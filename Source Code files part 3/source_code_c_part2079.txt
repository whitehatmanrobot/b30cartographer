AXIS_ANY_B_2                          0xFF044202 
#define DIAXIS_ANY_C_1                          0xFF04C201 
#define DIAXIS_ANY_C_2                          0xFF04C202 
#define DIAXIS_ANY_S_1                          0xFF054201 
#define DIAXIS_ANY_S_2                          0xFF054202 

#define DIAXIS_ANY_1                            0xFF004201 
#define DIAXIS_ANY_2                            0xFF004202 
#define DIAXIS_ANY_3                            0xFF004203 
#define DIAXIS_ANY_4                            0xFF004204 

#define DIPOV_ANY_1                             0xFF004601 
#define DIPOV_ANY_2                             0xFF004602 
#define DIPOV_ANY_3                             0xFF004603 
#define DIPOV_ANY_4                             0xFF004604 

#define DIBUTTON_ANY(instance)                  ( 0xFF004400 | instance )


#ifdef __cplusplus
};
#endif

#endif  /* __DINPUT_INCLUDED__ */

/****************************************************************************
 *
 *  Definitions for non-IDirectInput (VJoyD) features defined more recently
 *  than the current sdk files
 *
 ****************************************************************************/

#ifdef _INC_MMSYSTEM
#ifndef MMNOJOY

#ifndef __VJOYDX_INCLUDED__
#define __VJOYDX_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Flag to indicate that the dwReserved2 field of the JOYINFOEX structure
 * contains mini-driver specific data to be passed by VJoyD to the mini-
 * driver instead of doing a poll.
 */
#define JOY_PASSDRIVERDATA          0x10000000l

/*
 * Informs the joystick driver that the configuration has been changed
 * and should be reloaded from the registery.
 * dwFlags is reserved and should be set to zero
 */
WINMMAPI MMRESULT WINAPI joyConfigChanged( DWORD dwFlags );

#ifndef DIJ_RINGZERO
/*
 * Invoke the joystick control panel directly, using the passed window handle 
 * as the parent of the dialog.  This API is only supported for compatibility 
 * purposes; new applications should use the RunControlPanel method of a 
 * device interface for a game controller.
 * The API is called by using the function pointer returned by
 * GetProcAddress( hCPL, TEXT("ShowJoyCPL") ) where hCPL is a HMODULE returned 
 * by LoadLibrary( TEXT("joy.cpl") ).  The typedef is provided to allow 
 * declaration and casting of an appropriately typed variable.
 */
void WINAPI ShowJoyCPL( HWND hWnd );
typedef void (WINAPI* LPFNSHOWJOYCPL)( HWND hWnd );
#endif

/*
 * Hardware Setting indicating that the device is a headtracker
 */
#define JOY_HWS_ISHEADTRACKER       0x02000000l

/*
 * Hardware Setting indicating that the VxD is used to replace
 * the standard analog polling
 */
#define JOY_HWS_ISGAMEPORTDRIVER    0x04000000l

/*
 * Hardware Setting indicating that the driver needs a standard
 * gameport in order to communicate with the device.
 */
#define JOY_HWS_ISANALOGPORTDRIVER  0x08000000l

/*
 * Hardware Setting indicating that VJoyD should not load this
 * driver, it will be loaded externally and will register with
 * VJoyD of it's own accord.
 */
#define JOY_HWS_AUTOLOAD            0x10000000l

/*
 * Hardware Setting indicating that the driver acquires any
 * resources needed without needing a devnode through VJoyD.
 */
#define JOY_HWS_NODEVNODE           0x20000000l


/*
 * Hardware Setting indicating that the device is a gameport bus
 */
#define JOY_HWS_ISGAMEPORTBUS       0x80000000l
#define JOY_HWS_GAMEPORTBUSBUSY     0x00000001l

/*
 * Usage Setting indicating that the settings are volatile and
 * should be removed if still present on a reboot.
 */
#define JOY_US_VOLATILE             0x00000008L

#ifdef __cplusplus
};
#endif

#endif  /* __VJOYDX_INCLUDED__ */

#endif  /* not MMNOJOY */
#endif  /* _INC_MMSYSTEM */

/****************************************************************************
 *
 *  Definitions for non-IDirectInput (VJoyD) features defined more recently
 *  than the current ddk files
 *
 ****************************************************************************/

#ifndef DIJ_RINGZERO

#ifdef _INC_MMDDK
#ifndef MMNOJOYDEV

#ifndef __VJOYDXD_INCLUDED__
#define __VJOYDXD_INCLUDED__
/*
 * Poll type in which the do_other field of the JOYOEMPOLLDATA
 * structure contains mini-driver specific data passed from an app.
 */
#define JOY_OEMPOLL_PASSDRIVERDATA  7

#endif  /* __VJOYDXD_INCLUDED__ */

#endif  /* not MMNOJOYDEV */
#endif  /* _INC_MMDDK */

#endif /* DIJ_RINGZERO */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Dimm.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for dimm.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __dimm_h__
#define __dimm_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IEnumRegisterWordA_FWD_DEFINED__
#define __IEnumRegisterWordA_FWD_DEFINED__
typedef interface IEnumRegisterWordA IEnumRegisterWordA;
#endif 	/* __IEnumRegisterWordA_FWD_DEFINED__ */


#ifndef __IEnumRegisterWordW_FWD_DEFINED__
#define __IEnumRegisterWordW_FWD_DEFINED__
typedef interface IEnumRegisterWordW IEnumRegisterWordW;
#endif 	/* __IEnumRegisterWordW_FWD_DEFINED__ */


#ifndef __IEnumInputContext_FWD_DEFINED__
#define __IEnumInputContext_FWD_DEFINED__
typedef interface IEnumInputContext IEnumInputContext;
#endif 	/* __IEnumInputContext_FWD_DEFINED__ */


#ifndef __IActiveIMMRegistrar_FWD_DEFINED__
#define __IActiveIMMRegistrar_FWD_DEFINED__
typedef interface IActiveIMMRegistrar IActiveIMMRegistrar;
#endif 	/* __IActiveIMMRegistrar_FWD_DEFINED__ */


#ifndef __IActiveIMMMessagePumpOwner_FWD_DEFINED__
#define __IActiveIMMMessagePumpOwner_FWD_DEFINED__
typedef interface IActiveIMMMessagePumpOwner IActiveIMMMessagePumpOwner;
#endif 	/* __IActiveIMMMessagePumpOwner_FWD_DEFINED__ */


#ifndef __IActiveIMMApp_FWD_DEFINED__
#define __IActiveIMMApp_FWD_DEFINED__
typedef interface IActiveIMMApp IActiveIMMApp;
#endif 	/* __IActiveIMMApp_FWD_DEFINED__ */


#ifndef __IActiveIMMIME_FWD_DEFINED__
#define __IActiveIMMIME_FWD_DEFINED__
typedef interface IActiveIMMIME IActiveIMMIME;
#endif 	/* __IActiveIMMIME_FWD_DEFINED__ */


#ifndef __IActiveIME_FWD_DEFINED__
#define __IActiveIME_FWD_DEFINED__
typedef interface IActiveIME IActiveIME;
#endif 	/* __IActiveIME_FWD_DEFINED__ */


#ifndef __IActiveIME2_FWD_DEFINED__
#define __IActiveIME2_FWD_DEFINED__
typedef interface IActiveIME2 IActiveIME2;
#endif 	/* __IActiveIME2_FWD_DEFINED__ */


#ifndef __CActiveIMM_FWD_DEFINED__
#define __CActiveIMM_FWD_DEFINED__

#ifdef __cplusplus
typedef class CActiveIMM CActiveIMM;
#else
typedef struct CActiveIMM CActiveIMM;
#endif /* __cplusplus */

#endif 	/* __CActiveIMM_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_dimm_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// dimm.h
//=--------------------------------------------------------------------------=
// (C) Copyright Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// IActiveIMM Interfaces.




extern RPC_IF_HANDLE __MIDL_itf_dimm_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dimm_0000_0000_v0_0_s_ifspec;


#ifndef __ActiveIMM_LIBRARY_DEFINED__
#define __ActiveIMM_LIBRARY_DEFINED__

/* library ActiveIMM */
/* [version][lcid][helpstring][uuid] */ 

#include <imm.h>
#if 0
typedef WORD LANGID;

typedef /* [public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0000_0001
    {
    LPSTR lpReading;
    LPSTR lpWord;
    } 	REGISTERWORDA;

typedef /* [public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0000_0002
    {
    LPWSTR lpReading;
    LPWSTR lpWord;
    } 	REGISTERWORDW;

typedef /* [public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0000_0003
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    CHAR lfFaceName[ 32 ];
    } 	LOGFONTA;

typedef /* [public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0000_0004
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    WCHAR lfFaceName[ 32 ];
    } 	LOGFONTW;

typedef DWORD HIMC;

typedef DWORD HIMCC;

typedef /* [public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0000_0005
    {
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT rcArea;
    } 	CANDIDATEFORM;

typedef /* [public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0000_0006
    {
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT rcArea;
    } 	COMPOSITIONFORM;

typedef /* [public][public][public][public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0000_0007
    {
    DWORD dwSize;
    DWORD dwStyle;
    DWORD dwCount;
    DWORD dwSelection;
    DWORD dwPageStart;
    DWORD dwPageSize;
    DWORD dwOffset[ 1 ];
    } 	CANDIDATELIST;

typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0000_0008
    {
    DWORD dwStyle;
    CHAR szDescription[ 32 ];
    } 	STYLEBUFA;

typedef /* [public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0000_0009
    {
    DWORD dwStyle;
    WCHAR szDescription[ 32 ];
    } 	STYLEBUFW;

typedef WORD ATOM;

#endif
#if (WINVER < 0x040A)
typedef /* [public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0000_0010
    {
    UINT cbSize;
    UINT fType;
    UINT fState;
    UINT wID;
    HBITMAP hbmpChecked;
    HBITMAP hbmpUnchecked;
    DWORD dwItemData;
    CHAR szString[ 80 ];
    HBITMAP hbmpItem;
    } 	IMEMENUITEMINFOA;

typedef /* [public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0000_0011
    {
    UINT cbSize;
    UINT fType;
    UINT fState;
    UINT wID;
    HBITMAP hbmpChecked;
    HBITMAP hbmpUnchecked;
    DWORD dwItemData;
    WCHAR szString[ 80 ];
    HBITMAP hbmpItem;
    } 	IMEMENUITEMINFOW;

#endif
#ifndef _DDKIMM_H_
typedef /* [public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0000_0012
    {
    HWND hWnd;
    BOOL fOpen;
    POINT ptStatusWndPos;
    POINT ptSoftKbdPos;
    DWORD fdwConversion;
    DWORD fdwSentence;
    union 
        {
        LOGFONTA A;
        LOGFONTW W;
        } 	lfFont;
    COMPOSITIONFORM cfCompForm;
    CANDIDATEFORM cfCandForm[ 4 ];
    HIMCC hCompStr;
    HIMCC hCandInfo;
    HIMCC hGuideLine;
    HIMCC hPrivate;
    DWORD dwNumMsgBuf;
    HIMCC hMsgBuf;
    DWORD fdwInit;
    DWORD dwReserve[ 3 ];
    } 	INPUTCONTEXT;

typedef /* [public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0000_0014
    {
    DWORD dwPrivateDataSize;
    DWORD fdwProperty;
    DWORD fdwConversionCaps;
    DWORD fdwSentenceCaps;
    DWORD fdwUICaps;
    DWORD fdwSCSCaps;
    DWORD fdwSelectCaps;
    } 	IMEINFO;

#endif

EXTERN_C const IID LIBID_ActiveIMM;

#ifndef __IEnumRegisterWordA_INTERFACE_DEFINED__
#define __IEnumRegisterWordA_INTERFACE_DEFINED__

/* interface IEnumRegisterWordA */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumRegisterWordA;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08C03412-F96B-11d0-A475-00AA006BCC59")
    IEnumRegisterWordA : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumRegisterWordA **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [out] */ __RPC__out REGISTERWORDA *rgRegisterWord,
            /* [out] */ __RPC__out ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRegisterWordAVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumRegisterWordA * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumRegisterWordA * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumRegisterWordA * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumRegisterWordA * This,
            /* [out] */ __RPC__deref_out_opt IEnumRegisterWordA **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumRegisterWordA * This,
            /* [in] */ ULONG ulCount,
            /* [out] */ __RPC__out REGISTERWORDA *rgRegisterWord,
            /* [out] */ __RPC__out ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumRegisterWordA * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumRegisterWordA * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumRegisterWordAVtbl;

    interface IEnumRegisterWordA
    {
        CONST_VTBL struct IEnumRegisterWordAVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRegisterWordA_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumRegisterWordA_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumRegisterWordA_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumRegisterWordA_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#define IEnumRegisterWordA_Next(This,ulCount,rgRegisterWord,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,ulCount,rgRegisterWord,pcFetched) ) 

#define IEnumRegisterWordA_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumRegisterWordA_Skip(This,ulCount)	\
    ( (This)->lpVtbl -> Skip(This,ulCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumRegisterWordA_INTERFACE_DEFINED__ */


#ifndef __IEnumRegisterWordW_INTERFACE_DEFINED__
#define __IEnumRegisterWordW_INTERFACE_DEFINED__

/* interface IEnumRegisterWordW */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumRegisterWordW;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4955DD31-B159-11d0-8FCF-00AA006BCC59")
    IEnumRegisterWordW : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumRegisterWordW **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [out] */ __RPC__out REGISTERWORDW *rgRegisterWord,
            /* [out] */ __RPC__out ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRegisterWordWVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumRegisterWordW * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumRegisterWordW * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumRegisterWordW * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumRegisterWordW * This,
            /* [out] */ __RPC__deref_out_opt IEnumRegisterWordW **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumRegisterWordW * This,
            /* [in] */ ULONG ulCount,
            /* [out] */ __RPC__out REGISTERWORDW *rgRegisterWord,
            /* [out] */ __RPC__out ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumRegisterWordW * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumRegisterWordW * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumRegisterWordWVtbl;

    interface IEnumRegisterWordW
    {
        CONST_VTBL struct IEnumRegisterWordWVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRegisterWordW_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumRegisterWordW_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumRegisterWordW_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumRegisterWordW_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#define IEnumRegisterWordW_Next(This,ulCount,rgRegisterWord,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,ulCount,rgRegisterWord,pcFetched) ) 

#define IEnumRegisterWordW_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumRegisterWordW_Skip(This,ulCount)	\
    ( (This)->lpVtbl -> Skip(This,ulCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumRegisterWordW_INTERFACE_DEFINED__ */


#ifndef __IEnumInputContext_INTERFACE_DEFINED__
#define __IEnumInputContext_INTERFACE_DEFINED__

/* interface IEnumInputContext */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumInputContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("09b5eab0-f997-11d1-93d4-0060b067b86e")
    IEnumInputContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumInputContext **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [out] */ __RPC__out HIMC *rgInputContext,
            /* [out] */ __RPC__out ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumInputContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumInputContext * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumInputContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumInputContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumInputContext * This,
            /* [out] */ __RPC__deref_out_opt IEnumInputContext **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumInputContext * This,
            /* [in] */ ULONG ulCount,
            /* [out] */ __RPC__out HIMC *rgInputContext,
            /* [out] */ __RPC__out ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumInputContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumInputContext * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumInputContextVtbl;

    interface IEnumInputContext
    {
        CONST_VTBL struct IEnumInputContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumInputContext_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumInputContext_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumInputContext_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumInputContext_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#define IEnumInputContext_Next(This,ulCount,rgInputContext,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,ulCount,rgInputContext,pcFetched) ) 

#define IEnumInputContext_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumInputContext_Skip(This,ulCount)	\
    ( (This)->lpVtbl -> Skip(This,ulCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumInputContext_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMRegistrar_INTERFACE_DEFINED__
#define __IActiveIMMRegistrar_INTERFACE_DEFINED__

/* interface IActiveIMMRegistrar */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIMMRegistrar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b3458082-bd00-11d1-939b-0060b067b86e")
    IActiveIMMRegistrar : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterIME( 
            /* [in] */ __RPC__in REFCLSID rclsid,
            /* [in] */ LANGID lgid,
            /* [in] */ __RPC__in LPCWSTR pszIconFile,
            /* [in] */ __RPC__in LPCWSTR pszDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterIME( 
            /* [in] */ __RPC__in REFCLSID rclsid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMRegistrarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IActiveIMMRegistrar * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IActiveIMMRegistrar * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IActiveIMMRegistrar * This);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterIME )( 
            __RPC__in IActiveIMMRegistrar * This,
            /* [in] */ __RPC__in REFCLSID rclsid,
            /* [in] */ LANGID lgid,
            /* [in] */ __RPC__in LPCWSTR pszIconFile,
            /* [in] */ __RPC__in LPCWSTR pszDesc);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterIME )( 
            __RPC__in IActiveIMMRegistrar * This,
            /* [in] */ __RPC__in REFCLSID rclsid);
        
        END_INTERFACE
    } IActiveIMMRegistrarVtbl;

    interface IActiveIMMRegistrar
    {
        CONST_VTBL struct IActiveIMMRegistrarVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMRegistrar_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveIMMRegistrar_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveIMMRegistrar_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveIMMRegistrar_RegisterIME(This,rclsid,lgid,pszIconFile,pszDesc)	\
    ( (This)->lpVtbl -> RegisterIME(This,rclsid,lgid,pszIconFile,pszDesc) ) 

#define IActiveIMMRegistrar_UnregisterIME(This,rclsid)	\
    ( (This)->lpVtbl -> UnregisterIME(This,rclsid) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveIMMRegistrar_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMMessagePumpOwner_INTERFACE_DEFINED__
#define __IActiveIMMMessagePumpOwner_INTERFACE_DEFINED__

/* interface IActiveIMMMessagePumpOwner */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIMMMessagePumpOwner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b5cf2cfa-8aeb-11d1-9364-0060b067b86e")
    IActiveIMMMessagePumpOwner : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE End( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTranslateMessage( 
            /* [in] */ __RPC__in const MSG *pMsg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( 
            /* [out] */ __RPC__out DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( 
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMMessagePumpOwnerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IActiveIMMMessagePumpOwner * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IActiveIMMMessagePumpOwner * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IActiveIMMMessagePumpOwner * This);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            __RPC__in IActiveIMMMessagePumpOwner * This);
        
        HRESULT ( STDMETHODCALLTYPE *End )( 
            __RPC__in IActiveIMMMessagePumpOwner * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnTranslateMessage )( 
            __RPC__in IActiveIMMMessagePumpOwner * This,
            /* [in] */ __RPC__in const MSG *pMsg);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            __RPC__in IActiveIMMMessagePumpOwner * This,
            /* [out] */ __RPC__out DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            __RPC__in IActiveIMMMessagePumpOwner * This,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } IActiveIMMMessagePumpOwnerVtbl;

    interface IActiveIMMMessagePumpOwner
    {
        CONST_VTBL struct IActiveIMMMessagePumpOwnerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMMessagePumpOwner_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveIMMMessagePumpOwner_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveIMMMessagePumpOwner_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveIMMMessagePumpOwner_Start(This)	\
    ( (This)->lpVtbl -> Start(This) ) 

#define IActiveIMMMessagePumpOwner_End(This)	\
    ( (This)->lpVtbl -> End(This) ) 

#define IActiveIMMMessagePumpOwner_OnTranslateMessage(This,pMsg)	\
    ( (This)->lpVtbl -> OnTranslateMessage(This,pMsg) ) 

#define IActiveIMMMessagePumpOwner_Pause(This,pdwCookie)	\
    ( (This)->lpVtbl -> Pause(This,pdwCookie) ) 

#define IActiveIMMMessagePumpOwner_Resume(This,dwCookie)	\
    ( (This)->lpVtbl -> Resume(This,dwCookie) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveIMMMessagePumpOwner_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMApp_INTERFACE_DEFINED__
#define __IActiveIMMApp_INTERFACE_DEFINED__

/* interface IActiveIMMApp */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIMMApp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08c0e040-62d1-11d1-9326-0060b067b86e")
    IActiveIMMApp : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AssociateContext( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ __RPC__out HIMC *phPrev) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ __RPC__in REGISTERWORDA *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ __RPC__in REGISTERWORDW *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateContext( 
            /* [out] */ __RPC__out HIMC *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyContext( 
            /* [in] */ HIMC hIME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPSTR szRegister,
            /* [in] */ __RPC__in LPVOID pData,
            /* [out] */ __RPC__deref_out_opt IEnumRegisterWordA **pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szRegister,
            /* [in] */ __RPC__in LPVOID pData,
            /* [out] */ __RPC__deref_out_opt IEnumRegisterWordW **pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ __RPC__inout LPVOID pData,
            /* [out] */ __RPC__out LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ __RPC__inout LPVOID pData,
            /* [out] */ __RPC__out LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out CANDIDATELIST *pCandList,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out CANDIDATELIST *pCandList,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pdwListSize,
            /* [out] */ __RPC__out DWORD *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pdwListSize,
            /* [out] */ __RPC__out DWORD *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ __RPC__out CANDIDATEFORM *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out LOGFONTA *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out LOGFONTW *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LONG *plCopied,
            /* [out] */ __RPC__out LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LONG *plCopied,
            /* [out] */ __RPC__out LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out COMPOSITIONFORM *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [out] */ __RPC__out HIMC *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ __RPC__out CANDIDATELIST *pDst,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ __RPC__out CANDIDATELIST *pDst,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pfdwConversion,
            /* [out] */ __RPC__out DWORD *pfdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultIMEWnd( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [out] */ __RPC__deref_out_opt HWND *phDefWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPSTR szDescription,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPWSTR szDescription,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LPSTR pBuf,
            /* [out] */ __RPC__out DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LPWSTR pBuf,
            /* [out] */ __RPC__out DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPSTR szFileName,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPWSTR szFileName,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOpenStatus( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ __RPC__out DWORD *pdwProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ __RPC__out STYLEBUFA *pStyleBuf,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ __RPC__out STYLEBUFW *pStyleBuf,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out POINT *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVirtualKey( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [out] */ __RPC__out UINT *puVirtualKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEA( 
            /* [in] */ __RPC__in LPSTR szIMEFileName,
            /* [in] */ __RPC__in LPSTR szLayoutText,
            /* [out] */ __RPC__deref_out_opt HKL *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEW( 
            /* [in] */ __RPC__in LPWSTR szIMEFileName,
            /* [in] */ __RPC__in LPWSTR szLayoutText,
            /* [out] */ __RPC__deref_out_opt HKL *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsIME( 
            /* [in] */ __RPC__in HKL hKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageA( 
            /* [in] */ __RPC__in HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageW( 
            /* [in] */ __RPC__in HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyIME( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseContext( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in CANDIDATEFORM *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LOGFONTA *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LOGFONTW *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ __RPC__in LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ __RPC__in LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ __RPC__in LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ __RPC__in LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in COMPOSITIONFORM *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpenStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in POINT *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SimulateHotKey( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ DWORD dwHotKeyID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ BOOL fRestoreLayout) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDefWindowProc( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ UINT Msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ __RPC__out LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FilterClientWindows( 
            /* [in] */ __RPC__in ATOM *aaClassList,
            /* [in] */ UINT uSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodePageA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [out] */ __RPC__out UINT *uCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLangId( 
            /* [in] */ __RPC__in HKL hKL,
            /* [out] */ __RPC__out LANGID *plid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AssociateContextEx( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableIME( 
            /* [in] */ DWORD idThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImeMenuItemsA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ __RPC__in IMEMENUITEMINFOA *pImeParentMenu,
            /* [out] */ __RPC__out IMEMENUITEMINFOA *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ __RPC__out DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImeMenuItemsW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ __RPC__in IMEMENUITEMINFOW *pImeParentMenu,
            /* [out] */ __RPC__out IMEMENUITEMINFOW *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ __RPC__out DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumInputContext( 
            /* [in] */ DWORD idThread,
            /* [out] */ __RPC__deref_out_opt IEnumInputContext **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMAppVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IActiveIMMApp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IActiveIMMApp * This);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContext )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ __RPC__out HIMC *phPrev);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEA )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ __RPC__in REGISTERWORDA *pData);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEW )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ __RPC__in REGISTERWORDW *pData);
        
        HRESULT ( STDMETHODCALLTYPE *CreateContext )( 
            __RPC__in IActiveIMMApp * This,
            /* [out] */ __RPC__out HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyContext )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ HIMC hIME);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordA )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPSTR szRegister,
            /* [in] */ __RPC__in LPVOID pData,
            /* [out] */ __RPC__deref_out_opt IEnumRegisterWordA **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordW )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szRegister,
            /* [in] */ __RPC__in LPVOID pData,
            /* [out] */ __RPC__deref_out_opt IEnumRegisterWordW **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeA )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ __RPC__inout LPVOID pData,
            /* [out] */ __RPC__out LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeW )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ __RPC__inout LPVOID pData,
            /* [out] */ __RPC__out LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListA )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out CANDIDATELIST *pCandList,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListW )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out CANDIDATELIST *pCandList,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountA )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pdwListSize,
            /* [out] */ __RPC__out DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountW )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pdwListSize,
            /* [out] */ __RPC__out DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateWindow )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ __RPC__out CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontA )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontW )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringA )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LONG *plCopied,
            /* [out] */ __RPC__out LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringW )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LONG *plCopied,
            /* [out] */ __RPC__out LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionWindow )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [out] */ __RPC__out HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListA )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ __RPC__out CANDIDATELIST *pDst,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListW )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ __RPC__out CANDIDATELIST *pDst,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionStatus )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pfdwConversion,
            /* [out] */ __RPC__out DWORD *pfdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultIMEWnd )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [out] */ __RPC__deref_out_opt HWND *phDefWnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionA )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPSTR szDescription,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionW )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPWSTR szDescription,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineA )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LPSTR pBuf,
            /* [out] */ __RPC__out DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineW )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LPWSTR pBuf,
            /* [out] */ __RPC__out DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameA )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPSTR szFileName,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameW )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPWSTR szFileName,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpenStatus )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ __RPC__out DWORD *pdwProperty);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleA )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ __RPC__out STYLEBUFA *pStyleBuf,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleW )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ __RPC__out STYLEBUFW *pStyleBuf,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatusWindowPos )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *GetVirtualKey )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [out] */ __RPC__out UINT *puVirtualKey);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEA )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in LPSTR szIMEFileName,
            /* [in] */ __RPC__in LPSTR szLayoutText,
            /* [out] */ __RPC__deref_out_opt HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEW )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in LPWSTR szIMEFileName,
            /* [in] */ __RPC__in LPWSTR szLayoutText,
            /* [out] */ __RPC__deref_out_opt HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsIME )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageA )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageW )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyIME )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordA )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordW )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseContext )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *SetCandidateWindow )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontA )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontW )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringA )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ __RPC__in LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ __RPC__in LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringW )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ __RPC__in LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ __RPC__in LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionWindow )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *SetConversionStatus )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpenStatus )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatusWindowPos )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *SimulateHotKey )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ DWORD dwHotKeyID);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordA )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordW )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ BOOL fRestoreLayout);
        
        HRESULT ( STDMETHODCALLTYPE *Deactivate )( 
            __RPC__in IActiveIMMApp * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnDefWindowProc )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ UINT Msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ __RPC__out LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *FilterClientWindows )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in ATOM *aaClassList,
            /* [in] */ UINT uSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodePageA )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [out] */ __RPC__out UINT *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLangId )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [out] */ __RPC__out LANGID *plid);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContextEx )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *DisableIME )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ DWORD idThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsA )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ __RPC__in IMEMENUITEMINFOA *pImeParentMenu,
            /* [out] */ __RPC__out IMEMENUITEMINFOA *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ __RPC__out DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsW )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ __RPC__in IMEMENUITEMINFOW *pImeParentMenu,
            /* [out] */ __RPC__out IMEMENUITEMINFOW *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ __RPC__out DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *EnumInputContext )( 
            __RPC__in IActiveIMMApp * This,
            /* [in] */ DWORD idThread,
            /* [out] */ __RPC__deref_out_opt IEnumInputContext **ppEnum);
        
        END_INTERFACE
    } IActiveIMMAppVtbl;

    interface IActiveIMMApp
    {
        CONST_VTBL struct IActiveIMMAppVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMApp_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveIMMApp_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveIMMApp_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveIMMApp_AssociateContext(This,hWnd,hIME,phPrev)	\
    ( (This)->lpVtbl -> AssociateContext(This,hWnd,hIME,phPrev) ) 

#define IActiveIMMApp_ConfigureIMEA(This,hKL,hWnd,dwMode,pData)	\
    ( (This)->lpVtbl -> ConfigureIMEA(This,hKL,hWnd,dwMode,pData) ) 

#define IActiveIMMApp_ConfigureIMEW(This,hKL,hWnd,dwMode,pData)	\
    ( (This)->lpVtbl -> ConfigureIMEW(This,hKL,hWnd,dwMode,pData) ) 

#define IActiveIMMApp_CreateContext(This,phIMC)	\
    ( (This)->lpVtbl -> CreateContext(This,phIMC) ) 

#define IActiveIMMApp_DestroyContext(This,hIME)	\
    ( (This)->lpVtbl -> DestroyContext(This,hIME) ) 

#define IActiveIMMApp_EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    ( (This)->lpVtbl -> EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum) ) 

#define IActiveIMMApp_EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    ( (This)->lpVtbl -> EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum) ) 

#define IActiveIMMApp_EscapeA(This,hKL,hIMC,uEscape,pData,plResult)	\
    ( (This)->lpVtbl -> EscapeA(This,hKL,hIMC,uEscape,pData,plResult) ) 

#define IActiveIMMApp_EscapeW(This,hKL,hIMC,uEscape,pData,plResult)	\
    ( (This)->lpVtbl -> EscapeW(This,hKL,hIMC,uEscape,pData,plResult) ) 

#define IActiveIMMApp_GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    ( (This)->lpVtbl -> GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied) ) 

#define IActiveIMMApp_GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    ( (This)->lpVtbl -> GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied) ) 

#define IActiveIMMApp_GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)	\
    ( (This)->lpVtbl -> GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen) ) 

#define IActiveIMMApp_GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)	\
    ( (This)->lpVtbl -> GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen) ) 

#define IActiveIMMApp_GetCandidateWindow(This,hIMC,dwIndex,pCandidate)	\
    ( (This)->lpVtbl -> GetCandidateWindow(This,hIMC,dwIndex,pCandidate) ) 

#define IActiveIMMApp_GetCompositionFontA(This,hIMC,plf)	\
    ( (This)->lpVtbl -> GetCompositionFontA(This,hIMC,plf) ) 

#define IActiveIMMApp_GetCompositionFontW(This,hIMC,plf)	\
    ( (This)->lpVtbl -> GetCompositionFontW(This,hIMC,plf) ) 

#define IActiveIMMApp_GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    ( (This)->lpVtbl -> GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf) ) 

#define IActiveIMMApp_GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    ( (This)->lpVtbl -> GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf) ) 

#define IActiveIMMApp_GetCompositionWindow(This,hIMC,pCompForm)	\
    ( (This)->lpVtbl -> GetCompositionWindow(This,hIMC,pCompForm) ) 

#define IActiveIMMApp_GetContext(This,hWnd,phIMC)	\
    ( (This)->lpVtbl -> GetContext(This,hWnd,phIMC) ) 

#define IActiveIMMApp_GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    ( (This)->lpVtbl -> GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied) ) 

#define IActiveIMMApp_GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    ( (This)->lpVtbl -> GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied) ) 

#define IActiveIMMApp_GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)	\
    ( (This)->lpVtbl -> GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence) ) 

#define IActiveIMMApp_GetDefaultIMEWnd(This,hWnd,phDefWnd)	\
    ( (This)->lpVtbl -> GetDefaultIMEWnd(This,hWnd,phDefWnd) ) 

#define IActiveIMMApp_GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)	\
    ( (This)->lpVtbl -> GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied) ) 

#define IActiveIMMApp_GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)	\
    ( (This)->lpVtbl -> GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied) ) 

#define IActiveIMMApp_GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    ( (This)->lpVtbl -> GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult) ) 

#define IActiveIMMApp_GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    ( (This)->lpVtbl -> GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult) ) 

#define IActiveIMMApp_GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)	\
    ( (This)->lpVtbl -> GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied) ) 

#define IActiveIMMApp_GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)	\
    ( (This)->lpVtbl -> GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied) ) 

#define IActiveIMMApp_GetOpenStatus(This,hIMC)	\
    ( (This)->lpVtbl -> GetOpenStatus(This,hIMC) ) 

#define IActiveIMMApp_GetProperty(This,hKL,fdwIndex,pdwProperty)	\
    ( (This)->lpVtbl -> GetProperty(This,hKL,fdwIndex,pdwProperty) ) 

#define IActiveIMMApp_GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)	\
    ( (This)->lpVtbl -> GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied) ) 

#define IActiveIMMApp_GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)	\
    ( (This)->lpVtbl -> GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied) ) 

#define IActiveIMMApp_GetStatusWindowPos(This,hIMC,pptPos)	\
    ( (This)->lpVtbl -> GetStatusWindowPos(This,hIMC,pptPos) ) 

#define IActiveIMMApp_GetVirtualKey(This,hWnd,puVirtualKey)	\
    ( (This)->lpVtbl -> GetVirtualKey(This,hWnd,puVirtualKey) ) 

#define IActiveIMMApp_InstallIMEA(This,szIMEFileName,szLayoutText,phKL)	\
    ( (This)->lpVtbl -> InstallIMEA(This,szIMEFileName,szLayoutText,phKL) ) 

#define IActiveIMMApp_InstallIMEW(This,szIMEFileName,szLayoutText,phKL)	\
    ( (This)->lpVtbl -> InstallIMEW(This,szIMEFileName,szLayoutText,phKL) ) 

#define IActiveIMMApp_IsIME(This,hKL)	\
    ( (This)->lpVtbl -> IsIME(This,hKL) ) 

#define IActiveIMMApp_IsUIMessageA(This,hWndIME,msg,wParam,lParam)	\
    ( (This)->lpVtbl -> IsUIMessageA(This,hWndIME,msg,wParam,lParam) ) 

#define IActiveIMMApp_IsUIMessageW(This,hWndIME,msg,wParam,lParam)	\
    ( (This)->lpVtbl -> IsUIMessageW(This,hWndIME,msg,wParam,lParam) ) 

#define IActiveIMMApp_NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)	\
    ( (This)->lpVtbl -> NotifyIME(This,hIMC,dwAction,dwIndex,dwValue) ) 

#define IActiveIMMApp_RegisterWordA(This,hKL,szReading,dwStyle,szRegister)	\
    ( (This)->lpVtbl -> RegisterWordA(This,hKL,szReading,dwStyle,szRegister) ) 

#define IActiveIMMApp_RegisterWordW(This,hKL,szReading,dwStyle,szRegister)	\
    ( (This)->lpVtbl -> RegisterWordW(This,hKL,szReading,dwStyle,szRegister) ) 

#define IActiveIMMApp_ReleaseContext(This,hWnd,hIMC)	\
    ( (This)->lpVtbl -> ReleaseContext(This,hWnd,hIMC) ) 

#define IActiveIMMApp_SetCandidateWindow(This,hIMC,pCandidate)	\
    ( (This)->lpVtbl -> SetCandidateWindow(This,hIMC,pCandidate) ) 

#define IActiveIMMApp_SetCompositionFontA(This,hIMC,plf)	\
    ( (This)->lpVtbl -> SetCompositionFontA(This,hIMC,plf) ) 

#define IActiveIMMApp_SetCompositionFontW(This,hIMC,plf)	\
    ( (This)->lpVtbl -> SetCompositionFontW(This,hIMC,plf) ) 

#define IActiveIMMApp_SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    ( (This)->lpVtbl -> SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen) ) 

#define IActiveIMMApp_SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    ( (This)->lpVtbl -> SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen) ) 

#define IActiveIMMApp_SetCompositionWindow(This,hIMC,pCompForm)	\
    ( (This)->lpVtbl -> SetCompositionWindow(This,hIMC,pCompForm) ) 

#define IActiveIMMApp_SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)	\
    ( (This)->lpVtbl -> SetConversionStatus(This,hIMC,fdwConversion,fdwSentence) ) 

#define IActiveIMMApp_SetOpenStatus(This,hIMC,fOpen)	\
    ( (This)->lpVtbl -> SetOpenStatus(This,hIMC,fOpen) ) 

#define IActiveIMMApp_SetStatusWindowPos(This,hIMC,pptPos)	\
    ( (This)->lpVtbl -> SetStatusWindowPos(This,hIMC,pptPos) ) 

#define IActiveIMMApp_SimulateHotKey(This,hWnd,dwHotKeyID)	\
    ( (This)->lpVtbl -> SimulateHotKey(This,hWnd,dwHotKeyID) ) 

#define IActiveIMMApp_UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)	\
    ( (This)->lpVtbl -> UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister) ) 

#define IActiveIMMApp_UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)	\
    ( (This)->lpVtbl -> UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister) ) 

#define IActiveIMMApp_Activate(This,fRestoreLayout)	\
    ( (This)->lpVtbl -> Activate(This,fRestoreLayout) ) 

#define IActiveIMMApp_Deactivate(This)	\
    ( (This)->lpVtbl -> Deactivate(This) ) 

#define IActiveIMMApp_OnDefWindowProc(This,hWnd,Msg,wParam,lParam,plResult)	\
    ( (This)->lpVtbl -> OnDefWindowProc(This,hWnd,Msg,wParam,lParam,plResult) ) 

#define IActiveIMMApp_FilterClientWindows(This,aaClassList,uSize)	\
    ( (This)->lpVtbl -> FilterClientWindows(This,aaClassList,uSize) ) 

#define IActiveIMMApp_GetCodePageA(This,hKL,uCodePage)	\
    ( (This)->lpVtbl -> GetCodePageA(This,hKL,uCodePage) ) 

#define IActiveIMMApp_GetLangId(This,hKL,plid)	\
    ( (This)->lpVtbl -> GetLangId(This,hKL,plid) ) 

#define IActiveIMMApp_AssociateContextEx(This,hWnd,hIMC,dwFlags)	\
    ( (This)->lpVtbl -> AssociateContextEx(This,hWnd,hIMC,dwFlags) ) 

#define IActiveIMMApp_DisableIME(This,idThread)	\
    ( (This)->lpVtbl -> DisableIME(This,idThread) ) 

#define IActiveIMMApp_GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    ( (This)->lpVtbl -> GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult) ) 

#define IActiveIMMApp_GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    ( (This)->lpVtbl -> GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult) ) 

#define IActiveIMMApp_EnumInputContext(This,idThread,ppEnum)	\
    ( (This)->lpVtbl -> EnumInputContext(This,idThread,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveIMMApp_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMIME_INTERFACE_DEFINED__
#define __IActiveIMMIME_INTERFACE_DEFINED__

/* interface IActiveIMMIME */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIMMIME;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08C03411-F96B-11d0-A475-00AA006BCC59")
    IActiveIMMIME : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AssociateContext( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ __RPC__out HIMC *phPrev) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ __RPC__in REGISTERWORDA *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ __RPC__in REGISTERWORDW *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateContext( 
            /* [out] */ __RPC__out HIMC *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyContext( 
            /* [in] */ HIMC hIME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPSTR szRegister,
            /* [in] */ __RPC__in LPVOID pData,
            /* [out] */ __RPC__deref_out_opt IEnumRegisterWordA **pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szRegister,
            /* [in] */ __RPC__in LPVOID pData,
            /* [out] */ __RPC__deref_out_opt IEnumRegisterWordW **pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ __RPC__inout LPVOID pData,
            /* [out] */ __RPC__out LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ __RPC__inout LPVOID pData,
            /* [out] */ __RPC__out LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out CANDIDATELIST *pCandList,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out CANDIDATELIST *pCandList,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pdwListSize,
            /* [out] */ __RPC__out DWORD *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pdwListSize,
            /* [out] */ __RPC__out DWORD *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ __RPC__out CANDIDATEFORM *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out LOGFONTA *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out LOGFONTW *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LONG *plCopied,
            /* [out] */ __RPC__out LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LONG *plCopied,
            /* [out] */ __RPC__out LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out COMPOSITIONFORM *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [out] */ __RPC__out HIMC *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ __RPC__out CANDIDATELIST *pDst,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ __RPC__out CANDIDATELIST *pDst,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pfdwConversion,
            /* [out] */ __RPC__out DWORD *pfdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultIMEWnd( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [out] */ __RPC__deref_out_opt HWND *phDefWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPSTR szDescription,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPWSTR szDescription,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LPSTR pBuf,
            /* [out] */ __RPC__out DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LPWSTR pBuf,
            /* [out] */ __RPC__out DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPSTR szFileName,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPWSTR szFileName,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOpenStatus( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ __RPC__out DWORD *pdwProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ __RPC__out STYLEBUFA *pStyleBuf,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ __RPC__out STYLEBUFW *pStyleBuf,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out POINT *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVirtualKey( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [out] */ __RPC__out UINT *puVirtualKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEA( 
            /* [in] */ __RPC__in LPSTR szIMEFileName,
            /* [in] */ __RPC__in LPSTR szLayoutText,
            /* [out] */ __RPC__deref_out_opt HKL *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEW( 
            /* [in] */ __RPC__in LPWSTR szIMEFileName,
            /* [in] */ __RPC__in LPWSTR szLayoutText,
            /* [out] */ __RPC__deref_out_opt HKL *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsIME( 
            /* [in] */ __RPC__in HKL hKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageA( 
            /* [in] */ __RPC__in HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageW( 
            /* [in] */ __RPC__in HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyIME( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseContext( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in CANDIDATEFORM *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LOGFONTA *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LOGFONTW *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ __RPC__in LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ __RPC__in LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ __RPC__in LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ __RPC__in LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in COMPOSITIONFORM *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpenStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in POINT *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SimulateHotKey( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ DWORD dwHotKeyID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordW( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateMessage( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockIMC( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__deref_out_opt INPUTCONTEXT **ppIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockIMC( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMCLockCount( 
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pdwLockCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateIMCC( 
            /* [in] */ DWORD dwSize,
            /* [out] */ __RPC__out HIMCC *phIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyIMCC( 
            /* [in] */ HIMCC hIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockIMCC( 
            /* [in] */ HIMCC hIMCC,
            /* [out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockIMCC( 
            /* [in] */ HIMCC hIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReSizeIMCC( 
            /* [in] */ HIMCC hIMCC,
            /* [in] */ DWORD dwSize,
            /* [out] */ __RPC__out HIMCC *phIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMCCSize( 
            /* [in] */ HIMCC hIMCC,
            /* [out] */ __RPC__out DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMCCLockCount( 
            /* [in] */ HIMCC hIMCC,
            /* [out] */ __RPC__out DWORD *pdwLockCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHotKey( 
            /* [in] */ DWORD dwHotKeyID,
            /* [out] */ __RPC__out UINT *puModifiers,
            /* [out] */ __RPC__out UINT *puVKey,
            /* [out] */ __RPC__deref_out_opt HKL *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHotKey( 
            /* [in] */ DWORD dwHotKeyID,
            /* [in] */ UINT uModifiers,
            /* [in] */ UINT uVKey,
            /* [in] */ __RPC__in HKL hKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSoftKeyboard( 
            /* [in] */ UINT uType,
            /* [in] */ __RPC__in HWND hOwner,
            /* [in] */ int x,
            /* [in] */ int y,
            /* [out] */ __RPC__deref_out_opt HWND *phSoftKbdWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroySoftKeyboard( 
            /* [in] */ __RPC__in HWND hSoftKbdWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowSoftKeyboard( 
            /* [in] */ __RPC__in HWND hSoftKbdWnd,
            /* [in] */ int nCmdShow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodePageA( 
            /* [in] */ __RPC__in HKL hKL,
            /* [out] */ __RPC__out UINT *uCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLangId( 
            /* [in] */ __RPC__in HKL hKL,
            /* [out] */ __RPC__out LANGID *plid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KeybdEvent( 
            /* [in] */ LANGID lgidIME,
            /* [in] */ BYTE bVk,
            /* [in] */ BYTE bScan,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwExtraInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockModal( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockModal( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AssociateContextEx( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableIME( 
            /* [in] */ DWORD idThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImeMenuItemsA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ __RPC__in IMEMENUITEMINFOA *pImeParentMenu,
            /* [out] */ __RPC__out IMEMENUITEMINFOA *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ __RPC__out DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImeMenuItemsW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ __RPC__in IMEMENUITEMINFOW *pImeParentMenu,
            /* [out] */ __RPC__out IMEMENUITEMINFOW *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ __RPC__out DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumInputContext( 
            /* [in] */ DWORD idThread,
            /* [out] */ __RPC__deref_out_opt IEnumInputContext **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestMessageA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ __RPC__out LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestMessageW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ __RPC__out LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendIMCA( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ __RPC__out LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendIMCW( 
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ __RPC__out LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSleeping( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMIMEVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IActiveIMMIME * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IActiveIMMIME * This);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContext )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ __RPC__out HIMC *phPrev);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEA )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ __RPC__in REGISTERWORDA *pData);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEW )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ __RPC__in REGISTERWORDW *pData);
        
        HRESULT ( STDMETHODCALLTYPE *CreateContext )( 
            __RPC__in IActiveIMMIME * This,
            /* [out] */ __RPC__out HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyContext )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIME);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordA )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPSTR szRegister,
            /* [in] */ __RPC__in LPVOID pData,
            /* [out] */ __RPC__deref_out_opt IEnumRegisterWordA **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordW )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szRegister,
            /* [in] */ __RPC__in LPVOID pData,
            /* [out] */ __RPC__deref_out_opt IEnumRegisterWordW **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeA )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ __RPC__inout LPVOID pData,
            /* [out] */ __RPC__out LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeW )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ __RPC__inout LPVOID pData,
            /* [out] */ __RPC__out LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListA )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out CANDIDATELIST *pCandList,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListW )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out CANDIDATELIST *pCandList,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountA )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pdwListSize,
            /* [out] */ __RPC__out DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountW )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pdwListSize,
            /* [out] */ __RPC__out DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateWindow )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ __RPC__out CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontA )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontW )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringA )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LONG *plCopied,
            /* [out] */ __RPC__out LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringW )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LONG *plCopied,
            /* [out] */ __RPC__out LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionWindow )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [out] */ __RPC__out HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListA )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ __RPC__out CANDIDATELIST *pDst,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListW )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ __RPC__out CANDIDATELIST *pDst,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionStatus )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pfdwConversion,
            /* [out] */ __RPC__out DWORD *pfdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultIMEWnd )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [out] */ __RPC__deref_out_opt HWND *phDefWnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionA )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPSTR szDescription,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionW )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPWSTR szDescription,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineA )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LPSTR pBuf,
            /* [out] */ __RPC__out DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineW )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ __RPC__out LPWSTR pBuf,
            /* [out] */ __RPC__out DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameA )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPSTR szFileName,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameW )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out LPWSTR szFileName,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpenStatus )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ __RPC__out DWORD *pdwProperty);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleA )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ __RPC__out STYLEBUFA *pStyleBuf,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleW )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ __RPC__out STYLEBUFW *pStyleBuf,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatusWindowPos )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *GetVirtualKey )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [out] */ __RPC__out UINT *puVirtualKey);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEA )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in LPSTR szIMEFileName,
            /* [in] */ __RPC__in LPSTR szLayoutText,
            /* [out] */ __RPC__deref_out_opt HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEW )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in LPWSTR szIMEFileName,
            /* [in] */ __RPC__in LPWSTR szLayoutText,
            /* [out] */ __RPC__deref_out_opt HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsIME )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageA )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageW )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyIME )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordA )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordW )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseContext )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *SetCandidateWindow )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontA )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontW )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringA )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ __RPC__in LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ __RPC__in LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringW )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ __RPC__in LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ __RPC__in LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionWindow )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *SetConversionStatus )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpenStatus )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatusWindowPos )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *SimulateHotKey )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ DWORD dwHotKeyID);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordA )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordW )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateMessage )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *LockIMC )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__deref_out_opt INPUTCONTEXT **ppIMC);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockIMC )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMCLockCount )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pdwLockCount);
        
        HRESULT ( STDMETHODCALLTYPE *CreateIMCC )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ DWORD dwSize,
            /* [out] */ __RPC__out HIMCC *phIMCC);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyIMCC )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMCC hIMCC);
        
        HRESULT ( STDMETHODCALLTYPE *LockIMCC )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMCC hIMCC,
            /* [out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockIMCC )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMCC hIMCC);
        
        HRESULT ( STDMETHODCALLTYPE *ReSizeIMCC )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMCC hIMCC,
            /* [in] */ DWORD dwSize,
            /* [out] */ __RPC__out HIMCC *phIMCC);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMCCSize )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMCC hIMCC,
            /* [out] */ __RPC__out DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMCCLockCount )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMCC hIMCC,
            /* [out] */ __RPC__out DWORD *pdwLockCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetHotKey )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ DWORD dwHotKeyID,
            /* [out] */ __RPC__out UINT *puModifiers,
            /* [out] */ __RPC__out UINT *puVKey,
            /* [out] */ __RPC__deref_out_opt HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *SetHotKey )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ DWORD dwHotKeyID,
            /* [in] */ UINT uModifiers,
            /* [in] */ UINT uVKey,
            /* [in] */ __RPC__in HKL hKL);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSoftKeyboard )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ UINT uType,
            /* [in] */ __RPC__in HWND hOwner,
            /* [in] */ int x,
            /* [in] */ int y,
            /* [out] */ __RPC__deref_out_opt HWND *phSoftKbdWnd);
        
        HRESULT ( STDMETHODCALLTYPE *DestroySoftKeyboard )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HWND hSoftKbdWnd);
        
        HRESULT ( STDMETHODCALLTYPE *ShowSoftKeyboard )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HWND hSoftKbdWnd,
            /* [in] */ int nCmdShow);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodePageA )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [out] */ __RPC__out UINT *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLangId )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [out] */ __RPC__out LANGID *plid);
        
        HRESULT ( STDMETHODCALLTYPE *KeybdEvent )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ LANGID lgidIME,
            /* [in] */ BYTE bVk,
            /* [in] */ BYTE bScan,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwExtraInfo);
        
        HRESULT ( STDMETHODCALLTYPE *LockModal )( 
            __RPC__in IActiveIMMIME * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockModal )( 
            __RPC__in IActiveIMMIME * This);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContextEx )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *DisableIME )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ DWORD idThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsA )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ __RPC__in IMEMENUITEMINFOA *pImeParentMenu,
            /* [out] */ __RPC__out IMEMENUITEMINFOA *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ __RPC__out DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsW )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ __RPC__in IMEMENUITEMINFOW *pImeParentMenu,
            /* [out] */ __RPC__out IMEMENUITEMINFOW *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ __RPC__out DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *EnumInputContext )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ DWORD idThread,
            /* [out] */ __RPC__deref_out_opt IEnumInputContext **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *RequestMessageA )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ __RPC__out LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *RequestMessageW )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ __RPC__out LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *SendIMCA )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ __RPC__out LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *SendIMCW )( 
            __RPC__in IActiveIMMIME * This,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ __RPC__out LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *IsSleeping )( 
            __RPC__in IActiveIMMIME * This);
        
        END_INTERFACE
    } IActiveIMMIMEVtbl;

    interface IActiveIMMIME
    {
        CONST_VTBL struct IActiveIMMIMEVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMIME_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveIMMIME_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveIMMIME_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveIMMIME_AssociateContext(This,hWnd,hIME,phPrev)	\
    ( (This)->lpVtbl -> AssociateContext(This,hWnd,hIME,phPrev) ) 

#define IActiveIMMIME_ConfigureIMEA(This,hKL,hWnd,dwMode,pData)	\
    ( (This)->lpVtbl -> ConfigureIMEA(This,hKL,hWnd,dwMode,pData) ) 

#define IActiveIMMIME_ConfigureIMEW(This,hKL,hWnd,dwMode,pData)	\
    ( (This)->lpVtbl -> ConfigureIMEW(This,hKL,hWnd,dwMode,pData) ) 

#define IActiveIMMIME_CreateContext(This,phIMC)	\
    ( (This)->lpVtbl -> CreateContext(This,phIMC) ) 

#define IActiveIMMIME_DestroyContext(This,hIME)	\
    ( (This)->lpVtbl -> DestroyContext(This,hIME) ) 

#define IActiveIMMIME_EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    ( (This)->lpVtbl -> EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum) ) 

#define IActiveIMMIME_EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    ( (This)->lpVtbl -> EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum) ) 

#define IActiveIMMIME_EscapeA(This,hKL,hIMC,uEscape,pData,plResult)	\
    ( (This)->lpVtbl -> EscapeA(This,hKL,hIMC,uEscape,pData,plResult) ) 

#define IActiveIMMIME_EscapeW(This,hKL,hIMC,uEscape,pData,plResult)	\
    ( (This)->lpVtbl -> EscapeW(This,hKL,hIMC,uEscape,pData,plResult) ) 

#define IActiveIMMIME_GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    ( (This)->lpVtbl -> GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied) ) 

#define IActiveIMMIME_GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    ( (This)->lpVtbl -> GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied) ) 

#define IActiveIMMIME_GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)	\
    ( (This)->lpVtbl -> GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen) ) 

#define IActiveIMMIME_GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)	\
    ( (This)->lpVtbl -> GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen) ) 

#define IActiveIMMIME_GetCandidateWindow(This,hIMC,dwIndex,pCandidate)	\
    ( (This)->lpVtbl -> GetCandidateWindow(This,hIMC,dwIndex,pCandidate) ) 

#define IActiveIMMIME_GetCompositionFontA(This,hIMC,plf)	\
    ( (This)->lpVtbl -> GetCompositionFontA(This,hIMC,plf) ) 

#define IActiveIMMIME_GetCompositionFontW(This,hIMC,plf)	\
    ( (This)->lpVtbl -> GetCompositionFontW(This,hIMC,plf) ) 

#define IActiveIMMIME_GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    ( (This)->lpVtbl -> GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf) ) 

#define IActiveIMMIME_GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    ( (This)->lpVtbl -> GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf) ) 

#define IActiveIMMIME_GetCompositionWindow(This,hIMC,pCompForm)	\
    ( (This)->lpVtbl -> GetCompositionWindow(This,hIMC,pCompForm) ) 

#define IActiveIMMIME_GetContext(This,hWnd,phIMC)	\
    ( (This)->lpVtbl -> GetContext(This,hWnd,phIMC) ) 

#define IActiveIMMIME_GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    ( (This)->lpVtbl -> GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied) ) 

#define IActiveIMMIME_GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    ( (This)->lpVtbl -> GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied) ) 

#define IActiveIMMIME_GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)	\
    ( (This)->lpVtbl -> GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence) ) 

#define IActiveIMMIME_GetDefaultIMEWnd(This,hWnd,phDefWnd)	\
    ( (This)->lpVtbl -> GetDefaultIMEWnd(This,hWnd,phDefWnd) ) 

#define IActiveIMMIME_GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)	\
    ( (This)->lpVtbl -> GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied) ) 

#define IActiveIMMIME_GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)	\
    ( (This)->lpVtbl -> GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied) ) 

#define IActiveIMMIME_GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    ( (This)->lpVtbl -> GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult) ) 

#define IActiveIMMIME_GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    ( (This)->lpVtbl -> GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult) ) 

#define IActiveIMMIME_GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)	\
    ( (This)->lpVtbl -> GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied) ) 

#define IActiveIMMIME_GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)	\
    ( (This)->lpVtbl -> GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied) ) 

#define IActiveIMMIME_GetOpenStatus(This,hIMC)	\
    ( (This)->lpVtbl -> GetOpenStatus(This,hIMC) ) 

#define IActiveIMMIME_GetProperty(This,hKL,fdwIndex,pdwProperty)	\
    ( (This)->lpVtbl -> GetProperty(This,hKL,fdwIndex,pdwProperty) ) 

#define IActiveIMMIME_GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)	\
    ( (This)->lpVtbl -> GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied) ) 

#define IActiveIMMIME_GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)	\
    ( (This)->lpVtbl -> GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied) ) 

#define IActiveIMMIME_GetStatusWindowPos(This,hIMC,pptPos)	\
    ( (This)->lpVtbl -> GetStatusWindowPos(This,hIMC,pptPos) ) 

#define IActiveIMMIME_GetVirtualKey(This,hWnd,puVirtualKey)	\
    ( (This)->lpVtbl -> GetVirtualKey(This,hWnd,puVirtualKey) ) 

#define IActiveIMMIME_InstallIMEA(This,szIMEFileName,szLayoutText,phKL)	\
    ( (This)->lpVtbl -> InstallIMEA(This,szIMEFileName,szLayoutText,phKL) ) 

#define IActiveIMMIME_InstallIMEW(This,szIMEFileName,szLayoutText,phKL)	\
    ( (This)->lpVtbl -> InstallIMEW(This,szIMEFileName,szLayoutText,phKL) ) 

#define IActiveIMMIME_IsIME(This,hKL)	\
    ( (This)->lpVtbl -> IsIME(This,hKL) ) 

#define IActiveIMMIME_IsUIMessageA(This,hWndIME,msg,wParam,lParam)	\
    ( (This)->lpVtbl -> IsUIMessageA(This,hWndIME,msg,wParam,lParam) ) 

#define IActiveIMMIME_IsUIMessageW(This,hWndIME,msg,wParam,lParam)	\
    ( (This)->lpVtbl -> IsUIMessageW(This,hWndIME,msg,wParam,lParam) ) 

#define IActiveIMMIME_NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)	\
    ( (This)->lpVtbl -> NotifyIME(This,hIMC,dwAction,dwIndex,dwValue) ) 

#define IActiveIMMIME_RegisterWordA(This,hKL,szReading,dwStyle,szRegister)	\
    ( (This)->lpVtbl -> RegisterWordA(This,hKL,szReading,dwStyle,szRegister) ) 

#define IActiveIMMIME_RegisterWordW(This,hKL,szReading,dwStyle,szRegister)	\
    ( (This)->lpVtbl -> RegisterWordW(This,hKL,szReading,dwStyle,szRegister) ) 

#define IActiveIMMIME_ReleaseContext(This,hWnd,hIMC)	\
    ( (This)->lpVtbl -> ReleaseContext(This,hWnd,hIMC) ) 

#define IActiveIMMIME_SetCandidateWindow(This,hIMC,pCandidate)	\
    ( (This)->lpVtbl -> SetCandidateWindow(This,hIMC,pCandidate) ) 

#define IActiveIMMIME_SetCompositionFontA(This,hIMC,plf)	\
    ( (This)->lpVtbl -> SetCompositionFontA(This,hIMC,plf) ) 

#define IActiveIMMIME_SetCompositionFontW(This,hIMC,plf)	\
    ( (This)->lpVtbl -> SetCompositionFontW(This,hIMC,plf) ) 

#define IActiveIMMIME_SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    ( (This)->lpVtbl -> SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen) ) 

#define IActiveIMMIME_SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    ( (This)->lpVtbl -> SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen) ) 

#define IActiveIMMIME_SetCompositionWindow(This,hIMC,pCompForm)	\
    ( (This)->lpVtbl -> SetCompositionWindow(This,hIMC,pCompForm) ) 

#define IActiveIMMIME_SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)	\
    ( (This)->lpVtbl -> SetConversionStatus(This,hIMC,fdwConversion,fdwSentence) ) 

#define IActiveIMMIME_SetOpenStatus(This,hIMC,fOpen)	\
    ( (This)->lpVtbl -> SetOpenStatus(This,hIMC,fOpen) ) 

#define IActiveIMMIME_SetStatusWindowPos(This,hIMC,pptPos)	\
    ( (This)->lpVtbl -> SetStatusWindowPos(This,hIMC,pptPos) ) 

#define IActiveIMMIME_SimulateHotKey(This,hWnd,dwHotKeyID)	\
    ( (This)->lpVtbl -> SimulateHotKey(This,hWnd,dwHotKeyID) ) 

#define IActiveIMMIME_UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)	\
    ( (This)->lpVtbl -> UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister) ) 

#define IActiveIMMIME_UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)	\
    ( (This)->lpVtbl -> UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister) ) 

#define IActiveIMMIME_GenerateMessage(This,hIMC)	\
    ( (This)->lpVtbl -> GenerateMessage(This,hIMC) ) 

#define IActiveIMMIME_LockIMC(This,hIMC,ppIMC)	\
    ( (This)->lpVtbl -> LockIMC(This,hIMC,ppIMC) ) 

#define IActiveIMMIME_UnlockIMC(This,hIMC)	\
    ( (This)->lpVtbl -> UnlockIMC(This,hIMC) ) 

#define IActiveIMMIME_GetIMCLockCount(This,hIMC,pdwLockCount)	\
    ( (This)->lpVtbl -> GetIMCLockCount(This,hIMC,pdwLockCount) ) 

#define IActiveIMMIME_CreateIMCC(This,dwSize,phIMCC)	\
    ( (This)->lpVtbl -> CreateIMCC(This,dwSize,phIMCC) ) 

#define IActiveIMMIME_DestroyIMCC(This,hIMCC)	\
    ( (This)->lpVtbl -> DestroyIMCC(This,hIMCC) ) 

#define IActiveIMMIME_LockIMCC(This,hIMCC,ppv)	\
    ( (This)->lpVtbl -> LockIMCC(This,hIMCC,ppv) ) 

#define IActiveIMMIME_UnlockIMCC(This,hIMCC)	\
    ( (This)->lpVtbl -> UnlockIMCC(This,hIMCC) ) 

#define IActiveIMMIME_ReSizeIMCC(This,hIMCC,dwSize,phIMCC)	\
    ( (This)->lpVtbl -> ReSizeIMCC(This,hIMCC,dwSize,phIMCC) ) 

#define IActiveIMMIME_GetIMCCSize(This,hIMCC,pdwSize)	\
    ( (This)->lpVtbl -> GetIMCCSize(This,hIMCC,pdwSize) ) 

#define IActiveIMMIME_GetIMCCLockCount(This,hIMCC,pdwLockCount)	\
    ( (This)->lpVtbl -> GetIMCCLockCount(This,hIMCC,pdwLockCount) ) 

#define IActiveIMMIME_GetHotKey(This,dwHotKeyID,puModifiers,puVKey,phKL)	\
    ( (This)->lpVtbl -> GetHotKey(This,dwHotKeyID,puModifiers,puVKey,phKL) ) 

#define IActiveIMMIME_SetHotKey(This,dwHotKeyID,uModifiers,uVKey,hKL)	\
    ( (This)->lpVtbl -> SetHotKey(This,dwHotKeyID,uModifiers,uVKey,hKL) ) 

#define IActiveIMMIME_CreateSoftKeyboard(This,uType,hOwner,x,y,phSoftKbdWnd)	\
    ( (This)->lpVtbl -> CreateSoftKeyboard(This,uType,hOwner,x,y,phSoftKbdWnd) ) 

#define IActiveIMMIME_DestroySoftKeyboard(This,hSoftKbdWnd)	\
    ( (This)->lpVtbl -> DestroySoftKeyboard(This,hSoftKbdWnd) ) 

#define IActiveIMMIME_ShowSoftKeyboard(This,hSoftKbdWnd,nCmdShow)	\
    ( (This)->lpVtbl -> ShowSoftKeyboard(This,hSoftKbdWnd,nCmdShow) ) 

#define IActiveIMMIME_GetCodePageA(This,hKL,uCodePage)	\
    ( (This)->lpVtbl -> GetCodePageA(This,hKL,uCodePage) ) 

#define IActiveIMMIME_GetLangId(This,hKL,plid)	\
    ( (This)->lpVtbl -> GetLangId(This,hKL,plid) ) 

#define IActiveIMMIME_KeybdEvent(This,lgidIME,bVk,bScan,dwFlags,dwExtraInfo)	\
    ( (This)->lpVtbl -> KeybdEvent(This,lgidIME,bVk,bScan,dwFlags,dwExtraInfo) ) 

#define IActiveIMMIME_LockModal(This)	\
    ( (This)->lpVtbl -> LockModal(This) ) 

#define IActiveIMMIME_UnlockModal(This)	\
    ( (This)->lpVtbl -> UnlockModal(This) ) 

#define IActiveIMMIME_AssociateContextEx(This,hWnd,hIMC,dwFlags)	\
    ( (This)->lpVtbl -> AssociateContextEx(This,hWnd,hIMC,dwFlags) ) 

#define IActiveIMMIME_DisableIME(This,idThread)	\
    ( (This)->lpVtbl -> DisableIME(This,idThread) ) 

#define IActiveIMMIME_GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    ( (This)->lpVtbl -> GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult) ) 

#define IActiveIMMIME_GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    ( (This)->lpVtbl -> GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult) ) 

#define IActiveIMMIME_EnumInputContext(This,idThread,ppEnum)	\
    ( (This)->lpVtbl -> EnumInputContext(This,idThread,ppEnum) ) 

#define IActiveIMMIME_RequestMessageA(This,hIMC,wParam,lParam,plResult)	\
    ( (This)->lpVtbl -> RequestMessageA(This,hIMC,wParam,lParam,plResult) ) 

#define IActiveIMMIME_RequestMessageW(This,hIMC,wParam,lParam,plResult)	\
    ( (This)->lpVtbl -> RequestMessageW(This,hIMC,wParam,lParam,plResult) ) 

#define IActiveIMMIME_SendIMCA(This,hWnd,uMsg,wParam,lParam,plResult)	\
    ( (This)->lpVtbl -> SendIMCA(This,hWnd,uMsg,wParam,lParam,plResult) ) 

#define IActiveIMMIME_SendIMCW(This,hWnd,uMsg,wParam,lParam,plResult)	\
    ( (This)->lpVtbl -> SendIMCW(This,hWnd,uMsg,wParam,lParam,plResult) ) 

#define IActiveIMMIME_IsSleeping(This)	\
    ( (This)->lpVtbl -> IsSleeping(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveIMMIME_INTERFACE_DEFINED__ */


#ifndef __IActiveIME_INTERFACE_DEFINED__
#define __IActiveIME_INTERFACE_DEFINED__

/* interface IActiveIME */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIME;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6FE20962-D077-11d0-8FE7-00AA006BCC59")
    IActiveIME : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Inquire( 
            /* [in] */ DWORD dwSystemInfoFlags,
            /* [out] */ __RPC__out IMEINFO *pIMEInfo,
            /* [out] */ __RPC__out LPWSTR szWndClass,
            /* [out] */ __RPC__out DWORD *pdwPrivate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConversionList( 
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LPWSTR szSource,
            /* [in] */ UINT uFlag,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out CANDIDATELIST *pDest,
            /* [out] */ __RPC__out UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ __RPC__in REGISTERWORDW *pRegisterWord) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ UINT uReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Escape( 
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ __RPC__inout void *pData,
            /* [out] */ __RPC__out LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActiveContext( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessKey( 
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uVirKey,
            /* [in] */ DWORD lParam,
            /* [in] */ __RPC__in BYTE *pbKeyState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Select( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fSelect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionString( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ __RPC__in void *pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ __RPC__in void *pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ToAsciiEx( 
            /* [in] */ UINT uVirKey,
            /* [in] */ UINT uScanCode,
            /* [in] */ __RPC__in BYTE *pbKeyState,
            /* [in] */ UINT fuState,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pdwTransBuf,
            /* [out] */ __RPC__out UINT *puSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWord( 
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWord( 
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyle( 
            /* [in] */ UINT nItem,
            /* [out] */ __RPC__out STYLEBUFW *pStyleBuf,
            /* [out] */ __RPC__out UINT *puBufSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWord( 
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szRegister,
            /* [in] */ __RPC__in LPVOID pData,
            /* [out] */ __RPC__deref_out_opt IEnumRegisterWordW **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodePageA( 
            /* [out] */ __RPC__out UINT *uCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLangId( 
            /* [out] */ __RPC__out LANGID *plid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMEVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IActiveIME * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IActiveIME * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IActiveIME * This);
        
        HRESULT ( STDMETHODCALLTYPE *Inquire )( 
            __RPC__in IActiveIME * This,
            /* [in] */ DWORD dwSystemInfoFlags,
            /* [out] */ __RPC__out IMEINFO *pIMEInfo,
            /* [out] */ __RPC__out LPWSTR szWndClass,
            /* [out] */ __RPC__out DWORD *pdwPrivate);
        
        HRESULT ( STDMETHODCALLTYPE *ConversionList )( 
            __RPC__in IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LPWSTR szSource,
            /* [in] */ UINT uFlag,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out CANDIDATELIST *pDest,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *Configure )( 
            __RPC__in IActiveIME * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ __RPC__in REGISTERWORDW *pRegisterWord);
        
        HRESULT ( STDMETHODCALLTYPE *Destroy )( 
            __RPC__in IActiveIME * This,
            /* [in] */ UINT uReserved);
        
        HRESULT ( STDMETHODCALLTYPE *Escape )( 
            __RPC__in IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ __RPC__inout void *pData,
            /* [out] */ __RPC__out LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *SetActiveContext )( 
            __RPC__in IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fFlag);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessKey )( 
            __RPC__in IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uVirKey,
            /* [in] */ DWORD lParam,
            /* [in] */ __RPC__in BYTE *pbKeyState);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            __RPC__in IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *Select )( 
            __RPC__in IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fSelect);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionString )( 
            __RPC__in IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ __RPC__in void *pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ __RPC__in void *pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *ToAsciiEx )( 
            __RPC__in IActiveIME * This,
            /* [in] */ UINT uVirKey,
            /* [in] */ UINT uScanCode,
            /* [in] */ __RPC__in BYTE *pbKeyState,
            /* [in] */ UINT fuState,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pdwTransBuf,
            /* [out] */ __RPC__out UINT *puSize);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWord )( 
            __RPC__in IActiveIME * This,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szString);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWord )( 
            __RPC__in IActiveIME * This,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szString);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyle )( 
            __RPC__in IActiveIME * This,
            /* [in] */ UINT nItem,
            /* [out] */ __RPC__out STYLEBUFW *pStyleBuf,
            /* [out] */ __RPC__out UINT *puBufSize);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWord )( 
            __RPC__in IActiveIME * This,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szRegister,
            /* [in] */ __RPC__in LPVOID pData,
            /* [out] */ __RPC__deref_out_opt IEnumRegisterWordW **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodePageA )( 
            __RPC__in IActiveIME * This,
            /* [out] */ __RPC__out UINT *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLangId )( 
            __RPC__in IActiveIME * This,
            /* [out] */ __RPC__out LANGID *plid);
        
        END_INTERFACE
    } IActiveIMEVtbl;

    interface IActiveIME
    {
        CONST_VTBL struct IActiveIMEVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIME_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveIME_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveIME_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveIME_Inquire(This,dwSystemInfoFlags,pIMEInfo,szWndClass,pdwPrivate)	\
    ( (This)->lpVtbl -> Inquire(This,dwSystemInfoFlags,pIMEInfo,szWndClass,pdwPrivate) ) 

#define IActiveIME_ConversionList(This,hIMC,szSource,uFlag,uBufLen,pDest,puCopied)	\
    ( (This)->lpVtbl -> ConversionList(This,hIMC,szSource,uFlag,uBufLen,pDest,puCopied) ) 

#define IActiveIME_Configure(This,hKL,hWnd,dwMode,pRegisterWord)	\
    ( (This)->lpVtbl -> Configure(This,hKL,hWnd,dwMode,pRegisterWord) ) 

#define IActiveIME_Destroy(This,uReserved)	\
    ( (This)->lpVtbl -> Destroy(This,uReserved) ) 

#define IActiveIME_Escape(This,hIMC,uEscape,pData,plResult)	\
    ( (This)->lpVtbl -> Escape(This,hIMC,uEscape,pData,plResult) ) 

#define IActiveIME_SetActiveContext(This,hIMC,fFlag)	\
    ( (This)->lpVtbl -> SetActiveContext(This,hIMC,fFlag) ) 

#define IActiveIME_ProcessKey(This,hIMC,uVirKey,lParam,pbKeyState)	\
    ( (This)->lpVtbl -> ProcessKey(This,hIMC,uVirKey,lParam,pbKeyState) ) 

#define IActiveIME_Notify(This,hIMC,dwAction,dwIndex,dwValue)	\
    ( (This)->lpVtbl -> Notify(This,hIMC,dwAction,dwIndex,dwValue) ) 

#define IActiveIME_Select(This,hIMC,fSelect)	\
    ( (This)->lpVtbl -> Select(This,hIMC,fSelect) ) 

#define IActiveIME_SetCompositionString(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    ( (This)->lpVtbl -> SetCompositionString(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen) ) 

#define IActiveIME_ToAsciiEx(This,uVirKey,uScanCode,pbKeyState,fuState,hIMC,pdwTransBuf,puSize)	\
    ( (This)->lpVtbl -> ToAsciiEx(This,uVirKey,uScanCode,pbKeyState,fuState,hIMC,pdwTransBuf,puSize) ) 

#define IActiveIME_RegisterWord(This,szReading,dwStyle,szString)	\
    ( (This)->lpVtbl -> RegisterWord(This,szReading,dwStyle,szString) ) 

#define IActiveIME_UnregisterWord(This,szReading,dwStyle,szString)	\
    ( (This)->lpVtbl -> UnregisterWord(This,szReading,dwStyle,szString) ) 

#define IActiveIME_GetRegisterWordStyle(This,nItem,pStyleBuf,puBufSize)	\
    ( (This)->lpVtbl -> GetRegisterWordStyle(This,nItem,pStyleBuf,puBufSize) ) 

#define IActiveIME_EnumRegisterWord(This,szReading,dwStyle,szRegister,pData,ppEnum)	\
    ( (This)->lpVtbl -> EnumRegisterWord(This,szReading,dwStyle,szRegister,pData,ppEnum) ) 

#define IActiveIME_GetCodePageA(This,uCodePage)	\
    ( (This)->lpVtbl -> GetCodePageA(This,uCodePage) ) 

#define IActiveIME_GetLangId(This,plid)	\
    ( (This)->lpVtbl -> GetLangId(This,plid) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveIME_INTERFACE_DEFINED__ */


#ifndef __IActiveIME2_INTERFACE_DEFINED__
#define __IActiveIME2_INTERFACE_DEFINED__

/* interface IActiveIME2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIME2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e1c4bf0e-2d53-11d2-93e1-0060b067b86e")
    IActiveIME2 : public IActiveIME
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Sleep( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unsleep( 
            /* [in] */ BOOL fDead) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIME2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IActiveIME2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IActiveIME2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IActiveIME2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Inquire )( 
            __RPC__in IActiveIME2 * This,
            /* [in] */ DWORD dwSystemInfoFlags,
            /* [out] */ __RPC__out IMEINFO *pIMEInfo,
            /* [out] */ __RPC__out LPWSTR szWndClass,
            /* [out] */ __RPC__out DWORD *pdwPrivate);
        
        HRESULT ( STDMETHODCALLTYPE *ConversionList )( 
            __RPC__in IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ __RPC__in LPWSTR szSource,
            /* [in] */ UINT uFlag,
            /* [in] */ UINT uBufLen,
            /* [out] */ __RPC__out CANDIDATELIST *pDest,
            /* [out] */ __RPC__out UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *Configure )( 
            __RPC__in IActiveIME2 * This,
            /* [in] */ __RPC__in HKL hKL,
            /* [in] */ __RPC__in HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ __RPC__in REGISTERWORDW *pRegisterWord);
        
        HRESULT ( STDMETHODCALLTYPE *Destroy )( 
            __RPC__in IActiveIME2 * This,
            /* [in] */ UINT uReserved);
        
        HRESULT ( STDMETHODCALLTYPE *Escape )( 
            __RPC__in IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ __RPC__inout void *pData,
            /* [out] */ __RPC__out LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *SetActiveContext )( 
            __RPC__in IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fFlag);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessKey )( 
            __RPC__in IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uVirKey,
            /* [in] */ DWORD lParam,
            /* [in] */ __RPC__in BYTE *pbKeyState);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            __RPC__in IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *Select )( 
            __RPC__in IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fSelect);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionString )( 
            __RPC__in IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ __RPC__in void *pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ __RPC__in void *pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *ToAsciiEx )( 
            __RPC__in IActiveIME2 * This,
            /* [in] */ UINT uVirKey,
            /* [in] */ UINT uScanCode,
            /* [in] */ __RPC__in BYTE *pbKeyState,
            /* [in] */ UINT fuState,
            /* [in] */ HIMC hIMC,
            /* [out] */ __RPC__out DWORD *pdwTransBuf,
            /* [out] */ __RPC__out UINT *puSize);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWord )( 
            __RPC__in IActiveIME2 * This,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szString);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWord )( 
            __RPC__in IActiveIME2 * This,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szString);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyle )( 
            __RPC__in IActiveIME2 * This,
            /* [in] */ UINT nItem,
            /* [out] */ __RPC__out STYLEBUFW *pStyleBuf,
            /* [out] */ __RPC__out UINT *puBufSize);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWord )( 
            __RPC__in IActiveIME2 * This,
            /* [in] */ __RPC__in LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ __RPC__in LPWSTR szRegister,
            /* [in] */ __RPC__in LPVOID pData,
            /* [out] */ __RPC__deref_out_opt IEnumRegisterWordW **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodePageA )( 
            __RPC__in IActiveIME2 * This,
            /* [out] */ __RPC__out UINT *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLangId )( 
            __RPC__in IActiveIME2 * This,
            /* [out] */ __RPC__out LANGID *plid);
        
        HRESULT ( STDMETHODCALLTYPE *Sleep )( 
            __RPC__in IActiveIME2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Unsleep )( 
            __RPC__in IActiveIME2 * This,
            /* [in] */ BOOL fDead);
        
        END_INTERFACE
    } IActiveIME2Vtbl;

    interface IActiveIME2
    {
        CONST_VTBL struct IActiveIME2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIME2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveIME2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveIME2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveIME2_Inquire(This,dwSystemInfoFlags,pIMEInfo,szWndClass,pdwPrivate)	\
    ( (This)->lpVtbl -> Inquire(This,dwSystemInfoFlags,pIMEInfo,szWndClass,pdwPrivate) ) 

#define IActiveIME2_ConversionList(This,hIMC,szSource,uFlag,uBufLen,pDest,puCopied)	\
    ( (This)->lpVtbl -> ConversionList(This,hIMC,szSource,uFlag,uBufLen,pDest,puCopied) ) 

#define IActiveIME2_Configure(This,hKL,hWnd,dwMode,pRegisterWord)	\
    ( (This)->lpVtbl -> Configure(This,hKL,hWnd,dwMode,pRegisterWord) ) 

#define IActiveIME2_Destroy(This,uReserved)	\
    ( (This)->lpVtbl -> Destroy(This,uReserved) ) 

#define IActiveIME2_Escape(This,hIMC,uEscape,pData,plResult)	\
    ( (This)->lpVtbl -> Escape(This,hIMC,uEscape,pData,plResult) ) 

#define IActiveIME2_SetActiveContext(This,hIMC,fFlag)	\
    ( (This)->lpVtbl -> SetActiveContext(This,hIMC,fFlag) ) 

#define IActiveIME2_ProcessKey(This,hIMC,uVirKey,lParam,pbKeyState)	\
    ( (This)->lpVtbl -> ProcessKey(This,hIMC,uVirKey,lParam,pbKeyState) ) 

#define IActiveIME2_Notify(This,hIMC,dwAction,dwIndex,dwValue)	\
    ( (This)->lpVtbl -> Notify(This,hIMC,dwAction,dwIndex,dwValue) ) 

#define IActiveIME2_Select(This,hIMC,fSelect)	\
    ( (This)->lpVtbl -> Select(This,hIMC,fSelect) ) 

#define IActiveIME2_SetCompositionString(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    ( (This)->lpVtbl -> SetCompositionString(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen) ) 

#define IActiveIME2_ToAsciiEx(This,uVirKey,uScanCode,pbKeyState,fuState,hIMC,pdwTransBuf,puSize)	\
    ( (This)->lpVtbl -> ToAsciiEx(This,uVirKey,uScanCode,pbKeyState,fuState,hIMC,pdwTransBuf,puSize) ) 

#define IActiveIME2_RegisterWord(This,szReading,dwStyle,szString)	\
    ( (This)->lpVtbl -> RegisterWord(This,szReading,dwStyle,szString) ) 

#define IActiveIME2_UnregisterWord(This,szReading,dwStyle,szString)	\
    ( (This)->lpVtbl -> UnregisterWord(This,szReading,dwStyle,szString) ) 

#define IActiveIME2_GetRegisterWordStyle(This,nItem,pStyleBuf,puBufSize)	\
    ( (This)->lpVtbl -> GetRegisterWordStyle(This,nItem,pStyleBuf,puBufSize) ) 

#define IActiveIME2_EnumRegisterWord(This,szReading,dwStyle,szRegister,pData,ppEnum)	\
    ( (This)->lpVtbl -> EnumRegisterWord(This,szReading,dwStyle,szRegister,pData,ppEnum) ) 

#define IActiveIME2_GetCodePageA(This,uCodePage)	\
    ( (This)->lpVtbl -> GetCodePageA(This,uCodePage) ) 

#define IActiveIME2_GetLangId(This,plid)	\
    ( (This)->lpVtbl -> GetLangId(This,plid) ) 


#define IActiveIME2_Sleep(This)	\
    ( (This)->lpVtbl -> Sleep(This) ) 

#define IActiveIME2_Unsleep(This,fDead)	\
    ( (This)->lpVtbl -> Unsleep(This,fDead) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveIME2_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_CActiveIMM;

#ifdef __cplusplus

class DECLSPEC_UUID("4955DD33-B159-11d0-8FCF-00AA006BCC59")
CActiveIMM;
#endif
#endif /* __ActiveIMM_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\DispEx.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for dispex.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dispex_h__
#define __dispex_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDispatchEx_FWD_DEFINED__
#define __IDispatchEx_FWD_DEFINED__
typedef interface IDispatchEx IDispatchEx;
#endif 	/* __IDispatchEx_FWD_DEFINED__ */


#ifndef __IDispError_FWD_DEFINED__
#define __IDispError_FWD_DEFINED__
typedef interface IDispError IDispError;
#endif 	/* __IDispError_FWD_DEFINED__ */


#ifndef __IVariantChangeType_FWD_DEFINED__
#define __IVariantChangeType_FWD_DEFINED__
typedef interface IVariantChangeType IVariantChangeType;
#endif 	/* __IVariantChangeType_FWD_DEFINED__ */


#ifndef __IObjectIdentity_FWD_DEFINED__
#define __IObjectIdentity_FWD_DEFINED__
typedef interface IObjectIdentity IObjectIdentity;
#endif 	/* __IObjectIdentity_FWD_DEFINED__ */


#ifndef __IProvideRuntimeContext_FWD_DEFINED__
#define __IProvideRuntimeContext_FWD_DEFINED__
typedef interface IProvideRuntimeContext IProvideRuntimeContext;
#endif 	/* __IProvideRuntimeContext_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_dispex_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// DispEx.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1997 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// IDispatchEx Interfaces.
//

#ifndef DISPEX_H_
#define DISPEX_H_





#include "servprov.h"

#ifndef _NO_DISPATCHEX_GUIDS

// {A6EF9860-C720-11d0-9337-00A0C90DCAA9}
DEFINE_GUID(IID_IDispatchEx, 0xa6ef9860, 0xc720, 0x11d0, 0x93, 0x37, 0x0, 0xa0, 0xc9, 0xd, 0xca, 0xa9);

// {A6EF9861-C720-11d0-9337-00A0C90DCAA9}
DEFINE_GUID(IID_IDispError, 0xa6ef9861, 0xc720, 0x11d0, 0x93, 0x37, 0x0, 0xa0, 0xc9, 0xd, 0xca, 0xa9);

// {A6EF9862-C720-11d0-9337-00A0C90DCAA9}
DEFINE_GUID(IID_IVariantChangeType, 0xa6ef9862, 0xc720, 0x11d0, 0x93, 0x37, 0x0, 0xa0, 0xc9, 0xd, 0xca, 0xa9);

// {1F101481-BCCD-11d0-9336-00A0C90DCAA9}
DEFINE_GUID(SID_VariantConversion, 0x1f101481, 0xbccd, 0x11d0, 0x93, 0x36, 0x0, 0xa0, 0xc9, 0xd, 0xca, 0xa9);

// {4717CC40-BCB9-11d0-9336-00A0C90DCAA9}
DEFINE_GUID(SID_GetCaller, 0x4717cc40, 0xbcb9, 0x11d0, 0x93, 0x36, 0x0, 0xa0, 0xc9, 0xd, 0xca, 0xa9);

// {74A5040C-DD0C-48f0-AC85-194C3259180A}
DEFINE_GUID(SID_ProvideRuntimeContext, 0x74a5040c, 0xdd0c, 0x48f0, 0xac, 0x85, 0x19, 0x4c, 0x32, 0x59, 0x18, 0xa);

// {10E2414A-EC59-49d2-BC51-5ADD2C36FEBC}
DEFINE_GUID(IID_IProvideRuntimeContext, 0x10e2414a, 0xec59, 0x49d2, 0xbc, 0x51, 0x5a, 0xdd, 0x2c, 0x36, 0xfe, 0xbc);

// {CA04B7E6-0D21-11d1-8CC5-00C04FC2B085}
DEFINE_GUID(IID_IObjectIdentity, 0xca04b7e6, 0xd21, 0x11d1, 0x8c, 0xc5, 0x0, 0xc0, 0x4f, 0xc2, 0xb0, 0x85);

#define SID_GetScriptSite IID_IActiveScriptSite

#endif // _NO_DISPATCHEX_GUIDS


#ifndef _NO_DISPATCHEX_CONSTS

// Input flags for GetDispID
#define fdexNameCaseSensitive       0x00000001L
#define fdexNameEnsure              0x00000002L
#define fdexNameImplicit            0x00000004L
#define fdexNameCaseInsensitive     0x00000008L
#define fdexNameInternal            0x00000010L
#define fdexNameNoDynamicProperties 0x00000020L

// Output flags for GetMemberProperties
#define fdexPropCanGet              0x00000001L
#define fdexPropCannotGet           0x00000002L
#define fdexPropCanPut              0x00000004L
#define fdexPropCannotPut           0x00000008L
#define fdexPropCanPutRef           0x00000010L
#define fdexPropCannotPutRef        0x00000020L
#define fdexPropNoSideEffects       0x00000040L
#define fdexPropDynamicType         0x00000080L
#define fdexPropCanCall             0x00000100L
#define fdexPropCannotCall          0x00000200L
#define fdexPropCanConstruct        0x00000400L
#define fdexPropCannotConstruct     0x00000800L
#define fdexPropCanSourceEvents     0x00001000L
#define fdexPropCannotSourceEvents  0x00002000L

#define grfdexPropCanAll \
       (fdexPropCanGet | fdexPropCanPut | fdexPropCanPutRef | \
        fdexPropCanCall | fdexPropCanConstruct | fdexPropCanSourceEvents)
#define grfdexPropCannotAll \
       (fdexPropCannotGet | fdexPropCannotPut | fdexPropCannotPutRef | \
        fdexPropCannotCall | fdexPropCannotConstruct | fdexPropCannotSourceEvents)
#define grfdexPropExtraAll \
       (fdexPropNoSideEffects | fdexPropDynamicType)
#define grfdexPropAll \
       (grfdexPropCanAll | grfdexPropCannotAll | grfdexPropExtraAll)

// Input flags for GetNextDispID
#define fdexEnumDefault             0x00000001L
#define fdexEnumAll                 0x00000002L

// Additional flags for Invoke - when object member is
// used as a constructor.
#define DISPATCH_CONSTRUCT 0x4000

// Standard DISPIDs
#define DISPID_THIS (-613)
#define DISPID_STARTENUM DISPID_UNKNOWN

#endif //_NO_DISPATCHEX_CONSTS



extern RPC_IF_HANDLE __MIDL_itf_dispex_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dispex_0000_0000_v0_0_s_ifspec;

#ifndef __IDispatchEx_INTERFACE_DEFINED__
#define __IDispatchEx_INTERFACE_DEFINED__

/* interface IDispatchEx */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDispatchEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A6EF9860-C720-11d0-9337-00A0C90DCAA9")
    IDispatchEx : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDispID( 
            /* [in] */ __RPC__in BSTR bstrName,
            /* [in] */ DWORD grfdex,
            /* [out] */ __RPC__out DISPID *pid) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE InvokeEx( 
            /* [annotation][in] */ 
            __in  DISPID id,
            /* [annotation][in] */ 
            __in  LCID lcid,
            /* [annotation][in] */ 
            __in  WORD wFlags,
            /* [annotation][in] */ 
            __in  DISPPARAMS *pdp,
            /* [annotation][out] */ 
            __out_opt  VARIANT *pvarRes,
            /* [annotation][out] */ 
            __out_opt  EXCEPINFO *pei,
            /* [annotation][unique][in] */ 
            __in_opt  IServiceProvider *pspCaller) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteMemberByName( 
            /* [in] */ __RPC__in BSTR bstrName,
            /* [in] */ DWORD grfdex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteMemberByDispID( 
            /* [in] */ DISPID id) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMemberProperties( 
            /* [in] */ DISPID id,
            /* [in] */ DWORD grfdexFetch,
            /* [out] */ __RPC__out DWORD *pgrfdex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMemberName( 
            /* [in] */ DISPID id,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextDispID( 
            /* [in] */ DWORD grfdex,
            /* [in] */ DISPID id,
            /* [out] */ __RPC__out DISPID *pid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNameSpaceParent( 
            /* [out] */ __RPC__deref_out_opt IUnknown **ppunk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDispatchExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDispatchEx * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDispatchEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDispatchEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IDispatchEx * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IDispatchEx * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IDispatchEx * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDispatchEx * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *GetDispID )( 
            __RPC__in IDispatchEx * This,
            /* [in] */ __RPC__in BSTR bstrName,
            /* [in] */ DWORD grfdex,
            /* [out] */ __RPC__out DISPID *pid);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *InvokeEx )( 
            IDispatchEx * This,
            /* [annotation][in] */ 
            __in  DISPID id,
            /* [annotation][in] */ 
            __in  LCID lcid,
            /* [annotation][in] */ 
            __in  WORD wFlags,
            /* [annotation][in] */ 
            __in  DISPPARAMS *pdp,
            /* [annotation][out] */ 
            __out_opt  VARIANT *pvarRes,
            /* [annotation][out] */ 
            __out_opt  EXCEPINFO *pei,
            /* [annotation][unique][in] */ 
            __in_opt  IServiceProvider *pspCaller);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteMemberByName )( 
            __RPC__in IDispatchEx * This,
            /* [in] */ __RPC__in BSTR bstrName,
            /* [in] */ DWORD grfdex);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteMemberByDispID )( 
            __RPC__in IDispatchEx * This,
            /* [in] */ DISPID id);
        
        HRESULT ( STDMETHODCALLTYPE *GetMemberProperties )( 
            __RPC__in IDispatchEx * This,
            /* [in] */ DISPID id,
            /* [in] */ DWORD grfdexFetch,
            /* [out] */ __RPC__out DWORD *pgrfdex);
        
        HRESULT ( STDMETHODCALLTYPE *GetMemberName )( 
            __RPC__in IDispatchEx * This,
            /* [in] */ DISPID id,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextDispID )( 
            __RPC__in IDispatchEx * This,
            /* [in] */ DWORD grfdex,
            /* [in] */ DISPID id,
            /* [out] */ __RPC__out DISPID *pid);
        
        HRESULT ( STDMETHODCALLTYPE *GetNameSpaceParent )( 
            __RPC__in IDispatchEx * This,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppunk);
        
        END_INTERFACE
    } IDispatchExVtbl;

    interface IDispatchEx
    {
        CONST_VTBL struct IDispatchExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDispatchEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDispatchEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDispatchEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDispatchEx_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDispatchEx_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDispatchEx_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDispatchEx_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDispatchEx_GetDispID(This,bstrName,grfdex,pid)	\
    ( (This)->lpVtbl -> GetDispID(This,bstrName,grfdex,pid) ) 

#define IDispatchEx_InvokeEx(This,id,lcid,wFlags,pdp,pvarRes,pei,pspCaller)	\
    ( (This)->lpVtbl -> InvokeEx(This,id,lcid,wFlags,pdp,pvarRes,pei,pspCaller) ) 

#define IDispatchEx_DeleteMemberByName(This,bstrName,grfdex)	\
    ( (This)->lpVtbl -> DeleteMemberByName(This,bstrName,grfdex) ) 

#define IDispatchEx_DeleteMemberByDispID(This,id)	\
    ( (This)->lpVtbl -> DeleteMemberByDispID(This,id) ) 

#define IDispatchEx_GetMemberProperties(This,id,grfdexFetch,pgrfdex)	\
    ( (This)->lpVtbl -> GetMemberProperties(This,id,grfdexFetch,pgrfdex) ) 

#define IDispatchEx_GetMemberName(This,id,pbstrName)	\
    ( (This)->lpVtbl -> GetMemberName(This,id,pbstrName) ) 

#define IDispatchEx_GetNextDispID(This,grfdex,id,pid)	\
    ( (This)->lpVtbl -> GetNextDispID(This,grfdex,id,pid) ) 

#define IDispatchEx_GetNameSpaceParent(This,ppunk)	\
    ( (This)->lpVtbl -> GetNameSpaceParent(This,ppunk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IDispatchEx_RemoteInvokeEx_Proxy( 
    __RPC__in IDispatchEx * This,
    /* [in] */ DISPID id,
    /* [in] */ LCID lcid,
    /* [in] */ DWORD dwFlags,
    /* [in] */ __RPC__in DISPPARAMS *pdp,
    /* [out] */ __RPC__out VARIANT *pvarRes,
    /* [out] */ __RPC__out EXCEPINFO *pei,
    /* [unique][in] */ __RPC__in_opt IServiceProvider *pspCaller,
    /* [in] */ UINT cvarRefArg,
    /* [size_is][in] */ __RPC__in_ecount_full(cvarRefArg) UINT *rgiRefArg,
    /* [size_is][out][in] */ __RPC__inout_ecount_full(cvarRefArg) VARIANT *rgvarRefArg);


void __RPC_STUB IDispatchEx_RemoteInvokeEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDispatchEx_INTERFACE_DEFINED__ */


#ifndef __IDispError_INTERFACE_DEFINED__
#define __IDispError_INTERFACE_DEFINED__

/* interface IDispError */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDispError;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A6EF9861-C720-11d0-9337-00A0C90DCAA9")
    IDispError : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryErrorInfo( 
            /* [in] */ GUID guidErrorType,
            /* [out] */ __RPC__deref_out_opt IDispError **ppde) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ __RPC__deref_out_opt IDispError **ppde) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHresult( 
            /* [out] */ __RPC__out HRESULT *phr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSource( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHelpInfo( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrFileName,
            /* [out] */ __RPC__out DWORD *pdwContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrDescription) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDispErrorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDispError * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDispError * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDispError * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryErrorInfo )( 
            __RPC__in IDispError * This,
            /* [in] */ GUID guidErrorType,
            /* [out] */ __RPC__deref_out_opt IDispError **ppde);
        
        HRESULT ( STDMETHODCALLTYPE *GetNext )( 
            __RPC__in IDispError * This,
            /* [out] */ __RPC__deref_out_opt IDispError **ppde);
        
        HRESULT ( STDMETHODCALLTYPE *GetHresult )( 
            __RPC__in IDispError * This,
            /* [out] */ __RPC__out HRESULT *phr);
        
        HRESULT ( STDMETHODCALLTYPE *GetSource )( 
            __RPC__in IDispError * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrSource);
        
        HRESULT ( STDMETHODCALLTYPE *GetHelpInfo )( 
            __RPC__in IDispError * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrFileName,
            /* [out] */ __RPC__out DWORD *pdwContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            __RPC__in IDispError * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrDescription);
        
        END_INTERFACE
    } IDispErrorVtbl;

    interface IDispError
    {
        CONST_VTBL struct IDispErrorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDispError_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDispError_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDispError_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDispError_QueryErrorInfo(This,guidErrorType,ppde)	\
    ( (This)->lpVtbl -> QueryErrorInfo(This,guidErrorType,ppde) ) 

#define IDispError_GetNext(This,ppde)	\
    ( (This)->lpVtbl -> GetNext(This,ppde) ) 

#define IDispError_GetHresult(This,phr)	\
    ( (This)->lpVtbl -> GetHresult(This,phr) ) 

#define IDispError_GetSource(This,pbstrSource)	\
    ( (This)->lpVtbl -> GetSource(This,pbstrSource) ) 

#define IDispError_GetHelpInfo(This,pbstrFileName,pdwContext)	\
    ( (This)->lpVtbl -> GetHelpInfo(This,pbstrFileName,pdwContext) ) 

#define IDispError_GetDescription(This,pbstrDescription)	\
    ( (This)->lpVtbl -> GetDescription(This,pbstrDescription) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDispError_INTERFACE_DEFINED__ */


#ifndef __IVariantChangeType_INTERFACE_DEFINED__
#define __IVariantChangeType_INTERFACE_DEFINED__

/* interface IVariantChangeType */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVariantChangeType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A6EF9862-C720-11d0-9337-00A0C90DCAA9")
    IVariantChangeType : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ChangeType( 
            /* [unique][out][in] */ __RPC__inout_opt VARIANT *pvarDst,
            /* [unique][in] */ __RPC__in_opt VARIANT *pvarSrc,
            /* [in] */ LCID lcid,
            /* [in] */ VARTYPE vtNew) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVariantChangeTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVariantChangeType * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVariantChangeType * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVariantChangeType * This);
        
        HRESULT ( STDMETHODCALLTYPE *ChangeType )( 
            __RPC__in IVariantChangeType * This,
            /* [unique][out][in] */ __RPC__inout_opt VARIANT *pvarDst,
            /* [unique][in] */ __RPC__in_opt VARIANT *pvarSrc,
            /* [in] */ LCID lcid,
            /* [in] */ VARTYPE vtNew);
        
        END_INTERFACE
    } IVariantChangeTypeVtbl;

    interface IVariantChangeType
    {
        CONST_VTBL struct IVariantChangeTypeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVariantChangeType_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVariantChangeType_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVariantChangeType_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVariantChangeType_ChangeType(This,pvarDst,pvarSrc,lcid,vtNew)	\
    ( (This)->lpVtbl -> ChangeType(This,pvarDst,pvarSrc,lcid,vtNew) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVariantChangeType_INTERFACE_DEFINED__ */


#ifndef __IObjectIdentity_INTERFACE_DEFINED__
#define __IObjectIdentity_INTERFACE_DEFINED__

/* interface IObjectIdentity */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IObjectIdentity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CA04B7E6-0D21-11d1-8CC5-00C04FC2B085")
    IObjectIdentity : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsEqualObject( 
            /* [in] */ __RPC__in_opt IUnknown *punk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectIdentityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IObjectIdentity * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IObjectIdentity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IObjectIdentity * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqualObject )( 
            __RPC__in IObjectIdentity * This,
            /* [in] */ __RPC__in_opt IUnknown *punk);
        
        END_INTERFACE
    } IObjectIdentityVtbl;

    interface IObjectIdentity
    {
        CONST_VTBL struct IObjectIdentityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectIdentity_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObjectIdentity_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObjectIdentity_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObjectIdentity_IsEqualObject(This,punk)	\
    ( (This)->lpVtbl -> IsEqualObject(This,punk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObjectIdentity_INTERFACE_DEFINED__ */


#ifndef __IProvideRuntimeContext_INTERFACE_DEFINED__
#define __IProvideRuntimeContext_INTERFACE_DEFINED__

/* interface IProvideRuntimeContext */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IProvideRuntimeContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("10E2414A-EC59-49d2-BC51-5ADD2C36FEBC")
    IProvideRuntimeContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCurrentSourceContext( 
            /* [out] */ __RPC__out DWORD_PTR *pdwContext,
            /* [out] */ __RPC__out VARIANT_BOOL *pfExecutingGlobalCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProvideRuntimeContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IProvideRuntimeContext * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IProvideRuntimeContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IProvideRuntimeContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentSourceContext )( 
            __RPC__in IProvideRuntimeContext * This,
            /* [out] */ __RPC__out DWORD_PTR *pdwContext,
            /* [out] */ __RPC__out VARIANT_BOOL *pfExecutingGlobalCode);
        
        END_INTERFACE
    } IProvideRuntimeContextVtbl;

    interface IProvideRuntimeContext
    {
        CONST_VTBL struct IProvideRuntimeContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvideRuntimeContext_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IProvideRuntimeContext_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IProvideRuntimeContext_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IProvideRuntimeContext_GetCurrentSourceContext(This,pdwContext,pfExecutingGlobalCode)	\
    ( (This)->lpVtbl -> GetCurrentSourceContext(This,pdwContext,pfExecutingGlobalCode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IProvideRuntimeContext_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dispex_0000_0005 */
/* [local] */ 

#endif //DISPEX_H_


extern RPC_IF_HANDLE __MIDL_itf_dispex_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dispex_0000_0005_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     __RPC__in unsigned long *, __RPC__in VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     __RPC__in unsigned long *, __RPC__in VARIANT * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IDispatchEx_InvokeEx_Proxy( 
    IDispatchEx * This,
    /* [annotation][in] */ 
    __in  DISPID id,
    /* [annotation][in] */ 
    __in  LCID lcid,
    /* [annotation][in] */ 
    __in  WORD wFlags,
    /* [annotation][in] */ 
    __in  DISPPARAMS *pdp,
    /* [annotation][out] */ 
    __out_opt  VARIANT *pvarRes,
    /* [annotation][out] */ 
    __out_opt  EXCEPINFO *pei,
    /* [annotation][unique][in] */ 
    __in_opt  IServiceProvider *pspCaller);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDispatchEx_InvokeEx_Stub( 
    __RPC__in IDispatchEx * This,
    /* [in] */ DISPID id,
    /* [in] */ LCID lcid,
    /* [in] */ DWORD dwFlags,
    /* [in] */ __RPC__in DISPPARAMS *pdp,
    /* [out] */ __RPC__out VARIANT *pvarRes,
    /* [out] */ __RPC__out EXCEPINFO *pei,
    /* [unique][in] */ __RPC__in_opt IServiceProvider *pspCaller,
    /* [in] */ UINT cvarRefArg,
    /* [size_is][in] */ __RPC__in_ecount_full(cvarRefArg) UINT *rgiRefArg,
    /* [size_is][out][in] */ __RPC__inout_ecount_full(cvarRefArg) VARIANT *rgvarRefArg);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dinputd.h ===
/****************************************************************************
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dinputd.h
 *  Content:    DirectInput include file for device driver implementors
 *
 ****************************************************************************/
#ifndef __DINPUTD_INCLUDED__
#define __DINPUTD_INCLUDED__

#ifndef DIRECTINPUT_VERSION
#define DIRECTINPUT_VERSION         0x0800
#pragma message(__FILE__ ": DIRECTINPUT_VERSION undefined. Defaulting to version 0x0800")
#endif

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************
 *
 *      Interfaces
 *
 ****************************************************************************/

#ifndef DIJ_RINGZERO

DEFINE_GUID(IID_IDirectInputEffectDriver,   0x02538130,0x898F,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(IID_IDirectInputJoyConfig,      0x1DE12AB1,0xC9F5,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInputPIDDriver,      0xEEC6993A,0xB3FD,0x11D2,0xA9,0x16,0x00,0xC0,0x4F,0xB9,0x86,0x38);

DEFINE_GUID(IID_IDirectInputJoyConfig8,     0xeb0d7dfa,0x1990,0x4f27,0xb4,0xd6,0xed,0xf2,0xee,0xc4,0xa4,0x4c);

#endif /* DIJ_RINGZERO */


/****************************************************************************
 *
 *      IDirectInputEffectDriver
 *
 ****************************************************************************/

typedef struct DIOBJECTATTRIBUTES {
    DWORD   dwFlags;
    WORD    wUsagePage;
    WORD    wUsage;
} DIOBJECTATTRIBUTES, *LPDIOBJECTATTRIBUTES;
typedef const DIOBJECTATTRIBUTES *LPCDIOBJECTATTRIBUTES;

typedef struct DIFFOBJECTATTRIBUTES {
    DWORD   dwFFMaxForce;
    DWORD   dwFFForceResolution;
} DIFFOBJECTATTRIBUTES, *LPDIFFOBJECTATTRIBUTES;
typedef const DIFFOBJECTATTRIBUTES *LPCDIFFOBJECTATTRIBUTES;

typedef struct DIOBJECTCALIBRATION {
    LONG    lMin;
    LONG    lCenter;
    LONG    lMax;
} DIOBJECTCALIBRATION, *LPDIOBJECTCALIBRATION;
typedef const DIOBJECTCALIBRATION *LPCDIOBJECTCALIBRATION;

typedef struct DIPOVCALIBRATION {
    LONG    lMin[5];
    LONG    lMax[5];
} DIPOVCALIBRATION, *LPDIPOVCALIBRATION;
typedef const DIPOVCALIBRATION *LPCDIPOVCALIBRATION;

typedef struct DIEFFECTATTRIBUTES {
    DWORD   dwEffectId;
    DWORD   dwEffType;
    DWORD   dwStaticParams;
    DWORD   dwDynamicParams;
    DWORD   dwCoords;
} DIEFFECTATTRIBUTES, *LPDIEFFECTATTRIBUTES;
typedef const DIEFFECTATTRIBUTES *LPCDIEFFECTATTRIBUTES;

typedef struct DIFFDEVICEATTRIBUTES {
    DWORD   dwFlags;
    DWORD   dwFFSamplePeriod;
    DWORD   dwFFMinTimeResolution;
} DIFFDEVICEATTRIBUTES, *LPDIFFDEVICEATTRIBUTES;
typedef const DIFFDEVICEATTRIBUTES *LPCDIFFDEVICEATTRIBUTES;

typedef struct DIDRIVERVERSIONS {
    DWORD   dwSize;
    DWORD   dwFirmwareRevision;
    DWORD   dwHardwareRevision;
    DWORD   dwFFDriverVersion;
} DIDRIVERVERSIONS, *LPDIDRIVERVERSIONS;
typedef const DIDRIVERVERSIONS *LPCDIDRIVERVERSIONS;

typedef struct DIDEVICESTATE {
    DWORD   dwSize;
    DWORD   dwState;
    DWORD   dwLoad;
} DIDEVICESTATE, *LPDIDEVICESTATE;

#define DEV_STS_EFFECT_RUNNING  DIEGES_PLAYING

#ifndef DIJ_RINGZERO

typedef struct DIHIDFFINITINFO {
    DWORD   dwSize;
    LPWSTR  pwszDeviceInterface;
    GUID    GuidInstance;
} DIHIDFFINITINFO, *LPDIHIDFFINITINFO;

#undef INTERFACE
#define INTERFACE IDirectInputEffectDriver

DECLARE_INTERFACE_(IDirectInputEffectDriver, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputEffectDriver methods ***/
    STDMETHOD(DeviceID)(THIS_ DWORD,DWORD,DWORD,DWORD,LPVOID) PURE;
    STDMETHOD(GetVersions)(THIS_ LPDIDRIVERVERSIONS) PURE;
    STDMETHOD(Escape)(THIS_ DWORD,DWORD,LPDIEFFESCAPE) PURE;
    STDMETHOD(SetGain)(THIS_ DWORD,DWORD) PURE;
    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD,DWORD) PURE;
    STDMETHOD(GetForceFeedbackState)(THIS_ DWORD,LPDIDEVICESTATE) PURE;
    STDMETHOD(DownloadEffect)(THIS_ DWORD,DWORD,LPDWORD,LPCDIEFFECT,DWORD) PURE;
    STDMETHOD(DestroyEffect)(THIS_ DWORD,DWORD) PURE;
    STDMETHOD(StartEffect)(THIS_ DWORD,DWORD,DWORD,DWORD) PURE;
    STDMETHOD(StopEffect)(THIS_ DWORD,DWORD) PURE;
    STDMETHOD(GetEffectStatus)(THIS_ DWORD,DWORD,LPDWORD) PURE;
};

typedef struct IDirectInputEffectDriver *LPDIRECTINPUTEFFECTDRIVER;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputEffectDriver_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputEffectDriver_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputEffectDriver_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputEffectDriver_DeviceID(p,a,b,c,d,e) (p)->lpVtbl->DeviceID(p,a,b,c,d,e)
#define IDirectInputEffectDriver_GetVersions(p,a) (p)->lpVtbl->GetVersions(p,a)
#define IDirectInputEffectDriver_Escape(p,a,b,c) (p)->lpVtbl->Escape(p,a,b,c)
#define IDirectInputEffectDriver_SetGain(p,a,b) (p)->lpVtbl->SetGain(p,a,b)
#define IDirectInputEffectDriver_SendForceFeedbackCommand(p,a,b) (p)->lpVtbl->SendForceFeedbackCommand(p,a,b)
#define IDirectInputEffectDriver_GetForceFeedbackState(p,a,b) (p)->lpVtbl->GetForceFeedbackState(p,a,b)
#define IDirectInputEffectDriver_DownloadEffect(p,a,b,c,d,e) (p)->lpVtbl->DownloadEffect(p,a,b,c,d,e)
#define IDirectInputEffectDriver_DestroyEffect(p,a,b) (p)->lpVtbl->DestroyEffect(p,a,b)
#define IDirectInputEffectDriver_StartEffect(p,a,b,c,d) (p)->lpVtbl->StartEffect(p,a,b,c,d)
#define IDirectInputEffectDriver_StopEffect(p,a,b) (p)->lpVtbl->StopEffect(p,a,b)
#define IDirectInputEffectDriver_GetEffectStatus(p,a,b,c) (p)->lpVtbl->GetEffectStatus(p,a,b,c)
#else
#define IDirectInputEffectDriver_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputEffectDriver_AddRef(p) (p)->AddRef()
#define IDirectInputEffectDriver_Release(p) (p)->Release()
#define IDirectInputEffectDriver_DeviceID(p,a,b,c,d,e) (p)->DeviceID(a,b,c,d,e)
#define IDirectInputEffectDriver_GetVersions(p,a) (p)->GetVersions(a)
#define IDirectInputEffectDriver_Escape(p,a,b,c) (p)->Escape(a,b,c)
#define IDirectInputEffectDriver_SetGain(p,a,b) (p)->SetGain(a,b)
#define IDirectInputEffectDriver_SendForceFeedbackCommand(p,a,b) (p)->SendForceFeedbackCommand(a,b)
#define IDirectInputEffectDriver_GetForceFeedbackState(p,a,b) (p)->GetForceFeedbackState(a,b)
#define IDirectInputEffectDriver_DownloadEffect(p,a,b,c,d,e) (p)->DownloadEffect(a,b,c,d,e)
#define IDirectInputEffectDriver_DestroyEffect(p,a,b) (p)->DestroyEffect(a,b)
#define IDirectInputEffectDriver_StartEffect(p,a,b,c,d) (p)->StartEffect(a,b,c,d)
#define IDirectInputEffectDriver_StopEffect(p,a,b) (p)->StopEffect(a,b)
#define IDirectInputEffectDriver_GetEffectStatus(p,a,b,c) (p)->GetEffectStatus(a,b,c)
#endif


#endif /* DIJ_RINGZERO */


/****************************************************************************
 *
 *      IDirectInputJoyConfig
 *
 ****************************************************************************/

/****************************************************************************
 *
 *      Definitions copied from the DDK
 *
 ****************************************************************************/

#ifndef JOY_HW_NONE

/* pre-defined joystick types */
#define JOY_HW_NONE                     0
#define JOY_HW_CUSTOM                   1
#define JOY_HW_2A_2B_GENERIC            2
#define JOY_HW_2A_4B_GENERIC            3
#define JOY_HW_2B_GAMEPAD               4
#define JOY_HW_2B_FLIGHTYOKE            5
#define JOY_HW_2B_FLIGHTYOKETHROTTLE    6
#define JOY_HW_3A_2B_GENERIC            7
#define JOY_HW_3A_4B_GENERIC            8
#define JOY_HW_4B_GAMEPAD               9
#define JOY_HW_4B_FLIGHTYOKE            10
#define JOY_HW_4B_FLIGHTYOKETHROTTLE    11
#define JOY_HW_TWO_2A_2B_WITH_Y         12
#define JOY_HW_LASTENTRY                13


/* calibration flags */
#define JOY_ISCAL_XY            0x00000001l     /* XY are calibrated */
#define JOY_ISCAL_Z             0x00000002l     /* Z is calibrated */
#define JOY_ISCAL_R             0x00000004l     /* R is calibrated */
#define JOY_ISCAL_U             0x00000008l     /* U is calibrated */
#define JOY_ISCAL_V             0x00000010l     /* V is calibrated */
#define JOY_ISCAL_POV           0x00000020l     /* POV is calibrated */

/* point of view constants */
#define JOY_POV_NUMDIRS          4
#define JOY_POVVAL_FORWARD       0
#define JOY_POVVAL_BACKWARD      1
#define JOY_POVVAL_LEFT          2
#define JOY_POVVAL_RIGHT         3

/* Specific settings for joystick hardware */
#define JOY_HWS_HASZ            0x00000001l     /* has Z info? */
#define JOY_HWS_HASPOV          0x00000002l     /* point of view hat present */
#define JOY_HWS_POVISBUTTONCOMBOS 0x00000004l   /* pov done through combo of buttons */
#define JOY_HWS_POVISPOLL       0x00000008l     /* pov done through polling */
#define JOY_HWS_ISYOKE          0x00000010l     /* joystick is a flight yoke */
#define JOY_HWS_ISGAMEPAD       0x00000020l     /* joystick is a game pad */
#define JOY_HWS_ISCARCTRL       0x00000040l     /* joystick is a car controller */
/* X defaults to J1 X axis */
#define JOY_HWS_XISJ1Y          0x00000080l     /* X is on J1 Y axis */
#define JOY_HWS_XISJ2X          0x00000100l     /* X is on J2 X axis */
#define JOY_HWS_XISJ2Y          0x00000200l     /* X is on J2 Y axis */
/* Y defaults to J1 Y axis */
#define JOY_HWS_YISJ1X          0x00000400l     /* Y is on J1 X axis */
#define JOY_HWS_YISJ2X          0x00000800l     /* Y is on J2 X axis */
#define JOY_HWS_YISJ2Y          0x00001000l     /* Y is on J2 Y axis */
/* Z defaults to J2 Y axis */
#define JOY_HWS_ZISJ1X          0x00002000l     /* Z is on J1 X axis */
#define JOY_HWS_ZISJ1Y          0x00004000l     /* Z is on J1 Y axis */
#define JOY_HWS_ZISJ2X          0x00008000l     /* Z is on J2 X axis */
/* POV defaults to J2 Y axis, if it is not button based */
#define JOY_HWS_POVISJ1X        0x00010000l     /* pov done through J1 X axis */
#define JOY_HWS_POVISJ1Y        0x00020000l     /* pov done through J1 Y axis */
#define JOY_HWS_POVISJ2X        0x00040000l     /* pov done through J2 X axis */
/* R defaults to J2 X axis */
#define JOY_HWS_HASR            0x00080000l     /* has R (4th axis) info */
#define JOY_HWS_RISJ1X          0x00100000l     /* R done through J1 X axis */
#define JOY_HWS_RISJ1Y          0x00200000l     /* R done through J1 Y axis */
#define JOY_HWS_RISJ2Y          0x00400000l     /* R done through J2 X axis */
/* U & V for future hardware */
#define JOY_HWS_HASU            0x00800000l     /* has U (5th axis) info */
#define JOY_HWS_HASV            0x01000000l     /* has V (6th axis) info */

/* Usage settings */
#define JOY_US_HASRUDDER        0x00000001l     /* joystick configured with rudder */
#define JOY_US_PRESENT          0x00000002l     /* is joystick actually present? */
#define JOY_US_ISOEM            0x00000004l     /* joystick is an OEM defined type */

/* reserved for future use -> as link to next possible dword */
#define JOY_US_RESERVED         0x80000000l     /* reserved */


/* Settings for TypeInfo Flags1 */
#define JOYTYPE_ZEROGAMEENUMOEMDATA     0x00000001l /* Zero GameEnum's OEM data field */
#define JOYTYPE_NOAUTODETECTGAMEPORT    0x00000002l /* Device does not support Autodetect gameport*/
#define JOYTYPE_NOHIDDIRECT             0x00000004l /* Do not use HID directly for this device */
#define JOYTYPE_ANALOGCOMPAT            0x00000008l /* Expose the analog compatible ID */
#define JOYTYPE_DEFAULTPROPSHEET        0x80000000l /* CPL overrides custom property sheet */

/* Settings for TypeInfo Flags2 */
#define JOYTYPE_DEVICEHIDE              0x00010000l /* Hide unclassified devices */
#define JOYTYPE_MOUSEHIDE               0x00020000l /* Hide mice */
#define JOYTYPE_KEYBHIDE                0x00040000l /* Hide keyboards */
#define JOYTYPE_GAMEHIDE                0x00080000l /* Hide game controllers */
#define JOYTYPE_HIDEACTIVE              0x00100000l /* Hide flags are active */
#define JOYTYPE_INFOMASK                0x00E00000l /* Mask for type specific info */
#define JOYTYPE_INFODEFAULT             0x00000000l /* Use default axis mappings */
#define JOYTYPE_INFOYYPEDALS            0x00200000l /* Use Y as a combined pedals axis */
#define JOYTYPE_INFOZYPEDALS            0x00400000l /* Use Z for accelerate, Y for brake */
#define JOYTYPE_INFOYRPEDALS            0x00600000l /* Use Y for accelerate, R for brake */
#define JOYTYPE_INFOZRPEDALS            0x00800000l /* Use Z for accelerate, R for brake */
#define JOYTYPE_INFOZISSLIDER           0x00200000l /* Use Z as a slider */
#define JOYTYPE_INFOZISZ                0x00400000l /* Use Z as Z axis */
#define JOYTYPE_ENABLEINPUTREPORT       0x01000000l /* Enable initial input reports */

/* struct for storing x,y, z, and rudder values */
typedef struct joypos_tag {
    DWORD       dwX;
    DWORD       dwY;
    DWORD       dwZ;
    DWORD       dwR;
    DWORD       dwU;
    DWORD       dwV;
} JOYPOS, FAR *LPJOYPOS;

/* struct for storing ranges */
typedef struct joyrange_tag {
    JOYPOS      jpMin;
    JOYPOS      jpMax;
    JOYPOS      jpCenter;
} JOYRANGE,FAR *LPJOYRANGE;

/*
 *  dwTimeout - value at which to timeout joystick polling
 *  jrvRanges - range of values app wants returned for axes
 *  jpDeadZone - area around center to be considered
 *               as "dead". specified as a percentage
 *               (0-100). Only X & Y handled by system driver
 */
typedef struct joyreguservalues_tag {
    DWORD       dwTimeOut;
    JOYRANGE    jrvRanges;
    JOYPOS      jpDeadZone;
} JOYREGUSERVALUES, FAR *LPJOYREGUSERVALUES;

typedef struct joyreghwsettings_tag {
    DWORD       dwFlags;
    DWORD       dwNumButtons;
} JOYREGHWSETTINGS, FAR *LPJOYHWSETTINGS;

/* range of values returned by the hardware (filled in by calibration) */
/*
 *  jrvHardware - values returned by hardware
 *  dwPOVValues - POV values returned by hardware
 *  dwCalFlags  - what has been calibrated
 */
typedef struct joyreghwvalues_tag {
    JOYRANGE    jrvHardware;
    DWORD       dwPOVValues[JOY_POV_NUMDIRS];
    DWORD       dwCalFlags;
} JOYREGHWVALUES, FAR *LPJOYREGHWVALUES;

/* hardware configuration */
/*
 *  hws             - hardware settings
 *  dwUsageSettings - usage settings
 *  hwv             - values returned by hardware
 *  dwType          - type of joystick
 *  dwReserved      - reserved for OEM drivers
 */
typedef struct joyreghwconfig_tag {
    JOYREGHWSETTINGS    hws;
    DWORD               dwUsageSettings;
    JOYREGHWVALUES      hwv;
    DWORD               dwType;
    DWORD               dwReserved;
} JOYREGHWCONFIG, FAR *LPJOYREGHWCONFIG;

/* joystick calibration info structure */
typedef struct joycalibrate_tag {
    UINT    wXbase;
    UINT    wXdelta;
    UINT    wYbase;
    UINT    wYdelta;
    UINT    wZbase;
    UINT    wZdelta;
} JOYCALIBRATE;
typedef JOYCALIBRATE FAR *LPJOYCALIBRATE;

#endif

#ifndef DIJ_RINGZERO

#define MAX_JOYSTRING 256
typedef BOOL (FAR PASCAL * LPDIJOYTYPECALLBACK)(LPCWSTR, LPVOID);

#ifndef MAX_JOYSTICKOEMVXDNAME
#define MAX_JOYSTICKOEMVXDNAME 260
#endif

#define DITC_REGHWSETTINGS          0x00000001
#define DITC_CLSIDCONFIG            0x00000002
#define DITC_DISPLAYNAME            0x00000004
#define DITC_CALLOUT                0x00000008
#define DITC_HARDWAREID             0x00000010
#define DITC_FLAGS1                 0x00000020
#define DITC_FLAGS2                 0x00000040
#define DITC_MAPFILE                0x00000080



/* This structure is defined for DirectX 5.0 compatibility */

typedef struct DIJOYTYPEINFO_DX5 {
    DWORD dwSize;
    JOYREGHWSETTINGS hws;
    CLSID clsidConfig;
    WCHAR wszDisplayName[MAX_JOYSTRING];
    WCHAR wszCallout[MAX_JOYSTICKOEMVXDNAME];
} DIJOYTYPEINFO_DX5, *LPDIJOYTYPEINFO_DX5;
typedef const DIJOYTYPEINFO_DX5 *LPCDIJOYTYPEINFO_DX5;

/* This structure is defined for DirectX 6.1 compatibility */
typedef struct DIJOYTYPEINFO_DX6 {
    DWORD dwSize;
    JOYREGHWSETTINGS hws;
    CLSID clsidConfig;
    WCHAR wszDisplayName[MAX_JOYSTRING];
    WCHAR wszCallout[MAX_JOYSTICKOEMVXDNAME];
    WCHAR wszHardwareId[MAX_JOYSTRING];
    DWORD dwFlags1;
} DIJOYTYPEINFO_DX6, *LPDIJOYTYPEINFO_DX6;
typedef const DIJOYTYPEINFO_DX6 *LPCDIJOYTYPEINFO_DX6;

typedef struct DIJOYTYPEINFO {
    DWORD dwSize;
    JOYREGHWSETTINGS hws;
    CLSID clsidConfig;
    WCHAR wszDisplayName[MAX_JOYSTRING];
    WCHAR wszCallout[MAX_JOYSTICKOEMVXDNAME];
#if(DIRECTINPUT_VERSION >= 0x05b2)
    WCHAR wszHardwareId[MAX_JOYSTRING];
    DWORD dwFlags1;
#if(DIRECTINPUT_VERSION >= 0x0800)
    DWORD dwFlags2;
    WCHAR wszMapFile[MAX_JOYSTRING];
#endif /* DIRECTINPUT_VERSION >= 0x0800 */
#endif /* DIRECTINPUT_VERSION >= 0x05b2 */
} DIJOYTYPEINFO, *LPDIJOYTYPEINFO;
typedef const DIJOYTYPEINFO *LPCDIJOYTYPEINFO;
#define DIJC_GUIDINSTANCE           0x00000001
#define DIJC_REGHWCONFIGTYPE        0x00000002
#define DIJC_GAIN                   0x00000004
#define DIJC_CALLOUT                0x00000008
#define DIJC_WDMGAMEPORT            0x00000010

/* This structure is defined for DirectX 5.0 compatibility */

typedef struct DIJOYCONFIG_DX5 {
    DWORD dwSize;
    GUID guidInstance;
    JOYREGHWCONFIG hwc;
    DWORD dwGain;
    WCHAR wszType[MAX_JOYSTRING];
    WCHAR wszCallout[MAX_JOYSTRING];
} DIJOYCONFIG_DX5, *LPDIJOYCONFIG_DX5;
typedef const DIJOYCONFIG_DX5 *LPCDIJOYCONFIG_DX5;

typedef struct DIJOYCONFIG {
    DWORD dwSize;
    GUID guidInstance;
    JOYREGHWCONFIG hwc;
    DWORD dwGain;
    WCHAR wszType[MAX_JOYSTRING];
    WCHAR wszCallout[MAX_JOYSTRING];
#if(DIRECTINPUT_VERSION >= 0x05b2)
    GUID  guidGameport;
#endif /* DIRECTINPUT_VERSION >= 0x05b2 */
    } DIJOYCONFIG, *LPDIJOYCONFIG;
typedef const DIJOYCONFIG *LPCDIJOYCONFIG;


#define DIJU_USERVALUES             0x00000001
#define DIJU_GLOBALDRIVER           0x00000002
#define DIJU_GAMEPORTEMULATOR       0x00000004

typedef struct DIJOYUSERVALUES {
    DWORD dwSize;
    JOYREGUSERVALUES ruv;
    WCHAR wszGlobalDriver[MAX_JOYSTRING];
    WCHAR wszGameportEmulator[MAX_JOYSTRING];
} DIJOYUSERVALUES, *LPDIJOYUSERVALUES;
typedef const DIJOYUSERVALUES *LPCDIJOYUSERVALUES;

DEFINE_GUID(GUID_KeyboardClass, 0x4D36E96B,0xE325,0x11CE,0xBF,0xC1,0x08,0x00,0x2B,0xE1,0x03,0x18);
DEFINE_GUID(GUID_MediaClass,    0x4D36E96C,0xE325,0x11CE,0xBF,0xC1,0x08,0x00,0x2B,0xE1,0x03,0x18);
DEFINE_GUID(GUID_MouseClass,    0x4D36E96F,0xE325,0x11CE,0xBF,0xC1,0x08,0x00,0x2B,0xE1,0x03,0x18);
DEFINE_GUID(GUID_HIDClass,      0x745A17A0,0x74D3,0x11D0,0xB6,0xFE,0x00,0xA0,0xC9,0x0F,0x57,0xDA);

#undef INTERFACE
#define INTERFACE IDirectInputJoyConfig

DECLARE_INTERFACE_(IDirectInputJoyConfig, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputJoyConfig methods ***/
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(SendNotify)(THIS) PURE;
    STDMETHOD(EnumTypes)(THIS_ LPDIJOYTYPECALLBACK,LPVOID) PURE;
    STDMETHOD(GetTypeInfo)(THIS_ LPCWSTR,LPDIJOYTYPEINFO,DWORD) PURE;
    STDMETHOD(SetTypeInfo)(THIS_ LPCWSTR,LPCDIJOYTYPEINFO,DWORD) PURE;
    STDMETHOD(DeleteType)(THIS_ LPCWSTR) PURE;
    STDMETHOD(GetConfig)(THIS_ UINT,LPDIJOYCONFIG,DWORD) PURE;
    STDMETHOD(SetConfig)(THIS_ UINT,LPCDIJOYCONFIG,DWORD) PURE;
    STDMETHOD(DeleteConfig)(THIS_ UINT) PURE;
    STDMETHOD(GetUserValues)(THIS_ LPDIJOYUSERVALUES,DWORD) PURE;
    STDMETHOD(SetUserValues)(THIS_ LPCDIJOYUSERVALUES,DWORD) PURE;
    STDMETHOD(AddNewHardware)(THIS_ HWND,REFGUID) PURE;
    STDMETHOD(OpenTypeKey)(THIS_ LPCWSTR,DWORD,PHKEY) PURE;
    STDMETHOD(OpenConfigKey)(THIS_ UINT,DWORD,PHKEY) PURE;
};

typedef struct IDirectInputJoyConfig *LPDIRECTINPUTJOYCONFIG;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputJoyConfig_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputJoyConfig_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputJoyConfig_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputJoyConfig_Acquire(p) (p)->lpVtbl->Acquire(p)
#define IDirectInputJoyConfig_Unacquire(p) (p)->lpVtbl->Unacquire(p)
#define IDirectInputJoyConfig_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectInputJoyConfig_SendNotify(p) (p)->lpVtbl->SendNotify(p)
#define IDirectInputJoyConfig_EnumTypes(p,a,b) (p)->lpVtbl->EnumTypes(p,a,b)
#define IDirectInputJoyConfig_GetTypeInfo(p,a,b,c) (p)->lpVtbl->GetTypeInfo(p,a,b,c)
#define IDirectInputJoyConfig_SetTypeInfo(p,a,b,c) (p)->lpVtbl->SetTypeInfo(p,a,b,c)
#define IDirectInputJoyConfig_DeleteType(p,a) (p)->lpVtbl->DeleteType(p,a)
#define IDirectInputJoyConfig_GetConfig(p,a,b,c) (p)->lpVtbl->GetConfig(p,a,b,c)
#define IDirectInputJoyConfig_SetConfig(p,a,b,c) (p)->lpVtbl->SetConfig(p,a,b,c)
#define IDirectInputJoyConfig_DeleteConfig(p,a) (p)->lpVtbl->DeleteConfig(p,a)
#define IDirectInputJoyConfig_GetUserValues(p,a,b) (p)->lpVtbl->GetUserValues(p,a,b)
#define IDirectInputJoyConfig_SetUserValues(p,a,b) (p)->lpVtbl->SetUserValues(p,a,b)
#define IDirectInputJoyConfig_AddNewHardware(p,a,b) (p)->lpVtbl->AddNewHardware(p,a,b)
#define IDirectInputJoyConfig_OpenTypeKey(p,a,b,c) (p)->lpVtbl->OpenTypeKey(p,a,b,c)
#define IDirectInputJoyConfig_OpenConfigKey(p,a,b,c) (p)->lpVtbl->OpenConfigKey(p,a,b,c)
#else
#define IDirectInputJoyConfig_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputJoyConfig_AddRef(p) (p)->AddRef()
#define IDirectInputJoyConfig_Release(p) (p)->Release()
#define IDirectInputJoyConfig_Acquire(p) (p)->Acquire()
#define IDirectInputJoyConfig_Unacquire(p) (p)->Unacquire()
#define IDirectInputJoyConfig_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
#define IDirectInputJoyConfig_SendNotify(p) (p)->SendNotify()
#define IDirectInputJoyConfig_EnumTypes(p,a,b) (p)->EnumTypes(a,b)
#define IDirectInputJoyConfig_GetTypeInfo(p,a,b,c) (p)->GetTypeInfo(a,b,c)
#define IDirectInputJoyConfig_SetTypeInfo(p,a,b,c) (p)->SetTypeInfo(a,b,c)
#define IDirectInputJoyConfig_DeleteType(p,a) (p)->DeleteType(a)
#define IDirectInputJoyConfig_GetConfig(p,a,b,c) (p)->GetConfig(a,b,c)
#define IDirectInputJoyConfig_SetConfig(p,a,b,c) (p)->SetConfig(a,b,c)
#define IDirectInputJoyConfig_DeleteConfig(p,a) (p)->DeleteConfig(a)
#define IDirectInputJoyConfig_GetUserValues(p,a,b) (p)->GetUserValues(a,b)
#define IDirectInputJoyConfig_SetUserValues(p,a,b) (p)->SetUserValues(a,b)
#define IDirectInputJoyConfig_AddNewHardware(p,a,b) (p)->AddNewHardware(a,b)
#define IDirectInputJoyConfig_OpenTypeKey(p,a,b,c) (p)->OpenTypeKey(a,b,c)
#define IDirectInputJoyConfig_OpenConfigKey(p,a,b,c) (p)->OpenConfigKey(a,b,c)
#endif

#endif /* DIJ_RINGZERO */

#if(DIRECTINPUT_VERSION >= 0x0800)

#ifndef DIJ_RINGZERO

#undef INTERFACE
#define INTERFACE IDirectInputJoyConfig8

DECLARE_INTERFACE_(IDirectInputJoyConfig8, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputJoyConfig8 methods ***/
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(SendNotify)(THIS) PURE;
    STDMETHOD(EnumTypes)(THIS_ LPDIJOYTYPECALLBACK,LPVOID) PURE;
    STDMETHOD(GetTypeInfo)(THIS_ LPCWSTR,LPDIJOYTYPEINFO,DWORD) PURE;
    STDMETHOD(SetTypeInfo)(THIS_ LPCWSTR,LPCDIJOYTYPEINFO,DWORD,LPWSTR) PURE;
    STDMETHOD(DeleteType)(THIS_ LPCWSTR) PURE;
    STDMETHOD(GetConfig)(THIS_ UINT,LPDIJOYCONFIG,DWORD) PURE;
    STDMETHOD(SetConfig)(THIS_ UINT,LPCDIJOYCONFIG,DWORD) PURE;
    STDMETHOD(DeleteConfig)(THIS_ UINT) PURE;
    STDMETHOD(GetUserValues)(THIS_ LPDIJOYUSERVALUES,DWORD) PURE;
    STDMETHOD(SetUserValues)(THIS_ LPCDIJOYUSERVALUES,DWORD) PURE;
    STDMETHOD(AddNewHardware)(THIS_ HWND,REFGUID) PURE;
    STDMETHOD(OpenTypeKey)(THIS_ LPCWSTR,DWORD,PHKEY) PURE;
    STDMETHOD(OpenAppStatusKey)(THIS_ PHKEY) PURE;
};

typedef struct IDirectInputJoyConfig8 *LPDIRECTINPUTJOYCONFIG8;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputJoyConfig8_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputJoyConfig8_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputJoyConfig8_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputJoyConfig8_Acquire(p) (p)->lpVtbl->Acquire(p)
#define IDirectInputJoyConfig8_Unacquire(p) (p)->lpVtbl->Unacquire(p)
#define IDirectInputJoyConfig8_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectInputJoyConfig8_SendNotify(p) (p)->lpVtbl->SendNotify(p)
#define IDirectInputJoyConfig8_EnumTypes(p,a,b) (p)->lpVtbl->EnumTypes(p,a,b)
#define IDirectInputJoyConfig8_GetTypeInfo(p,a,b,c) (p)->lpVtbl->GetTypeInfo(p,a,b,c)
#define IDirectInputJoyConfig8_SetTypeInfo(p,a,b,c,d) (p)->lpVtbl->SetTypeInfo(p,a,b,c,d)
#define IDirectInputJoyConfig8_DeleteType(p,a) (p)->lpVtbl->DeleteType(p,a)
#define IDirectInputJoyConfig8_GetConfig(p,a,b,c) (p)->lpVtbl->GetConfig(p,a,b,c)
#define IDirectInputJoyConfig8_SetConfig(p,a,b,c) (p)->lpVtbl->SetConfig(p,a,b,c)
#define IDirectInputJoyConfig8_DeleteConfig(p,a) (p)->lpVtbl->DeleteConfig(p,a)
#define IDirectInputJoyConfig8_GetUserValues(p,a,b) (p)->lpVtbl->GetUserValues(p,a,b)
#define IDirectInputJoyConfig8_SetUserValues(p,a,b) (p)->lpVtbl->SetUserValues(p,a,b)
#define IDirectInputJoyConfig8_AddNewHardware(p,a,b) (p)->lpVtbl->AddNewHardware(p,a,b)
#define IDirectInputJoyConfig8_OpenTypeKey(p,a,b,c) (p)->lpVtbl->OpenTypeKey(p,a,b,c)
#define IDirectInputJoyConfig8_OpenAppStatusKey(p,a) (p)->lpVtbl->OpenAppStatusKey(p,a)
#else
#define IDirectInputJoyConfig8_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputJoyConfig8_AddRef(p) (p)->AddRef()
#define IDirectInputJoyConfig8_Release(p) (p)->Release()
#define IDirectInputJoyConfig8_Acquire(p) (p)->Acquire()
#define IDirectInputJoyConfig8_Unacquire(p) (p)->Unacquire()
#define IDirectInputJoyConfig8_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
#define IDirectInputJoyConfig8_SendNotify(p) (p)->SendNotify()
#define IDirectInputJoyConfig8_EnumTypes(p,a,b) (p)->EnumTypes(a,b)
#define IDirectInputJoyConfig8_GetTypeInfo(p,a,b,c) (p)->GetTypeInfo(a,b,c)
#define IDirectInputJoyConfig8_SetTypeInfo(p,a,b,c,d) (p)->SetTypeInfo(a,b,c,d)
#define IDirectInputJoyConfig8_DeleteType(p,a) (p)->DeleteType(a)
#define IDirectInputJoyConfig8_GetConfig(p,a,b,c) (p)->GetConfig(a,b,c)
#define IDirectInputJoyConfig8_SetConfig(p,a,b,c) (p)->SetConfig(a,b,c)
#define IDirectInputJoyConfig8_DeleteConfig(p,a) (p)->DeleteConfig(a)
#define IDirectInputJoyConfig8_GetUserValues(p,a,b) (p)->GetUserValues(a,b)
#define IDirectInputJoyConfig8_SetUserValues(p,a,b) (p)->SetUserValues(a,b)
#define IDirectInputJoyConfig8_AddNewHardware(p,a,b) (p)->AddNewHardware(a,b)
#define IDirectInputJoyConfig8_OpenTypeKey(p,a,b,c) (p)->OpenTypeKey(a,b,c)
#define IDirectInputJoyConfig8_OpenAppStatusKey(p,a) (p)->OpenAppStatusKey(a)
#endif

#endif /* DIJ_RINGZERO */

/****************************************************************************
 *
 *  Notification Messages
 *
 ****************************************************************************/

/* RegisterWindowMessage with this to get DirectInput notification messages */
#define DIRECTINPUT_NOTIFICATION_MSGSTRINGA  "DIRECTINPUT_NOTIFICATION_MSGSTRING"
#define DIRECTINPUT_NOTIFICATION_MSGSTRINGW  L"DIRECTINPUT_NOTIFICATION_MSGSTRING"

#ifdef UNICODE
#define DIRECTINPUT_NOTIFICATION_MSGSTRING  DIRECTINPUT_NOTIFICATION_MSGSTRINGW
#else
#define DIRECTINPUT_NOTIFICATION_MSGSTRING  DIRECTINPUT_NOTIFICATION_MSGSTRINGA
#endif

#define DIMSGWP_NEWAPPSTART         0x00000001
#define DIMSGWP_DX8APPSTART         0x00000002
#define DIMSGWP_DX8MAPPERAPPSTART   0x00000003

#endif /* DIRECTINPUT_VERSION >= 0x0800 */

#define DIAPPIDFLAG_NOTIME         0x00000001
#define DIAPPIDFLAG_NOSIZE         0x00000002

#define DIRECTINPUT_REGSTR_VAL_APPIDFLAGA   "AppIdFlag"
#define DIRECTINPUT_REGSTR_KEY_LASTAPPA     "MostRecentApplication"
#define DIRECTINPUT_REGSTR_KEY_LASTMAPAPPA  "MostRecentMapperApplication"
#define DIRECTINPUT_REGSTR_VAL_VERSIONA     "Version"
#define DIRECTINPUT_REGSTR_VAL_NAMEA        "Name"
#define DIRECTINPUT_REGSTR_VAL_IDA          "Id"
#define DIRECTINPUT_REGSTR_VAL_MAPPERA      "UsesMapper"
#define DIRECTINPUT_REGSTR_VAL_LASTSTARTA   "MostRecentStart"

#define DIRECTINPUT_REGSTR_VAL_APPIDFLAGW   L"AppIdFlag"
#define DIRECTINPUT_REGSTR_KEY_LASTAPPW     L"MostRecentApplication"
#define DIRECTINPUT_REGSTR_KEY_LASTMAPAPPW  L"MostRecentMapperApplication"
#define DIRECTINPUT_REGSTR_VAL_VERSIONW     L"Version"
#define DIRECTINPUT_REGSTR_VAL_NAMEW        L"Name"
#define DIRECTINPUT_REGSTR_VAL_IDW          L"Id"
#define DIRECTINPUT_REGSTR_VAL_MAPPERW      L"UsesMapper"
#define DIRECTINPUT_REGSTR_VAL_LASTSTARTW   L"MostRecentStart"

#ifdef UNICODE
#define DIRECTINPUT_REGSTR_VAL_APPIDFLAG    DIRECTINPUT_REGSTR_VAL_APPIDFLAGW
#define DIRECTINPUT_REGSTR_KEY_LASTAPP      DIRECTINPUT_REGSTR_KEY_LASTAPPW
#define DIRECTINPUT_REGSTR_KEY_LASTMAPAPP   DIRECTINPUT_REGSTR_KEY_LASTMAPAPPW
#define DIRECTINPUT_REGSTR_VAL_VERSION      DIRECTINPUT_REGSTR_VAL_VERSIONW
#define DIRECTINPUT_REGSTR_VAL_NAME         DIRECTINPUT_REGSTR_VAL_NAMEW
#define DIRECTINPUT_REGSTR_VAL_ID           DIRECTINPUT_REGSTR_VAL_IDW
#define DIRECTINPUT_REGSTR_VAL_MAPPER       DIRECTINPUT_REGSTR_VAL_MAPPERW
#define DIRECTINPUT_REGSTR_VAL_LASTSTART    DIRECTINPUT_REGSTR_VAL_LASTSTARTW
#else
#define DIRECTINPUT_REGSTR_VAL_APPIDFLAG    DIRECTINPUT_REGSTR_VAL_APPIDFLAGA
#define DIRECTINPUT_REGSTR_KEY_LASTAPP      DIRECTINPUT_REGSTR_KEY_LASTAPPA
#define DIRECTINPUT_REGSTR_KEY_LASTMAPAPP   DIRECTINPUT_REGSTR_KEY_LASTMAPAPPA
#define DIRECTINPUT_REGSTR_VAL_VERSION      DIRECTINPUT_REGSTR_VAL_VERSIONA
#define DIRECTINPUT_REGSTR_VAL_NAME         DIRECTINPUT_REGSTR_VAL_NAMEA
#define DIRECTINPUT_REGSTR_VAL_ID           DIRECTINPUT_REGSTR_VAL_IDA
#define DIRECTINPUT_REGSTR_VAL_MAPPER       DIRECTINPUT_REGSTR_VAL_MAPPERA
#define DIRECTINPUT_REGSTR_VAL_LASTSTART    DIRECTINPUT_REGSTR_VAL_LASTSTARTA
#endif


/****************************************************************************
 *
 *  Return Codes
 *
 ****************************************************************************/

#define DIERR_NOMOREITEMS               \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_NO_MORE_ITEMS)

/*
 *  Device driver-specific codes.
 */

#define DIERR_DRIVERFIRST               0x80040300L
#define DIERR_DRIVERLAST                0x800403FFL

/*
 *  Unless the specific driver has been precisely identified, no meaning 
 *  should be attributed to these values other than that the driver 
 *  originated the error.  However, to illustrate the types of error that 
 *  may be causing the failure, the PID force feedback driver distributed 
 *  with DirectX 7 could return the following errors:
 *
 *  DIERR_DRIVERFIRST + 1   
 *      The requested usage was not found.
 *  DIERR_DRIVERFIRST + 2   
 *      The parameter block couldn't be	downloaded to the device.
 *  DIERR_DRIVERFIRST + 3   
 *      PID initialization failed.
 *  DIERR_DRIVERFIRST + 4   
 *      The provided values couldn't be scaled.
 */


/*
 *  Device installer errors.
 */

/*
 *  Registry entry or DLL for class installer invalid
 *  or class installer not found.
 */
#define DIERR_INVALIDCLASSINSTALLER     0x80040400L

/*
 *  The user cancelled the install operation.
 */
#define DIERR_CANCELLED                 0x80040401L

/*
 *  The INF file for the selected device could not be
 *  found or is invalid or is damaged.
 */
#define DIERR_BADINF                    0x80040402L

/****************************************************************************
 *
 *  Map files
 *
 ****************************************************************************/

/*
 *  Delete particular data from default map file.
 */
#define DIDIFT_DELETE                   0x01000000

#ifdef __cplusplus
};
#endif

#endif  /* __DINPUTD_INCLUDED__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Dispdib.h ===
/****************************************************************************/
/*                                                                          */
/*        DISPDIB.H - Include file for DisplayDib() function.               */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1999, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/

#ifndef __DISPDIB_H__
#define __DISPDIB_H__

// DisplayDib() error return codes
#define DISPLAYDIB_NOERROR          0x0000  // success
#define DISPLAYDIB_NOTSUPPORTED     0x0001  // function not supported
#define DISPLAYDIB_INVALIDDIB       0x0002  // null or invalid DIB header
#define DISPLAYDIB_INVALIDFORMAT    0x0003  // invalid DIB format
#define DISPLAYDIB_INVALIDTASK      0x0004  // not called from current task
#define DISPLAYDIB_STOP             0x0005  // stop requested
#define DISPLAYDIB_NOTACTIVE	    0x0006  // DisplayDibWindow not foreground
#define DISPLAYDIB_BADSIZE          0x0007  //

// flags for <wFlags> parameter of DisplayDib()
#define DISPLAYDIB_NOPALETTE        0x0010  // don't set palette
#define DISPLAYDIB_NOCENTER         0x0020  // don't center image
#define DISPLAYDIB_NOWAIT           0x0040  // don't wait before returning
#define DISPLAYDIB_NOIMAGE          0x0080  // don't draw image
#define DISPLAYDIB_ZOOM2            0x0100  // stretch by 2
#define DISPLAYDIB_DONTLOCKTASK     0x0200  // don't lock current task
#define DISPLAYDIB_TEST             0x0400  // testing the command
#define DISPLAYDIB_NOFLIP           0x0800  // dont page flip
#define DISPLAYDIB_BEGIN            0x8000  // start of multiple calls
#define DISPLAYDIB_END              0x4000  // end of multiple calls

#define DISPLAYDIB_MODE             0x000F  // mask for display mode
#define DISPLAYDIB_MODE_DEFAULT     0x0000  // default display mode
#define DISPLAYDIB_MODE_320x200x8   0x0001  // 320-by-200
#define DISPLAYDIB_MODE_320x240x8   0x0005  // 320-by-240

//
// a Win32 app must use the window class the function
// versions are not available
//
#ifndef _WIN32

// function prototypes
UINT FAR PASCAL DisplayDib(LPBITMAPINFOHEADER lpbi, LPSTR lpBits, WORD wFlags);
UINT FAR PASCAL DisplayDibEx(LPBITMAPINFOHEADER lpbi, int x, int y, LPSTR lpBits, WORD wFlags);

#define DisplayDibBegin() DisplayDib(NULL, NULL, DISPLAYDIB_BEGIN|DISPDIB_NOWAIT)
#define DisplayDibEnd()   DisplayDib(NULL, NULL, DISPLAYDIB_END|DISPDIB_NOWAIT)

#endif

//
//  DisplayDibWindow class.
//
//  simple interface to DISPDIB as a window class.
//  draw images and create a fullscreen window in one easy step.
//
//  advantages over calling the APIs directly.
//
//      if you show the window it will handle enabling/disabling
//      fullscreen mode when it has a activation.
//
//      while in fullscreen mode, window will be sized to
//      cover entire display preventing other apps from getting
//      clicked on. (when visible)
//
//      if window looses activation, fullscreen mode will be disabled
//      DDM_DRAW will return DISPLAYDIB_NOTACTIVE if you try to draw
//
//      forwards all mouse and keyboard events to owner, easy way
//      to take over entire screen.
//
//      alows interop with a Win32 application (via WM_COPYDATA)
//      NOTE WM_COPYDATA does not actualy copy anything if the
//      window belongs to the calling thread.  it will do a copy
//      if the window is owned by another thread....
//
//  you can use a DisplayDibWindow in two ways.....
//
//      hidden window
//
//          if the window is hidden, you must use the
//          DDM_BEGIN and DDM_END message to enable/disable
//          fullscreen mode manualy when your app is activated deactivated.
//
//      visible toplevel window
//
//          if you show the window it will take over the entire screen
//          and forward all mouse/keyboard input to its owner.
//
//          it will enter fullscreen automaticly when it is shown.
//
//          it will leave fullscreen and hide it self it another app
//          grabs the focus.
//
//  class name:     "DisplayDibWindow"
//                  class is registered when DISPDIB.DLL is loaded.
//                  as a global class.
//
//  messages:
//
//      DDM_SETFMT  set new DIB format or program a new palette
//
//		    fullscreen mode, will use best mode
//                  for displaying the passed DIB format.
//		    defaul is 320x240x8 tripple buffered
//
//                  the palette will be programed with the color
//                  table of the passed BITMAPINFOHEADER.
//
//                  the format is a BITMAPINFOHEADER followed by a color table.
//
//                  you must set a format before doing a begin, end or draw
//                  you can set a 320x200 or a 320x24 mode by selecting
//                  a DIB of the format you want.
//
//                  if you do a setfmt while fullscreen mode is active only the
//                  the palette will be changed the new size (if any) wont
//                  happen until the next begin.
//
//	    wParam = 0
//          lParam = LPBITMAPINFOHEADER
//
//          returns 0 if success else DISPLAYDIB_* error code.
//
//      DDM_DRAW    draws DIB data to fullscreen
//                  format is assumed the same as format passed to
//                  DDM_BEGIN or DDM_FMT
//
//          wParam = flags
//          lParam = bits pointer.
//
//          returns 0 if success else DISPLAYDIB_* error code.
//
//      DDM_CLOSE   destroy window *and* free the DLL
//
//      DDM_BEGIN   enter DISPDIB mode.
//          wParam = flags
//          lParam = 0
//
//          returns 0 if success else DISPLAYDIB_* error code.
//
//      DDM_END     leave DISPDIB mode.
//          wParam = flags
//          lParam = 0
//
//          returns 0 if success else DISPLAYDIB_* error code.
//
//      WM_COPYDATA allows a Win32 app to send a DDM_ message, that requires
//      a pointer.
//
//          wParam = hwnd of sender
//          lParam = PCOPYDATASTRUCT
//                  dwData      - LOWORD: DDM_* message value.
//                  dwData      - HIWORD: wParam for message
//                  lpData      - lParam (pointer to a BITMAPINFOHEADER or bits)
//                  cbData      - size of data
//
//          returns   0 if success else DISPLAYDIB_* error code.
//

#define DISPLAYDIB_WINDOW_CLASS     "DisplayDibWindow"
#define DISPLAYDIB_DLL              "DISPDIB.DLL"

#define DDM_SETFMT      WM_USER+0
#define DDM_DRAW        WM_USER+1
#define DDM_CLOSE       WM_USER+2
#define DDM_BEGIN       WM_USER+3
#define DDM_END         WM_USER+4

//
// inline function to send a message to a DisplayDibWindow
//
__inline UINT DisplayDibWindowMessage(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, DWORD cbSize)
{
#if defined(_WIN32) || defined(WIN32)
        COPYDATASTRUCT cds;
        cds.dwData = MAKELONG(msg, wParam);
        cds.cbData = lParam ? cbSize : 0;
        cds.lpData = (LPVOID)lParam;
        return (UINT)SendMessage(hwnd, WM_COPYDATA, (WPARAM)(HWND)NULL, (LPARAM)(LPVOID)&cds);
#else
        return (UINT)SendMessage(hwnd, msg, wParam, lParam);
#endif
}

//
// inline function to create a DisplayDibWindow
//
__inline HWND DisplayDibWindowCreateEx(HWND hwndParent, HINSTANCE hInstance, DWORD dwStyle)
{
#if defined(_WIN32) || defined(WIN32)
    DWORD show = 2;
    DWORD zero = 0;
    LPVOID params[4] = {NULL, &zero, &show, 0};

    if ((UINT)LoadModule(DISPLAYDIB_DLL, &params) < (UINT)HINSTANCE_ERROR)
        return NULL;    // loading DISPDIB did not work
#else
    if ((UINT)LoadLibrary(DISPLAYDIB_DLL) < (UINT)HINSTANCE_ERROR)
        return NULL;    // loading DISPDIB did not work
#endif

    return CreateWindow(DISPLAYDIB_WINDOW_CLASS,"",dwStyle,0, 0,
            GetSystemMetrics(SM_CXSCREEN),GetSystemMetrics(SM_CYSCREEN),
            hwndParent, NULL,
            (hInstance ? hInstance : GetWindowInstance(hwndParent)), NULL);
}

//
//  helper macros for a DisplayDibWindow
//
//  DisplayDibWindowCreate
//
//      used to create a toplevel WS_POPUP window.
//
//  DisplayDibWindowCreateEx
//
//      used to create a non-toplevel window, of a custom style.
//
//  DisplayDibWindowSetFmt
//
//      macro to send the DDM_SETFMT message.
//
//  DisplayDibWindowDraw
//
//      macro to send the DDM_DRAW message
//
//  DisplayDibWindowBegin
//
//      macro used to show the window
//
//  DisplayDibWindowEnd
//
//      macro used to hide the window
//
//  DisplayDibWindowBeginEx
//
//      macro used to send a DDM_BEGIN message, used with hidden windows
//
//  DisplayDibWindowEndEx
//
//      macro used to send a DDM_END message, used with hidden windows
//
//  DisplayDibWindowClose
//
//      macro used to send a DDM_CLOSE message
//      this will destroy the window and free the DLL.
//
//  NOTES
//      warning DisplayDibWindowBegin/End will show the DisplayDibWindow
//      this will steal actiation away from your app. all mouse keyboard
//      input will go to the dispdib window and it will forward it to
//      its owner (make sure you set the right owner on create)
//
//      this may cause a problem for your app, you can keep the window
//      hidden be using the DDM_BEGIN/END messages in this case.
//
#define DisplayDibWindowCreate(hwndP, hInstance)        DisplayDibWindowCreateEx(hwndP, hInstance, WS_POPUP)
#define DisplayDibWindowSetFmt(hwnd, lpbi)              DisplayDibWindowMessage(hwnd, DDM_SETFMT, 0, (LPARAM)(LPVOID)(lpbi), sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD))
#define DisplayDibWindowDraw(hwnd, flags, bits, size)   DisplayDibWindowMessage(hwnd, DDM_DRAW, (WPARAM)(UINT)(flags), (LPARAM)(LPVOID)(bits), (DWORD)(size))

#ifdef __cplusplus
#define DisplayDibWindowBegin(hwnd)                     ::ShowWindow(hwnd, SW_SHOWNORMAL)
#define DisplayDibWindowEnd(hwnd)                       ::ShowWindow(hwnd, SW_HIDE)
#define DisplayDibWindowBeginEx(hwnd, f)                ::SendMessage(hwnd, DDM_BEGIN, (WPARAM)(UINT)(f), 0)
#define DisplayDibWindowEndEx(hwnd)                     ::SendMessage(hwnd, DDM_END, 0, 0)
#define DisplayDibWindowClose(hwnd)                     ::SendMessage(hwnd, DDM_CLOSE, 0, 0)
#else
#define DisplayDibWindowBegin(hwnd)                     ShowWindow(hwnd, SW_SHOWNORMAL)
#define DisplayDibWindowEnd(hwnd)                       ShowWindow(hwnd, SW_HIDE)
#define DisplayDibWindowBeginEx(hwnd)                   SendMessage(hwnd, DDM_BEGIN, 0, 0)
#define DisplayDibWindowEndEx(hwnd)                     SendMessage(hwnd, DDM_END, 0, 0)
#define DisplayDibWindowClose(hwnd)                     SendMessage(hwnd, DDM_CLOSE, 0, 0)
#endif

#endif // _DISPDIB_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\diskguid.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    diskguid.h

Abstract:

    GPT disk GUIDs.

Revision History:

--*/

//
// GPT Partition Type GUIDs
//
// need these GUIDs outside conditional includes so that user can
//   #include <ntdddisk.h> in precompiled header
//   #include <initguid.h> in a single source file
//   #include <ntdddisk.h> in that source file a second time to instantiate the GUIDs
//

#ifdef DEFINE_GUID

//
// Make sure FAR is defined...
//
#ifndef FAR
#ifdef _WIN32
#define FAR
#else
#define FAR _far
#endif
#endif


//
// Define the GPT partition guids known by disk drivers and volume managers.
//

DEFINE_GUID(PARTITION_ENTRY_UNUSED_GUID,   0x00000000L, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);    // Entry unused
DEFINE_GUID(PARTITION_SYSTEM_GUID,         0xC12A7328L, 0xF81F, 0x11D2, 0xBA, 0x4B, 0x00, 0xA0, 0xC9, 0x3E, 0xC9, 0x3B);    // EFI system partition
DEFINE_GUID(PARTITION_MSFT_RESERVED_GUID,  0xE3C9E316L, 0x0B5C, 0x4DB8, 0x81, 0x7D, 0xF9, 0x2D, 0xF0, 0x02, 0x15, 0xAE);    // Microsoft reserved space                                        
DEFINE_GUID(PARTITION_BASIC_DATA_GUID,     0xEBD0A0A2L, 0xB9E5, 0x4433, 0x87, 0xC0, 0x68, 0xB6, 0xB7, 0x26, 0x99, 0xC7);    // Basic data partition
DEFINE_GUID(PARTITION_LDM_METADATA_GUID,   0x5808C8AAL, 0x7E8F, 0x42E0, 0x85, 0xD2, 0xE1, 0xE9, 0x04, 0x34, 0xCF, 0xB3);    // Logical Disk Manager metadata partition
DEFINE_GUID(PARTITION_LDM_DATA_GUID,       0xAF9B60A0L, 0x1431, 0x4F62, 0xBC, 0x68, 0x33, 0x11, 0x71, 0x4A, 0x69, 0xAD);    // Logical Disk Manager data partition
DEFINE_GUID(PARTITION_MSFT_RECOVERY_GUID,  0xDE94BBA4L, 0x06D1, 0x4D40, 0xA1, 0x6A, 0xBF, 0xD5, 0x01, 0x79, 0xD6, 0xAC);    // Microsoft recovery partition
DEFINE_GUID(PARTITION_CLUSTER_GUID, 	   0xdb97dba9L, 0x0840, 0x4bae, 0x97, 0xf0, 0xff, 0xb9, 0xa3, 0x27, 0xc7, 0xe1);    // Cluster metadata partition
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Dlgs.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    dlgs.h

Abstract:

    This module contains the UI dialog header information.

--*/

#pragma once

#ifndef _DLGSH_INCLUDED_
#define _DLGSH_INCLUDED_


//
//  Constant Declarations.
//

#define ctlFirst    0x0400
#define ctlLast     0x04ff

//
//  Push buttons.
//
#define psh1        0x0400
#define psh2        0x0401
#define psh3        0x0402
#define psh4        0x0403
#define psh5        0x0404
#define psh6        0x0405
#define psh7        0x0406
#define psh8        0x0407
#define psh9        0x0408
#define psh10       0x0409
#define psh11       0x040a
#define psh12       0x040b
#define psh13       0x040c
#define psh14       0x040d
#define psh15       0x040e
#define pshHelp     psh15
#define psh16       0x040f

//
//  Checkboxes.
//
#define chx1        0x0410
#define chx2        0x0411
#define chx3        0x0412
#define chx4        0x0413
#define chx5        0x0414
#define chx6        0x0415
#define chx7        0x0416
#define chx8        0x0417
#define chx9        0x0418
#define chx10       0x0419
#define chx11       0x041a
#define chx12       0x041b
#define chx13       0x041c
#define chx14       0x041d
#define chx15       0x041e
#define chx16       0x041f

//
//  Radio buttons.
//
#define rad1        0x0420
#define rad2        0x0421
#define rad3        0x0422
#define rad4        0x0423
#define rad5        0x0424
#define rad6        0x0425
#define rad7        0x0426
#define rad8        0x0427
#define rad9        0x0428
#define rad10       0x0429
#define rad11       0x042a
#define rad12       0x042b
#define rad13       0x042c
#define rad14       0x042d
#define rad15       0x042e
#define rad16       0x042f

//
//  Groups, frames, rectangles, and icons.
//
#define grp1        0x0430
#define grp2        0x0431
#define grp3        0x0432
#define grp4        0x0433
#define frm1        0x0434
#define frm2        0x0435
#define frm3        0x0436
#define frm4        0x0437
#define rct1        0x0438
#define rct2        0x0439
#define rct3        0x043a
#define rct4        0x043b
#define ico1        0x043c
#define ico2        0x043d
#define ico3        0x043e
#define ico4        0x043f

//
//  Static text.
//
#define stc1        0x0440
#define stc2        0x0441
#define stc3        0x0442
#define stc4        0x0443
#define stc5        0x0444
#define stc6        0x0445
#define stc7        0x0446
#define stc8        0x0447
#define stc9        0x0448
#define stc10       0x0449
#define stc11       0x044a
#define stc12       0x044b
#define stc13       0x044c
#define stc14       0x044d
#define stc15       0x044e
#define stc16       0x044f
#define stc17       0x0450
#define stc18       0x0451
#define stc19       0x0452
#define stc20       0x0453
#define stc21       0x0454
#define stc22       0x0455
#define stc23       0x0456
#define stc24       0x0457
#define stc25       0x0458
#define stc26       0x0459
#define stc27       0x045a
#define stc28       0x045b
#define stc29       0x045c
#define stc30       0x045d
#define stc31       0x045e
#define stc32       0x045f

//
//  Listboxes.
//
#define lst1        0x0460
#define lst2        0x0461
#define lst3        0x0462
#define lst4        0x0463
#define lst5        0x0464
#define lst6        0x0465
#define lst7        0x0466
#define lst8        0x0467
#define lst9        0x0468
#define lst10       0x0469
#define lst11       0x046a
#define lst12       0x046b
#define lst13       0x046c
#define lst14       0x046d
#define lst15       0x046e
#define lst16       0x046f

//
//  Combo boxes.
//
#define cmb1        0x0470
#define cmb2        0x0471
#define cmb3        0x0472
#define cmb4        0x0473
#define cmb5        0x0474
#define cmb6        0x0475
#define cmb7        0x0476
#define cmb8        0x0477
#define cmb9        0x0478
#define cmb10       0x0479
#define cmb11       0x047a
#define cmb12       0x047b
#define cmb13       0x047c
#define cmb14       0x047d
#define cmb15       0x047e
#define cmb16       0x047f

//
//  Edit controls.
//
#define edt1        0x0480
#define edt2        0x0481
#define edt3        0x0482
#define edt4        0x0483
#define edt5        0x0484
#define edt6        0x0485
#define edt7        0x0486
#define edt8        0x0487
#define edt9        0x0488
#define edt10       0x0489
#define edt11       0x048a
#define edt12       0x048b
#define edt13       0x048c
#define edt14       0x048d
#define edt15       0x048e
#define edt16       0x048f

//
//  Scroll bars.
//
#define scr1        0x0490
#define scr2        0x0491
#define scr3        0x0492
#define scr4        0x0493
#define scr5        0x0494
#define scr6        0x0495
#define scr7        0x0496
#define scr8        0x0497

//
//  Controls
//
#define ctl1        0x04A0

#define FILEOPENORD             1536
#define MULTIFILEOPENORD        1537
#define PRINTDLGORD             1538
#define PRNSETUPDLGORD          1539
#define FINDDLGORD              1540
#define REPLACEDLGORD           1541
#define FONTDLGORD              1542
#define FORMATDLGORD31          1543
#define FORMATDLGORD30          1544
#define RUNDLGORD               1545

#if (WINVER >= 0x400)
#define PAGESETUPDLGORD         1546
#define NEWFILEOPENORD          1547
#define PRINTDLGEXORD           1549
#define PAGESETUPDLGORDMOTIF    1550
#define COLORMGMTDLGORD         1551
#define NEWFILEOPENV2ORD        1552
#endif /* WINVER >= 0x400) */

// 1581 - 1590
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define NEWFILEOPENV3ORD        1553
#endif // NTDDI_VISTA

// 1591 - 1600
#if (NTDDI_VERSION >= NTDDI_WIN7)
#define NEWFORMATDLGWITHLINK    1591
#define IDC_MANAGE_LINK         1592
#endif

//
//  Typedef Declarations.
//
typedef struct tagCRGB
{
    BYTE    bRed;
    BYTE    bGreen;
    BYTE    bBlue;
    BYTE    bExtra;
} CRGB;           /* RGB Color */


#endif // _DLGSH_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dls2.h ===
/*

 	dls2.h

 	Description:

 	Interface defines and structures for the DLS2 extensions of DLS.


     Written by Microsoft 1998.  Released for public use.

*/

#ifndef _INC_DLS2
#define _INC_DLS2

/*
     FOURCC's used in the DLS2 file, in addition to DLS1 chunks
*/

#define FOURCC_RGN2  mmioFOURCC('r','g','n','2')
#define FOURCC_LAR2  mmioFOURCC('l','a','r','2')
#define FOURCC_ART2  mmioFOURCC('a','r','t','2')
#define FOURCC_CDL   mmioFOURCC('c','d','l',' ')
#define FOURCC_DLID  mmioFOURCC('d','l','i','d')

/*
     Articulation connection graph definitions. These are in addition to
     the definitions in the DLS1 header.
*/

/* Generic Sources (in addition to DLS1 sources. */
#define CONN_SRC_POLYPRESSURE		0x0007	/* Polyphonic Pressure */
#define CONN_SRC_CHANNELPRESSURE		0x0008	/* Channel Pressure */
#define CONN_SRC_VIBRATO			0x0009	/* Vibrato LFO */
#define CONN_SRC_MONOPRESSURE       	0x000a  /* MIDI Mono pressure */


/* Midi Controllers */
#define CONN_SRC_CC91			0x00db	/* Reverb Send */
#define CONN_SRC_CC93			0x00dd	/* Chorus Send */


/* Generic Destinations */
#define CONN_DST_GAIN			0x0001	/* Same as CONN_DST_ ATTENUATION, but more appropriate terminology. */
#define CONN_DST_KEYNUMBER 0x0005  /* Key Number Generator */

/* Audio Channel Output Destinations */
#define CONN_DST_LEFT			0x0010	/* Left Channel Send */
#define CONN_DST_RIGHT			0x0011	/* Right Channel Send */
#define CONN_DST_CENTER			0x0012	/* Center Channel Send */
#define CONN_DST_LEFTREAR			0x0013	/* Left Rear Channel Send */
#define CONN_DST_RIGHTREAR			0x0014	/* Right Rear Channel Send */
#define CONN_DST_LFE_CHANNEL		0x0015	/* LFE Channel Send */
#define CONN_DST_CHORUS			0x0080	/* Chorus Send */
#define CONN_DST_REVERB			0x0081	/* Reverb Send */

/* Vibrato LFO Destinations */
#define CONN_DST_VIB_FREQUENCY		0x0114	/* Vibrato Frequency */
#define CONN_DST_VIB_STARTDELAY		0x0115	/* Vibrato Start Delay */

/* EG1 Destinations */
#define CONN_DST_EG1_DELAYTIME		0x020B	/* EG1 Delay Time */
#define CONN_DST_EG1_HOLDTIME		0x020C	/* EG1 Hold Time */
#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */
#define CONN_DST_EG1_SHUTDOWNTIME	0x020D	/* EG1 Shutdown Time */
#endif

/* EG2 Destinations */
#define CONN_DST_EG2_DELAYTIME		0x030F	/* EG2 Delay Time */
#define CONN_DST_EG2_HOLDTIME		0x0310	/* EG2 Hold Time */


/* Filter Destinations */
#define CONN_DST_FILTER_CUTOFF		0x0500	/* Filter Cutoff Frequency */
#define CONN_DST_FILTER_Q			0x0501	/* Filter Resonance */


/* Transforms */
#define CONN_TRN_CONVEX			0x0002	/* Convex Transform */
#define CONN_TRN_SWITCH			0x0003	/* Switch Transform */


/*	Conditional chunk operators */
 #define DLS_CDL_AND			0x0001	/* X = X & Y */
 #define DLS_CDL_OR			0x0002	/* X = X | Y */
 #define DLS_CDL_XOR			0x0003	/* X = X ^ Y */
 #define DLS_CDL_ADD			0x0004	/* X = X + Y */
 #define DLS_CDL_SUBTRACT		0x0005	/* X = X - Y */
 #define DLS_CDL_MULTIPLY		0x0006	/* X = X * Y */
 #define DLS_CDL_DIVIDE		0x0007	/* X = X / Y */
 #define DLS_CDL_LOGICAL_AND	0x0008	/* X = X && Y */
 #define DLS_CDL_LOGICAL_OR		0x0009	/* X = X || Y */
 #define DLS_CDL_LT			0x000A	/* X = (X < Y) */
 #define DLS_CDL_LE			0x000B	/* X = (X <= Y) */
 #define DLS_CDL_GT			0x000C	/* X = (X > Y) */
 #define DLS_CDL_GE			0x000D	/* X = (X >= Y) */
 #define DLS_CDL_EQ			0x000E	/* X = (X == Y) */
 #define DLS_CDL_NOT			0x000F	/* X = !X */
 #define DLS_CDL_CONST		0x0010	/* 32-bit constant */
 #define DLS_CDL_QUERY		0x0011	/* 32-bit value returned from query */
 #define DLS_CDL_QUERYSUPPORTED	0x0012	/* Test to see if query is supported by synth */

/*
  Loop and release
*/

#if (NTDDI_VERSION < NTDDI_WINXP) /* Windows 2000 and SPs */
#define WLOOP_TYPE_RELEASE 2
#else
#define WLOOP_TYPE_RELEASE 1
#endif

/*
  WaveLink chunk <wlnk-ck>
*/

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */
#define F_WAVELINK_MULTICHANNEL 0x0002
#endif

/*
  WaveLink chunk <wlnk-ck>
*/

#define F_WAVELINK_MULTICHANNEL 0x0002


/*
  DLSID queries for <cdl-ck>
*/

DEFINE_GUID(DLSID_GMInHardware, 0x178f2f24, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(DLSID_GSInHardware, 0x178f2f25, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(DLSID_XGInHardware, 0x178f2f26, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(DLSID_SupportsDLS1, 0x178f2f27, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(DLSID_SupportsDLS2, 0xf14599e5, 0x4689, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(DLSID_SampleMemorySize, 0x178f2f28, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(DLSID_ManufacturersID, 0xb03e1181, 0x8095, 0x11d2, 0xa1, 0xef, 0x0, 0x60, 0x8, 0x33, 0xdb, 0xd8);
DEFINE_GUID(DLSID_ProductID, 0xb03e1182, 0x8095, 0x11d2, 0xa1, 0xef, 0x0, 0x60, 0x8, 0x33, 0xdb, 0xd8);
DEFINE_GUID(DLSID_SamplePlaybackRate, 0x2a91f713, 0xa4bf, 0x11d2, 0xbb, 0xdf, 0x0, 0x60, 0x8, 0x33, 0xdb, 0xd8);

#endif /* _INC_DLS2 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dmdls.h ===
/************************************************************************
*                                                                       *
*   dmdls.h -- DLS download definitions for DirectMusic API's           *
*                                                                       *
*   Copyright (c) Microsoft Corporation.  All rights reserved.          *
*                                                                       *
************************************************************************/

#ifndef _DMDLS_
#define _DMDLS_

#include "dls1.h"

typedef long PCENT;     /* Pitch cents */
typedef long GCENT;     /* Gain cents */
typedef long TCENT;     /* Time cents */
typedef long PERCENT;   /* Per.. cent! */

typedef LONGLONG REFERENCE_TIME;
typedef REFERENCE_TIME *LPREFERENCE_TIME;
typedef long            MUSIC_TIME;

#ifndef MAKEFOURCC
#define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
                ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |   \
                ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ))


typedef DWORD           FOURCC;         /* a four character code */
#endif

typedef struct _DMUS_DOWNLOADINFO
{
    DWORD dwDLType;                     /* Instrument or Wave */
    DWORD dwDLId;                       /* Unique identifier to tag this download. */
    DWORD dwNumOffsetTableEntries;      /* Number of index in the offset address table. */
    DWORD cbSize;                       /* Total size of this memory chunk. */
} DMUS_DOWNLOADINFO;

#define DMUS_DOWNLOADINFO_INSTRUMENT        1
#define DMUS_DOWNLOADINFO_WAVE              2
#define DMUS_DOWNLOADINFO_INSTRUMENT2       3   /* New version for better DLS2 support. */

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

/* Support for oneshot and streaming wave data */
#define DMUS_DOWNLOADINFO_WAVEARTICULATION  4   /* Wave articulation data */
#define DMUS_DOWNLOADINFO_STREAMINGWAVE     5   /* One chunk of a streaming */
#define DMUS_DOWNLOADINFO_ONESHOTWAVE       6

#endif

#define DMUS_DEFAULT_SIZE_OFFSETTABLE   1

/* Flags for DMUS_INSTRUMENT's ulFlags member */

#define DMUS_INSTRUMENT_GM_INSTRUMENT   (1 << 0)

typedef struct _DMUS_OFFSETTABLE
{
    ULONG ulOffsetTable[DMUS_DEFAULT_SIZE_OFFSETTABLE];
} DMUS_OFFSETTABLE;

typedef struct _DMUS_INSTRUMENT
{
    ULONG           ulPatch;
    ULONG           ulFirstRegionIdx;
    ULONG           ulGlobalArtIdx;         /* If zero the instrument does not have an articulation */
    ULONG           ulFirstExtCkIdx;        /* If zero no 3rd party entenstion chunks associated with the instrument */
    ULONG           ulCopyrightIdx;         /* If zero no Copyright information associated with the instrument */
    ULONG           ulFlags;
} DMUS_INSTRUMENT;

typedef struct _DMUS_REGION
{
    RGNRANGE        RangeKey;
    RGNRANGE        RangeVelocity;
    USHORT          fusOptions;
    USHORT          usKeyGroup;
    ULONG           ulRegionArtIdx;         /* If zero the region does not have an articulation */
    ULONG           ulNextRegionIdx;        /* If zero no more regions */
    ULONG           ulFirstExtCkIdx;        /* If zero no 3rd party entenstion chunks associated with the region */
    WAVELINK        WaveLink;
    WSMPL           WSMP;                   /*  If WSMP.cSampleLoops > 1 then a WLOOP is included */
    WLOOP           WLOOP[1];
} DMUS_REGION;

typedef struct _DMUS_LFOPARAMS
{
    PCENT       pcFrequency;
    TCENT       tcDelay;
    GCENT       gcVolumeScale;
    PCENT       pcPitchScale;
    GCENT       gcMWToVolume;
    PCENT       pcMWToPitch;
} DMUS_LFOPARAMS;

typedef struct _DMUS_VEGPARAMS
{
    TCENT       tcAttack;
    TCENT       tcDecay;
    PERCENT     ptSustain;
    TCENT       tcRelease;
    TCENT       tcVel2Attack;
    TCENT       tcKey2Decay;
} DMUS_VEGPARAMS;

typedef struct _DMUS_PEGPARAMS
{
    TCENT       tcAttack;
    TCENT       tcDecay;
    PERCENT     ptSustain;
    TCENT       tcRelease;
    TCENT       tcVel2Attack;
    TCENT       tcKey2Decay;
    PCENT       pcRange;
} DMUS_PEGPARAMS;

typedef struct _DMUS_MSCPARAMS
{
    PERCENT     ptDefaultPan;
} DMUS_MSCPARAMS;

typedef struct _DMUS_ARTICPARAMS
{
    DMUS_LFOPARAMS   LFO;
    DMUS_VEGPARAMS   VolEG;
    DMUS_PEGPARAMS   PitchEG;
    DMUS_MSCPARAMS   Misc;
} DMUS_ARTICPARAMS;

typedef struct _DMUS_ARTICULATION           /* Articulation chunk for DMUS_DOWNLOADINFO_INSTRUMENT format. */
{
    ULONG           ulArt1Idx;              /* DLS Level 1 articulation chunk */
    ULONG           ulFirstExtCkIdx;        /* 3rd party extenstion chunks associated with the articulation */
} DMUS_ARTICULATION;

typedef struct _DMUS_ARTICULATION2          /* Articulation chunk for DMUS_DOWNLOADINFO_INSTRUMENT2 format. */
{
    ULONG           ulArtIdx;               /* DLS Level 1/2 articulation chunk */
    ULONG           ulFirstExtCkIdx;        /* 3rd party extenstion chunks associated with the articulation */
    ULONG           ulNextArtIdx;           /* Additional articulation chunks */
} DMUS_ARTICULATION2;

#define DMUS_MIN_DATA_SIZE 4
/*  The actual number is determined by cbSize of struct _DMUS_EXTENSIONCHUNK */

typedef struct _DMUS_EXTENSIONCHUNK
{
    ULONG           cbSize;                      /*  Size of extension chunk  */
    ULONG           ulNextExtCkIdx;              /*  If zero no more 3rd party entenstion chunks */
    FOURCC          ExtCkID;
    BYTE            byExtCk[DMUS_MIN_DATA_SIZE]; /*  The actual number that follows is determined by cbSize */
} DMUS_EXTENSIONCHUNK;

/*  The actual number is determined by cbSize of struct _DMUS_COPYRIGHT */

typedef struct _DMUS_COPYRIGHT
{
    ULONG           cbSize;                             /*  Size of copyright information */
    BYTE            byCopyright[DMUS_MIN_DATA_SIZE];    /*  The actual number that follows is determined by cbSize */
} DMUS_COPYRIGHT;

typedef struct _DMUS_WAVEDATA
{
    ULONG           cbSize;
    BYTE            byData[DMUS_MIN_DATA_SIZE];
} DMUS_WAVEDATA;

typedef struct _DMUS_WAVE
{
    ULONG           ulFirstExtCkIdx;    /* If zero no 3rd party entenstion chunks associated with the wave */
    ULONG           ulCopyrightIdx;     /* If zero no Copyright information associated with the wave */
    ULONG           ulWaveDataIdx;      /* Location of actual wave data. */
    WAVEFORMATEX    WaveformatEx;
} DMUS_WAVE;

typedef struct _DMUS_NOTERANGE *LPDMUS_NOTERANGE;
typedef struct _DMUS_NOTERANGE
{
    DWORD           dwLowNote;  /* Sets the low note for the range of MIDI note events to which the instrument responds.*/
    DWORD           dwHighNote; /* Sets the high note for the range of MIDI note events to which the instrument responds.*/
} DMUS_NOTERANGE;

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

typedef struct _DMUS_WAVEARTDL
{
    ULONG               ulDownloadIdIdx;    /* Download ID's of each buffer */
    ULONG               ulBus;              /* Playback bus */
    ULONG               ulBuffers;          /* Buffers */
    ULONG               ulMasterDLId;       /* Download ID of master voice of subordinate group */
    USHORT              usOptions;          /* Same as DLS2 region options */
}   DMUS_WAVEARTDL,
    *LPDMUS_WAVEARTDL;

typedef struct _DMUS_WAVEDL
{
    ULONG               cbWaveData;         /* Bytes of wave data */
}   DMUS_WAVEDL,
    *LPDMUS_WAVEDL;

#endif /* NTDDI_VERSION >= NTDDI_WINXP */

#endif /* _DMDLS_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dls1.h ===
/*==========================================================================;
//
//  dls1.h
//
//
//  Description:
//
//  Interface defines and structures for the Instrument Collection Form
//  RIFF DLS.
//
//
//  Written by Sonic Foundry 1996.  Released for public use.
//
//=========================================================================*/

#ifndef _INC_DLS1
#define _INC_DLS1

/*//////////////////////////////////////////////////////////////////////////
//
//
// Layout of an instrument collection:
//
//
// RIFF [] 'DLS ' [dlid,colh,INSTLIST,WAVEPOOL,INFOLIST]
//
// INSTLIST
// LIST [] 'lins'
//               LIST [] 'ins ' [dlid,insh,RGNLIST,ARTLIST,INFOLIST]
//               LIST [] 'ins ' [dlid,insh,RGNLIST,ARTLIST,INFOLIST]
//               LIST [] 'ins ' [dlid,insh,RGNLIST,ARTLIST,INFOLIST]
//
// RGNLIST
// LIST [] 'lrgn'
//               LIST [] 'rgn '  [rgnh,wsmp,wlnk,ARTLIST]
//               LIST [] 'rgn '  [rgnh,wsmp,wlnk,ARTLIST]
//               LIST [] 'rgn '  [rgnh,wsmp,wlnk,ARTLIST]
//
// ARTLIST
// LIST [] 'lart'
//         'art1' level 1 Articulation connection graph
//         'art2' level 2 Articulation connection graph
//         '3rd1' Possible 3rd party articulation structure 1
//         '3rd2' Possible 3rd party articulation structure 2 .... and so on
//
// WAVEPOOL
// ptbl [] [pool table]
// LIST [] 'wvpl'
//               [path],
//               [path],
//               LIST [] 'wave' [dlid,RIFFWAVE]
//               LIST [] 'wave' [dlid,RIFFWAVE]
//               LIST [] 'wave' [dlid,RIFFWAVE]
//               LIST [] 'wave' [dlid,RIFFWAVE]
//               LIST [] 'wave' [dlid,RIFFWAVE]
//
// INFOLIST
// LIST [] 'INFO'
//               'icmt' 'Comment.'
//               'icop' 'Copyright (C) Someone'
//
/////////////////////////////////////////////////////////////////////////*/


/*/////////////////////////////////////////////////////////////////////////
// FOURCC's used in the DLS file
/////////////////////////////////////////////////////////////////////////*/

#define FOURCC_DLS   mmioFOURCC('D','L','S',' ')
#define FOURCC_DLID  mmioFOURCC('d','l','i','d')
#define FOURCC_COLH  mmioFOURCC('c','o','l','h')
#define FOURCC_WVPL  mmioFOURCC('w','v','p','l')
#define FOURCC_PTBL  mmioFOURCC('p','t','b','l')
#define FOURCC_PATH  mmioFOURCC('p','a','t','h')
#define FOURCC_wave  mmioFOURCC('w','a','v','e')
#define FOURCC_LINS  mmioFOURCC('l','i','n','s')
#define FOURCC_INS   mmioFOURCC('i','n','s',' ')
#define FOURCC_INSH  mmioFOURCC('i','n','s','h')
#define FOURCC_LRGN  mmioFOURCC('l','r','g','n')
#define FOURCC_RGN   mmioFOURCC('r','g','n',' ')
#define FOURCC_RGNH  mmioFOURCC('r','g','n','h')
#define FOURCC_LART  mmioFOURCC('l','a','r','t')
#define FOURCC_ART1  mmioFOURCC('a','r','t','1')
#define FOURCC_WLNK  mmioFOURCC('w','l','n','k')
#define FOURCC_WSMP  mmioFOURCC('w','s','m','p')
#define FOURCC_VERS  mmioFOURCC('v','e','r','s')

/*/////////////////////////////////////////////////////////////////////////
// Articulation connection graph definitions
/////////////////////////////////////////////////////////////////////////*/

/* Generic Sources */
#define CONN_SRC_NONE              0x0000
#define CONN_SRC_LFO               0x0001
#define CONN_SRC_KEYONVELOCITY     0x0002
#define CONN_SRC_KEYNUMBER         0x0003
#define CONN_SRC_EG1               0x0004
#define CONN_SRC_EG2               0x0005
#define CONN_SRC_PITCHWHEEL        0x0006

/* Midi Controllers 0-127 */
#define CONN_SRC_CC1               0x0081
#define CONN_SRC_CC7               0x0087
#define CONN_SRC_CC10              0x008a
#define CONN_SRC_CC11              0x008b

/* Generic Destinations */
#define CONN_DST_NONE              0x0000
#define CONN_DST_ATTENUATION       0x0001
#define CONN_DST_PITCH             0x0003
#define CONN_DST_PAN               0x0004

/* LFO Destinations */
#define CONN_DST_LFO_FREQUENCY     0x0104
#define CONN_DST_LFO_STARTDELAY    0x0105

/* EG1 Destinations */
#define CONN_DST_EG1_ATTACKTIME    0x0206
#define CONN_DST_EG1_DECAYTIME     0x0207
#define CONN_DST_EG1_RELEASETIME   0x0209
#define CONN_DST_EG1_SUSTAINLEVEL  0x020a

/* EG2 Destinations */
#define CONN_DST_EG2_ATTACKTIME    0x030a
#define CONN_DST_EG2_DECAYTIME     0x030b
#define CONN_DST_EG2_RELEASETIME   0x030d
#define CONN_DST_EG2_SUSTAINLEVEL  0x030e

#define CONN_TRN_NONE              0x0000
#define CONN_TRN_CONCAVE           0x0001

typedef struct _DLSID {
  ULONG    ulData1;
  USHORT   usData2;
  USHORT   usData3;
  BYTE     abData4[8];
} DLSID, FAR *LPDLSID;

typedef struct _DLSVERSION {
  DWORD    dwVersionMS;
  DWORD    dwVersionLS;
}DLSVERSION, FAR *LPDLSVERSION;


typedef struct _CONNECTION {
  USHORT   usSource;
  USHORT   usControl;
  USHORT   usDestination;
  USHORT   usTransform;
  LONG     lScale;
  }CONNECTION, FAR *LPCONNECTION;


/* Level 1 Articulation Data */

typedef struct _CONNECTIONLIST {
  ULONG    cbSize;            /* size of the connection list structure */
  ULONG    cConnections;      /* count of connections in the list */
  } CONNECTIONLIST, FAR *LPCONNECTIONLIST;



/*/////////////////////////////////////////////////////////////////////////
// Generic type defines for regions and instruments
/////////////////////////////////////////////////////////////////////////*/

typedef struct _RGNRANGE {
  USHORT usLow;
  USHORT usHigh;
}RGNRANGE, FAR * LPRGNRANGE;

#define F_INSTRUMENT_DRUMS      0x80000000

typedef struct _MIDILOCALE {
  ULONG ulBank;
  ULONG ulInstrument;
}MIDILOCALE, FAR *LPMIDILOCALE;

/*/////////////////////////////////////////////////////////////////////////
// Header structures found in an DLS file for collection, instruments, and
// regions.
/////////////////////////////////////////////////////////////////////////*/

#define F_RGN_OPTION_SELFNONEXCLUSIVE  0x0001

typedef struct _RGNHEADER {
  RGNRANGE RangeKey;            /* Key range  */
  RGNRANGE RangeVelocity;       /* Velocity Range  */
  USHORT   fusOptions;          /* Synthesis options for this range */
  USHORT   usKeyGroup;          /* Key grouping for non simultaneous play */
                                /* 0 = no group, 1 up is group */
                                /* for Level 1 only groups 1-15 are allowed */
}RGNHEADER, FAR *LPRGNHEADER;

typedef struct _INSTHEADER {
  ULONG      cRegions;          /* Count of regions in this instrument */
  MIDILOCALE Locale;            /* Intended MIDI locale of this instrument */
}INSTHEADER, FAR *LPINSTHEADER;

typedef struct _DLSHEADER {
  ULONG      cInstruments;      /* Count of instruments in the collection */
}DLSHEADER, FAR *LPDLSHEADER;

/*////////////////////////////////////////////////////////////////////////////
// definitions for the Wave link structure
////////////////////////////////////////////////////////////////////////////*/

/* ****  For level 1 only WAVELINK_CHANNEL_MONO is valid  **** */
/* ulChannel allows for up to 32 channels of audio with each bit position */
/* specifiying a channel of playback */

#define WAVELINK_CHANNEL_LEFT    0x0001l
#define WAVELINK_CHANNEL_RIGHT   0x0002l

#define F_WAVELINK_PHASE_MASTER  0x0001

typedef struct _WAVELINK { /* any paths or links are stored right after struct */
  USHORT   fusOptions;     /* options flags for this wave */
  USHORT   usPhaseGroup;   /* Phase grouping for locking channels */
  ULONG    ulChannel;      /* channel placement */
  ULONG    ulTableIndex;   /* index into the wave pool table, 0 based */
}WAVELINK, FAR *LPWAVELINK;

#define POOL_CUE_NULL  0xffffffffl

typedef struct _POOLCUE {
  ULONG    ulOffset;       /* Offset to the entry in the list */
}POOLCUE, FAR *LPPOOLCUE;

typedef struct _POOLTABLE {
  ULONG    cbSize;            /* size of the pool table structure */
  ULONG    cCues;             /* count of cues in the list */
  } POOLTABLE, FAR *LPPOOLTABLE;

/*////////////////////////////////////////////////////////////////////////////
// Structures for the "wsmp" chunk
////////////////////////////////////////////////////////////////////////////*/

#define F_WSMP_NO_TRUNCATION     0x0001l
#define F_WSMP_NO_COMPRESSION    0x0002l


typedef struct _rwsmp {
  ULONG   cbSize;
  USHORT  usUnityNote;         /* MIDI Unity Playback Note */
  SHORT   sFineTune;           /* Fine Tune in log tuning */
  LONG    lAttenuation;        /* Overall Attenuation to be applied to data */
  ULONG   fulOptions;          /* Flag options  */
  ULONG   cSampleLoops;        /* Count of Sample loops, 0 loops is one shot */
  } WSMPL, FAR *LPWSMPL;


/* This loop type is a normal forward playing loop which is continually */
/* played until the envelope reaches an off threshold in the release */
/* portion of the volume envelope */

#define WLOOP_TYPE_FORWARD   0

typedef struct _rloop {
  ULONG cbSize;
  ULONG ulType;              /* Loop Type */
  ULONG ulStart;             /* Start of loop in samples */
  ULONG ulLength;            /* Length of loop in samples */
} WLOOP, FAR *LPWLOOP;

#endif /*_INC_DLS1 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dmerror.h ===
/************************************************************************
*                                                                       *
*   dmerror.h -- Error codes returned by DirectMusic API's              *
*                                                                       *
*   Copyright (c) Microsoft Corporation.  All rights reserved.          *
*                                                                       *
************************************************************************/

#ifndef _DMERROR_
#define _DMERROR_

#define FACILITY_DIRECTMUSIC      0x878       /* Shared with DirectSound */
#define DMUS_ERRBASE              0x1000      /* Make error codes human readable in hex */

#ifndef MAKE_HRESULT
#define MAKE_HRESULT(sev,fac,code) \
    ((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )
#endif

#define MAKE_DMHRESULTSUCCESS(code)     MAKE_HRESULT(0, FACILITY_DIRECTMUSIC, (DMUS_ERRBASE + (code)))
#define MAKE_DMHRESULTERROR(code)       MAKE_HRESULT(1, FACILITY_DIRECTMUSIC, (DMUS_ERRBASE + (code)))

/* DMUS_S_PARTIALLOAD
 *
 * The object could only load partially. This can happen if some components are
 * not registered properly, such as embedded tracks and tools. This can also happen
 * if some content is missing. For example, if a segment uses a DLS collection that
 * is not in the loader's current search directory.
 */
#define DMUS_S_PARTIALLOAD              MAKE_DMHRESULTSUCCESS(0x091)

/* DMUS_S_PARTIALDOWNLOAD
 *
 * Return value from IDirectMusicBand::Download() which indicates that
 * some of the instruments safely downloaded, but others failed. This usually
 * occurs when some instruments are on PChannels not supported by the performance
 * or port.
 */
#define DMUS_S_PARTIALDOWNLOAD          MAKE_DMHRESULTSUCCESS(0x092)

/* DMUS_S_REQUEUE
 *
 * Return value from IDirectMusicTool::ProcessPMsg() which indicates to the
 * performance that it should cue the PMsg again automatically.
 */
#define DMUS_S_REQUEUE                  MAKE_DMHRESULTSUCCESS(0x200)

/* DMUS_S_FREE
 *
 * Return value from IDirectMusicTool::ProcessPMsg() which indicates to the
 * performance that it should free the PMsg automatically.
 */
#define DMUS_S_FREE                     MAKE_DMHRESULTSUCCESS(0x201)

/* DMUS_S_END
 *
 * Return value from IDirectMusicTrack::Play() which indicates to the
 * segment that the track has no more data after mtEnd.
 */
#define DMUS_S_END                      MAKE_DMHRESULTSUCCESS(0x202)

/* DMUS_S_STRING_TRUNCATED
 *
 * Returned string has been truncated to fit the buffer size.
 */
#define DMUS_S_STRING_TRUNCATED         MAKE_DMHRESULTSUCCESS(0x210)

/* DMUS_S_LAST_TOOL
 *
 * Returned from IDirectMusicGraph::StampPMsg(), this indicates that the PMsg
 * is already stamped with the last tool in the graph. The returned PMsg's
 * tool pointer is now NULL.
 */
#define DMUS_S_LAST_TOOL                MAKE_DMHRESULTSUCCESS(0x211)

/* DMUS_S_OVER_CHORD
 *
 * Returned from IDirectMusicPerformance::MusicToMIDI(), this indicates
 * that no note has been calculated because the music value has the note
 * at a position higher than the top note of the chord. This applies only
 * to DMUS_PLAYMODE_NORMALCHORD play mode. This success code indicates
 * that the caller should not do anything with the note. It is not meant
 * to be played against this chord.
 */
#define DMUS_S_OVER_CHORD               MAKE_DMHRESULTSUCCESS(0x212)

/* DMUS_S_UP_OCTAVE
 *
 * Returned from IDirectMusicPerformance::MIDIToMusic(),  and
 * IDirectMusicPerformance::MusicToMIDI(), this indicates
 * that the note conversion generated a note value that is below 0,
 * so it has been bumped up one or more octaves to be in the proper
 * MIDI range of 0 through 127.
 * Note that this is valid for MIDIToMusic() when using play modes
 * DMUS_PLAYMODE_FIXEDTOCHORD and DMUS_PLAYMODE_FIXEDTOKEY, both of
 * which store MIDI values in wMusicValue. With MusicToMIDI(), it is
 * valid for all play modes.
 * Ofcourse, DMUS_PLAYMODE_FIXED will never return this success code.
 */
#define DMUS_S_UP_OCTAVE                MAKE_DMHRESULTSUCCESS(0x213)

/* DMUS_S_DOWN_OCTAVE
 *
 * Returned from IDirectMusicPerformance::MIDIToMusic(),  and
 * IDirectMusicPerformance::MusicToMIDI(), this indicates
 * that the note conversion generated a note value that is above 127,
 * so it has been bumped down one or more octaves to be in the proper
 * MIDI range of 0 through 127.
 * Note that this is valid for MIDIToMusic() when using play modes
 * DMUS_PLAYMODE_FIXEDTOCHORD and DMUS_PLAYMODE_FIXEDTOKEY, both of
 * which store MIDI values in wMusicValue. With MusicToMIDI(), it is
 * valid for all play modes.
 * Ofcourse, DMUS_PLAYMODE_FIXED will never return this success code.
 */
#define DMUS_S_DOWN_OCTAVE              MAKE_DMHRESULTSUCCESS(0x214)

/* DMUS_S_NOBUFFERCONTROL
 *
 * Although the audio output from the port will be routed to the
 * same device as the given DirectSound buffer, buffer controls
 * such as pan and volume will not affect the output.
 *
 */
#define DMUS_S_NOBUFFERCONTROL          MAKE_DMHRESULTSUCCESS(0x215)

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

/* DMUS_S_GARBAGE_COLLECTED
 *
 * The requested operation was not performed because during CollectGarbage
 * the loader determined that the object had been released.
 */
#define DMUS_S_GARBAGE_COLLECTED        MAKE_DMHRESULTSUCCESS(0x216)

#endif

/* DMUS_E_DRIVER_FAILED
 *
 * An unexpected error was returned from a device driver, indicating
 * possible failure of the driver or hardware.
 */
#define DMUS_E_DRIVER_FAILED            MAKE_DMHRESULTERROR(0x0101)

/* DMUS_E_PORTS_OPEN
 *
 * The requested operation cannot be performed while there are
 * instantiated ports in any process in the system.
 */
#define DMUS_E_PORTS_OPEN               MAKE_DMHRESULTERROR(0x0102)

/* DMUS_E_DEVICE_IN_USE
 *
 * The requested device is already in use (possibly by a non-DirectMusic
 * client) and cannot be opened again.
 */
#define DMUS_E_DEVICE_IN_USE            MAKE_DMHRESULTERROR(0x0103)

/* DMUS_E_INSUFFICIENTBUFFER
 *
 * Buffer is not large enough for requested operation.
 */
#define DMUS_E_INSUFFICIENTBUFFER       MAKE_DMHRESULTERROR(0x0104)

/* DMUS_E_BUFFERNOTSET
 *
 * No buffer was prepared for the download data.
 */
#define DMUS_E_BUFFERNOTSET             MAKE_DMHRESULTERROR(0x0105)

/* DMUS_E_BUFFERNOTAVAILABLE
 *
 * Download failed due to inability to access or create download buffer.
 */
#define DMUS_E_BUFFERNOTAVAILABLE       MAKE_DMHRESULTERROR(0x0106)

/* DMUS_E_NOTADLSCOL
 *
 * Error parsing DLS collection. File is corrupt.
 */
#define DMUS_E_NOTADLSCOL               MAKE_DMHRESULTERROR(0x0108)

/* DMUS_E_INVALIDOFFSET
 *
 * Wave chunks in DLS collection file are at incorrect offsets.
 */
#define DMUS_E_INVALIDOFFSET            MAKE_DMHRESULTERROR(0x0109)

/* DMUS_E_ALREADY_LOADED
 *
 * Second attempt to load a DLS collection that is currently open.
 */
#define DMUS_E_ALREADY_LOADED           MAKE_DMHRESULTERROR(0x0111)

/* DMUS_E_INVALIDPOS
 *
 * Error reading wave data from DLS collection. Indicates bad file.
 */
#define DMUS_E_INVALIDPOS               MAKE_DMHRESULTERROR(0x0113)

/* DMUS_E_INVALIDPATCH
 *
 * There is no instrument in the collection that matches patch number.
 */
#define DMUS_E_INVALIDPATCH             MAKE_DMHRESULTERROR(0x0114)

/* DMUS_E_CANNOTSEEK
 *
 * The IStream* doesn't support Seek().
 */
#define DMUS_E_CANNOTSEEK               MAKE_DMHRESULTERROR(0x0115)

/* DMUS_E_CANNOTWRITE
 *
 * The IStream* doesn't support Write().
 */
#define DMUS_E_CANNOTWRITE              MAKE_DMHRESULTERROR(0x0116)

/* DMUS_E_CHUNKNOTFOUND
 *
 * The RIFF parser doesn't contain a required chunk while parsing file.
 */
#define DMUS_E_CHUNKNOTFOUND            MAKE_DMHRESULTERROR(0x0117)

/* DMUS_E_INVALID_DOWNLOADID
 *
 * Invalid download id was used in the process of creating a download buffer.
 */
#define DMUS_E_INVALID_DOWNLOADID       MAKE_DMHRESULTERROR(0x0119)

/* DMUS_E_NOT_DOWNLOADED_TO_PORT
 *
 * Tried to unload an object that was not downloaded or previously unloaded.
 */
#define DMUS_E_NOT_DOWNLOADED_TO_PORT   MAKE_DMHRESULTERROR(0x0120)

/* DMUS_E_ALREADY_DOWNLOADED
 *
 * Buffer was already downloaded to synth.
 */
#define DMUS_E_ALREADY_DOWNLOADED       MAKE_DMHRESULTERROR(0x0121)

/* DMUS_E_UNKNOWN_PROPERTY
 *
 * The specified property item was not recognized by the target object.
 */
#define DMUS_E_UNKNOWN_PROPERTY         MAKE_DMHRESULTERROR(0x0122)

/* DMUS_E_SET_UNSUPPORTED
 *
 * The specified property item may not be set on the target object.
 */
#define DMUS_E_SET_UNSUPPORTED          MAKE_DMHRESULTERROR(0x0123)

/* DMUS_E_GET_UNSUPPORTED
 *
 * The specified property item may not be retrieved from the target object.
 */
#define DMUS_E_GET_UNSUPPORTED          MAKE_DMHRESULTERROR(0x0124)

/* DMUS_E_NOTMONO
 *
 * Wave chunk has more than one interleaved channel. DLS format requires MONO.
 */
#define DMUS_E_NOTMONO                  MAKE_DMHRESULTERROR(0x0125)

/* DMUS_E_BADARTICULATION
 *
 * Invalid articulation chunk in DLS collection.
 */
#define DMUS_E_BADARTICULATION          MAKE_DMHRESULTERROR(0x0126)

/* DMUS_E_BADINSTRUMENT
 *
 * Invalid instrument chunk in DLS collection.
 */
#define DMUS_E_BADINSTRUMENT            MAKE_DMHRESULTERROR(0x0127)

/* DMUS_E_BADWAVELINK
 *
 * Wavelink chunk in DLS collection points to invalid wave.
 */
#define DMUS_E_BADWAVELINK              MAKE_DMHRESULTERROR(0x0128)

/* DMUS_E_NOARTICULATION
 *
 * Articulation missing from instrument in DLS collection.
 */
#define DMUS_E_NOARTICULATION           MAKE_DMHRESULTERROR(0x0129)

/* DMUS_E_NOTPCM
 *
 * Downoaded DLS wave is not in PCM format.
*/
#define DMUS_E_NOTPCM                   MAKE_DMHRESULTERROR(0x012A)

/* DMUS_E_BADWAVE
 *
 * Bad wave chunk in DLS collection
 */
#define DMUS_E_BADWAVE                  MAKE_DMHRESULTERROR(0x012B)

/* DMUS_E_BADOFFSETTABLE
 *
 * Offset Table for download buffer has errors.
 */
#define DMUS_E_BADOFFSETTABLE           MAKE_DMHRESULTERROR(0x012C)

/* DMUS_E_UNKNOWNDOWNLOAD
 *
 * Attempted to download unknown data type.
 */
#define DMUS_E_UNKNOWNDOWNLOAD          MAKE_DMHRESULTERROR(0x012D)

/* DMUS_E_NOSYNTHSINK
 *
 * The operation could not be completed because no sink was connected to
 * the synthesizer.
 */
#define DMUS_E_NOSYNTHSINK              MAKE_DMHRESULTERROR(0x012E)

/* DMUS_E_ALREADYOPEN
 *
 * An attempt was made to open the software synthesizer while it was already
 * open.
 * ASSERT?
 */
#define DMUS_E_ALREADYOPEN              MAKE_DMHRESULTERROR(0x012F)

/* DMUS_E_ALREADYCLOSE
 *
 * An attempt was made to close the software synthesizer while it was already
 * open.
 * ASSERT?
 */
#define DMUS_E_ALREADYCLOSED            MAKE_DMHRESULTERROR(0x0130)

/* DMUS_E_SYNTHNOTCONFIGURED
 *
 * The operation could not be completed because the software synth has not
 * yet been fully configured.
 * ASSERT?
 */
#define DMUS_E_SYNTHNOTCONFIGURED       MAKE_DMHRESULTERROR(0x0131)

/* DMUS_E_SYNTHACTIVE
 *
 * The operation cannot be carried out while the synthesizer is active.
 */
#define DMUS_E_SYNTHACTIVE              MAKE_DMHRESULTERROR(0x0132)

/* DMUS_E_CANNOTREAD
 *
 * An error occurred while attempting to read from the IStream* object.
 */
#define DMUS_E_CANNOTREAD               MAKE_DMHRESULTERROR(0x0133)

/* DMUS_E_DMUSIC_RELEASED
 *
 * The operation cannot be performed because the final instance of the
 * DirectMusic object was released. Ports cannot be used after final
 * release of the DirectMusic object.
 */
#define DMUS_E_DMUSIC_RELEASED          MAKE_DMHRESULTERROR(0x0134)

/* DMUS_E_BUFFER_EMPTY
 *
 * There was no data in the referenced buffer.
 */
#define DMUS_E_BUFFER_EMPTY             MAKE_DMHRESULTERROR(0x0135)

/* DMUS_E_BUFFER_FULL
 *
 * There is insufficient space to insert the given event into the buffer.
 */
#define DMUS_E_BUFFER_FULL              MAKE_DMHRESULTERROR(0x0136)

/* DMUS_E_PORT_NOT_CAPTURE
 *
 * The given operation could not be carried out because the port is a
 * capture port.
 */
#define DMUS_E_PORT_NOT_CAPTURE         MAKE_DMHRESULTERROR(0x0137)

/* DMUS_E_PORT_NOT_RENDER
 *
 * The given operation could not be carried out because the port is a
 * render port.
 */
#define DMUS_E_PORT_NOT_RENDER          MAKE_DMHRESULTERROR(0x0138)

/* DMUS_E_DSOUND_NOT_SET
 *
 * The port could not be created because no DirectSound has been specified.
 * Specify a DirectSound interface via the IDirectMusic::SetDirectSound
 * method; pass NULL to have DirectMusic manage usage of DirectSound.
 */
#define DMUS_E_DSOUND_NOT_SET           MAKE_DMHRESULTERROR(0x0139)

/* DMUS_E_ALREADY_ACTIVATED
 *
 * The operation cannot be carried out while the port is active.
 */
#define DMUS_E_ALREADY_ACTIVATED        MAKE_DMHRESULTERROR(0x013A)

/* DMUS_E_INVALIDBUFFER
 *
 * Invalid DirectSound buffer was handed to port.
 */
#define DMUS_E_INVALIDBUFFER            MAKE_DMHRESULTERROR(0x013B)

/* DMUS_E_WAVEFORMATNOTSUPPORTED
 *
 * Invalid buffer format was handed to the synth sink.
 */
#define DMUS_E_WAVEFORMATNOTSUPPORTED   MAKE_DMHRESULTERROR(0x013C)

/* DMUS_E_SYNTHINACTIVE
 *
 * The operation cannot be carried out while the synthesizer is inactive.
 */
#define DMUS_E_SYNTHINACTIVE            MAKE_DMHRESULTERROR(0x013D)

/* DMUS_E_DSOUND_ALREADY_SET
 *
 * IDirectMusic::SetDirectSound has already been called. It may not be
 * changed while in use.
 */
#define DMUS_E_DSOUND_ALREADY_SET       MAKE_DMHRESULTERROR(0x013E)

/* DMUS_E_INVALID_EVENT
 *
 * The given event is invalid (either it is not a valid MIDI message
 * or it makes use of running status). The event cannot be packed
 * into the buffer.
 */
#define DMUS_E_INVALID_EVENT            MAKE_DMHRESULTERROR(0x013F)

/* DMUS_E_UNSUPPORTED_STREAM
 *
 * The IStream* object does not contain data supported by the loading object.
 */
#define DMUS_E_UNSUPPORTED_STREAM       MAKE_DMHRESULTERROR(0x0150)

/* DMUS_E_ALREADY_INITED
 *
 * The object has already been initialized.
 */
#define DMUS_E_ALREADY_INITED           MAKE_DMHRESULTERROR(0x0151)

/* DMUS_E_INVALID_BAND
 *
 * The file does not contain a valid band.
 */
#define DMUS_E_INVALID_BAND             MAKE_DMHRESULTERROR(0x0152)

/* DMUS_E_TRACK_HDR_NOT_FIRST_CK
 *
 * The IStream* object's data does not have a track header as the first chunk,
 * and therefore can not be read by the segment object.
 */
#define DMUS_E_TRACK_HDR_NOT_FIRST_CK   MAKE_DMHRESULTERROR(0x0155)

/* DMUS_E_TOOL_HDR_NOT_FIRST_CK
 *
 * The IStream* object's data does not have a tool header as the first chunk,
 * and therefore can not be read by the graph object.
 */
#define DMUS_E_TOOL_HDR_NOT_FIRST_CK    MAKE_DMHRESULTERROR(0x0156)

/* DMUS_E_INVALID_TRACK_HDR
 *
 * The IStream* object's data contains an invalid track header (ckid is 0 and
 * fccType is NULL,) and therefore can not be read by the segment object.
 */
#define DMUS_E_INVALID_TRACK_HDR        MAKE_DMHRESULTERROR(0x0157)

/* DMUS_E_INVALID_TOOL_HDR
 *
 * The IStream* object's data contains an invalid tool header (ckid is 0 and
 * fccType is NULL,) and therefore can not be read by the graph object.
 */
#define DMUS_E_INVALID_TOOL_HDR         MAKE_DMHRESULTERROR(0x0158)

/* DMUS_E_ALL_TOOLS_FAILED
 *
 * The graph object was unable to load all tools from the IStream* object data.
 * This may be due to errors in the stream, or the tools being incorrectly
 * registered on the client.
 */
#define DMUS_E_ALL_TOOLS_FAILED         MAKE_DMHRESULTERROR(0x0159)

/* DMUS_E_ALL_TRACKS_FAILED
 *
 * The segment object was unable to load all tracks from the IStream* object data.
 * This may be due to errors in the stream, or the tracks being incorrectly
 * registered on the client.
 */
#define DMUS_E_ALL_TRACKS_FAILED        MAKE_DMHRESULTERROR(0x0160)

/* DMUS_E_NOT_FOUND
 *
 * The requested item was not contained by the object.
 */
#define DMUS_E_NOT_FOUND                MAKE_DMHRESULTERROR(0x0161)

/* DMUS_E_NOT_INIT
 *
 * A required object is not initialized or failed to initialize.
 */
#define DMUS_E_NOT_INIT                 MAKE_DMHRESULTERROR(0x0162)

/* DMUS_E_TYPE_DISABLED
 *
 * The requested parameter type is currently disabled. Parameter types may
 * be enabled and disabled by certain calls to SetParam().
 */
#define DMUS_E_TYPE_DISABLED            MAKE_DMHRESULTERROR(0x0163)

/* DMUS_E_TYPE_UNSUPPORTED
 *
 * The requested parameter type is not supported on the object.
 */
#define DMUS_E_TYPE_UNSUPPORTED         MAKE_DMHRESULTERROR(0x0164)

/* DMUS_E_TIME_PAST
 *
 * The time is in the past, and the operation can not succeed.
 */
#define DMUS_E_TIME_PAST                MAKE_DMHRESULTERROR(0x0165)

/* DMUS_E_TRACK_NOT_FOUND
 *
 * The requested track is not contained by the segment.
 */
#define DMUS_E_TRACK_NOT_FOUND			MAKE_DMHRESULTERROR(0x0166)

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

/* DMUS_E_TRACK_NO_CLOCKTIME_SUPPORT
 *
 * The track does not support clock time playback or getparam.
 */
#define DMUS_E_TRACK_NO_CLOCKTIME_SUPPORT   MAKE_DMHRESULTERROR(0x0167)

#endif

/* DMUS_E_NO_MASTER_CLOCK
 *
 * There is no master clock in the performance. Be sure to call
 * IDirectMusicPerformance::Init().
 */
#define DMUS_E_NO_MASTER_CLOCK          MAKE_DMHRESULTERROR(0x0170)

/* DMUS_E_LOADER_NOCLASSID
 *
 * The class id field is required and missing in the DMUS_OBJECTDESC.
 */
#define DMUS_E_LOADER_NOCLASSID         MAKE_DMHRESULTERROR(0x0180)

/* DMUS_E_LOADER_BADPATH
 *
 * The requested file path is invalid.
 */
#define DMUS_E_LOADER_BADPATH           MAKE_DMHRESULTERROR(0x0181)

/* DMUS_E_LOADER_FAILEDOPEN
 *
 * File open failed - either file doesn't exist or is locked.
 */
#define DMUS_E_LOADER_FAILEDOPEN        MAKE_DMHRESULTERROR(0x0182)

/* DMUS_E_LOADER_FORMATNOTSUPPORTED
 *
 * Search data type is not supported.
 */
#define DMUS_E_LOADER_FORMATNOTSUPPORTED    MAKE_DMHRESULTERROR(0x0183)

/* DMUS_E_LOADER_FAILEDCREATE
 *
 * Unable to find or create object.
 */
#define DMUS_E_LOADER_FAILEDCREATE      MAKE_DMHRESULTERROR(0x0184)

/* DMUS_E_LOADER_OBJECTNOTFOUND
 *
 * Object was not found.
 */
#define DMUS_E_LOADER_OBJECTNOTFOUND    MAKE_DMHRESULTERROR(0x0185)

/* DMUS_E_LOADER_NOFILENAME
 *
 * The file name is missing from the DMUS_OBJECTDESC.
 */
#define DMUS_E_LOADER_NOFILENAME	    MAKE_DMHRESULTERROR(0x0186)

/* DMUS_E_INVALIDFILE
 *
 * The file requested is not a valid file.
 */
#define DMUS_E_INVALIDFILE              MAKE_DMHRESULTERROR(0x0200)

/* DMUS_E_ALREADY_EXISTS
 *
 * The tool is already contained in the graph. Create a new instance.
 */
#define DMUS_E_ALREADY_EXISTS           MAKE_DMHRESULTERROR(0x0201)

/* DMUS_E_OUT_OF_RANGE
 *
 * Value is out of range, for instance the requested length is longer than
 * the segment.
 */
#define DMUS_E_OUT_OF_RANGE             MAKE_DMHRESULTERROR(0x0202)

/* DMUS_E_SEGMENT_INIT_FAILED
 *
 * Segment initialization failed, most likely due to a critical memory situation.
 */
#define DMUS_E_SEGMENT_INIT_FAILED      MAKE_DMHRESULTERROR(0x0203)

/* DMUS_E_ALREADY_SENT
 *
 * The DMUS_PMSG has already been sent to the performance object via
 * IDirectMusicPerformance::SendPMsg().
 */
#define DMUS_E_ALREADY_SENT             MAKE_DMHRESULTERROR(0x0204)

/* DMUS_E_CANNOT_FREE
 *
 * The DMUS_PMSG was either not allocated by the performance via
 * IDirectMusicPerformance::AllocPMsg(), or it was already freed via
 * IDirectMusicPerformance::FreePMsg().
 */
#define DMUS_E_CANNOT_FREE              MAKE_DMHRESULTERROR(0x0205)

/* DMUS_E_CANNOT_OPEN_PORT
 *
 * The default system port could not be opened.
 */
#define DMUS_E_CANNOT_OPEN_PORT         MAKE_DMHRESULTERROR(0x0206)

/* DMUS_E_CANNOT_CONVERT
 *
 * A call to MIDIToMusic() or MusicToMIDI() resulted in an error because
 * the requested conversion could not happen. This usually occurs when the
 * provided DMUS_CHORD_KEY structure has an invalid chord or scale pattern.
 */
#define DMUS_E_CANNOT_CONVERT           MAKE_DMHRESULTERROR(0x0207)
/* misspelling in previous versions of DirectX preserved for backward compatibility */
#define DMUS_E_CONNOT_CONVERT           DMUS_E_CANNOT_CONVERT

/* DMUS_E_DESCEND_CHUNK_FAIL
 *
 * DMUS_E_DESCEND_CHUNK_FAIL is returned when the end of the file
 * was reached before the desired chunk was found.
 */
#define DMUS_E_DESCEND_CHUNK_FAIL       MAKE_DMHRESULTERROR(0x0210)


#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

/* DMUS_E_NOT_LOADED
 *
 * An attempt to use this object failed because it first needs to
 * be loaded.
 */
#define DMUS_E_NOT_LOADED               MAKE_DMHRESULTERROR(0x0211)

/* DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE
 *
 * The activeX scripting engine for the script's language is not compatible with
 * DirectMusic.
 *
 */
#define DMUS_E_SCRIPT_LANGUAGE_INCOMPATIBLE  MAKE_DMHRESULTERROR(0x0213)

/* DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE
 *
 * A varient was used that had a type that is not supported by DirectMusic.
 *
 */
#define DMUS_E_SCRIPT_UNSUPPORTED_VARTYPE    MAKE_DMHRESULTERROR(0x0214)

/* DMUS_E_SCRIPT_ERROR_IN_SCRIPT
 *
 * An error was encountered while parsing or executing the script.
 * The pErrorInfo parameter (if supplied) was filled with information about the error.
 */
#define DMUS_E_SCRIPT_ERROR_IN_SCRIPT        MAKE_DMHRESULTERROR(0x0215)

/* DMUS_E_SCRIPT_CANTLOAD_OLEAUT32
 *
 * Loading of oleaut32.dll failed.  VBScript and other activeX scripting languages
 * require use of oleaut32.dll.  On platforms where oleaut32.dll is not present, only
 * the DirectMusicScript language, which doesn't require oleaut32.dll can be used.
 */
#define DMUS_E_SCRIPT_CANTLOAD_OLEAUT32      MAKE_DMHRESULTERROR(0x0216)

/* DMUS_E_SCRIPT_LOADSCRIPT_ERROR
 *
 * An error occured while parsing a script loaded using LoadScript.  The script that
 * was loaded contains an error.
 */
#define DMUS_E_SCRIPT_LOADSCRIPT_ERROR       MAKE_DMHRESULTERROR(0x0217)

/* DMUS_E_SCRIPT_INVALID_FILE
 *
 * The script file is invalid.
 */
#define DMUS_E_SCRIPT_INVALID_FILE           MAKE_DMHRESULTERROR(0x0218)

/* DMUS_E_INVALID_SCRIPTTRACK
 *
 * The file contains an invalid script track.
 */
#define DMUS_E_INVALID_SCRIPTTRACK           MAKE_DMHRESULTERROR(0x0219)

/* DMUS_E_SCRIPT_VARIABLE_NOT_FOUND
 *
 * The script does not contain a variable with the specified name.
 */
#define DMUS_E_SCRIPT_VARIABLE_NOT_FOUND     MAKE_DMHRESULTERROR(0x021A)

/* DMUS_E_SCRIPT_ROUTINE_NOT_FOUND
 *
 * The script does not contain a routine with the specified name.
 */
#define DMUS_E_SCRIPT_ROUTINE_NOT_FOUND      MAKE_DMHRESULTERROR(0x021B)

/* DMUS_E_SCRIPT_CONTENT_READONLY
 *
 * Scripts variables for content referenced or embedded in a script cannot be set.
 */
#define DMUS_E_SCRIPT_CONTENT_READONLY       MAKE_DMHRESULTERROR(0x021C)

/* DMUS_E_SCRIPT_NOT_A_REFERENCE
 *
 * Attempt was made to set a script's variable by reference to a value that was
 * not an object type.
 */
#define DMUS_E_SCRIPT_NOT_A_REFERENCE        MAKE_DMHRESULTERROR(0x021D)

/* DMUS_E_SCRIPT_VALUE_NOT_SUPPORTED
 *
 * Attempt was made to set a script's variable by value to an object that does
 * not support a default value property.
 */
#define DMUS_E_SCRIPT_VALUE_NOT_SUPPORTED    MAKE_DMHRESULTERROR(0x021E)

/* DMUS_E_INVALID_SEGMENTTRIGGERTRACK
 *
 * The file contains an invalid segment trigger track.
 */
#define DMUS_E_INVALID_SEGMENTTRIGGERTRACK   MAKE_DMHRESULTERROR(0x0220)

/* DMUS_E_INVALID_LYRICSTRACK
 *
 * The file contains an invalid lyrics track.
 */
#define DMUS_E_INVALID_LYRICSTRACK           MAKE_DMHRESULTERROR(0x0221)

/* DMUS_E_INVALID_PARAMCONTROLTRACK
 *
 * The file contains an invalid parameter control track.
 */
#define DMUS_E_INVALID_PARAMCONTROLTRACK     MAKE_DMHRESULTERROR(0x0222)

/* DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR
 *
 * A script written in AudioVBScript could not be read because it contained a statement that
 * is not allowed by the AudioVBScript language.
 */
#define DMUS_E_AUDIOVBSCRIPT_SYNTAXERROR     MAKE_DMHRESULTERROR(0x0223)

/* DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR
 *
 * A script routine written in AudioVBScript failed because an invalid operation occurred.  For example,
 * adding the number 3 to a segment object would produce this error.  So would attempting to call a routine
 * that doesn't exist.
 */
#define DMUS_E_AUDIOVBSCRIPT_RUNTIMEERROR     MAKE_DMHRESULTERROR(0x0224)

/* DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE
 *
 * A script routine written in AudioVBScript failed because a function outside of a script failed to complete.
 * For example, a call to PlaySegment that fails to play because of low memory would return this error.
 */
#define DMUS_E_AUDIOVBSCRIPT_OPERATIONFAILURE     MAKE_DMHRESULTERROR(0x0225)

/* DMUS_E_AUDIOPATHS_NOT_VALID
 *
 * The Performance has set up some PChannels using the AssignPChannel command, which
 * makes it not capable of supporting audio paths.
 */
#define DMUS_E_AUDIOPATHS_NOT_VALID     MAKE_DMHRESULTERROR(0x0226)

/* DMUS_E_AUDIOPATHS_IN_USE
 *
 * This is the inverse of the previous error.
 * The Performance has set up some audio paths, which makes is incompatible
 * with the calls to allocate pchannels, etc.
 */
#define DMUS_E_AUDIOPATHS_IN_USE     MAKE_DMHRESULTERROR(0x0227)

/* DMUS_E_NO_AUDIOPATH_CONFIG
 *
 * A segment was asked for its embedded audio path configuration,
 * but there isn't any.
 */
#define DMUS_E_NO_AUDIOPATH_CONFIG     MAKE_DMHRESULTERROR(0x0228)

/* DMUS_E_AUDIOPATH_INACTIVE
 *
 * An audiopath is inactive, perhaps because closedown was called.
 */
#define DMUS_E_AUDIOPATH_INACTIVE     MAKE_DMHRESULTERROR(0x0229)

/* DMUS_E_AUDIOPATH_NOBUFFER
 *
 * An audiopath failed to create because a requested buffer could not be created.
 */
#define DMUS_E_AUDIOPATH_NOBUFFER     MAKE_DMHRESULTERROR(0x022A)

/* DMUS_E_AUDIOPATH_NOPORT
 *
 * An audiopath could not be used for playback because it lacked port assignments.
 */
#define DMUS_E_AUDIOPATH_NOPORT     MAKE_DMHRESULTERROR(0x022B)

/* DMUS_E_NO_AUDIOPATH
 *
 * Attempt was made to play segment in audiopath mode and there was no audiopath.
 */
#define DMUS_E_NO_AUDIOPATH     MAKE_DMHRESULTERROR(0x022C)

/* DMUS_E_INVALIDCHUNK
 *
 * Invalid data was found in a RIFF file chunk.
 */
#define DMUS_E_INVALIDCHUNK     MAKE_DMHRESULTERROR(0x022D)

/* DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER
 *
 * Attempt was made to create an audiopath that sends to a global effects buffer which did not exist.
 */
#define DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER     MAKE_DMHRESULTERROR(0x022E)

/* DMUS_E_INVALID_CONTAINER_OBJECT
 *
 * The file does not contain a valid container object.
 */
#define DMUS_E_INVALID_CONTAINER_OBJECT    MAKE_DMHRESULTERROR(0x022F)

#endif /* NTDDI_VERSION >= NTDDI_WINXP */

#endif /* _DMERROR_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dmksctrl.h ===
/************************************************************************
*                                                                       *
*   dmksctrl.h -- Definition of IKsControl                              *
*                                                                       *
*   Copyright (c) Microsoft Corporation.  All rights reserved.          *
*                                                                       *
*   This header file contains the definition of IKsControl, which       *
*   duplicates definitions from ks.h and ksproxy.h. Your code should    *
*   include ks.h and ksproxy.h directly if you have them (they are      *
*   provided in the Windows 98 DDK and will be in the Windows NT 5      *
*   SDK).                                                               *
*                                                                       *
************************************************************************/

#ifndef _DMKSCTRL_
#define _DMKSCTRL_

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)   /* Disable warnings on anonymous unions */

#include <pshpack8.h>

#include <objbase.h>

#if !defined(_NTRTL_)
    #ifndef DEFINE_GUIDEX
        #define DEFINE_GUIDEX(name) EXTERN_C const CDECL GUID name
    #endif /* !defined(DEFINE_GUIDEX) */

    #ifndef STATICGUIDOF
        #define STATICGUIDOF(guid) STATIC_##guid
    #endif /* !defined(STATICGUIDOF) */
#endif /* !defined(_NTRTL_) */

#ifndef STATIC_IID_IKsControl
#define STATIC_IID_IKsControl\
    0x28F54685L, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
#endif /* STATIC_IID_IKsControl */

/* 
 * Warning: This will prevent the rest of ks.h from being pulled in if ks.h is 
 * included after dmksctrl.h. Make sure you do not include both headers in
 * the same source file.
 */
#ifndef _KS_
#define _KS_

#if (defined(_MSC_EXTENSIONS) || defined(__cplusplus)) && !defined(CINTERFACE)
typedef struct {
    union {
        struct {
            GUID    Set;
            ULONG   Id;
            ULONG   Flags;
        };
        LONGLONG    Alignment;
    };
} KSIDENTIFIER, *PKSIDENTIFIER;
#else
typedef struct {
    union {
        struct {
            GUID    Set;
            ULONG   Id;
            ULONG   Flags;
        } Data;
        LONGLONG    Alignment;
    };
} KSIDENTIFIER, *PKSIDENTIFIER;
#endif

typedef KSIDENTIFIER KSPROPERTY, *PKSPROPERTY, KSMETHOD, *PKSMETHOD, KSEVENT, *PKSEVENT;

#define KSMETHOD_TYPE_NONE                  0x00000000
#define KSMETHOD_TYPE_READ                  0x00000001
#define KSMETHOD_TYPE_WRITE                 0x00000002
#define KSMETHOD_TYPE_MODIFY                0x00000003
#define KSMETHOD_TYPE_SOURCE                0x00000004

#define KSMETHOD_TYPE_SEND                  0x00000001
#define KSMETHOD_TYPE_SETSUPPORT            0x00000100
#define KSMETHOD_TYPE_BASICSUPPORT          0x00000200

#define KSPROPERTY_TYPE_GET                 0x00000001
#define KSPROPERTY_TYPE_SET                 0x00000002
#define KSPROPERTY_TYPE_SETSUPPORT          0x00000100
#define KSPROPERTY_TYPE_BASICSUPPORT        0x00000200
#define KSPROPERTY_TYPE_RELATIONS           0x00000400
#define KSPROPERTY_TYPE_SERIALIZESET        0x00000800
#define KSPROPERTY_TYPE_UNSERIALIZESET      0x00001000
#define KSPROPERTY_TYPE_SERIALIZERAW        0x00002000
#define KSPROPERTY_TYPE_UNSERIALIZERAW      0x00004000
#define KSPROPERTY_TYPE_SERIALIZESIZE       0x00008000
#define KSPROPERTY_TYPE_DEFAULTVALUES       0x00010000

#define KSPROPERTY_TYPE_TOPOLOGY            0x10000000
#endif  /* _KS_ */

#ifndef _IKsControl_
#define _IKsControl_

#ifdef DECLARE_INTERFACE_


#undef INTERFACE
#define INTERFACE IKsControl
DECLARE_INTERFACE_(IKsControl, IUnknown)
{
     /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*IKsControl*/
    STDMETHOD(KsProperty)(
        THIS_
        __in_bcount(PropertyLength) PKSPROPERTY Property,
        __in ULONG PropertyLength,
        __inout_bcount(DataLength) LPVOID PropertyData,
        __in ULONG DataLength,
        __out ULONG* BytesReturned
    ) PURE;
    STDMETHOD(KsMethod)(
        THIS_
        __in_bcount(MethodLength) PKSMETHOD Method,
        __in ULONG MethodLength,
        __inout_bcount(DataLength)  LPVOID MethodData,
        __in ULONG DataLength,
        __out ULONG* BytesReturned
    ) PURE;
    STDMETHOD(KsEvent)(
        THIS_
        __in_bcount(EventLength) PKSEVENT Event OPTIONAL,
        __in ULONG EventLength,
        __inout_bcount(DataLength) LPVOID EventData,
        __in ULONG DataLength,
        __out ULONG* BytesReturned
    ) PURE;
};

#endif /* DECLARE_INTERFACE_ */
#endif /* _IKsControl_ */

#include <poppack.h>

DEFINE_GUID(IID_IKsControl, 0x28F54685, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96);

/* These formats are in ksmedia.h
 */
#ifndef _KSMEDIA_

DEFINE_GUID(KSDATAFORMAT_SUBTYPE_MIDI, 0x1D262760L, 0xE957, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00);
DEFINE_GUID(KSDATAFORMAT_SUBTYPE_DIRECTMUSIC, 0x1a82f8bc,  0x3f8b, 0x11d2, 0xb7, 0x74, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1);

#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

#endif /* _DMKSCTRL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dmoimpl.h ===
//------------------------------------------------------------------------------
// File: DMOImpl.h
//
// Desc: Classes to implement a DMO
//
// Copyright (c) 2000-2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef _dmoimpl_h_
#define _dmoimpl_h_

#ifdef _DEBUG
#include <crtdbg.h>
#endif

//  Class to implement a DMO
//
//
//       Assumes the number of input and output streams is fixed
//       (these are template parameters)
//
//       Provides following services:
//
//          Basic parameter checking and locking
//          Fully implements :
//                 GetStreamCount
//                 SetInputType
//                 SetOutputType
//                 GetCurrentInputType
//                 GetCurrentOutputType
//
//          Checks if all types are set before streaming
//          Automatically calls AllocateStreamingResources before streaming
//              if it's not been called already
//          Prevents streaming until the types on all non-optional streams
//              have been set
//
//
//  Derived class implements the following methods :
//

/*
   HRESULT InternalGetInputStreamInfo(DWORD dwInputStreamIndex, DWORD *pdwFlags);
   HRESULT InternalGetOutputStreamInfo(DWORD dwOutputStreamIndex, DWORD *pdwFlags);
   HRESULT InternalCheckInputType(DWORD dwInputStreamIndex, const DMO_MEDIA_TYPE *pmt);
   HRESULT InternalCheckOutputType(DWORD dwOutputStreamIndex, const DMO_MEDIA_TYPE *pmt);
   HRESULT InternalGetInputType(DWORD dwInputStreamIndex, DWORD dwTypeIndex,
                            DMO_MEDIA_TYPE *pmt);
   HRESULT InternalGetOutputType(DWORD dwOutputStreamIndex, DWORD dwTypeIndex,
                            DMO_MEDIA_TYPE *pmt);
   HRESULT InternalGetInputSizeInfo(DWORD dwInputStreamIndex, DWORD *pcbSize,
                            DWORD *pcbMaxLookahead, DWORD *pcbAlignment);
   HRESULT InternalGetOutputSizeInfo(DWORD dwOutputStreamIndex, DWORD *pcbSize,
                             DWORD *pcbAlignment);
   HRESULT InternalGetInputMaxLatency(DWORD dwInputStreamIndex, REFERENCE_TIME *prtMaxLatency);
   HRESULT InternalSetInputMaxLatency(DWORD dwInputStreamIndex, REFERENCE_TIME rtMaxLatency);
   HRESULT InternalFlush();
   HRESULT InternalDiscontinuity(DWORD dwInputStreamIndex);
   HRESULT InternalAllocateStreamingResources();
   HRESULT InternalFreeStreamingResources();
   HRESULT InternalProcessInput(DWORD dwInputStreamIndex, IMediaBuffer *pBuffer,
                               DWORD dwFlags, REFERENCE_TIME rtTimestamp,
                               REFERENCE_TIME rtTimelength);
   HRESULT InternalProcessOutput(DWORD dwFlags, DWORD cOutputBufferCount,
                               DMO_OUTPUT_DATA_BUFFER *pOutputBuffers,
                           DWORD *pdwStatus);
   HRESULT InternalAcceptingInput(DWORD dwInputStreamIndex);
   void Lock();
   void Unlock();

   Notes:
       The derived class is meant to do most work to initialize streaming
       in AllocateStreamingResources rather than when types are set.

       This centralizes the work to one
       clear place based on the types set for all streams.

       The derived class implements locking.

       The derived class implements the IUnknown methods

   Usage example (1 input and 1 output) :
   class CMyDMO : public IMediaObjectImpl<CMyDmo, 1, 1>,
                  ...
*/


#define INTERNAL_CALL(_T_, _X_) \
    static_cast<_T_ *>(this)->Internal##_X_

template <class _DERIVED_, int NUMBEROFINPUTS, int NUMBEROFOUTPUTS>
class IMediaObjectImpl : public IMediaObject
{
private:
    // Member variables
    struct {
        DWORD   fTypeSet:1;
        DWORD   fIncomplete:1;
        DMO_MEDIA_TYPE CurrentMediaType;
    } m_InputInfo[NUMBEROFINPUTS], m_OutputInfo[NUMBEROFOUTPUTS];

    bool m_fTypesSet;
    bool m_fFlushed;
    bool m_fResourcesAllocated;

protected:

    //  Helpers
    bool InputTypeSet(DWORD ulInputStreamIndex) const
    {
        _ASSERTE(ulInputStreamIndex < NUMBEROFINPUTS);
        return 0 != m_InputInfo[ulInputStreamIndex].fTypeSet;
    }

    bool OutputTypeSet(DWORD ulOutputStreamIndex) const
    {
        _ASSERTE(ulOutputStreamIndex < NUMBEROFOUTPUTS);
        return 0 != m_OutputInfo[ulOutputStreamIndex].fTypeSet;
    }
    const DMO_MEDIA_TYPE *InputType(DWORD ulInputStreamIndex)
    {
        if (!InputTypeSet(ulInputStreamIndex)) {
            return NULL;
        }
        return &m_InputInfo[ulInputStreamIndex].CurrentMediaType;
    }
    const DMO_MEDIA_TYPE *OutputType(DWORD ulOutputStreamIndex)
    {
        if (!OutputTypeSet(ulOutputStreamIndex)) {
            return NULL;
        }
        return &m_OutputInfo[ulOutputStreamIndex].CurrentMediaType;
    }


    class LockIt
    {
    public:
        LockIt(_DERIVED_ *p) : m_p(p)
        {
            static_cast<_DERIVED_ *>(m_p)->Lock();
        }
        ~LockIt()
        {
            static_cast<_DERIVED_ *>(m_p)->Unlock();
        }
        _DERIVED_ *const m_p;
    };

    bool CheckTypesSet()
    {
        m_fTypesSet = false;
        DWORD dw;
        for (dw = 0; dw < NUMBEROFINPUTS; dw++) {
            if (!InputTypeSet(dw)) {
                return false;
            }
        }
        for (dw = 0; dw < NUMBEROFOUTPUTS; dw++) {
            if (!OutputTypeSet(dw)) {
                //  Check if it's optional
                DWORD dwFlags;
#ifdef _DEBUG
                dwFlags = 0xFFFFFFFF;
#endif
                INTERNAL_CALL(_DERIVED_, GetOutputStreamInfo)(dw, &dwFlags);
                _ASSERTE(0 == (dwFlags & ~(DMO_OUTPUT_STREAMF_WHOLE_SAMPLES |
                                         DMO_OUTPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER |
                                         DMO_OUTPUT_STREAMF_FIXED_SAMPLE_SIZE |
                                         DMO_OUTPUT_STREAMF_DISCARDABLE |
                                         DMO_OUTPUT_STREAMF_OPTIONAL)));
                if (!(dwFlags & DMO_OUTPUT_STREAMF_OPTIONAL)) {
                    return false;
                }
            }
        }
        m_fTypesSet = true;
        return true;
    }


    IMediaObjectImpl() :
        m_fTypesSet(false),
        m_fFlushed(true),
        m_fResourcesAllocated(false)
    {
        ZeroMemory(&m_InputInfo, sizeof(m_InputInfo));
        ZeroMemory(&m_OutputInfo, sizeof(m_OutputInfo));
    }

    virtual ~IMediaObjectImpl() {
        DWORD dwCurrentType;

        for (dwCurrentType = 0; dwCurrentType < NUMBEROFINPUTS; dwCurrentType++) {
            if(InputTypeSet(dwCurrentType)) {
                MoFreeMediaType(&m_InputInfo[dwCurrentType].CurrentMediaType);
            }
        }

        for (dwCurrentType = 0; dwCurrentType < NUMBEROFOUTPUTS; dwCurrentType++) {
            if(OutputTypeSet(dwCurrentType)) {
                MoFreeMediaType(&m_OutputInfo[dwCurrentType].CurrentMediaType);
            }
        }
    }


    // IMediaObject methods


    //
    // IMediaObject methods
    //
    STDMETHODIMP GetStreamCount(unsigned long *pulNumberOfInputStreams, unsigned long *pulNumberOfOutputStreams)
    {
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (pulNumberOfInputStreams == NULL ||
            pulNumberOfOutputStreams == NULL) {
            return E_POINTER;
        }
        *pulNumberOfInputStreams  = NUMBEROFINPUTS;
        *pulNumberOfOutputStreams = NUMBEROFOUTPUTS;
        return S_OK;
    }
    STDMETHODIMP GetInputStreamInfo(ULONG ulStreamIndex, DWORD *pdwFlags)
    {
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (pdwFlags == NULL) {
            return E_POINTER;
        }
        HRESULT hr = INTERNAL_CALL(_DERIVED_, GetInputStreamInfo)(ulStreamIndex, pdwFlags);
        _ASSERTE(0 == (*pdwFlags & ~(DMO_INPUT_STREAMF_WHOLE_SAMPLES |
                                   DMO_INPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER |
                                   DMO_INPUT_STREAMF_FIXED_SAMPLE_SIZE |
                                   DMO_INPUT_STREAMF_HOLDS_BUFFERS)));
        return hr;
    }
    STDMETHODIMP GetOutputStreamInfo(ULONG ulStreamIndex, DWORD *pdwFlags)
    {
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (ulStreamIndex >= NUMBEROFOUTPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (pdwFlags == NULL) {
            return E_POINTER;
        }
        HRESULT hr = INTERNAL_CALL(_DERIVED_, GetOutputStreamInfo)(ulStreamIndex, pdwFlags);
        _ASSERTE(0 == (*pdwFlags & ~(DMO_OUTPUT_STREAMF_WHOLE_SAMPLES |
                                   DMO_OUTPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER |
                                   DMO_OUTPUT_STREAMF_FIXED_SAMPLE_SIZE |
                                   DMO_OUTPUT_STREAMF_DISCARDABLE |
                                   DMO_OUTPUT_STREAMF_OPTIONAL)));
        return hr;
    }
    STDMETHODIMP GetInputType(ULONG ulStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        LockIt lck(static_cast<_DERIVED_ *>(this));
        return INTERNAL_CALL(_DERIVED_, GetInputType)(ulStreamIndex, ulTypeIndex, pmt);
    }
    STDMETHODIMP GetOutputType(ULONG ulStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
        if (ulStreamIndex >= NUMBEROFOUTPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        LockIt lck(static_cast<_DERIVED_ *>(this));
        return INTERNAL_CALL(_DERIVED_, GetOutputType)(ulStreamIndex, ulTypeIndex, pmt);
    }
    STDMETHODIMP GetInputCurrentType(ULONG ulStreamIndex, DMO_MEDIA_TYPE *pmt) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (NULL == pmt) {
            return E_POINTER;
        }
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (InputTypeSet(ulStreamIndex))
            return MoCopyMediaType(pmt,
                                   &m_InputInfo[ulStreamIndex].CurrentMediaType);
        else
           return DMO_E_TYPE_NOT_SET;
    }
    STDMETHODIMP GetOutputCurrentType(ULONG ulStreamIndex, DMO_MEDIA_TYPE *pmt) {
        if (ulStreamIndex >= NUMBEROFOUTPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (NULL == pmt) {
            return E_POINTER;
        }
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (OutputTypeSet(ulStreamIndex))
            return MoCopyMediaType(pmt,
                                   &m_OutputInfo[ulStreamIndex].CurrentMediaType);
        else
           return DMO_E_TYPE_NOT_SET;
    }
    STDMETHODIMP GetInputSizeInfo(ULONG ulStreamIndex, ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (NULL == pulSize || NULL == pulAlignment ||
            NULL == pcbMaxLookahead) {
            return E_POINTER;
        }
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (!InputTypeSet(ulStreamIndex)) {
           return DMO_E_TYPE_NOT_SET;
        }
        return INTERNAL_CALL(_DERIVED_, GetInputSizeInfo)(ulStreamIndex, pulSize, pcbMaxLookahead, pulAlignment);
    }
    STDMETHODIMP GetOutputSizeInfo(ULONG ulStreamIndex, ULONG *pulSize, ULONG *pulAlignment) {
        if (ulStreamIndex >= NUMBEROFOUTPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (NULL == pulSize || NULL == pulAlignment) {
            return E_POINTER;
        }
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (!m_fTypesSet || !OutputTypeSet(ulStreamIndex)) {
           return DMO_E_TYPE_NOT_SET;
        }
        return INTERNAL_CALL(_DERIVED_, GetOutputSizeInfo)(ulStreamIndex, pulSize, pulAlignment);
    }
    STDMETHODIMP SetInputType(ULONG ulStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (dwFlags & ~ (DMO_SET_TYPEF_CLEAR | DMO_SET_TYPEF_TEST_ONLY)) {
            return E_INVALIDARG;
        }

        LockIt lck(static_cast<_DERIVED_ *>(this));

        if (dwFlags & DMO_SET_TYPEF_CLEAR) {
            MoFreeMediaType(&m_InputInfo[ulStreamIndex].CurrentMediaType);
            m_InputInfo[ulStreamIndex].fTypeSet = FALSE;
            if (!CheckTypesSet()) {
                Flush();
                FreeStreamingResources();
            }
            return NOERROR;
        }
        if (NULL == pmt) {
            return E_POINTER;
        }
        HRESULT hr = INTERNAL_CALL(_DERIVED_, CheckInputType)(ulStreamIndex, pmt);
        if (FAILED(hr))
           return hr;

        if (dwFlags & DMO_SET_TYPEF_TEST_ONLY) {
           return NOERROR;
        }


        // actually set the type
        DMO_MEDIA_TYPE mtTemp;
        if (S_OK == MoCopyMediaType(&mtTemp, pmt)) {
            // Free any previous mediatype
            if (InputTypeSet(ulStreamIndex)) {
                MoFreeMediaType(&m_InputInfo[ulStreamIndex].CurrentMediaType);
            }
            m_InputInfo[ulStreamIndex].CurrentMediaType = mtTemp;
            m_InputInfo[ulStreamIndex].fTypeSet = TRUE;
            CheckTypesSet();
        } else {
            return E_OUTOFMEMORY;
        }

        return NOERROR;
    }

    STDMETHODIMP SetOutputType(ULONG ulStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
        if (ulStreamIndex >= NUMBEROFOUTPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (dwFlags & ~ (DMO_SET_TYPEF_CLEAR | DMO_SET_TYPEF_TEST_ONLY)) {
            return E_INVALIDARG;
        }

        LockIt lck(static_cast<_DERIVED_ *>(this));

        if (dwFlags & DMO_SET_TYPEF_CLEAR) {
            MoFreeMediaType(&m_OutputInfo[ulStreamIndex].CurrentMediaType);
            m_OutputInfo[ulStreamIndex].fTypeSet = FALSE;
            if (!CheckTypesSet()) {
                Flush();
                FreeStreamingResources();
            }
            return NOERROR;
        }
        if (NULL == pmt) {
            return E_POINTER;
        }
        HRESULT hr = INTERNAL_CALL(_DERIVED_, CheckOutputType)(ulStreamIndex, pmt);
        if (FAILED(hr)) {
           return hr;
        }

        if (dwFlags & DMO_SET_TYPEF_TEST_ONLY) {
           return NOERROR;
        }


        // actually set the type
        DMO_MEDIA_TYPE mtTemp;
        if (S_OK == MoCopyMediaType(&mtTemp, pmt)) {
            // Free any previous mediatype
            if (OutputTypeSet(ulStreamIndex)) {
                MoFreeMediaType(&m_OutputInfo[ulStreamIndex].CurrentMediaType);
            }
            m_OutputInfo[ulStreamIndex].CurrentMediaType = mtTemp;
            m_OutputInfo[ulStreamIndex].fTypeSet = TRUE;
            CheckTypesSet();
        } else {
            return E_OUTOFMEMORY;
        }

        return NOERROR;
    }
    STDMETHODIMP GetInputStatus(
        ULONG ulStreamIndex,
        DWORD *pdwStatus
    ) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (NULL == pdwStatus) {
            return E_POINTER;
        }
        *pdwStatus = 0;

        LockIt lck(static_cast<_DERIVED_ *>(this));

        if (!m_fTypesSet) {
            return DMO_E_TYPE_NOT_SET;
        }

        if (INTERNAL_CALL(_DERIVED_, AcceptingInput)(ulStreamIndex) == S_OK) {
           *pdwStatus |= DMO_INPUT_STATUSF_ACCEPT_DATA;
        }
        return NOERROR;
    }
    STDMETHODIMP GetInputMaxLatency(unsigned long ulStreamIndex, REFERENCE_TIME *prtLatency) {

        if (prtLatency == NULL) {
            return E_POINTER;
        }
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }

        LockIt lck(static_cast<_DERIVED_ *>(this));

        return INTERNAL_CALL(_DERIVED_, GetInputMaxLatency)(ulStreamIndex, prtLatency);
    }
    STDMETHODIMP SetInputMaxLatency(unsigned long ulStreamIndex, REFERENCE_TIME rtLatency) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }

        LockIt lck(static_cast<_DERIVED_ *>(this));

        return INTERNAL_CALL(_DERIVED_, SetInputMaxLatency)(ulStreamIndex, rtLatency);
    }
    STDMETHODIMP Discontinuity(ULONG ulStreamIndex) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }

        LockIt lck(static_cast<_DERIVED_ *>(this));

        if (!m_fTypesSet) {
            return DMO_E_TYPE_NOT_SET;
        }

        if (S_OK != INTERNAL_CALL(_DERIVED_, AcceptingInput)(ulStreamIndex)) {
            return DMO_E_NOTACCEPTING;
        }

        return INTERNAL_CALL(_DERIVED_, Discontinuity)(ulStreamIndex);
    }

    STDMETHODIMP Flush()
    {
        LockIt lck(static_cast<_DERIVED_ *>(this));

        if (!m_fTypesSet) {
            return S_OK;
        }
        if (m_fFlushed) {
            return S_OK;
        }
        HRESULT hr =  INTERNAL_CALL(_DERIVED_, Flush)();
        m_fFlushed = true;
        return hr;
    }

    STDMETHODIMP AllocateStreamingResources() {
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (!m_fTypesSet) {
            return DMO_E_TYPE_NOT_SET;
        }
        if (m_fResourcesAllocated) {
            return S_OK;
        }
        HRESULT hr = INTERNAL_CALL(_DERIVED_, AllocateStreamingResources)();
        if (SUCCEEDED(hr)) {
            m_fResourcesAllocated = true;
        }
        return hr;
    }
    STDMETHODIMP FreeStreamingResources()
    {
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (m_fResourcesAllocated) {
            m_fResourcesAllocated = false;
            INTERNAL_CALL(_DERIVED_, Flush)();
            return INTERNAL_CALL(_DERIVED_, FreeStreamingResources)();
        }
        return S_OK;
    }

    //
    // Processing methods - public entry points
    //
    STDMETHODIMP ProcessInput(
        DWORD ulStreamIndex,
        IMediaBuffer *pBuffer, // [in], must not be NULL
        DWORD dwFlags, // [in] - discontinuity, timestamp, etc.
        REFERENCE_TIME rtTimestamp, // [in], valid if flag set
        REFERENCE_TIME rtTimelength // [in], valid if flag set
    ) {
        if (!pBuffer) {
            return E_POINTER;
        }
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (dwFlags & ~(DMO_INPUT_DATA_BUFFERF_SYNCPOINT |
                        DMO_INPUT_DATA_BUFFERF_TIME |
                        DMO_INPUT_DATA_BUFFERF_TIMELENGTH)) {
            return E_INVALIDARG;
        }

        LockIt lck(static_cast<_DERIVED_ *>(this));

        //  Make sure all streams have media types set and resources are allocated
        HRESULT hr = AllocateStreamingResources();
        if (FAILED(hr)) {
            return hr;
        }
        if (INTERNAL_CALL(_DERIVED_, AcceptingInput)(ulStreamIndex) != S_OK) {
            return DMO_E_NOTACCEPTING;
        }

        m_fFlushed = false;

        return INTERNAL_CALL(_DERIVED_, ProcessInput)(
                                    ulStreamIndex,
                                    pBuffer,
                                    dwFlags,
                                    rtTimestamp,
                                    rtTimelength);
    }

    STDMETHODIMP ProcessOutput(
                    DWORD dwFlags,
                    DWORD ulOutputBufferCount,
                    DMO_OUTPUT_DATA_BUFFER *pOutputBuffers,
                    DWORD *pdwStatus)
    {
        if (pdwStatus == NULL) {
            return E_POINTER;
        }


        if (ulOutputBufferCount != NUMBEROFOUTPUTS || (dwFlags & ~DMO_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER)) {
           return E_INVALIDARG;
        }

        if (NUMBEROFOUTPUTS != 0 && pOutputBuffers == NULL) {
            return E_POINTER;
        }

        *pdwStatus = 0;

        LockIt lck(static_cast<_DERIVED_ *>(this));

        HRESULT hr = AllocateStreamingResources();
        if (FAILED(hr)) {
            return hr;
        }

        DWORD dw;
        for (dw = 0; dw < NUMBEROFOUTPUTS; dw++) {
            pOutputBuffers[dw].dwStatus = 0;
        }

        hr = INTERNAL_CALL(_DERIVED_, ProcessOutput)(
                           dwFlags,
                           ulOutputBufferCount,
                           pOutputBuffers,
                           pdwStatus);

        // remember the DMO's incomplete status
        for (dw = 0; dw < NUMBEROFOUTPUTS; dw++) {
            if (pOutputBuffers[dw].dwStatus & DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE) {
                m_OutputInfo[dw].fIncomplete = TRUE;
            } else {
                m_OutputInfo[dw].fIncomplete = FALSE;
            }
        }

        return hr;
    }

    STDMETHODIMP DMOLock(LONG lLock)
    {
        if (lLock) {
            static_cast<_DERIVED_ *>(this)->Lock();
        } else {
            static_cast<_DERIVED_ *>(this)->Unlock();
        }
        return S_OK;
    }
};

#endif // _dmoimpl_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dmo.h ===
//------------------------------------------------------------------------------
// File: DMO.h
//
// Desc: Headers needed by almost all DMOs.
//
// Copyright (c) 1999 - 2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __DMO_H__
#define __DMO_H__


#include "mediaerr.h"

// When using ATL we get collisions on Lock, so in this case rename
// IMediaObject::Lock to IMediaObject::DMOLock

#ifdef FIX_LOCK_NAME
#define Lock DMOLock
#endif
#include "mediaobj.h"
#ifdef FIX_LOCK_NAME
#undef Lock
#endif
#include "dmoreg.h"
#include "dmort.h"

#endif //__DMO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dmodshow.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for dmodshow.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dmodshow_h__
#define __dmodshow_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDMOWrapperFilter_FWD_DEFINED__
#define __IDMOWrapperFilter_FWD_DEFINED__
typedef interface IDMOWrapperFilter IDMOWrapperFilter;
#endif 	/* __IDMOWrapperFilter_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "mediaobj.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_dmodshow_0000_0000 */
/* [local] */ 

DEFINE_GUID(CLSID_DMOWrapperFilter, 0x94297043,0xbd82,0x4dfd,0xb0,0xde,0x81,0x77,0x73,0x9c,0x6d,0x20);
DEFINE_GUID(CLSID_DMOFilterCategory,0xbcd5796c,0xbd52,0x4d30,0xab,0x76,0x70,0xf9,0x75,0xb8,0x91,0x99);


extern RPC_IF_HANDLE __MIDL_itf_dmodshow_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dmodshow_0000_0000_v0_0_s_ifspec;

#ifndef __IDMOWrapperFilter_INTERFACE_DEFINED__
#define __IDMOWrapperFilter_INTERFACE_DEFINED__

/* interface IDMOWrapperFilter */
/* [uuid][object] */ 


EXTERN_C const IID IID_IDMOWrapperFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("52d6f586-9f0f-4824-8fc8-e32ca04930c2")
    IDMOWrapperFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            __RPC__in REFCLSID clsidDMO,
            __RPC__in REFCLSID catDMO) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDMOWrapperFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDMOWrapperFilter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDMOWrapperFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDMOWrapperFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            __RPC__in IDMOWrapperFilter * This,
            __RPC__in REFCLSID clsidDMO,
            __RPC__in REFCLSID catDMO);
        
        END_INTERFACE
    } IDMOWrapperFilterVtbl;

    interface IDMOWrapperFilter
    {
        CONST_VTBL struct IDMOWrapperFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDMOWrapperFilter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDMOWrapperFilter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDMOWrapperFilter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDMOWrapperFilter_Init(This,clsidDMO,catDMO)	\
    ( (This)->lpVtbl -> Init(This,clsidDMO,catDMO) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDMOWrapperFilter_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dmusbuff.h ===
/***************************************************************************
*                                                                          *
*   DMusBuff.h -- This module defines the buffer format for DirectMusic    *
*                 Shared file between user mode and kernel mode components *
*                                                                          *
*   Copyright (c) 1998, Microsoft Corp. All rights reserved.               *
*                                                                          *
***************************************************************************/

#ifndef _DMusBuff_
#define _DMusBuff_

#include "dmdls.h"

/* Format of DirectMusic events in a buffer
 *
 * A buffer contains 1 or more events, each with the following header.
 * Immediately following the header is the event data. The header+data
 * size is rounded to the nearest quadword (8 bytes).
 */
 
#include <pshpack4.h>                       /* Do not pad at end - that's where the data is */ 
typedef struct _DMUS_EVENTHEADER *LPDMUS_EVENTHEADER;
typedef struct _DMUS_EVENTHEADER
{
    DWORD           cbEvent;                /* Unrounded bytes in event */
    DWORD           dwChannelGroup;         /* Channel group of event */
    REFERENCE_TIME  rtDelta;                /* Delta from start time of entire buffer */
    DWORD           dwFlags;                /* Flags DMUS_EVENT_xxx */
} DMUS_EVENTHEADER;
#include <poppack.h>

#define DMUS_EVENT_STRUCTURED   0x00000001  /* Unstructured data (SysEx, etc.) */

/* The number of bytes to allocate for an event with 'cb' data bytes.
 */ 
#define QWORD_ALIGN(x) (((x) + 7) & ~7)
#define DMUS_EVENT_SIZE(cb) QWORD_ALIGN(sizeof(DMUS_EVENTHEADER) + cb)


#endif /* _DMusBuff_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dmusicc.h ===
/************************************************************************
*                                                                       *
*   dmusicc.h -- This module defines the DirectMusic core API's         *
*                                                                       *
*   Copyright (c) Microsoft Corporation.  All rights reserved.          *
*                                                                       *
************************************************************************/

#ifndef _DMUSICC_
#define _DMUSICC_

#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#include <mmsystem.h>

#include "dls1.h"
#include "dmerror.h"
#include "dmdls.h"
#include "dsound.h"
#include "dmusbuff.h"

#include <pshpack8.h>

#ifdef __cplusplus
extern "C" {
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */
typedef ULONGLONG    SAMPLE_TIME;
typedef ULONGLONG    SAMPLE_POSITION;
typedef SAMPLE_TIME *LPSAMPLE_TIME;
#endif

#define DMUS_MAX_DESCRIPTION 128
#define DMUS_MAX_DRIVER 128

typedef struct _DMUS_BUFFERDESC *LPDMUS_BUFFERDESC;
typedef struct _DMUS_BUFFERDESC
{
    DWORD dwSize;
    DWORD dwFlags;
    GUID guidBufferFormat;
    DWORD cbBuffer;
} DMUS_BUFFERDESC;

/* DMUS_EFFECT_ flags are used in the dwEffectFlags fields of both DMUS_PORTCAPS
 * and DMUS_PORTPARAMS.
 */
#define DMUS_EFFECT_NONE             0x00000000
#define DMUS_EFFECT_REVERB           0x00000001
#define DMUS_EFFECT_CHORUS           0x00000002
#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */
#define DMUS_EFFECT_DELAY            0x00000004
#endif

/* For DMUS_PORTCAPS dwClass
 */
#define DMUS_PC_INPUTCLASS       (0)
#define DMUS_PC_OUTPUTCLASS      (1)

/* For DMUS_PORTCAPS dwFlags
 */
#define DMUS_PC_DLS              (0x00000001)   /* Supports DLS downloading and DLS level 1. */
#define DMUS_PC_EXTERNAL         (0x00000002)   /* External MIDI module. */
#define DMUS_PC_SOFTWARESYNTH    (0x00000004)   /* Software synthesizer. */
#define DMUS_PC_MEMORYSIZEFIXED  (0x00000008)   /* Memory size is fixed. */
#define DMUS_PC_GMINHARDWARE     (0x00000010)   /* GM sound set is built in, no need to download. */
#define DMUS_PC_GSINHARDWARE     (0x00000020)   /* GS sound set is built in. */
#define DMUS_PC_XGINHARDWARE     (0x00000040)   /* XG sound set is built in. */
#define DMUS_PC_DIRECTSOUND      (0x00000080)   /* Connects to DirectSound via a DSound buffer. */
#define DMUS_PC_SHAREABLE        (0x00000100)   /* Synth can be actively shared by multiple apps at once. */
#define DMUS_PC_DLS2             (0x00000200)   /* Supports DLS2 instruments. */
#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */
#define DMUS_PC_AUDIOPATH        (0x00000400)   /* Multiple outputs can be connected to DirectSound for audiopaths. */
#define DMUS_PC_WAVE             (0x00000800)   /* Supports streaming and one shot waves. */
#endif

#define DMUS_PC_SYSTEMMEMORY     (0x7FFFFFFF)   /* Sample memory is system memory. */


typedef struct _DMUS_PORTCAPS
{
    DWORD   dwSize;
    DWORD   dwFlags;
    GUID    guidPort;
    DWORD   dwClass;
    DWORD   dwType;
    DWORD   dwMemorySize;
    DWORD   dwMaxChannelGroups;
    DWORD   dwMaxVoices;
    DWORD   dwMaxAudioChannels;
    DWORD   dwEffectFlags;
    WCHAR   wszDescription[DMUS_MAX_DESCRIPTION];
} DMUS_PORTCAPS;

typedef DMUS_PORTCAPS *LPDMUS_PORTCAPS;

/* Values for DMUS_PORTCAPS dwType. This field indicates the underlying
 * driver type of the port.
 */
#define DMUS_PORT_WINMM_DRIVER      (0)
#define DMUS_PORT_USER_MODE_SYNTH   (1)
#define DMUS_PORT_KERNEL_MODE       (2)

/* These flags (set in dwValidParams) indicate which other members of the */
/* DMUS_PORTPARAMS are valid. */
/* */
#define DMUS_PORTPARAMS_VOICES           0x00000001
#define DMUS_PORTPARAMS_CHANNELGROUPS    0x00000002
#define DMUS_PORTPARAMS_AUDIOCHANNELS    0x00000004
#define DMUS_PORTPARAMS_SAMPLERATE       0x00000008
#define DMUS_PORTPARAMS_EFFECTS          0x00000020
#define DMUS_PORTPARAMS_SHARE            0x00000040
#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */
#define DMUS_PORTPARAMS_FEATURES         0x00000080     /* DirectX 8.0 and above */
#endif

typedef struct _DMUS_PORTPARAMS
{
    DWORD   dwSize;
    DWORD   dwValidParams;
    DWORD   dwVoices;
    DWORD   dwChannelGroups;
    DWORD   dwAudioChannels;
    DWORD   dwSampleRate;
    DWORD   dwEffectFlags;
    BOOL    fShare;
} DMUS_PORTPARAMS7;

#if (NTDDI_VERSION < NTDDI_WINXP) /* Windows 2000 */

typedef DMUS_PORTPARAMS7 DMUS_PORTPARAMS;

#else /* NTDDI_VERSION < NTDDI_WINXP */

typedef struct _DMUS_PORTPARAMS8
{
    DWORD   dwSize;
    DWORD   dwValidParams;
    DWORD   dwVoices;
    DWORD   dwChannelGroups;
    DWORD   dwAudioChannels;
    DWORD   dwSampleRate;
    DWORD   dwEffectFlags;
    BOOL    fShare;
    DWORD   dwFeatures;
} DMUS_PORTPARAMS8;

#define DMUS_PORT_FEATURE_AUDIOPATH     0x00000001	/* Supports audiopath connection to DSound buffers. */
#define DMUS_PORT_FEATURE_STREAMING     0x00000002	/* Supports streaming waves through the synth. */

typedef DMUS_PORTPARAMS8 DMUS_PORTPARAMS;

#endif /* NTDDI_VERSION < NTDDI_WINXP */

typedef DMUS_PORTPARAMS *LPDMUS_PORTPARAMS;

typedef struct _DMUS_SYNTHSTATS *LPDMUS_SYNTHSTATS;
typedef struct _DMUS_SYNTHSTATS
{
    DWORD   dwSize;             /* Size in bytes of the structure */
    DWORD   dwValidStats;       /* Flags indicating which fields below are valid. */
    DWORD   dwVoices;           /* Average number of voices playing. */
    DWORD   dwTotalCPU;         /* Total CPU usage as percent * 100. */
    DWORD   dwCPUPerVoice;      /* CPU per voice as percent * 100. */
    DWORD   dwLostNotes;        /* Number of notes lost in 1 second. */
    DWORD   dwFreeMemory;       /* Free memory in bytes */
    long    lPeakVolume;        /* Decibel level * 100. */
} DMUS_SYNTHSTATS;

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

typedef struct _DMUS_SYNTHSTATS8 *LPDMUS_SYNTHSTATS8;
typedef struct _DMUS_SYNTHSTATS8
{
    DWORD   dwSize;             /* Size in bytes of the structure */
    DWORD   dwValidStats;       /* Flags indicating which fields below are valid. */
    DWORD   dwVoices;           /* Average number of voices playing. */
    DWORD   dwTotalCPU;         /* Total CPU usage as percent * 100. */
    DWORD   dwCPUPerVoice;      /* CPU per voice as percent * 100. */
    DWORD   dwLostNotes;        /* Number of notes lost in 1 second. */
    DWORD   dwFreeMemory;       /* Free memory in bytes */
    long    lPeakVolume;        /* Decibel level * 100. */
    DWORD   dwSynthMemUse;		/* Memory used by synth wave data */
} DMUS_SYNTHSTATS8;

#endif /* NTDDI_VERSION >= NTDDI_WINXP */

#define DMUS_SYNTHSTATS_VOICES          (1 << 0)
#define DMUS_SYNTHSTATS_TOTAL_CPU       (1 << 1)
#define DMUS_SYNTHSTATS_CPU_PER_VOICE   (1 << 2)
#define DMUS_SYNTHSTATS_LOST_NOTES      (1 << 3)
#define DMUS_SYNTHSTATS_PEAK_VOLUME     (1 << 4)
#define DMUS_SYNTHSTATS_FREE_MEMORY     (1 << 5)

#define DMUS_SYNTHSTATS_SYSTEMMEMORY    DMUS_PC_SYSTEMMEMORY

typedef struct _DMUS_WAVES_REVERB_PARAMS
{
    float   fInGain;        /* Input gain in dB (to avoid output overflows) */
    float   fReverbMix;     /* Reverb mix in dB. 0dB means 100% wet reverb (no direct signal)
                            Negative values gives less wet signal.
                            The coeficients are calculated so that the overall output level stays
                            (approximately) constant regardless of the ammount of reverb mix. */
    float   fReverbTime;    /* The reverb decay time, in milliseconds. */
    float   fHighFreqRTRatio; /* The ratio of the high frequencies to the global reverb time.
                            Unless very 'splashy-bright' reverbs are wanted, this should be set to
                            a value < 1.0.
                            For example if dRevTime==1000ms and dHighFreqRTRatio=0.1 than the
                            decay time for high frequencies will be 100ms.*/

} DMUS_WAVES_REVERB_PARAMS;

/*  Note: Default values for Reverb are:
    fInGain             = 0.0dB   (no change in level)
    fReverbMix          = -10.0dB   (a reasonable reverb mix)
    fReverbTime         = 1000.0ms (one second global reverb time)
    fHighFreqRTRatio    = 0.001    (the ratio of the high frequencies to the global reverb time)
*/

typedef enum
{
    DMUS_CLOCK_SYSTEM = 0,
    DMUS_CLOCK_WAVE = 1
} DMUS_CLOCKTYPE;

#define DMUS_CLOCKF_GLOBAL              0x00000001

typedef struct _DMUS_CLOCKINFO7 *LPDMUS_CLOCKINFO7;
typedef struct _DMUS_CLOCKINFO7
{
    DWORD           dwSize;
    DMUS_CLOCKTYPE  ctType;
    GUID            guidClock;          /* Identifies this time source */
    WCHAR           wszDescription[DMUS_MAX_DESCRIPTION];
} DMUS_CLOCKINFO7;

#if (NTDDI_VERSION < NTDDI_WINXP) /* Windows 2000 */

typedef DMUS_CLOCKINFO7 DMUS_CLOCKINFO;

#else /* NTDDI_VERSION < NTDDI_WINXP */

typedef struct _DMUS_CLOCKINFO8 *LPDMUS_CLOCKINFO8;
typedef struct _DMUS_CLOCKINFO8
{
    DWORD           dwSize;
    DMUS_CLOCKTYPE  ctType;
    GUID            guidClock;          /* Identifies this time source */
    WCHAR           wszDescription[DMUS_MAX_DESCRIPTION];
    DWORD           dwFlags;
} DMUS_CLOCKINFO8;

typedef DMUS_CLOCKINFO8 DMUS_CLOCKINFO;

#endif /* NTDDI_VERSION < NTDDI_WINXP */

typedef DMUS_CLOCKINFO *LPDMUS_CLOCKINFO;

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

/* Default bus identifiers
 *
 * The first 17 are direct mappings to the destinations defined in both
 * the MMA DLS Level 2 specification and the Microsoft Multi-Channel audio
 * specification.
 */
#define DSBUSID_FIRST_SPKR_LOC              0
#define DSBUSID_FRONT_LEFT                  0
#define DSBUSID_LEFT                        0   /* Front left is also just left */
#define DSBUSID_FRONT_RIGHT                 1
#define DSBUSID_RIGHT                       1   /* Ditto front right */
#define DSBUSID_FRONT_CENTER                2
#define DSBUSID_LOW_FREQUENCY               3
#define DSBUSID_BACK_LEFT                   4
#define DSBUSID_BACK_RIGHT                  5
#define DSBUSID_FRONT_LEFT_OF_CENTER        6
#define DSBUSID_FRONT_RIGHT_OF_CENTER       7
#define DSBUSID_BACK_CENTER                 8
#define DSBUSID_SIDE_LEFT                   9
#define DSBUSID_SIDE_RIGHT                 10
#define DSBUSID_TOP_CENTER                 11
#define DSBUSID_TOP_FRONT_LEFT             12
#define DSBUSID_TOP_FRONT_CENTER           13
#define DSBUSID_TOP_FRONT_RIGHT            14
#define DSBUSID_TOP_BACK_LEFT              15
#define DSBUSID_TOP_BACK_CENTER            16
#define DSBUSID_TOP_BACK_RIGHT             17
#define DSBUSID_LAST_SPKR_LOC              17

#define DSBUSID_IS_SPKR_LOC(id) ( ((id) >= DSBUSID_FIRST_SPKR_LOC) && ((id) <= DSBUSID_LAST_SPKR_LOC) )

/* These bus identifiers are for the standard DLS effect sends
 */
#define DSBUSID_REVERB_SEND                64
#define DSBUSID_CHORUS_SEND                65

/* Dynamic bus identifiers start here. See the documentation for how
 * synthesizers map the output of voices to static and dynamic
 * bus identifiers.
 */
#define DSBUSID_DYNAMIC_0                 512

/* Null bus, used to identify busses that have no function mapping.
*/
#define DSBUSID_NULL			   0xFFFFFFFF

#endif /* NTDDI_VERSION >= NTDDI_WINXP */

interface IDirectMusic;
#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */
interface IDirectMusic8;
#endif
interface IDirectMusicBuffer;
interface IDirectMusicPort;
interface IDirectMusicThru;
interface IReferenceClock;

#ifndef __cplusplus

typedef interface IDirectMusic IDirectMusic;
#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */
typedef interface IDirectMusic8 IDirectMusic8;
#endif
typedef interface IDirectMusicPort IDirectMusicPort;
typedef interface IDirectMusicBuffer IDirectMusicBuffer;
typedef interface IDirectMusicThru IDirectMusicThru;
typedef interface IReferenceClock IReferenceClock;

#endif  /* C++ */

typedef IDirectMusic *LPDIRECTMUSIC;
#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */
typedef IDirectMusic8 *LPDIRECTMUSIC8;
#endif
typedef IDirectMusicPort *LPDIRECTMUSICPORT;
typedef IDirectMusicBuffer *LPDIRECTMUSICBUFFER;

#undef  INTERFACE
#define INTERFACE  IDirectMusic
DECLARE_INTERFACE_(IDirectMusic, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusic */
    STDMETHOD(EnumPort)             (THIS_ DWORD dwIndex,
                                           LPDMUS_PORTCAPS pPortCaps) PURE;
    STDMETHOD(CreateMusicBuffer)    (THIS_ LPDMUS_BUFFERDESC pBufferDesc,
                                           LPDIRECTMUSICBUFFER *ppBuffer,
                                           LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(CreatePort)           (THIS_ REFCLSID rclsidPort,
                                           LPDMUS_PORTPARAMS pPortParams,
                                           LPDIRECTMUSICPORT *ppPort,
                                           LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(EnumMasterClock)      (THIS_ DWORD dwIndex,
                                           LPDMUS_CLOCKINFO lpClockInfo) PURE;
    STDMETHOD(GetMasterClock)       (THIS_ LPGUID pguidClock,
                                           IReferenceClock **ppReferenceClock) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ REFGUID rguidClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(GetDefaultPort)       (THIS_ LPGUID pguidPort) PURE;
    STDMETHOD(SetDirectSound)       (THIS_ LPDIRECTSOUND pDirectSound,
                                           HWND hWnd) PURE;
};

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

#undef  INTERFACE
#define INTERFACE  IDirectMusic8
DECLARE_INTERFACE_(IDirectMusic8, IDirectMusic)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusic */
    STDMETHOD(EnumPort)             (THIS_ DWORD dwIndex,
                                           LPDMUS_PORTCAPS pPortCaps) PURE;
    STDMETHOD(CreateMusicBuffer)    (THIS_ LPDMUS_BUFFERDESC pBufferDesc,
                                           LPDIRECTMUSICBUFFER *ppBuffer,
                                           LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(CreatePort)           (THIS_ REFCLSID rclsidPort,
                                           LPDMUS_PORTPARAMS pPortParams,
                                           LPDIRECTMUSICPORT *ppPort,
                                           LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(EnumMasterClock)      (THIS_ DWORD dwIndex,
                                           LPDMUS_CLOCKINFO lpClockInfo) PURE;
    STDMETHOD(GetMasterClock)       (THIS_ LPGUID pguidClock,
                                           IReferenceClock **ppReferenceClock) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ REFGUID rguidClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(GetDefaultPort)       (THIS_ LPGUID pguidPort) PURE;
    STDMETHOD(SetDirectSound)       (THIS_ LPDIRECTSOUND pDirectSound,
                                           HWND hWnd) PURE;
    /*  IDirectMusic8 */
    STDMETHOD(SetExternalMasterClock)
                                    (THIS_ IReferenceClock *pClock) PURE;
};

#endif /* NTDDI_VERSION >= NTDDI_WINXP */

#undef  INTERFACE
#define INTERFACE  IDirectMusicBuffer
DECLARE_INTERFACE_(IDirectMusicBuffer, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicBuffer */
    STDMETHOD(Flush)                (THIS) PURE;
    STDMETHOD(TotalTime)            (THIS_ LPREFERENCE_TIME prtTime) PURE;

    STDMETHOD(PackStructured)       (THIS_ REFERENCE_TIME rt,
                                           DWORD dwChannelGroup,
                                           DWORD dwChannelMessage) PURE;

    STDMETHOD(PackUnstructured)     (THIS_ REFERENCE_TIME rt,
                                           DWORD dwChannelGroup,
                                           DWORD cb,
                                           LPBYTE lpb) PURE;

    STDMETHOD(ResetReadPtr)         (THIS) PURE;
    STDMETHOD(GetNextEvent)         (THIS_ LPREFERENCE_TIME prt,
                                           LPDWORD pdwChannelGroup,
                                           LPDWORD pdwLength,
                                           LPBYTE *ppData) PURE;

    STDMETHOD(GetRawBufferPtr)      (THIS_ LPBYTE *ppData) PURE;
    STDMETHOD(GetStartTime)         (THIS_ LPREFERENCE_TIME prt) PURE;
    STDMETHOD(GetUsedBytes)         (THIS_ LPDWORD pcb) PURE;
    STDMETHOD(GetMaxBytes)          (THIS_ LPDWORD pcb) PURE;
    STDMETHOD(GetBufferFormat)      (THIS_ LPGUID pGuidFormat) PURE;

    STDMETHOD(SetStartTime)         (THIS_ REFERENCE_TIME rt) PURE;
    STDMETHOD(SetUsedBytes)         (THIS_ DWORD cb) PURE;
};

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

typedef IDirectMusicBuffer IDirectMusicBuffer8;
typedef IDirectMusicBuffer8 *LPDIRECTMUSICBUFFER8;

#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicInstrument
DECLARE_INTERFACE_(IDirectMusicInstrument, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /* IDirectMusicInstrument */
    STDMETHOD(GetPatch)                 (THIS_ DWORD* pdwPatch) PURE;
    STDMETHOD(SetPatch)                 (THIS_ DWORD dwPatch) PURE;
};

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

typedef IDirectMusicInstrument IDirectMusicInstrument8;
typedef IDirectMusicInstrument8 *LPDIRECTMUSICINSTRUMENT8;

#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicDownloadedInstrument
DECLARE_INTERFACE_(IDirectMusicDownloadedInstrument, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /* IDirectMusicDownloadedInstrument */
    /* None at this time */
};

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

typedef IDirectMusicDownloadedInstrument IDirectMusicDownloadedInstrument8;
typedef IDirectMusicDownloadedInstrument8 *LPDIRECTMUSICDOWNLOADEDINSTRUMENT8;

#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicCollection
DECLARE_INTERFACE_(IDirectMusicCollection, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /* IDirectMusicCollection */
    STDMETHOD(GetInstrument)            (THIS_ DWORD dwPatch,
                                               IDirectMusicInstrument** ppInstrument) PURE;
    STDMETHOD(EnumInstrument)           (THIS_ DWORD dwIndex,
                                               DWORD* pdwPatch,
                                               LPWSTR pwszName,
                                               DWORD dwNameLen) PURE;
};

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

typedef IDirectMusicCollection IDirectMusicCollection8;
typedef IDirectMusicCollection8 *LPDIRECTMUSICCOLLECTION8;

#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicDownload
DECLARE_INTERFACE_(IDirectMusicDownload , IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicDownload */
    STDMETHOD(GetBuffer)            (THIS_ void** ppvBuffer,
                                           DWORD* pdwSize) PURE;
};

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

typedef IDirectMusicDownload IDirectMusicDownload8;
typedef IDirectMusicDownload8 *LPDIRECTMUSICDOWNLOAD8;

#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicPortDownload
DECLARE_INTERFACE_(IDirectMusicPortDownload, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicPortDownload */
    STDMETHOD(GetBuffer)            (THIS_ DWORD dwDLId,
                                           IDirectMusicDownload** ppIDMDownload) PURE;
    STDMETHOD(AllocateBuffer)       (THIS_ DWORD dwSize,
                                           IDirectMusicDownload** ppIDMDownload) PURE;
    STDMETHOD(GetDLId)              (THIS_ DWORD* pdwStartDLId,
                                           DWORD dwCount) PURE;
    STDMETHOD(GetAppend)            (THIS_ DWORD* pdwAppend) PURE;
    STDMETHOD(Download)             (THIS_ IDirectMusicDownload* pIDMDownload) PURE;
    STDMETHOD(Unload)               (THIS_ IDirectMusicDownload* pIDMDownload) PURE;
};

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

typedef IDirectMusicPortDownload IDirectMusicPortDownload8;
typedef IDirectMusicPortDownload8 *LPDIRECTMUSICPORTDOWNLOAD8;

#endif

/* Standard values for voice priorities. Numerically higher priorities are higher in priority.
 * These priorities are used to set the voice priority for all voices on a channel. They are
 * used in the dwPriority parameter of IDirectMusicPort::GetPriority and returned in the
 * lpwPriority parameter of pdwPriority.
 *
 * These priorities are shared with DirectSound.
 */

#ifndef _DIRECTAUDIO_PRIORITIES_DEFINED_
#define _DIRECTAUDIO_PRIORITIES_DEFINED_

#define DAUD_CRITICAL_VOICE_PRIORITY    (0xF0000000)
#define DAUD_HIGH_VOICE_PRIORITY        (0xC0000000)
#define DAUD_STANDARD_VOICE_PRIORITY    (0x80000000)
#define DAUD_LOW_VOICE_PRIORITY         (0x40000000)
#define DAUD_PERSIST_VOICE_PRIORITY     (0x10000000)

/* These are the default priorities assigned if not overridden. By default priorities are
 * equal across channel groups (e.g. channel 5 on channel group 1 has the same priority as
 * channel 5 on channel group 2).
 *
 * In accordance with DLS level 1, channel 10 has the highest priority, followed by 1 through 16
 * except for 10.
 */
#define DAUD_CHAN1_VOICE_PRIORITY_OFFSET    (0x0000000E)
#define DAUD_CHAN2_VOICE_PRIORITY_OFFSET    (0x0000000D)
#define DAUD_CHAN3_VOICE_PRIORITY_OFFSET    (0x0000000C)
#define DAUD_CHAN4_VOICE_PRIORITY_OFFSET    (0x0000000B)
#define DAUD_CHAN5_VOICE_PRIORITY_OFFSET    (0x0000000A)
#define DAUD_CHAN6_VOICE_PRIORITY_OFFSET    (0x00000009)
#define DAUD_CHAN7_VOICE_PRIORITY_OFFSET    (0x00000008)
#define DAUD_CHAN8_VOICE_PRIORITY_OFFSET    (0x00000007)
#define DAUD_CHAN9_VOICE_PRIORITY_OFFSET    (0x00000006)
#define DAUD_CHAN10_VOICE_PRIORITY_OFFSET   (0x0000000F)
#define DAUD_CHAN11_VOICE_PRIORITY_OFFSET   (0x00000005)
#define DAUD_CHAN12_VOICE_PRIORITY_OFFSET   (0x00000004)
#define DAUD_CHAN13_VOICE_PRIORITY_OFFSET   (0x00000003)
#define DAUD_CHAN14_VOICE_PRIORITY_OFFSET   (0x00000002)
#define DAUD_CHAN15_VOICE_PRIORITY_OFFSET   (0x00000001)
#define DAUD_CHAN16_VOICE_PRIORITY_OFFSET   (0x00000000)


#define DAUD_CHAN1_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN1_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN2_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN2_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN3_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN3_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN4_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN4_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN5_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN5_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN6_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN6_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN7_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN7_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN8_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN8_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN9_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN9_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN10_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN10_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN11_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN11_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN12_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN12_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN13_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN13_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN14_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN14_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN15_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN15_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN16_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN16_VOICE_PRIORITY_OFFSET)

#endif  /* _DIRECTAUDIO_PRIORITIES_DEFINED_ */


#undef  INTERFACE
#define INTERFACE  IDirectMusicPort
DECLARE_INTERFACE_(IDirectMusicPort, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicPort */
    /*  */
    STDMETHOD(PlayBuffer)           (THIS_ LPDIRECTMUSICBUFFER pBuffer) PURE;
    STDMETHOD(SetReadNotificationHandle) (THIS_ HANDLE hEvent) PURE;
    STDMETHOD(Read)                 (THIS_ LPDIRECTMUSICBUFFER pBuffer) PURE;
    STDMETHOD(DownloadInstrument)   (THIS_ IDirectMusicInstrument *pInstrument,
                                     IDirectMusicDownloadedInstrument **ppDownloadedInstrument,
                                     DMUS_NOTERANGE *pNoteRanges,
                                     DWORD dwNumNoteRanges) PURE;
    STDMETHOD(UnloadInstrument)     (THIS_ IDirectMusicDownloadedInstrument *pDownloadedInstrument) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(GetRunningStats)      (THIS_ LPDMUS_SYNTHSTATS pStats) PURE;
    STDMETHOD(Compact)              (THIS) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDMUS_PORTCAPS pPortCaps) PURE;
    STDMETHOD(DeviceIoControl)      (THIS_ DWORD dwIoControlCode,
                                           LPVOID lpInBuffer,
                                           DWORD nInBufferSize,
                                           LPVOID lpOutBuffer,
                                           DWORD nOutBufferSize,
                                           LPDWORD lpBytesReturned,
                                           LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(SetNumChannelGroups)  (THIS_ DWORD dwChannelGroups) PURE;
    STDMETHOD(GetNumChannelGroups)  (THIS_ LPDWORD pdwChannelGroups) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fActive) PURE;
    STDMETHOD(SetChannelPriority)   (THIS_ DWORD dwChannelGroup, DWORD dwChannel, DWORD dwPriority) PURE;
    STDMETHOD(GetChannelPriority)   (THIS_ DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwPriority) PURE;
    STDMETHOD(SetDirectSound)       (THIS_ LPDIRECTSOUND pDirectSound, LPDIRECTSOUNDBUFFER pDirectSoundBuffer) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pWaveFormatEx, LPDWORD pdwWaveFormatExSize, LPDWORD pdwBufferSize) PURE;
};

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

typedef IDirectMusicPort IDirectMusicPort8;
typedef IDirectMusicPort8 *LPDIRECTMUSICPORT8;

#endif

#undef  INTERFACE
#define INTERFACE  IDirectMusicThru
DECLARE_INTERFACE_(IDirectMusicThru, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicThru
     */
    STDMETHOD(ThruChannel)          (THIS_ DWORD dwSourceChannelGroup,
                                           DWORD dwSourceChannel,
                                           DWORD dwDestinationChannelGroup,
                                           DWORD dwDestinationChannel,
                                           LPDIRECTMUSICPORT pDestinationPort) PURE;
};

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

typedef IDirectMusicThru IDirectMusicThru8;
typedef IDirectMusicThru8 *LPDIRECTMUSICTHRU8;

#endif

#ifndef __IReferenceClock_INTERFACE_DEFINED__
#define __IReferenceClock_INTERFACE_DEFINED__

DEFINE_GUID(IID_IReferenceClock,0x56a86897,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#undef  INTERFACE
#define INTERFACE  IReferenceClock
DECLARE_INTERFACE_(IReferenceClock, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /*  IReferenceClock */
    /*  */

    /*  get the time now */
    STDMETHOD(GetTime)                  (THIS_ REFERENCE_TIME *pTime) PURE;

    /*  ask for an async notification that a time has elapsed */
    STDMETHOD(AdviseTime)               (THIS_ REFERENCE_TIME baseTime,         /*  base time */
                                               REFERENCE_TIME streamTime,       /*  stream offset time */
                                               HANDLE hEvent,                   /*  advise via this event */
                                               DWORD * pdwAdviseCookie) PURE;   /*  where your cookie goes */

    /*  ask for an async periodic notification that a time has elapsed */
    STDMETHOD(AdvisePeriodic)           (THIS_ REFERENCE_TIME startTime,        /*  starting at this time */
                                               REFERENCE_TIME periodTime,       /*  time between notifications */
                                               HANDLE hSemaphore,               /*  advise via a semaphore */
                                               DWORD * pdwAdviseCookie) PURE;   /*  where your cookie goes */

    /*  cancel a request for notification */
    STDMETHOD(Unadvise)                 (THIS_ DWORD dwAdviseCookie) PURE;
};

#endif /* __IReferenceClock_INTERFACE_DEFINED__ */

DEFINE_GUID(CLSID_DirectMusic,0x636b9f10,0x0c7d,0x11d1,0x95,0xb2,0x00,0x20,0xaf,0xdc,0x74,0x21);
DEFINE_GUID(CLSID_DirectMusicCollection,0x480ff4b0, 0x28b2, 0x11d1, 0xbe, 0xf7, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);
DEFINE_GUID(CLSID_DirectMusicSynth,0x58C2B4D0,0x46E7,0x11D1,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);

DEFINE_GUID(IID_IDirectMusic,0x6536115a,0x7b2d,0x11d2,0xba,0x18,0x00,0x00,0xf8,0x75,0xac,0x12);
DEFINE_GUID(IID_IDirectMusicBuffer,0xd2ac2878, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicPort, 0x08f2d8c9,0x37c2,0x11d2,0xb9,0xf9,0x00,0x00,0xf8,0x75,0xac,0x12);
DEFINE_GUID(IID_IDirectMusicThru, 0xced153e7, 0x3606, 0x11d2, 0xb9, 0xf9, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(IID_IDirectMusicPortDownload,0xd2ac287a, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicDownload,0xd2ac287b, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicCollection,0xd2ac287c, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicInstrument,0xd2ac287d, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicDownloadedInstrument,0xd2ac287e, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);


/* Alternate interface ID for IID_IDirectMusic, available in DX7 release and after. */
DEFINE_GUID(IID_IDirectMusic2,0x6fc2cae1, 0xbc78, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

DEFINE_GUID(IID_IDirectMusic8,0x2d3629f7,0x813d,0x4939,0x85,0x08,0xf0,0x5c,0x6b,0x75,0xfd,0x97);

#define IID_IDirectMusicThru8 IID_IDirectMusicThru
#define IID_IDirectMusicPortDownload8 IID_IDirectMusicPortDownload
#define IID_IDirectMusicDownload8 IID_IDirectMusicDownload
#define IID_IDirectMusicCollection8 IID_IDirectMusicCollection
#define IID_IDirectMusicInstrument8 IID_IDirectMusicInstrument
#define IID_IDirectMusicDownloadedInstrument8 IID_IDirectMusicDownloadedInstrument
#define IID_IDirectMusicPort8 IID_IDirectMusicPort

#endif

/* Property Query GUID_DMUS_PROP_GM_Hardware - Local GM set, no need to download
 * Property Query GUID_DMUS_PROP_GS_Hardware - Local GS set, no need to download
 * Property Query GUID_DMUS_PROP_XG_Hardware - Local XG set, no need to download
 * Property Query GUID_DMUS_PROP_DLS1        - Support DLS level 1
 * Property Query GUID_DMUS_PROP_INSTRUMENT2 - Support new INSTRUMENT2 download format
 * Property Query GUID_DMUS_PROP_XG_Capable  - Support minimum requirements of XG
 * Property Query GUID_DMUS_PROP_GS_Capable  - Support minimum requirements of GS
 * Property Query GUID_DMUS_PROP_SynthSink_DSOUND - Synthsink talks to DSound
 * Property Query GUID_DMUS_PROP_SynthSink_WAVE - Synthsink talks to Wave device
 *
 * Item 0: Supported
 * Returns a DWORD which is non-zero if the feature is supported
 */
DEFINE_GUID(GUID_DMUS_PROP_GM_Hardware, 0x178f2f24, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_GS_Hardware, 0x178f2f25, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_XG_Hardware, 0x178f2f26, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_XG_Capable,  0x6496aba1, 0x61b0, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_GS_Capable,  0x6496aba2, 0x61b0, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_DLS1,        0x178f2f27, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_DLS2,        0xf14599e5, 0x4689, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_INSTRUMENT2, 0x865fd372, 0x9f67, 0x11d2, 0x87, 0x2a, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_DMUS_PROP_SynthSink_DSOUND,0xaa97844, 0xc877, 0x11d1, 0x87, 0xc, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_DMUS_PROP_SynthSink_WAVE,0xaa97845, 0xc877, 0x11d1, 0x87, 0xc, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_DMUS_PROP_SampleMemorySize, 0x178f2f28, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_SamplePlaybackRate, 0x2a91f713, 0xa4bf, 0x11d2, 0xbb, 0xdf, 0x0, 0x60, 0x8, 0x33, 0xdb, 0xd8);

/* Property Get/Set GUID_DMUS_PROP_WriteLatency
 *
 * Item 0: Synth buffer write latency, in milliseconds
 * Get/Set SynthSink latency, the average time after the play head that the next buffer gets written.
 */
DEFINE_GUID(GUID_DMUS_PROP_WriteLatency,0x268a0fa0, 0x60f2, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

/* Property Get/Set GUID_DMUS_PROP_WritePeriod
 *
 * Item 0: Synth buffer write period, in milliseconds
 * Get/Set SynthSink buffer write period, time span between successive writes.
 */
DEFINE_GUID(GUID_DMUS_PROP_WritePeriod,0x268a0fa1, 0x60f2, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

/* Property Get GUID_DMUS_PROP_MemorySize
 *
 * Item 0: Memory size
 * Returns a DWORD containing the total number of bytes of sample RAM
 */
DEFINE_GUID(GUID_DMUS_PROP_MemorySize,  0x178f2f28, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

/* Property Set GUID_DMUS_PROP_WavesReverb
 *
 * Item 0: DMUS_WAVES_REVERB structure
 * Sets reverb parameters
 */
DEFINE_GUID(GUID_DMUS_PROP_WavesReverb,0x4cb5622, 0x32e5, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

/* Property Set GUID_DMUS_PROP_Effects
 *
 * Item 0: DWORD with effects flags.
 * Get/Set effects bits, same as dwEffectFlags in DMUS_PORTPARAMS and DMUS_PORTCAPS:
 * DMUS_EFFECT_NONE
 * DMUS_EFFECT_REVERB
 * DMUS_EFFECT_CHORUS
 */
DEFINE_GUID(GUID_DMUS_PROP_Effects, 0xcda8d611, 0x684a, 0x11d2, 0x87, 0x1e, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Property Set GUID_DMUS_PROP_LegacyCaps
 *
 * Item 0: The MIDINCAPS or MIDIOUTCAPS which describes the port's underlying WinMM device. This property is only supported
 * by ports which wrap WinMM devices.
 */

DEFINE_GUID(GUID_DMUS_PROP_LegacyCaps,0xcfa7cdc2, 0x00a1, 0x11d2, 0xaa, 0xd5, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

/* Property Set GUID_DMUS_PROP_Volume
 *
 * Item 0: A long which contains an offset, in 1/100 dB, to be added to the final volume
 *
 */
DEFINE_GUID(GUID_DMUS_PROP_Volume, 0xfedfae25L, 0xe46e, 0x11d1, 0xaa, 0xce, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

/* Min and Max values for setting volume with GUID_DMUS_PROP_Volume */

#define DMUS_VOLUME_MAX     2000        /* +20 dB */
#define DMUS_VOLUME_MIN   -20000        /* -200 dB */

#ifdef __cplusplus
}; /* extern "C" */
#endif

#include <poppack.h>

#endif /* #ifndef _DMUSICC_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dmusics.h ===
/************************************************************************
*                                                                       *
*   dmusics.h -- Definitions for created a DirectMusic software synth   *
*                                                                       *
*   Copyright (c) Microsoft Corporation.  All rights reserved.          *
*                                                                       *
************************************************************************/

#ifndef _DMUSICS_
#define _DMUSICS_

#include "dmusicc.h"

/* Software synths are enumerated from under this registry key.
 */
#define REGSTR_PATH_SOFTWARESYNTHS  "Software\\Microsoft\\DirectMusic\\SoftwareSynths"

interface IDirectMusicSynth;
interface IDirectMusicSynthSink;

#ifndef __cplusplus
typedef interface IDirectMusicSynth IDirectMusicSynth;
typedef interface IDirectMusicSynthSink IDirectMusicSynthSink;
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

#ifndef _DMUS_VOICE_STATE_DEFINED
#define _DMUS_VOICE_STATE_DEFINED

typedef struct _DMUS_VOICE_STATE
{
    BOOL                bExists;
    SAMPLE_POSITION     spPosition;
} DMUS_VOICE_STATE;

#endif /* _DMUS_VOICE_STATE_DEFINED */

/* IDirectMusicSynth::Refresh
 *
 * This is the last buffer of the stream. It may be a partial block.
 */
#define REFRESH_F_LASTBUFFER        0x00000001

#endif /* NTDDI_VERSION >= NTDDI_WINXP */

#undef  INTERFACE
#define INTERFACE  IDirectMusicSynth
DECLARE_INTERFACE_(IDirectMusicSynth, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSynth */
    STDMETHOD(Open)                 (THIS_ LPDMUS_PORTPARAMS pPortParams) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(SetNumChannelGroups)  (THIS_ DWORD dwGroups) PURE;
    STDMETHOD(Download)             (THIS_ LPHANDLE phDownload,
                                           LPVOID pvData,
                                           LPBOOL pbFree ) PURE;
    STDMETHOD(Unload)               (THIS_ HANDLE hDownload,
                                           HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE),
                                           HANDLE hUserData ) PURE;
    STDMETHOD(PlayBuffer)           (THIS_ REFERENCE_TIME rt,
                                           LPBYTE pbBuffer,
                                           DWORD cbBuffer) PURE;
    STDMETHOD(GetRunningStats)      (THIS_ LPDMUS_SYNTHSTATS pStats) PURE;
    STDMETHOD(GetPortCaps)          (THIS_ LPDMUS_PORTCAPS pCaps) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(SetSynthSink)         (THIS_ IDirectMusicSynthSink *pSynthSink) PURE;
    STDMETHOD(Render)               (THIS_ short *pBuffer,
                                           DWORD dwLength,
                                           LONGLONG llPosition) PURE;
    STDMETHOD(SetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           DWORD dwPriority) PURE;
    STDMETHOD(GetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           LPDWORD pdwPriority) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pWaveFormatEx,
                                           LPDWORD pdwWaveFormatExSize) PURE;
    STDMETHOD(GetAppend)            (THIS_ DWORD* pdwAppend) PURE;
};

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */

#undef  INTERFACE
#define INTERFACE  IDirectMusicSynth8
DECLARE_INTERFACE_(IDirectMusicSynth8, IDirectMusicSynth)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSynth */
    STDMETHOD(Open)                 (THIS_ LPDMUS_PORTPARAMS pPortParams) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(SetNumChannelGroups)  (THIS_ DWORD dwGroups) PURE;
    STDMETHOD(Download)             (THIS_ LPHANDLE phDownload,
                                           LPVOID pvData,
                                           LPBOOL pbFree ) PURE;
    STDMETHOD(Unload)               (THIS_ HANDLE hDownload,
                                           HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE),
                                           HANDLE hUserData ) PURE;
    STDMETHOD(PlayBuffer)           (THIS_ REFERENCE_TIME rt,
                                           LPBYTE pbBuffer,
                                           DWORD cbBuffer) PURE;
    STDMETHOD(GetRunningStats)      (THIS_ LPDMUS_SYNTHSTATS pStats) PURE;
    STDMETHOD(GetPortCaps)          (THIS_ LPDMUS_PORTCAPS pCaps) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(SetSynthSink)         (THIS_ IDirectMusicSynthSink *pSynthSink) PURE;
    STDMETHOD(Render)               (THIS_ short *pBuffer,
                                           DWORD dwLength,
                                           LONGLONG llPosition) PURE;
    STDMETHOD(SetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           DWORD dwPriority) PURE;
    STDMETHOD(GetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           LPDWORD pdwPriority) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pWaveFormatEx,
                                           LPDWORD pdwWaveFormatExSize) PURE;
    STDMETHOD(GetAppend)            (THIS_ DWORD* pdwAppend) PURE;

	/* IDirectMusicSynth8 */
    STDMETHOD(PlayVoice)            (THIS_ REFERENCE_TIME rt,
										   DWORD dwVoiceId,
										   DWORD dwChannelGroup,
										   DWORD dwChannel,
										   DWORD dwDLId,
										   long	 prPitch,			/* PREL not defined here */
										   long  vrVolume,          /* VREL not defined here */
                                           SAMPLE_TIME stVoiceStart,
                                           SAMPLE_TIME stLoopStart,
                                           SAMPLE_TIME stLoopEnd) PURE;

    STDMETHOD(StopVoice)            (THIS_ REFERENCE_TIME rt,
										   DWORD dwVoiceId ) PURE;

    STDMETHOD(GetVoiceState)        (THIS_ DWORD dwVoice[],
										   DWORD cbVoice,
										   DMUS_VOICE_STATE dwVoiceState[] ) PURE;
    STDMETHOD(Refresh)              (THIS_ DWORD dwDownloadID,
                                           DWORD dwFlags) PURE;
    STDMETHOD(AssignChannelToBuses) (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           LPDWORD pdwBuses,
                                           DWORD cBuses) PURE;
};

#endif /* NTDDI_VERSION >= NTDDI_WINXP */

#undef  INTERFACE
#define INTERFACE  IDirectMusicSynthSink
DECLARE_INTERFACE_(IDirectMusicSynthSink, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSynthSink */
    STDMETHOD(Init)                 (THIS_ IDirectMusicSynth *pSynth) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(SampleToRefTime)      (THIS_ LONGLONG llSampleTime,
                                           REFERENCE_TIME *prfTime) PURE;
    STDMETHOD(RefTimeToSample)      (THIS_ REFERENCE_TIME rfTime,
                                           LONGLONG *pllSampleTime) PURE;
    STDMETHOD(SetDirectSound)       (THIS_ LPDIRECTSOUND pDirectSound,
                                           LPDIRECTSOUNDBUFFER pDirectSoundBuffer) PURE;
    STDMETHOD(GetDesiredBufferSize) (THIS_ LPDWORD pdwBufferSizeInSamples) PURE;
};


DEFINE_GUID(IID_IDirectMusicSynth, 0x9823661,  0x5c85, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(IID_IDirectMusicSynthSink,0x9823663, 0x5c85, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

#if (NTDDI_VERSION >= NTDDI_WINXP) /* Windows XP or greater */
DEFINE_GUID(IID_IDirectMusicSynth8,0x53cab625, 0x2711, 0x4c9f, 0x9d, 0xe7, 0x1b, 0x7f, 0x92, 0x5f, 0x6f, 0xc8);
#else
DEFINE_GUID(CLSID_DirectMusicSynthSink,0xaec17ce3, 0xa514, 0x11d1, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
#endif

/* Property Set GUID_DMUS_PROP_SetSynthSink
 *
 * Item 0: An IUnknown on which the port can QueryInterface for a user-mode synth sink.
 */
DEFINE_GUID(GUID_DMUS_PROP_SetSynthSink,0x0a3a5ba5, 0x37b6, 0x11d2, 0xb9, 0xf9, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

/* Property Set GUID_DMUS_PROP_SinkUsesDSound
 *
 * Item 0: A DWORD boolean indicating whether or not the sink requires an IDirectSound interface. The
 * default is FALSE if this property item is not implemented by the sink.
 */
DEFINE_GUID(GUID_DMUS_PROP_SinkUsesDSound, 0xbe208857, 0x8952, 0x11d2, 0xba, 0x1c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dmort.h ===
//------------------------------------------------------------------------------
// File: DMORt.h
//
// Desc: Miscellaneous runtime support for DirectShow Media Objects
//
// Copyright (c) 1999 - 2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __DMORT_H__
#define __DMORT_H__

//
// Mediatype helpers.  MoInitMediaType() goes with MoFreeMediaType(), and
// MoCreateMediaType() goes with MoDeleteMediaType().  Don't mix them!
//



//
// Takes a pointer to an already allocated DMO_MEDIA_TYPE structure, allocates
// a format block of cbFormat bytes, and sets appropriate members of
// DMO_MEDIA_TYPE to point to the newly allocated format block.  Also
// initializes the IUnknown pointer inside DMO_MEDIA_TYPE to NULL.
//
// The format block allocated by MoInitMediaType must be freed by calling
// MoFreeMediaType().
//
STDAPI MoInitMediaType(DMO_MEDIA_TYPE *pmt, DWORD cbFormat);

//
// Frees the format block and releases any IUnknown, but does not free the
// DMO_MEDIA_TYPE structure itself.  Input parameter must point to an
// DMO_MEDIA_TYPE structure previously initialized by MoInitMediaType().
//
STDAPI MoFreeMediaType(DMO_MEDIA_TYPE *pmt);

//
// Copies the DMO_MEDIA_TYPE members.  Also duplicates the format block and
// the IUnknown pointer.  Both parameters must point to valid DMO_MEDIA_TYPE
// structures.  Target structure must be later freed using MoFreeMediaType().
//
STDAPI MoCopyMediaType(DMO_MEDIA_TYPE *pmtDest, const DMO_MEDIA_TYPE *pmtSrc);



//
// Allocates a new DMO_MEDIA_TYPE structure and initializes it just like
// MoInitMediaType.  I.e., this function allocates both the format block
// and the DMO_MEDIA_TYPE structure itself.  Pointer to DMO_MEDIA_TYPE is
// returned as *ppmt.
//
// DMO_MEDIA_TYPE structures allocated by MoCreateMediaType() must be freed
// by calling MoDeleteMediaType().
//
STDAPI MoCreateMediaType(DMO_MEDIA_TYPE **ppmt, DWORD cbFormat);

//
// Frees any format block, releases any IUnknown, and deletes the
// DMO_MEDIA_TYPE structure itself.  The input parameter must point to an
// DMO_MEDIA_TYPE structure previously allocated by MoCreateMediaType().
//
STDAPI MoDeleteMediaType(DMO_MEDIA_TYPE *pmt);

//
// Allocates a new DMO_MEDIA_TYPE structure and copies pmtSrc into it like
// MoCopyMediaType.  I.e., this function allocates a new DMO_MEDIA_TYPE struct
// as well as a new format block for the target mediatype.  Trager mediatype
// must later be freed using MoDeleteMediaType().
//
STDAPI MoDuplicateMediaType(DMO_MEDIA_TYPE **ppmtDest, const DMO_MEDIA_TYPE *pmtSrc);



#endif //__DMORT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dmoreg.h ===
//------------------------------------------------------------------------------
// File: DMOReg.h
//
// Desc: 
//
// Copyright (c) 1999 - 2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __DMOREG_H__
#define __DMOREG_H__

#include "mediaobj.h"


// 57f2db8b-e6bb-4513-9d43-dcd2a6593125
DEFINE_GUID(DMOCATEGORY_AUDIO_DECODER, 0x57f2db8b,0xe6bb,0x4513,0x9d,0x43,0xdc,0xd2,0xa6,0x59,0x31,0x25);
// 33D9A761-90C8-11d0-BD43-00A0C911CE86
DEFINE_GUID(DMOCATEGORY_AUDIO_ENCODER, 0x33D9A761,0x90C8,0x11d0,0xBD,0x43,0x00,0xA0,0xC9,0x11,0xCE,0x86);
// 4a69b442-28be-4991-969c-b500adf5d8a8
DEFINE_GUID(DMOCATEGORY_VIDEO_DECODER, 0x4a69b442,0x28be,0x4991,0x96,0x9c,0xb5,0x00,0xad,0xf5,0xd8,0xa8);
// 33D9A760-90C8-11d0-BD43-00A0C911CE86
DEFINE_GUID(DMOCATEGORY_VIDEO_ENCODER, 0x33D9A760,0x90C8,0x11d0,0xBD,0x43,0x00,0xA0,0xC9,0x11,0xCE,0x86);
// f3602b3f-0592-48df-a4cd-674721e7ebeb
DEFINE_GUID(DMOCATEGORY_AUDIO_EFFECT, 0xf3602b3f,0x0592,0x48df,0xa4,0xcd,0x67,0x47,0x21,0xe7,0xeb,0xeb);
// d990ee14-776c-4723-be46-3da2f56f10b9
DEFINE_GUID(DMOCATEGORY_VIDEO_EFFECT, 0xd990ee14,0x776c,0x4723,0xbe,0x46,0x3d,0xa2,0xf5,0x6f,0x10,0xb9);
// f665aaba-3e09-4920-aa5f-219811148f09
DEFINE_GUID(DMOCATEGORY_AUDIO_CAPTURE_EFFECT, 0xf665aaba,0x3e09,0x4920,0xaa,0x5f,0x21,0x98,0x11,0x14,0x8f,0x09);

// Acoustic Echo Canceller {BF963D80-C559-11D0-8A2B-00A0C9255AC1}
// Matches KSNODETYPE_ACOUSTIC_ECHO_CANCEL in ksmedia.h
DEFINE_GUID(DMOCATEGORY_ACOUSTIC_ECHO_CANCEL, 0xBF963D80L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1);

// Noise Supression {E07F903F-62FD-4e60-8CDD-DEA7236665B5}
// Matches KSNODETYPE_AUDIO_NOISE_SUPPRESS in post Windows ME DDK's ksmedia.h
DEFINE_GUID(DMOCATEGORY_AUDIO_NOISE_SUPPRESS, 0xe07f903f, 0x62fd, 0x4e60, 0x8c, 0xdd, 0xde, 0xa7, 0x23, 0x66, 0x65, 0xb5);

// Automatic Gain Control {E88C9BA0-C557-11D0-8A2B-00A0C9255AC1}
// Matches KSNODETYPE_AGC in ksmedia.h
DEFINE_GUID(DMOCATEGORY_AGC, 0xE88C9BA0L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1);

typedef struct _DMO_PARTIAL_MEDIATYPE {
   GUID type;
   GUID subtype;
} DMO_PARTIAL_MEDIATYPE, *PDMO_PARTIAL_MEDIATYPE;

enum DMO_REGISTER_FLAGS {
   DMO_REGISTERF_IS_KEYED = 0x00000001
};

enum DMO_ENUM_FLAGS {
   DMO_ENUMF_INCLUDE_KEYED = 0x00000001
};

STDAPI DMORegister(
   LPCWSTR szName,
   REFCLSID clsidDMO,
   REFGUID guidCategory,
   DWORD dwFlags, // DMO_REGISTERF_XXX
   //
   // Register all mediatypes supported by the object.  This carries no
   // information about which combinations of input/output types would
   // actually work.
   //
   DWORD cInTypes,
   const DMO_PARTIAL_MEDIATYPE *pInTypes,
   DWORD cOutTypes,
   const DMO_PARTIAL_MEDIATYPE *pOutTypes
);

STDAPI DMOUnregister(
   REFCLSID clsidDMO,
   REFGUID guidCategory // optional - GUID_NULL means unregister from all
);

STDAPI DMOEnum(
   REFGUID guidCategory, // GUID_NULL for "all"
   DWORD dwFlags, // DMO_ENUMF_XXX
   //
   // Enumerate only objects that support at least one of the specified input types
   // and at least one of the specified output types.  If no input types are specified,
   // enumerate objects regardless of what input types they support.  Same for
   // output types.
   //
   DWORD cInTypes,
   const DMO_PARTIAL_MEDIATYPE *pInTypes, // can be NULL only of ulInTypes = 0
   DWORD cOutTypes,
   const DMO_PARTIAL_MEDIATYPE *pOutTypes, // can be NULL only of ulOutTypes = 0
   //
   // Output parameter - this receives a pointer to the DMO CLSID enumerator
   //
   IEnumDMO **ppEnum
);

STDAPI DMOGetTypes(
   REFCLSID clsidDMO,
   unsigned long ulInputTypesRequested,
   unsigned long *pulInputTypesSupplied,
   DMO_PARTIAL_MEDIATYPE *pInputTypes,
   unsigned long ulOutputTypesRequested,
   unsigned long *pulOutputTypesSupplied,
   DMO_PARTIAL_MEDIATYPE *pOutputTypes
);

STDAPI DMOGetName(
   REFCLSID clsidDMO,
   __out_ecount(80) WCHAR szName[80]
);
#endif //__DMOREG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\DomDid.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1997               **
//*********************************************************************

//;begin_internal
/***********************************************************************************************

  This is a distributed SDK component - do not put any #includes or other directives that rely
  upon files not dropped. If in doubt - build iedev

  If you add comments please include either ;BUGBUG at the beginning of a single line OR
  enclose in a ;begin_internal, ;end_internal block - such as this one!

 ***********************************************************************************************/
//;end_internal

//;begin_internal
#ifndef __DOMDID_H__
#define __DOMDID_H__
//;end_internal

//#define DISPID_DOM_BASE                 0x80010500

// Our dispids need to be mapped into the range 1..9999 to kep Trident happy
// specifically, to make the XML tag more efficient. (simonb, 09-18-1998)
#define DISPID_DOM_BASE                 0x00000001

#define DISPID_DOM_NODE                        (DISPID_DOM_BASE)
#define DISPID_DOM_NODE_NODENAME               (DISPID_DOM_NODE + 1)
#define DISPID_DOM_NODE_NODEVALUE              (DISPID_DOM_NODE + 2)
#define DISPID_DOM_NODE_NODETYPE               (DISPID_DOM_NODE + 3)
#define DISPID_DOM_NODE_NODETYPEENUM           (DISPID_DOM_NODE + 4)
#define DISPID_DOM_NODE_PARENTNODE             (DISPID_DOM_NODE + 5)
#define DISPID_DOM_NODE_CHILDNODES             (DISPID_DOM_NODE + 6)
#define DISPID_DOM_NODE_FIRSTCHILD             (DISPID_DOM_NODE + 7)
#define DISPID_DOM_NODE_LASTCHILD              (DISPID_DOM_NODE + 8)
#define DISPID_DOM_NODE_PREVIOUSSIBLING        (DISPID_DOM_NODE + 9)
#define DISPID_DOM_NODE_NEXTSIBLING            (DISPID_DOM_NODE + 10)
#define DISPID_DOM_NODE_ATTRIBUTES             (DISPID_DOM_NODE + 11)
#define DISPID_DOM_NODE_INSERTBEFORE           (DISPID_DOM_NODE + 12)
#define DISPID_DOM_NODE_REPLACECHILD           (DISPID_DOM_NODE + 13)
#define DISPID_DOM_NODE_REMOVECHILD            (DISPID_DOM_NODE + 14)
#define DISPID_DOM_NODE_APPENDCHILD            (DISPID_DOM_NODE + 15)
#define DISPID_DOM_NODE_HASCHILDNODES          (DISPID_DOM_NODE + 16)
#define DISPID_DOM_NODE_OWNERDOC               (DISPID_DOM_NODE + 17)
#define DISPID_DOM_NODE_CLONENODE              (DISPID_DOM_NODE + 18)


#define DISPID_DOM_W3CWRAPPERS                 (DISPID_DOM_NODE + 0x20)

#define DISPID_DOM_DOCUMENTFRAGMENT            (DISPID_DOM_W3CWRAPPERS)
#define DISPID_DOM_DOCUMENTFRAGMENT_TOP        (DISPID_DOM_DOCUMENTFRAGMENT + 2)

#define DISPID_DOM_DOCUMENT                        (DISPID_DOM_DOCUMENTFRAGMENT + 0x20)
#define DISPID_DOM_DOCUMENT_DOCTYPE                (DISPID_DOM_DOCUMENT + 1)
#define DISPID_DOM_DOCUMENT_IMPLEMENTATION         (DISPID_DOM_DOCUMENT + 2)
#define DISPID_DOM_DOCUMENT_DOCUMENTELEMENT        (DISPID_DOM_DOCUMENT + 3)
#define DISPID_DOM_DOCUMENT_CREATEELEMENT          (DISPID_DOM_DOCUMENT + 4)
#define DISPID_DOM_DOCUMENT_CREATEDOCUMENTFRAGMENT (DISPID_DOM_DOCUMENT + 5)
#define DISPID_DOM_DOCUMENT_CREATETEXTNODE         (DISPID_DOM_DOCUMENT + 6)
#define DISPID_DOM_DOCUMENT_CREATECOMMENT          (DISPID_DOM_DOCUMENT + 7)
#define DISPID_DOM_DOCUMENT_CREATECDATASECTION     (DISPID_DOM_DOCUMENT + 8)
#define DISPID_DOM_DOCUMENT_CREATEPROCESSINGINSTRUCTION (DISPID_DOM_DOCUMENT + 9)
#define DISPID_DOM_DOCUMENT_CREATEATTRIBUTE        (DISPID_DOM_DOCUMENT + 10)
#define DISPID_DOM_DOCUMENT_CREATEENTITY           (DISPID_DOM_DOCUMENT + 11)
#define DISPID_DOM_DOCUMENT_CREATEENTITYREFERENCE  (DISPID_DOM_DOCUMENT + 12)
#define DISPID_DOM_DOCUMENT_GETELEMENTSBYTAGNAME   (DISPID_DOM_DOCUMENT + 13)
#define DISPID_DOM_DOCUMENT_TOP                    (DISPID_DOM_DOCUMENT + 14)

#define DISPID_DOM_ELEMENT                         (DISPID_DOM_DOCUMENT + 0x20)
#define DISPID_DOM_ELEMENT_GETTAGNAME              (DISPID_DOM_ELEMENT + 1)
#define DISPID_DOM_ELEMENT_GETATTRIBUTES           (DISPID_DOM_ELEMENT + 2)
#define DISPID_DOM_ELEMENT_GETATTRIBUTE            (DISPID_DOM_ELEMENT + 3)
#define DISPID_DOM_ELEMENT_SETATTRIBUTE            (DISPID_DOM_ELEMENT + 4)
#define DISPID_DOM_ELEMENT_REMOVEATTRIBUTE         (DISPID_DOM_ELEMENT + 5)
#define DISPID_DOM_ELEMENT_GETATTRIBUTENODE        (DISPID_DOM_ELEMENT + 6)
#define DISPID_DOM_ELEMENT_SETATTRIBUTENODE        (DISPID_DOM_ELEMENT + 7)
#define DISPID_DOM_ELEMENT_REMOVEATTRIBUTENODE     (DISPID_DOM_ELEMENT + 8)
#define DISPID_DOM_ELEMENT_GETELEMENTSBYTAGNAME    (DISPID_DOM_ELEMENT + 9)
#define DISPID_DOM_ELEMENT_NORMALIZE               (DISPID_DOM_ELEMENT + 10)
#define DISPID_DOM_ELEMENT_TOP                     (DISPID_DOM_ELEMENT + 11)

#define DISPID_DOM_DATA                        (DISPID_DOM_ELEMENT + 0x20)
#define DISPID_DOM_DATA_LENGTH                 (DISPID_DOM_DATA + 1)
#define DISPID_DOM_DATA_SUBSTRING              (DISPID_DOM_DATA + 2)
#define DISPID_DOM_DATA_APPEND                 (DISPID_DOM_DATA + 3)
#define DISPID_DOM_DATA_INSERT                 (DISPID_DOM_DATA + 4)
#define DISPID_DOM_DATA_DELETE                 (DISPID_DOM_DATA + 5)
#define DISPID_DOM_DATA_REPLACE                (DISPID_DOM_DATA + 6)
#define DISPID_DOM_DATA_TOP                    (DISPID_DOM_DATA + 7)

#define DISPID_DOM_ATTRIBUTE                   (DISPID_DOM_DATA + 0x20)
#define DISPID_DOM_ATTRIBUTE_GETNAME           (DISPID_DOM_ATTRIBUTE + 1)
#define DISPID_DOM_ATTRIBUTE_SPECIFIED         (DISPID_DOM_ATTRIBUTE + 2)
#define DISPID_DOM_ATTRIBUTE_GETVALUE          (DISPID_DOM_ATTRIBUTE + 3)
#define DISPID_DOM_ATTRIBUTE_TOP               (DISPID_DOM_ATTRIBUTE + 4)

#define DISPID_DOM_TEXT                (DISPID_DOM_ATTRIBUTE + 0x20)
#define DISPID_DOM_TEXT_SPLITTEXT      (DISPID_DOM_TEXT + 1)
#define DISPID_DOM_TEXT_JOINTEXT       (DISPID_DOM_TEXT + 2)
#define DISPID_DOM_TEXT_TOP            (DISPID_DOM_TEXT + 3)

#define DISPID_DOM_PI           (DISPID_DOM_TEXT + 0x20)
#define DISPID_DOM_PI_TARGET    (DISPID_DOM_PI + 1)
#define DISPID_DOM_PI_DATA      (DISPID_DOM_PI + 2)
#define DISPID_DOM_PI_TOP       (DISPID_DOM_PI + 3)

#define DISPID_DOM_DOCUMENTTYPE            (DISPID_DOM_PI + 0x20)
#define DISPID_DOM_DOCUMENTTYPE_NAME       (DISPID_DOM_DOCUMENTTYPE + 1)
#define DISPID_DOM_DOCUMENTTYPE_ENTITIES   (DISPID_DOM_DOCUMENTTYPE + 2)
#define DISPID_DOM_DOCUMENTTYPE_NOTATIONS  (DISPID_DOM_DOCUMENTTYPE + 3)
#define DISPID_DOM_DOCUMENTTYPE_TOP        (DISPID_DOM_DOCUMENTTYPE + 4)

#define DISPID_DOM_NOTATION                (DISPID_DOM_DOCUMENTTYPE + 0x20)
#define DISPID_DOM_NOTATION_PUBLICID       (DISPID_DOM_NOTATION + 1)
#define DISPID_DOM_NOTATION_SYSTEMID       (DISPID_DOM_NOTATION + 2)
#define DISPID_DOM_NOTATION_TOP            (DISPID_DOM_NOTATION + 3)

#define DISPID_DOM_ENTITY                  (DISPID_DOM_NOTATION + 0x20)
#define DISPID_DOM_ENTITY_PUBLICID         (DISPID_DOM_ENTITY + 1)
#define DISPID_DOM_ENTITY_SYSTEMID         (DISPID_DOM_ENTITY + 2)
#define DISPID_DOM_ENTITY_NOTATIONNAME     (DISPID_DOM_ENTITY + 3)
#define DISPID_DOM_ENTITY_TOP              (DISPID_DOM_ENTITY + 4)

//define DISPID_DOM_COMMENT         
//define DISPID_DOM_CDATASECTION
//define DISPID_DOM_ENTITYREFERENCE

#define DISPID_DOM_W3CWRAPPERS_TOP         (DISPID_DOM_ENTITY + 0x20)
    
#define DISPID_DOM_NODELIST            (DISPID_DOM_W3CWRAPPERS_TOP + 0x20)
#define DISPID_DOM_NODELIST_ITEM       (DISPID_DOM_NODELIST + 1)
#define DISPID_DOM_NODELIST_LENGTH     (DISPID_DOM_NODELIST + 2)

#define DISPID_DOM_NAMEDNODEMAP                    (DISPID_DOM_NODELIST + 0x20)
#define DISPID_DOM_NAMEDNODEMAP_GETNAMEDITEM       (DISPID_DOM_NAMEDNODEMAP + 3)
#define DISPID_DOM_NAMEDNODEMAP_SETNAMEDITEM       (DISPID_DOM_NAMEDNODEMAP + 4)
#define DISPID_DOM_NAMEDNODEMAP_REMOVENAMEDITEM    (DISPID_DOM_NAMEDNODEMAP + 5)


#define DISPID_DOM_IMPLEMENTATION              (DISPID_DOM_NAMEDNODEMAP + 0x20)
#define DISPID_DOM_IMPLEMENTATION_HASFEATURE   (DISPID_DOM_IMPLEMENTATION + 1)

#define DISPID_DOM_TOP         (DISPID_DOM_IMPLEMENTATION + 0x20)

//;begin_internal
#endif // __XMLDOMDID_H__
//;end_internal
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\DocObjectService.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for docobjectservice.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __docobjectservice_h__
#define __docobjectservice_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDocObjectService_FWD_DEFINED__
#define __IDocObjectService_FWD_DEFINED__
typedef interface IDocObjectService IDocObjectService;
#endif 	/* __IDocObjectService_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "mshtml.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_docobjectservice_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// DocObjectService.h
//=--------------------------------------------------------------------------=
// (C) Copyright Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=



extern RPC_IF_HANDLE __MIDL_itf_docobjectservice_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobjectservice_0000_0000_v0_0_s_ifspec;

#ifndef __IDocObjectService_INTERFACE_DEFINED__
#define __IDocObjectService_INTERFACE_DEFINED__

/* interface IDocObjectService */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDocObjectService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f801-98b5-11cf-bb82-00aa00bdce0b")
    IDocObjectService : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FireBeforeNavigate2( 
            /* [in] */ __RPC__in_opt IDispatch *pDispatch,
            /* [in] */ __RPC__in LPCWSTR lpszUrl,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in LPCWSTR lpszFrameName,
            /* [in] */ __RPC__in BYTE *pPostData,
            /* [in] */ DWORD cbPostData,
            /* [in] */ __RPC__in LPCWSTR lpszHeaders,
            /* [in] */ BOOL fPlayNavSound,
            /* [out] */ __RPC__out BOOL *pfCancel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FireNavigateComplete2( 
            /* [in] */ __RPC__in_opt IHTMLWindow2 *pHTMLWindow2,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FireDownloadBegin( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FireDownloadComplete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FireDocumentComplete( 
            /* [in] */ __RPC__in_opt IHTMLWindow2 *pHTMLWindow,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateDesktopComponent( 
            /* [in] */ __RPC__in_opt IHTMLWindow2 *pHTMLWindow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPendingUrl( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrPendingUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ActiveElementChanged( 
            __RPC__in_opt IHTMLElement *pHTMLElement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUrlSearchComponent( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrSearch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsErrorUrl( 
            /* [in] */ __RPC__in LPCWSTR lpszUrl,
            /* [out] */ __RPC__out BOOL *pfIsError) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDocObjectServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDocObjectService * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDocObjectService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDocObjectService * This);
        
        HRESULT ( STDMETHODCALLTYPE *FireBeforeNavigate2 )( 
            __RPC__in IDocObjectService * This,
            /* [in] */ __RPC__in_opt IDispatch *pDispatch,
            /* [in] */ __RPC__in LPCWSTR lpszUrl,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in LPCWSTR lpszFrameName,
            /* [in] */ __RPC__in BYTE *pPostData,
            /* [in] */ DWORD cbPostData,
            /* [in] */ __RPC__in LPCWSTR lpszHeaders,
            /* [in] */ BOOL fPlayNavSound,
            /* [out] */ __RPC__out BOOL *pfCancel);
        
        HRESULT ( STDMETHODCALLTYPE *FireNavigateComplete2 )( 
            __RPC__in IDocObjectService * This,
            /* [in] */ __RPC__in_opt IHTMLWindow2 *pHTMLWindow2,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *FireDownloadBegin )( 
            __RPC__in IDocObjectService * This);
        
        HRESULT ( STDMETHODCALLTYPE *FireDownloadComplete )( 
            __RPC__in IDocObjectService * This);
        
        HRESULT ( STDMETHODCALLTYPE *FireDocumentComplete )( 
            __RPC__in IDocObjectService * This,
            /* [in] */ __RPC__in_opt IHTMLWindow2 *pHTMLWindow,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateDesktopComponent )( 
            __RPC__in IDocObjectService * This,
            /* [in] */ __RPC__in_opt IHTMLWindow2 *pHTMLWindow);
        
        HRESULT ( STDMETHODCALLTYPE *GetPendingUrl )( 
            __RPC__in IDocObjectService * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrPendingUrl);
        
        HRESULT ( STDMETHODCALLTYPE *ActiveElementChanged )( 
            __RPC__in IDocObjectService * This,
            __RPC__in_opt IHTMLElement *pHTMLElement);
        
        HRESULT ( STDMETHODCALLTYPE *GetUrlSearchComponent )( 
            __RPC__in IDocObjectService * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrSearch);
        
        HRESULT ( STDMETHODCALLTYPE *IsErrorUrl )( 
            __RPC__in IDocObjectService * This,
            /* [in] */ __RPC__in LPCWSTR lpszUrl,
            /* [out] */ __RPC__out BOOL *pfIsError);
        
        END_INTERFACE
    } IDocObjectServiceVtbl;

    interface IDocObjectService
    {
        CONST_VTBL struct IDocObjectServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDocObjectService_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDocObjectService_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDocObjectService_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDocObjectService_FireBeforeNavigate2(This,pDispatch,lpszUrl,dwFlags,lpszFrameName,pPostData,cbPostData,lpszHeaders,fPlayNavSound,pfCancel)	\
    ( (This)->lpVtbl -> FireBeforeNavigate2(This,pDispatch,lpszUrl,dwFlags,lpszFrameName,pPostData,cbPostData,lpszHeaders,fPlayNavSound,pfCancel) ) 

#define IDocObjectService_FireNavigateComplete2(This,pHTMLWindow2,dwFlags)	\
    ( (This)->lpVtbl -> FireNavigateComplete2(This,pHTMLWindow2,dwFlags) ) 

#define IDocObjectService_FireDownloadBegin(This)	\
    ( (This)->lpVtbl -> FireDownloadBegin(This) ) 

#define IDocObjectService_FireDownloadComplete(This)	\
    ( (This)->lpVtbl -> FireDownloadComplete(This) ) 

#define IDocObjectService_FireDocumentComplete(This,pHTMLWindow,dwFlags)	\
    ( (This)->lpVtbl -> FireDocumentComplete(This,pHTMLWindow,dwFlags) ) 

#define IDocObjectService_UpdateDesktopComponent(This,pHTMLWindow)	\
    ( (This)->lpVtbl -> UpdateDesktopComponent(This,pHTMLWindow) ) 

#define IDocObjectService_GetPendingUrl(This,pbstrPendingUrl)	\
    ( (This)->lpVtbl -> GetPendingUrl(This,pbstrPendingUrl) ) 

#define IDocObjectService_ActiveElementChanged(This,pHTMLElement)	\
    ( (This)->lpVtbl -> ActiveElementChanged(This,pHTMLElement) ) 

#define IDocObjectService_GetUrlSearchComponent(This,pbstrSearch)	\
    ( (This)->lpVtbl -> GetUrlSearchComponent(This,pbstrSearch) ) 

#define IDocObjectService_IsErrorUrl(This,lpszUrl,pfIsError)	\
    ( (This)->lpVtbl -> IsErrorUrl(This,lpszUrl,pfIsError) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDocObjectService_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\DocObj.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for docobj.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __docobj_h__
#define __docobj_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IOleDocument_FWD_DEFINED__
#define __IOleDocument_FWD_DEFINED__
typedef interface IOleDocument IOleDocument;
#endif 	/* __IOleDocument_FWD_DEFINED__ */


#ifndef __IOleDocumentSite_FWD_DEFINED__
#define __IOleDocumentSite_FWD_DEFINED__
typedef interface IOleDocumentSite IOleDocumentSite;
#endif 	/* __IOleDocumentSite_FWD_DEFINED__ */


#ifndef __IOleDocumentView_FWD_DEFINED__
#define __IOleDocumentView_FWD_DEFINED__
typedef interface IOleDocumentView IOleDocumentView;
#endif 	/* __IOleDocumentView_FWD_DEFINED__ */


#ifndef __IEnumOleDocumentViews_FWD_DEFINED__
#define __IEnumOleDocumentViews_FWD_DEFINED__
typedef interface IEnumOleDocumentViews IEnumOleDocumentViews;
#endif 	/* __IEnumOleDocumentViews_FWD_DEFINED__ */


#ifndef __IContinueCallback_FWD_DEFINED__
#define __IContinueCallback_FWD_DEFINED__
typedef interface IContinueCallback IContinueCallback;
#endif 	/* __IContinueCallback_FWD_DEFINED__ */


#ifndef __IPrint_FWD_DEFINED__
#define __IPrint_FWD_DEFINED__
typedef interface IPrint IPrint;
#endif 	/* __IPrint_FWD_DEFINED__ */


#ifndef __IOleCommandTarget_FWD_DEFINED__
#define __IOleCommandTarget_FWD_DEFINED__
typedef interface IOleCommandTarget IOleCommandTarget;
#endif 	/* __IOleCommandTarget_FWD_DEFINED__ */


#ifndef __IZoomEvents_FWD_DEFINED__
#define __IZoomEvents_FWD_DEFINED__
typedef interface IZoomEvents IZoomEvents;
#endif 	/* __IZoomEvents_FWD_DEFINED__ */


#ifndef __IProtectFocus_FWD_DEFINED__
#define __IProtectFocus_FWD_DEFINED__
typedef interface IProtectFocus IProtectFocus;
#endif 	/* __IProtectFocus_FWD_DEFINED__ */


#ifndef __IProtectedModeMenuServices_FWD_DEFINED__
#define __IProtectedModeMenuServices_FWD_DEFINED__
typedef interface IProtectedModeMenuServices IProtectedModeMenuServices;
#endif 	/* __IProtectedModeMenuServices_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_docobj_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// DocObj.h
//=--------------------------------------------------------------------------=
// (C) Copyright Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// OLE Document Object Interfaces.









////////////////////////////////////////////////////////////////////////////
//  Interface Definitions
#ifndef _LPOLEDOCUMENT_DEFINED
#define _LPOLEDOCUMENT_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0000_v0_0_s_ifspec;

#ifndef __IOleDocument_INTERFACE_DEFINED__
#define __IOleDocument_INTERFACE_DEFINED__

/* interface IOleDocument */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IOleDocument *LPOLEDOCUMENT;

typedef /* [public] */ 
enum __MIDL_IOleDocument_0001
    {	DOCMISC_CANCREATEMULTIPLEVIEWS	= 1,
	DOCMISC_SUPPORTCOMPLEXRECTANGLES	= 2,
	DOCMISC_CANTOPENEDIT	= 4,
	DOCMISC_NOFILESUPPORT	= 8
    } 	DOCMISC;


EXTERN_C const IID IID_IOleDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b722bcc5-4e68-101b-a2bc-00aa00404770")
    IOleDocument : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateView( 
            /* [unique][in] */ __RPC__in_opt IOleInPlaceSite *pIPSite,
            /* [unique][in] */ __RPC__in_opt IStream *pstm,
            /* [in] */ DWORD dwReserved,
            /* [out] */ __RPC__deref_out_opt IOleDocumentView **ppView) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocMiscStatus( 
            /* [out] */ __RPC__out DWORD *pdwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumViews( 
            /* [out] */ __RPC__deref_out_opt IEnumOleDocumentViews **ppEnum,
            /* [out] */ __RPC__deref_out_opt IOleDocumentView **ppView) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IOleDocument * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IOleDocument * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IOleDocument * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateView )( 
            __RPC__in IOleDocument * This,
            /* [unique][in] */ __RPC__in_opt IOleInPlaceSite *pIPSite,
            /* [unique][in] */ __RPC__in_opt IStream *pstm,
            /* [in] */ DWORD dwReserved,
            /* [out] */ __RPC__deref_out_opt IOleDocumentView **ppView);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocMiscStatus )( 
            __RPC__in IOleDocument * This,
            /* [out] */ __RPC__out DWORD *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE *EnumViews )( 
            __RPC__in IOleDocument * This,
            /* [out] */ __RPC__deref_out_opt IEnumOleDocumentViews **ppEnum,
            /* [out] */ __RPC__deref_out_opt IOleDocumentView **ppView);
        
        END_INTERFACE
    } IOleDocumentVtbl;

    interface IOleDocument
    {
        CONST_VTBL struct IOleDocumentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleDocument_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IOleDocument_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IOleDocument_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IOleDocument_CreateView(This,pIPSite,pstm,dwReserved,ppView)	\
    ( (This)->lpVtbl -> CreateView(This,pIPSite,pstm,dwReserved,ppView) ) 

#define IOleDocument_GetDocMiscStatus(This,pdwStatus)	\
    ( (This)->lpVtbl -> GetDocMiscStatus(This,pdwStatus) ) 

#define IOleDocument_EnumViews(This,ppEnum,ppView)	\
    ( (This)->lpVtbl -> EnumViews(This,ppEnum,ppView) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IOleDocument_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0000_0001 */
/* [local] */ 

#endif
#ifndef _LPOLEDOCUMENTSITE_DEFINED
#define _LPOLEDOCUMENTSITE_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0001_v0_0_s_ifspec;

#ifndef __IOleDocumentSite_INTERFACE_DEFINED__
#define __IOleDocumentSite_INTERFACE_DEFINED__

/* interface IOleDocumentSite */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IOleDocumentSite *LPOLEDOCUMENTSITE;


EXTERN_C const IID IID_IOleDocumentSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b722bcc7-4e68-101b-a2bc-00aa00404770")
    IOleDocumentSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ActivateMe( 
            /* [in] */ __RPC__in_opt IOleDocumentView *pViewToActivate) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleDocumentSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IOleDocumentSite * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IOleDocumentSite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IOleDocumentSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *ActivateMe )( 
            __RPC__in IOleDocumentSite * This,
            /* [in] */ __RPC__in_opt IOleDocumentView *pViewToActivate);
        
        END_INTERFACE
    } IOleDocumentSiteVtbl;

    interface IOleDocumentSite
    {
        CONST_VTBL struct IOleDocumentSiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleDocumentSite_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IOleDocumentSite_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IOleDocumentSite_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IOleDocumentSite_ActivateMe(This,pViewToActivate)	\
    ( (This)->lpVtbl -> ActivateMe(This,pViewToActivate) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IOleDocumentSite_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0000_0002 */
/* [local] */ 

#endif
#ifndef _LPOLEDOCUMENTVIEW_DEFINED
#define _LPOLEDOCUMENTVIEW_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0002_v0_0_s_ifspec;

#ifndef __IOleDocumentView_INTERFACE_DEFINED__
#define __IOleDocumentView_INTERFACE_DEFINED__

/* interface IOleDocumentView */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IOleDocumentView *LPOLEDOCUMENTVIEW;


EXTERN_C const IID IID_IOleDocumentView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b722bcc6-4e68-101b-a2bc-00aa00404770")
    IOleDocumentView : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetInPlaceSite( 
            /* [unique][in] */ __RPC__in_opt IOleInPlaceSite *pIPSite) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInPlaceSite( 
            /* [out] */ __RPC__deref_out_opt IOleInPlaceSite **ppIPSite) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocument( 
            /* [out] */ __RPC__deref_out_opt IUnknown **ppunk) = 0;
        
        virtual /* [input_sync] */ HRESULT STDMETHODCALLTYPE SetRect( 
            /* [in] */ __RPC__in LPRECT prcView) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRect( 
            /* [out] */ __RPC__out LPRECT prcView) = 0;
        
        virtual /* [input_sync] */ HRESULT STDMETHODCALLTYPE SetRectComplex( 
            /* [unique][in] */ __RPC__in_opt LPRECT prcView,
            /* [unique][in] */ __RPC__in_opt LPRECT prcHScroll,
            /* [unique][in] */ __RPC__in_opt LPRECT prcVScroll,
            /* [unique][in] */ __RPC__in_opt LPRECT prcSizeBox) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Show( 
            /* [in] */ BOOL fShow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UIActivate( 
            /* [in] */ BOOL fUIActivate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Open( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseView( 
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveViewState( 
            /* [in] */ __RPC__in_opt LPSTREAM pstm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplyViewState( 
            /* [in] */ __RPC__in_opt LPSTREAM pstm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [in] */ __RPC__in_opt IOleInPlaceSite *pIPSiteNew,
            /* [out] */ __RPC__deref_out_opt IOleDocumentView **ppViewNew) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleDocumentViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IOleDocumentView * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IOleDocumentView * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IOleDocumentView * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetInPlaceSite )( 
            __RPC__in IOleDocumentView * This,
            /* [unique][in] */ __RPC__in_opt IOleInPlaceSite *pIPSite);
        
        HRESULT ( STDMETHODCALLTYPE *GetInPlaceSite )( 
            __RPC__in IOleDocumentView * This,
            /* [out] */ __RPC__deref_out_opt IOleInPlaceSite **ppIPSite);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocument )( 
            __RPC__in IOleDocumentView * This,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppunk);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE *SetRect )( 
            __RPC__in IOleDocumentView * This,
            /* [in] */ __RPC__in LPRECT prcView);
        
        HRESULT ( STDMETHODCALLTYPE *GetRect )( 
            __RPC__in IOleDocumentView * This,
            /* [out] */ __RPC__out LPRECT prcView);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE *SetRectComplex )( 
            __RPC__in IOleDocumentView * This,
            /* [unique][in] */ __RPC__in_opt LPRECT prcView,
            /* [unique][in] */ __RPC__in_opt LPRECT prcHScroll,
            /* [unique][in] */ __RPC__in_opt LPRECT prcVScroll,
            /* [unique][in] */ __RPC__in_opt LPRECT prcSizeBox);
        
        HRESULT ( STDMETHODCALLTYPE *Show )( 
            __RPC__in IOleDocumentView * This,
            /* [in] */ BOOL fShow);
        
        HRESULT ( STDMETHODCALLTYPE *UIActivate )( 
            __RPC__in IOleDocumentView * This,
            /* [in] */ BOOL fUIActivate);
        
        HRESULT ( STDMETHODCALLTYPE *Open )( 
            __RPC__in IOleDocumentView * This);
        
        HRESULT ( STDMETHODCALLTYPE *CloseView )( 
            __RPC__in IOleDocumentView * This,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *SaveViewState )( 
            __RPC__in IOleDocumentView * This,
            /* [in] */ __RPC__in_opt LPSTREAM pstm);
        
        HRESULT ( STDMETHODCALLTYPE *ApplyViewState )( 
            __RPC__in IOleDocumentView * This,
            /* [in] */ __RPC__in_opt LPSTREAM pstm);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IOleDocumentView * This,
            /* [in] */ __RPC__in_opt IOleInPlaceSite *pIPSiteNew,
            /* [out] */ __RPC__deref_out_opt IOleDocumentView **ppViewNew);
        
        END_INTERFACE
    } IOleDocumentViewVtbl;

    interface IOleDocumentView
    {
        CONST_VTBL struct IOleDocumentViewVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleDocumentView_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IOleDocumentView_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IOleDocumentView_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IOleDocumentView_SetInPlaceSite(This,pIPSite)	\
    ( (This)->lpVtbl -> SetInPlaceSite(This,pIPSite) ) 

#define IOleDocumentView_GetInPlaceSite(This,ppIPSite)	\
    ( (This)->lpVtbl -> GetInPlaceSite(This,ppIPSite) ) 

#define IOleDocumentView_GetDocument(This,ppunk)	\
    ( (This)->lpVtbl -> GetDocument(This,ppunk) ) 

#define IOleDocumentView_SetRect(This,prcView)	\
    ( (This)->lpVtbl -> SetRect(This,prcView) ) 

#define IOleDocumentView_GetRect(This,prcView)	\
    ( (This)->lpVtbl -> GetRect(This,prcView) ) 

#define IOleDocumentView_SetRectComplex(This,prcView,prcHScroll,prcVScroll,prcSizeBox)	\
    ( (This)->lpVtbl -> SetRectComplex(This,prcView,prcHScroll,prcVScroll,prcSizeBox) ) 

#define IOleDocumentView_Show(This,fShow)	\
    ( (This)->lpVtbl -> Show(This,fShow) ) 

#define IOleDocumentView_UIActivate(This,fUIActivate)	\
    ( (This)->lpVtbl -> UIActivate(This,fUIActivate) ) 

#define IOleDocumentView_Open(This)	\
    ( (This)->lpVtbl -> Open(This) ) 

#define IOleDocumentView_CloseView(This,dwReserved)	\
    ( (This)->lpVtbl -> CloseView(This,dwReserved) ) 

#define IOleDocumentView_SaveViewState(This,pstm)	\
    ( (This)->lpVtbl -> SaveViewState(This,pstm) ) 

#define IOleDocumentView_ApplyViewState(This,pstm)	\
    ( (This)->lpVtbl -> ApplyViewState(This,pstm) ) 

#define IOleDocumentView_Clone(This,pIPSiteNew,ppViewNew)	\
    ( (This)->lpVtbl -> Clone(This,pIPSiteNew,ppViewNew) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IOleDocumentView_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0000_0003 */
/* [local] */ 

#endif
#ifndef _LPENUMOLEDOCUMENTVIEWS_DEFINED
#define _LPENUMOLEDOCUMENTVIEWS_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0003_v0_0_s_ifspec;

#ifndef __IEnumOleDocumentViews_INTERFACE_DEFINED__
#define __IEnumOleDocumentViews_INTERFACE_DEFINED__

/* interface IEnumOleDocumentViews */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IEnumOleDocumentViews *LPENUMOLEDOCUMENTVIEWS;


EXTERN_C const IID IID_IEnumOleDocumentViews;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b722bcc8-4e68-101b-a2bc-00aa00404770")
    IEnumOleDocumentViews : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT __stdcall Next( 
            /* [in] */ ULONG cViews,
            /* [out] */ IOleDocumentView **rgpView,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cViews) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumOleDocumentViews **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumOleDocumentViewsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumOleDocumentViews * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumOleDocumentViews * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumOleDocumentViews * This);
        
        /* [local] */ HRESULT ( __stdcall *Next )( 
            IEnumOleDocumentViews * This,
            /* [in] */ ULONG cViews,
            /* [out] */ IOleDocumentView **rgpView,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumOleDocumentViews * This,
            /* [in] */ ULONG cViews);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumOleDocumentViews * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumOleDocumentViews * This,
            /* [out] */ __RPC__deref_out_opt IEnumOleDocumentViews **ppEnum);
        
        END_INTERFACE
    } IEnumOleDocumentViewsVtbl;

    interface IEnumOleDocumentViews
    {
        CONST_VTBL struct IEnumOleDocumentViewsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumOleDocumentViews_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumOleDocumentViews_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumOleDocumentViews_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumOleDocumentViews_Next(This,cViews,rgpView,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,cViews,rgpView,pcFetched) ) 

#define IEnumOleDocumentViews_Skip(This,cViews)	\
    ( (This)->lpVtbl -> Skip(This,cViews) ) 

#define IEnumOleDocumentViews_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumOleDocumentViews_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumOleDocumentViews_RemoteNext_Proxy( 
    __RPC__in IEnumOleDocumentViews * This,
    /* [in] */ ULONG cViews,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(cViews, *pcFetched) IOleDocumentView **rgpView,
    /* [out] */ __RPC__out ULONG *pcFetched);


void __RPC_STUB IEnumOleDocumentViews_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumOleDocumentViews_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0000_0004 */
/* [local] */ 

#endif
#ifndef _LPCONTINUECALLBACK_DEFINED
#define _LPCONTINUECALLBACK_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0004_v0_0_s_ifspec;

#ifndef __IContinueCallback_INTERFACE_DEFINED__
#define __IContinueCallback_INTERFACE_DEFINED__

/* interface IContinueCallback */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IContinueCallback *LPCONTINUECALLBACK;


EXTERN_C const IID IID_IContinueCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b722bcca-4e68-101b-a2bc-00aa00404770")
    IContinueCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FContinue( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FContinuePrinting( 
            /* [in] */ LONG nCntPrinted,
            /* [in] */ LONG nCurPage,
            /* [unique][in] */ __RPC__in_opt wchar_t *pwszPrintStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContinueCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IContinueCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IContinueCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IContinueCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *FContinue )( 
            __RPC__in IContinueCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *FContinuePrinting )( 
            __RPC__in IContinueCallback * This,
            /* [in] */ LONG nCntPrinted,
            /* [in] */ LONG nCurPage,
            /* [unique][in] */ __RPC__in_opt wchar_t *pwszPrintStatus);
        
        END_INTERFACE
    } IContinueCallbackVtbl;

    interface IContinueCallback
    {
        CONST_VTBL struct IContinueCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContinueCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IContinueCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IContinueCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IContinueCallback_FContinue(This)	\
    ( (This)->lpVtbl -> FContinue(This) ) 

#define IContinueCallback_FContinuePrinting(This,nCntPrinted,nCurPage,pwszPrintStatus)	\
    ( (This)->lpVtbl -> FContinuePrinting(This,nCntPrinted,nCurPage,pwszPrintStatus) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IContinueCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0000_0005 */
/* [local] */ 

#endif
#ifndef _LPPRINT_DEFINED
#define _LPPRINT_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0005_v0_0_s_ifspec;

#ifndef __IPrint_INTERFACE_DEFINED__
#define __IPrint_INTERFACE_DEFINED__

/* interface IPrint */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IPrint *LPPRINT;

typedef /* [public] */ 
enum __MIDL_IPrint_0001
    {	PRINTFLAG_MAYBOTHERUSER	= 1,
	PRINTFLAG_PROMPTUSER	= 2,
	PRINTFLAG_USERMAYCHANGEPRINTER	= 4,
	PRINTFLAG_RECOMPOSETODEVICE	= 8,
	PRINTFLAG_DONTACTUALLYPRINT	= 16,
	PRINTFLAG_FORCEPROPERTIES	= 32,
	PRINTFLAG_PRINTTOFILE	= 64
    } 	PRINTFLAG;

typedef struct tagPAGERANGE
    {
    LONG nFromPage;
    LONG nToPage;
    } 	PAGERANGE;

typedef struct tagPAGESET
    {
    ULONG cbStruct;
    BOOL fOddPages;
    BOOL fEvenPages;
    ULONG cPageRange;
    PAGERANGE rgPages[ 1 ];
    } 	PAGESET;

#define PAGESET_TOLASTPAGE   ((WORD)(-1L))

EXTERN_C const IID IID_IPrint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b722bcc9-4e68-101b-a2bc-00aa00404770")
    IPrint : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetInitialPageNum( 
            /* [in] */ LONG nFirstPage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPageInfo( 
            /* [out] */ __RPC__out LONG *pnFirstPage,
            /* [out] */ __RPC__out LONG *pcPages) = 0;
        
        virtual /* [local] */ HRESULT __stdcall Print( 
            /* [in] */ DWORD grfFlags,
            /* [out][in] */ DVTARGETDEVICE **pptd,
            /* [out][in] */ PAGESET **ppPageSet,
            /* [unique][out][in] */ STGMEDIUM *pstgmOptions,
            /* [in] */ IContinueCallback *pcallback,
            /* [in] */ LONG nFirstPage,
            /* [out] */ LONG *pcPagesPrinted,
            /* [out] */ LONG *pnLastPage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPrintVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPrint * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPrint * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPrint * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetInitialPageNum )( 
            __RPC__in IPrint * This,
            /* [in] */ LONG nFirstPage);
        
        HRESULT ( STDMETHODCALLTYPE *GetPageInfo )( 
            __RPC__in IPrint * This,
            /* [out] */ __RPC__out LONG *pnFirstPage,
            /* [out] */ __RPC__out LONG *pcPages);
        
        /* [local] */ HRESULT ( __stdcall *Print )( 
            IPrint * This,
            /* [in] */ DWORD grfFlags,
            /* [out][in] */ DVTARGETDEVICE **pptd,
            /* [out][in] */ PAGESET **ppPageSet,
            /* [unique][out][in] */ STGMEDIUM *pstgmOptions,
            /* [in] */ IContinueCallback *pcallback,
            /* [in] */ LONG nFirstPage,
            /* [out] */ LONG *pcPagesPrinted,
            /* [out] */ LONG *pnLastPage);
        
        END_INTERFACE
    } IPrintVtbl;

    interface IPrint
    {
        CONST_VTBL struct IPrintVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPrint_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPrint_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPrint_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPrint_SetInitialPageNum(This,nFirstPage)	\
    ( (This)->lpVtbl -> SetInitialPageNum(This,nFirstPage) ) 

#define IPrint_GetPageInfo(This,pnFirstPage,pcPages)	\
    ( (This)->lpVtbl -> GetPageInfo(This,pnFirstPage,pcPages) ) 

#define IPrint_Print(This,grfFlags,pptd,ppPageSet,pstgmOptions,pcallback,nFirstPage,pcPagesPrinted,pnLastPage)	\
    ( (This)->lpVtbl -> Print(This,grfFlags,pptd,ppPageSet,pstgmOptions,pcallback,nFirstPage,pcPagesPrinted,pnLastPage) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT __stdcall IPrint_RemotePrint_Proxy( 
    __RPC__in IPrint * This,
    /* [in] */ DWORD grfFlags,
    /* [out][in] */ __RPC__deref_inout_opt DVTARGETDEVICE **pptd,
    /* [out][in] */ __RPC__deref_inout_opt PAGESET **pppageset,
    /* [unique][out][in] */ __RPC__inout_opt RemSTGMEDIUM *pstgmOptions,
    /* [in] */ __RPC__in_opt IContinueCallback *pcallback,
    /* [in] */ LONG nFirstPage,
    /* [out] */ __RPC__out LONG *pcPagesPrinted,
    /* [out] */ __RPC__out LONG *pnLastPage);


void __RPC_STUB IPrint_RemotePrint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPrint_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0000_0006 */
/* [local] */ 

#endif
#ifndef _LPOLECOMMANDTARGET_DEFINED
#define _LPOLECOMMANDTARGET_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0006_v0_0_s_ifspec;

#ifndef __IOleCommandTarget_INTERFACE_DEFINED__
#define __IOleCommandTarget_INTERFACE_DEFINED__

/* interface IOleCommandTarget */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IOleCommandTarget *LPOLECOMMANDTARGET;

typedef 
enum OLECMDF
    {	OLECMDF_SUPPORTED	= 0x1,
	OLECMDF_ENABLED	= 0x2,
	OLECMDF_LATCHED	= 0x4,
	OLECMDF_NINCHED	= 0x8,
	OLECMDF_INVISIBLE	= 0x10,
	OLECMDF_DEFHIDEONCTXTMENU	= 0x20
    } 	OLECMDF;

typedef struct _tagOLECMD
    {
    ULONG cmdID;
    DWORD cmdf;
    } 	OLECMD;

typedef struct _tagOLECMDTEXT
    {
    DWORD cmdtextf;
    ULONG cwActual;
    ULONG cwBuf;
    wchar_t rgwz[ 1 ];
    } 	OLECMDTEXT;

typedef 
enum OLECMDTEXTF
    {	OLECMDTEXTF_NONE	= 0,
	OLECMDTEXTF_NAME	= 1,
	OLECMDTEXTF_STATUS	= 2
    } 	OLECMDTEXTF;

typedef 
enum OLECMDEXECOPT
    {	OLECMDEXECOPT_DODEFAULT	= 0,
	OLECMDEXECOPT_PROMPTUSER	= 1,
	OLECMDEXECOPT_DONTPROMPTUSER	= 2,
	OLECMDEXECOPT_SHOWHELP	= 3
    } 	OLECMDEXECOPT;

/* OLECMDID_STOPDOWNLOAD and OLECMDID_ALLOWUILESSSAVEAS are supported for QueryStatus Only */
typedef 
enum OLECMDID
    {	OLECMDID_OPEN	= 1,
	OLECMDID_NEW	= 2,
	OLECMDID_SAVE	= 3,
	OLECMDID_SAVEAS	= 4,
	OLECMDID_SAVECOPYAS	= 5,
	OLECMDID_PRINT	= 6,
	OLECMDID_PRINTPREVIEW	= 7,
	OLECMDID_PAGESETUP	= 8,
	OLECMDID_SPELL	= 9,
	OLECMDID_PROPERTIES	= 10,
	OLECMDID_CUT	= 11,
	OLECMDID_COPY	= 12,
	OLECMDID_PASTE	= 13,
	OLECMDID_PASTESPECIAL	= 14,
	OLECMDID_UNDO	= 15,
	OLECMDID_REDO	= 16,
	OLECMDID_SELECTALL	= 17,
	OLECMDID_CLEARSELECTION	= 18,
	OLECMDID_ZOOM	= 19,
	OLECMDID_GETZOOMRANGE	= 20,
	OLECMDID_UPDATECOMMANDS	= 21,
	OLECMDID_REFRESH	= 22,
	OLECMDID_STOP	= 23,
	OLECMDID_HIDETOOLBARS	= 24,
	OLECMDID_SETPROGRESSMAX	= 25,
	OLECMDID_SETPROGRESSPOS	= 26,
	OLECMDID_SETPROGRESSTEXT	= 27,
	OLECMDID_SETTITLE	= 28,
	OLECMDID_SETDOWNLOADSTATE	= 29,
	OLECMDID_STOPDOWNLOAD	= 30,
	OLECMDID_ONTOOLBARACTIVATED	= 31,
	OLECMDID_FIND	= 32,
	OLECMDID_DELETE	= 33,
	OLECMDID_HTTPEQUIV	= 34,
	OLECMDID_HTTPEQUIV_DONE	= 35,
	OLECMDID_ENABLE_INTERACTION	= 36,
	OLECMDID_ONUNLOAD	= 37,
	OLECMDID_PROPERTYBAG2	= 38,
	OLECMDID_PREREFRESH	= 39,
	OLECMDID_SHOWSCRIPTERROR	= 40,
	OLECMDID_SHOWMESSAGE	= 41,
	OLECMDID_SHOWFIND	= 42,
	OLECMDID_SHOWPAGESETUP	= 43,
	OLECMDID_SHOWPRINT	= 44,
	OLECMDID_CLOSE	= 45,
	OLECMDID_ALLOWUILESSSAVEAS	= 46,
	OLECMDID_DONTDOWNLOADCSS	= 47,
	OLECMDID_UPDATEPAGESTATUS	= 48,
	OLECMDID_PRINT2	= 49,
	OLECMDID_PRINTPREVIEW2	= 50,
	OLECMDID_SETPRINTTEMPLATE	= 51,
	OLECMDID_GETPRINTTEMPLATE	= 52,
	OLECMDID_PAGEACTIONBLOCKED	= 55,
	OLECMDID_PAGEACTIONUIQUERY	= 56,
	OLECMDID_FOCUSVIEWCONTROLS	= 57,
	OLECMDID_FOCUSVIEWCONTROLSQUERY	= 58,
	OLECMDID_SHOWPAGEACTIONMENU	= 59,
	OLECMDID_ADDTRAVELENTRY	= 60,
	OLECMDID_UPDATETRAVELENTRY	= 61,
	OLECMDID_UPDATEBACKFORWARDSTATE	= 62,
	OLECMDID_OPTICAL_ZOOM	= 63,
	OLECMDID_OPTICAL_GETZOOMRANGE	= 64,
	OLECMDID_WINDOWSTATECHANGED	= 65,
	OLECMDID_ACTIVEXINSTALLSCOPE	= 66,
	OLECMDID_UPDATETRAVELENTRY_DATARECOVERY	= 67
    } 	OLECMDID;

#define OLECMDERR_E_FIRST            (OLE_E_LAST+1)
#define OLECMDERR_E_NOTSUPPORTED     (OLECMDERR_E_FIRST)
#define OLECMDERR_E_DISABLED         (OLECMDERR_E_FIRST+1)
#define OLECMDERR_E_NOHELP           (OLECMDERR_E_FIRST+2)
#define OLECMDERR_E_CANCELED         (OLECMDERR_E_FIRST+3)
#define OLECMDERR_E_UNKNOWNGROUP     (OLECMDERR_E_FIRST+4)
#define MSOCMDERR_E_FIRST            OLECMDERR_E_FIRST
#define MSOCMDERR_E_NOTSUPPORTED     OLECMDERR_E_NOTSUPPORTED
#define MSOCMDERR_E_DISABLED         OLECMDERR_E_DISABLED
#define MSOCMDERR_E_NOHELP           OLECMDERR_E_NOHELP
#define MSOCMDERR_E_CANCELED         OLECMDERR_E_CANCELED
#define MSOCMDERR_E_UNKNOWNGROUP     OLECMDERR_E_UNKNOWNGROUP
#if(NTDDI_VERSION >= NTDDI_WINXPSP2)
#define OLECMDARGINDEX_SHOWPAGEACTIONMENU_HWND     0
#define OLECMDARGINDEX_SHOWPAGEACTIONMENU_X        1
#define OLECMDARGINDEX_SHOWPAGEACTIONMENU_Y        2
#define OLECMDARGINDEX_ACTIVEXINSTALL_PUBLISHER    0
#define OLECMDARGINDEX_ACTIVEXINSTALL_DISPLAYNAME  1
#define OLECMDARGINDEX_ACTIVEXINSTALL_CLSID        2
#define OLECMDARGINDEX_ACTIVEXINSTALL_INSTALLSCOPE 3
#define INSTALL_SCOPE_INVALID    0
#define INSTALL_SCOPE_MACHINE    1
#define INSTALL_SCOPE_USER       2
typedef 
enum IGNOREMIME
    {	IGNOREMIME_PROMPT	= 0x1,
	IGNOREMIME_TEXT	= 0x2
    } 	IGNOREMIME;

typedef 
enum WPCSETTING
    {	WPCSETTING_LOGGING_ENABLED	= 0x1,
	WPCSETTING_FILEDOWNLOAD_BLOCKED	= 0x2
    } 	WPCSETTING;

#endif

EXTERN_C const IID IID_IOleCommandTarget;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b722bccb-4e68-101b-a2bc-00aa00404770")
    IOleCommandTarget : public IUnknown
    {
    public:
        virtual /* [input_sync] */ HRESULT STDMETHODCALLTYPE QueryStatus( 
            /* [unique][in] */ __RPC__in_opt const GUID *pguidCmdGroup,
            /* [in] */ ULONG cCmds,
            /* [out][in][size_is] */ __RPC__inout_ecount_full(cCmds) OLECMD prgCmds[  ],
            /* [unique][out][in] */ __RPC__inout_opt OLECMDTEXT *pCmdText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Exec( 
            /* [unique][in] */ __RPC__in_opt const GUID *pguidCmdGroup,
            /* [in] */ DWORD nCmdID,
            /* [in] */ DWORD nCmdexecopt,
            /* [unique][in] */ __RPC__in_opt VARIANT *pvaIn,
            /* [unique][out][in] */ __RPC__inout_opt VARIANT *pvaOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IOleCommandTargetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IOleCommandTarget * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IOleCommandTarget * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IOleCommandTarget * This);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE *QueryStatus )( 
            __RPC__in IOleCommandTarget * This,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidCmdGroup,
            /* [in] */ ULONG cCmds,
            /* [out][in][size_is] */ __RPC__inout_ecount_full(cCmds) OLECMD prgCmds[  ],
            /* [unique][out][in] */ __RPC__inout_opt OLECMDTEXT *pCmdText);
        
        HRESULT ( STDMETHODCALLTYPE *Exec )( 
            __RPC__in IOleCommandTarget * This,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidCmdGroup,
            /* [in] */ DWORD nCmdID,
            /* [in] */ DWORD nCmdexecopt,
            /* [unique][in] */ __RPC__in_opt VARIANT *pvaIn,
            /* [unique][out][in] */ __RPC__inout_opt VARIANT *pvaOut);
        
        END_INTERFACE
    } IOleCommandTargetVtbl;

    interface IOleCommandTarget
    {
        CONST_VTBL struct IOleCommandTargetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleCommandTarget_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IOleCommandTarget_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IOleCommandTarget_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IOleCommandTarget_QueryStatus(This,pguidCmdGroup,cCmds,prgCmds,pCmdText)	\
    ( (This)->lpVtbl -> QueryStatus(This,pguidCmdGroup,cCmds,prgCmds,pCmdText) ) 

#define IOleCommandTarget_Exec(This,pguidCmdGroup,nCmdID,nCmdexecopt,pvaIn,pvaOut)	\
    ( (This)->lpVtbl -> Exec(This,pguidCmdGroup,nCmdID,nCmdexecopt,pvaIn,pvaOut) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IOleCommandTarget_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0000_0007 */
/* [local] */ 

#endif
typedef enum
{
      OLECMDIDF_REFRESH_NORMAL          = 0,
      OLECMDIDF_REFRESH_IFEXPIRED       = 1,
      OLECMDIDF_REFRESH_CONTINUE        = 2,
      OLECMDIDF_REFRESH_COMPLETELY      = 3,
      OLECMDIDF_REFRESH_NO_CACHE        = 4,
      OLECMDIDF_REFRESH_RELOAD          = 5,
      OLECMDIDF_REFRESH_LEVELMASK       = 0x00FF,
      OLECMDIDF_REFRESH_CLEARUSERINPUT  = 0x1000,
#if(NTDDI_VERSION >= NTDDI_WINXPSP2)
      OLECMDIDF_REFRESH_PROMPTIFOFFLINE = 0x2000,
      OLECMDIDF_REFRESH_THROUGHSCRIPT   = 0x4000,
      OLECMDIDF_REFRESH_PAGEACTION_ACTIVEXINSTALL = 0x00010000,
      OLECMDIDF_REFRESH_PAGEACTION_FILEDOWNLOAD   = 0x00020000,
      OLECMDIDF_REFRESH_PAGEACTION_LOCALMACHINE   = 0x00040000,
      OLECMDIDF_REFRESH_PAGEACTION_POPUPWINDOW    = 0x00080000,
      OLECMDIDF_REFRESH_PAGEACTION_PROTLOCKDOWNLOCALMACHINE  = 0x00100000,
      OLECMDIDF_REFRESH_PAGEACTION_PROTLOCKDOWNTRUSTED       = 0x00200000,
      OLECMDIDF_REFRESH_PAGEACTION_PROTLOCKDOWNINTRANET      = 0x00400000,
      OLECMDIDF_REFRESH_PAGEACTION_PROTLOCKDOWNINTERNET      = 0x00800000,
      OLECMDIDF_REFRESH_PAGEACTION_PROTLOCKDOWNRESTRICTED    = 0x01000000,
#elif(NTDDI_VERSION >= NTDDI_WINXP)
      OLECMDIDF_REFRESH_PROMPTIFOFFLINE = 0x2000,
      OLECMDIDF_REFRESH_THROUGHSCRIPT   = 0x4000,
#else
      OLECMDIDF_REFRESH_PROMPTIFOFFLINE = 0x2000,
#endif
      OLECMDIDF_REFRESH_PAGEACTION_MIXEDCONTENT              = 0x02000000,
      OLECMDIDF_REFRESH_PAGEACTION_INVALID_CERT              = 0x04000000,
} OLECMDID_REFRESHFLAG;
#if(NTDDI_VERSION >= NTDDI_WINXPSP2)
typedef enum
{
      OLECMDIDF_PAGEACTION_FILEDOWNLOAD                       = 0x00000001,
      OLECMDIDF_PAGEACTION_ACTIVEXINSTALL                     = 0x00000002,
      OLECMDIDF_PAGEACTION_ACTIVEXTRUSTFAIL                   = 0x00000004,
      OLECMDIDF_PAGEACTION_ACTIVEXUSERDISABLE                 = 0x00000008,
      OLECMDIDF_PAGEACTION_ACTIVEXDISALLOW                    = 0x00000010,
      OLECMDIDF_PAGEACTION_ACTIVEXUNSAFE                      = 0x00000020,
      OLECMDIDF_PAGEACTION_POPUPWINDOW                        = 0x00000040,
      OLECMDIDF_PAGEACTION_LOCALMACHINE                       = 0x00000080,
      OLECMDIDF_PAGEACTION_MIMETEXTPLAIN                      = 0x00000100,
      OLECMDIDF_PAGEACTION_SCRIPTNAVIGATE                     = 0x00000200,
      OLECMDIDF_PAGEACTION_SCRIPTNAVIGATE_ACTIVEXINSTALL      = 0x00000200,
      OLECMDIDF_PAGEACTION_PROTLOCKDOWNLOCALMACHINE           = 0x00000400,
      OLECMDIDF_PAGEACTION_PROTLOCKDOWNTRUSTED                = 0x00000800,
      OLECMDIDF_PAGEACTION_PROTLOCKDOWNINTRANET               = 0x00001000,
      OLECMDIDF_PAGEACTION_PROTLOCKDOWNINTERNET               = 0x00002000,
      OLECMDIDF_PAGEACTION_PROTLOCKDOWNRESTRICTED             = 0x00004000,
      OLECMDIDF_PAGEACTION_PROTLOCKDOWNDENY                   = 0x00008000,
      OLECMDIDF_PAGEACTION_POPUPALLOWED                       = 0x00010000,
      OLECMDIDF_PAGEACTION_SCRIPTPROMPT                       = 0x00020000,
      OLECMDIDF_PAGEACTION_ACTIVEXUSERAPPROVAL                = 0x00040000,
      OLECMDIDF_PAGEACTION_MIXEDCONTENT                       = 0x00080000,
      OLECMDIDF_PAGEACTION_INVALID_CERT                       = 0x00100000,
      OLECMDIDF_PAGEACTION_INTRANETZONEREQUEST                = 0x00200000,
      OLECMDIDF_PAGEACTION_XSSFILTERED                        = 0x00400000,
      OLECMDIDF_PAGEACTION_SPOOFABLEIDNHOST                   = 0x00800000,
      OLECMDIDF_PAGEACTION_SCRIPTNAVIGATE_ACTIVEXUSERAPPROVAL = 0x02000000,
      OLECMDIDF_PAGEACTION_WPCBLOCKED                         = 0x04000000,
      OLECMDIDF_PAGEACTION_WPCBLOCKED_ACTIVEX                 = 0x08000000,
      OLECMDIDF_PAGEACTION_EXTENSION_COMPAT_BLOCKED           = 0x10000000,
      OLECMDIDF_PAGEACTION_NORESETACTIVEX                     = 0x20000000,
      OLECMDIDF_PAGEACTION_GENERIC_STATE                      = 0x40000000,
      OLECMDIDF_PAGEACTION_RESET                              = (int) 0x80000000,
} OLECMDID_PAGEACTIONFLAG;
typedef enum
{
      OLECMDIDF_BROWSERSTATE_EXTENSIONSOFF                      = 0x00000001,
      OLECMDIDF_BROWSERSTATE_IESECURITY                         = 0x00000002,
      OLECMDIDF_BROWSERSTATE_PROTECTEDMODE_OFF                  = 0x00000004,
      OLECMDIDF_BROWSERSTATE_RESET                              = 0x00000008,
} OLECMDID_BROWSERSTATEFLAG;
typedef enum
{
      OLECMDIDF_OPTICAL_ZOOM_NOPERSIST                          = 0x00000001,
} OLECMDID_OPTICAL_ZOOMFLAG;
typedef enum
{
    PAGEACTION_UI_DEFAULT     = 0,
    PAGEACTION_UI_MODAL       = 1,
    PAGEACTION_UI_MODELESS    = 2,
    PAGEACTION_UI_SILENT      = 3,
} PAGEACTION_UI;
#endif
typedef enum
{
    OLECMDIDF_WINDOWSTATE_USERVISIBLE        = 0x00000001,
    OLECMDIDF_WINDOWSTATE_ENABLED            = 0x00000002,
    OLECMDIDF_WINDOWSTATE_USERVISIBLE_VALID  = 0x00010000,
    OLECMDIDF_WINDOWSTATE_ENABLED_VALID      = 0x00020000,
} OLECMDID_WINDOWSTATE_FLAG;

////////////////////////////////////////////////////////////////////////////
//  Aliases to original office-compatible names
#define IMsoDocument             IOleDocument
#define IMsoDocumentSite         IOleDocumentSite
#define IMsoView                 IOleDocumentView
#define IEnumMsoView             IEnumOleDocumentViews
#define IMsoCommandTarget        IOleCommandTarget
#define LPMSODOCUMENT            LPOLEDOCUMENT
#define LPMSODOCUMENTSITE        LPOLEDOCUMENTSITE
#define LPMSOVIEW                LPOLEDOCUMENTVIEW
#define LPENUMMSOVIEW            LPENUMOLEDOCUMENTVIEWS
#define LPMSOCOMMANDTARGET       LPOLECOMMANDTARGET
#define MSOCMD                   OLECMD
#define MSOCMDTEXT               OLECMDTEXT
#define IID_IMsoDocument         IID_IOleDocument
#define IID_IMsoDocumentSite     IID_IOleDocumentSite
#define IID_IMsoView             IID_IOleDocumentView
#define IID_IEnumMsoView         IID_IEnumOleDocumentViews
#define IID_IMsoCommandTarget    IID_IOleCommandTarget
#define MSOCMDF_SUPPORTED OLECMDF_SUPPORTED
#define MSOCMDF_ENABLED OLECMDF_ENABLED
#define MSOCMDF_LATCHED OLECMDF_LATCHED
#define MSOCMDF_NINCHED OLECMDF_NINCHED
#define MSOCMDTEXTF_NONE OLECMDTEXTF_NONE
#define MSOCMDTEXTF_NAME OLECMDTEXTF_NAME
#define MSOCMDTEXTF_STATUS OLECMDTEXTF_STATUS
#define MSOCMDEXECOPT_DODEFAULT OLECMDEXECOPT_DODEFAULT
#define MSOCMDEXECOPT_PROMPTUSER OLECMDEXECOPT_PROMPTUSER
#define MSOCMDEXECOPT_DONTPROMPTUSER OLECMDEXECOPT_DONTPROMPTUSER
#define MSOCMDEXECOPT_SHOWHELP OLECMDEXECOPT_SHOWHELP
#define MSOCMDID_OPEN OLECMDID_OPEN
#define MSOCMDID_NEW OLECMDID_NEW
#define MSOCMDID_SAVE OLECMDID_SAVE
#define MSOCMDID_SAVEAS OLECMDID_SAVEAS
#define MSOCMDID_SAVECOPYAS OLECMDID_SAVECOPYAS
#define MSOCMDID_PRINT OLECMDID_PRINT
#define MSOCMDID_PRINTPREVIEW OLECMDID_PRINTPREVIEW
#define MSOCMDID_PAGESETUP OLECMDID_PAGESETUP
#define MSOCMDID_SPELL OLECMDID_SPELL
#define MSOCMDID_PROPERTIES OLECMDID_PROPERTIES
#define MSOCMDID_CUT OLECMDID_CUT
#define MSOCMDID_COPY OLECMDID_COPY
#define MSOCMDID_PASTE OLECMDID_PASTE
#define MSOCMDID_PASTESPECIAL OLECMDID_PASTESPECIAL
#define MSOCMDID_UNDO OLECMDID_UNDO
#define MSOCMDID_REDO OLECMDID_REDO
#define MSOCMDID_SELECTALL OLECMDID_SELECTALL
#define MSOCMDID_CLEARSELECTION OLECMDID_CLEARSELECTION
#define MSOCMDID_ZOOM OLECMDID_ZOOM
#define MSOCMDID_GETZOOMRANGE OLECMDID_GETZOOMRANGE
EXTERN_C const GUID SID_SContainerDispatch;


extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0007_v0_0_s_ifspec;

#ifndef __IZoomEvents_INTERFACE_DEFINED__
#define __IZoomEvents_INTERFACE_DEFINED__

/* interface IZoomEvents */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IZoomEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("41B68150-904C-4e17-A0BA-A438182E359D")
    IZoomEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnZoomPercentChanged( 
            /* [in] */ ULONG ulZoomPercent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IZoomEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IZoomEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IZoomEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IZoomEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnZoomPercentChanged )( 
            __RPC__in IZoomEvents * This,
            /* [in] */ ULONG ulZoomPercent);
        
        END_INTERFACE
    } IZoomEventsVtbl;

    interface IZoomEvents
    {
        CONST_VTBL struct IZoomEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IZoomEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IZoomEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IZoomEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IZoomEvents_OnZoomPercentChanged(This,ulZoomPercent)	\
    ( (This)->lpVtbl -> OnZoomPercentChanged(This,ulZoomPercent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IZoomEvents_INTERFACE_DEFINED__ */


#ifndef __IProtectFocus_INTERFACE_DEFINED__
#define __IProtectFocus_INTERFACE_DEFINED__

/* interface IProtectFocus */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IProtectFocus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d81f90a3-8156-44f7-ad28-5abb87003274")
    IProtectFocus : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AllowFocusChange( 
            /* [out] */ __RPC__out BOOL *pfAllow) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProtectFocusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IProtectFocus * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IProtectFocus * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IProtectFocus * This);
        
        HRESULT ( STDMETHODCALLTYPE *AllowFocusChange )( 
            __RPC__in IProtectFocus * This,
            /* [out] */ __RPC__out BOOL *pfAllow);
        
        END_INTERFACE
    } IProtectFocusVtbl;

    interface IProtectFocus
    {
        CONST_VTBL struct IProtectFocusVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProtectFocus_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IProtectFocus_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IProtectFocus_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IProtectFocus_AllowFocusChange(This,pfAllow)	\
    ( (This)->lpVtbl -> AllowFocusChange(This,pfAllow) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IProtectFocus_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0000_0009 */
/* [local] */ 

#define SID_SProtectFocus  IID_IProtectFocus
#ifndef _LPPROTECTEDMODEMENUSERVICES_DEFINED
#define _LPPROTECTEDMODEMENUSERVICES_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0009_v0_0_s_ifspec;

#ifndef __IProtectedModeMenuServices_INTERFACE_DEFINED__
#define __IProtectedModeMenuServices_INTERFACE_DEFINED__

/* interface IProtectedModeMenuServices */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IProtectedModeMenuServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("73c105ee-9dff-4a07-b83c-7eff290c266e")
    IProtectedModeMenuServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateMenu( 
            /* [out] */ __RPC__deref_out_opt HMENU *phMenu) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadMenu( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszModuleName,
            /* [string][in] */ __RPC__in_string LPCWSTR pszMenuName,
            /* [out] */ __RPC__deref_out_opt HMENU *phMenu) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadMenuID( 
            /* [string][in] */ __RPC__in_string LPCWSTR pszModuleName,
            /* [in] */ WORD wResourceID,
            /* [out] */ __RPC__deref_out_opt HMENU *phMenu) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProtectedModeMenuServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IProtectedModeMenuServices * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IProtectedModeMenuServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IProtectedModeMenuServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateMenu )( 
            __RPC__in IProtectedModeMenuServices * This,
            /* [out] */ __RPC__deref_out_opt HMENU *phMenu);
        
        HRESULT ( STDMETHODCALLTYPE *LoadMenu )( 
            __RPC__in IProtectedModeMenuServices * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszModuleName,
            /* [string][in] */ __RPC__in_string LPCWSTR pszMenuName,
            /* [out] */ __RPC__deref_out_opt HMENU *phMenu);
        
        HRESULT ( STDMETHODCALLTYPE *LoadMenuID )( 
            __RPC__in IProtectedModeMenuServices * This,
            /* [string][in] */ __RPC__in_string LPCWSTR pszModuleName,
            /* [in] */ WORD wResourceID,
            /* [out] */ __RPC__deref_out_opt HMENU *phMenu);
        
        END_INTERFACE
    } IProtectedModeMenuServicesVtbl;

    interface IProtectedModeMenuServices
    {
        CONST_VTBL struct IProtectedModeMenuServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProtectedModeMenuServices_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IProtectedModeMenuServices_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IProtectedModeMenuServices_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IProtectedModeMenuServices_CreateMenu(This,phMenu)	\
    ( (This)->lpVtbl -> CreateMenu(This,phMenu) ) 

#define IProtectedModeMenuServices_LoadMenu(This,pszModuleName,pszMenuName,phMenu)	\
    ( (This)->lpVtbl -> LoadMenu(This,pszModuleName,pszMenuName,phMenu) ) 

#define IProtectedModeMenuServices_LoadMenuID(This,pszModuleName,wResourceID,phMenu)	\
    ( (This)->lpVtbl -> LoadMenuID(This,pszModuleName,wResourceID,phMenu) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IProtectedModeMenuServices_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0000_0010 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0010_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_0010_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HMENU_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in HMENU * ); 
unsigned char * __RPC_USER  HMENU_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HMENU * ); 
unsigned char * __RPC_USER  HMENU_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HMENU * ); 
void                      __RPC_USER  HMENU_UserFree(     __RPC__in unsigned long *, __RPC__in HMENU * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     __RPC__in unsigned long *, __RPC__in VARIANT * ); 

unsigned long             __RPC_USER  HMENU_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in HMENU * ); 
unsigned char * __RPC_USER  HMENU_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HMENU * ); 
unsigned char * __RPC_USER  HMENU_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HMENU * ); 
void                      __RPC_USER  HMENU_UserFree64(     __RPC__in unsigned long *, __RPC__in HMENU * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     __RPC__in unsigned long *, __RPC__in VARIANT * ); 

/* [local] */ HRESULT __stdcall IEnumOleDocumentViews_Next_Proxy( 
    IEnumOleDocumentViews * This,
    /* [in] */ ULONG cViews,
    /* [out] */ IOleDocumentView **rgpView,
    /* [out] */ ULONG *pcFetched);


/* [call_as] */ HRESULT __stdcall IEnumOleDocumentViews_Next_Stub( 
    __RPC__in IEnumOleDocumentViews * This,
    /* [in] */ ULONG cViews,
    /* [length_is][size_is][out] */ __RPC__out_ecount_part(cViews, *pcFetched) IOleDocumentView **rgpView,
    /* [out] */ __RPC__out ULONG *pcFetched);

/* [local] */ HRESULT __stdcall IPrint_Print_Proxy( 
    IPrint * This,
    /* [in] */ DWORD grfFlags,
    /* [out][in] */ DVTARGETDEVICE **pptd,
    /* [out][in] */ PAGESET **ppPageSet,
    /* [unique][out][in] */ STGMEDIUM *pstgmOptions,
    /* [in] */ IContinueCallback *pcallback,
    /* [in] */ LONG nFirstPage,
    /* [out] */ LONG *pcPagesPrinted,
    /* [out] */ LONG *pnLastPage);


/* [call_as] */ HRESULT __stdcall IPrint_Print_Stub( 
    __RPC__in IPrint * This,
    /* [in] */ DWORD grfFlags,
    /* [out][in] */ __RPC__deref_inout_opt DVTARGETDEVICE **pptd,
    /* [out][in] */ __RPC__deref_inout_opt PAGESET **pppageset,
    /* [unique][out][in] */ __RPC__inout_opt RemSTGMEDIUM *pstgmOptions,
    /* [in] */ __RPC__in_opt IContinueCallback *pcallback,
    /* [in] */ LONG nFirstPage,
    /* [out] */ __RPC__out LONG *pcPagesPrinted,
    /* [out] */ __RPC__out LONG *pnLastPage);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\drivinit.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:       drivinit.h
//
//----------------------------------------------------------------------------

// All items moved to wingdi.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dpx.h ===
// Copyright Microsoft Corporation.  All rights reserved.

#pragma once

#include <dpx1.h>

//
//  DpxNewJob and DpxRestoreJob require a TargetPath which is the local file
//  system directory under which extracted files should be created.  If the
//  directory does not exist, DpxNewJob or DpxRestoreJob will fail.  Files
//  created under TargetPath directory may include relative subdirectory names
//  or even stream names.  Files and subdirectories will be created with
//  inherited ACL from TargetPath and owner from the thread calling
//  IDpxJob::ProvideRequestedData.  During the course of extraction, additional
//  temporary files might be created in the TargetPath directory but will be
//  deleted when the job completes.  If the job is cancelled or destroyed
//  before completing, these temporary files may not be automatically deleted.
//  To move partially completed extraction job to different TargetPath, caller
//  may Suspend and SaveJobState, then tree-copy entire existing TargetPath
//  contents to new location, create a new IDpxJob instance, then DpxRestoreJob
//  using the new TargetPath location.
//

EXTERN_C HRESULT WINAPI DpxNewJob( __in LPCWSTR TargetPath, __deref_out IDpxJob ** ppJob );

EXTERN_C HRESULT WINAPI DpxRestoreJob( __in LPCWSTR TargetPath, __deref_out IDpxJob ** ppJob );

EXTERN_C VOID    WINAPI DpxFreeMemory( __in void* Allocation );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\DownloadMgr.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for downloadmgr.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __downloadmgr_h__
#define __downloadmgr_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDownloadManager_FWD_DEFINED__
#define __IDownloadManager_FWD_DEFINED__
typedef interface IDownloadManager IDownloadManager;
#endif 	/* __IDownloadManager_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_downloadmgr_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// downloadmgr.h
//=--------------------------------------------------------------------------=
// (C) Copyright Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// Internet Explorer Download Manager Interfaces

// --------------------------------------------------------------------------------
// GUIDS
// --------------------------------------------------------------------------------
// {988934A4-064B-11D3-BB80-00104B35E7F9}
DEFINE_GUID(IID_IDownloadManager, 0x988934a4, 0x064b, 0x11d3, 0xbb, 0x80, 0x0, 0x10, 0x4b, 0x35, 0xe7, 0xf9);
#define SID_SDownloadManager IID_IDownloadManager



extern RPC_IF_HANDLE __MIDL_itf_downloadmgr_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_downloadmgr_0000_0000_v0_0_s_ifspec;

#ifndef __IDownloadManager_INTERFACE_DEFINED__
#define __IDownloadManager_INTERFACE_DEFINED__

/* interface IDownloadManager */
/* [local][unique][uuid][object][helpstring] */ 


EXTERN_C const IID IID_IDownloadManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("988934A4-064B-11D3-BB80-00104B35E7F9")
    IDownloadManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Download( 
            /* [in] */ IMoniker *pmk,
            /* [in] */ IBindCtx *pbc,
            /* [in] */ DWORD dwBindVerb,
            /* [in] */ LONG grfBINDF,
            /* [in] */ BINDINFO *pBindInfo,
            /* [in] */ LPCOLESTR pszHeaders,
            /* [in] */ LPCOLESTR pszRedir,
            /* [in] */ UINT uiCP) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDownloadManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDownloadManager * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDownloadManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDownloadManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *Download )( 
            IDownloadManager * This,
            /* [in] */ IMoniker *pmk,
            /* [in] */ IBindCtx *pbc,
            /* [in] */ DWORD dwBindVerb,
            /* [in] */ LONG grfBINDF,
            /* [in] */ BINDINFO *pBindInfo,
            /* [in] */ LPCOLESTR pszHeaders,
            /* [in] */ LPCOLESTR pszRedir,
            /* [in] */ UINT uiCP);
        
        END_INTERFACE
    } IDownloadManagerVtbl;

    interface IDownloadManager
    {
        CONST_VTBL struct IDownloadManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDownloadManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDownloadManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDownloadManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDownloadManager_Download(This,pmk,pbc,dwBindVerb,grfBINDF,pBindInfo,pszHeaders,pszRedir,uiCP)	\
    ( (This)->lpVtbl -> Download(This,pmk,pbc,dwBindVerb,grfBINDF,pBindInfo,pszHeaders,pszRedir,uiCP) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDownloadManager_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dot1x.h ===
#ifndef __DOT1X_H_
#define __DOT1X_H_

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include <l2cmn.h>
#include <eaptypes.h>

#if __midl
#define V1_ENUM [v1_enum]
#else
#define V1_ENUM
#endif

#pragma warning(disable:4214) // bit field types other than int


/*
    The identity that is being used by the 1X module. This is a function of the
    onex auth mode and system triggers (e.g. user logon/logoff)
    */  
typedef V1_ENUM enum _ONEX_AUTH_IDENTITY 
{
    OneXAuthIdentityNone,
    OneXAuthIdentityMachine,
    OneXAuthIdentityUser,
    OneXAuthIdentityExplicitUser,
    OneXAuthIdentityGuest,
    OneXAuthIdentityInvalid
} ONEX_AUTH_IDENTITY, *PONEX_AUTH_IDENTITY;

/*
    The 1X authentication status. Each of the auth status corresponds to one or
    more of the internal 1X states. 
    */
typedef V1_ENUM enum _ONEX_AUTH_STATUS
{
    OneXAuthNotStarted,
    OneXAuthInProgress,
    OneXAuthNoAuthenticatorFound,
    OneXAuthSuccess,
    OneXAuthFailure,
    OneXAuthInvalid
} ONEX_AUTH_STATUS, *PONEX_AUTH_STATUS;

/*
    1X specific reason codes
    */
typedef V1_ENUM enum _ONEX_REASON_CODE
{
    ONEX_REASON_CODE_SUCCESS = 0,
    ONEX_REASON_START = L2_REASON_CODE_ONEX_BASE,
    ONEX_UNABLE_TO_IDENTIFY_USER,
    ONEX_IDENTITY_NOT_FOUND,
    ONEX_UI_DISABLED,
    ONEX_UI_FAILURE,
    ONEX_EAP_FAILURE_RECEIVED,
    ONEX_AUTHENTICATOR_NO_LONGER_PRESENT,
    ONEX_NO_RESPONSE_TO_IDENTITY,
    ONEX_PROFILE_VERSION_NOT_SUPPORTED,
    ONEX_PROFILE_INVALID_LENGTH,
    ONEX_PROFILE_DISALLOWED_EAP_TYPE,
    ONEX_PROFILE_INVALID_EAP_TYPE_OR_FLAG,
    ONEX_PROFILE_INVALID_ONEX_FLAGS,
    ONEX_PROFILE_INVALID_TIMER_VALUE,
    ONEX_PROFILE_INVALID_SUPPLICANT_MODE,
    ONEX_PROFILE_INVALID_AUTH_MODE,
    ONEX_PROFILE_INVALID_EAP_CONNECTION_PROPERTIES,
    ONEX_UI_CANCELLED,
    ONEX_PROFILE_INVALID_EXPLICIT_CREDENTIALS,
    ONEX_PROFILE_EXPIRED_EXPLICIT_CREDENTIALS,
    ONEX_UI_NOT_PERMITTED    
} ONEX_REASON_CODE, *PONEX_REASON_CODE;

/*
    Events for which 1X sends notifications to MSM

    On getting an event notification the callee should switch on the dwEvent.
    
    If dwEvent =  OneXNotificationTypeResultUpdate, pvEventData points to an
    ONEX_RESULT_UPDATE_DATA structure
    
    If dwEvent = OneXNotificationTypeOneXUserIdentified, pvEventData points to
    a ONEX_USER_INFO structure
    
    If dwEvent = OneXNotificationTypeGotOneXIdentityString, pvEventData points to
    the identity (LPWSTR) being used for the 1X authentication
    
    If dwEvent = OneXNotificationTypeFallenBackOnGuest pvEventData is NULL
    
    if dwEvent = OneXNotificationTypeAuthRestarted, pvEventData points
    to the restart reason    
    */
typedef V1_ENUM enum _ONEX_NOTIFICATION_TYPE
{
    OneXPublicNotificationBase = 0,
    OneXNotificationTypeResultUpdate,
    OneXNotificationTypeAuthRestarted,
    OneXNotificationTypeEventInvalid,
    OneXNumNotifications = OneXNotificationTypeEventInvalid
} ONEX_NOTIFICATION_TYPE, *PONEX_NOTIFICATION_TYPE;

/*
    The following list enumerates the reason for the 1X authentication process 
    getting restarted
    */
typedef V1_ENUM enum _ONEX_AUTH_RESTART_REASON
{
    OneXRestartReasonPeerInitiated,
    OneXRestartReasonMsmInitiated,
    OneXRestartReasonOneXHeldStateTimeout,
    OneXRestartReasonOneXAuthTimeout,
    OneXRestartReasonOneXConfigurationChanged,
    OneXRestartReasonOneXUserChanged,
    OneXRestartReasonQuarantineStateChanged,
    OneXRestartReasonAltCredsTrial,
    OneXRestartReasonInvalid
} ONEX_AUTH_RESTART_REASON, *PONEX_AUTH_RESTART_REASON;

typedef struct _ONEX_VARIABLE_BLOB 
{
    DWORD dwSize; 
    DWORD dwOffset;
} ONEX_VARIABLE_BLOB, *PONEX_VARIABLE_BLOB;

/*
    The set of parameters that define the authentication context for 1X
    */
typedef struct _ONEX_AUTH_PARAMS
{
    BOOL fUpdatePending;
    ONEX_VARIABLE_BLOB oneXConnProfile;    
    ONEX_AUTH_IDENTITY authIdentity;
    DWORD dwQuarantineState;
    
    DWORD fSessionId:1;
    DWORD fhUserToken:1;
    DWORD fOnexUserProfile:1;
    DWORD fIdentity:1;
    DWORD fUserName:1;
    DWORD fDomain:1;

    DWORD dwSessionId;

    HANDLE hUserToken;
    
    ONEX_VARIABLE_BLOB OneXUserProfile;
    ONEX_VARIABLE_BLOB Identity;
    ONEX_VARIABLE_BLOB UserName;
    ONEX_VARIABLE_BLOB Domain;
} ONEX_AUTH_PARAMS, *PONEX_AUTH_PARAMS;

typedef struct _ONEX_EAP_ERROR
{
	DWORD dwWinError;
	EAP_METHOD_TYPE type;
	DWORD dwReasonCode;

	GUID   rootCauseGuid;
	GUID   repairGuid;
	GUID   helpLinkGuid;

	DWORD fRootCauseString:1;
	DWORD fRepairString:1;
	
	ONEX_VARIABLE_BLOB RootCauseString;
	ONEX_VARIABLE_BLOB RepairString;
} ONEX_EAP_ERROR, *PONEX_EAP_ERROR;

typedef struct _ONEX_STATUS
{
    ONEX_AUTH_STATUS authStatus;
    /*
        Any errors that happened during the authentication are indicated as 
        error and reason codes below
        */
    DWORD dwReason;
    DWORD dwError;    
} ONEX_STATUS, *PONEX_STATUS;

typedef V1_ENUM enum _ONEX_EAP_METHOD_BACKEND_SUPPORT
{
    OneXEapMethodBackendSupportUnknown,
    OneXEapMethodBackendSupported,
    OneXEapMethodBackendUnsupported
}ONEX_EAP_METHOD_BACKEND_SUPPORT;

typedef struct _ONEX_RESULT_UPDATE_DATA
{
    ONEX_STATUS oneXStatus;
    ONEX_EAP_METHOD_BACKEND_SUPPORT BackendSupport;
    BOOL fBackendEngaged;

    DWORD fOneXAuthParams:1;
    DWORD fEapError:1;
    
    ONEX_VARIABLE_BLOB authParams;
    ONEX_VARIABLE_BLOB eapError;
} ONEX_RESULT_UPDATE_DATA, *PONEX_RESULT_UPDATE_DATA;

typedef struct _ONEX_USER_INFO
{
    ONEX_AUTH_IDENTITY authIdentity;

    DWORD fUserName:1;
    DWORD fDomainName:1;

    ONEX_VARIABLE_BLOB UserName;
    ONEX_VARIABLE_BLOB DomainName;
} ONEX_USER_INFO, *PONEX_USER_INFO;

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dpnathlp.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dpnathlp.h
 *
 *  Content:	Header for using DirectPlayNATHelp interface.
 *
 *
 *  NOTE: This interface is deprecated and should no longer be used.
 *
 *
 ***************************************************************************/



#ifndef __DPNATHLP_H__
#define __DPNATHLP_H__



#include <ole2.h>	// for DECLARE_INTERFACE and HRESULT



#ifndef DPNATHLP_EXPORTS
#define DPNATHLPAPI DECLSPEC_IMPORT
#else
#define DPNATHLPAPI
#endif



#ifdef __cplusplus
extern "C" {
#endif





/****************************************************************************
 *
 * DirectPlay NAT Helper object class IDs
 *
 ****************************************************************************/

// {B9C2E9C4-68C1-4d42-A7A1-E76A26982AD6}
DEFINE_GUID(CLSID_DirectPlayNATHelpUPnP,
0xb9c2e9c4, 0x68c1, 0x4d42, 0xa7, 0xa1, 0xe7, 0x6a, 0x26, 0x98, 0x2a, 0xd6);

// {963AB779-16A1-477c-A36D-CB5E711938F7}
DEFINE_GUID(CLSID_DirectPlayNATHelpPAST,
0x963ab779, 0x16a1, 0x477c, 0xa3, 0x6d, 0xcb, 0x5e, 0x71, 0x19, 0x38, 0xf7);


/****************************************************************************
 *
 * DirectPlay NAT Helper interface ID
 *
 ****************************************************************************/

// {3b743591-791b-4864-9ee3-55e889409781}
DEFINE_GUID(IID_IDirectPlayNATHelp, 
0x3b743591, 0x791b, 0x4864, 0x9e, 0xe3, 0x55, 0xe8, 0x89, 0x40, 0x97, 0x81);

/****************************************************************************
 *
 * DirectPlay NAT Helper interface pointer definitions
 *
 ****************************************************************************/

typedef	struct IDirectPlayNATHelp     *PDIRECTPLAYNATHELP;




/****************************************************************************
 *
 * DirectPlay NAT Helper data types
 *
 ****************************************************************************/

//
// Handles used to identify specific port binding groups.  If multiple ports
// are registered at the same time, the DPNHHANDLE refers to all ports.
//
typedef DWORD_PTR	DPNHHANDLE,	* PDPNHHANDLE;




/****************************************************************************
 *
 * DirectPlay NAT Helper constants
 *
 ****************************************************************************/

#define DPNH_MAX_SIMULTANEOUS_PORTS		16	// up to 16 ports may be specified in a single RegisterPorts call




/****************************************************************************
 *
 * DirectPlay NAT Helper API flags
 *
 ****************************************************************************/

//
// Flags that can be passed to Initialize
//
#define DPNHINITIALIZE_DISABLEGATEWAYSUPPORT				0x01	// disables Internet gateway traversal support (cannot be specified with DPNHINITIALIZE_DISABLELOCALFIREWALLSUPPORT)
#define DPNHINITIALIZE_DISABLELOCALFIREWALLSUPPORT			0x02	// disables local firewall traversal support (cannot be specified with DPNHINITIALIZE_DISABLEGATEWAYSUPPORT)

//
// Flags that can be passed to GetCaps.
//
#define DPNHGETCAPS_UPDATESERVERSTATUS						0x01	// automatically extend expiring leases and detect changes in server status

//
// Flags that can be passed to RegisterPorts.
//
#define DPNHREGISTERPORTS_TCP								0x01	// request TCP ports instead of UDP
#define DPNHREGISTERPORTS_FIXEDPORTS						0x02	// asks the server to use the same port numbers on the public interface
#define DPNHREGISTERPORTS_SHAREDPORTS						0x04	// requests that the server allow the UDP fixed ports to be shared with other clients (must be specified with DPNHREGISTERPORTS_FIXEDPORTS and cannot be specified with DPNHREGISTERPORTS_TCP)

//
// Flags that can be passed to GetRegisteredAddresses.
//
#define DPNHGETREGISTEREDADDRESSES_LOCALFIREWALLREMAPONLY	0x01	// retrieve the public address for the local firewall only, even if mapped on remote Internet gateway

//
// Flags that can be passed to QueryAddress.
//
#define DPNHQUERYADDRESS_TCP								0x01	// request a TCP port instead of UDP
#define DPNHQUERYADDRESS_CACHEFOUND							0x02	// cache the discovered address if found
#define DPNHQUERYADDRESS_CACHENOTFOUND						0x04	// cache the fact that no address was found, if that is the case
#define DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED			0x08	// determine if the address is behind the same Internet gateway, but not mapped on that Internet gateway

/****************************************************************************
 *
 * DirectPlay NAT Helper structure flags
 *
 ****************************************************************************/

//
// DPNHCAPS flags
//
#define DPNHCAPSFLAG_LOCALFIREWALLPRESENT		0x01	// at least one network connection has a local firewall present
#define DPNHCAPSFLAG_GATEWAYPRESENT				0x02	// at least one network connection has an Internet gateway present
#define DPNHCAPSFLAG_GATEWAYISLOCAL				0x04	// a detected Internet gateway is local (i.e. the public address is another network interface on the same machine)
#define DPNHCAPSFLAG_PUBLICADDRESSAVAILABLE		0x08	// at least one server has a valid public address for registered mappings
#define DPNHCAPSFLAG_NOTALLSUPPORTACTIVENOTIFY	0x10	// at least one available server does not support an active-notification mechanisms and must be polled



/****************************************************************************
 *
 * DirectPlay NAT Helper structures
 *
 ****************************************************************************/
 
typedef struct _DPNHCAPS
{
	DWORD	dwSize;							// size of this structure, must be filled in prior to calling GetCaps
	DWORD	dwFlags;						// flags indicating capabilities of Internet gateway server(s)
	DWORD	dwNumRegisteredPorts;			// number of ports currently registered, including multiple ports registered at the same time (so this may not be equal to the number of DPNHHANDLEs given out)
	DWORD	dwMinLeaseTimeRemaining;		// approximate time remaining, in milliseconds, for the lease that will expire soonest
	DWORD	dwRecommendedGetCapsInterval;	// recommended time, in milliseconds, after which GetCaps should be called again (with DPNHGETCAPS_UPDATESERVERSTATUS flag)
} DPNHCAPS, * PDPNHCAPS;



/****************************************************************************
 *
 * Address type flags (returned by GetRegisteredAddresses)
 *
 ****************************************************************************/

#define DPNHADDRESSTYPE_TCP				0x01	// the mappings are for TCP ports instead of UDP
#define DPNHADDRESSTYPE_FIXEDPORTS		0x02	// the mappings are for ports which are the same on the Internet gateway 
#define DPNHADDRESSTYPE_SHAREDPORTS		0x04	// the mappings are for shared UDP fixed ports
#define DPNHADDRESSTYPE_LOCALFIREWALL	0x08	// the addresses are opened on a local firewall
#define DPNHADDRESSTYPE_GATEWAY			0x10	// the addresses are registered with an Internet gateway
#define DPNHADDRESSTYPE_GATEWAYISLOCAL	0x20	// the Internet gateway is local (i.e. the public address is another network interface on the same machine)




/****************************************************************************
 *
 * DirectPlay NAT Helper DLL exported functions
 *
 ****************************************************************************/

typedef HRESULT (WINAPI * PFN_DIRECTPLAYNATHELPCREATE)(const GUID * pIID, void ** ppvInterface);





/****************************************************************************
 *
 * DirectPlay NAT Helper application interfaces
 *
 ****************************************************************************/

#undef INTERFACE
#define INTERFACE IDirectPlayNATHelp
DECLARE_INTERFACE_(IDirectPlayNATHelp, IUnknown)
{
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)				(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)				(THIS) PURE;
	STDMETHOD_(ULONG,Release)				(THIS) PURE;

	/*** IDirectPlayNATHelp methods ***/
	STDMETHOD(Initialize)					(THIS_ const DWORD dwFlags) PURE;
	STDMETHOD(Close)						(THIS_ const DWORD dwFlags) PURE;
	STDMETHOD(GetCaps)						(THIS_ DPNHCAPS * const dpnhcaps, const DWORD dwFlags) PURE;
	STDMETHOD(RegisterPorts)				(THIS_ const SOCKADDR * const aLocalAddresses, const DWORD dwAddressesSize, const DWORD dwNumAddresses, const DWORD dwLeaseTime, DPNHHANDLE * const phRegisteredPorts, const DWORD dwFlags) PURE;
	STDMETHOD(GetRegisteredAddresses)		(THIS_ const DPNHHANDLE hRegisteredPorts, SOCKADDR * const paPublicAddresses, DWORD * const pdwPublicAddressesSize, DWORD * const pdwAddressTypeFlags, DWORD * const pdwLeaseTimeRemaining, const DWORD dwFlags) PURE;
	STDMETHOD(DeregisterPorts)				(THIS_ const DPNHHANDLE hRegisteredPorts, const DWORD dwFlags) PURE;
	STDMETHOD(QueryAddress)					(THIS_ const SOCKADDR * const pSourceAddress, const SOCKADDR * const pQueryAddress, SOCKADDR * const pResponseAddress, const int iAddressesSize, const DWORD dwFlags) PURE;
	STDMETHOD(SetAlertEvent)				(THIS_ const HANDLE hEvent, const DWORD dwFlags) PURE;
	STDMETHOD(SetAlertIOCompletionPort)		(THIS_ const HANDLE hIOCompletionPort, const DWORD dwCompletionKey, const DWORD dwNumConcurrentThreads, const DWORD dwFlags) PURE;
	STDMETHOD(ExtendRegisteredPortsLease)	(THIS_ const DPNHHANDLE hRegisteredPorts, const DWORD dwLeaseTime, const DWORD dwFlags) PURE;
};


/****************************************************************************
 *
 * DirectPlay NAT Helper application interface macros
 *
 ****************************************************************************/

#if (! defined(__cplusplus) || defined(CINTERFACE))

#define	IDirectPlayNATHelp_QueryInterface(p,a,b)					(p)->lpVtbl->QueryInterface(p,a,b)
#define	IDirectPlayNATHelp_AddRef(p)								(p)->lpVtbl->AddRef(p)
#define	IDirectPlayNATHelp_Release(p)								(p)->lpVtbl->Release(p)
#define	IDirectPlayNATHelp_Initialize(p,a)							(p)->lpVtbl->Initialize(p,a)
#define	IDirectPlayNATHelp_Close(p,a)								(p)->lpVtbl->Close(p,a)
#define	IDirectPlayNATHelp_GetCaps(p,a,b)							(p)->lpVtbl->GetCaps(p,a,b)
#define	IDirectPlayNATHelp_RegisterPorts(p,a,b,c,d,e,f)				(p)->lpVtbl->RegisterPorts(p,a,b,c,d,e,f)
#define	IDirectPlayNATHelp_GetRegisteredAddresses(p,a,b,c,d,e,f)	(p)->lpVtbl->GetRegisteredAddresses(p,a,b,c,d,e,f)
#define	IDirectPlayNATHelp_DeregisterPorts(p,a,b)					(p)->lpVtbl->DeregisterPorts(p,a,b)
#define	IDirectPlayNATHelp_QueryAddress(p,a,b,c,d,e)				(p)->lpVtbl->QueryAddress(p,a,b,c,d,e)
#define	IDirectPlayNATHelp_SetAlertEvent(p,a,b)						(p)->lpVtbl->SetAlertEvent(p,a,b)
#define	IDirectPlayNATHelp_SetAlertIOCompletionPort(p,a,b,c,d)		(p)->lpVtbl->SetAlertIOCompletionPort(p,a,b,c,d)
#define	IDirectPlayNATHelp_ExtendRegisteredPortsLease(p,a,b,c)		(p)->lpVtbl->ExtendRegisteredPortsLease(p,a,b,c)


#else // C++

#define	IDirectPlayNATHelp_QueryInterface(p,a,b)					(p)->QueryInterface(a,b)
#define	IDirectPlayNATHelp_AddRef(p)								(p)->AddRef()
#define	IDirectPlayNATHelp_Release(p)								(p)->Release()
#define	IDirectPlayNATHelp_Initialize(p,a)							(p)->Initialize(a)
#define	IDirectPlayNATHelp_Close(p,a)								(p)->Close(a)
#define	IDirectPlayNATHelp_GetCaps(p,a,b)							(p)->GetCaps(a,b)
#define	IDirectPlayNATHelp_RegisterPorts(p,a,b,c,d,e,f)				(p)->RegisterPorts(a,b,c,d,e,f)
#define	IDirectPlayNATHelp_GetRegisteredAddresses(p,a,b,c,d,e,f)	(p)->GetRegisteredAddresses(a,b,c,d,e,f)
#define	IDirectPlayNATHelp_DeregisterPorts(p,a,b)					(p)->DeregisterPorts(a,b)
#define	IDirectPlayNATHelp_QueryAddress(p,a,b,c,d,e)				(p)->QueryAddress(a,b,c,d,e)
#define	IDirectPlayNATHelp_SetAlertEvent(p,a,b)						(p)->SetAlertEvent(a,b)
#define	IDirectPlayNATHelp_SetAlertIOCompletionPort(p,a,b,c,d)		(p)->SetAlertIOCompletionPort(a,b,c,d)
#define	IDirectPlayNATHelp_ExtendRegisteredPortsLease(p,a,b,c)		(p)->ExtendRegisteredPortsLease(a,b,c)


#endif



/****************************************************************************
 *
 * DirectPlay NAT Helper return codes
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/

#define _DPNH_FACILITY_CODE					0x015
#define _DPNH_HRESULT_BASE					0xF000

#define MAKE_DPNHSUCCESS(code)				MAKE_HRESULT(0, _DPNH_FACILITY_CODE, (code + _DPNH_HRESULT_BASE))
#define MAKE_DPNHFAILURE(code)				MAKE_HRESULT(1, _DPNH_FACILITY_CODE, (code + _DPNH_HRESULT_BASE))



#define DPNH_OK								S_OK

#define DPNHSUCCESS_ADDRESSESCHANGED		MAKE_DPNHSUCCESS(0x10)

#define DPNHERR_ALREADYINITIALIZED			MAKE_DPNHFAILURE(0x10)
#define DPNHERR_BUFFERTOOSMALL				MAKE_DPNHFAILURE(0x20)
#define DPNHERR_GENERIC						E_FAIL
#define DPNHERR_INVALIDFLAGS				MAKE_DPNHFAILURE(0x30)
#define DPNHERR_INVALIDOBJECT				MAKE_DPNHFAILURE(0x40)
#define DPNHERR_INVALIDPARAM				E_INVALIDARG
#define DPNHERR_INVALIDPOINTER				E_POINTER
#define DPNHERR_NOMAPPING					MAKE_DPNHFAILURE(0x50)
#define DPNHERR_NOMAPPINGBUTPRIVATE			MAKE_DPNHFAILURE(0x60)
#define DPNHERR_NOTINITIALIZED				MAKE_DPNHFAILURE(0x70)
#define DPNHERR_OUTOFMEMORY					E_OUTOFMEMORY
#define DPNHERR_PORTALREADYREGISTERED		MAKE_DPNHFAILURE(0x80)
#define DPNHERR_PORTUNAVAILABLE				MAKE_DPNHFAILURE(0x90)
#define DPNHERR_REENTRANT					MAKE_DPNHFAILURE(0x95)
#define DPNHERR_SERVERNOTAVAILABLE			MAKE_DPNHFAILURE(0xA0)
#define DPNHERR_UPDATESERVERSTATUS			MAKE_DPNHFAILURE(0xC0)

#ifdef __cplusplus
}
#endif

#endif // __DPNATHLP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\driverspecs.h ===
/*****************************************************************************\
*                                                                             *
* DriverSpecs.h - markers for documenting the semantics of driver APIs        *
*                 See also <SpecStrings.h>                                    *
*                                                                             *
* Version 1.2.10                                                              *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
\*****************************************************************************/

/*****************************************************************************\
* NOTE																		  *
* NOTE																		  *
* NOTE																		  *
*   The macro bodies in this file are subject to change without notice.       *
*   Attempting to use the annotations in the macro bodies directly is not     *
*   supported.																  *
* NOTE																		  *
* NOTE																		  *
* NOTE																		  *
\*****************************************************************************/

/*****************************************************************************\
* The annotations described by KernelSpecs.h and DriverSpecs.h, taken together,
* are used to annotate drivers.  Many of the annotations are applicable to
* user space code (including subsystems) as well as to drivers.
*
* DriverSpecs.h contains those annotations which are appropriate to userspace
* code, or which might appear in headers that are shared between user space
* and kernel space.  In the case of annotations which might appear in such a
* shared header, but which are meaningless in user space, the annotations are
* #defined to nothing in DriverSpecs.h.
*
* KernelSpecs.h contains those annotations which either will only appear in
* kernel code or headers; or which might appear in shared headers.  In the
* latter case, it is assumed that DriverSpecs.h has been #included, and
* the anntoations are re-defined (using #undef) to give them a meaningful
* value.  In general, documentation for the shared-header annotations appears
* in DriverSpecs.h.
*
* Many annotations are context dependent.  They only apply to certain versions
* of Windows, or only to certain classes of driver.  These rules can be written
* using something like __drv_when(NTDDI_VERSION >= NTDDI_WINXP, ...)
* which causes the rule only to apply to Windows XP and later.  Many of these
* symbols are already defined in various Windows headers.
*
* To facilitate using this sort of conditional rule, we collect here the
* various known symbols that are (or reasonably might) be used in such
* a conditional annotation.  Some are speculative in that the symbol has
* not yet been defined because there are no known uses of it yet.
*
* Where the symbol already exists its relevant header is
* noted below (excluding the "really well known" ones).
*
* Each symbol is listed with the currently known possible values.
*
* Some symbols are marked as #define symbols -- they are used with #ifdef
* operators only.  To use them in __drv_when, use something like
* __drv_when(__drv_defined(NT), ...).
*
* WDK Version (copied for convenience from sdkddkver.h)
*     NTDDI_VERSION: NTDDI_WIN2K NTDDI_WIN2KSP1 NTDDI_WIN2KSP2 NTDDI_WIN2KSP3 
*                    NTDDI_WIN2KSP4 NTDDI_WINXP NTDDI_WINXPSP1 NTDDI_WINXPSP2 
*					 NTDDI_WS03 NTDDI_WS03SP1 NTDDI_VISTA
*     The WDK version is taken as the WDM version as well.
*
* OS Version: (copied for convenience from sdkddkver.h)
*     _WIN32_WINNT: _WIN32_WINNT_NT4 _WIN32_WINNT_WIN2K _WIN32_WINNT_WINXP 
*                   _WIN32_WINNT_WS03 _WIN32_WINNT_LONGHORN
*     WINVER: 0x030B 0x0400 0x0500 0x0600
*     NT (#define symbol)
* (sdkddkver.h also defines symbols for IE versions should they be needed.)
*
* Compiler Version:
*	  _MSC_VER: too many to list.
*	  _MSC_FULL_VER: too many to list.
*
* KMDF Version:  (Currently defined/used only in makefiles.)
*     KMDF_VERSION_MAJOR: 1     
*
* UMDF Version:  (Currently defined/used only in makefiles.)
*     UMDF_VERSION_MAJOR: 1     
*
* Architecture kinds:
*     __WIN64 (#define symbols)
*     _X86_
*     _AMD64_
*     _IA64_ 
*
* Machine Architectures:
*     _M_IX86
*     _M_AMD64
*     _M_IA64
*
* Driver Kind (NYI: "not yet implemented")
*   Typically these will be defined in the most-common header for a 
*   particular driver (or in individual source files if appropriate).
*   These are not intended to necessarily be orthogonal: more than one might 
*   apply to a particular driver.
*     _DRIVER_TYPE_BUS: 1                // NYI
*     _DRIVER_TYPE_FUNCTIONAL: 1         // NYI
*     _DRIVER_TYPE_MINIPORT: 1           // NYI
*     _DRIVER_TYPE_STORAGE: 1            // NYI
*     _DRIVER_TYPE_DISPLAY: 1            // NYI
*     _DRIVER_TYPE_FILESYSTEM: 1
*     _DRIVER_TYPE_FILESYSTEM_FILTER: 1
*
* NDIS driver version: (see ndis.h for much more detail.)
*   These can be used to both identify an NDIS driver and to check the version.
*     NDIS40 NDIS50 NDIS51 NDIS60 (#defined symbols)
*     NDIS_PROTOCOL_MAJOR_VERSION.NDIS_PROTOCOL_MINOR_VERSION: 4.0 5.0 5.1 6.0
*     And many others in ndis.h (including MINIPORT)
*
\*****************************************************************************/

#ifndef DRIVERSPECS_H
#define DRIVERSPECS_H

// In case driverspecs.h is included directly (and w/o specstrings.h)
#ifndef SPECSTRINGS_H
#include <specstrings.h>
#endif

#include "sdv_driverspecs.h"

#if _MSC_VER > 1000 // [
#pragma once
#endif // ]

#ifdef  __cplusplus // [
extern "C" {
#endif  // ]

#if (_MSC_VER >= 1000) && !defined(__midl) && defined(_PREFAST_) // [
#define __drv_declspec(x) __declspec(x)
#define __$drv_group(annotes)												\
	  __drv_declspec("SAL_begin") annotes __drv_declspec("SAL_end")
#define __drv_nop(x) x
#else // ][
#define __drv_declspec(x)
#define __$drv_group(x)
#endif // ]

#if (_MSC_VER >= 1000) && !defined(__midl) && defined(_PREFAST_) && defined(_MSC_EXTENSIONS)// [


	// Synthesize a unique symbol.
	#define $$MKID(x, y) x ## y
	#define $MKID(x, y) $$MKID(x, y)
	#define $GENSYM(x) $MKID(x, __COUNTER__)


	// ---------------------------------------------------------------------
	// Processing mode selection:
	//
	// __internal_kernel_driver
	//
	// Flag for headers that indicates a probable driver.
	// This should only be coded in headers that are normally used 
	// as the "primary" header for a class of drivers.  It sets the
	// default to kernel mode driver.
	//
	// ';' inside the parens to keep MIDL happy
	__ANNOTATION(SAL_internal_kernel_driver();)
	#define __internal_kernel_driver 										\
		typedef int __drv_declspec("SAL_internal_kernel_driver") 			\
					$GENSYM(__prefast_flag_kernel_driver_mode);

	//
	// __kernel_code
	// __kernel_driver
	// __user_driver
	// __user_code
	//
	// Flags for compilation units that indicated specifically what kind of 
	// code it is.
	// These should be coded as early as possible in any compilation unit 
	// (.c/.cpp file) that doesn't get the correct default.  Whether before
	// or after __internal_kernel_driver
	// 
	// Indicate that the code is kernel, but not driver, code.

	__ANNOTATION(SAL_kernel();)
	__ANNOTATION(SAL_nokernel();)
	__ANNOTATION(SAL_driver();)
	__ANNOTATION(SAL_nodriver();)

	#define __kernel_code 													\
		typedef int __drv_declspec("SAL_kernel")  							\
					__drv_declspec("SAL_nodriver")							\
					$GENSYM(__prefast_flag_kernel_driver_mode);

	// Indicate that the code is kernel, driver, code.
	#define __kernel_driver 												\
		typedef int __drv_declspec("SAL_kernel")   							\
					__drv_declspec("SAL_driver")  							\
					$GENSYM(__prefast_flag_kernel_driver_mode);

	// Indicate that the code is a user mode driver.
	#define __user_driver 													\
		typedef int __drv_declspec("SAL_nokernel")							\
					__drv_declspec("SAL_driver")   							\
					$GENSYM(__prefast_flag_kernel_driver_mode);

	// Indicate that the code is ordinary user mode code.
	#define __user_code 													\
		typedef int __drv_declspec("SAL_nokernel") 							\
					__drv_declspec("SAL_nodriver") 							\
					$GENSYM(__prefast_flag_kernel_driver_mode);

	// "landmark" function definition to pass information to the
	// analysis tools, as needed.

    __ANNOTATION(SAL_landmark(__in char *);)

    #define __drv_Mode_impl(x)												\
      __declspec("SAL_landmark(\"" #x "\")")								\
      __inline void $GENSYM(__SAL_dummy_)(void){}

    // Macros to declare a function to be a particular class
    // of driver.

	#define __drv_WDM __drv_Mode_impl(WDM)
	#define __drv_KMDF __drv_Mode_impl(KMDF)
	#define __drv_NDIS __drv_Mode_impl(NDIS)

    // Inform PREfast that operator new does [not] throw.
    // Be sure you really know which is actually in use before using one of
    // these.  The default is throwing (and cannot return NULL) which is
    // standard conformant, but much kernel code links with a non-throwing
    // operator new.
    //
    // Header <new> will set the default to throwing, so be sure to place
    // this after that header is included.
    //
    // Be sure to use these macros for this purpose as the implementation 
    // could change.

    #define __prefast_operator_new_throws                                 \
        void* __cdecl operator new(size_t size) throw(std::bad_alloc);    \
        void* __cdecl operator new[](size_t size) throw(std::bad_alloc);

    #define __prefast_operator_new_null                                   \
        void* __cdecl operator new(size_t size) throw();                  \
        void* __cdecl operator new[](size_t size) throw();


#else // ][

	#define __internal_kernel_driver
	#define __kernel_code 
	#define __kernel_driver
	#define __user_driver
	#define __user_code
	#define __drv_Mode_impl(x)
	#define __drv_WDM
	#define __drv_KMDF
	#define __drv_NDIS 
	#define __prefast_operator_new_throws
	#define __prefast_operator_new_null


#endif // ]

	// core macros: these provide syntatic wrappers to make other uses
	// simpler.
	// (Note: right now we can't safely use the ellipsis (...) macro
	// syntax.  If we could then '##__drv_nop(annotes)' below could be 
	// simply 'annotes', and we could code __$drv_group as __$drv_group(...) 
	// in the "expands to nothing" case.)
	//
	// For example:
	//	 __drv_in(__drv_nonconstant __setsIRQL)
	
	#define __drv_deref(annotes) __deref __$drv_group(##__drv_nop(annotes))
	#define __drv_in(annotes) __pre __$drv_group(##__drv_nop(annotes))
	#define __drv_in_deref(annotes) __pre __deref __$drv_group(##__drv_nop(annotes))
	#define __drv_out(annotes) __post __$drv_group(##__drv_nop(annotes))
	#define __drv_out_deref(annotes) __post __deref __$drv_group(##__drv_nop(annotes))
	#define __drv_when(cond, annotes)										\
	  __drv_declspec("SAL_when(" SPECSTRINGIZE(cond) ")") __$drv_group(##__drv_nop(annotes))
	#define __drv_at(expr,annotes)\
	  __drv_declspec("SAL_at(" SPECSTRINGIZE(expr) ")") __$drv_group(##__drv_nop(annotes))

	#define __drv_fun(annotes) __drv_at(return,##__drv_nop(annotes))
	#define __drv_ret(annotes) __drv_at(return,##__drv_nop(annotes))
	#define __drv_arg(expr,annotes) __drv_at(expr,##__drv_nop(annotes))
	#define __drv_unit(p)                                                   \
	  typedef int __$drv_unit_##p                                           \
                $GENSYM(__prefast_flag_kernel_driver_mode);

	// Internal macros for convenience
	#define __$drv_unit_internal_kernel_driver								\
		 __drv_declspec("SAL_internal_kernel_driver")

	//
	// __drv_unit
	//
	// Flags for compilation units that indicated specifically what kind of
	// code it is.
	// These should be coded as early as possible in any compilation unit
	// (.c/.cpp file) that doesn't get the correct default.	 Whether before
	// or after __internal_kernel_driver is immaterial as long as it will
	// successfully parse.
	//
	// Indicate that the code is kernel, but not driver, code.
	#define __$drv_unit_kernel_code											\
			__drv_declspec("SAL_kernel")  __drv_declspec("SAL_nodriver")

	// Indicate that the code is kernel, driver, code.
	#define __$drv_unit_kernel_driver										\
			__drv_declspec("SAL_kernel") __drv_declspec("SAL_driver")

	// Indicate that the code is a user mode driver.
	#define __$drv_unit_user_driver											\
			__drv_declspec("SAL_nokernel") __drv_declspec("SAL_driver")

	// Indicate that the code is ordinary user mode code.
	#define __$drv_unit_user_code											\
			__drv_declspec("SAL_nokernel")	__drv_declspec("SAL_nodriver")


	// These are needed for backwards compatability.
	#ifndef __internal_kernel_driver

	#define __internal_kernel_driver   __drv_unit(internal_kernel_driver)
	#define __kernel_code			   __drv_unit(kernel_code)
	#define __kernel_driver			   __drv_unit(kernel_driver)
	#define __user_driver			   __drv_unit(user_driver)
	#define __user_code				   __drv_unit(user_code)

	#endif

	// ---------------------------------------------------------------------
	// Syntatic utilities:
	// 
	// Needed to make the annotations convenient to use.
	//
	// So we can use a macro name that might be used in #ifdef context,
	// where it's defined with no value.  
	// This should only be used inside a __drv_when condition.
	//
	#define __drv_defined(x) macroDefined$( #x )

	// ---------------------------------------------------------------------
	// Callback properties:
	//
	// __drv_functionClass(x)
	//
	// Flag that the  the annotated function
	// is a member of that function class.	Some class names are recognized
	// by PREfast itself for special treatment.
	// This can be tested by the condition function inFunctionClass$()
	//
	__ANNOTATION(SAL_functionClass(__in char *);)
	#define __drv_functionClass(x)									     	\
		__drv_out(__drv_declspec("SAL_functionClass(\""#x"\")"))

	// ---------------------------------------------------------------------
	// Resources:
	// 
	// __drv_acquiresResource(kind)
	// __drv_releasesResource(kind)
	// __drv_acquiresResourceGlobal(kind,param)
	// __drv_releasesResourceGlobal(kind,param)
	// __drv_mustHold(kind)
	// __drv_neverHold(kind)
	// __drv_mustHoldGlobal(kind,param)
	// __drv_neverHoldGlobal(kind,param)
	//
	// Flag that the annotated parameter acquires a resource of type kind.
	//
	__ANNOTATION(SAL_acquire(__in char *);)
	#define __drv_acquiresResource(kind)									\
		__post __drv_declspec("SAL_acquire(\"" #kind "\")")

	//
	// Flag that the annotated parameter releases a resource of type kind.
	//
	__ANNOTATION(SAL_release(__in char *);)
	#define __drv_releasesResource(kind)									\
		__post __drv_declspec("SAL_release(\"" #kind "\")")

	//
	// Flag that the annotated object acquires a global (otherwise anonymous)
	// resource of type kind named by param.
	//
	__ANNOTATION(SAL_acquireGlobal(__in char *, ...);)
	#define __drv_innerAcquiresGlobal(kind, param)							\
		__post __drv_declspec("SAL_acquireGlobal(\"" #kind "\","			\
												 SPECSTRINGIZE(param\t)")")
	#define __drv_acquiresResourceGlobal(kind,param)						\
		__drv_innerAcquiresGlobal(kind, param)
	//
	// Flag that the annotated object acquires a global (otherwise anonymous)
	// resource of type kind named by param.
	//
	__ANNOTATION(SAL_releaseGlobal(__in char *, ...);)
	#define __drv_innerReleasesGlobal(kind, param)							\
		__post __drv_declspec("SAL_releaseGlobal(\"" #kind "\","			\
												 SPECSTRINGIZE(param\t)")")
	#define __drv_releasesResourceGlobal(kind, param)						\
		__drv_innerReleasesGlobal(kind, param)
											  
	//
	// Flag that the annotated parameter must hold a resource of type kind
	//
	__ANNOTATION(SAL_mustHold(__in char *);)
	#define __drv_mustHold(kind)											\
		__pre __drv_declspec("SAL_mustHold(\""#kind"\")")

	//
	// Flag that the annotated object must hold a global resource
	// of type kind named by param.
	//
	__ANNOTATION(SAL_mustHoldGlobal(__in char *, ...);)
	#define __drv_innerMustHoldGlobal(kind, param)							\
		__pre __drv_declspec("SAL_mustHoldGlobal(\"" #kind "\","			\
												 SPECSTRINGIZE(param\t)")")
	#define __drv_mustHoldGlobal(kind,param)								\
		__drv_innerMustHoldGlobal(kind, param)

	//
	// Flag that the annotated parameter must never hold a resource of type kind
	//
	__ANNOTATION(SAL_neverHold(__in char *);)
	#define __drv_neverHold(kind)											\
		__pre __drv_declspec("SAL_neverHold(\"" #kind "\")")

	//
	// Flag that the annotated object must never hold a global resource
	// of type kind named by param.
	//
	__ANNOTATION(SAL_neverHoldGlobal(__in char *, ...);)
	#define __drv_innerNeverHoldGlobal(kind, param)							\
		__pre __drv_declspec("SAL_neverHoldGlobal(\"" #kind "\","			\
												 SPECSTRINGIZE(param\t)")")
	#define __drv_neverHoldGlobal(kind,param)								\
		__drv_innerNeverHoldGlobal(kind, param)

	// Predicates to determine if a resource is held
	__PRIMOP(int, holdsResource$(__in __deferTypecheck char *,__in char *);)
	__PRIMOP(int, holdsResourceGlobal$(__in char *, ...);)

	// ---------------------------------------------------------------------
	// Maintenance of IRQL values
	//
	// __drv_setsIRQL(irql)
	// __drv_raisesIRQL(irql)
	// __drv_requiresIRQL(irql)
	// __drv_maxIRQL(irql)
	// __drv_minIRQL(irql)
	// __drv_savesIRQL
	// __drv_restoresIRQL
	// __drv_savesIRQLGlobal(kind,param)
	// __drv_restoresIRQLGlobal(kind,param)
	// __drv_minFunctionIRQL(irql)
	// __drv_maxFunctionIRQL(irql)
	// __drv_useCancelIRQL
	// __drv_sameIRQL

	// 
	// The funciton exits at IRQL irql
	//
	#define __drv_setsIRQL(irql)  /* see kernelspecs.h */

	// 
	// The funciton exits at IRQL irql, but this may only raise the irql.
	//
	#define __drv_raisesIRQL(irql)  /* see kernelspecs.h */

	// 
	// The called function must be entered at IRQL level
	//
	#define __drv_requiresIRQL(irql)  /* see kernelspecs.h */


	// 
	// The maximum IRQL at which the function may be called.
	//
	#define __drv_maxIRQL(irql)  /* see kernelspecs.h */

	// 
	// The minimum IRQL at which the function may be called.
	//
	#define __drv_minIRQL(irql)  /* see kernelspecs.h */

	// 
	// The current IRQL is saved in the annotated parameter
	//
	#define __drv_savesIRQL  /* see kernelspecs.h */

	// 
	// The current IRQL is saved in the (otherwise anonymous) global object
	// identified by kind and further refined by param.
	//
	#define __drv_savesIRQLGlobal(kind,param)  /* see kernelspecs.h */

	// 
	// The current IRQL is restored from the annotated parameter
	//
	#define __drv_restoresIRQL  /* see kernelspecs.h */

	// 
	// The current IRQL is restored from the (otherwise anonymous) global object
	// identified by kind and further refined by param.
	//
	#define __drv_restoresIRQLGlobal(kind,param)  /* see kernelspecs.h */

	// The minimum IRQL to which the function can lower itself.	 The IRQL
	// at entry is assumed to be that value unless overridden.
	#define __drv_minFunctionIRQL(irql)  /* see kernelspecs.h */

	// The maximum IRQL to which the function can raise itself.
	#define __drv_maxFunctionIRQL(irql)  /* see kernelspecs.h */

	// The function must exit with the same IRQL it was entered with.
	// (It may change it but it must restore it.)
	#define __drv_sameIRQL  /* see kernelspecs.h */

	// The annotated parameter contains the cancelIRQL, which will be restored
	// by the called function.

	#define __drv_useCancelIRQL  /* see kernelspecs.h */

	// ---------------------------------------------------------------------
	// Specific function behaviors

    // The annotated function clears the requirement that DoInitializeing
	// is cleared (or not).
	__ANNOTATION(SAL_clearDoInit(enum __SAL_YesNo);)
	#define __drv_clearDoInit(yesNo)										\
		__post __drv_declspec("SAL_clearDoInit(" SPECSTRINGIZE(yesNo) ")") 

	// This is (or is like) IoGetDmaAdapter: look for misuse of DMA pointers
	__ANNOTATION(SAL_IoGetDmaAdapter(void);)
	#define __drv_IoGetDmaAdapter										\
		__post __drv_declspec("SAL_IoGetDmaAdapter") 

	// ---------------------------------------------------------------------
	// Function and out parameter return values.
	//
	// __drv_valueIs(<list>)
	//
	// The function being annotated will return each of the specified values
	// during simulation.  The items in the list are <relational op><constant>,
	// e.g. ==0 or <0.
	// This is a ; separated list of values.  The internal parser will accept
	// a comma-separated list.  In the future __VA_ARGS__ could be used.
	// See the documentation for use of this.
	//

	__ANNOTATION(SAL_return(__in __AuToQuOtE char *);)
	#define __drv_valueIs(arglist)											\
			__post __drv_declspec("SAL_return("SPECSTRINGIZE(arglist)")")

	// ---------------------------------------------------------------------
	// Additional parameter checking.
	//
	// __drv_constant
	// __drv_nonConstant
	// __drv_strictTypeMatch(mode)
	// __drv_strictType(type,mode)
	//
	// The actual parameter must evaluate to a constant (not a const).
	//
	__ANNOTATION(SAL_constant(enum __SAL_YesNo);)
	#define __drv_constant __pre __drv_declspec("SAL_constant(__yes)")

	//
	// The actual parameter may never evaluate to a numeric constant 
	// (exclusive of a const symbol).
	//
	#define __drv_nonConstant __pre __drv_declspec("SAL_constant(__no)")

	//
	// The actual parameter must match the type of the annotated formal
	// within the specifications set by mode.
	//
	__ANNOTATION(SAL_strictTypeMatch(__int64);)
	#define __drv_strictTypeMatch(mode)										\
		__pre __drv_declspec("SAL_strictTypeMatch("SPECSTRINGIZE(mode)")")

	//
	// The actual parameter must match the type of typename (below) 
	// within the specifications set by mode.
	//
	__ANNOTATION(SAL_strictType(__in __AuToQuOtE char *);) // currently 1/2 args
	#define __drv_strictType(typename,mode)									\
		__pre __drv_declspec("SAL_strictType("SPECSTRINGIZE(typename)","\
											  SPECSTRINGIZE(mode)")")
	//
	//    The following modes are defined:
		#define __drv_typeConst   0    // constants of that type
		#define __drv_typeCond    1    // plus ?:
		#define __drv_typeBitset  2    // plus all operators
		#define __drv_typeExpr    3    // plus literal constants
	// 
	// The actual parameter must be data (not a pointer).  Used to
	// prevent passing pointers to pointers when pointers to structures
	// are needed (because &pXXX is a common error when pXXX is 
	// intended).
	__ANNOTATION(SAL_mayBePointer(enum __SAL_YesNo);)
	#define __drv_notPointer  __pre __drv_declspec("SAL_mayBePointer(__no)")
	//
	// Convenience for the most common form of the above.
	#define __drv_isObjectPointer __drv_deref(__drv_notPointer)

	// ---------------------------------------------------------------------
	// Memory management
	//
	// __drv_aliasesMem
	// __drv_allocatesMem
	// __drv_freesMem
	//
	// The annotated parameter is "kept" by the function, creating an
	// alias, and relieving any obligation to free the object.
	//
	__ANNOTATION(SAL_IsAliased(void);)
	#define __drv_aliasesMem __post __drv_declspec("SAL_IsAliased")

	//
	// Allocate/release memory-like objects.
	// Kind is unused, but should be "mem" for malloc/free
	// and "object" for new/delete.
	__ANNOTATION(SAL_NeedsRelease(enum __SAL_YesNo);)
	#define __drv_allocatesMem(kind) __post __drv_declspec("SAL_NeedsRelease(__yes)")

	#define __drv_freesMem(kind)	 __post __drv_declspec("SAL_NeedsRelease(__no)")

	// ---------------------------------------------------------------------
	// Additional diagnostics
	//
	// __drv_preferredFunction
	// __drv_reportError
	//
	//
	// Function 'func' should be used for reason 'why'.	 Often used
	// conditionally.
	//
	__ANNOTATION(SAL_preferredFunction(__in __AuToQuOtE char *, __in __AuToQuOtE char *);)
	#define __drv_preferredFunction(func,why)								\
		__pre __drv_declspec(												\
			"SAL_preferredFunction(" SPECSTRINGIZE(func) ","				\
											 SPECSTRINGIZE(why) ")")

	//
	// The error given by 'why' was detected.  Used conditionally.
	//
	__ANNOTATION(SAL_error(__in __AuToQuOtE char *);)
	#define __drv_reportError(why)											\
		__pre __drv_declspec("SAL_error(" SPECSTRINGIZE(why) ")")

	// ---------------------------------------------------------------------
	// Floating point save/restore:
	//
	// __drv_floatSaved
	// __drv_floatRestored
	// __drv_floatUsed
	//
	// The floating point hardware was saved (available to kernel)
	__ANNOTATION(SAL_floatSaved(void);)
	#define __drv_floatSaved __post __drv_declspec("SAL_floatSaved")

	//
	// The floating point hardware was restored (no longer available)
	__ANNOTATION(SAL_floatRestored(void);)
	#define __drv_floatRestored __post __drv_declspec("SAL_floatRestored")

	//
	// The function uses floating point.  Functions with floating point
	// in their type signature get this automatically.
	__ANNOTATION(SAL_floatUsed(void);)
	#define __drv_floatUsed __post __drv_declspec("SAL_floatUsed")

	// ---------------------------------------------------------------------
	// Usage:
	// 
	// __drv_interlocked
	// __drv_inTry
	// __drv_notInTry
	//
	// The parameter is used for interlocked instructions.
	__ANNOTATION(SAL_interlocked(void);)
	#define __drv_interlocked __pre __drv_declspec("SAL_interlocked")

	// The function must be called inside a try block
	__ANNOTATION(SAL_inTry(enum __SAL_YesNo);)
	#define __drv_inTry __pre __drv_declspec("SAL_inTry(__yes)")

	// The function must not be called inside a try block
	#define __drv_notInTry __pre __drv_declspec("SAL_inTry(__no)")

	// ---------------------------------------------------------------------
	// FormatString:
	//
	// kind can be "printf", "scanf", "strftime" or "FormatMessage".
	__ANNOTATION(SAL_IsFormatString(__in char *);)
	#define __drv_formatString(kind)\
		__drv_declspec("SAL_IsFormatString(\"" #kind "\")")
	
	// ---------------------------------------------------------------------
	// SDV support: see the SDV documentation for details

	// Identify dispatch callback types
	__ANNOTATION(SAL_dispatchType(__in __int64);)
	#define __drv_dispatchType(kindlist)\
		__pre __drv_declspec("SAL_dispatchType("\
							SPECSTRINGIZE(kindlist) ")" )

	// Identify dispatch callback types - special case
	#define __drv_dispatchType_other\
		__drv_dispatchType(-1)

	// Identify completion callback types
		__ANNOTATION(SAL_completionType(__in __AuToQuOtE char *);)
	#define __drv_completionType(kindlist)\
		__drv_declspec("SAL_completionType("\
							#kindlist ")" )

	__ANNOTATION(SAL_callbackType(__in __AuToQuOtE char *);)
	// Identify callback types (FDO or PDO)
	#define __drv_callbackType(kind)\
		__drv_declspec("SAL_callbackType("\
							#kind ")" )
	// ---------------------------------------------------------------------
	// Composite:

#ifdef _PREFAST_  // [ expand to nothing immediately to avoid RC problem
	//
	// Exclusive Resources
	#define __drv_acquiresExclusiveResource(kind)				\
		__$drv_group(											\
		__drv_neverHold(kind)									\
		__drv_acquiresResource(kind))

	#define __drv_releasesExclusiveResource(kind)				\
		__$drv_group(											\
		__drv_mustHold(kind)									\
		__drv_releasesResource(kind))

	#define __drv_acquiresExclusiveResourceGlobal(kind, param)	\
		__drv_neverHoldGlobal(kind, param)						\
		__drv_acquiresResourceGlobal(kind, param)

	#define __drv_releasesExclusiveResourceGlobal(kind, param)	\
		__drv_mustHoldGlobal(kind, param)						\
		__drv_releasesResourceGlobal(kind, param)

	//
	// CancelSpinLock
	#define __drv_acquiresCancelSpinLock						\
		__drv_innerNeverHoldGlobal(CancelSpinLock,)				\
		__drv_innerAcquiresGlobal(CancelSpinLock,)

	#define __drv_releasesCancelSpinLock						\
		__drv_innerMustHoldGlobal(CancelSpinLock,)				\
		__drv_innerReleasesGlobal(CancelSpinLock,)

	#define __drv_mustHoldCancelSpinLock						\
		__drv_innerMustHoldGlobal(CancelSpinLock,)

	#define __drv_neverHoldCancelSpinLock						\
		__drv_innerNeverHoldGlobal(CancelSpinLock,)

	#define __drv_holdsCancelSpinLock()							\
		holdsResourceGlobal$("CancelSpinLock",)

	//
	// CriticalRegion
	#define __drv_acquiresCriticalRegion						\
		__drv_innerNeverHoldGlobal(CriticalRegion,)				\
		__drv_innerAcquiresGlobal(CriticalRegion,)

	#define __drv_releasesCriticalRegion						\
		__drv_innerMustHoldGlobal(CriticalRegion,)				\
		__drv_innerReleasesGlobal(CriticalRegion,)

	#define __drv_mustHoldCriticalRegion						\
		__drv_innerMustHoldGlobal(CriticalRegion,)

	#define __drv_neverHoldCriticalRegion						\
		__drv_innerNeverHoldGlobal(CriticalRegion,)

	#define __drv_holdsCriticalRegion()							\
		holdsResourceGlobal$("CriticalRegion",)


    //
    // PriorityRegion
    #define __drv_acquiresPriorityRegion                        \
        __drv_innerNeverHoldGlobal(PriorityRegion,)             \
        __drv_innerAcquiresGlobal(PriorityRegion,)

    #define __drv_releasesPriorityRegion                        \
        __drv_innerMustHoldGlobal(PriorityRegion,)              \
        __drv_innerReleasesGlobal(PriorityRegion,)

    #define __drv_mustHoldPriorityRegion                        \
        __drv_innerMustHoldGlobal(PriorityRegion,)

    #define __drv_neverHoldPriorityRegion                       \
        __drv_innerNeverHoldGlobal(PriorityRegion,)

	#define __drv_holdsPriorityRegion()							\
		holdsResourceGlobal$("PriorityRegion",)

#else // ][

	#define __drv_acquiresExclusiveResource(kind)
	#define __drv_releasesExclusiveResource(kind)
	#define __drv_acquiresExclusiveResourceGlobal(kind, param)
	#define __drv_releasesExclusiveResourceGlobal(kind, param)
	#define __drv_acquiresCancelSpinLock
	#define __drv_releasesCancelSpinLock
	#define __drv_mustHoldCancelSpinLock
	#define __drv_holdsCancelSpinLock()
	#define __drv_neverHoldCancelSpinLock
	#define __drv_acquiresCriticalRegion
	#define __drv_releasesCriticalRegion
	#define __drv_mustHoldCriticalRegion
	#define __drv_neverHoldCriticalRegion
	#define __drv_holdsCriticalRegion()
	#define __drv_acquiresPriorityRegion
	#define __drv_releasesPriorityRegion
	#define __drv_mustHoldPriorityRegion
	#define __drv_neverHoldPriorityRegion
	#define __drv_holdsPriorityRegion()

#endif // ]

	// Passing the cancel Irql to a utility function
	#define __drv_isCancelIRQL  /* see kernelspecs.h */

    __PRIMOP(int, inFunctionClass$(__in char *);)

	// Check if this is kernel or driver code
	__PRIMOP(int, isKernel$(void);)
	__PRIMOP(int, isDriver$(void);)

#ifdef	__cplusplus
}
#endif

#endif // DRIVERSPECS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dpx1.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for dpx1.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dpx1_h__
#define __dpx1_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDpxJob_FWD_DEFINED__
#define __IDpxJob_FWD_DEFINED__
typedef interface IDpxJob IDpxJob;
#endif 	/* __IDpxJob_FWD_DEFINED__ */


#ifndef __IDpxContainer_FWD_DEFINED__
#define __IDpxContainer_FWD_DEFINED__
typedef interface IDpxContainer IDpxContainer;
#endif 	/* __IDpxContainer_FWD_DEFINED__ */


#ifndef __IDpxFile_FWD_DEFINED__
#define __IDpxFile_FWD_DEFINED__
typedef interface IDpxFile IDpxFile;
#endif 	/* __IDpxFile_FWD_DEFINED__ */


#ifndef __IDpxContainerDirectoryEntry_FWD_DEFINED__
#define __IDpxContainerDirectoryEntry_FWD_DEFINED__
typedef interface IDpxContainerDirectoryEntry IDpxContainerDirectoryEntry;
#endif 	/* __IDpxContainerDirectoryEntry_FWD_DEFINED__ */


#ifndef __IDpxDownloadProvider_FWD_DEFINED__
#define __IDpxDownloadProvider_FWD_DEFINED__
typedef interface IDpxDownloadProvider IDpxDownloadProvider;
#endif 	/* __IDpxDownloadProvider_FWD_DEFINED__ */


#ifndef __IDpxDownloadCallback_FWD_DEFINED__
#define __IDpxDownloadCallback_FWD_DEFINED__
typedef interface IDpxDownloadCallback IDpxDownloadCallback;
#endif 	/* __IDpxDownloadCallback_FWD_DEFINED__ */


#ifndef __IEnumDpxContainers_FWD_DEFINED__
#define __IEnumDpxContainers_FWD_DEFINED__
typedef interface IEnumDpxContainers IEnumDpxContainers;
#endif 	/* __IEnumDpxContainers_FWD_DEFINED__ */


#ifndef __IEnumDpxFiles_FWD_DEFINED__
#define __IEnumDpxFiles_FWD_DEFINED__
typedef interface IEnumDpxFiles IEnumDpxFiles;
#endif 	/* __IEnumDpxFiles_FWD_DEFINED__ */


#ifndef __IEnumDpxContainerDirectoryEntries_FWD_DEFINED__
#define __IEnumDpxContainerDirectoryEntries_FWD_DEFINED__
typedef interface IEnumDpxContainerDirectoryEntries IEnumDpxContainerDirectoryEntries;
#endif 	/* __IEnumDpxContainerDirectoryEntries_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_dpx1_0000_0000 */
/* [local] */ 

// Copyright (c) Microsoft Corporation.  All rights reserved.

#include <SpecStrings.h>
typedef unsigned int ALG_ID;










typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_dpx1_0000_0000_0001
    {	DPX_RESUME_AND_DOWNLOAD	= 0,
	DPX_RESUME_UNTIL_DOWNLOAD	= 0x1,
	DPX_RESUME_AND_DOWNLOAD_FALLBACK	= 0x2
    } 	DPX_RESUME_TYPE;

#define DPX_MAX_HASH_SIZE 64
typedef /* [public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_dpx1_0000_0000_0002
    {
    ALG_ID AlgorithmId;
    UINT HashSize;
    BYTE HashData[ 64 ];
    } 	DPX_HASH;

typedef /* [public][public][public][public][public] */ struct __MIDL___MIDL_itf_dpx1_0000_0000_0003
    {
    UINT64 Offset;
    UINT64 Length;
    } 	DPX_BYTE_RANGE;

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_dpx1_0000_0000_0004
    {	DPX_PHASE_JOB_IDLE	= 0,
	DPX_PHASE_DOWNLOAD_INDEX	= 0x10,
	DPX_PHASE_INVENTORY	= 0x20,
	DPX_PHASE_DOWNLOAD_FILES	= 0x30,
	DPX_PHASE_EXPAND_FILES	= 0x40,
	DPX_PHASE_JOB_INPROGRESS	= 0x50,
	DPX_PHASE_JOB_COMPLETE	= 0x7f00,
	DPX_PHASE_JOB_CANCELLED	= 0xfffe,
	DPX_PHASE_JOB_FAILURE	= 0xffff
    } 	DPX_PROGRESS_PHASE;

typedef /* [public][public][public][public][public][public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_dpx1_0000_0000_0005
    {
    UINT64 Completed;
    UINT64 Remaining;
    } 	DPX_PROGRESS_REMAIN;

typedef /* [public][public] */ struct __MIDL___MIDL_itf_dpx1_0000_0000_0006
    {
    DPX_PROGRESS_REMAIN Inventory;
    DPX_PROGRESS_REMAIN Download;
    DPX_PROGRESS_REMAIN Expansion;
    DPX_PROGRESS_REMAIN Files;
    DPX_PROGRESS_REMAIN Overall;
    DPX_PROGRESS_PHASE ePhase;
    } 	DPX_PROGRESS;



extern RPC_IF_HANDLE __MIDL_itf_dpx1_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dpx1_0000_0000_v0_0_s_ifspec;

#ifndef __IDpxJob_INTERFACE_DEFINED__
#define __IDpxJob_INTERFACE_DEFINED__

/* interface IDpxJob */
/* [nocode][unique][object][uuid] */ 


EXTERN_C const IID IID_IDpxJob;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ddc1b711-0e55-452f-838e-d1505b866e2b")
    IDpxJob : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTargetPath( 
            /* [out] */ __RPC__deref_out_opt LPWSTR *TargetPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddContainer( 
            /* [in] */ __RPC__in LPCWSTR ContainerPath,
            /* [out] */ __RPC__deref_out_opt IDpxContainer **ppContainer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumContainers( 
            /* [out] */ __RPC__deref_out_opt IEnumDpxContainers **ppEnumContainers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDownloadProvider( 
            /* [unique][in] */ __RPC__in_opt IDpxDownloadProvider *pDownloadProvider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDownloadProvider( 
            /* [out] */ __RPC__deref_out_opt IDpxDownloadProvider **ppDownloadProvider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( 
            DPX_RESUME_TYPE eResumeType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProgress( 
            /* [out] */ __RPC__out DPX_PROGRESS *pProgress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveJobState( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUserValue( 
            /* [in] */ UINT64 UserValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserValue( 
            /* [out] */ __RPC__out UINT64 *pUserValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOptionValue( 
            /* [in] */ __RPC__in LPCWSTR OptionName,
            /* [unique][in] */ __RPC__in_opt LPCWSTR OptionValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOptionValue( 
            /* [in] */ __RPC__in LPCWSTR OptionName,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pOptionValue) = 0;
        
        virtual /* [local] */ void STDMETHODCALLTYPE FreeMemory( 
            /* [in] */ void *Allocation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDpxJobVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDpxJob * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDpxJob * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDpxJob * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTargetPath )( 
            __RPC__in IDpxJob * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *TargetPath);
        
        HRESULT ( STDMETHODCALLTYPE *AddContainer )( 
            __RPC__in IDpxJob * This,
            /* [in] */ __RPC__in LPCWSTR ContainerPath,
            /* [out] */ __RPC__deref_out_opt IDpxContainer **ppContainer);
        
        HRESULT ( STDMETHODCALLTYPE *EnumContainers )( 
            __RPC__in IDpxJob * This,
            /* [out] */ __RPC__deref_out_opt IEnumDpxContainers **ppEnumContainers);
        
        HRESULT ( STDMETHODCALLTYPE *SetDownloadProvider )( 
            __RPC__in IDpxJob * This,
            /* [unique][in] */ __RPC__in_opt IDpxDownloadProvider *pDownloadProvider);
        
        HRESULT ( STDMETHODCALLTYPE *GetDownloadProvider )( 
            __RPC__in IDpxJob * This,
            /* [out] */ __RPC__deref_out_opt IDpxDownloadProvider **ppDownloadProvider);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            __RPC__in IDpxJob * This,
            DPX_RESUME_TYPE eResumeType);
        
        HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            __RPC__in IDpxJob * This);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            __RPC__in IDpxJob * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProgress )( 
            __RPC__in IDpxJob * This,
            /* [out] */ __RPC__out DPX_PROGRESS *pProgress);
        
        HRESULT ( STDMETHODCALLTYPE *SaveJobState )( 
            __RPC__in IDpxJob * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUserValue )( 
            __RPC__in IDpxJob * This,
            /* [in] */ UINT64 UserValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserValue )( 
            __RPC__in IDpxJob * This,
            /* [out] */ __RPC__out UINT64 *pUserValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetOptionValue )( 
            __RPC__in IDpxJob * This,
            /* [in] */ __RPC__in LPCWSTR OptionName,
            /* [unique][in] */ __RPC__in_opt LPCWSTR OptionValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetOptionValue )( 
            __RPC__in IDpxJob * This,
            /* [in] */ __RPC__in LPCWSTR OptionName,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pOptionValue);
        
        /* [local] */ void ( STDMETHODCALLTYPE *FreeMemory )( 
            IDpxJob * This,
            /* [in] */ void *Allocation);
        
        END_INTERFACE
    } IDpxJobVtbl;

    interface IDpxJob
    {
        CONST_VTBL struct IDpxJobVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDpxJob_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDpxJob_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDpxJob_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDpxJob_GetTargetPath(This,TargetPath)	\
    ( (This)->lpVtbl -> GetTargetPath(This,TargetPath) ) 

#define IDpxJob_AddContainer(This,ContainerPath,ppContainer)	\
    ( (This)->lpVtbl -> AddContainer(This,ContainerPath,ppContainer) ) 

#define IDpxJob_EnumContainers(This,ppEnumContainers)	\
    ( (This)->lpVtbl -> EnumContainers(This,ppEnumContainers) ) 

#define IDpxJob_SetDownloadProvider(This,pDownloadProvider)	\
    ( (This)->lpVtbl -> SetDownloadProvider(This,pDownloadProvider) ) 

#define IDpxJob_GetDownloadProvider(This,ppDownloadProvider)	\
    ( (This)->lpVtbl -> GetDownloadProvider(This,ppDownloadProvider) ) 

#define IDpxJob_Resume(This,eResumeType)	\
    ( (This)->lpVtbl -> Resume(This,eResumeType) ) 

#define IDpxJob_Suspend(This)	\
    ( (This)->lpVtbl -> Suspend(This) ) 

#define IDpxJob_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#define IDpxJob_GetProgress(This,pProgress)	\
    ( (This)->lpVtbl -> GetProgress(This,pProgress) ) 

#define IDpxJob_SaveJobState(This)	\
    ( (This)->lpVtbl -> SaveJobState(This) ) 

#define IDpxJob_SetUserValue(This,UserValue)	\
    ( (This)->lpVtbl -> SetUserValue(This,UserValue) ) 

#define IDpxJob_GetUserValue(This,pUserValue)	\
    ( (This)->lpVtbl -> GetUserValue(This,pUserValue) ) 

#define IDpxJob_SetOptionValue(This,OptionName,OptionValue)	\
    ( (This)->lpVtbl -> SetOptionValue(This,OptionName,OptionValue) ) 

#define IDpxJob_GetOptionValue(This,OptionName,pOptionValue)	\
    ( (This)->lpVtbl -> GetOptionValue(This,OptionName,pOptionValue) ) 

#define IDpxJob_FreeMemory(This,Allocation)	\
    ( (This)->lpVtbl -> FreeMemory(This,Allocation) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDpxJob_INTERFACE_DEFINED__ */


#ifndef __IDpxContainer_INTERFACE_DEFINED__
#define __IDpxContainer_INTERFACE_DEFINED__

/* interface IDpxContainer */
/* [nocode][unique][object][uuid] */ 


EXTERN_C const IID IID_IDpxContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ddc1b712-0e55-452f-838e-d1505b866e2b")
    IDpxContainer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetContainerPath( 
            /* [in] */ __RPC__in LPCWSTR ContainerPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContainerPath( 
            /* [out] */ __RPC__deref_out_opt LPWSTR *pContainerPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddFileToExtract( 
            /* [in] */ __RPC__in LPCWSTR SourceFileName,
            /* [unique][in] */ __RPC__in_opt LPCWSTR TargetFileName,
            /* [unique][in] */ __RPC__in_opt DPX_HASH *TargetFileHash) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddFileToExtract2( 
            /* [in] */ __RPC__in LPCWSTR SourceFileName,
            /* [unique][in] */ __RPC__in_opt LPCWSTR TargetFileName,
            /* [out] */ __RPC__deref_out_opt IDpxFile **ppFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExtractAllFiles( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumFilesToExtract( 
            /* [out] */ __RPC__deref_out_opt IEnumDpxFiles **ppEnumFiles) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExpectedContainerIndexHash( 
            /* [in] */ __RPC__in DPX_HASH *pExpectedHash) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExpectedContainerIndexHash( 
            /* [out] */ __RPC__deref_out_opt DPX_HASH **ppExpectedHash) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProvideContainerIndex( 
            /* [in] */ UINT IndexSize,
            /* [size_is][in] */ __RPC__in_ecount_full(IndexSize) BYTE IndexData[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProvideContainerIndexByFile( 
            /* [in] */ __RPC__in LPCWSTR IndexFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumDirectoryEntries( 
            /* [out] */ __RPC__deref_out_opt IEnumDpxContainerDirectoryEntries **ppEnumEntries) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUserValue( 
            /* [in] */ UINT64 UserValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserValue( 
            /* [out] */ __RPC__out UINT64 *pUserValue) = 0;
        
        virtual /* [local] */ void STDMETHODCALLTYPE FreeMemory( 
            /* [in] */ void *Allocation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDpxContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDpxContainer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDpxContainer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDpxContainer * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetContainerPath )( 
            __RPC__in IDpxContainer * This,
            /* [in] */ __RPC__in LPCWSTR ContainerPath);
        
        HRESULT ( STDMETHODCALLTYPE *GetContainerPath )( 
            __RPC__in IDpxContainer * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pContainerPath);
        
        HRESULT ( STDMETHODCALLTYPE *AddFileToExtract )( 
            __RPC__in IDpxContainer * This,
            /* [in] */ __RPC__in LPCWSTR SourceFileName,
            /* [unique][in] */ __RPC__in_opt LPCWSTR TargetFileName,
            /* [unique][in] */ __RPC__in_opt DPX_HASH *TargetFileHash);
        
        HRESULT ( STDMETHODCALLTYPE *AddFileToExtract2 )( 
            __RPC__in IDpxContainer * This,
            /* [in] */ __RPC__in LPCWSTR SourceFileName,
            /* [unique][in] */ __RPC__in_opt LPCWSTR TargetFileName,
            /* [out] */ __RPC__deref_out_opt IDpxFile **ppFile);
        
        HRESULT ( STDMETHODCALLTYPE *ExtractAllFiles )( 
            __RPC__in IDpxContainer * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumFilesToExtract )( 
            __RPC__in IDpxContainer * This,
            /* [out] */ __RPC__deref_out_opt IEnumDpxFiles **ppEnumFiles);
        
        HRESULT ( STDMETHODCALLTYPE *SetExpectedContainerIndexHash )( 
            __RPC__in IDpxContainer * This,
            /* [in] */ __RPC__in DPX_HASH *pExpectedHash);
        
        HRESULT ( STDMETHODCALLTYPE *GetExpectedContainerIndexHash )( 
            __RPC__in IDpxContainer * This,
            /* [out] */ __RPC__deref_out_opt DPX_HASH **ppExpectedHash);
        
        HRESULT ( STDMETHODCALLTYPE *ProvideContainerIndex )( 
            __RPC__in IDpxContainer * This,
            /* [in] */ UINT IndexSize,
            /* [size_is][in] */ __RPC__in_ecount_full(IndexSize) BYTE IndexData[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ProvideContainerIndexByFile )( 
            __RPC__in IDpxContainer * This,
            /* [in] */ __RPC__in LPCWSTR IndexFileName);
        
        HRESULT ( STDMETHODCALLTYPE *EnumDirectoryEntries )( 
            __RPC__in IDpxContainer * This,
            /* [out] */ __RPC__deref_out_opt IEnumDpxContainerDirectoryEntries **ppEnumEntries);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            __RPC__in IDpxContainer * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUserValue )( 
            __RPC__in IDpxContainer * This,
            /* [in] */ UINT64 UserValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserValue )( 
            __RPC__in IDpxContainer * This,
            /* [out] */ __RPC__out UINT64 *pUserValue);
        
        /* [local] */ void ( STDMETHODCALLTYPE *FreeMemory )( 
            IDpxContainer * This,
            /* [in] */ void *Allocation);
        
        END_INTERFACE
    } IDpxContainerVtbl;

    interface IDpxContainer
    {
        CONST_VTBL struct IDpxContainerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDpxContainer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDpxContainer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDpxContainer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDpxContainer_SetContainerPath(This,ContainerPath)	\
    ( (This)->lpVtbl -> SetContainerPath(This,ContainerPath) ) 

#define IDpxContainer_GetContainerPath(This,pContainerPath)	\
    ( (This)->lpVtbl -> GetContainerPath(This,pContainerPath) ) 

#define IDpxContainer_AddFileToExtract(This,SourceFileName,TargetFileName,TargetFileHash)	\
    ( (This)->lpVtbl -> AddFileToExtract(This,SourceFileName,TargetFileName,TargetFileHash) ) 

#define IDpxContainer_AddFileToExtract2(This,SourceFileName,TargetFileName,ppFile)	\
    ( (This)->lpVtbl -> AddFileToExtract2(This,SourceFileName,TargetFileName,ppFile) ) 

#define IDpxContainer_ExtractAllFiles(This)	\
    ( (This)->lpVtbl -> ExtractAllFiles(This) ) 

#define IDpxContainer_EnumFilesToExtract(This,ppEnumFiles)	\
    ( (This)->lpVtbl -> EnumFilesToExtract(This,ppEnumFiles) ) 

#define IDpxContainer_SetExpectedContainerIndexHash(This,pExpectedHash)	\
    ( (This)->lpVtbl -> SetExpectedContainerIndexHash(This,pExpectedHash) ) 

#define IDpxContainer_GetExpectedContainerIndexHash(This,ppExpectedHash)	\
    ( (This)->lpVtbl -> GetExpectedContainerIndexHash(This,ppExpectedHash) ) 

#define IDpxContainer_ProvideContainerIndex(This,IndexSize,IndexData)	\
    ( (This)->lpVtbl -> ProvideContainerIndex(This,IndexSize,IndexData) ) 

#define IDpxContainer_ProvideContainerIndexByFile(This,IndexFileName)	\
    ( (This)->lpVtbl -> ProvideContainerIndexByFile(This,IndexFileName) ) 

#define IDpxContainer_EnumDirectoryEntries(This,ppEnumEntries)	\
    ( (This)->lpVtbl -> EnumDirectoryEntries(This,ppEnumEntries) ) 

#define IDpxContainer_Remove(This)	\
    ( (This)->lpVtbl -> Remove(This) ) 

#define IDpxContainer_SetUserValue(This,UserValue)	\
    ( (This)->lpVtbl -> SetUserValue(This,UserValue) ) 

#define IDpxContainer_GetUserValue(This,pUserValue)	\
    ( (This)->lpVtbl -> GetUserValue(This,pUserValue) ) 

#define IDpxContainer_FreeMemory(This,Allocation)	\
    ( (This)->lpVtbl -> FreeMemory(This,Allocation) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDpxContainer_INTERFACE_DEFINED__ */


#ifndef __IDpxFile_INTERFACE_DEFINED__
#define __IDpxFile_INTERFACE_DEFINED__

/* interface IDpxFile */
/* [nocode][unique][object][uuid] */ 


EXTERN_C const IID IID_IDpxFile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ddc1b713-0e55-452f-838e-d1505b866e2b")
    IDpxFile : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSourceFileName( 
            /* [out] */ __RPC__deref_out_opt LPWSTR *pSourceFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTargetFileName( 
            /* [out] */ __RPC__deref_out_opt LPWSTR *pTargetFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExpectedHash( 
            /* [in] */ __RPC__in DPX_HASH *pExpectedHash) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExpectedHash( 
            /* [out] */ __RPC__deref_out_opt DPX_HASH **ppExpectedHash) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUserValue( 
            /* [in] */ UINT64 UserValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserValue( 
            /* [out] */ __RPC__out UINT64 *pUserValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ __RPC__out HRESULT *pStatus) = 0;
        
        virtual /* [local] */ void STDMETHODCALLTYPE FreeMemory( 
            /* [in] */ void *Allocation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDpxFileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDpxFile * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDpxFile * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDpxFile * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourceFileName )( 
            __RPC__in IDpxFile * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pSourceFileName);
        
        HRESULT ( STDMETHODCALLTYPE *GetTargetFileName )( 
            __RPC__in IDpxFile * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pTargetFileName);
        
        HRESULT ( STDMETHODCALLTYPE *SetExpectedHash )( 
            __RPC__in IDpxFile * This,
            /* [in] */ __RPC__in DPX_HASH *pExpectedHash);
        
        HRESULT ( STDMETHODCALLTYPE *GetExpectedHash )( 
            __RPC__in IDpxFile * This,
            /* [out] */ __RPC__deref_out_opt DPX_HASH **ppExpectedHash);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            __RPC__in IDpxFile * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUserValue )( 
            __RPC__in IDpxFile * This,
            /* [in] */ UINT64 UserValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserValue )( 
            __RPC__in IDpxFile * This,
            /* [out] */ __RPC__out UINT64 *pUserValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            __RPC__in IDpxFile * This,
            /* [out] */ __RPC__out HRESULT *pStatus);
        
        /* [local] */ void ( STDMETHODCALLTYPE *FreeMemory )( 
            IDpxFile * This,
            /* [in] */ void *Allocation);
        
        END_INTERFACE
    } IDpxFileVtbl;

    interface IDpxFile
    {
        CONST_VTBL struct IDpxFileVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDpxFile_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDpxFile_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDpxFile_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDpxFile_GetSourceFileName(This,pSourceFileName)	\
    ( (This)->lpVtbl -> GetSourceFileName(This,pSourceFileName) ) 

#define IDpxFile_GetTargetFileName(This,pTargetFileName)	\
    ( (This)->lpVtbl -> GetTargetFileName(This,pTargetFileName) ) 

#define IDpxFile_SetExpectedHash(This,pExpectedHash)	\
    ( (This)->lpVtbl -> SetExpectedHash(This,pExpectedHash) ) 

#define IDpxFile_GetExpectedHash(This,ppExpectedHash)	\
    ( (This)->lpVtbl -> GetExpectedHash(This,ppExpectedHash) ) 

#define IDpxFile_Remove(This)	\
    ( (This)->lpVtbl -> Remove(This) ) 

#define IDpxFile_SetUserValue(This,UserValue)	\
    ( (This)->lpVtbl -> SetUserValue(This,UserValue) ) 

#define IDpxFile_GetUserValue(This,pUserValue)	\
    ( (This)->lpVtbl -> GetUserValue(This,pUserValue) ) 

#define IDpxFile_GetStatus(This,pStatus)	\
    ( (This)->lpVtbl -> GetStatus(This,pStatus) ) 

#define IDpxFile_FreeMemory(This,Allocation)	\
    ( (This)->lpVtbl -> FreeMemory(This,Allocation) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDpxFile_INTERFACE_DEFINED__ */


#ifndef __IDpxContainerDirectoryEntry_INTERFACE_DEFINED__
#define __IDpxContainerDirectoryEntry_INTERFACE_DEFINED__

/* interface IDpxContainerDirectoryEntry */
/* [nocode][unique][object][uuid] */ 


EXTERN_C const IID IID_IDpxContainerDirectoryEntry;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ddc1b715-0e55-452f-838e-d1505b866e2b")
    IDpxContainerDirectoryEntry : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ __RPC__deref_out_opt LPWSTR *pDirEntryName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHash( 
            /* [out] */ __RPC__deref_out_opt DPX_HASH **pDirEntryHash) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ __RPC__out UINT64 *pDirEntrySize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTime( 
            /* [out] */ __RPC__out FILETIME *pDirEntryTime) = 0;
        
        virtual /* [local] */ void STDMETHODCALLTYPE FreeMemory( 
            /* [in] */ void *Allocation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDpxContainerDirectoryEntryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDpxContainerDirectoryEntry * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDpxContainerDirectoryEntry * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDpxContainerDirectoryEntry * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            __RPC__in IDpxContainerDirectoryEntry * This,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pDirEntryName);
        
        HRESULT ( STDMETHODCALLTYPE *GetHash )( 
            __RPC__in IDpxContainerDirectoryEntry * This,
            /* [out] */ __RPC__deref_out_opt DPX_HASH **pDirEntryHash);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            __RPC__in IDpxContainerDirectoryEntry * This,
            /* [out] */ __RPC__out UINT64 *pDirEntrySize);
        
        HRESULT ( STDMETHODCALLTYPE *GetTime )( 
            __RPC__in IDpxContainerDirectoryEntry * This,
            /* [out] */ __RPC__out FILETIME *pDirEntryTime);
        
        /* [local] */ void ( STDMETHODCALLTYPE *FreeMemory )( 
            IDpxContainerDirectoryEntry * This,
            /* [in] */ void *Allocation);
        
        END_INTERFACE
    } IDpxContainerDirectoryEntryVtbl;

    interface IDpxContainerDirectoryEntry
    {
        CONST_VTBL struct IDpxContainerDirectoryEntryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDpxContainerDirectoryEntry_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDpxContainerDirectoryEntry_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDpxContainerDirectoryEntry_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDpxContainerDirectoryEntry_GetName(This,pDirEntryName)	\
    ( (This)->lpVtbl -> GetName(This,pDirEntryName) ) 

#define IDpxContainerDirectoryEntry_GetHash(This,pDirEntryHash)	\
    ( (This)->lpVtbl -> GetHash(This,pDirEntryHash) ) 

#define IDpxContainerDirectoryEntry_GetSize(This,pDirEntrySize)	\
    ( (This)->lpVtbl -> GetSize(This,pDirEntrySize) ) 

#define IDpxContainerDirectoryEntry_GetTime(This,pDirEntryTime)	\
    ( (This)->lpVtbl -> GetTime(This,pDirEntryTime) ) 

#define IDpxContainerDirectoryEntry_FreeMemory(This,Allocation)	\
    ( (This)->lpVtbl -> FreeMemory(This,Allocation) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDpxContainerDirectoryEntry_INTERFACE_DEFINED__ */


#ifndef __IDpxDownloadProvider_INTERFACE_DEFINED__
#define __IDpxDownloadProvider_INTERFACE_DEFINED__

/* interface IDpxDownloadProvider */
/* [nocode][unique][object][uuid] */ 


EXTERN_C const IID IID_IDpxDownloadProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ddc1b716-0e55-452f-838e-d1505b866e2b")
    IDpxDownloadProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProvideDataCallback( 
            /* [in] */ __RPC__in_opt IDpxDownloadCallback *pProvideData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProvideDataCallback( 
            /* [out] */ __RPC__deref_out_opt IDpxDownloadCallback **ppProvideData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddContainer( 
            /* [in] */ __RPC__in LPCWSTR ContainerFilePath,
            /* [in] */ UINT64 ContainerId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRanges( 
            /* [in] */ UINT64 ContainerId,
            /* [in] */ UINT RangeCount,
            /* [size_is][in] */ __RPC__in_ecount_full(RangeCount) DPX_BYTE_RANGE RangeList[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContainers( 
            /* [out] */ __RPC__out UINT *ContainerCount,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*ContainerCount) UINT64 **ppContainerIdArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContainerPath( 
            /* [in] */ UINT64 ContainerId,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ContainerPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRanges( 
            /* [in] */ UINT64 ContainerId,
            /* [in] */ BOOL IncludeCompletedRanges,
            /* [out] */ __RPC__out UINT *RangeCount,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*RangeCount) DPX_BYTE_RANGE **ppRangeArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WaitForCompletion( 
            /* [in] */ DWORD TimeoutMilliseconds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProgress( 
            /* [out] */ __RPC__out DPX_PROGRESS_REMAIN *pDownloadProgress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearRequest( void) = 0;
        
        virtual /* [local] */ void STDMETHODCALLTYPE FreeMemory( 
            /* [in] */ void *Allocation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDpxDownloadProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDpxDownloadProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDpxDownloadProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDpxDownloadProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetProvideDataCallback )( 
            __RPC__in IDpxDownloadProvider * This,
            /* [in] */ __RPC__in_opt IDpxDownloadCallback *pProvideData);
        
        HRESULT ( STDMETHODCALLTYPE *GetProvideDataCallback )( 
            __RPC__in IDpxDownloadProvider * This,
            /* [out] */ __RPC__deref_out_opt IDpxDownloadCallback **ppProvideData);
        
        HRESULT ( STDMETHODCALLTYPE *AddContainer )( 
            __RPC__in IDpxDownloadProvider * This,
            /* [in] */ __RPC__in LPCWSTR ContainerFilePath,
            /* [in] */ UINT64 ContainerId);
        
        HRESULT ( STDMETHODCALLTYPE *AddRanges )( 
            __RPC__in IDpxDownloadProvider * This,
            /* [in] */ UINT64 ContainerId,
            /* [in] */ UINT RangeCount,
            /* [size_is][in] */ __RPC__in_ecount_full(RangeCount) DPX_BYTE_RANGE RangeList[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetContainers )( 
            __RPC__in IDpxDownloadProvider * This,
            /* [out] */ __RPC__out UINT *ContainerCount,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*ContainerCount) UINT64 **ppContainerIdArray);
        
        HRESULT ( STDMETHODCALLTYPE *GetContainerPath )( 
            __RPC__in IDpxDownloadProvider * This,
            /* [in] */ UINT64 ContainerId,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ContainerPath);
        
        HRESULT ( STDMETHODCALLTYPE *GetRanges )( 
            __RPC__in IDpxDownloadProvider * This,
            /* [in] */ UINT64 ContainerId,
            /* [in] */ BOOL IncludeCompletedRanges,
            /* [out] */ __RPC__out UINT *RangeCount,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*RangeCount) DPX_BYTE_RANGE **ppRangeArray);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            __RPC__in IDpxDownloadProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            __RPC__in IDpxDownloadProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            __RPC__in IDpxDownloadProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *WaitForCompletion )( 
            __RPC__in IDpxDownloadProvider * This,
            /* [in] */ DWORD TimeoutMilliseconds);
        
        HRESULT ( STDMETHODCALLTYPE *GetProgress )( 
            __RPC__in IDpxDownloadProvider * This,
            /* [out] */ __RPC__out DPX_PROGRESS_REMAIN *pDownloadProgress);
        
        HRESULT ( STDMETHODCALLTYPE *ClearRequest )( 
            __RPC__in IDpxDownloadProvider * This);
        
        /* [local] */ void ( STDMETHODCALLTYPE *FreeMemory )( 
            IDpxDownloadProvider * This,
            /* [in] */ void *Allocation);
        
        END_INTERFACE
    } IDpxDownloadProviderVtbl;

    interface IDpxDownloadProvider
    {
        CONST_VTBL struct IDpxDownloadProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDpxDownloadProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDpxDownloadProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDpxDownloadProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDpxDownloadProvider_SetProvideDataCallback(This,pProvideData)	\
    ( (This)->lpVtbl -> SetProvideDataCallback(This,pProvideData) ) 

#define IDpxDownloadProvider_GetProvideDataCallback(This,ppProvideData)	\
    ( (This)->lpVtbl -> GetProvideDataCallback(This,ppProvideData) ) 

#define IDpxDownloadProvider_AddContainer(This,ContainerFilePath,ContainerId)	\
    ( (This)->lpVtbl -> AddContainer(This,ContainerFilePath,ContainerId) ) 

#define IDpxDownloadProvider_AddRanges(This,ContainerId,RangeCount,RangeList)	\
    ( (This)->lpVtbl -> AddRanges(This,ContainerId,RangeCount,RangeList) ) 

#define IDpxDownloadProvider_GetContainers(This,ContainerCount,ppContainerIdArray)	\
    ( (This)->lpVtbl -> GetContainers(This,ContainerCount,ppContainerIdArray) ) 

#define IDpxDownloadProvider_GetContainerPath(This,ContainerId,ContainerPath)	\
    ( (This)->lpVtbl -> GetContainerPath(This,ContainerId,ContainerPath) ) 

#define IDpxDownloadProvider_GetRanges(This,ContainerId,IncludeCompletedRanges,RangeCount,ppRangeArray)	\
    ( (This)->lpVtbl -> GetRanges(This,ContainerId,IncludeCompletedRanges,RangeCount,ppRangeArray) ) 

#define IDpxDownloadProvider_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 

#define IDpxDownloadProvider_Suspend(This)	\
    ( (This)->lpVtbl -> Suspend(This) ) 

#define IDpxDownloadProvider_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#define IDpxDownloadProvider_WaitForCompletion(This,TimeoutMilliseconds)	\
    ( (This)->lpVtbl -> WaitForCompletion(This,TimeoutMilliseconds) ) 

#define IDpxDownloadProvider_GetProgress(This,pDownloadProgress)	\
    ( (This)->lpVtbl -> GetProgress(This,pDownloadProgress) ) 

#define IDpxDownloadProvider_ClearRequest(This)	\
    ( (This)->lpVtbl -> ClearRequest(This) ) 

#define IDpxDownloadProvider_FreeMemory(This,Allocation)	\
    ( (This)->lpVtbl -> FreeMemory(This,Allocation) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDpxDownloadProvider_INTERFACE_DEFINED__ */


#ifndef __IDpxDownloadCallback_INTERFACE_DEFINED__
#define __IDpxDownloadCallback_INTERFACE_DEFINED__

/* interface IDpxDownloadCallback */
/* [nocode][unique][object][uuid] */ 


EXTERN_C const IID IID_IDpxDownloadCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ddc1b717-0e55-452f-838e-d1505b866e2b")
    IDpxDownloadCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ProvideRequestedData( 
            /* [in] */ UINT64 ContainerId,
            /* [in] */ UINT RangeCount,
            /* [size_is][in] */ __RPC__in_ecount_full(RangeCount) DPX_BYTE_RANGE RangeList[  ],
            /* [size_is][in] */ __RPC__in_ecount_full(RangeCount) const BYTE *RangeData[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProvideRequestedDataByFile( 
            /* [in] */ UINT64 ContainerId,
            /* [in] */ __RPC__in LPCWSTR ResponseFilePath,
            /* [in] */ UINT RangeCount,
            /* [size_is][in] */ __RPC__in_ecount_full(RangeCount) DPX_BYTE_RANGE RangeArray[  ],
            /* [size_is][in] */ __RPC__in_ecount_full(RangeCount) UINT64 OffsetInResponseFile[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProvideRequestedDataByPackedRangeFile( 
            /* [in] */ UINT64 ContainerId,
            /* [in] */ __RPC__in LPCWSTR ResponseFilePath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDpxDownloadCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDpxDownloadCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDpxDownloadCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDpxDownloadCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ProvideRequestedData )( 
            __RPC__in IDpxDownloadCallback * This,
            /* [in] */ UINT64 ContainerId,
            /* [in] */ UINT RangeCount,
            /* [size_is][in] */ __RPC__in_ecount_full(RangeCount) DPX_BYTE_RANGE RangeList[  ],
            /* [size_is][in] */ __RPC__in_ecount_full(RangeCount) const BYTE *RangeData[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ProvideRequestedDataByFile )( 
            __RPC__in IDpxDownloadCallback * This,
            /* [in] */ UINT64 ContainerId,
            /* [in] */ __RPC__in LPCWSTR ResponseFilePath,
            /* [in] */ UINT RangeCount,
            /* [size_is][in] */ __RPC__in_ecount_full(RangeCount) DPX_BYTE_RANGE RangeArray[  ],
            /* [size_is][in] */ __RPC__in_ecount_full(RangeCount) UINT64 OffsetInResponseFile[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ProvideRequestedDataByPackedRangeFile )( 
            __RPC__in IDpxDownloadCallback * This,
            /* [in] */ UINT64 ContainerId,
            /* [in] */ __RPC__in LPCWSTR ResponseFilePath);
        
        END_INTERFACE
    } IDpxDownloadCallbackVtbl;

    interface IDpxDownloadCallback
    {
        CONST_VTBL struct IDpxDownloadCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDpxDownloadCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDpxDownloadCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDpxDownloadCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDpxDownloadCallback_ProvideRequestedData(This,ContainerId,RangeCount,RangeList,RangeData)	\
    ( (This)->lpVtbl -> ProvideRequestedData(This,ContainerId,RangeCount,RangeList,RangeData) ) 

#define IDpxDownloadCallback_ProvideRequestedDataByFile(This,ContainerId,ResponseFilePath,RangeCount,RangeArray,OffsetInResponseFile)	\
    ( (This)->lpVtbl -> ProvideRequestedDataByFile(This,ContainerId,ResponseFilePath,RangeCount,RangeArray,OffsetInResponseFile) ) 

#define IDpxDownloadCallback_ProvideRequestedDataByPackedRangeFile(This,ContainerId,ResponseFilePath)	\
    ( (This)->lpVtbl -> ProvideRequestedDataByPackedRangeFile(This,ContainerId,ResponseFilePath) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDpxDownloadCallback_INTERFACE_DEFINED__ */


#ifndef __IEnumDpxContainers_INTERFACE_DEFINED__
#define __IEnumDpxContainers_INTERFACE_DEFINED__

/* interface IEnumDpxContainers */
/* [nocode][unique][object][uuid] */ 


EXTERN_C const IID IID_IEnumDpxContainers;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ddc1b722-0e55-452f-838e-d1505b866e2b")
    IEnumDpxContainers : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ UINT ItemCount,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(ItemCount, *pFetchedCount) IDpxContainer **ppContainers,
            /* [out] */ __RPC__out UINT *pFetchedCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ UINT ItemCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumDpxContainers **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out UINT *pItemCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDpxContainersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumDpxContainers * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumDpxContainers * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumDpxContainers * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumDpxContainers * This,
            /* [in] */ UINT ItemCount,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(ItemCount, *pFetchedCount) IDpxContainer **ppContainers,
            /* [out] */ __RPC__out UINT *pFetchedCount);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumDpxContainers * This,
            /* [in] */ UINT ItemCount);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumDpxContainers * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumDpxContainers * This,
            /* [out] */ __RPC__deref_out_opt IEnumDpxContainers **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IEnumDpxContainers * This,
            /* [out] */ __RPC__out UINT *pItemCount);
        
        END_INTERFACE
    } IEnumDpxContainersVtbl;

    interface IEnumDpxContainers
    {
        CONST_VTBL struct IEnumDpxContainersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDpxContainers_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumDpxContainers_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumDpxContainers_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumDpxContainers_Next(This,ItemCount,ppContainers,pFetchedCount)	\
    ( (This)->lpVtbl -> Next(This,ItemCount,ppContainers,pFetchedCount) ) 

#define IEnumDpxContainers_Skip(This,ItemCount)	\
    ( (This)->lpVtbl -> Skip(This,ItemCount) ) 

#define IEnumDpxContainers_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumDpxContainers_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#define IEnumDpxContainers_GetCount(This,pItemCount)	\
    ( (This)->lpVtbl -> GetCount(This,pItemCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumDpxContainers_INTERFACE_DEFINED__ */


#ifndef __IEnumDpxFiles_INTERFACE_DEFINED__
#define __IEnumDpxFiles_INTERFACE_DEFINED__

/* interface IEnumDpxFiles */
/* [nocode][unique][object][uuid] */ 


EXTERN_C const IID IID_IEnumDpxFiles;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ddc1b723-0e55-452f-838e-d1505b866e2b")
    IEnumDpxFiles : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ UINT ItemCount,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(ItemCount, *pFetchedCount) IDpxFile **ppFiles,
            /* [out] */ __RPC__out UINT *pFetchedCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ UINT ItemCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumDpxFiles **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out UINT *pItemCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDpxFilesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumDpxFiles * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumDpxFiles * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumDpxFiles * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumDpxFiles * This,
            /* [in] */ UINT ItemCount,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(ItemCount, *pFetchedCount) IDpxFile **ppFiles,
            /* [out] */ __RPC__out UINT *pFetchedCount);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumDpxFiles * This,
            /* [in] */ UINT ItemCount);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumDpxFiles * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumDpxFiles * This,
            /* [out] */ __RPC__deref_out_opt IEnumDpxFiles **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IEnumDpxFiles * This,
            /* [out] */ __RPC__out UINT *pItemCount);
        
        END_INTERFACE
    } IEnumDpxFilesVtbl;

    interface IEnumDpxFiles
    {
        CONST_VTBL struct IEnumDpxFilesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDpxFiles_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumDpxFiles_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumDpxFiles_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumDpxFiles_Next(This,ItemCount,ppFiles,pFetchedCount)	\
    ( (This)->lpVtbl -> Next(This,ItemCount,ppFiles,pFetchedCount) ) 

#define IEnumDpxFiles_Skip(This,ItemCount)	\
    ( (This)->lpVtbl -> Skip(This,ItemCount) ) 

#define IEnumDpxFiles_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumDpxFiles_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#define IEnumDpxFiles_GetCount(This,pItemCount)	\
    ( (This)->lpVtbl -> GetCount(This,pItemCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumDpxFiles_INTERFACE_DEFINED__ */


#ifndef __IEnumDpxContainerDirectoryEntries_INTERFACE_DEFINED__
#define __IEnumDpxContainerDirectoryEntries_INTERFACE_DEFINED__

/* interface IEnumDpxContainerDirectoryEntries */
/* [nocode][unique][object][uuid] */ 


EXTERN_C const IID IID_IEnumDpxContainerDirectoryEntries;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ddc1b725-0e55-452f-838e-d1505b866e2b")
    IEnumDpxContainerDirectoryEntries : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ UINT ItemCount,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(ItemCount, *pFetchedCount) IDpxContainerDirectoryEntry **ppDirectoryEntries,
            /* [out] */ __RPC__out UINT *pFetchedCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ UINT ItemCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumDpxContainerDirectoryEntries **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out UINT *pItemCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDpxContainerDirectoryEntriesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumDpxContainerDirectoryEntries * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumDpxContainerDirectoryEntries * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumDpxContainerDirectoryEntries * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumDpxContainerDirectoryEntries * This,
            /* [in] */ UINT ItemCount,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(ItemCount, *pFetchedCount) IDpxContainerDirectoryEntry **ppDirectoryEntries,
            /* [out] */ __RPC__out UINT *pFetchedCount);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumDpxContainerDirectoryEntries * This,
            /* [in] */ UINT ItemCount);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumDpxContainerDirectoryEntries * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumDpxContainerDirectoryEntries * This,
            /* [out] */ __RPC__deref_out_opt IEnumDpxContainerDirectoryEntries **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IEnumDpxContainerDirectoryEntries * This,
            /* [out] */ __RPC__out UINT *pItemCount);
        
        END_INTERFACE
    } IEnumDpxContainerDirectoryEntriesVtbl;

    interface IEnumDpxContainerDirectoryEntries
    {
        CONST_VTBL struct IEnumDpxContainerDirectoryEntriesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDpxContainerDirectoryEntries_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumDpxContainerDirectoryEntries_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumDpxContainerDirectoryEntries_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumDpxContainerDirectoryEntries_Next(This,ItemCount,ppDirectoryEntries,pFetchedCount)	\
    ( (This)->lpVtbl -> Next(This,ItemCount,ppDirectoryEntries,pFetchedCount) ) 

#define IEnumDpxContainerDirectoryEntries_Skip(This,ItemCount)	\
    ( (This)->lpVtbl -> Skip(This,ItemCount) ) 

#define IEnumDpxContainerDirectoryEntries_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumDpxContainerDirectoryEntries_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#define IEnumDpxContainerDirectoryEntries_GetCount(This,pItemCount)	\
    ( (This)->lpVtbl -> GetCount(This,pItemCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumDpxContainerDirectoryEntries_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\drt.h ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// File:     drt.h
//
// Contents: Win32 APIs and structures for the Microsoft Distributed Routing Table. 
//
// Questions or feedback:
//
// Email:     peerfb@microsoft.com
// Website:   http://www.microsoft.com/p2p
// Newsgroup: microsoft.public.win32.programmer.networks
//
//----------------------------------------------------------------------------

#ifndef _DRT_H_
#define _DRT_H_

#ifndef MIDL_PASS
#include <specstrings.h>
#include <winsock2.h>
#include <ws2tcpip.h>  // for sockaddrin_6
#include <wincrypt.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

//////////////////////////////////////////////////////////////////////////////
// Constants

typedef PVOID HDRT;
typedef PVOID HDRT_SEARCH_CONTEXT;
typedef PVOID HDRT_TRANSPORT;
typedef PVOID HDRT_REGISTRATION_CONTEXT;

#define FACILITY_DRT      98
#define DRT_E_TIMEOUT                             MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x1001)
#define DRT_E_INVALID_KEY_SIZE                    MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x1002)
#define DRT_E_INVALID_CERT_CHAIN                  MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x1004)
#define DRT_E_INVALID_MESSAGE                     MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x1005)
#define DRT_E_NO_MORE                             MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x1006)
#define DRT_E_INVALID_MAX_ADDRESSES               MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x1007)
#define DRT_E_SEARCH_IN_PROGRESS                  MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x1008)
#define DRT_E_INVALID_KEY                         MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x1009)

#define DRT_S_RETRY                               MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_DRT, 0x1010)
#define DRT_E_INVALID_MAX_ENDPOINTS               MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x1011)
#define DRT_E_INVALID_SEARCH_RANGE                MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x1012)

#define DRT_E_INVALID_PORT                        MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x2000)
#define DRT_E_INVALID_TRANSPORT_PROVIDER          MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x2001)
#define DRT_E_INVALID_SECURITY_PROVIDER           MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x2002)
#define DRT_E_STILL_IN_USE                        MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x2003)
#define DRT_E_INVALID_BOOTSTRAP_PROVIDER          MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x2004)
#define DRT_E_INVALID_ADDRESS                     MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x2005)
#define DRT_E_INVALID_SCOPE                       MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x2006)
#define DRT_E_TRANSPORT_SHUTTING_DOWN             MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x2007)
#define DRT_E_NO_ADDRESSES_AVAILABLE              MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x2008)
#define DRT_E_DUPLICATE_KEY                       MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x2009)
#define DRT_E_TRANSPORTPROVIDER_IN_USE            MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x200a)
#define DRT_E_TRANSPORTPROVIDER_NOT_ATTACHED      MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x200b)
#define DRT_E_SECURITYPROVIDER_IN_USE             MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x200c)
#define DRT_E_SECURITYPROVIDER_NOT_ATTACHED       MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x200d)
#define DRT_E_BOOTSTRAPPROVIDER_IN_USE            MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x200e)
#define DRT_E_BOOTSTRAPPROVIDER_NOT_ATTACHED      MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x200f)

#define DRT_E_TRANSPORT_ALREADY_BOUND             MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x2101)
#define DRT_E_TRANSPORT_NOT_BOUND                 MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x2102)
#define DRT_E_TRANSPORT_UNEXPECTED                MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x2103)
#define DRT_E_TRANSPORT_INVALID_ARGUMENT          MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x2104)
#define DRT_E_TRANSPORT_NO_DEST_ADDRESSES         MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x2105)
#define DRT_E_TRANSPORT_EXECUTING_CALLBACK        MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x2106)
#define DRT_E_TRANSPORT_ALREADY_EXISTS_FOR_SCOPE  MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x2107)
#define DRT_E_INVALID_SETTINGS                    MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x2108)
#define DRT_E_INVALID_SEARCH_INFO                 MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x2109)
#define DRT_E_FAULTED                             MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x210a)
#define DRT_E_TRANSPORT_STILL_BOUND               MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x210b)
#define DRT_E_INSUFFICIENT_BUFFER                 MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x210c)
#define DRT_E_INVALID_INSTANCE_PREFIX             MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x210d)
#define DRT_E_INVALID_SECURITY_MODE               MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x210e)
#define DRT_E_CAPABILITY_MISMATCH                 MAKE_HRESULT(SEVERITY_ERROR,   FACILITY_DRT, 0x210f)



#define DRT_PAYLOAD_REVOKED     (1<<0)
#define DRT_MIN_ROUTING_ADDRESSES 1
#define DRT_MAX_ROUTING_ADDRESSES 20
#define DRT_MAX_PAYLOAD_SIZE 5120
#define DRT_MAX_INSTANCE_PREFIX_LEN  128

#define DRT_LINK_LOCAL_ISATAP_SCOPEID 0xffffffff


//////////////////////////////////////////////////////////////////////////////
// Enums

typedef enum drt_scope_tag
{
    DRT_GLOBAL_SCOPE     = 1,
    DRT_SITE_LOCAL_SCOPE = 2,
    DRT_LINK_LOCAL_SCOPE = 3,
} DRT_SCOPE;

typedef enum drt_status_tag
{
    DRT_ACTIVE        = 0,
    DRT_ALONE         = 1,
    DRT_NO_NETWORK    = 10,
    DRT_FAULTED       = 20,
} DRT_STATUS;

typedef enum drt_match_type_tag
{
    DRT_MATCH_EXACT        = 0,
    DRT_MATCH_NEAR         = 1,
    DRT_MATCH_INTERMEDIATE = 2,
} DRT_MATCH_TYPE;

typedef enum drt_leafset_key_change_type_tag
{
    DRT_LEAFSET_KEY_ADDED    = 0,
    DRT_LEAFSET_KEY_DELETED  = 1,
} DRT_LEAFSET_KEY_CHANGE_TYPE;

typedef enum drt_event_type_tag
{
    DRT_EVENT_STATUS_CHANGED      = 0,
    DRT_EVENT_LEAFSET_KEY_CHANGED = 1,
    DRT_EVENT_REGISTRATION_STATE_CHANGED = 2,
} DRT_EVENT_TYPE;

typedef enum drt_security_mode_tag
{
    DRT_SECURE_RESOLVE = 0,
    DRT_SECURE_MEMBERSHIP = 1,
    DRT_SECURE_CONFIDENTIALPAYLOAD = 2,
} DRT_SECURITY_MODE;

typedef enum _DRT_REGISTRATION_STATE
{
    DRT_REGISTRATION_STATE_UNRESOLVEABLE = 1

} DRT_REGISTRATION_STATE, *PDRT_REGISTRATION_STATE;

typedef enum _DRT_ADDRESS_FLAGS
{
    DRT_ADDRESS_FLAG_ACCEPTED                   = 0x01,
    DRT_ADDRESS_FLAG_REJECTED                   = 0x02,
    DRT_ADDRESS_FLAG_UNREACHABLE                = 0x04,
    DRT_ADDRESS_FLAG_LOOP                       = 0x08,
    DRT_ADDRESS_FLAG_TOO_BUSY                   = 0x10,
    DRT_ADDRESS_FLAG_BAD_VALIDATE_ID            = 0x20,
    DRT_ADDRESS_FLAG_SUSPECT_UNREGISTERED_ID    = 0x40,
    DRT_ADDRESS_FLAG_INQUIRE                    = 0x80

} DRT_ADDRESS_FLAGS, *PDRT_ADDRESS_FLAGS;

//////////////////////////////////////////////////////////////////////////////
// Structures

typedef struct drt_data_tag
{
    ULONG cb;
    BYTE* pb;
} DRT_DATA, *PDRT_DATA;
typedef const DRT_DATA *PCDRT_DATA;

typedef struct drt_registration_tag
{
    DRT_DATA key;
    DRT_DATA appData;
} DRT_REGISTRATION, *PDRT_REGISTRATION;
typedef const DRT_REGISTRATION *PCDRT_REGISTRATION;

typedef struct drt_security_provider_tag
{
    PVOID pvContext;

    HRESULT (*Attach)(
        __in        const PVOID pvContext);

    VOID    (*Detach)(
        __in        const PVOID pvContext);

    HRESULT (*RegisterKey)(
        __in        const PVOID pvContext,
        __in        const DRT_REGISTRATION* pRegistration,
        __in_opt    PVOID pvKeyContext);

    HRESULT (*UnregisterKey)(
        __in        const PVOID pvContext,
        __in        const DRT_DATA* pKey,
        __in_opt    PVOID pvKeyContext);

    HRESULT (*ValidateAndUnpackPayload)(
        __in        const PVOID pvContext,
        __in        DRT_DATA* pSecuredAddressPayload,
        __in_opt    DRT_DATA* pCertChain,
        __in_opt    DRT_DATA* pClassifier,
        __in_opt    DRT_DATA* pNonce,
        __in_opt    DRT_DATA* pSecuredPayload,

        __out       BYTE* pbProtocolMajor,
        __out       BYTE* pbProtocolMinor,
        __out       DRT_DATA* pKey,
        __out_opt   DRT_DATA* pPayload,
        __out       CERT_PUBLIC_KEY_INFO** ppPublicKey,
        __out_opt   SOCKET_ADDRESS_LIST** ppAddressList,
        __out       DWORD* pdwFlags);

    HRESULT (*SecureAndPackPayload)(
        __in        const PVOID pvContext,
        __in_opt    PVOID pvKeyContext,
                    BYTE bProtocolMajor,
                    BYTE bProtocolMinor,
                    DWORD dwFlags,
        __in        const DRT_DATA* pKey,
        __in_opt    const DRT_DATA* pPayload,
        __in_opt    const SOCKET_ADDRESS_LIST* pAddressList,
        __in        const DRT_DATA* pNonce,

        __out       DRT_DATA* pSecuredAddressPayload,
        __out_opt   DRT_DATA* pClassifier,
        __out_opt   DRT_DATA* pSecuredPayload,
        __out_opt   DRT_DATA* pCertChain);

    void (*FreeData)(
        __in        const PVOID pvContext,
        __in_opt    PVOID pv);


    HRESULT (*EncryptData)(
        __in                                    const PVOID pvContext,
        __in                                    const DRT_DATA* pRemoteCredential,
        __in                                    DWORD dwBuffers,
        __in_ecount(dwBuffers)      DRT_DATA* pDataBuffers,
        __out_ecount(dwBuffers)     DRT_DATA* pEncryptedBuffers,
        __out                                   DRT_DATA *pKeyToken
        );
        
    HRESULT (*DecryptData)(
        __in                                    const PVOID pvContext,
        __in                                    DRT_DATA* pKeyToken,
        __in                                    const PVOID pvKeyContext,
        __in                                    DWORD dwBuffers,
        __inout_ecount(dwBuffers) DRT_DATA* pData
        );

    HRESULT (*GetSerializedCredential)(
        __in                             const PVOID pvContext,
        __out                           DRT_DATA *pSelfCredential);

    HRESULT (*ValidateRemoteCredential)(
        __in                                const PVOID pvContext,
        __in                                DRT_DATA *pRemoteCredential);

    HRESULT (*SignData)(
        __in                                const PVOID pvContext,
        __in                                DWORD dwBuffers,
        __in_ecount(dwBuffers) DRT_DATA* pDataBuffers,
        __out                               DRT_DATA *pKeyIdentifier,
        __out                               DRT_DATA *pSignature);

    HRESULT (*VerifyData)(
        __in                                const PVOID pvContext,
        __in                                DWORD dwBuffers,
        __in_ecount(dwBuffers) DRT_DATA* pDataBuffers,
        __in                                DRT_DATA *pRemoteCredentials,
        __in                                DRT_DATA *pKeyIdentifier,
        __in                                DRT_DATA *pSignature);

} DRT_SECURITY_PROVIDER, *PDRT_SECURITY_PROVIDER;
typedef const DRT_SECURITY_PROVIDER *PCDRT_SECURITY_PROVIDER;

typedef PVOID   DRT_BOOTSTRAP_RESOLVE_CONTEXT;

typedef void (CALLBACK* DRT_BOOTSTRAP_RESOLVE_CALLBACK)(HRESULT hr, PVOID pvContext, SOCKET_ADDRESS_LIST* pAddresses, BOOL fFatalError);

typedef struct drt_bootstrap_provider_tag
{
    PVOID pvContext;

    HRESULT (*Attach)(
        __in        const PVOID pvContext);

    VOID (*Detach)(
        __in        const PVOID pvContext);

    HRESULT (*InitResolve)(
        __in        const PVOID pvContext,
        __in        BOOL fSplitDetect,
        __in        ULONG timeout,
        __in        ULONG cMaxResults,
        __out       DRT_BOOTSTRAP_RESOLVE_CONTEXT* ResolveContext,
        __out       BOOL* fFatalError
                    );
    HRESULT (*IssueResolve)(
        __in        const PVOID pvContext,
        __in        const PVOID pvCallbackContext,
        __in        DRT_BOOTSTRAP_RESOLVE_CALLBACK callback,
        __in        DRT_BOOTSTRAP_RESOLVE_CONTEXT  ResolveContext,
        __out       BOOL* fFatalError
        );

    VOID (*EndResolve)(
        __in        const PVOID pvContext,
        __in        DRT_BOOTSTRAP_RESOLVE_CONTEXT  ResolveContext
        );

    HRESULT (*Register)(
        __in        const PVOID pvContext,
        __in        const SOCKET_ADDRESS_LIST* pAddressList);

    VOID (*Unregister)(
        __in        const PVOID pvContext
        );

} DRT_BOOTSTRAP_PROVIDER, *PDRT_BOOTSTRAP_PROVIDER;
typedef const DRT_BOOTSTRAP_PROVIDER *PCDRT_BOOTSTRAP_PROVIDER;

typedef struct drt_settings_tag
{
    DWORD dwSize;
    ULONG cbKey;

    BYTE  bProtocolMajorVersion;
    BYTE  bProtocolMinorVersion;

    ULONG ulMaxRoutingAddresses;
    PWSTR pwzDrtInstancePrefix;
    HDRT_TRANSPORT hTransport;
    
    DRT_SECURITY_PROVIDER* pSecurityProvider;
    DRT_BOOTSTRAP_PROVIDER* pBootstrapProvider;
    DRT_SECURITY_MODE eSecurityMode;

} DRT_SETTINGS, *PDRT_SETTINGS;

typedef const DRT_SETTINGS *PCDRT_SETTINGS;

typedef struct drt_search_info_tag
{
    DWORD dwSize;
    BOOL fIterative;
    BOOL fAllowCurrentInstanceMatch;
    BOOL fAnyMatchInRange;
    ULONG cMaxEndpoints;
    DRT_DATA* pMaximumKey;
    DRT_DATA* pMinimumKey;

} DRT_SEARCH_INFO, *PDRT_SEARCH_INFO;
typedef const DRT_SEARCH_INFO *PCDRT_SEARCH_INFO;

typedef struct _DRT_ADDRESS
{
    SOCKADDR_STORAGE    socketAddress;
    ULONG               flags;
    LONG                nearness;
    ULONG               latency;

} DRT_ADDRESS, *PDRT_ADDRESS;

typedef struct _DRT_ADDRESS_LIST {

    ULONG                                       AddressCount;
    __field_ecount(AddressCount) DRT_ADDRESS    AddressList[1];

} DRT_ADDRESS_LIST, *PDRT_ADDRESS_LIST;
typedef const DRT_ADDRESS_LIST *PCDRT_ADDRESS_LIST;

typedef struct drt_search_result_tag
{
    DWORD dwSize;
    DRT_MATCH_TYPE type;
    PVOID pvContext;
    DRT_REGISTRATION registration;

} DRT_SEARCH_RESULT, *PDRT_SEARCH_RESULT;
typedef const DRT_SEARCH_RESULT *PCDRT_SEARCH_RESULT;

typedef struct drt_event_data_tag
{
    DRT_EVENT_TYPE type;
    HRESULT hr;
    PVOID pvContext;

    union
    {
        struct
        {
            DRT_LEAFSET_KEY_CHANGE_TYPE change;
            DRT_DATA localKey;
            DRT_DATA remoteKey;
        } leafsetKeyChange;

        struct
        {
            DRT_REGISTRATION_STATE  state;
            DRT_DATA localKey;
        } registrationStateChange;

        struct
        {
            DRT_STATUS status;
            struct
            {
                ULONG                   cntAddress;
                PSOCKADDR_STORAGE       pAddresses;
            } bootstrapAddresses;
        } statusChange;
    };
} DRT_EVENT_DATA, *PDRT_EVENT_DATA;
typedef const DRT_EVENT_DATA *PCDRT_EVENT_DATA;


//////////////////////////////////////////////////////////////////////////////
// DRT Default Module Management APIs

HRESULT WINAPI DrtCreatePnrpBootstrapResolver(
    __in        BOOL   fPublish,
    __in        PCWSTR pwzPeerName,
    __in_opt    PCWSTR pwzCloudName,
    __in_opt    PCWSTR pwzPublishingIdentity,
    __out       DRT_BOOTSTRAP_PROVIDER** ppResolver);

void WINAPI DrtDeletePnrpBootstrapResolver(
    __in        DRT_BOOTSTRAP_PROVIDER* pResolver);

HRESULT WINAPI DrtCreateDnsBootstrapResolver(
    __in USHORT port,
    __in PCWSTR pwszAddress,
    __out DRT_BOOTSTRAP_PROVIDER** ppModule
    );

void WINAPI DrtDeleteDnsBootstrapResolver(
    __in DRT_BOOTSTRAP_PROVIDER* pResolver
    );

HRESULT WINAPI DrtCreateIpv6UdpTransport(
                DRT_SCOPE scope,
                ULONG dwScopeId,
                ULONG dwLocalityThreshold,
    __inout     USHORT *pwPort,
    __out       HDRT_TRANSPORT *phTransport);

HRESULT WINAPI DrtDeleteIpv6UdpTransport(
    __in        HDRT_TRANSPORT hTransport);

HRESULT WINAPI DrtCreateDerivedKeySecurityProvider(
    __in        PCCERT_CONTEXT pRootCert,
    __in_opt    PCCERT_CONTEXT pLocalCert,
    __out       DRT_SECURITY_PROVIDER** ppSecurityProvider);

HRESULT WINAPI DrtCreateDerivedKey(
    __in        PCCERT_CONTEXT pLocalCert,
    __out       DRT_DATA* pKey);

void WINAPI DrtDeleteDerivedKeySecurityProvider(
    __in        DRT_SECURITY_PROVIDER* pSecurityProvider);

HRESULT WINAPI DrtCreateNullSecurityProvider(
    __out DRT_SECURITY_PROVIDER** ppSecurityProvider);

void WINAPI DrtDeleteNullSecurityProvider(
    __in DRT_SECURITY_PROVIDER* pSecurityProvider);

//////////////////////////////////////////////////////////////////////////////
// DRT Lifetime Management APIs

HRESULT WINAPI DrtOpen(
    __in        const DRT_SETTINGS* pSettings,
    __in_opt    HANDLE hEvent,
    __in_opt    const PVOID pvContext,
    __out       HDRT *phDrt);

VOID WINAPI DrtClose(
    __in        HDRT hDrt);

HRESULT WINAPI DrtGetEventDataSize(
    __in        HDRT hDrt,
    __out       ULONG          *pulEventDataLen);
    
HRESULT WINAPI DrtGetEventData(
    __in        HDRT hDrt,
    __in        ULONG          ulEventDataLen,
    __out_bcount_full(ulEventDataLen) DRT_EVENT_DATA *pEventData);

//////////////////////////////////////////////////////////////////////////////
// DRT Key Registration APIs

HRESULT WINAPI DrtRegisterKey(
    __in        HDRT hDrt,
    __in        DRT_REGISTRATION *pRegistration,
    __in_opt    PVOID pvKeyContext,
    __out       HDRT_REGISTRATION_CONTEXT *phKeyRegistration);

HRESULT WINAPI DrtUpdateKey(
    __in        HDRT_REGISTRATION_CONTEXT hKeyRegistration,
    __in        DRT_DATA *pAppData
    );

VOID WINAPI DrtUnregisterKey(
    __in        HDRT_REGISTRATION_CONTEXT hKeyRegistration);

//////////////////////////////////////////////////////////////////////////////
// DRT Search APIs

HRESULT WINAPI DrtStartSearch(
    __in        HDRT hDrt,
    __in        DRT_DATA *pKey,
    __in_opt    const DRT_SEARCH_INFO *pInfo,
                ULONG timeout,
    __in        HANDLE hEvent,
    __in_opt    const PVOID pvContext,
    __out       HDRT_SEARCH_CONTEXT* hSearchContext);

HRESULT WINAPI DrtContinueSearch(
    __in        HDRT_SEARCH_CONTEXT hSearchContext);

HRESULT WINAPI DrtGetSearchResultSize(
    __in        HDRT_SEARCH_CONTEXT hSearchContext,
    __out       ULONG               *pulSearchResultSize);

HRESULT WINAPI DrtGetSearchResult(
    __in        HDRT_SEARCH_CONTEXT hSearchContext,
    __inout     ULONG               ulSearchResultSize, 
    __out_bcount_full(ulSearchResultSize) DRT_SEARCH_RESULT   *pSearchResult);

HRESULT WINAPI DrtGetSearchPathSize(
    __in        HDRT_SEARCH_CONTEXT hSearchContext,
    __out       ULONG               *pulSearchPathSize);

HRESULT WINAPI DrtGetSearchPath(
    __in        HDRT_SEARCH_CONTEXT hSearchContext,
    __inout     ULONG               ulSearchPathSize, 
    __out_bcount_full(ulSearchPathSize) DRT_ADDRESS_LIST   *pSearchPath);

HRESULT WINAPI DrtEndSearch(
    __in        HDRT_SEARCH_CONTEXT hSearchContext);

//////////////////////////////////////////////////////////////////////////////
// DRT Instance name related APIs

HRESULT WINAPI DrtGetInstanceName(
    __in        HDRT    hDrt,
    __in        ULONG   ulcbInstanceNameSize,
    __out_bcount_full(ulcbInstanceNameSize) PWSTR  pwzDrtInstanceName);

HRESULT WINAPI DrtGetInstanceNameSize(
    __in        HDRT    hDrt,
    __out       ULONG*  pulcbInstanceNameSize);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif  // _DRT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dsattrib.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for dsattrib.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dsattrib_h__
#define __dsattrib_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAttributeSet_FWD_DEFINED__
#define __IAttributeSet_FWD_DEFINED__
typedef interface IAttributeSet IAttributeSet;
#endif 	/* __IAttributeSet_FWD_DEFINED__ */


#ifndef __IAttributeGet_FWD_DEFINED__
#define __IAttributeGet_FWD_DEFINED__
typedef interface IAttributeGet IAttributeGet;
#endif 	/* __IAttributeGet_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "strmif.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_dsattrib_0000_0000 */
/* [local] */ 





extern RPC_IF_HANDLE __MIDL_itf_dsattrib_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dsattrib_0000_0000_v0_0_s_ifspec;

#ifndef __IAttributeSet_INTERFACE_DEFINED__
#define __IAttributeSet_INTERFACE_DEFINED__

/* interface IAttributeSet */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAttributeSet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("583ec3cc-4960-4857-982b-41a33ea0a006")
    IAttributeSet : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAttrib( 
            /* [in] */ GUID guidAttribute,
            /* [in] */ __RPC__in BYTE *pbAttribute,
            /* [in] */ DWORD dwAttributeLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAttributeSetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IAttributeSet * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IAttributeSet * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IAttributeSet * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAttrib )( 
            __RPC__in IAttributeSet * This,
            /* [in] */ GUID guidAttribute,
            /* [in] */ __RPC__in BYTE *pbAttribute,
            /* [in] */ DWORD dwAttributeLength);
        
        END_INTERFACE
    } IAttributeSetVtbl;

    interface IAttributeSet
    {
        CONST_VTBL struct IAttributeSetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAttributeSet_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAttributeSet_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAttributeSet_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAttributeSet_SetAttrib(This,guidAttribute,pbAttribute,dwAttributeLength)	\
    ( (This)->lpVtbl -> SetAttrib(This,guidAttribute,pbAttribute,dwAttributeLength) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAttributeSet_INTERFACE_DEFINED__ */


#ifndef __IAttributeGet_INTERFACE_DEFINED__
#define __IAttributeGet_INTERFACE_DEFINED__

/* interface IAttributeGet */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAttributeGet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("52dbd1ec-e48f-4528-9232-f442a68f0ae1")
    IAttributeGet : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out LONG *plCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttribIndexed( 
            /* [in] */ LONG lIndex,
            /* [out] */ __RPC__out GUID *pguidAttribute,
            /* [out][in] */ __RPC__inout BYTE *pbAttribute,
            /* [out][in] */ __RPC__inout DWORD *pdwAttributeLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttrib( 
            /* [in] */ GUID guidAttribute,
            /* [out][in] */ __RPC__inout BYTE *pbAttribute,
            /* [out][in] */ __RPC__inout DWORD *pdwAttributeLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAttributeGetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IAttributeGet * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IAttributeGet * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IAttributeGet * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            __RPC__in IAttributeGet * This,
            /* [out] */ __RPC__out LONG *plCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttribIndexed )( 
            __RPC__in IAttributeGet * This,
            /* [in] */ LONG lIndex,
            /* [out] */ __RPC__out GUID *pguidAttribute,
            /* [out][in] */ __RPC__inout BYTE *pbAttribute,
            /* [out][in] */ __RPC__inout DWORD *pdwAttributeLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttrib )( 
            __RPC__in IAttributeGet * This,
            /* [in] */ GUID guidAttribute,
            /* [out][in] */ __RPC__inout BYTE *pbAttribute,
            /* [out][in] */ __RPC__inout DWORD *pdwAttributeLength);
        
        END_INTERFACE
    } IAttributeGetVtbl;

    interface IAttributeGet
    {
        CONST_VTBL struct IAttributeGetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAttributeGet_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAttributeGet_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAttributeGet_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAttributeGet_GetCount(This,plCount)	\
    ( (This)->lpVtbl -> GetCount(This,plCount) ) 

#define IAttributeGet_GetAttribIndexed(This,lIndex,pguidAttribute,pbAttribute,pdwAttributeLength)	\
    ( (This)->lpVtbl -> GetAttribIndexed(This,lIndex,pguidAttribute,pbAttribute,pdwAttributeLength) ) 

#define IAttributeGet_GetAttrib(This,guidAttribute,pbAttribute,pdwAttributeLength)	\
    ( (This)->lpVtbl -> GetAttrib(This,guidAttribute,pbAttribute,pdwAttributeLength) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAttributeGet_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dsattrib_0000_0002 */
/* [local] */ 

// ------------------------------------------------------
// GUID: DSATTRIB_UDCRTag
// ------------------------------------------------------
typedef struct _UDCR_TAG {
    BYTE        bVersion ;
    BYTE        KID [24 + 1] ;
    ULONGLONG   ullBaseCounter ;
    ULONGLONG   ullBaseCounterRange ;
    BOOL        fScrambled ;
    BYTE        bStreamMark ;
    DWORD       dwReserved1 ;
    DWORD       dwReserved2 ;
} UDCR_TAG ;
// ------------------------------------------------------
// GUID: DSATTRIB_PicSampleSeq
// ------------------------------------------------------
// Older defines with mnemonics specific to MPEG-2 video:
#define SAMPLE_SEQ_SEQUENCE_HEADER      1
#define SAMPLE_SEQ_GOP_HEADER           2
#define SAMPLE_SEQ_PICTURE_HEADER       3
// Latest defines with mnemonics generic to MPEG-2 and H.264 video:
#define SAMPLE_SEQ_SEQUENCE_START       SAMPLE_SEQ_SEQUENCE_HEADER
#define SAMPLE_SEQ_SEEK_POINT           SAMPLE_SEQ_GOP_HEADER
#define SAMPLE_SEQ_FRAME_START          SAMPLE_SEQ_PICTURE_HEADER
// Older defines with mnemonics specific to MPEG-2 video:
#define SAMPLE_SEQ_CONTENT_UNKNOWN      0
#define SAMPLE_SEQ_CONTENT_I_FRAME      1
#define SAMPLE_SEQ_CONTENT_P_FRAME      2
#define SAMPLE_SEQ_CONTENT_B_FRAME      3
// Latest defines with mnemonics generic to MPEG-2 and H.264 video:
#define SAMPLE_SEQ_CONTENT_STANDALONE_FRAME      SAMPLE_SEQ_CONTENT_I_FRAME
#define SAMPLE_SEQ_CONTENT_REF_FRAME             SAMPLE_SEQ_CONTENT_P_FRAME
#define SAMPLE_SEQ_CONTENT_NONREF_FRAME          SAMPLE_SEQ_CONTENT_B_FRAME
typedef struct _PIC_SEQ_SAMPLE {
    DWORD
      Content   : 3,    //  SAMPLE_CONTENT_*
      Start     : 1,    //  '1' if the sample is a PictureSampleSequence start
      FrameRate : 4,    //  see below (h.262, table 6-4)
      InvalidVA  : 1,   //  0 normally. 1 if VA attempted but failed
      Reserved   : 19,  //  reserved; shall have value 0
      Version   : 4 ;   //  1 [0 means InvalidVA defaults to 0]
} PIC_SEQ_SAMPLE, *PPIC_SEQ_SAMPLE ;
//      Frame Rate
//          (see h.262, table 6-4)
//
//          0000    reserved (ignore field value)
//          0001    23.976
//          0010    24
//          0011    25
//          0100    29.97
//          0101    30
//          0110    50
//          0111    59.94
//          1000    60
typedef struct _SAMPLE_SEQ_OFFSET {
    DWORD
      Type      : 4,       //  SAMPLE_SEQ_*; 0 means not used
      Offset    : 20,      //  downstream byte offset; 0xfffff means > 2^20-1
      Reserved  : 8 ;      //  reserved; o
} SAMPLE_SEQ_OFFSET ;
#define OFFSET_MARKER_COUNT(attr_len)   \
    ((attr_len - sizeof (PIC_SEQ_SAMPLE)) / sizeof (SAMPLE_SEQ_OFFSET))
#define PIC_SEQ_SAMPLE_ATTR_LEN(cOffsets)   (sizeof (PIC_SEQ_SAMPLE) + (cOffsets) * sizeof (SAMPLE_SEQ_OFFSET))
// ------------------------------------------------------
// GUID: DSATTRIB_OptionalVideoAttributes
// ------------------------------------------------------

typedef enum VA_VIDEO_FORMAT
{
    // Original video format known:

    VA_VIDEO_COMPONENT = 0,
    VA_VIDEO_PAL = 1,
    VA_VIDEO_NTSC = 2,
    VA_VIDEO_SECAM = 3,
    VA_VIDEO_MAC = 4,

    // Original video format not known:

    VA_VIDEO_UNSPECIFIED = 5

    // The MPEG-2 video and H.264 specs reserve values
    // 6 and 7 for future use. 
} VA_VIDEO_FORMAT;

typedef enum VA_COLOR_PRIMARIES
{
    // 0 is reserved by both H.264 and MPEG-2 video

    VA_PRIMARIES_ITU_R_BT_709 = 1,

    // Use this value if the color primaries system is not
    // known or non-standard:

    VA_PRIMARIES_UNSPECIFIED = 2, 

    // 3 is reserved by both H.264 and MPEG-2 video

    VA_PRIMARIES_ITU_R_BT_470_SYSTEM_M = 4,
    VA_PRIMARIES_ITU_R_BT_470_SYSTEM_B_G = 5,
    VA_PRIMARIES_SMPTE_170M = 6,
    VA_PRIMARIES_SMPTE_240M = 7,
    VA_PRIMARIES_H264_GENERIC_FILM = 8

    //  Values in the range 9 to 255 are reserved by H.264. Values in 
    // the range 8 to 255 are reserved by MPEG-2 video
} VA_COLOR_PRIMARIES;

typedef enum VA_TRANSFER_CHARACTERISTICS
{
    // The value 0 is reserved by both MPEG-2 video and H.264

    VA_TRANSFER_CHARACTERISTICS_ITU_R_BT_709 = 1,

    // Use the value below of the transfer characteristics
    // are unknown or non-standard:

    VA_TRANSFER_CHARACTERISTICS_UNSPECIFIED = 2, 

    // The value 3 is reserved by both MPEG-2 video and H.264

    VA_TRANSFER_CHARACTERISTICS_ITU_R_BT_470_SYSTEM_M = 4,
    VA_TRANSFER_CHARACTERISTICS_ITU_R_BT_470_SYSTEM_B_G = 5,
    VA_TRANSFER_CHARACTERISTICS_SMPTE_170M = 6,
    VA_TRANSFER_CHARACTERISTICS_SMPTE_240M = 7,
    VA_TRANSFER_CHARACTERISTICS_LINEAR = 8,
    VA_TRANSFER_CHARACTERISTICS_H264_LOG_100_TO_1 = 9,
    VA_TRANSFER_CHARACTERISTICS_H264_LOG_316_TO_1 = 10

    // The values 11 to 255 are reserved by H.264. The values
    // 9 to 255 are reserved by MPEG-2 video.
} VA_TRANSFER_CHARACTERISTICS;

typedef enum VA_MATRIX_COEFFICIENTS
{
    VA_MATRIX_COEFF_H264_RGB = 0,
    VA_MATRIX_COEFF_ITU_R_BT_709 = 1,

    // Use the value below if the matrix coefficients are
    // unknown or non-standard:

    VA_MATRIX_COEFF_UNSPECIFIED = 2,

    // The value 3 is reserved by both MPEG-2 video and H.264

    VA_MATRIX_COEFF_FCC = 4,
    VA_MATRIX_COEFF_ITU_R_BT_470_SYSTEM_B_G = 5,
    VA_MATRIX_COEFF_SMPTE_170M = 6,
    VA_MATRIX_COEFF_SMPTE_240M = 7,
    VA_MATRIX_COEFF_H264_YCgCo = 8

    // The values 9 to 255 are reserved by H.264. The values 8 to 255
    // are reserved by MPEG-2 video.
} VA_MATRIX_COEFFICIENTS;

typedef struct VA_OPTIONAL_VIDEO_PROPERTIES
{
    WORD					dwPictureHeight ;
    WORD		 			dwPictureWidth ;
    WORD					dwAspectRatioX ;
    WORD					dwAspectRatioY ;
    VA_VIDEO_FORMAT			VAVideoFormat;
    VA_COLOR_PRIMARIES 		VAColorPrimaries;
    VA_TRANSFER_CHARACTERISTICS VATransferCharacteristics;
    VA_MATRIX_COEFFICIENTS 	VAMatrixCoefficients;
}  VA_OPTIONAL_VIDEO_PROPERTIES;
// ------------------------------------------------------
// GUID: DSATTRIB_TRANSPORT_PROPERTIES
// ------------------------------------------------------
typedef struct _TRANSPORT_PROPERTIES {
    ULONG               PID ;
    REFERENCE_TIME      PCR ;
    union {
        struct _Others {
            LONGLONG 
                TransportScramblingControl : 8 ,
                Reserved : 56 ;
        } Others ;
        LONGLONG Value ;
    } Fields ;
} TRANSPORT_PROPERTIES ;
// ------------------------------------------------------
// GUID: DSATTRIB_PBDATAG_ATTRIBUTE
// ------------------------------------------------------
typedef struct _PBDA_TAG_ATTRIBUTE {
    GUID                TableUUId ;
    BYTE                TableId ;
    WORD                VersionNo ;
    DWORD               TableDataSize ;
    BYTE                TableData [1] ;
} PBDA_TAG_ATTRIBUTE ;
// ------------------------------------------------------
// GUID: DSATTRIB_CAPTURE_STREAMTIME
// ------------------------------------------------------
typedef struct _CAPTURE_STREAMTIME {
    REFERENCE_TIME      StreamTime ;
} CAPTURE_STREAMTIME ;
// ------------------------------------------------------
// GUID: DSATTRIB_DSHOW_STREAM_DESC
// ------------------------------------------------------
typedef struct _DSHOW_STREAM_DESC {
    DWORD   VersionNo ;
    DWORD   StreamId ;
    BOOL    Default ;
    BOOL    Creation ;
    DWORD   Reserved ;
} DSHOW_STREAM_DESC ;
// ------------------------------------------------------
// GUID: DSATTRIB_SAMPLE_LIVE_STREAM_TIME
// ------------------------------------------------------
typedef struct _SAMPLE_LIVE_STREAM_TIME{
    ULONGLONG qwStreamTime;
    ULONGLONG qwLiveTime;
}SAMPLE_LIVE_STREAM_TIME ;


extern RPC_IF_HANDLE __MIDL_itf_dsattrib_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dsattrib_0000_0002_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\DSAdmin.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999.
//
//  File:       dsadmin.h
//
//  Contents:   DS Admin Object Creation public header
//
//---------------------------------------------------------------------------


//
// CoClass for the Object creation dialog object
//
// {E301A009-F901-11d2-82B9-00C04F68928B}
DEFINE_GUID(CLSID_DsAdminCreateObj, 
    0xe301a009, 0xf901, 0x11d2, 0x82, 0xb9, 0x0, 0xc0, 0x4f, 0x68, 0x92, 0x8b);


//
// Interface GUIDs
//


// {53554A38-F902-11d2-82B9-00C04F68928B}
DEFINE_GUID(IID_IDsAdminCreateObj, 
    0x53554a38, 0xf902, 0x11d2, 0x82, 0xb9, 0x0, 0xc0, 0x4f, 0x68, 0x92, 0x8b);

// {F2573587-E6FC-11d2-82AF-00C04F68928B}
DEFINE_GUID(IID_IDsAdminNewObj, 
    0xf2573587, 0xe6fc, 0x11d2, 0x82, 0xaf, 0x0, 0xc0, 0x4f, 0x68, 0x92, 0x8b);

// {BE2B487E-F904-11d2-82B9-00C04F68928B}
DEFINE_GUID(IID_IDsAdminNewObjPrimarySite, 
0xbe2b487e, 0xf904, 0x11d2, 0x82, 0xb9, 0x0, 0xc0, 0x4f, 0x68, 0x92, 0x8b);


// {6088EAE2-E7BF-11d2-82AF-00C04F68928B}
DEFINE_GUID(IID_IDsAdminNewObjExt, 
    0x6088eae2, 0xe7bf, 0x11d2, 0x82, 0xaf, 0x0, 0xc0, 0x4f, 0x68, 0x92, 0x8b);


// {E4A2B8B3-5A18-11d2-97C1-00A0C9A06D2D}
DEFINE_GUID(IID_IDsAdminNotifyHandler, 
    0xe4a2b8b3, 0x5a18, 0x11d2, 0x97, 0xc1, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d);


#ifndef _DSADMIN_H
#define _DSADMIN_H


// ----------------------------------------------------------------------------
// 
// Interface: IDsAdminCreateObj
//  
// Implemented by the object (implemented by the system) CLSID_DsAdminCreateObj
//
// Used by: any client needing to invoke the creation UI
//

  
#undef  INTERFACE
#define INTERFACE   IDsAdminCreateObj

DECLARE_INTERFACE_(IDsAdminCreateObj, IUnknown)
{
  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
  STDMETHOD_(ULONG,Release)(THIS) PURE;

  // *** IDsAdminCreateObj methods ***
  STDMETHOD(Initialize)(THIS_ /*IN*/ IADsContainer* pADsContainerObj, 
                              /*IN*/ IADs* pADsCopySource,
                              /*IN*/ LPCWSTR lpszClassName) PURE;
  STDMETHOD(CreateModal)(THIS_ /*IN*/ HWND hwndParent, 
                               /*OUT*/ IADs** ppADsObj) PURE;
};






//---------------------------------------------------------------------------
//
// Interface: IDsAdminNewObj
// 
// Implemented by: DS Admin
//
// Used by: creation extension in proc server (both primary and regular)
//

#undef  INTERFACE
#define INTERFACE   IDsAdminNewObj

DECLARE_INTERFACE_(IDsAdminNewObj, IUnknown)
{
  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
  STDMETHOD_(ULONG,Release)(THIS) PURE;

  // *** IDsAdminNewObj methods ***
  STDMETHOD(SetButtons)(THIS_ /*IN*/ ULONG nCurrIndex, /*IN*/ BOOL bValid) PURE; 
  STDMETHOD(GetPageCounts)(THIS_ /*OUT*/ LONG* pnTotal,
                                 /*OUT*/ LONG* pnStartIndex) PURE; 
};





//---------------------------------------------------------------------------
//
// Interface: IDsAdminNewObjPrimarySite
// 
// Implemented by: DS Admin
//
// Used by: creation extension in proc server (primary only)
//

#undef  INTERFACE
#define INTERFACE   IDsAdminNewObjPrimarySite

DECLARE_INTERFACE_(IDsAdminNewObjPrimarySite, IUnknown)
{
  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
  STDMETHOD_(ULONG,Release)(THIS) PURE;


  // *** IDsAdminNewObjPrimarySite methods ***
  STDMETHOD(CreateNew)(THIS_ /*IN*/ LPCWSTR pszName) PURE;
  STDMETHOD(Commit)(THIS_ ) PURE;
};



//
// struct passed to IDsAdminNewObjExt::Initialize()
//
// it contains information regarding UI look
//

typedef struct
{
    DWORD   dwSize;                     // size of struct, for versioning
    HICON   hObjClassIcon;              // class icon for the object to be created
    LPWSTR  lpszWizTitle;               // title of the wizard
    LPWSTR  lpszContDisplayName;        // container display name (canonical name)
} DSA_NEWOBJ_DISPINFO, * LPDSA_NEWOBJ_DISPINFO;




//
// context flags passed to IDsAdminNewObjExt::OnError() and to IDsAdminNewObjExt::WriteData()
//

#define DSA_NEWOBJ_CTX_PRECOMMIT      0x00000001  // before SetInfo()
#define DSA_NEWOBJ_CTX_COMMIT         0x00000002  // SetInfo(), commit phase
#define DSA_NEWOBJ_CTX_POSTCOMMIT     0x00000003  // after SetInfo()
#define DSA_NEWOBJ_CTX_CLEANUP        0x00000004  // on post commit fail



//---------------------------------------------------------------------------
//
// Interface: IDsAdminNewObjExt
// 
// Implemented by: creation extension in proc server (both primary and regular)
//
// Used by: DS Admin
//

#undef  INTERFACE
#define INTERFACE   IDsAdminNewObjExt

DECLARE_INTERFACE_(IDsAdminNewObjExt, IUnknown)
{
  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
  STDMETHOD_(ULONG,Release)(THIS) PURE;


  // *** IDsAdminNewObjExt methods ***
  STDMETHOD(Initialize)(THIS_ /*IN*/ IADsContainer* pADsContainerObj, 
                              /*IN*/ IADs* pADsCopySource,
                              /*IN*/ LPCWSTR lpszClassName,
                              /*IN*/ IDsAdminNewObj* pDsAdminNewObj,
                              /*IN*/ LPDSA_NEWOBJ_DISPINFO pDispInfo) PURE;

  STDMETHOD(AddPages)(THIS_ /*IN*/ LPFNADDPROPSHEETPAGE lpfnAddPage, 
                            /*IN*/ LPARAM lParam) PURE;

  STDMETHOD(SetObject)(THIS_ /*IN*/ IADs* pADsObj) PURE;

  STDMETHOD(WriteData)(THIS_ /*IN*/ HWND hWnd, 
                             /*IN*/ ULONG uContext) PURE;
  
  STDMETHOD(OnError)(THIS_ /*IN*/ HWND hWnd, 
                           /*IN*/ HRESULT hr,
                              /*IN*/ ULONG uContext) PURE;
  
  STDMETHOD(GetSummaryInfo)(THIS_ /*OUT*/BSTR* pBstrText) PURE;
};


//
// Notification opcodes for IDsAdminNotifyHandler
//

#define DSA_NOTIFY_DEL      0x00000001  // delete
#define DSA_NOTIFY_REN      0x00000002  // rename
#define DSA_NOTIFY_MOV      0x00000004  // move
#define DSA_NOTIFY_PROP     0x00000008  // property change

#define DSA_NOTIFY_ALL      (DSA_NOTIFY_DEL|DSA_NOTIFY_REN|DSA_NOTIFY_MOV|DSA_NOTIFY_PROP)

//
// TODO: add explaination
//
// flags to handle additional data
//

#define DSA_NOTIFY_FLAG_ADDITIONAL_DATA        0x00000002   //process additional extension data?
#define DSA_NOTIFY_FLAG_FORCE_ADDITIONAL_DATA  0x00000001   //operation forced



//---------------------------------------------------------------------------
//
// Interface: IDsAdminNotifyHandler
// 
// Implemented by: notification handler in proc server
//
// Used by: DS Admin
//

#undef  INTERFACE
#define INTERFACE   IDsAdminNotifyHandler


DECLARE_INTERFACE_(IDsAdminNotifyHandler, IUnknown)
{
  // *** IUnknown methods ***
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
  STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
  STDMETHOD_(ULONG,Release)(THIS) PURE;

  // IDsAdminNotifyHandler methods
  STDMETHOD(Initialize)(THIS_ /*IN*/ IDataObject* pExtraInfo, 
                              /*OUT*/ ULONG* puEventFlags) PURE;
  STDMETHOD(Begin)(THIS_ /*IN*/ ULONG uEvent,
                         /*IN*/ IDataObject* pArg1,
                         /*IN*/ IDataObject* pArg2,
                         /*OUT*/ ULONG* puFlags,
                         /*OUT*/ BSTR* pBstr) PURE;

  STDMETHOD(Notify)(THIS_ /*IN*/ ULONG nItem, /*IN*/ ULONG uFlags) PURE; 

  STDMETHOD(End)(THIS_) PURE; 
};



#endif // _DSADMIN_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dsconf.h ===
/*==========================================================================;
 *
 *  Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 *  File:       dsconf.h
 *  Content:    DirectSound configuration interface include file
 *
 **************************************************************************/

#ifndef __DSCONF_INCLUDED__
#define __DSCONF_INCLUDED__

#ifndef __DSOUND_INCLUDED__
#error dsound.h not included
#endif // __DSOUND_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


// DirectSound Configuration Component GUID {11AB3EC0-25EC-11d1-A4D8-00C04FC28ACA}
DEFINE_GUID(CLSID_DirectSoundPrivate, 0x11ab3ec0, 0x25ec, 0x11d1, 0xa4, 0xd8, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);


//
// DirectSound Device Properties {84624F82-25EC-11d1-A4D8-00C04FC28ACA}
//

DEFINE_GUID(DSPROPSETID_DirectSoundDevice, 0x84624f82, 0x25ec, 0x11d1, 0xa4, 0xd8, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

typedef enum
{
    DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A = 1,
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1 = 2,
    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1 = 3,
    DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W = 4,
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A = 5,
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W = 6,
    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A = 7,
    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W = 8,
} DSPROPERTY_DIRECTSOUNDDEVICE;

#if DIRECTSOUND_VERSION >= 0x0700
#ifdef UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W
#define DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W
#define DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W
#else // UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A
#define DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A
#define DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A
#endif // UNICODE
#else // DIRECTSOUND_VERSION >= 0x0700
#define DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A
#define DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1
#define DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1
#endif // DIRECTSOUND_VERSION >= 0x0700

typedef enum
{
    DIRECTSOUNDDEVICE_TYPE_EMULATED,
    DIRECTSOUNDDEVICE_TYPE_VXD,
    DIRECTSOUNDDEVICE_TYPE_WDM
} DIRECTSOUNDDEVICE_TYPE;

typedef enum
{
    DIRECTSOUNDDEVICE_DATAFLOW_RENDER,
    DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE
} DIRECTSOUNDDEVICE_DATAFLOW;


typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A_DATA
{
    LPSTR                       DeviceName; // waveIn/waveOut device name
    DIRECTSOUNDDEVICE_DATAFLOW  DataFlow;   // Data flow (i.e. waveIn or waveOut)
    GUID                        DeviceId;   // DirectSound device id
} DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W_DATA
{
    LPWSTR                      DeviceName; // waveIn/waveOut device name
    DIRECTSOUNDDEVICE_DATAFLOW  DataFlow;   // Data flow (i.e. waveIn or waveOut)
    GUID                        DeviceId;   // DirectSound device id
} DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W_DATA;

#ifdef UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W_DATA
#else // UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A_DATA
#endif // UNICODE

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA
{
    GUID                        DeviceId;               // DirectSound device id
    CHAR                        DescriptionA[0x100];    // Device description (ANSI)
    WCHAR                       DescriptionW[0x100];    // Device description (Unicode)
    CHAR                        ModuleA[MAX_PATH];      // Device driver module (ANSI)
    WCHAR                       ModuleW[MAX_PATH];      // Device driver module (Unicode)
    DIRECTSOUNDDEVICE_TYPE      Type;                   // Device type
    DIRECTSOUNDDEVICE_DATAFLOW  DataFlow;               // Device dataflow
    ULONG                       WaveDeviceId;           // Wave device id
    ULONG                       Devnode;                // Devnode (or DevInst)
} DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA
{
    DIRECTSOUNDDEVICE_TYPE      Type;           // Device type
    DIRECTSOUNDDEVICE_DATAFLOW  DataFlow;       // Device dataflow
    GUID                        DeviceId;       // DirectSound device id
    LPSTR                       Description;    // Device description
    LPSTR                       Module;         // Device driver module
    LPSTR                       Interface;      // Device interface
    ULONG                       WaveDeviceId;   // Wave device id
} DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA
{
    DIRECTSOUNDDEVICE_TYPE      Type;           // Device type
    DIRECTSOUNDDEVICE_DATAFLOW  DataFlow;       // Device dataflow
    GUID                        DeviceId;       // DirectSound device id
    LPWSTR                      Description;    // Device description
    LPWSTR                      Module;         // Device driver module
    LPWSTR                      Interface;      // Device interface
    ULONG                       WaveDeviceId;   // Wave device id
} DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA;

#if DIRECTSOUND_VERSION >= 0x0700
#ifdef UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA
#else // UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA
#endif // UNICODE
#else // DIRECTSOUND_VERSION >= 0x0700
#define DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA
#endif // DIRECTSOUND_VERSION >= 0x0700

typedef BOOL (CALLBACK *LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK1)(PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA, LPVOID);
typedef BOOL (CALLBACK *LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKA)(PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA, LPVOID);
typedef BOOL (CALLBACK *LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKW)(PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA, LPVOID);

#if DIRECTSOUND_VERSION >= 0x0700
#ifdef UNICODE
#define LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKW
#else // UNICODE
#define LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKA
#endif // UNICODE
#else // DIRECTSOUND_VERSION >= 0x0700
#define LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK1
#endif // DIRECTSOUND_VERSION >= 0x0700

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1_DATA
{
    LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK1 Callback;   // Callback function pointer
    LPVOID                                  Context;    // Callback function context argument
} DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A_DATA
{
    LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKA Callback;   // Callback function pointer
    LPVOID                                  Context;    // Callback function context argument
} DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W_DATA
{
    LPFNDIRECTSOUNDDEVICEENUMERATECALLBACKW Callback;   // Callback function pointer
    LPVOID                                  Context;    // Callback function context argument
} DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W_DATA;

#if DIRECTSOUND_VERSION >= 0x0700
#ifdef UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_DATA DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W_DATA
#else // UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_DATA DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A_DATA
#endif // UNICODE
#else // DIRECTSOUND_VERSION >= 0x0700
#define DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_DATA DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1_DATA
#endif // DIRECTSOUND_VERSION >= 0x0700


#ifdef __cplusplus
}
#endif // __cplusplus

#endif  // __DSCONF_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\DsGetDC.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    dsgetdc.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the DsGetDcName API.

Environment:

    User Mode - Win32

Notes:

--*/


#ifndef _DSGETDC_
#define _DSGETDC_

#if _MSC_VER > 1000
#pragma once
#endif

#if !defined(_DSGETDCAPI_)
#define DSGETDCAPI DECLSPEC_IMPORT
#else
#define DSGETDCAPI
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Structure definitions
//

//
// Flags to passed to DsGetDcName
//

#define DS_FORCE_REDISCOVERY            0x00000001

#define DS_DIRECTORY_SERVICE_REQUIRED   0x00000010
#define DS_DIRECTORY_SERVICE_PREFERRED  0x00000020
#define DS_GC_SERVER_REQUIRED           0x00000040
#define DS_PDC_REQUIRED                 0x00000080
#define DS_BACKGROUND_ONLY              0x00000100
#define DS_IP_REQUIRED                  0x00000200
#define DS_KDC_REQUIRED                 0x00000400
#define DS_TIMESERV_REQUIRED            0x00000800
#define DS_WRITABLE_REQUIRED            0x00001000
#define DS_GOOD_TIMESERV_PREFERRED      0x00002000
#define DS_AVOID_SELF                   0x00004000
#define DS_ONLY_LDAP_NEEDED             0x00008000


#define DS_IS_FLAT_NAME                 0x00010000
#define DS_IS_DNS_NAME                  0x00020000

#define DS_TRY_NEXTCLOSEST_SITE         0x00040000

#define DS_DIRECTORY_SERVICE_6_REQUIRED 0x00080000

#define DS_WEB_SERVICE_REQUIRED         0x00100000

#define DS_RETURN_DNS_NAME              0x40000000
#define DS_RETURN_FLAT_NAME             0x80000000

#define DSGETDC_VALID_FLAGS ( \
            DS_FORCE_REDISCOVERY | \
            DS_DIRECTORY_SERVICE_REQUIRED | \
            DS_DIRECTORY_SERVICE_PREFERRED | \
            DS_GC_SERVER_REQUIRED | \
            DS_PDC_REQUIRED | \
            DS_BACKGROUND_ONLY | \
            DS_IP_REQUIRED | \
            DS_KDC_REQUIRED | \
            DS_TIMESERV_REQUIRED | \
            DS_WRITABLE_REQUIRED | \
            DS_GOOD_TIMESERV_PREFERRED | \
            DS_AVOID_SELF | \
            DS_ONLY_LDAP_NEEDED | \
            DS_IS_FLAT_NAME | \
            DS_IS_DNS_NAME | \
            DS_TRY_NEXTCLOSEST_SITE | \
            DS_DIRECTORY_SERVICE_6_REQUIRED | \
            DS_WEB_SERVICE_REQUIRED | \
            DS_RETURN_FLAT_NAME  | \
            DS_RETURN_DNS_NAME )


//
// Structure returned from DsGetDcName
//

typedef struct _DOMAIN_CONTROLLER_INFOA {
    LPSTR DomainControllerName;
    LPSTR DomainControllerAddress;
    ULONG DomainControllerAddressType;
    GUID DomainGuid;
    LPSTR DomainName;
    LPSTR DnsForestName;
    ULONG Flags;
    LPSTR DcSiteName;
    LPSTR ClientSiteName;
} DOMAIN_CONTROLLER_INFOA, *PDOMAIN_CONTROLLER_INFOA;

typedef struct _DOMAIN_CONTROLLER_INFOW {
#ifdef MIDL_PASS
    [string,unique] wchar_t *DomainControllerName;
#else // MIDL_PASS
    LPWSTR DomainControllerName;
#endif // MIDL_PASS
#ifdef MIDL_PASS
    [string,unique] wchar_t *DomainControllerAddress;
#else // MIDL_PASS
    LPWSTR DomainControllerAddress;
#endif // MIDL_PASS
    ULONG DomainControllerAddressType;
    GUID DomainGuid;
#ifdef MIDL_PASS
    [string,unique] wchar_t *DomainName;
#else // MIDL_PASS
    LPWSTR DomainName;
#endif // MIDL_PASS
#ifdef MIDL_PASS
    [string,unique] wchar_t *DnsForestName;
#else // MIDL_PASS
    LPWSTR DnsForestName;
#endif // MIDL_PASS
    ULONG Flags;
#ifdef MIDL_PASS
    [string,unique] wchar_t *DcSiteName;
#else // MIDL_PASS
    LPWSTR DcSiteName;
#endif // MIDL_PASS
#ifdef MIDL_PASS
    [string,unique] wchar_t *ClientSiteName;
#else // MIDL_PASS
    LPWSTR ClientSiteName;
#endif // MIDL_PASS
} DOMAIN_CONTROLLER_INFOW, *PDOMAIN_CONTROLLER_INFOW;

#ifdef UNICODE
#define DOMAIN_CONTROLLER_INFO DOMAIN_CONTROLLER_INFOW
#define PDOMAIN_CONTROLLER_INFO PDOMAIN_CONTROLLER_INFOW
#else
#define DOMAIN_CONTROLLER_INFO DOMAIN_CONTROLLER_INFOA
#define PDOMAIN_CONTROLLER_INFO PDOMAIN_CONTROLLER_INFOA
#endif // !UNICODE

//
// Values for DomainControllerAddressType
//

#define DS_INET_ADDRESS    1
#define DS_NETBIOS_ADDRESS 2

//
// Values for returned Flags
//

#define DS_PDC_FLAG            0x00000001    // DC is PDC of Domain
#define DS_GC_FLAG             0x00000004    // DC is a GC of forest
#define DS_LDAP_FLAG           0x00000008    // Server supports an LDAP server
#define DS_DS_FLAG             0x00000010    // DC supports a DS and is a Domain Controller
#define DS_KDC_FLAG            0x00000020    // DC is running KDC service
#define DS_TIMESERV_FLAG       0x00000040    // DC is running time service
#define DS_CLOSEST_FLAG        0x00000080    // DC is in closest site to client
#define DS_WRITABLE_FLAG       0x00000100    // DC has a writable DS
#define DS_GOOD_TIMESERV_FLAG  0x00000200    // DC is running time service (and has clock hardware)
#define DS_NDNC_FLAG           0x00000400    // DomainName is non-domain NC serviced by the LDAP server
#define DS_SELECT_SECRET_DOMAIN_6_FLAG  0x00000800  // DC has some secrets
#define DS_FULL_SECRET_DOMAIN_6_FLAG    0x00001000  // DC has all secrets
#define DS_WS_FLAG             0x00002000    // DC is running web service
#define DS_PING_FLAGS          0x000FFFFF    // Flags returned on ping

#define DS_DNS_CONTROLLER_FLAG 0x20000000    // DomainControllerName is a DNS name
#define DS_DNS_DOMAIN_FLAG     0x40000000    // DomainName is a DNS name
#define DS_DNS_FOREST_FLAG     0x80000000    // DnsForestName is a DNS name


//
// Function Prototypes
//

DSGETDCAPI
DWORD
WINAPI
DsGetDcNameA(
    IN __in_opt LPCSTR ComputerName OPTIONAL,
    IN __in_opt LPCSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN __in_opt LPCSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOA *DomainControllerInfo
);

DSGETDCAPI
DWORD
WINAPI
DsGetDcNameW(
    IN __in_opt LPCWSTR ComputerName OPTIONAL,
    IN __in_opt LPCWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN __in_opt LPCWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
);

#ifdef UNICODE
#define DsGetDcName DsGetDcNameW
#else
#define DsGetDcName DsGetDcNameA
#endif // !UNICODE

DSGETDCAPI
DWORD
WINAPI
DsGetSiteNameA(
    IN __in_opt LPCSTR ComputerName OPTIONAL,
    OUT __deref_out LPSTR *SiteName
);

DSGETDCAPI
DWORD
WINAPI
DsGetSiteNameW(
    IN __in_opt LPCWSTR ComputerName OPTIONAL,
    OUT  __deref_out LPWSTR *SiteName
);

#ifdef UNICODE
#define DsGetSiteName DsGetSiteNameW
#else
#define DsGetSiteName DsGetSiteNameA
#endif // !UNICODE


DSGETDCAPI
DWORD
WINAPI
DsValidateSubnetNameW(
    __in IN LPCWSTR SubnetName
);

DSGETDCAPI
DWORD
WINAPI
DsValidateSubnetNameA(
    __in IN LPCSTR SubnetName
);

#ifdef UNICODE
#define DsValidateSubnetName DsValidateSubnetNameW
#else
#define DsValidateSubnetName DsValidateSubnetNameA
#endif // !UNICODE


//
// Only include if winsock2.h has been included
//
#ifdef _WINSOCK2API_
DSGETDCAPI
DWORD
WINAPI
DsAddressToSiteNamesW(
    IN __in_opt LPCWSTR ComputerName OPTIONAL,
    IN DWORD EntryCount,
    IN PSOCKET_ADDRESS SocketAddresses,
    OUT __deref_out_ecount(EntryCount) LPWSTR **SiteNames
    );

DSGETDCAPI
DWORD
WINAPI
DsAddressToSiteNamesA(
    IN __in_opt LPCSTR ComputerName OPTIONAL,
    IN DWORD EntryCount,
    IN PSOCKET_ADDRESS SocketAddresses,
    OUT __deref_out_ecount(EntryCount) LPSTR **SiteNames
    );

#ifdef UNICODE
#define DsAddressToSiteNames DsAddressToSiteNamesW
#else
#define DsAddressToSiteNames DsAddressToSiteNamesA
#endif // !UNICODE

DSGETDCAPI
DWORD
WINAPI
DsAddressToSiteNamesExW(
    IN __in_opt LPCWSTR ComputerName OPTIONAL,
    IN DWORD EntryCount,
    IN PSOCKET_ADDRESS SocketAddresses,
    OUT __deref_out_ecount(EntryCount) LPWSTR **SiteNames,
    OUT __deref_out_ecount(EntryCount) LPWSTR **SubnetNames
    );

DSGETDCAPI
DWORD
WINAPI
DsAddressToSiteNamesExA(
    IN __in_opt LPCSTR ComputerName OPTIONAL,
    IN DWORD EntryCount,
    IN PSOCKET_ADDRESS SocketAddresses,
    OUT __deref_out_ecount(EntryCount) LPSTR **SiteNames,
    OUT __deref_out_ecount(EntryCount) LPSTR **SubnetNames
    );

#ifdef UNICODE
#define DsAddressToSiteNamesEx DsAddressToSiteNamesExW
#else
#define DsAddressToSiteNamesEx DsAddressToSiteNamesExA
#endif // !UNICODE
#endif // _WINSOCK2API_

//
// API to enumerate trusted domains
//

typedef struct _DS_DOMAIN_TRUSTSW {

    //
    // Name of the trusted domain.
    //
#ifdef MIDL_PASS
    [string] wchar_t * NetbiosDomainName;
    [string] wchar_t * DnsDomainName;
#else // MIDL_PASS
    LPWSTR NetbiosDomainName;
    LPWSTR DnsDomainName;
#endif // MIDL_PASS


    //
    // Flags defining attributes of the trust.
    //
    ULONG Flags;
#define DS_DOMAIN_IN_FOREST           0x0001  // Domain is a member of the forest
#define DS_DOMAIN_DIRECT_OUTBOUND     0x0002  // Domain is directly trusted
#define DS_DOMAIN_TREE_ROOT           0x0004  // Domain is root of a tree in the forest
#define DS_DOMAIN_PRIMARY             0x0008  // Domain is the primary domain of queried server
#define DS_DOMAIN_NATIVE_MODE         0x0010  // Primary domain is running in native mode
#define DS_DOMAIN_DIRECT_INBOUND      0x0020  // Domain is directly trusting
#define DS_DOMAIN_VALID_FLAGS (         \
            DS_DOMAIN_IN_FOREST       | \
            DS_DOMAIN_DIRECT_OUTBOUND | \
            DS_DOMAIN_TREE_ROOT       | \
            DS_DOMAIN_PRIMARY         | \
            DS_DOMAIN_NATIVE_MODE     | \
            DS_DOMAIN_DIRECT_INBOUND )

    //
    // Index to the domain that is the parent of this domain.
    //  Only defined if NETLOGON_DOMAIN_IN_FOREST is set and
    //      NETLOGON_DOMAIN_TREE_ROOT is not set.
    //
    ULONG ParentIndex;

    //
    // The trust type and attributes of this trust.
    //
    // If NETLOGON_DOMAIN_DIRECTLY_TRUSTED is not set,
    //  these value are infered.
    //
    ULONG TrustType;
    ULONG TrustAttributes;

    //
    // The SID of the trusted domain.
    //
    // If NETLOGON_DOMAIN_DIRECTLY_TRUSTED is not set,
    //  this value will be NULL.
    //
#if defined(MIDL_PASS)
    PISID DomainSid;
#else
    PSID DomainSid;
#endif

    //
    // The GUID of the trusted domain.
    //

    GUID DomainGuid;

} DS_DOMAIN_TRUSTSW, *PDS_DOMAIN_TRUSTSW;

//
// ANSI version of the above struct
//
typedef struct _DS_DOMAIN_TRUSTSA {
    LPSTR NetbiosDomainName;
    LPSTR DnsDomainName;
    ULONG Flags;
    ULONG ParentIndex;
    ULONG TrustType;
    ULONG TrustAttributes;
    PSID DomainSid;
    GUID DomainGuid;
} DS_DOMAIN_TRUSTSA, *PDS_DOMAIN_TRUSTSA;

#ifdef UNICODE
#define DS_DOMAIN_TRUSTS DS_DOMAIN_TRUSTSW
#define PDS_DOMAIN_TRUSTS PDS_DOMAIN_TRUSTSW
#else
#define DS_DOMAIN_TRUSTS DS_DOMAIN_TRUSTSA
#define PDS_DOMAIN_TRUSTS PDS_DOMAIN_TRUSTSA
#endif // !UNICODE

DSGETDCAPI
DWORD
WINAPI
DsEnumerateDomainTrustsW (
    __in_opt LPWSTR ServerName OPTIONAL,
    __in ULONG Flags,
    __deref_out_ecount(*DomainCount) PDS_DOMAIN_TRUSTSW *Domains,
    __out PULONG DomainCount
    );

DSGETDCAPI
DWORD
WINAPI
DsEnumerateDomainTrustsA (
    __in_opt LPSTR ServerName OPTIONAL,
    __in ULONG Flags,
    __deref_out_ecount(*DomainCount) PDS_DOMAIN_TRUSTSA *Domains,
    __out PULONG DomainCount
    );

#ifdef UNICODE
#define DsEnumerateDomainTrusts DsEnumerateDomainTrustsW
#else
#define DsEnumerateDomainTrusts DsEnumerateDomainTrustsA
#endif // !UNICODE



//
// Only define this API if the caller has #included the pre-requisite 
// ntlsa.h or ntsecapi.h  
//

#if defined(_NTLSA_) || defined(_NTSECAPI_)

DSGETDCAPI
DWORD
WINAPI
DsGetForestTrustInformationW (
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR TrustedDomainName OPTIONAL,
    IN DWORD Flags,
    OUT PLSA_FOREST_TRUST_INFORMATION *ForestTrustInfo
    );

#define DS_GFTI_UPDATE_TDO      0x1     // Update TDO with information returned
#define DS_GFTI_VALID_FLAGS     0x1     // All valid flags to DsGetForestTrustInformation

DSGETDCAPI
DWORD
WINAPI
DsMergeForestTrustInformationW(
    IN LPCWSTR DomainName,
    IN PLSA_FOREST_TRUST_INFORMATION NewForestTrustInfo,
    IN PLSA_FOREST_TRUST_INFORMATION OldForestTrustInfo OPTIONAL,
    OUT PLSA_FOREST_TRUST_INFORMATION *MergedForestTrustInfo
    );

#endif // _NTLSA_ || _NTSECAPI_

DSGETDCAPI
DWORD
WINAPI
DsGetDcSiteCoverageW(
    IN __in_opt LPCWSTR ServerName OPTIONAL,
    OUT PULONG EntryCount,
    OUT __deref_out_ecount(*EntryCount) LPWSTR **SiteNames
    );

DSGETDCAPI
DWORD
WINAPI
DsGetDcSiteCoverageA(
    IN __in_opt LPCSTR ServerName OPTIONAL,
    OUT PULONG EntryCount,
    OUT __deref_out_ecount(*EntryCount) LPSTR **SiteNames
    );

#ifdef UNICODE
#define DsGetDcSiteCoverage DsGetDcSiteCoverageW
#else
#define DsGetDcSiteCoverage DsGetDcSiteCoverageA
#endif // !UNICODE

DSGETDCAPI
DWORD
WINAPI
DsDeregisterDnsHostRecordsW (
    __in_opt LPWSTR ServerName OPTIONAL,
    __in_opt LPWSTR DnsDomainName OPTIONAL,
    __in_opt GUID   *DomainGuid OPTIONAL,
    __in_opt GUID   *DsaGuid OPTIONAL,
    __in LPWSTR DnsHostName
    );

DSGETDCAPI
DWORD
WINAPI
DsDeregisterDnsHostRecordsA (
    __in_opt LPSTR ServerName OPTIONAL,
    __in_opt LPSTR DnsDomainName OPTIONAL,
    __in_opt GUID  *DomainGuid OPTIONAL,
    __in_opt GUID  *DsaGuid OPTIONAL,
    __in LPSTR DnsHostName
    );

#ifdef UNICODE
#define DsDeregisterDnsHostRecords DsDeregisterDnsHostRecordsW
#else
#define DsDeregisterDnsHostRecords DsDeregisterDnsHostRecordsA
#endif // !UNICODE


#ifdef _WINSOCK2API_  // DsGetDcOpen/Next/Close depend on winsock2.h be included

//
// Option flags passed to DsGetDcOpen
//

#define DS_ONLY_DO_SITE_NAME         0x01   // Non-site specific names should be avoided.
#define DS_NOTIFY_AFTER_SITE_RECORDS 0x02   // Return ERROR_FILEMARK_DETECTED after all
                                            //  site specific records have been processed.

#define DS_OPEN_VALID_OPTION_FLAGS ( DS_ONLY_DO_SITE_NAME | DS_NOTIFY_AFTER_SITE_RECORDS )

//
// Valid DcFlags for DsGetDcOpen
//

#define DS_OPEN_VALID_FLAGS (       \
            DS_FORCE_REDISCOVERY  | \
            DS_ONLY_LDAP_NEEDED   | \
            DS_KDC_REQUIRED       | \
            DS_PDC_REQUIRED       | \
            DS_GC_SERVER_REQUIRED | \
            DS_WRITABLE_REQUIRED )

DSGETDCAPI
DWORD
WINAPI
DsGetDcOpenW(
    IN LPCWSTR DnsName,
    IN ULONG OptionFlags,
    IN LPCWSTR SiteName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR DnsForestName OPTIONAL,
    IN ULONG DcFlags,
    OUT PHANDLE RetGetDcContext
    );

DSGETDCAPI
DWORD
WINAPI
DsGetDcOpenA(
    IN LPCSTR DnsName,
    IN ULONG OptionFlags,
    IN LPCSTR SiteName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCSTR DnsForestName OPTIONAL,
    IN ULONG DcFlags,
    OUT PHANDLE RetGetDcContext
    );

#ifdef UNICODE
#define DsGetDcOpen DsGetDcOpenW
#else
#define DsGetDcOpen DsGetDcOpenA
#endif // !UNICODE

DSGETDCAPI
DWORD
WINAPI
DsGetDcNextW(
    IN HANDLE GetDcContextHandle,
    OUT PULONG SockAddressCount OPTIONAL,
    OUT LPSOCKET_ADDRESS *SockAddresses OPTIONAL,
    OUT __deref_opt_out LPWSTR *DnsHostName OPTIONAL
    );

DSGETDCAPI
DWORD
WINAPI
DsGetDcNextA(
    IN HANDLE GetDcContextHandle,
    OUT PULONG SockAddressCount OPTIONAL,
    OUT LPSOCKET_ADDRESS *SockAddresses OPTIONAL,
    OUT __deref_opt_out LPSTR *DnsHostName OPTIONAL
    );

#ifdef UNICODE
#define DsGetDcNext DsGetDcNextW
#else
#define DsGetDcNext DsGetDcNextA
#endif // !UNICODE

DSGETDCAPI
VOID
WINAPI
DsGetDcCloseW(
    IN HANDLE GetDcContextHandle
    );

#ifdef UNICODE
#define DsGetDcClose DsGetDcCloseW
#else
#define DsGetDcClose DsGetDcCloseW  // same for ANSI
#endif // !UNICODE

#endif // _WINSOCK2API_

#ifdef __cplusplus
}
#endif

#endif // _DSGETDC_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\drmexternals.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for drmexternals.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __drmexternals_h__
#define __drmexternals_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "wmdrmsdk.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_drmexternals_0000_0000 */
/* [local] */ 

static const WCHAR *g_wszWMDRM_IsDRM                             = L"IsDRM";
static const WCHAR *g_wszWMDRM_IsDRMCached                       = L"IsDRMCached";
static const WCHAR *g_wszWMDRM_BaseLicenseAcqURL                 = L"BaseLAURL";
static const WCHAR *g_wszWMDRM_Rights                            = L"Rights";
static const WCHAR *g_wszWMDRM_LicenseID                         = L"LID";
static const WCHAR *g_wszWMDRM_DRMHeader                         = L"DRMHeader.";
static const WCHAR *g_wszWMDRM_DRMHeader_KeyID                   = L"DRMHeader.KID";
static const WCHAR *g_wszWMDRM_DRMHeader_LicenseAcqURL           = L"DRMHeader.LAINFO";
static const WCHAR *g_wszWMDRM_DRMHeader_ContentID               = L"DRMHeader.CID";
static const WCHAR *g_wszWMDRM_DRMHeader_IndividualizedVersion   = L"DRMHeader.SECURITYVERSION";
static const WCHAR *g_wszWMDRM_DRMHeader_ContentDistributor      = L"DRMHeader.ContentDistributor";
static const WCHAR *g_wszWMDRM_DRMHeader_SubscriptionContentID   = L"DRMHeader.SubscriptionContentID";
#ifndef DRM_PLAYLIST_TYPES_DEFINED
#define DRM_PLAYLIST_TYPES_DEFINED 1
#define DRM_PLAYLIST_DATA_V2_VALID         ((DWORD) 0x00000001)
#define DRM_PLAYLIST_DATA_V1_VALID         ((DWORD) 0x00000002)
#define DRM_PLAYLIST_DATA_OTHER_VALID      ((DWORD) 0x00000004)
#define DRM_CANCEL_PLAYLIST_BURN          ((DWORD) 0x00000001)
#define DRM_COMMIT_PLAYLIST_BURN          ((DWORD) 0x00000002)
typedef struct __tagDRM_PLAYLIST_CONTENT_ID
    {
    LPCWSTR lpcwszV2Header;
    LPCSTR lpcszV1KID;
    BYTE *pbOtherData;
    DWORD cbOtherData;
    DWORD dwUniqueIDForSession;
    DWORD dwValidFields;
    } 	DRM_PLAYLIST_CONTENT_ID;

#endif // DRM_PLAYLIST_TYPES_DEFINED
typedef 
enum WMT_RIGHTS
    {	WMT_RIGHT_PLAYBACK	= 0x1,
	WMT_RIGHT_COPY_TO_NON_SDMI_DEVICE	= 0x2,
	WMT_RIGHT_COPY_TO_CD	= 0x8,
	WMT_RIGHT_COPY_TO_SDMI_DEVICE	= 0x10,
	WMT_RIGHT_ONE_TIME	= 0x20,
	WMT_RIGHT_SAVE_STREAM_PROTECTED	= 0x40,
	WMT_RIGHT_COPY	= 0x80,
	WMT_RIGHT_COLLABORATIVE_PLAY	= 0x100,
	WMT_RIGHT_SDMI_TRIGGER	= 0x10000,
	WMT_RIGHT_SDMI_NOMORECOPIES	= 0x20000
    } 	WMT_RIGHTS;

#define DRM_DEVICE_REGISTER_TYPE_STREAMING      ((DWORD) 0x00000001)
#define DRM_DEVICE_REGISTER_TYPE_STORAGE        ((DWORD) 0x00000002)
#ifndef DRM_PROTECTION_SCHEMES_DEFINED
#define DRM_PROTECTION_SCHEMES_DEFINED 1
EXTERN_GUID( WMDRM_PROTECTION_SCHEME_ACP,                      0xc3fd11c6, 0xf8b7, 0x4d20, 0xB0, 0x08, 0x1d, 0xb1, 0x7d, 0x61, 0xf2, 0xda );
EXTERN_GUID( WMDRM_PROTECTION_SCHEME_MAX_VGA_RESOLUTION,       0xd783a191, 0xe083, 0x4baf, 0xb2, 0xda, 0xe6, 0x9f, 0x91, 0x0b, 0x37, 0x72 );
EXTERN_GUID( WMDRM_PROTECTION_SCHEME_MAX_COMPONENT_RESOLUTION, 0x811c5110, 0x46c8, 0x4c6e, 0x81, 0x63, 0xc0, 0x48, 0x2a, 0x15, 0xd4, 0x7e );
EXTERN_GUID( WMDRM_PROTECTION_SCHEME_DOWNSAMPLE_REQUIRED,      0x8f81a453, 0x998c, 0x4596, 0xb1, 0x50, 0xf8, 0x48, 0x6d, 0xf6, 0xf2, 0xe6 );
EXTERN_GUID( WMDRM_PROTECTION_SCHEME_MAX_VGA_RESOLUTION_1,         0xd9619433, 0xec9f, 0x489e, 0x9e, 0x07, 0x77, 0x0d, 0xed, 0xd8, 0xbd, 0x04 );
EXTERN_GUID( WMDRM_PROTECTION_SCHEME_MAX_VGA_RESOLUTION_2,         0xa24f0a24, 0x5c92, 0x4737, 0x9b, 0x21, 0xa2, 0x3e, 0x4f, 0xed, 0x32, 0x2e );
EXTERN_GUID( WMDRM_PROTECTION_SCHEME_MAX_VGA_RESOLUTION_3,         0xc4db4310, 0xa1ae, 0x422e, 0xb7, 0xa7, 0x21, 0xbc, 0x34, 0x73, 0xda, 0x77 );
EXTERN_GUID( WMDRM_PROTECTION_SCHEME_MAX_VGA_RESOLUTION_4,         0xe84e4d21, 0x3b1c, 0x44bc, 0xa2, 0xec, 0xc4, 0x81, 0x08, 0x58, 0x7c, 0xad );
EXTERN_GUID( WMDRM_PROTECTION_SCHEME_MAX_COMPONENT_RESOLUTION_1,         0xec3a1c03, 0xdd4e, 0x47f7, 0xbf, 0xe5, 0xae, 0xe7, 0x53, 0x48, 0x66, 0x71 );
EXTERN_GUID( WMDRM_PROTECTION_SCHEME_MAX_COMPONENT_RESOLUTION_2,         0x327803ca, 0xd914, 0x4da3, 0x97, 0x28, 0xe1, 0x9e, 0x82, 0xbe, 0x8c, 0x25 );
EXTERN_GUID( WMDRM_PROTECTION_SCHEME_MAX_COMPONENT_RESOLUTION_3,         0x36d9c83f, 0xaf07, 0x4727, 0xab, 0x74, 0xca, 0x69, 0x31, 0xba, 0x69, 0xf3 );
EXTERN_GUID( WMDRM_PROTECTION_SCHEME_MAX_COMPONENT_RESOLUTION_4,         0x9443d876, 0x1d46, 0x40cb, 0xbd, 0xe5, 0x9c, 0xc1, 0x46, 0x4c, 0x9b, 0xaf );
#endif // DRM_PROTECTION_SCHEMES_DEFINED
#ifndef DRM_WM_GET_LIC_DATA_DEFINED
#define DRM_WM_GET_LIC_DATA_DEFINED 1
typedef struct _WMGetLicenseData
    {
    DWORD dwSize;
    HRESULT hr;
    BSTR wszURL;
    WCHAR *wszLocalFilename;
    BYTE *pbPostData;
    DWORD dwPostDataSize;
    } 	WM_GET_LICENSE_DATA;

#endif // DRM_WM_GET_LIC_DATA_DEFINED
#define WMDRM_KEYTYPE_RC4       0
#define WMDRM_KEYTYPE_COCKTAIL  1
#ifndef WMDRM_IMPORT_SESSION_KEY_DEFINED
#define WMDRM_IMPORT_SESSION_KEY_DEFINED 1
typedef struct __tagWMDRM_IMPORT_SESSION_KEY
    {
    DWORD dwKeyType;
    DWORD cbKey;
    BYTE rgbKey[ 1 ];
    } 	WMDRM_IMPORT_SESSION_KEY;

#endif // WMDRM_IMPORT_SESSION_KEY_DEFINED
#ifndef WMDRM_IMPORT_CONTENT_KEY_DEFINED
#define WMDRM_IMPORT_CONTENT_KEY_DEFINED 1
typedef struct __tagWMDRM_IMPORT_CONTENT_KEY
    {
    DWORD dwVersion;
    DWORD cbStructSize;
    DWORD dwIVKeyType;
    DWORD cbIVKey;
    DWORD dwContentKeyType;
    DWORD cbContentKey;
    BYTE rgbKeyData[ 1 ];
    } 	WMDRM_IMPORT_CONTENT_KEY;

#endif // WMDRM_IMPORT_CONTENT_KEY_DEFINED
#ifndef WMDRM_IMPORT_INIT_STRUCT_DEFINED
#define WMDRM_IMPORT_INIT_STRUCT_DEFINED 1
typedef struct WMDRM_IMPORT_INIT_STRUCT
    {
    DWORD dwVersion;
    DWORD cbEncryptedSessionKeyMessage;
    BYTE *pbEncryptedSessionKeyMessage;
    DWORD cbEncryptedKeyMessage;
    BYTE *pbEncryptedKeyMessage;
    } 	WMDRM_IMPORT_INIT_STRUCT;

#endif // WMDRM_IMPORT_INIT_STRUCT_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_drmexternals_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_drmexternals_0000_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\DSClient.h ===
#pragma once

//---------------------------------------------------------------------------//
// CLSIDs exposed for the dsclient.
//---------------------------------------------------------------------------//

// this CLSID is used to signal that the DSOBJECTNAMEs structure originated
// for the Microsoft DS.

DEFINE_GUID(CLSID_MicrosoftDS, 0xfe1290f0, 0xcfbd, 0x11cf, 0xa3, 0x30, 0x0, 0xaa, 0x0, 0xc1, 0x6e, 0x65);
#define CLSID_DsFolder CLSID_MicrosoftDS


// this is the CLSID used by clients to get the IShellExtInit, IPropSheetExt
// and IContextMenus exposed from dsuiext.dll.

DEFINE_GUID(CLSID_DsPropertyPages, 0xd45d530,  0x764b, 0x11d0, 0xa1, 0xca, 0x0, 0xaa, 0x0, 0xc1, 0x6e, 0x65);

DEFINE_GUID(CLSID_DsDomainTreeBrowser, 0x1698790a, 0xe2b4, 0x11d0, 0xb0, 0xb1, 0x00, 0xc0, 0x4f, 0xd8, 0xdc, 0xa6);
DEFINE_GUID(IID_IDsBrowseDomainTree, 0x7cabcf1e, 0x78f5, 0x11d2, 0x96, 0xc, 0x0, 0xc0, 0x4f, 0xa3, 0x1a, 0x86);

DEFINE_GUID(CLSID_DsDisplaySpecifier, 0x1ab4a8c0, 0x6a0b, 0x11d2, 0xad, 0x49, 0x0, 0xc0, 0x4f, 0xa3, 0x1a, 0x86);
#define IID_IDsDisplaySpecifier CLSID_DsDisplaySpecifier

DEFINE_GUID(CLSID_DsFolderProperties, 0x9e51e0d0, 0x6e0f, 0x11d2, 0x96, 0x1, 0x0, 0xc0, 0x4f, 0xa3, 0x1a, 0x86);

#ifndef GUID_DEFS_ONLY

#include "activeds.h"

//---------------------------------------------------------------------------//
// Clipboard formats used within DSUI
//---------------------------------------------------------------------------//

//
// CF_DSOBJECTS
// ------------
//  This clipboard format defines the seleciton for an DS IShellFolder to the
//  shell extensions.   All strings are stored as BSTR's, and an offset == 0 
//  is used to indicate that the string is not present.
// 

#define DSOBJECT_ISCONTAINER            0x00000001  // = 1 => object is a container
#define DSOBJECT_READONLYPAGES          0x80000000  // = 1 => read only pages

#define DSPROVIDER_UNUSED_0             0x00000001
#define DSPROVIDER_UNUSED_1             0x00000002
#define DSPROVIDER_UNUSED_2             0x00000004
#define DSPROVIDER_UNUSED_3             0x00000008
#define DSPROVIDER_ADVANCED             0x00000010  // = 1 => advanced mode 
#define DSPROVIDER_AD_LDS               0x00000020  // = 1 => talking to an AD LDS instance 

#define CFSTR_DSOBJECTNAMES TEXT("DsObjectNames")

typedef struct
{
    DWORD   dwFlags;                    // item flags
    DWORD   dwProviderFlags;            // flags for item provider
    DWORD   offsetName;                 // offset to ADS path of the object
    DWORD   offsetClass;                // offset to object class name / == 0 not known
} DSOBJECT, * LPDSOBJECT;

typedef struct
{
    CLSID    clsidNamespace;            // namespace identifier (indicates which namespace selection from)
    UINT     cItems;                    // number of objects
    DSOBJECT aObjects[1];               // array of objects
} DSOBJECTNAMES, * LPDSOBJECTNAMES;


//
// CF_DSDISPLAYSPECOPTIONS
// -----------------------
//  When invoking an object referenced by a display specifier (context menu, property
//  page, etc) we call the IShellExtInit interface passing a IDataObject.  This data
//  object supports the CF_DSDISPLAYSPECOPTIONS format to give out configuration
//  informaiton about admin/shell invocation.
//
//  When interacting with dsuiext.dll the interfaces uses this clipboard format
//  to determine which display specifier attributes to address (admin/shell)
//  and pick up the values accordingly.  If no format is suppoted then
//  dsuiext.dll defaults to shell.
// 

#define CFSTR_DS_DISPLAY_SPEC_OPTIONS TEXT("DsDisplaySpecOptions")
#define CFSTR_DSDISPLAYSPECOPTIONS CFSTR_DS_DISPLAY_SPEC_OPTIONS

typedef struct _DSDISPLAYSPECOPTIONS
{
    DWORD   dwSize;                             // size of struct, for versioning
    DWORD   dwFlags;                            // invocation flags
    DWORD   offsetAttribPrefix;                 // offset to attribute prefix string.

    DWORD   offsetUserName;                     // offset to UNICODE user name
    DWORD   offsetPassword;                     // offset to UNICODE password
    DWORD   offsetServer;
    DWORD   offsetServerConfigPath;

} DSDISPLAYSPECOPTIONS, * PDSDISPLAYSPECOPTIONS, * LPDSDISPLAYSPECOPTIONS;

#define DS_PROP_SHELL_PREFIX L"shell"
#define DS_PROP_ADMIN_PREFIX L"admin"

#define DSDSOF_HASUSERANDSERVERINFO     0x00000001      // = 1 => user name/password are valid
#define DSDSOF_SIMPLEAUTHENTICATE       0x00000002      // = 1 => don't use secure authentication to DS
#define DSDSOF_DONTSIGNSEAL             0x00000004      // = 1 => don't sign+seal when opening DS objects
#define DSDSOF_DSAVAILABLE              0x40000000      // = 1 => ignore DS available checks

//
// CF_DSPROPERTYPAGEINFO
// ---------------------
//  When the property pages for an object are being displayed the parsed
//  display specifier string is passed to the page object via the IDataObject
//  in the following clipboard format.
//
//  Within the display specifier for a property page, the format for a
//  Win32 extension is "n,{clsid}[,bla...]" we take the "bla" section and
//  pass it down.
// 

#define CFSTR_DSPROPERTYPAGEINFO TEXT("DsPropPageInfo")

typedef struct
{
    DWORD offsetString;                 // offset to UNICODE string
} DSPROPERTYPAGEINFO, * LPDSPROPERTYPAGEINFO;


// 
// To sync property pages and the admin tools this message is broadcast
//

#define DSPROP_ATTRCHANGED_MSG  TEXT("DsPropAttrChanged")

//---------------------------------------------------------------------------//


//---------------------------------------------------------------------------//
//
// IDsBrowseDomainTree
// ===================
//  This interface returns a list of the domains from a given computer name
//  (or the current computer name if none is specified).
//
//  NOTES:
//    1) The structure returned by ::GetDomains should be free'd using
//       FreeDomains.
//
//    2) ::BrowseTo allocates a string on exit, this is allocated using
//       CoTaskMemAlloc, and therefore should be free'd using CoTaskMemFree.
//
//---------------------------------------------------------------------------//

#define DBDTF_RETURNFQDN          0x00000001  // if not set, pszNCName will be blank
#define DBDTF_RETURNMIXEDDOMAINS  0x00000002  // set it if you want downlevel trust domains too
#define DBDTF_RETURNEXTERNAL      0x00000004  // set it if you want external trust domains too
#define DBDTF_RETURNINBOUND       0x00000008  // set it if you want trusting domains
#define DBDTF_RETURNINOUTBOUND    0x00000010  // set it if you want both trusted and trusting domains

typedef struct _DOMAINDESC
{       
  LPWSTR pszName;                       // domain name (if no dns, use netbios)
  LPWSTR pszPath;                       // set to blank
  LPWSTR pszNCName;                     // FQDN, e.g.,DC=mydomain,DC=microsoft,DC=com
  LPWSTR pszTrustParent;                // parent domain name (if no dns, use netbios)
  LPWSTR pszObjectClass;                // Object class of the domain object referenced
  ULONG  ulFlags;                       // Flags, from DS_TRUSTED_DOMAINS.Flags
  BOOL   fDownLevel;                    // == 1 if downlevel domain
  struct _DOMAINDESC *pdChildList;      // Children of this node
  struct _DOMAINDESC *pdNextSibling;    // Siblings of this node            
} DOMAIN_DESC, DOMAINDESC, * PDOMAIN_DESC, * LPDOMAINDESC;

typedef struct
{
  DWORD dsSize;
  DWORD dwCount;
  DOMAINDESC aDomains[1];
} DOMAIN_TREE, DOMAINTREE, * PDOMAIN_TREE, * LPDOMAINTREE;

#undef  INTERFACE
#define INTERFACE  IDsBrowseDomainTree

DECLARE_INTERFACE_IID_(IDsBrowseDomainTree, IUnknown, "7cabcf1e-78f5-11d2-960c-00c04fa31a86")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IDsBrowseDomainTree methods ***
    STDMETHOD(BrowseTo)(THIS_ HWND hwndParent, __out LPWSTR *ppszTargetPath, __in DWORD dwFlags) PURE;
    STDMETHOD(GetDomains)(THIS_ PDOMAIN_TREE *ppDomainTree, DWORD dwFlags) PURE;
    STDMETHOD(FreeDomains)(THIS_ PDOMAIN_TREE *ppDomainTree) PURE;
    STDMETHOD(FlushCachedDomains)(THIS) PURE;
    STDMETHOD(SetComputer)(THIS_ LPCWSTR pszComputerName, LPCWSTR pszUserName, LPCWSTR pszPassword) PURE;
};

//---------------------------------------------------------------------------//


//---------------------------------------------------------------------------//
//
// IDsDisplaySpecifier
// ===================
//  This interface gives client UI access to the display specifiers for 
//  specific attributes.
//
//---------------------------------------------------------------------------//

//
// IDsDisplaySpecifier::SetServer flags
//
#define DSSSF_SIMPLEAUTHENTICATE        0x00000001  // = 1 => don't use secure authentication to DS
#define DSSSF_DONTSIGNSEAL              0x00000002  // = 1 => don't use sign+seal when opening objects in the DS
#define DSSSF_DSAVAILABLE               0x80000000  // = 1 => ignore DS available checks

//
// Flags for IDsDisplaySpecifier::GetIcon / GetIconLocation
//
#define DSGIF_ISNORMAL                  0x0000000   // = icon is in normal state (default)
#define DSGIF_ISOPEN                    0x0000001   // = icon is in open state
#define DSGIF_ISDISABLED                0x0000002   // = icon is in a disabled state
#define DSGIF_ISMASK                    0x000000f
#define DSGIF_GETDEFAULTICON            0x0000010   // = 1 => if no icon then get default (from shell32.dll)
#define DSGIF_DEFAULTISCONTAINER        0x0000020   // = 1 => if returning default icon, return it as a container

//
// Flags for IDsDisplaySpecifier::IsClassContainer
//
#define DSICCF_IGNORETREATASLEAF        0x00000001  // = 1 => igore the "treatAsLeaf" and use only schema information

//
// Callback function used for IDsDisplaySpecifier::EnumClassAttributes
//

#define DSECAF_NOTLISTED               0x00000001  // = 1 => hide from the field drop down in the query UI

typedef HRESULT (CALLBACK *LPDSENUMATTRIBUTES)(LPARAM lParam, LPCWSTR pszAttributeName, LPCWSTR pszDisplayName, DWORD dwFlags);

//
// IDsDisplaySpecifier::GetClassCreationInfo information
//

#define DSCCIF_HASWIZARDDIALOG          0x00000001  // = 1 => return the wizard dialog CLSID
#define DSCCIF_HASWIZARDPRIMARYPAGE     0x00000002  // = 1 => returning a primary wizard dlg CLSID

typedef struct
{
    DWORD dwFlags;
    CLSID clsidWizardDialog;
    CLSID clsidWizardPrimaryPage;
    DWORD cWizardExtensions;            // how many extension CLSIDs?
    CLSID aWizardExtensions[1];
} DSCLASSCREATIONINFO, * LPDSCLASSCREATIONINFO;

//
// IDsDisplaySpecifier - a COM object for interacting with display specifiers
//

#undef  INTERFACE
#define INTERFACE IDsDisplaySpecifier

DECLARE_INTERFACE_IID_(IDsDisplaySpecifier, IUnknown, "1ab4a8c0-6a0b-11d2-ad49-00c04fa31a86")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IDsDisplaySpecifier methods ***
    STDMETHOD(SetServer)(THIS_ LPCWSTR pszServer, LPCWSTR pszUserName, LPCWSTR pszPassword, DWORD dwFlags) PURE;
    STDMETHOD(SetLanguageID)(THIS_ LANGID langid) PURE;
    STDMETHOD(GetDisplaySpecifier)(THIS_ LPCWSTR pszObjectClass, REFIID riid, void **ppv) PURE;
    STDMETHOD(GetIconLocation)(THIS_ LPCWSTR pszObjectClass, __in DWORD dwFlags, __out_ecount(cchBuffer) LPWSTR pszBuffer, __in INT cchBuffer, __out INT *presid) PURE;
    STDMETHOD_(HICON, GetIcon)(THIS_ LPCWSTR pszObjectClass, DWORD dwFlags, INT cxIcon, INT cyIcon) PURE;
    STDMETHOD(GetFriendlyClassName)(THIS_ LPCWSTR pszObjectClass, __out_ecount(cchBuffer) LPWSTR pszBuffer, __in INT cchBuffer) PURE;
    STDMETHOD(GetFriendlyAttributeName)(THIS_ LPCWSTR pszObjectClass, __in LPCWSTR pszAttributeName, __out_ecount(cchBuffer) LPWSTR pszBuffer, __in UINT cchBuffer) PURE;
    STDMETHOD_(BOOL, IsClassContainer)(THIS_ LPCWSTR pszObjectClass, LPCWSTR pszADsPath, DWORD dwFlags) PURE;
    STDMETHOD(GetClassCreationInfo)(THIS_ LPCWSTR pszObjectClass, LPDSCLASSCREATIONINFO* ppdscci) PURE;
    STDMETHOD(EnumClassAttributes)(THIS_ LPCWSTR pszObjectClass, LPDSENUMATTRIBUTES pcbEnum, LPARAM lParam) PURE;
    STDMETHOD_(ADSTYPE, GetAttributeADsType)(THIS_ LPCWSTR pszAttributeName) PURE;
};


//---------------------------------------------------------------------------//
//
// DsBrowseForContainer
// --------------------
//  Provides a container browser similar to the SHBrowseForFolder, except
//  targetting the DS.
//
// In:
//  pInfo -> DSBROWSEINFO structure
//
// Out:
//  == IDOK/IDCANCEL depending on buttons, -1 if error
//
//---------------------------------------------------------------------------//

typedef struct
{
    DWORD           cbStruct;       // size of structure in bytes
    HWND            hwndOwner;      // dialog owner
    LPCWSTR         pszCaption;     // dialog caption text (can be NULL)
    LPCWSTR         pszTitle;       // displayed above the tree view control (can be NULL)
    LPCWSTR         pszRoot;        // ADS path to root (NULL == root of DS namespace)
    LPWSTR          pszPath;        // [in/out] initial selection & returned path (required)
    ULONG           cchPath;        // size of pszPath buffer in characters
    DWORD           dwFlags;
    BFFCALLBACK     pfnCallback;    // callback function (see SHBrowseForFolder)
    LPARAM          lParam;         // passed to pfnCallback as lpUserData
    DWORD           dwReturnFormat; // ADS_FORMAT_* (default is ADS_FORMAT_X500_NO_SERVER)
    LPCWSTR         pUserName;      // Username and Password to authenticate against DS with  
    LPCWSTR         pPassword;
    LPWSTR          pszObjectClass; // UNICODE string for the object class
    ULONG           cchObjectClass;
} DSBROWSEINFOW, *PDSBROWSEINFOW;

typedef struct
{
    DWORD           cbStruct;
    HWND            hwndOwner;
    LPCSTR          pszCaption;
    LPCSTR          pszTitle;
    LPCWSTR         pszRoot;        // ADS paths are always UNICODE
    LPWSTR          pszPath;        // ditto
    ULONG           cchPath;
    DWORD           dwFlags;
    BFFCALLBACK     pfnCallback;
    LPARAM          lParam;
    DWORD           dwReturnFormat;
    LPCWSTR         pUserName;      // Username and Password to authenticate against DS with  
    LPCWSTR         pPassword;
    LPWSTR          pszObjectClass; // object class of the selected object
    ULONG           cchObjectClass;
} DSBROWSEINFOA, *PDSBROWSEINFOA;

#ifdef UNICODE
#define DSBROWSEINFO   DSBROWSEINFOW
#define PDSBROWSEINFO  PDSBROWSEINFOW
#else
#define DSBROWSEINFO   DSBROWSEINFOA
#define PDSBROWSEINFO  PDSBROWSEINFOA
#endif

// DSBROWSEINFO flags
#define DSBI_NOBUTTONS          0x00000001  // NOT TVS_HASBUTTONS
#define DSBI_NOLINES            0x00000002  // NOT TVS_HASLINES
#define DSBI_NOLINESATROOT      0x00000004  // NOT TVS_LINESATROOT
#define DSBI_CHECKBOXES         0x00000100  // TVS_CHECKBOXES
#define DSBI_NOROOT             0x00010000  // don't include pszRoot in tree (its children become top level nodes)
#define DSBI_INCLUDEHIDDEN      0x00020000  // display hidden objects
#define DSBI_EXPANDONOPEN       0x00040000  // expand to the path specified in pszPath when opening the dialog
#define DSBI_ENTIREDIRECTORY    0x00090000  // browse the entire directory (defaults to having DSBI_NOROOT set)
#define DSBI_RETURN_FORMAT      0x00100000  // dwReturnFormat field is valid
#define DSBI_HASCREDENTIALS     0x00200000  // pUserName & pPassword are valid
#define DSBI_IGNORETREATASLEAF  0x00400000  // ignore the treat as leaf flag when calling IsClassContainer
#define DSBI_SIMPLEAUTHENTICATE 0x00800000  // don't use secure authentication to DS
#define DSBI_RETURNOBJECTCLASS  0x01000000  // return object class of selected object
#define DSBI_DONTSIGNSEAL       0x02000000  // don't sign+seal communication with DS

#define DSB_MAX_DISPLAYNAME_CHARS   64

typedef struct
{
    DWORD           cbStruct;
    LPCWSTR         pszADsPath;     // ADS paths are always Unicode
    LPCWSTR         pszClass;       // ADS properties are always Unicode
    DWORD           dwMask;
    DWORD           dwState;
    DWORD           dwStateMask;
    WCHAR           szDisplayName[DSB_MAX_DISPLAYNAME_CHARS];
    WCHAR           szIconLocation[MAX_PATH];
    INT             iIconResID;
} DSBITEMW, *PDSBITEMW;

typedef struct
{
    DWORD           cbStruct;
    LPCWSTR         pszADsPath;     // ADS paths are always Unicode
    LPCWSTR         pszClass;       // ADS properties are always Unicode
    DWORD           dwMask;
    DWORD           dwState;
    DWORD           dwStateMask;
    CHAR            szDisplayName[DSB_MAX_DISPLAYNAME_CHARS];
    CHAR            szIconLocation[MAX_PATH];
    INT             iIconResID;
} DSBITEMA, *PDSBITEMA;

#ifdef UNICODE
#define DSBITEM     DSBITEMW
#define PDSBITEM    PDSBITEMW
#else
#define DSBITEM     DSBITEMA
#define PDSBITEM    PDSBITEMA
#endif

// DSBITEM mask flags
#define DSBF_STATE              0x00000001
#define DSBF_ICONLOCATION       0x00000002
#define DSBF_DISPLAYNAME        0x00000004

// DSBITEM state flags
#define DSBS_CHECKED            0x00000001
#define DSBS_HIDDEN             0x00000002
#define DSBS_ROOT               0x00000004

//
// this message is sent to the callback to see if it wants to insert or modify 
// the item that is about to be inserted into the view.
//

#define DSBM_QUERYINSERTW       100 // lParam = PDSBITEMW (state, icon & name may be modified). Return TRUE if handled.
#define DSBM_QUERYINSERTA       101 // lParam = PDSBITEMA (state, icon & name may be modified). Return TRUE if handled.

#ifdef UNICODE
#define DSBM_QUERYINSERT DSBM_QUERYINSERTW
#else
#define DSBM_QUERYINSERT DSBM_QUERYINSERTA
#endif

//
// Called before we change the state of the icon (on tree collapse/expand)
//

#define DSBM_CHANGEIMAGESTATE   102 // lParam = adspath.  Return TRUE/FALSE top allow/disallow

//
// The dialog receives a WM_HELP
//

#define DSBM_HELP               103 // lParam == LPHELPINFO structure

//
// The dialog receives a WM_CONTEXTMENU, DSBID_xxx are the control ID's for this
// dialog so that you can display suitable help.
//

#define DSBM_CONTEXTMENU        104 // lParam == window handle to retrieve help for


//
// These are the control IDs for the controls in the dialog.   The callback can use
// these to modify the contents of the dialog as required.
//

#define DSBID_BANNER            256
#define DSBID_CONTAINERLIST     257

//
// API exported for browsing for containers.
//

STDAPI_(int) DsBrowseForContainerW(__inout PDSBROWSEINFOW pInfo);
STDAPI_(int) DsBrowseForContainerA(__inout PDSBROWSEINFOA pInfo);

#ifdef UNICODE
#define DsBrowseForContainer    DsBrowseForContainerW
#else
#define DsBrowseForContainer    DsBrowseForContainerA
#endif


// NOTE: these are here to keep old clients building - remove soon

STDAPI_(HICON) DsGetIcon(DWORD dwFlags, LPCWSTR pszObjectClass, INT cxImage, INT cyImage);
STDAPI DsGetFriendlyClassName(LPCWSTR pszObjectClass, __out_ecount(cchBuffer) LPWSTR pszBuffer, UINT cchBuffer);


#ifdef  __cplusplus
struct __declspec(uuid("1ab4a8c0-6a0b-11d2-ad49-00c04fa31a86")) IDsDisplaySpecifier;
#endif

#endif  // GUID_DEFS_ONLY
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\DShow.h ===
//------------------------------------------------------------------------------
// File: DShow.h
//
// Desc: DirectShow top-level include file
//
// Copyright (c) 2000-2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------

#ifndef __DSHOW_INCLUDED__
#define __DSHOW_INCLUDED__

///////////////////////////////////////////////////////////////////////////
// Set up constants & pragmas for the compiler
///////////////////////////////////////////////////////////////////////////
#ifdef  _MSC_VER
// disable some level-4 warnings, use #pragma warning(default:###) to re-enable
#pragma warning(disable:4100) // warning C4100: unreferenced formal parameter
#pragma warning(disable:4201) // warning C4201: nonstandard extension used : nameless struct/union
#pragma warning(disable:4511) // warning C4511: copy constructor could not be generated
#pragma warning(disable:4512) // warning C4512: assignment operator could not be generated
#pragma warning(disable:4514) // warning C4514: "unreferenced inline function has been removed"

#if _MSC_VER>=1100
#define AM_NOVTABLE __declspec(novtable)
#else
#define AM_NOVTABLE
#endif
#endif  // MSC_VER

///////////////////////////////////////////////////////////////////////////
// Include standard Windows files
///////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <windowsx.h>
#include <olectl.h>
#include <ddraw.h>
#include <mmsystem.h>

#ifndef NO_DSHOW_STRSAFE
#define NO_SHLWAPI_STRFCNS
#include <strsafe.h>  
#endif

#ifndef NUMELMS
   #define NUMELMS(aa) (sizeof(aa)/sizeof((aa)[0]))
#endif

///////////////////////////////////////////////////////////////////////////
// Include DirectShow include files
///////////////////////////////////////////////////////////////////////////
#include <strmif.h>     // Generated IDL header file for streams interfaces
#include <amvideo.h>    // ActiveMovie video interfaces and definitions

#ifdef DSHOW_USE_AMAUDIO
#include <amaudio.h>    // ActiveMovie audio interfaces and definitions
#endif

#include <control.h>    // generated from control.odl
#include <evcode.h>     // event code definitions
#include <uuids.h>      // declaration of type GUIDs and well-known clsids
#include <errors.h>     // HRESULT status and error definitions
#include <edevdefs.h>   // External device control interface defines
#include <audevcod.h>   // audio filter device error event codes
#include <dvdevcod.h>   // DVD error event codes

///////////////////////////////////////////////////////////////////////////
// Define OLE Automation constants
///////////////////////////////////////////////////////////////////////////
#ifndef OATRUE
#define OATRUE (-1)
#endif // OATRUE
#ifndef OAFALSE
#define OAFALSE (0)
#endif // OAFALSE

///////////////////////////////////////////////////////////////////////////
// Define Win64 interfaces if not already defined
///////////////////////////////////////////////////////////////////////////

// InterlockedExchangePointer
#ifndef InterlockedExchangePointer
#define InterlockedExchangePointer(Target, Value) \
   (PVOID)InterlockedExchange((PLONG)(Target), (LONG)(Value))
#endif 


#endif // __DSHOW_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dsound.h ===
/*==========================================================================;
 *
 *  Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 *  File:       dsound.h
 *  Content:    DirectSound include file
 *
 **************************************************************************/

#define COM_NO_WINDOWS_H
#include <objbase.h>
#include <float.h>
#include <sal.h>

#ifndef DIRECTSOUND_VERSION

#if (NTDDI_VERSION < NTDDI_WINXP) /* Windows 2000 */
#define DIRECTSOUND_VERSION 0x0700  /* Version 7.0 */
#elif (NTDDI_VERSION < NTDDI_WINXPSP2 || NTDDI_VERSION == NTDDI_WS03) /* Windows XP and SP1, or Windows Server 2003 */
#define DIRECTSOUND_VERSION 0x0800  /* Version 8.0 */
#else /* Windows XP SP2 and higher, Windows Server 2003 SP1 and higher, Longhorn, or higher */
#define DIRECTSOUND_VERSION 0x0900  /* Version 9.0 */
#endif

#endif // DIRECTSOUND_VERSION

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#ifndef __DSOUND_INCLUDED__
#define __DSOUND_INCLUDED__

/* Type definitions shared with Direct3D */

#ifndef DX_SHARED_DEFINES

typedef float D3DVALUE, *LPD3DVALUE;

#ifndef D3DCOLOR_DEFINED
typedef DWORD D3DCOLOR;
#define D3DCOLOR_DEFINED
#endif

#ifndef LPD3DCOLOR_DEFINED
typedef DWORD *LPD3DCOLOR;
#define LPD3DCOLOR_DEFINED
#endif

#ifndef D3DVECTOR_DEFINED
typedef struct _D3DVECTOR {
    float x;
    float y;
    float z;
} D3DVECTOR;
#define D3DVECTOR_DEFINED
#endif

#ifndef LPD3DVECTOR_DEFINED
typedef D3DVECTOR *LPD3DVECTOR;
#define LPD3DVECTOR_DEFINED
#endif

#define DX_SHARED_DEFINES
#endif // DX_SHARED_DEFINES

#define _FACDS  0x878   /* DirectSound's facility code */
#define MAKE_DSHRESULT(code)  MAKE_HRESULT(1, _FACDS, code)

// DirectSound Component GUID {47D4D946-62E8-11CF-93BC-444553540000}
DEFINE_GUID(CLSID_DirectSound, 0x47d4d946, 0x62e8, 0x11cf, 0x93, 0xbc, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

// DirectSound 8.0 Component GUID {3901CC3F-84B5-4FA4-BA35-AA8172B8A09B}
DEFINE_GUID(CLSID_DirectSound8, 0x3901cc3f, 0x84b5, 0x4fa4, 0xba, 0x35, 0xaa, 0x81, 0x72, 0xb8, 0xa0, 0x9b);

// DirectSound Capture Component GUID {B0210780-89CD-11D0-AF08-00A0C925CD16}
DEFINE_GUID(CLSID_DirectSoundCapture, 0xb0210780, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

// DirectSound 8.0 Capture Component GUID {E4BCAC13-7F99-4908-9A8E-74E3BF24B6E1}
DEFINE_GUID(CLSID_DirectSoundCapture8, 0xe4bcac13, 0x7f99, 0x4908, 0x9a, 0x8e, 0x74, 0xe3, 0xbf, 0x24, 0xb6, 0xe1);

// DirectSound Full Duplex Component GUID {FEA4300C-7959-4147-B26A-2377B9E7A91D}
DEFINE_GUID(CLSID_DirectSoundFullDuplex, 0xfea4300c, 0x7959, 0x4147, 0xb2, 0x6a, 0x23, 0x77, 0xb9, 0xe7, 0xa9, 0x1d);


// DirectSound default playback device GUID {DEF00000-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultPlayback, 0xdef00000, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);

// DirectSound default capture device GUID {DEF00001-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultCapture, 0xdef00001, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);

// DirectSound default device for voice playback {DEF00002-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultVoicePlayback, 0xdef00002, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);

// DirectSound default device for voice capture {DEF00003-9C6D-47ED-AAF1-4DDA8F2B5C03}
DEFINE_GUID(DSDEVID_DefaultVoiceCapture, 0xdef00003, 0x9c6d, 0x47ed, 0xaa, 0xf1, 0x4d, 0xda, 0x8f, 0x2b, 0x5c, 0x03);


//
// Forward declarations for interfaces.
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
//

#ifdef __cplusplus
struct IDirectSound;
struct IDirectSoundBuffer;
struct IDirectSound3DListener;
struct IDirectSound3DBuffer;
struct IDirectSoundCapture;
struct IDirectSoundCaptureBuffer;
struct IDirectSoundNotify;
#endif // __cplusplus

//
// DirectSound 8.0 interfaces.
//

#if DIRECTSOUND_VERSION >= 0x0800

#ifdef __cplusplus
struct IDirectSound8;
struct IDirectSoundBuffer8;
struct IDirectSoundCaptureBuffer8;
struct IDirectSoundFXGargle;
struct IDirectSoundFXChorus;
struct IDirectSoundFXFlanger;
struct IDirectSoundFXEcho;
struct IDirectSoundFXDistortion;
struct IDirectSoundFXCompressor;
struct IDirectSoundFXParamEq;
struct IDirectSoundFXWavesReverb;
struct IDirectSoundFXI3DL2Reverb;
struct IDirectSoundCaptureFXAec;
struct IDirectSoundCaptureFXNoiseSuppress;
struct IDirectSoundFullDuplex;
#endif // __cplusplus

// IDirectSound8, IDirectSoundBuffer8 and IDirectSoundCaptureBuffer8 are the
// only DirectSound 7.0 interfaces with changed functionality in version 8.0.
// The other level 8 interfaces as equivalent to their level 7 counterparts:

#define IDirectSoundCapture8            IDirectSoundCapture
#define IDirectSound3DListener8         IDirectSound3DListener
#define IDirectSound3DBuffer8           IDirectSound3DBuffer
#define IDirectSoundNotify8             IDirectSoundNotify
#define IDirectSoundFXGargle8           IDirectSoundFXGargle
#define IDirectSoundFXChorus8           IDirectSoundFXChorus
#define IDirectSoundFXFlanger8          IDirectSoundFXFlanger
#define IDirectSoundFXEcho8             IDirectSoundFXEcho
#define IDirectSoundFXDistortion8       IDirectSoundFXDistortion
#define IDirectSoundFXCompressor8       IDirectSoundFXCompressor
#define IDirectSoundFXParamEq8          IDirectSoundFXParamEq
#define IDirectSoundFXWavesReverb8      IDirectSoundFXWavesReverb
#define IDirectSoundFXI3DL2Reverb8      IDirectSoundFXI3DL2Reverb
#define IDirectSoundCaptureFXAec8       IDirectSoundCaptureFXAec
#define IDirectSoundCaptureFXNoiseSuppress8 IDirectSoundCaptureFXNoiseSuppress
#define IDirectSoundFullDuplex8         IDirectSoundFullDuplex

#endif // DIRECTSOUND_VERSION >= 0x0800

typedef struct IDirectSound                 *LPDIRECTSOUND;
typedef struct IDirectSoundBuffer           *LPDIRECTSOUNDBUFFER;
typedef struct IDirectSound3DListener       *LPDIRECTSOUND3DLISTENER;
typedef struct IDirectSound3DBuffer         *LPDIRECTSOUND3DBUFFER;
typedef struct IDirectSoundCapture          *LPDIRECTSOUNDCAPTURE;
typedef struct IDirectSoundCaptureBuffer    *LPDIRECTSOUNDCAPTUREBUFFER;
typedef struct IDirectSoundNotify           *LPDIRECTSOUNDNOTIFY;

#if DIRECTSOUND_VERSION >= 0x0800

typedef struct IDirectSoundFXGargle         *LPDIRECTSOUNDFXGARGLE;
typedef struct IDirectSoundFXChorus         *LPDIRECTSOUNDFXCHORUS;
typedef struct IDirectSoundFXFlanger        *LPDIRECTSOUNDFXFLANGER;
typedef struct IDirectSoundFXEcho           *LPDIRECTSOUNDFXECHO;
typedef struct IDirectSoundFXDistortion     *LPDIRECTSOUNDFXDISTORTION;
typedef struct IDirectSoundFXCompressor     *LPDIRECTSOUNDFXCOMPRESSOR;
typedef struct IDirectSoundFXParamEq        *LPDIRECTSOUNDFXPARAMEQ;
typedef struct IDirectSoundFXWavesReverb    *LPDIRECTSOUNDFXWAVESREVERB;
typedef struct IDirectSoundFXI3DL2Reverb    *LPDIRECTSOUNDFXI3DL2REVERB;
typedef struct IDirectSoundCaptureFXAec     *LPDIRECTSOUNDCAPTUREFXAEC;
typedef struct IDirectSoundCaptureFXNoiseSuppress *LPDIRECTSOUNDCAPTUREFXNOISESUPPRESS;
typedef struct IDirectSoundFullDuplex       *LPDIRECTSOUNDFULLDUPLEX;

typedef struct IDirectSound8                *LPDIRECTSOUND8;
typedef struct IDirectSoundBuffer8          *LPDIRECTSOUNDBUFFER8;
typedef struct IDirectSound3DListener8      *LPDIRECTSOUND3DLISTENER8;
typedef struct IDirectSound3DBuffer8        *LPDIRECTSOUND3DBUFFER8;
typedef struct IDirectSoundCapture8         *LPDIRECTSOUNDCAPTURE8;
typedef struct IDirectSoundCaptureBuffer8   *LPDIRECTSOUNDCAPTUREBUFFER8;
typedef struct IDirectSoundNotify8          *LPDIRECTSOUNDNOTIFY8;
typedef struct IDirectSoundFXGargle8        *LPDIRECTSOUNDFXGARGLE8;
typedef struct IDirectSoundFXChorus8        *LPDIRECTSOUNDFXCHORUS8;
typedef struct IDirectSoundFXFlanger8       *LPDIRECTSOUNDFXFLANGER8;
typedef struct IDirectSoundFXEcho8          *LPDIRECTSOUNDFXECHO8;
typedef struct IDirectSoundFXDistortion8    *LPDIRECTSOUNDFXDISTORTION8;
typedef struct IDirectSoundFXCompressor8    *LPDIRECTSOUNDFXCOMPRESSOR8;
typedef struct IDirectSoundFXParamEq8       *LPDIRECTSOUNDFXPARAMEQ8;
typedef struct IDirectSoundFXWavesReverb8   *LPDIRECTSOUNDFXWAVESREVERB8;
typedef struct IDirectSoundFXI3DL2Reverb8   *LPDIRECTSOUNDFXI3DL2REVERB8;
typedef struct IDirectSoundCaptureFXAec8    *LPDIRECTSOUNDCAPTUREFXAEC8;
typedef struct IDirectSoundCaptureFXNoiseSuppress8 *LPDIRECTSOUNDCAPTUREFXNOISESUPPRESS8;
typedef struct IDirectSoundFullDuplex8      *LPDIRECTSOUNDFULLDUPLEX8;

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IID definitions for the unchanged DirectSound 8.0 interfaces
//

#if DIRECTSOUND_VERSION >= 0x0800

#define IID_IDirectSoundCapture8            IID_IDirectSoundCapture
#define IID_IDirectSound3DListener8         IID_IDirectSound3DListener
#define IID_IDirectSound3DBuffer8           IID_IDirectSound3DBuffer
#define IID_IDirectSoundNotify8             IID_IDirectSoundNotify
#define IID_IDirectSoundFXGargle8           IID_IDirectSoundFXGargle
#define IID_IDirectSoundFXChorus8           IID_IDirectSoundFXChorus
#define IID_IDirectSoundFXFlanger8          IID_IDirectSoundFXFlanger
#define IID_IDirectSoundFXEcho8             IID_IDirectSoundFXEcho
#define IID_IDirectSoundFXDistortion8       IID_IDirectSoundFXDistortion
#define IID_IDirectSoundFXCompressor8       IID_IDirectSoundFXCompressor
#define IID_IDirectSoundFXParamEq8          IID_IDirectSoundFXParamEq
#define IID_IDirectSoundFXWavesReverb8      IID_IDirectSoundFXWavesReverb
#define IID_IDirectSoundFXI3DL2Reverb8      IID_IDirectSoundFXI3DL2Reverb
#define IID_IDirectSoundCaptureFXAec8       IID_IDirectSoundCaptureFXAec
#define IID_IDirectSoundCaptureFXNoiseSuppress8 IID_IDirectSoundCaptureFXNoiseSuppress
#define IID_IDirectSoundFullDuplex8         IID_IDirectSoundFullDuplex

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// Compatibility typedefs
//

#ifndef _LPCWAVEFORMATEX_DEFINED
#define _LPCWAVEFORMATEX_DEFINED
typedef const WAVEFORMATEX *LPCWAVEFORMATEX;
#endif // _LPCWAVEFORMATEX_DEFINED

#ifndef __LPCGUID_DEFINED__
#define __LPCGUID_DEFINED__
typedef const GUID *LPCGUID;
#endif // __LPCGUID_DEFINED__

typedef LPDIRECTSOUND *LPLPDIRECTSOUND;
typedef LPDIRECTSOUNDBUFFER *LPLPDIRECTSOUNDBUFFER;
typedef LPDIRECTSOUND3DLISTENER *LPLPDIRECTSOUND3DLISTENER;
typedef LPDIRECTSOUND3DBUFFER *LPLPDIRECTSOUND3DBUFFER;
typedef LPDIRECTSOUNDCAPTURE *LPLPDIRECTSOUNDCAPTURE;
typedef LPDIRECTSOUNDCAPTUREBUFFER *LPLPDIRECTSOUNDCAPTUREBUFFER;
typedef LPDIRECTSOUNDNOTIFY *LPLPDIRECTSOUNDNOTIFY;

#if DIRECTSOUND_VERSION >= 0x0800
typedef LPDIRECTSOUND8 *LPLPDIRECTSOUND8;
typedef LPDIRECTSOUNDBUFFER8 *LPLPDIRECTSOUNDBUFFER8;
typedef LPDIRECTSOUNDCAPTURE8 *LPLPDIRECTSOUNDCAPTURE8;
typedef LPDIRECTSOUNDCAPTUREBUFFER8 *LPLPDIRECTSOUNDCAPTUREBUFFER8;
#endif // DIRECTSOUND_VERSION >= 0x0800

//
// Structures
//

typedef struct _DSCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwMinSecondarySampleRate;
    DWORD           dwMaxSecondarySampleRate;
    DWORD           dwPrimaryBuffers;
    DWORD           dwMaxHwMixingAllBuffers;
    DWORD           dwMaxHwMixingStaticBuffers;
    DWORD           dwMaxHwMixingStreamingBuffers;
    DWORD           dwFreeHwMixingAllBuffers;
    DWORD           dwFreeHwMixingStaticBuffers;
    DWORD           dwFreeHwMixingStreamingBuffers;
    DWORD           dwMaxHw3DAllBuffers;
    DWORD           dwMaxHw3DStaticBuffers;
    DWORD           dwMaxHw3DStreamingBuffers;
    DWORD           dwFreeHw3DAllBuffers;
    DWORD           dwFreeHw3DStaticBuffers;
    DWORD           dwFreeHw3DStreamingBuffers;
    DWORD           dwTotalHwMemBytes;
    DWORD           dwFreeHwMemBytes;
    DWORD           dwMaxContigFreeHwMemBytes;
    DWORD           dwUnlockTransferRateHwBuffers;
    DWORD           dwPlayCpuOverheadSwBuffers;
    DWORD           dwReserved1;
    DWORD           dwReserved2;
} DSCAPS, *LPDSCAPS;

typedef const DSCAPS *LPCDSCAPS;

typedef struct _DSBCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwUnlockTransferRate;
    DWORD           dwPlayCpuOverhead;
} DSBCAPS, *LPDSBCAPS;

typedef const DSBCAPS *LPCDSBCAPS;

#if DIRECTSOUND_VERSION >= 0x0800

    typedef struct _DSEFFECTDESC
    {
        DWORD       dwSize;
        DWORD       dwFlags;
        GUID        guidDSFXClass;
        DWORD_PTR   dwReserved1;
        DWORD_PTR   dwReserved2;
    } DSEFFECTDESC, *LPDSEFFECTDESC;
    typedef const DSEFFECTDESC *LPCDSEFFECTDESC;

    #define DSFX_LOCHARDWARE    0x00000001
    #define DSFX_LOCSOFTWARE    0x00000002

    enum
    {
        DSFXR_PRESENT,          // 0
        DSFXR_LOCHARDWARE,      // 1
        DSFXR_LOCSOFTWARE,      // 2
        DSFXR_UNALLOCATED,      // 3
        DSFXR_FAILED,           // 4
        DSFXR_UNKNOWN,          // 5
        DSFXR_SENDLOOP          // 6
    };

    typedef struct _DSCEFFECTDESC
    {
        DWORD       dwSize;
        DWORD       dwFlags;
        GUID        guidDSCFXClass;
        GUID        guidDSCFXInstance;
        DWORD       dwReserved1;
        DWORD       dwReserved2;
    } DSCEFFECTDESC, *LPDSCEFFECTDESC;
    typedef const DSCEFFECTDESC *LPCDSCEFFECTDESC;

    #define DSCFX_LOCHARDWARE   0x00000001
    #define DSCFX_LOCSOFTWARE   0x00000002

    #define DSCFXR_LOCHARDWARE  0x00000010
    #define DSCFXR_LOCSOFTWARE  0x00000020

#endif // DIRECTSOUND_VERSION >= 0x0800

typedef struct _DSBUFFERDESC
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
#if DIRECTSOUND_VERSION >= 0x0700
    GUID            guid3DAlgorithm;
#endif
} DSBUFFERDESC, *LPDSBUFFERDESC;

typedef const DSBUFFERDESC *LPCDSBUFFERDESC;

// Older version of this structure:

typedef struct _DSBUFFERDESC1
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
} DSBUFFERDESC1, *LPDSBUFFERDESC1;

typedef const DSBUFFERDESC1 *LPCDSBUFFERDESC1;

typedef struct _DS3DBUFFER
{
    DWORD           dwSize;
    D3DVECTOR       vPosition;
    D3DVECTOR       vVelocity;
    DWORD           dwInsideConeAngle;
    DWORD           dwOutsideConeAngle;
    D3DVECTOR       vConeOrientation;
    LONG            lConeOutsideVolume;
    D3DVALUE        flMinDistance;
    D3DVALUE        flMaxDistance;
    DWORD           dwMode;
} DS3DBUFFER, *LPDS3DBUFFER;

typedef const DS3DBUFFER *LPCDS3DBUFFER;

typedef struct _DS3DLISTENER
{
    DWORD           dwSize;
    D3DVECTOR       vPosition;
    D3DVECTOR       vVelocity;
    D3DVECTOR       vOrientFront;
    D3DVECTOR       vOrientTop;
    D3DVALUE        flDistanceFactor;
    D3DVALUE        flRolloffFactor;
    D3DVALUE        flDopplerFactor;
} DS3DLISTENER, *LPDS3DLISTENER;

typedef const DS3DLISTENER *LPCDS3DLISTENER;

typedef struct _DSCCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwFormats;
    DWORD           dwChannels;
} DSCCAPS, *LPDSCCAPS;

typedef const DSCCAPS *LPCDSCCAPS;

typedef struct _DSCBUFFERDESC1
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
} DSCBUFFERDESC1, *LPDSCBUFFERDESC1;

typedef struct _DSCBUFFERDESC
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
#if DIRECTSOUND_VERSION >= 0x0800
    DWORD           dwFXCount;
    LPDSCEFFECTDESC lpDSCFXDesc;
#endif
} DSCBUFFERDESC, *LPDSCBUFFERDESC;

typedef const DSCBUFFERDESC *LPCDSCBUFFERDESC;

typedef struct _DSCBCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
} DSCBCAPS, *LPDSCBCAPS;

typedef const DSCBCAPS *LPCDSCBCAPS;

typedef struct _DSBPOSITIONNOTIFY
{
    DWORD           dwOffset;
    HANDLE          hEventNotify;
} DSBPOSITIONNOTIFY, *LPDSBPOSITIONNOTIFY;

typedef const DSBPOSITIONNOTIFY *LPCDSBPOSITIONNOTIFY;

//
// DirectSound API
//

typedef BOOL (CALLBACK *LPDSENUMCALLBACKA)(LPGUID, LPCSTR, LPCSTR, LPVOID);
typedef BOOL (CALLBACK *LPDSENUMCALLBACKW)(LPGUID, LPCWSTR, LPCWSTR, LPVOID);

extern HRESULT WINAPI DirectSoundCreate(__in_opt LPCGUID pcGuidDevice, __deref_out LPDIRECTSOUND *ppDS, __null LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundEnumerateA(__in LPDSENUMCALLBACKA pDSEnumCallback, __in_opt LPVOID pContext);
extern HRESULT WINAPI DirectSoundEnumerateW(__in LPDSENUMCALLBACKW pDSEnumCallback, __in_opt LPVOID pContext);

extern HRESULT WINAPI DirectSoundCaptureCreate(__in_opt LPCGUID pcGuidDevice, __deref_out LPDIRECTSOUNDCAPTURE *ppDSC, __null LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundCaptureEnumerateA(__in LPDSENUMCALLBACKA pDSEnumCallback, __in_opt LPVOID pContext);
extern HRESULT WINAPI DirectSoundCaptureEnumerateW(__in LPDSENUMCALLBACKW pDSEnumCallback, __in_opt LPVOID pContext);

#if DIRECTSOUND_VERSION >= 0x0800
extern HRESULT WINAPI DirectSoundCreate8(__in_opt LPCGUID pcGuidDevice, __deref_out LPDIRECTSOUND8 *ppDS8, __null LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundCaptureCreate8(__in_opt LPCGUID pcGuidDevice, __deref_out LPDIRECTSOUNDCAPTURE8 *ppDSC8, __null LPUNKNOWN pUnkOuter);
extern HRESULT WINAPI DirectSoundFullDuplexCreate
(
    __in_opt LPCGUID pcGuidCaptureDevice,
    __in_opt LPCGUID pcGuidRenderDevice,
    __in LPCDSCBUFFERDESC pcDSCBufferDesc,
    __in LPCDSBUFFERDESC pcDSBufferDesc,
    HWND hWnd,
    DWORD dwLevel,
    __deref_out LPDIRECTSOUNDFULLDUPLEX* ppDSFD,
    __deref_out LPDIRECTSOUNDCAPTUREBUFFER8 *ppDSCBuffer8,
    __deref_out LPDIRECTSOUNDBUFFER8 *ppDSBuffer8,
    __null LPUNKNOWN pUnkOuter
);
#define DirectSoundFullDuplexCreate8 DirectSoundFullDuplexCreate

extern HRESULT WINAPI GetDeviceID(__in_opt LPCGUID pGuidSrc, __out LPGUID pGuidDest);
#endif // DIRECTSOUND_VERSION >= 0x0800

#ifdef UNICODE
#define LPDSENUMCALLBACK            LPDSENUMCALLBACKW
#define DirectSoundEnumerate        DirectSoundEnumerateW
#define DirectSoundCaptureEnumerate DirectSoundCaptureEnumerateW
#else // UNICODE
#define LPDSENUMCALLBACK            LPDSENUMCALLBACKA
#define DirectSoundEnumerate        DirectSoundEnumerateA
#define DirectSoundCaptureEnumerate DirectSoundCaptureEnumerateA
#endif // UNICODE

//
// IUnknown
//

#if !defined(__cplusplus) || defined(CINTERFACE)
#ifndef IUnknown_QueryInterface
#define IUnknown_QueryInterface(p,a,b)  (p)->lpVtbl->QueryInterface(p,a,b)
#endif // IUnknown_QueryInterface
#ifndef IUnknown_AddRef
#define IUnknown_AddRef(p)              (p)->lpVtbl->AddRef(p)
#endif // IUnknown_AddRef
#ifndef IUnknown_Release
#define IUnknown_Release(p)             (p)->lpVtbl->Release(p)
#endif // IUnknown_Release
#else // !defined(__cplusplus) || defined(CINTERFACE)
#ifndef IUnknown_QueryInterface
#define IUnknown_QueryInterface(p,a,b)  (p)->QueryInterface(a,b)
#endif // IUnknown_QueryInterface
#ifndef IUnknown_AddRef
#define IUnknown_AddRef(p)              (p)->AddRef()
#endif // IUnknown_AddRef
#ifndef IUnknown_Release
#define IUnknown_Release(p)             (p)->Release()
#endif // IUnknown_Release
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#ifndef __IReferenceClock_INTERFACE_DEFINED__
#define __IReferenceClock_INTERFACE_DEFINED__

typedef LONGLONG REFERENCE_TIME;
typedef REFERENCE_TIME *LPREFERENCE_TIME;

DEFINE_GUID(IID_IReferenceClock, 0x56a86897, 0x0ad4, 0x11ce, 0xb0, 0x3a, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);

#undef INTERFACE
#define INTERFACE IReferenceClock

DECLARE_INTERFACE_(IReferenceClock, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ __in REFIID, __deref_out LPVOID*) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IReferenceClock methods
    STDMETHOD(GetTime)              (THIS_ __out REFERENCE_TIME *pTime) PURE;
    STDMETHOD(AdviseTime)           (THIS_ REFERENCE_TIME rtBaseTime, REFERENCE_TIME rtStreamTime,
                                           HANDLE hEvent, __out LPDWORD pdwAdviseCookie) PURE;
    STDMETHOD(AdvisePeriodic)       (THIS_ REFERENCE_TIME rtStartTime, REFERENCE_TIME rtPeriodTime,
                                           HANDLE hSemaphore, __out LPDWORD pdwAdviseCookie) PURE;
    STDMETHOD(Unadvise)             (THIS_ DWORD dwAdviseCookie) PURE;
};

#endif // __IReferenceClock_INTERFACE_DEFINED__

#ifndef IReferenceClock_QueryInterface

#define IReferenceClock_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IReferenceClock_AddRef(p)                  IUnknown_AddRef(p)
#define IReferenceClock_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IReferenceClock_GetTime(p,a)               (p)->lpVtbl->GetTime(p,a)
#define IReferenceClock_AdviseTime(p,a,b,c,d)      (p)->lpVtbl->AdviseTime(p,a,b,c,d)
#define IReferenceClock_AdvisePeriodic(p,a,b,c,d)  (p)->lpVtbl->AdvisePeriodic(p,a,b,c,d)
#define IReferenceClock_Unadvise(p,a)              (p)->lpVtbl->Unadvise(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IReferenceClock_GetTime(p,a)               (p)->GetTime(a)
#define IReferenceClock_AdviseTime(p,a,b,c,d)      (p)->AdviseTime(a,b,c,d)
#define IReferenceClock_AdvisePeriodic(p,a,b,c,d)  (p)->AdvisePeriodic(a,b,c,d)
#define IReferenceClock_Unadvise(p,a)              (p)->Unadvise(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // IReferenceClock_QueryInterface

//
// IDirectSound
//

DEFINE_GUID(IID_IDirectSound, 0x279AFA83, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound

DECLARE_INTERFACE_(IDirectSound, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ __in REFIID, __deref_out LPVOID*) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound methods
    STDMETHOD(CreateSoundBuffer)    (THIS_ __in LPCDSBUFFERDESC pcDSBufferDesc, __deref_out LPDIRECTSOUNDBUFFER *ppDSBuffer, __null LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(GetCaps)              (THIS_ __out LPDSCAPS pDSCaps) PURE;
    STDMETHOD(DuplicateSoundBuffer) (THIS_ __in LPDIRECTSOUNDBUFFER pDSBufferOriginal, __deref_out LPDIRECTSOUNDBUFFER *ppDSBufferDuplicate) PURE;
    STDMETHOD(SetCooperativeLevel)  (THIS_ HWND hwnd, DWORD dwLevel) PURE;
    STDMETHOD(Compact)              (THIS) PURE;
    STDMETHOD(GetSpeakerConfig)     (THIS_ __out LPDWORD pdwSpeakerConfig) PURE;
    STDMETHOD(SetSpeakerConfig)     (THIS_ DWORD dwSpeakerConfig) PURE;
    STDMETHOD(Initialize)           (THIS_ __in_opt LPCGUID pcGuidDevice) PURE;
};

#define IDirectSound_QueryInterface(p,a,b)       IUnknown_QueryInterface(p,a,b)
#define IDirectSound_AddRef(p)                   IUnknown_AddRef(p)
#define IDirectSound_Release(p)                  IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound_CreateSoundBuffer(p,a,b,c)  (p)->lpVtbl->CreateSoundBuffer(p,a,b,c)
#define IDirectSound_GetCaps(p,a)                (p)->lpVtbl->GetCaps(p,a)
#define IDirectSound_DuplicateSoundBuffer(p,a,b) (p)->lpVtbl->DuplicateSoundBuffer(p,a,b)
#define IDirectSound_SetCooperativeLevel(p,a,b)  (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectSound_Compact(p)                  (p)->lpVtbl->Compact(p)
#define IDirectSound_GetSpeakerConfig(p,a)       (p)->lpVtbl->GetSpeakerConfig(p,a)
#define IDirectSound_SetSpeakerConfig(p,b)       (p)->lpVtbl->SetSpeakerConfig(p,b)
#define IDirectSound_Initialize(p,a)             (p)->lpVtbl->Initialize(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound_CreateSoundBuffer(p,a,b,c)  (p)->CreateSoundBuffer(a,b,c)
#define IDirectSound_GetCaps(p,a)                (p)->GetCaps(a)
#define IDirectSound_DuplicateSoundBuffer(p,a,b) (p)->DuplicateSoundBuffer(a,b)
#define IDirectSound_SetCooperativeLevel(p,a,b)  (p)->SetCooperativeLevel(a,b)
#define IDirectSound_Compact(p)                  (p)->Compact()
#define IDirectSound_GetSpeakerConfig(p,a)       (p)->GetSpeakerConfig(a)
#define IDirectSound_SetSpeakerConfig(p,b)       (p)->SetSpeakerConfig(b)
#define IDirectSound_Initialize(p,a)             (p)->Initialize(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#if DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSound8
//

DEFINE_GUID(IID_IDirectSound8, 0xC50A7E93, 0xF395, 0x4834, 0x9E, 0xF6, 0x7F, 0xA9, 0x9D, 0xE5, 0x09, 0x66);

#undef INTERFACE
#define INTERFACE IDirectSound8

DECLARE_INTERFACE_(IDirectSound8, IDirectSound)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ __in REFIID, __deref_out LPVOID*) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound methods
    STDMETHOD(CreateSoundBuffer)    (THIS_ __in LPCDSBUFFERDESC pcDSBufferDesc, __out LPDIRECTSOUNDBUFFER *ppDSBuffer, __null LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(GetCaps)              (THIS_ __out LPDSCAPS pDSCaps) PURE;
    STDMETHOD(DuplicateSoundBuffer) (THIS_ __in LPDIRECTSOUNDBUFFER pDSBufferOriginal, __out LPDIRECTSOUNDBUFFER *ppDSBufferDuplicate) PURE;
    STDMETHOD(SetCooperativeLevel)  (THIS_ HWND hwnd, DWORD dwLevel) PURE;
    STDMETHOD(Compact)              (THIS) PURE;
    STDMETHOD(GetSpeakerConfig)     (THIS_ __out LPDWORD pdwSpeakerConfig) PURE;
    STDMETHOD(SetSpeakerConfig)     (THIS_ DWORD dwSpeakerConfig) PURE;
    STDMETHOD(Initialize)           (THIS_ __in_opt LPCGUID pcGuidDevice) PURE;

    // IDirectSound8 methods
    STDMETHOD(VerifyCertification)  (THIS_ __out LPDWORD pdwCertified) PURE;
};

#define IDirectSound8_QueryInterface(p,a,b)       IDirectSound_QueryInterface(p,a,b)
#define IDirectSound8_AddRef(p)                   IDirectSound_AddRef(p)
#define IDirectSound8_Release(p)                  IDirectSound_Release(p)
#define IDirectSound8_CreateSoundBuffer(p,a,b,c)  IDirectSound_CreateSoundBuffer(p,a,b,c)
#define IDirectSound8_GetCaps(p,a)                IDirectSound_GetCaps(p,a)
#define IDirectSound8_DuplicateSoundBuffer(p,a,b) IDirectSound_DuplicateSoundBuffer(p,a,b)
#define IDirectSound8_SetCooperativeLevel(p,a,b)  IDirectSound_SetCooperativeLevel(p,a,b)
#define IDirectSound8_Compact(p)                  IDirectSound_Compact(p)
#define IDirectSound8_GetSpeakerConfig(p,a)       IDirectSound_GetSpeakerConfig(p,a)
#define IDirectSound8_SetSpeakerConfig(p,a)       IDirectSound_SetSpeakerConfig(p,a)
#define IDirectSound8_Initialize(p,a)             IDirectSound_Initialize(p,a)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound8_VerifyCertification(p,a)           (p)->lpVtbl->VerifyCertification(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound8_VerifyCertification(p,a)           (p)->VerifyCertification(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundBuffer
//

DEFINE_GUID(IID_IDirectSoundBuffer, 0x279AFA85, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSoundBuffer

DECLARE_INTERFACE_(IDirectSoundBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ __in REFIID, __deref_out LPVOID*) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundBuffer methods
    STDMETHOD(GetCaps)              (THIS_ __out LPDSBCAPS pDSBufferCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ __out_opt LPDWORD pdwCurrentPlayCursor, __out_opt LPDWORD pdwCurrentWriteCursor) PURE;
    STDMETHOD(GetFormat)            (THIS_ __out_bcount_opt(dwSizeAllocated) LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, __out_opt LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetVolume)            (THIS_ __out LPLONG plVolume) PURE;
    STDMETHOD(GetPan)               (THIS_ __out LPLONG plPan) PURE;
    STDMETHOD(GetFrequency)         (THIS_ __out LPDWORD pdwFrequency) PURE;
    STDMETHOD(GetStatus)            (THIS_ __out LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ __in LPDIRECTSOUND pDirectSound, __in LPCDSBUFFERDESC pcDSBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes,
                                           __deref_out_bcount(*pdwAudioBytes1) LPVOID *ppvAudioPtr1, __out LPDWORD pdwAudioBytes1,
                                           __deref_opt_out_bcount(*pdwAudioBytes2) LPVOID *ppvAudioPtr2, __out_opt LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Play)                 (THIS_ DWORD dwReserved1, DWORD dwPriority, DWORD dwFlags) PURE;
    STDMETHOD(SetCurrentPosition)   (THIS_ DWORD dwNewPosition) PURE;
    STDMETHOD(SetFormat)            (THIS_ __in LPCWAVEFORMATEX pcfxFormat) PURE;
    STDMETHOD(SetVolume)            (THIS_ LONG lVolume) PURE;
    STDMETHOD(SetPan)               (THIS_ LONG lPan) PURE;
    STDMETHOD(SetFrequency)         (THIS_ DWORD dwFrequency) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ __in_bcount(dwAudioBytes1) LPVOID pvAudioPtr1, DWORD dwAudioBytes1,
                                           __in_bcount_opt(dwAudioBytes2) LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;
    STDMETHOD(Restore)              (THIS) PURE;
};

#define IDirectSoundBuffer_QueryInterface(p,a,b)        IUnknown_QueryInterface(p,a,b)
#define IDirectSoundBuffer_AddRef(p)                    IUnknown_AddRef(p)
#define IDirectSoundBuffer_Release(p)                   IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer_GetCaps(p,a)                 (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundBuffer_GetCurrentPosition(p,a,b)    (p)->lpVtbl->GetCurrentPosition(p,a,b)
#define IDirectSoundBuffer_GetFormat(p,a,b,c)           (p)->lpVtbl->GetFormat(p,a,b,c)
#define IDirectSoundBuffer_GetVolume(p,a)               (p)->lpVtbl->GetVolume(p,a)
#define IDirectSoundBuffer_GetPan(p,a)                  (p)->lpVtbl->GetPan(p,a)
#define IDirectSoundBuffer_GetFrequency(p,a)            (p)->lpVtbl->GetFrequency(p,a)
#define IDirectSoundBuffer_GetStatus(p,a)               (p)->lpVtbl->GetStatus(p,a)
#define IDirectSoundBuffer_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundBuffer_Play(p,a,b,c)                (p)->lpVtbl->Play(p,a,b,c)
#define IDirectSoundBuffer_SetCurrentPosition(p,a)      (p)->lpVtbl->SetCurrentPosition(p,a)
#define IDirectSoundBuffer_SetFormat(p,a)               (p)->lpVtbl->SetFormat(p,a)
#define IDirectSoundBuffer_SetVolume(p,a)               (p)->lpVtbl->SetVolume(p,a)
#define IDirectSoundBuffer_SetPan(p,a)                  (p)->lpVtbl->SetPan(p,a)
#define IDirectSoundBuffer_SetFrequency(p,a)            (p)->lpVtbl->SetFrequency(p,a)
#define IDirectSoundBuffer_Stop(p)                      (p)->lpVtbl->Stop(p)
#define IDirectSoundBuffer_Unlock(p,a,b,c,d)            (p)->lpVtbl->Unlock(p,a,b,c,d)
#define IDirectSoundBuffer_Restore(p)                   (p)->lpVtbl->Restore(p)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer_GetCaps(p,a)                 (p)->GetCaps(a)
#define IDirectSoundBuffer_GetCurrentPosition(p,a,b)    (p)->GetCurrentPosition(a,b)
#define IDirectSoundBuffer_GetFormat(p,a,b,c)           (p)->GetFormat(a,b,c)
#define IDirectSoundBuffer_GetVolume(p,a)               (p)->GetVolume(a)
#define IDirectSoundBuffer_GetPan(p,a)                  (p)->GetPan(a)
#define IDirectSoundBuffer_GetFrequency(p,a)            (p)->GetFrequency(a)
#define IDirectSoundBuffer_GetStatus(p,a)               (p)->GetStatus(a)
#define IDirectSoundBuffer_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->Lock(a,b,c,d,e,f,g)
#define IDirectSoundBuffer_Play(p,a,b,c)                (p)->Play(a,b,c)
#define IDirectSoundBuffer_SetCurrentPosition(p,a)      (p)->SetCurrentPosition(a)
#define IDirectSoundBuffer_SetFormat(p,a)               (p)->SetFormat(a)
#define IDirectSoundBuffer_SetVolume(p,a)               (p)->SetVolume(a)
#define IDirectSoundBuffer_SetPan(p,a)                  (p)->SetPan(a)
#define IDirectSoundBuffer_SetFrequency(p,a)            (p)->SetFrequency(a)
#define IDirectSoundBuffer_Stop(p)                      (p)->Stop()
#define IDirectSoundBuffer_Unlock(p,a,b,c,d)            (p)->Unlock(a,b,c,d)
#define IDirectSoundBuffer_Restore(p)                   (p)->Restore()
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#if DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundBuffer8
//

DEFINE_GUID(IID_IDirectSoundBuffer8, 0x6825a449, 0x7524, 0x4d82, 0x92, 0x0f, 0x50, 0xe3, 0x6a, 0xb3, 0xab, 0x1e);

#undef INTERFACE
#define INTERFACE IDirectSoundBuffer8

DECLARE_INTERFACE_(IDirectSoundBuffer8, IDirectSoundBuffer)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ __in REFIID, __deref_out LPVOID*) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundBuffer methods
    STDMETHOD(GetCaps)              (THIS_ __out LPDSBCAPS pDSBufferCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ __out_opt LPDWORD pdwCurrentPlayCursor, __out_opt LPDWORD pdwCurrentWriteCursor) PURE;
    STDMETHOD(GetFormat)            (THIS_ __out_bcount_opt(dwSizeAllocated) LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, __out_opt LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetVolume)            (THIS_ __out LPLONG plVolume) PURE;
    STDMETHOD(GetPan)               (THIS_ __out LPLONG plPan) PURE;
    STDMETHOD(GetFrequency)         (THIS_ __out LPDWORD pdwFrequency) PURE;
    STDMETHOD(GetStatus)            (THIS_ __out LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ __in LPDIRECTSOUND pDirectSound, __in LPCDSBUFFERDESC pcDSBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes,
                                           __deref_out_bcount(*pdwAudioBytes1) LPVOID *ppvAudioPtr1, __out LPDWORD pdwAudioBytes1,
                                           __deref_opt_out_bcount(*pdwAudioBytes2) LPVOID *ppvAudioPtr2, __out_opt LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Play)                 (THIS_ DWORD dwReserved1, DWORD dwPriority, DWORD dwFlags) PURE;
    STDMETHOD(SetCurrentPosition)   (THIS_ DWORD dwNewPosition) PURE;
    STDMETHOD(SetFormat)            (THIS_ __in LPCWAVEFORMATEX pcfxFormat) PURE;
    STDMETHOD(SetVolume)            (THIS_ LONG lVolume) PURE;
    STDMETHOD(SetPan)               (THIS_ LONG lPan) PURE;
    STDMETHOD(SetFrequency)         (THIS_ DWORD dwFrequency) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ __in_bcount(dwAudioBytes1) LPVOID pvAudioPtr1, DWORD dwAudioBytes1,
                                           __in_bcount_opt(dwAudioBytes2) LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;
    STDMETHOD(Restore)              (THIS) PURE;

    // IDirectSoundBuffer8 methods
    STDMETHOD(SetFX)                (THIS_ DWORD dwEffectsCount, __in_ecount_opt(dwEffectsCount) LPDSEFFECTDESC pDSFXDesc, __out_ecount_opt(dwEffectsCount) LPDWORD pdwResultCodes) PURE;
    STDMETHOD(AcquireResources)     (THIS_ DWORD dwFlags, DWORD dwEffectsCount, __out_ecount(dwEffectsCount) LPDWORD pdwResultCodes) PURE;
    STDMETHOD(GetObjectInPath)      (THIS_ __in REFGUID rguidObject, DWORD dwIndex, __in REFGUID rguidInterface, __deref_out LPVOID *ppObject) PURE;
};

// Special GUID meaning "select all objects" for use in GetObjectInPath()
DEFINE_GUID(GUID_All_Objects, 0xaa114de5, 0xc262, 0x4169, 0xa1, 0xc8, 0x23, 0xd6, 0x98, 0xcc, 0x73, 0xb5);

#define IDirectSoundBuffer8_QueryInterface(p,a,b)           IUnknown_QueryInterface(p,a,b)
#define IDirectSoundBuffer8_AddRef(p)                       IUnknown_AddRef(p)
#define IDirectSoundBuffer8_Release(p)                      IUnknown_Release(p)

#define IDirectSoundBuffer8_GetCaps(p,a)                    IDirectSoundBuffer_GetCaps(p,a)
#define IDirectSoundBuffer8_GetCurrentPosition(p,a,b)       IDirectSoundBuffer_GetCurrentPosition(p,a,b)
#define IDirectSoundBuffer8_GetFormat(p,a,b,c)              IDirectSoundBuffer_GetFormat(p,a,b,c)
#define IDirectSoundBuffer8_GetVolume(p,a)                  IDirectSoundBuffer_GetVolume(p,a)
#define IDirectSoundBuffer8_GetPan(p,a)                     IDirectSoundBuffer_GetPan(p,a)
#define IDirectSoundBuffer8_GetFrequency(p,a)               IDirectSoundBuffer_GetFrequency(p,a)
#define IDirectSoundBuffer8_GetStatus(p,a)                  IDirectSoundBuffer_GetStatus(p,a)
#define IDirectSoundBuffer8_Initialize(p,a,b)               IDirectSoundBuffer_Initialize(p,a,b)
#define IDirectSoundBuffer8_Lock(p,a,b,c,d,e,f,g)           IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundBuffer8_Play(p,a,b,c)                   IDirectSoundBuffer_Play(p,a,b,c)
#define IDirectSoundBuffer8_SetCurrentPosition(p,a)         IDirectSoundBuffer_SetCurrentPosition(p,a)
#define IDirectSoundBuffer8_SetFormat(p,a)                  IDirectSoundBuffer_SetFormat(p,a)
#define IDirectSoundBuffer8_SetVolume(p,a)                  IDirectSoundBuffer_SetVolume(p,a)
#define IDirectSoundBuffer8_SetPan(p,a)                     IDirectSoundBuffer_SetPan(p,a)
#define IDirectSoundBuffer8_SetFrequency(p,a)               IDirectSoundBuffer_SetFrequency(p,a)
#define IDirectSoundBuffer8_Stop(p)                         IDirectSoundBuffer_Stop(p)
#define IDirectSoundBuffer8_Unlock(p,a,b,c,d)               IDirectSoundBuffer_Unlock(p,a,b,c,d)
#define IDirectSoundBuffer8_Restore(p)                      IDirectSoundBuffer_Restore(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer8_SetFX(p,a,b,c)                  (p)->lpVtbl->SetFX(p,a,b,c)
#define IDirectSoundBuffer8_AcquireResources(p,a,b,c)       (p)->lpVtbl->AcquireResources(p,a,b,c)
#define IDirectSoundBuffer8_GetObjectInPath(p,a,b,c,d)      (p)->lpVtbl->GetObjectInPath(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer8_SetFX(p,a,b,c)                  (p)->SetFX(a,b,c)
#define IDirectSoundBuffer8_AcquireResources(p,a,b,c)       (p)->AcquireResources(a,b,c)
#define IDirectSoundBuffer8_GetObjectInPath(p,a,b,c,d)      (p)->GetObjectInPath(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSound3DListener
//

DEFINE_GUID(IID_IDirectSound3DListener, 0x279AFA84, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound3DListener

DECLARE_INTERFACE_(IDirectSound3DListener, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)           (THIS_ __in REFIID, __deref_out LPVOID*) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    // IDirectSound3DListener methods
    STDMETHOD(GetAllParameters)         (THIS_ __out LPDS3DLISTENER pListener) PURE;
    STDMETHOD(GetDistanceFactor)        (THIS_ __out D3DVALUE* pflDistanceFactor) PURE;
    STDMETHOD(GetDopplerFactor)         (THIS_ __out D3DVALUE* pflDopplerFactor) PURE;
    STDMETHOD(GetOrientation)           (THIS_ __out D3DVECTOR* pvOrientFront, __out D3DVECTOR* pvOrientTop) PURE;
    STDMETHOD(GetPosition)              (THIS_ __out D3DVECTOR* pvPosition) PURE;
    STDMETHOD(GetRolloffFactor)         (THIS_ __out D3DVALUE* pflRolloffFactor) PURE;
    STDMETHOD(GetVelocity)              (THIS_ __out D3DVECTOR* pvVelocity) PURE;
    STDMETHOD(SetAllParameters)         (THIS_ __in LPCDS3DLISTENER pcListener, DWORD dwApply) PURE;
    STDMETHOD(SetDistanceFactor)        (THIS_ D3DVALUE flDistanceFactor, DWORD dwApply) PURE;
    STDMETHOD(SetDopplerFactor)         (THIS_ D3DVALUE flDopplerFactor, DWORD dwApply) PURE;
    STDMETHOD(SetOrientation)           (THIS_ D3DVALUE xFront, D3DVALUE yFront, D3DVALUE zFront,
                                               D3DVALUE xTop, D3DVALUE yTop, D3DVALUE zTop, DWORD dwApply) PURE;
    STDMETHOD(SetPosition)              (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(SetRolloffFactor)         (THIS_ D3DVALUE flRolloffFactor, DWORD dwApply) PURE;
    STDMETHOD(SetVelocity)              (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(CommitDeferredSettings)   (THIS) PURE;
};

#define IDirectSound3DListener_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSound3DListener_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSound3DListener_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DListener_GetAllParameters(p,a)            (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSound3DListener_GetDistanceFactor(p,a)           (p)->lpVtbl->GetDistanceFactor(p,a)
#define IDirectSound3DListener_GetDopplerFactor(p,a)            (p)->lpVtbl->GetDopplerFactor(p,a)
#define IDirectSound3DListener_GetOrientation(p,a,b)            (p)->lpVtbl->GetOrientation(p,a,b)
#define IDirectSound3DListener_GetPosition(p,a)                 (p)->lpVtbl->GetPosition(p,a)
#define IDirectSound3DListener_GetRolloffFactor(p,a)            (p)->lpVtbl->GetRolloffFactor(p,a)
#define IDirectSound3DListener_GetVelocity(p,a)                 (p)->lpVtbl->GetVelocity(p,a)
#define IDirectSound3DListener_SetAllParameters(p,a,b)          (p)->lpVtbl->SetAllParameters(p,a,b)
#define IDirectSound3DListener_SetDistanceFactor(p,a,b)         (p)->lpVtbl->SetDistanceFactor(p,a,b)
#define IDirectSound3DListener_SetDopplerFactor(p,a,b)          (p)->lpVtbl->SetDopplerFactor(p,a,b)
#define IDirectSound3DListener_SetOrientation(p,a,b,c,d,e,f,g)  (p)->lpVtbl->SetOrientation(p,a,b,c,d,e,f,g)
#define IDirectSound3DListener_SetPosition(p,a,b,c,d)           (p)->lpVtbl->SetPosition(p,a,b,c,d)
#define IDirectSound3DListener_SetRolloffFactor(p,a,b)          (p)->lpVtbl->SetRolloffFactor(p,a,b)
#define IDirectSound3DListener_SetVelocity(p,a,b,c,d)           (p)->lpVtbl->SetVelocity(p,a,b,c,d)
#define IDirectSound3DListener_CommitDeferredSettings(p)        (p)->lpVtbl->CommitDeferredSettings(p)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DListener_GetAllParameters(p,a)            (p)->GetAllParameters(a)
#define IDirectSound3DListener_GetDistanceFactor(p,a)           (p)->GetDistanceFactor(a)
#define IDirectSound3DListener_GetDopplerFactor(p,a)            (p)->GetDopplerFactor(a)
#define IDirectSound3DListener_GetOrientation(p,a,b)            (p)->GetOrientation(a,b)
#define IDirectSound3DListener_GetPosition(p,a)                 (p)->GetPosition(a)
#define IDirectSound3DListener_GetRolloffFactor(p,a)            (p)->GetRolloffFactor(a)
#define IDirectSound3DListener_GetVelocity(p,a)                 (p)->GetVelocity(a)
#define IDirectSound3DListener_SetAllParameters(p,a,b)          (p)->SetAllParameters(a,b)
#define IDirectSound3DListener_SetDistanceFactor(p,a,b)         (p)->SetDistanceFactor(a,b)
#define IDirectSound3DListener_SetDopplerFactor(p,a,b)          (p)->SetDopplerFactor(a,b)
#define IDirectSound3DListener_SetOrientation(p,a,b,c,d,e,f,g)  (p)->SetOrientation(a,b,c,d,e,f,g)
#define IDirectSound3DListener_SetPosition(p,a,b,c,d)           (p)->SetPosition(a,b,c,d)
#define IDirectSound3DListener_SetRolloffFactor(p,a,b)          (p)->SetRolloffFactor(a,b)
#define IDirectSound3DListener_SetVelocity(p,a,b,c,d)           (p)->SetVelocity(a,b,c,d)
#define IDirectSound3DListener_CommitDeferredSettings(p)        (p)->CommitDeferredSettings()
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSound3DBuffer
//

DEFINE_GUID(IID_IDirectSound3DBuffer, 0x279AFA86, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound3DBuffer

DECLARE_INTERFACE_(IDirectSound3DBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ __in REFIID, __deref_out LPVOID*) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound3DBuffer methods
    STDMETHOD(GetAllParameters)     (THIS_ __out LPDS3DBUFFER pDs3dBuffer) PURE;
    STDMETHOD(GetConeAngles)        (THIS_ __out LPDWORD pdwInsideConeAngle, __out LPDWORD pdwOutsideConeAngle) PURE;
    STDMETHOD(GetConeOrientation)   (THIS_ __out D3DVECTOR* pvOrientation) PURE;
    STDMETHOD(GetConeOutsideVolume) (THIS_ __out LPLONG plConeOutsideVolume) PURE;
    STDMETHOD(GetMaxDistance)       (THIS_ __out D3DVALUE* pflMaxDistance) PURE;
    STDMETHOD(GetMinDistance)       (THIS_ __out D3DVALUE* pflMinDistance) PURE;
    STDMETHOD(GetMode)              (THIS_ __out LPDWORD pdwMode) PURE;
    STDMETHOD(GetPosition)          (THIS_ __out D3DVECTOR* pvPosition) PURE;
    STDMETHOD(GetVelocity)          (THIS_ __out D3DVECTOR* pvVelocity) PURE;
    STDMETHOD(SetAllParameters)     (THIS_ __in LPCDS3DBUFFER pcDs3dBuffer, DWORD dwApply) PURE;
    STDMETHOD(SetConeAngles)        (THIS_ DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwApply) PURE;
    STDMETHOD(SetConeOrientation)   (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(SetConeOutsideVolume) (THIS_ LONG lConeOutsideVolume, DWORD dwApply) PURE;
    STDMETHOD(SetMaxDistance)       (THIS_ D3DVALUE flMaxDistance, DWORD dwApply) PURE;
    STDMETHOD(SetMinDistance)       (THIS_ D3DVALUE flMinDistance, DWORD dwApply) PURE;
    STDMETHOD(SetMode)              (THIS_ DWORD dwMode, DWORD dwApply) PURE;
    STDMETHOD(SetPosition)          (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(SetVelocity)          (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
};

#define IDirectSound3DBuffer_QueryInterface(p,a,b)          IUnknown_QueryInterface(p,a,b)
#define IDirectSound3DBuffer_AddRef(p)                      IUnknown_AddRef(p)
#define IDirectSound3DBuffer_Release(p)                     IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBuffer_GetAllParameters(p,a)          (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSound3DBuffer_GetConeAngles(p,a,b)           (p)->lpVtbl->GetConeAngles(p,a,b)
#define IDirectSound3DBuffer_GetConeOrientation(p,a)        (p)->lpVtbl->GetConeOrientation(p,a)
#define IDirectSound3DBuffer_GetConeOutsideVolume(p,a)      (p)->lpVtbl->GetConeOutsideVolume(p,a)
#define IDirectSound3DBuffer_GetPosition(p,a)               (p)->lpVtbl->GetPosition(p,a)
#define IDirectSound3DBuffer_GetMinDistance(p,a)            (p)->lpVtbl->GetMinDistance(p,a)
#define IDirectSound3DBuffer_GetMaxDistance(p,a)            (p)->lpVtbl->GetMaxDistance(p,a)
#define IDirectSound3DBuffer_GetMode(p,a)                   (p)->lpVtbl->GetMode(p,a)
#define IDirectSound3DBuffer_GetVelocity(p,a)               (p)->lpVtbl->GetVelocity(p,a)
#define IDirectSound3DBuffer_SetAllParameters(p,a,b)        (p)->lpVtbl->SetAllParameters(p,a,b)
#define IDirectSound3DBuffer_SetConeAngles(p,a,b,c)         (p)->lpVtbl->SetConeAngles(p,a,b,c)
#define IDirectSound3DBuffer_SetConeOrientation(p,a,b,c,d)  (p)->lpVtbl->SetConeOrientation(p,a,b,c,d)
#define IDirectSound3DBuffer_SetConeOutsideVolume(p,a,b)    (p)->lpVtbl->SetConeOutsideVolume(p,a,b)
#define IDirectSound3DBuffer_SetPosition(p,a,b,c,d)         (p)->lpVtbl->SetPosition(p,a,b,c,d)
#define IDirectSound3DBuffer_SetMinDistance(p,a,b)          (p)->lpVtbl->SetMinDistance(p,a,b)
#define IDirectSound3DBuffer_SetMaxDistance(p,a,b)          (p)->lpVtbl->SetMaxDistance(p,a,b)
#define IDirectSound3DBuffer_SetMode(p,a,b)                 (p)->lpVtbl->SetMode(p,a,b)
#define IDirectSound3DBuffer_SetVelocity(p,a,b,c,d)         (p)->lpVtbl->SetVelocity(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBuffer_GetAllParameters(p,a)          (p)->GetAllParameters(a)
#define IDirectSound3DBuffer_GetConeAngles(p,a,b)           (p)->GetConeAngles(a,b)
#define IDirectSound3DBuffer_GetConeOrientation(p,a)        (p)->GetConeOrientation(a)
#define IDirectSound3DBuffer_GetConeOutsideVolume(p,a)      (p)->GetConeOutsideVolume(a)
#define IDirectSound3DBuffer_GetPosition(p,a)               (p)->GetPosition(a)
#define IDirectSound3DBuffer_GetMinDistance(p,a)            (p)->GetMinDistance(a)
#define IDirectSound3DBuffer_GetMaxDistance(p,a)            (p)->GetMaxDistance(a)
#define IDirectSound3DBuffer_GetMode(p,a)                   (p)->GetMode(a)
#define IDirectSound3DBuffer_GetVelocity(p,a)               (p)->GetVelocity(a)
#define IDirectSound3DBuffer_SetAllParameters(p,a,b)        (p)->SetAllParameters(a,b)
#define IDirectSound3DBuffer_SetConeAngles(p,a,b,c)         (p)->SetConeAngles(a,b,c)
#define IDirectSound3DBuffer_SetConeOrientation(p,a,b,c,d)  (p)->SetConeOrientation(a,b,c,d)
#define IDirectSound3DBuffer_SetConeOutsideVolume(p,a,b)    (p)->SetConeOutsideVolume(a,b)
#define IDirectSound3DBuffer_SetPosition(p,a,b,c,d)         (p)->SetPosition(a,b,c,d)
#define IDirectSound3DBuffer_SetMinDistance(p,a,b)          (p)->SetMinDistance(a,b)
#define IDirectSound3DBuffer_SetMaxDistance(p,a,b)          (p)->SetMaxDistance(a,b)
#define IDirectSound3DBuffer_SetMode(p,a,b)                 (p)->SetMode(a,b)
#define IDirectSound3DBuffer_SetVelocity(p,a,b,c,d)         (p)->SetVelocity(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCapture
//

DEFINE_GUID(IID_IDirectSoundCapture, 0xb0210781, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundCapture

DECLARE_INTERFACE_(IDirectSoundCapture, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ __in REFIID, __deref_out LPVOID*) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCapture methods
    STDMETHOD(CreateCaptureBuffer)  (THIS_ __in LPCDSCBUFFERDESC pcDSCBufferDesc, __deref_out LPDIRECTSOUNDCAPTUREBUFFER *ppDSCBuffer, __null LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(GetCaps)              (THIS_ __out LPDSCCAPS pDSCCaps) PURE;
    STDMETHOD(Initialize)           (THIS_ __in_opt LPCGUID pcGuidDevice) PURE;
};

#define IDirectSoundCapture_QueryInterface(p,a,b)           IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCapture_AddRef(p)                       IUnknown_AddRef(p)
#define IDirectSoundCapture_Release(p)                      IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCapture_CreateCaptureBuffer(p,a,b,c)    (p)->lpVtbl->CreateCaptureBuffer(p,a,b,c)
#define IDirectSoundCapture_GetCaps(p,a)                    (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundCapture_Initialize(p,a)                 (p)->lpVtbl->Initialize(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCapture_CreateCaptureBuffer(p,a,b,c)    (p)->CreateCaptureBuffer(a,b,c)
#define IDirectSoundCapture_GetCaps(p,a)                    (p)->GetCaps(a)
#define IDirectSoundCapture_Initialize(p,a)                 (p)->Initialize(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCaptureBuffer
//

DEFINE_GUID(IID_IDirectSoundCaptureBuffer, 0xb0210782, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureBuffer

DECLARE_INTERFACE_(IDirectSoundCaptureBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ __in REFIID, __deref_out LPVOID*) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureBuffer methods
    STDMETHOD(GetCaps)              (THIS_ __out LPDSCBCAPS pDSCBCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ __out_opt LPDWORD pdwCapturePosition, __out_opt LPDWORD pdwReadPosition) PURE;
    STDMETHOD(GetFormat)            (THIS_ __out_bcount_opt(dwSizeAllocated) LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, __out_opt LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetStatus)            (THIS_ __out LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ __in LPDIRECTSOUNDCAPTURE pDirectSoundCapture, __in LPCDSCBUFFERDESC pcDSCBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes,
                                           __deref_out_bcount(*pdwAudioBytes1) LPVOID *ppvAudioPtr1, __out LPDWORD pdwAudioBytes1,
                                           __deref_opt_out_bcount(*pdwAudioBytes2) LPVOID *ppvAudioPtr2, __out_opt LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Start)                (THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ __in_bcount(dwAudioBytes1) LPVOID pvAudioPtr1, DWORD dwAudioBytes1,
                                           __in_bcount_opt(dwAudioBytes2) LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;
};

#define IDirectSoundCaptureBuffer_QueryInterface(p,a,b)         IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureBuffer_AddRef(p)                     IUnknown_AddRef(p)
#define IDirectSoundCaptureBuffer_Release(p)                    IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer_GetCaps(p,a)                  (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)     (p)->lpVtbl->GetCurrentPosition(p,a,b)
#define IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)            (p)->lpVtbl->GetFormat(p,a,b,c)
#define IDirectSoundCaptureBuffer_GetStatus(p,a)                (p)->lpVtbl->GetStatus(p,a)
#define IDirectSoundCaptureBuffer_Initialize(p,a,b)             (p)->lpVtbl->Initialize(p,a,b)
#define IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)         (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer_Start(p,a)                    (p)->lpVtbl->Start(p,a)
#define IDirectSoundCaptureBuffer_Stop(p)                       (p)->lpVtbl->Stop(p)
#define IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)             (p)->lpVtbl->Unlock(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer_GetCaps(p,a)                  (p)->GetCaps(a)
#define IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)     (p)->GetCurrentPosition(a,b)
#define IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)            (p)->GetFormat(a,b,c)
#define IDirectSoundCaptureBuffer_GetStatus(p,a)                (p)->GetStatus(a)
#define IDirectSoundCaptureBuffer_Initialize(p,a,b)             (p)->Initialize(a,b)
#define IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)         (p)->Lock(a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer_Start(p,a)                    (p)->Start(a)
#define IDirectSoundCaptureBuffer_Stop(p)                       (p)->Stop()
#define IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)             (p)->Unlock(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#if DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundCaptureBuffer8
//

DEFINE_GUID(IID_IDirectSoundCaptureBuffer8, 0x990df4, 0xdbb, 0x4872, 0x83, 0x3e, 0x6d, 0x30, 0x3e, 0x80, 0xae, 0xb6);

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureBuffer8

DECLARE_INTERFACE_(IDirectSoundCaptureBuffer8, IDirectSoundCaptureBuffer)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ __in REFIID, __deref_out LPVOID*) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureBuffer methods
    STDMETHOD(GetCaps)              (THIS_ __out LPDSCBCAPS pDSCBCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ __out_opt LPDWORD pdwCapturePosition, __out_opt LPDWORD pdwReadPosition) PURE;
    STDMETHOD(GetFormat)            (THIS_ __out_bcount_opt(dwSizeAllocated) LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, __out_opt LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetStatus)            (THIS_ __out LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ __in LPDIRECTSOUNDCAPTURE pDirectSoundCapture, __in LPCDSCBUFFERDESC pcDSCBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes,
                                           __deref_out_bcount(*pdwAudioBytes1) LPVOID *ppvAudioPtr1, __out LPDWORD pdwAudioBytes1,
                                           __deref_opt_out_bcount(*pdwAudioBytes2) LPVOID *ppvAudioPtr2, __out_opt LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Start)                (THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ __in_bcount(dwAudioBytes1) LPVOID pvAudioPtr1, DWORD dwAudioBytes1,
                                           __in_bcount_opt(dwAudioBytes2) LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;

    // IDirectSoundCaptureBuffer8 methods
    STDMETHOD(GetObjectInPath)      (THIS_ __in REFGUID rguidObject, DWORD dwIndex, __in REFGUID rguidInterface, __deref_out LPVOID *ppObject) PURE;
    STDMETHOD(GetFXStatus)          (DWORD dwEffectsCount, __out_ecount(dwEffectsCount) LPDWORD pdwFXStatus) PURE;
};

#define IDirectSoundCaptureBuffer8_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureBuffer8_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundCaptureBuffer8_Release(p)                       IUnknown_Release(p)

#define IDirectSoundCaptureBuffer8_GetCaps(p,a)                     IDirectSoundCaptureBuffer_GetCaps(p,a)
#define IDirectSoundCaptureBuffer8_GetCurrentPosition(p,a,b)        IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)
#define IDirectSoundCaptureBuffer8_GetFormat(p,a,b,c)               IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)
#define IDirectSoundCaptureBuffer8_GetStatus(p,a)                   IDirectSoundCaptureBuffer_GetStatus(p,a)
#define IDirectSoundCaptureBuffer8_Initialize(p,a,b)                IDirectSoundCaptureBuffer_Initialize(p,a,b)
#define IDirectSoundCaptureBuffer8_Lock(p,a,b,c,d,e,f,g)            IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer8_Start(p,a)                       IDirectSoundCaptureBuffer_Start(p,a)
#define IDirectSoundCaptureBuffer8_Stop(p)                          IDirectSoundCaptureBuffer_Stop(p))
#define IDirectSoundCaptureBuffer8_Unlock(p,a,b,c,d)                IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer8_GetObjectInPath(p,a,b,c,d)       (p)->lpVtbl->GetObjectInPath(p,a,b,c,d)
#define IDirectSoundCaptureBuffer8_GetFXStatus(p,a,b)               (p)->lpVtbl->GetFXStatus(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer8_GetObjectInPath(p,a,b,c,d)       (p)->GetObjectInPath(a,b,c,d)
#define IDirectSoundCaptureBuffer8_GetFXStatus(p,a,b)               (p)->GetFXStatus(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundNotify
//

DEFINE_GUID(IID_IDirectSoundNotify, 0xb0210783, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundNotify

DECLARE_INTERFACE_(IDirectSoundNotify, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)           (THIS_ __in REFIID, __deref_out LPVOID*) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    // IDirectSoundNotify methods
    STDMETHOD(SetNotificationPositions) (THIS_ DWORD dwPositionNotifies, __in_ecount(dwPositionNotifies) LPCDSBPOSITIONNOTIFY pcPositionNotifies) PURE;
};

#define IDirectSoundNotify_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundNotify_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundNotify_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundNotify_SetNotificationPositions(p,a,b)  (p)->lpVtbl->SetNotificationPositions(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundNotify_SetNotificationPositions(p,a,b)  (p)->SetNotificationPositions(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IKsPropertySet
//

#ifndef _IKsPropertySet_
#define _IKsPropertySet_

#ifdef __cplusplus
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
struct IKsPropertySet;
#endif // __cplusplus

typedef struct IKsPropertySet *LPKSPROPERTYSET;

#define KSPROPERTY_SUPPORT_GET  0x00000001
#define KSPROPERTY_SUPPORT_SET  0x00000002

DEFINE_GUID(IID_IKsPropertySet, 0x31efac30, 0x515c, 0x11d0, 0xa9, 0xaa, 0x00, 0xaa, 0x00, 0x61, 0xbe, 0x93);

#undef INTERFACE
#define INTERFACE IKsPropertySet

DECLARE_INTERFACE_(IKsPropertySet, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)   (THIS_ __in REFIID, __deref_out LPVOID*) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // IKsPropertySet methods
    STDMETHOD(Get)              (THIS_ __in REFGUID rguidPropSet, ULONG ulId, __in_bcount(ulInstanceLength) LPVOID pInstanceData, ULONG ulInstanceLength,
                                       __out_bcount(ulDataLength) LPVOID pPropertyData, ULONG ulDataLength, __out PULONG pulBytesReturned) PURE;
    STDMETHOD(Set)              (THIS_ __in REFGUID rguidPropSet, ULONG ulId, __in_bcount(ulInstanceLength)  LPVOID pInstanceData, ULONG ulInstanceLength,
                                       __in_bcount(ulDataLength) LPVOID pPropertyData, ULONG ulDataLength) PURE;
    STDMETHOD(QuerySupport)     (THIS_ __in REFGUID rguidPropSet, ULONG ulId, __out PULONG pulTypeSupport) PURE;
};

#define IKsPropertySet_QueryInterface(p,a,b)       IUnknown_QueryInterface(p,a,b)
#define IKsPropertySet_AddRef(p)                   IUnknown_AddRef(p)
#define IKsPropertySet_Release(p)                  IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IKsPropertySet_Get(p,a,b,c,d,e,f,g)        (p)->lpVtbl->Get(p,a,b,c,d,e,f,g)
#define IKsPropertySet_Set(p,a,b,c,d,e,f)          (p)->lpVtbl->Set(p,a,b,c,d,e,f)
#define IKsPropertySet_QuerySupport(p,a,b,c)       (p)->lpVtbl->QuerySupport(p,a,b,c)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IKsPropertySet_Get(p,a,b,c,d,e,f,g)        (p)->Get(a,b,c,d,e,f,g)
#define IKsPropertySet_Set(p,a,b,c,d,e,f)          (p)->Set(a,b,c,d,e,f)
#define IKsPropertySet_QuerySupport(p,a,b,c)       (p)->QuerySupport(a,b,c)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // _IKsPropertySet_

#if DIRECTSOUND_VERSION >= 0x0800

//
// IDirectSoundFXGargle
//

DEFINE_GUID(IID_IDirectSoundFXGargle, 0xd616f352, 0xd622, 0x11ce, 0xaa, 0xc5, 0x00, 0x20, 0xaf, 0x0b, 0x99, 0xa3);

typedef struct _DSFXGargle
{
    DWORD       dwRateHz;               // Rate of modulation in hz
    DWORD       dwWaveShape;            // DSFXGARGLE_WAVE_xxx
} DSFXGargle, *LPDSFXGargle;

#define DSFXGARGLE_WAVE_TRIANGLE        0
#define DSFXGARGLE_WAVE_SQUARE          1

typedef const DSFXGargle *LPCDSFXGargle;

#define DSFXGARGLE_RATEHZ_MIN           1
#define DSFXGARGLE_RATEHZ_MAX           1000

#undef INTERFACE
#define INTERFACE IDirectSoundFXGargle

DECLARE_INTERFACE_(IDirectSoundFXGargle, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ __in REFIID, __deref_out LPVOID*) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXGargle methods
    STDMETHOD(SetAllParameters)     (THIS_ __in LPCDSFXGargle pcDsFxGargle) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ __out LPDSFXGargle pDsFxGargle) PURE;
};

#define IDirectSoundFXGargle_QueryInterface(p,a,b)          IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXGargle_AddRef(p)                      IUnknown_AddRef(p)
#define IDirectSoundFXGargle_Release(p)                     IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXGargle_SetAllParameters(p,a)          (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXGargle_GetAllParameters(p,a)          (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXGargle_SetAllParameters(p,a)          (p)->SetAllParameters(a)
#define IDirectSoundFXGargle_GetAllParameters(p,a)          (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXChorus
//

DEFINE_GUID(IID_IDirectSoundFXChorus, 0x880842e3, 0x145f, 0x43e6, 0xa9, 0x34, 0xa7, 0x18, 0x06, 0xe5, 0x05, 0x47);

typedef struct _DSFXChorus
{
    FLOAT       fWetDryMix;
    FLOAT       fDepth;
    FLOAT       fFeedback;
    FLOAT       fFrequency;
    LONG        lWaveform;          // LFO shape; DSFXCHORUS_WAVE_xxx
    FLOAT       fDelay;
    LONG        lPhase;
} DSFXChorus, *LPDSFXChorus;

typedef const DSFXChorus *LPCDSFXChorus;

#define DSFXCHORUS_WAVE_TRIANGLE        0
#define DSFXCHORUS_WAVE_SIN             1

#define DSFXCHORUS_WETDRYMIX_MIN        0.0f
#define DSFXCHORUS_WETDRYMIX_MAX        100.0f
#define DSFXCHORUS_DEPTH_MIN            0.0f
#define DSFXCHORUS_DEPTH_MAX            100.0f
#define DSFXCHORUS_FEEDBACK_MIN         -99.0f
#define DSFXCHORUS_FEEDBACK_MAX         99.0f
#define DSFXCHORUS_FREQUENCY_MIN        0.0f
#define DSFXCHORUS_FREQUENCY_MAX        10.0f
#define DSFXCHORUS_DELAY_MIN            0.0f
#define DSFXCHORUS_DELAY_MAX            20.0f
#define DSFXCHORUS_PHASE_MIN            0
#define DSFXCHORUS_PHASE_MAX            4

#define DSFXCHORUS_PHASE_NEG_180        0
#define DSFXCHORUS_PHASE_NEG_90         1
#define DSFXCHORUS_PHASE_ZERO           2
#define DSFXCHORUS_PHASE_90             3
#define DSFXCHORUS_PHASE_180            4

#undef INTERFACE
#define INTERFACE IDirectSoundFXChorus

DECLARE_INTERFACE_(IDirectSoundFXChorus, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ __in REFIID, __deref_out LPVOID*) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXChorus methods
    STDMETHOD(SetAllParameters)     (THIS_ __in LPCDSFXChorus pcDsFxChorus) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ __out LPDSFXChorus pDsFxChorus) PURE;
};

#define IDirectSoundFXChorus_QueryInterface(p,a,b)          IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXChorus_AddRef(p)                      IUnknown_AddRef(p)
#define IDirectSoundFXChorus_Release(p)                     IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXChorus_SetAllParameters(p,a)          (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXChorus_GetAllParameters(p,a)          (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXChorus_SetAllParameters(p,a)          (p)->SetAllParameters(a)
#define IDirectSoundFXChorus_GetAllParameters(p,a)          (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXFlanger
//

DEFINE_GUID(IID_IDirectSoundFXFlanger, 0x903e9878, 0x2c92, 0x4072, 0x9b, 0x2c, 0xea, 0x68, 0xf5, 0x39, 0x67, 0x83);

typedef struct _DSFXFlanger
{
    FLOAT       fWetDryMix;
    FLOAT       fDepth;
    FLOAT       fFeedback;
    FLOAT       fFrequency;
    LONG        lWaveform;
    FLOAT       fDelay;
    LONG        lPhase;
} DSFXFlanger, *LPDSFXFlanger;

typedef const DSFXFlanger *LPCDSFXFlanger;

#define DSFXFLANGER_WAVE_TRIANGLE       0
#define DSFXFLANGER_WAVE_SIN            1

#define DSFXFLANGER_WETDRYMIX_MIN       0.0f
#define DSFXFLANGER_WETDRYMIX_MAX       100.0f
#define DSFXFLANGER_FREQUENCY_MIN       0.0f
#define DSFXFLANGER_FREQUENCY_MAX       10.0f
#define DSFXFLANGER_DEPTH_MIN           0.0f
#define DSFXFLANGER_DEPTH_MAX           100.0f
#define DSFXFLANGER_PHASE_MIN           0
#define DSFXFLANGER_PHASE_MAX           4
#define DSFXFLANGER_FEEDBACK_MIN        -99.0f
#define DSFXFLANGER_FEEDBACK_MAX        99.0f
#define DSFXFLANGER_DELAY_MIN           0.0f
#define DSFXFLANGER_DELAY_MAX           4.0f

#define DSFXFLANGER_PHASE_NEG_180       0
#define DSFXFLANGER_PHASE_NEG_90        1
#define DSFXFLANGER_PHASE_ZERO          2
#define DSFXFLANGER_PHASE_90            3
#define DSFXFLANGER_PHASE_180           4

#undef INTERFACE
#define INTERFACE IDirectSoundFXFlanger

DECLARE_INTERFACE_(IDirectSoundFXFlanger, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ __in REFIID, __deref_out LPVOID*) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXFlanger methods
    STDMETHOD(SetAllParameters)     (THIS_ __in LPCDSFXFlanger pcDsFxFlanger) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ __out LPDSFXFlanger pDsFxFlanger) PURE;
};

#define IDirectSoundFXFlanger_QueryInterface(p,a,b)         IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXFlanger_AddRef(p)                     IUnknown_AddRef(p)
#define IDirectSoundFXFlanger_Release(p)                    IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXFlanger_SetAllParameters(p,a)         (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXFlanger_GetAllParameters(p,a)         (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXFlanger_SetAllParameters(p,a)         (p)->SetAllParameters(a)
#define IDirectSoundFXFlanger_GetAllParameters(p,a)         (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXEcho
//

DEFINE_GUID(IID_IDirectSoundFXEcho, 0x8bd28edf, 0x50db, 0x4e92, 0xa2, 0xbd, 0x44, 0x54, 0x88, 0xd1, 0xed, 0x42);

typedef struct _DSFXEcho
{
    FLOAT   fWetDryMix;
    FLOAT   fFeedback;
    FLOAT   fLeftDelay;
    FLOAT   fRightDelay;
    LONG    lPanDelay;
} DSFXEcho, *LPDSFXEcho;

typedef const DSFXEcho *LPCDSFXEcho;

#define DSFXECHO_WETDRYMIX_MIN      0.0f
#define DSFXECHO_WETDRYMIX_MAX      100.0f
#define DSFXECHO_FEEDBACK_MIN       0.0f
#define DSFXECHO_FEEDBACK_MAX       100.0f
#define DSFXECHO_LEFTDELAY_MIN      1.0f
#define DSFXECHO_LEFTDELAY_MAX      2000.0f
#define DSFXECHO_RIGHTDELAY_MIN     1.0f
#define DSFXECHO_RIGHTDELAY_MAX     2000.0f
#define DSFXECHO_PANDELAY_MIN       0
#define DSFXECHO_PANDELAY_MAX       1

#undef INTERFACE
#define INTERFACE IDirectSoundFXEcho

DECLARE_INTERFACE_(IDirectSoundFXEcho, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ __in REFIID, __deref_out LPVOID*) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXEcho methods
    STDMETHOD(SetAllParameters)     (THIS_ __in LPCDSFXEcho pcDsFxEcho) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ __out LPDSFXEcho pDsFxEcho) PURE;
};

#define IDirectSoundFXEcho_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXEcho_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundFXEcho_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXEcho_SetAllParameters(p,a)            (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXEcho_GetAllParameters(p,a)            (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXEcho_SetAllParameters(p,a)            (p)->SetAllParameters(a)
#define IDirectSoundFXEcho_GetAllParameters(p,a)            (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXDistortion
//

DEFINE_GUID(IID_IDirectSoundFXDistortion, 0x8ecf4326, 0x455f, 0x4d8b, 0xbd, 0xa9, 0x8d, 0x5d, 0x3e, 0x9e, 0x3e, 0x0b);

typedef struct _DSFXDistortion
{
    FLOAT   fGain;
    FLOAT   fEdge;
    FLOAT   fPostEQCenterFrequency;
    FLOAT   fPostEQBandwidth;
    FLOAT   fPreLowpassCutoff;
} DSFXDistortion, *LPDSFXDistortion;

typedef const DSFXDistortion *LPCDSFXDistortion;

#define DSFXDISTORTION_GAIN_MIN                     -60.0f
#define DSFXDISTORTION_GAIN_MAX                     0.0f
#define DSFXDISTORTION_EDGE_MIN                     0.0f
#define DSFXDISTORTION_EDGE_MAX                     100.0f
#define DSFXDISTORTION_POSTEQCENTERFREQUENCY_MIN    100.0f
#define DSFXDISTORTION_POSTEQCENTERFREQUENCY_MAX    8000.0f
#define DSFXDISTORTION_POSTEQBANDWIDTH_MIN          100.0f
#define DSFXDISTORTION_POSTEQBANDWIDTH_MAX          8000.0f
#define DSFXDISTORTION_PRELOWPASSCUTOFF_MIN         100.0f
#define DSFXDISTORTION_PRELOWPASSCUTOFF_MAX         8000.0f

#undef INTERFACE
#define INTERFACE IDirectSoundFXDistortion

DECLARE_INTERFACE_(IDirectSoundFXDistortion, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ __in REFIID, __deref_out LPVOID*) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXDistortion methods
    STDMETHOD(SetAllParameters)     (THIS_ __in LPCDSFXDistortion pcDsFxDistortion) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ __out LPDSFXDistortion pDsFxDistortion) PURE;
};

#define IDirectSoundFXDistortion_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXDistortion_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundFXDistortion_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXDistortion_SetAllParameters(p,a)      (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXDistortion_GetAllParameters(p,a)      (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXDistortion_SetAllParameters(p,a)      (p)->SetAllParameters(a)
#define IDirectSoundFXDistortion_GetAllParameters(p,a)      (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXCompressor
//

DEFINE_GUID(IID_IDirectSoundFXCompressor, 0x4bbd1154, 0x62f6, 0x4e2c, 0xa1, 0x5c, 0xd3, 0xb6, 0xc4, 0x17, 0xf7, 0xa0);

typedef struct _DSFXCompressor
{
    FLOAT   fGain;
    FLOAT   fAttack;
    FLOAT   fRelease;
    FLOAT   fThreshold;
    FLOAT   fRatio;
    FLOAT   fPredelay;
} DSFXCompressor, *LPDSFXCompressor;

typedef const DSFXCompressor *LPCDSFXCompressor;

#define DSFXCOMPRESSOR_GAIN_MIN             -60.0f
#define DSFXCOMPRESSOR_GAIN_MAX             60.0f
#define DSFXCOMPRESSOR_ATTACK_MIN           0.01f
#define DSFXCOMPRESSOR_ATTACK_MAX           500.0f
#define DSFXCOMPRESSOR_RELEASE_MIN          50.0f
#define DSFXCOMPRESSOR_RELEASE_MAX          3000.0f
#define DSFXCOMPRESSOR_THRESHOLD_MIN        -60.0f
#define DSFXCOMPRESSOR_THRESHOLD_MAX        0.0f
#define DSFXCOMPRESSOR_RATIO_MIN            1.0f
#define DSFXCOMPRESSOR_RATIO_MAX            100.0f
#define DSFXCOMPRESSOR_PREDELAY_MIN         0.0f
#define DSFXCOMPRESSOR_PREDELAY_MAX         4.0f

#undef INTERFACE
#define INTERFACE IDirectSoundFXCompressor

DECLARE_INTERFACE_(IDirectSoundFXCompressor, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ __in REFIID, __deref_out LPVOID*) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXCompressor methods
    STDMETHOD(SetAllParameters)     (THIS_ __in LPCDSFXCompressor pcDsFxCompressor) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ __out LPDSFXCompressor pDsFxCompressor) PURE;
};

#define IDirectSoundFXCompressor_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXCompressor_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundFXCompressor_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXCompressor_SetAllParameters(p,a)      (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXCompressor_GetAllParameters(p,a)      (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXCompressor_SetAllParameters(p,a)      (p)->SetAllParameters(a)
#define IDirectSoundFXCompressor_GetAllParameters(p,a)      (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXParamEq
//

DEFINE_GUID(IID_IDirectSoundFXParamEq, 0xc03ca9fe, 0xfe90, 0x4204, 0x80, 0x78, 0x82, 0x33, 0x4c, 0xd1, 0x77, 0xda);

typedef struct _DSFXParamEq
{
    FLOAT   fCenter;
    FLOAT   fBandwidth;
    FLOAT   fGain;
} DSFXParamEq, *LPDSFXParamEq;

typedef const DSFXParamEq *LPCDSFXParamEq;

#define DSFXPARAMEQ_CENTER_MIN      80.0f
#define DSFXPARAMEQ_CENTER_MAX      16000.0f
#define DSFXPARAMEQ_BANDWIDTH_MIN   1.0f
#define DSFXPARAMEQ_BANDWIDTH_MAX   36.0f
#define DSFXPARAMEQ_GAIN_MIN        -15.0f
#define DSFXPARAMEQ_GAIN_MAX        15.0f

#undef INTERFACE
#define INTERFACE IDirectSoundFXParamEq

DECLARE_INTERFACE_(IDirectSoundFXParamEq, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ __in REFIID, __deref_out LPVOID*) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXParamEq methods
    STDMETHOD(SetAllParameters)     (THIS_ __in LPCDSFXParamEq pcDsFxParamEq) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ __out LPDSFXParamEq pDsFxParamEq) PURE;
};

#define IDirectSoundFXParamEq_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXParamEq_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundFXParamEq_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXParamEq_SetAllParameters(p,a)      (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXParamEq_GetAllParameters(p,a)      (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXParamEq_SetAllParameters(p,a)      (p)->SetAllParameters(a)
#define IDirectSoundFXParamEq_GetAllParameters(p,a)      (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXI3DL2Reverb
//

DEFINE_GUID(IID_IDirectSoundFXI3DL2Reverb, 0x4b166a6a, 0x0d66, 0x43f3, 0x80, 0xe3, 0xee, 0x62, 0x80, 0xde, 0xe1, 0xa4);

typedef struct _DSFXI3DL2Reverb
{
    LONG    lRoom;                  // [-10000, 0]      default: -1000 mB
    LONG    lRoomHF;                // [-10000, 0]      default: 0 mB
    FLOAT   flRoomRolloffFactor;    // [0.0, 10.0]      default: 0.0
    FLOAT   flDecayTime;            // [0.1, 20.0]      default: 1.49s
    FLOAT   flDecayHFRatio;         // [0.1, 2.0]       default: 0.83
    LONG    lReflections;           // [-10000, 1000]   default: -2602 mB
    FLOAT   flReflectionsDelay;     // [0.0, 0.3]       default: 0.007 s
    LONG    lReverb;                // [-10000, 2000]   default: 200 mB
    FLOAT   flReverbDelay;          // [0.0, 0.1]       default: 0.011 s
    FLOAT   flDiffusion;            // [0.0, 100.0]     default: 100.0 %
    FLOAT   flDensity;              // [0.0, 100.0]     default: 100.0 %
    FLOAT   flHFReference;          // [20.0, 20000.0]  default: 5000.0 Hz
} DSFXI3DL2Reverb, *LPDSFXI3DL2Reverb;

typedef const DSFXI3DL2Reverb *LPCDSFXI3DL2Reverb;

#define DSFX_I3DL2REVERB_ROOM_MIN                   (-10000)
#define DSFX_I3DL2REVERB_ROOM_MAX                   0
#define DSFX_I3DL2REVERB_ROOM_DEFAULT               (-1000)

#define DSFX_I3DL2REVERB_ROOMHF_MIN                 (-10000)
#define DSFX_I3DL2REVERB_ROOMHF_MAX                 0
#define DSFX_I3DL2REVERB_ROOMHF_DEFAULT             (-100)

#define DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_MIN      0.0f
#define DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_MAX      10.0f
#define DSFX_I3DL2REVERB_ROOMROLLOFFFACTOR_DEFAULT  0.0f

#define DSFX_I3DL2REVERB_DECAYTIME_MIN              0.1f
#define DSFX_I3DL2REVERB_DECAYTIME_MAX              20.0f
#define DSFX_I3DL2REVERB_DECAYTIME_DEFAULT          1.49f

#define DSFX_I3DL2REVERB_DECAYHFRATIO_MIN           0.1f
#define DSFX_I3DL2REVERB_DECAYHFRATIO_MAX           2.0f
#define DSFX_I3DL2REVERB_DECAYHFRATIO_DEFAULT       0.83f

#define DSFX_I3DL2REVERB_REFLECTIONS_MIN            (-10000)
#define DSFX_I3DL2REVERB_REFLECTIONS_MAX            1000
#define DSFX_I3DL2REVERB_REFLECTIONS_DEFAULT        (-2602)

#define DSFX_I3DL2REVERB_REFLECTIONSDELAY_MIN       0.0f
#define DSFX_I3DL2REVERB_REFLECTIONSDELAY_MAX       0.3f
#define DSFX_I3DL2REVERB_REFLECTIONSDELAY_DEFAULT   0.007f

#define DSFX_I3DL2REVERB_REVERB_MIN                 (-10000)
#define DSFX_I3DL2REVERB_REVERB_MAX                 2000
#define DSFX_I3DL2REVERB_REVERB_DEFAULT             (200)

#define DSFX_I3DL2REVERB_REVERBDELAY_MIN            0.0f
#define DSFX_I3DL2REVERB_REVERBDELAY_MAX            0.1f
#define DSFX_I3DL2REVERB_REVERBDELAY_DEFAULT        0.011f

#define DSFX_I3DL2REVERB_DIFFUSION_MIN              0.0f
#define DSFX_I3DL2REVERB_DIFFUSION_MAX              100.0f
#define DSFX_I3DL2REVERB_DIFFUSION_DEFAULT          100.0f

#define DSFX_I3DL2REVERB_DENSITY_MIN                0.0f
#define DSFX_I3DL2REVERB_DENSITY_MAX                100.0f
#define DSFX_I3DL2REVERB_DENSITY_DEFAULT            100.0f

#define DSFX_I3DL2REVERB_HFREFERENCE_MIN            20.0f
#define DSFX_I3DL2REVERB_HFREFERENCE_MAX            20000.0f
#define DSFX_I3DL2REVERB_HFREFERENCE_DEFAULT        5000.0f

#define DSFX_I3DL2REVERB_QUALITY_MIN                0
#define DSFX_I3DL2REVERB_QUALITY_MAX                3
#define DSFX_I3DL2REVERB_QUALITY_DEFAULT            2

#undef INTERFACE
#define INTERFACE IDirectSoundFXI3DL2Reverb

DECLARE_INTERFACE_(IDirectSoundFXI3DL2Reverb, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ __in REFIID, __deref_out LPVOID*) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXI3DL2Reverb methods
    STDMETHOD(SetAllParameters)     (THIS_ __in LPCDSFXI3DL2Reverb pcDsFxI3DL2Reverb) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ __out LPDSFXI3DL2Reverb pDsFxI3DL2Reverb) PURE;
    STDMETHOD(SetPreset)            (THIS_ DWORD dwPreset) PURE;
    STDMETHOD(GetPreset)            (THIS_ __out LPDWORD pdwPreset) PURE;
    STDMETHOD(SetQuality)           (THIS_ LONG lQuality) PURE;
    STDMETHOD(GetQuality)           (THIS_ __out LONG *plQuality) PURE;
};

#define IDirectSoundFXI3DL2Reverb_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXI3DL2Reverb_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundFXI3DL2Reverb_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2Reverb_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXI3DL2Reverb_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSoundFXI3DL2Reverb_SetPreset(p,a)            (p)->lpVtbl->SetPreset(p,a)
#define IDirectSoundFXI3DL2Reverb_GetPreset(p,a)            (p)->lpVtbl->GetPreset(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXI3DL2Reverb_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundFXI3DL2Reverb_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#define IDirectSoundFXI3DL2Reverb_SetPreset(p,a)            (p)->SetPreset(a)
#define IDirectSoundFXI3DL2Reverb_GetPreset(p,a)            (p)->GetPreset(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundFXWavesReverb
//

DEFINE_GUID(IID_IDirectSoundFXWavesReverb,0x46858c3a,0x0dc6,0x45e3,0xb7,0x60,0xd4,0xee,0xf1,0x6c,0xb3,0x25);

typedef struct _DSFXWavesReverb
{
    FLOAT   fInGain;                // [-96.0,0.0]            default: 0.0 dB
    FLOAT   fReverbMix;             // [-96.0,0.0]            default: 0.0 db
    FLOAT   fReverbTime;            // [0.001,3000.0]         default: 1000.0 ms
    FLOAT   fHighFreqRTRatio;       // [0.001,0.999]          default: 0.001
} DSFXWavesReverb, *LPDSFXWavesReverb;

typedef const DSFXWavesReverb *LPCDSFXWavesReverb;

#define DSFX_WAVESREVERB_INGAIN_MIN                 -96.0f
#define DSFX_WAVESREVERB_INGAIN_MAX                 0.0f
#define DSFX_WAVESREVERB_INGAIN_DEFAULT             0.0f
#define DSFX_WAVESREVERB_REVERBMIX_MIN              -96.0f
#define DSFX_WAVESREVERB_REVERBMIX_MAX              0.0f
#define DSFX_WAVESREVERB_REVERBMIX_DEFAULT          0.0f
#define DSFX_WAVESREVERB_REVERBTIME_MIN             0.001f
#define DSFX_WAVESREVERB_REVERBTIME_MAX             3000.0f
#define DSFX_WAVESREVERB_REVERBTIME_DEFAULT         1000.0f
#define DSFX_WAVESREVERB_HIGHFREQRTRATIO_MIN        0.001f
#define DSFX_WAVESREVERB_HIGHFREQRTRATIO_MAX        0.999f
#define DSFX_WAVESREVERB_HIGHFREQRTRATIO_DEFAULT    0.001f

#undef INTERFACE
#define INTERFACE IDirectSoundFXWavesReverb

DECLARE_INTERFACE_(IDirectSoundFXWavesReverb, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ __in REFIID, __deref_out LPVOID*) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundFXWavesReverb methods
    STDMETHOD(SetAllParameters)     (THIS_ __in LPCDSFXWavesReverb pcDsFxWavesReverb) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ __out LPDSFXWavesReverb pDsFxWavesReverb) PURE;
};

#define IDirectSoundFXWavesReverb_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFXWavesReverb_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundFXWavesReverb_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXWavesReverb_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundFXWavesReverb_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFXWavesReverb_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundFXWavesReverb_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCaptureFXAec
//

DEFINE_GUID(IID_IDirectSoundCaptureFXAec, 0xad74143d, 0x903d, 0x4ab7, 0x80, 0x66, 0x28, 0xd3, 0x63, 0x03, 0x6d, 0x65);

typedef struct _DSCFXAec
{
    BOOL    fEnable;
    BOOL    fNoiseFill;
    DWORD   dwMode;
} DSCFXAec, *LPDSCFXAec;

typedef const DSCFXAec *LPCDSCFXAec;

// These match the AEC_MODE_* constants in the DDK's ksmedia.h file
#define DSCFX_AEC_MODE_PASS_THROUGH                     0x0
#define DSCFX_AEC_MODE_HALF_DUPLEX                      0x1
#define DSCFX_AEC_MODE_FULL_DUPLEX                      0x2

// These match the AEC_STATUS_* constants in ksmedia.h
#define DSCFX_AEC_STATUS_HISTORY_UNINITIALIZED          0x0
#define DSCFX_AEC_STATUS_HISTORY_CONTINUOUSLY_CONVERGED 0x1
#define DSCFX_AEC_STATUS_HISTORY_PREVIOUSLY_DIVERGED    0x2
#define DSCFX_AEC_STATUS_CURRENTLY_CONVERGED            0x8

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureFXAec

DECLARE_INTERFACE_(IDirectSoundCaptureFXAec, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ __in REFIID, __deref_out LPVOID*) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureFXAec methods
    STDMETHOD(SetAllParameters)     (THIS_ __in LPCDSCFXAec pDscFxAec) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ __out LPDSCFXAec pDscFxAec) PURE;
    STDMETHOD(GetStatus)            (THIS_ __out LPDWORD pdwStatus) PURE;
    STDMETHOD(Reset)                (THIS) PURE;
};

#define IDirectSoundCaptureFXAec_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureFXAec_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundCaptureFXAec_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXAec_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundCaptureFXAec_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXAec_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundCaptureFXAec_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)


//
// IDirectSoundCaptureFXNoiseSuppress
//

DEFINE_GUID(IID_IDirectSoundCaptureFXNoiseSuppress, 0xed311e41, 0xfbae, 0x4175, 0x96, 0x25, 0xcd, 0x8, 0x54, 0xf6, 0x93, 0xca);

typedef struct _DSCFXNoiseSuppress
{
    BOOL    fEnable;
} DSCFXNoiseSuppress, *LPDSCFXNoiseSuppress;

typedef const DSCFXNoiseSuppress *LPCDSCFXNoiseSuppress;

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureFXNoiseSuppress

DECLARE_INTERFACE_(IDirectSoundCaptureFXNoiseSuppress, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ __in REFIID, __deref_out LPVOID*) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureFXNoiseSuppress methods
    STDMETHOD(SetAllParameters)     (THIS_ __in LPCDSCFXNoiseSuppress pcDscFxNoiseSuppress) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ __out LPDSCFXNoiseSuppress pDscFxNoiseSuppress) PURE;
    STDMETHOD(Reset)                (THIS) PURE;
};

#define IDirectSoundCaptureFXNoiseSuppress_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureFXNoiseSuppress_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundCaptureFXNoiseSuppress_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXNoiseSuppress_SetAllParameters(p,a)     (p)->lpVtbl->SetAllParameters(p,a)
#define IDirectSoundCaptureFXNoiseSuppress_GetAllParameters(p,a)     (p)->lpVtbl->GetAllParameters(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureFXNoiseSuppress_SetAllParameters(p,a)     (p)->SetAllParameters(a)
#define IDirectSoundCaptureFXNoiseSuppress_GetAllParameters(p,a)     (p)->GetAllParameters(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)


//
// IDirectSoundFullDuplex
//

#ifndef _IDirectSoundFullDuplex_
#define _IDirectSoundFullDuplex_

#ifdef __cplusplus
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
struct IDirectSoundFullDuplex;
#endif // __cplusplus

typedef struct IDirectSoundFullDuplex *LPDIRECTSOUNDFULLDUPLEX;

DEFINE_GUID(IID_IDirectSoundFullDuplex, 0xedcb4c7a, 0xdaab, 0x4216, 0xa4, 0x2e, 0x6c, 0x50, 0x59, 0x6d, 0xdc, 0x1d);

#undef INTERFACE
#define INTERFACE IDirectSoundFullDuplex

DECLARE_INTERFACE_(IDirectSoundFullDuplex, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)   (THIS_ __in REFIID, __deref_out LPVOID*) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // IDirectSoundFullDuplex methods
    STDMETHOD(Initialize)     (THIS_ __in LPCGUID pCaptureGuid, __in LPCGUID pRenderGuid, __in LPCDSCBUFFERDESC lpDscBufferDesc, __in LPCDSBUFFERDESC lpDsBufferDesc, HWND hWnd, DWORD dwLevel,
                               __deref_out LPLPDIRECTSOUNDCAPTUREBUFFER8 lplpDirectSoundCaptureBuffer8, __deref_out LPLPDIRECTSOUNDBUFFER8 lplpDirectSoundBuffer8) PURE;
};

#define IDirectSoundFullDuplex_QueryInterface(p,a,b)    IUnknown_QueryInterface(p,a,b)
#define IDirectSoundFullDuplex_AddRef(p)                IUnknown_AddRef(p)
#define IDirectSoundFullDuplex_Release(p)               IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFullDuplex_Initialize(p,a,b,c,d,e,f,g,h)     (p)->lpVtbl->Initialize(p,a,b,c,d,e,f,g,h)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundFullDuplex_Initialize(p,a,b,c,d,e,f,g,h)     (p)->Initialize(a,b,c,d,e,f,g,h)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // _IDirectSoundFullDuplex_

#endif // DIRECTSOUND_VERSION >= 0x0800

//
// Return Codes
//

// The function completed successfully
#define DS_OK                           S_OK

// The call succeeded, but we had to substitute the 3D algorithm
#define DS_NO_VIRTUALIZATION            MAKE_HRESULT(0, _FACDS, 10)

// The call failed because resources (such as a priority level)
// were already being used by another caller
#define DSERR_ALLOCATED                 MAKE_DSHRESULT(10)

// The control (vol, pan, etc.) requested by the caller is not available
#define DSERR_CONTROLUNAVAIL            MAKE_DSHRESULT(30)

// An invalid parameter was passed to the returning function
#define DSERR_INVALIDPARAM              E_INVALIDARG

// This call is not valid for the current state of this object
#define DSERR_INVALIDCALL               MAKE_DSHRESULT(50)

// An undetermined error occurred inside the DirectSound subsystem
#define DSERR_GENERIC                   E_FAIL

// The caller does not have the priority level required for the function to
// succeed
#define DSERR_PRIOLEVELNEEDED           MAKE_DSHRESULT(70)

// Not enough free memory is available to complete the operation
#define DSERR_OUTOFMEMORY               E_OUTOFMEMORY

// The specified WAVE format is not supported
#define DSERR_BADFORMAT                 MAKE_DSHRESULT(100)

// The function called is not supported at this time
#define DSERR_UNSUPPORTED               E_NOTIMPL

// No sound driver is available for use
#define DSERR_NODRIVER                  MAKE_DSHRESULT(120)

// This object is already initialized
#define DSERR_ALREADYINITIALIZED        MAKE_DSHRESULT(130)

// This object does not support aggregation
#define DSERR_NOAGGREGATION             CLASS_E_NOAGGREGATION

// The buffer memory has been lost, and must be restored
#define DSERR_BUFFERLOST                MAKE_DSHRESULT(150)

// Another app has a higher priority level, preventing this call from
// succeeding
#define DSERR_OTHERAPPHASPRIO           MAKE_DSHRESULT(160)

// This object has not been initialized
#define DSERR_UNINITIALIZED             MAKE_DSHRESULT(170)

// The requested COM interface is not available
#define DSERR_NOINTERFACE               E_NOINTERFACE

// Access is denied
#define DSERR_ACCESSDENIED              E_ACCESSDENIED

// Tried to create a DSBCAPS_CTRLFX buffer shorter than DSBSIZE_FX_MIN milliseconds
#define DSERR_BUFFERTOOSMALL            MAKE_DSHRESULT(180)

// Attempt to use DirectSound 8 functionality on an older DirectSound object
#define DSERR_DS8_REQUIRED              MAKE_DSHRESULT(190)

// A circular loop of send effects was detected
#define DSERR_SENDLOOP                  MAKE_DSHRESULT(200)

// The GUID specified in an audiopath file does not match a valid MIXIN buffer
#define DSERR_BADSENDBUFFERGUID         MAKE_DSHRESULT(210)

// The object requested was not found (numerically equal to DMUS_E_NOT_FOUND)
#define DSERR_OBJECTNOTFOUND            MAKE_DSHRESULT(4449)

// The effects requested could not be found on the system, or they were found
// but in the wrong order, or in the wrong hardware/software locations.
#define DSERR_FXUNAVAILABLE             MAKE_DSHRESULT(220)

//
// Flags
//

#define DSCAPS_PRIMARYMONO          0x00000001
#define DSCAPS_PRIMARYSTEREO        0x00000002
#define DSCAPS_PRIMARY8BIT          0x00000004
#define DSCAPS_PRIMARY16BIT         0x00000008
#define DSCAPS_CONTINUOUSRATE       0x00000010
#define DSCAPS_EMULDRIVER           0x00000020
#define DSCAPS_CERTIFIED            0x00000040
#define DSCAPS_SECONDARYMONO        0x00000100
#define DSCAPS_SECONDARYSTEREO      0x00000200
#define DSCAPS_SECONDARY8BIT        0x00000400
#define DSCAPS_SECONDARY16BIT       0x00000800

#define DSSCL_NORMAL                0x00000001
#define DSSCL_PRIORITY              0x00000002
#define DSSCL_EXCLUSIVE             0x00000003
#define DSSCL_WRITEPRIMARY          0x00000004

#define DSSPEAKER_DIRECTOUT         0x00000000
#define DSSPEAKER_HEADPHONE         0x00000001
#define DSSPEAKER_MONO              0x00000002
#define DSSPEAKER_QUAD              0x00000003
#define DSSPEAKER_STEREO            0x00000004
#define DSSPEAKER_SURROUND          0x00000005
#define DSSPEAKER_5POINT1           0x00000006  // obsolete 5.1 setting
#define DSSPEAKER_7POINT1           0x00000007  // obsolete 7.1 setting
#define DSSPEAKER_7POINT1_SURROUND  0x00000008  // correct 7.1 Home Theater setting
#define DSSPEAKER_5POINT1_SURROUND  0x00000009  // correct 5.1 setting
#define DSSPEAKER_7POINT1_WIDE      DSSPEAKER_7POINT1
#define DSSPEAKER_5POINT1_BACK      DSSPEAKER_5POINT1

#define DSSPEAKER_GEOMETRY_MIN      0x00000005  //   5 degrees
#define DSSPEAKER_GEOMETRY_NARROW   0x0000000A  //  10 degrees
#define DSSPEAKER_GEOMETRY_WIDE     0x00000014  //  20 degrees
#define DSSPEAKER_GEOMETRY_MAX      0x000000B4  // 180 degrees

#define DSSPEAKER_COMBINED(c, g)    ((DWORD)(((BYTE)(c)) | ((DWORD)((BYTE)(g))) << 16))
#define DSSPEAKER_CONFIG(a)         ((BYTE)(a))
#define DSSPEAKER_GEOMETRY(a)       ((BYTE)(((DWORD)(a) >> 16) & 0x00FF))

#define DSBCAPS_PRIMARYBUFFER       0x00000001
#define DSBCAPS_STATIC              0x00000002
#define DSBCAPS_LOCHARDWARE         0x00000004
#define DSBCAPS_LOCSOFTWARE         0x00000008
#define DSBCAPS_CTRL3D              0x00000010
#define DSBCAPS_CTRLFREQUENCY       0x00000020
#define DSBCAPS_CTRLPAN             0x00000040
#define DSBCAPS_CTRLVOLUME          0x00000080
#define DSBCAPS_CTRLPOSITIONNOTIFY  0x00000100
#define DSBCAPS_CTRLFX              0x00000200
#define DSBCAPS_STICKYFOCUS         0x00004000
#define DSBCAPS_GLOBALFOCUS         0x00008000
#define DSBCAPS_GETCURRENTPOSITION2 0x00010000
#define DSBCAPS_MUTE3DATMAXDISTANCE 0x00020000
#define DSBCAPS_LOCDEFER            0x00040000
#define DSBCAPS_TRUEPLAYPOSITION    0x00080000

#define DSBPLAY_LOOPING             0x00000001
#define DSBPLAY_LOCHARDWARE         0x00000002
#define DSBPLAY_LOCSOFTWARE         0x00000004
#define DSBPLAY_TERMINATEBY_TIME    0x00000008
#define DSBPLAY_TERMINATEBY_DISTANCE    0x000000010
#define DSBPLAY_TERMINATEBY_PRIORITY    0x000000020

#define DSBSTATUS_PLAYING           0x00000001
#define DSBSTATUS_BUFFERLOST        0x00000002
#define DSBSTATUS_LOOPING           0x00000004
#define DSBSTATUS_LOCHARDWARE       0x00000008
#define DSBSTATUS_LOCSOFTWARE       0x00000010
#define DSBSTATUS_TERMINATED        0x00000020

#define DSBLOCK_FROMWRITECURSOR     0x00000001
#define DSBLOCK_ENTIREBUFFER        0x00000002

#define DSBFREQUENCY_ORIGINAL       0
#define DSBFREQUENCY_MIN            100
#if DIRECTSOUND_VERSION >= 0x0900
#define DSBFREQUENCY_MAX            200000
#else
#define DSBFREQUENCY_MAX            100000
#endif

#define DSBPAN_LEFT                 -10000
#define DSBPAN_CENTER               0
#define DSBPAN_RIGHT                10000

#define DSBVOLUME_MIN               -10000
#define DSBVOLUME_MAX               0

#define DSBSIZE_MIN                 4
#define DSBSIZE_MAX                 0x0FFFFFFF
#define DSBSIZE_FX_MIN              150  // NOTE: Milliseconds, not bytes

#define DSBNOTIFICATIONS_MAX        100000UL

#define DS3DMODE_NORMAL             0x00000000
#define DS3DMODE_HEADRELATIVE       0x00000001
#define DS3DMODE_DISABLE            0x00000002

#define DS3D_IMMEDIATE              0x00000000
#define DS3D_DEFERRED               0x00000001

#define DS3D_MINDISTANCEFACTOR      FLT_MIN
#define DS3D_MAXDISTANCEFACTOR      FLT_MAX
#define DS3D_DEFAULTDISTANCEFACTOR  1.0f

#define DS3D_MINROLLOFFFACTOR       0.0f
#define DS3D_MAXROLLOFFFACTOR       10.0f
#define DS3D_DEFAULTROLLOFFFACTOR   1.0f

#define DS3D_MINDOPPLERFACTOR       0.0f
#define DS3D_MAXDOPPLERFACTOR       10.0f
#define DS3D_DEFAULTDOPPLERFACTOR   1.0f

#define DS3D_DEFAULTMINDISTANCE     1.0f
#define DS3D_DEFAULTMAXDISTANCE     1000000000.0f

#define DS3D_MINCONEANGLE           0
#define DS3D_MAXCONEANGLE           360
#define DS3D_DEFAULTCONEANGLE       360

#define DS3D_DEFAULTCONEOUTSIDEVOLUME DSBVOLUME_MAX

// IDirectSoundCapture attributes

#define DSCCAPS_EMULDRIVER          DSCAPS_EMULDRIVER
#define DSCCAPS_CERTIFIED           DSCAPS_CERTIFIED
#define DSCCAPS_MULTIPLECAPTURE     0x00000001

// IDirectSoundCaptureBuffer attributes

#define DSCBCAPS_WAVEMAPPED         0x80000000
#if DIRECTSOUND_VERSION >= 0x0800
#define DSCBCAPS_CTRLFX             0x00000200
#endif

#define DSCBLOCK_ENTIREBUFFER       0x00000001

#define DSCBSTATUS_CAPTURING        0x00000001
#define DSCBSTATUS_LOOPING          0x00000002

#define DSCBSTART_LOOPING           0x00000001

#define DSBPN_OFFSETSTOP            0xFFFFFFFF

#define DS_CERTIFIED                0x00000000
#define DS_UNCERTIFIED              0x00000001

//
// Flags for the I3DL2 effects
//

//
// I3DL2 Material Presets
//

enum
{
    DSFX_I3DL2_MATERIAL_PRESET_SINGLEWINDOW,
    DSFX_I3DL2_MATERIAL_PRESET_DOUBLEWINDOW,
    DSFX_I3DL2_MATERIAL_PRESET_THINDOOR,
    DSFX_I3DL2_MATERIAL_PRESET_THICKDOOR,
    DSFX_I3DL2_MATERIAL_PRESET_WOODWALL,
    DSFX_I3DL2_MATERIAL_PRESET_BRICKWALL,
    DSFX_I3DL2_MATERIAL_PRESET_STONEWALL,
    DSFX_I3DL2_MATERIAL_PRESET_CURTAIN
};

#define I3DL2_MATERIAL_PRESET_SINGLEWINDOW    -2800,0.71f
#define I3DL2_MATERIAL_PRESET_DOUBLEWINDOW    -5000,0.40f
#define I3DL2_MATERIAL_PRESET_THINDOOR        -1800,0.66f
#define I3DL2_MATERIAL_PRESET_THICKDOOR       -4400,0.64f
#define I3DL2_MATERIAL_PRESET_WOODWALL        -4000,0.50f
#define I3DL2_MATERIAL_PRESET_BRICKWALL       -5000,0.60f
#define I3DL2_MATERIAL_PRESET_STONEWALL       -6000,0.68f
#define I3DL2_MATERIAL_PRESET_CURTAIN         -1200,0.15f

enum
{
    DSFX_I3DL2_ENVIRONMENT_PRESET_DEFAULT,
    DSFX_I3DL2_ENVIRONMENT_PRESET_GENERIC,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PADDEDCELL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_ROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_BATHROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_LIVINGROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_STONEROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_AUDITORIUM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CONCERTHALL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CAVE,
    DSFX_I3DL2_ENVIRONMENT_PRESET_ARENA,
    DSFX_I3DL2_ENVIRONMENT_PRESET_HANGAR,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CARPETEDHALLWAY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_HALLWAY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_STONECORRIDOR,
    DSFX_I3DL2_ENVIRONMENT_PRESET_ALLEY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_FOREST,
    DSFX_I3DL2_ENVIRONMENT_PRESET_CITY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_MOUNTAINS,
    DSFX_I3DL2_ENVIRONMENT_PRESET_QUARRY,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PLAIN,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PARKINGLOT,
    DSFX_I3DL2_ENVIRONMENT_PRESET_SEWERPIPE,
    DSFX_I3DL2_ENVIRONMENT_PRESET_UNDERWATER,
    DSFX_I3DL2_ENVIRONMENT_PRESET_SMALLROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_MEDIUMROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_LARGEROOM,
    DSFX_I3DL2_ENVIRONMENT_PRESET_MEDIUMHALL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_LARGEHALL,
    DSFX_I3DL2_ENVIRONMENT_PRESET_PLATE
};

//
// I3DL2 Reverberation Presets Values
//

#define I3DL2_ENVIRONMENT_PRESET_DEFAULT         -1000, -100, 0.0f, 1.49f, 0.83f, -2602, 0.007f,   200, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_GENERIC         -1000, -100, 0.0f, 1.49f, 0.83f, -2602, 0.007f,   200, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PADDEDCELL      -1000,-6000, 0.0f, 0.17f, 0.10f, -1204, 0.001f,   207, 0.002f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_ROOM            -1000, -454, 0.0f, 0.40f, 0.83f, -1646, 0.002f,    53, 0.003f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_BATHROOM        -1000,-1200, 0.0f, 1.49f, 0.54f,  -370, 0.007f,  1030, 0.011f, 100.0f,  60.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_LIVINGROOM      -1000,-6000, 0.0f, 0.50f, 0.10f, -1376, 0.003f, -1104, 0.004f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_STONEROOM       -1000, -300, 0.0f, 2.31f, 0.64f,  -711, 0.012f,    83, 0.017f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_AUDITORIUM      -1000, -476, 0.0f, 4.32f, 0.59f,  -789, 0.020f,  -289, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CONCERTHALL     -1000, -500, 0.0f, 3.92f, 0.70f, -1230, 0.020f,    -2, 0.029f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CAVE            -1000,    0, 0.0f, 2.91f, 1.30f,  -602, 0.015f,  -302, 0.022f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_ARENA           -1000, -698, 0.0f, 7.24f, 0.33f, -1166, 0.020f,    16, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_HANGAR          -1000,-1000, 0.0f,10.05f, 0.23f,  -602, 0.020f,   198, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CARPETEDHALLWAY -1000,-4000, 0.0f, 0.30f, 0.10f, -1831, 0.002f, -1630, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_HALLWAY         -1000, -300, 0.0f, 1.49f, 0.59f, -1219, 0.007f,   441, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_STONECORRIDOR   -1000, -237, 0.0f, 2.70f, 0.79f, -1214, 0.013f,   395, 0.020f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_ALLEY           -1000, -270, 0.0f, 1.49f, 0.86f, -1204, 0.007f,    -4, 0.011f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_FOREST          -1000,-3300, 0.0f, 1.49f, 0.54f, -2560, 0.162f,  -613, 0.088f,  79.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_CITY            -1000, -800, 0.0f, 1.49f, 0.67f, -2273, 0.007f, -2217, 0.011f,  50.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_MOUNTAINS       -1000,-2500, 0.0f, 1.49f, 0.21f, -2780, 0.300f, -2014, 0.100f,  27.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_QUARRY          -1000,-1000, 0.0f, 1.49f, 0.83f,-10000, 0.061f,   500, 0.025f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PLAIN           -1000,-2000, 0.0f, 1.49f, 0.50f, -2466, 0.179f, -2514, 0.100f,  21.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PARKINGLOT      -1000,    0, 0.0f, 1.65f, 1.50f, -1363, 0.008f, -1153, 0.012f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_SEWERPIPE       -1000,-1000, 0.0f, 2.81f, 0.14f,   429, 0.014f,   648, 0.021f,  80.0f,  60.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_UNDERWATER      -1000,-4000, 0.0f, 1.49f, 0.10f,  -449, 0.007f,  1700, 0.011f, 100.0f, 100.0f, 5000.0f

//
// Examples simulating 'musical' reverb presets
//
// Name       Decay time   Description
// Small Room    1.1s      A small size room with a length of 5m or so.
// Medium Room   1.3s      A medium size room with a length of 10m or so.
// Large Room    1.5s      A large size room suitable for live performances.
// Medium Hall   1.8s      A medium size concert hall.
// Large Hall    1.8s      A large size concert hall suitable for a full orchestra.
// Plate         1.3s      A plate reverb simulation.
//

#define I3DL2_ENVIRONMENT_PRESET_SMALLROOM       -1000, -600, 0.0f, 1.10f, 0.83f,  -400, 0.005f,   500, 0.010f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_MEDIUMROOM      -1000, -600, 0.0f, 1.30f, 0.83f, -1000, 0.010f,  -200, 0.020f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_LARGEROOM       -1000, -600, 0.0f, 1.50f, 0.83f, -1600, 0.020f, -1000, 0.040f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_MEDIUMHALL      -1000, -600, 0.0f, 1.80f, 0.70f, -1300, 0.015f,  -800, 0.030f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_LARGEHALL       -1000, -600, 0.0f, 1.80f, 0.70f, -2000, 0.030f, -1400, 0.060f, 100.0f, 100.0f, 5000.0f
#define I3DL2_ENVIRONMENT_PRESET_PLATE           -1000, -200, 0.0f, 1.30f, 0.90f,     0, 0.002f,     0, 0.010f, 100.0f,  75.0f, 5000.0f

//
// DirectSound3D Algorithms
//

// Default DirectSound3D algorithm {00000000-0000-0000-0000-000000000000}
#define DS3DALG_DEFAULT GUID_NULL

// No virtualization (Pan3D) {C241333F-1C1B-11d2-94F5-00C04FC28ACA}
DEFINE_GUID(DS3DALG_NO_VIRTUALIZATION, 0xc241333f, 0x1c1b, 0x11d2, 0x94, 0xf5, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

// High-quality HRTF algorithm {C2413340-1C1B-11d2-94F5-00C04FC28ACA}
DEFINE_GUID(DS3DALG_HRTF_FULL, 0xc2413340, 0x1c1b, 0x11d2, 0x94, 0xf5, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

// Lower-quality HRTF algorithm {C2413342-1C1B-11d2-94F5-00C04FC28ACA}
DEFINE_GUID(DS3DALG_HRTF_LIGHT, 0xc2413342, 0x1c1b, 0x11d2, 0x94, 0xf5, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);


#if DIRECTSOUND_VERSION >= 0x0800

//
// DirectSound Internal Effect Algorithms
//


// Gargle {DAFD8210-5711-4B91-9FE3-F75B7AE279BF}
DEFINE_GUID(GUID_DSFX_STANDARD_GARGLE, 0xdafd8210, 0x5711, 0x4b91, 0x9f, 0xe3, 0xf7, 0x5b, 0x7a, 0xe2, 0x79, 0xbf);

// Chorus {EFE6629C-81F7-4281-BD91-C9D604A95AF6}
DEFINE_GUID(GUID_DSFX_STANDARD_CHORUS, 0xefe6629c, 0x81f7, 0x4281, 0xbd, 0x91, 0xc9, 0xd6, 0x04, 0xa9, 0x5a, 0xf6);

// Flanger {EFCA3D92-DFD8-4672-A603-7420894BAD98}
DEFINE_GUID(GUID_DSFX_STANDARD_FLANGER, 0xefca3d92, 0xdfd8, 0x4672, 0xa6, 0x03, 0x74, 0x20, 0x89, 0x4b, 0xad, 0x98);

// Echo/Delay {EF3E932C-D40B-4F51-8CCF-3F98F1B29D5D}
DEFINE_GUID(GUID_DSFX_STANDARD_ECHO, 0xef3e932c, 0xd40b, 0x4f51, 0x8c, 0xcf, 0x3f, 0x98, 0xf1, 0xb2, 0x9d, 0x5d);

// Distortion {EF114C90-CD1D-484E-96E5-09CFAF912A21}
DEFINE_GUID(GUID_DSFX_STANDARD_DISTORTION, 0xef114c90, 0xcd1d, 0x484e, 0x96, 0xe5, 0x09, 0xcf, 0xaf, 0x91, 0x2a, 0x21);

// Compressor/Limiter {EF011F79-4000-406D-87AF-BFFB3FC39D57}
DEFINE_GUID(GUID_DSFX_STANDARD_COMPRESSOR, 0xef011f79, 0x4000, 0x406d, 0x87, 0xaf, 0xbf, 0xfb, 0x3f, 0xc3, 0x9d, 0x57);

// Parametric Equalization {120CED89-3BF4-4173-A132-3CB406CF3231}
DEFINE_GUID(GUID_DSFX_STANDARD_PARAMEQ, 0x120ced89, 0x3bf4, 0x4173, 0xa1, 0x32, 0x3c, 0xb4, 0x06, 0xcf, 0x32, 0x31);

// I3DL2 Environmental Reverberation: Reverb (Listener) Effect {EF985E71-D5C7-42D4-BA4D-2D073E2E96F4}
DEFINE_GUID(GUID_DSFX_STANDARD_I3DL2REVERB, 0xef985e71, 0xd5c7, 0x42d4, 0xba, 0x4d, 0x2d, 0x07, 0x3e, 0x2e, 0x96, 0xf4);

// Waves Reverberation {87FC0268-9A55-4360-95AA-004A1D9DE26C}
DEFINE_GUID(GUID_DSFX_WAVES_REVERB, 0x87fc0268, 0x9a55, 0x4360, 0x95, 0xaa, 0x00, 0x4a, 0x1d, 0x9d, 0xe2, 0x6c);

//
// DirectSound Capture Effect Algorithms
//


// Acoustic Echo Canceller {BF963D80-C559-11D0-8A2B-00A0C9255AC1}
// Matches KSNODETYPE_ACOUSTIC_ECHO_CANCEL in ksmedia.h
DEFINE_GUID(GUID_DSCFX_CLASS_AEC, 0xBF963D80L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1);

// Microsoft AEC {CDEBB919-379A-488a-8765-F53CFD36DE40}
DEFINE_GUID(GUID_DSCFX_MS_AEC, 0xcdebb919, 0x379a, 0x488a, 0x87, 0x65, 0xf5, 0x3c, 0xfd, 0x36, 0xde, 0x40);

// System AEC {1C22C56D-9879-4f5b-A389-27996DDC2810}
DEFINE_GUID(GUID_DSCFX_SYSTEM_AEC, 0x1c22c56d, 0x9879, 0x4f5b, 0xa3, 0x89, 0x27, 0x99, 0x6d, 0xdc, 0x28, 0x10);

// Noise Supression {E07F903F-62FD-4e60-8CDD-DEA7236665B5}
// Matches KSNODETYPE_NOISE_SUPPRESS in post Windows ME DDK's ksmedia.h
DEFINE_GUID(GUID_DSCFX_CLASS_NS, 0xe07f903f, 0x62fd, 0x4e60, 0x8c, 0xdd, 0xde, 0xa7, 0x23, 0x66, 0x65, 0xb5);

// Microsoft Noise Suppresion {11C5C73B-66E9-4ba1-A0BA-E814C6EED92D}
DEFINE_GUID(GUID_DSCFX_MS_NS, 0x11c5c73b, 0x66e9, 0x4ba1, 0xa0, 0xba, 0xe8, 0x14, 0xc6, 0xee, 0xd9, 0x2d);

// System Noise Suppresion {5AB0882E-7274-4516-877D-4EEE99BA4FD0}
DEFINE_GUID(GUID_DSCFX_SYSTEM_NS, 0x5ab0882e, 0x7274, 0x4516, 0x87, 0x7d, 0x4e, 0xee, 0x99, 0xba, 0x4f, 0xd0);

#endif // DIRECTSOUND_VERSION >= 0x0800

#endif // __DSOUND_INCLUDED__



#ifdef __cplusplus
};
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dshowasf.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0416 */
/* Compiler settings for dshowasf.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dshowasf_h__
#define __dshowasf_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAMWMBufferPass_FWD_DEFINED__
#define __IAMWMBufferPass_FWD_DEFINED__
typedef interface IAMWMBufferPass IAMWMBufferPass;
#endif 	/* __IAMWMBufferPass_FWD_DEFINED__ */


#ifndef __IAMWMBufferPassCallback_FWD_DEFINED__
#define __IAMWMBufferPassCallback_FWD_DEFINED__
typedef interface IAMWMBufferPassCallback IAMWMBufferPassCallback;
#endif 	/* __IAMWMBufferPassCallback_FWD_DEFINED__ */


#ifndef __IConfigAsfWriter_FWD_DEFINED__
#define __IConfigAsfWriter_FWD_DEFINED__
typedef interface IConfigAsfWriter IConfigAsfWriter;
#endif 	/* __IConfigAsfWriter_FWD_DEFINED__ */


#ifndef __IConfigAsfWriter2_FWD_DEFINED__
#define __IConfigAsfWriter2_FWD_DEFINED__
typedef interface IConfigAsfWriter2 IConfigAsfWriter2;
#endif 	/* __IConfigAsfWriter2_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "strmif.h"
#include "wmsdkidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_dshowasf_0000 */
/* [local] */ 

//=========================================================================
//
// Microsoft Windows Media Technologies
// Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//=========================================================================
EXTERN_GUID( IID_IConfigAsfWriter2,0x7989ccaa, 0x53f0, 0x44f0, 0x88, 0x4a, 0xf3, 0xb0, 0x3f, 0x6a, 0xe0, 0x66 );
EXTERN_GUID( IID_IConfigAsfWriter,0x45086030,0xF7E4,0x486a,0xB5,0x04,0x82,0x6B,0xB5,0x79,0x2A,0x3B );
EXTERN_GUID( IID_IAMWMBufferPass,0x6dd816d7, 0xe740, 0x4123, 0x9e, 0x24, 0x24, 0x44, 0x41, 0x26, 0x44, 0xd8 );
EXTERN_GUID( IID_IAMWMBufferPassCallback,0xb25b8372, 0xd2d2, 0x44b2, 0x86, 0x53, 0x1b, 0x8d, 0xae, 0x33, 0x24, 0x89 );
#ifndef EC_PREPROCESS_COMPLETE
#define EC_PREPROCESS_COMPLETE 0x56
#endif








extern RPC_IF_HANDLE __MIDL_itf_dshowasf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dshowasf_0000_v0_0_s_ifspec;

#ifndef __IAMWMBufferPass_INTERFACE_DEFINED__
#define __IAMWMBufferPass_INTERFACE_DEFINED__

/* interface IAMWMBufferPass */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMWMBufferPass;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6DD816D7-E740-4123-9E24-2444412644D8")
    IAMWMBufferPass : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetNotify( 
            /* [in] */ IAMWMBufferPassCallback *pCallback) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMWMBufferPassVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMWMBufferPass * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMWMBufferPass * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMWMBufferPass * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetNotify )( 
            IAMWMBufferPass * This,
            /* [in] */ IAMWMBufferPassCallback *pCallback);
        
        END_INTERFACE
    } IAMWMBufferPassVtbl;

    interface IAMWMBufferPass
    {
        CONST_VTBL struct IAMWMBufferPassVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMWMBufferPass_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMWMBufferPass_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMWMBufferPass_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMWMBufferPass_SetNotify(This,pCallback)	\
    ( (This)->lpVtbl -> SetNotify(This,pCallback) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMWMBufferPass_SetNotify_Proxy( 
    IAMWMBufferPass * This,
    /* [in] */ IAMWMBufferPassCallback *pCallback);


void __RPC_STUB IAMWMBufferPass_SetNotify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMWMBufferPass_INTERFACE_DEFINED__ */


#ifndef __IAMWMBufferPassCallback_INTERFACE_DEFINED__
#define __IAMWMBufferPassCallback_INTERFACE_DEFINED__

/* interface IAMWMBufferPassCallback */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMWMBufferPassCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B25B8372-D2D2-44b2-8653-1B8DAE332489")
    IAMWMBufferPassCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ INSSBuffer3 *pNSSBuffer3,
            /* [in] */ IPin *pPin,
            /* [in] */ REFERENCE_TIME *prtStart,
            /* [in] */ REFERENCE_TIME *prtEnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMWMBufferPassCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMWMBufferPassCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMWMBufferPassCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMWMBufferPassCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IAMWMBufferPassCallback * This,
            /* [in] */ INSSBuffer3 *pNSSBuffer3,
            /* [in] */ IPin *pPin,
            /* [in] */ REFERENCE_TIME *prtStart,
            /* [in] */ REFERENCE_TIME *prtEnd);
        
        END_INTERFACE
    } IAMWMBufferPassCallbackVtbl;

    interface IAMWMBufferPassCallback
    {
        CONST_VTBL struct IAMWMBufferPassCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMWMBufferPassCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMWMBufferPassCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMWMBufferPassCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMWMBufferPassCallback_Notify(This,pNSSBuffer3,pPin,prtStart,prtEnd)	\
    ( (This)->lpVtbl -> Notify(This,pNSSBuffer3,pPin,prtStart,prtEnd) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMWMBufferPassCallback_Notify_Proxy( 
    IAMWMBufferPassCallback * This,
    /* [in] */ INSSBuffer3 *pNSSBuffer3,
    /* [in] */ IPin *pPin,
    /* [in] */ REFERENCE_TIME *prtStart,
    /* [in] */ REFERENCE_TIME *prtEnd);


void __RPC_STUB IAMWMBufferPassCallback_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMWMBufferPassCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dshowasf_0506 */
/* [local] */ 


enum _AM_ASFWRITERCONFIG_PARAM
    {	AM_CONFIGASFWRITER_PARAM_AUTOINDEX	= 1,
	AM_CONFIGASFWRITER_PARAM_MULTIPASS	= ( AM_CONFIGASFWRITER_PARAM_AUTOINDEX + 1 ) ,
	AM_CONFIGASFWRITER_PARAM_DONTCOMPRESS	= ( AM_CONFIGASFWRITER_PARAM_MULTIPASS + 1 ) 
    } ;


extern RPC_IF_HANDLE __MIDL_itf_dshowasf_0506_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dshowasf_0506_v0_0_s_ifspec;

#ifndef __IConfigAsfWriter_INTERFACE_DEFINED__
#define __IConfigAsfWriter_INTERFACE_DEFINED__

/* interface IConfigAsfWriter */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IConfigAsfWriter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("45086030-F7E4-486a-B504-826BB5792A3B")
    IConfigAsfWriter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ConfigureFilterUsingProfileId( 
            /* [in] */ DWORD dwProfileId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentProfileId( 
            /* [out] */ DWORD *pdwProfileId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureFilterUsingProfileGuid( 
            /* [in] */ REFGUID guidProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentProfileGuid( 
            /* [out] */ GUID *pProfileGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureFilterUsingProfile( 
            /* [in] */ IWMProfile *pProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentProfile( 
            /* [out] */ IWMProfile **ppProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIndexMode( 
            /* [in] */ BOOL bIndexFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndexMode( 
            /* [out] */ BOOL *pbIndexFile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConfigAsfWriterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IConfigAsfWriter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IConfigAsfWriter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IConfigAsfWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureFilterUsingProfileId )( 
            IConfigAsfWriter * This,
            /* [in] */ DWORD dwProfileId);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentProfileId )( 
            IConfigAsfWriter * This,
            /* [out] */ DWORD *pdwProfileId);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureFilterUsingProfileGuid )( 
            IConfigAsfWriter * This,
            /* [in] */ REFGUID guidProfile);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentProfileGuid )( 
            IConfigAsfWriter * This,
            /* [out] */ GUID *pProfileGuid);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureFilterUsingProfile )( 
            IConfigAsfWriter * This,
            /* [in] */ IWMProfile *pProfile);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentProfile )( 
            IConfigAsfWriter * This,
            /* [out] */ IWMProfile **ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE *SetIndexMode )( 
            IConfigAsfWriter * This,
            /* [in] */ BOOL bIndexFile);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndexMode )( 
            IConfigAsfWriter * This,
            /* [out] */ BOOL *pbIndexFile);
        
        END_INTERFACE
    } IConfigAsfWriterVtbl;

    interface IConfigAsfWriter
    {
        CONST_VTBL struct IConfigAsfWriterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConfigAsfWriter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IConfigAsfWriter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IConfigAsfWriter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IConfigAsfWriter_ConfigureFilterUsingProfileId(This,dwProfileId)	\
    ( (This)->lpVtbl -> ConfigureFilterUsingProfileId(This,dwProfileId) ) 

#define IConfigAsfWriter_GetCurrentProfileId(This,pdwProfileId)	\
    ( (This)->lpVtbl -> GetCurrentProfileId(This,pdwProfileId) ) 

#define IConfigAsfWriter_ConfigureFilterUsingProfileGuid(This,guidProfile)	\
    ( (This)->lpVtbl -> ConfigureFilterUsingProfileGuid(This,guidProfile) ) 

#define IConfigAsfWriter_GetCurrentProfileGuid(This,pProfileGuid)	\
    ( (This)->lpVtbl -> GetCurrentProfileGuid(This,pProfileGuid) ) 

#define IConfigAsfWriter_ConfigureFilterUsingProfile(This,pProfile)	\
    ( (This)->lpVtbl -> ConfigureFilterUsingProfile(This,pProfile) ) 

#define IConfigAsfWriter_GetCurrentProfile(This,ppProfile)	\
    ( (This)->lpVtbl -> GetCurrentProfile(This,ppProfile) ) 

#define IConfigAsfWriter_SetIndexMode(This,bIndexFile)	\
    ( (This)->lpVtbl -> SetIndexMode(This,bIndexFile) ) 

#define IConfigAsfWriter_GetIndexMode(This,pbIndexFile)	\
    ( (This)->lpVtbl -> GetIndexMode(This,pbIndexFile) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IConfigAsfWriter_ConfigureFilterUsingProfileId_Proxy( 
    IConfigAsfWriter * This,
    /* [in] */ DWORD dwProfileId);


void __RPC_STUB IConfigAsfWriter_ConfigureFilterUsingProfileId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigAsfWriter_GetCurrentProfileId_Proxy( 
    IConfigAsfWriter * This,
    /* [out] */ DWORD *pdwProfileId);


void __RPC_STUB IConfigAsfWriter_GetCurrentProfileId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigAsfWriter_ConfigureFilterUsingProfileGuid_Proxy( 
    IConfigAsfWriter * This,
    /* [in] */ REFGUID guidProfile);


void __RPC_STUB IConfigAsfWriter_ConfigureFilterUsingProfileGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigAsfWriter_GetCurrentProfileGuid_Proxy( 
    IConfigAsfWriter * This,
    /* [out] */ GUID *pProfileGuid);


void __RPC_STUB IConfigAsfWriter_GetCurrentProfileGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigAsfWriter_ConfigureFilterUsingProfile_Proxy( 
    IConfigAsfWriter * This,
    /* [in] */ IWMProfile *pProfile);


void __RPC_STUB IConfigAsfWriter_ConfigureFilterUsingProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigAsfWriter_GetCurrentProfile_Proxy( 
    IConfigAsfWriter * This,
    /* [out] */ IWMProfile **ppProfile);


void __RPC_STUB IConfigAsfWriter_GetCurrentProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigAsfWriter_SetIndexMode_Proxy( 
    IConfigAsfWriter * This,
    /* [in] */ BOOL bIndexFile);


void __RPC_STUB IConfigAsfWriter_SetIndexMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigAsfWriter_GetIndexMode_Proxy( 
    IConfigAsfWriter * This,
    /* [out] */ BOOL *pbIndexFile);


void __RPC_STUB IConfigAsfWriter_GetIndexMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConfigAsfWriter_INTERFACE_DEFINED__ */


#ifndef __IConfigAsfWriter2_INTERFACE_DEFINED__
#define __IConfigAsfWriter2_INTERFACE_DEFINED__

/* interface IConfigAsfWriter2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IConfigAsfWriter2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7989CCAA-53F0-44f0-884A-F3B03F6AE066")
    IConfigAsfWriter2 : public IConfigAsfWriter
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StreamNumFromPin( 
            /* [in] */ IPin *pPin,
            /* [out] */ WORD *pwStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetParam( 
            /* [in] */ DWORD dwParam,
            /* [in] */ DWORD dwParam1,
            /* [in] */ DWORD dwParam2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParam( 
            /* [in] */ DWORD dwParam,
            /* [out] */ DWORD *pdwParam1,
            /* [out] */ DWORD *pdwParam2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetMultiPassState( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConfigAsfWriter2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IConfigAsfWriter2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IConfigAsfWriter2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IConfigAsfWriter2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureFilterUsingProfileId )( 
            IConfigAsfWriter2 * This,
            /* [in] */ DWORD dwProfileId);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentProfileId )( 
            IConfigAsfWriter2 * This,
            /* [out] */ DWORD *pdwProfileId);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureFilterUsingProfileGuid )( 
            IConfigAsfWriter2 * This,
            /* [in] */ REFGUID guidProfile);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentProfileGuid )( 
            IConfigAsfWriter2 * This,
            /* [out] */ GUID *pProfileGuid);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureFilterUsingProfile )( 
            IConfigAsfWriter2 * This,
            /* [in] */ IWMProfile *pProfile);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentProfile )( 
            IConfigAsfWriter2 * This,
            /* [out] */ IWMProfile **ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE *SetIndexMode )( 
            IConfigAsfWriter2 * This,
            /* [in] */ BOOL bIndexFile);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndexMode )( 
            IConfigAsfWriter2 * This,
            /* [out] */ BOOL *pbIndexFile);
        
        HRESULT ( STDMETHODCALLTYPE *StreamNumFromPin )( 
            IConfigAsfWriter2 * This,
            /* [in] */ IPin *pPin,
            /* [out] */ WORD *pwStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE *SetParam )( 
            IConfigAsfWriter2 * This,
            /* [in] */ DWORD dwParam,
            /* [in] */ DWORD dwParam1,
            /* [in] */ DWORD dwParam2);
        
        HRESULT ( STDMETHODCALLTYPE *GetParam )( 
            IConfigAsfWriter2 * This,
            /* [in] */ DWORD dwParam,
            /* [out] */ DWORD *pdwParam1,
            /* [out] */ DWORD *pdwParam2);
        
        HRESULT ( STDMETHODCALLTYPE *ResetMultiPassState )( 
            IConfigAsfWriter2 * This);
        
        END_INTERFACE
    } IConfigAsfWriter2Vtbl;

    interface IConfigAsfWriter2
    {
        CONST_VTBL struct IConfigAsfWriter2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConfigAsfWriter2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IConfigAsfWriter2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IConfigAsfWriter2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IConfigAsfWriter2_ConfigureFilterUsingProfileId(This,dwProfileId)	\
    ( (This)->lpVtbl -> ConfigureFilterUsingProfileId(This,dwProfileId) ) 

#define IConfigAsfWriter2_GetCurrentProfileId(This,pdwProfileId)	\
    ( (This)->lpVtbl -> GetCurrentProfileId(This,pdwProfileId) ) 

#define IConfigAsfWriter2_ConfigureFilterUsingProfileGuid(This,guidProfile)	\
    ( (This)->lpVtbl -> ConfigureFilterUsingProfileGuid(This,guidProfile) ) 

#define IConfigAsfWriter2_GetCurrentProfileGuid(This,pProfileGuid)	\
    ( (This)->lpVtbl -> GetCurrentProfileGuid(This,pProfileGuid) ) 

#define IConfigAsfWriter2_ConfigureFilterUsingProfile(This,pProfile)	\
    ( (This)->lpVtbl -> ConfigureFilterUsingProfile(This,pProfile) ) 

#define IConfigAsfWriter2_GetCurrentProfile(This,ppProfile)	\
    ( (This)->lpVtbl -> GetCurrentProfile(This,ppProfile) ) 

#define IConfigAsfWriter2_SetIndexMode(This,bIndexFile)	\
    ( (This)->lpVtbl -> SetIndexMode(This,bIndexFile) ) 

#define IConfigAsfWriter2_GetIndexMode(This,pbIndexFile)	\
    ( (This)->lpVtbl -> GetIndexMode(This,pbIndexFile) ) 


#define IConfigAsfWriter2_StreamNumFromPin(This,pPin,pwStreamNum)	\
    ( (This)->lpVtbl -> StreamNumFromPin(This,pPin,pwStreamNum) ) 

#define IConfigAsfWriter2_SetParam(This,dwParam,dwParam1,dwParam2)	\
    ( (This)->lpVtbl -> SetParam(This,dwParam,dwParam1,dwParam2) ) 

#define IConfigAsfWriter2_GetParam(This,dwParam,pdwParam1,pdwParam2)	\
    ( (This)->lpVtbl -> GetParam(This,dwParam,pdwParam1,pdwParam2) ) 

#define IConfigAsfWriter2_ResetMultiPassState(This)	\
    ( (This)->lpVtbl -> ResetMultiPassState(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IConfigAsfWriter2_StreamNumFromPin_Proxy( 
    IConfigAsfWriter2 * This,
    /* [in] */ IPin *pPin,
    /* [out] */ WORD *pwStreamNum);


void __RPC_STUB IConfigAsfWriter2_StreamNumFromPin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigAsfWriter2_SetParam_Proxy( 
    IConfigAsfWriter2 * This,
    /* [in] */ DWORD dwParam,
    /* [in] */ DWORD dwParam1,
    /* [in] */ DWORD dwParam2);


void __RPC_STUB IConfigAsfWriter2_SetParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigAsfWriter2_GetParam_Proxy( 
    IConfigAsfWriter2 * This,
    /* [in] */ DWORD dwParam,
    /* [out] */ DWORD *pdwParam1,
    /* [out] */ DWORD *pdwParam2);


void __RPC_STUB IConfigAsfWriter2_GetParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IConfigAsfWriter2_ResetMultiPassState_Proxy( 
    IConfigAsfWriter2 * This);


void __RPC_STUB IConfigAsfWriter2_ResetMultiPassState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConfigAsfWriter2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dshowasf_0508 */
/* [local] */ 

////////////////////////////////////////////////////////////////
//
// Windows Media Filters compatibility option flags
//
static DWORD EXCLUDE_SCRIPT_STREAM_DELIVERY_SYNCHRONIZATION = 0x00000001;

////////////////////////////////////////////////////////////////
//
// ATOM strings to match compatibility option flags above for certain applications that don't want to (or not allowed to) update registry entries
// These need to be setup by the application using the WM filters to enable the particular functionality
//
static const WCHAR* g_wszExcludeScriptStreamDeliverySynchronization = L"ExcludeScriptStreamDeliverySynchronization";



extern RPC_IF_HANDLE __MIDL_itf_dshowasf_0508_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dshowasf_0508_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\DSQuery.h ===
#ifndef __dsquery_h
#define __dsquery_h

//
// query handler ID for dsquery.
//

DEFINE_GUID(CLSID_DsQuery, 0x8a23e65e, 0x31c2, 0x11d0, 0x89, 0x1c, 0x0, 0xa0, 0x24, 0xab, 0x2d, 0xbb);

//
// standard forms shipped in dsquery.dll
//

DEFINE_GUID(CLSID_DsFindObjects, 0x83ee3fe1, 0x57d9, 0x11d0, 0xb9, 0x32, 0x0, 0xa0, 0x24, 0xab, 0x2d, 0xbb);
DEFINE_GUID(CLSID_DsFindPeople, 0x83ee3fe2, 0x57d9, 0x11d0, 0xb9, 0x32, 0x0, 0xa0, 0x24, 0xab, 0x2d, 0xbb);
DEFINE_GUID(CLSID_DsFindPrinter, 0xb577f070, 0x7ee2, 0x11d0, 0x91, 0x3f, 0x0, 0xaa, 0x0, 0xc1, 0x6e, 0x65);
DEFINE_GUID(CLSID_DsFindComputer, 0x16006700, 0x87ad, 0x11d0, 0x91, 0x40, 0x0, 0xaa, 0x0, 0xc1, 0x6e, 0x65);
DEFINE_GUID(CLSID_DsFindVolume, 0xc1b3cbf1, 0x886a, 0x11d0, 0x91, 0x40, 0x0, 0xaa, 0x0, 0xc1, 0x6e, 0x65);
DEFINE_GUID(CLSID_DsFindContainer, 0xc1b3cbf2, 0x886a, 0x11d0, 0x91, 0x40, 0x0, 0xaa, 0x0, 0xc1, 0x6e, 0x65);
DEFINE_GUID(CLSID_DsFindAdvanced, 0x83ee3fe3, 0x57d9, 0x11d0, 0xb9, 0x32, 0x0, 0xa0, 0x24, 0xab, 0x2d, 0xbb);

//
// admin forms
//

DEFINE_GUID(CLSID_DsFindDomainController, 0x538c7b7e, 0xd25e, 0x11d0, 0x97, 0x42, 0x0, 0xa0, 0xc9, 0x6, 0xaf, 0x45);
DEFINE_GUID(CLSID_DsFindWriteableDomainController, 0x7cbef079, 0xaa84, 0x444b, 0xbc, 0x70, 0x68, 0xe4, 0x12, 0x83, 0xea, 0xbc);
DEFINE_GUID(CLSID_DsFindFrsMembers, 0x94ce4b18, 0xb3d3, 0x11d1, 0xb9, 0xb4, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0);


#ifndef GUID_DEFS_ONLY

//
// DSQUERYINITPARAMS
// -----------------
//  This structured is used when creating a new query view.
//

#define DSQPF_NOSAVE                 0x00000001 // = 1 => remove save verb
#define DSQPF_SAVELOCATION           0x00000002 // = 1 => pSaveLocation contains directory to save queries into
#define DSQPF_SHOWHIDDENOBJECTS      0x00000004 // = 1 => show objects marked as "hidden" in results
#define DSQPF_ENABLEADMINFEATURES    0x00000008 // = 1 => show admin verbs, property pages etc
#define DSQPF_ENABLEADVANCEDFEATURES 0x00000010 // = 1 => set the advanced flag for the property pages
#define DSQPF_HASCREDENTIALS         0x00000020 // = 1 => pServer, pUserName & pPassword are valid
#define DSQPF_NOCHOOSECOLUMNS        0x00000040 // = 1 => remove choose columns from view

typedef struct
{
    DWORD  cbStruct;
    DWORD  dwFlags;
    LPWSTR pDefaultScope;           // -> Active Directory path to use as scope / == NULL for none
    LPWSTR pDefaultSaveLocation;    // -> Directory to save queries into / == NULL default location
    LPWSTR pUserName;               // -> user name to authenticate with
    LPWSTR pPassword;               // -> password for authentication
    LPWSTR pServer;                 // -> server to use for obtaining trusts etc
} DSQUERYINITPARAMS, * LPDSQUERYINITPARAMS;


//
// DSQUERYPARAMS
// -------------
//  The DS query handle takes a packed structure which contains the
//  columns and query to be issued.
//

#define CFSTR_DSQUERYPARAMS         TEXT("DsQueryParameters")

#define DSCOLUMNPROP_ADSPATH        ((LONG)(-1))
#define DSCOLUMNPROP_OBJECTCLASS    ((LONG)(-2))

typedef struct
{
    DWORD dwFlags;                  // flags for this column
    INT   fmt;                      // list view form information
    INT   cx;                       // default column width
    INT   idsName;                  // resource ID for the column dispaly name
    LONG  offsetProperty;           // offset to BSTR defining column ADs property name
    DWORD dwReserved;               // reserved field
} DSCOLUMN, * LPDSCOLUMN;

typedef struct
{
    DWORD     cbStruct;
    DWORD     dwFlags;
    HINSTANCE hInstance;            // instance handle used for string extraction
    LONG      offsetQuery;          // offset to LDAP filter string
    LONG      iColumns;             // column count
    DWORD     dwReserved;           // reserved field for this query
    DSCOLUMN  aColumns[1];          // array of column descriptions
} DSQUERYPARAMS, * LPDSQUERYPARAMS;


//
// CF_DSQUERYSCOPE
// ---------------
//  A clipboard format the puts a string version of the scope into a
//  storage medium via GlobalAlloc.
//
#define CFSTR_DSQUERYSCOPE         TEXT("DsQueryScope")


//
// DSQPM_GETCLASSLIST
// ------------------
//  This page message is sent to the form pages to retrieve the list of classes
//  that the pages are going to query from.  This is used by the feild selector
//  and the property well to build its list of display classes.
//

typedef struct
{
    DWORD   cbStruct;
    LONG    cClasses;               // number of classes in array
    DWORD   offsetClass[1];         // offset to the class names (UNICODE)
} DSQUERYCLASSLIST, * LPDSQUERYCLASSLIST;


#define DSQPM_GETCLASSLIST          (CQPM_HANDLERSPECIFIC+0) // wParam == flags, lParam = LPLPDSQUERYCLASSLIST


//
// DSQPM_HELPTOPICS
// ----------------
//  This page message is sent to the form pages to allow them to handle the
//  "Help Topics" verb.
//

#define DSQPM_HELPTOPICS            (CQPM_HANDLERSPECIFIC+1) // wParam = 0, lParam = hWnd parent



#endif  // GUID_DEFS_ONLY
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\DskQuota.h ===
/**************************************************************************
*                                                                         *
*   dskquota.h --  public header for Windows 2000 disk quota interfaces.  *
*                                                                         *
*   Copyright (c) 1991-1999, Microsoft Corp. All rights reserved.         *
*                                                                         *
**************************************************************************/
#ifndef __DSKQUOTA_H
#define __DSKQUOTA_H

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _WINDOWS_
#include <windows.h>
#endif

#ifndef _OLE2_H_
#include <ole2.h>
#endif

#ifndef _OLECTL_H_
#include <olectl.h>
#endif

#ifdef INITGUIDS
#include <initguid.h>
#endif


//
// Class IDs
//
// {7988B571-EC89-11cf-9C00-00AA00A14F56}
DEFINE_GUID(CLSID_DiskQuotaControl,
0x7988b571, 0xec89, 0x11cf, 0x9c, 0x0, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x56);

//
// Interface IDs
//
// {7988B572-EC89-11cf-9C00-00AA00A14F56}
DEFINE_GUID(IID_IDiskQuotaControl,
0x7988b572, 0xec89, 0x11cf, 0x9c, 0x0, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x56);

// {7988B574-EC89-11cf-9C00-00AA00A14F56}
DEFINE_GUID(IID_IDiskQuotaUser,
0x7988b574, 0xec89, 0x11cf, 0x9c, 0x0, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x56);

// {7988B576-EC89-11cf-9C00-00AA00A14F56}
DEFINE_GUID(IID_IDiskQuotaUserBatch,
0x7988b576, 0xec89, 0x11cf, 0x9c, 0x0, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x56);

// {7988B577-EC89-11cf-9C00-00AA00A14F56}
DEFINE_GUID(IID_IEnumDiskQuotaUsers,
0x7988b577, 0xec89, 0x11cf, 0x9c, 0x0, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x56);

// {7988B579-EC89-11cf-9C00-00AA00A14F56}
DEFINE_GUID(IID_IDiskQuotaEvents,
0x7988b579, 0xec89, 0x11cf, 0x9c, 0x0, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x56);


//
// Definitions for value and bits in DWORD returned by 
// IDiskQuotaControl::GetQuotaState.
//
#define DISKQUOTA_STATE_DISABLED            0x00000000
#define DISKQUOTA_STATE_TRACK               0x00000001
#define DISKQUOTA_STATE_ENFORCE             0x00000002
#define DISKQUOTA_STATE_MASK                0x00000003
#define DISKQUOTA_FILESTATE_INCOMPLETE      0x00000100
#define DISKQUOTA_FILESTATE_REBUILDING      0x00000200
#define DISKQUOTA_FILESTATE_MASK            0x00000300

//
// Helper macros for setting and testing state value.
//
#define DISKQUOTA_SET_DISABLED(s) \
            ((s) &= ~DISKQUOTA_STATE_MASK)

#define DISKQUOTA_SET_TRACKED(s) \
            ((s) |= (DISKQUOTA_STATE_MASK & DISKQUOTA_STATE_TRACK))

#define DISKQUOTA_SET_ENFORCED(s) \
            ((s) |= (DISKQUOTA_STATE_ENFORCE & DISKQUOTA_STATE_ENFORCE))

#define DISKQUOTA_IS_DISABLED(s) \
            (DISKQUOTA_STATE_DISABLED == ((s) & DISKQUOTA_STATE_MASK))

#define DISKQUOTA_IS_TRACKED(s) \
            (DISKQUOTA_STATE_TRACK == ((s) & DISKQUOTA_STATE_MASK))

#define DISKQUOTA_IS_ENFORCED(s) \
            (DISKQUOTA_STATE_ENFORCE == ((s) & DISKQUOTA_STATE_MASK))
//
// These file state flags are read-only.
//
#define DISKQUOTA_FILE_INCOMPLETE(s) \
            (0 != ((s) & DISKQUOTA_FILESTATE_INCOMPLETE))

#define DISKQUOTA_FILE_REBUILDING(s) \
            (0 != ((s) & DISKQUOTA_FILESTATE_REBUILDING))


//
// Definitions for bits in DWORD returned by 
// IDiskQuotaControl::GetQuotaLogFlags.
//
#define DISKQUOTA_LOGFLAG_USER_THRESHOLD    0x00000001
#define DISKQUOTA_LOGFLAG_USER_LIMIT        0x00000002

//
// Helper macros to interrogate a log flags DWORD.
//
#define DISKQUOTA_IS_LOGGED_USER_THRESHOLD(f) \
            (0 != ((f) & DISKQUOTA_LOGFLAG_USER_THRESHOLD))

#define DISKQUOTA_IS_LOGGED_USER_LIMIT(f) \
            (0 != ((f) & DISKQUOTA_LOGFLAG_USER_LIMIT))

//
// Helper macros to set/clear bits in a log flags DWORD.
//
#define DISKQUOTA_SET_LOG_USER_THRESHOLD(f,yn) \
              ((f &= ~DISKQUOTA_LOGFLAG_USER_THRESHOLD) |= ((yn) ? DISKQUOTA_LOGFLAG_USER_THRESHOLD : 0))

#define DISKQUOTA_SET_LOG_USER_LIMIT(f,yn) \
              ((f &= ~DISKQUOTA_LOGFLAG_USER_LIMIT) |= ((yn) ? DISKQUOTA_LOGFLAG_USER_LIMIT : 0))

//
// Per-user quota information.
//
typedef struct DiskQuotaUserInformation {
    LONGLONG QuotaUsed;
    LONGLONG QuotaThreshold;
    LONGLONG QuotaLimit;
} DISKQUOTA_USER_INFORMATION, *PDISKQUOTA_USER_INFORMATION;


//
// Values for fNameResolution argument to:
//
//      IDiskQuotaControl::AddUserSid
//      IDiskQuotaControl::AddUserName
//      IDiskQuotaControl::FindUserSid
//      IDiskQuotaControl::CreateEnumUsers
//
#define DISKQUOTA_USERNAME_RESOLVE_NONE     0
#define DISKQUOTA_USERNAME_RESOLVE_SYNC     1
#define DISKQUOTA_USERNAME_RESOLVE_ASYNC    2

//
// Values for status returned by IDiskQuotaUser::GetAccountStatus.
//
#define DISKQUOTA_USER_ACCOUNT_RESOLVED     0
#define DISKQUOTA_USER_ACCOUNT_UNAVAILABLE  1
#define DISKQUOTA_USER_ACCOUNT_DELETED      2
#define DISKQUOTA_USER_ACCOUNT_INVALID      3
#define DISKQUOTA_USER_ACCOUNT_UNKNOWN      4
#define DISKQUOTA_USER_ACCOUNT_UNRESOLVED   5


//
// IDiskQuotaUser represents a single user quota record on a particular
// NTFS volume.  Objects using this interface are instantiated 
// through several IDiskQuotaControl methods.
//
#undef  INTERFACE
#define INTERFACE IDiskQuotaUser
DECLARE_INTERFACE_IID_(IDiskQuotaUser, IUnknown, "7988B574-EC89-11cf-9C00-00AA00A14F56")
{
    STDMETHOD(GetID)(THIS_
        ULONG *pulID) PURE;

    STDMETHOD(GetName)(THIS_
        LPWSTR pszAccountContainer,
        DWORD cchAccountContainer,
        LPWSTR pszLogonName,
        DWORD cchLogonName,
        LPWSTR pszDisplayName,
        DWORD cchDisplayName) PURE;

    STDMETHOD(GetSidLength)(THIS_
        LPDWORD pdwLength) PURE;

    STDMETHOD(GetSid)(THIS_
        LPBYTE pbSidBuffer,
        DWORD cbSidBuffer) PURE;

    STDMETHOD(GetQuotaThreshold)(THIS_
        PLONGLONG pllThreshold) PURE;

    STDMETHOD(GetQuotaThresholdText)(THIS_
        LPWSTR pszText,
        DWORD cchText) PURE;

    STDMETHOD(GetQuotaLimit)(THIS_
        PLONGLONG pllLimit) PURE;

    STDMETHOD(GetQuotaLimitText)(THIS_
        LPWSTR pszText,
        DWORD cchText) PURE;

    STDMETHOD(GetQuotaUsed)(THIS_
        PLONGLONG pllUsed) PURE;

    STDMETHOD(GetQuotaUsedText)(THIS_
        LPWSTR pszText,
        DWORD cchText) PURE;

    STDMETHOD(GetQuotaInformation)(THIS_
        LPVOID pbQuotaInfo,
        DWORD cbQuotaInfo) PURE;

    STDMETHOD(SetQuotaThreshold)(THIS_
        LONGLONG llThreshold,
        BOOL fWriteThrough) PURE;

    STDMETHOD(SetQuotaLimit)(THIS_
        LONGLONG llLimit,
        BOOL fWriteThrough) PURE;

    STDMETHOD(Invalidate)(THIS) PURE;

    STDMETHOD(GetAccountStatus)(THIS_
        LPDWORD pdwStatus) PURE;
};

typedef IDiskQuotaUser DISKQUOTA_USER, *PDISKQUOTA_USER;


//
// IEnumDiskQuotaUsers represents an enumerator created by 
// IDiskQuotaControl for the purpose of enumerating individual user quota
// records on a particular volume.  Each record is represented through
// the IDiskQuotaUser interface.
//
#undef  INTERFACE
#define INTERFACE IEnumDiskQuotaUsers
DECLARE_INTERFACE_IID_(IEnumDiskQuotaUsers, IUnknown, "7988B577-EC89-11cf-9C00-00AA00A14F56")
{
    STDMETHOD(Next)(THIS_
        DWORD cUsers,
        PDISKQUOTA_USER *rgUsers,
        LPDWORD pcUsersFetched) PURE;

    STDMETHOD(Skip)(THIS_
        DWORD cUsers) PURE;

    STDMETHOD(Reset)(THIS) PURE;

    STDMETHOD(Clone)(THIS_
        IEnumDiskQuotaUsers **ppEnum) PURE;
};

typedef IEnumDiskQuotaUsers ENUM_DISKQUOTA_USERS, *PENUM_DISKQUOTA_USERS;


//
// IDiskQuotaUserBatch represents a collection of IDiskQuotaUser 
// pointers for the purpose of grouping updates to quota information.
// 
#undef  INTERFACE
#define INTERFACE IDiskQuotaUserBatch
DECLARE_INTERFACE_IID_(IDiskQuotaUserBatch, IUnknown, "7988B576-EC89-11cf-9C00-00AA00A14F56")
{
    STDMETHOD(Add)(THIS_
        PDISKQUOTA_USER pUser) PURE;

    STDMETHOD(Remove)(THIS_
        PDISKQUOTA_USER pUser) PURE;

    STDMETHOD(RemoveAll)(THIS) PURE;

    STDMETHOD(FlushToDisk)(THIS) PURE;
};

typedef IDiskQuotaUserBatch DISKQUOTA_USER_BATCH, *PDISKQUOTA_USER_BATCH;


//
// IDiskQuotaControl represents a disk volume, providing query and 
// control of that volume's quota information.
//
#undef INTERFACE
#define INTERFACE IDiskQuotaControl
DECLARE_INTERFACE_IID_(IDiskQuotaControl, IConnectionPointContainer, "7988B572-EC89-11cf-9C00-00AA00A14F56")
{
    STDMETHOD(Initialize)(THIS_
        LPCWSTR pszPath,
        BOOL bReadWrite) PURE;

    STDMETHOD(SetQuotaState)(THIS_
        DWORD dwState) PURE;

    STDMETHOD(GetQuotaState)(THIS_
        LPDWORD pdwState) PURE;

    STDMETHOD(SetQuotaLogFlags)(THIS_
        DWORD dwFlags) PURE;

    STDMETHOD(GetQuotaLogFlags)(THIS_
        LPDWORD pdwFlags) PURE;

    STDMETHOD(SetDefaultQuotaThreshold)(THIS_
        LONGLONG llThreshold) PURE;

    STDMETHOD(GetDefaultQuotaThreshold)(THIS_
        PLONGLONG pllThreshold) PURE;

    STDMETHOD(GetDefaultQuotaThresholdText)(THIS_
        LPWSTR pszText,
        DWORD cchText) PURE;

    STDMETHOD(SetDefaultQuotaLimit)(THIS_
        LONGLONG llLimit) PURE;

    STDMETHOD(GetDefaultQuotaLimit)(THIS_
        PLONGLONG pllLimit) PURE;

    STDMETHOD(GetDefaultQuotaLimitText)(THIS_
        LPWSTR pszText,
        DWORD cchText) PURE;

    STDMETHOD(AddUserSid)(THIS_
        PSID pUserSid,
        DWORD fNameResolution,
        PDISKQUOTA_USER *ppUser) PURE;

    STDMETHOD(AddUserName)(THIS_
        LPCWSTR pszLogonName,
        DWORD fNameResolution,
        PDISKQUOTA_USER *ppUser) PURE;

    STDMETHOD(DeleteUser)(THIS_
        PDISKQUOTA_USER pUser) PURE;

    STDMETHOD(FindUserSid)(THIS_
        PSID pUserSid,
        DWORD fNameResolution,
        PDISKQUOTA_USER *ppUser) PURE;

    STDMETHOD(FindUserName)(THIS_
        LPCWSTR pszLogonName,
        PDISKQUOTA_USER *ppUser) PURE;

    STDMETHOD(CreateEnumUsers)(THIS_
        PSID *rgpUserSids,
        DWORD cpSids,
        DWORD fNameResolution,
        PENUM_DISKQUOTA_USERS *ppEnum) PURE;

    STDMETHOD(CreateUserBatch)(THIS_
        PDISKQUOTA_USER_BATCH *ppBatch) PURE;

    STDMETHOD(InvalidateSidNameCache)(THIS) PURE;

    STDMETHOD(GiveUserNameResolutionPriority)(THIS_
        PDISKQUOTA_USER pUser) PURE;

    STDMETHOD(ShutdownNameResolution)(THIS) PURE;
};

typedef IDiskQuotaControl DISKQUOTA_CONTROL, *PDISKQUOTA_CONTROL;



#undef  INTERFACE
#define INTERFACE IDiskQuotaEvents
DECLARE_INTERFACE_IID_(IDiskQuotaEvents, IUnknown, "7988B579-EC89-11cf-9C00-00AA00A14F56")
{
    STDMETHOD(OnUserNameChanged)(THIS_
        PDISKQUOTA_USER pUser) PURE;
};

typedef IDiskQuotaEvents DISKQUOTA_EVENTS, *PDISKQUOTA_EVENTS;



#endif // __DSKQUOTA_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dv.h ===
//------------------------------------------------------------------------------
// File: DV.h
//
// Desc: DV typedefs and defines.
//
// Copyright (c) 1997 - 2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef _DV_H_
#define _DV_H_

#define DV_DVSD_NTSC_FRAMESIZE	120000L
#define DV_DVSD_PAL_FRAMESIZE	144000L

#define DV_SMCHN	0x0000e000
#define DV_AUDIOMODE    0x00000f00
#define DV_AUDIOSMP	0x38000000

#define DV_AUDIOQU	0x07000000
#define DV_NTSCPAL	0x00200000
#define DV_STYPE	0x001f0000


//There are NTSC or PAL DV camcorders  
#define DV_NTSC		    0
#define DV_PAL		    1
//DV camcorder can output sd/hd/sl  
#define DV_SD		    0x00
#define DV_HD		    0x01
#define DV_SL		    0x02
//user can choice 12 bits or 16 bits audio from DV camcorder
#define DV_CAP_AUD16Bits    0x00
#define DV_CAP_AUD12Bits    0x01

#define SIZE_DVINFO	    0x20    

typedef struct Tag_DVAudInfo
{
	BYTE    bAudStyle[2];           
	//LSB 6 bits for starting DIF sequence number
	//MSB 2 bits: 0 for mon. 1: stereo in one 5/6 DIF sequences, 2: stereo audio in both 5/6 DIF sequences
	//example: 0x00: mon, audio in first 5/6 DIF sequence
	//                 0x05: mon, audio in 2nd 5 DIF sequence
	//                 0x15: stereo, audio only in 2nd 5 DIF sequence
	//                 0x10: stereo, audio only in 1st 5/6 DIF sequence
	//                 0x20: stereo, left ch in 1st 5/6 DIF sequence, right ch in 2nd 5/6 DIF sequence
	//                 0x26: stereo, rightch in 1st 6 DIF sequence, left ch in 2nd 6 DIF sequence
	BYTE    bAudQu[2];                      //qbits, only support 12, 16,           
		
	BYTE    bNumAudPin;                     //how many pin(language)
	WORD    wAvgSamplesPerPinPerFrm[2];     //samples size for one audio pin in one frame(which has 10 or 12 DIF sequence) 
	WORD    wBlkMode;                       //45 for NTSC, 54 for PAL
	WORD    wDIFMode;                       //5  for NTSC, 6 for PAL
	WORD    wBlkDiv;                        //15  for NTSC, 18 for PAL
} DVAudInfo;
	  
#endif // _DV_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dssec.h ===
#ifndef _DSSEC_H_
#define _DSSEC_H_

#include <aclui.h>  // LPSECURITYINFO


//+---------------------------------------------------------------------------
//
//  Function:   PFNREADOBJECTSECURITY
//
//  Synopsis:   Reads the security descriptor of a DS object
//
//  Arguments:  [IN  LPCWSTR]               --  ADS path of DS Object
//              [IN  SECURITY_INFORMATION]  --  Which SD parts to read
//              [OUT PSECURITY_DESCRIPTOR*] --  Return SD here. Caller frees with LocalFree
//              [IN  LPARAM]                --  Context param
//
//  Return:     HRESULT
//
//----------------------------------------------------------------------------
//
//  Function:   PFNWRITEOBJECTSECURITY
//
//  Synopsis:   Writes a security descriptor to a DS object
//
//  Arguments:  [IN  LPCWSTR]               --  ADS path of DS Object
//              [IN  SECURITY_INFORMATION]  --  Which SD parts to write
//              [OUT PSECURITY_DESCRIPTOR]  --  Security descriptor to write
//              [IN  LPARAM]                --  Context param
//
//  Return:     HRESULT
//
//----------------------------------------------------------------------------
typedef HRESULT (WINAPI *PFNREADOBJECTSECURITY)(LPCWSTR, SECURITY_INFORMATION, PSECURITY_DESCRIPTOR*, LPARAM);
typedef HRESULT (WINAPI *PFNWRITEOBJECTSECURITY)(LPCWSTR, SECURITY_INFORMATION, PSECURITY_DESCRIPTOR, LPARAM);

//+---------------------------------------------------------------------------
//
//  Function:   DSCreateISecurityInfoObject
//
//  Synopsis:   Instantiates an ISecurityInfo interface for a DS object
//
//  Arguments:  [IN  pwszObjectPath]    --  Full ADS path of DS object
//              [IN  pwszObjectClass]   --  Class of the object (optional)
//              [IN  dwFlags]           --  Combination of DSSI_* flags
//              [OUT ppSI]              --  Interface pointer returned here
//              [IN  pfnReadSD]         --  Optional function for reading SD
//              [IN  pfnWriteSD]        --  Optional function for writing SD
//              [IN  LPARAM]            --  Passed to pfnReadSD/pfnWriteSD
//
//  Return:     HRESULT
//
//----------------------------------------------------------------------------
STDAPI
DSCreateISecurityInfoObject(LPCWSTR pwszObjectPath,
                            LPCWSTR pwszObjectClass,
                            DWORD dwFlags,
                            __out LPSECURITYINFO *ppSI,
                            __in_opt PFNREADOBJECTSECURITY pfnReadSD,
                            __in_opt PFNWRITEOBJECTSECURITY pfnWriteSD,
                            LPARAM lpContext);

// Flags for DSCreateISecurityInfoObject
#define DSSI_READ_ONLY          0x00000001
#define DSSI_NO_ACCESS_CHECK    0x00000002
#define DSSI_NO_EDIT_SACL       0x00000004
#define DSSI_NO_EDIT_OWNER      0x00000008
#define DSSI_IS_ROOT            0x00000010
#define DSSI_NO_FILTER          0x00000020
#define DSSI_NO_READONLY_MESSAGE          0x00000040

//
// Same as above, with optional server, user & password arguments.
// If use & password are not provided, ADSI defaults are used.
// If the server is not provided, it is obtained from the object
// path or DsGetDcName.
//
STDAPI
DSCreateISecurityInfoObjectEx(LPCWSTR pwszObjectPath,
                              LPCWSTR pwszObjectClass,
                              LPCWSTR pwszServer,
                              LPCWSTR pwszUserName,
                              LPCWSTR pwszPassword,
                              DWORD   dwFlags,
                              __out LPSECURITYINFO *ppSI,
                              __in_opt PFNREADOBJECTSECURITY  pfnReadSD,
                              __in_opt PFNWRITEOBJECTSECURITY pfnWriteSD,
                              LPARAM lpContext);


//+---------------------------------------------------------------------------
//
//  Function:   DSCreateSecurityPage
//
//  Synopsis:   Creates a Security property page for a DS object
//
//  Arguments:  [IN  pwszObjectPath]    --  Full ADS path of DS object
//              [IN  pwszObjectClass]   --  Class of the object (optional)
//              [IN  dwFlags]           --  Combination of DSSI_* flags
//              [OUT phPage]            --  HPROPSHEETPAGE returned here
//              [IN  pfnReadSD]         --  Optional function for reading SD
//              [IN  pfnWriteSD]        --  Optional function for writing SD
//              [IN  LPARAM]            --  Passed to pfnReadSD/pfnWriteSD
//
//  Return:     HRESULT
//
//----------------------------------------------------------------------------
STDAPI
DSCreateSecurityPage(LPCWSTR pwszObjectPath,
                     LPCWSTR pwszObjectClass,
                     DWORD dwFlags,
                     __out HPROPSHEETPAGE *phPage,
                     __in_opt PFNREADOBJECTSECURITY pfnReadSD,
                     __in_opt PFNWRITEOBJECTSECURITY pfnWriteSD,
                     LPARAM lpContext);

//+---------------------------------------------------------------------------
//
//  Function:   DSEditSecurity
//
//  Synopsis:   Displays a modal dialog for editing security on a DS object
//
//  Arguments:  [IN  hwndOwner]         --  Dialog owner window
//              [IN  pwszObjectPath]    --  Full ADS path of DS object
//              [IN  pwszObjectClass]   --  Class of the object (optional)
//              [IN  dwFlags]           --  Combination of DSSI_* flags
//              [IN  pwszCaption]       --  Optional dialog caption
//              [IN  pfnReadSD]         --  Optional function for reading SD
//              [IN  pfnWriteSD]        --  Optional function for writing SD
//              [IN  LPARAM]            --  Passed to pfnReadSD/pfnWriteSD
//
//  Return:     HRESULT
//
//----------------------------------------------------------------------------
STDAPI
DSEditSecurity(HWND hwndOwner,
               LPCWSTR pwszObjectPath,
               LPCWSTR pwszObjectClass,
               DWORD dwFlags,
               LPCWSTR pwszCaption,
               __in_opt PFNREADOBJECTSECURITY pfnReadSD,
               __in_opt PFNWRITEOBJECTSECURITY pfnWriteSD,
               LPARAM lpContext);


typedef HRESULT (WINAPI *PFNDSCREATEISECINFO)(LPCWSTR,
                                              LPCWSTR,
                                              DWORD,
                                              LPSECURITYINFO*,
                                              PFNREADOBJECTSECURITY,
                                              PFNWRITEOBJECTSECURITY,
                                              LPARAM);

typedef HRESULT (WINAPI *PFNDSCREATEISECINFOEX)(LPCWSTR,
                                                LPCWSTR,
                                                LPCWSTR,
                                                LPCWSTR,
                                                LPCWSTR,
                                                DWORD,
                                                LPSECURITYINFO*,
                                                PFNREADOBJECTSECURITY,
                                                PFNWRITEOBJECTSECURITY,
                                                LPARAM);

typedef HRESULT (WINAPI *PFNDSCREATESECPAGE)(LPCWSTR,
                                             LPCWSTR,
                                             DWORD,
                                             HPROPSHEETPAGE*,
                                             PFNREADOBJECTSECURITY,
                                             PFNWRITEOBJECTSECURITY,
                                             LPARAM);

typedef HRESULT (WINAPI *PFNDSEDITSECURITY)(HWND,
                                            LPCWSTR,
                                            LPCWSTR,
                                            DWORD,
                                            LPCWSTR,
                                            PFNREADOBJECTSECURITY,
                                            PFNWRITEOBJECTSECURITY,
                                            LPARAM);

#endif  /* _DSSEC_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\DSRole.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    dsrole.h

Abstract:

    This module contains the public interfaces to query the network roles of 
    workstations, servers, and DCs

--*/

#ifndef __DSROLE_H__
#define __DSROLE_H__

#if _MSC_VER > 1000
#pragma once
#endif


#ifdef __cplusplus
extern "C" {
#endif

//
// Domain information
//
typedef enum _DSROLE_MACHINE_ROLE {

    DsRole_RoleStandaloneWorkstation,
    DsRole_RoleMemberWorkstation,
    DsRole_RoleStandaloneServer,
    DsRole_RoleMemberServer,
    DsRole_RoleBackupDomainController,
    DsRole_RolePrimaryDomainController

} DSROLE_MACHINE_ROLE;

//
// Previous server state
//
typedef enum _DSROLE_SERVER_STATE {

    DsRoleServerUnknown = 0,
    DsRoleServerPrimary,
    DsRoleServerBackup

} DSROLE_SERVER_STATE, *PDSROLE_SERVER_STATE;

typedef enum _DSROLE_PRIMARY_DOMAIN_INFO_LEVEL {

    DsRolePrimaryDomainInfoBasic = 1,
    DsRoleUpgradeStatus,
    DsRoleOperationState

} DSROLE_PRIMARY_DOMAIN_INFO_LEVEL;

//
// Flags to be used with the PRIMARY_DOMAIN_INFO_LEVEL structures below
//
#define DSROLE_PRIMARY_DS_RUNNING           0x00000001
#define DSROLE_PRIMARY_DS_MIXED_MODE        0x00000002
#define DSROLE_UPGRADE_IN_PROGRESS          0x00000004
#define DSROLE_PRIMARY_DS_READONLY          0x00000008
#define DSROLE_PRIMARY_DOMAIN_GUID_PRESENT  0x01000000

//
// Structure that correspond to the DSROLE_PRIMARY_DOMAIN_INFO_LEVEL
//
typedef struct _DSROLE_PRIMARY_DOMAIN_INFO_BASIC {

    DSROLE_MACHINE_ROLE MachineRole;
    ULONG Flags;
    LPWSTR DomainNameFlat;
    LPWSTR DomainNameDns;
    LPWSTR DomainForestName;
    GUID DomainGuid;

} DSROLE_PRIMARY_DOMAIN_INFO_BASIC, *PDSROLE_PRIMARY_DOMAIN_INFO_BASIC;

typedef struct _DSROLE_UPGRADE_STATUS_INFO {

    ULONG OperationState;
    DSROLE_SERVER_STATE PreviousServerState;

} DSROLE_UPGRADE_STATUS_INFO, *PDSROLE_UPGRADE_STATUS_INFO;

typedef enum _DSROLE_OPERATION_STATE {

    DsRoleOperationIdle = 0,
    DsRoleOperationActive,
    DsRoleOperationNeedReboot

} DSROLE_OPERATION_STATE;

typedef struct _DSROLE_OPERATION_STATE_INFO {

    DSROLE_OPERATION_STATE OperationState;

} DSROLE_OPERATION_STATE_INFO, *PDSROLE_OPERATION_STATE_INFO;

DWORD
WINAPI
DsRoleGetPrimaryDomainInformation(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  DSROLE_PRIMARY_DOMAIN_INFO_LEVEL InfoLevel,
    OUT PBYTE *Buffer 
    );

VOID
WINAPI
DsRoleFreeMemory(
    IN PVOID    Buffer
    );


#ifdef __cplusplus
}
#endif

#endif // __DSROLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\DtcHelp.h ===
/* ----------------------------------------------------------------------------
Microsoft	D.T.C (Distributed Transaction Coordinator)

Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.

@doc

@module		DTCHelp.h	|

			contains helper API for loading the DTCHelper DLL

-------------------------------------------------------------------------------
@rev 	0 	| 8th -Sep-1995	|	GaganC		| Created
----------------------------------------------------------------------------- */
#ifndef __DTCHELP_H__
#define __DTCHELP_H__


//---------------------------------------------------------
//		ALL INCLUDE FILES GO HERE
//---------------------------------------------------------
#include <windows.h>


//---------------------------------------------------------
// constants / enums / typedefs / defines
//---------------------------------------------------------
#ifndef DEFINED_DTC_STATUS
typedef enum DTC_STATUS_
{
	DTC_STATUS_UNKNOWN = 0,			// Status not known
	DTC_STATUS_STARTING = 1,		// DTC is starting
	DTC_STATUS_STARTED = 2,			// DTC has started
	DTC_STATUS_PAUSING = 3,			// DTC is being paused
	DTC_STATUS_PAUSED = 4,			// DTC has been paused
	DTC_STATUS_CONTINUING = 5,		// DTC is being continued
	DTC_STATUS_STOPPING = 6,		// DTC is stopping
	DTC_STATUS_STOPPED = 7,			// DTC has stopped
	DTC_STATUS_E_CANTCONTROL = 8,	// DTC cannot be controlled in its present state
	DTC_STATUS_FAILED = 9			// DTC has failed.
} DTC_STATUS;
#define DEFINED_DTC_STATUS
#endif

typedef HRESULT  (__cdecl * DTC_GET_TRANSACTION_MANAGER)(
									/* in */ char * pszHost,
									/* in */ char * pszTmName,
									/* in */ REFIID rid,
									/* in */ DWORD	dwReserved1,
									/* in */ WORD	wcbReserved2,
									/* in */ void FAR * pvReserved2,
									/*out */ void** ppvObject )	;

typedef HRESULT  (__cdecl * DTC_GET_TRANSACTION_MANAGER_EX_A)(
									/* in */ char * i_pszHost,
									/* in */ char * i_pszTmName,
									/* in */ REFIID i_riid,
									/* in */ DWORD i_grfOptions,
									/* in */ void * i_pvConfigParams,
									/* out */ void ** o_ppvObject
									);

typedef HRESULT  (__cdecl * DTC_GET_TRANSACTION_MANAGER_EX_W)(
									/* in */ WCHAR * i_pwszHost,
									/* in */ WCHAR * i_pwszTmName,
									/* in */ REFIID i_riid,
									/* in */ DWORD i_grfOptions,
									/* in */ void * i_pvConfigParams,
									/* out */ void ** o_ppvObject
									);

typedef HRESULT	( * DTC_INSTALL_CLIENT ) ( 
									   LPTSTR i_pszRemoteTmHostName, 
									   DWORD i_dwProtocol,
									   DWORD i_dwOverwrite );

#ifndef UNICODE 

#define DTC_GET_TRANSACTION_MANAGER_EX		DTC_GET_TRANSACTION_MANAGER_EX_A
#define LoadDtcHelperEx						LoadDtcHelperExA
#define	GetDTCStatus						GetDTCStatusA
#define	StartDTC							StartDTCA
#define	StopDTC								StopDTCA

#else

#define DTC_GET_TRANSACTION_MANAGER_EX		DTC_GET_TRANSACTION_MANAGER_EX_W
#define LoadDtcHelperEx						LoadDtcHelperExW
#define	GetDTCStatus						GetDTCStatusW
#define	StartDTC							StartDTCW
#define	StopDTC								StopDTCW

#endif 



#define	DTCINSTALL_E_CLIENT_ALREADY_INSTALLED					0x0000180L

#define	DTCINSTALL_E_SERVER_ALREADY_INSTALLED					0x0000181L

//***** Install overwrite options
const	DWORD	DTC_INSTALL_OVERWRITE_CLIENT	=	0x00000001;
													// first bit from right, controls client overwrite
													// 1=Overwrite existing client install
													// 0=dont overwrite existing client install
const	DWORD	DTC_INSTALL_OVERWRITE_SERVER	=	0x00000002;
													//  second bit from right, controls server overwrite
													// 1=Overwrite existing server install
													// 0=dont overwrite existing server install

//---------------------------------------------------------
//			Function Prototypes
//---------------------------------------------------------
EXTERN_C
{
	DTC_GET_TRANSACTION_MANAGER			__cdecl LoadDtcHelper (void);
	DTC_GET_TRANSACTION_MANAGER_EX_A	__cdecl LoadDtcHelperExA (void);
	DTC_GET_TRANSACTION_MANAGER_EX_W	__cdecl LoadDtcHelperExW (void);
	void								__cdecl FreeDtcHelper (void);

	HMODULE __cdecl GetDtcLocaleResourceHandle(void);

	// Function:	Initialize
	// This function initialized all the function pointers needed to 
	// carry out other operations supported by this static library.
	// It is optional to make this call.
	// Returns - S_OK if all is fine, E_FAIL other wise.
	// Note: this function is not thread safe
	HRESULT __cdecl Initialize (void);

	// Function:	Uninitialize
	// This function unloads the dynamically loaded dlls.
	// Returns - S_OK if all is fine, E_FAIL other wise.
	// Note: this function is not thread safe
	HRESULT __cdecl Uninitialize (void);

	// Function:	GetDTCStatusW
	// Unicode version of GetDTCStatus - used to get the status of the DTC service.
	// The wszHostName parameter specifies the node on which to perform the 
	// operation.  On Windows 9x this parameter must be either NULL or the local
	// machine name.
	// Returns - the appropriate status from the enum DTC_STATUS
	DTC_STATUS __cdecl GetDTCStatusW (__in LPWSTR wszHostName);

	// Function:	GetDTCStatusA
	// Ansi version of GetDTCStatus - used to get the status of the DTC service
	// The szHostName parameter specifies the node on which to perform the 
	// operation.  On Windows 9x this parameter must be either NULL or the local
	// machine name.
	// Returns - the appropriate status from the enum DTC_STATUS
	DTC_STATUS __cdecl GetDTCStatusA (__in LPSTR szHostName);

	// Function:	StartDTCW
	// Unicode version of StartDTC - used to start the DTC service.
	// If the service is already started then the following is a no-op
	// The wszHostName parameter specifies the node on which to perform the 
	// operation.  On Windows 9x this parameter must be either NULL or the local
	// machine name.
	// Returns -	S_OK if all is ok
	// 			E_FAIL if the operation failed for some reason.
	// 			E_UNEXPECTED if an unexpected error occured.
	HRESULT __cdecl StartDTCW (__in LPWSTR wszHostName);

	// Function:	StartDTCA
	// Ansi version of StartDTC - used to start the DTC service.
	// If the service is already started then the following is a no-op
	// The szHostName parameter specifies the node on which to perform the 
	// operation.  On Windows 9x this parameter must be either NULL or the local
	// machine name.
	// Returns -	S_OK if all is ok
	// 			E_FAIL if the operation failed for some reason.
	// 			E_UNEXPECTED if an unexpected error occured.
	HRESULT __cdecl StartDTCA (__in LPSTR szHostName);

	// Function:	StopDTCW
	// Unicode version of StopDTC - used to stop the DTC service.
	// If the service is already stopped then the following is a no-op
	// The wszHostName parameter specifies the node on which to perform the 
	// operation.  On Windows 9x this parameter must be either NULL or the local
	// machine name.
	// Returns -	S_OK if all is ok
	// 			E_FAIL if the operation failed for some reason.
	// 			E_UNEXPECTED if an unexpected error occured.
	HRESULT __cdecl StopDTCW (__in LPWSTR wszHostName);

	// Function:	StopDTCA
	// Ansi version of StopDTC - used to stop the DTC service.
	// If the service is already stopped then the following is a no-op
	// The szHostName parameter specifies the node on which to perform the 
	// operation.  On Windows 9x this parameter must be either NULL or the local
	// machine name.
	// Returns -	S_OK if all is ok
	// 			E_FAIL if the operation failed for some reason.
	// 			E_UNEXPECTED if an unexpected error occured.
	HRESULT __cdecl StopDTCA (__in LPSTR szHostName);


	//  Function:	DtcInstallClient
	//  Installs the client version of DTC.
	//  Parameters:	i_pszRemoteTmHostName	- the name of the host tm,
	//			i_szProt				- the protocol to use in string format
	//									0x00000001	TCP/IP  (1)
	//									0x00000004	NetBEUI	(4)
	//										
	//			i_dwOverwrite			- overwrite previous install or not?
	//			DTC_INSTALL_OVERWRITE_CLIENT	=	0x00000001;
													// 0=Overwrite existing client install
													// 1=dont overwrite existing client install
	//			DTC_INSTALL_OVERWRITE_SERVER	=	0x00000002;
													// 0=Overwrite existing server install
													// 1=dont overwrite existing server install
	//  Returns -	S_OK if all is ok
	//			E_FAIL if the operation failed for some reason
	//  E_UNEXPECTED if an unexpected error occured
	HRESULT __cdecl DtcInstallClient(__in LPTSTR i_pszRemoteTmHostName, DWORD i_dwProtocol, DWORD i_dwOverwrite);
}


//---------------------------------------------------------
//			ALL ERRORS GO HERE
//---------------------------------------------------------


#endif __DTCHELP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dvbsiparser.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for dvbsiparser.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dvbsiparser_h__
#define __dvbsiparser_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDvbSiParser_FWD_DEFINED__
#define __IDvbSiParser_FWD_DEFINED__
typedef interface IDvbSiParser IDvbSiParser;
#endif 	/* __IDvbSiParser_FWD_DEFINED__ */


#ifndef __IDvbSiParser2_FWD_DEFINED__
#define __IDvbSiParser2_FWD_DEFINED__
typedef interface IDvbSiParser2 IDvbSiParser2;
#endif 	/* __IDvbSiParser2_FWD_DEFINED__ */


#ifndef __IIsdbSiParser2_FWD_DEFINED__
#define __IIsdbSiParser2_FWD_DEFINED__
typedef interface IIsdbSiParser2 IIsdbSiParser2;
#endif 	/* __IIsdbSiParser2_FWD_DEFINED__ */


#ifndef __IDVB_NIT_FWD_DEFINED__
#define __IDVB_NIT_FWD_DEFINED__
typedef interface IDVB_NIT IDVB_NIT;
#endif 	/* __IDVB_NIT_FWD_DEFINED__ */


#ifndef __IDVB_SDT_FWD_DEFINED__
#define __IDVB_SDT_FWD_DEFINED__
typedef interface IDVB_SDT IDVB_SDT;
#endif 	/* __IDVB_SDT_FWD_DEFINED__ */


#ifndef __IISDB_SDT_FWD_DEFINED__
#define __IISDB_SDT_FWD_DEFINED__
typedef interface IISDB_SDT IISDB_SDT;
#endif 	/* __IISDB_SDT_FWD_DEFINED__ */


#ifndef __IDVB_EIT_FWD_DEFINED__
#define __IDVB_EIT_FWD_DEFINED__
typedef interface IDVB_EIT IDVB_EIT;
#endif 	/* __IDVB_EIT_FWD_DEFINED__ */


#ifndef __IDVB_EIT2_FWD_DEFINED__
#define __IDVB_EIT2_FWD_DEFINED__
typedef interface IDVB_EIT2 IDVB_EIT2;
#endif 	/* __IDVB_EIT2_FWD_DEFINED__ */


#ifndef __IDVB_BAT_FWD_DEFINED__
#define __IDVB_BAT_FWD_DEFINED__
typedef interface IDVB_BAT IDVB_BAT;
#endif 	/* __IDVB_BAT_FWD_DEFINED__ */


#ifndef __IDVB_RST_FWD_DEFINED__
#define __IDVB_RST_FWD_DEFINED__
typedef interface IDVB_RST IDVB_RST;
#endif 	/* __IDVB_RST_FWD_DEFINED__ */


#ifndef __IDVB_ST_FWD_DEFINED__
#define __IDVB_ST_FWD_DEFINED__
typedef interface IDVB_ST IDVB_ST;
#endif 	/* __IDVB_ST_FWD_DEFINED__ */


#ifndef __IDVB_TDT_FWD_DEFINED__
#define __IDVB_TDT_FWD_DEFINED__
typedef interface IDVB_TDT IDVB_TDT;
#endif 	/* __IDVB_TDT_FWD_DEFINED__ */


#ifndef __IDVB_TOT_FWD_DEFINED__
#define __IDVB_TOT_FWD_DEFINED__
typedef interface IDVB_TOT IDVB_TOT;
#endif 	/* __IDVB_TOT_FWD_DEFINED__ */


#ifndef __IDVB_DIT_FWD_DEFINED__
#define __IDVB_DIT_FWD_DEFINED__
typedef interface IDVB_DIT IDVB_DIT;
#endif 	/* __IDVB_DIT_FWD_DEFINED__ */


#ifndef __IDVB_SIT_FWD_DEFINED__
#define __IDVB_SIT_FWD_DEFINED__
typedef interface IDVB_SIT IDVB_SIT;
#endif 	/* __IDVB_SIT_FWD_DEFINED__ */


#ifndef __IISDB_BIT_FWD_DEFINED__
#define __IISDB_BIT_FWD_DEFINED__
typedef interface IISDB_BIT IISDB_BIT;
#endif 	/* __IISDB_BIT_FWD_DEFINED__ */


#ifndef __IISDB_NBIT_FWD_DEFINED__
#define __IISDB_NBIT_FWD_DEFINED__
typedef interface IISDB_NBIT IISDB_NBIT;
#endif 	/* __IISDB_NBIT_FWD_DEFINED__ */


#ifndef __IISDB_LDT_FWD_DEFINED__
#define __IISDB_LDT_FWD_DEFINED__
typedef interface IISDB_LDT IISDB_LDT;
#endif 	/* __IISDB_LDT_FWD_DEFINED__ */


#ifndef __IISDB_SDTT_FWD_DEFINED__
#define __IISDB_SDTT_FWD_DEFINED__
typedef interface IISDB_SDTT IISDB_SDTT;
#endif 	/* __IISDB_SDTT_FWD_DEFINED__ */


#ifndef __IISDB_CDT_FWD_DEFINED__
#define __IISDB_CDT_FWD_DEFINED__
typedef interface IISDB_CDT IISDB_CDT;
#endif 	/* __IISDB_CDT_FWD_DEFINED__ */


#ifndef __IISDB_EMM_FWD_DEFINED__
#define __IISDB_EMM_FWD_DEFINED__
typedef interface IISDB_EMM IISDB_EMM;
#endif 	/* __IISDB_EMM_FWD_DEFINED__ */


#ifndef __IDvbServiceAttributeDescriptor_FWD_DEFINED__
#define __IDvbServiceAttributeDescriptor_FWD_DEFINED__
typedef interface IDvbServiceAttributeDescriptor IDvbServiceAttributeDescriptor;
#endif 	/* __IDvbServiceAttributeDescriptor_FWD_DEFINED__ */


#ifndef __IDvbContentIdentifierDescriptor_FWD_DEFINED__
#define __IDvbContentIdentifierDescriptor_FWD_DEFINED__
typedef interface IDvbContentIdentifierDescriptor IDvbContentIdentifierDescriptor;
#endif 	/* __IDvbContentIdentifierDescriptor_FWD_DEFINED__ */


#ifndef __IDvbDefaultAuthorityDescriptor_FWD_DEFINED__
#define __IDvbDefaultAuthorityDescriptor_FWD_DEFINED__
typedef interface IDvbDefaultAuthorityDescriptor IDvbDefaultAuthorityDescriptor;
#endif 	/* __IDvbDefaultAuthorityDescriptor_FWD_DEFINED__ */


#ifndef __IDvbSatelliteDeliverySystemDescriptor_FWD_DEFINED__
#define __IDvbSatelliteDeliverySystemDescriptor_FWD_DEFINED__
typedef interface IDvbSatelliteDeliverySystemDescriptor IDvbSatelliteDeliverySystemDescriptor;
#endif 	/* __IDvbSatelliteDeliverySystemDescriptor_FWD_DEFINED__ */


#ifndef __IDvbCableDeliverySystemDescriptor_FWD_DEFINED__
#define __IDvbCableDeliverySystemDescriptor_FWD_DEFINED__
typedef interface IDvbCableDeliverySystemDescriptor IDvbCableDeliverySystemDescriptor;
#endif 	/* __IDvbCableDeliverySystemDescriptor_FWD_DEFINED__ */


#ifndef __IDvbTerrestrialDeliverySystemDescriptor_FWD_DEFINED__
#define __IDvbTerrestrialDeliverySystemDescriptor_FWD_DEFINED__
typedef interface IDvbTerrestrialDeliverySystemDescriptor IDvbTerrestrialDeliverySystemDescriptor;
#endif 	/* __IDvbTerrestrialDeliverySystemDescriptor_FWD_DEFINED__ */


#ifndef __IDvbTerrestrial2DeliverySystemDescriptor_FWD_DEFINED__
#define __IDvbTerrestrial2DeliverySystemDescriptor_FWD_DEFINED__
typedef interface IDvbTerrestrial2DeliverySystemDescriptor IDvbTerrestrial2DeliverySystemDescriptor;
#endif 	/* __IDvbTerrestrial2DeliverySystemDescriptor_FWD_DEFINED__ */


#ifndef __IDvbFrequencyListDescriptor_FWD_DEFINED__
#define __IDvbFrequencyListDescriptor_FWD_DEFINED__
typedef interface IDvbFrequencyListDescriptor IDvbFrequencyListDescriptor;
#endif 	/* __IDvbFrequencyListDescriptor_FWD_DEFINED__ */


#ifndef __IDvbPrivateDataSpecifierDescriptor_FWD_DEFINED__
#define __IDvbPrivateDataSpecifierDescriptor_FWD_DEFINED__
typedef interface IDvbPrivateDataSpecifierDescriptor IDvbPrivateDataSpecifierDescriptor;
#endif 	/* __IDvbPrivateDataSpecifierDescriptor_FWD_DEFINED__ */


#ifndef __IDvbLogicalChannelDescriptor_FWD_DEFINED__
#define __IDvbLogicalChannelDescriptor_FWD_DEFINED__
typedef interface IDvbLogicalChannelDescriptor IDvbLogicalChannelDescriptor;
#endif 	/* __IDvbLogicalChannelDescriptor_FWD_DEFINED__ */


#ifndef __IDvbLogicalChannelDescriptor2_FWD_DEFINED__
#define __IDvbLogicalChannelDescriptor2_FWD_DEFINED__
typedef interface IDvbLogicalChannelDescriptor2 IDvbLogicalChannelDescriptor2;
#endif 	/* __IDvbLogicalChannelDescriptor2_FWD_DEFINED__ */


#ifndef __IDvbLogicalChannel2Descriptor_FWD_DEFINED__
#define __IDvbLogicalChannel2Descriptor_FWD_DEFINED__
typedef interface IDvbLogicalChannel2Descriptor IDvbLogicalChannel2Descriptor;
#endif 	/* __IDvbLogicalChannel2Descriptor_FWD_DEFINED__ */


#ifndef __IDvbHDSimulcastLogicalChannelDescriptor_FWD_DEFINED__
#define __IDvbHDSimulcastLogicalChannelDescriptor_FWD_DEFINED__
typedef interface IDvbHDSimulcastLogicalChannelDescriptor IDvbHDSimulcastLogicalChannelDescriptor;
#endif 	/* __IDvbHDSimulcastLogicalChannelDescriptor_FWD_DEFINED__ */


#ifndef __IDvbDataBroadcastIDDescriptor_FWD_DEFINED__
#define __IDvbDataBroadcastIDDescriptor_FWD_DEFINED__
typedef interface IDvbDataBroadcastIDDescriptor IDvbDataBroadcastIDDescriptor;
#endif 	/* __IDvbDataBroadcastIDDescriptor_FWD_DEFINED__ */


#ifndef __IDvbDataBroadcastDescriptor_FWD_DEFINED__
#define __IDvbDataBroadcastDescriptor_FWD_DEFINED__
typedef interface IDvbDataBroadcastDescriptor IDvbDataBroadcastDescriptor;
#endif 	/* __IDvbDataBroadcastDescriptor_FWD_DEFINED__ */


#ifndef __IDvbLinkageDescriptor_FWD_DEFINED__
#define __IDvbLinkageDescriptor_FWD_DEFINED__
typedef interface IDvbLinkageDescriptor IDvbLinkageDescriptor;
#endif 	/* __IDvbLinkageDescriptor_FWD_DEFINED__ */


#ifndef __IDvbTeletextDescriptor_FWD_DEFINED__
#define __IDvbTeletextDescriptor_FWD_DEFINED__
typedef interface IDvbTeletextDescriptor IDvbTeletextDescriptor;
#endif 	/* __IDvbTeletextDescriptor_FWD_DEFINED__ */


#ifndef __IDvbSubtitlingDescriptor_FWD_DEFINED__
#define __IDvbSubtitlingDescriptor_FWD_DEFINED__
typedef interface IDvbSubtitlingDescriptor IDvbSubtitlingDescriptor;
#endif 	/* __IDvbSubtitlingDescriptor_FWD_DEFINED__ */


#ifndef __IDvbServiceDescriptor_FWD_DEFINED__
#define __IDvbServiceDescriptor_FWD_DEFINED__
typedef interface IDvbServiceDescriptor IDvbServiceDescriptor;
#endif 	/* __IDvbServiceDescriptor_FWD_DEFINED__ */


#ifndef __IDvbServiceDescriptor2_FWD_DEFINED__
#define __IDvbServiceDescriptor2_FWD_DEFINED__
typedef interface IDvbServiceDescriptor2 IDvbServiceDescriptor2;
#endif 	/* __IDvbServiceDescriptor2_FWD_DEFINED__ */


#ifndef __IDvbServiceListDescriptor_FWD_DEFINED__
#define __IDvbServiceListDescriptor_FWD_DEFINED__
typedef interface IDvbServiceListDescriptor IDvbServiceListDescriptor;
#endif 	/* __IDvbServiceListDescriptor_FWD_DEFINED__ */


#ifndef __IDvbMultilingualServiceNameDescriptor_FWD_DEFINED__
#define __IDvbMultilingualServiceNameDescriptor_FWD_DEFINED__
typedef interface IDvbMultilingualServiceNameDescriptor IDvbMultilingualServiceNameDescriptor;
#endif 	/* __IDvbMultilingualServiceNameDescriptor_FWD_DEFINED__ */


#ifndef __IDvbNetworkNameDescriptor_FWD_DEFINED__
#define __IDvbNetworkNameDescriptor_FWD_DEFINED__
typedef interface IDvbNetworkNameDescriptor IDvbNetworkNameDescriptor;
#endif 	/* __IDvbNetworkNameDescriptor_FWD_DEFINED__ */


#ifndef __IDvbShortEventDescriptor_FWD_DEFINED__
#define __IDvbShortEventDescriptor_FWD_DEFINED__
typedef interface IDvbShortEventDescriptor IDvbShortEventDescriptor;
#endif 	/* __IDvbShortEventDescriptor_FWD_DEFINED__ */


#ifndef __IDvbExtendedEventDescriptor_FWD_DEFINED__
#define __IDvbExtendedEventDescriptor_FWD_DEFINED__
typedef interface IDvbExtendedEventDescriptor IDvbExtendedEventDescriptor;
#endif 	/* __IDvbExtendedEventDescriptor_FWD_DEFINED__ */


#ifndef __IDvbComponentDescriptor_FWD_DEFINED__
#define __IDvbComponentDescriptor_FWD_DEFINED__
typedef interface IDvbComponentDescriptor IDvbComponentDescriptor;
#endif 	/* __IDvbComponentDescriptor_FWD_DEFINED__ */


#ifndef __IDvbContentDescriptor_FWD_DEFINED__
#define __IDvbContentDescriptor_FWD_DEFINED__
typedef interface IDvbContentDescriptor IDvbContentDescriptor;
#endif 	/* __IDvbContentDescriptor_FWD_DEFINED__ */


#ifndef __IDvbParentalRatingDescriptor_FWD_DEFINED__
#define __IDvbParentalRatingDescriptor_FWD_DEFINED__
typedef interface IDvbParentalRatingDescriptor IDvbParentalRatingDescriptor;
#endif 	/* __IDvbParentalRatingDescriptor_FWD_DEFINED__ */


#ifndef __IIsdbTerrestrialDeliverySystemDescriptor_FWD_DEFINED__
#define __IIsdbTerrestrialDeliverySystemDescriptor_FWD_DEFINED__
typedef interface IIsdbTerrestrialDeliverySystemDescriptor IIsdbTerrestrialDeliverySystemDescriptor;
#endif 	/* __IIsdbTerrestrialDeliverySystemDescriptor_FWD_DEFINED__ */


#ifndef __IIsdbTSInformationDescriptor_FWD_DEFINED__
#define __IIsdbTSInformationDescriptor_FWD_DEFINED__
typedef interface IIsdbTSInformationDescriptor IIsdbTSInformationDescriptor;
#endif 	/* __IIsdbTSInformationDescriptor_FWD_DEFINED__ */


#ifndef __IIsdbDigitalCopyControlDescriptor_FWD_DEFINED__
#define __IIsdbDigitalCopyControlDescriptor_FWD_DEFINED__
typedef interface IIsdbDigitalCopyControlDescriptor IIsdbDigitalCopyControlDescriptor;
#endif 	/* __IIsdbDigitalCopyControlDescriptor_FWD_DEFINED__ */


#ifndef __IIsdbAudioComponentDescriptor_FWD_DEFINED__
#define __IIsdbAudioComponentDescriptor_FWD_DEFINED__
typedef interface IIsdbAudioComponentDescriptor IIsdbAudioComponentDescriptor;
#endif 	/* __IIsdbAudioComponentDescriptor_FWD_DEFINED__ */


#ifndef __IIsdbDataContentDescriptor_FWD_DEFINED__
#define __IIsdbDataContentDescriptor_FWD_DEFINED__
typedef interface IIsdbDataContentDescriptor IIsdbDataContentDescriptor;
#endif 	/* __IIsdbDataContentDescriptor_FWD_DEFINED__ */


#ifndef __IIsdbCAContractInformationDescriptor_FWD_DEFINED__
#define __IIsdbCAContractInformationDescriptor_FWD_DEFINED__
typedef interface IIsdbCAContractInformationDescriptor IIsdbCAContractInformationDescriptor;
#endif 	/* __IIsdbCAContractInformationDescriptor_FWD_DEFINED__ */


#ifndef __IIsdbEventGroupDescriptor_FWD_DEFINED__
#define __IIsdbEventGroupDescriptor_FWD_DEFINED__
typedef interface IIsdbEventGroupDescriptor IIsdbEventGroupDescriptor;
#endif 	/* __IIsdbEventGroupDescriptor_FWD_DEFINED__ */


#ifndef __IIsdbComponentGroupDescriptor_FWD_DEFINED__
#define __IIsdbComponentGroupDescriptor_FWD_DEFINED__
typedef interface IIsdbComponentGroupDescriptor IIsdbComponentGroupDescriptor;
#endif 	/* __IIsdbComponentGroupDescriptor_FWD_DEFINED__ */


#ifndef __IIsdbSeriesDescriptor_FWD_DEFINED__
#define __IIsdbSeriesDescriptor_FWD_DEFINED__
typedef interface IIsdbSeriesDescriptor IIsdbSeriesDescriptor;
#endif 	/* __IIsdbSeriesDescriptor_FWD_DEFINED__ */


#ifndef __IIsdbDownloadContentDescriptor_FWD_DEFINED__
#define __IIsdbDownloadContentDescriptor_FWD_DEFINED__
typedef interface IIsdbDownloadContentDescriptor IIsdbDownloadContentDescriptor;
#endif 	/* __IIsdbDownloadContentDescriptor_FWD_DEFINED__ */


#ifndef __IIsdbLogoTransmissionDescriptor_FWD_DEFINED__
#define __IIsdbLogoTransmissionDescriptor_FWD_DEFINED__
typedef interface IIsdbLogoTransmissionDescriptor IIsdbLogoTransmissionDescriptor;
#endif 	/* __IIsdbLogoTransmissionDescriptor_FWD_DEFINED__ */


#ifndef __IIsdbSIParameterDescriptor_FWD_DEFINED__
#define __IIsdbSIParameterDescriptor_FWD_DEFINED__
typedef interface IIsdbSIParameterDescriptor IIsdbSIParameterDescriptor;
#endif 	/* __IIsdbSIParameterDescriptor_FWD_DEFINED__ */


#ifndef __IIsdbEmergencyInformationDescriptor_FWD_DEFINED__
#define __IIsdbEmergencyInformationDescriptor_FWD_DEFINED__
typedef interface IIsdbEmergencyInformationDescriptor IIsdbEmergencyInformationDescriptor;
#endif 	/* __IIsdbEmergencyInformationDescriptor_FWD_DEFINED__ */


#ifndef __IIsdbCADescriptor_FWD_DEFINED__
#define __IIsdbCADescriptor_FWD_DEFINED__
typedef interface IIsdbCADescriptor IIsdbCADescriptor;
#endif 	/* __IIsdbCADescriptor_FWD_DEFINED__ */


#ifndef __IIsdbCAServiceDescriptor_FWD_DEFINED__
#define __IIsdbCAServiceDescriptor_FWD_DEFINED__
typedef interface IIsdbCAServiceDescriptor IIsdbCAServiceDescriptor;
#endif 	/* __IIsdbCAServiceDescriptor_FWD_DEFINED__ */


#ifndef __IIsdbHierarchicalTransmissionDescriptor_FWD_DEFINED__
#define __IIsdbHierarchicalTransmissionDescriptor_FWD_DEFINED__
typedef interface IIsdbHierarchicalTransmissionDescriptor IIsdbHierarchicalTransmissionDescriptor;
#endif 	/* __IIsdbHierarchicalTransmissionDescriptor_FWD_DEFINED__ */


#ifndef __IPBDASiParser_FWD_DEFINED__
#define __IPBDASiParser_FWD_DEFINED__
typedef interface IPBDASiParser IPBDASiParser;
#endif 	/* __IPBDASiParser_FWD_DEFINED__ */


#ifndef __IPBDA_EIT_FWD_DEFINED__
#define __IPBDA_EIT_FWD_DEFINED__
typedef interface IPBDA_EIT IPBDA_EIT;
#endif 	/* __IPBDA_EIT_FWD_DEFINED__ */


#ifndef __IPBDA_Services_FWD_DEFINED__
#define __IPBDA_Services_FWD_DEFINED__
typedef interface IPBDA_Services IPBDA_Services;
#endif 	/* __IPBDA_Services_FWD_DEFINED__ */


#ifndef __IPBDAEntitlementDescriptor_FWD_DEFINED__
#define __IPBDAEntitlementDescriptor_FWD_DEFINED__
typedef interface IPBDAEntitlementDescriptor IPBDAEntitlementDescriptor;
#endif 	/* __IPBDAEntitlementDescriptor_FWD_DEFINED__ */


#ifndef __IPBDAAttributesDescriptor_FWD_DEFINED__
#define __IPBDAAttributesDescriptor_FWD_DEFINED__
typedef interface IPBDAAttributesDescriptor IPBDAAttributesDescriptor;
#endif 	/* __IPBDAAttributesDescriptor_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "mpeg2structs.h"
#include "mpeg2data.h"
#include "mpeg2psiparser.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_dvbsiparser_0000_0000 */
/* [local] */ 

typedef /* [public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_dvbsiparser_0000_0000_0001
    {	STRCONV_MODE_DVB	= 0,
	STRCONV_MODE_DVB_EMPHASIS	= ( STRCONV_MODE_DVB + 1 ) ,
	STRCONV_MODE_DVB_WITHOUT_EMPHASIS	= ( STRCONV_MODE_DVB_EMPHASIS + 1 ) ,
	STRCONV_MODE_ISDB	= ( STRCONV_MODE_DVB_WITHOUT_EMPHASIS + 1 ) 
    } 	DVB_STRCONV_MODE;

























extern RPC_IF_HANDLE __MIDL_itf_dvbsiparser_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dvbsiparser_0000_0000_v0_0_s_ifspec;

#ifndef __IDvbSiParser_INTERFACE_DEFINED__
#define __IDvbSiParser_INTERFACE_DEFINED__

/* interface IDvbSiParser */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvbSiParser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B758A7BD-14DC-449d-B828-35909ACB3B1E")
    IDvbSiParser : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IUnknown *punkMpeg2Data) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPAT( 
            /* [out] */ IPAT **ppPAT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCAT( 
            /* [in] */ DWORD dwTimeout,
            /* [out] */ ICAT **ppCAT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPMT( 
            /* [in] */ PID pid,
            /* [annotation][in] */ 
            __in_opt  WORD *pwProgramNumber,
            /* [out] */ IPMT **ppPMT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTSDT( 
            /* [out] */ ITSDT **ppTSDT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNIT( 
            /* [in] */ TID tableId,
            /* [annotation][in] */ 
            __in_opt  WORD *pwNetworkId,
            /* [out] */ IDVB_NIT **ppNIT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSDT( 
            /* [in] */ TID tableId,
            /* [annotation][in] */ 
            __in_opt  WORD *pwTransportStreamId,
            /* [out] */ IDVB_SDT **ppSDT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEIT( 
            /* [in] */ TID tableId,
            /* [annotation][in] */ 
            __in_opt  WORD *pwServiceId,
            /* [out] */ IDVB_EIT **ppEIT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBAT( 
            /* [annotation][in] */ 
            __in_opt  WORD *pwBouquetId,
            /* [out] */ IDVB_BAT **ppBAT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRST( 
            /* [in] */ DWORD dwTimeout,
            /* [out] */ IDVB_RST **ppRST) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetST( 
            /* [in] */ PID pid,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ IDVB_ST **ppST) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTDT( 
            /* [out] */ IDVB_TDT **ppTDT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTOT( 
            /* [out] */ IDVB_TOT **ppTOT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDIT( 
            /* [in] */ DWORD dwTimeout,
            /* [out] */ IDVB_DIT **ppDIT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSIT( 
            /* [in] */ DWORD dwTimeout,
            /* [out] */ IDVB_SIT **ppSIT) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbSiParserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbSiParser * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbSiParser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbSiParser * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDvbSiParser * This,
            /* [in] */ IUnknown *punkMpeg2Data);
        
        HRESULT ( STDMETHODCALLTYPE *GetPAT )( 
            IDvbSiParser * This,
            /* [out] */ IPAT **ppPAT);
        
        HRESULT ( STDMETHODCALLTYPE *GetCAT )( 
            IDvbSiParser * This,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ ICAT **ppCAT);
        
        HRESULT ( STDMETHODCALLTYPE *GetPMT )( 
            IDvbSiParser * This,
            /* [in] */ PID pid,
            /* [annotation][in] */ 
            __in_opt  WORD *pwProgramNumber,
            /* [out] */ IPMT **ppPMT);
        
        HRESULT ( STDMETHODCALLTYPE *GetTSDT )( 
            IDvbSiParser * This,
            /* [out] */ ITSDT **ppTSDT);
        
        HRESULT ( STDMETHODCALLTYPE *GetNIT )( 
            IDvbSiParser * This,
            /* [in] */ TID tableId,
            /* [annotation][in] */ 
            __in_opt  WORD *pwNetworkId,
            /* [out] */ IDVB_NIT **ppNIT);
        
        HRESULT ( STDMETHODCALLTYPE *GetSDT )( 
            IDvbSiParser * This,
            /* [in] */ TID tableId,
            /* [annotation][in] */ 
            __in_opt  WORD *pwTransportStreamId,
            /* [out] */ IDVB_SDT **ppSDT);
        
        HRESULT ( STDMETHODCALLTYPE *GetEIT )( 
            IDvbSiParser * This,
            /* [in] */ TID tableId,
            /* [annotation][in] */ 
            __in_opt  WORD *pwServiceId,
            /* [out] */ IDVB_EIT **ppEIT);
        
        HRESULT ( STDMETHODCALLTYPE *GetBAT )( 
            IDvbSiParser * This,
            /* [annotation][in] */ 
            __in_opt  WORD *pwBouquetId,
            /* [out] */ IDVB_BAT **ppBAT);
        
        HRESULT ( STDMETHODCALLTYPE *GetRST )( 
            IDvbSiParser * This,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ IDVB_RST **ppRST);
        
        HRESULT ( STDMETHODCALLTYPE *GetST )( 
            IDvbSiParser * This,
            /* [in] */ PID pid,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ IDVB_ST **ppST);
        
        HRESULT ( STDMETHODCALLTYPE *GetTDT )( 
            IDvbSiParser * This,
            /* [out] */ IDVB_TDT **ppTDT);
        
        HRESULT ( STDMETHODCALLTYPE *GetTOT )( 
            IDvbSiParser * This,
            /* [out] */ IDVB_TOT **ppTOT);
        
        HRESULT ( STDMETHODCALLTYPE *GetDIT )( 
            IDvbSiParser * This,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ IDVB_DIT **ppDIT);
        
        HRESULT ( STDMETHODCALLTYPE *GetSIT )( 
            IDvbSiParser * This,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ IDVB_SIT **ppSIT);
        
        END_INTERFACE
    } IDvbSiParserVtbl;

    interface IDvbSiParser
    {
        CONST_VTBL struct IDvbSiParserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbSiParser_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbSiParser_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbSiParser_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbSiParser_Initialize(This,punkMpeg2Data)	\
    ( (This)->lpVtbl -> Initialize(This,punkMpeg2Data) ) 

#define IDvbSiParser_GetPAT(This,ppPAT)	\
    ( (This)->lpVtbl -> GetPAT(This,ppPAT) ) 

#define IDvbSiParser_GetCAT(This,dwTimeout,ppCAT)	\
    ( (This)->lpVtbl -> GetCAT(This,dwTimeout,ppCAT) ) 

#define IDvbSiParser_GetPMT(This,pid,pwProgramNumber,ppPMT)	\
    ( (This)->lpVtbl -> GetPMT(This,pid,pwProgramNumber,ppPMT) ) 

#define IDvbSiParser_GetTSDT(This,ppTSDT)	\
    ( (This)->lpVtbl -> GetTSDT(This,ppTSDT) ) 

#define IDvbSiParser_GetNIT(This,tableId,pwNetworkId,ppNIT)	\
    ( (This)->lpVtbl -> GetNIT(This,tableId,pwNetworkId,ppNIT) ) 

#define IDvbSiParser_GetSDT(This,tableId,pwTransportStreamId,ppSDT)	\
    ( (This)->lpVtbl -> GetSDT(This,tableId,pwTransportStreamId,ppSDT) ) 

#define IDvbSiParser_GetEIT(This,tableId,pwServiceId,ppEIT)	\
    ( (This)->lpVtbl -> GetEIT(This,tableId,pwServiceId,ppEIT) ) 

#define IDvbSiParser_GetBAT(This,pwBouquetId,ppBAT)	\
    ( (This)->lpVtbl -> GetBAT(This,pwBouquetId,ppBAT) ) 

#define IDvbSiParser_GetRST(This,dwTimeout,ppRST)	\
    ( (This)->lpVtbl -> GetRST(This,dwTimeout,ppRST) ) 

#define IDvbSiParser_GetST(This,pid,dwTimeout,ppST)	\
    ( (This)->lpVtbl -> GetST(This,pid,dwTimeout,ppST) ) 

#define IDvbSiParser_GetTDT(This,ppTDT)	\
    ( (This)->lpVtbl -> GetTDT(This,ppTDT) ) 

#define IDvbSiParser_GetTOT(This,ppTOT)	\
    ( (This)->lpVtbl -> GetTOT(This,ppTOT) ) 

#define IDvbSiParser_GetDIT(This,dwTimeout,ppDIT)	\
    ( (This)->lpVtbl -> GetDIT(This,dwTimeout,ppDIT) ) 

#define IDvbSiParser_GetSIT(This,dwTimeout,ppSIT)	\
    ( (This)->lpVtbl -> GetSIT(This,dwTimeout,ppSIT) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbSiParser_INTERFACE_DEFINED__ */


#ifndef __IDvbSiParser2_INTERFACE_DEFINED__
#define __IDvbSiParser2_INTERFACE_DEFINED__

/* interface IDvbSiParser2 */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvbSiParser2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0AC5525F-F816-42F4-93BA-4C0F32F46E54")
    IDvbSiParser2 : public IDvbSiParser
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetEIT2( 
            /* [in] */ TID tableId,
            /* [annotation][in] */ 
            __in_opt  WORD *pwServiceId,
            /* [annotation][in] */ 
            __in_opt  BYTE *pbSegment,
            /* [out] */ IDVB_EIT2 **ppEIT) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbSiParser2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbSiParser2 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbSiParser2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbSiParser2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDvbSiParser2 * This,
            /* [in] */ IUnknown *punkMpeg2Data);
        
        HRESULT ( STDMETHODCALLTYPE *GetPAT )( 
            IDvbSiParser2 * This,
            /* [out] */ IPAT **ppPAT);
        
        HRESULT ( STDMETHODCALLTYPE *GetCAT )( 
            IDvbSiParser2 * This,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ ICAT **ppCAT);
        
        HRESULT ( STDMETHODCALLTYPE *GetPMT )( 
            IDvbSiParser2 * This,
            /* [in] */ PID pid,
            /* [annotation][in] */ 
            __in_opt  WORD *pwProgramNumber,
            /* [out] */ IPMT **ppPMT);
        
        HRESULT ( STDMETHODCALLTYPE *GetTSDT )( 
            IDvbSiParser2 * This,
            /* [out] */ ITSDT **ppTSDT);
        
        HRESULT ( STDMETHODCALLTYPE *GetNIT )( 
            IDvbSiParser2 * This,
            /* [in] */ TID tableId,
            /* [annotation][in] */ 
            __in_opt  WORD *pwNetworkId,
            /* [out] */ IDVB_NIT **ppNIT);
        
        HRESULT ( STDMETHODCALLTYPE *GetSDT )( 
            IDvbSiParser2 * This,
            /* [in] */ TID tableId,
            /* [annotation][in] */ 
            __in_opt  WORD *pwTransportStreamId,
            /* [out] */ IDVB_SDT **ppSDT);
        
        HRESULT ( STDMETHODCALLTYPE *GetEIT )( 
            IDvbSiParser2 * This,
            /* [in] */ TID tableId,
            /* [annotation][in] */ 
            __in_opt  WORD *pwServiceId,
            /* [out] */ IDVB_EIT **ppEIT);
        
        HRESULT ( STDMETHODCALLTYPE *GetBAT )( 
            IDvbSiParser2 * This,
            /* [annotation][in] */ 
            __in_opt  WORD *pwBouquetId,
            /* [out] */ IDVB_BAT **ppBAT);
        
        HRESULT ( STDMETHODCALLTYPE *GetRST )( 
            IDvbSiParser2 * This,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ IDVB_RST **ppRST);
        
        HRESULT ( STDMETHODCALLTYPE *GetST )( 
            IDvbSiParser2 * This,
            /* [in] */ PID pid,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ IDVB_ST **ppST);
        
        HRESULT ( STDMETHODCALLTYPE *GetTDT )( 
            IDvbSiParser2 * This,
            /* [out] */ IDVB_TDT **ppTDT);
        
        HRESULT ( STDMETHODCALLTYPE *GetTOT )( 
            IDvbSiParser2 * This,
            /* [out] */ IDVB_TOT **ppTOT);
        
        HRESULT ( STDMETHODCALLTYPE *GetDIT )( 
            IDvbSiParser2 * This,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ IDVB_DIT **ppDIT);
        
        HRESULT ( STDMETHODCALLTYPE *GetSIT )( 
            IDvbSiParser2 * This,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ IDVB_SIT **ppSIT);
        
        HRESULT ( STDMETHODCALLTYPE *GetEIT2 )( 
            IDvbSiParser2 * This,
            /* [in] */ TID tableId,
            /* [annotation][in] */ 
            __in_opt  WORD *pwServiceId,
            /* [annotation][in] */ 
            __in_opt  BYTE *pbSegment,
            /* [out] */ IDVB_EIT2 **ppEIT);
        
        END_INTERFACE
    } IDvbSiParser2Vtbl;

    interface IDvbSiParser2
    {
        CONST_VTBL struct IDvbSiParser2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbSiParser2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbSiParser2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbSiParser2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbSiParser2_Initialize(This,punkMpeg2Data)	\
    ( (This)->lpVtbl -> Initialize(This,punkMpeg2Data) ) 

#define IDvbSiParser2_GetPAT(This,ppPAT)	\
    ( (This)->lpVtbl -> GetPAT(This,ppPAT) ) 

#define IDvbSiParser2_GetCAT(This,dwTimeout,ppCAT)	\
    ( (This)->lpVtbl -> GetCAT(This,dwTimeout,ppCAT) ) 

#define IDvbSiParser2_GetPMT(This,pid,pwProgramNumber,ppPMT)	\
    ( (This)->lpVtbl -> GetPMT(This,pid,pwProgramNumber,ppPMT) ) 

#define IDvbSiParser2_GetTSDT(This,ppTSDT)	\
    ( (This)->lpVtbl -> GetTSDT(This,ppTSDT) ) 

#define IDvbSiParser2_GetNIT(This,tableId,pwNetworkId,ppNIT)	\
    ( (This)->lpVtbl -> GetNIT(This,tableId,pwNetworkId,ppNIT) ) 

#define IDvbSiParser2_GetSDT(This,tableId,pwTransportStreamId,ppSDT)	\
    ( (This)->lpVtbl -> GetSDT(This,tableId,pwTransportStreamId,ppSDT) ) 

#define IDvbSiParser2_GetEIT(This,tableId,pwServiceId,ppEIT)	\
    ( (This)->lpVtbl -> GetEIT(This,tableId,pwServiceId,ppEIT) ) 

#define IDvbSiParser2_GetBAT(This,pwBouquetId,ppBAT)	\
    ( (This)->lpVtbl -> GetBAT(This,pwBouquetId,ppBAT) ) 

#define IDvbSiParser2_GetRST(This,dwTimeout,ppRST)	\
    ( (This)->lpVtbl -> GetRST(This,dwTimeout,ppRST) ) 

#define IDvbSiParser2_GetST(This,pid,dwTimeout,ppST)	\
    ( (This)->lpVtbl -> GetST(This,pid,dwTimeout,ppST) ) 

#define IDvbSiParser2_GetTDT(This,ppTDT)	\
    ( (This)->lpVtbl -> GetTDT(This,ppTDT) ) 

#define IDvbSiParser2_GetTOT(This,ppTOT)	\
    ( (This)->lpVtbl -> GetTOT(This,ppTOT) ) 

#define IDvbSiParser2_GetDIT(This,dwTimeout,ppDIT)	\
    ( (This)->lpVtbl -> GetDIT(This,dwTimeout,ppDIT) ) 

#define IDvbSiParser2_GetSIT(This,dwTimeout,ppSIT)	\
    ( (This)->lpVtbl -> GetSIT(This,dwTimeout,ppSIT) ) 


#define IDvbSiParser2_GetEIT2(This,tableId,pwServiceId,pbSegment,ppEIT)	\
    ( (This)->lpVtbl -> GetEIT2(This,tableId,pwServiceId,pbSegment,ppEIT) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbSiParser2_INTERFACE_DEFINED__ */


#ifndef __IIsdbSiParser2_INTERFACE_DEFINED__
#define __IIsdbSiParser2_INTERFACE_DEFINED__

/* interface IIsdbSiParser2 */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IIsdbSiParser2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("900E4BB7-18CD-453F-98BE-3BE6AA211772")
    IIsdbSiParser2 : public IDvbSiParser2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSDT( 
            /* [in] */ TID tableId,
            /* [annotation][in] */ 
            __in_opt  WORD *pwTransportStreamId,
            /* [out] */ IISDB_SDT **ppSDT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBIT( 
            /* [in] */ TID tableId,
            /* [annotation][in] */ 
            __in_opt  WORD *pwOriginalNetworkId,
            /* [out] */ IISDB_BIT **ppBIT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNBIT( 
            /* [in] */ TID tableId,
            /* [annotation][in] */ 
            __in_opt  WORD *pwOriginalNetworkId,
            /* [out] */ IISDB_NBIT **ppNBIT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLDT( 
            /* [in] */ TID tableId,
            /* [annotation][in] */ 
            __in_opt  WORD *pwOriginalServiceId,
            /* [out] */ IISDB_LDT **ppLDT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSDTT( 
            /* [in] */ TID tableId,
            /* [annotation][in] */ 
            __in_opt  WORD *pwTableIdExt,
            /* [out] */ IISDB_SDTT **ppSDTT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCDT( 
            /* [in] */ TID tableId,
            /* [in] */ BYTE bSectionNumber,
            /* [annotation][in] */ 
            __in_opt  WORD *pwDownloadDataId,
            /* [out] */ IISDB_CDT **ppCDT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEMM( 
            /* [in] */ PID pid,
            /* [in] */ WORD wTableIdExt,
            /* [out] */ IISDB_EMM **ppEMM) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIsdbSiParser2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIsdbSiParser2 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIsdbSiParser2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIsdbSiParser2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IIsdbSiParser2 * This,
            /* [in] */ IUnknown *punkMpeg2Data);
        
        HRESULT ( STDMETHODCALLTYPE *GetPAT )( 
            IIsdbSiParser2 * This,
            /* [out] */ IPAT **ppPAT);
        
        HRESULT ( STDMETHODCALLTYPE *GetCAT )( 
            IIsdbSiParser2 * This,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ ICAT **ppCAT);
        
        HRESULT ( STDMETHODCALLTYPE *GetPMT )( 
            IIsdbSiParser2 * This,
            /* [in] */ PID pid,
            /* [annotation][in] */ 
            __in_opt  WORD *pwProgramNumber,
            /* [out] */ IPMT **ppPMT);
        
        HRESULT ( STDMETHODCALLTYPE *GetTSDT )( 
            IIsdbSiParser2 * This,
            /* [out] */ ITSDT **ppTSDT);
        
        HRESULT ( STDMETHODCALLTYPE *GetNIT )( 
            IIsdbSiParser2 * This,
            /* [in] */ TID tableId,
            /* [annotation][in] */ 
            __in_opt  WORD *pwNetworkId,
            /* [out] */ IDVB_NIT **ppNIT);
        
        HRESULT ( STDMETHODCALLTYPE *GetSDT )( 
            IIsdbSiParser2 * This,
            /* [in] */ TID tableId,
            /* [annotation][in] */ 
            __in_opt  WORD *pwTransportStreamId,
            /* [out] */ IDVB_SDT **ppSDT);
        
        HRESULT ( STDMETHODCALLTYPE *GetEIT )( 
            IIsdbSiParser2 * This,
            /* [in] */ TID tableId,
            /* [annotation][in] */ 
            __in_opt  WORD *pwServiceId,
            /* [out] */ IDVB_EIT **ppEIT);
        
        HRESULT ( STDMETHODCALLTYPE *GetBAT )( 
            IIsdbSiParser2 * This,
            /* [annotation][in] */ 
            __in_opt  WORD *pwBouquetId,
            /* [out] */ IDVB_BAT **ppBAT);
        
        HRESULT ( STDMETHODCALLTYPE *GetRST )( 
            IIsdbSiParser2 * This,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ IDVB_RST **ppRST);
        
        HRESULT ( STDMETHODCALLTYPE *GetST )( 
            IIsdbSiParser2 * This,
            /* [in] */ PID pid,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ IDVB_ST **ppST);
        
        HRESULT ( STDMETHODCALLTYPE *GetTDT )( 
            IIsdbSiParser2 * This,
            /* [out] */ IDVB_TDT **ppTDT);
        
        HRESULT ( STDMETHODCALLTYPE *GetTOT )( 
            IIsdbSiParser2 * This,
            /* [out] */ IDVB_TOT **ppTOT);
        
        HRESULT ( STDMETHODCALLTYPE *GetDIT )( 
            IIsdbSiParser2 * This,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ IDVB_DIT **ppDIT);
        
        HRESULT ( STDMETHODCALLTYPE *GetSIT )( 
            IIsdbSiParser2 * This,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ IDVB_SIT **ppSIT);
        
        HRESULT ( STDMETHODCALLTYPE *GetEIT2 )( 
            IIsdbSiParser2 * This,
            /* [in] */ TID tableId,
            /* [annotation][in] */ 
            __in_opt  WORD *pwServiceId,
            /* [annotation][in] */ 
            __in_opt  BYTE *pbSegment,
            /* [out] */ IDVB_EIT2 **ppEIT);
        
        HRESULT ( STDMETHODCALLTYPE *GetSDT )( 
            IIsdbSiParser2 * This,
            /* [in] */ TID tableId,
            /* [annotation][in] */ 
            __in_opt  WORD *pwTransportStreamId,
            /* [out] */ IISDB_SDT **ppSDT);
        
        HRESULT ( STDMETHODCALLTYPE *GetBIT )( 
            IIsdbSiParser2 * This,
            /* [in] */ TID tableId,
            /* [annotation][in] */ 
            __in_opt  WORD *pwOriginalNetworkId,
            /* [out] */ IISDB_BIT **ppBIT);
        
        HRESULT ( STDMETHODCALLTYPE *GetNBIT )( 
            IIsdbSiParser2 * This,
            /* [in] */ TID tableId,
            /* [annotation][in] */ 
            __in_opt  WORD *pwOriginalNetworkId,
            /* [out] */ IISDB_NBIT **ppNBIT);
        
        HRESULT ( STDMETHODCALLTYPE *GetLDT )( 
            IIsdbSiParser2 * This,
            /* [in] */ TID tableId,
            /* [annotation][in] */ 
            __in_opt  WORD *pwOriginalServiceId,
            /* [out] */ IISDB_LDT **ppLDT);
        
        HRESULT ( STDMETHODCALLTYPE *GetSDTT )( 
            IIsdbSiParser2 * This,
            /* [in] */ TID tableId,
            /* [annotation][in] */ 
            __in_opt  WORD *pwTableIdExt,
            /* [out] */ IISDB_SDTT **ppSDTT);
        
        HRESULT ( STDMETHODCALLTYPE *GetCDT )( 
            IIsdbSiParser2 * This,
            /* [in] */ TID tableId,
            /* [in] */ BYTE bSectionNumber,
            /* [annotation][in] */ 
            __in_opt  WORD *pwDownloadDataId,
            /* [out] */ IISDB_CDT **ppCDT);
        
        HRESULT ( STDMETHODCALLTYPE *GetEMM )( 
            IIsdbSiParser2 * This,
            /* [in] */ PID pid,
            /* [in] */ WORD wTableIdExt,
            /* [out] */ IISDB_EMM **ppEMM);
        
        END_INTERFACE
    } IIsdbSiParser2Vtbl;

    interface IIsdbSiParser2
    {
        CONST_VTBL struct IIsdbSiParser2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIsdbSiParser2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IIsdbSiParser2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IIsdbSiParser2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IIsdbSiParser2_Initialize(This,punkMpeg2Data)	\
    ( (This)->lpVtbl -> Initialize(This,punkMpeg2Data) ) 

#define IIsdbSiParser2_GetPAT(This,ppPAT)	\
    ( (This)->lpVtbl -> GetPAT(This,ppPAT) ) 

#define IIsdbSiParser2_GetCAT(This,dwTimeout,ppCAT)	\
    ( (This)->lpVtbl -> GetCAT(This,dwTimeout,ppCAT) ) 

#define IIsdbSiParser2_GetPMT(This,pid,pwProgramNumber,ppPMT)	\
    ( (This)->lpVtbl -> GetPMT(This,pid,pwProgramNumber,ppPMT) ) 

#define IIsdbSiParser2_GetTSDT(This,ppTSDT)	\
    ( (This)->lpVtbl -> GetTSDT(This,ppTSDT) ) 

#define IIsdbSiParser2_GetNIT(This,tableId,pwNetworkId,ppNIT)	\
    ( (This)->lpVtbl -> GetNIT(This,tableId,pwNetworkId,ppNIT) ) 

#define IIsdbSiParser2_GetSDT(This,tableId,pwTransportStreamId,ppSDT)	\
    ( (This)->lpVtbl -> GetSDT(This,tableId,pwTransportStreamId,ppSDT) ) 

#define IIsdbSiParser2_GetEIT(This,tableId,pwServiceId,ppEIT)	\
    ( (This)->lpVtbl -> GetEIT(This,tableId,pwServiceId,ppEIT) ) 

#define IIsdbSiParser2_GetBAT(This,pwBouquetId,ppBAT)	\
    ( (This)->lpVtbl -> GetBAT(This,pwBouquetId,ppBAT) ) 

#define IIsdbSiParser2_GetRST(This,dwTimeout,ppRST)	\
    ( (This)->lpVtbl -> GetRST(This,dwTimeout,ppRST) ) 

#define IIsdbSiParser2_GetST(This,pid,dwTimeout,ppST)	\
    ( (This)->lpVtbl -> GetST(This,pid,dwTimeout,ppST) ) 

#define IIsdbSiParser2_GetTDT(This,ppTDT)	\
    ( (This)->lpVtbl -> GetTDT(This,ppTDT) ) 

#define IIsdbSiParser2_GetTOT(This,ppTOT)	\
    ( (This)->lpVtbl -> GetTOT(This,ppTOT) ) 

#define IIsdbSiParser2_GetDIT(This,dwTimeout,ppDIT)	\
    ( (This)->lpVtbl -> GetDIT(This,dwTimeout,ppDIT) ) 

#define IIsdbSiParser2_GetSIT(This,dwTimeout,ppSIT)	\
    ( (This)->lpVtbl -> GetSIT(This,dwTimeout,ppSIT) ) 


#define IIsdbSiParser2_GetEIT2(This,tableId,pwServiceId,pbSegment,ppEIT)	\
    ( (This)->lpVtbl -> GetEIT2(This,tableId,pwServiceId,pbSegment,ppEIT) ) 


#define IIsdbSiParser2_GetSDT(This,tableId,pwTransportStreamId,ppSDT)	\
    ( (This)->lpVtbl -> GetSDT(This,tableId,pwTransportStreamId,ppSDT) ) 

#define IIsdbSiParser2_GetBIT(This,tableId,pwOriginalNetworkId,ppBIT)	\
    ( (This)->lpVtbl -> GetBIT(This,tableId,pwOriginalNetworkId,ppBIT) ) 

#define IIsdbSiParser2_GetNBIT(This,tableId,pwOriginalNetworkId,ppNBIT)	\
    ( (This)->lpVtbl -> GetNBIT(This,tableId,pwOriginalNetworkId,ppNBIT) ) 

#define IIsdbSiParser2_GetLDT(This,tableId,pwOriginalServiceId,ppLDT)	\
    ( (This)->lpVtbl -> GetLDT(This,tableId,pwOriginalServiceId,ppLDT) ) 

#define IIsdbSiParser2_GetSDTT(This,tableId,pwTableIdExt,ppSDTT)	\
    ( (This)->lpVtbl -> GetSDTT(This,tableId,pwTableIdExt,ppSDTT) ) 

#define IIsdbSiParser2_GetCDT(This,tableId,bSectionNumber,pwDownloadDataId,ppCDT)	\
    ( (This)->lpVtbl -> GetCDT(This,tableId,bSectionNumber,pwDownloadDataId,ppCDT) ) 

#define IIsdbSiParser2_GetEMM(This,pid,wTableIdExt,ppEMM)	\
    ( (This)->lpVtbl -> GetEMM(This,pid,wTableIdExt,ppEMM) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IIsdbSiParser2_INTERFACE_DEFINED__ */


#ifndef __IDVB_NIT_INTERFACE_DEFINED__
#define __IDVB_NIT_INTERFACE_DEFINED__

/* interface IDVB_NIT */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDVB_NIT;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C64935F4-29E4-4e22-911A-63F7F55CB097")
    IDVB_NIT : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionNumber( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNetworkId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfTableDescriptors( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTableDescriptorByIndex( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTableDescriptorByTag( 
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordTransportStreamId( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordOriginalNetworkId( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordCountOfDescriptors( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptorByIndex( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptorByTag( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterForNextTable( 
            /* [in] */ HANDLE hNextTableAvailable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextTable( 
            /* [out] */ IDVB_NIT **ppNIT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterForWhenCurrent( 
            /* [in] */ HANDLE hNextTableIsCurrent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertNextToCurrent( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionHash( 
            /* [out] */ DWORD *pdwVersionHash) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVB_NITVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVB_NIT * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVB_NIT * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVB_NIT * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDVB_NIT * This,
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionNumber )( 
            IDVB_NIT * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetNetworkId )( 
            IDVB_NIT * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfTableDescriptors )( 
            IDVB_NIT * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTableDescriptorByIndex )( 
            IDVB_NIT * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetTableDescriptorByTag )( 
            IDVB_NIT * This,
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IDVB_NIT * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordTransportStreamId )( 
            IDVB_NIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordOriginalNetworkId )( 
            IDVB_NIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordCountOfDescriptors )( 
            IDVB_NIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByIndex )( 
            IDVB_NIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByTag )( 
            IDVB_NIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterForNextTable )( 
            IDVB_NIT * This,
            /* [in] */ HANDLE hNextTableAvailable);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextTable )( 
            IDVB_NIT * This,
            /* [out] */ IDVB_NIT **ppNIT);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterForWhenCurrent )( 
            IDVB_NIT * This,
            /* [in] */ HANDLE hNextTableIsCurrent);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertNextToCurrent )( 
            IDVB_NIT * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionHash )( 
            IDVB_NIT * This,
            /* [out] */ DWORD *pdwVersionHash);
        
        END_INTERFACE
    } IDVB_NITVtbl;

    interface IDVB_NIT
    {
        CONST_VTBL struct IDVB_NITVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVB_NIT_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVB_NIT_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVB_NIT_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVB_NIT_Initialize(This,pSectionList,pMPEGData)	\
    ( (This)->lpVtbl -> Initialize(This,pSectionList,pMPEGData) ) 

#define IDVB_NIT_GetVersionNumber(This,pbVal)	\
    ( (This)->lpVtbl -> GetVersionNumber(This,pbVal) ) 

#define IDVB_NIT_GetNetworkId(This,pwVal)	\
    ( (This)->lpVtbl -> GetNetworkId(This,pwVal) ) 

#define IDVB_NIT_GetCountOfTableDescriptors(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCountOfTableDescriptors(This,pdwVal) ) 

#define IDVB_NIT_GetTableDescriptorByIndex(This,dwIndex,ppDescriptor)	\
    ( (This)->lpVtbl -> GetTableDescriptorByIndex(This,dwIndex,ppDescriptor) ) 

#define IDVB_NIT_GetTableDescriptorByTag(This,bTag,pdwCookie,ppDescriptor)	\
    ( (This)->lpVtbl -> GetTableDescriptorByTag(This,bTag,pdwCookie,ppDescriptor) ) 

#define IDVB_NIT_GetCountOfRecords(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pdwVal) ) 

#define IDVB_NIT_GetRecordTransportStreamId(This,dwRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordTransportStreamId(This,dwRecordIndex,pwVal) ) 

#define IDVB_NIT_GetRecordOriginalNetworkId(This,dwRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordOriginalNetworkId(This,dwRecordIndex,pwVal) ) 

#define IDVB_NIT_GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal)	\
    ( (This)->lpVtbl -> GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal) ) 

#define IDVB_NIT_GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor) ) 

#define IDVB_NIT_GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor) ) 

#define IDVB_NIT_RegisterForNextTable(This,hNextTableAvailable)	\
    ( (This)->lpVtbl -> RegisterForNextTable(This,hNextTableAvailable) ) 

#define IDVB_NIT_GetNextTable(This,ppNIT)	\
    ( (This)->lpVtbl -> GetNextTable(This,ppNIT) ) 

#define IDVB_NIT_RegisterForWhenCurrent(This,hNextTableIsCurrent)	\
    ( (This)->lpVtbl -> RegisterForWhenCurrent(This,hNextTableIsCurrent) ) 

#define IDVB_NIT_ConvertNextToCurrent(This)	\
    ( (This)->lpVtbl -> ConvertNextToCurrent(This) ) 

#define IDVB_NIT_GetVersionHash(This,pdwVersionHash)	\
    ( (This)->lpVtbl -> GetVersionHash(This,pdwVersionHash) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVB_NIT_INTERFACE_DEFINED__ */


#ifndef __IDVB_SDT_INTERFACE_DEFINED__
#define __IDVB_SDT_INTERFACE_DEFINED__

/* interface IDVB_SDT */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDVB_SDT;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("02CAD8D3-FE43-48e2-90BD-450ED9A8A5FD")
    IDVB_SDT : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionNumber( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransportStreamId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOriginalNetworkId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordServiceId( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordEITScheduleFlag( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BOOL *pfVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordEITPresentFollowingFlag( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BOOL *pfVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordRunningStatus( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordFreeCAMode( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BOOL *pfVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordCountOfDescriptors( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptorByIndex( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptorByTag( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterForNextTable( 
            /* [in] */ HANDLE hNextTableAvailable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextTable( 
            /* [out] */ IDVB_SDT **ppSDT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterForWhenCurrent( 
            /* [in] */ HANDLE hNextTableIsCurrent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertNextToCurrent( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionHash( 
            /* [out] */ DWORD *pdwVersionHash) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVB_SDTVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVB_SDT * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVB_SDT * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVB_SDT * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDVB_SDT * This,
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionNumber )( 
            IDVB_SDT * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransportStreamId )( 
            IDVB_SDT * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetOriginalNetworkId )( 
            IDVB_SDT * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IDVB_SDT * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordServiceId )( 
            IDVB_SDT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordEITScheduleFlag )( 
            IDVB_SDT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BOOL *pfVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordEITPresentFollowingFlag )( 
            IDVB_SDT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BOOL *pfVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordRunningStatus )( 
            IDVB_SDT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordFreeCAMode )( 
            IDVB_SDT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BOOL *pfVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordCountOfDescriptors )( 
            IDVB_SDT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByIndex )( 
            IDVB_SDT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByTag )( 
            IDVB_SDT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterForNextTable )( 
            IDVB_SDT * This,
            /* [in] */ HANDLE hNextTableAvailable);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextTable )( 
            IDVB_SDT * This,
            /* [out] */ IDVB_SDT **ppSDT);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterForWhenCurrent )( 
            IDVB_SDT * This,
            /* [in] */ HANDLE hNextTableIsCurrent);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertNextToCurrent )( 
            IDVB_SDT * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionHash )( 
            IDVB_SDT * This,
            /* [out] */ DWORD *pdwVersionHash);
        
        END_INTERFACE
    } IDVB_SDTVtbl;

    interface IDVB_SDT
    {
        CONST_VTBL struct IDVB_SDTVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVB_SDT_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVB_SDT_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVB_SDT_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVB_SDT_Initialize(This,pSectionList,pMPEGData)	\
    ( (This)->lpVtbl -> Initialize(This,pSectionList,pMPEGData) ) 

#define IDVB_SDT_GetVersionNumber(This,pbVal)	\
    ( (This)->lpVtbl -> GetVersionNumber(This,pbVal) ) 

#define IDVB_SDT_GetTransportStreamId(This,pwVal)	\
    ( (This)->lpVtbl -> GetTransportStreamId(This,pwVal) ) 

#define IDVB_SDT_GetOriginalNetworkId(This,pwVal)	\
    ( (This)->lpVtbl -> GetOriginalNetworkId(This,pwVal) ) 

#define IDVB_SDT_GetCountOfRecords(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pdwVal) ) 

#define IDVB_SDT_GetRecordServiceId(This,dwRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordServiceId(This,dwRecordIndex,pwVal) ) 

#define IDVB_SDT_GetRecordEITScheduleFlag(This,dwRecordIndex,pfVal)	\
    ( (This)->lpVtbl -> GetRecordEITScheduleFlag(This,dwRecordIndex,pfVal) ) 

#define IDVB_SDT_GetRecordEITPresentFollowingFlag(This,dwRecordIndex,pfVal)	\
    ( (This)->lpVtbl -> GetRecordEITPresentFollowingFlag(This,dwRecordIndex,pfVal) ) 

#define IDVB_SDT_GetRecordRunningStatus(This,dwRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordRunningStatus(This,dwRecordIndex,pbVal) ) 

#define IDVB_SDT_GetRecordFreeCAMode(This,dwRecordIndex,pfVal)	\
    ( (This)->lpVtbl -> GetRecordFreeCAMode(This,dwRecordIndex,pfVal) ) 

#define IDVB_SDT_GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal)	\
    ( (This)->lpVtbl -> GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal) ) 

#define IDVB_SDT_GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor) ) 

#define IDVB_SDT_GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor) ) 

#define IDVB_SDT_RegisterForNextTable(This,hNextTableAvailable)	\
    ( (This)->lpVtbl -> RegisterForNextTable(This,hNextTableAvailable) ) 

#define IDVB_SDT_GetNextTable(This,ppSDT)	\
    ( (This)->lpVtbl -> GetNextTable(This,ppSDT) ) 

#define IDVB_SDT_RegisterForWhenCurrent(This,hNextTableIsCurrent)	\
    ( (This)->lpVtbl -> RegisterForWhenCurrent(This,hNextTableIsCurrent) ) 

#define IDVB_SDT_ConvertNextToCurrent(This)	\
    ( (This)->lpVtbl -> ConvertNextToCurrent(This) ) 

#define IDVB_SDT_GetVersionHash(This,pdwVersionHash)	\
    ( (This)->lpVtbl -> GetVersionHash(This,pdwVersionHash) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVB_SDT_INTERFACE_DEFINED__ */


#ifndef __IISDB_SDT_INTERFACE_DEFINED__
#define __IISDB_SDT_INTERFACE_DEFINED__

/* interface IISDB_SDT */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IISDB_SDT;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3F3DC9A2-BB32-4FB9-AE9E-D856848927A3")
    IISDB_SDT : public IDVB_SDT
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRecordEITUserDefinedFlags( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IISDB_SDTVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IISDB_SDT * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IISDB_SDT * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IISDB_SDT * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IISDB_SDT * This,
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionNumber )( 
            IISDB_SDT * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransportStreamId )( 
            IISDB_SDT * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetOriginalNetworkId )( 
            IISDB_SDT * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IISDB_SDT * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordServiceId )( 
            IISDB_SDT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordEITScheduleFlag )( 
            IISDB_SDT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BOOL *pfVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordEITPresentFollowingFlag )( 
            IISDB_SDT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BOOL *pfVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordRunningStatus )( 
            IISDB_SDT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordFreeCAMode )( 
            IISDB_SDT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BOOL *pfVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordCountOfDescriptors )( 
            IISDB_SDT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByIndex )( 
            IISDB_SDT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByTag )( 
            IISDB_SDT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterForNextTable )( 
            IISDB_SDT * This,
            /* [in] */ HANDLE hNextTableAvailable);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextTable )( 
            IISDB_SDT * This,
            /* [out] */ IDVB_SDT **ppSDT);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterForWhenCurrent )( 
            IISDB_SDT * This,
            /* [in] */ HANDLE hNextTableIsCurrent);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertNextToCurrent )( 
            IISDB_SDT * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionHash )( 
            IISDB_SDT * This,
            /* [out] */ DWORD *pdwVersionHash);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordEITUserDefinedFlags )( 
            IISDB_SDT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        END_INTERFACE
    } IISDB_SDTVtbl;

    interface IISDB_SDT
    {
        CONST_VTBL struct IISDB_SDTVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IISDB_SDT_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IISDB_SDT_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IISDB_SDT_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IISDB_SDT_Initialize(This,pSectionList,pMPEGData)	\
    ( (This)->lpVtbl -> Initialize(This,pSectionList,pMPEGData) ) 

#define IISDB_SDT_GetVersionNumber(This,pbVal)	\
    ( (This)->lpVtbl -> GetVersionNumber(This,pbVal) ) 

#define IISDB_SDT_GetTransportStreamId(This,pwVal)	\
    ( (This)->lpVtbl -> GetTransportStreamId(This,pwVal) ) 

#define IISDB_SDT_GetOriginalNetworkId(This,pwVal)	\
    ( (This)->lpVtbl -> GetOriginalNetworkId(This,pwVal) ) 

#define IISDB_SDT_GetCountOfRecords(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pdwVal) ) 

#define IISDB_SDT_GetRecordServiceId(This,dwRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordServiceId(This,dwRecordIndex,pwVal) ) 

#define IISDB_SDT_GetRecordEITScheduleFlag(This,dwRecordIndex,pfVal)	\
    ( (This)->lpVtbl -> GetRecordEITScheduleFlag(This,dwRecordIndex,pfVal) ) 

#define IISDB_SDT_GetRecordEITPresentFollowingFlag(This,dwRecordIndex,pfVal)	\
    ( (This)->lpVtbl -> GetRecordEITPresentFollowingFlag(This,dwRecordIndex,pfVal) ) 

#define IISDB_SDT_GetRecordRunningStatus(This,dwRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordRunningStatus(This,dwRecordIndex,pbVal) ) 

#define IISDB_SDT_GetRecordFreeCAMode(This,dwRecordIndex,pfVal)	\
    ( (This)->lpVtbl -> GetRecordFreeCAMode(This,dwRecordIndex,pfVal) ) 

#define IISDB_SDT_GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal)	\
    ( (This)->lpVtbl -> GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal) ) 

#define IISDB_SDT_GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor) ) 

#define IISDB_SDT_GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor) ) 

#define IISDB_SDT_RegisterForNextTable(This,hNextTableAvailable)	\
    ( (This)->lpVtbl -> RegisterForNextTable(This,hNextTableAvailable) ) 

#define IISDB_SDT_GetNextTable(This,ppSDT)	\
    ( (This)->lpVtbl -> GetNextTable(This,ppSDT) ) 

#define IISDB_SDT_RegisterForWhenCurrent(This,hNextTableIsCurrent)	\
    ( (This)->lpVtbl -> RegisterForWhenCurrent(This,hNextTableIsCurrent) ) 

#define IISDB_SDT_ConvertNextToCurrent(This)	\
    ( (This)->lpVtbl -> ConvertNextToCurrent(This) ) 

#define IISDB_SDT_GetVersionHash(This,pdwVersionHash)	\
    ( (This)->lpVtbl -> GetVersionHash(This,pdwVersionHash) ) 


#define IISDB_SDT_GetRecordEITUserDefinedFlags(This,dwRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordEITUserDefinedFlags(This,dwRecordIndex,pbVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IISDB_SDT_INTERFACE_DEFINED__ */


#ifndef __IDVB_EIT_INTERFACE_DEFINED__
#define __IDVB_EIT_INTERFACE_DEFINED__

/* interface IDVB_EIT */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDVB_EIT;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("442DB029-02CB-4495-8B92-1C13375BCE99")
    IDVB_EIT : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionNumber( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServiceId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransportStreamId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOriginalNetworkId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSegmentLastSectionNumber( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastTableId( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordEventId( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordStartTime( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ MPEG_DATE_AND_TIME *pmdtVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDuration( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ MPEG_DURATION *pmdVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordRunningStatus( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordFreeCAMode( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BOOL *pfVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordCountOfDescriptors( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptorByIndex( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptorByTag( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterForNextTable( 
            /* [in] */ HANDLE hNextTableAvailable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextTable( 
            /* [out] */ IDVB_EIT **ppEIT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterForWhenCurrent( 
            /* [in] */ HANDLE hNextTableIsCurrent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertNextToCurrent( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionHash( 
            /* [out] */ DWORD *pdwVersionHash) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVB_EITVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVB_EIT * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVB_EIT * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVB_EIT * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDVB_EIT * This,
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionNumber )( 
            IDVB_EIT * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceId )( 
            IDVB_EIT * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransportStreamId )( 
            IDVB_EIT * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetOriginalNetworkId )( 
            IDVB_EIT * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSegmentLastSectionNumber )( 
            IDVB_EIT * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastTableId )( 
            IDVB_EIT * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IDVB_EIT * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordEventId )( 
            IDVB_EIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordStartTime )( 
            IDVB_EIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ MPEG_DATE_AND_TIME *pmdtVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDuration )( 
            IDVB_EIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ MPEG_DURATION *pmdVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordRunningStatus )( 
            IDVB_EIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordFreeCAMode )( 
            IDVB_EIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BOOL *pfVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordCountOfDescriptors )( 
            IDVB_EIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByIndex )( 
            IDVB_EIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByTag )( 
            IDVB_EIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterForNextTable )( 
            IDVB_EIT * This,
            /* [in] */ HANDLE hNextTableAvailable);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextTable )( 
            IDVB_EIT * This,
            /* [out] */ IDVB_EIT **ppEIT);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterForWhenCurrent )( 
            IDVB_EIT * This,
            /* [in] */ HANDLE hNextTableIsCurrent);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertNextToCurrent )( 
            IDVB_EIT * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionHash )( 
            IDVB_EIT * This,
            /* [out] */ DWORD *pdwVersionHash);
        
        END_INTERFACE
    } IDVB_EITVtbl;

    interface IDVB_EIT
    {
        CONST_VTBL struct IDVB_EITVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVB_EIT_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVB_EIT_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVB_EIT_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVB_EIT_Initialize(This,pSectionList,pMPEGData)	\
    ( (This)->lpVtbl -> Initialize(This,pSectionList,pMPEGData) ) 

#define IDVB_EIT_GetVersionNumber(This,pbVal)	\
    ( (This)->lpVtbl -> GetVersionNumber(This,pbVal) ) 

#define IDVB_EIT_GetServiceId(This,pwVal)	\
    ( (This)->lpVtbl -> GetServiceId(This,pwVal) ) 

#define IDVB_EIT_GetTransportStreamId(This,pwVal)	\
    ( (This)->lpVtbl -> GetTransportStreamId(This,pwVal) ) 

#define IDVB_EIT_GetOriginalNetworkId(This,pwVal)	\
    ( (This)->lpVtbl -> GetOriginalNetworkId(This,pwVal) ) 

#define IDVB_EIT_GetSegmentLastSectionNumber(This,pbVal)	\
    ( (This)->lpVtbl -> GetSegmentLastSectionNumber(This,pbVal) ) 

#define IDVB_EIT_GetLastTableId(This,pbVal)	\
    ( (This)->lpVtbl -> GetLastTableId(This,pbVal) ) 

#define IDVB_EIT_GetCountOfRecords(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pdwVal) ) 

#define IDVB_EIT_GetRecordEventId(This,dwRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordEventId(This,dwRecordIndex,pwVal) ) 

#define IDVB_EIT_GetRecordStartTime(This,dwRecordIndex,pmdtVal)	\
    ( (This)->lpVtbl -> GetRecordStartTime(This,dwRecordIndex,pmdtVal) ) 

#define IDVB_EIT_GetRecordDuration(This,dwRecordIndex,pmdVal)	\
    ( (This)->lpVtbl -> GetRecordDuration(This,dwRecordIndex,pmdVal) ) 

#define IDVB_EIT_GetRecordRunningStatus(This,dwRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordRunningStatus(This,dwRecordIndex,pbVal) ) 

#define IDVB_EIT_GetRecordFreeCAMode(This,dwRecordIndex,pfVal)	\
    ( (This)->lpVtbl -> GetRecordFreeCAMode(This,dwRecordIndex,pfVal) ) 

#define IDVB_EIT_GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal)	\
    ( (This)->lpVtbl -> GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal) ) 

#define IDVB_EIT_GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor) ) 

#define IDVB_EIT_GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor) ) 

#define IDVB_EIT_RegisterForNextTable(This,hNextTableAvailable)	\
    ( (This)->lpVtbl -> RegisterForNextTable(This,hNextTableAvailable) ) 

#define IDVB_EIT_GetNextTable(This,ppEIT)	\
    ( (This)->lpVtbl -> GetNextTable(This,ppEIT) ) 

#define IDVB_EIT_RegisterForWhenCurrent(This,hNextTableIsCurrent)	\
    ( (This)->lpVtbl -> RegisterForWhenCurrent(This,hNextTableIsCurrent) ) 

#define IDVB_EIT_ConvertNextToCurrent(This)	\
    ( (This)->lpVtbl -> ConvertNextToCurrent(This) ) 

#define IDVB_EIT_GetVersionHash(This,pdwVersionHash)	\
    ( (This)->lpVtbl -> GetVersionHash(This,pdwVersionHash) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVB_EIT_INTERFACE_DEFINED__ */


#ifndef __IDVB_EIT2_INTERFACE_DEFINED__
#define __IDVB_EIT2_INTERFACE_DEFINED__

/* interface IDVB_EIT2 */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDVB_EIT2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("61A389E0-9B9E-4ba0-AEEA-5DDD159820EA")
    IDVB_EIT2 : public IDVB_EIT
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSegmentInfo( 
            /* [out] */ BYTE *pbTid,
            /* [out] */ BYTE *pbSegment) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordSection( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVB_EIT2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVB_EIT2 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVB_EIT2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVB_EIT2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDVB_EIT2 * This,
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionNumber )( 
            IDVB_EIT2 * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceId )( 
            IDVB_EIT2 * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransportStreamId )( 
            IDVB_EIT2 * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetOriginalNetworkId )( 
            IDVB_EIT2 * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSegmentLastSectionNumber )( 
            IDVB_EIT2 * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastTableId )( 
            IDVB_EIT2 * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IDVB_EIT2 * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordEventId )( 
            IDVB_EIT2 * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordStartTime )( 
            IDVB_EIT2 * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ MPEG_DATE_AND_TIME *pmdtVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDuration )( 
            IDVB_EIT2 * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ MPEG_DURATION *pmdVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordRunningStatus )( 
            IDVB_EIT2 * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordFreeCAMode )( 
            IDVB_EIT2 * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BOOL *pfVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordCountOfDescriptors )( 
            IDVB_EIT2 * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByIndex )( 
            IDVB_EIT2 * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByTag )( 
            IDVB_EIT2 * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterForNextTable )( 
            IDVB_EIT2 * This,
            /* [in] */ HANDLE hNextTableAvailable);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextTable )( 
            IDVB_EIT2 * This,
            /* [out] */ IDVB_EIT **ppEIT);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterForWhenCurrent )( 
            IDVB_EIT2 * This,
            /* [in] */ HANDLE hNextTableIsCurrent);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertNextToCurrent )( 
            IDVB_EIT2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionHash )( 
            IDVB_EIT2 * This,
            /* [out] */ DWORD *pdwVersionHash);
        
        HRESULT ( STDMETHODCALLTYPE *GetSegmentInfo )( 
            IDVB_EIT2 * This,
            /* [out] */ BYTE *pbTid,
            /* [out] */ BYTE *pbSegment);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordSection )( 
            IDVB_EIT2 * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        END_INTERFACE
    } IDVB_EIT2Vtbl;

    interface IDVB_EIT2
    {
        CONST_VTBL struct IDVB_EIT2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVB_EIT2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVB_EIT2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVB_EIT2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVB_EIT2_Initialize(This,pSectionList,pMPEGData)	\
    ( (This)->lpVtbl -> Initialize(This,pSectionList,pMPEGData) ) 

#define IDVB_EIT2_GetVersionNumber(This,pbVal)	\
    ( (This)->lpVtbl -> GetVersionNumber(This,pbVal) ) 

#define IDVB_EIT2_GetServiceId(This,pwVal)	\
    ( (This)->lpVtbl -> GetServiceId(This,pwVal) ) 

#define IDVB_EIT2_GetTransportStreamId(This,pwVal)	\
    ( (This)->lpVtbl -> GetTransportStreamId(This,pwVal) ) 

#define IDVB_EIT2_GetOriginalNetworkId(This,pwVal)	\
    ( (This)->lpVtbl -> GetOriginalNetworkId(This,pwVal) ) 

#define IDVB_EIT2_GetSegmentLastSectionNumber(This,pbVal)	\
    ( (This)->lpVtbl -> GetSegmentLastSectionNumber(This,pbVal) ) 

#define IDVB_EIT2_GetLastTableId(This,pbVal)	\
    ( (This)->lpVtbl -> GetLastTableId(This,pbVal) ) 

#define IDVB_EIT2_GetCountOfRecords(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pdwVal) ) 

#define IDVB_EIT2_GetRecordEventId(This,dwRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordEventId(This,dwRecordIndex,pwVal) ) 

#define IDVB_EIT2_GetRecordStartTime(This,dwRecordIndex,pmdtVal)	\
    ( (This)->lpVtbl -> GetRecordStartTime(This,dwRecordIndex,pmdtVal) ) 

#define IDVB_EIT2_GetRecordDuration(This,dwRecordIndex,pmdVal)	\
    ( (This)->lpVtbl -> GetRecordDuration(This,dwRecordIndex,pmdVal) ) 

#define IDVB_EIT2_GetRecordRunningStatus(This,dwRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordRunningStatus(This,dwRecordIndex,pbVal) ) 

#define IDVB_EIT2_GetRecordFreeCAMode(This,dwRecordIndex,pfVal)	\
    ( (This)->lpVtbl -> GetRecordFreeCAMode(This,dwRecordIndex,pfVal) ) 

#define IDVB_EIT2_GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal)	\
    ( (This)->lpVtbl -> GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal) ) 

#define IDVB_EIT2_GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor) ) 

#define IDVB_EIT2_GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor) ) 

#define IDVB_EIT2_RegisterForNextTable(This,hNextTableAvailable)	\
    ( (This)->lpVtbl -> RegisterForNextTable(This,hNextTableAvailable) ) 

#define IDVB_EIT2_GetNextTable(This,ppEIT)	\
    ( (This)->lpVtbl -> GetNextTable(This,ppEIT) ) 

#define IDVB_EIT2_RegisterForWhenCurrent(This,hNextTableIsCurrent)	\
    ( (This)->lpVtbl -> RegisterForWhenCurrent(This,hNextTableIsCurrent) ) 

#define IDVB_EIT2_ConvertNextToCurrent(This)	\
    ( (This)->lpVtbl -> ConvertNextToCurrent(This) ) 

#define IDVB_EIT2_GetVersionHash(This,pdwVersionHash)	\
    ( (This)->lpVtbl -> GetVersionHash(This,pdwVersionHash) ) 


#define IDVB_EIT2_GetSegmentInfo(This,pbTid,pbSegment)	\
    ( (This)->lpVtbl -> GetSegmentInfo(This,pbTid,pbSegment) ) 

#define IDVB_EIT2_GetRecordSection(This,dwRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordSection(This,dwRecordIndex,pbVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVB_EIT2_INTERFACE_DEFINED__ */


#ifndef __IDVB_BAT_INTERFACE_DEFINED__
#define __IDVB_BAT_INTERFACE_DEFINED__

/* interface IDVB_BAT */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDVB_BAT;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ECE9BB0C-43B6-4558-A0EC-1812C34CD6CA")
    IDVB_BAT : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionNumber( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBouquetId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfTableDescriptors( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTableDescriptorByIndex( 
            /* [in] */ DWORD dwIndex,
            /* [in] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTableDescriptorByTag( 
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordTransportStreamId( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordOriginalNetworkId( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordCountOfDescriptors( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptorByIndex( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptorByTag( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterForNextTable( 
            /* [in] */ HANDLE hNextTableAvailable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextTable( 
            /* [out] */ IDVB_BAT **ppBAT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterForWhenCurrent( 
            /* [in] */ HANDLE hNextTableIsCurrent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertNextToCurrent( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVB_BATVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVB_BAT * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVB_BAT * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVB_BAT * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDVB_BAT * This,
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionNumber )( 
            IDVB_BAT * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetBouquetId )( 
            IDVB_BAT * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfTableDescriptors )( 
            IDVB_BAT * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTableDescriptorByIndex )( 
            IDVB_BAT * This,
            /* [in] */ DWORD dwIndex,
            /* [in] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetTableDescriptorByTag )( 
            IDVB_BAT * This,
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IDVB_BAT * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordTransportStreamId )( 
            IDVB_BAT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordOriginalNetworkId )( 
            IDVB_BAT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordCountOfDescriptors )( 
            IDVB_BAT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByIndex )( 
            IDVB_BAT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByTag )( 
            IDVB_BAT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterForNextTable )( 
            IDVB_BAT * This,
            /* [in] */ HANDLE hNextTableAvailable);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextTable )( 
            IDVB_BAT * This,
            /* [out] */ IDVB_BAT **ppBAT);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterForWhenCurrent )( 
            IDVB_BAT * This,
            /* [in] */ HANDLE hNextTableIsCurrent);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertNextToCurrent )( 
            IDVB_BAT * This);
        
        END_INTERFACE
    } IDVB_BATVtbl;

    interface IDVB_BAT
    {
        CONST_VTBL struct IDVB_BATVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVB_BAT_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVB_BAT_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVB_BAT_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVB_BAT_Initialize(This,pSectionList,pMPEGData)	\
    ( (This)->lpVtbl -> Initialize(This,pSectionList,pMPEGData) ) 

#define IDVB_BAT_GetVersionNumber(This,pbVal)	\
    ( (This)->lpVtbl -> GetVersionNumber(This,pbVal) ) 

#define IDVB_BAT_GetBouquetId(This,pwVal)	\
    ( (This)->lpVtbl -> GetBouquetId(This,pwVal) ) 

#define IDVB_BAT_GetCountOfTableDescriptors(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCountOfTableDescriptors(This,pdwVal) ) 

#define IDVB_BAT_GetTableDescriptorByIndex(This,dwIndex,ppDescriptor)	\
    ( (This)->lpVtbl -> GetTableDescriptorByIndex(This,dwIndex,ppDescriptor) ) 

#define IDVB_BAT_GetTableDescriptorByTag(This,bTag,pdwCookie,ppDescriptor)	\
    ( (This)->lpVtbl -> GetTableDescriptorByTag(This,bTag,pdwCookie,ppDescriptor) ) 

#define IDVB_BAT_GetCountOfRecords(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pdwVal) ) 

#define IDVB_BAT_GetRecordTransportStreamId(This,dwRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordTransportStreamId(This,dwRecordIndex,pwVal) ) 

#define IDVB_BAT_GetRecordOriginalNetworkId(This,dwRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordOriginalNetworkId(This,dwRecordIndex,pwVal) ) 

#define IDVB_BAT_GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal)	\
    ( (This)->lpVtbl -> GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal) ) 

#define IDVB_BAT_GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor) ) 

#define IDVB_BAT_GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor) ) 

#define IDVB_BAT_RegisterForNextTable(This,hNextTableAvailable)	\
    ( (This)->lpVtbl -> RegisterForNextTable(This,hNextTableAvailable) ) 

#define IDVB_BAT_GetNextTable(This,ppBAT)	\
    ( (This)->lpVtbl -> GetNextTable(This,ppBAT) ) 

#define IDVB_BAT_RegisterForWhenCurrent(This,hNextTableIsCurrent)	\
    ( (This)->lpVtbl -> RegisterForWhenCurrent(This,hNextTableIsCurrent) ) 

#define IDVB_BAT_ConvertNextToCurrent(This)	\
    ( (This)->lpVtbl -> ConvertNextToCurrent(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVB_BAT_INTERFACE_DEFINED__ */


#ifndef __IDVB_RST_INTERFACE_DEFINED__
#define __IDVB_RST_INTERFACE_DEFINED__

/* interface IDVB_RST */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDVB_RST;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F47DCD04-1E23-4fb7-9F96-B40EEAD10B2B")
    IDVB_RST : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ ISectionList *pSectionList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordTransportStreamId( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordOriginalNetworkId( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordServiceId( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordEventId( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordRunningStatus( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVB_RSTVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVB_RST * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVB_RST * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVB_RST * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDVB_RST * This,
            /* [in] */ ISectionList *pSectionList);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IDVB_RST * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordTransportStreamId )( 
            IDVB_RST * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordOriginalNetworkId )( 
            IDVB_RST * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordServiceId )( 
            IDVB_RST * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordEventId )( 
            IDVB_RST * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordRunningStatus )( 
            IDVB_RST * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        END_INTERFACE
    } IDVB_RSTVtbl;

    interface IDVB_RST
    {
        CONST_VTBL struct IDVB_RSTVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVB_RST_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVB_RST_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVB_RST_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVB_RST_Initialize(This,pSectionList)	\
    ( (This)->lpVtbl -> Initialize(This,pSectionList) ) 

#define IDVB_RST_GetCountOfRecords(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pdwVal) ) 

#define IDVB_RST_GetRecordTransportStreamId(This,dwRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordTransportStreamId(This,dwRecordIndex,pwVal) ) 

#define IDVB_RST_GetRecordOriginalNetworkId(This,dwRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordOriginalNetworkId(This,dwRecordIndex,pwVal) ) 

#define IDVB_RST_GetRecordServiceId(This,dwRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordServiceId(This,dwRecordIndex,pwVal) ) 

#define IDVB_RST_GetRecordEventId(This,dwRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordEventId(This,dwRecordIndex,pwVal) ) 

#define IDVB_RST_GetRecordRunningStatus(This,dwRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordRunningStatus(This,dwRecordIndex,pbVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVB_RST_INTERFACE_DEFINED__ */


#ifndef __IDVB_ST_INTERFACE_DEFINED__
#define __IDVB_ST_INTERFACE_DEFINED__

/* interface IDVB_ST */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDVB_ST;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4D5B9F23-2A02-45de-BCDA-5D5DBFBFBE62")
    IDVB_ST : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ ISectionList *pSectionList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDataLength( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetData( 
            /* [out] */ BYTE **ppData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVB_STVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVB_ST * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVB_ST * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVB_ST * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDVB_ST * This,
            /* [in] */ ISectionList *pSectionList);
        
        HRESULT ( STDMETHODCALLTYPE *GetDataLength )( 
            IDVB_ST * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetData )( 
            IDVB_ST * This,
            /* [out] */ BYTE **ppData);
        
        END_INTERFACE
    } IDVB_STVtbl;

    interface IDVB_ST
    {
        CONST_VTBL struct IDVB_STVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVB_ST_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVB_ST_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVB_ST_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVB_ST_Initialize(This,pSectionList)	\
    ( (This)->lpVtbl -> Initialize(This,pSectionList) ) 

#define IDVB_ST_GetDataLength(This,pwVal)	\
    ( (This)->lpVtbl -> GetDataLength(This,pwVal) ) 

#define IDVB_ST_GetData(This,ppData)	\
    ( (This)->lpVtbl -> GetData(This,ppData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVB_ST_INTERFACE_DEFINED__ */


#ifndef __IDVB_TDT_INTERFACE_DEFINED__
#define __IDVB_TDT_INTERFACE_DEFINED__

/* interface IDVB_TDT */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDVB_TDT;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0780DC7D-D55C-4aef-97E6-6B75906E2796")
    IDVB_TDT : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ ISectionList *pSectionList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUTCTime( 
            /* [out] */ MPEG_DATE_AND_TIME *pmdtVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVB_TDTVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVB_TDT * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVB_TDT * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVB_TDT * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDVB_TDT * This,
            /* [in] */ ISectionList *pSectionList);
        
        HRESULT ( STDMETHODCALLTYPE *GetUTCTime )( 
            IDVB_TDT * This,
            /* [out] */ MPEG_DATE_AND_TIME *pmdtVal);
        
        END_INTERFACE
    } IDVB_TDTVtbl;

    interface IDVB_TDT
    {
        CONST_VTBL struct IDVB_TDTVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVB_TDT_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVB_TDT_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVB_TDT_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVB_TDT_Initialize(This,pSectionList)	\
    ( (This)->lpVtbl -> Initialize(This,pSectionList) ) 

#define IDVB_TDT_GetUTCTime(This,pmdtVal)	\
    ( (This)->lpVtbl -> GetUTCTime(This,pmdtVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVB_TDT_INTERFACE_DEFINED__ */


#ifndef __IDVB_TOT_INTERFACE_DEFINED__
#define __IDVB_TOT_INTERFACE_DEFINED__

/* interface IDVB_TOT */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDVB_TOT;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("83295D6A-FABA-4ee1-9B15-8067696910AE")
    IDVB_TOT : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ ISectionList *pSectionList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUTCTime( 
            /* [out] */ MPEG_DATE_AND_TIME *pmdtVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfTableDescriptors( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTableDescriptorByIndex( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTableDescriptorByTag( 
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVB_TOTVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVB_TOT * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVB_TOT * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVB_TOT * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDVB_TOT * This,
            /* [in] */ ISectionList *pSectionList);
        
        HRESULT ( STDMETHODCALLTYPE *GetUTCTime )( 
            IDVB_TOT * This,
            /* [out] */ MPEG_DATE_AND_TIME *pmdtVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfTableDescriptors )( 
            IDVB_TOT * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTableDescriptorByIndex )( 
            IDVB_TOT * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetTableDescriptorByTag )( 
            IDVB_TOT * This,
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        END_INTERFACE
    } IDVB_TOTVtbl;

    interface IDVB_TOT
    {
        CONST_VTBL struct IDVB_TOTVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVB_TOT_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVB_TOT_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVB_TOT_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVB_TOT_Initialize(This,pSectionList)	\
    ( (This)->lpVtbl -> Initialize(This,pSectionList) ) 

#define IDVB_TOT_GetUTCTime(This,pmdtVal)	\
    ( (This)->lpVtbl -> GetUTCTime(This,pmdtVal) ) 

#define IDVB_TOT_GetCountOfTableDescriptors(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCountOfTableDescriptors(This,pdwVal) ) 

#define IDVB_TOT_GetTableDescriptorByIndex(This,dwIndex,ppDescriptor)	\
    ( (This)->lpVtbl -> GetTableDescriptorByIndex(This,dwIndex,ppDescriptor) ) 

#define IDVB_TOT_GetTableDescriptorByTag(This,bTag,pdwCookie,ppDescriptor)	\
    ( (This)->lpVtbl -> GetTableDescriptorByTag(This,bTag,pdwCookie,ppDescriptor) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVB_TOT_INTERFACE_DEFINED__ */


#ifndef __IDVB_DIT_INTERFACE_DEFINED__
#define __IDVB_DIT_INTERFACE_DEFINED__

/* interface IDVB_DIT */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDVB_DIT;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("91BFFDF9-9432-410f-86EF-1C228ED0AD70")
    IDVB_DIT : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ ISectionList *pSectionList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransitionFlag( 
            /* [out] */ BOOL *pfVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVB_DITVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVB_DIT * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVB_DIT * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVB_DIT * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDVB_DIT * This,
            /* [in] */ ISectionList *pSectionList);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransitionFlag )( 
            IDVB_DIT * This,
            /* [out] */ BOOL *pfVal);
        
        END_INTERFACE
    } IDVB_DITVtbl;

    interface IDVB_DIT
    {
        CONST_VTBL struct IDVB_DITVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVB_DIT_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVB_DIT_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVB_DIT_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVB_DIT_Initialize(This,pSectionList)	\
    ( (This)->lpVtbl -> Initialize(This,pSectionList) ) 

#define IDVB_DIT_GetTransitionFlag(This,pfVal)	\
    ( (This)->lpVtbl -> GetTransitionFlag(This,pfVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVB_DIT_INTERFACE_DEFINED__ */


#ifndef __IDVB_SIT_INTERFACE_DEFINED__
#define __IDVB_SIT_INTERFACE_DEFINED__

/* interface IDVB_SIT */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDVB_SIT;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("68CDCE53-8BEA-45c2-9D9D-ACF575A089B5")
    IDVB_SIT : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionNumber( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfTableDescriptors( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTableDescriptorByIndex( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTableDescriptorByTag( 
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordServiceId( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordRunningStatus( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordCountOfDescriptors( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptorByIndex( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptorByTag( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterForNextTable( 
            /* [in] */ HANDLE hNextTableAvailable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextTable( 
            /* [in] */ DWORD dwTimeout,
            /* [out] */ IDVB_SIT **ppSIT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterForWhenCurrent( 
            /* [in] */ HANDLE hNextTableIsCurrent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertNextToCurrent( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVB_SITVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVB_SIT * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVB_SIT * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVB_SIT * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDVB_SIT * This,
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionNumber )( 
            IDVB_SIT * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfTableDescriptors )( 
            IDVB_SIT * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTableDescriptorByIndex )( 
            IDVB_SIT * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetTableDescriptorByTag )( 
            IDVB_SIT * This,
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IDVB_SIT * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordServiceId )( 
            IDVB_SIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordRunningStatus )( 
            IDVB_SIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordCountOfDescriptors )( 
            IDVB_SIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByIndex )( 
            IDVB_SIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByTag )( 
            IDVB_SIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterForNextTable )( 
            IDVB_SIT * This,
            /* [in] */ HANDLE hNextTableAvailable);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextTable )( 
            IDVB_SIT * This,
            /* [in] */ DWORD dwTimeout,
            /* [out] */ IDVB_SIT **ppSIT);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterForWhenCurrent )( 
            IDVB_SIT * This,
            /* [in] */ HANDLE hNextTableIsCurrent);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertNextToCurrent )( 
            IDVB_SIT * This);
        
        END_INTERFACE
    } IDVB_SITVtbl;

    interface IDVB_SIT
    {
        CONST_VTBL struct IDVB_SITVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVB_SIT_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVB_SIT_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVB_SIT_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVB_SIT_Initialize(This,pSectionList,pMPEGData)	\
    ( (This)->lpVtbl -> Initialize(This,pSectionList,pMPEGData) ) 

#define IDVB_SIT_GetVersionNumber(This,pbVal)	\
    ( (This)->lpVtbl -> GetVersionNumber(This,pbVal) ) 

#define IDVB_SIT_GetCountOfTableDescriptors(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCountOfTableDescriptors(This,pdwVal) ) 

#define IDVB_SIT_GetTableDescriptorByIndex(This,dwIndex,ppDescriptor)	\
    ( (This)->lpVtbl -> GetTableDescriptorByIndex(This,dwIndex,ppDescriptor) ) 

#define IDVB_SIT_GetTableDescriptorByTag(This,bTag,pdwCookie,ppDescriptor)	\
    ( (This)->lpVtbl -> GetTableDescriptorByTag(This,bTag,pdwCookie,ppDescriptor) ) 

#define IDVB_SIT_GetCountOfRecords(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pdwVal) ) 

#define IDVB_SIT_GetRecordServiceId(This,dwRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordServiceId(This,dwRecordIndex,pwVal) ) 

#define IDVB_SIT_GetRecordRunningStatus(This,dwRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordRunningStatus(This,dwRecordIndex,pbVal) ) 

#define IDVB_SIT_GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal)	\
    ( (This)->lpVtbl -> GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal) ) 

#define IDVB_SIT_GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor) ) 

#define IDVB_SIT_GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor) ) 

#define IDVB_SIT_RegisterForNextTable(This,hNextTableAvailable)	\
    ( (This)->lpVtbl -> RegisterForNextTable(This,hNextTableAvailable) ) 

#define IDVB_SIT_GetNextTable(This,dwTimeout,ppSIT)	\
    ( (This)->lpVtbl -> GetNextTable(This,dwTimeout,ppSIT) ) 

#define IDVB_SIT_RegisterForWhenCurrent(This,hNextTableIsCurrent)	\
    ( (This)->lpVtbl -> RegisterForWhenCurrent(This,hNextTableIsCurrent) ) 

#define IDVB_SIT_ConvertNextToCurrent(This)	\
    ( (This)->lpVtbl -> ConvertNextToCurrent(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVB_SIT_INTERFACE_DEFINED__ */


#ifndef __IISDB_BIT_INTERFACE_DEFINED__
#define __IISDB_BIT_INTERFACE_DEFINED__

/* interface IISDB_BIT */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IISDB_BIT;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("537CD71E-0E46-4173-9001-BA043F3E49E2")
    IISDB_BIT : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionNumber( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOriginalNetworkId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBroadcastViewPropriety( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfTableDescriptors( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTableDescriptorByIndex( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTableDescriptorByTag( 
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordBroadcasterId( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordCountOfDescriptors( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptorByIndex( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptorByTag( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionHash( 
            /* [out] */ DWORD *pdwVersionHash) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IISDB_BITVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IISDB_BIT * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IISDB_BIT * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IISDB_BIT * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IISDB_BIT * This,
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionNumber )( 
            IISDB_BIT * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetOriginalNetworkId )( 
            IISDB_BIT * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetBroadcastViewPropriety )( 
            IISDB_BIT * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfTableDescriptors )( 
            IISDB_BIT * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTableDescriptorByIndex )( 
            IISDB_BIT * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetTableDescriptorByTag )( 
            IISDB_BIT * This,
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IISDB_BIT * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordBroadcasterId )( 
            IISDB_BIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordCountOfDescriptors )( 
            IISDB_BIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByIndex )( 
            IISDB_BIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByTag )( 
            IISDB_BIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionHash )( 
            IISDB_BIT * This,
            /* [out] */ DWORD *pdwVersionHash);
        
        END_INTERFACE
    } IISDB_BITVtbl;

    interface IISDB_BIT
    {
        CONST_VTBL struct IISDB_BITVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IISDB_BIT_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IISDB_BIT_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IISDB_BIT_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IISDB_BIT_Initialize(This,pSectionList,pMPEGData)	\
    ( (This)->lpVtbl -> Initialize(This,pSectionList,pMPEGData) ) 

#define IISDB_BIT_GetVersionNumber(This,pbVal)	\
    ( (This)->lpVtbl -> GetVersionNumber(This,pbVal) ) 

#define IISDB_BIT_GetOriginalNetworkId(This,pwVal)	\
    ( (This)->lpVtbl -> GetOriginalNetworkId(This,pwVal) ) 

#define IISDB_BIT_GetBroadcastViewPropriety(This,pbVal)	\
    ( (This)->lpVtbl -> GetBroadcastViewPropriety(This,pbVal) ) 

#define IISDB_BIT_GetCountOfTableDescriptors(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCountOfTableDescriptors(This,pdwVal) ) 

#define IISDB_BIT_GetTableDescriptorByIndex(This,dwIndex,ppDescriptor)	\
    ( (This)->lpVtbl -> GetTableDescriptorByIndex(This,dwIndex,ppDescriptor) ) 

#define IISDB_BIT_GetTableDescriptorByTag(This,bTag,pdwCookie,ppDescriptor)	\
    ( (This)->lpVtbl -> GetTableDescriptorByTag(This,bTag,pdwCookie,ppDescriptor) ) 

#define IISDB_BIT_GetCountOfRecords(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pdwVal) ) 

#define IISDB_BIT_GetRecordBroadcasterId(This,dwRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordBroadcasterId(This,dwRecordIndex,pbVal) ) 

#define IISDB_BIT_GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal)	\
    ( (This)->lpVtbl -> GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal) ) 

#define IISDB_BIT_GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor) ) 

#define IISDB_BIT_GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor) ) 

#define IISDB_BIT_GetVersionHash(This,pdwVersionHash)	\
    ( (This)->lpVtbl -> GetVersionHash(This,pdwVersionHash) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IISDB_BIT_INTERFACE_DEFINED__ */


#ifndef __IISDB_NBIT_INTERFACE_DEFINED__
#define __IISDB_NBIT_INTERFACE_DEFINED__

/* interface IISDB_NBIT */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IISDB_NBIT;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1B1863EF-08F1-40B7-A559-3B1EFF8CAFA6")
    IISDB_NBIT : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionNumber( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOriginalNetworkId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordInformationId( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordInformationType( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptionBodyLocation( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordMessageSectionNumber( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordUserDefined( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordNumberOfKeys( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordKeys( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE **pbKeys) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordCountOfDescriptors( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptorByIndex( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptorByTag( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionHash( 
            /* [out] */ DWORD *pdwVersionHash) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IISDB_NBITVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IISDB_NBIT * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IISDB_NBIT * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IISDB_NBIT * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IISDB_NBIT * This,
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionNumber )( 
            IISDB_NBIT * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetOriginalNetworkId )( 
            IISDB_NBIT * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IISDB_NBIT * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordInformationId )( 
            IISDB_NBIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordInformationType )( 
            IISDB_NBIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptionBodyLocation )( 
            IISDB_NBIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordMessageSectionNumber )( 
            IISDB_NBIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordUserDefined )( 
            IISDB_NBIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordNumberOfKeys )( 
            IISDB_NBIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordKeys )( 
            IISDB_NBIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE **pbKeys);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordCountOfDescriptors )( 
            IISDB_NBIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByIndex )( 
            IISDB_NBIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByTag )( 
            IISDB_NBIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionHash )( 
            IISDB_NBIT * This,
            /* [out] */ DWORD *pdwVersionHash);
        
        END_INTERFACE
    } IISDB_NBITVtbl;

    interface IISDB_NBIT
    {
        CONST_VTBL struct IISDB_NBITVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IISDB_NBIT_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IISDB_NBIT_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IISDB_NBIT_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IISDB_NBIT_Initialize(This,pSectionList,pMPEGData)	\
    ( (This)->lpVtbl -> Initialize(This,pSectionList,pMPEGData) ) 

#define IISDB_NBIT_GetVersionNumber(This,pbVal)	\
    ( (This)->lpVtbl -> GetVersionNumber(This,pbVal) ) 

#define IISDB_NBIT_GetOriginalNetworkId(This,pwVal)	\
    ( (This)->lpVtbl -> GetOriginalNetworkId(This,pwVal) ) 

#define IISDB_NBIT_GetCountOfRecords(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pdwVal) ) 

#define IISDB_NBIT_GetRecordInformationId(This,dwRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordInformationId(This,dwRecordIndex,pwVal) ) 

#define IISDB_NBIT_GetRecordInformationType(This,dwRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordInformationType(This,dwRecordIndex,pbVal) ) 

#define IISDB_NBIT_GetRecordDescriptionBodyLocation(This,dwRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordDescriptionBodyLocation(This,dwRecordIndex,pbVal) ) 

#define IISDB_NBIT_GetRecordMessageSectionNumber(This,dwRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordMessageSectionNumber(This,dwRecordIndex,pbVal) ) 

#define IISDB_NBIT_GetRecordUserDefined(This,dwRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordUserDefined(This,dwRecordIndex,pbVal) ) 

#define IISDB_NBIT_GetRecordNumberOfKeys(This,dwRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordNumberOfKeys(This,dwRecordIndex,pbVal) ) 

#define IISDB_NBIT_GetRecordKeys(This,dwRecordIndex,pbKeys)	\
    ( (This)->lpVtbl -> GetRecordKeys(This,dwRecordIndex,pbKeys) ) 

#define IISDB_NBIT_GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal)	\
    ( (This)->lpVtbl -> GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal) ) 

#define IISDB_NBIT_GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor) ) 

#define IISDB_NBIT_GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor) ) 

#define IISDB_NBIT_GetVersionHash(This,pdwVersionHash)	\
    ( (This)->lpVtbl -> GetVersionHash(This,pdwVersionHash) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IISDB_NBIT_INTERFACE_DEFINED__ */


#ifndef __IISDB_LDT_INTERFACE_DEFINED__
#define __IISDB_LDT_INTERFACE_DEFINED__

/* interface IISDB_LDT */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IISDB_LDT;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("141A546B-02FF-4FB9-A3A3-2F074B74A9A9")
    IISDB_LDT : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionNumber( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOriginalServiceId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransportStreamId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOriginalNetworkId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptionId( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordCountOfDescriptors( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptorByIndex( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptorByTag( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionHash( 
            /* [out] */ DWORD *pdwVersionHash) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IISDB_LDTVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IISDB_LDT * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IISDB_LDT * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IISDB_LDT * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IISDB_LDT * This,
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionNumber )( 
            IISDB_LDT * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetOriginalServiceId )( 
            IISDB_LDT * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransportStreamId )( 
            IISDB_LDT * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetOriginalNetworkId )( 
            IISDB_LDT * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IISDB_LDT * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptionId )( 
            IISDB_LDT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordCountOfDescriptors )( 
            IISDB_LDT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByIndex )( 
            IISDB_LDT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByTag )( 
            IISDB_LDT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionHash )( 
            IISDB_LDT * This,
            /* [out] */ DWORD *pdwVersionHash);
        
        END_INTERFACE
    } IISDB_LDTVtbl;

    interface IISDB_LDT
    {
        CONST_VTBL struct IISDB_LDTVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IISDB_LDT_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IISDB_LDT_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IISDB_LDT_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IISDB_LDT_Initialize(This,pSectionList,pMPEGData)	\
    ( (This)->lpVtbl -> Initialize(This,pSectionList,pMPEGData) ) 

#define IISDB_LDT_GetVersionNumber(This,pbVal)	\
    ( (This)->lpVtbl -> GetVersionNumber(This,pbVal) ) 

#define IISDB_LDT_GetOriginalServiceId(This,pwVal)	\
    ( (This)->lpVtbl -> GetOriginalServiceId(This,pwVal) ) 

#define IISDB_LDT_GetTransportStreamId(This,pwVal)	\
    ( (This)->lpVtbl -> GetTransportStreamId(This,pwVal) ) 

#define IISDB_LDT_GetOriginalNetworkId(This,pwVal)	\
    ( (This)->lpVtbl -> GetOriginalNetworkId(This,pwVal) ) 

#define IISDB_LDT_GetCountOfRecords(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pdwVal) ) 

#define IISDB_LDT_GetRecordDescriptionId(This,dwRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordDescriptionId(This,dwRecordIndex,pwVal) ) 

#define IISDB_LDT_GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal)	\
    ( (This)->lpVtbl -> GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal) ) 

#define IISDB_LDT_GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor) ) 

#define IISDB_LDT_GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor) ) 

#define IISDB_LDT_GetVersionHash(This,pdwVersionHash)	\
    ( (This)->lpVtbl -> GetVersionHash(This,pdwVersionHash) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IISDB_LDT_INTERFACE_DEFINED__ */


#ifndef __IISDB_SDTT_INTERFACE_DEFINED__
#define __IISDB_SDTT_INTERFACE_DEFINED__

/* interface IISDB_SDTT */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IISDB_SDTT;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EE60EF2D-813A-4DC7-BF92-EA13DAC85313")
    IISDB_SDTT : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionNumber( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTableIdExt( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransportStreamId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOriginalNetworkId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServiceId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordGroup( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordTargetVersion( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordNewVersion( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDownloadLevel( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordVersionIndicator( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordScheduleTimeShiftInformation( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordCountOfSchedules( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordStartTimeByIndex( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ MPEG_DATE_AND_TIME *pmdtVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDurationByIndex( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ MPEG_DURATION *pmdVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordCountOfDescriptors( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptorByIndex( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptorByTag( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionHash( 
            /* [out] */ DWORD *pdwVersionHash) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IISDB_SDTTVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IISDB_SDTT * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IISDB_SDTT * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IISDB_SDTT * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IISDB_SDTT * This,
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionNumber )( 
            IISDB_SDTT * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTableIdExt )( 
            IISDB_SDTT * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransportStreamId )( 
            IISDB_SDTT * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetOriginalNetworkId )( 
            IISDB_SDTT * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceId )( 
            IISDB_SDTT * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IISDB_SDTT * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordGroup )( 
            IISDB_SDTT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordTargetVersion )( 
            IISDB_SDTT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordNewVersion )( 
            IISDB_SDTT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDownloadLevel )( 
            IISDB_SDTT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordVersionIndicator )( 
            IISDB_SDTT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordScheduleTimeShiftInformation )( 
            IISDB_SDTT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordCountOfSchedules )( 
            IISDB_SDTT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordStartTimeByIndex )( 
            IISDB_SDTT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ MPEG_DATE_AND_TIME *pmdtVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDurationByIndex )( 
            IISDB_SDTT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ MPEG_DURATION *pmdVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordCountOfDescriptors )( 
            IISDB_SDTT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByIndex )( 
            IISDB_SDTT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByTag )( 
            IISDB_SDTT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionHash )( 
            IISDB_SDTT * This,
            /* [out] */ DWORD *pdwVersionHash);
        
        END_INTERFACE
    } IISDB_SDTTVtbl;

    interface IISDB_SDTT
    {
        CONST_VTBL struct IISDB_SDTTVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IISDB_SDTT_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IISDB_SDTT_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IISDB_SDTT_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IISDB_SDTT_Initialize(This,pSectionList,pMPEGData)	\
    ( (This)->lpVtbl -> Initialize(This,pSectionList,pMPEGData) ) 

#define IISDB_SDTT_GetVersionNumber(This,pbVal)	\
    ( (This)->lpVtbl -> GetVersionNumber(This,pbVal) ) 

#define IISDB_SDTT_GetTableIdExt(This,pwVal)	\
    ( (This)->lpVtbl -> GetTableIdExt(This,pwVal) ) 

#define IISDB_SDTT_GetTransportStreamId(This,pwVal)	\
    ( (This)->lpVtbl -> GetTransportStreamId(This,pwVal) ) 

#define IISDB_SDTT_GetOriginalNetworkId(This,pwVal)	\
    ( (This)->lpVtbl -> GetOriginalNetworkId(This,pwVal) ) 

#define IISDB_SDTT_GetServiceId(This,pwVal)	\
    ( (This)->lpVtbl -> GetServiceId(This,pwVal) ) 

#define IISDB_SDTT_GetCountOfRecords(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pdwVal) ) 

#define IISDB_SDTT_GetRecordGroup(This,dwRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordGroup(This,dwRecordIndex,pbVal) ) 

#define IISDB_SDTT_GetRecordTargetVersion(This,dwRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordTargetVersion(This,dwRecordIndex,pwVal) ) 

#define IISDB_SDTT_GetRecordNewVersion(This,dwRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordNewVersion(This,dwRecordIndex,pwVal) ) 

#define IISDB_SDTT_GetRecordDownloadLevel(This,dwRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordDownloadLevel(This,dwRecordIndex,pbVal) ) 

#define IISDB_SDTT_GetRecordVersionIndicator(This,dwRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordVersionIndicator(This,dwRecordIndex,pbVal) ) 

#define IISDB_SDTT_GetRecordScheduleTimeShiftInformation(This,dwRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordScheduleTimeShiftInformation(This,dwRecordIndex,pbVal) ) 

#define IISDB_SDTT_GetRecordCountOfSchedules(This,dwRecordIndex,pdwVal)	\
    ( (This)->lpVtbl -> GetRecordCountOfSchedules(This,dwRecordIndex,pdwVal) ) 

#define IISDB_SDTT_GetRecordStartTimeByIndex(This,dwRecordIndex,dwIndex,pmdtVal)	\
    ( (This)->lpVtbl -> GetRecordStartTimeByIndex(This,dwRecordIndex,dwIndex,pmdtVal) ) 

#define IISDB_SDTT_GetRecordDurationByIndex(This,dwRecordIndex,dwIndex,pmdVal)	\
    ( (This)->lpVtbl -> GetRecordDurationByIndex(This,dwRecordIndex,dwIndex,pmdVal) ) 

#define IISDB_SDTT_GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal)	\
    ( (This)->lpVtbl -> GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal) ) 

#define IISDB_SDTT_GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor) ) 

#define IISDB_SDTT_GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor) ) 

#define IISDB_SDTT_GetVersionHash(This,pdwVersionHash)	\
    ( (This)->lpVtbl -> GetVersionHash(This,pdwVersionHash) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IISDB_SDTT_INTERFACE_DEFINED__ */


#ifndef __IISDB_CDT_INTERFACE_DEFINED__
#define __IISDB_CDT_INTERFACE_DEFINED__

/* interface IISDB_CDT */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IISDB_CDT;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("25FA92C2-8B80-4787-A841-3A0E8F17984B")
    IISDB_CDT : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData,
            /* [in] */ BYTE bSectionNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionNumber( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDownloadDataId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSectionNumber( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOriginalNetworkId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDataType( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfTableDescriptors( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTableDescriptorByIndex( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTableDescriptorByTag( 
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSizeOfDataModule( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDataModule( 
            /* [out] */ BYTE **pbData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionHash( 
            /* [out] */ DWORD *pdwVersionHash) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IISDB_CDTVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IISDB_CDT * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IISDB_CDT * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IISDB_CDT * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IISDB_CDT * This,
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData,
            /* [in] */ BYTE bSectionNumber);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionNumber )( 
            IISDB_CDT * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetDownloadDataId )( 
            IISDB_CDT * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSectionNumber )( 
            IISDB_CDT * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetOriginalNetworkId )( 
            IISDB_CDT * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetDataType )( 
            IISDB_CDT * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfTableDescriptors )( 
            IISDB_CDT * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTableDescriptorByIndex )( 
            IISDB_CDT * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetTableDescriptorByTag )( 
            IISDB_CDT * This,
            /* [in] */ BYTE bTag,
            /* [annotation][out][in] */ 
            __inout_opt  DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetSizeOfDataModule )( 
            IISDB_CDT * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetDataModule )( 
            IISDB_CDT * This,
            /* [out] */ BYTE **pbData);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionHash )( 
            IISDB_CDT * This,
            /* [out] */ DWORD *pdwVersionHash);
        
        END_INTERFACE
    } IISDB_CDTVtbl;

    interface IISDB_CDT
    {
        CONST_VTBL struct IISDB_CDTVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IISDB_CDT_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IISDB_CDT_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IISDB_CDT_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IISDB_CDT_Initialize(This,pSectionList,pMPEGData,bSectionNumber)	\
    ( (This)->lpVtbl -> Initialize(This,pSectionList,pMPEGData,bSectionNumber) ) 

#define IISDB_CDT_GetVersionNumber(This,pbVal)	\
    ( (This)->lpVtbl -> GetVersionNumber(This,pbVal) ) 

#define IISDB_CDT_GetDownloadDataId(This,pwVal)	\
    ( (This)->lpVtbl -> GetDownloadDataId(This,pwVal) ) 

#define IISDB_CDT_GetSectionNumber(This,pbVal)	\
    ( (This)->lpVtbl -> GetSectionNumber(This,pbVal) ) 

#define IISDB_CDT_GetOriginalNetworkId(This,pwVal)	\
    ( (This)->lpVtbl -> GetOriginalNetworkId(This,pwVal) ) 

#define IISDB_CDT_GetDataType(This,pbVal)	\
    ( (This)->lpVtbl -> GetDataType(This,pbVal) ) 

#define IISDB_CDT_GetCountOfTableDescriptors(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCountOfTableDescriptors(This,pdwVal) ) 

#define IISDB_CDT_GetTableDescriptorByIndex(This,dwIndex,ppDescriptor)	\
    ( (This)->lpVtbl -> GetTableDescriptorByIndex(This,dwIndex,ppDescriptor) ) 

#define IISDB_CDT_GetTableDescriptorByTag(This,bTag,pdwCookie,ppDescriptor)	\
    ( (This)->lpVtbl -> GetTableDescriptorByTag(This,bTag,pdwCookie,ppDescriptor) ) 

#define IISDB_CDT_GetSizeOfDataModule(This,pdwVal)	\
    ( (This)->lpVtbl -> GetSizeOfDataModule(This,pdwVal) ) 

#define IISDB_CDT_GetDataModule(This,pbData)	\
    ( (This)->lpVtbl -> GetDataModule(This,pbData) ) 

#define IISDB_CDT_GetVersionHash(This,pdwVersionHash)	\
    ( (This)->lpVtbl -> GetVersionHash(This,pdwVersionHash) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IISDB_CDT_INTERFACE_DEFINED__ */


#ifndef __IISDB_EMM_INTERFACE_DEFINED__
#define __IISDB_EMM_INTERFACE_DEFINED__

/* interface IISDB_EMM */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IISDB_EMM;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0EDB556D-43AD-4938-9668-321B2FFECFD3")
    IISDB_EMM : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionNumber( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTableIdExtension( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDataBytes( 
            /* [out][in] */ WORD *pwBufferLength,
            /* [out] */ BYTE *pbBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSharedEmmMessage( 
            WORD *pwLength,
            BYTE **ppbMessage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndividualEmmMessage( 
            IUnknown *pUnknown,
            WORD *pwLength,
            BYTE **ppbMessage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionHash( 
            /* [out] */ DWORD *pdwVersionHash) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IISDB_EMMVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IISDB_EMM * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IISDB_EMM * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IISDB_EMM * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IISDB_EMM * This,
            /* [in] */ ISectionList *pSectionList,
            /* [in] */ IMpeg2Data *pMPEGData);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionNumber )( 
            IISDB_EMM * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTableIdExtension )( 
            IISDB_EMM * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetDataBytes )( 
            IISDB_EMM * This,
            /* [out][in] */ WORD *pwBufferLength,
            /* [out] */ BYTE *pbBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *GetSharedEmmMessage )( 
            IISDB_EMM * This,
            WORD *pwLength,
            BYTE **ppbMessage);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndividualEmmMessage )( 
            IISDB_EMM * This,
            IUnknown *pUnknown,
            WORD *pwLength,
            BYTE **ppbMessage);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionHash )( 
            IISDB_EMM * This,
            /* [out] */ DWORD *pdwVersionHash);
        
        END_INTERFACE
    } IISDB_EMMVtbl;

    interface IISDB_EMM
    {
        CONST_VTBL struct IISDB_EMMVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IISDB_EMM_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IISDB_EMM_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IISDB_EMM_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IISDB_EMM_Initialize(This,pSectionList,pMPEGData)	\
    ( (This)->lpVtbl -> Initialize(This,pSectionList,pMPEGData) ) 

#define IISDB_EMM_GetVersionNumber(This,pbVal)	\
    ( (This)->lpVtbl -> GetVersionNumber(This,pbVal) ) 

#define IISDB_EMM_GetTableIdExtension(This,pwVal)	\
    ( (This)->lpVtbl -> GetTableIdExtension(This,pwVal) ) 

#define IISDB_EMM_GetDataBytes(This,pwBufferLength,pbBuffer)	\
    ( (This)->lpVtbl -> GetDataBytes(This,pwBufferLength,pbBuffer) ) 

#define IISDB_EMM_GetSharedEmmMessage(This,pwLength,ppbMessage)	\
    ( (This)->lpVtbl -> GetSharedEmmMessage(This,pwLength,ppbMessage) ) 

#define IISDB_EMM_GetIndividualEmmMessage(This,pUnknown,pwLength,ppbMessage)	\
    ( (This)->lpVtbl -> GetIndividualEmmMessage(This,pUnknown,pwLength,ppbMessage) ) 

#define IISDB_EMM_GetVersionHash(This,pdwVersionHash)	\
    ( (This)->lpVtbl -> GetVersionHash(This,pdwVersionHash) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IISDB_EMM_INTERFACE_DEFINED__ */


#ifndef __IDvbServiceAttributeDescriptor_INTERFACE_DEFINED__
#define __IDvbServiceAttributeDescriptor_INTERFACE_DEFINED__

/* interface IDvbServiceAttributeDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvbServiceAttributeDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0F37BD92-D6A1-4854-B950-3A969D27F30E")
    IDvbServiceAttributeDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordServiceId( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordNumericSelectionFlag( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BOOL *pfVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordVisibleServiceFlag( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BOOL *pfVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbServiceAttributeDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbServiceAttributeDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbServiceAttributeDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbServiceAttributeDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbServiceAttributeDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbServiceAttributeDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IDvbServiceAttributeDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordServiceId )( 
            IDvbServiceAttributeDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordNumericSelectionFlag )( 
            IDvbServiceAttributeDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BOOL *pfVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordVisibleServiceFlag )( 
            IDvbServiceAttributeDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BOOL *pfVal);
        
        END_INTERFACE
    } IDvbServiceAttributeDescriptorVtbl;

    interface IDvbServiceAttributeDescriptor
    {
        CONST_VTBL struct IDvbServiceAttributeDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbServiceAttributeDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbServiceAttributeDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbServiceAttributeDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbServiceAttributeDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbServiceAttributeDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbServiceAttributeDescriptor_GetCountOfRecords(This,pbVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pbVal) ) 

#define IDvbServiceAttributeDescriptor_GetRecordServiceId(This,bRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordServiceId(This,bRecordIndex,pwVal) ) 

#define IDvbServiceAttributeDescriptor_GetRecordNumericSelectionFlag(This,bRecordIndex,pfVal)	\
    ( (This)->lpVtbl -> GetRecordNumericSelectionFlag(This,bRecordIndex,pfVal) ) 

#define IDvbServiceAttributeDescriptor_GetRecordVisibleServiceFlag(This,bRecordIndex,pfVal)	\
    ( (This)->lpVtbl -> GetRecordVisibleServiceFlag(This,bRecordIndex,pfVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbServiceAttributeDescriptor_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dvbsiparser_0000_0022 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_dvbsiparser_0000_0022_0001
    {	CRID_LOCATION_IN_DESCRIPTOR	= 0,
	CRID_LOCATION_IN_CIT	= 0x1,
	CRID_LOCATION_DVB_RESERVED1	= 0x2,
	CRID_LOCATION_DVB_RESERVED2	= 0x3
    } 	CRID_LOCATION;



extern RPC_IF_HANDLE __MIDL_itf_dvbsiparser_0000_0022_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dvbsiparser_0000_0022_v0_0_s_ifspec;

#ifndef __IDvbContentIdentifierDescriptor_INTERFACE_DEFINED__
#define __IDvbContentIdentifierDescriptor_INTERFACE_DEFINED__

/* interface IDvbContentIdentifierDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvbContentIdentifierDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("05E0C1EA-F661-4053-9FBF-D93B28359838")
    IDvbContentIdentifierDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordCrid( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbType,
            /* [out] */ BYTE *pbLocation,
            /* [out] */ BYTE *pbLength,
            /* [size_is][size_is][out] */ BYTE **ppbBytes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbContentIdentifierDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbContentIdentifierDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbContentIdentifierDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbContentIdentifierDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbContentIdentifierDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbContentIdentifierDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IDvbContentIdentifierDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordCrid )( 
            IDvbContentIdentifierDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbType,
            /* [out] */ BYTE *pbLocation,
            /* [out] */ BYTE *pbLength,
            /* [size_is][size_is][out] */ BYTE **ppbBytes);
        
        END_INTERFACE
    } IDvbContentIdentifierDescriptorVtbl;

    interface IDvbContentIdentifierDescriptor
    {
        CONST_VTBL struct IDvbContentIdentifierDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbContentIdentifierDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbContentIdentifierDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbContentIdentifierDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbContentIdentifierDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbContentIdentifierDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbContentIdentifierDescriptor_GetCountOfRecords(This,pbVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pbVal) ) 

#define IDvbContentIdentifierDescriptor_GetRecordCrid(This,bRecordIndex,pbType,pbLocation,pbLength,ppbBytes)	\
    ( (This)->lpVtbl -> GetRecordCrid(This,bRecordIndex,pbType,pbLocation,pbLength,ppbBytes) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbContentIdentifierDescriptor_INTERFACE_DEFINED__ */


#ifndef __IDvbDefaultAuthorityDescriptor_INTERFACE_DEFINED__
#define __IDvbDefaultAuthorityDescriptor_INTERFACE_DEFINED__

/* interface IDvbDefaultAuthorityDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvbDefaultAuthorityDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("05EC24D1-3A31-44e7-B408-67C60A352276")
    IDvbDefaultAuthorityDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultAuthority( 
            /* [out] */ BYTE *pbLength,
            /* [size_is][size_is][out] */ BYTE **ppbBytes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbDefaultAuthorityDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbDefaultAuthorityDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbDefaultAuthorityDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbDefaultAuthorityDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbDefaultAuthorityDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbDefaultAuthorityDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultAuthority )( 
            IDvbDefaultAuthorityDescriptor * This,
            /* [out] */ BYTE *pbLength,
            /* [size_is][size_is][out] */ BYTE **ppbBytes);
        
        END_INTERFACE
    } IDvbDefaultAuthorityDescriptorVtbl;

    interface IDvbDefaultAuthorityDescriptor
    {
        CONST_VTBL struct IDvbDefaultAuthorityDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbDefaultAuthorityDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbDefaultAuthorityDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbDefaultAuthorityDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbDefaultAuthorityDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbDefaultAuthorityDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbDefaultAuthorityDescriptor_GetDefaultAuthority(This,pbLength,ppbBytes)	\
    ( (This)->lpVtbl -> GetDefaultAuthority(This,pbLength,ppbBytes) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbDefaultAuthorityDescriptor_INTERFACE_DEFINED__ */


#ifndef __IDvbSatelliteDeliverySystemDescriptor_INTERFACE_DEFINED__
#define __IDvbSatelliteDeliverySystemDescriptor_INTERFACE_DEFINED__

/* interface IDvbSatelliteDeliverySystemDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvbSatelliteDeliverySystemDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("02F2225A-805B-4ec5-A9A6-F9B5913CD470")
    IDvbSatelliteDeliverySystemDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrequency( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOrbitalPosition( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWestEastFlag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPolarization( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetModulation( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSymbolRate( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFECInner( 
            /* [out] */ BYTE *pbVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbSatelliteDeliverySystemDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbSatelliteDeliverySystemDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbSatelliteDeliverySystemDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbSatelliteDeliverySystemDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbSatelliteDeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbSatelliteDeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrequency )( 
            IDvbSatelliteDeliverySystemDescriptor * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetOrbitalPosition )( 
            IDvbSatelliteDeliverySystemDescriptor * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetWestEastFlag )( 
            IDvbSatelliteDeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetPolarization )( 
            IDvbSatelliteDeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetModulation )( 
            IDvbSatelliteDeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSymbolRate )( 
            IDvbSatelliteDeliverySystemDescriptor * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetFECInner )( 
            IDvbSatelliteDeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        END_INTERFACE
    } IDvbSatelliteDeliverySystemDescriptorVtbl;

    interface IDvbSatelliteDeliverySystemDescriptor
    {
        CONST_VTBL struct IDvbSatelliteDeliverySystemDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbSatelliteDeliverySystemDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbSatelliteDeliverySystemDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbSatelliteDeliverySystemDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbSatelliteDeliverySystemDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbSatelliteDeliverySystemDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbSatelliteDeliverySystemDescriptor_GetFrequency(This,pdwVal)	\
    ( (This)->lpVtbl -> GetFrequency(This,pdwVal) ) 

#define IDvbSatelliteDeliverySystemDescriptor_GetOrbitalPosition(This,pwVal)	\
    ( (This)->lpVtbl -> GetOrbitalPosition(This,pwVal) ) 

#define IDvbSatelliteDeliverySystemDescriptor_GetWestEastFlag(This,pbVal)	\
    ( (This)->lpVtbl -> GetWestEastFlag(This,pbVal) ) 

#define IDvbSatelliteDeliverySystemDescriptor_GetPolarization(This,pbVal)	\
    ( (This)->lpVtbl -> GetPolarization(This,pbVal) ) 

#define IDvbSatelliteDeliverySystemDescriptor_GetModulation(This,pbVal)	\
    ( (This)->lpVtbl -> GetModulation(This,pbVal) ) 

#define IDvbSatelliteDeliverySystemDescriptor_GetSymbolRate(This,pdwVal)	\
    ( (This)->lpVtbl -> GetSymbolRate(This,pdwVal) ) 

#define IDvbSatelliteDeliverySystemDescriptor_GetFECInner(This,pbVal)	\
    ( (This)->lpVtbl -> GetFECInner(This,pbVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbSatelliteDeliverySystemDescriptor_INTERFACE_DEFINED__ */


#ifndef __IDvbCableDeliverySystemDescriptor_INTERFACE_DEFINED__
#define __IDvbCableDeliverySystemDescriptor_INTERFACE_DEFINED__

/* interface IDvbCableDeliverySystemDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvbCableDeliverySystemDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DFB98E36-9E1A-4862-9946-993A4E59017B")
    IDvbCableDeliverySystemDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrequency( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFECOuter( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetModulation( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSymbolRate( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFECInner( 
            /* [out] */ BYTE *pbVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbCableDeliverySystemDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbCableDeliverySystemDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbCableDeliverySystemDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbCableDeliverySystemDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbCableDeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbCableDeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrequency )( 
            IDvbCableDeliverySystemDescriptor * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetFECOuter )( 
            IDvbCableDeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetModulation )( 
            IDvbCableDeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSymbolRate )( 
            IDvbCableDeliverySystemDescriptor * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetFECInner )( 
            IDvbCableDeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        END_INTERFACE
    } IDvbCableDeliverySystemDescriptorVtbl;

    interface IDvbCableDeliverySystemDescriptor
    {
        CONST_VTBL struct IDvbCableDeliverySystemDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbCableDeliverySystemDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbCableDeliverySystemDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbCableDeliverySystemDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbCableDeliverySystemDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbCableDeliverySystemDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbCableDeliverySystemDescriptor_GetFrequency(This,pdwVal)	\
    ( (This)->lpVtbl -> GetFrequency(This,pdwVal) ) 

#define IDvbCableDeliverySystemDescriptor_GetFECOuter(This,pbVal)	\
    ( (This)->lpVtbl -> GetFECOuter(This,pbVal) ) 

#define IDvbCableDeliverySystemDescriptor_GetModulation(This,pbVal)	\
    ( (This)->lpVtbl -> GetModulation(This,pbVal) ) 

#define IDvbCableDeliverySystemDescriptor_GetSymbolRate(This,pdwVal)	\
    ( (This)->lpVtbl -> GetSymbolRate(This,pdwVal) ) 

#define IDvbCableDeliverySystemDescriptor_GetFECInner(This,pbVal)	\
    ( (This)->lpVtbl -> GetFECInner(This,pbVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbCableDeliverySystemDescriptor_INTERFACE_DEFINED__ */


#ifndef __IDvbTerrestrialDeliverySystemDescriptor_INTERFACE_DEFINED__
#define __IDvbTerrestrialDeliverySystemDescriptor_INTERFACE_DEFINED__

/* interface IDvbTerrestrialDeliverySystemDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvbTerrestrialDeliverySystemDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ED7E1B91-D12E-420c-B41D-A49D84FE1823")
    IDvbTerrestrialDeliverySystemDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCentreFrequency( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBandwidth( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConstellation( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHierarchyInformation( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodeRateHPStream( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodeRateLPStream( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuardInterval( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransmissionMode( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOtherFrequencyFlag( 
            /* [out] */ BYTE *pbVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbTerrestrialDeliverySystemDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbTerrestrialDeliverySystemDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbTerrestrialDeliverySystemDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbTerrestrialDeliverySystemDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbTerrestrialDeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbTerrestrialDeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCentreFrequency )( 
            IDvbTerrestrialDeliverySystemDescriptor * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetBandwidth )( 
            IDvbTerrestrialDeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetConstellation )( 
            IDvbTerrestrialDeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetHierarchyInformation )( 
            IDvbTerrestrialDeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodeRateHPStream )( 
            IDvbTerrestrialDeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodeRateLPStream )( 
            IDvbTerrestrialDeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuardInterval )( 
            IDvbTerrestrialDeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransmissionMode )( 
            IDvbTerrestrialDeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetOtherFrequencyFlag )( 
            IDvbTerrestrialDeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        END_INTERFACE
    } IDvbTerrestrialDeliverySystemDescriptorVtbl;

    interface IDvbTerrestrialDeliverySystemDescriptor
    {
        CONST_VTBL struct IDvbTerrestrialDeliverySystemDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbTerrestrialDeliverySystemDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbTerrestrialDeliverySystemDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbTerrestrialDeliverySystemDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbTerrestrialDeliverySystemDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbTerrestrialDeliverySystemDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbTerrestrialDeliverySystemDescriptor_GetCentreFrequency(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCentreFrequency(This,pdwVal) ) 

#define IDvbTerrestrialDeliverySystemDescriptor_GetBandwidth(This,pbVal)	\
    ( (This)->lpVtbl -> GetBandwidth(This,pbVal) ) 

#define IDvbTerrestrialDeliverySystemDescriptor_GetConstellation(This,pbVal)	\
    ( (This)->lpVtbl -> GetConstellation(This,pbVal) ) 

#define IDvbTerrestrialDeliverySystemDescriptor_GetHierarchyInformation(This,pbVal)	\
    ( (This)->lpVtbl -> GetHierarchyInformation(This,pbVal) ) 

#define IDvbTerrestrialDeliverySystemDescriptor_GetCodeRateHPStream(This,pbVal)	\
    ( (This)->lpVtbl -> GetCodeRateHPStream(This,pbVal) ) 

#define IDvbTerrestrialDeliverySystemDescriptor_GetCodeRateLPStream(This,pbVal)	\
    ( (This)->lpVtbl -> GetCodeRateLPStream(This,pbVal) ) 

#define IDvbTerrestrialDeliverySystemDescriptor_GetGuardInterval(This,pbVal)	\
    ( (This)->lpVtbl -> GetGuardInterval(This,pbVal) ) 

#define IDvbTerrestrialDeliverySystemDescriptor_GetTransmissionMode(This,pbVal)	\
    ( (This)->lpVtbl -> GetTransmissionMode(This,pbVal) ) 

#define IDvbTerrestrialDeliverySystemDescriptor_GetOtherFrequencyFlag(This,pbVal)	\
    ( (This)->lpVtbl -> GetOtherFrequencyFlag(This,pbVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbTerrestrialDeliverySystemDescriptor_INTERFACE_DEFINED__ */


#ifndef __IDvbTerrestrial2DeliverySystemDescriptor_INTERFACE_DEFINED__
#define __IDvbTerrestrial2DeliverySystemDescriptor_INTERFACE_DEFINED__

/* interface IDvbTerrestrial2DeliverySystemDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvbTerrestrial2DeliverySystemDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("20EE9BE9-CD57-49ab-8F6E-1D07AEB8E482")
    IDvbTerrestrial2DeliverySystemDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTagExtension( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCentreFrequency( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPLPId( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetT2SystemId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMultipleInputMode( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBandwidth( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuardInterval( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransmissionMode( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCellId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOtherFrequencyFlag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTFSFlag( 
            /* [out] */ BYTE *pbVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbTerrestrial2DeliverySystemDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbTerrestrial2DeliverySystemDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbTerrestrial2DeliverySystemDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbTerrestrial2DeliverySystemDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbTerrestrial2DeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbTerrestrial2DeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTagExtension )( 
            IDvbTerrestrial2DeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCentreFrequency )( 
            IDvbTerrestrial2DeliverySystemDescriptor * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetPLPId )( 
            IDvbTerrestrial2DeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetT2SystemId )( 
            IDvbTerrestrial2DeliverySystemDescriptor * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetMultipleInputMode )( 
            IDvbTerrestrial2DeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetBandwidth )( 
            IDvbTerrestrial2DeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuardInterval )( 
            IDvbTerrestrial2DeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransmissionMode )( 
            IDvbTerrestrial2DeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCellId )( 
            IDvbTerrestrial2DeliverySystemDescriptor * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetOtherFrequencyFlag )( 
            IDvbTerrestrial2DeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTFSFlag )( 
            IDvbTerrestrial2DeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        END_INTERFACE
    } IDvbTerrestrial2DeliverySystemDescriptorVtbl;

    interface IDvbTerrestrial2DeliverySystemDescriptor
    {
        CONST_VTBL struct IDvbTerrestrial2DeliverySystemDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbTerrestrial2DeliverySystemDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbTerrestrial2DeliverySystemDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbTerrestrial2DeliverySystemDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbTerrestrial2DeliverySystemDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbTerrestrial2DeliverySystemDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbTerrestrial2DeliverySystemDescriptor_GetTagExtension(This,pbVal)	\
    ( (This)->lpVtbl -> GetTagExtension(This,pbVal) ) 

#define IDvbTerrestrial2DeliverySystemDescriptor_GetCentreFrequency(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCentreFrequency(This,pdwVal) ) 

#define IDvbTerrestrial2DeliverySystemDescriptor_GetPLPId(This,pbVal)	\
    ( (This)->lpVtbl -> GetPLPId(This,pbVal) ) 

#define IDvbTerrestrial2DeliverySystemDescriptor_GetT2SystemId(This,pwVal)	\
    ( (This)->lpVtbl -> GetT2SystemId(This,pwVal) ) 

#define IDvbTerrestrial2DeliverySystemDescriptor_GetMultipleInputMode(This,pbVal)	\
    ( (This)->lpVtbl -> GetMultipleInputMode(This,pbVal) ) 

#define IDvbTerrestrial2DeliverySystemDescriptor_GetBandwidth(This,pbVal)	\
    ( (This)->lpVtbl -> GetBandwidth(This,pbVal) ) 

#define IDvbTerrestrial2DeliverySystemDescriptor_GetGuardInterval(This,pbVal)	\
    ( (This)->lpVtbl -> GetGuardInterval(This,pbVal) ) 

#define IDvbTerrestrial2DeliverySystemDescriptor_GetTransmissionMode(This,pbVal)	\
    ( (This)->lpVtbl -> GetTransmissionMode(This,pbVal) ) 

#define IDvbTerrestrial2DeliverySystemDescriptor_GetCellId(This,pwVal)	\
    ( (This)->lpVtbl -> GetCellId(This,pwVal) ) 

#define IDvbTerrestrial2DeliverySystemDescriptor_GetOtherFrequencyFlag(This,pbVal)	\
    ( (This)->lpVtbl -> GetOtherFrequencyFlag(This,pbVal) ) 

#define IDvbTerrestrial2DeliverySystemDescriptor_GetTFSFlag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTFSFlag(This,pbVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbTerrestrial2DeliverySystemDescriptor_INTERFACE_DEFINED__ */


#ifndef __IDvbFrequencyListDescriptor_INTERFACE_DEFINED__
#define __IDvbFrequencyListDescriptor_INTERFACE_DEFINED__

/* interface IDvbFrequencyListDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvbFrequencyListDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1CADB613-E1DD-4512-AFA8-BB7A007EF8B1")
    IDvbFrequencyListDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodingType( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordCentreFrequency( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ DWORD *pdwVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbFrequencyListDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbFrequencyListDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbFrequencyListDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbFrequencyListDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbFrequencyListDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbFrequencyListDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodingType )( 
            IDvbFrequencyListDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IDvbFrequencyListDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordCentreFrequency )( 
            IDvbFrequencyListDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ DWORD *pdwVal);
        
        END_INTERFACE
    } IDvbFrequencyListDescriptorVtbl;

    interface IDvbFrequencyListDescriptor
    {
        CONST_VTBL struct IDvbFrequencyListDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbFrequencyListDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbFrequencyListDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbFrequencyListDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbFrequencyListDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbFrequencyListDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbFrequencyListDescriptor_GetCodingType(This,pbVal)	\
    ( (This)->lpVtbl -> GetCodingType(This,pbVal) ) 

#define IDvbFrequencyListDescriptor_GetCountOfRecords(This,pbVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pbVal) ) 

#define IDvbFrequencyListDescriptor_GetRecordCentreFrequency(This,bRecordIndex,pdwVal)	\
    ( (This)->lpVtbl -> GetRecordCentreFrequency(This,bRecordIndex,pdwVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbFrequencyListDescriptor_INTERFACE_DEFINED__ */


#ifndef __IDvbPrivateDataSpecifierDescriptor_INTERFACE_DEFINED__
#define __IDvbPrivateDataSpecifierDescriptor_INTERFACE_DEFINED__

/* interface IDvbPrivateDataSpecifierDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvbPrivateDataSpecifierDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5660A019-E75A-4b82-9B4C-ED2256D165A2")
    IDvbPrivateDataSpecifierDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrivateDataSpecifier( 
            /* [out] */ DWORD *pdwVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbPrivateDataSpecifierDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbPrivateDataSpecifierDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbPrivateDataSpecifierDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbPrivateDataSpecifierDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbPrivateDataSpecifierDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbPrivateDataSpecifierDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateDataSpecifier )( 
            IDvbPrivateDataSpecifierDescriptor * This,
            /* [out] */ DWORD *pdwVal);
        
        END_INTERFACE
    } IDvbPrivateDataSpecifierDescriptorVtbl;

    interface IDvbPrivateDataSpecifierDescriptor
    {
        CONST_VTBL struct IDvbPrivateDataSpecifierDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbPrivateDataSpecifierDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbPrivateDataSpecifierDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbPrivateDataSpecifierDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbPrivateDataSpecifierDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbPrivateDataSpecifierDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbPrivateDataSpecifierDescriptor_GetPrivateDataSpecifier(This,pdwVal)	\
    ( (This)->lpVtbl -> GetPrivateDataSpecifier(This,pdwVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbPrivateDataSpecifierDescriptor_INTERFACE_DEFINED__ */


#ifndef __IDvbLogicalChannelDescriptor_INTERFACE_DEFINED__
#define __IDvbLogicalChannelDescriptor_INTERFACE_DEFINED__

/* interface IDvbLogicalChannelDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvbLogicalChannelDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CF1EDAFF-3FFD-4cf7-8201-35756ACBF85F")
    IDvbLogicalChannelDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordServiceId( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordLogicalChannelNumber( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbLogicalChannelDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbLogicalChannelDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbLogicalChannelDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbLogicalChannelDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbLogicalChannelDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbLogicalChannelDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IDvbLogicalChannelDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordServiceId )( 
            IDvbLogicalChannelDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordLogicalChannelNumber )( 
            IDvbLogicalChannelDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwVal);
        
        END_INTERFACE
    } IDvbLogicalChannelDescriptorVtbl;

    interface IDvbLogicalChannelDescriptor
    {
        CONST_VTBL struct IDvbLogicalChannelDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbLogicalChannelDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbLogicalChannelDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbLogicalChannelDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbLogicalChannelDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbLogicalChannelDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbLogicalChannelDescriptor_GetCountOfRecords(This,pbVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pbVal) ) 

#define IDvbLogicalChannelDescriptor_GetRecordServiceId(This,bRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordServiceId(This,bRecordIndex,pwVal) ) 

#define IDvbLogicalChannelDescriptor_GetRecordLogicalChannelNumber(This,bRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordLogicalChannelNumber(This,bRecordIndex,pwVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbLogicalChannelDescriptor_INTERFACE_DEFINED__ */


#ifndef __IDvbLogicalChannelDescriptor2_INTERFACE_DEFINED__
#define __IDvbLogicalChannelDescriptor2_INTERFACE_DEFINED__

/* interface IDvbLogicalChannelDescriptor2 */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvbLogicalChannelDescriptor2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43ACA974-4BE8-4b98-BC17-9EAFD788B1D7")
    IDvbLogicalChannelDescriptor2 : public IDvbLogicalChannelDescriptor
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRecordLogicalChannelAndVisibility( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbLogicalChannelDescriptor2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbLogicalChannelDescriptor2 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbLogicalChannelDescriptor2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbLogicalChannelDescriptor2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbLogicalChannelDescriptor2 * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbLogicalChannelDescriptor2 * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IDvbLogicalChannelDescriptor2 * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordServiceId )( 
            IDvbLogicalChannelDescriptor2 * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordLogicalChannelNumber )( 
            IDvbLogicalChannelDescriptor2 * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordLogicalChannelAndVisibility )( 
            IDvbLogicalChannelDescriptor2 * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwVal);
        
        END_INTERFACE
    } IDvbLogicalChannelDescriptor2Vtbl;

    interface IDvbLogicalChannelDescriptor2
    {
        CONST_VTBL struct IDvbLogicalChannelDescriptor2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbLogicalChannelDescriptor2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbLogicalChannelDescriptor2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbLogicalChannelDescriptor2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbLogicalChannelDescriptor2_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbLogicalChannelDescriptor2_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbLogicalChannelDescriptor2_GetCountOfRecords(This,pbVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pbVal) ) 

#define IDvbLogicalChannelDescriptor2_GetRecordServiceId(This,bRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordServiceId(This,bRecordIndex,pwVal) ) 

#define IDvbLogicalChannelDescriptor2_GetRecordLogicalChannelNumber(This,bRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordLogicalChannelNumber(This,bRecordIndex,pwVal) ) 


#define IDvbLogicalChannelDescriptor2_GetRecordLogicalChannelAndVisibility(This,bRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordLogicalChannelAndVisibility(This,bRecordIndex,pwVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbLogicalChannelDescriptor2_INTERFACE_DEFINED__ */


#ifndef __IDvbLogicalChannel2Descriptor_INTERFACE_DEFINED__
#define __IDvbLogicalChannel2Descriptor_INTERFACE_DEFINED__

/* interface IDvbLogicalChannel2Descriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvbLogicalChannel2Descriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F69C3747-8A30-4980-998C-01FE7F0BA35A")
    IDvbLogicalChannel2Descriptor : public IDvbLogicalChannelDescriptor2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCountOfLists( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetListId( 
            /* [in] */ BYTE bListIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetListNameW( 
            /* [in] */ BYTE bListIndex,
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetListCountryCode( 
            /* [in] */ BYTE bListIndex,
            /* [annotation][out] */ 
            __out_ecount(4)  char *pszCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetListCountOfRecords( 
            /* [in] */ BYTE bChannelListIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetListRecordServiceId( 
            /* [in] */ BYTE bListIndex,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetListRecordLogicalChannelNumber( 
            /* [in] */ BYTE bListIndex,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetListRecordLogicalChannelAndVisibility( 
            /* [in] */ BYTE bListIndex,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbLogicalChannel2DescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbLogicalChannel2Descriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbLogicalChannel2Descriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbLogicalChannel2Descriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbLogicalChannel2Descriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbLogicalChannel2Descriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IDvbLogicalChannel2Descriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordServiceId )( 
            IDvbLogicalChannel2Descriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordLogicalChannelNumber )( 
            IDvbLogicalChannel2Descriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordLogicalChannelAndVisibility )( 
            IDvbLogicalChannel2Descriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfLists )( 
            IDvbLogicalChannel2Descriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetListId )( 
            IDvbLogicalChannel2Descriptor * This,
            /* [in] */ BYTE bListIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetListNameW )( 
            IDvbLogicalChannel2Descriptor * This,
            /* [in] */ BYTE bListIndex,
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetListCountryCode )( 
            IDvbLogicalChannel2Descriptor * This,
            /* [in] */ BYTE bListIndex,
            /* [annotation][out] */ 
            __out_ecount(4)  char *pszCode);
        
        HRESULT ( STDMETHODCALLTYPE *GetListCountOfRecords )( 
            IDvbLogicalChannel2Descriptor * This,
            /* [in] */ BYTE bChannelListIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetListRecordServiceId )( 
            IDvbLogicalChannel2Descriptor * This,
            /* [in] */ BYTE bListIndex,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetListRecordLogicalChannelNumber )( 
            IDvbLogicalChannel2Descriptor * This,
            /* [in] */ BYTE bListIndex,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetListRecordLogicalChannelAndVisibility )( 
            IDvbLogicalChannel2Descriptor * This,
            /* [in] */ BYTE bListIndex,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwVal);
        
        END_INTERFACE
    } IDvbLogicalChannel2DescriptorVtbl;

    interface IDvbLogicalChannel2Descriptor
    {
        CONST_VTBL struct IDvbLogicalChannel2DescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbLogicalChannel2Descriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbLogicalChannel2Descriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbLogicalChannel2Descriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbLogicalChannel2Descriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbLogicalChannel2Descriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbLogicalChannel2Descriptor_GetCountOfRecords(This,pbVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pbVal) ) 

#define IDvbLogicalChannel2Descriptor_GetRecordServiceId(This,bRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordServiceId(This,bRecordIndex,pwVal) ) 

#define IDvbLogicalChannel2Descriptor_GetRecordLogicalChannelNumber(This,bRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordLogicalChannelNumber(This,bRecordIndex,pwVal) ) 


#define IDvbLogicalChannel2Descriptor_GetRecordLogicalChannelAndVisibility(This,bRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordLogicalChannelAndVisibility(This,bRecordIndex,pwVal) ) 


#define IDvbLogicalChannel2Descriptor_GetCountOfLists(This,pbVal)	\
    ( (This)->lpVtbl -> GetCountOfLists(This,pbVal) ) 

#define IDvbLogicalChannel2Descriptor_GetListId(This,bListIndex,pbVal)	\
    ( (This)->lpVtbl -> GetListId(This,bListIndex,pbVal) ) 

#define IDvbLogicalChannel2Descriptor_GetListNameW(This,bListIndex,convMode,pbstrName)	\
    ( (This)->lpVtbl -> GetListNameW(This,bListIndex,convMode,pbstrName) ) 

#define IDvbLogicalChannel2Descriptor_GetListCountryCode(This,bListIndex,pszCode)	\
    ( (This)->lpVtbl -> GetListCountryCode(This,bListIndex,pszCode) ) 

#define IDvbLogicalChannel2Descriptor_GetListCountOfRecords(This,bChannelListIndex,pbVal)	\
    ( (This)->lpVtbl -> GetListCountOfRecords(This,bChannelListIndex,pbVal) ) 

#define IDvbLogicalChannel2Descriptor_GetListRecordServiceId(This,bListIndex,bRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetListRecordServiceId(This,bListIndex,bRecordIndex,pwVal) ) 

#define IDvbLogicalChannel2Descriptor_GetListRecordLogicalChannelNumber(This,bListIndex,bRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetListRecordLogicalChannelNumber(This,bListIndex,bRecordIndex,pwVal) ) 

#define IDvbLogicalChannel2Descriptor_GetListRecordLogicalChannelAndVisibility(This,bListIndex,bRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetListRecordLogicalChannelAndVisibility(This,bListIndex,bRecordIndex,pwVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbLogicalChannel2Descriptor_INTERFACE_DEFINED__ */


#ifndef __IDvbHDSimulcastLogicalChannelDescriptor_INTERFACE_DEFINED__
#define __IDvbHDSimulcastLogicalChannelDescriptor_INTERFACE_DEFINED__

/* interface IDvbHDSimulcastLogicalChannelDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvbHDSimulcastLogicalChannelDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1EA8B738-A307-4680-9E26-D0A908C824F4")
    IDvbHDSimulcastLogicalChannelDescriptor : public IDvbLogicalChannelDescriptor2
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDvbHDSimulcastLogicalChannelDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbHDSimulcastLogicalChannelDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbHDSimulcastLogicalChannelDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbHDSimulcastLogicalChannelDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbHDSimulcastLogicalChannelDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbHDSimulcastLogicalChannelDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IDvbHDSimulcastLogicalChannelDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordServiceId )( 
            IDvbHDSimulcastLogicalChannelDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordLogicalChannelNumber )( 
            IDvbHDSimulcastLogicalChannelDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordLogicalChannelAndVisibility )( 
            IDvbHDSimulcastLogicalChannelDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwVal);
        
        END_INTERFACE
    } IDvbHDSimulcastLogicalChannelDescriptorVtbl;

    interface IDvbHDSimulcastLogicalChannelDescriptor
    {
        CONST_VTBL struct IDvbHDSimulcastLogicalChannelDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbHDSimulcastLogicalChannelDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbHDSimulcastLogicalChannelDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbHDSimulcastLogicalChannelDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbHDSimulcastLogicalChannelDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbHDSimulcastLogicalChannelDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbHDSimulcastLogicalChannelDescriptor_GetCountOfRecords(This,pbVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pbVal) ) 

#define IDvbHDSimulcastLogicalChannelDescriptor_GetRecordServiceId(This,bRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordServiceId(This,bRecordIndex,pwVal) ) 

#define IDvbHDSimulcastLogicalChannelDescriptor_GetRecordLogicalChannelNumber(This,bRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordLogicalChannelNumber(This,bRecordIndex,pwVal) ) 


#define IDvbHDSimulcastLogicalChannelDescriptor_GetRecordLogicalChannelAndVisibility(This,bRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordLogicalChannelAndVisibility(This,bRecordIndex,pwVal) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbHDSimulcastLogicalChannelDescriptor_INTERFACE_DEFINED__ */


#ifndef __IDvbDataBroadcastIDDescriptor_INTERFACE_DEFINED__
#define __IDvbDataBroadcastIDDescriptor_INTERFACE_DEFINED__

/* interface IDvbDataBroadcastIDDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvbDataBroadcastIDDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5F26F518-65C8-4048-91F2-9290F59F7B90")
    IDvbDataBroadcastIDDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDataBroadcastID( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIDSelectorBytes( 
            /* [out][in] */ BYTE *pbLen,
            /* [out] */ BYTE *pbVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbDataBroadcastIDDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbDataBroadcastIDDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbDataBroadcastIDDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbDataBroadcastIDDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbDataBroadcastIDDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbDataBroadcastIDDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetDataBroadcastID )( 
            IDvbDataBroadcastIDDescriptor * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDSelectorBytes )( 
            IDvbDataBroadcastIDDescriptor * This,
            /* [out][in] */ BYTE *pbLen,
            /* [out] */ BYTE *pbVal);
        
        END_INTERFACE
    } IDvbDataBroadcastIDDescriptorVtbl;

    interface IDvbDataBroadcastIDDescriptor
    {
        CONST_VTBL struct IDvbDataBroadcastIDDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbDataBroadcastIDDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbDataBroadcastIDDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbDataBroadcastIDDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbDataBroadcastIDDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbDataBroadcastIDDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbDataBroadcastIDDescriptor_GetDataBroadcastID(This,pwVal)	\
    ( (This)->lpVtbl -> GetDataBroadcastID(This,pwVal) ) 

#define IDvbDataBroadcastIDDescriptor_GetIDSelectorBytes(This,pbLen,pbVal)	\
    ( (This)->lpVtbl -> GetIDSelectorBytes(This,pbLen,pbVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbDataBroadcastIDDescriptor_INTERFACE_DEFINED__ */


#ifndef __IDvbDataBroadcastDescriptor_INTERFACE_DEFINED__
#define __IDvbDataBroadcastDescriptor_INTERFACE_DEFINED__

/* interface IDvbDataBroadcastDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvbDataBroadcastDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D1EBC1D6-8B60-4c20-9CAF-E59382E7C400")
    IDvbDataBroadcastDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDataBroadcastID( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetComponentTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelectorLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelectorBytes( 
            /* [out][in] */ BYTE *pbLen,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLangID( 
            /* [out] */ ULONG *pulVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTextLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetText( 
            /* [out][in] */ BYTE *pbLen,
            /* [out] */ BYTE *pbVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbDataBroadcastDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbDataBroadcastDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbDataBroadcastDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbDataBroadcastDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbDataBroadcastDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbDataBroadcastDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetDataBroadcastID )( 
            IDvbDataBroadcastDescriptor * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetComponentTag )( 
            IDvbDataBroadcastDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelectorLength )( 
            IDvbDataBroadcastDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelectorBytes )( 
            IDvbDataBroadcastDescriptor * This,
            /* [out][in] */ BYTE *pbLen,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLangID )( 
            IDvbDataBroadcastDescriptor * This,
            /* [out] */ ULONG *pulVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTextLength )( 
            IDvbDataBroadcastDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            IDvbDataBroadcastDescriptor * This,
            /* [out][in] */ BYTE *pbLen,
            /* [out] */ BYTE *pbVal);
        
        END_INTERFACE
    } IDvbDataBroadcastDescriptorVtbl;

    interface IDvbDataBroadcastDescriptor
    {
        CONST_VTBL struct IDvbDataBroadcastDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbDataBroadcastDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbDataBroadcastDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbDataBroadcastDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbDataBroadcastDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbDataBroadcastDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbDataBroadcastDescriptor_GetDataBroadcastID(This,pwVal)	\
    ( (This)->lpVtbl -> GetDataBroadcastID(This,pwVal) ) 

#define IDvbDataBroadcastDescriptor_GetComponentTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetComponentTag(This,pbVal) ) 

#define IDvbDataBroadcastDescriptor_GetSelectorLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetSelectorLength(This,pbVal) ) 

#define IDvbDataBroadcastDescriptor_GetSelectorBytes(This,pbLen,pbVal)	\
    ( (This)->lpVtbl -> GetSelectorBytes(This,pbLen,pbVal) ) 

#define IDvbDataBroadcastDescriptor_GetLangID(This,pulVal)	\
    ( (This)->lpVtbl -> GetLangID(This,pulVal) ) 

#define IDvbDataBroadcastDescriptor_GetTextLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetTextLength(This,pbVal) ) 

#define IDvbDataBroadcastDescriptor_GetText(This,pbLen,pbVal)	\
    ( (This)->lpVtbl -> GetText(This,pbLen,pbVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbDataBroadcastDescriptor_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dvbsiparser_0000_0036 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_dvbsiparser_0000_0036_0001
    {	DESC_LINKAGE_RESERVED0	= 0,
	DESC_LINKAGE_INFORMATION	= ( DESC_LINKAGE_RESERVED0 + 1 ) ,
	DESC_LINKAGE_EPG	= ( DESC_LINKAGE_INFORMATION + 1 ) ,
	DESC_LINKAGE_CA_REPLACEMENT	= ( DESC_LINKAGE_EPG + 1 ) ,
	DESC_LINKAGE_COMPLETE_NET_BOUQUET_SI	= ( DESC_LINKAGE_CA_REPLACEMENT + 1 ) ,
	DESC_LINKAGE_REPLACEMENT	= ( DESC_LINKAGE_COMPLETE_NET_BOUQUET_SI + 1 ) ,
	DESC_LINKAGE_DATA	= ( DESC_LINKAGE_REPLACEMENT + 1 ) ,
	DESC_LINKAGE_RESERVED1	= 0x7,
	DESC_LINKAGE_USER	= 0x8,
	DESC_LINKAGE_RESERVED2	= 0xff
    } 	DESC_LINKAGE_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_dvbsiparser_0000_0036_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dvbsiparser_0000_0036_v0_0_s_ifspec;

#ifndef __IDvbLinkageDescriptor_INTERFACE_DEFINED__
#define __IDvbLinkageDescriptor_INTERFACE_DEFINED__

/* interface IDvbLinkageDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvbLinkageDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1CDF8B31-994A-46fc-ACFD-6A6BE8934DD5")
    IDvbLinkageDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTSId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetONId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServiceId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLinkageType( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrivateDataLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrivateData( 
            /* [out][in] */ BYTE *pbLen,
            /* [out] */ BYTE *pbData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbLinkageDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbLinkageDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbLinkageDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbLinkageDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbLinkageDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbLinkageDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTSId )( 
            IDvbLinkageDescriptor * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetONId )( 
            IDvbLinkageDescriptor * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceId )( 
            IDvbLinkageDescriptor * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLinkageType )( 
            IDvbLinkageDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateDataLength )( 
            IDvbLinkageDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
            IDvbLinkageDescriptor * This,
            /* [out][in] */ BYTE *pbLen,
            /* [out] */ BYTE *pbData);
        
        END_INTERFACE
    } IDvbLinkageDescriptorVtbl;

    interface IDvbLinkageDescriptor
    {
        CONST_VTBL struct IDvbLinkageDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbLinkageDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbLinkageDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbLinkageDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbLinkageDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbLinkageDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbLinkageDescriptor_GetTSId(This,pwVal)	\
    ( (This)->lpVtbl -> GetTSId(This,pwVal) ) 

#define IDvbLinkageDescriptor_GetONId(This,pwVal)	\
    ( (This)->lpVtbl -> GetONId(This,pwVal) ) 

#define IDvbLinkageDescriptor_GetServiceId(This,pwVal)	\
    ( (This)->lpVtbl -> GetServiceId(This,pwVal) ) 

#define IDvbLinkageDescriptor_GetLinkageType(This,pbVal)	\
    ( (This)->lpVtbl -> GetLinkageType(This,pbVal) ) 

#define IDvbLinkageDescriptor_GetPrivateDataLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetPrivateDataLength(This,pbVal) ) 

#define IDvbLinkageDescriptor_GetPrivateData(This,pbLen,pbData)	\
    ( (This)->lpVtbl -> GetPrivateData(This,pbLen,pbData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbLinkageDescriptor_INTERFACE_DEFINED__ */


#ifndef __IDvbTeletextDescriptor_INTERFACE_DEFINED__
#define __IDvbTeletextDescriptor_INTERFACE_DEFINED__

/* interface IDvbTeletextDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvbTeletextDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9CD29D47-69C6-4f92-98A9-210AF1B7303A")
    IDvbTeletextDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordLangId( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ ULONG *pulVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordTeletextType( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordMagazineNumber( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordPageNumber( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbTeletextDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbTeletextDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbTeletextDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbTeletextDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbTeletextDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbTeletextDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IDvbTeletextDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordLangId )( 
            IDvbTeletextDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ ULONG *pulVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordTeletextType )( 
            IDvbTeletextDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordMagazineNumber )( 
            IDvbTeletextDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordPageNumber )( 
            IDvbTeletextDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        END_INTERFACE
    } IDvbTeletextDescriptorVtbl;

    interface IDvbTeletextDescriptor
    {
        CONST_VTBL struct IDvbTeletextDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbTeletextDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbTeletextDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbTeletextDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbTeletextDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbTeletextDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbTeletextDescriptor_GetCountOfRecords(This,pbVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pbVal) ) 

#define IDvbTeletextDescriptor_GetRecordLangId(This,bRecordIndex,pulVal)	\
    ( (This)->lpVtbl -> GetRecordLangId(This,bRecordIndex,pulVal) ) 

#define IDvbTeletextDescriptor_GetRecordTeletextType(This,bRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordTeletextType(This,bRecordIndex,pbVal) ) 

#define IDvbTeletextDescriptor_GetRecordMagazineNumber(This,bRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordMagazineNumber(This,bRecordIndex,pbVal) ) 

#define IDvbTeletextDescriptor_GetRecordPageNumber(This,bRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordPageNumber(This,bRecordIndex,pbVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbTeletextDescriptor_INTERFACE_DEFINED__ */


#ifndef __IDvbSubtitlingDescriptor_INTERFACE_DEFINED__
#define __IDvbSubtitlingDescriptor_INTERFACE_DEFINED__

/* interface IDvbSubtitlingDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvbSubtitlingDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9B25FE1D-FA23-4e50-9784-6DF8B26F8A49")
    IDvbSubtitlingDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordLangId( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ ULONG *pulVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordSubtitlingType( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordCompositionPageID( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordAncillaryPageID( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbSubtitlingDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbSubtitlingDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbSubtitlingDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbSubtitlingDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbSubtitlingDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbSubtitlingDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IDvbSubtitlingDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordLangId )( 
            IDvbSubtitlingDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ ULONG *pulVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordSubtitlingType )( 
            IDvbSubtitlingDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordCompositionPageID )( 
            IDvbSubtitlingDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordAncillaryPageID )( 
            IDvbSubtitlingDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwVal);
        
        END_INTERFACE
    } IDvbSubtitlingDescriptorVtbl;

    interface IDvbSubtitlingDescriptor
    {
        CONST_VTBL struct IDvbSubtitlingDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbSubtitlingDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbSubtitlingDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbSubtitlingDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbSubtitlingDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbSubtitlingDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbSubtitlingDescriptor_GetCountOfRecords(This,pbVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pbVal) ) 

#define IDvbSubtitlingDescriptor_GetRecordLangId(This,bRecordIndex,pulVal)	\
    ( (This)->lpVtbl -> GetRecordLangId(This,bRecordIndex,pulVal) ) 

#define IDvbSubtitlingDescriptor_GetRecordSubtitlingType(This,bRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordSubtitlingType(This,bRecordIndex,pbVal) ) 

#define IDvbSubtitlingDescriptor_GetRecordCompositionPageID(This,bRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordCompositionPageID(This,bRecordIndex,pwVal) ) 

#define IDvbSubtitlingDescriptor_GetRecordAncillaryPageID(This,bRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordAncillaryPageID(This,bRecordIndex,pwVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbSubtitlingDescriptor_INTERFACE_DEFINED__ */


#ifndef __IDvbServiceDescriptor_INTERFACE_DEFINED__
#define __IDvbServiceDescriptor_INTERFACE_DEFINED__

/* interface IDvbServiceDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvbServiceDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F9C7FBCF-E2D6-464d-B32D-2EF526E49290")
    IDvbServiceDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServiceType( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServiceProviderName( 
            /* [annotation][out] */ 
            __deref_out  char **pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServiceProviderNameW( 
            /* [annotation][out] */ 
            __deref_out  BSTR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServiceName( 
            /* [annotation][out] */ 
            __deref_out  char **pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcessedServiceName( 
            /* [out] */ BSTR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServiceNameEmphasized( 
            /* [out] */ BSTR *pbstrName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbServiceDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbServiceDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbServiceDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbServiceDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbServiceDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbServiceDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceType )( 
            IDvbServiceDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceProviderName )( 
            IDvbServiceDescriptor * This,
            /* [annotation][out] */ 
            __deref_out  char **pszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceProviderNameW )( 
            IDvbServiceDescriptor * This,
            /* [annotation][out] */ 
            __deref_out  BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceName )( 
            IDvbServiceDescriptor * This,
            /* [annotation][out] */ 
            __deref_out  char **pszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcessedServiceName )( 
            IDvbServiceDescriptor * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceNameEmphasized )( 
            IDvbServiceDescriptor * This,
            /* [out] */ BSTR *pbstrName);
        
        END_INTERFACE
    } IDvbServiceDescriptorVtbl;

    interface IDvbServiceDescriptor
    {
        CONST_VTBL struct IDvbServiceDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbServiceDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbServiceDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbServiceDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbServiceDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbServiceDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbServiceDescriptor_GetServiceType(This,pbVal)	\
    ( (This)->lpVtbl -> GetServiceType(This,pbVal) ) 

#define IDvbServiceDescriptor_GetServiceProviderName(This,pszName)	\
    ( (This)->lpVtbl -> GetServiceProviderName(This,pszName) ) 

#define IDvbServiceDescriptor_GetServiceProviderNameW(This,pbstrName)	\
    ( (This)->lpVtbl -> GetServiceProviderNameW(This,pbstrName) ) 

#define IDvbServiceDescriptor_GetServiceName(This,pszName)	\
    ( (This)->lpVtbl -> GetServiceName(This,pszName) ) 

#define IDvbServiceDescriptor_GetProcessedServiceName(This,pbstrName)	\
    ( (This)->lpVtbl -> GetProcessedServiceName(This,pbstrName) ) 

#define IDvbServiceDescriptor_GetServiceNameEmphasized(This,pbstrName)	\
    ( (This)->lpVtbl -> GetServiceNameEmphasized(This,pbstrName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbServiceDescriptor_INTERFACE_DEFINED__ */


#ifndef __IDvbServiceDescriptor2_INTERFACE_DEFINED__
#define __IDvbServiceDescriptor2_INTERFACE_DEFINED__

/* interface IDvbServiceDescriptor2 */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvbServiceDescriptor2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D6C76506-85AB-487C-9B2B-36416511E4A2")
    IDvbServiceDescriptor2 : public IDvbServiceDescriptor
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetServiceProviderNameW( 
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServiceNameW( 
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbServiceDescriptor2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbServiceDescriptor2 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbServiceDescriptor2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbServiceDescriptor2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbServiceDescriptor2 * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbServiceDescriptor2 * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceType )( 
            IDvbServiceDescriptor2 * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceProviderName )( 
            IDvbServiceDescriptor2 * This,
            /* [annotation][out] */ 
            __deref_out  char **pszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceProviderNameW )( 
            IDvbServiceDescriptor2 * This,
            /* [annotation][out] */ 
            __deref_out  BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceName )( 
            IDvbServiceDescriptor2 * This,
            /* [annotation][out] */ 
            __deref_out  char **pszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcessedServiceName )( 
            IDvbServiceDescriptor2 * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceNameEmphasized )( 
            IDvbServiceDescriptor2 * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceProviderNameW )( 
            IDvbServiceDescriptor2 * This,
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceNameW )( 
            IDvbServiceDescriptor2 * This,
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrName);
        
        END_INTERFACE
    } IDvbServiceDescriptor2Vtbl;

    interface IDvbServiceDescriptor2
    {
        CONST_VTBL struct IDvbServiceDescriptor2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbServiceDescriptor2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbServiceDescriptor2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbServiceDescriptor2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbServiceDescriptor2_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbServiceDescriptor2_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbServiceDescriptor2_GetServiceType(This,pbVal)	\
    ( (This)->lpVtbl -> GetServiceType(This,pbVal) ) 

#define IDvbServiceDescriptor2_GetServiceProviderName(This,pszName)	\
    ( (This)->lpVtbl -> GetServiceProviderName(This,pszName) ) 

#define IDvbServiceDescriptor2_GetServiceProviderNameW(This,pbstrName)	\
    ( (This)->lpVtbl -> GetServiceProviderNameW(This,pbstrName) ) 

#define IDvbServiceDescriptor2_GetServiceName(This,pszName)	\
    ( (This)->lpVtbl -> GetServiceName(This,pszName) ) 

#define IDvbServiceDescriptor2_GetProcessedServiceName(This,pbstrName)	\
    ( (This)->lpVtbl -> GetProcessedServiceName(This,pbstrName) ) 

#define IDvbServiceDescriptor2_GetServiceNameEmphasized(This,pbstrName)	\
    ( (This)->lpVtbl -> GetServiceNameEmphasized(This,pbstrName) ) 


#define IDvbServiceDescriptor2_GetServiceProviderNameW(This,convMode,pbstrName)	\
    ( (This)->lpVtbl -> GetServiceProviderNameW(This,convMode,pbstrName) ) 

#define IDvbServiceDescriptor2_GetServiceNameW(This,convMode,pbstrName)	\
    ( (This)->lpVtbl -> GetServiceNameW(This,convMode,pbstrName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbServiceDescriptor2_INTERFACE_DEFINED__ */


#ifndef __IDvbServiceListDescriptor_INTERFACE_DEFINED__
#define __IDvbServiceListDescriptor_INTERFACE_DEFINED__

/* interface IDvbServiceListDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvbServiceListDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("05DB0D8F-6008-491a-ACD3-7090952707D0")
    IDvbServiceListDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordServiceId( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordServiceType( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbServiceListDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbServiceListDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbServiceListDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbServiceListDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbServiceListDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbServiceListDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IDvbServiceListDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordServiceId )( 
            IDvbServiceListDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordServiceType )( 
            IDvbServiceListDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        END_INTERFACE
    } IDvbServiceListDescriptorVtbl;

    interface IDvbServiceListDescriptor
    {
        CONST_VTBL struct IDvbServiceListDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbServiceListDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbServiceListDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbServiceListDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbServiceListDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbServiceListDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbServiceListDescriptor_GetCountOfRecords(This,pbVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pbVal) ) 

#define IDvbServiceListDescriptor_GetRecordServiceId(This,bRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordServiceId(This,bRecordIndex,pwVal) ) 

#define IDvbServiceListDescriptor_GetRecordServiceType(This,bRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordServiceType(This,bRecordIndex,pbVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbServiceListDescriptor_INTERFACE_DEFINED__ */


#ifndef __IDvbMultilingualServiceNameDescriptor_INTERFACE_DEFINED__
#define __IDvbMultilingualServiceNameDescriptor_INTERFACE_DEFINED__

/* interface IDvbMultilingualServiceNameDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvbMultilingualServiceNameDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2D80433B-B32C-47ef-987F-E78EBB773E34")
    IDvbMultilingualServiceNameDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordLangId( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ ULONG *ulVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordServiceProviderNameW( 
            /* [in] */ BYTE bRecordIndex,
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordServiceNameW( 
            /* [in] */ BYTE bRecordIndex,
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbMultilingualServiceNameDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbMultilingualServiceNameDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbMultilingualServiceNameDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbMultilingualServiceNameDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbMultilingualServiceNameDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbMultilingualServiceNameDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IDvbMultilingualServiceNameDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordLangId )( 
            IDvbMultilingualServiceNameDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ ULONG *ulVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordServiceProviderNameW )( 
            IDvbMultilingualServiceNameDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordServiceNameW )( 
            IDvbMultilingualServiceNameDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrName);
        
        END_INTERFACE
    } IDvbMultilingualServiceNameDescriptorVtbl;

    interface IDvbMultilingualServiceNameDescriptor
    {
        CONST_VTBL struct IDvbMultilingualServiceNameDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbMultilingualServiceNameDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbMultilingualServiceNameDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbMultilingualServiceNameDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbMultilingualServiceNameDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbMultilingualServiceNameDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbMultilingualServiceNameDescriptor_GetCountOfRecords(This,pbVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pbVal) ) 

#define IDvbMultilingualServiceNameDescriptor_GetRecordLangId(This,bRecordIndex,ulVal)	\
    ( (This)->lpVtbl -> GetRecordLangId(This,bRecordIndex,ulVal) ) 

#define IDvbMultilingualServiceNameDescriptor_GetRecordServiceProviderNameW(This,bRecordIndex,convMode,pbstrName)	\
    ( (This)->lpVtbl -> GetRecordServiceProviderNameW(This,bRecordIndex,convMode,pbstrName) ) 

#define IDvbMultilingualServiceNameDescriptor_GetRecordServiceNameW(This,bRecordIndex,convMode,pbstrName)	\
    ( (This)->lpVtbl -> GetRecordServiceNameW(This,bRecordIndex,convMode,pbstrName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbMultilingualServiceNameDescriptor_INTERFACE_DEFINED__ */


#ifndef __IDvbNetworkNameDescriptor_INTERFACE_DEFINED__
#define __IDvbNetworkNameDescriptor_INTERFACE_DEFINED__

/* interface IDvbNetworkNameDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvbNetworkNameDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5B2A80CF-35B9-446C-B3E4-048B761DBC51")
    IDvbNetworkNameDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNetworkName( 
            /* [annotation][out] */ 
            __deref_out  char **pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNetworkNameW( 
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbNetworkNameDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbNetworkNameDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbNetworkNameDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbNetworkNameDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbNetworkNameDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbNetworkNameDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetNetworkName )( 
            IDvbNetworkNameDescriptor * This,
            /* [annotation][out] */ 
            __deref_out  char **pszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetNetworkNameW )( 
            IDvbNetworkNameDescriptor * This,
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrName);
        
        END_INTERFACE
    } IDvbNetworkNameDescriptorVtbl;

    interface IDvbNetworkNameDescriptor
    {
        CONST_VTBL struct IDvbNetworkNameDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbNetworkNameDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbNetworkNameDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbNetworkNameDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbNetworkNameDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbNetworkNameDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbNetworkNameDescriptor_GetNetworkName(This,pszName)	\
    ( (This)->lpVtbl -> GetNetworkName(This,pszName) ) 

#define IDvbNetworkNameDescriptor_GetNetworkNameW(This,convMode,pbstrName)	\
    ( (This)->lpVtbl -> GetNetworkNameW(This,convMode,pbstrName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbNetworkNameDescriptor_INTERFACE_DEFINED__ */


#ifndef __IDvbShortEventDescriptor_INTERFACE_DEFINED__
#define __IDvbShortEventDescriptor_INTERFACE_DEFINED__

/* interface IDvbShortEventDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvbShortEventDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B170BE92-5B75-458E-9C6E-B0008231491A")
    IDvbShortEventDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLanguageCode( 
            /* [annotation][out] */ 
            __out_ecount(4)  char *pszCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEventNameW( 
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTextW( 
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbShortEventDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbShortEventDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbShortEventDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbShortEventDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbShortEventDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbShortEventDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLanguageCode )( 
            IDvbShortEventDescriptor * This,
            /* [annotation][out] */ 
            __out_ecount(4)  char *pszCode);
        
        HRESULT ( STDMETHODCALLTYPE *GetEventNameW )( 
            IDvbShortEventDescriptor * This,
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetTextW )( 
            IDvbShortEventDescriptor * This,
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrText);
        
        END_INTERFACE
    } IDvbShortEventDescriptorVtbl;

    interface IDvbShortEventDescriptor
    {
        CONST_VTBL struct IDvbShortEventDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbShortEventDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbShortEventDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbShortEventDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbShortEventDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbShortEventDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbShortEventDescriptor_GetLanguageCode(This,pszCode)	\
    ( (This)->lpVtbl -> GetLanguageCode(This,pszCode) ) 

#define IDvbShortEventDescriptor_GetEventNameW(This,convMode,pbstrName)	\
    ( (This)->lpVtbl -> GetEventNameW(This,convMode,pbstrName) ) 

#define IDvbShortEventDescriptor_GetTextW(This,convMode,pbstrText)	\
    ( (This)->lpVtbl -> GetTextW(This,convMode,pbstrText) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbShortEventDescriptor_INTERFACE_DEFINED__ */


#ifndef __IDvbExtendedEventDescriptor_INTERFACE_DEFINED__
#define __IDvbExtendedEventDescriptor_INTERFACE_DEFINED__

/* interface IDvbExtendedEventDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvbExtendedEventDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C9B22ECA-85F4-499F-B1DB-EFA93A91EE57")
    IDvbExtendedEventDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptorNumber( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastDescriptorNumber( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLanguageCode( 
            /* [annotation][out] */ 
            __out_ecount(4)  char *pszCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordItemW( 
            /* [in] */ BYTE bRecordIndex,
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrDesc,
            /* [out] */ BSTR *pbstrItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConcatenatedItemW( 
            /* [in] */ IDvbExtendedEventDescriptor *pFollowingDescriptor,
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrDesc,
            /* [out] */ BSTR *pbstrItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTextW( 
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConcatenatedTextW( 
            /* [in] */ IDvbExtendedEventDescriptor *FollowingDescriptor,
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordItemRawBytes( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE **ppbRawItem,
            /* [out] */ BYTE *pbItemLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbExtendedEventDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbExtendedEventDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbExtendedEventDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbExtendedEventDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbExtendedEventDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbExtendedEventDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptorNumber )( 
            IDvbExtendedEventDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastDescriptorNumber )( 
            IDvbExtendedEventDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLanguageCode )( 
            IDvbExtendedEventDescriptor * This,
            /* [annotation][out] */ 
            __out_ecount(4)  char *pszCode);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IDvbExtendedEventDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordItemW )( 
            IDvbExtendedEventDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrDesc,
            /* [out] */ BSTR *pbstrItem);
        
        HRESULT ( STDMETHODCALLTYPE *GetConcatenatedItemW )( 
            IDvbExtendedEventDescriptor * This,
            /* [in] */ IDvbExtendedEventDescriptor *pFollowingDescriptor,
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrDesc,
            /* [out] */ BSTR *pbstrItem);
        
        HRESULT ( STDMETHODCALLTYPE *GetTextW )( 
            IDvbExtendedEventDescriptor * This,
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrText);
        
        HRESULT ( STDMETHODCALLTYPE *GetConcatenatedTextW )( 
            IDvbExtendedEventDescriptor * This,
            /* [in] */ IDvbExtendedEventDescriptor *FollowingDescriptor,
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrText);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordItemRawBytes )( 
            IDvbExtendedEventDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE **ppbRawItem,
            /* [out] */ BYTE *pbItemLength);
        
        END_INTERFACE
    } IDvbExtendedEventDescriptorVtbl;

    interface IDvbExtendedEventDescriptor
    {
        CONST_VTBL struct IDvbExtendedEventDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbExtendedEventDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbExtendedEventDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbExtendedEventDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbExtendedEventDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbExtendedEventDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbExtendedEventDescriptor_GetDescriptorNumber(This,pbVal)	\
    ( (This)->lpVtbl -> GetDescriptorNumber(This,pbVal) ) 

#define IDvbExtendedEventDescriptor_GetLastDescriptorNumber(This,pbVal)	\
    ( (This)->lpVtbl -> GetLastDescriptorNumber(This,pbVal) ) 

#define IDvbExtendedEventDescriptor_GetLanguageCode(This,pszCode)	\
    ( (This)->lpVtbl -> GetLanguageCode(This,pszCode) ) 

#define IDvbExtendedEventDescriptor_GetCountOfRecords(This,pbVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pbVal) ) 

#define IDvbExtendedEventDescriptor_GetRecordItemW(This,bRecordIndex,convMode,pbstrDesc,pbstrItem)	\
    ( (This)->lpVtbl -> GetRecordItemW(This,bRecordIndex,convMode,pbstrDesc,pbstrItem) ) 

#define IDvbExtendedEventDescriptor_GetConcatenatedItemW(This,pFollowingDescriptor,convMode,pbstrDesc,pbstrItem)	\
    ( (This)->lpVtbl -> GetConcatenatedItemW(This,pFollowingDescriptor,convMode,pbstrDesc,pbstrItem) ) 

#define IDvbExtendedEventDescriptor_GetTextW(This,convMode,pbstrText)	\
    ( (This)->lpVtbl -> GetTextW(This,convMode,pbstrText) ) 

#define IDvbExtendedEventDescriptor_GetConcatenatedTextW(This,FollowingDescriptor,convMode,pbstrText)	\
    ( (This)->lpVtbl -> GetConcatenatedTextW(This,FollowingDescriptor,convMode,pbstrText) ) 

#define IDvbExtendedEventDescriptor_GetRecordItemRawBytes(This,bRecordIndex,ppbRawItem,pbItemLength)	\
    ( (This)->lpVtbl -> GetRecordItemRawBytes(This,bRecordIndex,ppbRawItem,pbItemLength) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbExtendedEventDescriptor_INTERFACE_DEFINED__ */


#ifndef __IDvbComponentDescriptor_INTERFACE_DEFINED__
#define __IDvbComponentDescriptor_INTERFACE_DEFINED__

/* interface IDvbComponentDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvbComponentDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("91E405CF-80E7-457F-9096-1B9D1CE32141")
    IDvbComponentDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamContent( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetComponentType( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetComponentTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLanguageCode( 
            /* [annotation][out] */ 
            __out_ecount(4)  char *pszCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTextW( 
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbComponentDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbComponentDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbComponentDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbComponentDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbComponentDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbComponentDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamContent )( 
            IDvbComponentDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetComponentType )( 
            IDvbComponentDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetComponentTag )( 
            IDvbComponentDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLanguageCode )( 
            IDvbComponentDescriptor * This,
            /* [annotation][out] */ 
            __out_ecount(4)  char *pszCode);
        
        HRESULT ( STDMETHODCALLTYPE *GetTextW )( 
            IDvbComponentDescriptor * This,
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrText);
        
        END_INTERFACE
    } IDvbComponentDescriptorVtbl;

    interface IDvbComponentDescriptor
    {
        CONST_VTBL struct IDvbComponentDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbComponentDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbComponentDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbComponentDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbComponentDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbComponentDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbComponentDescriptor_GetStreamContent(This,pbVal)	\
    ( (This)->lpVtbl -> GetStreamContent(This,pbVal) ) 

#define IDvbComponentDescriptor_GetComponentType(This,pbVal)	\
    ( (This)->lpVtbl -> GetComponentType(This,pbVal) ) 

#define IDvbComponentDescriptor_GetComponentTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetComponentTag(This,pbVal) ) 

#define IDvbComponentDescriptor_GetLanguageCode(This,pszCode)	\
    ( (This)->lpVtbl -> GetLanguageCode(This,pszCode) ) 

#define IDvbComponentDescriptor_GetTextW(This,convMode,pbstrText)	\
    ( (This)->lpVtbl -> GetTextW(This,convMode,pbstrText) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbComponentDescriptor_INTERFACE_DEFINED__ */


#ifndef __IDvbContentDescriptor_INTERFACE_DEFINED__
#define __IDvbContentDescriptor_INTERFACE_DEFINED__

/* interface IDvbContentDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvbContentDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2E883881-A467-412A-9D63-6F2B6DA05BF0")
    IDvbContentDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordContentNibbles( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbValLevel1,
            /* [out] */ BYTE *pbValLevel2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordUserNibbles( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal1,
            /* [out] */ BYTE *pbVal2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbContentDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbContentDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbContentDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbContentDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbContentDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbContentDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IDvbContentDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordContentNibbles )( 
            IDvbContentDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbValLevel1,
            /* [out] */ BYTE *pbValLevel2);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordUserNibbles )( 
            IDvbContentDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal1,
            /* [out] */ BYTE *pbVal2);
        
        END_INTERFACE
    } IDvbContentDescriptorVtbl;

    interface IDvbContentDescriptor
    {
        CONST_VTBL struct IDvbContentDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbContentDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbContentDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbContentDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbContentDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbContentDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbContentDescriptor_GetCountOfRecords(This,pbVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pbVal) ) 

#define IDvbContentDescriptor_GetRecordContentNibbles(This,bRecordIndex,pbValLevel1,pbValLevel2)	\
    ( (This)->lpVtbl -> GetRecordContentNibbles(This,bRecordIndex,pbValLevel1,pbValLevel2) ) 

#define IDvbContentDescriptor_GetRecordUserNibbles(This,bRecordIndex,pbVal1,pbVal2)	\
    ( (This)->lpVtbl -> GetRecordUserNibbles(This,bRecordIndex,pbVal1,pbVal2) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbContentDescriptor_INTERFACE_DEFINED__ */


#ifndef __IDvbParentalRatingDescriptor_INTERFACE_DEFINED__
#define __IDvbParentalRatingDescriptor_INTERFACE_DEFINED__

/* interface IDvbParentalRatingDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvbParentalRatingDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3AD9DDE1-FB1B-4186-937F-22E6B5A72A10")
    IDvbParentalRatingDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordRating( 
            /* [in] */ BYTE bRecordIndex,
            /* [annotation][out] */ 
            __out_ecount(4)  char *pszCountryCode,
            /* [out] */ BYTE *pbVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvbParentalRatingDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvbParentalRatingDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvbParentalRatingDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvbParentalRatingDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IDvbParentalRatingDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IDvbParentalRatingDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IDvbParentalRatingDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordRating )( 
            IDvbParentalRatingDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [annotation][out] */ 
            __out_ecount(4)  char *pszCountryCode,
            /* [out] */ BYTE *pbVal);
        
        END_INTERFACE
    } IDvbParentalRatingDescriptorVtbl;

    interface IDvbParentalRatingDescriptor
    {
        CONST_VTBL struct IDvbParentalRatingDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvbParentalRatingDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvbParentalRatingDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvbParentalRatingDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvbParentalRatingDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IDvbParentalRatingDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IDvbParentalRatingDescriptor_GetCountOfRecords(This,pbVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pbVal) ) 

#define IDvbParentalRatingDescriptor_GetRecordRating(This,bRecordIndex,pszCountryCode,pbVal)	\
    ( (This)->lpVtbl -> GetRecordRating(This,bRecordIndex,pszCountryCode,pbVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvbParentalRatingDescriptor_INTERFACE_DEFINED__ */


#ifndef __IIsdbTerrestrialDeliverySystemDescriptor_INTERFACE_DEFINED__
#define __IIsdbTerrestrialDeliverySystemDescriptor_INTERFACE_DEFINED__

/* interface IIsdbTerrestrialDeliverySystemDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IIsdbTerrestrialDeliverySystemDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("39FAE0A6-D151-44DD-A28A-765DE5991670")
    IIsdbTerrestrialDeliverySystemDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAreaCode( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuardInterval( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransmissionMode( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordFrequency( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ DWORD *pdwVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIsdbTerrestrialDeliverySystemDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIsdbTerrestrialDeliverySystemDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIsdbTerrestrialDeliverySystemDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIsdbTerrestrialDeliverySystemDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IIsdbTerrestrialDeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IIsdbTerrestrialDeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetAreaCode )( 
            IIsdbTerrestrialDeliverySystemDescriptor * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuardInterval )( 
            IIsdbTerrestrialDeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransmissionMode )( 
            IIsdbTerrestrialDeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IIsdbTerrestrialDeliverySystemDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordFrequency )( 
            IIsdbTerrestrialDeliverySystemDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ DWORD *pdwVal);
        
        END_INTERFACE
    } IIsdbTerrestrialDeliverySystemDescriptorVtbl;

    interface IIsdbTerrestrialDeliverySystemDescriptor
    {
        CONST_VTBL struct IIsdbTerrestrialDeliverySystemDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIsdbTerrestrialDeliverySystemDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IIsdbTerrestrialDeliverySystemDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IIsdbTerrestrialDeliverySystemDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IIsdbTerrestrialDeliverySystemDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IIsdbTerrestrialDeliverySystemDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IIsdbTerrestrialDeliverySystemDescriptor_GetAreaCode(This,pwVal)	\
    ( (This)->lpVtbl -> GetAreaCode(This,pwVal) ) 

#define IIsdbTerrestrialDeliverySystemDescriptor_GetGuardInterval(This,pbVal)	\
    ( (This)->lpVtbl -> GetGuardInterval(This,pbVal) ) 

#define IIsdbTerrestrialDeliverySystemDescriptor_GetTransmissionMode(This,pbVal)	\
    ( (This)->lpVtbl -> GetTransmissionMode(This,pbVal) ) 

#define IIsdbTerrestrialDeliverySystemDescriptor_GetCountOfRecords(This,pbVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pbVal) ) 

#define IIsdbTerrestrialDeliverySystemDescriptor_GetRecordFrequency(This,bRecordIndex,pdwVal)	\
    ( (This)->lpVtbl -> GetRecordFrequency(This,bRecordIndex,pdwVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IIsdbTerrestrialDeliverySystemDescriptor_INTERFACE_DEFINED__ */


#ifndef __IIsdbTSInformationDescriptor_INTERFACE_DEFINED__
#define __IIsdbTSInformationDescriptor_INTERFACE_DEFINED__

/* interface IIsdbTSInformationDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IIsdbTSInformationDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D7AD183E-38F5-4210-B55F-EC8D601BBD47")
    IIsdbTSInformationDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRemoteControlKeyId( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTSNameW( 
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordTransmissionTypeInfo( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordNumberOfServices( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordServiceIdByIndex( 
            /* [in] */ BYTE bRecordIndex,
            /* [in] */ BYTE bServiceIndex,
            /* [out] */ WORD *pdwVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIsdbTSInformationDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIsdbTSInformationDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIsdbTSInformationDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIsdbTSInformationDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IIsdbTSInformationDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IIsdbTSInformationDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRemoteControlKeyId )( 
            IIsdbTSInformationDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTSNameW )( 
            IIsdbTSInformationDescriptor * This,
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IIsdbTSInformationDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordTransmissionTypeInfo )( 
            IIsdbTSInformationDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordNumberOfServices )( 
            IIsdbTSInformationDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordServiceIdByIndex )( 
            IIsdbTSInformationDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [in] */ BYTE bServiceIndex,
            /* [out] */ WORD *pdwVal);
        
        END_INTERFACE
    } IIsdbTSInformationDescriptorVtbl;

    interface IIsdbTSInformationDescriptor
    {
        CONST_VTBL struct IIsdbTSInformationDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIsdbTSInformationDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IIsdbTSInformationDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IIsdbTSInformationDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IIsdbTSInformationDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IIsdbTSInformationDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IIsdbTSInformationDescriptor_GetRemoteControlKeyId(This,pbVal)	\
    ( (This)->lpVtbl -> GetRemoteControlKeyId(This,pbVal) ) 

#define IIsdbTSInformationDescriptor_GetTSNameW(This,convMode,pbstrName)	\
    ( (This)->lpVtbl -> GetTSNameW(This,convMode,pbstrName) ) 

#define IIsdbTSInformationDescriptor_GetCountOfRecords(This,pbVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pbVal) ) 

#define IIsdbTSInformationDescriptor_GetRecordTransmissionTypeInfo(This,bRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordTransmissionTypeInfo(This,bRecordIndex,pbVal) ) 

#define IIsdbTSInformationDescriptor_GetRecordNumberOfServices(This,bRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordNumberOfServices(This,bRecordIndex,pbVal) ) 

#define IIsdbTSInformationDescriptor_GetRecordServiceIdByIndex(This,bRecordIndex,bServiceIndex,pdwVal)	\
    ( (This)->lpVtbl -> GetRecordServiceIdByIndex(This,bRecordIndex,bServiceIndex,pdwVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IIsdbTSInformationDescriptor_INTERFACE_DEFINED__ */


#ifndef __IIsdbDigitalCopyControlDescriptor_INTERFACE_DEFINED__
#define __IIsdbDigitalCopyControlDescriptor_INTERFACE_DEFINED__

/* interface IIsdbDigitalCopyControlDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IIsdbDigitalCopyControlDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1A28417E-266A-4BB8-A4BD-D782BCFB8161")
    IIsdbDigitalCopyControlDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCopyControl( 
            /* [out] */ BYTE *pbDigitalRecordingControlData,
            /* [out] */ BYTE *pbCopyControlType,
            /* [out] */ BYTE *pbAPSControlData,
            /* [out] */ BYTE *pbMaximumBitrate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordCopyControl( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbComponentTag,
            /* [out] */ BYTE *pbDigitalRecordingControlData,
            /* [out] */ BYTE *pbCopyControlType,
            /* [out] */ BYTE *pbAPSControlData,
            /* [out] */ BYTE *pbMaximumBitrate) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIsdbDigitalCopyControlDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIsdbDigitalCopyControlDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIsdbDigitalCopyControlDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIsdbDigitalCopyControlDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IIsdbDigitalCopyControlDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IIsdbDigitalCopyControlDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCopyControl )( 
            IIsdbDigitalCopyControlDescriptor * This,
            /* [out] */ BYTE *pbDigitalRecordingControlData,
            /* [out] */ BYTE *pbCopyControlType,
            /* [out] */ BYTE *pbAPSControlData,
            /* [out] */ BYTE *pbMaximumBitrate);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IIsdbDigitalCopyControlDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordCopyControl )( 
            IIsdbDigitalCopyControlDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbComponentTag,
            /* [out] */ BYTE *pbDigitalRecordingControlData,
            /* [out] */ BYTE *pbCopyControlType,
            /* [out] */ BYTE *pbAPSControlData,
            /* [out] */ BYTE *pbMaximumBitrate);
        
        END_INTERFACE
    } IIsdbDigitalCopyControlDescriptorVtbl;

    interface IIsdbDigitalCopyControlDescriptor
    {
        CONST_VTBL struct IIsdbDigitalCopyControlDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIsdbDigitalCopyControlDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IIsdbDigitalCopyControlDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IIsdbDigitalCopyControlDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IIsdbDigitalCopyControlDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IIsdbDigitalCopyControlDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IIsdbDigitalCopyControlDescriptor_GetCopyControl(This,pbDigitalRecordingControlData,pbCopyControlType,pbAPSControlData,pbMaximumBitrate)	\
    ( (This)->lpVtbl -> GetCopyControl(This,pbDigitalRecordingControlData,pbCopyControlType,pbAPSControlData,pbMaximumBitrate) ) 

#define IIsdbDigitalCopyControlDescriptor_GetCountOfRecords(This,pbVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pbVal) ) 

#define IIsdbDigitalCopyControlDescriptor_GetRecordCopyControl(This,bRecordIndex,pbComponentTag,pbDigitalRecordingControlData,pbCopyControlType,pbAPSControlData,pbMaximumBitrate)	\
    ( (This)->lpVtbl -> GetRecordCopyControl(This,bRecordIndex,pbComponentTag,pbDigitalRecordingControlData,pbCopyControlType,pbAPSControlData,pbMaximumBitrate) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IIsdbDigitalCopyControlDescriptor_INTERFACE_DEFINED__ */


#ifndef __IIsdbAudioComponentDescriptor_INTERFACE_DEFINED__
#define __IIsdbAudioComponentDescriptor_INTERFACE_DEFINED__

/* interface IIsdbAudioComponentDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IIsdbAudioComponentDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("679D2002-2425-4BE4-A4C7-D6632A574F4D")
    IIsdbAudioComponentDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamContent( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetComponentType( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetComponentTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamType( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSimulcastGroupTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetESMultiLingualFlag( 
            /* [out] */ BOOL *pfVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMainComponentFlag( 
            /* [out] */ BOOL *pfVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetQualityIndicator( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSamplingRate( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLanguageCode( 
            /* [annotation][out] */ 
            __out_ecount(4)  char *pszCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLanguageCode2( 
            /* [annotation][out] */ 
            __out_ecount(4)  char *pszCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTextW( 
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIsdbAudioComponentDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIsdbAudioComponentDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIsdbAudioComponentDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIsdbAudioComponentDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IIsdbAudioComponentDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IIsdbAudioComponentDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamContent )( 
            IIsdbAudioComponentDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetComponentType )( 
            IIsdbAudioComponentDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetComponentTag )( 
            IIsdbAudioComponentDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamType )( 
            IIsdbAudioComponentDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSimulcastGroupTag )( 
            IIsdbAudioComponentDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetESMultiLingualFlag )( 
            IIsdbAudioComponentDescriptor * This,
            /* [out] */ BOOL *pfVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetMainComponentFlag )( 
            IIsdbAudioComponentDescriptor * This,
            /* [out] */ BOOL *pfVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetQualityIndicator )( 
            IIsdbAudioComponentDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSamplingRate )( 
            IIsdbAudioComponentDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLanguageCode )( 
            IIsdbAudioComponentDescriptor * This,
            /* [annotation][out] */ 
            __out_ecount(4)  char *pszCode);
        
        HRESULT ( STDMETHODCALLTYPE *GetLanguageCode2 )( 
            IIsdbAudioComponentDescriptor * This,
            /* [annotation][out] */ 
            __out_ecount(4)  char *pszCode);
        
        HRESULT ( STDMETHODCALLTYPE *GetTextW )( 
            IIsdbAudioComponentDescriptor * This,
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrText);
        
        END_INTERFACE
    } IIsdbAudioComponentDescriptorVtbl;

    interface IIsdbAudioComponentDescriptor
    {
        CONST_VTBL struct IIsdbAudioComponentDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIsdbAudioComponentDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IIsdbAudioComponentDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IIsdbAudioComponentDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IIsdbAudioComponentDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IIsdbAudioComponentDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IIsdbAudioComponentDescriptor_GetStreamContent(This,pbVal)	\
    ( (This)->lpVtbl -> GetStreamContent(This,pbVal) ) 

#define IIsdbAudioComponentDescriptor_GetComponentType(This,pbVal)	\
    ( (This)->lpVtbl -> GetComponentType(This,pbVal) ) 

#define IIsdbAudioComponentDescriptor_GetComponentTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetComponentTag(This,pbVal) ) 

#define IIsdbAudioComponentDescriptor_GetStreamType(This,pbVal)	\
    ( (This)->lpVtbl -> GetStreamType(This,pbVal) ) 

#define IIsdbAudioComponentDescriptor_GetSimulcastGroupTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetSimulcastGroupTag(This,pbVal) ) 

#define IIsdbAudioComponentDescriptor_GetESMultiLingualFlag(This,pfVal)	\
    ( (This)->lpVtbl -> GetESMultiLingualFlag(This,pfVal) ) 

#define IIsdbAudioComponentDescriptor_GetMainComponentFlag(This,pfVal)	\
    ( (This)->lpVtbl -> GetMainComponentFlag(This,pfVal) ) 

#define IIsdbAudioComponentDescriptor_GetQualityIndicator(This,pbVal)	\
    ( (This)->lpVtbl -> GetQualityIndicator(This,pbVal) ) 

#define IIsdbAudioComponentDescriptor_GetSamplingRate(This,pbVal)	\
    ( (This)->lpVtbl -> GetSamplingRate(This,pbVal) ) 

#define IIsdbAudioComponentDescriptor_GetLanguageCode(This,pszCode)	\
    ( (This)->lpVtbl -> GetLanguageCode(This,pszCode) ) 

#define IIsdbAudioComponentDescriptor_GetLanguageCode2(This,pszCode)	\
    ( (This)->lpVtbl -> GetLanguageCode2(This,pszCode) ) 

#define IIsdbAudioComponentDescriptor_GetTextW(This,convMode,pbstrText)	\
    ( (This)->lpVtbl -> GetTextW(This,convMode,pbstrText) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IIsdbAudioComponentDescriptor_INTERFACE_DEFINED__ */


#ifndef __IIsdbDataContentDescriptor_INTERFACE_DEFINED__
#define __IIsdbDataContentDescriptor_INTERFACE_DEFINED__

/* interface IIsdbDataContentDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IIsdbDataContentDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A428100A-E646-4BD6-AA14-6087BDC08CD5")
    IIsdbDataContentDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDataComponentId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEntryComponent( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelectorLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelectorBytes( 
            /* [in] */ BYTE bBufLength,
            /* [out] */ BYTE *pbBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordComponentRef( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLanguageCode( 
            /* [annotation][out] */ 
            __out_ecount(4)  char *pszCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTextW( 
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIsdbDataContentDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIsdbDataContentDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIsdbDataContentDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIsdbDataContentDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IIsdbDataContentDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IIsdbDataContentDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetDataComponentId )( 
            IIsdbDataContentDescriptor * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetEntryComponent )( 
            IIsdbDataContentDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelectorLength )( 
            IIsdbDataContentDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelectorBytes )( 
            IIsdbDataContentDescriptor * This,
            /* [in] */ BYTE bBufLength,
            /* [out] */ BYTE *pbBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IIsdbDataContentDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordComponentRef )( 
            IIsdbDataContentDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLanguageCode )( 
            IIsdbDataContentDescriptor * This,
            /* [annotation][out] */ 
            __out_ecount(4)  char *pszCode);
        
        HRESULT ( STDMETHODCALLTYPE *GetTextW )( 
            IIsdbDataContentDescriptor * This,
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrText);
        
        END_INTERFACE
    } IIsdbDataContentDescriptorVtbl;

    interface IIsdbDataContentDescriptor
    {
        CONST_VTBL struct IIsdbDataContentDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIsdbDataContentDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IIsdbDataContentDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IIsdbDataContentDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IIsdbDataContentDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IIsdbDataContentDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IIsdbDataContentDescriptor_GetDataComponentId(This,pwVal)	\
    ( (This)->lpVtbl -> GetDataComponentId(This,pwVal) ) 

#define IIsdbDataContentDescriptor_GetEntryComponent(This,pbVal)	\
    ( (This)->lpVtbl -> GetEntryComponent(This,pbVal) ) 

#define IIsdbDataContentDescriptor_GetSelectorLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetSelectorLength(This,pbVal) ) 

#define IIsdbDataContentDescriptor_GetSelectorBytes(This,bBufLength,pbBuf)	\
    ( (This)->lpVtbl -> GetSelectorBytes(This,bBufLength,pbBuf) ) 

#define IIsdbDataContentDescriptor_GetCountOfRecords(This,pbVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pbVal) ) 

#define IIsdbDataContentDescriptor_GetRecordComponentRef(This,bRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordComponentRef(This,bRecordIndex,pbVal) ) 

#define IIsdbDataContentDescriptor_GetLanguageCode(This,pszCode)	\
    ( (This)->lpVtbl -> GetLanguageCode(This,pszCode) ) 

#define IIsdbDataContentDescriptor_GetTextW(This,convMode,pbstrText)	\
    ( (This)->lpVtbl -> GetTextW(This,convMode,pbstrText) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IIsdbDataContentDescriptor_INTERFACE_DEFINED__ */


#ifndef __IIsdbCAContractInformationDescriptor_INTERFACE_DEFINED__
#define __IIsdbCAContractInformationDescriptor_INTERFACE_DEFINED__

/* interface IIsdbCAContractInformationDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IIsdbCAContractInformationDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08E18B25-A28F-4E92-821E-4FCED5CC2291")
    IIsdbCAContractInformationDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCASystemId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCAUnitId( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordComponentTag( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContractVerificationInfoLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContractVerificationInfo( 
            /* [in] */ BYTE bBufLength,
            /* [out] */ BYTE *pbBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFeeNameW( 
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIsdbCAContractInformationDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIsdbCAContractInformationDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIsdbCAContractInformationDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIsdbCAContractInformationDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IIsdbCAContractInformationDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IIsdbCAContractInformationDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCASystemId )( 
            IIsdbCAContractInformationDescriptor * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCAUnitId )( 
            IIsdbCAContractInformationDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IIsdbCAContractInformationDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordComponentTag )( 
            IIsdbCAContractInformationDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetContractVerificationInfoLength )( 
            IIsdbCAContractInformationDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetContractVerificationInfo )( 
            IIsdbCAContractInformationDescriptor * This,
            /* [in] */ BYTE bBufLength,
            /* [out] */ BYTE *pbBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetFeeNameW )( 
            IIsdbCAContractInformationDescriptor * This,
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrName);
        
        END_INTERFACE
    } IIsdbCAContractInformationDescriptorVtbl;

    interface IIsdbCAContractInformationDescriptor
    {
        CONST_VTBL struct IIsdbCAContractInformationDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIsdbCAContractInformationDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IIsdbCAContractInformationDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IIsdbCAContractInformationDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IIsdbCAContractInformationDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IIsdbCAContractInformationDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IIsdbCAContractInformationDescriptor_GetCASystemId(This,pwVal)	\
    ( (This)->lpVtbl -> GetCASystemId(This,pwVal) ) 

#define IIsdbCAContractInformationDescriptor_GetCAUnitId(This,pbVal)	\
    ( (This)->lpVtbl -> GetCAUnitId(This,pbVal) ) 

#define IIsdbCAContractInformationDescriptor_GetCountOfRecords(This,pbVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pbVal) ) 

#define IIsdbCAContractInformationDescriptor_GetRecordComponentTag(This,bRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordComponentTag(This,bRecordIndex,pbVal) ) 

#define IIsdbCAContractInformationDescriptor_GetContractVerificationInfoLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetContractVerificationInfoLength(This,pbVal) ) 

#define IIsdbCAContractInformationDescriptor_GetContractVerificationInfo(This,bBufLength,pbBuf)	\
    ( (This)->lpVtbl -> GetContractVerificationInfo(This,bBufLength,pbBuf) ) 

#define IIsdbCAContractInformationDescriptor_GetFeeNameW(This,convMode,pbstrName)	\
    ( (This)->lpVtbl -> GetFeeNameW(This,convMode,pbstrName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IIsdbCAContractInformationDescriptor_INTERFACE_DEFINED__ */


#ifndef __IIsdbEventGroupDescriptor_INTERFACE_DEFINED__
#define __IIsdbEventGroupDescriptor_INTERFACE_DEFINED__

/* interface IIsdbEventGroupDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IIsdbEventGroupDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("94B06780-2E2A-44DC-A966-CC56FDABC6C2")
    IIsdbEventGroupDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroupType( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordEvent( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwServiceId,
            /* [out] */ WORD *pwEventId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRefRecords( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRefRecordEvent( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwOriginalNetworkId,
            /* [out] */ WORD *pwTransportStreamId,
            /* [out] */ WORD *pwServiceId,
            /* [out] */ WORD *pwEventId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIsdbEventGroupDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIsdbEventGroupDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIsdbEventGroupDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIsdbEventGroupDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IIsdbEventGroupDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IIsdbEventGroupDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupType )( 
            IIsdbEventGroupDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IIsdbEventGroupDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordEvent )( 
            IIsdbEventGroupDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwServiceId,
            /* [out] */ WORD *pwEventId);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRefRecords )( 
            IIsdbEventGroupDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRefRecordEvent )( 
            IIsdbEventGroupDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwOriginalNetworkId,
            /* [out] */ WORD *pwTransportStreamId,
            /* [out] */ WORD *pwServiceId,
            /* [out] */ WORD *pwEventId);
        
        END_INTERFACE
    } IIsdbEventGroupDescriptorVtbl;

    interface IIsdbEventGroupDescriptor
    {
        CONST_VTBL struct IIsdbEventGroupDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIsdbEventGroupDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IIsdbEventGroupDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IIsdbEventGroupDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IIsdbEventGroupDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IIsdbEventGroupDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IIsdbEventGroupDescriptor_GetGroupType(This,pbVal)	\
    ( (This)->lpVtbl -> GetGroupType(This,pbVal) ) 

#define IIsdbEventGroupDescriptor_GetCountOfRecords(This,pbVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pbVal) ) 

#define IIsdbEventGroupDescriptor_GetRecordEvent(This,bRecordIndex,pwServiceId,pwEventId)	\
    ( (This)->lpVtbl -> GetRecordEvent(This,bRecordIndex,pwServiceId,pwEventId) ) 

#define IIsdbEventGroupDescriptor_GetCountOfRefRecords(This,pbVal)	\
    ( (This)->lpVtbl -> GetCountOfRefRecords(This,pbVal) ) 

#define IIsdbEventGroupDescriptor_GetRefRecordEvent(This,bRecordIndex,pwOriginalNetworkId,pwTransportStreamId,pwServiceId,pwEventId)	\
    ( (This)->lpVtbl -> GetRefRecordEvent(This,bRecordIndex,pwOriginalNetworkId,pwTransportStreamId,pwServiceId,pwEventId) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IIsdbEventGroupDescriptor_INTERFACE_DEFINED__ */


#ifndef __IIsdbComponentGroupDescriptor_INTERFACE_DEFINED__
#define __IIsdbComponentGroupDescriptor_INTERFACE_DEFINED__

/* interface IIsdbComponentGroupDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IIsdbComponentGroupDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A494F17F-C592-47D8-8943-64C9A34BE7B9")
    IIsdbComponentGroupDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetComponentGroupType( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordGroupId( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordNumberOfCAUnit( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordCAUnitCAUnitId( 
            /* [in] */ BYTE bRecordIndex,
            /* [in] */ BYTE bCAUnitIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordCAUnitNumberOfComponents( 
            /* [in] */ BYTE bRecordIndex,
            /* [in] */ BYTE bCAUnitIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordCAUnitComponentTag( 
            /* [in] */ BYTE bRecordIndex,
            /* [in] */ BYTE bCAUnitIndex,
            /* [in] */ BYTE bComponentIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordTotalBitRate( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordTextW( 
            /* [in] */ BYTE bRecordIndex,
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIsdbComponentGroupDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIsdbComponentGroupDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIsdbComponentGroupDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIsdbComponentGroupDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IIsdbComponentGroupDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IIsdbComponentGroupDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetComponentGroupType )( 
            IIsdbComponentGroupDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IIsdbComponentGroupDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordGroupId )( 
            IIsdbComponentGroupDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordNumberOfCAUnit )( 
            IIsdbComponentGroupDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordCAUnitCAUnitId )( 
            IIsdbComponentGroupDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [in] */ BYTE bCAUnitIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordCAUnitNumberOfComponents )( 
            IIsdbComponentGroupDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [in] */ BYTE bCAUnitIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordCAUnitComponentTag )( 
            IIsdbComponentGroupDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [in] */ BYTE bCAUnitIndex,
            /* [in] */ BYTE bComponentIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordTotalBitRate )( 
            IIsdbComponentGroupDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordTextW )( 
            IIsdbComponentGroupDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrText);
        
        END_INTERFACE
    } IIsdbComponentGroupDescriptorVtbl;

    interface IIsdbComponentGroupDescriptor
    {
        CONST_VTBL struct IIsdbComponentGroupDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIsdbComponentGroupDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IIsdbComponentGroupDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IIsdbComponentGroupDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IIsdbComponentGroupDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IIsdbComponentGroupDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IIsdbComponentGroupDescriptor_GetComponentGroupType(This,pbVal)	\
    ( (This)->lpVtbl -> GetComponentGroupType(This,pbVal) ) 

#define IIsdbComponentGroupDescriptor_GetCountOfRecords(This,pbVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pbVal) ) 

#define IIsdbComponentGroupDescriptor_GetRecordGroupId(This,bRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordGroupId(This,bRecordIndex,pbVal) ) 

#define IIsdbComponentGroupDescriptor_GetRecordNumberOfCAUnit(This,bRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordNumberOfCAUnit(This,bRecordIndex,pbVal) ) 

#define IIsdbComponentGroupDescriptor_GetRecordCAUnitCAUnitId(This,bRecordIndex,bCAUnitIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordCAUnitCAUnitId(This,bRecordIndex,bCAUnitIndex,pbVal) ) 

#define IIsdbComponentGroupDescriptor_GetRecordCAUnitNumberOfComponents(This,bRecordIndex,bCAUnitIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordCAUnitNumberOfComponents(This,bRecordIndex,bCAUnitIndex,pbVal) ) 

#define IIsdbComponentGroupDescriptor_GetRecordCAUnitComponentTag(This,bRecordIndex,bCAUnitIndex,bComponentIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordCAUnitComponentTag(This,bRecordIndex,bCAUnitIndex,bComponentIndex,pbVal) ) 

#define IIsdbComponentGroupDescriptor_GetRecordTotalBitRate(This,bRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordTotalBitRate(This,bRecordIndex,pbVal) ) 

#define IIsdbComponentGroupDescriptor_GetRecordTextW(This,bRecordIndex,convMode,pbstrText)	\
    ( (This)->lpVtbl -> GetRecordTextW(This,bRecordIndex,convMode,pbstrText) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IIsdbComponentGroupDescriptor_INTERFACE_DEFINED__ */


#ifndef __IIsdbSeriesDescriptor_INTERFACE_DEFINED__
#define __IIsdbSeriesDescriptor_INTERFACE_DEFINED__

/* interface IIsdbSeriesDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IIsdbSeriesDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("07EF6370-1660-4F26-87FC-614ADAB24B11")
    IIsdbSeriesDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSeriesId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRepeatLabel( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProgramPattern( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExpireDate( 
            /* [out] */ BOOL *pfValid,
            /* [out] */ MPEG_DATE_AND_TIME *pmdtVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEpisodeNumber( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastEpisodeNumber( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSeriesNameW( 
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIsdbSeriesDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIsdbSeriesDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIsdbSeriesDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIsdbSeriesDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IIsdbSeriesDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IIsdbSeriesDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSeriesId )( 
            IIsdbSeriesDescriptor * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRepeatLabel )( 
            IIsdbSeriesDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetProgramPattern )( 
            IIsdbSeriesDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetExpireDate )( 
            IIsdbSeriesDescriptor * This,
            /* [out] */ BOOL *pfValid,
            /* [out] */ MPEG_DATE_AND_TIME *pmdtVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetEpisodeNumber )( 
            IIsdbSeriesDescriptor * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastEpisodeNumber )( 
            IIsdbSeriesDescriptor * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSeriesNameW )( 
            IIsdbSeriesDescriptor * This,
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrName);
        
        END_INTERFACE
    } IIsdbSeriesDescriptorVtbl;

    interface IIsdbSeriesDescriptor
    {
        CONST_VTBL struct IIsdbSeriesDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIsdbSeriesDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IIsdbSeriesDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IIsdbSeriesDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IIsdbSeriesDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IIsdbSeriesDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IIsdbSeriesDescriptor_GetSeriesId(This,pwVal)	\
    ( (This)->lpVtbl -> GetSeriesId(This,pwVal) ) 

#define IIsdbSeriesDescriptor_GetRepeatLabel(This,pbVal)	\
    ( (This)->lpVtbl -> GetRepeatLabel(This,pbVal) ) 

#define IIsdbSeriesDescriptor_GetProgramPattern(This,pbVal)	\
    ( (This)->lpVtbl -> GetProgramPattern(This,pbVal) ) 

#define IIsdbSeriesDescriptor_GetExpireDate(This,pfValid,pmdtVal)	\
    ( (This)->lpVtbl -> GetExpireDate(This,pfValid,pmdtVal) ) 

#define IIsdbSeriesDescriptor_GetEpisodeNumber(This,pwVal)	\
    ( (This)->lpVtbl -> GetEpisodeNumber(This,pwVal) ) 

#define IIsdbSeriesDescriptor_GetLastEpisodeNumber(This,pwVal)	\
    ( (This)->lpVtbl -> GetLastEpisodeNumber(This,pwVal) ) 

#define IIsdbSeriesDescriptor_GetSeriesNameW(This,convMode,pbstrName)	\
    ( (This)->lpVtbl -> GetSeriesNameW(This,convMode,pbstrName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IIsdbSeriesDescriptor_INTERFACE_DEFINED__ */


#ifndef __IIsdbDownloadContentDescriptor_INTERFACE_DEFINED__
#define __IIsdbDownloadContentDescriptor_INTERFACE_DEFINED__

/* interface IIsdbDownloadContentDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IIsdbDownloadContentDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5298661E-CB88-4F5F-A1DE-5F440C185B92")
    IIsdbDownloadContentDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFlags( 
            /* [out] */ BOOL *pfReboot,
            /* [out] */ BOOL *pfAddOn,
            /* [out] */ BOOL *pfCompatibility,
            /* [out] */ BOOL *pfModuleInfo,
            /* [out] */ BOOL *pfTextInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetComponentSize( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDownloadId( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimeOutValueDII( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLeakRate( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetComponentTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompatiblityDescriptorLength( 
            /* [out] */ WORD *pwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompatiblityDescriptor( 
            /* [out] */ BYTE **ppbData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordModuleId( 
            /* [in] */ WORD wRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordModuleSize( 
            /* [in] */ WORD wRecordIndex,
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordModuleInfoLength( 
            /* [in] */ WORD wRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordModuleInfo( 
            /* [in] */ WORD wRecordIndex,
            /* [out] */ BYTE **ppbData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTextLanguageCode( 
            /* [annotation][out] */ 
            __out_ecount(4)  char *szCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTextW( 
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIsdbDownloadContentDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIsdbDownloadContentDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIsdbDownloadContentDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIsdbDownloadContentDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IIsdbDownloadContentDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IIsdbDownloadContentDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetFlags )( 
            IIsdbDownloadContentDescriptor * This,
            /* [out] */ BOOL *pfReboot,
            /* [out] */ BOOL *pfAddOn,
            /* [out] */ BOOL *pfCompatibility,
            /* [out] */ BOOL *pfModuleInfo,
            /* [out] */ BOOL *pfTextInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetComponentSize )( 
            IIsdbDownloadContentDescriptor * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetDownloadId )( 
            IIsdbDownloadContentDescriptor * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimeOutValueDII )( 
            IIsdbDownloadContentDescriptor * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLeakRate )( 
            IIsdbDownloadContentDescriptor * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetComponentTag )( 
            IIsdbDownloadContentDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompatiblityDescriptorLength )( 
            IIsdbDownloadContentDescriptor * This,
            /* [out] */ WORD *pwLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompatiblityDescriptor )( 
            IIsdbDownloadContentDescriptor * This,
            /* [out] */ BYTE **ppbData);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IIsdbDownloadContentDescriptor * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordModuleId )( 
            IIsdbDownloadContentDescriptor * This,
            /* [in] */ WORD wRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordModuleSize )( 
            IIsdbDownloadContentDescriptor * This,
            /* [in] */ WORD wRecordIndex,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordModuleInfoLength )( 
            IIsdbDownloadContentDescriptor * This,
            /* [in] */ WORD wRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordModuleInfo )( 
            IIsdbDownloadContentDescriptor * This,
            /* [in] */ WORD wRecordIndex,
            /* [out] */ BYTE **ppbData);
        
        HRESULT ( STDMETHODCALLTYPE *GetTextLanguageCode )( 
            IIsdbDownloadContentDescriptor * This,
            /* [annotation][out] */ 
            __out_ecount(4)  char *szCode);
        
        HRESULT ( STDMETHODCALLTYPE *GetTextW )( 
            IIsdbDownloadContentDescriptor * This,
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrName);
        
        END_INTERFACE
    } IIsdbDownloadContentDescriptorVtbl;

    interface IIsdbDownloadContentDescriptor
    {
        CONST_VTBL struct IIsdbDownloadContentDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIsdbDownloadContentDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IIsdbDownloadContentDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IIsdbDownloadContentDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IIsdbDownloadContentDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IIsdbDownloadContentDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IIsdbDownloadContentDescriptor_GetFlags(This,pfReboot,pfAddOn,pfCompatibility,pfModuleInfo,pfTextInfo)	\
    ( (This)->lpVtbl -> GetFlags(This,pfReboot,pfAddOn,pfCompatibility,pfModuleInfo,pfTextInfo) ) 

#define IIsdbDownloadContentDescriptor_GetComponentSize(This,pdwVal)	\
    ( (This)->lpVtbl -> GetComponentSize(This,pdwVal) ) 

#define IIsdbDownloadContentDescriptor_GetDownloadId(This,pdwVal)	\
    ( (This)->lpVtbl -> GetDownloadId(This,pdwVal) ) 

#define IIsdbDownloadContentDescriptor_GetTimeOutValueDII(This,pdwVal)	\
    ( (This)->lpVtbl -> GetTimeOutValueDII(This,pdwVal) ) 

#define IIsdbDownloadContentDescriptor_GetLeakRate(This,pdwVal)	\
    ( (This)->lpVtbl -> GetLeakRate(This,pdwVal) ) 

#define IIsdbDownloadContentDescriptor_GetComponentTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetComponentTag(This,pbVal) ) 

#define IIsdbDownloadContentDescriptor_GetCompatiblityDescriptorLength(This,pwLength)	\
    ( (This)->lpVtbl -> GetCompatiblityDescriptorLength(This,pwLength) ) 

#define IIsdbDownloadContentDescriptor_GetCompatiblityDescriptor(This,ppbData)	\
    ( (This)->lpVtbl -> GetCompatiblityDescriptor(This,ppbData) ) 

#define IIsdbDownloadContentDescriptor_GetCountOfRecords(This,pwVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pwVal) ) 

#define IIsdbDownloadContentDescriptor_GetRecordModuleId(This,wRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetRecordModuleId(This,wRecordIndex,pwVal) ) 

#define IIsdbDownloadContentDescriptor_GetRecordModuleSize(This,wRecordIndex,pdwVal)	\
    ( (This)->lpVtbl -> GetRecordModuleSize(This,wRecordIndex,pdwVal) ) 

#define IIsdbDownloadContentDescriptor_GetRecordModuleInfoLength(This,wRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetRecordModuleInfoLength(This,wRecordIndex,pbVal) ) 

#define IIsdbDownloadContentDescriptor_GetRecordModuleInfo(This,wRecordIndex,ppbData)	\
    ( (This)->lpVtbl -> GetRecordModuleInfo(This,wRecordIndex,ppbData) ) 

#define IIsdbDownloadContentDescriptor_GetTextLanguageCode(This,szCode)	\
    ( (This)->lpVtbl -> GetTextLanguageCode(This,szCode) ) 

#define IIsdbDownloadContentDescriptor_GetTextW(This,convMode,pbstrName)	\
    ( (This)->lpVtbl -> GetTextW(This,convMode,pbstrName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IIsdbDownloadContentDescriptor_INTERFACE_DEFINED__ */


#ifndef __IIsdbLogoTransmissionDescriptor_INTERFACE_DEFINED__
#define __IIsdbLogoTransmissionDescriptor_INTERFACE_DEFINED__

/* interface IIsdbLogoTransmissionDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IIsdbLogoTransmissionDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E0103F49-4AE1-4F07-9098-756DB1FA88CD")
    IIsdbLogoTransmissionDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLogoTransmissionType( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLogoId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLogoVersion( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDownloadDataId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLogoCharW( 
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrChar) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIsdbLogoTransmissionDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIsdbLogoTransmissionDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIsdbLogoTransmissionDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIsdbLogoTransmissionDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IIsdbLogoTransmissionDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IIsdbLogoTransmissionDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLogoTransmissionType )( 
            IIsdbLogoTransmissionDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLogoId )( 
            IIsdbLogoTransmissionDescriptor * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLogoVersion )( 
            IIsdbLogoTransmissionDescriptor * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetDownloadDataId )( 
            IIsdbLogoTransmissionDescriptor * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLogoCharW )( 
            IIsdbLogoTransmissionDescriptor * This,
            /* [in] */ DVB_STRCONV_MODE convMode,
            /* [out] */ BSTR *pbstrChar);
        
        END_INTERFACE
    } IIsdbLogoTransmissionDescriptorVtbl;

    interface IIsdbLogoTransmissionDescriptor
    {
        CONST_VTBL struct IIsdbLogoTransmissionDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIsdbLogoTransmissionDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IIsdbLogoTransmissionDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IIsdbLogoTransmissionDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IIsdbLogoTransmissionDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IIsdbLogoTransmissionDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IIsdbLogoTransmissionDescriptor_GetLogoTransmissionType(This,pbVal)	\
    ( (This)->lpVtbl -> GetLogoTransmissionType(This,pbVal) ) 

#define IIsdbLogoTransmissionDescriptor_GetLogoId(This,pwVal)	\
    ( (This)->lpVtbl -> GetLogoId(This,pwVal) ) 

#define IIsdbLogoTransmissionDescriptor_GetLogoVersion(This,pwVal)	\
    ( (This)->lpVtbl -> GetLogoVersion(This,pwVal) ) 

#define IIsdbLogoTransmissionDescriptor_GetDownloadDataId(This,pwVal)	\
    ( (This)->lpVtbl -> GetDownloadDataId(This,pwVal) ) 

#define IIsdbLogoTransmissionDescriptor_GetLogoCharW(This,convMode,pbstrChar)	\
    ( (This)->lpVtbl -> GetLogoCharW(This,convMode,pbstrChar) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IIsdbLogoTransmissionDescriptor_INTERFACE_DEFINED__ */


#ifndef __IIsdbSIParameterDescriptor_INTERFACE_DEFINED__
#define __IIsdbSIParameterDescriptor_INTERFACE_DEFINED__

/* interface IIsdbSIParameterDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IIsdbSIParameterDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F837DC36-867C-426a-9111-F62093951A45")
    IIsdbSIParameterDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParameterVersion( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUpdateTime( 
            /* [out] */ MPEG_DATE *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordNumberOfTable( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTableId( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTableDescriptionLength( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTableDescriptionBytes( 
            /* [in] */ BYTE bRecordIndex,
            /* [out][in] */ BYTE *pbBufferLength,
            /* [out] */ BYTE *pbBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIsdbSIParameterDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIsdbSIParameterDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIsdbSIParameterDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIsdbSIParameterDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IIsdbSIParameterDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IIsdbSIParameterDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetParameterVersion )( 
            IIsdbSIParameterDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetUpdateTime )( 
            IIsdbSIParameterDescriptor * This,
            /* [out] */ MPEG_DATE *pVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordNumberOfTable )( 
            IIsdbSIParameterDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTableId )( 
            IIsdbSIParameterDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTableDescriptionLength )( 
            IIsdbSIParameterDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTableDescriptionBytes )( 
            IIsdbSIParameterDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out][in] */ BYTE *pbBufferLength,
            /* [out] */ BYTE *pbBuffer);
        
        END_INTERFACE
    } IIsdbSIParameterDescriptorVtbl;

    interface IIsdbSIParameterDescriptor
    {
        CONST_VTBL struct IIsdbSIParameterDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIsdbSIParameterDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IIsdbSIParameterDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IIsdbSIParameterDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IIsdbSIParameterDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IIsdbSIParameterDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IIsdbSIParameterDescriptor_GetParameterVersion(This,pbVal)	\
    ( (This)->lpVtbl -> GetParameterVersion(This,pbVal) ) 

#define IIsdbSIParameterDescriptor_GetUpdateTime(This,pVal)	\
    ( (This)->lpVtbl -> GetUpdateTime(This,pVal) ) 

#define IIsdbSIParameterDescriptor_GetRecordNumberOfTable(This,pbVal)	\
    ( (This)->lpVtbl -> GetRecordNumberOfTable(This,pbVal) ) 

#define IIsdbSIParameterDescriptor_GetTableId(This,bRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetTableId(This,bRecordIndex,pbVal) ) 

#define IIsdbSIParameterDescriptor_GetTableDescriptionLength(This,bRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetTableDescriptionLength(This,bRecordIndex,pbVal) ) 

#define IIsdbSIParameterDescriptor_GetTableDescriptionBytes(This,bRecordIndex,pbBufferLength,pbBuffer)	\
    ( (This)->lpVtbl -> GetTableDescriptionBytes(This,bRecordIndex,pbBufferLength,pbBuffer) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IIsdbSIParameterDescriptor_INTERFACE_DEFINED__ */


#ifndef __IIsdbEmergencyInformationDescriptor_INTERFACE_DEFINED__
#define __IIsdbEmergencyInformationDescriptor_INTERFACE_DEFINED__

/* interface IIsdbEmergencyInformationDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IIsdbEmergencyInformationDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BA6FA681-B973-4da1-9207-AC3E7F0341EB")
    IIsdbEmergencyInformationDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServiceId( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStartEndFlag( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSignalLevel( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAreaCode( 
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD **ppwVal,
            /* [out] */ BYTE *pbNumAreaCodes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIsdbEmergencyInformationDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIsdbEmergencyInformationDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIsdbEmergencyInformationDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIsdbEmergencyInformationDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IIsdbEmergencyInformationDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IIsdbEmergencyInformationDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IIsdbEmergencyInformationDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceId )( 
            IIsdbEmergencyInformationDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetStartEndFlag )( 
            IIsdbEmergencyInformationDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSignalLevel )( 
            IIsdbEmergencyInformationDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetAreaCode )( 
            IIsdbEmergencyInformationDescriptor * This,
            /* [in] */ BYTE bRecordIndex,
            /* [out] */ WORD **ppwVal,
            /* [out] */ BYTE *pbNumAreaCodes);
        
        END_INTERFACE
    } IIsdbEmergencyInformationDescriptorVtbl;

    interface IIsdbEmergencyInformationDescriptor
    {
        CONST_VTBL struct IIsdbEmergencyInformationDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIsdbEmergencyInformationDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IIsdbEmergencyInformationDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IIsdbEmergencyInformationDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IIsdbEmergencyInformationDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IIsdbEmergencyInformationDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IIsdbEmergencyInformationDescriptor_GetCountOfRecords(This,pbVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pbVal) ) 

#define IIsdbEmergencyInformationDescriptor_GetServiceId(This,bRecordIndex,pwVal)	\
    ( (This)->lpVtbl -> GetServiceId(This,bRecordIndex,pwVal) ) 

#define IIsdbEmergencyInformationDescriptor_GetStartEndFlag(This,bRecordIndex,pVal)	\
    ( (This)->lpVtbl -> GetStartEndFlag(This,bRecordIndex,pVal) ) 

#define IIsdbEmergencyInformationDescriptor_GetSignalLevel(This,bRecordIndex,pbVal)	\
    ( (This)->lpVtbl -> GetSignalLevel(This,bRecordIndex,pbVal) ) 

#define IIsdbEmergencyInformationDescriptor_GetAreaCode(This,bRecordIndex,ppwVal,pbNumAreaCodes)	\
    ( (This)->lpVtbl -> GetAreaCode(This,bRecordIndex,ppwVal,pbNumAreaCodes) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IIsdbEmergencyInformationDescriptor_INTERFACE_DEFINED__ */


#ifndef __IIsdbCADescriptor_INTERFACE_DEFINED__
#define __IIsdbCADescriptor_INTERFACE_DEFINED__

/* interface IIsdbCADescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IIsdbCADescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0570AA47-52BC-42ae-8CA5-969F41E81AEA")
    IIsdbCADescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCASystemId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReservedBits( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCAPID( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrivateDataBytes( 
            /* [out][in] */ BYTE *pbBufferLength,
            /* [out] */ BYTE *pbBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIsdbCADescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIsdbCADescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIsdbCADescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIsdbCADescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IIsdbCADescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IIsdbCADescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCASystemId )( 
            IIsdbCADescriptor * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetReservedBits )( 
            IIsdbCADescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCAPID )( 
            IIsdbCADescriptor * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateDataBytes )( 
            IIsdbCADescriptor * This,
            /* [out][in] */ BYTE *pbBufferLength,
            /* [out] */ BYTE *pbBuffer);
        
        END_INTERFACE
    } IIsdbCADescriptorVtbl;

    interface IIsdbCADescriptor
    {
        CONST_VTBL struct IIsdbCADescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIsdbCADescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IIsdbCADescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IIsdbCADescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IIsdbCADescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IIsdbCADescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IIsdbCADescriptor_GetCASystemId(This,pwVal)	\
    ( (This)->lpVtbl -> GetCASystemId(This,pwVal) ) 

#define IIsdbCADescriptor_GetReservedBits(This,pbVal)	\
    ( (This)->lpVtbl -> GetReservedBits(This,pbVal) ) 

#define IIsdbCADescriptor_GetCAPID(This,pwVal)	\
    ( (This)->lpVtbl -> GetCAPID(This,pwVal) ) 

#define IIsdbCADescriptor_GetPrivateDataBytes(This,pbBufferLength,pbBuffer)	\
    ( (This)->lpVtbl -> GetPrivateDataBytes(This,pbBufferLength,pbBuffer) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IIsdbCADescriptor_INTERFACE_DEFINED__ */


#ifndef __IIsdbCAServiceDescriptor_INTERFACE_DEFINED__
#define __IIsdbCAServiceDescriptor_INTERFACE_DEFINED__

/* interface IIsdbCAServiceDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IIsdbCAServiceDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("39CBEB97-FF0B-42a7-9AB9-7B9CFE70A77A")
    IIsdbCAServiceDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCASystemId( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCABroadcasterGroupId( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMessageControl( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServiceIds( 
            /* [out][in] */ BYTE *pbNumServiceIds,
            /* [out] */ WORD *pwServiceIds) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIsdbCAServiceDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIsdbCAServiceDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIsdbCAServiceDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIsdbCAServiceDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IIsdbCAServiceDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IIsdbCAServiceDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCASystemId )( 
            IIsdbCAServiceDescriptor * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCABroadcasterGroupId )( 
            IIsdbCAServiceDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetMessageControl )( 
            IIsdbCAServiceDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceIds )( 
            IIsdbCAServiceDescriptor * This,
            /* [out][in] */ BYTE *pbNumServiceIds,
            /* [out] */ WORD *pwServiceIds);
        
        END_INTERFACE
    } IIsdbCAServiceDescriptorVtbl;

    interface IIsdbCAServiceDescriptor
    {
        CONST_VTBL struct IIsdbCAServiceDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIsdbCAServiceDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IIsdbCAServiceDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IIsdbCAServiceDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IIsdbCAServiceDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IIsdbCAServiceDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IIsdbCAServiceDescriptor_GetCASystemId(This,pwVal)	\
    ( (This)->lpVtbl -> GetCASystemId(This,pwVal) ) 

#define IIsdbCAServiceDescriptor_GetCABroadcasterGroupId(This,pbVal)	\
    ( (This)->lpVtbl -> GetCABroadcasterGroupId(This,pbVal) ) 

#define IIsdbCAServiceDescriptor_GetMessageControl(This,pbVal)	\
    ( (This)->lpVtbl -> GetMessageControl(This,pbVal) ) 

#define IIsdbCAServiceDescriptor_GetServiceIds(This,pbNumServiceIds,pwServiceIds)	\
    ( (This)->lpVtbl -> GetServiceIds(This,pbNumServiceIds,pwServiceIds) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IIsdbCAServiceDescriptor_INTERFACE_DEFINED__ */


#ifndef __IIsdbHierarchicalTransmissionDescriptor_INTERFACE_DEFINED__
#define __IIsdbHierarchicalTransmissionDescriptor_INTERFACE_DEFINED__

/* interface IIsdbHierarchicalTransmissionDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IIsdbHierarchicalTransmissionDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B7B3AE90-EE0B-446d-8769-F7E2AA266AA6")
    IIsdbHierarchicalTransmissionDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFutureUse1( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetQualityLevel( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFutureUse2( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReferencePid( 
            /* [out] */ WORD *pwVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIsdbHierarchicalTransmissionDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIsdbHierarchicalTransmissionDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIsdbHierarchicalTransmissionDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIsdbHierarchicalTransmissionDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IIsdbHierarchicalTransmissionDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IIsdbHierarchicalTransmissionDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetFutureUse1 )( 
            IIsdbHierarchicalTransmissionDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetQualityLevel )( 
            IIsdbHierarchicalTransmissionDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetFutureUse2 )( 
            IIsdbHierarchicalTransmissionDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetReferencePid )( 
            IIsdbHierarchicalTransmissionDescriptor * This,
            /* [out] */ WORD *pwVal);
        
        END_INTERFACE
    } IIsdbHierarchicalTransmissionDescriptorVtbl;

    interface IIsdbHierarchicalTransmissionDescriptor
    {
        CONST_VTBL struct IIsdbHierarchicalTransmissionDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIsdbHierarchicalTransmissionDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IIsdbHierarchicalTransmissionDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IIsdbHierarchicalTransmissionDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IIsdbHierarchicalTransmissionDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IIsdbHierarchicalTransmissionDescriptor_GetLength(This,pbVal)	\
    ( (This)->lpVtbl -> GetLength(This,pbVal) ) 

#define IIsdbHierarchicalTransmissionDescriptor_GetFutureUse1(This,pbVal)	\
    ( (This)->lpVtbl -> GetFutureUse1(This,pbVal) ) 

#define IIsdbHierarchicalTransmissionDescriptor_GetQualityLevel(This,pbVal)	\
    ( (This)->lpVtbl -> GetQualityLevel(This,pbVal) ) 

#define IIsdbHierarchicalTransmissionDescriptor_GetFutureUse2(This,pbVal)	\
    ( (This)->lpVtbl -> GetFutureUse2(This,pbVal) ) 

#define IIsdbHierarchicalTransmissionDescriptor_GetReferencePid(This,pwVal)	\
    ( (This)->lpVtbl -> GetReferencePid(This,pwVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IIsdbHierarchicalTransmissionDescriptor_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dvbsiparser_0000_0065 */
/* [local] */ 

#define COMPONENT_TAG_CAPTION_MIN            0x30
#define COMPONENT_TAG_CAPTION_MAX            0x37
#define COMPONENT_TAG_SUPERIMPOSE_MIN        0x38
#define COMPONENT_TAG_SUPERIMPOSE_MAX        0x3F




extern RPC_IF_HANDLE __MIDL_itf_dvbsiparser_0000_0065_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dvbsiparser_0000_0065_v0_0_s_ifspec;

#ifndef __IPBDASiParser_INTERFACE_DEFINED__
#define __IPBDASiParser_INTERFACE_DEFINED__

/* interface IPBDASiParser */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IPBDASiParser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9DE49A74-ABA2-4a18-93E1-21F17F95C3C3")
    IPBDASiParser : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IUnknown *punk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEIT( 
            /* [in] */ DWORD dwSize,
            /* [in] */ BYTE *pBuffer,
            /* [out] */ IPBDA_EIT **ppEIT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServices( 
            /* [in] */ DWORD dwSize,
            /* [in] */ const BYTE *pBuffer,
            /* [out] */ IPBDA_Services **ppServices) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPBDASiParserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPBDASiParser * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPBDASiParser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPBDASiParser * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IPBDASiParser * This,
            /* [in] */ IUnknown *punk);
        
        HRESULT ( STDMETHODCALLTYPE *GetEIT )( 
            IPBDASiParser * This,
            /* [in] */ DWORD dwSize,
            /* [in] */ BYTE *pBuffer,
            /* [out] */ IPBDA_EIT **ppEIT);
        
        HRESULT ( STDMETHODCALLTYPE *GetServices )( 
            IPBDASiParser * This,
            /* [in] */ DWORD dwSize,
            /* [in] */ const BYTE *pBuffer,
            /* [out] */ IPBDA_Services **ppServices);
        
        END_INTERFACE
    } IPBDASiParserVtbl;

    interface IPBDASiParser
    {
        CONST_VTBL struct IPBDASiParserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPBDASiParser_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPBDASiParser_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPBDASiParser_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPBDASiParser_Initialize(This,punk)	\
    ( (This)->lpVtbl -> Initialize(This,punk) ) 

#define IPBDASiParser_GetEIT(This,dwSize,pBuffer,ppEIT)	\
    ( (This)->lpVtbl -> GetEIT(This,dwSize,pBuffer,ppEIT) ) 

#define IPBDASiParser_GetServices(This,dwSize,pBuffer,ppServices)	\
    ( (This)->lpVtbl -> GetServices(This,dwSize,pBuffer,ppServices) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPBDASiParser_INTERFACE_DEFINED__ */


#ifndef __IPBDA_EIT_INTERFACE_DEFINED__
#define __IPBDA_EIT_INTERFACE_DEFINED__

/* interface IPBDA_EIT */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IPBDA_EIT;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A35F2DEA-098F-4ebd-984C-2BD4C3C8CE0A")
    IPBDA_EIT : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ DWORD size,
            /* [size_is][in] */ const BYTE *pBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTableId( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionNumber( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServiceIdx( 
            /* [out] */ ULONG64 *plwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordEventId( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ ULONG64 *plwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordStartTime( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ MPEG_DATE_AND_TIME *pmdtVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDuration( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ MPEG_DURATION *pmdVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordCountOfDescriptors( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptorByIndex( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordDescriptorByTag( 
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [out][in] */ DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPBDA_EITVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPBDA_EIT * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPBDA_EIT * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPBDA_EIT * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IPBDA_EIT * This,
            /* [in] */ DWORD size,
            /* [size_is][in] */ const BYTE *pBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *GetTableId )( 
            IPBDA_EIT * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionNumber )( 
            IPBDA_EIT * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceIdx )( 
            IPBDA_EIT * This,
            /* [out] */ ULONG64 *plwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IPBDA_EIT * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordEventId )( 
            IPBDA_EIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ ULONG64 *plwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordStartTime )( 
            IPBDA_EIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ MPEG_DATE_AND_TIME *pmdtVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDuration )( 
            IPBDA_EIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ MPEG_DURATION *pmdVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordCountOfDescriptors )( 
            IPBDA_EIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByIndex )( 
            IPBDA_EIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordDescriptorByTag )( 
            IPBDA_EIT * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [in] */ BYTE bTag,
            /* [out][in] */ DWORD *pdwCookie,
            /* [out] */ IGenericDescriptor **ppDescriptor);
        
        END_INTERFACE
    } IPBDA_EITVtbl;

    interface IPBDA_EIT
    {
        CONST_VTBL struct IPBDA_EITVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPBDA_EIT_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPBDA_EIT_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPBDA_EIT_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPBDA_EIT_Initialize(This,size,pBuffer)	\
    ( (This)->lpVtbl -> Initialize(This,size,pBuffer) ) 

#define IPBDA_EIT_GetTableId(This,pbVal)	\
    ( (This)->lpVtbl -> GetTableId(This,pbVal) ) 

#define IPBDA_EIT_GetVersionNumber(This,pwVal)	\
    ( (This)->lpVtbl -> GetVersionNumber(This,pwVal) ) 

#define IPBDA_EIT_GetServiceIdx(This,plwVal)	\
    ( (This)->lpVtbl -> GetServiceIdx(This,plwVal) ) 

#define IPBDA_EIT_GetCountOfRecords(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pdwVal) ) 

#define IPBDA_EIT_GetRecordEventId(This,dwRecordIndex,plwVal)	\
    ( (This)->lpVtbl -> GetRecordEventId(This,dwRecordIndex,plwVal) ) 

#define IPBDA_EIT_GetRecordStartTime(This,dwRecordIndex,pmdtVal)	\
    ( (This)->lpVtbl -> GetRecordStartTime(This,dwRecordIndex,pmdtVal) ) 

#define IPBDA_EIT_GetRecordDuration(This,dwRecordIndex,pmdVal)	\
    ( (This)->lpVtbl -> GetRecordDuration(This,dwRecordIndex,pmdVal) ) 

#define IPBDA_EIT_GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal)	\
    ( (This)->lpVtbl -> GetRecordCountOfDescriptors(This,dwRecordIndex,pdwVal) ) 

#define IPBDA_EIT_GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByIndex(This,dwRecordIndex,dwIndex,ppDescriptor) ) 

#define IPBDA_EIT_GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor)	\
    ( (This)->lpVtbl -> GetRecordDescriptorByTag(This,dwRecordIndex,bTag,pdwCookie,ppDescriptor) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPBDA_EIT_INTERFACE_DEFINED__ */


#ifndef __IPBDA_Services_INTERFACE_DEFINED__
#define __IPBDA_Services_INTERFACE_DEFINED__

/* interface IPBDA_Services */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IPBDA_Services;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("944EAB37-EED4-4850-AFD2-77E7EFEB4427")
    IPBDA_Services : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ DWORD size,
            /* [size_is][in] */ BYTE *pBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCountOfRecords( 
            /* [out] */ DWORD *pdwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordByIndex( 
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ ULONG64 *pul64ServiceIdx) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPBDA_ServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPBDA_Services * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPBDA_Services * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPBDA_Services * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IPBDA_Services * This,
            /* [in] */ DWORD size,
            /* [size_is][in] */ BYTE *pBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *GetCountOfRecords )( 
            IPBDA_Services * This,
            /* [out] */ DWORD *pdwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordByIndex )( 
            IPBDA_Services * This,
            /* [in] */ DWORD dwRecordIndex,
            /* [out] */ ULONG64 *pul64ServiceIdx);
        
        END_INTERFACE
    } IPBDA_ServicesVtbl;

    interface IPBDA_Services
    {
        CONST_VTBL struct IPBDA_ServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPBDA_Services_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPBDA_Services_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPBDA_Services_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPBDA_Services_Initialize(This,size,pBuffer)	\
    ( (This)->lpVtbl -> Initialize(This,size,pBuffer) ) 

#define IPBDA_Services_GetCountOfRecords(This,pdwVal)	\
    ( (This)->lpVtbl -> GetCountOfRecords(This,pdwVal) ) 

#define IPBDA_Services_GetRecordByIndex(This,dwRecordIndex,pul64ServiceIdx)	\
    ( (This)->lpVtbl -> GetRecordByIndex(This,dwRecordIndex,pul64ServiceIdx) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPBDA_Services_INTERFACE_DEFINED__ */


#ifndef __IPBDAEntitlementDescriptor_INTERFACE_DEFINED__
#define __IPBDAEntitlementDescriptor_INTERFACE_DEFINED__

/* interface IPBDAEntitlementDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IPBDAEntitlementDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("22632497-0DE3-4587-AADC-D8D99017E760")
    IPBDAEntitlementDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetToken( 
            /* [out] */ BYTE **ppbTokenBuffer,
            /* [out] */ DWORD *pdwTokenLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPBDAEntitlementDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPBDAEntitlementDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPBDAEntitlementDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPBDAEntitlementDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IPBDAEntitlementDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IPBDAEntitlementDescriptor * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetToken )( 
            IPBDAEntitlementDescriptor * This,
            /* [out] */ BYTE **ppbTokenBuffer,
            /* [out] */ DWORD *pdwTokenLength);
        
        END_INTERFACE
    } IPBDAEntitlementDescriptorVtbl;

    interface IPBDAEntitlementDescriptor
    {
        CONST_VTBL struct IPBDAEntitlementDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPBDAEntitlementDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPBDAEntitlementDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPBDAEntitlementDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPBDAEntitlementDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IPBDAEntitlementDescriptor_GetLength(This,pwVal)	\
    ( (This)->lpVtbl -> GetLength(This,pwVal) ) 

#define IPBDAEntitlementDescriptor_GetToken(This,ppbTokenBuffer,pdwTokenLength)	\
    ( (This)->lpVtbl -> GetToken(This,ppbTokenBuffer,pdwTokenLength) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPBDAEntitlementDescriptor_INTERFACE_DEFINED__ */


#ifndef __IPBDAAttributesDescriptor_INTERFACE_DEFINED__
#define __IPBDAAttributesDescriptor_INTERFACE_DEFINED__

/* interface IPBDAAttributesDescriptor */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IPBDAAttributesDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("313B3620-3263-45a6-9533-968BEFBEAC03")
    IPBDAAttributesDescriptor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTag( 
            /* [out] */ BYTE *pbVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ WORD *pwVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributePayload( 
            /* [out] */ BYTE **ppbAttributeBuffer,
            /* [out] */ DWORD *pdwAttributeLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPBDAAttributesDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPBDAAttributesDescriptor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPBDAAttributesDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPBDAAttributesDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IPBDAAttributesDescriptor * This,
            /* [out] */ BYTE *pbVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            IPBDAAttributesDescriptor * This,
            /* [out] */ WORD *pwVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributePayload )( 
            IPBDAAttributesDescriptor * This,
            /* [out] */ BYTE **ppbAttributeBuffer,
            /* [out] */ DWORD *pdwAttributeLength);
        
        END_INTERFACE
    } IPBDAAttributesDescriptorVtbl;

    interface IPBDAAttributesDescriptor
    {
        CONST_VTBL struct IPBDAAttributesDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPBDAAttributesDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPBDAAttributesDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPBDAAttributesDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPBDAAttributesDescriptor_GetTag(This,pbVal)	\
    ( (This)->lpVtbl -> GetTag(This,pbVal) ) 

#define IPBDAAttributesDescriptor_GetLength(This,pwVal)	\
    ( (This)->lpVtbl -> GetLength(This,pwVal) ) 

#define IPBDAAttributesDescriptor_GetAttributePayload(This,ppbAttributeBuffer,pdwAttributeLength)	\
    ( (This)->lpVtbl -> GetAttributePayload(This,ppbAttributeBuffer,pdwAttributeLength) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPBDAAttributesDescriptor_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\DvObj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:       dvobj.h
//
//----------------------------------------------------------------------------

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef RC_INVOKED
#pragma message("WARNING: your code should include ole2.h instead of dvobj.h")
#endif /* !RC_INVOKED */

#include <ole2.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dvdevcod.h ===
//------------------------------------------------------------------------------
// File: DVDevCod.h
//
// Desc: List of standard DVD-Video event codes and the expected params.
//
// Copyright (c) 1992 - 2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------

#ifndef __DVDEVCOD__
#define __DVDEVCOD__


#define EC_DVDBASE                          0x0100

#ifndef EXCLUDE_DVDEVCODE_ENUMS

typedef enum _tagDVD_ERROR {
    DVD_ERROR_Unexpected=1,         // Something unexpected happened, perhaps content
                                    //   is incorrectly authored.  Playback is stopped.
    DVD_ERROR_CopyProtectFail=2,    // Key exchange for DVD copy protection failed. 
                                    //   Playback is stopped.
    DVD_ERROR_InvalidDVD1_0Disc=3,  // DVD-Video disc is incorrectly authored for v1.0 
                                    //   of spec. Playback is stopped.
    DVD_ERROR_InvalidDiscRegion=4,  // The Disc cannot be played because the disc is not
                                    // authored to play in system region.
                                    // The region mismatch may be fixable by 
                                    // changing the system region with dvdrgn.exe
    DVD_ERROR_LowParentalLevel=5,   // Player parental level is lower than the lowest parental
                                    //   level available in the DVD content. Playback is stopped.
    DVD_ERROR_MacrovisionFail=6,    // Macrovision Distribution Failed.
                                    // Playback is stopped.
    DVD_ERROR_IncompatibleSystemAndDecoderRegions=7,
                                    // No discs can be played because the system region
                                    // does not match the decoder region.
    DVD_ERROR_IncompatibleDiscAndDecoderRegions=8,
                                    // The disc cannot be played because the disc is
                                    // not authored to be played in the decoder's region
    DVD_ERROR_CopyProtectOutputFail=9,  // DVD copy protection failed due to output display
    DVD_ERROR_CopyProtectOutputNotSupported=10,  // DVD copy protection failed due to lack of driver
                                    // support for checking the output display
} DVD_ERROR;

typedef enum _tagDVD_WARNING {
    DVD_WARNING_InvalidDVD1_0Disc=1,// DVD-Video disc is incorrectly authored. Playback
                                    //   can continue, but unexpected behavior may occur.
    DVD_WARNING_FormatNotSupported=2,// A decoder would not support the current format.  Playback
                                    //   of a stream (audio, video of SP) may not function.
                                    //   lParam2 contains the stream type (see AM_DVD_STREAM_FLAGS)
    DVD_WARNING_IllegalNavCommand=3,// The internal DVD navigation command processor attempted to 
                                    //   process an illegal command.
    DVD_WARNING_Open = 4,           // File Open Failed
    DVD_WARNING_Seek = 5,           // File Seek Failed
    DVD_WARNING_Read = 6            // File Read Failed
} DVD_WARNING;

typedef enum _tagDVD_PB_STOPPED {
    DVD_PB_STOPPED_Other=0,                 // The navigator stopped the playback (no reason available).
    DVD_PB_STOPPED_NoBranch=1,              // The nav completed the current pgc and there was no more video and
                                            // did not find any other branching instruction for subsequent playback.
    DVD_PB_STOPPED_NoFirstPlayDomain =2,    // The disc does not contain an initial startup program.
    DVD_PB_STOPPED_StopCommand = 3,         // The app issued a stop() command or a stop command was authored on the disc.
    DVD_PB_STOPPED_Reset=4,                 // The navigator was reset to the start of the disc (using ResetOnStop).
    DVD_PB_STOPPED_DiscEjected=5,           // The disc was ejected.
    DVD_PB_STOPPED_IllegalNavCommand = 6,   // An illegal nav command prevented playback from continuing.
    DVD_PB_STOPPED_PlayPeriodAutoStop = 7,  // PlayPeriod completed
    DVD_PB_STOPPED_PlayChapterAutoStop = 8, // PlayChapter completed
    DVD_PB_STOPPED_ParentalFailure = 9,     // A parental level failure prevented playback
    DVD_PB_STOPPED_RegionFailure = 10,      // A region failure prevented playback
    DVD_PB_STOPPED_MacrovisionFailure = 11, // A Macrovision failure prevented playback.
    DVD_PB_STOPPED_DiscReadError = 12,      // A read error prevented playback.
    DVD_PB_STOPPED_CopyProtectFailure = 13, // Copy protection failure.
    DVD_PB_STOPPED_CopyProtectOutputFailure = 14, // Copy protection failure due to non-compliant output device
    DVD_PB_STOPPED_CopyProtectOutputNotSupported = 15 // Copy protection failure due to missing driver support to check
                                            // output device
} DVD_PB_STOPPED;


#endif

// DVD-Video event codes
// ======================
//
// All DVD-Video event are always passed on to the application, and are 
// never processed by the filter graph


#define EC_DVD_DOMAIN_CHANGE                    (EC_DVDBASE + 0x01)
// Parameters: ( DWORD, void ) 
// lParam1 is enum DVD_DOMAIN, and indicates the player's new domain
//
// Raised from following domains: all
//
// Signaled when ever the DVD player changes domains.


#define EC_DVD_TITLE_CHANGE                     (EC_DVDBASE + 0x02)
// Parameters: ( DWORD, void ) 
// lParam1 is the new title number.
//
// Raised from following domains: DVD_DOMAIN_Title
//
// Indicates when the current title number changes.  Title numbers
// range 1 to 99.  This indicates the TTN, which is the title number
// with respect to the whole disc, not the VTS_TTN which is the title
// number with respect to just a current VTS.


#define EC_DVD_CHAPTER_START                   (EC_DVDBASE + 0x03)
// Parameters: ( DWORD, void ) 
// lParam1 is the new chapter number (which is the program number for 
// One_Sequential_PGC_Titles).
//
// Raised from following domains: DVD_DOMAIN_Title
//
// Signales that DVD player started playback of a new program in the Title 
// domain.  This is only signaled for One_Sequential_PGC_Titles.


#define EC_DVD_AUDIO_STREAM_CHANGE              (EC_DVDBASE + 0x04)
// Parameters: ( DWORD, void ) 
// lParam1 is the new user audio stream number.
//
// Raised from following domains: all
//
// Signaled when ever the current user audio stream number changes for the main 
// title.  This can be changed automatically with a navigation command on disc
// as well as through IDVDAnnexJ.
// Audio stream numbers range from 0 to 7.  Stream 0xffffffff
// indicates that no stream is selected.

#define EC_DVD_SUBPICTURE_STREAM_CHANGE         (EC_DVDBASE + 0x05)
// Parameters: ( DWORD, BOOL ) 
// lParam1 is the new user subpicture stream number.
// lParam2 is the subpicture's on/off state (TRUE if on)
//
// Raised from following domains: all
//
// Signaled when ever the current user subpicture stream number changes for the main 
// title.  This can be changed automatically with a navigation command on disc
// as well as through IDVDAnnexJ.  
// Subpicture stream numbers range from 0 to 31.  Stream 0xffffffff
// indicates that no stream is selected.  

#define EC_DVD_ANGLE_CHANGE                     (EC_DVDBASE + 0x06)
// Parameters: ( DWORD, DWORD ) 
// lParam1 is the number of available angles.
// lParam2 is the current user angle number.
//
// Raised from following domains: all
//
// Signaled when ever either 
//   a) the number of available angles changes, or  
//   b) the current user angle number changes.
// Current angle number can be changed automatically with navigation command 
// on disc as well as through IDVDAnnexJ.
// When the number of available angles is 1, the current video is not multiangle.
// Angle numbers range from 1 to 9.


#define EC_DVD_BUTTON_CHANGE                    (EC_DVDBASE + 0x07)
// Parameters: ( DWORD, DWORD ) 
// lParam1 is the number of available buttons.
// lParam2 is the current selected button number.
//
// Raised from following domains: all
//
// Signaled when ever either 
//   a) the number of available buttons changes, or  
//   b) the current selected button number changes.
// The current selected button can be changed automatically with navigation 
// commands on disc as well as through IDVDAnnexJ.  
// Button numbers range from 1 to 36.  Selected button number 0 implies that
// no button is selected.  Note that these button numbers enumerate all 
// available button numbers, and do not always correspond to button numbers
// used for IDVDAnnexJ::ButtonSelectAndActivate since only a subset of buttons
// may be activated with ButtonSelectAndActivate.


#define EC_DVD_VALID_UOPS_CHANGE                (EC_DVDBASE + 0x08)
// Parameters: ( DWORD, void ) 
// lParam1 is a VALID_UOP_SOMTHING_OR_OTHER bit-field stuct which indicates
//   which IDVDAnnexJ commands are explicitly disable by the DVD disc.
//
// Raised from following domains: all
//
// Signaled when ever the available set of IDVDAnnexJ methods changes.  This
// only indicates which operations are explicited disabled by the content on 
// the DVD disc, and does not guarentee that it is valid to call methods 
// which are not disabled.  For example, if no buttons are currently present,
// IDVDAnnexJ::ButtonActivate() won't work, even though the buttons are not
// explicitly disabled. 


#define EC_DVD_STILL_ON                         (EC_DVDBASE + 0x09)
// Parameters: ( BOOL, DWORD ) 
// lParam1 == 0  -->  buttons are available, so StillOff won't work
// lParam1 == 1  -->  no buttons available, so StillOff will work
// lParam2 indicates the number of seconds the still will last, with 0xffffffff 
//   indicating an infinite still (wait till button or StillOff selected).
//
// Raised from following domains: all
//
// Signaled at the beginning of any still: PGC still, Cell Still, or VOBU Still.
// Note that all combinations of buttons and still are possible (buttons on with
// still on, buttons on with still off, button off with still on, button off
// with still off).

#define EC_DVD_STILL_OFF                         (EC_DVDBASE + 0x0a)
// Parameters: ( void, void ) 
//
//   Indicating that any still that is currently active
//   has been released.
//
// Raised from following domains: all
//
// Signaled at the end of any still: PGC still, Cell Still, or VOBU Still.
//

#define EC_DVD_CURRENT_TIME                     (EC_DVDBASE + 0x0b)
// Parameters: ( DWORD, BOOL ) 
// lParam1 is a DVD_TIMECODE which indicates the current 
//   playback time code in a BCD HH:MM:SS:FF format.
// lParam2 == 0  -->  time code is 25 frames/sec
// lParam2 == 1  -->  time code is 30 frames/sec (non-drop).
// lParam2 == 2  -->  time code is invalid (current playback time 
//                    cannot be determined for current title)
//
// Raised from following domains: DVD_DOMAIN_Title
//
// Signaled at the beginning of every VOBU, which occurs every .4 to 1.0 sec.
// This is only signaled for One_Sequential_PGC_Titles.


#define EC_DVD_ERROR                            (EC_DVDBASE + 0x0c)
// Parameters: ( DWORD, void) 
// lParam1 is an enum DVD_ERROR which notifies the app of some error condition.
//
// Raised from following domains: all
//

#define EC_DVD_WARNING                           (EC_DVDBASE + 0x0d)
// Parameters: ( DWORD, DWORD) 
// lParam1 is an enum DVD_WARNING which notifies the app of some warning condition.
// lParam2 contains more specific information about the warning (warning dependent)
//
// Raised from following domains: all
//

#define EC_DVD_CHAPTER_AUTOSTOP                  (EC_DVDBASE + 0x0e)
// Parameters: (BOOL, void)
// lParam1 is a BOOL which indicates the reason for the cancellation of ChapterPlayAutoStop
// lParam1 == 0 indicates successful completion of ChapterPlayAutoStop
// lParam1 == 1 indicates that ChapterPlayAutoStop is being cancelled as a result of another
//            IDVDControl call or the end of content has been reached & no more chapters
//            can be played.
//  Indicating that playback is stopped as a result of a call
//  to IDVDControl::ChapterPlayAutoStop()
//
// Raised from following domains : DVD_DOMAIN_TITLE
//

#define EC_DVD_NO_FP_PGC                         (EC_DVDBASE + 0x0f)
//  Parameters : (void, void)
//
//  Raised from the following domains : FP_DOM
//
//  Indicates that the DVD disc does not have a FP_PGC (First Play Program Chain)
//  and the DVD Navigator will not automatically load any PGC and start playback.
//

#define EC_DVD_PLAYBACK_RATE_CHANGE              (EC_DVDBASE + 0x10)
//  Parameters : (LONG, void)
//  lParam1 is a LONG indicating the new playback rate.
//  lParam1 < 0 indicates reverse playback mode.
//  lParam1 > 0 indicates forward playback mode
//  Value of lParam1 is the actual playback rate multiplied by 10000.
//  i.e. lParam1 = rate * 10000
//
//  Raised from the following domains : TT_DOM
//
//  Indicates that a rate change in playback has been initiated and the parameter
//  lParam1 indicates the new playback rate that is being used.
//

#define EC_DVD_PARENTAL_LEVEL_CHANGE            (EC_DVDBASE + 0x11)
//  Parameters : (LONG, void)
//  lParam1 is a LONG indicating the new parental level.
//
//  Raised from the following domains : VMGM_DOM
//
//  Indicates that an authored Nav command has changed the parental level
//  setting in the player.
//

#define EC_DVD_PLAYBACK_STOPPED                 (EC_DVDBASE + 0x12)
//  Parameters : (DWORD, void)
//
//  Raised from the following domains : All Domains
//
// Indicates that playback has been stopped as the Navigator has completed
// playback of the pgc and did not find any other branching instruction for
// subsequent playback.
//
//  The DWORD returns the reason for the completion of the playback.  See
//  The DVD_PB_STOPPED enumeration for details.
//

#define EC_DVD_ANGLES_AVAILABLE                 (EC_DVDBASE + 0x13)
//  Parameters : (BOOL, void)
//  lParam1 == 0 indicates that playback is not in an angle block and angles are
//             not available
//  lParam1 == 1 indicates that an angle block is being played back and angle changes
//             can be performed.
//
//  Indicates whether an angle block is being played and if angle changes can be 
//  performed. However, angle changes are not restricted to angle blocks and the
//  manifestation of the angle change can be seen only in an angle block.

#define EC_DVD_PLAYPERIOD_AUTOSTOP              (EC_DVDBASE + 0x14)
// Parameters: (void, void)
// Sent when the PlayPeriodInTitle completes or is cancelled
//
// Raised from following domains : DVD_DOMAIN_TITLE
//

#define EC_DVD_BUTTON_AUTO_ACTIVATED                 (EC_DVDBASE + 0x15)
// Parameters: (DWORD button, void)
// Sent when a button is automatically activated
//
// Raised from following domains : DVD_DOMAIN_MENU
//

#define EC_DVD_CMD_START                 (EC_DVDBASE + 0x16)
// Parameters: (CmdID, HRESULT)
// Sent when a command begins
//

#define EC_DVD_CMD_END                 (EC_DVDBASE + 0x17)
// Parameters: (CmdID, HRESULT)
// Sent when a command completes
//

#define EC_DVD_DISC_EJECTED                (EC_DVDBASE + 0x18)
// Parameters: none
// Sent when the nav detects that a disc was ejected and stops the playback
// The app does not need to take any action to stop the playback.
//

#define EC_DVD_DISC_INSERTED                (EC_DVDBASE + 0x19)
// Parameters: none
// Sent when the nav detects that a disc was inserted and the nav begins playback
// The app does not need to take any action to start the playback.
//

#define EC_DVD_CURRENT_HMSF_TIME                     (EC_DVDBASE + 0x1a)
// Parameters: ( ULONG, ULONG ) 
// lParam2 contains a union of the DVD_TIMECODE_FLAGS
// lParam1 contains a DVD_HMSF_TIMECODE.  Assign lParam1 to a ULONG then cast the
// ULONG as a DVD_HMSF_TIMECODE to use its values.
//
// Raised from following domains: DVD_DOMAIN_Title
//
// Signaled at the beginning of every VOBU, which occurs every .4 to 1.0 sec.

#define EC_DVD_KARAOKE_MODE                     (EC_DVDBASE + 0x1b)
// Parameters: ( BOOL, reserved ) 
// lParam1 is either TRUE (a karaoke track is being played) or FALSE (no karaoke data is being played).
//

#define EC_DVD_PROGRAM_CELL_CHANGE              (EC_DVDBASE + 0x1c)
// Parameters: ( ULONG, ULONG )
// Sent when current program ID and/or cell ID change
// lParam1 contains the new Program ID
// lParam2 contains the new Cell ID

#define EC_DVD_TITLE_SET_CHANGE                 (EC_DVDBASE + 0x1d)
// Parameters: ( BYTE, void )
// Sent when current VTS (Video Title Set) changes
// lParam1 contains the new VTSN (Video Title Set Number)

#define EC_DVD_PROGRAM_CHAIN_CHANGE             (EC_DVDBASE + 0x1e)
// Parameters: ( WORD, void )
// Sent when current PGC (Program Chain) changes
// lParam1 contains the new PGCN (Program Chain Number)

#define EC_DVD_VOBU_Offset                     (EC_DVDBASE + 0x1f)
// Parameters: ( BlockOffset, VTSN ) 
// lParam1 is the block offset of the most recent VOBU.
//

#define EC_DVD_VOBU_Timestamp                  (EC_DVDBASE + 0x20)
// Parameters: ( rtTimestamp.LowPart, rtTimeStamps.HighPart ) 
// lParam1 is the dshow timestamp of the most recent VOBU.
//

#define EC_DVD_GPRM_Change                     (EC_DVDBASE + 0x21)
// Parameters: ( GPRM index, GPRM value ) 
// lParam1 is the GPRM index
// loword(lParam2) is the new GPRM value, hiword(lParam2) is type
//

#define EC_DVD_SPRM_Change                     (EC_DVDBASE + 0x22)
// Parameters: ( SPRM index, SPRM value ) 
// lParam1 is the SPRM index
// loword(lParam2) is the new SPRM value, hiword(lParam2) is type
//

#define EC_DVD_BeginNavigationCommands         (EC_DVDBASE + 0x23)
// Parameters: ( command type, reserved ) 
// Sent when navigation commands are starting
//

#define EC_DVD_NavigationCommand               (EC_DVDBASE + 0x24)
// Parameters: ( cmd.LowPart, cmd.HighPart ) 
// 64 bits of DVD navigation command.
//

#endif // __DVDEVCOD__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dwmapi.h ===
/*=========================================================================*\

    Copyright (c) Microsoft Corporation.  All rights reserved.

    File: dwmapi.h

    Module Name: dwmapi

    Description: DWM API declarations

\*=========================================================================*/
#ifndef _DWMAPI_H_
#define _DWMAPI_H_


#ifndef DWMAPI
#if !defined(_DWMAPI_)
#define DWMAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define DWMAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#else
#define DWMAPI          STDAPI
#define DWMAPI_(type)   STDAPI_(type)
#endif /* _DWMAPI_ */
#endif /* DWMAPI */

#ifdef __cplusplus
extern "C"
{
#endif


#ifndef MILCORE_KERNEL_COMPONENT
#include <wtypes.h>
#include <uxtheme.h>
#endif

#include <pshpack1.h>

// Blur behind data structures
#define DWM_BB_ENABLE                 0x00000001  // fEnable has been specified
#define DWM_BB_BLURREGION             0x00000002  // hRgnBlur has been specified
#define DWM_BB_TRANSITIONONMAXIMIZED  0x00000004  // fTransitionOnMaximized has been specified

typedef struct _DWM_BLURBEHIND
{
    DWORD dwFlags;
    BOOL fEnable;
    HRGN hRgnBlur;
    BOOL fTransitionOnMaximized;
} DWM_BLURBEHIND, *PDWM_BLURBEHIND;

// Window attributes
enum DWMWINDOWATTRIBUTE
{
    DWMWA_NCRENDERING_ENABLED = 1,      // [get] Is non-client rendering enabled/disabled
    DWMWA_NCRENDERING_POLICY,           // [set] Non-client rendering policy
    DWMWA_TRANSITIONS_FORCEDISABLED,    // [set] Potentially enable/forcibly disable transitions
    DWMWA_ALLOW_NCPAINT,                // [set] Allow contents rendered in the non-client area to be visible on the DWM-drawn frame.
    DWMWA_CAPTION_BUTTON_BOUNDS,        // [get] Bounds of the caption button area in window-relative space.
    DWMWA_NONCLIENT_RTL_LAYOUT,         // [set] Is non-client content RTL mirrored
    DWMWA_FORCE_ICONIC_REPRESENTATION,  // [set] Force this window to display iconic thumbnails.
    DWMWA_FLIP3D_POLICY,                // [set] Designates how Flip3D will treat the window.
    DWMWA_EXTENDED_FRAME_BOUNDS,        // [get] Gets the extended frame bounds rectangle in screen space
    DWMWA_HAS_ICONIC_BITMAP,            // [set] Indicates an available bitmap when there is no better thumbnail representation.
    DWMWA_DISALLOW_PEEK,                // [set] Don't invoke Peek on the window.
    DWMWA_EXCLUDED_FROM_PEEK,           // [set] LivePreview exclusion information
    DWMWA_LAST
};

// Non-client rendering policy attribute values
enum DWMNCRENDERINGPOLICY
{
    DWMNCRP_USEWINDOWSTYLE, // Enable/disable non-client rendering based on window style
    DWMNCRP_DISABLED,       // Disabled non-client rendering; window style is ignored
    DWMNCRP_ENABLED,        // Enabled non-client rendering; window style is ignored
    DWMNCRP_LAST
};

// Values designating how Flip3D treats a given window.
enum DWMFLIP3DWINDOWPOLICY
{
    DWMFLIP3D_DEFAULT,      // Hide or include the window in Flip3D based on window style and visibility.
    DWMFLIP3D_EXCLUDEBELOW, // Display the window under Flip3D and disabled.
    DWMFLIP3D_EXCLUDEABOVE, // Display the window above Flip3D and enabled.
    DWMFLIP3D_LAST
};


// Thumbnails
typedef HANDLE HTHUMBNAIL;
typedef HTHUMBNAIL* PHTHUMBNAIL;

#define DWM_TNP_RECTDESTINATION       0x00000001
#define DWM_TNP_RECTSOURCE            0x00000002
#define DWM_TNP_OPACITY               0x00000004
#define DWM_TNP_VISIBLE               0x00000008
#define DWM_TNP_SOURCECLIENTAREAONLY  0x00000010

typedef struct _DWM_THUMBNAIL_PROPERTIES
{
    DWORD dwFlags;
    RECT rcDestination;
    RECT rcSource;
    BYTE opacity;
    BOOL fVisible;
    BOOL fSourceClientAreaOnly;
} DWM_THUMBNAIL_PROPERTIES, *PDWM_THUMBNAIL_PROPERTIES;

// Video enabling apis

typedef ULONGLONG DWM_FRAME_COUNT;
typedef ULONGLONG QPC_TIME;

typedef  struct _UNSIGNED_RATIO
{
    UINT32 uiNumerator;
    UINT32 uiDenominator;
} UNSIGNED_RATIO;

typedef  struct _DWM_TIMING_INFO
{
    UINT32          cbSize;

    // Data on DWM composition overall
    
    // Monitor refresh rate
    UNSIGNED_RATIO  rateRefresh;

    // Actual period
    QPC_TIME        qpcRefreshPeriod;

    // composition rate     
    UNSIGNED_RATIO  rateCompose;

    // QPC time at a VSync interupt
    QPC_TIME        qpcVBlank;

    // DWM refresh count of the last vsync
    // DWM refresh count is a 64bit number where zero is
    // the first refresh the DWM woke up to process
    DWM_FRAME_COUNT cRefresh;

    // DX refresh count at the last Vsync Interupt
    // DX refresh count is a 32bit number with zero 
    // being the first refresh after the card was initialized
    // DX increments a counter when ever a VSync ISR is processed
    // It is possible for DX to miss VSyncs
    //
    // There is not a fixed mapping between DX and DWM refresh counts
    // because the DX will rollover and may miss VSync interupts
    UINT cDXRefresh;

    // QPC time at a compose time.  
    QPC_TIME        qpcCompose;

    // Frame number that was composed at qpcCompose
    DWM_FRAME_COUNT cFrame;

    // The present number DX uses to identify renderer frames
    UINT            cDXPresent;

    // Refresh count of the frame that was composed at qpcCompose
    DWM_FRAME_COUNT cRefreshFrame;


    // DWM frame number that was last submitted
    DWM_FRAME_COUNT cFrameSubmitted;

    // DX Present number that was last submitted
    UINT cDXPresentSubmitted;

    // DWM frame number that was last confirmed presented
    DWM_FRAME_COUNT cFrameConfirmed;

    // DX Present number that was last confirmed presented
    UINT cDXPresentConfirmed;

    // The target refresh count of the last
    // frame confirmed completed by the GPU
    DWM_FRAME_COUNT cRefreshConfirmed;

    // DX refresh count when the frame was confirmed presented
    UINT cDXRefreshConfirmed;

    // Number of frames the DWM presented late
    // AKA Glitches
    DWM_FRAME_COUNT          cFramesLate;
    
    // the number of composition frames that 
    // have been issued but not confirmed completed
    UINT          cFramesOutstanding;


    // Following fields are only relavent when an HWND is specified
    // Display frame


    // Last frame displayed
    DWM_FRAME_COUNT cFrameDisplayed;

    // QPC time of the composition pass when the frame was displayed
    QPC_TIME        qpcFrameDisplayed; 

    // Count of the VSync when the frame should have become visible
    DWM_FRAME_COUNT cRefreshFrameDisplayed;

    // Complete frames: DX has notified the DWM that the frame is done rendering

    // ID of the the last frame marked complete (starts at 0)
    DWM_FRAME_COUNT cFrameComplete;

    // QPC time when the last frame was marked complete
    QPC_TIME        qpcFrameComplete;

    // Pending frames:
    // The application has been submitted to DX but not completed by the GPU
 
    // ID of the the last frame marked pending (starts at 0)
    DWM_FRAME_COUNT cFramePending;

    // QPC time when the last frame was marked pending
    QPC_TIME        qpcFramePending;

    // number of unique frames displayed
    DWM_FRAME_COUNT cFramesDisplayed;

    // number of new completed frames that have been received
    DWM_FRAME_COUNT cFramesComplete;

     // number of new frames submitted to DX but not yet complete
    DWM_FRAME_COUNT cFramesPending;

    // number of frames available but not displayed, used or dropped
    DWM_FRAME_COUNT cFramesAvailable;

    // number of rendered frames that were never
    // displayed because composition occured too late
    DWM_FRAME_COUNT cFramesDropped;
    
    // number of times an old frame was composed 
    // when a new frame should have been used
    // but was not available
    DWM_FRAME_COUNT cFramesMissed;
    
    // the refresh at which the next frame is
    // scheduled to be displayed
    DWM_FRAME_COUNT cRefreshNextDisplayed;

    // the refresh at which the next DX present is 
    // scheduled to be displayed
    DWM_FRAME_COUNT cRefreshNextPresented;

    // The total number of refreshes worth of content
    // for this HWND that have been displayed by the DWM
    // since DwmSetPresentParameters was called
    DWM_FRAME_COUNT cRefreshesDisplayed;
	
    // The total number of refreshes worth of content
    // that have been presented by the application
    // since DwmSetPresentParameters was called
    DWM_FRAME_COUNT cRefreshesPresented;


    // The actual refresh # when content for this
    // window started to be displayed
    // it may be different than that requested
    // DwmSetPresentParameters
    DWM_FRAME_COUNT cRefreshStarted;

    // Total number of pixels DX redirected
    // to the DWM.
    // If Queueing is used the full buffer
    // is transfered on each present.
    // If not queuing it is possible only 
    // a dirty region is updated
    ULONGLONG  cPixelsReceived;

    // Total number of pixels drawn.
    // Does not take into account if
    // if the window is only partial drawn
    // do to clipping or dirty rect management 
    ULONGLONG  cPixelsDrawn;

    // The number of buffers in the flipchain
    // that are empty.   An application can 
    // present that number of times and guarantee 
    // it won't be blocked waiting for a buffer to 
    // become empty to present to
    DWM_FRAME_COUNT      cBuffersEmpty;

} DWM_TIMING_INFO;

typedef enum 
{
    // Use the first source frame that 
    // includes the first refresh of the output frame
    DWM_SOURCE_FRAME_SAMPLING_POINT,

    // use the source frame that includes the most 
    // refreshes of out the output frame
    // in case of multiple source frames with the 
    // same coverage the last will be used
    DWM_SOURCE_FRAME_SAMPLING_COVERAGE,

       // Sentinel value
    DWM_SOURCE_FRAME_SAMPLING_LAST
} DWM_SOURCE_FRAME_SAMPLING;

static const UINT c_DwmMaxQueuedBuffers = 8;
static const UINT c_DwmMaxMonitors = 16;
static const UINT c_DwmMaxAdapters = 16;

#pragma warning(push)
#pragma warning(disable:4201)
typedef struct _DWM_PRESENT_PARAMETERS
{
    UINT32          cbSize;
    BOOL            fQueue;
    DWM_FRAME_COUNT cRefreshStart;
    UINT            cBuffer;
    BOOL            fUseSourceRate;
    UNSIGNED_RATIO  rateSource;
    UINT            cRefreshesPerFrame;
    DWM_SOURCE_FRAME_SAMPLING  eSampling;
} DWM_PRESENT_PARAMETERS;
#pragma warning(pop)



#define DWM_FRAME_DURATION_DEFAULT -1

DWMAPI_(BOOL)
DwmDefWindowProc(
    __in HWND hWnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam,
    __out LRESULT *plResult
    );

DWMAPI 
DwmEnableBlurBehindWindow(
    HWND hWnd, 
    __in const DWM_BLURBEHIND* pBlurBehind
    );

#define DWM_EC_DISABLECOMPOSITION         0
#define DWM_EC_ENABLECOMPOSITION          1


DWMAPI 
DwmEnableComposition(
    UINT uCompositionAction
    );

DWMAPI  
DwmEnableMMCSS(
    BOOL fEnableMMCSS
    );

DWMAPI 
DwmExtendFrameIntoClientArea(
    HWND hWnd,
    __in const MARGINS* pMarInset
    );
    
DWMAPI
DwmGetColorizationColor(
    __out DWORD* pcrColorization,
    __out BOOL* pfOpaqueBlend
    );

DWMAPI
DwmGetCompositionTimingInfo(
    HWND hwnd,
    __out DWM_TIMING_INFO* pTimingInfo
    );


DWMAPI
DwmGetWindowAttribute(
    HWND hwnd,
    DWORD dwAttribute,
    __out_bcount(cbAttribute) PVOID pvAttribute, 
    DWORD cbAttribute
    );

DWMAPI 
DwmIsCompositionEnabled(
    __out BOOL* pfEnabled
    );

DWMAPI
DwmModifyPreviousDxFrameDuration(
    HWND hwnd, 
    INT cRefreshes,
    BOOL fRelative
    );

DWMAPI
DwmQueryThumbnailSourceSize(
    HTHUMBNAIL hThumbnail, 
    __out PSIZE pSize
    );

DWMAPI
DwmRegisterThumbnail(
    HWND hwndDestination, 
    HWND hwndSource, 
    __out PHTHUMBNAIL phThumbnailId
    );

DWMAPI
DwmSetDxFrameDuration(
    HWND hwnd, 
    INT cRefreshes
    );

DWMAPI
DwmSetPresentParameters(
    HWND hwnd,
   __inout DWM_PRESENT_PARAMETERS* pPresentParams
    );

DWMAPI
DwmSetWindowAttribute(
    HWND hwnd,
    DWORD dwAttribute,
    __in_bcount(cbAttribute) LPCVOID pvAttribute, 
    DWORD cbAttribute
    );

DWMAPI
DwmUnregisterThumbnail(
    HTHUMBNAIL hThumbnailId
    );

DWMAPI
DwmUpdateThumbnailProperties(
    HTHUMBNAIL hThumbnailId, 
    __in const DWM_THUMBNAIL_PROPERTIES* ptnProperties
    );

#if(_WIN32_WINNT >= 0x0601)
#define DWM_SIT_DISPLAYFRAME    0x00000001  // Display a window frame around the provided bitmap

DWMAPI DwmSetIconicThumbnail(
    HWND hwnd,
    HBITMAP hbmp,
    DWORD dwSITFlags
    );

DWMAPI DwmSetIconicLivePreviewBitmap(
    HWND hwnd,
    HBITMAP hbmp,
    __in_opt POINT *pptClient,
    DWORD dwSITFlags
    );

DWMAPI DwmInvalidateIconicBitmaps(
    HWND hwnd
    );

#endif /* _WIN32_WINNT >= 0x0601 */

DWMAPI
DwmAttachMilContent(
    __in HWND hwnd
    );

DWMAPI
DwmDetachMilContent(
    __in HWND hwnd
    );

DWMAPI
DwmFlush();

#ifndef MILCORE_KERNEL_COMPONENT
#ifndef _MIL_MATRIX3X2D_DEFINED

typedef struct _MilMatrix3x2D
{
    DOUBLE S_11;
    DOUBLE S_12;
    DOUBLE S_21;
    DOUBLE S_22;
    DOUBLE DX;
    DOUBLE DY;
} MilMatrix3x2D;

#define _MIL_MATRIX3X2D_DEFINED

#endif // _MIL_MATRIX3X2D_DEFINED

#ifndef MILCORE_MIL_MATRIX3X2D_COMPAT_TYPEDEF
// Compatibility for Vista dwm api.
typedef MilMatrix3x2D MIL_MATRIX3X2D;
#define MILCORE_MIL_MATRIX3X2D_COMPAT_TYPEDEF
#endif MILCORE_MIL_MATRIX3X2D_COMPAT_TYPEDEF


DWMAPI
DwmGetGraphicsStreamTransformHint(
    UINT uIndex,
    __out MilMatrix3x2D *pTransform
    );

DWMAPI
DwmGetGraphicsStreamClient(
    UINT uIndex,
    __out UUID *pClientUuid
    );
#endif // MILCORE_KERNEL_COMPONENT

DWMAPI
DwmGetTransportAttributes(
    __out_ecount(1) BOOL *pfIsRemoting,
    __out_ecount(1) BOOL *pfIsConnected,
    __out_ecount(1) DWORD *pDwGeneration
    );



#include <poppack.h>

#ifdef __cplusplus
}
#endif


#endif // _DWMAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dvdmedia.h ===
//------------------------------------------------------------------------------
// File: DVDMedia.h
//
// Desc: Contains typedefs and defines necessary for user mode (ring 3) DVD
//       filters and applications.
//
//       This should be included in the DirectShow SDK for user mode filters.
//       The types defined here should be kept in synch with ksmedia.h WDM
//       DDK for kernel mode filters.
//
// Copyright (c) 1997 - 2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __DVDMEDIA_H__
#define __DVDMEDIA_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// -----------------------------------------------------------------------
// AC-3 definition for the AM_KSPROPSETID_AC3 property set
// -----------------------------------------------------------------------

typedef enum {
    AM_PROPERTY_AC3_ERROR_CONCEALMENT = 1,
    AM_PROPERTY_AC3_ALTERNATE_AUDIO = 2,
    AM_PROPERTY_AC3_DOWNMIX = 3,
    AM_PROPERTY_AC3_BIT_STREAM_MODE = 4,
    AM_PROPERTY_AC3_DIALOGUE_LEVEL = 5,
    AM_PROPERTY_AC3_LANGUAGE_CODE = 6,
    AM_PROPERTY_AC3_ROOM_TYPE = 7
} AM_PROPERTY_AC3;

typedef struct  {
    BOOL        fRepeatPreviousBlock;
    BOOL        fErrorInCurrentBlock;
} AM_AC3_ERROR_CONCEALMENT, *PAM_AC3_ERROR_CONCEALMENT;

typedef struct {
    BOOL    fStereo;
    ULONG   DualMode;
} AM_AC3_ALTERNATE_AUDIO, *PAM_AC3_ALTERNATE_AUDIO;

#define AM_AC3_ALTERNATE_AUDIO_1     1
#define AM_AC3_ALTERNATE_AUDIO_2     2
#define AM_AC3_ALTERNATE_AUDIO_BOTH  3

typedef struct {
    BOOL        fDownMix;
    BOOL        fDolbySurround;
} AM_AC3_DOWNMIX, *PAM_AC3_DOWNMIX;

typedef struct {
    LONG        BitStreamMode;
} AM_AC3_BIT_STREAM_MODE, *PAM_AC3_BIT_STREAM_MODE;

#define AM_AC3_SERVICE_MAIN_AUDIO            0
#define AM_AC3_SERVICE_NO_DIALOG             1
#define AM_AC3_SERVICE_VISUALLY_IMPAIRED     2
#define AM_AC3_SERVICE_HEARING_IMPAIRED      3
#define AM_AC3_SERVICE_DIALOG_ONLY           4
#define AM_AC3_SERVICE_COMMENTARY            5
#define AM_AC3_SERVICE_EMERGENCY_FLASH       6
#define AM_AC3_SERVICE_VOICE_OVER            7

typedef struct {
    ULONG   DialogueLevel;
} AM_AC3_DIALOGUE_LEVEL, *PAM_AC3_DIALOGUE_LEVEL;

typedef struct {
    BOOL    fLargeRoom;
} AM_AC3_ROOM_TYPE, *PAM_AC3_ROOM_TYPE;


// -----------------------------------------------------------------------
// subpicture definition for the AM_KSPROPSETID_DvdSubPic property set
// -----------------------------------------------------------------------

typedef enum {
    AM_PROPERTY_DVDSUBPIC_PALETTE = 0,
    AM_PROPERTY_DVDSUBPIC_HLI = 1,
    AM_PROPERTY_DVDSUBPIC_COMPOSIT_ON = 2  // TRUE for subpicture is displayed
} AM_PROPERTY_DVDSUBPIC;

typedef struct _AM_DVD_YUV {
    UCHAR   Reserved;
    UCHAR   Y;
    UCHAR   U;
    UCHAR   V;
} AM_DVD_YUV, *PAM_DVD_YUV;

typedef struct _AM_PROPERTY_SPPAL {
    AM_DVD_YUV sppal[16];
} AM_PROPERTY_SPPAL, *PAM_PROPERTY_SPPAL;

typedef struct _AM_COLCON {
    UCHAR emph1col:4;
    UCHAR emph2col:4;
    UCHAR backcol:4;
    UCHAR patcol:4;
    UCHAR emph1con:4;
    UCHAR emph2con:4;
    UCHAR backcon:4;
    UCHAR patcon:4;

} AM_COLCON, *PAM_COLCON;

typedef struct _AM_PROPERTY_SPHLI {
    USHORT     HLISS;      //
    USHORT     Reserved;
    ULONG      StartPTM;   // start presentation time in x/90000
    ULONG      EndPTM;     // end PTM in x/90000
    USHORT     StartX;
    USHORT     StartY;
    USHORT     StopX;
    USHORT     StopY;
    AM_COLCON  ColCon;     // color contrast description (4 bytes as given in HLI)
} AM_PROPERTY_SPHLI, *PAM_PROPERTY_SPHLI;

typedef BOOL AM_PROPERTY_COMPOSIT_ON, *PAM_PROPERTY_COMPOSIT_ON;



// -----------------------------------------------------------------------
// copy protection definitions
// -----------------------------------------------------------------------

// AM_UseNewCSSKey for the dwTypeSpecificFlags in IMediaSample2 to indicate
// the exact point in a stream after which to start applying a new CSS key.
// This is typically sent on an empty media sample just before attempting
// to renegotiate a CSS key.
#define AM_UseNewCSSKey       0x1

#define AM_ReverseBlockStart  0x2
#define AM_ReverseBlockEnd    0x4


//
// AM_KSPROPSETID_CopyProt property set definitions
//
typedef enum {
    AM_PROPERTY_DVDCOPY_CHLG_KEY = 0x01,
    AM_PROPERTY_DVDCOPY_DVD_KEY1 = 0x02,
    AM_PROPERTY_DVDCOPY_DEC_KEY2 = 0x03,
    AM_PROPERTY_DVDCOPY_TITLE_KEY = 0x04,
    AM_PROPERTY_COPY_MACROVISION = 0x05,
    AM_PROPERTY_DVDCOPY_REGION = 0x06,
    AM_PROPERTY_DVDCOPY_SET_COPY_STATE = 0x07,
    AM_PROPERTY_COPY_ANALOG_COMPONENT = 0x08, // GetOnly property, return data is a BOOL
    AM_PROPERTY_COPY_DIGITAL_CP =   0x09, 
    AM_PROPERTY_COPY_DVD_SRM =          0x0a,
    AM_PROPERTY_DVDCOPY_SUPPORTS_NEW_KEYCOUNT = 0x0b,    // read only, BOOL
    // gap
    AM_PROPERTY_DVDCOPY_DISC_KEY = 0x80
} AM_PROPERTY_DVDCOPYPROT;

typedef enum _AM_DIGITAL_CP {
    AM_DIGITAL_CP_OFF = 0,
    AM_DIGITAL_CP_ON = 1,
    AM_DIGITAL_CP_DVD_COMPLIANT = 2
} AM_DIGITAL_CP;

typedef struct _AM_DVDCOPY_CHLGKEY {
    BYTE ChlgKey[10];
    BYTE Reserved[2];
} AM_DVDCOPY_CHLGKEY, *PAM_DVDCOPY_CHLGKEY;

typedef struct _AM_DVDCOPY_BUSKEY {
    BYTE BusKey[5];
    BYTE Reserved[1];
} AM_DVDCOPY_BUSKEY, *PAM_DVDCOPY_BUSKEY;

typedef struct _AM_DVDCOPY_DISCKEY {
    BYTE DiscKey[2048];
} AM_DVDCOPY_DISCKEY, *PAM_DVDCOPY_DISCKEY;

typedef struct AM_DVDCOPY_TITLEKEY {
    ULONG KeyFlags;
    ULONG Reserved1[2];
    UCHAR TitleKey[6];
    UCHAR Reserved2[2];
} AM_DVDCOPY_TITLEKEY, *PAM_DVDCOPY_TITLEKEY;

typedef struct _AM_COPY_MACROVISION {
    ULONG MACROVISIONLevel;
} AM_COPY_MACROVISION, *PAM_COPY_MACROVISION;

typedef struct AM_DVDCOPY_SET_COPY_STATE {
    ULONG DVDCopyState;
} AM_DVDCOPY_SET_COPY_STATE, *PAM_DVDCOPY_SET_COPY_STATE;

typedef enum {
    AM_DVDCOPYSTATE_INITIALIZE = 0,
    AM_DVDCOPYSTATE_INITIALIZE_TITLE = 1,   // indicates we are starting a title
                                        // key copy protection sequence
    AM_DVDCOPYSTATE_AUTHENTICATION_NOT_REQUIRED = 2,
    AM_DVDCOPYSTATE_AUTHENTICATION_REQUIRED = 3,
    AM_DVDCOPYSTATE_DONE = 4
} AM_DVDCOPYSTATE;

typedef enum {
    AM_MACROVISION_DISABLED = 0,
    AM_MACROVISION_LEVEL1 = 1,
    AM_MACROVISION_LEVEL2 = 2,
    AM_MACROVISION_LEVEL3 = 3
} AM_COPY_MACROVISION_LEVEL, *PAM_COPY_MACROVISION_LEVEL;


// CSS region stucture
typedef struct _DVD_REGION {
    UCHAR CopySystem;
    UCHAR RegionData;
    UCHAR SystemRegion;
    UCHAR ResetCount;
} DVD_REGION, *PDVD_REGION;

//
// CGMS Copy Protection Flags
//

#define AM_DVD_CGMS_RESERVED_MASK      0x00000078

#define AM_DVD_CGMS_COPY_PROTECT_MASK  0x00000018
#define AM_DVD_CGMS_COPY_PERMITTED     0x00000000
#define AM_DVD_CGMS_COPY_ONCE          0x00000010
#define AM_DVD_CGMS_NO_COPY            0x00000018

#define AM_DVD_COPYRIGHT_MASK          0x00000040
#define AM_DVD_NOT_COPYRIGHTED         0x00000000
#define AM_DVD_COPYRIGHTED             0x00000040

#define AM_DVD_SECTOR_PROTECT_MASK     0x00000020
#define AM_DVD_SECTOR_NOT_PROTECTED    0x00000000
#define AM_DVD_SECTOR_PROTECTED        0x00000020


// -----------------------------------------------------------------------
// video format blocks
// -----------------------------------------------------------------------

enum AM_MPEG2Level {
    AM_MPEG2Level_Low = 1,
    AM_MPEG2Level_Main = 2,
    AM_MPEG2Level_High1440 = 3,
    AM_MPEG2Level_High = 4
};

enum AM_MPEG2Profile {
    AM_MPEG2Profile_Simple = 1,
    AM_MPEG2Profile_Main = 2,
    AM_MPEG2Profile_SNRScalable = 3,
    AM_MPEG2Profile_SpatiallyScalable = 4,
    AM_MPEG2Profile_High = 5
};

#define AMINTERLACE_IsInterlaced            0x00000001  // if 0, other interlace bits are irrelevent
#define AMINTERLACE_1FieldPerSample         0x00000002  // else 2 fields per media sample
#define AMINTERLACE_Field1First             0x00000004  // else Field 2 is first;  top field in PAL is field 1, top field in NTSC is field 2?
#define AMINTERLACE_UNUSED                  0x00000008  //
#define AMINTERLACE_FieldPatternMask        0x00000030  // use this mask with AMINTERLACE_FieldPat*
#define AMINTERLACE_FieldPatField1Only      0x00000000  // stream never contains a Field2
#define AMINTERLACE_FieldPatField2Only      0x00000010  // stream never contains a Field1
#define AMINTERLACE_FieldPatBothRegular     0x00000020  // There will be a Field2 for every Field1 (required for Weave?)
#define AMINTERLACE_FieldPatBothIrregular   0x00000030  // Random pattern of Field1s and Field2s
#define AMINTERLACE_DisplayModeMask         0x000000c0
#define AMINTERLACE_DisplayModeBobOnly      0x00000000
#define AMINTERLACE_DisplayModeWeaveOnly    0x00000040
#define AMINTERLACE_DisplayModeBobOrWeave   0x00000080

#define AMCOPYPROTECT_RestrictDuplication   0x00000001  // duplication of this stream should be restricted

#define AMMPEG2_DoPanScan           0x00000001  //if set, the MPEG-2 video decoder should crop output image
                        //  based on pan-scan vectors in picture_display_extension
                        //  and change the picture aspect ratio accordingly.
#define AMMPEG2_DVDLine21Field1     0x00000002  //if set, the MPEG-2 decoder must be able to produce an output
                        //  pin for DVD style closed caption data found in GOP layer of field 1
#define AMMPEG2_DVDLine21Field2     0x00000004  //if set, the MPEG-2 decoder must be able to produce an output
                        //  pin for DVD style closed caption data found in GOP layer of field 2
#define AMMPEG2_SourceIsLetterboxed 0x00000008  //if set, indicates that black bars have been encoded in the top
                        //  and bottom of the video.
#define AMMPEG2_FilmCameraMode      0x00000010  //if set, indicates "film mode" used for 625/50 content.  If cleared,
                        //  indicates that "camera mode" was used.
#define AMMPEG2_LetterboxAnalogOut  0x00000020  //if set and this stream is sent to an analog output, it should
                        //  be letterboxed.  Streams sent to VGA should be letterboxed only by renderers.
#define AMMPEG2_DSS_UserData        0x00000040  //if set, the MPEG-2 decoder must process DSS style user data
#define AMMPEG2_DVB_UserData        0x00000080  //if set, the MPEG-2 decoder must process DVB style user data
#define AMMPEG2_27MhzTimebase       0x00000100  //if set, the PTS,DTS timestamps advance at 27MHz rather than 90KHz

#define AMMPEG2_WidescreenAnalogOut 0x00000200  //if set and this stream is sent to an analog output, it should
                        //  be in widescreen format (4x3 content should be centered on a 16x9 output).
                        //  Streams sent to VGA should be widescreened only by renderers.

// PRESENT in dwReserved1 field in VIDEOINFOHEADER2
#define AMCONTROL_USED              0x00000001 // Used to test if these flags are supported.  Set and test for AcceptMediaType.
                                                // If rejected, then you cannot use the AMCONTROL flags (send 0 for dwReserved1)
#define AMCONTROL_PAD_TO_4x3        0x00000002 // if set means display the image in a 4x3 area
#define AMCONTROL_PAD_TO_16x9       0x00000004 // if set means display the image in a 16x9 area
#define AMCONTROL_COLORINFO_PRESENT 0x00000080 // if set, indicates DXVA color info is present in the upper (24) bits of the dwControlFlags

typedef struct tagVIDEOINFOHEADER2 {
    RECT                rcSource;
    RECT                rcTarget;
    DWORD               dwBitRate;
    DWORD               dwBitErrorRate;
    REFERENCE_TIME      AvgTimePerFrame;
    DWORD               dwInterlaceFlags;   // use AMINTERLACE_* defines. Reject connection if undefined bits are not 0
    DWORD               dwCopyProtectFlags; // use AMCOPYPROTECT_* defines. Reject connection if undefined bits are not 0
    DWORD               dwPictAspectRatioX; // X dimension of picture aspect ratio, e.g. 16 for 16x9 display
    DWORD               dwPictAspectRatioY; // Y dimension of picture aspect ratio, e.g.  9 for 16x9 display
    union {
        DWORD dwControlFlags;               // use AMCONTROL_* defines, use this from now on
        DWORD dwReserved1;                  // for backward compatiblity (was "must be 0";  connection rejected otherwise)
    };
    DWORD               dwReserved2;        // must be 0; reject connection otherwise
    BITMAPINFOHEADER    bmiHeader;
} VIDEOINFOHEADER2;

typedef struct tagMPEG2VIDEOINFO {
    VIDEOINFOHEADER2    hdr;
    DWORD               dwStartTimeCode;        //  ?? not used for DVD ??
    DWORD               cbSequenceHeader;       // is 0 for DVD (no sequence header)
    DWORD               dwProfile;              // use enum MPEG2Profile
    DWORD               dwLevel;                // use enum MPEG2Level
    DWORD               dwFlags;                // use AMMPEG2_* defines.  Reject connection if undefined bits are not 0
    DWORD               dwSequenceHeader[1];    // DWORD instead of Byte for alignment purposes
                                                //   For MPEG-2, if a sequence_header is included, the sequence_extension
                                                //   should also be included
} MPEG2VIDEOINFO;

#define SIZE_MPEG2VIDEOINFO(pv) (FIELD_OFFSET(MPEG2VIDEOINFO, dwSequenceHeader[0]) + (pv)->cbSequenceHeader)

// do not use
#define MPEG1_SEQUENCE_INFO(pv) ((const BYTE *)(pv)->bSequenceHeader)

// use this macro instead, the previous only works for MPEG1VIDEOINFO structures
#define MPEG2_SEQUENCE_INFO(pv) ((const BYTE *)(pv)->dwSequenceHeader)


//===================================================================================
// flags for dwTypeSpecificFlags in AM_SAMPLE2_PROPERTIES which define type specific
// data in IMediaSample2
//===================================================================================

#define AM_VIDEO_FLAG_FIELD_MASK        0x0003L // use this mask to check whether the sample is field1 or field2 or frame
#define AM_VIDEO_FLAG_INTERLEAVED_FRAME 0x0000L // the sample is a frame (remember to use AM_VIDEO_FLAG_FIELD_MASK when using this)
#define AM_VIDEO_FLAG_FIELD1            0x0001L // the sample is field1 (remember to use AM_VIDEO_FLAG_FIELD_MASK when using this)
#define AM_VIDEO_FLAG_FIELD2            0x0002L // the sample is the field2 (remember to use AM_VIDEO_FLAG_FIELD_MASK when using this)
#define AM_VIDEO_FLAG_FIELD1FIRST       0x0004L // if set means display field1 first, else display field2 first.
                                                // this bit is irrelavant for 1FieldPerSample mode
#define AM_VIDEO_FLAG_WEAVE             0x0008L // if set use bob display mode else weave
#define AM_VIDEO_FLAG_IPB_MASK          0x0030L // use this mask to check whether the sample is I, P or B
#define AM_VIDEO_FLAG_I_SAMPLE          0x0000L // I Sample (remember to use AM_VIDEO_FLAG_IPB_MASK when using this)
#define AM_VIDEO_FLAG_P_SAMPLE          0x0010L // P Sample (remember to use AM_VIDEO_FLAG_IPB_MASK when using this)
#define AM_VIDEO_FLAG_B_SAMPLE          0x0020L // B Sample (remember to use AM_VIDEO_FLAG_IPB_MASK when using this)
#define AM_VIDEO_FLAG_REPEAT_FIELD      0x0040L // if set means display the field which has been displayed first again after displaying
                                                // both fields first. This bit is irrelavant for 1FieldPerSample mode

// -----------------------------------------------------------------------
// AM_KSPROPSETID_DvdKaraoke property set definitions
// -----------------------------------------------------------------------

typedef struct tagAM_DvdKaraokeData
{
    DWORD   dwDownmix;              // bitwise OR of AM_DvdKaraoke_Downmix flags
    DWORD   dwSpeakerAssignment;    // AM_DvdKaraoke_SpeakerAssignment
} AM_DvdKaraokeData;

typedef enum {
    AM_PROPERTY_DVDKARAOKE_ENABLE = 0,  // BOOL
    AM_PROPERTY_DVDKARAOKE_DATA = 1,
} AM_PROPERTY_DVDKARAOKE;

// -----------------------------------------------------------------------
// AM_KSPROPSETID_TSRateChange property set definitions for time stamp
// rate changes.
// -----------------------------------------------------------------------

typedef enum {
    AM_RATE_SimpleRateChange = 1,    // rw, use AM_SimpleRateChange
    AM_RATE_ExactRateChange  = 2,    // rw, use AM_ExactRateChange
    AM_RATE_MaxFullDataRate  = 3,    // r,  use AM_MaxFullDataRate
    AM_RATE_Step             = 4,    // w,  use AM_Step
    AM_RATE_UseRateVersion   = 5,       //  w, use WORD
    AM_RATE_QueryFullFrameRate =6,      //  r, use AM_QueryRate
    AM_RATE_QueryLastRateSegPTS =7,     //  r, use REFERENCE_TIME
    AM_RATE_CorrectTS        = 8,    // w,  use LONG
    AM_RATE_ReverseMaxFullDataRate = 9,    // r,  use AM_MaxFullDataRate
    AM_RATE_ResetOnTimeDisc = 10,    // rw, use DWORD - indicates supports new 'timeline reset on time discontinuity' sample
    AM_RATE_QueryMapping    = 11
} AM_PROPERTY_TS_RATE_CHANGE;

// -------------------------------------------------------------------
// AM_KSPROPSETID_DVD_RateChange property set definitions for new DVD
// rate change scheme.
// -------------------------------------------------------------------

typedef enum {
    AM_RATE_ChangeRate       = 1,    // w,  use AM_DVD_ChangeRate
    AM_RATE_FullDataRateMax  = 2,    // r,  use AM_MaxFullDataRate
    AM_RATE_ReverseDecode    = 3,    // r,  use LONG
    AM_RATE_DecoderPosition  = 4,    // r,  use AM_DVD_DecoderPosition
    AM_RATE_DecoderVersion   = 5     // r,  use LONG
} AM_PROPERTY_DVD_RATE_CHANGE;

typedef struct {
    // this is the simplest mechanism to set a time stamp rate change on
    // a filter (simplest for the person setting the rate change, harder
    // for the filter doing the rate change).
    REFERENCE_TIME  StartTime;  //stream time at which to start this rate
    LONG        Rate;       //new rate * 10000 (decimal)
} AM_SimpleRateChange;

typedef struct {
    LONG    lMaxForwardFullFrame ;          //  rate * 10000
    LONG    lMaxReverseFullFrame ;          //  rate * 10000
} AM_QueryRate ;

typedef struct {
    REFERENCE_TIME  OutputZeroTime; //input TS that maps to zero output TS
    LONG        Rate;       //new rate * 10000 (decimal)
} AM_ExactRateChange;

typedef LONG AM_MaxFullDataRate; //rate * 10000 (decimal)

typedef DWORD AM_Step; // number of frame to step

// New rate change property set, structs. enums etc.
typedef struct {
    REFERENCE_TIME  StartInTime;   // stream time (input) at which to start decoding at this rate
    REFERENCE_TIME  StartOutTime;  // reference time (output) at which to start showing at this rate
    LONG            Rate;          // new rate * 10000 (decimal)
} AM_DVD_ChangeRate ;

typedef LONGLONG  AM_DVD_DecoderPosition ;

typedef enum {
    DVD_DIR_FORWARD  = 0,
    DVD_DIR_BACKWARD = 1
} DVD_PLAY_DIRECTION ;

#ifdef __cplusplus
}
#endif // __cplusplus
#endif // __DVDMEDIA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dwrite.h ===
//+--------------------------------------------------------------------------
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  Abstract:
//     DirectX Typography Services public API definitions.
//
//----------------------------------------------------------------------------

#ifndef DWRITE_H_INCLUDED
#define DWRITE_H_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef DWRITE_NO_WINDOWS_H

#include <specstrings.h>
#include <unknwn.h>

#endif // DWRITE_NO_WINDOWS_H

#include <dcommon.h>

#ifndef DWRITE_DECLARE_INTERFACE
#define DWRITE_DECLARE_INTERFACE(iid) DECLSPEC_UUID(iid) DECLSPEC_NOVTABLE
#endif

#ifndef DWRITE_EXPORT
#define DWRITE_EXPORT __declspec(dllimport) WINAPI
#endif

/// <summary>
/// The type of a font represented by a single font file.
/// Font formats that consist of multiple files, e.g. Type 1 .PFM and .PFB, have
/// separate enum values for each of the file type.
/// </summary>
enum DWRITE_FONT_FILE_TYPE
{
    /// <summary>
    /// Font type is not recognized by the DirectWrite font system.
    /// </summary>
    DWRITE_FONT_FILE_TYPE_UNKNOWN,

    /// <summary>
    /// OpenType font with CFF outlines.
    /// </summary>
    DWRITE_FONT_FILE_TYPE_CFF,

    /// <summary>
    /// OpenType font with TrueType outlines.
    /// </summary>
    DWRITE_FONT_FILE_TYPE_TRUETYPE,

    /// <summary>
    /// OpenType font that contains a TrueType collection.
    /// </summary>
    DWRITE_FONT_FILE_TYPE_TRUETYPE_COLLECTION,

    /// <summary>
    /// Type 1 PFM font.
    /// </summary>
    DWRITE_FONT_FILE_TYPE_TYPE1_PFM,

    /// <summary>
    /// Type 1 PFB font.
    /// </summary>
    DWRITE_FONT_FILE_TYPE_TYPE1_PFB,

    /// <summary>
    /// Vector .FON font.
    /// </summary>
    DWRITE_FONT_FILE_TYPE_VECTOR,

    /// <summary>
    /// Bitmap .FON font.
    /// </summary>
    DWRITE_FONT_FILE_TYPE_BITMAP
};

/// <summary>
/// The file format of a complete font face.
/// Font formats that consist of multiple files, e.g. Type 1 .PFM and .PFB, have
/// a single enum entry.
/// </summary>
enum DWRITE_FONT_FACE_TYPE
{
    /// <summary>
    /// OpenType font face with CFF outlines.
    /// </summary>
    DWRITE_FONT_FACE_TYPE_CFF,

    /// <summary>
    /// OpenType font face with TrueType outlines.
    /// </summary>
    DWRITE_FONT_FACE_TYPE_TRUETYPE,

    /// <summary>
    /// OpenType font face that is a part of a TrueType collection.
    /// </summary>
    DWRITE_FONT_FACE_TYPE_TRUETYPE_COLLECTION,

    /// <summary>
    /// A Type 1 font face.
    /// </summary>
    DWRITE_FONT_FACE_TYPE_TYPE1,

    /// <summary>
    /// A vector .FON format font face.
    /// </summary>
    DWRITE_FONT_FACE_TYPE_VECTOR,

    /// <summary>
    /// A bitmap .FON format font face.
    /// </summary>
    DWRITE_FONT_FACE_TYPE_BITMAP,

    /// <summary>
    /// Font face type is not recognized by the DirectWrite font system.
    /// </summary>
    DWRITE_FONT_FACE_TYPE_UNKNOWN
};

/// <summary>
/// Specifies algorithmic style simulations to be applied to the font face.
/// Bold and oblique simulations can be combined via bitwise OR operation.
/// </summary>
enum DWRITE_FONT_SIMULATIONS
{
    /// <summary>
    /// No simulations are performed.
    /// </summary>
    DWRITE_FONT_SIMULATIONS_NONE    = 0x0000,

    /// <summary>
    /// Algorithmic emboldening is performed.
    /// </summary>
    DWRITE_FONT_SIMULATIONS_BOLD    = 0x0001,

    /// <summary>
    /// Algorithmic italicization is performed.
    /// </summary>
    DWRITE_FONT_SIMULATIONS_OBLIQUE = 0x0002
};

#ifdef DEFINE_ENUM_FLAG_OPERATORS
DEFINE_ENUM_FLAG_OPERATORS(DWRITE_FONT_SIMULATIONS);
#endif

/// <summary>
/// The font weight enumeration describes common values for degree of blackness or thickness of strokes of characters in a font.
/// Font weight values less than 1 or greater than 999 are considered to be invalid, and they are rejected by font API functions.
/// </summary>
enum DWRITE_FONT_WEIGHT
{
    /// <summary>
    /// Predefined font weight : Thin (100).
    /// </summary>
    DWRITE_FONT_WEIGHT_THIN = 100,

    /// <summary>
    /// Predefined font weight : Extra-light (200).
    /// </summary>
    DWRITE_FONT_WEIGHT_EXTRA_LIGHT = 200,

    /// <summary>
    /// Predefined font weight : Ultra-light (200).
    /// </summary>
    DWRITE_FONT_WEIGHT_ULTRA_LIGHT = 200,

    /// <summary>
    /// Predefined font weight : Light (300).
    /// </summary>
    DWRITE_FONT_WEIGHT_LIGHT = 300,

    /// <summary>
    /// Predefined font weight : Normal (400).
    /// </summary>
    DWRITE_FONT_WEIGHT_NORMAL = 400,

    /// <summary>
    /// Predefined font weight : Regular (400).
    /// </summary>
    DWRITE_FONT_WEIGHT_REGULAR = 400,

    /// <summary>
    /// Predefined font weight : Medium (500).
    /// </summary>
    DWRITE_FONT_WEIGHT_MEDIUM = 500,

    /// <summary>
    /// Predefined font weight : Demi-bold (600).
    /// </summary>
    DWRITE_FONT_WEIGHT_DEMI_BOLD = 600,

    /// <summary>
    /// Predefined font weight : Semi-bold (600).
    /// </summary>
    DWRITE_FONT_WEIGHT_SEMI_BOLD = 600,

    /// <summary>
    /// Predefined font weight : Bold (700).
    /// </summary>
    DWRITE_FONT_WEIGHT_BOLD = 700,

    /// <summary>
    /// Predefined font weight : Extra-bold (800).
    /// </summary>
    DWRITE_FONT_WEIGHT_EXTRA_BOLD = 800,

    /// <summary>
    /// Predefined font weight : Ultra-bold (800).
    /// </summary>
    DWRITE_FONT_WEIGHT_ULTRA_BOLD = 800,

    /// <summary>
    /// Predefined font weight : Black (900).
    /// </summary>
    DWRITE_FONT_WEIGHT_BLACK = 900,

    /// <summary>
    /// Predefined font weight : Heavy (900).
    /// </summary>
    DWRITE_FONT_WEIGHT_HEAVY = 900,

    /// <summary>
    /// Predefined font weight : Extra-black (950).
    /// </summary>
    DWRITE_FONT_WEIGHT_EXTRA_BLACK = 950,

    /// <summary>
    /// Predefined font weight : Ultra-black (950).
    /// </summary>
    DWRITE_FONT_WEIGHT_ULTRA_BLACK = 950
};

/// <summary>
/// The font stretch enumeration describes relative change from the normal aspect ratio
/// as specified by a font designer for the glyphs in a font.
/// Values less than 1 or greater than 9 are considered to be invalid, and they are rejected by font API functions.
/// </summary>
enum DWRITE_FONT_STRETCH
{
    /// <summary>
    /// Predefined font stretch : Not known (0).
    /// </summary>
    DWRITE_FONT_STRETCH_UNDEFINED = 0,

    /// <summary>
    /// Predefined font stretch : Ultra-condensed (1).
    /// </summary>
    DWRITE_FONT_STRETCH_ULTRA_CONDENSED = 1,

    /// <summary>
    /// Predefined font stretch : Extra-condensed (2).
    /// </summary>
    DWRITE_FONT_STRETCH_EXTRA_CONDENSED = 2,

    /// <summary>
    /// Predefined font stretch : Condensed (3).
    /// </summary>
    DWRITE_FONT_STRETCH_CONDENSED = 3,

    /// <summary>
    /// Predefined font stretch : Semi-condensed (4).
    /// </summary>
    DWRITE_FONT_STRETCH_SEMI_CONDENSED = 4,

    /// <summary>
    /// Predefined font stretch : Normal (5).
    /// </summary>
    DWRITE_FONT_STRETCH_NORMAL = 5,

    /// <summary>
    /// Predefined font stretch : Medium (5).
    /// </summary>
    DWRITE_FONT_STRETCH_MEDIUM = 5,

    /// <summary>
    /// Predefined font stretch : Semi-expanded (6).
    /// </summary>
    DWRITE_FONT_STRETCH_SEMI_EXPANDED = 6,

    /// <summary>
    /// Predefined font stretch : Expanded (7).
    /// </summary>
    DWRITE_FONT_STRETCH_EXPANDED = 7,

    /// <summary>
    /// Predefined font stretch : Extra-expanded (8).
    /// </summary>
    DWRITE_FONT_STRETCH_EXTRA_EXPANDED = 8,

    /// <summary>
    /// Predefined font stretch : Ultra-expanded (9).
    /// </summary>
    DWRITE_FONT_STRETCH_ULTRA_EXPANDED = 9
};

/// <summary>
/// The font style enumeration describes the slope style of a font face, such as Normal, Italic or Oblique.
/// Values other than the ones defined in the enumeration are considered to be invalid, and they are rejected by font API functions.
/// </summary>
enum DWRITE_FONT_STYLE
{
    /// <summary>
    /// Font slope style : Normal.
    /// </summary>
    DWRITE_FONT_STYLE_NORMAL,

    /// <summary>
    /// Font slope style : Oblique.
    /// </summary>
    DWRITE_FONT_STYLE_OBLIQUE,

    /// <summary>
    /// Font slope style : Italic.
    /// </summary>
    DWRITE_FONT_STYLE_ITALIC

};

/// <summary>
/// The informational string enumeration identifies a string in a font.
/// </summary>
enum DWRITE_INFORMATIONAL_STRING_ID
{
    /// <summary>
    /// Unspecified name ID.
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_NONE,

    /// <summary>
    /// Copyright notice provided by the font.
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_COPYRIGHT_NOTICE,

    /// <summary>
    /// String containing a version number.
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_VERSION_STRINGS,

    /// <summary>
    /// Trademark information provided by the font.
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_TRADEMARK,

    /// <summary>
    /// Name of the font manufacturer.
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_MANUFACTURER,

    /// <summary>
    /// Name of the font designer.
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_DESIGNER,

    /// <summary>
    /// URL of font designer (with protocol, e.g., http://, ftp://).
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_DESIGNER_URL,

    /// <summary>
    /// Description of the font. Can contain revision information, usage recommendations, history, features, etc.
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_DESCRIPTION,

    /// <summary>
    /// URL of font vendor (with protocol, e.g., http://, ftp://). If a unique serial number is embedded in the URL, it can be used to register the font.
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_FONT_VENDOR_URL,

    /// <summary>
    /// Description of how the font may be legally used, or different example scenarios for licensed use. This field should be written in plain language, not legalese.
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_LICENSE_DESCRIPTION,

    /// <summary>
    /// URL where additional licensing information can be found.
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_LICENSE_INFO_URL,

    /// <summary>
    /// GDI-compatible family name. Because GDI allows a maximum of four fonts per family, fonts in the same family may have different GDI-compatible family names
    /// (e.g., "Arial", "Arial Narrow", "Arial Black").
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_WIN32_FAMILY_NAMES,

    /// <summary>
    /// GDI-compatible subfamily name.
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_WIN32_SUBFAMILY_NAMES,

    /// <summary>
    /// Family name preferred by the designer. This enables font designers to group more than four fonts in a single family without losing compatibility with
    /// GDI. This name is typically only present if it differs from the GDI-compatible family name.
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_PREFERRED_FAMILY_NAMES,

    /// <summary>
    /// Subfamily name preferred by the designer. This name is typically only present if it differs from the GDI-compatible subfamily name. 
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_PREFERRED_SUBFAMILY_NAMES,

    /// <summary>
    /// Sample text. This can be the font name or any other text that the designer thinks is the best example to display the font in.
    /// </summary>
    DWRITE_INFORMATIONAL_STRING_SAMPLE_TEXT
};


/// <summary>
/// The DWRITE_FONT_METRICS structure specifies the metrics of a font face that
/// are applicable to all glyphs within the font face.
/// </summary>
struct DWRITE_FONT_METRICS
{
    /// <summary>
    /// The number of font design units per em unit.
    /// Font files use their own coordinate system of font design units.
    /// A font design unit is the smallest measurable unit in the em square,
    /// an imaginary square that is used to size and align glyphs.
    /// The concept of em square is used as a reference scale factor when defining font size and device transformation semantics.
    /// The size of one em square is also commonly used to compute the paragraph identation value.
    /// </summary>
    UINT16 designUnitsPerEm;

    /// <summary>
    /// Ascent value of the font face in font design units.
    /// Ascent is the distance from the top of font character alignment box to English baseline.
    /// </summary>
    UINT16 ascent;

    /// <summary>
    /// Descent value of the font face in font design units.
    /// Descent is the distance from the bottom of font character alignment box to English baseline.
    /// </summary>
    UINT16 descent;

    /// <summary>
    /// Line gap in font design units.
    /// Recommended additional white space to add between lines to improve legibility. The recommended line spacing 
    /// (baseline-to-baseline distance) is thus the sum of ascent, descent, and lineGap. The line gap is usually 
    /// positive or zero but can be negative, in which case the recommended line spacing is less than the height
    /// of the character alignment box.
    /// </summary>
    INT16 lineGap;

    /// <summary>
    /// Cap height value of the font face in font design units.
    /// Cap height is the distance from English baseline to the top of a typical English capital.
    /// Capital "H" is often used as a reference character for the purpose of calculating the cap height value.
    /// </summary>
    UINT16 capHeight;

    /// <summary>
    /// x-height value of the font face in font design units.
    /// x-height is the distance from English baseline to the top of lowercase letter "x", or a similar lowercase character.
    /// </summary>
    UINT16 xHeight;

    /// <summary>
    /// The underline position value of the font face in font design units.
    /// Underline position is the position of underline relative to the English baseline.
    /// The value is usually made negative in order to place the underline below the baseline.
    /// </summary>
    INT16 underlinePosition;

    /// <summary>
    /// The suggested underline thickness value of the font face in font design units.
    /// </summary>
    UINT16 underlineThickness;

    /// <summary>
    /// The strikethrough position value of the font face in font design units.
    /// Strikethrough position is the position of strikethrough relative to the English baseline.
    /// The value is usually made positive in order to place the strikethrough above the baseline.
    /// </summary>
    INT16 strikethroughPosition;

    /// <summary>
    /// The suggested strikethrough thickness value of the font face in font design units.
    /// </summary>
    UINT16 strikethroughThickness;
};

/// <summary>
/// The DWRITE_GLYPH_METRICS structure specifies the metrics of an individual glyph.
/// The units depend on how the metrics are obtained.
/// </summary>
struct DWRITE_GLYPH_METRICS
{
    /// <summary>
    /// Specifies the X offset from the glyph origin to the left edge of the black box.
    /// The glyph origin is the current horizontal writing position.
    /// A negative value means the black box extends to the left of the origin (often true for lowercase italic 'f').
    /// </summary>
    INT32 leftSideBearing;

    /// <summary>
    /// Specifies the X offset from the origin of the current glyph to the origin of the next glyph when writing horizontally.
    /// </summary>
    UINT32 advanceWidth;

    /// <summary>
    /// Specifies the X offset from the right edge of the black box to the origin of the next glyph when writing horizontally.
    /// The value is negative when the right edge of the black box overhangs the layout box.
    /// </summary>
    INT32 rightSideBearing;

    /// <summary>
    /// Specifies the vertical offset from the vertical origin to the top of the black box.
    /// Thus, a positive value adds whitespace whereas a negative value means the glyph overhangs the top of the layout box.
    /// </summary>
    INT32 topSideBearing;

    /// <summary>
    /// Specifies the Y offset from the vertical origin of the current glyph to the vertical origin of the next glyph when writing vertically.
    /// (Note that the term "origin" by itself denotes the horizontal origin. The vertical origin is different.
    /// Its Y coordinate is specified by verticalOriginY value,
    /// and its X coordinate is half the advanceWidth to the right of the horizontal origin).
    /// </summary>
    UINT32 advanceHeight;

    /// <summary>
    /// Specifies the vertical distance from the black box's bottom edge to the advance height.
    /// Positive when the bottom edge of the black box is within the layout box.
    /// Negative when the bottom edge of black box overhangs the layout box.
    /// </summary>
    INT32 bottomSideBearing;

    /// <summary>
    /// Specifies the Y coordinate of a glyph's vertical origin, in the font's design coordinate system.
    /// The y coordinate of a glyph's vertical origin is the sum of the glyph's top side bearing
    /// and the top (i.e. yMax) of the glyph's bounding box.
    /// </summary>
    INT32 verticalOriginY;
};

/// <summary>
/// Optional adjustment to a glyph's position. An glyph offset changes the position of a glyph without affecting
/// the pen position. Offsets are in logical, pre-transform units.
/// </summary>
struct DWRITE_GLYPH_OFFSET
{
    /// <summary>
    /// Offset in the advance direction of the run. A positive advance offset moves the glyph to the right
    /// (in pre-transform coordinates) if the run is left-to-right or to the left if the run is right-to-left.
    /// </summary>
    FLOAT advanceOffset;

    /// <summary>
    /// Offset in the ascent direction, i.e., the direction ascenders point. A positive ascender offset moves
    /// the glyph up (in pre-transform coordinates).
    /// </summary>
    FLOAT ascenderOffset;
};

/// <summary>
/// Specifies the type of DirectWrite factory object.
/// DirectWrite factory contains internal state such as font loader registration and cached font data.
/// In most cases it is recommended to use the shared factory object, because it allows multiple components
/// that use DirectWrite to share internal DirectWrite state and reduce memory usage.
/// However, there are cases when it is desirable to reduce the impact of a component,
/// such as a plug-in from an untrusted source, on the rest of the process by sandboxing and isolating it
/// from the rest of the process components. In such cases, it is recommended to use an isolated factory for the sandboxed
/// component.
/// </summary>
enum DWRITE_FACTORY_TYPE
{
    /// <summary>
    /// Shared factory allow for re-use of cached font data across multiple in process components.
    /// Such factories also take advantage of cross process font caching components for better performance.
    /// </summary>
    DWRITE_FACTORY_TYPE_SHARED,

    /// <summary>
    /// Objects created from the isolated factory do not interact with internal DirectWrite state from other components.
    /// </summary>
    DWRITE_FACTORY_TYPE_ISOLATED
};

// Creates an OpenType tag as a 32bit integer such that
// the first character in the tag is the lowest byte,
// (least significant on little endian architectures)
// which can be used to compare with tags in the font file.
// This macro is compatible with DWRITE_FONT_FEATURE_TAG.
//
// Example: DWRITE_MAKE_OPENTYPE_TAG('c','c','m','p')
// Dword:   0x706D6363
//
#define DWRITE_MAKE_OPENTYPE_TAG(a,b,c,d) ( \
    (static_cast<UINT32>(static_cast<UINT8>(d)) << 24) | \
    (static_cast<UINT32>(static_cast<UINT8>(c)) << 16) | \
    (static_cast<UINT32>(static_cast<UINT8>(b)) << 8)  | \
     static_cast<UINT32>(static_cast<UINT8>(a)))

interface IDWriteFontFileStream;

/// <summary>
/// Font file loader interface handles loading font file resources of a particular type from a key.
/// The font file loader interface is recommended to be implemented by a singleton object.
/// IMPORTANT: font file loader implementations must not register themselves with DirectWrite factory
/// inside their constructors and must not unregister themselves in their destructors, because
/// registration and unregistraton operations increment and decrement the object reference count respectively.
/// Instead, registration and unregistration of font file loaders with DirectWrite factory should be performed
/// outside of the font file loader implementation as a separate step.
/// </summary>
interface DWRITE_DECLARE_INTERFACE("727cad4e-d6af-4c9e-8a08-d695b11caa49") IDWriteFontFileLoader : public IUnknown
{
    /// <summary>
    /// Creates a font file stream object that encapsulates an open file resource.
    /// The resource is closed when the last reference to fontFileStream is released.
    /// </summary>
    /// <param name="fontFileReferenceKey">Font file reference key that uniquely identifies the font file resource
    /// within the scope of the font loader being used.</param>
    /// <param name="fontFileReferenceKeySize">Size of font file reference key in bytes.</param>
    /// <param name="fontFileStream">Pointer to the newly created font file stream.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateStreamFromKey)(
        __in_bcount(fontFileReferenceKeySize) void const* fontFileReferenceKey,
        UINT32 fontFileReferenceKeySize,
        __out IDWriteFontFileStream** fontFileStream
        ) PURE;
};

/// <summary>
/// A built-in implementation of IDWriteFontFileLoader interface that operates on local font files
/// and exposes local font file information from the font file reference key.
/// Font file references created using CreateFontFileReference use this font file loader.
/// </summary>
interface DWRITE_DECLARE_INTERFACE("b2d9f3ec-c9fe-4a11-a2ec-d86208f7c0a2") IDWriteLocalFontFileLoader : public IDWriteFontFileLoader
{
    /// <summary>
    /// Obtains the length of the absolute file path from the font file reference key.
    /// </summary>
    /// <param name="fontFileReferenceKey">Font file reference key that uniquely identifies the local font file
    /// within the scope of the font loader being used.</param>
    /// <param name="fontFileReferenceKeySize">Size of font file reference key in bytes.</param>
    /// <param name="filePathLength">Length of the file path string not including the terminated NULL character.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetFilePathLengthFromKey)(
        __in_bcount(fontFileReferenceKeySize) void const* fontFileReferenceKey,
        UINT32 fontFileReferenceKeySize,
        __out UINT32* filePathLength
        ) PURE;

    /// <summary>
    /// Obtains the absolute font file path from the font file reference key.
    /// </summary>
    /// <param name="fontFileReferenceKey">Font file reference key that uniquely identifies the local font file
    /// within the scope of the font loader being used.</param>
    /// <param name="fontFileReferenceKeySize">Size of font file reference key in bytes.</param>
    /// <param name="filePath">Character array that receives the local file path.</param>
    /// <param name="filePathSize">Size of the filePath array in character count including the terminated NULL character.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetFilePathFromKey)(
        __in_bcount(fontFileReferenceKeySize) void const* fontFileReferenceKey,
        UINT32 fontFileReferenceKeySize,
        __out_ecount_z(filePathSize) WCHAR* filePath,
        UINT32 filePathSize
        ) PURE;

    /// <summary>
    /// Obtains the last write time of the file from the font file reference key.
    /// </summary>
    /// <param name="fontFileReferenceKey">Font file reference key that uniquely identifies the local font file
    /// within the scope of the font loader being used.</param>
    /// <param name="fontFileReferenceKeySize">Size of font file reference key in bytes.</param>
    /// <param name="lastWriteTime">Last modified time of the font file.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetLastWriteTimeFromKey)(
        __in_bcount(fontFileReferenceKeySize) void const* fontFileReferenceKey,
        UINT32 fontFileReferenceKeySize,
        __out FILETIME* lastWriteTime
        ) PURE;
};

/// <summary>
/// The interface for loading font file data.
/// </summary>
interface DWRITE_DECLARE_INTERFACE("6d4865fe-0ab8-4d91-8f62-5dd6be34a3e0") IDWriteFontFileStream : public IUnknown
{
    /// <summary>
    /// Reads a fragment from a file.
    /// </summary>
    /// <param name="fragmentStart">Receives the pointer to the start of the font file fragment.</param>
    /// <param name="fileOffset">Offset of the fragment from the beginning of the font file.</param>
    /// <param name="fragmentSize">Size of the fragment in bytes.</param>
    /// <param name="fragmentContext">The client defined context to be passed to the ReleaseFileFragment.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// IMPORTANT: ReadFileFragment() implementations must check whether the requested file fragment
    /// is within the file bounds. Otherwise, an error should be returned from ReadFileFragment.
    /// </remarks>
    STDMETHOD(ReadFileFragment)(
        __deref_out_bcount(fragmentSize) void const** fragmentStart,
        UINT64 fileOffset,
        UINT64 fragmentSize,
        __out void** fragmentContext
        ) PURE;

    /// <summary>
    /// Releases a fragment from a file.
    /// </summary>
    /// <param name="fragmentContext">The client defined context of a font fragment returned from ReadFileFragment.</param>
    STDMETHOD_(void, ReleaseFileFragment)(
        void* fragmentContext
        ) PURE;

    /// <summary>
    /// Obtains the total size of a file.
    /// </summary>
    /// <param name="fileSize">Receives the total size of the file.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// Implementing GetFileSize() for asynchronously loaded font files may require
    /// downloading the complete file contents, therefore this method should only be used for operations that
    /// either require complete font file to be loaded (e.g., copying a font file) or need to make
    /// decisions based on the value of the file size (e.g., validation against a persisted file size).
    /// </remarks>
    STDMETHOD(GetFileSize)(
        __out UINT64* fileSize
        ) PURE;

    /// <summary>
    /// Obtains the last modified time of the file. The last modified time is used by DirectWrite font selection algorithms
    /// to determine whether one font resource is more up to date than another one.
    /// </summary>
    /// <param name="lastWriteTime">Receives the last modifed time of the file in the format that represents
    /// the number of 100-nanosecond intervals since January 1, 1601 (UTC).</param>
    /// <returns>
    /// Standard HRESULT error code. For resources that don't have a concept of the last modified time, the implementation of
    /// GetLastWriteTime should return E_NOTIMPL.
    /// </returns>
    STDMETHOD(GetLastWriteTime)(
        __out UINT64* lastWriteTime
        ) PURE;
};

/// <summary>
/// The interface that represents a reference to a font file.
/// </summary>
interface DWRITE_DECLARE_INTERFACE("739d886a-cef5-47dc-8769-1a8b41bebbb0") IDWriteFontFile : public IUnknown
{
    /// <summary>
    /// This method obtains the pointer to the reference key of a font file. The pointer is only valid until the object that refers to it is released.
    /// </summary>
    /// <param name="fontFileReferenceKey">Pointer to the font file reference key.
    /// IMPORTANT: The pointer value is valid until the font file reference object it is obtained from is released.</param>
    /// <param name="fontFileReferenceKeySize">Size of font file reference key in bytes.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetReferenceKey)(
        __deref_out_bcount(*fontFileReferenceKeySize) void const** fontFileReferenceKey,
        __out UINT32* fontFileReferenceKeySize
        ) PURE;

    /// <summary>
    /// Obtains the file loader associated with a font file object.
    /// </summary>
    /// <param name="fontFileLoader">The font file loader associated with the font file object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetLoader)(
        __out IDWriteFontFileLoader** fontFileLoader
        ) PURE;

    /// <summary>
    /// Analyzes a file and returns whether it represents a font, and whether the font type is supported by the font system.
    /// </summary>
    /// <param name="isSupportedFontType">TRUE if the font type is supported by the font system, FALSE otherwise.</param>
    /// <param name="fontFileType">The type of the font file. Note that even if isSupportedFontType is FALSE,
    /// the fontFileType value may be different from DWRITE_FONT_FILE_TYPE_UNKNOWN.</param>
    /// <param name="fontFaceType">The type of the font face that can be constructed from the font file.
    /// Note that even if isSupportedFontType is FALSE, the fontFaceType value may be different from
    /// DWRITE_FONT_FACE_TYPE_UNKNOWN.</param>
    /// <param name="numberOfFaces">Number of font faces contained in the font file.</param>
    /// <returns>
    /// Standard HRESULT error code if there was a processing error during analysis.
    /// </returns>
    /// <remarks>
    /// IMPORTANT: certain font file types are recognized, but not supported by the font system.
    /// For example, the font system will recognize a file as a Type 1 font file,
    /// but will not be able to construct a font face object from it. In such situations, Analyze will set
    /// isSupportedFontType output parameter to FALSE.
    /// </remarks>
    STDMETHOD(Analyze)(
        __out BOOL* isSupportedFontType,
        __out DWRITE_FONT_FILE_TYPE* fontFileType,
        __out_opt DWRITE_FONT_FACE_TYPE* fontFaceType,
        __out UINT32* numberOfFaces
        ) PURE;
};

/// <summary>
/// Represents the internal structure of a device pixel (i.e., the physical arrangement of red,
/// green, and blue color components) that is assumed for purposes of rendering text.
/// </summary>
#ifndef DWRITE_PIXEL_GEOMETRY_DEFINED
enum DWRITE_PIXEL_GEOMETRY
{
    /// <summary>
    /// The red, green, and blue color components of each pixel are assumed to occupy the same point.
    /// </summary>
    DWRITE_PIXEL_GEOMETRY_FLAT,

    /// <summary>
    /// Each pixel comprises three vertical stripes, with red on the left, green in the center, and 
    /// blue on the right. This is the most common pixel geometry for LCD monitors.
    /// </summary>
    DWRITE_PIXEL_GEOMETRY_RGB,

    /// <summary>
    /// Each pixel comprises three vertical stripes, with blue on the left, green in the center, and 
    /// red on the right.
    /// </summary>
    DWRITE_PIXEL_GEOMETRY_BGR
};
#define DWRITE_PIXEL_GEOMETRY_DEFINED
#endif

/// <summary>
/// Represents a method of rendering glyphs.
/// </summary>
enum DWRITE_RENDERING_MODE
{
    /// <summary>
    /// Specifies that the rendering mode is determined automatically based on the font and size.
    /// </summary>
    DWRITE_RENDERING_MODE_DEFAULT,

    /// <summary>
    /// Specifies that no anti-aliasing is performed. Each pixel is either set to the foreground 
    /// color of the text or retains the color of the background.
    /// </summary>
    DWRITE_RENDERING_MODE_ALIASED,

    /// <summary>
    /// Specifies ClearType rendering with the same metrics as aliased text. Glyphs can only
    /// be positioned on whole-pixel boundaries.
    /// </summary>
    DWRITE_RENDERING_MODE_CLEARTYPE_GDI_CLASSIC,

    /// <summary>
    /// Specifies ClearType rendering with the same metrics as text rendering using GDI using a font
    /// created with CLEARTYPE_NATURAL_QUALITY. Glyph metrics are closer to their ideal values than 
    /// with aliased text, but glyphs are still positioned on whole-pixel boundaries.
    /// </summary>
    DWRITE_RENDERING_MODE_CLEARTYPE_GDI_NATURAL,

    /// <summary>
    /// Specifies ClearType rendering with anti-aliasing in the horizontal dimension only. This is 
    /// typically used with small to medium font sizes (up to 16 ppem).
    /// </summary>
    DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL,

    /// <summary>
    /// Specifies ClearType rendering with anti-aliasing in both horizontal and vertical dimensions. 
    /// This is typically used at larger sizes to makes curves and diagonal lines look smoother, at 
    /// the expense of some softness.
    /// </summary>
    DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL_SYMMETRIC,

    /// <summary>
    /// Specifies that rendering should bypass the rasterizer and use the outlines directly. This is 
    /// typically used at very large sizes.
    /// </summary>
    DWRITE_RENDERING_MODE_OUTLINE
};

/// <summary>
/// The DWRITE_MATRIX structure specifies the graphics transform to be applied
/// to rendered glyphs.
/// </summary>
struct DWRITE_MATRIX
{
    /// <summary>
    /// Horizontal scaling / cosine of rotation
    /// </summary>
    FLOAT m11;

    /// <summary>
    /// Vertical shear / sine of rotation
    /// </summary>
    FLOAT m12;

    /// <summary>
    /// Horizontal shear / negative sine of rotation
    /// </summary>
    FLOAT m21;

    /// <summary>
    /// Vertical scaling / cosine of rotation
    /// </summary>
    FLOAT m22;

    /// <summary>
    /// Horizontal shift (always orthogonal regardless of rotation)
    /// </summary>
    FLOAT dx;

    /// <summary>
    /// Vertical shift (always orthogonal regardless of rotation)
    /// </summary>
    FLOAT dy;
};

/// <summary>
/// The interface that represents text rendering settings for glyph rasterization and filtering.
/// </summary>
interface DWRITE_DECLARE_INTERFACE("2f0da53a-2add-47cd-82ee-d9ec34688e75") IDWriteRenderingParams : public IUnknown
{
    /// <summary>
    /// Gets the gamma value used for gamma correction. Valid values must be
    /// greater than zero and cannot exceed 256.
    /// </summary>
    STDMETHOD_(FLOAT, GetGamma)() PURE;

    /// <summary>
    /// Gets the amount of contrast enhancement. Valid values are greater than
    /// or equal to zero.
    /// </summary>
    STDMETHOD_(FLOAT, GetEnhancedContrast)() PURE;

    /// <summary>
    /// Gets the ClearType level. Valid values range from 0.0f (no ClearType) 
    /// to 1.0f (full ClearType).
    /// </summary>
    STDMETHOD_(FLOAT, GetClearTypeLevel)() PURE;

    /// <summary>
    /// Gets the pixel geometry.
    /// </summary>
    STDMETHOD_(DWRITE_PIXEL_GEOMETRY, GetPixelGeometry)() PURE;

    /// <summary>
    /// Gets the rendering mode.
    /// </summary>
    STDMETHOD_(DWRITE_RENDERING_MODE, GetRenderingMode)() PURE;
};

// Forward declarations of D2D types
interface ID2D1SimplifiedGeometrySink;

typedef ID2D1SimplifiedGeometrySink IDWriteGeometrySink;

/// <summary>
/// The interface that represents an absolute reference to a font face.
/// It contains font face type, appropriate file references and face identification data.
/// Various font data such as metrics, names and glyph outlines is obtained from IDWriteFontFace.
/// </summary>
interface DWRITE_DECLARE_INTERFACE("5f49804d-7024-4d43-bfa9-d25984f53849") IDWriteFontFace : public IUnknown
{
    /// <summary>
    /// Obtains the file format type of a font face.
    /// </summary>
    STDMETHOD_(DWRITE_FONT_FACE_TYPE, GetType)() PURE;

    /// <summary>
    /// Obtains the font files representing a font face.
    /// </summary>
    /// <param name="numberOfFiles">The number of files representing the font face.</param>
    /// <param name="fontFiles">User provided array that stores pointers to font files representing the font face.
    /// This parameter can be NULL if the user is only interested in the number of files representing the font face.
    /// This API increments reference count of the font file pointers returned according to COM conventions, and the client
    /// should release them when finished.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetFiles)(
        __inout UINT32* numberOfFiles,
        __out_ecount_opt(*numberOfFiles) IDWriteFontFile** fontFiles
        ) PURE;

    /// <summary>
    /// Obtains the zero-based index of the font face in its font file or files. If the font files contain a single face,
    /// the return value is zero.
    /// </summary>
    STDMETHOD_(UINT32, GetIndex)() PURE;

    /// <summary>
    /// Obtains the algorithmic style simulation flags of a font face.
    /// </summary>
    STDMETHOD_(DWRITE_FONT_SIMULATIONS, GetSimulations)() PURE;

    /// <summary>
    /// Determines whether the font is a symbol font.
    /// </summary>
    STDMETHOD_(BOOL, IsSymbolFont)() PURE;

    /// <summary>
    /// Obtains design units and common metrics for the font face.
    /// These metrics are applicable to all the glyphs within a fontface and are used by applications for layout calculations.
    /// </summary>
    /// <param name="fontFaceMetrics">Points to a DWRITE_FONT_METRICS structure to fill in.
    /// The metrics returned by this function are in font design units.</param>
    STDMETHOD_(void, GetMetrics)(
        __out DWRITE_FONT_METRICS* fontFaceMetrics
        ) PURE;

    /// <summary>
    /// Obtains the number of glyphs in the font face.
    /// </summary>
    STDMETHOD_(UINT16, GetGlyphCount)() PURE;

    /// <summary>
    /// Obtains ideal glyph metrics in font design units. Design glyphs metrics are used for glyph positioning.
    /// </summary>
    /// <param name="glyphIndices">An array of glyph indices to compute the metrics for.</param>
    /// <param name="glyphCount">The number of elements in the glyphIndices array.</param>
    /// <param name="glyphMetrics">Array of DWRITE_GLYPH_METRICS structures filled by this function.
    /// The metrics returned by this function are in font design units.</param>
    /// <param name="isSideways">Indicates whether the font is being used in a sideways run.
    /// This can affect the glyph metrics if the font has oblique simulation
    /// because sideways oblique simulation differs from non-sideways oblique simulation.</param>
    /// <returns>
    /// Standard HRESULT error code. If any of the input glyph indices are outside of the valid glyph index range
    /// for the current font face, E_INVALIDARG will be returned.
    /// </returns>
    STDMETHOD(GetDesignGlyphMetrics)(
        __in_ecount(glyphCount) UINT16 const* glyphIndices,
        UINT32 glyphCount,
        __out_ecount(glyphCount) DWRITE_GLYPH_METRICS* glyphMetrics,
        BOOL isSideways = FALSE
        ) PURE;

    /// <summary>
    /// Returns the nominal mapping of UCS4 Unicode code points to glyph indices as defined by the font 'CMAP' table.
    /// Note that this mapping is primarily provided for line layout engines built on top of the physical font API.
    /// Because of OpenType glyph substitution and line layout character substitution, the nominal conversion does not always correspond
    /// to how a Unicode string will map to glyph indices when rendering using a particular font face.
    /// Also, note that Unicode Variant Selectors provide for alternate mappings for character to glyph.
    /// This call will always return the default variant.
    /// </summary>
    /// <param name="codePoints">An array of USC4 code points to obtain nominal glyph indices from.</param>
    /// <param name="codePointCount">The number of elements in the codePoints array.</param>
    /// <param name="glyphIndices">Array of nominal glyph indices filled by this function.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetGlyphIndices)(
        __in_ecount(codePointCount) UINT32 const* codePoints,
        UINT32 codePointCount,
        __out_ecount(codePointCount) UINT16* glyphIndices
        ) PURE;
 
    /// <summary>
    /// Finds the specified OpenType font table if it exists and returns a pointer to it.
    /// The function accesses the underling font data via the IDWriteFontStream interface
    /// implemented by the font file loader.
    /// </summary>
    /// <param name="openTypeTableTag">Four character tag of table to find.
    ///     Use the DWRITE_MAKE_OPENTYPE_TAG() macro to create it.
    ///     Unlike GDI, it does not support the special TTCF and null tags to access the whole font.</param>
    /// <param name="tableData">
    ///     Pointer to base of table in memory.
    ///     The pointer is only valid so long as the FontFace used to get the font table still exists
    ///     (not any other FontFace, even if it actually refers to the same physical font).
    /// </param>
    /// <param name="tableSize">Byte size of table.</param>
    /// <param name="tableContext">
    ///     Opaque context which must be freed by calling ReleaseFontTable.
    ///     The context actually comes from the lower level IDWriteFontFileStream,
    ///     which may be implemented by the application or DWrite itself.
    ///     It is possible for a NULL tableContext to be returned, especially if
    ///     the implementation directly memory maps the whole file.
    ///     Nevertheless, always release it later, and do not use it as a test for function success.
    ///     The same table can be queried multiple times,
    ///     but each returned context can be different, so release each separately.
    /// </param>
    /// <param name="exists">True if table exists.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// If a table can not be found, the function will not return an error, but the size will be 0, table NULL, and exists = FALSE.
    /// The context does not need to be freed if the table was not found.
    /// </returns>
    /// <remarks>
    /// The context for the same tag may be different for each call,
    /// so each one must be held and released separately.
    /// </remarks>
    STDMETHOD(TryGetFontTable)(
        __in UINT32 openTypeTableTag,
        __deref_out_bcount(*tableSize) const void** tableData,
        __out UINT32* tableSize,
        __out void** tableContext,
        __out BOOL* exists
        ) PURE;

    /// <summary>
    /// Releases the table obtained earlier from TryGetFontTable.
    /// </summary>
    /// <param name="tableContext">Opaque context from TryGetFontTable.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD_(void, ReleaseFontTable)(
        __in void* tableContext
        ) PURE;

    /// <summary>
    /// Computes the outline of a run of glyphs by calling back to the outline sink interface.
    /// </summary>
    /// <param name="emSize">Logical size of the font in DIP units. A DIP ("device-independent pixel") equals 1/96 inch.</param>
    /// <param name="glyphIndices">Array of glyph indices.</param>
    /// <param name="glyphAdvances">Optional array of glyph advances in DIPs.</param>
    /// <param name="glyphOffsets">Optional array of glyph offsets.</param>
    /// <param name="glyphCount">Number of glyphs.</param>
    /// <param name="isSideways">If true, specifies that glyphs are rotated 90 degrees to the left and vertical metrics are used.
    /// A client can render a vertical run by specifying isSideways = true and rotating the resulting geometry 90 degrees to the
    /// right using a transform. The isSideways and isRightToLeft parameters cannot both be true.</param>
    /// <param name="isRightToLeft">If true, specifies that the advance direction is right to left. By default, the advance direction
    /// is left to right.</param>
    /// <param name="geometrySink">Interface the function calls back to draw each element of the geometry.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetGlyphRunOutline)(
        FLOAT emSize,
        __in_ecount(glyphCount) UINT16 const* glyphIndices,
        __in_ecount_opt(glyphCount) FLOAT const* glyphAdvances,
        __in_ecount_opt(glyphCount) DWRITE_GLYPH_OFFSET const* glyphOffsets,
        UINT32 glyphCount,
        BOOL isSideways,
        BOOL isRightToLeft,
        IDWriteGeometrySink* geometrySink
        ) PURE;

    /// <summary>
    /// Determines the recommended rendering mode for the font given the specified size and rendering parameters.
    /// </summary>
    /// <param name="emSize">Logical size of the font in DIP units. A DIP ("device-independent pixel") equals 1/96 inch.</param>
    /// <param name="pixelsPerDip">Number of physical pixels per DIP. For example, if the DPI of the rendering surface is 96 this 
    /// value is 1.0f. If the DPI is 120, this value is 120.0f/96.</param>
    /// <param name="measuringMode">Specifies measuring method that will be used for glyphs in the font.
    /// Renderer implementations may choose different rendering modes for given measuring methods, but
    /// best results are seen when the corresponding modes match:
    /// DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL for DWRITE_MEASURING_MODE_NATURAL
    /// DWRITE_RENDERING_MODE_CLEARTYPE_GDI_CLASSIC for DWRITE_MEASURING_MODE_GDI_CLASSIC
    /// DWRITE_RENDERING_MODE_CLEARTYPE_GDI_NATURAL for DWRITE_MEASURING_MODE_GDI_NATURAL
    /// </param>
    /// <param name="renderingParams">Rendering parameters object. This parameter is necessary in case the rendering parameters 
    /// object overrides the rendering mode.</param>
    /// <param name="renderingMode">Receives the recommended rendering mode to use.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetRecommendedRenderingMode)(
        FLOAT emSize,
        FLOAT pixelsPerDip,
        DWRITE_MEASURING_MODE measuringMode,
        IDWriteRenderingParams* renderingParams,
        __out DWRITE_RENDERING_MODE* renderingMode
        ) PURE;

    /// <summary>
    /// Obtains design units and common metrics for the font face.
    /// These metrics are applicable to all the glyphs within a fontface and are used by applications for layout calculations.
    /// </summary>
    /// <param name="emSize">Logical size of the font in DIP units. A DIP ("device-independent pixel") equals 1/96 inch.</param>
    /// <param name="pixelsPerDip">Number of physical pixels per DIP. For example, if the DPI of the rendering surface is 96 this 
    /// value is 1.0f. If the DPI is 120, this value is 120.0f/96.</param>
    /// <param name="transform">Optional transform applied to the glyphs and their positions. This transform is applied after the
    /// scaling specified by the font size and pixelsPerDip.</param>
    /// <param name="fontFaceMetrics">Points to a DWRITE_FONT_METRICS structure to fill in.
    /// The metrics returned by this function are in font design units.</param>
    STDMETHOD(GetGdiCompatibleMetrics)(
        FLOAT emSize,
        FLOAT pixelsPerDip,
        __in_opt DWRITE_MATRIX const* transform,
        __out DWRITE_FONT_METRICS* fontFaceMetrics
        ) PURE;


    /// <summary>
    /// Obtains glyph metrics in font design units with the return values compatible with what GDI would produce.
    /// Glyphs metrics are used for positioning of individual glyphs.
    /// </summary>
    /// <param name="emSize">Logical size of the font in DIP units. A DIP ("device-independent pixel") equals 1/96 inch.</param>
    /// <param name="pixelsPerDip">Number of physical pixels per DIP. For example, if the DPI of the rendering surface is 96 this 
    /// value is 1.0f. If the DPI is 120, this value is 120.0f/96.</param>
    /// <param name="transform">Optional transform applied to the glyphs and their positions. This transform is applied after the
    /// scaling specified by the font size and pixelsPerDip.</param>
    /// <param name="useGdiNatural">
    /// When set to FALSE, the metrics are the same as the metrics of GDI aliased text.
    /// When set to TRUE, the metrics are the same as the metrics of text measured by GDI using a font
    /// created with CLEARTYPE_NATURAL_QUALITY.
    /// </param>
    /// <param name="glyphIndices">An array of glyph indices to compute the metrics for.</param>
    /// <param name="glyphCount">The number of elements in the glyphIndices array.</param>
    /// <param name="glyphMetrics">Array of DWRITE_GLYPH_METRICS structures filled by this function.
    /// The metrics returned by this function are in font design units.</param>
    /// <param name="isSideways">Indicates whether the font is being used in a sideways run.
    /// This can affect the glyph metrics if the font has oblique simulation
    /// because sideways oblique simulation differs from non-sideways oblique simulation.</param>
    /// <returns>
    /// Standard HRESULT error code. If any of the input glyph indices are outside of the valid glyph index range
    /// for the current font face, E_INVALIDARG will be returned.
    /// </returns>
    STDMETHOD(GetGdiCompatibleGlyphMetrics)(
        FLOAT emSize,
        FLOAT pixelsPerDip,
        __in_opt DWRITE_MATRIX const* transform,
        BOOL useGdiNatural,
        __in_ecount(glyphCount) UINT16 const* glyphIndices,
        UINT32 glyphCount,
        __out_ecount(glyphCount) DWRITE_GLYPH_METRICS* glyphMetrics,
        BOOL isSideways = FALSE
        ) PURE;
};

interface IDWriteFactory;
interface IDWriteFontFileEnumerator;

/// <summary>
/// The font collection loader interface is used to construct a collection of fonts given a particular type of key.
/// The font collection loader interface is recommended to be implemented by a singleton object.
/// IMPORTANT: font collection loader implementations must not register themselves with a DirectWrite factory
/// inside their constructors and must not unregister themselves in their destructors, because
/// registration and unregistraton operations increment and decrement the object reference count respectively.
/// Instead, registration and unregistration of font file loaders with DirectWrite factory should be performed
/// outside of the font file loader implementation as a separate step.
/// </summary>
interface DWRITE_DECLARE_INTERFACE("cca920e4-52f0-492b-bfa8-29c72ee0a468") IDWriteFontCollectionLoader : public IUnknown
{
    /// <summary>
    /// Creates a font file enumerator object that encapsulates a collection of font files.
    /// The font system calls back to this interface to create a font collection.
    /// </summary>
    /// <param name="factory">Factory associated with the loader.</param>
    /// <param name="collectionKey">Font collection key that uniquely identifies the collection of font files within
    /// the scope of the font collection loader being used.</param>
    /// <param name="collectionKeySize">Size of the font collection key in bytes.</param>
    /// <param name="fontFileEnumerator">Pointer to the newly created font file enumerator.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateEnumeratorFromKey)(
        IDWriteFactory* factory,
        __in_bcount(collectionKeySize) void const* collectionKey,
        UINT32 collectionKeySize,
        __out IDWriteFontFileEnumerator** fontFileEnumerator
        ) PURE;
};

/// <summary>
/// The font file enumerator interface encapsulates a collection of font files. The font system uses this interface
/// to enumerate font files when building a font collection.
/// </summary>
interface DWRITE_DECLARE_INTERFACE("72755049-5ff7-435d-8348-4be97cfa6c7c") IDWriteFontFileEnumerator : public IUnknown
{
    /// <summary>
    /// Advances to the next font file in the collection. When it is first created, the enumerator is positioned
    /// before the first element of the collection and the first call to MoveNext advances to the first file.
    /// </summary>
    /// <param name="hasCurrentFile">Receives the value TRUE if the enumerator advances to a file, or FALSE if
    /// the enumerator advanced past the last file in the collection.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(MoveNext)(
        __out BOOL* hasCurrentFile
        ) PURE;

    /// <summary>
    /// Gets a reference to the current font file.
    /// </summary>
    /// <param name="fontFile">Pointer to the newly created font file object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetCurrentFontFile)(
        __out IDWriteFontFile** fontFile
        ) PURE;
};

/// <summary>
/// Represents a collection of strings indexed by locale name.
/// </summary>
interface DWRITE_DECLARE_INTERFACE("08256209-099a-4b34-b86d-c22b110e7771") IDWriteLocalizedStrings : public IUnknown
{
    /// <summary>
    /// Gets the number of language/string pairs.
    /// </summary>
    STDMETHOD_(UINT32, GetCount)() PURE;

    /// <summary>
    /// Gets the index of the item with the specified locale name.
    /// </summary>
    /// <param name="localeName">Locale name to look for.</param>
    /// <param name="index">Receives the zero-based index of the locale name/string pair.</param>
    /// <param name="exists">Receives TRUE if the locale name exists or FALSE if not.</param>
    /// <returns>
    /// Standard HRESULT error code. If the specified locale name does not exist, the return value is S_OK, 
    /// but *index is UINT_MAX and *exists is FALSE.
    /// </returns>
    STDMETHOD(FindLocaleName)(
        __in_z WCHAR const* localeName, 
        __out UINT32* index,
        __out BOOL* exists
        ) PURE;

    /// <summary>
    /// Gets the length in characters (not including the null terminator) of the locale name with the specified index.
    /// </summary>
    /// <param name="index">Zero-based index of the locale name.</param>
    /// <param name="length">Receives the length in characters, not including the null terminator.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetLocaleNameLength)(
        UINT32 index,
        __out UINT32* length
        ) PURE;

    /// <summary>
    /// Copies the locale name with the specified index to the specified array.
    /// </summary>
    /// <param name="index">Zero-based index of the locale name.</param>
    /// <param name="localeName">Character array that receives the locale name.</param>
    /// <param name="size">Size of the array in characters. The size must include space for the terminating
    /// null character.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetLocaleName)(
        UINT32 index,
        __out_ecount_z(size) WCHAR* localeName,
        UINT32 size
        ) PURE;

    /// <summary>
    /// Gets the length in characters (not including the null terminator) of the string with the specified index.
    /// </summary>
    /// <param name="index">Zero-based index of the string.</param>
    /// <param name="length">Receives the length in characters, not including the null terminator.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetStringLength)(
        UINT32 index,
        __out UINT32* length
        ) PURE;

    /// <summary>
    /// Copies the string with the specified index to the specified array.
    /// </summary>
    /// <param name="index">Zero-based index of the string.</param>
    /// <param name="stringBuffer">Character array that receives the string.</param>
    /// <param name="size">Size of the array in characters. The size must include space for the terminating
    /// null character.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetString)(
        UINT32 index,
        __out_ecount_z(size) WCHAR* stringBuffer,
        UINT32 size
        ) PURE;
};

interface IDWriteFontFamily;
interface IDWriteFont;

/// <summary>
/// The IDWriteFontCollection encapsulates a collection of fonts.
/// </summary>
interface DWRITE_DECLARE_INTERFACE("a84cee02-3eea-4eee-a827-87c1a02a0fcc") IDWriteFontCollection : public IUnknown
{
    /// <summary>
    /// Gets the number of font families in the collection.
    /// </summary>
    STDMETHOD_(UINT32, GetFontFamilyCount)() PURE;

    /// <summary>
    /// Creates a font family object given a zero-based font family index.
    /// </summary>
    /// <param name="index">Zero-based index of the font family.</param>
    /// <param name="fontFamily">Receives a pointer the newly created font family object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetFontFamily)(
        UINT32 index,
        __out IDWriteFontFamily** fontFamily
        ) PURE;

    /// <summary>
    /// Finds the font family with the specified family name.
    /// </summary>
    /// <param name="familyName">Name of the font family. The name is not case-sensitive but must otherwise exactly match a family name in the collection.</param>
    /// <param name="index">Receives the zero-based index of the matching font family if the family name was found or UINT_MAX otherwise.</param>
    /// <param name="exists">Receives TRUE if the family name exists or FALSE otherwise.</param>
    /// <returns>
    /// Standard HRESULT error code. If the specified family name does not exist, the return value is S_OK, but *index is UINT_MAX and *exists is FALSE.
    /// </returns>
    STDMETHOD(FindFamilyName)(
        __in_z WCHAR const* familyName,
        __out UINT32* index,
        __out BOOL* exists
        ) PURE;

    /// <summary>
    /// Gets the font object that corresponds to the same physical font as the specified font face object. The specified physical font must belong 
    /// to the font collection.
    /// </summary>
    /// <param name="fontFace">Font face object that specifies the physical font.</param>
    /// <param name="font">Receives a pointer to the newly created font object if successful or NULL otherwise.</param>
    /// <returns>
    /// Standard HRESULT error code. If the specified physical font is not part of the font collection the return value is DWRITE_E_NOFONT.
    /// </returns>
    STDMETHOD(GetFontFromFontFace)(
        IDWriteFontFace* fontFace,
        __out IDWriteFont** font
        ) PURE;
};

/// <summary>
/// The IDWriteFontList interface represents a list of fonts.
/// </summary>
interface DWRITE_DECLARE_INTERFACE("1a0d8438-1d97-4ec1-aef9-a2fb86ed6acb") IDWriteFontList : public IUnknown
{
    /// <summary>
    /// Gets the font collection that contains the fonts.
    /// </summary>
    /// <param name="fontCollection">Receives a pointer to the font collection object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetFontCollection)(
        __out IDWriteFontCollection** fontCollection
        ) PURE;

    /// <summary>
    /// Gets the number of fonts in the font list.
    /// </summary>
    STDMETHOD_(UINT32, GetFontCount)() PURE;

    /// <summary>
    /// Gets a font given its zero-based index.
    /// </summary>
    /// <param name="index">Zero-based index of the font in the font list.</param>
    /// <param name="font">Receives a pointer to the newly created font object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetFont)(
        UINT32 index, 
        __out IDWriteFont** font
        ) PURE;
};

/// <summary>
/// The IDWriteFontFamily interface represents a set of fonts that share the same design but are differentiated
/// by weight, stretch, and style.
/// </summary>
interface DWRITE_DECLARE_INTERFACE("da20d8ef-812a-4c43-9802-62ec4abd7add") IDWriteFontFamily : public IDWriteFontList
{
    /// <summary>
    /// Creates an localized strings object that contains the family names for the font family, indexed by locale name.
    /// </summary>
    /// <param name="names">Receives a pointer to the newly created localized strings object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetFamilyNames)(
        __out IDWriteLocalizedStrings** names
        ) PURE;

    /// <summary>
    /// Gets the font that best matches the specified properties.
    /// </summary>
    /// <param name="weight">Requested font weight.</param>
    /// <param name="stretch">Requested font stretch.</param>
    /// <param name="style">Requested font style.</param>
    /// <param name="matchingFont">Receives a pointer to the newly created font object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetFirstMatchingFont)(
        DWRITE_FONT_WEIGHT  weight,
        DWRITE_FONT_STRETCH stretch,
        DWRITE_FONT_STYLE   style,
        __out IDWriteFont** matchingFont
        ) PURE;

    /// <summary>
    /// Gets a list of fonts in the font family ranked in order of how well they match the specified properties.
    /// </summary>
    /// <param name="weight">Requested font weight.</param>
    /// <param name="stretch">Requested font stretch.</param>
    /// <param name="style">Requested font style.</param>
    /// <param name="matchingFonts">Receives a pointer to the newly created font list object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetMatchingFonts)(
        DWRITE_FONT_WEIGHT      weight,
        DWRITE_FONT_STRETCH     stretch,
        DWRITE_FONT_STYLE       style,
        __out IDWriteFontList** matchingFonts
        ) PURE;
};

/// <summary>
/// The IDWriteFont interface represents a physical font in a font collection.
/// </summary>
interface DWRITE_DECLARE_INTERFACE("acd16696-8c14-4f5d-877e-fe3fc1d32737") IDWriteFont : public IUnknown
{
    /// <summary>
    /// Gets the font family to which the specified font belongs.
    /// </summary>
    /// <param name="fontFamily">Receives a pointer to the font family object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetFontFamily)(
        __out IDWriteFontFamily** fontFamily
        ) PURE;

    /// <summary>
    /// Gets the weight of the specified font.
    /// </summary>
    STDMETHOD_(DWRITE_FONT_WEIGHT, GetWeight)() PURE;

    /// <summary>
    /// Gets the stretch (aka. width) of the specified font.
    /// </summary>
    STDMETHOD_(DWRITE_FONT_STRETCH, GetStretch)() PURE;

    /// <summary>
    /// Gets the style (aka. slope) of the specified font.
    /// </summary>
    STDMETHOD_(DWRITE_FONT_STYLE, GetStyle)() PURE;

    /// <summary>
    /// Returns TRUE if the font is a symbol font or FALSE if not.
    /// </summary>
    STDMETHOD_(BOOL, IsSymbolFont)() PURE;

    /// <summary>
    /// Gets a localized strings collection containing the face names for the font (e.g., Regular or Bold), indexed by locale name.
    /// </summary>
    /// <param name="names">Receives a pointer to the newly created localized strings object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetFaceNames)(
        __out IDWriteLocalizedStrings** names
        ) PURE;

    /// <summary>
    /// Gets a localized strings collection containing the specified informational strings, indexed by locale name.
    /// </summary>
    /// <param name="informationalStringID">Identifies the string to get.</param>
    /// <param name="informationalStrings">Receives a pointer to the newly created localized strings object.</param>
    /// <param name="exists">Receives the value TRUE if the font contains the specified string ID or FALSE if not.</param>
    /// <returns>
    /// Standard HRESULT error code. If the font does not contain the specified string, the return value is S_OK but 
    /// informationalStrings receives a NULL pointer and exists receives the value FALSE.
    /// </returns>
    STDMETHOD(GetInformationalStrings)(
        DWRITE_INFORMATIONAL_STRING_ID informationalStringID,
        __out IDWriteLocalizedStrings** informationalStrings,
        __out BOOL* exists
        ) PURE;

    /// <summary>
    /// Gets a value that indicates what simulation are applied to the specified font.
    /// </summary>
    STDMETHOD_(DWRITE_FONT_SIMULATIONS, GetSimulations)() PURE;

    /// <summary>
    /// Gets the metrics for the font.
    /// </summary>
    /// <param name="fontMetrics">Receives the font metrics.</param>
    STDMETHOD_(void, GetMetrics)(
        __out DWRITE_FONT_METRICS* fontMetrics
        ) PURE;

    /// <summary>
    /// Determines whether the font supports the specified character.
    /// </summary>
    /// <param name="unicodeValue">Unicode (UCS-4) character value.</param>
    /// <param name="exists">Receives the value TRUE if the font supports the specified character or FALSE if not.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(HasCharacter)(
        UINT32 unicodeValue,
        __out BOOL* exists
        ) PURE;

    /// <summary>
    /// Creates a font face object for the font.
    /// </summary>
    /// <param name="fontFace">Receives a pointer to the newly created font face object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateFontFace)(
        __out IDWriteFontFace** fontFace
        ) PURE;
};

/// <summary>
/// Direction for how reading progresses.
/// </summary>
enum DWRITE_READING_DIRECTION
{
    /// <summary>
    /// Reading progresses from left to right.
    /// </summary>
    DWRITE_READING_DIRECTION_LEFT_TO_RIGHT,

    /// <summary>
    /// Reading progresses from right to left.
    /// </summary>
    DWRITE_READING_DIRECTION_RIGHT_TO_LEFT
};

/// <summary>
/// Direction for how lines of text are placed relative to one another.
/// </summary>
enum DWRITE_FLOW_DIRECTION
{
    /// <summary>
    /// Text lines are placed from top to bottom.
    /// </summary>
    DWRITE_FLOW_DIRECTION_TOP_TO_BOTTOM
};

/// <summary>
/// Alignment of paragraph text along the reading direction axis relative to 
/// the leading and trailing edge of the layout box.
/// </summary>
enum DWRITE_TEXT_ALIGNMENT
{
    /// <summary>
    /// The leading edge of the paragraph text is aligned to the layout box's leading edge.
    /// </summary>
    DWRITE_TEXT_ALIGNMENT_LEADING,

    /// <summary>
    /// The trailing edge of the paragraph text is aligned to the layout box's trailing edge.
    /// </summary>
    DWRITE_TEXT_ALIGNMENT_TRAILING,

    /// <summary>
    /// The center of the paragraph text is aligned to the center of the layout box.
    /// </summary>
    DWRITE_TEXT_ALIGNMENT_CENTER
};

/// <summary>
/// Alignment of paragraph text along the flow direction axis relative to the
/// flow's beginning and ending edge of the layout box.
/// </summary>
enum DWRITE_PARAGRAPH_ALIGNMENT
{
    /// <summary>
    /// The first line of paragraph is aligned to the flow's beginning edge of the layout box.
    /// </summary>
    DWRITE_PARAGRAPH_ALIGNMENT_NEAR,

    /// <summary>
    /// The last line of paragraph is aligned to the flow's ending edge of the layout box.
    /// </summary>
    DWRITE_PARAGRAPH_ALIGNMENT_FAR,

    /// <summary>
    /// The center of the paragraph is aligned to the center of the flow of the layout box.
    /// </summary>
    DWRITE_PARAGRAPH_ALIGNMENT_CENTER
};

/// <summary>
/// Word wrapping in multiline paragraph.
/// </summary>
enum DWRITE_WORD_WRAPPING
{
    /// <summary>
    /// Words are broken across lines to avoid text overflowing the layout box.
    /// </summary>
    DWRITE_WORD_WRAPPING_WRAP,

    /// <summary>
    /// Words are kept within the same line even when it overflows the layout box.
    /// This option is often used with scrolling to reveal overflow text. 
    /// </summary>
    DWRITE_WORD_WRAPPING_NO_WRAP
};

/// <summary>
/// The method used for line spacing in layout.
/// </summary>
enum DWRITE_LINE_SPACING_METHOD
{
    /// <summary>
    /// Line spacing depends solely on the content, growing to accomodate the size of fonts and inline objects.
    /// </summary>
    DWRITE_LINE_SPACING_METHOD_DEFAULT,

    /// <summary>
    /// Lines are explicitly set to uniform spacing, regardless of contained font sizes.
    /// This can be useful to avoid the uneven appearance that can occur from font fallback.
    /// </summary>
    DWRITE_LINE_SPACING_METHOD_UNIFORM
};

/// <summary>
/// Text granularity used to trim text overflowing the layout box.
/// </summary>
enum DWRITE_TRIMMING_GRANULARITY
{
    /// <summary>
    /// No trimming occurs. Text flows beyond the layout width.
    /// </summary>
    DWRITE_TRIMMING_GRANULARITY_NONE,

    /// <summary>
    /// Trimming occurs at character cluster boundary.
    /// </summary>
    DWRITE_TRIMMING_GRANULARITY_CHARACTER,
    
    /// <summary>
    /// Trimming occurs at word boundary.
    /// </summary>
    DWRITE_TRIMMING_GRANULARITY_WORD	
};

/// <summary>
/// Typographic feature of text supplied by the font.
/// </summary>
enum DWRITE_FONT_FEATURE_TAG
{
    DWRITE_FONT_FEATURE_TAG_ALTERNATIVE_FRACTIONS               = 0x63726661, // 'afrc'
    DWRITE_FONT_FEATURE_TAG_PETITE_CAPITALS_FROM_CAPITALS       = 0x63703263, // 'c2pc'
    DWRITE_FONT_FEATURE_TAG_SMALL_CAPITALS_FROM_CAPITALS        = 0x63733263, // 'c2sc'
    DWRITE_FONT_FEATURE_TAG_CONTEXTUAL_ALTERNATES               = 0x746c6163, // 'calt'
    DWRITE_FONT_FEATURE_TAG_CASE_SENSITIVE_FORMS                = 0x65736163, // 'case'
    DWRITE_FONT_FEATURE_TAG_GLYPH_COMPOSITION_DECOMPOSITION     = 0x706d6363, // 'ccmp'
    DWRITE_FONT_FEATURE_TAG_CONTEXTUAL_LIGATURES                = 0x67696c63, // 'clig'
    DWRITE_FONT_FEATURE_TAG_CAPITAL_SPACING                     = 0x70737063, // 'cpsp'
    DWRITE_FONT_FEATURE_TAG_CONTEXTUAL_SWASH                    = 0x68777363, // 'cswh'
    DWRITE_FONT_FEATURE_TAG_CURSIVE_POSITIONING                 = 0x73727563, // 'curs'
    DWRITE_FONT_FEATURE_TAG_DEFAULT                             = 0x746c6664, // 'dflt'
    DWRITE_FONT_FEATURE_TAG_DISCRETIONARY_LIGATURES             = 0x67696c64, // 'dlig'
    DWRITE_FONT_FEATURE_TAG_EXPERT_FORMS                        = 0x74707865, // 'expt'
    DWRITE_FONT_FEATURE_TAG_FRACTIONS                           = 0x63617266, // 'frac'
    DWRITE_FONT_FEATURE_TAG_FULL_WIDTH                          = 0x64697766, // 'fwid'
    DWRITE_FONT_FEATURE_TAG_HALF_FORMS                          = 0x666c6168, // 'half'
    DWRITE_FONT_FEATURE_TAG_HALANT_FORMS                        = 0x6e6c6168, // 'haln'
    DWRITE_FONT_FEATURE_TAG_ALTERNATE_HALF_WIDTH                = 0x746c6168, // 'halt'
    DWRITE_FONT_FEATURE_TAG_HISTORICAL_FORMS                    = 0x74736968, // 'hist'
    DWRITE_FONT_FEATURE_TAG_HORIZONTAL_KANA_ALTERNATES          = 0x616e6b68, // 'hkna'
    DWRITE_FONT_FEATURE_TAG_HISTORICAL_LIGATURES                = 0x67696c68, // 'hlig'
    DWRITE_FONT_FEATURE_TAG_HALF_WIDTH                          = 0x64697768, // 'hwid'
    DWRITE_FONT_FEATURE_TAG_HOJO_KANJI_FORMS                    = 0x6f6a6f68, // 'hojo'
    DWRITE_FONT_FEATURE_TAG_JIS04_FORMS                         = 0x3430706a, // 'jp04'
    DWRITE_FONT_FEATURE_TAG_JIS78_FORMS                         = 0x3837706a, // 'jp78'
    DWRITE_FONT_FEATURE_TAG_JIS83_FORMS                         = 0x3338706a, // 'jp83'
    DWRITE_FONT_FEATURE_TAG_JIS90_FORMS                         = 0x3039706a, // 'jp90'
    DWRITE_FONT_FEATURE_TAG_KERNING                             = 0x6e72656b, // 'kern'
    DWRITE_FONT_FEATURE_TAG_STANDARD_LIGATURES                  = 0x6167696c, // 'liga'
    DWRITE_FONT_FEATURE_TAG_LINING_FIGURES                      = 0x6d756e6c, // 'lnum'
    DWRITE_FONT_FEATURE_TAG_LOCALIZED_FORMS                     = 0x6c636f6c, // 'locl'
    DWRITE_FONT_FEATURE_TAG_MARK_POSITIONING                    = 0x6b72616d, // 'mark'
    DWRITE_FONT_FEATURE_TAG_MATHEMATICAL_GREEK                  = 0x6b72676d, // 'mgrk'
    DWRITE_FONT_FEATURE_TAG_MARK_TO_MARK_POSITIONING            = 0x6b6d6b6d, // 'mkmk'
    DWRITE_FONT_FEATURE_TAG_ALTERNATE_ANNOTATION_FORMS          = 0x746c616e, // 'nalt'
    DWRITE_FONT_FEATURE_TAG_NLC_KANJI_FORMS                     = 0x6b636c6e, // 'nlck'
    DWRITE_FONT_FEATURE_TAG_OLD_STYLE_FIGURES                   = 0x6d756e6f, // 'onum'
    DWRITE_FONT_FEATURE_TAG_ORDINALS                            = 0x6e64726f, // 'ordn'
    DWRITE_FONT_FEATURE_TAG_PROPORTIONAL_ALTERNATE_WIDTH        = 0x746c6170, // 'palt'
    DWRITE_FONT_FEATURE_TAG_PETITE_CAPITALS                     = 0x70616370, // 'pcap'
    DWRITE_FONT_FEATURE_TAG_PROPORTIONAL_FIGURES                = 0x6d756e70, // 'pnum'
    DWRITE_FONT_FEATURE_TAG_PROPORTIONAL_WIDTHS                 = 0x64697770, // 'pwid'
    DWRITE_FONT_FEATURE_TAG_QUARTER_WIDTHS                      = 0x64697771, // 'qwid'
    DWRITE_FONT_FEATURE_TAG_REQUIRED_LIGATURES                  = 0x67696c72, // 'rlig'
    DWRITE_FONT_FEATURE_TAG_RUBY_NOTATION_FORMS                 = 0x79627572, // 'ruby'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_ALTERNATES                = 0x746c6173, // 'salt'
    DWRITE_FONT_FEATURE_TAG_SCIENTIFIC_INFERIORS                = 0x666e6973, // 'sinf'
    DWRITE_FONT_FEATURE_TAG_SMALL_CAPITALS                      = 0x70636d73, // 'smcp'
    DWRITE_FONT_FEATURE_TAG_SIMPLIFIED_FORMS                    = 0x6c706d73, // 'smpl'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_1                     = 0x31307373, // 'ss01'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_2                     = 0x32307373, // 'ss02'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_3                     = 0x33307373, // 'ss03'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_4                     = 0x34307373, // 'ss04'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_5                     = 0x35307373, // 'ss05'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_6                     = 0x36307373, // 'ss06'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_7                     = 0x37307373, // 'ss07'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_8                     = 0x38307373, // 'ss08'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_9                     = 0x39307373, // 'ss09'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_10                    = 0x30317373, // 'ss10'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_11                    = 0x31317373, // 'ss11'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_12                    = 0x32317373, // 'ss12'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_13                    = 0x33317373, // 'ss13'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_14                    = 0x34317373, // 'ss14'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_15                    = 0x35317373, // 'ss15'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_16                    = 0x36317373, // 'ss16'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_17                    = 0x37317373, // 'ss17'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_18                    = 0x38317373, // 'ss18'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_19                    = 0x39317373, // 'ss19'
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_20                    = 0x30327373, // 'ss20'
    DWRITE_FONT_FEATURE_TAG_SUBSCRIPT                           = 0x73627573, // 'subs'
    DWRITE_FONT_FEATURE_TAG_SUPERSCRIPT                         = 0x73707573, // 'sups'
    DWRITE_FONT_FEATURE_TAG_SWASH                               = 0x68737773, // 'swsh'
    DWRITE_FONT_FEATURE_TAG_TITLING                             = 0x6c746974, // 'titl'
    DWRITE_FONT_FEATURE_TAG_TRADITIONAL_NAME_FORMS              = 0x6d616e74, // 'tnam'
    DWRITE_FONT_FEATURE_TAG_TABULAR_FIGURES                     = 0x6d756e74, // 'tnum'
    DWRITE_FONT_FEATURE_TAG_TRADITIONAL_FORMS                   = 0x64617274, // 'trad'
    DWRITE_FONT_FEATURE_TAG_THIRD_WIDTHS                        = 0x64697774, // 'twid'
    DWRITE_FONT_FEATURE_TAG_UNICASE                             = 0x63696e75, // 'unic'
    DWRITE_FONT_FEATURE_TAG_SLASHED_ZERO                        = 0x6f72657a, // 'zero'
};

/// <summary>
/// The DWRITE_TEXT_RANGE structure specifies a range of text positions where format is applied.
/// </summary>
struct DWRITE_TEXT_RANGE
{
    /// <summary>
    /// The start text position of the range.
    /// </summary>
    UINT32 startPosition;

    /// <summary>
    /// The number of text positions in the range.
    /// </summary>
    UINT32 length;
};

/// <summary>
/// The DWRITE_FONT_FEATURE structure specifies properties used to identify and execute typographic feature in the font.
/// </summary>
struct DWRITE_FONT_FEATURE
{
    /// <summary>
    /// The feature OpenType name identifier.
    /// </summary>
    DWRITE_FONT_FEATURE_TAG nameTag;

    /// <summary>
    /// Execution parameter of the feature.
    /// </summary>
    /// <remarks>
    /// The parameter should be non-zero to enable the feature.  Once enabled, a feature can't be disabled again within
    /// the same range.  Features requiring a selector use this value to indicate the selector index. 
    /// </remarks>
    UINT32 parameter;
};

/// <summary>
/// Defines a set of typographic features to be applied during shaping.
/// Notice the character range which this feature list spans is specified
/// as a separate parameter to GetGlyphs.
/// </summary>
struct DWRITE_TYPOGRAPHIC_FEATURES
{
    /// <summary>
    /// Array of font features.
    /// </summary>
    __field_ecount(featureCount) DWRITE_FONT_FEATURE* features;

    /// <summary>
    /// The number of features.
    /// </summary>
    UINT32 featureCount;
};

/// <summary>
/// The DWRITE_TRIMMING structure specifies the trimming option for text overflowing the layout box.
/// </summary>
struct DWRITE_TRIMMING
{
    /// <summary>
    /// Text granularity of which trimming applies.
    /// </summary>
    DWRITE_TRIMMING_GRANULARITY granularity;

    /// <summary>
    /// Character code used as the delimiter signaling the beginning of the portion of text to be preserved,
    /// most useful for path ellipsis, where the delimeter would be a slash.
    /// </summary>
    UINT32 delimiter;

    /// <summary>
    /// How many occurences of the delimiter to step back.
    /// </summary>
    UINT32 delimiterCount;
};


interface IDWriteTypography;
interface IDWriteInlineObject;

/// <summary>
/// The format of text used for text layout purpose.
/// </summary>
/// <remarks>
/// This object may not be thread-safe and it may carry the state of text format change.
/// </remarks>
interface DWRITE_DECLARE_INTERFACE("9c906818-31d7-4fd3-a151-7c5e225db55a") IDWriteTextFormat : public IUnknown
{
    /// <summary>
    /// Set alignment option of text relative to layout box's leading and trailing edge.
    /// </summary>
    /// <param name="textAlignment">Text alignment option</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(SetTextAlignment)(
        DWRITE_TEXT_ALIGNMENT textAlignment
        ) PURE;

    /// <summary>
    /// Set alignment option of paragraph relative to layout box's top and bottom edge.
    /// </summary>
    /// <param name="paragraphAlignment">Paragraph alignment option</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(SetParagraphAlignment)(
        DWRITE_PARAGRAPH_ALIGNMENT paragraphAlignment
        ) PURE;

    /// <summary>
    /// Set word wrapping option.
    /// </summary>
    /// <param name="wordWrapping">Word wrapping option</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(SetWordWrapping)(
        DWRITE_WORD_WRAPPING wordWrapping
        ) PURE;

    /// <summary>
    /// Set paragraph reading direction.
    /// </summary>
    /// <param name="readingDirection">Text reading direction</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(SetReadingDirection)(
        DWRITE_READING_DIRECTION readingDirection
        ) PURE;

    /// <summary>
    /// Set paragraph flow direction.
    /// </summary>
    /// <param name="flowDirection">Paragraph flow direction</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(SetFlowDirection)(
        DWRITE_FLOW_DIRECTION flowDirection
        ) PURE;

    /// <summary>
    /// Set incremental tab stop position.
    /// </summary>
    /// <param name="incrementalTabStop">The incremental tab stop value</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(SetIncrementalTabStop)(
        FLOAT incrementalTabStop
        ) PURE;

    /// <summary>
    /// Set trimming options for any trailing text exceeding the layout width
    /// or for any far text exceeding the layout height.
    /// </summary>
    /// <param name="trimmingOptions">Text trimming options.</param>
    /// <param name="trimmingSign">Application-defined omission sign. This parameter may be NULL if no trimming sign is desired.</param>
    /// <remarks>
    /// Any inline object can be used for the trimming sign, but CreateEllipsisTrimmingSign
    /// provides a typical ellipsis symbol. Trimming is also useful vertically for hiding
    /// partial lines.
    /// </remarks>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(SetTrimming)(
        __in DWRITE_TRIMMING const* trimmingOptions,
        IDWriteInlineObject* trimmingSign
        ) PURE;

    /// <summary>
    /// Set line spacing.
    /// </summary>
    /// <param name="lineSpacingMethod">How to determine line height.</param>
    /// <param name="lineSpacing">The line height, or rather distance between one baseline to another.</param>
    /// <param name="baseline">Distance from top of line to baseline. A reasonable ratio to lineSpacing is 80%.</param>
    /// <remarks>
    /// For the default method, spacing depends solely on the content.
    /// For uniform spacing, the given line height will override the content.
    /// </remarks>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(SetLineSpacing)(
        DWRITE_LINE_SPACING_METHOD lineSpacingMethod,
        FLOAT lineSpacing,
        FLOAT baseline
        ) PURE;

    /// <summary>
    /// Get alignment option of text relative to layout box's leading and trailing edge.
    /// </summary>
    STDMETHOD_(DWRITE_TEXT_ALIGNMENT, GetTextAlignment)() PURE;

    /// <summary>
    /// Get alignment option of paragraph relative to layout box's top and bottom edge.
    /// </summary>
    STDMETHOD_(DWRITE_PARAGRAPH_ALIGNMENT, GetParagraphAlignment)() PURE;

    /// <summary>
    /// Get word wrapping option.
    /// </summary>
    STDMETHOD_(DWRITE_WORD_WRAPPING, GetWordWrapping)() PURE;

    /// <summary>
    /// Get paragraph reading direction.
    /// </summary>
    STDMETHOD_(DWRITE_READING_DIRECTION, GetReadingDirection)() PURE;

    /// <summary>
    /// Get paragraph flow direction.
    /// </summary>
    STDMETHOD_(DWRITE_FLOW_DIRECTION, GetFlowDirection)() PURE;

    /// <summary>
    /// Get incremental tab stop position.
    /// </summary>
    STDMETHOD_(FLOAT, GetIncrementalTabStop)() PURE;

    /// <summary>
    /// Get trimming options for text overflowing the layout width.
    /// </summary>
    /// <param name="trimmingOptions">Text trimming options.</param>
    /// <param name="trimmingSign">Trimming omission sign. This parameter may be NULL.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetTrimming)(
        __out DWRITE_TRIMMING* trimmingOptions,
        __out IDWriteInlineObject** trimmingSign
        ) PURE;

    /// <summary>
    /// Get line spacing.
    /// </summary>
    /// <param name="lineSpacingMethod">How line height is determined.</param>
    /// <param name="lineSpacing">The line height, or rather distance between one baseline to another.</param>
    /// <param name="baseline">Distance from top of line to baseline.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetLineSpacing)(
        __out DWRITE_LINE_SPACING_METHOD* lineSpacingMethod,
        __out FLOAT* lineSpacing,
        __out FLOAT* baseline
        ) PURE;

    /// <summary>
    /// Get the font collection.
    /// </summary>
    /// <param name="fontCollection">The current font collection.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetFontCollection)(
        __out IDWriteFontCollection** fontCollection
        ) PURE;

    /// <summary>
    /// Get the length of the font family name, in characters, not including the terminating NULL character.
    /// </summary>
    STDMETHOD_(UINT32, GetFontFamilyNameLength)() PURE;

    /// <summary>
    /// Get a copy of the font family name.
    /// </summary>
    /// <param name="fontFamilyName">Character array that receives the current font family name</param>
    /// <param name="nameSize">Size of the character array in character count including the terminated NULL character.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetFontFamilyName)(
        __out_ecount_z(nameSize) WCHAR* fontFamilyName,
        UINT32 nameSize
        ) PURE;

    /// <summary>
    /// Get the font weight.
    /// </summary>
    STDMETHOD_(DWRITE_FONT_WEIGHT, GetFontWeight)() PURE;

    /// <summary>
    /// Get the font style.
    /// </summary>
    STDMETHOD_(DWRITE_FONT_STYLE, GetFontStyle)() PURE;

    /// <summary>
    /// Get the font stretch.
    /// </summary>
    STDMETHOD_(DWRITE_FONT_STRETCH, GetFontStretch)() PURE;

    /// <summary>
    /// Get the font em height.
    /// </summary>
    STDMETHOD_(FLOAT, GetFontSize)() PURE;

    /// <summary>
    /// Get the length of the locale name, in characters, not including the terminating NULL character.
    /// </summary>
    STDMETHOD_(UINT32, GetLocaleNameLength)() PURE;

    /// <summary>
    /// Get a copy of the locale name.
    /// </summary>
    /// <param name="localeName">Character array that receives the current locale name</param>
    /// <param name="nameSize">Size of the character array in character count including the terminated NULL character.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetLocaleName)(
        __out_ecount_z(nameSize) WCHAR* localeName,
        UINT32 nameSize
        ) PURE;
};


/// <summary>
/// Font typography setting.
/// </summary>
interface DWRITE_DECLARE_INTERFACE("55f1112b-1dc2-4b3c-9541-f46894ed85b6") IDWriteTypography : public IUnknown
{
    /// <summary>
    /// Add font feature.
    /// </summary>
    /// <param name="fontFeature">The font feature to add.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(AddFontFeature)(
        DWRITE_FONT_FEATURE fontFeature
        ) PURE;

    /// <summary>
    /// Get the number of font features.
    /// </summary>
    STDMETHOD_(UINT32, GetFontFeatureCount)() PURE;

    /// <summary>
    /// Get the font feature at the specified index.
    /// </summary>
    /// <param name="fontFeatureIndex">The zero-based index of the font feature to get.</param>
    /// <param name="fontFeature">The font feature.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetFontFeature)(
        UINT32 fontFeatureIndex,
        __out DWRITE_FONT_FEATURE* fontFeature
        ) PURE;
};

enum DWRITE_SCRIPT_SHAPES
{
    /// <summary>
    /// No additional shaping requirement. Text is shaped with the writing system default behavior.
    /// </summary>
    DWRITE_SCRIPT_SHAPES_DEFAULT = 0,

    /// <summary>
    /// Text should leave no visual on display i.e. control or format control characters.
    /// </summary>
    DWRITE_SCRIPT_SHAPES_NO_VISUAL = 1
};

#ifdef DEFINE_ENUM_FLAG_OPERATORS
DEFINE_ENUM_FLAG_OPERATORS(DWRITE_SCRIPT_SHAPES);
#endif

/// <summary>
/// Association of text and its writing system script as well as some display attributes.
/// </summary>
struct DWRITE_SCRIPT_ANALYSIS
{
    /// <summary>
    /// Zero-based index representation of writing system script.
    /// </summary>
    UINT16 script;

    /// <summary>
    /// Additional shaping requirement of text.
    /// </summary>
    DWRITE_SCRIPT_SHAPES shapes;
};

/// <summary>
/// Condition at the edges of inline object or text used to determine
/// line-breaking behavior.
/// </summary>
enum DWRITE_BREAK_CONDITION
{
    /// <summary>
    /// Whether a break is allowed is determined by the condition of the
    /// neighboring text span or inline object.
    /// </summary>
    DWRITE_BREAK_CONDITION_NEUTRAL,

    /// <summary>
    /// A break is allowed, unless overruled by the condition of the
    /// neighboring text span or inline object, either prohibited by a
    /// May Not or forced by a Must.
    /// </summary>
    DWRITE_BREAK_CONDITION_CAN_BREAK,

    /// <summary>
    /// There should be no break, unless overruled by a Must condition from
    /// the neighboring text span or inline object.
    /// </summary>
    DWRITE_BREAK_CONDITION_MAY_NOT_BREAK,

    /// <summary>
    /// The break must happen, regardless of the condition of the adjacent
    /// text span or inline object.
    /// </summary>
    DWRITE_BREAK_CONDITION_MUST_BREAK
};

/// <summary>
/// Line breakpoint characteristics of a character.
/// </summary>
struct DWRITE_LINE_BREAKPOINT
{
    /// <summary>
    /// Breaking condition before the character.
    /// </summary>
    UINT8 breakConditionBefore  : 2;

    /// <summary>
    /// Breaking condition after the character.
    /// </summary>
    UINT8 breakConditionAfter   : 2;

    /// <summary>
    /// The character is some form of whitespace, which may be meaningful
    /// for justification.
    /// </summary>
    UINT8 isWhitespace          : 1;

    /// <summary>
    /// The character is a soft hyphen, often used to indicate hyphenation
    /// points inside words.
    /// </summary>
    UINT8 isSoftHyphen          : 1;

    UINT8 padding               : 2;
};

/// <summary>
/// How to apply number substitution on digits and related punctuation.
/// </summary>
enum DWRITE_NUMBER_SUBSTITUTION_METHOD
{
    /// <summary>
    /// Specifies that the substitution method should be determined based
    /// on LOCALE_IDIGITSUBSTITUTION value of the specified text culture.
    /// </summary>
    DWRITE_NUMBER_SUBSTITUTION_METHOD_FROM_CULTURE,

    /// <summary>
    /// If the culture is Arabic or Farsi, specifies that the number shape
    /// depend on the context. Either traditional or nominal number shape
    /// are used depending on the nearest preceding strong character or (if
    /// there is none) the reading direction of the paragraph.
    /// </summary>
    DWRITE_NUMBER_SUBSTITUTION_METHOD_CONTEXTUAL,

    /// <summary>
    /// Specifies that code points 0x30-0x39 are always rendered as nominal numeral 
    /// shapes (ones of the European number), i.e., no substitution is performed.
    /// </summary>
    DWRITE_NUMBER_SUBSTITUTION_METHOD_NONE,

    /// <summary>
    /// Specifies that number are rendered using the national number shape 
    /// as specified by the LOCALE_SNATIVEDIGITS value of the specified text culture.
    /// </summary>
    DWRITE_NUMBER_SUBSTITUTION_METHOD_NATIONAL,

    /// <summary>
    /// Specifies that number are rendered using the traditional shape
    /// for the specified culture. For most cultures, this is the same as
    /// NativeNational. However, NativeNational results in Latin number
    /// for some Arabic cultures, whereas this value results in Arabic
    /// number for all Arabic cultures.
    /// </summary>
    DWRITE_NUMBER_SUBSTITUTION_METHOD_TRADITIONAL
};

/// <summary>
/// Holds the appropriate digits and numeric punctuation for a given locale.
/// </summary>
interface DECLSPEC_UUID("14885CC9-BAB0-4f90-B6ED-5C366A2CD03D") DECLSPEC_NOVTABLE IDWriteNumberSubstitution : public IUnknown
{
};

/// <summary>
/// Shaping output properties per input character.
/// </summary>
struct DWRITE_SHAPING_TEXT_PROPERTIES
{
    /// <summary>
    /// This character can be shaped independently from the others
    /// (usually set for the space character).
    /// </summary>
    UINT16  isShapedAlone       : 1;

    /// <summary>
    /// Reserved for use by shaping engine.
    /// </summary>
    UINT16  reserved            : 15;
};

/// <summary>
/// Shaping output properties per output glyph.
/// </summary>
struct DWRITE_SHAPING_GLYPH_PROPERTIES
{
    /// <summary>
    /// Justification class, whether to use spacing, kashidas, or
    /// another method. This exists for backwards compatibility
    /// with Uniscribe's SCRIPT_JUSTIFY enum.
    /// </summary>
    UINT16  justification       : 4;

    /// <summary>
    /// Indicates glyph is the first of a cluster.
    /// </summary>
    UINT16  isClusterStart      : 1;

    /// <summary>
    /// Glyph is a diacritic.
    /// </summary>
    UINT16  isDiacritic         : 1;

    /// <summary>
    /// Glyph has no width, blank, ZWJ, ZWNJ etc.
    /// </summary>
    UINT16  isZeroWidthSpace    : 1;

    /// <summary>
    /// Reserved for use by shaping engine.
    /// </summary>
    UINT16  reserved            : 9;
};

/// <summary>
/// The interface implemented by the text analyzer's client to provide text to
/// the analyzer. It allows the separation between the logical view of text as
/// a continuous stream of characters identifiable by unique text positions,
/// and the actual memory layout of potentially discrete blocks of text in the
/// client's backing store.
///
/// If any of these callbacks returns an error, the analysis functions will
/// stop prematurely and return a callback error. Rather than return E_NOTIMPL,
/// an application should stub the method and return a constant/null and S_OK.
/// </summary>
interface DECLSPEC_UUID("688e1a58-5094-47c8-adc8-fbcea60ae92b") DECLSPEC_NOVTABLE IDWriteTextAnalysisSource : public IUnknown
{
    /// <summary>
    /// Get a block of text starting at the specified text position.
    /// Returning NULL indicates the end of text - the position is after
    /// the last character. This function is called iteratively for
    /// each consecutive block, tying together several fragmented blocks
    /// in the backing store into a virtual contiguous string.
    /// </summary>
    /// <param name="textPosition">First position of the piece to obtain. All
    ///     positions are in UTF16 code-units, not whole characters, which
    ///     matters when supplementary characters are used.</param>
    /// <param name="textString">Address that receives a pointer to the text block
    ///     at the specified position.</param>
    /// <param name="textLength">Number of UTF16 units of the retrieved chunk.
    ///     The returned length is not the length of the block, but the length
    ///     remaining in the block, from the given position until its end.
    ///     So querying for a position that is 75 positions into a 100
    ///     postition block would return 25.</param>
    /// <returns>Pointer to the first character at the given text position.
    /// NULL indicates no chunk available at the specified position, either
    /// because textPosition >= the entire text content length or because the
    /// queried position is not mapped into the app's backing store.</returns>
    /// <remarks>
    /// Although apps can implement sparse textual content that only maps part of
    /// the backing store, the app must map any text that is in the range passed
    /// to any analysis functions.
    /// </remarks>
    STDMETHOD(GetTextAtPosition)(
        UINT32 textPosition,
        __out WCHAR const** textString,
        __out UINT32* textLength
        ) PURE;

    /// <summary>
    /// Get a block of text immediately preceding the specified position.
    /// </summary>
    /// <param name="textPosition">Position immediately after the last position of the chunk to obtain.</param>
    /// <param name="textString">Address that receives a pointer to the text block
    ///     at the specified position.</param>
    /// <param name="textLength">Number of UTF16 units of the retrieved block.
    ///     The length returned is from the given position to the front of
    ///     the block.</param>
    /// <returns>Pointer to the first character at (textPosition - textLength).
    /// NULL indicates no chunk available at the specified position, either
    /// because textPosition == 0,the textPosition > the entire text content
    /// length, or the queried position is not mapped into the app's backing
    /// store.</returns>
    /// <remarks>
    /// Although apps can implement sparse textual content that only maps part of
    /// the backing store, the app must map any text that is in the range passed
    /// to any analysis functions.
    /// </remarks>
    STDMETHOD(GetTextBeforePosition)(
        UINT32 textPosition,
        __out WCHAR const** textString,
        __out UINT32* textLength
        ) PURE;

    /// <summary>
    /// Get paragraph reading direction.
    /// </summary>
    STDMETHOD_(DWRITE_READING_DIRECTION, GetParagraphReadingDirection)() PURE;

    /// <summary>
    /// Get locale name on the range affected by it.
    /// </summary>
    /// <param name="textPosition">Position to get the locale name of.</param>
    /// <param name="textLength">Receives the length from the given position up to the
    ///     next differing locale.</param>
    /// <param name="localeName">Address that receives a pointer to the locale
    ///     at the specified position.</param>
    /// <remarks>
    /// The localeName pointer must remain valid until the next call or until
    /// the analysis returns.
    /// </remarks>
    STDMETHOD(GetLocaleName)(
        UINT32 textPosition,
        __out UINT32* textLength,
        __out_z WCHAR const** localeName
        ) PURE;

    /// <summary>
    /// Get number substitution on the range affected by it.
    /// </summary>
    /// <param name="textPosition">Position to get the number substitution of.</param>
    /// <param name="textLength">Receives the length from the given position up to the
    ///     next differing number substitution.</param>
    /// <param name="numberSubstitution">Address that receives a pointer to the number substitution
    ///     at the specified position.</param>
    /// <remarks>
    /// Any implementation should return the number substitution with an
    /// incremented ref count, and the analysis will release when finished
    /// with it (either before the next call or before it returns). However,
    /// the sink callback may hold onto it after that.
    /// </remarks>
    STDMETHOD(GetNumberSubstitution)(
        UINT32 textPosition,
        __out UINT32* textLength,
        __out IDWriteNumberSubstitution** numberSubstitution
        ) PURE;
};

/// <summary>
/// The interface implemented by the text analyzer's client to receive the
/// output of a given text analysis. The Text analyzer disregards any current
/// state of the analysis sink, therefore a Set method call on a range
/// overwrites the previously set analysis result of the same range. 
/// </summary>
interface DECLSPEC_UUID("5810cd44-0ca0-4701-b3fa-bec5182ae4f6") DECLSPEC_NOVTABLE IDWriteTextAnalysisSink : public IUnknown
{
    /// <summary>
    /// Report script analysis for the text range.
    /// </summary>
    /// <param name="textPosition">Starting position to report from.</param>
    /// <param name="textLength">Number of UTF16 units of the reported range.</param>
    /// <param name="scriptAnalysis">Script analysis of characters in range.</param>
    /// <returns>
    /// A successful code or error code to abort analysis.
    /// </returns>
    STDMETHOD(SetScriptAnalysis)(
        UINT32 textPosition,
        UINT32 textLength,
        __in DWRITE_SCRIPT_ANALYSIS const* scriptAnalysis
        ) PURE;

    /// <summary>
    /// Repport line-break opportunities for each character, starting from
    /// the specified position.
    /// </summary>
    /// <param name="textPosition">Starting position to report from.</param>
    /// <param name="textLength">Number of UTF16 units of the reported range.</param>
    /// <param name="lineBreakpoints">Breaking conditions for each character.</param>
    /// <returns>
    /// A successful code or error code to abort analysis.
    /// </returns>
    STDMETHOD(SetLineBreakpoints)(
        UINT32 textPosition,
        UINT32 textLength,
        __in_ecount(textLength) DWRITE_LINE_BREAKPOINT const* lineBreakpoints
        ) PURE;

    /// <summary>
    /// Set bidirectional level on the range, called once per each
    /// level run change (either explicit or resolved implicit).
    /// </summary>
    /// <param name="textPosition">Starting position to report from.</param>
    /// <param name="textLength">Number of UTF16 units of the reported range.</param>
    /// <param name="explicitLevel">Explicit level from embedded control codes
    ///     RLE/RLO/LRE/LRO/PDF, determined before any additional rules.</param>
    /// <param name="resolvedLevel">Final implicit level considering the
    ///     explicit level and characters' natural directionality, after all
    ///     Bidi rules have been applied.</param>
    /// <returns>
    /// A successful code or error code to abort analysis.
    /// </returns>
    STDMETHOD(SetBidiLevel)(
        UINT32 textPosition,
        UINT32 textLength,
        UINT8 explicitLevel,
        UINT8 resolvedLevel
        ) PURE;

    /// <summary>
    /// Set number substitution on the range.
    /// </summary>
    /// <param name="textPosition">Starting position to report from.</param>
    /// <param name="textLength">Number of UTF16 units of the reported range.</param>
    /// <param name="numberSubstitution">The number substitution applicable to
    ///     the returned range of text. The sink callback may hold onto it by
    ///     incrementing its ref count.</param>
    /// <returns>
    /// A successful code or error code to abort analysis.
    /// </returns>
    /// <remark>
    /// Unlike script and bidi analysis, where every character passed to the
    /// analyzer has a result, this will only be called for those ranges where
    /// substitution is applicable. For any other range, you will simply not
    /// be called.
    /// </remark>
    STDMETHOD(SetNumberSubstitution)(
        UINT32 textPosition,
        UINT32 textLength,
        __notnull IDWriteNumberSubstitution* numberSubstitution
        ) PURE;
};

/// <summary>
/// Analyzes various text properties for complex script processing.
/// </summary>
interface DWRITE_DECLARE_INTERFACE("b7e6163e-7f46-43b4-84b3-e4e6249c365d") IDWriteTextAnalyzer : public IUnknown
{
    /// <summary>
    /// Analyzes a text range for script boundaries, reading text attributes
    /// from the source and reporting the Unicode script ID to the sink 
    /// callback SetScript.
    /// </summary>
    /// <param name="analysisSource">Source object to analyze.</param>
    /// <param name="textPosition">Starting position within the source object.</param>
    /// <param name="textLength">Length to analyze.</param>
    /// <param name="analysisSink">Callback object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(AnalyzeScript)(
        IDWriteTextAnalysisSource* analysisSource,
        UINT32 textPosition,
        UINT32 textLength,
        IDWriteTextAnalysisSink* analysisSink
        ) PURE;

    /// <summary>
    /// Analyzes a text range for script directionality, reading attributes
    /// from the source and reporting levels to the sink callback SetBidiLevel.
    /// </summary>
    /// <param name="analysisSource">Source object to analyze.</param>
    /// <param name="textPosition">Starting position within the source object.</param>
    /// <param name="textLength">Length to analyze.</param>
    /// <param name="analysisSink">Callback object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// While the function can handle multiple paragraphs, the text range
    /// should not arbitrarily split the middle of paragraphs. Otherwise the
    /// returned levels may be wrong, since the Bidi algorithm is meant to
    /// apply to the paragraph as a whole.
    /// </remarks>
    /// <remarks>
    /// Embedded control codes (LRE/LRO/RLE/RLO/PDF) are taken into account.
    /// </remarks>
    STDMETHOD(AnalyzeBidi)(
        IDWriteTextAnalysisSource* analysisSource,
        UINT32 textPosition,
        UINT32 textLength,
        IDWriteTextAnalysisSink* analysisSink
        ) PURE;

    /// <summary>
    /// Analyzes a text range for spans where number substitution is applicable,
    /// reading attributes from the source and reporting substitutable ranges
    /// to the sink callback SetNumberSubstitution.
    /// </summary>
    /// <param name="analysisSource">Source object to analyze.</param>
    /// <param name="textPosition">Starting position within the source object.</param>
    /// <param name="textLength">Length to analyze.</param>
    /// <param name="analysisSink">Callback object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// While the function can handle multiple ranges of differing number
    /// substitutions, the text ranges should not arbitrarily split the
    /// middle of numbers. Otherwise it will treat the numbers separately
    /// and will not translate any intervening punctuation.
    /// </remarks>
    /// <remarks>
    /// Embedded control codes (LRE/LRO/RLE/RLO/PDF) are taken into account.
    /// </remarks>
    STDMETHOD(AnalyzeNumberSubstitution)(
        IDWriteTextAnalysisSource* analysisSource,
        UINT32 textPosition,
        UINT32 textLength,
        IDWriteTextAnalysisSink* analysisSink
        ) PURE;

    /// <summary>
    /// Analyzes a text range for potential breakpoint opportunities, reading
    /// attributes from the source and reporting breakpoint opportunities to
    /// the sink callback SetLineBreakpoints.
    /// </summary>
    /// <param name="analysisSource">Source object to analyze.</param>
    /// <param name="textPosition">Starting position within the source object.</param>
    /// <param name="textLength">Length to analyze.</param>
    /// <param name="analysisSink">Callback object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// While the function can handle multiple paragraphs, the text range
    /// should not arbitrarily split the middle of paragraphs, unless the
    /// given text span is considered a whole unit. Otherwise the
    /// returned properties for the first and last characters will
    /// inappropriately allow breaks.
    /// </remarks>
    /// <remarks>
    /// Special cases include the first, last, and surrogate characters. Any
    /// text span is treated as if adjacent to inline objects on either side.
    /// So the rules with contingent-break opportunities are used, where the 
    /// edge between text and inline objects is always treated as a potential
    /// break opportunity, dependent on any overriding rules of the adjacent
    /// objects to prohibit or force the break (see Unicode TR #14).
    /// Surrogate pairs never break between.
    /// </remarks>
    STDMETHOD(AnalyzeLineBreakpoints)(
        IDWriteTextAnalysisSource* analysisSource,
        UINT32 textPosition,
        UINT32 textLength,
        IDWriteTextAnalysisSink* analysisSink
        ) PURE;

    /// <summary>
    /// Parses the input text string and maps it to the set of glyphs and associated glyph data
    /// according to the font and the writing system's rendering rules.
    /// </summary>
    /// <param name="textString">The string to convert to glyphs.</param>
    /// <param name="textLength">The length of textString.</param>
    /// <param name="fontFace">The font face to get glyphs from.</param>
    /// <param name="isSideways">Set to true if the text is intended to be
    /// drawn vertically.</param>
    /// <param name="isRightToLeft">Set to TRUE for right-to-left text.</param>
    /// <param name="scriptAnalysis">Script analysis result from AnalyzeScript.</param>
    /// <param name="localeName">The locale to use when selecting glyphs.
    /// e.g. the same character may map to different glyphs for ja-jp vs zh-chs.
    /// If this is NULL then the default mapping based on the script is used.</param>
    /// <param name="numberSubstitution">Optional number substitution which
    /// selects the appropriate glyphs for digits and related numeric characters,
    /// depending on the results obtained from AnalyzeNumberSubstitution. Passing
    /// null indicates that no substitution is needed and that the digits should
    /// receive nominal glyphs.</param>
    /// <param name="features">An array of pointers to the sets of typographic 
    /// features to use in each feature range.</param>
    /// <param name="featureRangeLengths">The length of each feature range, in characters.  
    /// The sum of all lengths should be equal to textLength.</param>
    /// <param name="featureRanges">The number of feature ranges.</param>
    /// <param name="maxGlyphCount">The maximum number of glyphs that can be
    /// returned.</param>
    /// <param name="clusterMap">The mapping from character ranges to glyph 
    /// ranges.</param>
    /// <param name="textProps">Per-character output properties.</param>
    /// <param name="glyphIndices">Output glyph indices.</param>
    /// <param name="glyphProps">Per-glyph output properties.</param>
    /// <param name="actualGlyphCount">The actual number of glyphs returned if
    /// the call succeeds.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// Note that the mapping from characters to glyphs is, in general, many-
    /// to-many.  The recommended estimate for the per-glyph output buffers is
    /// (3 * textLength / 2 + 16).  This is not guaranteed to be sufficient.
    ///
    /// The value of the actualGlyphCount parameter is only valid if the call
    /// succeeds.  In the event that maxGlyphCount is not big enough
    /// E_NOT_SUFFICIENT_BUFFER, which is equivalent to HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER),
    /// will be returned.  The application should allocate a larger buffer and try again.
    /// </remarks>
    STDMETHOD(GetGlyphs)(
        __in_ecount(textLength) WCHAR const* textString,
        UINT32 textLength,
        IDWriteFontFace* fontFace,
        BOOL isSideways,
        BOOL isRightToLeft,
        __in DWRITE_SCRIPT_ANALYSIS const* scriptAnalysis,
        __in_z_opt WCHAR const* localeName,
        __maybenull IDWriteNumberSubstitution* numberSubstitution,
        __in_ecount_opt(featureRanges) DWRITE_TYPOGRAPHIC_FEATURES const** features,
        __in_ecount_opt(featureRanges) UINT32 const* featureRangeLengths,
        UINT32 featureRanges,
        UINT32 maxGlyphCount,
        __out_ecount(textLength) UINT16* clusterMap,
        __out_ecount(textLength) DWRITE_SHAPING_TEXT_PROPERTIES* textProps,
        __out_ecount(maxGlyphCount) UINT16* glyphIndices,
        __out_ecount(maxGlyphCount) DWRITE_SHAPING_GLYPH_PROPERTIES* glyphProps,
        __out UINT32* actualGlyphCount
        ) PURE;

    /// <summary>
    /// Place glyphs output from the GetGlyphs method according to the font 
    /// and the writing system's rendering rules.
    /// </summary>
    /// <param name="textString">The original string the glyphs came from.</param>
    /// <param name="clusterMap">The mapping from character ranges to glyph 
    /// ranges. Returned by GetGlyphs.</param>
    /// <param name="textProps">Per-character properties. Returned by 
    /// GetGlyphs.</param>
    /// <param name="textLength">The length of textString.</param>
    /// <param name="glyphIndices">Glyph indices. See GetGlyphs</param>
    /// <param name="glyphProps">Per-glyph properties. See GetGlyphs</param>
    /// <param name="glyphCount">The number of glyphs.</param>
    /// <param name="fontFace">The font face the glyphs came from.</param>
    /// <param name="fontEmSize">Logical font size in DIP's.</param>
    /// <param name="isSideways">Set to true if the text is intended to be
    /// drawn vertically.</param>
    /// <param name="isRightToLeft">Set to TRUE for right-to-left text.</param>
    /// <param name="scriptAnalysis">Script analysis result from AnalyzeScript.</param>
    /// <param name="localeName">The locale to use when selecting glyphs.
    /// e.g. the same character may map to different glyphs for ja-jp vs zh-chs.
    /// If this is NULL then the default mapping based on the script is used.</param>
    /// <param name="features">An array of pointers to the sets of typographic 
    /// features to use in each feature range.</param>
    /// <param name="featureRangeLengths">The length of each feature range, in characters.  
    /// The sum of all lengths should be equal to textLength.</param>
    /// <param name="featureRanges">The number of feature ranges.</param>
    /// <param name="glyphAdvances">The advance width of each glyph.</param>
    /// <param name="glyphOffsets">The offset of the origin of each glyph.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetGlyphPlacements)(
        __in_ecount(textLength) WCHAR const* textString,
        __in_ecount(textLength) UINT16 const* clusterMap,
        __in_ecount(textLength) DWRITE_SHAPING_TEXT_PROPERTIES* textProps,
        UINT32 textLength,
        __in_ecount(glyphCount) UINT16 const* glyphIndices,
        __in_ecount(glyphCount) DWRITE_SHAPING_GLYPH_PROPERTIES const* glyphProps,
        UINT32 glyphCount,
        IDWriteFontFace * fontFace,
        FLOAT fontEmSize,
        BOOL isSideways,
        BOOL isRightToLeft,
        __in DWRITE_SCRIPT_ANALYSIS const* scriptAnalysis,
        __in_z_opt WCHAR const* localeName,
        __in_ecount_opt(featureRanges) DWRITE_TYPOGRAPHIC_FEATURES const** features,
        __in_ecount_opt(featureRanges) UINT32 const* featureRangeLengths,
        UINT32 featureRanges,
        __out_ecount(glyphCount) FLOAT* glyphAdvances,
        __out_ecount(glyphCount) DWRITE_GLYPH_OFFSET* glyphOffsets
        ) PURE;

    /// <summary>
    /// Place glyphs output from the GetGlyphs method according to the font 
    /// and the writing system's rendering rules.
    /// </summary>
    /// <param name="textString">The original string the glyphs came from.</param>
    /// <param name="clusterMap">The mapping from character ranges to glyph 
    /// ranges. Returned by GetGlyphs.</param>
    /// <param name="textProps">Per-character properties. Returned by 
    /// GetGlyphs.</param>
    /// <param name="textLength">The length of textString.</param>
    /// <param name="glyphIndices">Glyph indices. See GetGlyphs</param>
    /// <param name="glyphProps">Per-glyph properties. See GetGlyphs</param>
    /// <param name="glyphCount">The number of glyphs.</param>
    /// <param name="fontFace">The font face the glyphs came from.</param>
    /// <param name="fontEmSize">Logical font size in DIP's.</param>
    /// <param name="pixelsPerDip">Number of physical pixels per DIP. For example, if the DPI of the rendering surface is 96 this 
    /// value is 1.0f. If the DPI is 120, this value is 120.0f/96.</param>
    /// <param name="transform">Optional transform applied to the glyphs and their positions. This transform is applied after the
    /// scaling specified by the font size and pixelsPerDip.</param>
    /// <param name="useGdiNatural">
    /// When set to FALSE, the metrics are the same as the metrics of GDI aliased text.
    /// When set to TRUE, the metrics are the same as the metrics of text measured by GDI using a font
    /// created with CLEARTYPE_NATURAL_QUALITY.
    /// </param>
    /// <param name="isSideways">Set to true if the text is intended to be
    /// drawn vertically.</param>
    /// <param name="isRightToLeft">Set to TRUE for right-to-left text.</param>
    /// <param name="scriptAnalysis">Script analysis result from AnalyzeScript.</param>
    /// <param name="localeName">The locale to use when selecting glyphs.
    /// e.g. the same character may map to different glyphs for ja-jp vs zh-chs.
    /// If this is NULL then the default mapping based on the script is used.</param>
    /// <param name="features">An array of pointers to the sets of typographic 
    /// features to use in each feature range.</param>
    /// <param name="featureRangeLengths">The length of each feature range, in characters.  
    /// The sum of all lengths should be equal to textLength.</param>
    /// <param name="featureRanges">The number of feature ranges.</param>
    /// <param name="glyphAdvances">The advance width of each glyph.</param>
    /// <param name="glyphOffsets">The offset of the origin of each glyph.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetGdiCompatibleGlyphPlacements)(
        __in_ecount(textLength) WCHAR const* textString,
        __in_ecount(textLength) UINT16 const* clusterMap,
        __in_ecount(textLength) DWRITE_SHAPING_TEXT_PROPERTIES* textProps,
        UINT32 textLength,
        __in_ecount(glyphCount) UINT16 const* glyphIndices,
        __in_ecount(glyphCount) DWRITE_SHAPING_GLYPH_PROPERTIES const* glyphProps,
        UINT32 glyphCount,
        IDWriteFontFace * fontFace,
        FLOAT fontEmSize,
        FLOAT pixelsPerDip,
        __in_opt DWRITE_MATRIX const* transform,
        BOOL useGdiNatural,
        BOOL isSideways,
        BOOL isRightToLeft,
        __in DWRITE_SCRIPT_ANALYSIS const* scriptAnalysis,
        __in_z_opt WCHAR const* localeName,
        __in_ecount_opt(featureRanges) DWRITE_TYPOGRAPHIC_FEATURES const** features,
        __in_ecount_opt(featureRanges) UINT32 const* featureRangeLengths,
        UINT32 featureRanges,
        __out_ecount(glyphCount) FLOAT* glyphAdvances,
        __out_ecount(glyphCount) DWRITE_GLYPH_OFFSET* glyphOffsets
        ) PURE;
};

/// <summary>
/// The DWRITE_GLYPH_RUN structure contains the information needed by renderers
/// to draw glyph runs. All coordinates are in device independent pixels (DIPs).
/// </summary>
struct DWRITE_GLYPH_RUN
{
    /// <summary>
    /// The physical font face to draw with.
    /// </summary>
    __notnull IDWriteFontFace* fontFace;

    /// <summary>
    /// Logical size of the font in DIPs, not points (equals 1/96 inch).
    /// </summary>
    FLOAT fontEmSize;

    /// <summary>
    /// The number of glyphs.
    /// </summary>
    UINT32 glyphCount;

    /// <summary>
    /// The indices to render.
    /// </summary>    
    __field_ecount(glyphCount) UINT16 const* glyphIndices;

    /// <summary>
    /// Glyph advance widths.
    /// </summary>
    __field_ecount_opt(glyphCount) FLOAT const* glyphAdvances;

    /// <summary>
    /// Glyph offsets.
    /// </summary>
    __field_ecount_opt(glyphCount) DWRITE_GLYPH_OFFSET const* glyphOffsets;

    /// <summary>
    /// If true, specifies that glyphs are rotated 90 degrees to the left and
    /// vertical metrics are used. Vertical writing is achieved by specifying
    /// isSideways = true and rotating the entire run 90 degrees to the right
    /// via a rotate transform.
    /// </summary>
    BOOL isSideways;

    /// <summary>
    /// The implicit resolved bidi level of the run. Odd levels indicate
    /// right-to-left languages like Hebrew and Arabic, while even levels
    /// indicate left-to-right languages like English and Japanese (when
    /// written horizontally). For right-to-left languages, the text origin
    /// is on the right, and text should be drawn to the left.
    /// </summary>
    UINT32 bidiLevel;
};

/// <summary>
/// The DWRITE_GLYPH_RUN_DESCRIPTION structure contains additional properties
/// related to those in DWRITE_GLYPH_RUN.
/// </summary>
struct DWRITE_GLYPH_RUN_DESCRIPTION
{
    /// <summary>
    /// The locale name associated with this run.
    /// </summary>
    __nullterminated WCHAR const* localeName;

    /// <summary>
    /// The text associated with the glyphs.
    /// </summary>
    __field_ecount(stringLength) WCHAR const* string;

    /// <summary>
    /// The number of characters (UTF16 code-units).
    /// Note that this may be different than the number of glyphs.
    /// </summary>
    UINT32 stringLength;

    /// <summary>
    /// An array of indices to the glyph indices array, of the first glyphs of
    /// all the glyph clusters of the glyphs to render. 
    /// </summary>
    __field_ecount(stringLength) UINT16 const* clusterMap;

    /// <summary>
    /// Corresponding text position in the original string
    /// this glyph run came from.
    /// </summary>
    UINT32 textPosition;
};

/// <summary>
/// The DWRITE_UNDERLINE structure contains about the size and placement of 
/// underlines. All coordinates are in device independent pixels (DIPs).
/// </summary>
struct DWRITE_UNDERLINE
{
    /// <summary>
    /// Width of the underline, measured parallel to the baseline.
    /// </summary>
    FLOAT width;

    /// <summary>
    /// Thickness of the underline, measured perpendicular to the
    /// baseline.
    /// </summary>
    FLOAT thickness;

    /// <summary>
    /// Offset of the underline from the baseline.
    /// A positive offset represents a position below the baseline and
    /// a negative offset is above.
    /// </summary>
    FLOAT offset;

    /// <summary>
    /// Height of the tallest run where the underline applies.
    /// </summary>
    FLOAT runHeight;

    /// <summary>
    /// Reading direction of the text associated with the underline.  This 
    /// value is used to interpret whether the width value runs horizontally 
    /// or vertically.
    /// </summary>
    DWRITE_READING_DIRECTION readingDirection;

    /// <summary>
    /// Flow direction of the text associated with the underline.  This value
    /// is used to interpret whether the thickness value advances top to 
    /// bottom, left to right, or right to left.
    /// </summary>
    DWRITE_FLOW_DIRECTION flowDirection;

    /// <summary>
    /// Locale of the text the underline is being drawn under. Can be
    /// pertinent where the locale affects how the underline is drawn.
    /// For example, in vertical text, the underline belongs on the
    /// left for Chinese but on the right for Japanese.
    /// This choice is completely left up to higher levels.
    /// </summary>
    __nullterminated WCHAR const* localeName;

    /// <summary>
    /// The measuring mode can be useful to the renderer to determine how
    /// underlines are rendered, e.g. rounding the thickness to a whole pixel
    /// in GDI-compatible modes.
    /// </summary>
    DWRITE_MEASURING_MODE measuringMode;
};

/// <summary>
/// The DWRITE_STRIKETHROUGH structure contains about the size and placement of 
/// strickthroughs. All coordinates are in device independent pixels (DIPs).
/// </summary>
struct DWRITE_STRIKETHROUGH
{
    /// <summary>
    /// Width of the strikethrough, measured parallel to the baseline.
    /// </summary>
    FLOAT width;

    /// <summary>
    /// Thickness of the strikethrough, measured perpendicular to the
    /// baseline.
    /// </summary>
    FLOAT thickness;

    /// <summary>
    /// Offset of the stikethrough from the baseline.
    /// A positive offset represents a position below the baseline and
    /// a negative offset is above.
    /// </summary>
    FLOAT offset;

    /// <summary>
    /// Reading direction of the text associated with the strikethrough.  This
    /// value is used to interpret whether the width value runs horizontally 
    /// or vertically.
    /// </summary>
    DWRITE_READING_DIRECTION readingDirection;

    /// <summary>
    /// Flow direction of the text associated with the strikethrough.  This 
    /// value is used to interpret whether the thickness value advances top to
    /// bottom, left to right, or right to left.
    /// </summary>
    DWRITE_FLOW_DIRECTION flowDirection;

    /// <summary>
    /// Locale of the range. Can be pertinent where the locale affects the style.
    /// </summary>
    __nullterminated WCHAR const* localeName;

    /// <summary>
    /// The measuring mode can be useful to the renderer to determine how
    /// underlines are rendered, e.g. rounding the thickness to a whole pixel
    /// in GDI-compatible modes.
    /// </summary>
    DWRITE_MEASURING_MODE measuringMode;
};

/// <summary>
/// The DWRITE_LINE_METRICS structure contains information about a formatted
/// line of text.
/// </summary>
struct DWRITE_LINE_METRICS
{
    /// <summary>
    /// The number of total text positions in the line.
    /// This includes any trailing whitespace and newline characters.
    /// </summary>
    UINT32 length;

    /// <summary>
    /// The number of whitespace positions at the end of the line.  Newline
    /// sequences are considered whitespace.
    /// </summary>
    UINT32 trailingWhitespaceLength;

    /// <summary>
    /// The number of characters in the newline sequence at the end of the line.
    /// If the count is zero, then the line was either wrapped or it is the
    /// end of the text.
    /// </summary>
    UINT32 newlineLength;

    /// <summary>
    /// Height of the line as measured from top to bottom.
    /// </summary>
    FLOAT height;

    /// <summary>
    /// Distance from the top of the line to its baseline.
    /// </summary>
    FLOAT baseline;

    /// <summary>
    /// The line is trimmed.
    /// </summary>
    BOOL isTrimmed;
};


/// <summary>
/// The DWRITE_CLUSTER_METRICS structure contains information about a glyph cluster.
/// </summary>
struct DWRITE_CLUSTER_METRICS
{
    /// <summary>
    /// The total advance width of all glyphs in the cluster.
    /// </summary>
    FLOAT width;

    /// <summary>
    /// The number of text positions in the cluster.
    /// </summary>
    UINT16 length;

    /// <summary>
    /// Indicate whether line can be broken right after the cluster.
    /// </summary>
    UINT16 canWrapLineAfter : 1;

    /// <summary>
    /// Indicate whether the cluster corresponds to whitespace character.
    /// </summary>
    UINT16 isWhitespace : 1;

    /// <summary>
    /// Indicate whether the cluster corresponds to a newline character.
    /// </summary>
    UINT16 isNewline : 1;

    /// <summary>
    /// Indicate whether the cluster corresponds to soft hyphen character.
    /// </summary>
    UINT16 isSoftHyphen : 1;

    /// <summary>
    /// Indicate whether the cluster is read from right to left.
    /// </summary>
    UINT16 isRightToLeft : 1;

    UINT16 padding : 11;
};


/// <summary>
/// Overall metrics associated with text after layout.
/// All coordinates are in device independent pixels (DIPs).
/// </summary>
struct DWRITE_TEXT_METRICS
{
    /// <summary>
    /// Left-most point of formatted text relative to layout box
    /// (excluding any glyph overhang).
    /// </summary>
    FLOAT left;

    /// <summary>
    /// Top-most point of formatted text relative to layout box
    /// (excluding any glyph overhang).
    /// </summary>
    FLOAT top;

    /// <summary>
    /// The width of the formatted text ignoring trailing whitespace
    /// at the end of each line.
    /// </summary>
    FLOAT width;

    /// <summary>
    /// The width of the formatted text taking into account the
    /// trailing whitespace at the end of each line.
    /// </summary>
    FLOAT widthIncludingTrailingWhitespace;

    /// <summary>
    /// The height of the formatted text. The height of an empty string
    /// is determined by the size of the default font's line height.
    /// </summary>
    FLOAT height;

    /// <summary>
    /// Initial width given to the layout. Depending on whether the text
    /// was wrapped or not, it can be either larger or smaller than the
    /// text content width.
    /// </summary>
    FLOAT layoutWidth;

    /// <summary>
    /// Initial height given to the layout. Depending on the length of the
    /// text, it may be larger or smaller than the text content height.
    /// </summary>
    FLOAT layoutHeight;

    /// <summary>
    /// The maximum reordering count of any line of text, used
    /// to calculate the most number of hit-testing boxes needed.
    /// If the layout has no bidirectional text or no text at all,
    /// the minimum level is 1.
    /// </summary>
    UINT32 maxBidiReorderingDepth;

    /// <summary>
    /// Total number of lines.
    /// </summary>
    UINT32 lineCount;
};


/// <summary>
/// Properties describing the geometric measurement of an
/// application-defined inline object.
/// </summary>
struct DWRITE_INLINE_OBJECT_METRICS
{
    /// <summary>
    /// Width of the inline object.
    /// </summary>
    FLOAT width;

    /// <summary>
    /// Height of the inline object as measured from top to bottom.
    /// </summary>
    FLOAT height;

    /// <summary>
    /// Distance from the top of the object to the baseline where it is lined up with the adjacent text.
    /// If the baseline is at the bottom, baseline simply equals height.
    /// </summary>
    FLOAT baseline;

    /// <summary>
    /// Flag indicating whether the object is to be placed upright or alongside the text baseline
    /// for vertical text.
    /// </summary>
    BOOL  supportsSideways;
};


/// <summary>
/// The DWRITE_OVERHANG_METRICS structure holds how much any visible pixels
/// (in DIPs) overshoot each side of the layout or inline objects.
/// </summary>
/// <remarks>
/// Positive overhangs indicate that the visible area extends outside the layout
/// box or inline object, while negative values mean there is whitespace inside.
/// The returned values are unaffected by rendering transforms or pixel snapping.
/// Additionally, they may not exactly match final target's pixel bounds after
/// applying grid fitting and hinting.
/// </remarks>
struct DWRITE_OVERHANG_METRICS
{
    /// <summary>
    /// The distance from the left-most visible DIP to its left alignment edge.
    /// </summary>
    FLOAT left;

    /// <summary>
    /// The distance from the top-most visible DIP to its top alignment edge.
    /// </summary>
    FLOAT top;

    /// <summary>
    /// The distance from the right-most visible DIP to its right alignment edge.
    /// </summary>
    FLOAT right;

    /// <summary>
    /// The distance from the bottom-most visible DIP to its bottom alignment edge.
    /// </summary>
    FLOAT bottom;
};


/// <summary>
/// Geometry enclosing of text positions.
/// </summary>
struct DWRITE_HIT_TEST_METRICS
{
    /// <summary>
    /// First text position within the geometry.
    /// </summary>
    UINT32 textPosition;

    /// <summary>
    /// Number of text positions within the geometry.
    /// </summary>
    UINT32 length;

    /// <summary>
    /// Left position of the top-left coordinate of the geometry.
    /// </summary>
    FLOAT left;

    /// <summary>
    /// Top position of the top-left coordinate of the geometry.
    /// </summary>
    FLOAT top;

    /// <summary>
    /// Geometry's width.
    /// </summary>
    FLOAT width;

    /// <summary>
    /// Geometry's height.
    /// </summary>
    FLOAT height;

    /// <summary>
    /// Bidi level of text positions enclosed within the geometry.
    /// </summary>
    UINT32 bidiLevel;

    /// <summary>
    /// Geometry encloses text?
    /// </summary>
    BOOL isText;

    /// <summary>
    /// Range is trimmed.
    /// </summary>
    BOOL isTrimmed;
};


interface IDWriteTextRenderer;


/// <summary>
/// The IDWriteInlineObject interface wraps an application defined inline graphic,
/// allowing DWrite to query metrics as if it was a glyph inline with the text.
/// </summary>
interface DWRITE_DECLARE_INTERFACE("8339FDE3-106F-47ab-8373-1C6295EB10B3") IDWriteInlineObject : public IUnknown
{
    /// <summary>
    /// The application implemented rendering callback (IDWriteTextRenderer::DrawInlineObject)
    /// can use this to draw the inline object without needing to cast or query the object
    /// type. The text layout does not call this method directly.
    /// </summary>
    /// <param name="clientDrawingContext">The context passed to IDWriteTextLayout::Draw.</param>
    /// <param name="renderer">The renderer passed to IDWriteTextLayout::Draw as the object's containing parent.</param>
    /// <param name="originX">X-coordinate at the top-left corner of the inline object.</param>
    /// <param name="originY">Y-coordinate at the top-left corner of the inline object.</param>
    /// <param name="isSideways">The object should be drawn on its side.</param>
    /// <param name="isRightToLeft">The object is in an right-to-left context and should be drawn flipped.</param>
    /// <param name="clientDrawingEffect">The drawing effect set in IDWriteTextLayout::SetDrawingEffect.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(Draw)(
        __maybenull void* clientDrawingContext,
        IDWriteTextRenderer* renderer,
        FLOAT originX,
        FLOAT originY,
        BOOL isSideways,
        BOOL isRightToLeft,
        __maybenull IUnknown* clientDrawingEffect
        ) PURE;

    /// <summary>
    /// TextLayout calls this callback function to get the measurement of the inline object.
    /// </summary>
    /// <param name="metrics">Returned metrics</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetMetrics)(
        __out DWRITE_INLINE_OBJECT_METRICS* metrics
        ) PURE;

    /// <summary>
    /// TextLayout calls this callback function to get the visible extents (in DIPs) of the inline object.
    /// In the case of a simple bitmap, with no padding and no overhang, all the overhangs will
    /// simply be zeroes.
    /// </summary>
    /// <param name="overhangs">Overshoot of visible extents (in DIPs) outside the object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// The overhangs should be returned relative to the reported size of the object
    /// (DWRITE_INLINE_OBJECT_METRICS::width/height), and should not be baseline
    /// adjusted. If you have an image that is actually 100x100 DIPs, but you want it
    /// slightly inset (perhaps it has a glow) by 20 DIPs on each side, you would
    /// return a width/height of 60x60 and four overhangs of 20 DIPs.
    /// </remarks>
    STDMETHOD(GetOverhangMetrics)(
        __out DWRITE_OVERHANG_METRICS* overhangs
        ) PURE;

    /// <summary>
    /// Layout uses this to determine the line breaking behavior of the inline object
    /// amidst the text.
    /// </summary>
    /// <param name="breakConditionBefore">Line-breaking condition between the object and the content immediately preceding it.</param>
    /// <param name="breakConditionAfter" >Line-breaking condition between the object and the content immediately following it.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetBreakConditions)(
        __out DWRITE_BREAK_CONDITION* breakConditionBefore,
        __out DWRITE_BREAK_CONDITION* breakConditionAfter
        ) PURE;
};

/// <summary>
/// The IDWritePixelSnapping interface defines the pixel snapping properties of a text renderer.
/// </summary>
interface DWRITE_DECLARE_INTERFACE("eaf3a2da-ecf4-4d24-b644-b34f6842024b") IDWritePixelSnapping : public IUnknown
{
    /// <summary>
    /// Determines whether pixel snapping is disabled. The recommended default is FALSE,
    /// unless doing animation that requires subpixel vertical placement.
    /// </summary>
    /// <param name="clientDrawingContext">The context passed to IDWriteTextLayout::Draw.</param>
    /// <param name="isDisabled">Receives TRUE if pixel snapping is disabled or FALSE if it not.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(IsPixelSnappingDisabled)(
        __maybenull void* clientDrawingContext,
        __out BOOL* isDisabled
        ) PURE;

    /// <summary>
    /// Gets the current transform that maps abstract coordinates to DIPs,
    /// which may disable pixel snapping upon any rotation or shear.
    /// </summary>
    /// <param name="clientDrawingContext">The context passed to IDWriteTextLayout::Draw.</param>
    /// <param name="transform">Receives the transform.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetCurrentTransform)(
        __maybenull void* clientDrawingContext,
        __out DWRITE_MATRIX* transform
        ) PURE;

    /// <summary>
    /// Gets the number of physical pixels per DIP. A DIP (device-independent pixel) is 1/96 inch,
    /// so the pixelsPerDip value is the number of logical pixels per inch divided by 96 (yielding
    /// a value of 1 for 96 DPI and 1.25 for 120).
    /// </summary>
    /// <param name="clientDrawingContext">The context passed to IDWriteTextLayout::Draw.</param>
    /// <param name="pixelsPerDip">Receives the number of physical pixels per DIP.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetPixelsPerDip)(
        __maybenull void* clientDrawingContext,
        __out FLOAT* pixelsPerDip
        ) PURE;
};

/// <summary>
/// The IDWriteTextLayout interface represents a set of application-defined
/// callbacks that perform rendering of text, inline objects, and decorations
/// such as underlines.
/// </summary>
interface DWRITE_DECLARE_INTERFACE("ef8a8135-5cc6-45fe-8825-c5a0724eb819") IDWriteTextRenderer : public IDWritePixelSnapping
{
    /// <summary>
    /// IDWriteTextLayout::Draw calls this function to instruct the client to
    /// render a run of glyphs.
    /// </summary>
    /// <param name="clientDrawingContext">The context passed to 
    /// IDWriteTextLayout::Draw.</param>
    /// <param name="baselineOriginX">X-coordinate of the baseline.</param>
    /// <param name="baselineOriginY">Y-coordinate of the baseline.</param>
    /// <param name="measuringMode">Specifies measuring method for glyphs in the run.
    /// Renderer implementations may choose different rendering modes for given measuring methods,
    /// but best results are seen when the rendering mode matches the corresponding measuring mode:
    /// DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL for DWRITE_MEASURING_MODE_NATURAL
    /// DWRITE_RENDERING_MODE_CLEARTYPE_GDI_CLASSIC for DWRITE_MEASURING_MODE_GDI_CLASSIC
    /// DWRITE_RENDERING_MODE_CLEARTYPE_GDI_NATURAL for DWRITE_MEASURING_MODE_GDI_NATURAL
    /// </param>
    /// <param name="glyphRun">The glyph run to draw.</param>
    /// <param name="glyphRunDescription">Properties of the characters 
    /// associated with this run.</param>
    /// <param name="clientDrawingEffect">The drawing effect set in
    /// IDWriteTextLayout::SetDrawingEffect.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(DrawGlyphRun)(
        __maybenull void* clientDrawingContext,
        FLOAT baselineOriginX,
        FLOAT baselineOriginY,
        DWRITE_MEASURING_MODE measuringMode,
        __in DWRITE_GLYPH_RUN const* glyphRun,
        __in DWRITE_GLYPH_RUN_DESCRIPTION const* glyphRunDescription,
        __maybenull IUnknown* clientDrawingEffect
        ) PURE;

    /// <summary>
    /// IDWriteTextLayout::Draw calls this function to instruct the client to draw
    /// an underline.
    /// </summary>
    /// <param name="clientDrawingContext">The context passed to 
    /// IDWriteTextLayout::Draw.</param>
    /// <param name="baselineOriginX">X-coordinate of the baseline.</param>
    /// <param name="baselineOriginY">Y-coordinate of the baseline.</param>
    /// <param name="underline">Underline logical information.</param>
    /// <param name="clientDrawingEffect">The drawing effect set in
    /// IDWriteTextLayout::SetDrawingEffect.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// A single underline can be broken into multiple calls, depending on
    /// how the formatting changes attributes. If font sizes/styles change
    /// within an underline, the thickness and offset will be averaged
    /// weighted according to characters.
    /// To get the correct top coordinate of the underline rect, add underline::offset
    /// to the baseline's Y. Otherwise the underline will be immediately under the text.
    /// The x coordinate will always be passed as the left side, regardless
    /// of text directionality. This simplifies drawing and reduces the
    /// problem of round-off that could potentially cause gaps or a double
    /// stamped alpha blend. To avoid alpha overlap, round the end points
    /// to the nearest device pixel.
    /// </remarks>
    STDMETHOD(DrawUnderline)(
        __maybenull void* clientDrawingContext,
        FLOAT baselineOriginX,
        FLOAT baselineOriginY,
        __in DWRITE_UNDERLINE const* underline,
        __maybenull IUnknown* clientDrawingEffect
        ) PURE;

    /// <summary>
    /// IDWriteTextLayout::Draw calls this function to instruct the client to draw
    /// a strikethrough.
    /// </summary>
    /// <param name="clientDrawingContext">The context passed to 
    /// IDWriteTextLayout::Draw.</param>
    /// <param name="baselineOriginX">X-coordinate of the baseline.</param>
    /// <param name="baselineOriginY">Y-coordinate of the baseline.</param>
    /// <param name="strikethrough">Strikethrough logical information.</param>
    /// <param name="clientDrawingEffect">The drawing effect set in
    /// IDWriteTextLayout::SetDrawingEffect.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// A single strikethrough can be broken into multiple calls, depending on
    /// how the formatting changes attributes. Strikethrough is not averaged
    /// across font sizes/styles changes.
    /// To get the correct top coordinate of the strikethrough rect,
    /// add strikethrough::offset to the baseline's Y.
    /// Like underlines, the x coordinate will always be passed as the left side,
    /// regardless of text directionality.
    /// </remarks>
    STDMETHOD(DrawStrikethrough)(
        __maybenull void* clientDrawingContext,
        FLOAT baselineOriginX,
        FLOAT baselineOriginY,
        __in DWRITE_STRIKETHROUGH const* strikethrough,
        __maybenull IUnknown* clientDrawingEffect
        ) PURE;

    /// <summary>
    /// IDWriteTextLayout::Draw calls this application callback when it needs to
    /// draw an inline object.
    /// </summary>
    /// <param name="clientDrawingContext">The context passed to IDWriteTextLayout::Draw.</param>
    /// <param name="originX">X-coordinate at the top-left corner of the inline object.</param>
    /// <param name="originY">Y-coordinate at the top-left corner of the inline object.</param>
    /// <param name="inlineObject">The object set using IDWriteTextLayout::SetInlineObject.</param>
    /// <param name="isSideways">The object should be drawn on its side.</param>
    /// <param name="isRightToLeft">The object is in an right-to-left context and should be drawn flipped.</param>
    /// <param name="clientDrawingEffect">The drawing effect set in
    /// IDWriteTextLayout::SetDrawingEffect.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// The right-to-left flag is a hint for those cases where it would look
    /// strange for the image to be shown normally (like an arrow pointing to
    /// right to indicate a submenu).
    /// </remarks>
    STDMETHOD(DrawInlineObject)(
        __maybenull void* clientDrawingContext,
        FLOAT originX,
        FLOAT originY,
        IDWriteInlineObject* inlineObject,
        BOOL isSideways,
        BOOL isRightToLeft,
        __maybenull IUnknown* clientDrawingEffect
        ) PURE;
};

/// <summary>
/// The IDWriteTextLayout interface represents a block of text after it has
/// been fully analyzed and formatted.
///
/// All coordinates are in device independent pixels (DIPs).
/// </summary>
interface DWRITE_DECLARE_INTERFACE("53737037-6d14-410b-9bfe-0b182bb70961") IDWriteTextLayout : public IDWriteTextFormat
{
    /// <summary>
    /// Set layout maximum width
    /// </summary>
    /// <param name="maxWidth">Layout maximum width</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(SetMaxWidth)(
        FLOAT maxWidth
        ) PURE;

    /// <summary>
    /// Set layout maximum height
    /// </summary>
    /// <param name="maxHeight">Layout maximum height</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(SetMaxHeight)(
        FLOAT maxHeight
        ) PURE;

    /// <summary>
    /// Set the font collection.
    /// </summary>
    /// <param name="fontCollection">The font collection to set</param>
    /// <param name="textRange">Text range to which this change applies.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(SetFontCollection)(
        IDWriteFontCollection* fontCollection,
        DWRITE_TEXT_RANGE textRange
        ) PURE;

    /// <summary>
    /// Set null-terminated font family name.
    /// </summary>
    /// <param name="fontFamilyName">Font family name</param>
    /// <param name="textRange">Text range to which this change applies.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(SetFontFamilyName)(
        __in_z WCHAR const* fontFamilyName,
        DWRITE_TEXT_RANGE textRange
        ) PURE;

    /// <summary>
    /// Set font weight.
    /// </summary>
    /// <param name="fontWeight">Font weight</param>
    /// <param name="textRange">Text range to which this change applies.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(SetFontWeight)(
        DWRITE_FONT_WEIGHT fontWeight,
        DWRITE_TEXT_RANGE textRange
        ) PURE;

    /// <summary>
    /// Set font style.
    /// </summary>
    /// <param name="fontStyle">Font style</param>
    /// <param name="textRange">Text range to which this change applies.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(SetFontStyle)(
        DWRITE_FONT_STYLE fontStyle,
        DWRITE_TEXT_RANGE textRange
        ) PURE;

    /// <summary>
    /// Set font stretch.
    /// </summary>
    /// <param name="fontStretch">font stretch</param>
    /// <param name="textRange">Text range to which this change applies.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(SetFontStretch)(
        DWRITE_FONT_STRETCH fontStretch,
        DWRITE_TEXT_RANGE textRange
        ) PURE;

    /// <summary>
    /// Set font em height.
    /// </summary>
    /// <param name="fontSize">Font em height</param>
    /// <param name="textRange">Text range to which this change applies.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(SetFontSize)(
        FLOAT fontSize,
        DWRITE_TEXT_RANGE textRange
        ) PURE;

    /// <summary>
    /// Set underline.
    /// </summary>
    /// <param name="hasUnderline">The Boolean flag indicates whether underline takes place</param>
    /// <param name="textRange">Text range to which this change applies.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(SetUnderline)(
        BOOL hasUnderline,
        DWRITE_TEXT_RANGE textRange
        ) PURE;

    /// <summary>
    /// Set strikethrough.
    /// </summary>
    /// <param name="hasStrikethrough">The Boolean flag indicates whether strikethrough takes place</param>
    /// <param name="textRange">Text range to which this change applies.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(SetStrikethrough)(
        BOOL hasStrikethrough,
        DWRITE_TEXT_RANGE textRange
        ) PURE;

    /// <summary>
    /// Set application-defined drawing effect.
    /// </summary>
    /// <param name="drawingEffect">Pointer to an application-defined drawing effect.</param>
    /// <param name="textRange">Text range to which this change applies.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// This drawing effect is associated with the specified range and will be passed back
    /// to the application via the callback when the range is drawn at drawing time.
    /// </remarks>
    STDMETHOD(SetDrawingEffect)(
        IUnknown* drawingEffect,
        DWRITE_TEXT_RANGE textRange
        ) PURE;

    /// <summary>
    /// Set inline object.
    /// </summary>
    /// <param name="inlineObject">Pointer to an application-implemented inline object.</param>
    /// <param name="textRange">Text range to which this change applies.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// This inline object applies to the specified range and will be passed back
    /// to the application via the DrawInlineObject callback when the range is drawn.
    /// Any text in that range will be suppressed.
    /// </remarks>
    STDMETHOD(SetInlineObject)(
        IDWriteInlineObject* inlineObject,
        DWRITE_TEXT_RANGE textRange
        ) PURE;

    /// <summary>
    /// Set font typography features.
    /// </summary>
    /// <param name="typography">Pointer to font typography setting.</param>
    /// <param name="textRange">Text range to which this change applies.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(SetTypography)(
        IDWriteTypography* typography,
        DWRITE_TEXT_RANGE textRange
        ) PURE;

    /// <summary>
    /// Set locale name.
    /// </summary>
    /// <param name="localeName">Locale name</param>
    /// <param name="textRange">Text range to which this change applies.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(SetLocaleName)(
        __in_z WCHAR const* localeName,
        DWRITE_TEXT_RANGE textRange
        ) PURE;

    /// <summary>
    /// Get layout maximum width
    /// </summary>
    STDMETHOD_(FLOAT, GetMaxWidth)() PURE;

    /// <summary>
    /// Get layout maximum height
    /// </summary>
    STDMETHOD_(FLOAT, GetMaxHeight)() PURE;

    /// <summary>
    /// Get the font collection where the current position is at.
    /// </summary>
    /// <param name="currentPosition">The current text position.</param>
    /// <param name="fontCollection">The current font collection</param>
    /// <param name="textRange">Text range to which this change applies.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetFontCollection)(
        UINT32 currentPosition,
        __out IDWriteFontCollection** fontCollection,
        __out_opt DWRITE_TEXT_RANGE* textRange = NULL
        ) PURE;

    /// <summary>
    /// Get the length of the font family name where the current position is at.
    /// </summary>
    /// <param name="currentPosition">The current text position.</param>
    /// <param name="nameLength">Size of the character array in character count not including the terminated NULL character.</param>
    /// <param name="textRange">The position range of the current format.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetFontFamilyNameLength)(
        UINT32 currentPosition,
        __out UINT32* nameLength,
        __out_opt DWRITE_TEXT_RANGE* textRange = NULL
        ) PURE;

    /// <summary>
    /// Copy the font family name where the current position is at.
    /// </summary>
    /// <param name="currentPosition">The current text position.</param>
    /// <param name="fontFamilyName">Character array that receives the current font family name</param>
    /// <param name="nameSize">Size of the character array in character count including the terminated NULL character.</param>
    /// <param name="textRange">The position range of the current format.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetFontFamilyName)(
        UINT32 currentPosition,
        __out_ecount_z(nameSize) WCHAR* fontFamilyName,
        UINT32 nameSize,
        __out_opt DWRITE_TEXT_RANGE* textRange = NULL
        ) PURE;

    /// <summary>
    /// Get the font weight where the current position is at.
    /// </summary>
    /// <param name="currentPosition">The current text position.</param>
    /// <param name="fontWeight">The current font weight</param>
    /// <param name="textRange">The position range of the current format.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetFontWeight)(
        UINT32 currentPosition,
        __out DWRITE_FONT_WEIGHT* fontWeight,
        __out_opt DWRITE_TEXT_RANGE* textRange = NULL
        ) PURE;

    /// <summary>
    /// Get the font style where the current position is at.
    /// </summary>
    /// <param name="currentPosition">The current text position.</param>
    /// <param name="fontStyle">The current font style</param>
    /// <param name="textRange">The position range of the current format.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetFontStyle)(
        UINT32 currentPosition,
        __out DWRITE_FONT_STYLE* fontStyle,
        __out_opt DWRITE_TEXT_RANGE* textRange = NULL
        ) PURE;

    /// <summary>
    /// Get the font stretch where the current position is at.
    /// </summary>
    /// <param name="currentPosition">The current text position.</param>
    /// <param name="fontStretch">The current font stretch</param>
    /// <param name="textRange">The position range of the current format.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetFontStretch)(
        UINT32 currentPosition,
        __out DWRITE_FONT_STRETCH* fontStretch,
        __out_opt DWRITE_TEXT_RANGE* textRange = NULL
        ) PURE;

    /// <summary>
    /// Get the font em height where the current position is at.
    /// </summary>
    /// <param name="currentPosition">The current text position.</param>
    /// <param name="fontSize">The current font em height</param>
    /// <param name="textRange">The position range of the current format.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetFontSize)(
        UINT32 currentPosition,
        __out FLOAT* fontSize,
        __out_opt DWRITE_TEXT_RANGE* textRange = NULL
        ) PURE;

    /// <summary>
    /// Get the underline presence where the current position is at.
    /// </summary>
    /// <param name="currentPosition">The current text position.</param>
    /// <param name="hasUnderline">The Boolean flag indicates whether text is underlined.</param>
    /// <param name="textRange">The position range of the current format.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetUnderline)(
        UINT32 currentPosition,
        __out BOOL* hasUnderline,
        __out_opt DWRITE_TEXT_RANGE* textRange = NULL
        ) PURE;

    /// <summary>
    /// Get the strikethrough presence where the current position is at.
    /// </summary>
    /// <param name="currentPosition">The current text position.</param>
    /// <param name="hasStrikethrough">The Boolean flag indicates whether text has strikethrough.</param>
    /// <param name="textRange">The position range of the current format.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetStrikethrough)(
        UINT32 currentPosition,
        __out BOOL* hasStrikethrough,
        __out_opt DWRITE_TEXT_RANGE* textRange = NULL
        ) PURE;

    /// <summary>
    /// Get the application-defined drawing effect where the current position is at.
    /// </summary>
    /// <param name="currentPosition">The current text position.</param>
    /// <param name="drawingEffect">The current application-defined drawing effect.</param>
    /// <param name="textRange">The position range of the current format.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetDrawingEffect)(
        UINT32 currentPosition,
        __out IUnknown** drawingEffect,
        __out_opt DWRITE_TEXT_RANGE* textRange = NULL
        ) PURE;

    /// <summary>
    /// Get the inline object at the given position.
    /// </summary>
    /// <param name="currentPosition">The given text position.</param>
    /// <param name="inlineObject">The inline object.</param>
    /// <param name="textRange">The position range of the current format.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetInlineObject)(
        UINT32 currentPosition,
        __out IDWriteInlineObject** inlineObject,
        __out_opt DWRITE_TEXT_RANGE* textRange = NULL
        ) PURE;

    /// <summary>
    /// Get the typography setting where the current position is at.
    /// </summary>
    /// <param name="currentPosition">The current text position.</param>
    /// <param name="typography">The current typography setting.</param>
    /// <param name="textRange">The position range of the current format.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetTypography)(
        UINT32 currentPosition,
        __out IDWriteTypography** typography,
        __out_opt DWRITE_TEXT_RANGE* textRange = NULL
        ) PURE;

    /// <summary>
    /// Get the length of the locale name where the current position is at.
    /// </summary>
    /// <param name="currentPosition">The current text position.</param>
    /// <param name="nameLength">Size of the character array in character count not including the terminated NULL character.</param>
    /// <param name="textRange">The position range of the current format.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetLocaleNameLength)(
        UINT32 currentPosition,
        __out UINT32* nameLength,
        __out_opt DWRITE_TEXT_RANGE* textRange = NULL
        ) PURE;

    /// <summary>
    /// Get the locale name where the current position is at.
    /// </summary>
    /// <param name="currentPosition">The current text position.</param>
    /// <param name="localeName">Character array that receives the current locale name</param>
    /// <param name="nameSize">Size of the character array in character count including the terminated NULL character.</param>
    /// <param name="textRange">The position range of the current format.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetLocaleName)(
        UINT32 currentPosition,
        __out_ecount_z(nameSize) WCHAR* localeName,
        UINT32 nameSize,
        __out_opt DWRITE_TEXT_RANGE* textRange = NULL
        ) PURE;

    /// <summary>
    /// Initiate drawing of the text.
    /// </summary>
    /// <param name="clientDrawingContext">An application defined value
    /// included in rendering callbacks.</param>
    /// <param name="renderer">The set of application-defined callbacks that do
    /// the actual rendering.</param>
    /// <param name="originX">X-coordinate of the layout's left side.</param>
    /// <param name="originY">Y-coordinate of the layout's top side.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(Draw)(
        __maybenull void* clientDrawingContext,
        IDWriteTextRenderer* renderer,
        FLOAT originX,
        FLOAT originY
        ) PURE;

    /// <summary>
    /// GetLineMetrics returns properties of each line.
    /// </summary>
    /// <param name="lineMetrics">The array to fill with line information.</param>
    /// <param name="maxLineCount">The maximum size of the lineMetrics array.</param>
    /// <param name="actualLineCount">The actual size of the lineMetrics
    /// array that is needed.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// If maxLineCount is not large enough E_NOT_SUFFICIENT_BUFFER, 
    /// which is equivalent to HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER),
    /// is returned and *actualLineCount is set to the number of lines
    /// needed.
    /// </remarks>
    STDMETHOD(GetLineMetrics)(
        __out_ecount_opt(maxLineCount) DWRITE_LINE_METRICS* lineMetrics,
        UINT32 maxLineCount,
        __out UINT32* actualLineCount
        ) PURE;

    /// <summary>
    /// GetMetrics retrieves overall metrics for the formatted string.
    /// </summary>
    /// <param name="textMetrics">The returned metrics.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// Drawing effects like underline and strikethrough do not contribute
    /// to the text size, which is essentially the sum of advance widths and
    /// line heights. Additionally, visible swashes and other graphic
    /// adornments may extend outside the returned width and height.
    /// </remarks>
    STDMETHOD(GetMetrics)(
        __out DWRITE_TEXT_METRICS* textMetrics
        ) PURE;

    /// <summary>
    /// GetOverhangMetrics returns the overhangs (in DIPs) of the layout and all
    /// objects contained in it, including text glyphs and inline objects.
    /// </summary>
    /// <param name="overhangs">Overshoots of visible extents (in DIPs) outside the layout.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// Any underline and strikethrough do not contribute to the black box
    /// determination, since these are actually drawn by the renderer, which
    /// is allowed to draw them in any variety of styles.
    /// </remarks>
    STDMETHOD(GetOverhangMetrics)(
        __out DWRITE_OVERHANG_METRICS* overhangs
        ) PURE;

    /// <summary>
    /// Retrieve logical properties and measurement of each cluster.
    /// </summary>
    /// <param name="clusterMetrics">The array to fill with cluster information.</param>
    /// <param name="maxClusterCount">The maximum size of the clusterMetrics array.</param>
    /// <param name="actualClusterCount">The actual size of the clusterMetrics array that is needed.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// If maxClusterCount is not large enough E_NOT_SUFFICIENT_BUFFER, 
    /// which is equivalent to HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER), 
    /// is returned and *actualClusterCount is set to the number of clusters
    /// needed.
    /// </remarks>
    STDMETHOD(GetClusterMetrics)(
        __out_ecount_opt(maxClusterCount) DWRITE_CLUSTER_METRICS* clusterMetrics,
        UINT32 maxClusterCount,
        __out UINT32* actualClusterCount
        ) PURE;

    /// <summary>
    /// Determines the minimum possible width the layout can be set to without
    /// emergency breaking between the characters of whole words.
    /// </summary>
    /// <param name="minWidth">Minimum width.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(DetermineMinWidth)(
        __out FLOAT* minWidth
        ) PURE;

    /// <summary>
    /// Given a coordinate (in DIPs) relative to the top-left of the layout box,
    /// this returns the corresponding hit-test metrics of the text string where
    /// the hit-test has occurred. This is useful for mapping mouse clicks to caret
    /// positions. When the given coordinate is outside the text string, the function
    /// sets the output value *isInside to false but returns the nearest character
    /// position.
    /// </summary>
    /// <param name="pointX">X coordinate to hit-test, relative to the top-left location of the layout box.</param>
    /// <param name="pointY">Y coordinate to hit-test, relative to the top-left location of the layout box.</param>
    /// <param name="isTrailingHit">Output flag indicating whether the hit-test location is at the leading or the trailing
    ///     side of the character. When the output *isInside value is set to false, this value is set according to the output
    ///     *position value to represent the edge closest to the hit-test location. </param>
    /// <param name="isInside">Output flag indicating whether the hit-test location is inside the text string.
    ///     When false, the position nearest the text's edge is returned.</param>
    /// <param name="hitTestMetrics">Output geometry fully enclosing the hit-test location. When the output *isInside value
    ///     is set to false, this structure represents the geometry enclosing the edge closest to the hit-test location.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(HitTestPoint)(
        FLOAT pointX,
        FLOAT pointY,
        __out BOOL* isTrailingHit,
        __out BOOL* isInside,
        __out DWRITE_HIT_TEST_METRICS* hitTestMetrics
        ) PURE;

    /// <summary>
    /// Given a text position and whether the caret is on the leading or trailing
    /// edge of that position, this returns the corresponding coordinate (in DIPs)
    /// relative to the top-left of the layout box. This is most useful for drawing
    /// the caret's current position, but it could also be used to anchor an IME to the
    /// typed text or attach a floating menu near the point of interest. It may also be
    /// used to programmatically obtain the geometry of a particular text position
    /// for UI automation.
    /// </summary>
    /// <param name="textPosition">Text position to get the coordinate of.</param>
    /// <param name="isTrailingHit">Flag indicating whether the location is of the leading or the trailing side of the specified text position. </param>
    /// <param name="pointX">Output caret X, relative to the top-left of the layout box.</param>
    /// <param name="pointY">Output caret Y, relative to the top-left of the layout box.</param>
    /// <param name="hitTestMetrics">Output geometry fully enclosing the specified text position.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// When drawing a caret at the returned X,Y, it should should be centered on X
    /// and drawn from the Y coordinate down. The height will be the size of the
    /// hit-tested text (which can vary in size within a line).
    /// Reading direction also affects which side of the character the caret is drawn.
    /// However, the returned X coordinate will be correct for either case.
    /// You can get a text length back that is larger than a single character.
    /// This happens for complex scripts when multiple characters form a single cluster,
    /// when diacritics join their base character, or when you test a surrogate pair.
    /// </remarks>
    STDMETHOD(HitTestTextPosition)(
        UINT32 textPosition,
        BOOL isTrailingHit,
        __out FLOAT* pointX,
        __out FLOAT* pointY,
        __out DWRITE_HIT_TEST_METRICS* hitTestMetrics
        ) PURE;

    /// <summary>
    /// The application calls this function to get a set of hit-test metrics
    /// corresponding to a range of text positions. The main usage for this
    /// is to draw highlighted selection of the text string.
    ///
    /// The function returns E_NOT_SUFFICIENT_BUFFER, which is equivalent to 
    /// HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER), when the buffer size of
    /// hitTestMetrics is too small to hold all the regions calculated by the
    /// function. In such situation, the function sets the output value
    /// *actualHitTestMetricsCount to the number of geometries calculated.
    /// The application is responsible to allocate a new buffer of greater
    /// size and call the function again.
    ///
    /// A good value to use as an initial value for maxHitTestMetricsCount may
    /// be calculated from the following equation:
    ///     maxHitTestMetricsCount = lineCount * maxBidiReorderingDepth
    ///
    /// where lineCount is obtained from the value of the output argument
    /// *actualLineCount from the function IDWriteTextLayout::GetLineMetrics,
    /// and the maxBidiReorderingDepth value from the DWRITE_TEXT_METRICS
    /// structure of the output argument *textMetrics from the function
    /// IDWriteFactory::CreateTextLayout.
    /// </summary>
    /// <param name="textPosition">First text position of the specified range.</param>
    /// <param name="textLength">Number of positions of the specified range.</param>
    /// <param name="originX">Offset of the X origin (left of the layout box) which is added to each of the hit-test metrics returned.</param>
    /// <param name="originY">Offset of the Y origin (top of the layout box) which is added to each of the hit-test metrics returned.</param>
    /// <param name="hitTestMetrics">Pointer to a buffer of the output geometry fully enclosing the specified position range.</param>
    /// <param name="maxHitTestMetricsCount">Maximum number of distinct metrics it could hold in its buffer memory.</param>
    /// <param name="actualHitTestMetricsCount">Actual number of metrics returned or needed.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// There are no gaps in the returned metrics. While there could be visual gaps,
    /// depending on bidi ordering, each range is contiguous and reports all the text,
    /// including any hidden characters and trimmed text.
    /// The height of each returned range will be the same within each line, regardless
    /// of how the font sizes vary.
    /// </remarks>
    STDMETHOD(HitTestTextRange)(
        UINT32 textPosition,
        UINT32 textLength,
        FLOAT originX,
        FLOAT originY,
        __out_ecount_opt(maxHitTestMetricsCount) DWRITE_HIT_TEST_METRICS* hitTestMetrics,
        UINT32 maxHitTestMetricsCount,
        __out UINT32* actualHitTestMetricsCount
        ) PURE;
};

/// <summary>
/// Encapsulates a 32-bit device independent bitmap and device context, which can be used for rendering glyphs.
/// </summary>
interface DWRITE_DECLARE_INTERFACE("5e5a32a3-8dff-4773-9ff6-0696eab77267") IDWriteBitmapRenderTarget : public IUnknown
{
    /// <summary>
    /// Draws a run of glyphs to the bitmap.
    /// </summary>
    /// <param name="baselineOriginX">Horizontal position of the baseline origin, in DIPs, relative to the upper-left corner of the DIB.</param>
    /// <param name="baselineOriginY">Vertical position of the baseline origin, in DIPs, relative to the upper-left corner of the DIB.</param>
    /// <param name="measuringMode">Specifies measuring method for glyphs in the run.
    /// Renderer implementations may choose different rendering modes for different measuring methods, for example
    /// DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL for DWRITE_MEASURING_MODE_NATURAL,
    /// DWRITE_RENDERING_MODE_CLEARTYPE_GDI_CLASSIC for DWRITE_MEASURING_MODE_GDI_CLASSIC, and
    /// DWRITE_RENDERING_MODE_CLEARTYPE_GDI_NATURAL for DWRITE_MEASURING_MODE_GDI_NATURAL.
    /// </param>
    /// <param name="glyphRun">Structure containing the properties of the glyph run.</param>
    /// <param name="renderingParams">Object that controls rendering behavior.</param>
    /// <param name="textColor">Specifies the foreground color of the text.</param>
    /// <param name="blackBoxRect">Optional rectangle that receives the bounding box (in pixels not DIPs) of all the pixels affected by 
    /// drawing the glyph run. The black box rectangle may extend beyond the dimensions of the bitmap.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(DrawGlyphRun)(
        FLOAT baselineOriginX,
        FLOAT baselineOriginY,
        DWRITE_MEASURING_MODE measuringMode,
        __in DWRITE_GLYPH_RUN const* glyphRun,
        IDWriteRenderingParams* renderingParams,
        COLORREF textColor,
        __out_opt RECT* blackBoxRect = NULL
        ) PURE;

    /// <summary>
    /// Gets a handle to the memory device context.
    /// </summary>
    /// <returns>
    /// Returns the device context handle.
    /// </returns>
    /// <remarks>
    /// An application can use the device context to draw using GDI functions. An application can obtain the bitmap handle
    /// (HBITMAP) by calling GetCurrentObject. An application that wants information about the underlying bitmap, including
    /// a pointer to the pixel data, can call GetObject to fill in a DIBSECTION structure. The bitmap is always a 32-bit 
    /// top-down DIB.
    /// </remarks>
    STDMETHOD_(HDC, GetMemoryDC)() PURE;

    /// <summary>
    /// Gets the number of bitmap pixels per DIP. A DIP (device-independent pixel) is 1/96 inch so this value is the number
    /// if pixels per inch divided by 96.
    /// </summary>
    /// <returns>
    /// Returns the number of bitmap pixels per DIP.
    /// </returns>
    STDMETHOD_(FLOAT, GetPixelsPerDip)() PURE;

    /// <summary>
    /// Sets the number of bitmap pixels per DIP. A DIP (device-independent pixel) is 1/96 inch so this value is the number
    /// if pixels per inch divided by 96.
    /// </summary>
    /// <param name="pixelsPerDip">Specifies the number of pixels per DIP.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(SetPixelsPerDip)(
        FLOAT pixelsPerDip
        ) PURE;

    /// <summary>
    /// Gets the transform that maps abstract coordinate to DIPs. By default this is the identity 
    /// transform. Note that this is unrelated to the world transform of the underlying device
    /// context.
    /// </summary>
    /// <param name="transform">Receives the transform.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetCurrentTransform)(
        __out DWRITE_MATRIX* transform
        ) PURE;

    /// <summary>
    /// Sets the transform that maps abstract coordinate to DIPs. This does not affect the world
    /// transform of the underlying device context.
    /// </summary>
    /// <param name="transform">Specifies the new transform. This parameter can be NULL, in which
    /// case the identity transform is implied.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(SetCurrentTransform)(
        __in_opt DWRITE_MATRIX const* transform
        ) PURE;

    /// <summary>
    /// Gets the dimensions of the bitmap.
    /// </summary>
    /// <param name="size">Receives the size of the bitmap in pixels.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetSize)(
        __out SIZE* size
        ) PURE;

    /// <summary>
    /// Resizes the bitmap.
    /// </summary>
    /// <param name="width">New bitmap width, in pixels.</param>
    /// <param name="height">New bitmap height, in pixels.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(Resize)(
        UINT32 width,
        UINT32 height
        ) PURE;
};

/// <summary>
/// The GDI interop interface provides interoperability with GDI.
/// </summary>
interface DWRITE_DECLARE_INTERFACE("1edd9491-9853-4299-898f-6432983b6f3a") IDWriteGdiInterop : public IUnknown
{
    /// <summary>
    /// Creates a font object that matches the properties specified by the LOGFONT structure.
    /// </summary>
    /// <param name="logFont">Structure containing a GDI-compatible font description.</param>
    /// <param name="font">Receives a newly created font object if successful, or NULL in case of error.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateFontFromLOGFONT)(
        __in LOGFONTW const* logFont,
        __out IDWriteFont** font
        ) PURE;

    /// <summary>
    /// Initializes a LOGFONT structure based on the GDI-compatible properties of the specified font.
    /// </summary>
    /// <param name="font">Specifies a font in the system font collection.</param>
    /// <param name="logFont">Structure that receives a GDI-compatible font description.</param>
    /// <param name="isSystemFont">Contains TRUE if the specified font object is part of the system font collection
    /// or FALSE otherwise.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(ConvertFontToLOGFONT)(
        IDWriteFont* font,
        __out LOGFONTW* logFont,
        __out BOOL* isSystemFont
        ) PURE;

    /// <summary>
    /// Initializes a LOGFONT structure based on the GDI-compatible properties of the specified font.
    /// </summary>
    /// <param name="font">Specifies a font face.</param>
    /// <param name="logFont">Structure that receives a GDI-compatible font description.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(ConvertFontFaceToLOGFONT)(
        IDWriteFontFace* font,
        __out LOGFONTW* logFont
        ) PURE;

    /// <summary>
    /// Creates a font face object that corresponds to the currently selected HFONT.
    /// </summary>
    /// <param name="hdc">Handle to a device context into which a font has been selected. It is assumed that the client
    /// has already performed font mapping and that the font selected into the DC is the actual font that would be used 
    /// for rendering glyphs.</param>
    /// <param name="fontFace">Contains the newly created font face object, or NULL in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateFontFaceFromHdc)(
        HDC hdc,
        __out IDWriteFontFace** fontFace
        ) PURE;

    /// <summary>
    /// Creates an object that encapsulates a bitmap and memory DC which can be used for rendering glyphs.
    /// </summary>
    /// <param name="hdc">Optional device context used to create a compatible memory DC.</param>
    /// <param name="width">Width of the bitmap.</param>
    /// <param name="height">Height of the bitmap.</param>
    /// <param name="renderTarget">Receives a pointer to the newly created render target.</param>
    STDMETHOD(CreateBitmapRenderTarget)(
        __in_opt HDC hdc,
        UINT32 width,
        UINT32 height,
        __out IDWriteBitmapRenderTarget** renderTarget
        ) PURE;
};

/// <summary>
/// The DWRITE_TEXTURE_TYPE enumeration identifies a type of alpha texture. An alpha texture is a bitmap of alpha values, each
/// representing the darkness (i.e., opacity) of a pixel or subpixel.
/// </summary>
enum DWRITE_TEXTURE_TYPE
{
    /// <summary>
    /// Specifies an alpha texture for aliased text rendering (i.e., bi-level, where each pixel is either fully opaque or fully transparent),
    /// with one byte per pixel.
    /// </summary>
    DWRITE_TEXTURE_ALIASED_1x1,

    /// <summary>
    /// Specifies an alpha texture for ClearType text rendering, with three bytes per pixel in the horizontal dimension and 
    /// one byte per pixel in the vertical dimension.
    /// </summary>
    DWRITE_TEXTURE_CLEARTYPE_3x1
};

/// <summary>
/// Maximum alpha value in a texture returned by IDWriteGlyphRunAnalysis::CreateAlphaTexture.
/// </summary>
#define DWRITE_ALPHA_MAX 255

/// <summary>
/// Interface that encapsulates information used to render a glyph run.
/// </summary>
interface DWRITE_DECLARE_INTERFACE("7d97dbf7-e085-42d4-81e3-6a883bded118") IDWriteGlyphRunAnalysis : public IUnknown
{
    /// <summary>
    /// Gets the bounding rectangle of the physical pixels affected by the glyph run.
    /// </summary>
    /// <param name="textureType">Specifies the type of texture requested. If a bi-level texture is requested, the
    /// bounding rectangle includes only bi-level glyphs. Otherwise, the bounding rectangle includes only anti-aliased
    /// glyphs.</param>
    /// <param name="textureBounds">Receives the bounding rectangle, or an empty rectangle if there are no glyphs
    /// if the specified type.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetAlphaTextureBounds)(
        DWRITE_TEXTURE_TYPE textureType,
        __out RECT* textureBounds
        ) PURE;

    /// <summary>
    /// Creates an alpha texture of the specified type.
    /// </summary>
    /// <param name="textureType">Specifies the type of texture requested. If a bi-level texture is requested, the
    /// texture contains only bi-level glyphs. Otherwise, the texture contains only anti-aliased glyphs.</param>
    /// <param name="textureBounds">Specifies the bounding rectangle of the texture, which can be different than
    /// the bounding rectangle returned by GetAlphaTextureBounds.</param>
    /// <param name="alphaValues">Receives the array of alpha values.</param>
    /// <param name="bufferSize">Size of the alphaValues array. The minimum size depends on the dimensions of the
    /// rectangle and the type of texture requested.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateAlphaTexture)(
        DWRITE_TEXTURE_TYPE textureType,
        __in RECT const* textureBounds,
        __out_bcount(bufferSize) BYTE* alphaValues,
        UINT32 bufferSize
        ) PURE;

    /// <summary>
    /// Gets properties required for ClearType blending.
    /// </summary>
    /// <param name="renderingParams">Rendering parameters object. In most cases, the values returned in the output
    /// parameters are based on the properties of this object. The exception is if a GDI-compatible rendering mode
    /// is specified.</param>
    /// <param name="blendGamma">Receives the gamma value to use for gamma correction.</param>
    /// <param name="blendEnhancedContrast">Receives the enhanced contrast value.</param>
    /// <param name="blendClearTypeLevel">Receives the ClearType level.</param>
    STDMETHOD(GetAlphaBlendParams)(
        IDWriteRenderingParams* renderingParams,
        __out FLOAT* blendGamma,
        __out FLOAT* blendEnhancedContrast,
        __out FLOAT* blendClearTypeLevel
        ) PURE;
};

/// <summary>
/// The root factory interface for all DWrite objects.
/// </summary>
interface DWRITE_DECLARE_INTERFACE("b859ee5a-d838-4b5b-a2e8-1adc7d93db48") IDWriteFactory : public IUnknown
{
    /// <summary>
    /// Gets a font collection representing the set of installed fonts.
    /// </summary>
    /// <param name="fontCollection">Receives a pointer to the system font collection object, or NULL in case of failure.</param>
    /// <param name="checkForUpdates">If this parameter is nonzero, the function performs an immediate check for changes to the set of
    /// installed fonts. If this parameter is FALSE, the function will still detect changes if the font cache service is running, but
    /// there may be some latency. For example, an application might specify TRUE if it has itself just installed a font and wants to 
    /// be sure the font collection contains that font.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetSystemFontCollection)(
        __out IDWriteFontCollection** fontCollection,
        BOOL checkForUpdates = FALSE
        ) PURE;

    /// <summary>
    /// Creates a font collection using a custom font collection loader.
    /// </summary>
    /// <param name="collectionLoader">Application-defined font collection loader, which must have been previously
    /// registered using RegisterFontCollectionLoader.</param>
    /// <param name="collectionKey">Key used by the loader to identify a collection of font files.</param>
    /// <param name="collectionKeySize">Size in bytes of the collection key.</param>
    /// <param name="fontCollection">Receives a pointer to the system font collection object, or NULL in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateCustomFontCollection)(
        IDWriteFontCollectionLoader* collectionLoader,
        __in_bcount(collectionKeySize) void const* collectionKey,
        UINT32 collectionKeySize,
        __out IDWriteFontCollection** fontCollection
        ) PURE;

    /// <summary>
    /// Registers a custom font collection loader with the factory object.
    /// </summary>
    /// <param name="fontCollectionLoader">Application-defined font collection loader.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(RegisterFontCollectionLoader)(
        IDWriteFontCollectionLoader* fontCollectionLoader
        ) PURE;

    /// <summary>
    /// Unregisters a custom font collection loader that was previously registered using RegisterFontCollectionLoader.
    /// </summary>
    /// <param name="fontCollectionLoader">Application-defined font collection loader.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(UnregisterFontCollectionLoader)(
        IDWriteFontCollectionLoader* fontCollectionLoader
        ) PURE;

    /// <summary>
    /// CreateFontFileReference creates a font file reference object from a local font file.
    /// </summary>
    /// <param name="filePath">Absolute file path. Subsequent operations on the constructed object may fail
    /// if the user provided filePath doesn't correspond to a valid file on the disk.</param>
    /// <param name="lastWriteTime">Last modified time of the input file path. If the parameter is omitted,
    /// the function will access the font file to obtain its last write time, so the clients are encouraged to specify this value
    /// to avoid extra disk access. Subsequent operations on the constructed object may fail
    /// if the user provided lastWriteTime doesn't match the file on the disk.</param>
    /// <param name="fontFile">Contains newly created font file reference object, or NULL in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateFontFileReference)(
        __in_z WCHAR const* filePath,
        __in_opt FILETIME const* lastWriteTime,
        __out IDWriteFontFile** fontFile
        ) PURE;

    /// <summary>
    /// CreateCustomFontFileReference creates a reference to an application specific font file resource.
    /// This function enables an application or a document to use a font without having to install it on the system.
    /// The fontFileReferenceKey has to be unique only in the scope of the fontFileLoader used in this call.
    /// </summary>
    /// <param name="fontFileReferenceKey">Font file reference key that uniquely identifies the font file resource
    /// during the lifetime of fontFileLoader.</param>
    /// <param name="fontFileReferenceKeySize">Size of font file reference key in bytes.</param>
    /// <param name="fontFileLoader">Font file loader that will be used by the font system to load data from the file identified by
    /// fontFileReferenceKey.</param>
    /// <param name="fontFile">Contains the newly created font file object, or NULL in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// This function is provided for cases when an application or a document needs to use a font
    /// without having to install it on the system. fontFileReferenceKey has to be unique only in the scope
    /// of the fontFileLoader used in this call.
    /// </remarks>
    STDMETHOD(CreateCustomFontFileReference)(
        __in_bcount(fontFileReferenceKeySize) void const* fontFileReferenceKey,
        UINT32 fontFileReferenceKeySize,
        IDWriteFontFileLoader* fontFileLoader,
        __out IDWriteFontFile** fontFile
        ) PURE;

    /// <summary>
    /// Creates a font face object.
    /// </summary>
    /// <param name="fontFaceType">The file format of the font face.</param>
    /// <param name="numberOfFiles">The number of font files require to represent the font face.</param>
    /// <param name="fontFiles">Font files representing the font face. Since IDWriteFontFace maintains its own references
    /// to the input font file objects, it's OK to release them after this call.</param>
    /// <param name="faceIndex">The zero based index of a font face in cases when the font files contain a collection of font faces.
    /// If the font files contain a single face, this value should be zero.</param>
    /// <param name="fontFaceSimulationFlags">Font face simulation flags for algorithmic emboldening and italicization.</param>
    /// <param name="fontFace">Contains the newly created font face object, or NULL in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateFontFace)(
        DWRITE_FONT_FACE_TYPE fontFaceType,
        UINT32 numberOfFiles,
        __in_ecount(numberOfFiles) IDWriteFontFile* const* fontFiles,
        UINT32 faceIndex,
        DWRITE_FONT_SIMULATIONS fontFaceSimulationFlags,
        __out IDWriteFontFace** fontFace
        ) PURE;

    /// <summary>
    /// Creates a rendering parameters object with default settings for the primary monitor.
    /// </summary>
    /// <param name="renderingParams">Holds the newly created rendering parameters object, or NULL in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateRenderingParams)(
        __out IDWriteRenderingParams** renderingParams
        ) PURE;

    /// <summary>
    /// Creates a rendering parameters object with default settings for the specified monitor.
    /// </summary>
    /// <param name="monitor">The monitor to read the default values from.</param>
    /// <param name="renderingParams">Holds the newly created rendering parameters object, or NULL in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateMonitorRenderingParams)(
        HMONITOR monitor,
        __out IDWriteRenderingParams** renderingParams
        ) PURE;

    /// <summary>
    /// Creates a rendering parameters object with the specified properties.
    /// </summary>
    /// <param name="gamma">The gamma value used for gamma correction, which must be greater than zero and cannot exceed 256.</param>
    /// <param name="enhancedContrast">The amount of contrast enhancement, zero or greater.</param>
    /// <param name="clearTypeLevel">The degree of ClearType level, from 0.0f (no ClearType) to 1.0f (full ClearType).</param>
    /// <param name="pixelGeometry">The geometry of a device pixel.</param>
    /// <param name="renderingMode">Method of rendering glyphs. In most cases, this should be DWRITE_RENDERING_MODE_DEFAULT to automatically use an appropriate mode.</param>
    /// <param name="renderingParams">Holds the newly created rendering parameters object, or NULL in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateCustomRenderingParams)(
        FLOAT gamma,
        FLOAT enhancedContrast,
        FLOAT clearTypeLevel,
        DWRITE_PIXEL_GEOMETRY pixelGeometry,
        DWRITE_RENDERING_MODE renderingMode,
        __out IDWriteRenderingParams** renderingParams
        ) PURE;

    /// <summary>
    /// Registers a font file loader with DirectWrite.
    /// </summary>
    /// <param name="fontFileLoader">Pointer to the implementation of the IDWriteFontFileLoader for a particular file resource type.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    /// <remarks>
    /// This function registers a font file loader with DirectWrite.
    /// Font file loader interface handles loading font file resources of a particular type from a key.
    /// The font file loader interface is recommended to be implemented by a singleton object.
    /// A given instance can only be registered once.
    /// Succeeding attempts will return an error that it has already been registered.
    /// IMPORTANT: font file loader implementations must not register themselves with DirectWrite
    /// inside their constructors and must not unregister themselves in their destructors, because
    /// registration and unregistraton operations increment and decrement the object reference count respectively.
    /// Instead, registration and unregistration of font file loaders with DirectWrite should be performed
    /// outside of the font file loader implementation as a separate step.
    /// </remarks>
    STDMETHOD(RegisterFontFileLoader)(
        IDWriteFontFileLoader* fontFileLoader
        ) PURE;

    /// <summary>
    /// Unregisters a font file loader that was previously registered with the DirectWrite font system using RegisterFontFileLoader.
    /// </summary>
    /// <param name="fontFileLoader">Pointer to the file loader that was previously registered with the DirectWrite font system using RegisterFontFileLoader.</param>
    /// <returns>
    /// This function will succeed if the user loader is requested to be removed.
    /// It will fail if the pointer to the file loader identifies a standard DirectWrite loader,
    /// or a loader that is never registered or has already been unregistered.
    /// </returns>
    /// <remarks>
    /// This function unregisters font file loader callbacks with the DirectWrite font system.
    /// The font file loader interface is recommended to be implemented by a singleton object.
    /// IMPORTANT: font file loader implementations must not register themselves with DirectWrite
    /// inside their constructors and must not unregister themselves in their destructors, because
    /// registration and unregistraton operations increment and decrement the object reference count respectively.
    /// Instead, registration and unregistration of font file loaders with DirectWrite should be performed
    /// outside of the font file loader implementation as a separate step.
    /// </remarks>
    STDMETHOD(UnregisterFontFileLoader)(
        IDWriteFontFileLoader* fontFileLoader
        ) PURE;

    /// <summary>
    /// Create a text format object used for text layout.
    /// </summary>
    /// <param name="fontFamilyName">Name of the font family</param>
    /// <param name="fontCollection">Font collection. NULL indicates the system font collection.</param>
    /// <param name="fontWeight">Font weight</param>
    /// <param name="fontStyle">Font style</param>
    /// <param name="fontStretch">Font stretch</param>
    /// <param name="fontSize">Logical size of the font in DIP units. A DIP ("device-independent pixel") equals 1/96 inch.</param>
    /// <param name="localeName">Locale name</param>
    /// <param name="textFormat">Contains newly created text format object, or NULL in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateTextFormat)(
        __in_z WCHAR const* fontFamilyName,
        __maybenull IDWriteFontCollection* fontCollection,
        DWRITE_FONT_WEIGHT fontWeight,
        DWRITE_FONT_STYLE fontStyle,
        DWRITE_FONT_STRETCH fontStretch,
        FLOAT fontSize,
        __in_z WCHAR const* localeName,
        __out IDWriteTextFormat** textFormat
        ) PURE;

    /// <summary>
    /// Create a typography object used in conjunction with text format for text layout.
    /// </summary>
    /// <param name="typography">Contains newly created typography object, or NULL in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateTypography)(
        __out IDWriteTypography** typography
        ) PURE;

    /// <summary>
    /// Create an object used for interoperability with GDI.
    /// </summary>
    /// <param name="gdiInterop">Receives the GDI interop object if successful, or NULL in case of failure.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(GetGdiInterop)(
        __out IDWriteGdiInterop** gdiInterop
        ) PURE;

    /// <summary>
    /// CreateTextLayout takes a string, format, and associated constraints
    /// and produces and object representing the fully analyzed
    /// and formatted result.
    /// </summary>
    /// <param name="string">The string to layout.</param>
    /// <param name="stringLength">The length of the string.</param>
    /// <param name="textFormat">The format to apply to the string.</param>
    /// <param name="maxWidth">Width of the layout box.</param>
    /// <param name="maxHeight">Height of the layout box.</param>
    /// <param name="textLayout">The resultant object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateTextLayout)(
        __in_ecount(stringLength) WCHAR const* string,
        UINT32 stringLength,
        IDWriteTextFormat* textFormat,
        FLOAT maxWidth,
        FLOAT maxHeight,
        __out IDWriteTextLayout** textLayout
        ) PURE;

    /// <summary>
    /// CreateGdiCompatibleTextLayout takes a string, format, and associated constraints
    /// and produces and object representing the result formatted for a particular display resolution
    /// and measuring method. The resulting text layout should only be used for the intended resolution,
    /// and for cases where text scalability is desired, CreateTextLayout should be used instead.
    /// </summary>
    /// <param name="string">The string to layout.</param>
    /// <param name="stringLength">The length of the string.</param>
    /// <param name="textFormat">The format to apply to the string.</param>
    /// <param name="layoutWidth">Width of the layout box.</param>
    /// <param name="layoutHeight">Height of the layout box.</param>
    /// <param name="pixelsPerDip">Number of physical pixels per DIP. For example, if rendering onto a 96 DPI device then pixelsPerDip
    /// is 1. If rendering onto a 120 DPI device then pixelsPerDip is 120/96.</param>
    /// <param name="transform">Optional transform applied to the glyphs and their positions. This transform is applied after the
    /// scaling specified the font size and pixelsPerDip.</param>
    /// <param name="useGdiNatural">
    /// When set to FALSE, instructs the text layout to use the same metrics as GDI aliased text.
    /// When set to TRUE, instructs the text layout to use the same metrics as text measured by GDI using a font
    /// created with CLEARTYPE_NATURAL_QUALITY.
    /// </param>
    /// <param name="textLayout">The resultant object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateGdiCompatibleTextLayout)(
        __in_ecount(stringLength) WCHAR const* string,
        UINT32 stringLength,
        IDWriteTextFormat* textFormat,
        FLOAT layoutWidth,
        FLOAT layoutHeight,
        FLOAT pixelsPerDip,
        __in_opt DWRITE_MATRIX const* transform,
        BOOL useGdiNatural,
        __out IDWriteTextLayout** textLayout
        ) PURE;

    /// <summary>
    /// The application may call this function to create an inline object for trimming, using an ellipsis as the omission sign.
    /// The ellipsis will be created using the current settings of the format, including base font, style, and any effects.
    /// Alternate omission signs can be created by the application by implementing IDWriteInlineObject.
    /// </summary>
    /// <param name="textFormat">Text format used as a template for the omission sign.</param>
    /// <param name="trimmingSign">Created omission sign.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateEllipsisTrimmingSign)(
        IDWriteTextFormat* textFormat,
        __out IDWriteInlineObject** trimmingSign
        ) PURE;

    /// <summary>
    /// Return an interface to perform text analysis with.
    /// </summary>
    /// <param name="textAnalyzer">The resultant object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateTextAnalyzer)(
        __out IDWriteTextAnalyzer** textAnalyzer
        ) PURE;

    /// <summary>
    /// Creates a number substitution object using a locale name,
    /// substitution method, and whether to ignore user overrides (uses NLS
    /// defaults for the given culture instead).
    /// </summary>
    /// <param name="substitutionMethod">Method of number substitution to use.</param>
    /// <param name="localeName">Which locale to obtain the digits from.</param>
    /// <param name="ignoreUserOverride">Ignore the user's settings and use the locale defaults</param>
    /// <param name="numberSubstitution">Receives a pointer to the newly created object.</param>
    STDMETHOD(CreateNumberSubstitution)(
        __in DWRITE_NUMBER_SUBSTITUTION_METHOD substitutionMethod,
        __in_z WCHAR const* localeName,
        __in BOOL ignoreUserOverride,
        __out IDWriteNumberSubstitution** numberSubstitution
        ) PURE;

    /// <summary>
    /// Creates a glyph run analysis object, which encapsulates information
    /// used to render a glyph run.
    /// </summary>
    /// <param name="glyphRun">Structure specifying the properties of the glyph run.</param>
    /// <param name="pixelsPerDip">Number of physical pixels per DIP. For example, if rendering onto a 96 DPI bitmap then pixelsPerDip
    /// is 1. If rendering onto a 120 DPI bitmap then pixelsPerDip is 120/96.</param>
    /// <param name="transform">Optional transform applied to the glyphs and their positions. This transform is applied after the
    /// scaling specified the emSize and pixelsPerDip.</param>
    /// <param name="renderingMode">Specifies the rendering mode, which must be one of the raster rendering modes (i.e., not default
    /// and not outline).</param>
    /// <param name="measuringMode">Specifies the method to measure glyphs.</param>
    /// <param name="baselineOriginX">Horizontal position of the baseline origin, in DIPs.</param>
    /// <param name="baselineOriginY">Vertical position of the baseline origin, in DIPs.</param>
    /// <param name="glyphRunAnalysis">Receives a pointer to the newly created object.</param>
    /// <returns>
    /// Standard HRESULT error code.
    /// </returns>
    STDMETHOD(CreateGlyphRunAnalysis)(
        __in DWRITE_GLYPH_RUN const* glyphRun,
        FLOAT pixelsPerDip,
        __in_opt DWRITE_MATRIX const* transform,
        DWRITE_RENDERING_MODE renderingMode,
        DWRITE_MEASURING_MODE measuringMode,
        FLOAT baselineOriginX,
        FLOAT baselineOriginY,
        __out IDWriteGlyphRunAnalysis** glyphRunAnalysis
        ) PURE;

}; // interface IDWriteFactory

/// <summary>
/// Creates a DirectWrite factory object that is used for subsequent creation of individual DirectWrite objects.
/// </summary>
/// <param name="factoryType">Identifies whether the factory object will be shared or isolated.</param>
/// <param name="iid">Identifies the DirectWrite factory interface, such as __uuidof(IDWriteFactory).</param>
/// <param name="factory">Receives the DirectWrite factory object.</param>
/// <returns>
/// Standard HRESULT error code.
/// </returns>
/// <remarks>
/// Obtains DirectWrite factory object that is used for subsequent creation of individual DirectWrite classes.
/// DirectWrite factory contains internal state such as font loader registration and cached font data.
/// In most cases it is recommended to use the shared factory object, because it allows multiple components
/// that use DirectWrite to share internal DirectWrite state and reduce memory usage.
/// However, there are cases when it is desirable to reduce the impact of a component,
/// such as a plug-in from an untrusted source, on the rest of the process by sandboxing and isolating it
/// from the rest of the process components. In such cases, it is recommended to use an isolated factory for the sandboxed
/// component.
/// </remarks>
EXTERN_C HRESULT DWRITE_EXPORT DWriteCreateFactory(
    __in DWRITE_FACTORY_TYPE factoryType,
    __in REFIID iid,
    __out IUnknown **factory
    );

// Macros used to define DirectWrite error codes.
#define FACILITY_DWRITE 0x898
#define DWRITE_ERR_BASE 0x5000
#define MAKE_DWRITE_HR(severity, code) MAKE_HRESULT(severity, FACILITY_DWRITE, (DWRITE_ERR_BASE + code))
#define MAKE_DWRITE_HR_ERR(code) MAKE_DWRITE_HR(SEVERITY_ERROR, code)

/// <summary>
/// Indicates an error in an input file such as a font file.
/// </summary>
#define DWRITE_E_FILEFORMAT             MAKE_DWRITE_HR_ERR(0x000)

/// <summary>
/// Indicates an error originating in DirectWrite code, which is not expected to occur but is safe to recover from.
/// </summary>
#define DWRITE_E_UNEXPECTED             MAKE_DWRITE_HR_ERR(0x001)

/// <summary>
/// Indicates the specified font does not exist.
/// </summary>
#define DWRITE_E_NOFONT                 MAKE_DWRITE_HR_ERR(0x002)

/// <summary>
/// A font file could not be opened because the file, directory, network location, drive, or other storage
/// location does not exist or is unavailable.
/// </summary>
#define DWRITE_E_FILENOTFOUND           MAKE_DWRITE_HR_ERR(0x003)

/// <summary>
/// A font file exists but could not be opened due to access denied, sharing violation, or similar error.
/// </summary>
#define DWRITE_E_FILEACCESS             MAKE_DWRITE_HR_ERR(0x004)

/// <summary>
/// A font collection is obsolete due to changes in the system.
/// </summary>
#define DWRITE_E_FONTCOLLECTIONOBSOLETE MAKE_DWRITE_HR_ERR(0x005)

/// <summary>
/// The given interface is already registered.
/// </summary>
#define DWRITE_E_ALREADYREGISTERED      MAKE_DWRITE_HR_ERR(0x006)

#endif /* DWRITE_H_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dxgi.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for dxgi.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dxgi_h__
#define __dxgi_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDXGIObject_FWD_DEFINED__
#define __IDXGIObject_FWD_DEFINED__
typedef interface IDXGIObject IDXGIObject;
#endif 	/* __IDXGIObject_FWD_DEFINED__ */


#ifndef __IDXGIDeviceSubObject_FWD_DEFINED__
#define __IDXGIDeviceSubObject_FWD_DEFINED__
typedef interface IDXGIDeviceSubObject IDXGIDeviceSubObject;
#endif 	/* __IDXGIDeviceSubObject_FWD_DEFINED__ */


#ifndef __IDXGIResource_FWD_DEFINED__
#define __IDXGIResource_FWD_DEFINED__
typedef interface IDXGIResource IDXGIResource;
#endif 	/* __IDXGIResource_FWD_DEFINED__ */


#ifndef __IDXGIKeyedMutex_FWD_DEFINED__
#define __IDXGIKeyedMutex_FWD_DEFINED__
typedef interface IDXGIKeyedMutex IDXGIKeyedMutex;
#endif 	/* __IDXGIKeyedMutex_FWD_DEFINED__ */


#ifndef __IDXGISurface_FWD_DEFINED__
#define __IDXGISurface_FWD_DEFINED__
typedef interface IDXGISurface IDXGISurface;
#endif 	/* __IDXGISurface_FWD_DEFINED__ */


#ifndef __IDXGISurface1_FWD_DEFINED__
#define __IDXGISurface1_FWD_DEFINED__
typedef interface IDXGISurface1 IDXGISurface1;
#endif 	/* __IDXGISurface1_FWD_DEFINED__ */


#ifndef __IDXGIAdapter_FWD_DEFINED__
#define __IDXGIAdapter_FWD_DEFINED__
typedef interface IDXGIAdapter IDXGIAdapter;
#endif 	/* __IDXGIAdapter_FWD_DEFINED__ */


#ifndef __IDXGIOutput_FWD_DEFINED__
#define __IDXGIOutput_FWD_DEFINED__
typedef interface IDXGIOutput IDXGIOutput;
#endif 	/* __IDXGIOutput_FWD_DEFINED__ */


#ifndef __IDXGISwapChain_FWD_DEFINED__
#define __IDXGISwapChain_FWD_DEFINED__
typedef interface IDXGISwapChain IDXGISwapChain;
#endif 	/* __IDXGISwapChain_FWD_DEFINED__ */


#ifndef __IDXGIFactory_FWD_DEFINED__
#define __IDXGIFactory_FWD_DEFINED__
typedef interface IDXGIFactory IDXGIFactory;
#endif 	/* __IDXGIFactory_FWD_DEFINED__ */


#ifndef __IDXGIDevice_FWD_DEFINED__
#define __IDXGIDevice_FWD_DEFINED__
typedef interface IDXGIDevice IDXGIDevice;
#endif 	/* __IDXGIDevice_FWD_DEFINED__ */


#ifndef __IDXGIFactory1_FWD_DEFINED__
#define __IDXGIFactory1_FWD_DEFINED__
typedef interface IDXGIFactory1 IDXGIFactory1;
#endif 	/* __IDXGIFactory1_FWD_DEFINED__ */


#ifndef __IDXGIAdapter1_FWD_DEFINED__
#define __IDXGIAdapter1_FWD_DEFINED__
typedef interface IDXGIAdapter1 IDXGIAdapter1;
#endif 	/* __IDXGIAdapter1_FWD_DEFINED__ */


#ifndef __IDXGIDevice1_FWD_DEFINED__
#define __IDXGIDevice1_FWD_DEFINED__
typedef interface IDXGIDevice1 IDXGIDevice1;
#endif 	/* __IDXGIDevice1_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "dxgitype.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_dxgi_0000_0000 */
/* [local] */ 

#define DXGI_CPU_ACCESS_NONE    ( 0 )
#define DXGI_CPU_ACCESS_DYNAMIC    ( 1 )
#define DXGI_CPU_ACCESS_READ_WRITE    ( 2 )
#define DXGI_CPU_ACCESS_SCRATCH    ( 3 )
#define DXGI_CPU_ACCESS_FIELD        15
#define DXGI_USAGE_SHADER_INPUT             ( 1L << (0 + 4) )
#define DXGI_USAGE_RENDER_TARGET_OUTPUT     ( 1L << (1 + 4) )
#define DXGI_USAGE_BACK_BUFFER              ( 1L << (2 + 4) )
#define DXGI_USAGE_SHARED                   ( 1L << (3 + 4) )
#define DXGI_USAGE_READ_ONLY                ( 1L << (4 + 4) )
#define DXGI_USAGE_DISCARD_ON_PRESENT       ( 1L << (5 + 4) )
#define DXGI_USAGE_UNORDERED_ACCESS         ( 1L << (6 + 4) )
typedef UINT DXGI_USAGE;

typedef struct DXGI_FRAME_STATISTICS
    {
    UINT PresentCount;
    UINT PresentRefreshCount;
    UINT SyncRefreshCount;
    LARGE_INTEGER SyncQPCTime;
    LARGE_INTEGER SyncGPUTime;
    } 	DXGI_FRAME_STATISTICS;

typedef struct DXGI_MAPPED_RECT
    {
    INT Pitch;
    BYTE *pBits;
    } 	DXGI_MAPPED_RECT;

#ifdef __midl
typedef struct _LUID
    {
    DWORD LowPart;
    LONG HighPart;
    } 	LUID;

typedef struct _LUID *PLUID;

#endif
typedef struct DXGI_ADAPTER_DESC
    {
    WCHAR Description[ 128 ];
    UINT VendorId;
    UINT DeviceId;
    UINT SubSysId;
    UINT Revision;
    SIZE_T DedicatedVideoMemory;
    SIZE_T DedicatedSystemMemory;
    SIZE_T SharedSystemMemory;
    LUID AdapterLuid;
    } 	DXGI_ADAPTER_DESC;

#if !defined(HMONITOR_DECLARED) && !defined(HMONITOR) && (WINVER < 0x0500)
#define HMONITOR_DECLARED
#if 0
typedef HANDLE HMONITOR;

#endif
DECLARE_HANDLE(HMONITOR);
#endif
typedef struct DXGI_OUTPUT_DESC
    {
    WCHAR DeviceName[ 32 ];
    RECT DesktopCoordinates;
    BOOL AttachedToDesktop;
    DXGI_MODE_ROTATION Rotation;
    HMONITOR Monitor;
    } 	DXGI_OUTPUT_DESC;

typedef struct DXGI_SHARED_RESOURCE
    {
    HANDLE Handle;
    } 	DXGI_SHARED_RESOURCE;

#define	DXGI_RESOURCE_PRIORITY_MINIMUM	( 0x28000000 )

#define	DXGI_RESOURCE_PRIORITY_LOW	( 0x50000000 )

#define	DXGI_RESOURCE_PRIORITY_NORMAL	( 0x78000000 )

#define	DXGI_RESOURCE_PRIORITY_HIGH	( 0xa0000000 )

#define	DXGI_RESOURCE_PRIORITY_MAXIMUM	( 0xc8000000 )

typedef 
enum DXGI_RESIDENCY
    {	DXGI_RESIDENCY_FULLY_RESIDENT	= 1,
	DXGI_RESIDENCY_RESIDENT_IN_SHARED_MEMORY	= 2,
	DXGI_RESIDENCY_EVICTED_TO_DISK	= 3
    } 	DXGI_RESIDENCY;

typedef struct DXGI_SURFACE_DESC
    {
    UINT Width;
    UINT Height;
    DXGI_FORMAT Format;
    DXGI_SAMPLE_DESC SampleDesc;
    } 	DXGI_SURFACE_DESC;

typedef 
enum DXGI_SWAP_EFFECT
    {	DXGI_SWAP_EFFECT_DISCARD	= 0,
	DXGI_SWAP_EFFECT_SEQUENTIAL	= 1
    } 	DXGI_SWAP_EFFECT;

typedef 
enum DXGI_SWAP_CHAIN_FLAG
    {	DXGI_SWAP_CHAIN_FLAG_NONPREROTATED	= 1,
	DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH	= 2,
	DXGI_SWAP_CHAIN_FLAG_GDI_COMPATIBLE	= 4
    } 	DXGI_SWAP_CHAIN_FLAG;

typedef struct DXGI_SWAP_CHAIN_DESC
    {
    DXGI_MODE_DESC BufferDesc;
    DXGI_SAMPLE_DESC SampleDesc;
    DXGI_USAGE BufferUsage;
    UINT BufferCount;
    HWND OutputWindow;
    BOOL Windowed;
    DXGI_SWAP_EFFECT SwapEffect;
    UINT Flags;
    } 	DXGI_SWAP_CHAIN_DESC;



extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0000_v0_0_s_ifspec;

#ifndef __IDXGIObject_INTERFACE_DEFINED__
#define __IDXGIObject_INTERFACE_DEFINED__

/* interface IDXGIObject */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IDXGIObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aec22fb8-76f3-4639-9be0-28eb43a67a2e")
    IDXGIObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPrivateData( 
            /* [in] */ REFGUID Name,
            /* [in] */ UINT DataSize,
            /* [in] */ const void *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPrivateDataInterface( 
            /* [in] */ REFGUID Name,
            /* [in] */ const IUnknown *pUnknown) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrivateData( 
            /* [in] */ REFGUID Name,
            /* [out][in] */ UINT *pDataSize,
            /* [out] */ void *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParent( 
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppParent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGIObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXGIObject * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXGIObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXGIObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
            IDXGIObject * This,
            /* [in] */ REFGUID Name,
            /* [in] */ UINT DataSize,
            /* [in] */ const void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
            IDXGIObject * This,
            /* [in] */ REFGUID Name,
            /* [in] */ const IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
            IDXGIObject * This,
            /* [in] */ REFGUID Name,
            /* [out][in] */ UINT *pDataSize,
            /* [out] */ void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IDXGIObject * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppParent);
        
        END_INTERFACE
    } IDXGIObjectVtbl;

    interface IDXGIObject
    {
        CONST_VTBL struct IDXGIObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGIObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDXGIObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDXGIObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDXGIObject_SetPrivateData(This,Name,DataSize,pData)	\
    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 

#define IDXGIObject_SetPrivateDataInterface(This,Name,pUnknown)	\
    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 

#define IDXGIObject_GetPrivateData(This,Name,pDataSize,pData)	\
    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 

#define IDXGIObject_GetParent(This,riid,ppParent)	\
    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDXGIObject_INTERFACE_DEFINED__ */


#ifndef __IDXGIDeviceSubObject_INTERFACE_DEFINED__
#define __IDXGIDeviceSubObject_INTERFACE_DEFINED__

/* interface IDXGIDeviceSubObject */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IDXGIDeviceSubObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3d3e0379-f9de-4d58-bb6c-18d62992f1a6")
    IDXGIDeviceSubObject : public IDXGIObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDevice( 
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGIDeviceSubObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXGIDeviceSubObject * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXGIDeviceSubObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXGIDeviceSubObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
            IDXGIDeviceSubObject * This,
            /* [in] */ REFGUID Name,
            /* [in] */ UINT DataSize,
            /* [in] */ const void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
            IDXGIDeviceSubObject * This,
            /* [in] */ REFGUID Name,
            /* [in] */ const IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
            IDXGIDeviceSubObject * This,
            /* [in] */ REFGUID Name,
            /* [out][in] */ UINT *pDataSize,
            /* [out] */ void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IDXGIDeviceSubObject * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppParent);
        
        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
            IDXGIDeviceSubObject * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppDevice);
        
        END_INTERFACE
    } IDXGIDeviceSubObjectVtbl;

    interface IDXGIDeviceSubObject
    {
        CONST_VTBL struct IDXGIDeviceSubObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGIDeviceSubObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDXGIDeviceSubObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDXGIDeviceSubObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDXGIDeviceSubObject_SetPrivateData(This,Name,DataSize,pData)	\
    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 

#define IDXGIDeviceSubObject_SetPrivateDataInterface(This,Name,pUnknown)	\
    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 

#define IDXGIDeviceSubObject_GetPrivateData(This,Name,pDataSize,pData)	\
    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 

#define IDXGIDeviceSubObject_GetParent(This,riid,ppParent)	\
    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 


#define IDXGIDeviceSubObject_GetDevice(This,riid,ppDevice)	\
    ( (This)->lpVtbl -> GetDevice(This,riid,ppDevice) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDXGIDeviceSubObject_INTERFACE_DEFINED__ */


#ifndef __IDXGIResource_INTERFACE_DEFINED__
#define __IDXGIResource_INTERFACE_DEFINED__

/* interface IDXGIResource */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IDXGIResource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("035f3ab4-482e-4e50-b41f-8a7f8bd8960b")
    IDXGIResource : public IDXGIDeviceSubObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSharedHandle( 
            /* [out] */ HANDLE *pSharedHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUsage( 
            /* [out] */ DXGI_USAGE *pUsage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEvictionPriority( 
            /* [in] */ UINT EvictionPriority) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEvictionPriority( 
            /* [retval][out] */ UINT *pEvictionPriority) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGIResourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXGIResource * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXGIResource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXGIResource * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
            IDXGIResource * This,
            /* [in] */ REFGUID Name,
            /* [in] */ UINT DataSize,
            /* [in] */ const void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
            IDXGIResource * This,
            /* [in] */ REFGUID Name,
            /* [in] */ const IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
            IDXGIResource * This,
            /* [in] */ REFGUID Name,
            /* [out][in] */ UINT *pDataSize,
            /* [out] */ void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IDXGIResource * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppParent);
        
        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
            IDXGIResource * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppDevice);
        
        HRESULT ( STDMETHODCALLTYPE *GetSharedHandle )( 
            IDXGIResource * This,
            /* [out] */ HANDLE *pSharedHandle);
        
        HRESULT ( STDMETHODCALLTYPE *GetUsage )( 
            IDXGIResource * This,
            /* [out] */ DXGI_USAGE *pUsage);
        
        HRESULT ( STDMETHODCALLTYPE *SetEvictionPriority )( 
            IDXGIResource * This,
            /* [in] */ UINT EvictionPriority);
        
        HRESULT ( STDMETHODCALLTYPE *GetEvictionPriority )( 
            IDXGIResource * This,
            /* [retval][out] */ UINT *pEvictionPriority);
        
        END_INTERFACE
    } IDXGIResourceVtbl;

    interface IDXGIResource
    {
        CONST_VTBL struct IDXGIResourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGIResource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDXGIResource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDXGIResource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDXGIResource_SetPrivateData(This,Name,DataSize,pData)	\
    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 

#define IDXGIResource_SetPrivateDataInterface(This,Name,pUnknown)	\
    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 

#define IDXGIResource_GetPrivateData(This,Name,pDataSize,pData)	\
    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 

#define IDXGIResource_GetParent(This,riid,ppParent)	\
    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 


#define IDXGIResource_GetDevice(This,riid,ppDevice)	\
    ( (This)->lpVtbl -> GetDevice(This,riid,ppDevice) ) 


#define IDXGIResource_GetSharedHandle(This,pSharedHandle)	\
    ( (This)->lpVtbl -> GetSharedHandle(This,pSharedHandle) ) 

#define IDXGIResource_GetUsage(This,pUsage)	\
    ( (This)->lpVtbl -> GetUsage(This,pUsage) ) 

#define IDXGIResource_SetEvictionPriority(This,EvictionPriority)	\
    ( (This)->lpVtbl -> SetEvictionPriority(This,EvictionPriority) ) 

#define IDXGIResource_GetEvictionPriority(This,pEvictionPriority)	\
    ( (This)->lpVtbl -> GetEvictionPriority(This,pEvictionPriority) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDXGIResource_INTERFACE_DEFINED__ */


#ifndef __IDXGIKeyedMutex_INTERFACE_DEFINED__
#define __IDXGIKeyedMutex_INTERFACE_DEFINED__

/* interface IDXGIKeyedMutex */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IDXGIKeyedMutex;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9d8e1289-d7b3-465f-8126-250e349af85d")
    IDXGIKeyedMutex : public IDXGIDeviceSubObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AcquireSync( 
            /* [in] */ UINT64 Key,
            /* [in] */ DWORD dwMilliseconds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseSync( 
            /* [in] */ UINT64 Key) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGIKeyedMutexVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXGIKeyedMutex * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXGIKeyedMutex * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXGIKeyedMutex * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
            IDXGIKeyedMutex * This,
            /* [in] */ REFGUID Name,
            /* [in] */ UINT DataSize,
            /* [in] */ const void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
            IDXGIKeyedMutex * This,
            /* [in] */ REFGUID Name,
            /* [in] */ const IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
            IDXGIKeyedMutex * This,
            /* [in] */ REFGUID Name,
            /* [out][in] */ UINT *pDataSize,
            /* [out] */ void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IDXGIKeyedMutex * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppParent);
        
        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
            IDXGIKeyedMutex * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppDevice);
        
        HRESULT ( STDMETHODCALLTYPE *AcquireSync )( 
            IDXGIKeyedMutex * This,
            /* [in] */ UINT64 Key,
            /* [in] */ DWORD dwMilliseconds);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseSync )( 
            IDXGIKeyedMutex * This,
            /* [in] */ UINT64 Key);
        
        END_INTERFACE
    } IDXGIKeyedMutexVtbl;

    interface IDXGIKeyedMutex
    {
        CONST_VTBL struct IDXGIKeyedMutexVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGIKeyedMutex_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDXGIKeyedMutex_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDXGIKeyedMutex_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDXGIKeyedMutex_SetPrivateData(This,Name,DataSize,pData)	\
    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 

#define IDXGIKeyedMutex_SetPrivateDataInterface(This,Name,pUnknown)	\
    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 

#define IDXGIKeyedMutex_GetPrivateData(This,Name,pDataSize,pData)	\
    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 

#define IDXGIKeyedMutex_GetParent(This,riid,ppParent)	\
    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 


#define IDXGIKeyedMutex_GetDevice(This,riid,ppDevice)	\
    ( (This)->lpVtbl -> GetDevice(This,riid,ppDevice) ) 


#define IDXGIKeyedMutex_AcquireSync(This,Key,dwMilliseconds)	\
    ( (This)->lpVtbl -> AcquireSync(This,Key,dwMilliseconds) ) 

#define IDXGIKeyedMutex_ReleaseSync(This,Key)	\
    ( (This)->lpVtbl -> ReleaseSync(This,Key) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDXGIKeyedMutex_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxgi_0000_0004 */
/* [local] */ 

#define	DXGI_MAP_READ	( 1UL )

#define	DXGI_MAP_WRITE	( 2UL )

#define	DXGI_MAP_DISCARD	( 4UL )



extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0004_v0_0_s_ifspec;

#ifndef __IDXGISurface_INTERFACE_DEFINED__
#define __IDXGISurface_INTERFACE_DEFINED__

/* interface IDXGISurface */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IDXGISurface;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cafcb56c-6ac3-4889-bf47-9e23bbd260ec")
    IDXGISurface : public IDXGIDeviceSubObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDesc( 
            /* [out] */ DXGI_SURFACE_DESC *pDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Map( 
            /* [out] */ DXGI_MAPPED_RECT *pLockedRect,
            /* [in] */ UINT MapFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unmap( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGISurfaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXGISurface * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXGISurface * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXGISurface * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
            IDXGISurface * This,
            /* [in] */ REFGUID Name,
            /* [in] */ UINT DataSize,
            /* [in] */ const void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
            IDXGISurface * This,
            /* [in] */ REFGUID Name,
            /* [in] */ const IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
            IDXGISurface * This,
            /* [in] */ REFGUID Name,
            /* [out][in] */ UINT *pDataSize,
            /* [out] */ void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IDXGISurface * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppParent);
        
        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
            IDXGISurface * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppDevice);
        
        HRESULT ( STDMETHODCALLTYPE *GetDesc )( 
            IDXGISurface * This,
            /* [out] */ DXGI_SURFACE_DESC *pDesc);
        
        HRESULT ( STDMETHODCALLTYPE *Map )( 
            IDXGISurface * This,
            /* [out] */ DXGI_MAPPED_RECT *pLockedRect,
            /* [in] */ UINT MapFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Unmap )( 
            IDXGISurface * This);
        
        END_INTERFACE
    } IDXGISurfaceVtbl;

    interface IDXGISurface
    {
        CONST_VTBL struct IDXGISurfaceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGISurface_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDXGISurface_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDXGISurface_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDXGISurface_SetPrivateData(This,Name,DataSize,pData)	\
    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 

#define IDXGISurface_SetPrivateDataInterface(This,Name,pUnknown)	\
    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 

#define IDXGISurface_GetPrivateData(This,Name,pDataSize,pData)	\
    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 

#define IDXGISurface_GetParent(This,riid,ppParent)	\
    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 


#define IDXGISurface_GetDevice(This,riid,ppDevice)	\
    ( (This)->lpVtbl -> GetDevice(This,riid,ppDevice) ) 


#define IDXGISurface_GetDesc(This,pDesc)	\
    ( (This)->lpVtbl -> GetDesc(This,pDesc) ) 

#define IDXGISurface_Map(This,pLockedRect,MapFlags)	\
    ( (This)->lpVtbl -> Map(This,pLockedRect,MapFlags) ) 

#define IDXGISurface_Unmap(This)	\
    ( (This)->lpVtbl -> Unmap(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDXGISurface_INTERFACE_DEFINED__ */


#ifndef __IDXGISurface1_INTERFACE_DEFINED__
#define __IDXGISurface1_INTERFACE_DEFINED__

/* interface IDXGISurface1 */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IDXGISurface1;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4AE63092-6327-4c1b-80AE-BFE12EA32B86")
    IDXGISurface1 : public IDXGISurface
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDC( 
            /* [in] */ BOOL Discard,
            /* [out] */ HDC *phdc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseDC( 
            /* [in] */ RECT *pDirtyRect) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGISurface1Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXGISurface1 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXGISurface1 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXGISurface1 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
            IDXGISurface1 * This,
            /* [in] */ REFGUID Name,
            /* [in] */ UINT DataSize,
            /* [in] */ const void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
            IDXGISurface1 * This,
            /* [in] */ REFGUID Name,
            /* [in] */ const IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
            IDXGISurface1 * This,
            /* [in] */ REFGUID Name,
            /* [out][in] */ UINT *pDataSize,
            /* [out] */ void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IDXGISurface1 * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppParent);
        
        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
            IDXGISurface1 * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppDevice);
        
        HRESULT ( STDMETHODCALLTYPE *GetDesc )( 
            IDXGISurface1 * This,
            /* [out] */ DXGI_SURFACE_DESC *pDesc);
        
        HRESULT ( STDMETHODCALLTYPE *Map )( 
            IDXGISurface1 * This,
            /* [out] */ DXGI_MAPPED_RECT *pLockedRect,
            /* [in] */ UINT MapFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Unmap )( 
            IDXGISurface1 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDC )( 
            IDXGISurface1 * This,
            /* [in] */ BOOL Discard,
            /* [out] */ HDC *phdc);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseDC )( 
            IDXGISurface1 * This,
            /* [in] */ RECT *pDirtyRect);
        
        END_INTERFACE
    } IDXGISurface1Vtbl;

    interface IDXGISurface1
    {
        CONST_VTBL struct IDXGISurface1Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGISurface1_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDXGISurface1_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDXGISurface1_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDXGISurface1_SetPrivateData(This,Name,DataSize,pData)	\
    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 

#define IDXGISurface1_SetPrivateDataInterface(This,Name,pUnknown)	\
    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 

#define IDXGISurface1_GetPrivateData(This,Name,pDataSize,pData)	\
    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 

#define IDXGISurface1_GetParent(This,riid,ppParent)	\
    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 


#define IDXGISurface1_GetDevice(This,riid,ppDevice)	\
    ( (This)->lpVtbl -> GetDevice(This,riid,ppDevice) ) 


#define IDXGISurface1_GetDesc(This,pDesc)	\
    ( (This)->lpVtbl -> GetDesc(This,pDesc) ) 

#define IDXGISurface1_Map(This,pLockedRect,MapFlags)	\
    ( (This)->lpVtbl -> Map(This,pLockedRect,MapFlags) ) 

#define IDXGISurface1_Unmap(This)	\
    ( (This)->lpVtbl -> Unmap(This) ) 


#define IDXGISurface1_GetDC(This,Discard,phdc)	\
    ( (This)->lpVtbl -> GetDC(This,Discard,phdc) ) 

#define IDXGISurface1_ReleaseDC(This,pDirtyRect)	\
    ( (This)->lpVtbl -> ReleaseDC(This,pDirtyRect) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDXGISurface1_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxgi_0000_0006 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0006_v0_0_s_ifspec;

#ifndef __IDXGIAdapter_INTERFACE_DEFINED__
#define __IDXGIAdapter_INTERFACE_DEFINED__

/* interface IDXGIAdapter */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IDXGIAdapter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2411e7e1-12ac-4ccf-bd14-9798e8534dc0")
    IDXGIAdapter : public IDXGIObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumOutputs( 
            /* [in] */ UINT Output,
            /* [out][in] */ IDXGIOutput **ppOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDesc( 
            /* [out] */ DXGI_ADAPTER_DESC *pDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CheckInterfaceSupport( 
            /* [in] */ REFGUID InterfaceName,
            /* [out] */ LARGE_INTEGER *pUMDVersion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGIAdapterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXGIAdapter * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXGIAdapter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXGIAdapter * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
            IDXGIAdapter * This,
            /* [in] */ REFGUID Name,
            /* [in] */ UINT DataSize,
            /* [in] */ const void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
            IDXGIAdapter * This,
            /* [in] */ REFGUID Name,
            /* [in] */ const IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
            IDXGIAdapter * This,
            /* [in] */ REFGUID Name,
            /* [out][in] */ UINT *pDataSize,
            /* [out] */ void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IDXGIAdapter * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppParent);
        
        HRESULT ( STDMETHODCALLTYPE *EnumOutputs )( 
            IDXGIAdapter * This,
            /* [in] */ UINT Output,
            /* [out][in] */ IDXGIOutput **ppOutput);
        
        HRESULT ( STDMETHODCALLTYPE *GetDesc )( 
            IDXGIAdapter * This,
            /* [out] */ DXGI_ADAPTER_DESC *pDesc);
        
        HRESULT ( STDMETHODCALLTYPE *CheckInterfaceSupport )( 
            IDXGIAdapter * This,
            /* [in] */ REFGUID InterfaceName,
            /* [out] */ LARGE_INTEGER *pUMDVersion);
        
        END_INTERFACE
    } IDXGIAdapterVtbl;

    interface IDXGIAdapter
    {
        CONST_VTBL struct IDXGIAdapterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGIAdapter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDXGIAdapter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDXGIAdapter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDXGIAdapter_SetPrivateData(This,Name,DataSize,pData)	\
    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 

#define IDXGIAdapter_SetPrivateDataInterface(This,Name,pUnknown)	\
    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 

#define IDXGIAdapter_GetPrivateData(This,Name,pDataSize,pData)	\
    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 

#define IDXGIAdapter_GetParent(This,riid,ppParent)	\
    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 


#define IDXGIAdapter_EnumOutputs(This,Output,ppOutput)	\
    ( (This)->lpVtbl -> EnumOutputs(This,Output,ppOutput) ) 

#define IDXGIAdapter_GetDesc(This,pDesc)	\
    ( (This)->lpVtbl -> GetDesc(This,pDesc) ) 

#define IDXGIAdapter_CheckInterfaceSupport(This,InterfaceName,pUMDVersion)	\
    ( (This)->lpVtbl -> CheckInterfaceSupport(This,InterfaceName,pUMDVersion) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDXGIAdapter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxgi_0000_0007 */
/* [local] */ 

#define	DXGI_ENUM_MODES_INTERLACED	( 1UL )

#define	DXGI_ENUM_MODES_SCALING	( 2UL )



extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0007_v0_0_s_ifspec;

#ifndef __IDXGIOutput_INTERFACE_DEFINED__
#define __IDXGIOutput_INTERFACE_DEFINED__

/* interface IDXGIOutput */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IDXGIOutput;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ae02eedb-c735-4690-8d52-5a8dc20213aa")
    IDXGIOutput : public IDXGIObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDesc( 
            /* [out] */ DXGI_OUTPUT_DESC *pDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayModeList( 
            /* [in] */ DXGI_FORMAT EnumFormat,
            /* [in] */ UINT Flags,
            /* [out][in] */ UINT *pNumModes,
            /* [out] */ DXGI_MODE_DESC *pDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindClosestMatchingMode( 
            /* [in] */ const DXGI_MODE_DESC *pModeToMatch,
            /* [out] */ DXGI_MODE_DESC *pClosestMatch,
            /* [in] */ IUnknown *pConcernedDevice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WaitForVBlank( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TakeOwnership( 
            /* [in] */ IUnknown *pDevice,
            BOOL Exclusive) = 0;
        
        virtual void STDMETHODCALLTYPE ReleaseOwnership( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGammaControlCapabilities( 
            /* [out] */ DXGI_GAMMA_CONTROL_CAPABILITIES *pGammaCaps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGammaControl( 
            /* [in] */ const DXGI_GAMMA_CONTROL *pArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGammaControl( 
            /* [out] */ DXGI_GAMMA_CONTROL *pArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDisplaySurface( 
            /* [in] */ IDXGISurface *pScanoutSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplaySurfaceData( 
            /* [in] */ IDXGISurface *pDestination) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrameStatistics( 
            /* [out] */ DXGI_FRAME_STATISTICS *pStats) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGIOutputVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXGIOutput * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXGIOutput * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXGIOutput * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
            IDXGIOutput * This,
            /* [in] */ REFGUID Name,
            /* [in] */ UINT DataSize,
            /* [in] */ const void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
            IDXGIOutput * This,
            /* [in] */ REFGUID Name,
            /* [in] */ const IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
            IDXGIOutput * This,
            /* [in] */ REFGUID Name,
            /* [out][in] */ UINT *pDataSize,
            /* [out] */ void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IDXGIOutput * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppParent);
        
        HRESULT ( STDMETHODCALLTYPE *GetDesc )( 
            IDXGIOutput * This,
            /* [out] */ DXGI_OUTPUT_DESC *pDesc);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayModeList )( 
            IDXGIOutput * This,
            /* [in] */ DXGI_FORMAT EnumFormat,
            /* [in] */ UINT Flags,
            /* [out][in] */ UINT *pNumModes,
            /* [out] */ DXGI_MODE_DESC *pDesc);
        
        HRESULT ( STDMETHODCALLTYPE *FindClosestMatchingMode )( 
            IDXGIOutput * This,
            /* [in] */ const DXGI_MODE_DESC *pModeToMatch,
            /* [out] */ DXGI_MODE_DESC *pClosestMatch,
            /* [in] */ IUnknown *pConcernedDevice);
        
        HRESULT ( STDMETHODCALLTYPE *WaitForVBlank )( 
            IDXGIOutput * This);
        
        HRESULT ( STDMETHODCALLTYPE *TakeOwnership )( 
            IDXGIOutput * This,
            /* [in] */ IUnknown *pDevice,
            BOOL Exclusive);
        
        void ( STDMETHODCALLTYPE *ReleaseOwnership )( 
            IDXGIOutput * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetGammaControlCapabilities )( 
            IDXGIOutput * This,
            /* [out] */ DXGI_GAMMA_CONTROL_CAPABILITIES *pGammaCaps);
        
        HRESULT ( STDMETHODCALLTYPE *SetGammaControl )( 
            IDXGIOutput * This,
            /* [in] */ const DXGI_GAMMA_CONTROL *pArray);
        
        HRESULT ( STDMETHODCALLTYPE *GetGammaControl )( 
            IDXGIOutput * This,
            /* [out] */ DXGI_GAMMA_CONTROL *pArray);
        
        HRESULT ( STDMETHODCALLTYPE *SetDisplaySurface )( 
            IDXGIOutput * This,
            /* [in] */ IDXGISurface *pScanoutSurface);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplaySurfaceData )( 
            IDXGIOutput * This,
            /* [in] */ IDXGISurface *pDestination);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrameStatistics )( 
            IDXGIOutput * This,
            /* [out] */ DXGI_FRAME_STATISTICS *pStats);
        
        END_INTERFACE
    } IDXGIOutputVtbl;

    interface IDXGIOutput
    {
        CONST_VTBL struct IDXGIOutputVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGIOutput_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDXGIOutput_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDXGIOutput_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDXGIOutput_SetPrivateData(This,Name,DataSize,pData)	\
    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 

#define IDXGIOutput_SetPrivateDataInterface(This,Name,pUnknown)	\
    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 

#define IDXGIOutput_GetPrivateData(This,Name,pDataSize,pData)	\
    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 

#define IDXGIOutput_GetParent(This,riid,ppParent)	\
    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 


#define IDXGIOutput_GetDesc(This,pDesc)	\
    ( (This)->lpVtbl -> GetDesc(This,pDesc) ) 

#define IDXGIOutput_GetDisplayModeList(This,EnumFormat,Flags,pNumModes,pDesc)	\
    ( (This)->lpVtbl -> GetDisplayModeList(This,EnumFormat,Flags,pNumModes,pDesc) ) 

#define IDXGIOutput_FindClosestMatchingMode(This,pModeToMatch,pClosestMatch,pConcernedDevice)	\
    ( (This)->lpVtbl -> FindClosestMatchingMode(This,pModeToMatch,pClosestMatch,pConcernedDevice) ) 

#define IDXGIOutput_WaitForVBlank(This)	\
    ( (This)->lpVtbl -> WaitForVBlank(This) ) 

#define IDXGIOutput_TakeOwnership(This,pDevice,Exclusive)	\
    ( (This)->lpVtbl -> TakeOwnership(This,pDevice,Exclusive) ) 

#define IDXGIOutput_ReleaseOwnership(This)	\
    ( (This)->lpVtbl -> ReleaseOwnership(This) ) 

#define IDXGIOutput_GetGammaControlCapabilities(This,pGammaCaps)	\
    ( (This)->lpVtbl -> GetGammaControlCapabilities(This,pGammaCaps) ) 

#define IDXGIOutput_SetGammaControl(This,pArray)	\
    ( (This)->lpVtbl -> SetGammaControl(This,pArray) ) 

#define IDXGIOutput_GetGammaControl(This,pArray)	\
    ( (This)->lpVtbl -> GetGammaControl(This,pArray) ) 

#define IDXGIOutput_SetDisplaySurface(This,pScanoutSurface)	\
    ( (This)->lpVtbl -> SetDisplaySurface(This,pScanoutSurface) ) 

#define IDXGIOutput_GetDisplaySurfaceData(This,pDestination)	\
    ( (This)->lpVtbl -> GetDisplaySurfaceData(This,pDestination) ) 

#define IDXGIOutput_GetFrameStatistics(This,pStats)	\
    ( (This)->lpVtbl -> GetFrameStatistics(This,pStats) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDXGIOutput_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxgi_0000_0008 */
/* [local] */ 

#define DXGI_MAX_SWAP_CHAIN_BUFFERS        ( 16 )
#define DXGI_PRESENT_TEST               0x00000001UL
#define DXGI_PRESENT_DO_NOT_SEQUENCE    0x00000002UL
#define DXGI_PRESENT_RESTART            0x00000004UL


extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0008_v0_0_s_ifspec;

#ifndef __IDXGISwapChain_INTERFACE_DEFINED__
#define __IDXGISwapChain_INTERFACE_DEFINED__

/* interface IDXGISwapChain */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IDXGISwapChain;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("310d36a0-d2e7-4c0a-aa04-6a9d23b8886a")
    IDXGISwapChain : public IDXGIDeviceSubObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Present( 
            /* [in] */ UINT SyncInterval,
            /* [in] */ UINT Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBuffer( 
            /* [in] */ UINT Buffer,
            /* [in] */ REFIID riid,
            /* [out][in] */ void **ppSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFullscreenState( 
            /* [in] */ BOOL Fullscreen,
            /* [in] */ IDXGIOutput *pTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFullscreenState( 
            /* [out] */ BOOL *pFullscreen,
            /* [out] */ IDXGIOutput **ppTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDesc( 
            /* [out] */ DXGI_SWAP_CHAIN_DESC *pDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResizeBuffers( 
            /* [in] */ UINT BufferCount,
            /* [in] */ UINT Width,
            /* [in] */ UINT Height,
            /* [in] */ DXGI_FORMAT NewFormat,
            /* [in] */ UINT SwapChainFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResizeTarget( 
            /* [in] */ const DXGI_MODE_DESC *pNewTargetParameters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContainingOutput( 
            IDXGIOutput **ppOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrameStatistics( 
            /* [out] */ DXGI_FRAME_STATISTICS *pStats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastPresentCount( 
            /* [out] */ UINT *pLastPresentCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGISwapChainVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXGISwapChain * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXGISwapChain * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXGISwapChain * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
            IDXGISwapChain * This,
            /* [in] */ REFGUID Name,
            /* [in] */ UINT DataSize,
            /* [in] */ const void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
            IDXGISwapChain * This,
            /* [in] */ REFGUID Name,
            /* [in] */ const IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
            IDXGISwapChain * This,
            /* [in] */ REFGUID Name,
            /* [out][in] */ UINT *pDataSize,
            /* [out] */ void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IDXGISwapChain * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppParent);
        
        HRESULT ( STDMETHODCALLTYPE *GetDevice )( 
            IDXGISwapChain * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppDevice);
        
        HRESULT ( STDMETHODCALLTYPE *Present )( 
            IDXGISwapChain * This,
            /* [in] */ UINT SyncInterval,
            /* [in] */ UINT Flags);
        
        HRESULT ( STDMETHODCALLTYPE *GetBuffer )( 
            IDXGISwapChain * This,
            /* [in] */ UINT Buffer,
            /* [in] */ REFIID riid,
            /* [out][in] */ void **ppSurface);
        
        HRESULT ( STDMETHODCALLTYPE *SetFullscreenState )( 
            IDXGISwapChain * This,
            /* [in] */ BOOL Fullscreen,
            /* [in] */ IDXGIOutput *pTarget);
        
        HRESULT ( STDMETHODCALLTYPE *GetFullscreenState )( 
            IDXGISwapChain * This,
            /* [out] */ BOOL *pFullscreen,
            /* [out] */ IDXGIOutput **ppTarget);
        
        HRESULT ( STDMETHODCALLTYPE *GetDesc )( 
            IDXGISwapChain * This,
            /* [out] */ DXGI_SWAP_CHAIN_DESC *pDesc);
        
        HRESULT ( STDMETHODCALLTYPE *ResizeBuffers )( 
            IDXGISwapChain * This,
            /* [in] */ UINT BufferCount,
            /* [in] */ UINT Width,
            /* [in] */ UINT Height,
            /* [in] */ DXGI_FORMAT NewFormat,
            /* [in] */ UINT SwapChainFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ResizeTarget )( 
            IDXGISwapChain * This,
            /* [in] */ const DXGI_MODE_DESC *pNewTargetParameters);
        
        HRESULT ( STDMETHODCALLTYPE *GetContainingOutput )( 
            IDXGISwapChain * This,
            IDXGIOutput **ppOutput);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrameStatistics )( 
            IDXGISwapChain * This,
            /* [out] */ DXGI_FRAME_STATISTICS *pStats);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastPresentCount )( 
            IDXGISwapChain * This,
            /* [out] */ UINT *pLastPresentCount);
        
        END_INTERFACE
    } IDXGISwapChainVtbl;

    interface IDXGISwapChain
    {
        CONST_VTBL struct IDXGISwapChainVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGISwapChain_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDXGISwapChain_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDXGISwapChain_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDXGISwapChain_SetPrivateData(This,Name,DataSize,pData)	\
    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 

#define IDXGISwapChain_SetPrivateDataInterface(This,Name,pUnknown)	\
    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 

#define IDXGISwapChain_GetPrivateData(This,Name,pDataSize,pData)	\
    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 

#define IDXGISwapChain_GetParent(This,riid,ppParent)	\
    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 


#define IDXGISwapChain_GetDevice(This,riid,ppDevice)	\
    ( (This)->lpVtbl -> GetDevice(This,riid,ppDevice) ) 


#define IDXGISwapChain_Present(This,SyncInterval,Flags)	\
    ( (This)->lpVtbl -> Present(This,SyncInterval,Flags) ) 

#define IDXGISwapChain_GetBuffer(This,Buffer,riid,ppSurface)	\
    ( (This)->lpVtbl -> GetBuffer(This,Buffer,riid,ppSurface) ) 

#define IDXGISwapChain_SetFullscreenState(This,Fullscreen,pTarget)	\
    ( (This)->lpVtbl -> SetFullscreenState(This,Fullscreen,pTarget) ) 

#define IDXGISwapChain_GetFullscreenState(This,pFullscreen,ppTarget)	\
    ( (This)->lpVtbl -> GetFullscreenState(This,pFullscreen,ppTarget) ) 

#define IDXGISwapChain_GetDesc(This,pDesc)	\
    ( (This)->lpVtbl -> GetDesc(This,pDesc) ) 

#define IDXGISwapChain_ResizeBuffers(This,BufferCount,Width,Height,NewFormat,SwapChainFlags)	\
    ( (This)->lpVtbl -> ResizeBuffers(This,BufferCount,Width,Height,NewFormat,SwapChainFlags) ) 

#define IDXGISwapChain_ResizeTarget(This,pNewTargetParameters)	\
    ( (This)->lpVtbl -> ResizeTarget(This,pNewTargetParameters) ) 

#define IDXGISwapChain_GetContainingOutput(This,ppOutput)	\
    ( (This)->lpVtbl -> GetContainingOutput(This,ppOutput) ) 

#define IDXGISwapChain_GetFrameStatistics(This,pStats)	\
    ( (This)->lpVtbl -> GetFrameStatistics(This,pStats) ) 

#define IDXGISwapChain_GetLastPresentCount(This,pLastPresentCount)	\
    ( (This)->lpVtbl -> GetLastPresentCount(This,pLastPresentCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDXGISwapChain_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxgi_0000_0009 */
/* [local] */ 

#define DXGI_MWA_NO_WINDOW_CHANGES      ( 1 << 0 )
#define DXGI_MWA_NO_ALT_ENTER           ( 1 << 1 )
#define DXGI_MWA_NO_PRINT_SCREEN        ( 1 << 2 )
#define DXGI_MWA_VALID                  ( 0x7 )


extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0009_v0_0_s_ifspec;

#ifndef __IDXGIFactory_INTERFACE_DEFINED__
#define __IDXGIFactory_INTERFACE_DEFINED__

/* interface IDXGIFactory */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IDXGIFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7b7166ec-21c7-44ae-b21a-c9ae321ae369")
    IDXGIFactory : public IDXGIObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumAdapters( 
            /* [in] */ UINT Adapter,
            /* [out] */ IDXGIAdapter **ppAdapter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MakeWindowAssociation( 
            HWND WindowHandle,
            UINT Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWindowAssociation( 
            HWND *pWindowHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSwapChain( 
            IUnknown *pDevice,
            DXGI_SWAP_CHAIN_DESC *pDesc,
            IDXGISwapChain **ppSwapChain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSoftwareAdapter( 
            /* [in] */ HMODULE Module,
            /* [out] */ IDXGIAdapter **ppAdapter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGIFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXGIFactory * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXGIFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXGIFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
            IDXGIFactory * This,
            /* [in] */ REFGUID Name,
            /* [in] */ UINT DataSize,
            /* [in] */ const void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
            IDXGIFactory * This,
            /* [in] */ REFGUID Name,
            /* [in] */ const IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
            IDXGIFactory * This,
            /* [in] */ REFGUID Name,
            /* [out][in] */ UINT *pDataSize,
            /* [out] */ void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IDXGIFactory * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppParent);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAdapters )( 
            IDXGIFactory * This,
            /* [in] */ UINT Adapter,
            /* [out] */ IDXGIAdapter **ppAdapter);
        
        HRESULT ( STDMETHODCALLTYPE *MakeWindowAssociation )( 
            IDXGIFactory * This,
            HWND WindowHandle,
            UINT Flags);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindowAssociation )( 
            IDXGIFactory * This,
            HWND *pWindowHandle);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSwapChain )( 
            IDXGIFactory * This,
            IUnknown *pDevice,
            DXGI_SWAP_CHAIN_DESC *pDesc,
            IDXGISwapChain **ppSwapChain);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSoftwareAdapter )( 
            IDXGIFactory * This,
            /* [in] */ HMODULE Module,
            /* [out] */ IDXGIAdapter **ppAdapter);
        
        END_INTERFACE
    } IDXGIFactoryVtbl;

    interface IDXGIFactory
    {
        CONST_VTBL struct IDXGIFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGIFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDXGIFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDXGIFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDXGIFactory_SetPrivateData(This,Name,DataSize,pData)	\
    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 

#define IDXGIFactory_SetPrivateDataInterface(This,Name,pUnknown)	\
    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 

#define IDXGIFactory_GetPrivateData(This,Name,pDataSize,pData)	\
    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 

#define IDXGIFactory_GetParent(This,riid,ppParent)	\
    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 


#define IDXGIFactory_EnumAdapters(This,Adapter,ppAdapter)	\
    ( (This)->lpVtbl -> EnumAdapters(This,Adapter,ppAdapter) ) 

#define IDXGIFactory_MakeWindowAssociation(This,WindowHandle,Flags)	\
    ( (This)->lpVtbl -> MakeWindowAssociation(This,WindowHandle,Flags) ) 

#define IDXGIFactory_GetWindowAssociation(This,pWindowHandle)	\
    ( (This)->lpVtbl -> GetWindowAssociation(This,pWindowHandle) ) 

#define IDXGIFactory_CreateSwapChain(This,pDevice,pDesc,ppSwapChain)	\
    ( (This)->lpVtbl -> CreateSwapChain(This,pDevice,pDesc,ppSwapChain) ) 

#define IDXGIFactory_CreateSoftwareAdapter(This,Module,ppAdapter)	\
    ( (This)->lpVtbl -> CreateSoftwareAdapter(This,Module,ppAdapter) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDXGIFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxgi_0000_0010 */
/* [local] */ 

HRESULT WINAPI CreateDXGIFactory(REFIID riid, void **ppFactory);
HRESULT WINAPI CreateDXGIFactory1(REFIID riid, void **ppFactory);


extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0010_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0010_v0_0_s_ifspec;

#ifndef __IDXGIDevice_INTERFACE_DEFINED__
#define __IDXGIDevice_INTERFACE_DEFINED__

/* interface IDXGIDevice */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IDXGIDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("54ec77fa-1377-44e6-8c32-88fd5f44c84c")
    IDXGIDevice : public IDXGIObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAdapter( 
            /* [out] */ IDXGIAdapter **pAdapter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSurface( 
            /* [in] */ const DXGI_SURFACE_DESC *pDesc,
            /* [in] */ UINT NumSurfaces,
            /* [in] */ DXGI_USAGE Usage,
            /* [in] */ const DXGI_SHARED_RESOURCE *pSharedResource,
            /* [out] */ IDXGISurface **ppSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryResourceResidency( 
            /* [size_is][in] */ IUnknown *const *ppResources,
            /* [size_is][out] */ DXGI_RESIDENCY *pResidencyStatus,
            /* [in] */ UINT NumResources) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGPUThreadPriority( 
            /* [in] */ INT Priority) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGPUThreadPriority( 
            /* [retval][out] */ INT *pPriority) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGIDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXGIDevice * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXGIDevice * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXGIDevice * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
            IDXGIDevice * This,
            /* [in] */ REFGUID Name,
            /* [in] */ UINT DataSize,
            /* [in] */ const void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
            IDXGIDevice * This,
            /* [in] */ REFGUID Name,
            /* [in] */ const IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
            IDXGIDevice * This,
            /* [in] */ REFGUID Name,
            /* [out][in] */ UINT *pDataSize,
            /* [out] */ void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IDXGIDevice * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppParent);
        
        HRESULT ( STDMETHODCALLTYPE *GetAdapter )( 
            IDXGIDevice * This,
            /* [out] */ IDXGIAdapter **pAdapter);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSurface )( 
            IDXGIDevice * This,
            /* [in] */ const DXGI_SURFACE_DESC *pDesc,
            /* [in] */ UINT NumSurfaces,
            /* [in] */ DXGI_USAGE Usage,
            /* [in] */ const DXGI_SHARED_RESOURCE *pSharedResource,
            /* [out] */ IDXGISurface **ppSurface);
        
        HRESULT ( STDMETHODCALLTYPE *QueryResourceResidency )( 
            IDXGIDevice * This,
            /* [size_is][in] */ IUnknown *const *ppResources,
            /* [size_is][out] */ DXGI_RESIDENCY *pResidencyStatus,
            /* [in] */ UINT NumResources);
        
        HRESULT ( STDMETHODCALLTYPE *SetGPUThreadPriority )( 
            IDXGIDevice * This,
            /* [in] */ INT Priority);
        
        HRESULT ( STDMETHODCALLTYPE *GetGPUThreadPriority )( 
            IDXGIDevice * This,
            /* [retval][out] */ INT *pPriority);
        
        END_INTERFACE
    } IDXGIDeviceVtbl;

    interface IDXGIDevice
    {
        CONST_VTBL struct IDXGIDeviceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGIDevice_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDXGIDevice_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDXGIDevice_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDXGIDevice_SetPrivateData(This,Name,DataSize,pData)	\
    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 

#define IDXGIDevice_SetPrivateDataInterface(This,Name,pUnknown)	\
    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 

#define IDXGIDevice_GetPrivateData(This,Name,pDataSize,pData)	\
    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 

#define IDXGIDevice_GetParent(This,riid,ppParent)	\
    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 


#define IDXGIDevice_GetAdapter(This,pAdapter)	\
    ( (This)->lpVtbl -> GetAdapter(This,pAdapter) ) 

#define IDXGIDevice_CreateSurface(This,pDesc,NumSurfaces,Usage,pSharedResource,ppSurface)	\
    ( (This)->lpVtbl -> CreateSurface(This,pDesc,NumSurfaces,Usage,pSharedResource,ppSurface) ) 

#define IDXGIDevice_QueryResourceResidency(This,ppResources,pResidencyStatus,NumResources)	\
    ( (This)->lpVtbl -> QueryResourceResidency(This,ppResources,pResidencyStatus,NumResources) ) 

#define IDXGIDevice_SetGPUThreadPriority(This,Priority)	\
    ( (This)->lpVtbl -> SetGPUThreadPriority(This,Priority) ) 

#define IDXGIDevice_GetGPUThreadPriority(This,pPriority)	\
    ( (This)->lpVtbl -> GetGPUThreadPriority(This,pPriority) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDXGIDevice_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxgi_0000_0011 */
/* [local] */ 

typedef 
enum DXGI_ADAPTER_FLAG
    {	DXGI_ADAPTER_FLAG_NONE	= 0,
	DXGI_ADAPTER_FLAG_REMOTE	= 1,
	DXGI_ADAPTER_FLAG_FORCE_DWORD	= 0xffffffff
    } 	DXGI_ADAPTER_FLAG;

typedef struct DXGI_ADAPTER_DESC1
    {
    WCHAR Description[ 128 ];
    UINT VendorId;
    UINT DeviceId;
    UINT SubSysId;
    UINT Revision;
    SIZE_T DedicatedVideoMemory;
    SIZE_T DedicatedSystemMemory;
    SIZE_T SharedSystemMemory;
    LUID AdapterLuid;
    UINT Flags;
    } 	DXGI_ADAPTER_DESC1;

typedef struct DXGI_DISPLAY_COLOR_SPACE
    {
    FLOAT PrimaryCoordinates[ 8 ][ 2 ];
    FLOAT WhitePoints[ 16 ][ 2 ];
    } 	DXGI_DISPLAY_COLOR_SPACE;




extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0011_v0_0_s_ifspec;

#ifndef __IDXGIFactory1_INTERFACE_DEFINED__
#define __IDXGIFactory1_INTERFACE_DEFINED__

/* interface IDXGIFactory1 */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IDXGIFactory1;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("770aae78-f26f-4dba-a829-253c83d1b387")
    IDXGIFactory1 : public IDXGIFactory
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumAdapters1( 
            /* [in] */ UINT Adapter,
            /* [out] */ IDXGIAdapter1 **ppAdapter) = 0;
        
        virtual BOOL STDMETHODCALLTYPE IsCurrent( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGIFactory1Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXGIFactory1 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXGIFactory1 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXGIFactory1 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
            IDXGIFactory1 * This,
            /* [in] */ REFGUID Name,
            /* [in] */ UINT DataSize,
            /* [in] */ const void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
            IDXGIFactory1 * This,
            /* [in] */ REFGUID Name,
            /* [in] */ const IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
            IDXGIFactory1 * This,
            /* [in] */ REFGUID Name,
            /* [out][in] */ UINT *pDataSize,
            /* [out] */ void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IDXGIFactory1 * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppParent);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAdapters )( 
            IDXGIFactory1 * This,
            /* [in] */ UINT Adapter,
            /* [out] */ IDXGIAdapter **ppAdapter);
        
        HRESULT ( STDMETHODCALLTYPE *MakeWindowAssociation )( 
            IDXGIFactory1 * This,
            HWND WindowHandle,
            UINT Flags);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindowAssociation )( 
            IDXGIFactory1 * This,
            HWND *pWindowHandle);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSwapChain )( 
            IDXGIFactory1 * This,
            IUnknown *pDevice,
            DXGI_SWAP_CHAIN_DESC *pDesc,
            IDXGISwapChain **ppSwapChain);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSoftwareAdapter )( 
            IDXGIFactory1 * This,
            /* [in] */ HMODULE Module,
            /* [out] */ IDXGIAdapter **ppAdapter);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAdapters1 )( 
            IDXGIFactory1 * This,
            /* [in] */ UINT Adapter,
            /* [out] */ IDXGIAdapter1 **ppAdapter);
        
        BOOL ( STDMETHODCALLTYPE *IsCurrent )( 
            IDXGIFactory1 * This);
        
        END_INTERFACE
    } IDXGIFactory1Vtbl;

    interface IDXGIFactory1
    {
        CONST_VTBL struct IDXGIFactory1Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGIFactory1_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDXGIFactory1_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDXGIFactory1_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDXGIFactory1_SetPrivateData(This,Name,DataSize,pData)	\
    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 

#define IDXGIFactory1_SetPrivateDataInterface(This,Name,pUnknown)	\
    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 

#define IDXGIFactory1_GetPrivateData(This,Name,pDataSize,pData)	\
    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 

#define IDXGIFactory1_GetParent(This,riid,ppParent)	\
    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 


#define IDXGIFactory1_EnumAdapters(This,Adapter,ppAdapter)	\
    ( (This)->lpVtbl -> EnumAdapters(This,Adapter,ppAdapter) ) 

#define IDXGIFactory1_MakeWindowAssociation(This,WindowHandle,Flags)	\
    ( (This)->lpVtbl -> MakeWindowAssociation(This,WindowHandle,Flags) ) 

#define IDXGIFactory1_GetWindowAssociation(This,pWindowHandle)	\
    ( (This)->lpVtbl -> GetWindowAssociation(This,pWindowHandle) ) 

#define IDXGIFactory1_CreateSwapChain(This,pDevice,pDesc,ppSwapChain)	\
    ( (This)->lpVtbl -> CreateSwapChain(This,pDevice,pDesc,ppSwapChain) ) 

#define IDXGIFactory1_CreateSoftwareAdapter(This,Module,ppAdapter)	\
    ( (This)->lpVtbl -> CreateSoftwareAdapter(This,Module,ppAdapter) ) 


#define IDXGIFactory1_EnumAdapters1(This,Adapter,ppAdapter)	\
    ( (This)->lpVtbl -> EnumAdapters1(This,Adapter,ppAdapter) ) 

#define IDXGIFactory1_IsCurrent(This)	\
    ( (This)->lpVtbl -> IsCurrent(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDXGIFactory1_INTERFACE_DEFINED__ */


#ifndef __IDXGIAdapter1_INTERFACE_DEFINED__
#define __IDXGIAdapter1_INTERFACE_DEFINED__

/* interface IDXGIAdapter1 */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IDXGIAdapter1;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("29038f61-3839-4626-91fd-086879011a05")
    IDXGIAdapter1 : public IDXGIAdapter
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDesc1( 
            /* [out] */ DXGI_ADAPTER_DESC1 *pDesc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGIAdapter1Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXGIAdapter1 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXGIAdapter1 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXGIAdapter1 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
            IDXGIAdapter1 * This,
            /* [in] */ REFGUID Name,
            /* [in] */ UINT DataSize,
            /* [in] */ const void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
            IDXGIAdapter1 * This,
            /* [in] */ REFGUID Name,
            /* [in] */ const IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
            IDXGIAdapter1 * This,
            /* [in] */ REFGUID Name,
            /* [out][in] */ UINT *pDataSize,
            /* [out] */ void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IDXGIAdapter1 * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppParent);
        
        HRESULT ( STDMETHODCALLTYPE *EnumOutputs )( 
            IDXGIAdapter1 * This,
            /* [in] */ UINT Output,
            /* [out][in] */ IDXGIOutput **ppOutput);
        
        HRESULT ( STDMETHODCALLTYPE *GetDesc )( 
            IDXGIAdapter1 * This,
            /* [out] */ DXGI_ADAPTER_DESC *pDesc);
        
        HRESULT ( STDMETHODCALLTYPE *CheckInterfaceSupport )( 
            IDXGIAdapter1 * This,
            /* [in] */ REFGUID InterfaceName,
            /* [out] */ LARGE_INTEGER *pUMDVersion);
        
        HRESULT ( STDMETHODCALLTYPE *GetDesc1 )( 
            IDXGIAdapter1 * This,
            /* [out] */ DXGI_ADAPTER_DESC1 *pDesc);
        
        END_INTERFACE
    } IDXGIAdapter1Vtbl;

    interface IDXGIAdapter1
    {
        CONST_VTBL struct IDXGIAdapter1Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGIAdapter1_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDXGIAdapter1_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDXGIAdapter1_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDXGIAdapter1_SetPrivateData(This,Name,DataSize,pData)	\
    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 

#define IDXGIAdapter1_SetPrivateDataInterface(This,Name,pUnknown)	\
    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 

#define IDXGIAdapter1_GetPrivateData(This,Name,pDataSize,pData)	\
    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 

#define IDXGIAdapter1_GetParent(This,riid,ppParent)	\
    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 


#define IDXGIAdapter1_EnumOutputs(This,Output,ppOutput)	\
    ( (This)->lpVtbl -> EnumOutputs(This,Output,ppOutput) ) 

#define IDXGIAdapter1_GetDesc(This,pDesc)	\
    ( (This)->lpVtbl -> GetDesc(This,pDesc) ) 

#define IDXGIAdapter1_CheckInterfaceSupport(This,InterfaceName,pUMDVersion)	\
    ( (This)->lpVtbl -> CheckInterfaceSupport(This,InterfaceName,pUMDVersion) ) 


#define IDXGIAdapter1_GetDesc1(This,pDesc)	\
    ( (This)->lpVtbl -> GetDesc1(This,pDesc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDXGIAdapter1_INTERFACE_DEFINED__ */


#ifndef __IDXGIDevice1_INTERFACE_DEFINED__
#define __IDXGIDevice1_INTERFACE_DEFINED__

/* interface IDXGIDevice1 */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IDXGIDevice1;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77db970f-6276-48ba-ba28-070143b4392c")
    IDXGIDevice1 : public IDXGIDevice
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMaximumFrameLatency( 
            /* [in] */ UINT MaxLatency) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaximumFrameLatency( 
            /* [out] */ UINT *pMaxLatency) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGIDevice1Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXGIDevice1 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXGIDevice1 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXGIDevice1 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateData )( 
            IDXGIDevice1 * This,
            /* [in] */ REFGUID Name,
            /* [in] */ UINT DataSize,
            /* [in] */ const void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrivateDataInterface )( 
            IDXGIDevice1 * This,
            /* [in] */ REFGUID Name,
            /* [in] */ const IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateData )( 
            IDXGIDevice1 * This,
            /* [in] */ REFGUID Name,
            /* [out][in] */ UINT *pDataSize,
            /* [out] */ void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            IDXGIDevice1 * This,
            /* [in] */ REFIID riid,
            /* [retval][out] */ void **ppParent);
        
        HRESULT ( STDMETHODCALLTYPE *GetAdapter )( 
            IDXGIDevice1 * This,
            /* [out] */ IDXGIAdapter **pAdapter);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSurface )( 
            IDXGIDevice1 * This,
            /* [in] */ const DXGI_SURFACE_DESC *pDesc,
            /* [in] */ UINT NumSurfaces,
            /* [in] */ DXGI_USAGE Usage,
            /* [in] */ const DXGI_SHARED_RESOURCE *pSharedResource,
            /* [out] */ IDXGISurface **ppSurface);
        
        HRESULT ( STDMETHODCALLTYPE *QueryResourceResidency )( 
            IDXGIDevice1 * This,
            /* [size_is][in] */ IUnknown *const *ppResources,
            /* [size_is][out] */ DXGI_RESIDENCY *pResidencyStatus,
            /* [in] */ UINT NumResources);
        
        HRESULT ( STDMETHODCALLTYPE *SetGPUThreadPriority )( 
            IDXGIDevice1 * This,
            /* [in] */ INT Priority);
        
        HRESULT ( STDMETHODCALLTYPE *GetGPUThreadPriority )( 
            IDXGIDevice1 * This,
            /* [retval][out] */ INT *pPriority);
        
        HRESULT ( STDMETHODCALLTYPE *SetMaximumFrameLatency )( 
            IDXGIDevice1 * This,
            /* [in] */ UINT MaxLatency);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaximumFrameLatency )( 
            IDXGIDevice1 * This,
            /* [out] */ UINT *pMaxLatency);
        
        END_INTERFACE
    } IDXGIDevice1Vtbl;

    interface IDXGIDevice1
    {
        CONST_VTBL struct IDXGIDevice1Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGIDevice1_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDXGIDevice1_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDXGIDevice1_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDXGIDevice1_SetPrivateData(This,Name,DataSize,pData)	\
    ( (This)->lpVtbl -> SetPrivateData(This,Name,DataSize,pData) ) 

#define IDXGIDevice1_SetPrivateDataInterface(This,Name,pUnknown)	\
    ( (This)->lpVtbl -> SetPrivateDataInterface(This,Name,pUnknown) ) 

#define IDXGIDevice1_GetPrivateData(This,Name,pDataSize,pData)	\
    ( (This)->lpVtbl -> GetPrivateData(This,Name,pDataSize,pData) ) 

#define IDXGIDevice1_GetParent(This,riid,ppParent)	\
    ( (This)->lpVtbl -> GetParent(This,riid,ppParent) ) 


#define IDXGIDevice1_GetAdapter(This,pAdapter)	\
    ( (This)->lpVtbl -> GetAdapter(This,pAdapter) ) 

#define IDXGIDevice1_CreateSurface(This,pDesc,NumSurfaces,Usage,pSharedResource,ppSurface)	\
    ( (This)->lpVtbl -> CreateSurface(This,pDesc,NumSurfaces,Usage,pSharedResource,ppSurface) ) 

#define IDXGIDevice1_QueryResourceResidency(This,ppResources,pResidencyStatus,NumResources)	\
    ( (This)->lpVtbl -> QueryResourceResidency(This,ppResources,pResidencyStatus,NumResources) ) 

#define IDXGIDevice1_SetGPUThreadPriority(This,Priority)	\
    ( (This)->lpVtbl -> SetGPUThreadPriority(This,Priority) ) 

#define IDXGIDevice1_GetGPUThreadPriority(This,pPriority)	\
    ( (This)->lpVtbl -> GetGPUThreadPriority(This,pPriority) ) 


#define IDXGIDevice1_SetMaximumFrameLatency(This,MaxLatency)	\
    ( (This)->lpVtbl -> SetMaximumFrameLatency(This,MaxLatency) ) 

#define IDXGIDevice1_GetMaximumFrameLatency(This,pMaxLatency)	\
    ( (This)->lpVtbl -> GetMaximumFrameLatency(This,pMaxLatency) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDXGIDevice1_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxgi_0000_0014 */
/* [local] */ 

#ifdef __cplusplus
#endif /*__cplusplus*/
DEFINE_GUID(IID_IDXGIObject,0xaec22fb8,0x76f3,0x4639,0x9b,0xe0,0x28,0xeb,0x43,0xa6,0x7a,0x2e);
DEFINE_GUID(IID_IDXGIDeviceSubObject,0x3d3e0379,0xf9de,0x4d58,0xbb,0x6c,0x18,0xd6,0x29,0x92,0xf1,0xa6);
DEFINE_GUID(IID_IDXGIResource,0x035f3ab4,0x482e,0x4e50,0xb4,0x1f,0x8a,0x7f,0x8b,0xd8,0x96,0x0b);
DEFINE_GUID(IID_IDXGIKeyedMutex,0x9d8e1289,0xd7b3,0x465f,0x81,0x26,0x25,0x0e,0x34,0x9a,0xf8,0x5d);
DEFINE_GUID(IID_IDXGISurface,0xcafcb56c,0x6ac3,0x4889,0xbf,0x47,0x9e,0x23,0xbb,0xd2,0x60,0xec);
DEFINE_GUID(IID_IDXGISurface1,0x4AE63092,0x6327,0x4c1b,0x80,0xAE,0xBF,0xE1,0x2E,0xA3,0x2B,0x86);
DEFINE_GUID(IID_IDXGIAdapter,0x2411e7e1,0x12ac,0x4ccf,0xbd,0x14,0x97,0x98,0xe8,0x53,0x4d,0xc0);
DEFINE_GUID(IID_IDXGIOutput,0xae02eedb,0xc735,0x4690,0x8d,0x52,0x5a,0x8d,0xc2,0x02,0x13,0xaa);
DEFINE_GUID(IID_IDXGISwapChain,0x310d36a0,0xd2e7,0x4c0a,0xaa,0x04,0x6a,0x9d,0x23,0xb8,0x88,0x6a);
DEFINE_GUID(IID_IDXGIFactory,0x7b7166ec,0x21c7,0x44ae,0xb2,0x1a,0xc9,0xae,0x32,0x1a,0xe3,0x69);
DEFINE_GUID(IID_IDXGIDevice,0x54ec77fa,0x1377,0x44e6,0x8c,0x32,0x88,0xfd,0x5f,0x44,0xc8,0x4c);
DEFINE_GUID(IID_IDXGIFactory1,0x770aae78,0xf26f,0x4dba,0xa8,0x29,0x25,0x3c,0x83,0xd1,0xb3,0x87);
DEFINE_GUID(IID_IDXGIAdapter1,0x29038f61,0x3839,0x4626,0x91,0xfd,0x08,0x68,0x79,0x01,0x1a,0x05);
DEFINE_GUID(IID_IDXGIDevice1,0x77db970f,0x6276,0x48ba,0xba,0x28,0x07,0x01,0x43,0xb4,0x39,0x2c);


extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0014_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxgi_0000_0014_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dxgiformat.h ===
#ifndef __dxgiformat_h__
#define __dxgiformat_h__

#define DXGI_FORMAT_DEFINED 1

typedef enum DXGI_FORMAT
{
    DXGI_FORMAT_UNKNOWN	                    = 0,
    DXGI_FORMAT_R32G32B32A32_TYPELESS       = 1,
    DXGI_FORMAT_R32G32B32A32_FLOAT          = 2,
    DXGI_FORMAT_R32G32B32A32_UINT           = 3,
    DXGI_FORMAT_R32G32B32A32_SINT           = 4,
    DXGI_FORMAT_R32G32B32_TYPELESS          = 5,
    DXGI_FORMAT_R32G32B32_FLOAT             = 6,
    DXGI_FORMAT_R32G32B32_UINT              = 7,
    DXGI_FORMAT_R32G32B32_SINT              = 8,
    DXGI_FORMAT_R16G16B16A16_TYPELESS       = 9,
    DXGI_FORMAT_R16G16B16A16_FLOAT          = 10,
    DXGI_FORMAT_R16G16B16A16_UNORM          = 11,
    DXGI_FORMAT_R16G16B16A16_UINT           = 12,
    DXGI_FORMAT_R16G16B16A16_SNORM          = 13,
    DXGI_FORMAT_R16G16B16A16_SINT           = 14,
    DXGI_FORMAT_R32G32_TYPELESS             = 15,
    DXGI_FORMAT_R32G32_FLOAT                = 16,
    DXGI_FORMAT_R32G32_UINT                 = 17,
    DXGI_FORMAT_R32G32_SINT                 = 18,
    DXGI_FORMAT_R32G8X24_TYPELESS           = 19,
    DXGI_FORMAT_D32_FLOAT_S8X24_UINT        = 20,
    DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS    = 21,
    DXGI_FORMAT_X32_TYPELESS_G8X24_UINT     = 22,
    DXGI_FORMAT_R10G10B10A2_TYPELESS        = 23,
    DXGI_FORMAT_R10G10B10A2_UNORM           = 24,
    DXGI_FORMAT_R10G10B10A2_UINT            = 25,
    DXGI_FORMAT_R11G11B10_FLOAT             = 26,
    DXGI_FORMAT_R8G8B8A8_TYPELESS           = 27,
    DXGI_FORMAT_R8G8B8A8_UNORM              = 28,
    DXGI_FORMAT_R8G8B8A8_UNORM_SRGB         = 29,
    DXGI_FORMAT_R8G8B8A8_UINT               = 30,
    DXGI_FORMAT_R8G8B8A8_SNORM              = 31,
    DXGI_FORMAT_R8G8B8A8_SINT               = 32,
    DXGI_FORMAT_R16G16_TYPELESS             = 33,
    DXGI_FORMAT_R16G16_FLOAT                = 34,
    DXGI_FORMAT_R16G16_UNORM                = 35,
    DXGI_FORMAT_R16G16_UINT                 = 36,
    DXGI_FORMAT_R16G16_SNORM                = 37,
    DXGI_FORMAT_R16G16_SINT                 = 38,
    DXGI_FORMAT_R32_TYPELESS                = 39,
    DXGI_FORMAT_D32_FLOAT                   = 40,
    DXGI_FORMAT_R32_FLOAT                   = 41,
    DXGI_FORMAT_R32_UINT                    = 42,
    DXGI_FORMAT_R32_SINT                    = 43,
    DXGI_FORMAT_R24G8_TYPELESS              = 44,
    DXGI_FORMAT_D24_UNORM_S8_UINT           = 45,
    DXGI_FORMAT_R24_UNORM_X8_TYPELESS       = 46,
    DXGI_FORMAT_X24_TYPELESS_G8_UINT        = 47,
    DXGI_FORMAT_R8G8_TYPELESS               = 48,
    DXGI_FORMAT_R8G8_UNORM                  = 49,
    DXGI_FORMAT_R8G8_UINT                   = 50,
    DXGI_FORMAT_R8G8_SNORM                  = 51,
    DXGI_FORMAT_R8G8_SINT                   = 52,
    DXGI_FORMAT_R16_TYPELESS                = 53,
    DXGI_FORMAT_R16_FLOAT                   = 54,
    DXGI_FORMAT_D16_UNORM                   = 55,
    DXGI_FORMAT_R16_UNORM                   = 56,
    DXGI_FORMAT_R16_UINT                    = 57,
    DXGI_FORMAT_R16_SNORM                   = 58,
    DXGI_FORMAT_R16_SINT                    = 59,
    DXGI_FORMAT_R8_TYPELESS                 = 60,
    DXGI_FORMAT_R8_UNORM                    = 61,
    DXGI_FORMAT_R8_UINT                     = 62,
    DXGI_FORMAT_R8_SNORM                    = 63,
    DXGI_FORMAT_R8_SINT                     = 64,
    DXGI_FORMAT_A8_UNORM                    = 65,
    DXGI_FORMAT_R1_UNORM                    = 66,
    DXGI_FORMAT_R9G9B9E5_SHAREDEXP          = 67,
    DXGI_FORMAT_R8G8_B8G8_UNORM             = 68,
    DXGI_FORMAT_G8R8_G8B8_UNORM             = 69,
    DXGI_FORMAT_BC1_TYPELESS                = 70,
    DXGI_FORMAT_BC1_UNORM                   = 71,
    DXGI_FORMAT_BC1_UNORM_SRGB              = 72,
    DXGI_FORMAT_BC2_TYPELESS                = 73,
    DXGI_FORMAT_BC2_UNORM                   = 74,
    DXGI_FORMAT_BC2_UNORM_SRGB              = 75,
    DXGI_FORMAT_BC3_TYPELESS                = 76,
    DXGI_FORMAT_BC3_UNORM                   = 77,
    DXGI_FORMAT_BC3_UNORM_SRGB              = 78,
    DXGI_FORMAT_BC4_TYPELESS                = 79,
    DXGI_FORMAT_BC4_UNORM                   = 80,
    DXGI_FORMAT_BC4_SNORM                   = 81,
    DXGI_FORMAT_BC5_TYPELESS                = 82,
    DXGI_FORMAT_BC5_UNORM                   = 83,
    DXGI_FORMAT_BC5_SNORM                   = 84,
    DXGI_FORMAT_B5G6R5_UNORM                = 85,
    DXGI_FORMAT_B5G5R5A1_UNORM              = 86,
    DXGI_FORMAT_B8G8R8A8_UNORM              = 87,
    DXGI_FORMAT_B8G8R8X8_UNORM              = 88,
    DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM  = 89,
    DXGI_FORMAT_B8G8R8A8_TYPELESS           = 90,
    DXGI_FORMAT_B8G8R8A8_UNORM_SRGB         = 91,
    DXGI_FORMAT_B8G8R8X8_TYPELESS           = 92,
    DXGI_FORMAT_B8G8R8X8_UNORM_SRGB         = 93,
    DXGI_FORMAT_BC6H_TYPELESS               = 94,
    DXGI_FORMAT_BC6H_UF16                   = 95,
    DXGI_FORMAT_BC6H_SF16                   = 96,
    DXGI_FORMAT_BC7_TYPELESS                = 97,
    DXGI_FORMAT_BC7_UNORM                   = 98,
    DXGI_FORMAT_BC7_UNORM_SRGB              = 99,
    DXGI_FORMAT_FORCE_UINT                  = 0xffffffff
} DXGI_FORMAT;

#endif // __dxgiformat_h__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dxva2api.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for dxva2api.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dxva2api_h__
#define __dxva2api_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDirect3DDeviceManager9_FWD_DEFINED__
#define __IDirect3DDeviceManager9_FWD_DEFINED__
typedef interface IDirect3DDeviceManager9 IDirect3DDeviceManager9;
#endif 	/* __IDirect3DDeviceManager9_FWD_DEFINED__ */


#ifndef __IDirectXVideoAccelerationService_FWD_DEFINED__
#define __IDirectXVideoAccelerationService_FWD_DEFINED__
typedef interface IDirectXVideoAccelerationService IDirectXVideoAccelerationService;
#endif 	/* __IDirectXVideoAccelerationService_FWD_DEFINED__ */


#ifndef __IDirectXVideoDecoderService_FWD_DEFINED__
#define __IDirectXVideoDecoderService_FWD_DEFINED__
typedef interface IDirectXVideoDecoderService IDirectXVideoDecoderService;
#endif 	/* __IDirectXVideoDecoderService_FWD_DEFINED__ */


#ifndef __IDirectXVideoProcessorService_FWD_DEFINED__
#define __IDirectXVideoProcessorService_FWD_DEFINED__
typedef interface IDirectXVideoProcessorService IDirectXVideoProcessorService;
#endif 	/* __IDirectXVideoProcessorService_FWD_DEFINED__ */


#ifndef __IDirectXVideoDecoder_FWD_DEFINED__
#define __IDirectXVideoDecoder_FWD_DEFINED__
typedef interface IDirectXVideoDecoder IDirectXVideoDecoder;
#endif 	/* __IDirectXVideoDecoder_FWD_DEFINED__ */


#ifndef __IDirectXVideoProcessor_FWD_DEFINED__
#define __IDirectXVideoProcessor_FWD_DEFINED__
typedef interface IDirectXVideoProcessor IDirectXVideoProcessor;
#endif 	/* __IDirectXVideoProcessor_FWD_DEFINED__ */


#ifndef __IDirectXVideoMemoryConfiguration_FWD_DEFINED__
#define __IDirectXVideoMemoryConfiguration_FWD_DEFINED__
typedef interface IDirectXVideoMemoryConfiguration IDirectXVideoMemoryConfiguration;
#endif 	/* __IDirectXVideoMemoryConfiguration_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_dxva2api_0000_0000 */
/* [local] */ 

//
//   The following declarations within the 'if 0' block are dummy typedefs used to make
//   the evr.idl file build. The actual definitions are contained in d3d9.h
//
#if 0
typedef DWORD IDirect3DDevice9;

typedef DWORD IDirect3DSurface9;

typedef DWORD D3DFORMAT;

typedef DWORD D3DPOOL;

#endif
#ifndef DXVA2_API_DEFINED
#define DXVA2_API_DEFINED
DEFINE_GUID(DXVA2_ModeMPEG2_MoComp, 0xe6a9f44b, 0x61b0, 0x4563,0x9e,0xa4,0x63,0xd2,0xa3,0xc6,0xfe,0x66);
DEFINE_GUID(DXVA2_ModeMPEG2_IDCT,   0xbf22ad00, 0x03ea, 0x4690,0x80,0x77,0x47,0x33,0x46,0x20,0x9b,0x7e);
DEFINE_GUID(DXVA2_ModeMPEG2_VLD,    0xee27417f, 0x5e28, 0x4e65,0xbe,0xea,0x1d,0x26,0xb5,0x08,0xad,0xc9);
DEFINE_GUID(DXVA2_ModeH264_A,  0x1b81be64, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_ModeH264_B,  0x1b81be65, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_ModeH264_C,  0x1b81be66, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_ModeH264_D,  0x1b81be67, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_ModeH264_E,  0x1b81be68, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_ModeH264_F,  0x1b81be69, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_ModeWMV8_A,  0x1b81be80, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_ModeWMV8_B,  0x1b81be81, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_ModeWMV9_A,  0x1b81be90, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_ModeWMV9_B,  0x1b81be91, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_ModeWMV9_C,  0x1b81be94, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_ModeVC1_A,   0x1b81beA0, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_ModeVC1_B,   0x1b81beA1, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_ModeVC1_C,   0x1b81beA2, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_ModeVC1_D,   0x1b81beA3, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_NoEncrypt,   0x1b81beD0, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA2_VideoProcProgressiveDevice, 0x5a54a0c9,0xc7ec,0x4bd9,0x8e,0xde,0xf3,0xc7,0x5d,0xc4,0x39,0x3b);
DEFINE_GUID(DXVA2_VideoProcBobDevice,         0x335aa36e,0x7884,0x43a4,0x9c,0x91,0x7f,0x87,0xfa,0xf3,0xe3,0x7e);
DEFINE_GUID(DXVA2_VideoProcSoftwareDevice,    0x4553d47f,0xee7e,0x4e3f,0x94,0x75,0xdb,0xf1,0x37,0x6c,0x48,0x10);
#define DXVA2_ModeMPEG2_MOCOMP      DXVA2_ModeMPEG2_MoComp
#define DXVA2_ModeWMV8_PostProc     DXVA2_ModeWMV8_A
#define DXVA2_ModeWMV8_MoComp       DXVA2_ModeWMV8_B
#define DXVA2_ModeWMV9_PostProc     DXVA2_ModeWMV9_A
#define DXVA2_ModeWMV9_MoComp       DXVA2_ModeWMV9_B
#define DXVA2_ModeWMV9_IDCT         DXVA2_ModeWMV9_C
#define DXVA2_ModeVC1_PostProc      DXVA2_ModeVC1_A
#define DXVA2_ModeVC1_MoComp        DXVA2_ModeVC1_B
#define DXVA2_ModeVC1_IDCT          DXVA2_ModeVC1_C
#define DXVA2_ModeVC1_VLD           DXVA2_ModeVC1_D
#define DXVA2_ModeH264_MoComp_NoFGT DXVA2_ModeH264_A
#define DXVA2_ModeH264_MoComp_FGT   DXVA2_ModeH264_B
#define DXVA2_ModeH264_IDCT_NoFGT   DXVA2_ModeH264_C
#define DXVA2_ModeH264_IDCT_FGT     DXVA2_ModeH264_D
#define DXVA2_ModeH264_VLD_NoFGT    DXVA2_ModeH264_E
#define DXVA2_ModeH264_VLD_FGT      DXVA2_ModeH264_F
#define DXVA2_E_NOT_INITIALIZED     ((HRESULT)0x80041000L)
#define DXVA2_E_NEW_VIDEO_DEVICE    ((HRESULT)0x80041001L)
#define DXVA2_E_VIDEO_DEVICE_LOCKED ((HRESULT)0x80041002L)
#define DXVA2_E_NOT_AVAILABLE       ((HRESULT)0x80041003L)
#if defined(_WIN32) && !defined(_NO_COM)
DEFINE_GUID(IID_IDirect3DDeviceManager9,          0xa0cade0f,0x06d5,0x4cf4,0xa1,0xc7,0xf3,0xcd,0xd7,0x25,0xaa,0x75);
DEFINE_GUID(IID_IDirectXVideoAccelerationService, 0xfc51a550,0xd5e7,0x11d9,0xaf,0x55,0x00,0x05,0x4e,0x43,0xff,0x02);
DEFINE_GUID(IID_IDirectXVideoDecoderService,      0xfc51a551,0xd5e7,0x11d9,0xaf,0x55,0x00,0x05,0x4e,0x43,0xff,0x02);
DEFINE_GUID(IID_IDirectXVideoProcessorService,    0xfc51a552,0xd5e7,0x11d9,0xaf,0x55,0x00,0x05,0x4e,0x43,0xff,0x02);
DEFINE_GUID(IID_IDirectXVideoDecoder,             0xf2b0810a,0xfd00,0x43c9,0x91,0x8c,0xdf,0x94,0xe2,0xd8,0xef,0x7d);
DEFINE_GUID(IID_IDirectXVideoProcessor,           0x8c3a39f0,0x916e,0x4690,0x80,0x4f,0x4c,0x80,0x01,0x35,0x5d,0x25);
DEFINE_GUID(IID_IDirectXVideoMemoryConfiguration, 0xb7f916dd,0xdb3b,0x49c1,0x84,0xd7,0xe4,0x5e,0xf9,0x9e,0xc7,0x26);
#endif
#ifndef MAX_DEINTERLACE_SURFACES
#define MAX_DEINTERLACE_SURFACES 32
#endif
#ifndef MAX_SUBSTREAMS
#define MAX_SUBSTREAMS 15
#endif
typedef struct _DXVA2_ExtendedFormat
    {
    union 
        {
        struct 
            {
            UINT SampleFormat	: 8;
            UINT VideoChromaSubsampling	: 4;
            UINT NominalRange	: 3;
            UINT VideoTransferMatrix	: 3;
            UINT VideoLighting	: 4;
            UINT VideoPrimaries	: 5;
            UINT VideoTransferFunction	: 5;
            } 	;
        UINT value;
        } 	;
    } 	DXVA2_ExtendedFormat;

typedef 
enum _DXVA2_SampleFormat
    {	DXVA2_SampleFormatMask	= 0xff,
	DXVA2_SampleUnknown	= 0,
	DXVA2_SampleProgressiveFrame	= 2,
	DXVA2_SampleFieldInterleavedEvenFirst	= 3,
	DXVA2_SampleFieldInterleavedOddFirst	= 4,
	DXVA2_SampleFieldSingleEven	= 5,
	DXVA2_SampleFieldSingleOdd	= 6,
	DXVA2_SampleSubStream	= 7
    } 	DXVA2_SampleFormat;

typedef 
enum _DXVA2_VideoChromaSubSampling
    {	DXVA2_VideoChromaSubsamplingMask	= 0xf,
	DXVA2_VideoChromaSubsampling_Unknown	= 0,
	DXVA2_VideoChromaSubsampling_ProgressiveChroma	= 0x8,
	DXVA2_VideoChromaSubsampling_Horizontally_Cosited	= 0x4,
	DXVA2_VideoChromaSubsampling_Vertically_Cosited	= 0x2,
	DXVA2_VideoChromaSubsampling_Vertically_AlignedChromaPlanes	= 0x1,
	DXVA2_VideoChromaSubsampling_MPEG2	= ( DXVA2_VideoChromaSubsampling_Horizontally_Cosited | DXVA2_VideoChromaSubsampling_Vertically_AlignedChromaPlanes ) ,
	DXVA2_VideoChromaSubsampling_MPEG1	= DXVA2_VideoChromaSubsampling_Vertically_AlignedChromaPlanes,
	DXVA2_VideoChromaSubsampling_DV_PAL	= ( DXVA2_VideoChromaSubsampling_Horizontally_Cosited | DXVA2_VideoChromaSubsampling_Vertically_Cosited ) ,
	DXVA2_VideoChromaSubsampling_Cosited	= ( ( DXVA2_VideoChromaSubsampling_Horizontally_Cosited | DXVA2_VideoChromaSubsampling_Vertically_Cosited )  | DXVA2_VideoChromaSubsampling_Vertically_AlignedChromaPlanes ) 
    } 	DXVA2_VideoChromaSubSampling;

typedef 
enum _DXVA2_NominalRange
    {	DXVA2_NominalRangeMask	= 0x7,
	DXVA2_NominalRange_Unknown	= 0,
	DXVA2_NominalRange_Normal	= 1,
	DXVA2_NominalRange_Wide	= 2,
	DXVA2_NominalRange_0_255	= 1,
	DXVA2_NominalRange_16_235	= 2,
	DXVA2_NominalRange_48_208	= 3
    } 	DXVA2_NominalRange;

typedef 
enum _DXVA2_VideoTransferMatrix
    {	DXVA2_VideoTransferMatrixMask	= 0x7,
	DXVA2_VideoTransferMatrix_Unknown	= 0,
	DXVA2_VideoTransferMatrix_BT709	= 1,
	DXVA2_VideoTransferMatrix_BT601	= 2,
	DXVA2_VideoTransferMatrix_SMPTE240M	= 3
    } 	DXVA2_VideoTransferMatrix;

typedef 
enum _DXVA2_VideoLighting
    {	DXVA2_VideoLightingMask	= 0xf,
	DXVA2_VideoLighting_Unknown	= 0,
	DXVA2_VideoLighting_bright	= 1,
	DXVA2_VideoLighting_office	= 2,
	DXVA2_VideoLighting_dim	= 3,
	DXVA2_VideoLighting_dark	= 4
    } 	DXVA2_VideoLighting;

typedef 
enum _DXVA2_VideoPrimaries
    {	DXVA2_VideoPrimariesMask	= 0x1f,
	DXVA2_VideoPrimaries_Unknown	= 0,
	DXVA2_VideoPrimaries_reserved	= 1,
	DXVA2_VideoPrimaries_BT709	= 2,
	DXVA2_VideoPrimaries_BT470_2_SysM	= 3,
	DXVA2_VideoPrimaries_BT470_2_SysBG	= 4,
	DXVA2_VideoPrimaries_SMPTE170M	= 5,
	DXVA2_VideoPrimaries_SMPTE240M	= 6,
	DXVA2_VideoPrimaries_EBU3213	= 7,
	DXVA2_VideoPrimaries_SMPTE_C	= 8
    } 	DXVA2_VideoPrimaries;

typedef 
enum _DXVA2_VideoTransferFunction
    {	DXVA2_VideoTransFuncMask	= 0x1f,
	DXVA2_VideoTransFunc_Unknown	= 0,
	DXVA2_VideoTransFunc_10	= 1,
	DXVA2_VideoTransFunc_18	= 2,
	DXVA2_VideoTransFunc_20	= 3,
	DXVA2_VideoTransFunc_22	= 4,
	DXVA2_VideoTransFunc_709	= 5,
	DXVA2_VideoTransFunc_240M	= 6,
	DXVA2_VideoTransFunc_sRGB	= 7,
	DXVA2_VideoTransFunc_28	= 8
    } 	DXVA2_VideoTransferFunction;

//
// Deprecated labels - please use the ones in the DXVA2_VideoTransferFunction enum.
//
#define DXVA2_VideoTransFunc_22_709         DXVA2_VideoTransFunc_709     
#define DXVA2_VideoTransFunc_22_240M        DXVA2_VideoTransFunc_240M    
#define DXVA2_VideoTransFunc_22_8bit_sRGB   DXVA2_VideoTransFunc_sRGB    
typedef struct _DXVA2_Frequency
    {
    UINT Numerator;
    UINT Denominator;
    } 	DXVA2_Frequency;

typedef struct _DXVA2_VideoDesc
    {
    UINT SampleWidth;
    UINT SampleHeight;
    DXVA2_ExtendedFormat SampleFormat;
    D3DFORMAT Format;
    DXVA2_Frequency InputSampleFreq;
    DXVA2_Frequency OutputFrameFreq;
    UINT UABProtectionLevel;
    UINT Reserved;
    } 	DXVA2_VideoDesc;


enum __MIDL___MIDL_itf_dxva2api_0000_0000_0003
    {	DXVA2_DeinterlaceTech_Unknown	= 0,
	DXVA2_DeinterlaceTech_BOBLineReplicate	= 0x1,
	DXVA2_DeinterlaceTech_BOBVerticalStretch	= 0x2,
	DXVA2_DeinterlaceTech_BOBVerticalStretch4Tap	= 0x4,
	DXVA2_DeinterlaceTech_MedianFiltering	= 0x8,
	DXVA2_DeinterlaceTech_EdgeFiltering	= 0x10,
	DXVA2_DeinterlaceTech_FieldAdaptive	= 0x20,
	DXVA2_DeinterlaceTech_PixelAdaptive	= 0x40,
	DXVA2_DeinterlaceTech_MotionVectorSteered	= 0x80,
	DXVA2_DeinterlaceTech_InverseTelecine	= 0x100,
	DXVA2_DeinterlaceTech_Mask	= 0x1ff
    } ;

enum __MIDL___MIDL_itf_dxva2api_0000_0000_0004
    {	DXVA2_NoiseFilterLumaLevel	= 1,
	DXVA2_NoiseFilterLumaThreshold	= 2,
	DXVA2_NoiseFilterLumaRadius	= 3,
	DXVA2_NoiseFilterChromaLevel	= 4,
	DXVA2_NoiseFilterChromaThreshold	= 5,
	DXVA2_NoiseFilterChromaRadius	= 6,
	DXVA2_DetailFilterLumaLevel	= 7,
	DXVA2_DetailFilterLumaThreshold	= 8,
	DXVA2_DetailFilterLumaRadius	= 9,
	DXVA2_DetailFilterChromaLevel	= 10,
	DXVA2_DetailFilterChromaThreshold	= 11,
	DXVA2_DetailFilterChromaRadius	= 12
    } ;

enum __MIDL___MIDL_itf_dxva2api_0000_0000_0005
    {	DXVA2_NoiseFilterTech_Unsupported	= 0,
	DXVA2_NoiseFilterTech_Unknown	= 0x1,
	DXVA2_NoiseFilterTech_Median	= 0x2,
	DXVA2_NoiseFilterTech_Temporal	= 0x4,
	DXVA2_NoiseFilterTech_BlockNoise	= 0x8,
	DXVA2_NoiseFilterTech_MosquitoNoise	= 0x10,
	DXVA2_NoiseFilterTech_Mask	= 0x1f
    } ;

enum __MIDL___MIDL_itf_dxva2api_0000_0000_0006
    {	DXVA2_DetailFilterTech_Unsupported	= 0,
	DXVA2_DetailFilterTech_Unknown	= 0x1,
	DXVA2_DetailFilterTech_Edge	= 0x2,
	DXVA2_DetailFilterTech_Sharpening	= 0x4,
	DXVA2_DetailFilterTech_Mask	= 0x7
    } ;

enum __MIDL___MIDL_itf_dxva2api_0000_0000_0007
    {	DXVA2_ProcAmp_None	= 0,
	DXVA2_ProcAmp_Brightness	= 0x1,
	DXVA2_ProcAmp_Contrast	= 0x2,
	DXVA2_ProcAmp_Hue	= 0x4,
	DXVA2_ProcAmp_Saturation	= 0x8,
	DXVA2_ProcAmp_Mask	= 0xf
    } ;

enum __MIDL___MIDL_itf_dxva2api_0000_0000_0008
    {	DXVA2_VideoProcess_None	= 0,
	DXVA2_VideoProcess_YUV2RGB	= 0x1,
	DXVA2_VideoProcess_StretchX	= 0x2,
	DXVA2_VideoProcess_StretchY	= 0x4,
	DXVA2_VideoProcess_AlphaBlend	= 0x8,
	DXVA2_VideoProcess_SubRects	= 0x10,
	DXVA2_VideoProcess_SubStreams	= 0x20,
	DXVA2_VideoProcess_SubStreamsExtended	= 0x40,
	DXVA2_VideoProcess_YUV2RGBExtended	= 0x80,
	DXVA2_VideoProcess_AlphaBlendExtended	= 0x100,
	DXVA2_VideoProcess_Constriction	= 0x200,
	DXVA2_VideoProcess_NoiseFilter	= 0x400,
	DXVA2_VideoProcess_DetailFilter	= 0x800,
	DXVA2_VideoProcess_PlanarAlpha	= 0x1000,
	DXVA2_VideoProcess_LinearScaling	= 0x2000,
	DXVA2_VideoProcess_GammaCompensated	= 0x4000,
	DXVA2_VideoProcess_MaintainsOriginalFieldData	= 0x8000,
	DXVA2_VideoProcess_Mask	= 0xffff
    } ;

enum __MIDL___MIDL_itf_dxva2api_0000_0000_0009
    {	DXVA2_VPDev_HardwareDevice	= 0x1,
	DXVA2_VPDev_EmulatedDXVA1	= 0x2,
	DXVA2_VPDev_SoftwareDevice	= 0x4,
	DXVA2_VPDev_Mask	= 0x7
    } ;

enum __MIDL___MIDL_itf_dxva2api_0000_0000_0010
    {	DXVA2_SampleData_RFF	= 0x1,
	DXVA2_SampleData_TFF	= 0x2,
	DXVA2_SampleData_RFF_TFF_Present	= 0x4,
	DXVA2_SampleData_Mask	= 0xffff
    } ;

enum __MIDL___MIDL_itf_dxva2api_0000_0000_0011
    {	DXVA2_DestData_RFF	= 0x1,
	DXVA2_DestData_TFF	= 0x2,
	DXVA2_DestData_RFF_TFF_Present	= 0x4,
	DXVA2_DestData_Mask	= 0xffff
    } ;
typedef struct _DXVA2_VideoProcessorCaps
    {
    UINT DeviceCaps;
    D3DPOOL InputPool;
    UINT NumForwardRefSamples;
    UINT NumBackwardRefSamples;
    UINT Reserved;
    UINT DeinterlaceTechnology;
    UINT ProcAmpControlCaps;
    UINT VideoProcessorOperations;
    UINT NoiseFilterTechnology;
    UINT DetailFilterTechnology;
    } 	DXVA2_VideoProcessorCaps;

#ifdef __midl
typedef LONG DXVA2_Fixed32;

#else
typedef struct _DXVA2_Fixed32
{
    union {
        struct {
            USHORT  Fraction;
            SHORT   Value;
        };
        LONG ll;
    };
} DXVA2_Fixed32;
#endif
typedef struct _DXVA2_AYUVSample8
    {
    UCHAR Cr;
    UCHAR Cb;
    UCHAR Y;
    UCHAR Alpha;
    } 	DXVA2_AYUVSample8;

typedef struct _DXVA2_AYUVSample16
    {
    USHORT Cr;
    USHORT Cb;
    USHORT Y;
    USHORT Alpha;
    } 	DXVA2_AYUVSample16;

typedef LONGLONG REFERENCE_TIME;

#if defined(_D3D9_H_) || defined(_d3d9P_H_)
typedef struct _DXVA2_VideoSample
    {
    REFERENCE_TIME Start;
    REFERENCE_TIME End;
    DXVA2_ExtendedFormat SampleFormat;
    IDirect3DSurface9 *SrcSurface;
    RECT SrcRect;
    RECT DstRect;
    DXVA2_AYUVSample8 Pal[ 16 ];
    DXVA2_Fixed32 PlanarAlpha;
    DWORD SampleData;
    } 	DXVA2_VideoSample;

#endif  // _D3D9_H_
typedef struct _DXVA2_ValueRange
    {
    DXVA2_Fixed32 MinValue;
    DXVA2_Fixed32 MaxValue;
    DXVA2_Fixed32 DefaultValue;
    DXVA2_Fixed32 StepSize;
    } 	DXVA2_ValueRange;

typedef struct _DXVA2_ProcAmpValues
    {
    DXVA2_Fixed32 Brightness;
    DXVA2_Fixed32 Contrast;
    DXVA2_Fixed32 Hue;
    DXVA2_Fixed32 Saturation;
    } 	DXVA2_ProcAmpValues;

typedef struct _DXVA2_FilterValues
    {
    DXVA2_Fixed32 Level;
    DXVA2_Fixed32 Threshold;
    DXVA2_Fixed32 Radius;
    } 	DXVA2_FilterValues;

typedef struct _DXVA2_VideoProcessBltParams
    {
    REFERENCE_TIME TargetFrame;
    RECT TargetRect;
    SIZE ConstrictionSize;
    UINT StreamingFlags;
    DXVA2_AYUVSample16 BackgroundColor;
    DXVA2_ExtendedFormat DestFormat;
    DXVA2_ProcAmpValues ProcAmpValues;
    DXVA2_Fixed32 Alpha;
    DXVA2_FilterValues NoiseFilterLuma;
    DXVA2_FilterValues NoiseFilterChroma;
    DXVA2_FilterValues DetailFilterLuma;
    DXVA2_FilterValues DetailFilterChroma;
    DWORD DestData;
    } 	DXVA2_VideoProcessBltParams;


enum __MIDL___MIDL_itf_dxva2api_0000_0000_0012
    {	DXVA2_PictureParametersBufferType	= 0,
	DXVA2_MacroBlockControlBufferType	= 1,
	DXVA2_ResidualDifferenceBufferType	= 2,
	DXVA2_DeblockingControlBufferType	= 3,
	DXVA2_InverseQuantizationMatrixBufferType	= 4,
	DXVA2_SliceControlBufferType	= 5,
	DXVA2_BitStreamDateBufferType	= 6,
	DXVA2_MotionVectorBuffer	= 7,
	DXVA2_FilmGrainBuffer	= 8
    } ;

enum __MIDL___MIDL_itf_dxva2api_0000_0000_0013
    {	DXVA2_VideoDecoderRenderTarget	= 0,
	DXVA2_VideoProcessorRenderTarget	= 1,
	DXVA2_VideoSoftwareRenderTarget	= 2
    } ;
typedef struct _DXVA2_ConfigPictureDecode
    {
    GUID guidConfigBitstreamEncryption;
    GUID guidConfigMBcontrolEncryption;
    GUID guidConfigResidDiffEncryption;
    UINT ConfigBitstreamRaw;
    UINT ConfigMBcontrolRasterOrder;
    UINT ConfigResidDiffHost;
    UINT ConfigSpatialResid8;
    UINT ConfigResid8Subtraction;
    UINT ConfigSpatialHost8or9Clipping;
    UINT ConfigSpatialResidInterleaved;
    UINT ConfigIntraResidUnsigned;
    UINT ConfigResidDiffAccelerator;
    UINT ConfigHostInverseScan;
    UINT ConfigSpecificIDCT;
    UINT Config4GroupedCoefs;
    USHORT ConfigMinRenderTargetBuffCount;
    USHORT ConfigDecoderSpecific;
    } 	DXVA2_ConfigPictureDecode;

typedef struct _DXVA2_DecodeBufferDesc
    {
    DWORD CompressedBufferType;
    UINT BufferIndex;
    UINT DataOffset;
    UINT DataSize;
    UINT FirstMBaddress;
    UINT NumMBsInBuffer;
    UINT Width;
    UINT Height;
    UINT Stride;
    UINT ReservedBits;
    PVOID pvPVPState;
    } 	DXVA2_DecodeBufferDesc;

// The value in pvPVPState depends on the type of crypo used.  For 
// D3DCRYPTOTYPE_AES128_CTR, pvPState points to the following structure:
 
typedef struct _DXVA2_AES_CTR_IV
    {
    UINT64 IV;
    UINT64 Count;
    } 	DXVA2_AES_CTR_IV;

typedef struct _DXVA2_DecodeExtensionData
    {
    UINT Function;
    PVOID pPrivateInputData;
    UINT PrivateInputDataSize;
    PVOID pPrivateOutputData;
    UINT PrivateOutputDataSize;
    } 	DXVA2_DecodeExtensionData;

// DXVA2_DECODE_GET_DRIVER_HANDLE is an extension function that allows the 
// driver to return a handle for the DXVA2 decode device that can be used to
// associate it with a IDirect3DCryptoSession9 interface.  When this function
// is used:
//     pPrivateInputData = NULL
//     pPrivateInputDataSize = 0
//     pPrivateOutputData = HANDLE*
//     pPrivateOutputDataSize = sizeof(HANDLE)
#define DXVA2_DECODE_GET_DRIVER_HANDLE               0x725
 
// DXVA2_DECODE_SPECIFY_ENCRYPTED_BLOCKS is an extension function that that allows 
// the decoder to specify which portions of the compressed buffers are encrypted. 
// If this fucntion is not used to specify this information, it is assumed that 
// the entire buffer is encrypted. 
//     pPrivateInputData = D3DENCRYPTED_BLOCK_INFO*; 
//     PrivateInputDataSize = sizeof(D3DENCRYPTED_BLOCK_INFO); 
//     pPrivateOutputData = NULL; 
//     PrivateOutputDataSize = 0; 
#define DXVA2_DECODE_SPECIFY_ENCRYPTED_BLOCKS	0x724 
 
typedef struct _DXVA2_DecodeExecuteParams
    {
    UINT NumCompBuffers;
    DXVA2_DecodeBufferDesc *pCompressedBuffers;
    DXVA2_DecodeExtensionData *pExtensionData;
    } 	DXVA2_DecodeExecuteParams;

#if defined(_D3D9_H_) || defined(_d3d9P_H_)








extern RPC_IF_HANDLE __MIDL_itf_dxva2api_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxva2api_0000_0000_v0_0_s_ifspec;

#ifndef __IDirect3DDeviceManager9_INTERFACE_DEFINED__
#define __IDirect3DDeviceManager9_INTERFACE_DEFINED__

/* interface IDirect3DDeviceManager9 */
/* [local][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDirect3DDeviceManager9;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a0cade0f-06d5-4cf4-a1c7-f3cdd725aa75")
    IDirect3DDeviceManager9 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ResetDevice( 
            /* [annotation][in] */ 
            __in  IDirect3DDevice9 *pDevice,
            /* [annotation][in] */ 
            __in  UINT resetToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenDeviceHandle( 
            /* [annotation][out] */ 
            __out  HANDLE *phDevice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseDeviceHandle( 
            /* [annotation][in] */ 
            __in  HANDLE hDevice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TestDevice( 
            /* [annotation][in] */ 
            __in  HANDLE hDevice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockDevice( 
            /* [annotation][in] */ 
            __in  HANDLE hDevice,
            /* [annotation][out] */ 
            __deref_out  IDirect3DDevice9 **ppDevice,
            /* [annotation][in] */ 
            __in  BOOL fBlock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockDevice( 
            /* [annotation][in] */ 
            __in  HANDLE hDevice,
            /* [annotation][in] */ 
            __in  BOOL fSaveState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoService( 
            /* [annotation][in] */ 
            __in  HANDLE hDevice,
            /* [annotation][in] */ 
            __in  REFIID riid,
            /* [annotation][out] */ 
            __deref_out  void **ppService) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirect3DDeviceManager9Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirect3DDeviceManager9 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirect3DDeviceManager9 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirect3DDeviceManager9 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResetDevice )( 
            IDirect3DDeviceManager9 * This,
            /* [annotation][in] */ 
            __in  IDirect3DDevice9 *pDevice,
            /* [annotation][in] */ 
            __in  UINT resetToken);
        
        HRESULT ( STDMETHODCALLTYPE *OpenDeviceHandle )( 
            IDirect3DDeviceManager9 * This,
            /* [annotation][out] */ 
            __out  HANDLE *phDevice);
        
        HRESULT ( STDMETHODCALLTYPE *CloseDeviceHandle )( 
            IDirect3DDeviceManager9 * This,
            /* [annotation][in] */ 
            __in  HANDLE hDevice);
        
        HRESULT ( STDMETHODCALLTYPE *TestDevice )( 
            IDirect3DDeviceManager9 * This,
            /* [annotation][in] */ 
            __in  HANDLE hDevice);
        
        HRESULT ( STDMETHODCALLTYPE *LockDevice )( 
            IDirect3DDeviceManager9 * This,
            /* [annotation][in] */ 
            __in  HANDLE hDevice,
            /* [annotation][out] */ 
            __deref_out  IDirect3DDevice9 **ppDevice,
            /* [annotation][in] */ 
            __in  BOOL fBlock);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockDevice )( 
            IDirect3DDeviceManager9 * This,
            /* [annotation][in] */ 
            __in  HANDLE hDevice,
            /* [annotation][in] */ 
            __in  BOOL fSaveState);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoService )( 
            IDirect3DDeviceManager9 * This,
            /* [annotation][in] */ 
            __in  HANDLE hDevice,
            /* [annotation][in] */ 
            __in  REFIID riid,
            /* [annotation][out] */ 
            __deref_out  void **ppService);
        
        END_INTERFACE
    } IDirect3DDeviceManager9Vtbl;

    interface IDirect3DDeviceManager9
    {
        CONST_VTBL struct IDirect3DDeviceManager9Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirect3DDeviceManager9_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDirect3DDeviceManager9_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDirect3DDeviceManager9_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDirect3DDeviceManager9_ResetDevice(This,pDevice,resetToken)	\
    ( (This)->lpVtbl -> ResetDevice(This,pDevice,resetToken) ) 

#define IDirect3DDeviceManager9_OpenDeviceHandle(This,phDevice)	\
    ( (This)->lpVtbl -> OpenDeviceHandle(This,phDevice) ) 

#define IDirect3DDeviceManager9_CloseDeviceHandle(This,hDevice)	\
    ( (This)->lpVtbl -> CloseDeviceHandle(This,hDevice) ) 

#define IDirect3DDeviceManager9_TestDevice(This,hDevice)	\
    ( (This)->lpVtbl -> TestDevice(This,hDevice) ) 

#define IDirect3DDeviceManager9_LockDevice(This,hDevice,ppDevice,fBlock)	\
    ( (This)->lpVtbl -> LockDevice(This,hDevice,ppDevice,fBlock) ) 

#define IDirect3DDeviceManager9_UnlockDevice(This,hDevice,fSaveState)	\
    ( (This)->lpVtbl -> UnlockDevice(This,hDevice,fSaveState) ) 

#define IDirect3DDeviceManager9_GetVideoService(This,hDevice,riid,ppService)	\
    ( (This)->lpVtbl -> GetVideoService(This,hDevice,riid,ppService) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDirect3DDeviceManager9_INTERFACE_DEFINED__ */


#ifndef __IDirectXVideoAccelerationService_INTERFACE_DEFINED__
#define __IDirectXVideoAccelerationService_INTERFACE_DEFINED__

/* interface IDirectXVideoAccelerationService */
/* [local][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDirectXVideoAccelerationService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fc51a550-d5e7-11d9-af55-00054e43ff02")
    IDirectXVideoAccelerationService : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateSurface( 
            /* [annotation][in] */ 
            __in  UINT Width,
            /* [annotation][in] */ 
            __in  UINT Height,
            /* [annotation][in] */ 
            __in  UINT BackBuffers,
            /* [annotation][in] */ 
            __in  D3DFORMAT Format,
            /* [annotation][in] */ 
            __in  D3DPOOL Pool,
            /* [annotation][in] */ 
            __in  DWORD Usage,
            /* [annotation][in] */ 
            __in  DWORD DxvaType,
            /* [annotation][size_is][out] */ 
            __out_ecount(BackBuffers+1)  IDirect3DSurface9 **ppSurface,
            /* [annotation][out][in] */ 
            __inout_opt  HANDLE *pSharedHandle) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirectXVideoAccelerationServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirectXVideoAccelerationService * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirectXVideoAccelerationService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirectXVideoAccelerationService * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSurface )( 
            IDirectXVideoAccelerationService * This,
            /* [annotation][in] */ 
            __in  UINT Width,
            /* [annotation][in] */ 
            __in  UINT Height,
            /* [annotation][in] */ 
            __in  UINT BackBuffers,
            /* [annotation][in] */ 
            __in  D3DFORMAT Format,
            /* [annotation][in] */ 
            __in  D3DPOOL Pool,
            /* [annotation][in] */ 
            __in  DWORD Usage,
            /* [annotation][in] */ 
            __in  DWORD DxvaType,
            /* [annotation][size_is][out] */ 
            __out_ecount(BackBuffers+1)  IDirect3DSurface9 **ppSurface,
            /* [annotation][out][in] */ 
            __inout_opt  HANDLE *pSharedHandle);
        
        END_INTERFACE
    } IDirectXVideoAccelerationServiceVtbl;

    interface IDirectXVideoAccelerationService
    {
        CONST_VTBL struct IDirectXVideoAccelerationServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirectXVideoAccelerationService_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDirectXVideoAccelerationService_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDirectXVideoAccelerationService_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDirectXVideoAccelerationService_CreateSurface(This,Width,Height,BackBuffers,Format,Pool,Usage,DxvaType,ppSurface,pSharedHandle)	\
    ( (This)->lpVtbl -> CreateSurface(This,Width,Height,BackBuffers,Format,Pool,Usage,DxvaType,ppSurface,pSharedHandle) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDirectXVideoAccelerationService_INTERFACE_DEFINED__ */


#ifndef __IDirectXVideoDecoderService_INTERFACE_DEFINED__
#define __IDirectXVideoDecoderService_INTERFACE_DEFINED__

/* interface IDirectXVideoDecoderService */
/* [local][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDirectXVideoDecoderService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fc51a551-d5e7-11d9-af55-00054e43ff02")
    IDirectXVideoDecoderService : public IDirectXVideoAccelerationService
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDecoderDeviceGuids( 
            /* [annotation][out] */ 
            __out  UINT *pCount,
            /* [annotation][size_is][unique][out] */ 
            __deref_out_ecount_opt(*pCount)  GUID **pGuids) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDecoderRenderTargets( 
            /* [annotation][in] */ 
            __in  REFGUID Guid,
            /* [annotation][out] */ 
            __out  UINT *pCount,
            /* [annotation][size_is][unique][out] */ 
            __deref_out_ecount_opt(*pCount)  D3DFORMAT **pFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDecoderConfigurations( 
            /* [annotation][in] */ 
            __in  REFGUID Guid,
            /* [annotation][in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [annotation][in] */ 
            __reserved  void *pReserved,
            /* [annotation][out] */ 
            __out  UINT *pCount,
            /* [annotation][size_is][unique][out] */ 
            __deref_out_ecount_opt(*pCount)  DXVA2_ConfigPictureDecode **ppConfigs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateVideoDecoder( 
            /* [annotation][in] */ 
            __in  REFGUID Guid,
            /* [annotation][in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [annotation][in] */ 
            __in  const DXVA2_ConfigPictureDecode *pConfig,
            /* [annotation][size_is][in] */ 
            __in_ecount(NumRenderTargets)  IDirect3DSurface9 **ppDecoderRenderTargets,
            /* [annotation][in] */ 
            __in  UINT NumRenderTargets,
            /* [annotation][out] */ 
            __deref_out  IDirectXVideoDecoder **ppDecode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirectXVideoDecoderServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirectXVideoDecoderService * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirectXVideoDecoderService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirectXVideoDecoderService * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSurface )( 
            IDirectXVideoDecoderService * This,
            /* [annotation][in] */ 
            __in  UINT Width,
            /* [annotation][in] */ 
            __in  UINT Height,
            /* [annotation][in] */ 
            __in  UINT BackBuffers,
            /* [annotation][in] */ 
            __in  D3DFORMAT Format,
            /* [annotation][in] */ 
            __in  D3DPOOL Pool,
            /* [annotation][in] */ 
            __in  DWORD Usage,
            /* [annotation][in] */ 
            __in  DWORD DxvaType,
            /* [annotation][size_is][out] */ 
            __out_ecount(BackBuffers+1)  IDirect3DSurface9 **ppSurface,
            /* [annotation][out][in] */ 
            __inout_opt  HANDLE *pSharedHandle);
        
        HRESULT ( STDMETHODCALLTYPE *GetDecoderDeviceGuids )( 
            IDirectXVideoDecoderService * This,
            /* [annotation][out] */ 
            __out  UINT *pCount,
            /* [annotation][size_is][unique][out] */ 
            __deref_out_ecount_opt(*pCount)  GUID **pGuids);
        
        HRESULT ( STDMETHODCALLTYPE *GetDecoderRenderTargets )( 
            IDirectXVideoDecoderService * This,
            /* [annotation][in] */ 
            __in  REFGUID Guid,
            /* [annotation][out] */ 
            __out  UINT *pCount,
            /* [annotation][size_is][unique][out] */ 
            __deref_out_ecount_opt(*pCount)  D3DFORMAT **pFormats);
        
        HRESULT ( STDMETHODCALLTYPE *GetDecoderConfigurations )( 
            IDirectXVideoDecoderService * This,
            /* [annotation][in] */ 
            __in  REFGUID Guid,
            /* [annotation][in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [annotation][in] */ 
            __reserved  void *pReserved,
            /* [annotation][out] */ 
            __out  UINT *pCount,
            /* [annotation][size_is][unique][out] */ 
            __deref_out_ecount_opt(*pCount)  DXVA2_ConfigPictureDecode **ppConfigs);
        
        HRESULT ( STDMETHODCALLTYPE *CreateVideoDecoder )( 
            IDirectXVideoDecoderService * This,
            /* [annotation][in] */ 
            __in  REFGUID Guid,
            /* [annotation][in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [annotation][in] */ 
            __in  const DXVA2_ConfigPictureDecode *pConfig,
            /* [annotation][size_is][in] */ 
            __in_ecount(NumRenderTargets)  IDirect3DSurface9 **ppDecoderRenderTargets,
            /* [annotation][in] */ 
            __in  UINT NumRenderTargets,
            /* [annotation][out] */ 
            __deref_out  IDirectXVideoDecoder **ppDecode);
        
        END_INTERFACE
    } IDirectXVideoDecoderServiceVtbl;

    interface IDirectXVideoDecoderService
    {
        CONST_VTBL struct IDirectXVideoDecoderServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirectXVideoDecoderService_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDirectXVideoDecoderService_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDirectXVideoDecoderService_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDirectXVideoDecoderService_CreateSurface(This,Width,Height,BackBuffers,Format,Pool,Usage,DxvaType,ppSurface,pSharedHandle)	\
    ( (This)->lpVtbl -> CreateSurface(This,Width,Height,BackBuffers,Format,Pool,Usage,DxvaType,ppSurface,pSharedHandle) ) 


#define IDirectXVideoDecoderService_GetDecoderDeviceGuids(This,pCount,pGuids)	\
    ( (This)->lpVtbl -> GetDecoderDeviceGuids(This,pCount,pGuids) ) 

#define IDirectXVideoDecoderService_GetDecoderRenderTargets(This,Guid,pCount,pFormats)	\
    ( (This)->lpVtbl -> GetDecoderRenderTargets(This,Guid,pCount,pFormats) ) 

#define IDirectXVideoDecoderService_GetDecoderConfigurations(This,Guid,pVideoDesc,pReserved,pCount,ppConfigs)	\
    ( (This)->lpVtbl -> GetDecoderConfigurations(This,Guid,pVideoDesc,pReserved,pCount,ppConfigs) ) 

#define IDirectXVideoDecoderService_CreateVideoDecoder(This,Guid,pVideoDesc,pConfig,ppDecoderRenderTargets,NumRenderTargets,ppDecode)	\
    ( (This)->lpVtbl -> CreateVideoDecoder(This,Guid,pVideoDesc,pConfig,ppDecoderRenderTargets,NumRenderTargets,ppDecode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDirectXVideoDecoderService_INTERFACE_DEFINED__ */


#ifndef __IDirectXVideoProcessorService_INTERFACE_DEFINED__
#define __IDirectXVideoProcessorService_INTERFACE_DEFINED__

/* interface IDirectXVideoProcessorService */
/* [local][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDirectXVideoProcessorService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fc51a552-d5e7-11d9-af55-00054e43ff02")
    IDirectXVideoProcessorService : public IDirectXVideoAccelerationService
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterVideoProcessorSoftwareDevice( 
            /* [annotation][in] */ 
            __in  void *pCallbacks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoProcessorDeviceGuids( 
            /* [annotation][in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [annotation][out] */ 
            __out  UINT *pCount,
            /* [annotation][size_is][unique][out] */ 
            __deref_out_ecount_opt(*pCount)  GUID **pGuids) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoProcessorRenderTargets( 
            /* [annotation][in] */ 
            __in  REFGUID VideoProcDeviceGuid,
            /* [annotation][in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [annotation][out] */ 
            __out  UINT *pCount,
            /* [annotation][size_is][unique][out] */ 
            __deref_out_ecount_opt(*pCount)  D3DFORMAT **pFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoProcessorSubStreamFormats( 
            /* [annotation][in] */ 
            __in  REFGUID VideoProcDeviceGuid,
            /* [annotation][in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [annotation][in] */ 
            __in  D3DFORMAT RenderTargetFormat,
            /* [annotation][out] */ 
            __out  UINT *pCount,
            /* [annotation][size_is][unique][out] */ 
            __deref_out_ecount_opt(*pCount)  D3DFORMAT **pFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoProcessorCaps( 
            /* [annotation][in] */ 
            __in  REFGUID VideoProcDeviceGuid,
            /* [annotation][in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [annotation][in] */ 
            __in  D3DFORMAT RenderTargetFormat,
            /* [annotation][out] */ 
            __out  DXVA2_VideoProcessorCaps *pCaps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcAmpRange( 
            /* [annotation][in] */ 
            __in  REFGUID VideoProcDeviceGuid,
            /* [annotation][in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [annotation][in] */ 
            __in  D3DFORMAT RenderTargetFormat,
            /* [annotation][in] */ 
            __in  UINT ProcAmpCap,
            /* [annotation][out] */ 
            __out  DXVA2_ValueRange *pRange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilterPropertyRange( 
            /* [annotation][in] */ 
            __in  REFGUID VideoProcDeviceGuid,
            /* [annotation][in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [annotation][in] */ 
            __in  D3DFORMAT RenderTargetFormat,
            /* [annotation][in] */ 
            __in  UINT FilterSetting,
            /* [annotation][out] */ 
            __out  DXVA2_ValueRange *pRange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateVideoProcessor( 
            /* [annotation][in] */ 
            __in  REFGUID VideoProcDeviceGuid,
            /* [annotation][in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [annotation][in] */ 
            __in  D3DFORMAT RenderTargetFormat,
            /* [annotation][in] */ 
            __in  UINT MaxNumSubStreams,
            /* [annotation][out] */ 
            __deref_out  IDirectXVideoProcessor **ppVidProcess) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirectXVideoProcessorServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirectXVideoProcessorService * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirectXVideoProcessorService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirectXVideoProcessorService * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSurface )( 
            IDirectXVideoProcessorService * This,
            /* [annotation][in] */ 
            __in  UINT Width,
            /* [annotation][in] */ 
            __in  UINT Height,
            /* [annotation][in] */ 
            __in  UINT BackBuffers,
            /* [annotation][in] */ 
            __in  D3DFORMAT Format,
            /* [annotation][in] */ 
            __in  D3DPOOL Pool,
            /* [annotation][in] */ 
            __in  DWORD Usage,
            /* [annotation][in] */ 
            __in  DWORD DxvaType,
            /* [annotation][size_is][out] */ 
            __out_ecount(BackBuffers+1)  IDirect3DSurface9 **ppSurface,
            /* [annotation][out][in] */ 
            __inout_opt  HANDLE *pSharedHandle);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterVideoProcessorSoftwareDevice )( 
            IDirectXVideoProcessorService * This,
            /* [annotation][in] */ 
            __in  void *pCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoProcessorDeviceGuids )( 
            IDirectXVideoProcessorService * This,
            /* [annotation][in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [annotation][out] */ 
            __out  UINT *pCount,
            /* [annotation][size_is][unique][out] */ 
            __deref_out_ecount_opt(*pCount)  GUID **pGuids);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoProcessorRenderTargets )( 
            IDirectXVideoProcessorService * This,
            /* [annotation][in] */ 
            __in  REFGUID VideoProcDeviceGuid,
            /* [annotation][in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [annotation][out] */ 
            __out  UINT *pCount,
            /* [annotation][size_is][unique][out] */ 
            __deref_out_ecount_opt(*pCount)  D3DFORMAT **pFormats);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoProcessorSubStreamFormats )( 
            IDirectXVideoProcessorService * This,
            /* [annotation][in] */ 
            __in  REFGUID VideoProcDeviceGuid,
            /* [annotation][in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [annotation][in] */ 
            __in  D3DFORMAT RenderTargetFormat,
            /* [annotation][out] */ 
            __out  UINT *pCount,
            /* [annotation][size_is][unique][out] */ 
            __deref_out_ecount_opt(*pCount)  D3DFORMAT **pFormats);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoProcessorCaps )( 
            IDirectXVideoProcessorService * This,
            /* [annotation][in] */ 
            __in  REFGUID VideoProcDeviceGuid,
            /* [annotation][in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [annotation][in] */ 
            __in  D3DFORMAT RenderTargetFormat,
            /* [annotation][out] */ 
            __out  DXVA2_VideoProcessorCaps *pCaps);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcAmpRange )( 
            IDirectXVideoProcessorService * This,
            /* [annotation][in] */ 
            __in  REFGUID VideoProcDeviceGuid,
            /* [annotation][in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [annotation][in] */ 
            __in  D3DFORMAT RenderTargetFormat,
            /* [annotation][in] */ 
            __in  UINT ProcAmpCap,
            /* [annotation][out] */ 
            __out  DXVA2_ValueRange *pRange);
        
        HRESULT ( STDMETHODCALLTYPE *GetFilterPropertyRange )( 
            IDirectXVideoProcessorService * This,
            /* [annotation][in] */ 
            __in  REFGUID VideoProcDeviceGuid,
            /* [annotation][in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [annotation][in] */ 
            __in  D3DFORMAT RenderTargetFormat,
            /* [annotation][in] */ 
            __in  UINT FilterSetting,
            /* [annotation][out] */ 
            __out  DXVA2_ValueRange *pRange);
        
        HRESULT ( STDMETHODCALLTYPE *CreateVideoProcessor )( 
            IDirectXVideoProcessorService * This,
            /* [annotation][in] */ 
            __in  REFGUID VideoProcDeviceGuid,
            /* [annotation][in] */ 
            __in  const DXVA2_VideoDesc *pVideoDesc,
            /* [annotation][in] */ 
            __in  D3DFORMAT RenderTargetFormat,
            /* [annotation][in] */ 
            __in  UINT MaxNumSubStreams,
            /* [annotation][out] */ 
            __deref_out  IDirectXVideoProcessor **ppVidProcess);
        
        END_INTERFACE
    } IDirectXVideoProcessorServiceVtbl;

    interface IDirectXVideoProcessorService
    {
        CONST_VTBL struct IDirectXVideoProcessorServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirectXVideoProcessorService_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDirectXVideoProcessorService_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDirectXVideoProcessorService_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDirectXVideoProcessorService_CreateSurface(This,Width,Height,BackBuffers,Format,Pool,Usage,DxvaType,ppSurface,pSharedHandle)	\
    ( (This)->lpVtbl -> CreateSurface(This,Width,Height,BackBuffers,Format,Pool,Usage,DxvaType,ppSurface,pSharedHandle) ) 


#define IDirectXVideoProcessorService_RegisterVideoProcessorSoftwareDevice(This,pCallbacks)	\
    ( (This)->lpVtbl -> RegisterVideoProcessorSoftwareDevice(This,pCallbacks) ) 

#define IDirectXVideoProcessorService_GetVideoProcessorDeviceGuids(This,pVideoDesc,pCount,pGuids)	\
    ( (This)->lpVtbl -> GetVideoProcessorDeviceGuids(This,pVideoDesc,pCount,pGuids) ) 

#define IDirectXVideoProcessorService_GetVideoProcessorRenderTargets(This,VideoProcDeviceGuid,pVideoDesc,pCount,pFormats)	\
    ( (This)->lpVtbl -> GetVideoProcessorRenderTargets(This,VideoProcDeviceGuid,pVideoDesc,pCount,pFormats) ) 

#define IDirectXVideoProcessorService_GetVideoProcessorSubStreamFormats(This,VideoProcDeviceGuid,pVideoDesc,RenderTargetFormat,pCount,pFormats)	\
    ( (This)->lpVtbl -> GetVideoProcessorSubStreamFormats(This,VideoProcDeviceGuid,pVideoDesc,RenderTargetFormat,pCount,pFormats) ) 

#define IDirectXVideoProcessorService_GetVideoProcessorCaps(This,VideoProcDeviceGuid,pVideoDesc,RenderTargetFormat,pCaps)	\
    ( (This)->lpVtbl -> GetVideoProcessorCaps(This,VideoProcDeviceGuid,pVideoDesc,RenderTargetFormat,pCaps) ) 

#define IDirectXVideoProcessorService_GetProcAmpRange(This,VideoProcDeviceGuid,pVideoDesc,RenderTargetFormat,ProcAmpCap,pRange)	\
    ( (This)->lpVtbl -> GetProcAmpRange(This,VideoProcDeviceGuid,pVideoDesc,RenderTargetFormat,ProcAmpCap,pRange) ) 

#define IDirectXVideoProcessorService_GetFilterPropertyRange(This,VideoProcDeviceGuid,pVideoDesc,RenderTargetFormat,FilterSetting,pRange)	\
    ( (This)->lpVtbl -> GetFilterPropertyRange(This,VideoProcDeviceGuid,pVideoDesc,RenderTargetFormat,FilterSetting,pRange) ) 

#define IDirectXVideoProcessorService_CreateVideoProcessor(This,VideoProcDeviceGuid,pVideoDesc,RenderTargetFormat,MaxNumSubStreams,ppVidProcess)	\
    ( (This)->lpVtbl -> CreateVideoProcessor(This,VideoProcDeviceGuid,pVideoDesc,RenderTargetFormat,MaxNumSubStreams,ppVidProcess) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDirectXVideoProcessorService_INTERFACE_DEFINED__ */


#ifndef __IDirectXVideoDecoder_INTERFACE_DEFINED__
#define __IDirectXVideoDecoder_INTERFACE_DEFINED__

/* interface IDirectXVideoDecoder */
/* [local][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDirectXVideoDecoder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f2b0810a-fd00-43c9-918c-df94e2d8ef7d")
    IDirectXVideoDecoder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetVideoDecoderService( 
            /* [annotation][out] */ 
            __deref_out  IDirectXVideoDecoderService **ppService) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCreationParameters( 
            /* [annotation][out] */ 
            __out_opt  GUID *pDeviceGuid,
            /* [annotation][out] */ 
            __out_opt  DXVA2_VideoDesc *pVideoDesc,
            /* [annotation][out] */ 
            __out_opt  DXVA2_ConfigPictureDecode *pConfig,
            /* [annotation][size_is][unique][out] */ 
            __out_ecount(*pNumSurfaces)  IDirect3DSurface9 ***pDecoderRenderTargets,
            /* [annotation][out] */ 
            __out_opt  UINT *pNumSurfaces) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBuffer( 
            /* [annotation][in] */ 
            __in  UINT BufferType,
            /* [annotation][out] */ 
            __out  void **ppBuffer,
            /* [annotation][out] */ 
            __out  UINT *pBufferSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseBuffer( 
            /* [annotation][in] */ 
            __in  UINT BufferType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginFrame( 
            /* [annotation][in] */ 
            __in  IDirect3DSurface9 *pRenderTarget,
            /* [annotation][in] */ 
            __in_opt  void *pvPVPData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndFrame( 
            /* [annotation][out] */ 
            __inout_opt  HANDLE *pHandleComplete) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Execute( 
            /* [annotation][in] */ 
            __in  const DXVA2_DecodeExecuteParams *pExecuteParams) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirectXVideoDecoderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirectXVideoDecoder * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirectXVideoDecoder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirectXVideoDecoder * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoDecoderService )( 
            IDirectXVideoDecoder * This,
            /* [annotation][out] */ 
            __deref_out  IDirectXVideoDecoderService **ppService);
        
        HRESULT ( STDMETHODCALLTYPE *GetCreationParameters )( 
            IDirectXVideoDecoder * This,
            /* [annotation][out] */ 
            __out_opt  GUID *pDeviceGuid,
            /* [annotation][out] */ 
            __out_opt  DXVA2_VideoDesc *pVideoDesc,
            /* [annotation][out] */ 
            __out_opt  DXVA2_ConfigPictureDecode *pConfig,
            /* [annotation][size_is][unique][out] */ 
            __out_ecount(*pNumSurfaces)  IDirect3DSurface9 ***pDecoderRenderTargets,
            /* [annotation][out] */ 
            __out_opt  UINT *pNumSurfaces);
        
        HRESULT ( STDMETHODCALLTYPE *GetBuffer )( 
            IDirectXVideoDecoder * This,
            /* [annotation][in] */ 
            __in  UINT BufferType,
            /* [annotation][out] */ 
            __out  void **ppBuffer,
            /* [annotation][out] */ 
            __out  UINT *pBufferSize);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseBuffer )( 
            IDirectXVideoDecoder * This,
            /* [annotation][in] */ 
            __in  UINT BufferType);
        
        HRESULT ( STDMETHODCALLTYPE *BeginFrame )( 
            IDirectXVideoDecoder * This,
            /* [annotation][in] */ 
            __in  IDirect3DSurface9 *pRenderTarget,
            /* [annotation][in] */ 
            __in_opt  void *pvPVPData);
        
        HRESULT ( STDMETHODCALLTYPE *EndFrame )( 
            IDirectXVideoDecoder * This,
            /* [annotation][out] */ 
            __inout_opt  HANDLE *pHandleComplete);
        
        HRESULT ( STDMETHODCALLTYPE *Execute )( 
            IDirectXVideoDecoder * This,
            /* [annotation][in] */ 
            __in  const DXVA2_DecodeExecuteParams *pExecuteParams);
        
        END_INTERFACE
    } IDirectXVideoDecoderVtbl;

    interface IDirectXVideoDecoder
    {
        CONST_VTBL struct IDirectXVideoDecoderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirectXVideoDecoder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDirectXVideoDecoder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDirectXVideoDecoder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDirectXVideoDecoder_GetVideoDecoderService(This,ppService)	\
    ( (This)->lpVtbl -> GetVideoDecoderService(This,ppService) ) 

#define IDirectXVideoDecoder_GetCreationParameters(This,pDeviceGuid,pVideoDesc,pConfig,pDecoderRenderTargets,pNumSurfaces)	\
    ( (This)->lpVtbl -> GetCreationParameters(This,pDeviceGuid,pVideoDesc,pConfig,pDecoderRenderTargets,pNumSurfaces) ) 

#define IDirectXVideoDecoder_GetBuffer(This,BufferType,ppBuffer,pBufferSize)	\
    ( (This)->lpVtbl -> GetBuffer(This,BufferType,ppBuffer,pBufferSize) ) 

#define IDirectXVideoDecoder_ReleaseBuffer(This,BufferType)	\
    ( (This)->lpVtbl -> ReleaseBuffer(This,BufferType) ) 

#define IDirectXVideoDecoder_BeginFrame(This,pRenderTarget,pvPVPData)	\
    ( (This)->lpVtbl -> BeginFrame(This,pRenderTarget,pvPVPData) ) 

#define IDirectXVideoDecoder_EndFrame(This,pHandleComplete)	\
    ( (This)->lpVtbl -> EndFrame(This,pHandleComplete) ) 

#define IDirectXVideoDecoder_Execute(This,pExecuteParams)	\
    ( (This)->lpVtbl -> Execute(This,pExecuteParams) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDirectXVideoDecoder_INTERFACE_DEFINED__ */


#ifndef __IDirectXVideoProcessor_INTERFACE_DEFINED__
#define __IDirectXVideoProcessor_INTERFACE_DEFINED__

/* interface IDirectXVideoProcessor */
/* [local][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDirectXVideoProcessor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8c3a39f0-916e-4690-804f-4c8001355d25")
    IDirectXVideoProcessor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetVideoProcessorService( 
            /* [annotation][out] */ 
            __deref_out  IDirectXVideoProcessorService **ppService) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCreationParameters( 
            /* [annotation][out] */ 
            __out_opt  GUID *pDeviceGuid,
            /* [annotation][out] */ 
            __out_opt  DXVA2_VideoDesc *pVideoDesc,
            /* [annotation][out] */ 
            __out_opt  D3DFORMAT *pRenderTargetFormat,
            /* [annotation][out] */ 
            __out_opt  UINT *pMaxNumSubStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoProcessorCaps( 
            /* [annotation][out] */ 
            __out  DXVA2_VideoProcessorCaps *pCaps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcAmpRange( 
            /* [annotation][in] */ 
            __in  UINT ProcAmpCap,
            /* [annotation][out] */ 
            __out  DXVA2_ValueRange *pRange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilterPropertyRange( 
            /* [annotation][in] */ 
            __in  UINT FilterSetting,
            /* [annotation][out] */ 
            __out  DXVA2_ValueRange *pRange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE VideoProcessBlt( 
            /* [annotation][in] */ 
            __in  IDirect3DSurface9 *pRenderTarget,
            /* [annotation][in] */ 
            __in  const DXVA2_VideoProcessBltParams *pBltParams,
            /* [annotation][size_is][in] */ 
            __in_ecount(NumSamples)  const DXVA2_VideoSample *pSamples,
            /* [annotation][in] */ 
            __in  UINT NumSamples,
            /* [annotation][out] */ 
            __inout_opt  HANDLE *pHandleComplete) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirectXVideoProcessorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirectXVideoProcessor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirectXVideoProcessor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirectXVideoProcessor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoProcessorService )( 
            IDirectXVideoProcessor * This,
            /* [annotation][out] */ 
            __deref_out  IDirectXVideoProcessorService **ppService);
        
        HRESULT ( STDMETHODCALLTYPE *GetCreationParameters )( 
            IDirectXVideoProcessor * This,
            /* [annotation][out] */ 
            __out_opt  GUID *pDeviceGuid,
            /* [annotation][out] */ 
            __out_opt  DXVA2_VideoDesc *pVideoDesc,
            /* [annotation][out] */ 
            __out_opt  D3DFORMAT *pRenderTargetFormat,
            /* [annotation][out] */ 
            __out_opt  UINT *pMaxNumSubStreams);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoProcessorCaps )( 
            IDirectXVideoProcessor * This,
            /* [annotation][out] */ 
            __out  DXVA2_VideoProcessorCaps *pCaps);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcAmpRange )( 
            IDirectXVideoProcessor * This,
            /* [annotation][in] */ 
            __in  UINT ProcAmpCap,
            /* [annotation][out] */ 
            __out  DXVA2_ValueRange *pRange);
        
        HRESULT ( STDMETHODCALLTYPE *GetFilterPropertyRange )( 
            IDirectXVideoProcessor * This,
            /* [annotation][in] */ 
            __in  UINT FilterSetting,
            /* [annotation][out] */ 
            __out  DXVA2_ValueRange *pRange);
        
        HRESULT ( STDMETHODCALLTYPE *VideoProcessBlt )( 
            IDirectXVideoProcessor * This,
            /* [annotation][in] */ 
            __in  IDirect3DSurface9 *pRenderTarget,
            /* [annotation][in] */ 
            __in  const DXVA2_VideoProcessBltParams *pBltParams,
            /* [annotation][size_is][in] */ 
            __in_ecount(NumSamples)  const DXVA2_VideoSample *pSamples,
            /* [annotation][in] */ 
            __in  UINT NumSamples,
            /* [annotation][out] */ 
            __inout_opt  HANDLE *pHandleComplete);
        
        END_INTERFACE
    } IDirectXVideoProcessorVtbl;

    interface IDirectXVideoProcessor
    {
        CONST_VTBL struct IDirectXVideoProcessorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirectXVideoProcessor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDirectXVideoProcessor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDirectXVideoProcessor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDirectXVideoProcessor_GetVideoProcessorService(This,ppService)	\
    ( (This)->lpVtbl -> GetVideoProcessorService(This,ppService) ) 

#define IDirectXVideoProcessor_GetCreationParameters(This,pDeviceGuid,pVideoDesc,pRenderTargetFormat,pMaxNumSubStreams)	\
    ( (This)->lpVtbl -> GetCreationParameters(This,pDeviceGuid,pVideoDesc,pRenderTargetFormat,pMaxNumSubStreams) ) 

#define IDirectXVideoProcessor_GetVideoProcessorCaps(This,pCaps)	\
    ( (This)->lpVtbl -> GetVideoProcessorCaps(This,pCaps) ) 

#define IDirectXVideoProcessor_GetProcAmpRange(This,ProcAmpCap,pRange)	\
    ( (This)->lpVtbl -> GetProcAmpRange(This,ProcAmpCap,pRange) ) 

#define IDirectXVideoProcessor_GetFilterPropertyRange(This,FilterSetting,pRange)	\
    ( (This)->lpVtbl -> GetFilterPropertyRange(This,FilterSetting,pRange) ) 

#define IDirectXVideoProcessor_VideoProcessBlt(This,pRenderTarget,pBltParams,pSamples,NumSamples,pHandleComplete)	\
    ( (This)->lpVtbl -> VideoProcessBlt(This,pRenderTarget,pBltParams,pSamples,NumSamples,pHandleComplete) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDirectXVideoProcessor_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxva2api_0000_0006 */
/* [local] */ 

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_dxva2api_0000_0006_0001
    {	DXVA2_SurfaceType_DecoderRenderTarget	= 0,
	DXVA2_SurfaceType_ProcessorRenderTarget	= 1,
	DXVA2_SurfaceType_D3DRenderTargetTexture	= 2
    } 	DXVA2_SurfaceType;



extern RPC_IF_HANDLE __MIDL_itf_dxva2api_0000_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxva2api_0000_0006_v0_0_s_ifspec;

#ifndef __IDirectXVideoMemoryConfiguration_INTERFACE_DEFINED__
#define __IDirectXVideoMemoryConfiguration_INTERFACE_DEFINED__

/* interface IDirectXVideoMemoryConfiguration */
/* [local][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDirectXVideoMemoryConfiguration;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b7f916dd-db3b-49c1-84d7-e45ef99ec726")
    IDirectXVideoMemoryConfiguration : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAvailableSurfaceTypeByIndex( 
            /* [annotation][in] */ 
            __in  DWORD dwTypeIndex,
            /* [annotation][out] */ 
            __out  DXVA2_SurfaceType *pdwType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSurfaceType( 
            /* [annotation][in] */ 
            __in  DXVA2_SurfaceType dwType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirectXVideoMemoryConfigurationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirectXVideoMemoryConfiguration * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirectXVideoMemoryConfiguration * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirectXVideoMemoryConfiguration * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAvailableSurfaceTypeByIndex )( 
            IDirectXVideoMemoryConfiguration * This,
            /* [annotation][in] */ 
            __in  DWORD dwTypeIndex,
            /* [annotation][out] */ 
            __out  DXVA2_SurfaceType *pdwType);
        
        HRESULT ( STDMETHODCALLTYPE *SetSurfaceType )( 
            IDirectXVideoMemoryConfiguration * This,
            /* [annotation][in] */ 
            __in  DXVA2_SurfaceType dwType);
        
        END_INTERFACE
    } IDirectXVideoMemoryConfigurationVtbl;

    interface IDirectXVideoMemoryConfiguration
    {
        CONST_VTBL struct IDirectXVideoMemoryConfigurationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirectXVideoMemoryConfiguration_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDirectXVideoMemoryConfiguration_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDirectXVideoMemoryConfiguration_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDirectXVideoMemoryConfiguration_GetAvailableSurfaceTypeByIndex(This,dwTypeIndex,pdwType)	\
    ( (This)->lpVtbl -> GetAvailableSurfaceTypeByIndex(This,dwTypeIndex,pdwType) ) 

#define IDirectXVideoMemoryConfiguration_SetSurfaceType(This,dwType)	\
    ( (This)->lpVtbl -> SetSurfaceType(This,dwType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDirectXVideoMemoryConfiguration_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxva2api_0000_0007 */
/* [local] */ 

STDAPI DXVA2CreateDirect3DDeviceManager9(
    __out UINT* pResetToken,
    __deref_out IDirect3DDeviceManager9** ppDeviceManager
    );
STDAPI DXVA2CreateVideoService(
    __in IDirect3DDevice9* pDD,
    __in REFIID riid,
    __deref_out void** ppService
    );
#endif  // _D3D9_H_
__inline DXVA2_Fixed32 DXVA2FloatToFixed(__in const float _float_)
{
    DXVA2_Fixed32 _fixed_;
    _fixed_.Fraction = LOWORD(_float_ * 0x10000);
    _fixed_.Value = HIWORD(_float_ * 0x10000);
    return _fixed_;
}
__inline float DXVA2FixedToFloat(__in const DXVA2_Fixed32 _fixed_)
{
    return (FLOAT)_fixed_.Value + (FLOAT)_fixed_.Fraction / 0x10000;
}
__inline const DXVA2_Fixed32 DXVA2_Fixed32TransparentAlpha()
{
    DXVA2_Fixed32 _fixed_ = {0, 0};
    return _fixed_;
}
__inline const DXVA2_Fixed32 DXVA2_Fixed32OpaqueAlpha()
{
    DXVA2_Fixed32 _fixed_ = {0, 1};
    return _fixed_;
}
#endif


extern RPC_IF_HANDLE __MIDL_itf_dxva2api_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxva2api_0000_0007_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dxva2swdev.h ===
//------------------------------------------------------------------------------
// File: dxva2SWDev.h
//
// Desc: DirectX Video Acceleration 2 header file for software video
// processing devices
//
// Copyright (c) 1999 - 2002, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------

#ifndef __inc_dxva2SWDev_h
#define __inc_dxva2SWDev_h

#ifdef __cplusplus
extern "C" {
#endif

typedef enum _DXVA2_SampleFlags
{
    DXVA2_SampleFlag_Palette_Changed         = 0x00000001,
    DXVA2_SampleFlag_SrcRect_Changed         = 0x00000002,
    DXVA2_SampleFlag_DstRect_Changed         = 0x00000004,
    DXVA2_SampleFlag_ColorData_Changed       = 0x00000008,
    DXVA2_SampleFlag_PlanarAlpha_Changed     = 0x00000010,
    DXVA2_SampleFlag_RFF                     = 0x00010000,
    DXVA2_SampleFlag_TFF                     = 0x00020000,
    DXVA2_SampleFlag_RFF_TFF_Present         = 0x00040000,
    DXVA2_SampleFlagsMask                    = 0xFFFF001F
} DXVA2_SampleFlags;

typedef enum _DXVA2_DestinationFlags
{
    DXVA2_DestinationFlag_Background_Changed = 0x00000001,
    DXVA2_DestinationFlag_TargetRect_Changed = 0x00000002,
    DXVA2_DestinationFlag_ColorData_Changed  = 0x00000004,
    DXVA2_DestinationFlag_Alpha_Changed      = 0x00000008,
    DXVA2_DestinationFlag_RFF                = 0x00010000,
    DXVA2_DestinationFlag_TFF                = 0x00020000,
    DXVA2_DestinationFlag_RFF_TFF_Present    = 0x00040000,
    DXVA2_DestinationFlagMask                = 0xFFFF000F
} DXVA2_DestinationFlags;

typedef struct _DXVA2_VIDEOSAMPLE
{
    REFERENCE_TIME           Start;
    REFERENCE_TIME           End;
    DXVA2_ExtendedFormat     SampleFormat;
    UINT                     SampleFlags;
    VOID*                    SrcResource;
    RECT                     SrcRect;
    RECT                     DstRect;
    DXVA2_AYUVSample8        Pal[16];
    DXVA2_Fixed32            PlanarAlpha;
} DXVA2_VIDEOSAMPLE;

typedef struct _DXVA2_VIDEOPROCESSBLT
{
    REFERENCE_TIME           TargetFrame;
    RECT                     TargetRect;
    SIZE                     ConstrictionSize;
    UINT                     StreamingFlags;
    DXVA2_AYUVSample16       BackgroundColor;
    DXVA2_ExtendedFormat     DestFormat;
    UINT                     DestFlags;
    DXVA2_ProcAmpValues      ProcAmpValues;
    DXVA2_Fixed32            Alpha;
    DXVA2_FilterValues       NoiseFilterLuma;
    DXVA2_FilterValues       NoiseFilterChroma;
    DXVA2_FilterValues       DetailFilterLuma;
    DXVA2_FilterValues       DetailFilterChroma;
    DXVA2_VIDEOSAMPLE*       pSrcSurfaces;
    UINT                     NumSrcSurfaces;
} DXVA2_VIDEOPROCESSBLT;

#if defined(_D3D9_H_) || defined(_d3d9P_H_)

typedef HRESULT (CALLBACK* PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETCOUNT)(
    __in const DXVA2_VideoDesc* pVideoDesc,
    __out UINT* pCount
    );

typedef HRESULT (CALLBACK* PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETS)(
    __in const DXVA2_VideoDesc* pVideoDesc,
    __in UINT Count,
    __out_ecount(Count) D3DFORMAT* pFormats
    );

typedef HRESULT (CALLBACK* PDXVA2SW_GETVIDEOPROCESSORCAPS)(
    __in const DXVA2_VideoDesc* pVideoDesc,
    __in D3DFORMAT RenderTargetFormat,
    __out DXVA2_VideoProcessorCaps* pCaps
    );

typedef HRESULT (CALLBACK* PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATCOUNT)(
    __in const DXVA2_VideoDesc* pVideoDesc,
    __in D3DFORMAT RenderTargetFormat,
    __out UINT* pCount
    );

typedef HRESULT (CALLBACK* PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATS)(
    __in const DXVA2_VideoDesc* pVideoDesc,
    __in D3DFORMAT RenderTargetFormat,
    __in UINT Count,
    __out_ecount(Count) D3DFORMAT* pFormats
    );

typedef HRESULT (CALLBACK* PDXVA2SW_GETPROCAMPRANGE)(
    __in const DXVA2_VideoDesc* pVideoDesc,
    __in D3DFORMAT RenderTargetFormat,
    __in UINT ProcAmpCap,
    __out DXVA2_ValueRange* pRange
    );

typedef HRESULT (CALLBACK* PDXVA2SW_GETFILTERPROPERTYRANGE)(
    __in const DXVA2_VideoDesc* pVideoDesc,
    __in D3DFORMAT RenderTargetFormat,
    __in UINT FilterSetting,
    __out DXVA2_ValueRange* pRange
    );

typedef HRESULT (CALLBACK* PDXVA2SW_CREATEVIDEOPROCESSDEVICE)(
    __in IDirect3DDevice9* pD3DD9,
    __in const DXVA2_VideoDesc* pVideoDesc,
    __in D3DFORMAT RenderTargetFormat,
    __in UINT MaxSubStreams,
    __out HANDLE* phDevice
    );

typedef HRESULT (CALLBACK* PDXVA2SW_DESTROYVIDEOPROCESSDEVICE)(
    __in HANDLE hDevice
    );

typedef HRESULT (CALLBACK* PDXVA2SW_VIDEOPROCESSBEGINFRAME)(
    __in HANDLE hDevice
    );

typedef HRESULT (CALLBACK* PDXVA2SW_VIDEOPROCESSENDFRAME)(
    __in HANDLE hDevice,
    __inout_opt HANDLE* pHandleComplete
    );

typedef HRESULT (CALLBACK* PDXVA2SW_VIDEOPROCESSSETRENDERTARGET)(
    __in HANDLE hDevice,
    __in IDirect3DSurface9* pRenderTarget
    );

typedef HRESULT (CALLBACK* PDXVA2SW_VIDEOPROCESSBLT)(
    __in HANDLE hDevice,
    __in const DXVA2_VIDEOPROCESSBLT* pBlt
    );

typedef struct _DXVA2SW_CALLBACKS
{
    UINT                                           Size;
    PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETCOUNT    GetVideoProcessorRenderTargetCount;
    PDXVA2SW_GETVIDEOPROCESSORRENDERTARGETS        GetVideoProcessorRenderTargets;
    PDXVA2SW_GETVIDEOPROCESSORCAPS                 GetVideoProcessorCaps;
    PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATCOUNT GetVideoProcessorSubStreamFormatCount;
    PDXVA2SW_GETVIDEOPROCESSORSUBSTREAMFORMATS     GetVideoProcessorSubStreamFormats;
    PDXVA2SW_GETPROCAMPRANGE                       GetProcAmpRange;
    PDXVA2SW_GETFILTERPROPERTYRANGE                GetFilterPropertyRange;
    PDXVA2SW_CREATEVIDEOPROCESSDEVICE              CreateVideoProcessDevice;
    PDXVA2SW_DESTROYVIDEOPROCESSDEVICE             DestroyVideoProcessDevice;
    PDXVA2SW_VIDEOPROCESSBEGINFRAME                VideoProcessBeginFrame;
    PDXVA2SW_VIDEOPROCESSENDFRAME                  VideoProcessEndFrame;
    PDXVA2SW_VIDEOPROCESSSETRENDERTARGET           VideoProcessSetRenderTarget;
    PDXVA2SW_VIDEOPROCESSBLT                       VideoProcessBlt;
} DXVA2SW_CALLBACKS, *PDXVA2SW_CALLBACKS;

#endif  // _D3D9_H_

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dxtmpl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//  File:       dxtmpl.h
//
//  Description:
//      This is the header file contains the DX collection class templates. It
//  has been derived from the MFC collection templates for compatibility.
//
//----------------------------------------------------------------------------

#ifndef DXTmpl_h
#define DXTmpl_h

#ifndef _INC_LIMITS
#include <limits.h>
#endif

#ifndef _INC_STRING
#include <string.h>
#endif

#ifndef _INC_STDLIB
#include <stdlib.h>
#endif

#ifndef _INC_SEARCH
#include <search.h>
#endif

#define DXASSERT_VALID( pObj )

#ifndef PASCAL_INLINE
#ifdef _M_CEE_PURE
#define PASCAL_INLINE  __clrcall
#else
#define PASCAL_INLINE  PASCAL
#endif
#endif

/////////////////////////////////////////////////////////////////////////////
typedef void* DXLISTPOS;
typedef DWORD DXLISTHANDLE;

#define DX_BEFORE_START_POSITION ((void*)-1L)

inline BOOL DXIsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite)
{
    // simple version using Win-32 APIs for pointer validation.
    return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
        (!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}

/////////////////////////////////////////////////////////////////////////////
// global helpers (can be overridden)
template<class TYPE>
inline void DXConstructElements(TYPE* pElements, int nCount)
{
    _ASSERT( nCount == 0 ||
             DXIsValidAddress( pElements, nCount * sizeof(TYPE), TRUE ) );

    // default is bit-wise zero initialization
    memset((void*)pElements, 0, nCount * sizeof(TYPE));
}

template<class TYPE>
inline void DXDestructElements(TYPE* pElements, int nCount)
{
    _ASSERT( ( nCount == 0 ||
               DXIsValidAddress( pElements, nCount * sizeof(TYPE), TRUE  ) ) );
    pElements;  // not used
    nCount; // not used

    // default does nothing
}

template<class TYPE>
inline void DXCopyElements(TYPE* pDest, const TYPE* pSrc, int nCount)
{
    _ASSERT( ( nCount == 0 ||
               DXIsValidAddress( pDest, nCount * sizeof(TYPE), TRUE  )) );
    _ASSERT( ( nCount == 0 ||
               DXIsValidAddress( pSrc, nCount * sizeof(TYPE), FALSE  )) );

    // default is bit-wise copy
    memcpy(pDest, pSrc, nCount * sizeof(TYPE));
}

template<class TYPE, class ARG_TYPE>
BOOL DXCompareElements(const TYPE* pElement1, const ARG_TYPE* pElement2)
{
    _ASSERT( DXIsValidAddress( pElement1, sizeof(TYPE), FALSE ) );
    _ASSERT( DXIsValidAddress( pElement2, sizeof(ARG_TYPE), FALSE ) );
    return *pElement1 == *pElement2;
}

template<class ARG_KEY>
inline UINT DXHashKey(ARG_KEY key)
{
    // default identity hash - works for most primitive values
    return ((UINT)(void*)(DWORD)key) >> 4;
}

/////////////////////////////////////////////////////////////////////////////
// CDXPlex

struct CDXPlex    // warning variable length structure
{
    CDXPlex* pNext;
    UINT nMax;
    UINT nCur;
    /* BYTE data[maxNum*elementSize]; */
    void* data() { return this+1; }

    static CDXPlex* PASCAL_INLINE Create( CDXPlex*& pHead, UINT nMax, UINT cbElement )
    {
	if ((nMax * cbElement) > (SIZE_MAX - sizeof(CDXPlex)))
	    return NULL;
        CDXPlex* p = (CDXPlex*) new BYTE[sizeof(CDXPlex) + nMax * cbElement];
        if (p == NULL)
            return NULL;
        p->nMax = nMax;
        p->nCur = 0;
        p->pNext = pHead;
        pHead = p;  // change head (adds in reverse order for simplicity)
        return p;
    }

    void FreeDataChain()
    {
        CDXPlex* p = this;
        while (p != NULL)
        {
            BYTE* bytes = (BYTE*) p;
            CDXPlex* pNext = p->pNext;
            delete [] bytes;
            p = pNext;
        }
    }
};


/////////////////////////////////////////////////////////////////////////////
// CDXArray<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CDXArray
{
public:
// Construction
    CDXArray();

// Attributes
    int GetSize() const;
    int GetUpperBound() const;
    void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
    // Clean up
    void FreeExtra();
    void RemoveAll();

    // Accessing elements
    TYPE GetAt(int nIndex) const;
    void SetAt(int nIndex, ARG_TYPE newElement);
    TYPE& ElementAt(int nIndex);

    // Direct Access to the element data (may return NULL)
    const TYPE* GetData() const;
    TYPE* GetData();

    // Potentially growing the array
    void SetAtGrow(int nIndex, ARG_TYPE newElement);
    int Add(ARG_TYPE newElement);
    int Append(const CDXArray& src);
    void Copy(const CDXArray& src);

    // overloaded operator helpers
    TYPE operator[](int nIndex) const;
    TYPE& operator[](int nIndex);

    // Operations that move elements around
    void InsertAt(int nIndex, ARG_TYPE newElement, int nCount = 1);
    void RemoveAt(int nIndex, int nCount = 1);
    void InsertAt(int nStartIndex, CDXArray* pNewArray);
    void Sort(int (__cdecl *compare )(const void *elem1, const void *elem2 ));

// Implementation
protected:
    TYPE* m_pData;   // the actual array of data
    int m_nSize;     // # of elements (upperBound - 1)
    int m_nMaxSize;  // max allocated
    int m_nGrowBy;   // grow amount

public:
    ~CDXArray();
#ifdef _DEBUG
//  void Dump(CDumpContext&) const;
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CDXArray<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CDXArray<TYPE, ARG_TYPE>::GetSize() const
    { return m_nSize; }
template<class TYPE, class ARG_TYPE>
inline int CDXArray<TYPE, ARG_TYPE>::GetUpperBound() const
    { return m_nSize-1; }
template<class TYPE, class ARG_TYPE>
inline void CDXArray<TYPE, ARG_TYPE>::RemoveAll()
    { SetSize(0, -1); }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXArray<TYPE, ARG_TYPE>::GetAt(int nIndex) const
    { _ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline void CDXArray<TYPE, ARG_TYPE>::SetAt(int nIndex, ARG_TYPE newElement)
    { _ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        m_pData[nIndex] = newElement; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXArray<TYPE, ARG_TYPE>::ElementAt(int nIndex)
    { _ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline const TYPE* CDXArray<TYPE, ARG_TYPE>::GetData() const
    { return (const TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline TYPE* CDXArray<TYPE, ARG_TYPE>::GetData()
    { return (TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline int CDXArray<TYPE, ARG_TYPE>::Add(ARG_TYPE newElement)
    { int nIndex = m_nSize;
        SetAtGrow(nIndex, newElement);
        return nIndex; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXArray<TYPE, ARG_TYPE>::operator[](int nIndex) const
    { return GetAt(nIndex); }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXArray<TYPE, ARG_TYPE>::operator[](int nIndex)
    { return ElementAt(nIndex); }

/////////////////////////////////////////////////////////////////////////////
// CDXArray<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CDXArray<TYPE, ARG_TYPE>::CDXArray()
{
    m_pData = NULL;
    m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

template<class TYPE, class ARG_TYPE>
CDXArray<TYPE, ARG_TYPE>::~CDXArray()
{
    DXASSERT_VALID( this );

    if (m_pData != NULL)
    {
        DXDestructElements(m_pData, m_nSize);
        delete[] (BYTE*)m_pData;
    }
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::SetSize(int nNewSize, int nGrowBy)
{
    DXASSERT_VALID( this );
    _ASSERT( nNewSize >= 0 );

    if (nGrowBy != -1)
        m_nGrowBy = nGrowBy;  // set new size

    if (nNewSize == 0)
    {
        // shrink to nothing
        if (m_pData != NULL)
        {
            DXDestructElements(m_pData, m_nSize);
            delete[] (BYTE*)m_pData;
            m_pData = NULL;
        }
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size
#ifdef SIZE_T_MAX
        _ASSERT( nNewSize <= SIZE_T_MAX/sizeof(TYPE) );    // no overflow
#endif
        m_pData = (TYPE*) new BYTE[nNewSize * sizeof(TYPE)];
        DXConstructElements(m_pData, nNewSize);
        m_nSize = m_nMaxSize = nNewSize;
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements
            DXConstructElements(&m_pData[m_nSize], nNewSize-m_nSize);
        }
        else if (m_nSize > nNewSize)
        {
            // destroy the old elements
            DXDestructElements(&m_pData[nNewSize], m_nSize-nNewSize);
        }
        m_nSize = nNewSize;
    }
    else
    {
        // otherwise, grow array
        int nGrowBy = m_nGrowBy;
        if (nGrowBy == 0)
        {
            // heuristically determe growth when nGrowBy == 0
            //  (this avoids heap fragmentation in many situations)
            nGrowBy = min(1024, max(4, m_nSize / 8));
        }
        int nNewMax;
        if (nNewSize < m_nMaxSize + nGrowBy)
            nNewMax = m_nMaxSize + nGrowBy;  // granularity
        else
            nNewMax = nNewSize;  // no slush

        _ASSERT( nNewMax >= m_nMaxSize );  // no wrap around
#ifdef SIZE_T_MAX
        _ASSERT( nNewMax <= SIZE_T_MAX/sizeof(TYPE) ); // no overflow
#endif
        TYPE* pNewData = (TYPE*) new BYTE[nNewMax * sizeof(TYPE)];

        // oh well, it's better than crashing
        if (pNewData == NULL)
            return;

        // copy new data from old
        memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));

        // construct remaining elements
        _ASSERT( nNewSize > m_nSize );
        DXConstructElements(&pNewData[m_nSize], nNewSize-m_nSize);

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nSize = nNewSize;
        m_nMaxSize = nNewMax;
    }
}

template<class TYPE, class ARG_TYPE>
int CDXArray<TYPE, ARG_TYPE>::Append(const CDXArray& src)
{
    DXASSERT_VALID( this );
    _ASSERT( this != &src );   // cannot append to itself

    int nOldSize = m_nSize;
    SetSize(m_nSize + src.m_nSize);
    DXCopyElements(m_pData + nOldSize, src.m_pData, src.m_nSize);
    return nOldSize;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::Copy(const CDXArray& src)
{
    DXASSERT_VALID( this );
    _ASSERT( this != &src );   // cannot copy to itself

    SetSize(src.m_nSize);
    DXCopyElements(m_pData, src.m_pData, src.m_nSize);
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::FreeExtra()
{
    DXASSERT_VALID( this );

    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size
#ifdef SIZE_T_MAX
        _ASSERT( m_nSize <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
#endif
        TYPE* pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (TYPE*) new BYTE[m_nSize * sizeof(TYPE)];

            // oh well, it's better than crashing
            if (pNewData == NULL)
                return;

            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));
        }

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::SetAtGrow(int nIndex, ARG_TYPE newElement)
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );

    if (nIndex >= m_nSize)
        SetSize(nIndex+1, -1);
    m_pData[nIndex] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::InsertAt(int nIndex, ARG_TYPE newElement, int nCount /*=1*/)
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );    // will expand to meet need
    _ASSERT( nCount > 0 );     // zero or negative size not allowed

    if (nIndex >= m_nSize)
    {
        // adding after the end of the array
        SetSize(nIndex + nCount, -1);   // grow so nIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        int nOldSize = m_nSize;
        SetSize(m_nSize + nCount, -1);  // grow it to new size
        // shift old data up to fill gap
        memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
            (nOldSize-nIndex) * sizeof(TYPE));

        // re-init slots we copied from
        DXConstructElements(&m_pData[nIndex], nCount);
    }

    // insert new value in the gap
    _ASSERT( nIndex + nCount <= m_nSize );
    while (nCount--)
        m_pData[nIndex++] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::RemoveAt(int nIndex, int nCount)
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );
    _ASSERT( nCount >= 0 );
    _ASSERT( nIndex + nCount <= m_nSize );

    // just remove a range
    int nMoveCount = m_nSize - (nIndex + nCount);
    DXDestructElements(&m_pData[nIndex], nCount);
    if (nMoveCount)
        memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
            nMoveCount * sizeof(TYPE));
    m_nSize -= nCount;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::InsertAt(int nStartIndex, CDXArray* pNewArray)
{
    DXASSERT_VALID( this );
    DXASSERT_VALID( pNewArray );
    _ASSERT( nStartIndex >= 0 );

    if (pNewArray->GetSize() > 0)
    {
        InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
        for (int i = 0; i < pNewArray->GetSize(); i++)
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
    }
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::Sort(int (__cdecl *compare )(const void *elem1, const void *elem2 ))
{
    DXASSERT_VALID( this );
    _ASSERT( m_pData != NULL );

    qsort( m_pData, m_nSize, sizeof(TYPE), compare );
}

#ifdef _DEBUG
template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::AssertValid() const
{
    if (m_pData == NULL)
    {
        _ASSERT( m_nSize == 0 );
        _ASSERT( m_nMaxSize == 0 );
    }
    else
    {
        _ASSERT( m_nSize >= 0 );
        _ASSERT( m_nMaxSize >= 0 );
        _ASSERT( m_nSize <= m_nMaxSize );
        _ASSERT( DXIsValidAddress(m_pData, m_nMaxSize * sizeof(TYPE), TRUE ) );
    }
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CDXList<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CDXList
{
protected:
    struct CNode
    {
        CNode* pNext;
        CNode* pPrev;
        TYPE data;
    };
public:

// Construction
    CDXList(int nBlockSize = 10);

// Attributes (head and tail)
    // count of elements
    int GetCount() const;
    BOOL IsEmpty() const;

    // peek at head or tail
    TYPE& GetHead();
    TYPE GetHead() const;
    TYPE& GetTail();
    TYPE GetTail() const;

// Operations
    // get head or tail (and remove it) - don't call on empty list !
    TYPE RemoveHead();
    TYPE RemoveTail();

    // add before head or after tail
    DXLISTPOS AddHead(ARG_TYPE newElement);
    DXLISTPOS AddTail(ARG_TYPE newElement);

    // add another list of elements before head or after tail
    void AddHead(CDXList* pNewList);
    void AddTail(CDXList* pNewList);

    // remove all elements
    void RemoveAll();

    // iteration
    DXLISTPOS GetHeadPosition() const;
    DXLISTPOS GetTailPosition() const;
    TYPE& GetNext(DXLISTPOS& rPosition); // return *Position++
    TYPE GetNext(DXLISTPOS& rPosition) const; // return *Position++
    TYPE& GetPrev(DXLISTPOS& rPosition); // return *Position--
    TYPE GetPrev(DXLISTPOS& rPosition) const; // return *Position--

    // getting/modifying an element at a given position
    TYPE& GetAt(DXLISTPOS position);
    TYPE GetAt(DXLISTPOS position) const;
    void SetAt(DXLISTPOS pos, ARG_TYPE newElement);
    void RemoveAt(DXLISTPOS position);

    // inserting before or after a given position
    DXLISTPOS InsertBefore(DXLISTPOS position, ARG_TYPE newElement);
    DXLISTPOS InsertAfter(DXLISTPOS position, ARG_TYPE newElement);

    // helper functions (note: O(n) speed)
    DXLISTPOS Find(ARG_TYPE searchValue, DXLISTPOS startAfter = NULL) const;
        // defaults to starting at the HEAD, return NULL if not found
    DXLISTPOS FindIndex(int nIndex) const;
        // get the 'nIndex'th element (may return NULL)

// Implementation
protected:
    CNode* m_pNodeHead;
    CNode* m_pNodeTail;
    int m_nCount;
    CNode* m_pNodeFree;
    struct CDXPlex* m_pBlocks;
    int m_nBlockSize;

    CNode* NewNode(CNode*, CNode*);
    void FreeNode(CNode*);

public:
    ~CDXList();
#ifdef _DEBUG
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CDXList<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CDXList<TYPE, ARG_TYPE>::GetCount() const
    { return m_nCount; }
template<class TYPE, class ARG_TYPE>
inline BOOL CDXList<TYPE, ARG_TYPE>::IsEmpty() const
    { return m_nCount == 0; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetHead()
    {   _ASSERT( m_pNodeHead != NULL );
        return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetHead() const
    {   _ASSERT( m_pNodeHead != NULL );
        return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetTail()
    {   _ASSERT( m_pNodeTail != NULL );
        return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetTail() const
    {   _ASSERT( m_pNodeTail != NULL );
        return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline DXLISTPOS CDXList<TYPE, ARG_TYPE>::GetHeadPosition() const
    { return (DXLISTPOS) m_pNodeHead; }
template<class TYPE, class ARG_TYPE>
inline DXLISTPOS CDXList<TYPE, ARG_TYPE>::GetTailPosition() const
    { return (DXLISTPOS) m_pNodeTail; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetNext(DXLISTPOS& rPosition) // return *Position++
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pNext;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetNext(DXLISTPOS& rPosition) const // return *Position++
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pNext;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetPrev(DXLISTPOS& rPosition) // return *Position--
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pPrev;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetPrev(DXLISTPOS& rPosition) const // return *Position--
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pPrev;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetAt(DXLISTPOS position)
    {   CNode* pNode = (CNode*) position;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetAt(DXLISTPOS position) const
    {   CNode* pNode = (CNode*) position;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline void CDXList<TYPE, ARG_TYPE>::SetAt(DXLISTPOS pos, ARG_TYPE newElement)
    {   CNode* pNode = (CNode*) pos;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        pNode->data = newElement; }

/////////////////////////////////////////////////////////////////////////////
// CDXList<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CDXList<TYPE, ARG_TYPE>::CDXList( int nBlockSize )
{
    _ASSERT( nBlockSize > 0 );

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::RemoveAll()
{
    DXASSERT_VALID( this );

    // destroy elements
    CNode* pNode;
    for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
        DXDestructElements(&pNode->data, 1);

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks->FreeDataChain();
    m_pBlocks = NULL;
}

template<class TYPE, class ARG_TYPE>
CDXList<TYPE, ARG_TYPE>::~CDXList()
{
    RemoveAll();
    _ASSERT( m_nCount == 0 );
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
//
// Implementation note: CNode's are stored in CDXPlex blocks and
//  chained together. Free blocks are maintained in a singly linked list
//  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
//  Used blocks are maintained in a doubly linked list using both 'pNext'
//  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
//   as the head/tail.
//
// We never free a CDXPlex block unless the List is destroyed or RemoveAll()
//  is used - so the total number of CDXPlex blocks may grow large depending
//  on the maximum past size of the list.
//

template<class TYPE, class ARG_TYPE>
typename CDXList<TYPE, ARG_TYPE>::CNode*
CDXList<TYPE, ARG_TYPE>::NewNode(CNode* pPrev, CNode* pNext)
{
    if (m_pNodeFree == NULL)
    {
        // add another block
        CDXPlex* pNewBlock = CDXPlex::Create(m_pBlocks, m_nBlockSize,
                 sizeof(CNode));

        // chain them into free list
        CNode* pNode = (CNode*) pNewBlock->data();
        // free in reverse order to make it easier to debug
        pNode += m_nBlockSize - 1;
        for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
        {
            pNode->pNext = m_pNodeFree;
            m_pNodeFree = pNode;
        }
    }
    _ASSERT( m_pNodeFree != NULL );  // we must have something

    CDXList::CNode* pNode = m_pNodeFree;
    m_pNodeFree = m_pNodeFree->pNext;
    pNode->pPrev = pPrev;
    pNode->pNext = pNext;
    m_nCount++;
    _ASSERT( m_nCount > 0 );  // make sure we don't overflow

    DXConstructElements(&pNode->data, 1);
    return pNode;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::FreeNode(CNode* pNode)
{
    DXDestructElements(&pNode->data, 1);
    pNode->pNext = m_pNodeFree;
    m_pNodeFree = pNode;
    m_nCount--;
    _ASSERT( m_nCount >= 0 );  // make sure we don't underflow
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    CNode* pNewNode = NewNode(NULL, m_pNodeHead);
    pNewNode->data = newElement;
    if (m_pNodeHead != NULL)
        m_pNodeHead->pPrev = pNewNode;
    else
        m_pNodeTail = pNewNode;
    m_pNodeHead = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    CNode* pNewNode = NewNode(m_pNodeTail, NULL);
    pNewNode->data = newElement;
    if (m_pNodeTail != NULL)
        m_pNodeTail->pNext = pNewNode;
    else
        m_pNodeHead = pNewNode;
    m_pNodeTail = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::AddHead(CDXList* pNewList)
{
    DXASSERT_VALID( this );
    DXASSERT_VALID( pNewList );

    // add a list of same elements to head (maintain order)
    DXLISTPOS pos = pNewList->GetTailPosition();
    while (pos != NULL)
        AddHead(pNewList->GetPrev(pos));
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::AddTail(CDXList* pNewList)
{
    DXASSERT_VALID( this );
    DXASSERT_VALID( pNewList );

    // add a list of same elements
    DXLISTPOS pos = pNewList->GetHeadPosition();
    while (pos != NULL)
        AddTail(pNewList->GetNext(pos));
}

template<class TYPE, class ARG_TYPE>
TYPE CDXList<TYPE, ARG_TYPE>::RemoveHead()
{
    DXASSERT_VALID( this );
    _ASSERT( m_pNodeHead != NULL );  // don't call on empty list !!!
    _ASSERT( DXIsValidAddress(m_pNodeHead, sizeof(CNode), TRUE ) );

    CNode* pOldNode = m_pNodeHead;
    TYPE returnValue = pOldNode->data;

    m_pNodeHead = pOldNode->pNext;
    if (m_pNodeHead != NULL)
        m_pNodeHead->pPrev = NULL;
    else
        m_pNodeTail = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

template<class TYPE, class ARG_TYPE>
TYPE CDXList<TYPE, ARG_TYPE>::RemoveTail()
{
    DXASSERT_VALID( this );
    _ASSERT( m_pNodeTail != NULL );  // don't call on empty list !!!
    _ASSERT( DXIsValidAddress(m_pNodeTail, sizeof(CNode), TRUE ) );

    CNode* pOldNode = m_pNodeTail;
    TYPE returnValue = pOldNode->data;

    m_pNodeTail = pOldNode->pPrev;
    if (m_pNodeTail != NULL)
        m_pNodeTail->pNext = NULL;
    else
        m_pNodeHead = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::InsertBefore(DXLISTPOS position, ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    if (position == NULL)
        return AddHead(newElement); // insert before nothing -> head of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
    pNewNode->data = newElement;

    if (pOldNode->pPrev != NULL)
    {
        _ASSERT( DXIsValidAddress(pOldNode->pPrev, sizeof(CNode), TRUE ) );
        pOldNode->pPrev->pNext = pNewNode;
    }
    else
    {
        _ASSERT( pOldNode == m_pNodeHead );
        m_pNodeHead = pNewNode;
    }
    pOldNode->pPrev = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::InsertAfter(DXLISTPOS position, ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    if (position == NULL)
        return AddTail(newElement); // insert after nothing -> tail of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    _ASSERT( DXIsValidAddress(pOldNode, sizeof(CNode), TRUE ));
    CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
    pNewNode->data = newElement;

    if (pOldNode->pNext != NULL)
    {
        _ASSERT( DXIsValidAddress(pOldNode->pNext, sizeof(CNode), TRUE ));
        pOldNode->pNext->pPrev = pNewNode;
    }
    else
    {
        _ASSERT( pOldNode == m_pNodeTail );
        m_pNodeTail = pNewNode;
    }
    pOldNode->pNext = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::RemoveAt(DXLISTPOS position)
{
    DXASSERT_VALID( this );

    CNode* pOldNode = (CNode*) position;
    _ASSERT( DXIsValidAddress(pOldNode, sizeof(CNode), TRUE ) );

    // remove pOldNode from list
    if (pOldNode == m_pNodeHead)
    {
        m_pNodeHead = pOldNode->pNext;
    }
    else
    {
        _ASSERT( DXIsValidAddress(pOldNode->pPrev, sizeof(CNode), TRUE ) );
        pOldNode->pPrev->pNext = pOldNode->pNext;
    }
    if (pOldNode == m_pNodeTail)
    {
        m_pNodeTail = pOldNode->pPrev;
    }
    else
    {
        _ASSERT( DXIsValidAddress(pOldNode->pNext, sizeof(CNode), TRUE ) );
        pOldNode->pNext->pPrev = pOldNode->pPrev;
    }
    FreeNode(pOldNode);
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::FindIndex(int nIndex) const
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );

    if (nIndex >= m_nCount)
        return NULL;  // went too far

    CNode* pNode = m_pNodeHead;
    while (nIndex--)
    {
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ));
        pNode = pNode->pNext;
    }
    return (DXLISTPOS) pNode;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, DXLISTPOS startAfter) const
{
    DXASSERT_VALID( this );

    CNode* pNode = (CNode*) startAfter;
    if (pNode == NULL)
    {
        pNode = m_pNodeHead;  // start at head
    }
    else
    {
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        pNode = pNode->pNext;  // start after the one specified
    }

    for (; pNode != NULL; pNode = pNode->pNext)
        if (DXCompareElements(&pNode->data, &searchValue))
            return (DXLISTPOS)pNode;
    return NULL;
}

#ifdef _DEBUG
template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::AssertValid() const
{
    if (m_nCount == 0)
    {
        // empty list
        _ASSERT( m_pNodeHead == NULL );
        _ASSERT( m_pNodeTail == NULL );
    }
    else
    {
        // non-empty list
        _ASSERT( DXIsValidAddress(m_pNodeHead, sizeof(CNode), TRUE ));
        _ASSERT( DXIsValidAddress(m_pNodeTail, sizeof(CNode), TRUE ));
    }
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CDXMap
{
protected:
    // Association
    struct CAssoc
    {
        CAssoc* pNext;
        UINT nHashValue;  // needed for efficient iteration
        KEY key;
        VALUE value;
    };
public:
// Construction
    CDXMap( int nBlockSize = 10 );

// Attributes
    // number of elements
    int GetCount() const;
    BOOL IsEmpty() const;

    // Lookup
    BOOL Lookup(ARG_KEY key, VALUE& rValue) const;

// Operations
    // Lookup and add if not there
    VALUE& operator[](ARG_KEY key);

    // add a new (key, value) pair
    void SetAt(ARG_KEY key, ARG_VALUE newValue);

    // removing existing (key, ?) pair
    BOOL RemoveKey(ARG_KEY key);
    void RemoveAll();

    // iterating all (key, value) pairs
    DXLISTPOS GetStartPosition() const;
    void GetNextAssoc(DXLISTPOS& rNextPosition, KEY& rKey, VALUE& rValue) const;

    // advanced features for derived classes
    UINT GetHashTableSize() const;
    void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Implementation
protected:
    CAssoc** m_pHashTable;
    UINT m_nHashTableSize;
    int m_nCount;
    CAssoc* m_pFreeList;
    struct CDXPlex* m_pBlocks;
    int m_nBlockSize;

    CAssoc* NewAssoc();
    void FreeAssoc(CAssoc*);
    CAssoc* GetAssocAt(ARG_KEY, UINT&) const;

public:
    ~CDXMap();
#ifdef _DEBUG
//  void Dump(CDumpContext&) const;
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE> inline functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline int CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCount() const
    { return m_nCount; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline BOOL CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::IsEmpty() const
    { return m_nCount == 0; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
    { (*this)[key] = newValue; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline DXLISTPOS CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetStartPosition() const
    { return (m_nCount == 0) ? NULL : DX_BEFORE_START_POSITION; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline UINT CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetHashTableSize() const
    { return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////
// CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE> out-of-line functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CDXMap( int nBlockSize )
{
    _ASSERT( nBlockSize > 0 );

    m_pHashTable = NULL;
    m_nHashTableSize = 17;  // default size
    m_nCount = 0;
    m_pFreeList = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(
    UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
    DXASSERT_VALID( this );
    _ASSERT( m_nCount == 0 );
    _ASSERT( nHashSize > 0 );

    if (m_pHashTable != NULL)
    {
        // free hash table
        delete[] m_pHashTable;
        m_pHashTable = NULL;
    }

    if (bAllocNow)
    {
        m_pHashTable = new CAssoc* [nHashSize];

        // oh well, it's better than crashing
        if (m_pHashTable == NULL)
            return;

        memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
    }
    m_nHashTableSize = nHashSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveAll()
{
    DXASSERT_VALID( this );

    if (m_pHashTable != NULL)
    {
        // destroy elements (values and keys)
        for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
        {
            CAssoc* pAssoc;
            for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
              pAssoc = pAssoc->pNext)
            {
                DXDestructElements(&pAssoc->value, 1);
                DXDestructElements(&pAssoc->key, 1);
            }
        }
    }

    // free hash table
    delete[] m_pHashTable;
    m_pHashTable = NULL;

    m_nCount = 0;
    m_pFreeList = NULL;
    m_pBlocks->FreeDataChain();
    m_pBlocks = NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::~CDXMap()
{
    RemoveAll();
    _ASSERT( m_nCount == 0 );
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::NewAssoc()
{
    if (m_pFreeList == NULL)
    {
        // add another block
        CDXPlex* newBlock = CDXPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CDXMap::CAssoc));
        // chain them into free list
        CDXMap::CAssoc* pAssoc = (CDXMap::CAssoc*) newBlock->data();
        // free in reverse order to make it easier to debug
        pAssoc += m_nBlockSize - 1;
        for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
        {
            pAssoc->pNext = m_pFreeList;
            m_pFreeList = pAssoc;
        }
    }
    _ASSERT( m_pFreeList != NULL );  // we must have something

    CDXMap::CAssoc* pAssoc = m_pFreeList;
    m_pFreeList = m_pFreeList->pNext;
    m_nCount++;
    _ASSERT( m_nCount > 0 );  // make sure we don't overflow
    DXConstructElements(&pAssoc->key, 1);
    DXConstructElements(&pAssoc->value, 1);   // special construct values
    return pAssoc;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::FreeAssoc(CAssoc* pAssoc)
{
    DXDestructElements(&pAssoc->value, 1);
    DXDestructElements(&pAssoc->key, 1);
    pAssoc->pNext = m_pFreeList;
    m_pFreeList = pAssoc;
    m_nCount--;
    _ASSERT( m_nCount >= 0 );  // make sure we don't underflow
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetAssocAt(ARG_KEY key, UINT& nHash) const
// find association (or return NULL)
{
    nHash = DXHashKey(key) % m_nHashTableSize;

    if (m_pHashTable == NULL)
        return NULL;

    // see if it exists
    CAssoc* pAssoc;
    for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
    {
        if (DXCompareElements(&pAssoc->key, &key))
            return pAssoc;
    }
    return NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Lookup(ARG_KEY key, VALUE& rValue) const
{
    DXASSERT_VALID( this );

    UINT nHash;
    CAssoc* pAssoc = GetAssocAt(key, nHash);
    if (pAssoc == NULL)
        return FALSE;  // not in map

    rValue = pAssoc->value;
    return TRUE;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::operator[](ARG_KEY key)
{
    DXASSERT_VALID( this );

    UINT nHash;
    CAssoc* pAssoc;
    if ((pAssoc = GetAssocAt(key, nHash)) == NULL)
    {
        if (m_pHashTable == NULL)
            InitHashTable(m_nHashTableSize);

        // it doesn't exist, add a new Association
        pAssoc = NewAssoc();
        pAssoc->nHashValue = nHash;
        pAssoc->key = key;
        // 'pAssoc->value' is a constructed object, nothing more

        // put into hash table
        pAssoc->pNext = m_pHashTable[nHash];
        m_pHashTable[nHash] = pAssoc;
    }
    return pAssoc->value;  // return new reference
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveKey(ARG_KEY key)
// remove key - return TRUE if removed
{
    DXASSERT_VALID( this );

    if (m_pHashTable == NULL)
        return FALSE;  // nothing in the table

    CAssoc** ppAssocPrev;
    ppAssocPrev = &m_pHashTable[DXHashKey(key) % m_nHashTableSize];

    CAssoc* pAssoc;
    for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
    {
        if (DXCompareElements(&pAssoc->key, &key))
        {
            // remove it
            *ppAssocPrev = pAssoc->pNext;  // remove from list
            FreeAssoc(pAssoc);
            return TRUE;
        }
        ppAssocPrev = &pAssoc->pNext;
    }
    return FALSE;  // not found
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetNextAssoc(DXLISTPOS& rNextPosition,
    KEY& rKey, VALUE& rValue) const
{
    DXASSERT_VALID( this );
    _ASSERT( m_pHashTable != NULL );  // never call on empty map

    CAssoc* pAssocRet = (CAssoc*)rNextPosition;
    _ASSERT( pAssocRet != NULL );

    if (pAssocRet == (CAssoc*) DX_BEFORE_START_POSITION)
    {
        // find the first association
        for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
            if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
                break;
        _ASSERT( pAssocRet != NULL );  // must find something
    }

    // find next association
    _ASSERT( DXIsValidAddress(pAssocRet, sizeof(CAssoc), TRUE ));
    CAssoc* pAssocNext;
    if ((pAssocNext = pAssocRet->pNext) == NULL)
    {
        // go to next bucket
        for (UINT nBucket = pAssocRet->nHashValue + 1;
          nBucket < m_nHashTableSize; nBucket++)
            if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
                break;
    }

    rNextPosition = (DXLISTPOS) pAssocNext;

    // fill in return data
    rKey = pAssocRet->key;
    rValue = pAssocRet->value;
}

#ifdef _DEBUG
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::AssertValid() const
{
    _ASSERT( m_nHashTableSize > 0 );
    _ASSERT( (m_nCount == 0 || m_pHashTable != NULL) );
        // non-empty map should have hash table
}
#endif //_DEBUG

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dxva2trace.h ===
//------------------------------------------------------------------------------
// File: dxva2Trace.h
//
// Desc: DirectX Video Acceleration 2 header file for ETW data
//
// Copyright (c) 1999 - 2005, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------

#ifndef __inc_dxva2Trace_h
#define __inc_dxva2Trace_h

#ifdef __cplusplus
extern "C" {
#endif

DEFINE_GUID(DXVA2Trace_Control, 0xa0386e75,0xf70c,0x464c,
    0xa9, 0xce, 0x33, 0xc4, 0x4e, 0x09, 0x16, 0x23);

// -------------------------------------------------------------------------
// DXVA2 Video Decoder ETW definitions
//
// There are event for:
//      Device creation
//      Device destruction
//
// When the device is being used there are events for:
//      Begin frame
//      Begin execute
//      End execute
//      End frame
// -------------------------------------------------------------------------
//
typedef struct {
#ifndef DXVA2Trace_PostProcessing
    EVENT_TRACE_HEADER  wmiHeader;
#endif
    ULONGLONG           pObject;
    ULONGLONG           pD3DDevice;
    GUID                DeviceGuid;
    ULONG               Width;
    ULONG               Height;
    BOOL                Enter;
} DXVA2Trace_DecodeDevCreatedData;

typedef struct {
#ifndef DXVA2Trace_PostProcessing
    EVENT_TRACE_HEADER  wmiHeader;
#endif
    ULONGLONG           pObject;
    BOOL                Enter;
} DXVA2Trace_DecodeDeviceData;

typedef DXVA2Trace_DecodeDeviceData DXVA2Trace_DecodeDevDestroyedData;
typedef DXVA2Trace_DecodeDeviceData DXVA2Trace_DecodeDevExecuteData;
typedef DXVA2Trace_DecodeDeviceData DXVA2Trace_DecodeDevEndFrameData;

typedef struct {
#ifndef DXVA2Trace_PostProcessing
    EVENT_TRACE_HEADER  wmiHeader;
#endif
    ULONGLONG           pObject;
    ULONGLONG           pRenderTarget;
    BOOL                Enter;
} DXVA2Trace_DecodeDevBeginFrameData;

typedef struct {
#ifndef DXVA2Trace_PostProcessing
    EVENT_TRACE_HEADER  wmiHeader;
#endif
    ULONGLONG           pObject;
    UINT                BufferType;
    BOOL                Enter;
} DXVA2Trace_DecodeDevGetBufferData;

DEFINE_GUID(DXVA2Trace_DecodeDevCreated, 0xb4de17a1,0xc5b2,0x44fe,
            0x86, 0xd5, 0xd9, 0x7a, 0x64, 0x81, 0x14, 0xff);

DEFINE_GUID(DXVA2Trace_DecodeDevDestroyed, 0x853ebdf2,0x4160,0x421d,
            0x88, 0x93, 0x63, 0xdc, 0xea, 0x4f, 0x18, 0xbb);

DEFINE_GUID(DXVA2Trace_DecodeDevBeginFrame, 0x9fd1acf6,0x44cb,0x4637,
            0xbc, 0x62, 0x2c, 0x11, 0xa9, 0x60, 0x8f, 0x90);

DEFINE_GUID(DXVA2Trace_DecodeDevExecute,0x850aeb4c,0xd19a,0x4609,
            0xb3, 0xb4, 0xbc, 0xbf, 0x0e, 0x22, 0x12, 0x1e);

DEFINE_GUID(DXVA2Trace_DecodeDevGetBuffer,0x57b128fb,0x72cb,0x4137,
            0xa5, 0x75, 0xd9, 0x1f, 0xa3, 0x16, 0x08, 0x97);

DEFINE_GUID(DXVA2Trace_DecodeDevEndFrame, 0x9fb3cb33,0x47dc,0x4899,
            0x98, 0xc8, 0xc0, 0xc6, 0xcd, 0x7c, 0xd3, 0xcb);



// -------------------------------------------------------------------------
// DXVA2 Video Processing ETW definitions
//
// There are event for:
//      Device creation
//      Device destruction
//
// When the device is being used there are events for:
//      Begin VideoProcessBlt
//      End VideoProcessBlt
// -------------------------------------------------------------------------
//
typedef struct {
#ifndef DXVA2Trace_PostProcessing
    EVENT_TRACE_HEADER  wmiHeader;
#endif
    ULONGLONG           pObject;
    ULONGLONG           pD3DDevice;
    GUID                DeviceGuid;
    ULONG               RTFourCC;
    ULONG               Width;
    ULONG               Height;
    BOOL                Enter;
} DXVA2Trace_VideoProcessDevCreatedData;

typedef struct {
#ifndef DXVA2Trace_PostProcessing
    EVENT_TRACE_HEADER  wmiHeader;
#endif
    ULONGLONG           pObject;
    BOOL                Enter;
} DXVA2Trace_VideoProcessDeviceData;
typedef DXVA2Trace_VideoProcessDeviceData DXVA2Trace_VideoProcessDevDestroyedData;
typedef DXVA2Trace_VideoProcessDeviceData DXVA2Trace_VideoProcessBltEndData;

typedef struct {
#ifndef DXVA2Trace_PostProcessing
    EVENT_TRACE_HEADER  wmiHeader;
#endif
    ULONGLONG           pObject;
    ULONGLONG           pRenderTarget;
    ULONGLONG           TargetFrameTime;
    RECT                TargetRect;
    BOOL                Enter;
} DXVA2TraceVideoProcessBltData;
#define DXVA2TraceVideoProcessBltDataData DXVA2TraceVideoProcessBltData;

DEFINE_GUID(DXVA2Trace_VideoProcessDevCreated, 0x895508c6,0x540d,0x4c87,
            0x98, 0xf8, 0x8d, 0xcb, 0xf2, 0xda, 0xbb, 0x2a);

DEFINE_GUID(DXVA2Trace_VideoProcessDevDestroyed, 0xf97f30b1,0xfb49,0x42c7,
            0x8e, 0xe8, 0x88, 0xbd, 0xfa, 0x92, 0xd4, 0xe2);

DEFINE_GUID(DXVA2Trace_VideoProcessBlt, 0x69089cc0,0x71ab,0x42d0,
            0x95, 0x3a, 0x28, 0x87, 0xbf, 0x05, 0xa8, 0xaf);

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dxva.h ===
//------------------------------------------------------------------------------
// File: DXVA.h
//
// Desc: DirectX Video Acceleration header file.
//
// Copyright (c) 1999 - 2002, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __DIRECTX_VA__
#define __DIRECTX_VA__

#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning(disable:4201) // named type definition in parentheses

#ifdef __cplusplus
extern "C" {
#endif

#ifdef __DIRECTX_VA_COPP_ONLY
#define __DIRECTX_VA_DECODER__
#define __DIRECTX_VA_PROCAMPCONTROL__
#define __DIRECTX_VA_DEINTERLACE__
#endif

#ifndef DXVABit
#define DXVABit(__x) (1 << __x)
#endif

// -------------------------------------------------------------------------
//
// The definitions that follow describe the DirectX Video Acceleration
// decoding interface.
// This interface is accessable via the IAMVideoAccelerator interface.
//
// -------------------------------------------------------------------------
//
#ifndef __DIRECTX_VA_DECODER__
#define __DIRECTX_VA_DECODER__

DEFINE_GUID(DXVA_ModeNone,    0x1b81be00, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH261_A,  0x1b81be01, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH261_B,  0x1b81be02, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

DEFINE_GUID(DXVA_ModeH263_A,  0x1b81be03, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_B,  0x1b81be04, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_C,  0x1b81be05, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_D,  0x1b81be06, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_E,  0x1b81be07, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH263_F,  0x1b81be08, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

DEFINE_GUID(DXVA_ModeMPEG1_A, 0x1b81be09, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

DEFINE_GUID(DXVA_ModeMPEG2_A, 0x1b81be0A, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeMPEG2_B, 0x1b81be0B, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeMPEG2_C, 0x1b81be0C, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeMPEG2_D, 0x1b81be0D, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

DEFINE_GUID(DXVA_ModeH264_A,  0x1b81be64, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH264_B,  0x1b81be65, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH264_C,  0x1b81be66, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH264_D,  0x1b81be67, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH264_E,  0x1b81be68, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeH264_F,  0x1b81be69, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

DEFINE_GUID(DXVA_ModeWMV8_A,  0x1b81be80, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeWMV8_B,  0x1b81be81, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

DEFINE_GUID(DXVA_ModeWMV9_A,  0x1b81be90, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeWMV9_B,  0x1b81be91, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeWMV9_C,  0x1b81be94, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

DEFINE_GUID(DXVA_ModeVC1_A,   0x1b81beA0, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeVC1_B,   0x1b81beA1, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeVC1_C,   0x1b81beA2, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);
DEFINE_GUID(DXVA_ModeVC1_D,   0x1b81beA3, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

DEFINE_GUID(DXVA_NoEncrypt,   0x1b81beD0, 0xa0c7,0x11d3,0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);

#define DXVA_ModeWMV8_PostProc                  DXVA_ModeWMV8_A
#define DXVA_ModeWMV8_MoComp                    DXVA_ModeWMV8_B

#define DXVA_ModeWMV9_PostProc                  DXVA_ModeWMV9_A
#define DXVA_ModeWMV9_MoComp                    DXVA_ModeWMV9_B
#define DXVA_ModeWMV9_IDCT                      DXVA_ModeWMV9_C

#define DXVA_ModeVC1_PostProc                   DXVA_ModeVC1_A
#define DXVA_ModeVC1_MoComp                     DXVA_ModeVC1_B
#define DXVA_ModeVC1_IDCT                       DXVA_ModeVC1_C
#define DXVA_ModeVC1_VLD                        DXVA_ModeVC1_D

#define DXVA_ModeH264_MoComp_NoFGT              DXVA_ModeH264_A
#define DXVA_ModeH264_MoComp_FGT                DXVA_ModeH264_B
#define DXVA_ModeH264_IDCT_NoFGT                DXVA_ModeH264_C
#define DXVA_ModeH264_IDCT_FGT                  DXVA_ModeH264_D
#define DXVA_ModeH264_VLD_NoFGT                 DXVA_ModeH264_E
#define DXVA_ModeH264_VLD_FGT                   DXVA_ModeH264_F

#define DXVA_RESTRICTED_MODE_UNRESTRICTED       0xFFFF
#define DXVA_RESTRICTED_MODE_H261_A             1
#define DXVA_RESTRICTED_MODE_H261_B             2

#define DXVA_RESTRICTED_MODE_H263_A             3
#define DXVA_RESTRICTED_MODE_H263_B             4
#define DXVA_RESTRICTED_MODE_H263_C             5
#define DXVA_RESTRICTED_MODE_H263_D             6
#define DXVA_RESTRICTED_MODE_H263_E             7
#define DXVA_RESTRICTED_MODE_H263_F             8

#define DXVA_RESTRICTED_MODE_MPEG1_A            9

#define DXVA_RESTRICTED_MODE_MPEG2_A            0xA
#define DXVA_RESTRICTED_MODE_MPEG2_B            0xB
#define DXVA_RESTRICTED_MODE_MPEG2_C            0xC
#define DXVA_RESTRICTED_MODE_MPEG2_D            0xD

#define DXVA_RESTRICTED_MODE_H264_A             0x64
#define DXVA_RESTRICTED_MODE_H264_B             0x65
#define DXVA_RESTRICTED_MODE_H264_C             0x66
#define DXVA_RESTRICTED_MODE_H264_D             0x67
#define DXVA_RESTRICTED_MODE_H264_E             0x68
#define DXVA_RESTRICTED_MODE_H264_F             0x69

#define DXVA_RESTRICTED_MODE_WMV8_A             0x80
#define DXVA_RESTRICTED_MODE_WMV8_B             0x81

#define DXVA_RESTRICTED_MODE_WMV9_A             0x90
#define DXVA_RESTRICTED_MODE_WMV9_B             0x91
#define DXVA_RESTRICTED_MODE_WMV9_C             0x94

#define DXVA_RESTRICTED_MODE_VC1_A              0xA0
#define DXVA_RESTRICTED_MODE_VC1_B              0xA1
#define DXVA_RESTRICTED_MODE_VC1_C              0xA2
#define DXVA_RESTRICTED_MODE_VC1_D              0xA3

#define DXVA_RESTRICTED_MODE_WMV8_POSTPROC      DXVA_RESTRICTED_MODE_WMV8_A
#define DXVA_RESTRICTED_MODE_WMV8_MOCOMP        DXVA_RESTRICTED_MODE_WMV8_B

#define DXVA_RESTRICTED_MODE_WMV9_POSTPROC      DXVA_RESTRICTED_MODE_WMV9_A
#define DXVA_RESTRICTED_MODE_WMV9_MOCOMP        DXVA_RESTRICTED_MODE_WMV9_B
#define DXVA_RESTRICTED_MODE_WMV9_IDCT          DXVA_RESTRICTED_MODE_WMV9_C

#define DXVA_RESTRICTED_MODE_VC1_POSTPROC       DXVA_RESTRICTED_MODE_VC1_A
#define DXVA_RESTRICTED_MODE_VC1_MOCOMP         DXVA_RESTRICTED_MODE_VC1_B
#define DXVA_RESTRICTED_MODE_VC1_IDCT           DXVA_RESTRICTED_MODE_VC1_C
#define DXVA_RESTRICTED_MODE_VC1_VLD            DXVA_RESTRICTED_MODE_VC1_D

#define DXVA_RESTRICTED_MODE_H264_MOCOMP_NOFGT  DXVA_RESTRICTED_MODE_H264_A
#define DXVA_RESTRICTED_MODE_H264_MOCOMP_FGT    DXVA_RESTRICTED_MODE_H264_B
#define DXVA_RESTRICTED_MODE_H264_IDCT_NOFGT    DXVA_RESTRICTED_MODE_H264_C
#define DXVA_RESTRICTED_MODE_H264_IDCT_FGT      DXVA_RESTRICTED_MODE_H264_D
#define DXVA_RESTRICTED_MODE_H264_VLD_NOFGT     DXVA_RESTRICTED_MODE_H264_E
#define DXVA_RESTRICTED_MODE_H264_VLD_FGT       DXVA_RESTRICTED_MODE_H264_F

#define DXVA_COMPBUFFER_TYPE_THAT_IS_NOT_USED    0
#define DXVA_PICTURE_DECODE_BUFFER               1
#define DXVA_MACROBLOCK_CONTROL_BUFFER           2
#define DXVA_RESIDUAL_DIFFERENCE_BUFFER          3
#define DXVA_DEBLOCKING_CONTROL_BUFFER           4
#define DXVA_INVERSE_QUANTIZATION_MATRIX_BUFFER  5
#define DXVA_SLICE_CONTROL_BUFFER                6
#define DXVA_BITSTREAM_DATA_BUFFER               7
#define DXVA_AYUV_BUFFER                         8
#define DXVA_IA44_SURFACE_BUFFER                 9
#define DXVA_DPXD_SURFACE_BUFFER                10
#define DXVA_HIGHLIGHT_BUFFER                   11
#define DXVA_DCCMD_SURFACE_BUFFER               12
#define DXVA_ALPHA_BLEND_COMBINATION_BUFFER     13
#define DXVA_PICTURE_RESAMPLE_BUFFER            14
#define DXVA_READ_BACK_BUFFER                   15

/* H.264/AVC Additional buffer types */
#define DXVA_MOTION_VECTOR_BUFFER               16
#define DXVA_FILM_GRAIN_BUFFER                  17

#define DXVA_NUM_TYPES_COMP_BUFFERS             18

/* values for bDXVA_Func */
#define DXVA_PICTURE_DECODING_FUNCTION        1
#define DXVA_ALPHA_BLEND_DATA_LOAD_FUNCTION   2
#define DXVA_ALPHA_BLEND_COMBINATION_FUNCTION 3
#define DXVA_PICTURE_RESAMPLE_FUNCTION        4
#define DXVA_DEBLOCKING_FILTER_FUNCTION       5
#define DXVA_FILM_GRAIN_SYNTHESIS_FUNCTION    6
#define DXVA_STATUS_REPORTING_FUNCTION        7

/* values returned from Execute command in absence of read-back */
#define DXVA_EXECUTE_RETURN_OK                  0
#define DXVA_EXECUTE_RETURN_DATA_ERROR_MINOR    1
#define DXVA_EXECUTE_RETURN_DATA_ERROR_SIGNIF   2
#define DXVA_EXECUTE_RETURN_DATA_ERROR_SEVERE   3
#define DXVA_EXECUTE_RETURN_OTHER_ERROR_SEVERE  4


#pragma pack(push, BeforeDXVApacking, 1)


typedef struct _DXVA_ConnectMode {
  GUID guidMode;
  WORD wRestrictedMode;
} DXVA_ConnectMode, *LPDXVA_ConnectMode;


typedef DWORD DXVA_ConfigQueryOrReplyFunc, *LPDXVA_ConfigQueryOrReplyFunc;

#define DXVA_QUERYORREPLYFUNCFLAG_DECODER_PROBE_QUERY     0xFFFFF1
#define DXVA_QUERYORREPLYFUNCFLAG_DECODER_LOCK_QUERY      0xFFFFF5
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_OK_COPY     0xFFFFF8
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_OK_PLUS     0xFFFFF9
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_OK_COPY      0xFFFFFC
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_PROBE_FALSE_PLUS  0xFFFFFB
#define DXVA_QUERYORREPLYFUNCFLAG_ACCEL_LOCK_FALSE_PLUS   0xFFFFFF

#define readDXVA_QueryOrReplyFuncFlag(ptr)        ((*(ptr)) >> 8)

#define readDXVA_QueryOrReplyFuncFlag_ACCEL(ptr)  (((*(ptr)) >> 11) & 1)
#define readDXVA_QueryOrReplyFuncFlag_LOCK(ptr)   (((*(ptr)) >> 10) & 1)
#define readDXVA_QueryOrReplyFuncFlag_BAD(ptr)    (((*(ptr)) >>  9) & 1)
#define readDXVA_QueryOrReplyFuncFlag_PLUS(ptr)   (((*(ptr)) >>  8) & 1)

#define readDXVA_QueryOrReplyFuncFunc(ptr)        ((*(ptr)) & 0xFF)

#define writeDXVA_QueryOrReplyFunc(ptr, flg, fnc) ((*(ptr)) = ((flg) << 8) | (fnc))

#define setDXVA_QueryOrReplyFuncFlag(ptr, flg) ((*(ptr)) |= ((flg) << 8))
#define setDXVA_QueryOrReplyFuncFunc(ptr, fnc) ((*(ptr)) |= (fnc));

typedef DWORD DXVA_EncryptProtocolFunc, *LPDXVA_EncryptProtocolFunc;

#define DXVA_ENCRYPTPROTOCOLFUNCFLAG_HOST    0xFFFF00
#define DXVA_ENCRYPTPROTOCOLFUNCFLAG_ACCEL   0xFFFF08

#define readDXVA_EncryptProtocolFuncFlag(ptr)        ((*(ptr)) >> 8)
#define readDXVA_EncryptProtocolFuncFlag_ACCEL(ptr)  (((*(ptr)) >> 11) & 1)

#define readDXVA_EncryptProtocolFuncFunc(ptr)        ((*(ptr)) & 0xFF)

#define writeDXVA_EncryptProtocolFunc(ptr, flg, fnc) ((*(ptr)) = ((flg) << 8) | (fnc))

#define setDXVA_EncryptProtocolFuncFlag(ptr, flg) ((*(ptr)) |= ((flg) << 8))
#define setDXVA_EncryptProtocolFuncFunc(ptr, fnc) ((*(ptr)) |= (fnc));

typedef struct _DXVA_EncryptProtocolHeader {
  DXVA_EncryptProtocolFunc dwFunction;
  DWORD ReservedBits[3];
  GUID  guidEncryptProtocol;
} DXVA_EncryptProtocolHeader, *LPDXVA_EncryptProtocolHeader;

typedef struct _DXVA_ConfigPictureDecode {

  // Operation Indicated
  DXVA_ConfigQueryOrReplyFunc dwFunction;

  // Alignment
  DWORD dwReservedBits[3];

  // Encryption GUIDs
  GUID guidConfigBitstreamEncryption;
  GUID guidConfigMBcontrolEncryption;
  GUID guidConfigResidDiffEncryption;

  // Bitstream Processing Indicator
  BYTE bConfigBitstreamRaw;

  // Macroblock Control Config
  BYTE bConfigMBcontrolRasterOrder;

  // Host Resid Diff Config
  BYTE bConfigResidDiffHost;
  BYTE bConfigSpatialResid8;
  BYTE bConfigResid8Subtraction;
  BYTE bConfigSpatialHost8or9Clipping;
  BYTE bConfigSpatialResidInterleaved;
  BYTE bConfigIntraResidUnsigned;

  // Accelerator Resid Diff Config
  BYTE bConfigResidDiffAccelerator;
  BYTE bConfigHostInverseScan;
  BYTE bConfigSpecificIDCT;
  BYTE bConfig4GroupedCoefs;
} DXVA_ConfigPictureDecode, *LPDXVA_ConfigPictureDecode;


/* Picture Decoding Parameters */

typedef struct _DXVA_PictureParameters {

  WORD wDecodedPictureIndex;
  WORD wDeblockedPictureIndex;

  WORD wForwardRefPictureIndex;
  WORD wBackwardRefPictureIndex;

  WORD wPicWidthInMBminus1;
  WORD wPicHeightInMBminus1;

  BYTE bMacroblockWidthMinus1;
  BYTE bMacroblockHeightMinus1;

  BYTE bBlockWidthMinus1;
  BYTE bBlockHeightMinus1;

  BYTE bBPPminus1;

  BYTE bPicStructure;
  BYTE bSecondField;
  BYTE bPicIntra;
  BYTE bPicBackwardPrediction;

  BYTE bBidirectionalAveragingMode;
  BYTE bMVprecisionAndChromaRelation;
  BYTE bChromaFormat;

  BYTE bPicScanFixed;
  BYTE bPicScanMethod;
  BYTE bPicReadbackRequests;

  BYTE bRcontrol;
  BYTE bPicSpatialResid8;
  BYTE bPicOverflowBlocks;
  BYTE bPicExtrapolation;

  BYTE bPicDeblocked;
  BYTE bPicDeblockConfined;
  BYTE bPic4MVallowed;
  BYTE bPicOBMC;
  BYTE bPicBinPB;
  BYTE bMV_RPS;

  BYTE bReservedBits;

  WORD wBitstreamFcodes;
  WORD wBitstreamPCEelements;
  BYTE bBitstreamConcealmentNeed;
  BYTE bBitstreamConcealmentMethod;

} DXVA_PictureParameters, *LPDXVA_PictureParameters;



/* Picture Resampling */

typedef struct _DXVA_PicResample {

  WORD  wPicResampleSourcePicIndex;
  WORD  wPicResampleDestPicIndex;

  WORD  wPicResampleRcontrol;
  BYTE  bPicResampleExtrapWidth;
  BYTE  bPicResampleExtrapHeight;

  DWORD dwPicResampleSourceWidth;
  DWORD dwPicResampleSourceHeight;

  DWORD dwPicResampleDestWidth;
  DWORD dwPicResampleDestHeight;

  DWORD dwPicResampleFullDestWidth;
  DWORD dwPicResampleFullDestHeight;

} DXVA_PicResample, *LPDXVA_PicResample;


#define DXVA_CHROMA_FORMAT_420 1
#define DXVA_CHROMA_FORMAT_422 2
#define DXVA_CHROMA_FORMAT_444 3

#define DXVA_PICTURE_STRUCTURE_TOP_FIELD    1
#define DXVA_PICTURE_STRUCTURE_BOTTOM_FIELD 2
#define DXVA_PICTURE_STRUCTURE_FRAME        3

#define DXVA_BIDIRECTIONAL_AVERAGING_MPEG2_ROUND 0
#define DXVA_BIDIRECTIONAL_AVERAGING_H263_TRUNC  1

#define DXVA_MV_PRECISION_AND_CHROMA_RELATION_MPEG2  0
#define DXVA_MV_PRECISION_AND_CHROMA_RELATION_H263   1
#define DXVA_MV_PRECISION_AND_CHROMA_RELATION_H261   2

#define DXVA_SCAN_METHOD_ZIG_ZAG              0
#define DXVA_SCAN_METHOD_ALTERNATE_VERTICAL   1
#define DXVA_SCAN_METHOD_ALTERNATE_HORIZONTAL 2
#define DXVA_SCAN_METHOD_ARBITRARY            3

#define DXVA_BITSTREAM_CONCEALMENT_NEED_UNLIKELY 0
#define DXVA_BITSTREAM_CONCEALMENT_NEED_MILD     1
#define DXVA_BITSTREAM_CONCEALMENT_NEED_LIKELY   2
#define DXVA_BITSTREAM_CONCEALMENT_NEED_SEVERE   3

#define DXVA_BITSTREAM_CONCEALMENT_METHOD_UNSPECIFIED 0
#define DXVA_BITSTREAM_CONCEALMENT_METHOD_INTRA       1
#define DXVA_BITSTREAM_CONCEALMENT_METHOD_FORWARD     2
#define DXVA_BITSTREAM_CONCEALMENT_METHOD_BACKWARD    3


/* Buffer Description Data */

typedef struct _DXVA_BufferDescription {
  DWORD dwTypeIndex;
  DWORD dwBufferIndex;
  DWORD dwDataOffset;
  DWORD dwDataSize;
  DWORD dwFirstMBaddress;
  DWORD dwNumMBsInBuffer;
  DWORD dwWidth;
  DWORD dwHeight;
  DWORD dwStride;
  DWORD dwReservedBits;
} DXVA_BufferDescription, *LPDXVA_BufferDescription;


/* Off-Host IDCT Coefficient Data Structures */

typedef struct _DXVA_TCoef4Group {
  BYTE  TCoefIDX[4];
  SHORT TCoefValue[4];
} DXVA_TCoef4Group, *LPDXVA_TCoef4Group;

typedef struct _DXVA_TCoefSingle {
  WORD  wIndexWithEOB;
  SHORT TCoefValue;
} DXVA_TCoefSingle, *LPDXVA_TCoefSingle;

/* Macros for Reading EOB and Index Values */

#define readDXVA_TCoefSingleIDX(ptr) ((ptr)->wIndexWithEOB >> 1)
#define readDXVA_TCoefSingleEOB(ptr) ((ptr)->wIndexWithEOB & 1)

/* Macro for Writing EOB and Index Values */

#define writeDXVA_TCoefSingleIndexWithEOB(ptr, idx, eob) ((ptr)->wIndexWithEOB = ((idx) << 1) | (eob))
#define setDXVA_TCoefSingleIDX(ptr, idx) ((ptr)->wIndexWithEOB |= ((idx) << 1))
#define setDXVA_TCoefSingleEOB(ptr)      ((ptr)->wIndexWithEOB |= 1)

/* Spatial-Domain Residual Difference Blocks */

#define DXVA_USUAL_BLOCK_WIDTH   8
#define DXVA_USUAL_BLOCK_HEIGHT  8
#define DXVA_USUAL_BLOCK_SIZE   (DXVA_USUAL_BLOCK_WIDTH * DXVA_USUAL_BLOCK_HEIGHT)

typedef SHORT       DXVA_Sample16[DXVA_USUAL_BLOCK_SIZE];
typedef signed char DXVA_Sample8 [DXVA_USUAL_BLOCK_SIZE];

/* Deblocking Filter Control Structure */

typedef BYTE DXVA_DeblockingEdgeControl;

typedef DXVA_DeblockingEdgeControl * LPDXVA_DeblockingEdgeControl;

/* Macros for Reading STRENGTH and FilterOn */

#define readDXVA_EdgeFilterStrength(ptr) ((*(ptr)) >> 1)
#define readDXVA_EdgeFilterOn(ptr)       ((*(ptr)) & 1)

/* Macro for Writing STRENGTH and FilterOn */

#define writeDXVA_DeblockingEdgeControl(ptr, str, fon) ((*(ptr)) = ((str) << 1) | (fon))
#define setDXVA_EdgeFilterStrength(ptr, str)           ((*(ptr)) |= ((str) << 1))
#define setDXVA_EdgeFilterOn(ptr)                      ((*(ptr)) |= 1)


/* Macroblock Control Command Data Structures */

typedef struct _DXVA_MVvalue {
  SHORT horz, vert;
} DXVA_MVvalue, *LPDXVA_MVvalue;


/* Inverse Quantization Matrices */

typedef struct _DXVA_QmatrixData {
  BYTE bNewQmatrix[4]; /* intra Y, inter Y, intra chroma, inter chroma */
  WORD Qmatrix[4][DXVA_USUAL_BLOCK_WIDTH * DXVA_USUAL_BLOCK_HEIGHT];
} DXVA_QmatrixData, *LPDXVA_QmatrixData;


/* Slice Control Buffer Data */

typedef struct _DXVA_SliceInfo {
  WORD  wHorizontalPosition;
  WORD  wVerticalPosition;
  DWORD dwSliceBitsInBuffer;
  DWORD dwSliceDataLocation;
  BYTE  bStartCodeBitOffset;
  BYTE  bReservedBits;
  WORD  wMBbitOffset;
  WORD  wNumberMBsInSlice;
  WORD  wQuantizerScaleCode;
  WORD  wBadSliceChopping;
} DXVA_SliceInfo, *LPDXVA_SliceInfo;


#define DXVA_NumMV_OBMC_off_BinPBwith4MV_off    4
#define DXVA_NumMV_OBMC_off_BinPBwith4MV_on  (4+1)
#define DXVA_NumMV_OBMC_on__BinPB_off         (10)
#define DXVA_NumMV_OBMC_on__BinPB_on          (11) /* not current standards */

#define DXVA_NumBlocksPerMB_420 (4+2+0)
#define DXVA_NumBlocksPerMB_422 (4+2+2)
#define DXVA_NumBlocksPerMB_444 (4+4+4)

/* Basic form for I pictures */
/* Host Residual Differences */
typedef struct _DXVA_MBctrl_I_HostResidDiff_1 {
  WORD  wMBaddress;
  WORD  wMBtype;
  DWORD dwMB_SNL;
  WORD  wPatternCode;
  WORD  wPC_Overflow; /* zero if not overflow format */
  DWORD dwReservedBits2;
} DXVA_MBctrl_I_HostResidDiff_1;

/* Basic form for I pictures */
/* Off-Host IDCT, 4:2:0 sampling */
typedef struct _DXVA_MBctrl_I_OffHostIDCT_1 {
  WORD  wMBaddress;
  WORD  wMBtype;
  DWORD dwMB_SNL;
  WORD  wPatternCode;
  BYTE  bNumCoef[DXVA_NumBlocksPerMB_420];
} DXVA_MBctrl_I_OffHostIDCT_1;

/* Basic form for P and B pictures */
/* Should also be used for concealment MVs in MPEG-2 I pictures */
/* Without OBMC, without BinPB and 4MV together, without MV RPS */
/* Host Residual Differences */
typedef struct _DXVA_MBctrl_P_HostResidDiff_1 {
  WORD         wMBaddress;
  WORD         wMBtype;
  DWORD        dwMB_SNL;
  WORD         wPatternCode;
  WORD         wPC_Overflow; /* zero if not overflow format */
  DWORD        dwReservedBits2;
  DXVA_MVvalue MVector[DXVA_NumMV_OBMC_off_BinPBwith4MV_off];
} DXVA_MBctrl_P_HostResidDiff_1;

/* Basic form for P and B pictures */
/* Without OBMC, without BinPB and 4MV together, without MV RPS */
/* Off-Host IDCT, 4:2:0 sampling */
typedef struct _DXVA_MBctrl_P_OffHostIDCT_1 {
  WORD         wMBaddress;
  WORD         wMBtype;
  DWORD        dwMB_SNL;
  WORD         wPatternCode;
  BYTE         bNumCoef[DXVA_NumBlocksPerMB_420];
  DXVA_MVvalue MVector[DXVA_NumMV_OBMC_off_BinPBwith4MV_off];
} DXVA_MBctrl_P_OffHostIDCT_1;

/* How to load alpha blending graphic data */
typedef struct _DXVA_ConfigAlphaLoad {

  // Operation Indicated
  DXVA_ConfigQueryOrReplyFunc dwFunction;

  // Alignment
  DWORD dwReservedBits[3];

  BYTE  bConfigDataType;
} DXVA_ConfigAlphaLoad, *LPDXVA_ConfigAlphaLoad;

#define DXVA_CONFIG_DATA_TYPE_IA44  0
#define DXVA_CONFIG_DATA_TYPE_AI44  1
#define DXVA_CONFIG_DATA_TYPE_DPXD  2
#define DXVA_CONFIG_DATA_TYPE_AYUV  3


/* How to combine alpha blending graphic data */
typedef struct _DXVA_ConfigAlphaCombine {

  // Operation Indicated
  DXVA_ConfigQueryOrReplyFunc dwFunction;

  // Alignment
  DWORD dwReservedBits[3];

  BYTE  bConfigBlendType;
  BYTE  bConfigPictureResizing;
  BYTE  bConfigOnlyUsePicDestRectArea;
  BYTE  bConfigGraphicResizing;
  BYTE  bConfigWholePlaneAlpha;

} DXVA_ConfigAlphaCombine, *LPDXVA_ConfigAlphaCombine;

#define DXVA_CONFIG_BLEND_TYPE_FRONT_BUFFER   0
#define DXVA_CONFIG_BLEND_TYPE_BACK_HARDWARE  1


/* AYUV sample for 16-entry YUV palette or graphic surface */

typedef struct _DXVA_AYUVsample2 {
  BYTE bCrValue;
  BYTE bCbValue;
  BYTE bY_Value;
  BYTE bSampleAlpha8;
} DXVA_AYUVsample2, *LPDXVA_AYUVsample2;

/* Macros for IA44 alpha blending surface samples */

typedef BYTE DXVA_IA44sample, *LPDXVA_IA44sample;

#define readDXVA_IA44index(ptr) (((*(ptr)) & 0xF0) >> 4)
#define readDXVA_IA44alpha(ptr)  ((*(ptr)) & 0x0F)

#define writeDXVA_IA44(ptr, idx, alpha) ((*(ptr)) = (((idx) << 4) | (alpha)))

#define setDXVA_IA44index(ptr, idx)    ((*(ptr)) |= ((idx) << 4))
#define setDXVA_IA44alpha(ptr, alpha)  ((*(ptr)) |= (alpha))

/* Macros for AI44 alpha blending surface samples */

typedef BYTE DXVA_AI44sample, *LPDXVA_AI44sample;

#define readDXVA_AI44index(ptr)  ((*(ptr)) & 0x0F)
#define readDXVA_AI44alpha(ptr) (((*(ptr)) & 0xF0) >> 4)

#define writeDXVA_AI44(ptr, idx, alpha) ((*(ptr)) = (((alpha) << 4) | (idx)))

#define setDXVA_AI44index(ptr, idx)    ((*(ptr)) |= (idx))
#define setDXVA_AI44alpha(ptr, alpha)  ((*(ptr)) |= ((alpha) << 4))


/* Highlight data structure */

typedef struct _DXVA_Highlight {
  WORD wHighlightActive;
  WORD wHighlightIndices;
  WORD wHighlightAlphas;
  RECT HighlightRect;
} DXVA_Highlight, *LPDXVA_Highlight;

typedef BYTE DXVA_DPXD,  *LPDXVA_DPXD;
typedef WORD DXVA_DCCMD, *LPDXVA_DCCMD;

/* Alpha blend combination */

typedef struct _DXVA_BlendCombination {
  WORD wPictureSourceIndex;
  WORD wBlendedDestinationIndex;
  RECT PictureSourceRect16thPel;
  RECT PictureDestinationRect;
  RECT GraphicSourceRect;
  RECT GraphicDestinationRect;
  WORD wBlendDelay;
  BYTE bBlendOn;
  BYTE bWholePlaneAlpha;
  DXVA_AYUVsample2 OutsideYUVcolor;
} DXVA_BlendCombination, *LPDXVA_BlendCombination;

/* H.264/AVC-specific structures */

/* H.264/AVC picture entry data structure */
typedef struct _DXVA_PicEntry_H264 {
  union {
    struct {
      UCHAR  Index7Bits      : 7;
      UCHAR  AssociatedFlag  : 1;
    };
    UCHAR  bPicEntry;
  };
} DXVA_PicEntry_H264, *LPDXVA_PicEntry_H264;  /* 1 byte */

/* H.264/AVC picture parameters structure */
typedef struct _DXVA_PicParams_H264 {
  USHORT  wFrameWidthInMbsMinus1;
  USHORT  wFrameHeightInMbsMinus1;
  DXVA_PicEntry_H264  CurrPic; /* flag is bot field flag */
  UCHAR   num_ref_frames;

  union {
    struct {
      USHORT  field_pic_flag                 : 1;
      USHORT  MbaffFrameFlag                 : 1;
      USHORT  residual_colour_transform_flag : 1;
      USHORT  sp_for_switch_flag             : 1;
      USHORT  chroma_format_idc              : 2;
      USHORT  RefPicFlag                     : 1;
      USHORT  constrained_intra_pred_flag    : 1;

      USHORT  weighted_pred_flag             : 1;
      USHORT  weighted_bipred_idc            : 2;
      USHORT  MbsConsecutiveFlag             : 1;
      USHORT  frame_mbs_only_flag            : 1;
      USHORT  transform_8x8_mode_flag        : 1;
      USHORT  MinLumaBipredSize8x8Flag       : 1;
      USHORT  IntraPicFlag                   : 1;
    };
    USHORT  wBitFields;
  };
  UCHAR  bit_depth_luma_minus8;
  UCHAR  bit_depth_chroma_minus8;

  USHORT Reserved16Bits;
  UINT   StatusReportFeedbackNumber;

  DXVA_PicEntry_H264  RefFrameList[16]; /* flag LT */
  INT    CurrFieldOrderCnt[2];
  INT    FieldOrderCntList[16][2];

  CHAR   pic_init_qs_minus26;
  CHAR   chroma_qp_index_offset;   /* also used for QScb */
  CHAR   second_chroma_qp_index_offset; /* also for QScr */
  UCHAR  ContinuationFlag;

/* remainder for parsing */
  CHAR   pic_init_qp_minus26;
  UCHAR  num_ref_idx_l0_active_minus1;
  UCHAR  num_ref_idx_l1_active_minus1;
  UCHAR  Reserved8BitsA;

  USHORT FrameNumList[16];
  UINT   UsedForReferenceFlags;
  USHORT NonExistingFrameFlags;
  USHORT frame_num;

  UCHAR  log2_max_frame_num_minus4;
  UCHAR  pic_order_cnt_type;
  UCHAR  log2_max_pic_order_cnt_lsb_minus4;
  UCHAR  delta_pic_order_always_zero_flag;

  UCHAR  direct_8x8_inference_flag;
  UCHAR  entropy_coding_mode_flag;
  UCHAR  pic_order_present_flag;
  UCHAR  num_slice_groups_minus1;

  UCHAR  slice_group_map_type;
  UCHAR  deblocking_filter_control_present_flag;
  UCHAR  redundant_pic_cnt_present_flag;
  UCHAR  Reserved8BitsB;

  USHORT slice_group_change_rate_minus1;

  UCHAR  SliceGroupMap[810]; /* 4b/sgmu, Size BT.601 */

} DXVA_PicParams_H264, *LPDXVA_PicParams_H264;

/* H.264/AVC quantization weighting matrix data structure */
typedef struct _DXVA_Qmatrix_H264 {
  UCHAR  bScalingLists4x4[6][16];
  UCHAR  bScalingLists8x8[2][64];

} DXVA_Qmatrix_H264, *LPDXVA_Qmatrix_H264;

/* H.264/AVC slice control data structure - short form */
typedef struct _DXVA_Slice_H264_Short {
  UINT   BSNALunitDataLocation; /* type 1..5 */
  UINT   SliceBytesInBuffer; /* for off-host parse */
  USHORT wBadSliceChopping;  /* for off-host parse */
} DXVA_Slice_H264_Short, *LPDXVA_Slice_H264_Short;

/* H.264/AVC picture entry data structure - long form */
typedef struct _DXVA_Slice_H264_Long {
  UINT   BSNALunitDataLocation; /* type 1..5 */
  UINT   SliceBytesInBuffer; /* for off-host parse */
  USHORT wBadSliceChopping;  /* for off-host parse */

  USHORT first_mb_in_slice;
  USHORT NumMbsForSlice;

  USHORT BitOffsetToSliceData; /* after CABAC alignment */

  UCHAR  slice_type;
  UCHAR  luma_log2_weight_denom;
  UCHAR  chroma_log2_weight_denom;
  UCHAR  num_ref_idx_l0_active_minus1;
  UCHAR  num_ref_idx_l1_active_minus1;
  CHAR   slice_alpha_c0_offset_div2;
  CHAR   slice_beta_offset_div2;
  UCHAR  Reserved8Bits;
  DXVA_PicEntry_H264 RefPicList[2][32]; /* L0 & L1 */
  SHORT  Weights[2][32][3][2]; /* L0 & L1; Y, Cb, Cr */
  CHAR   slice_qs_delta;
                               /* rest off-host parse */
  CHAR   slice_qp_delta;
  UCHAR  redundant_pic_cnt;
  UCHAR  direct_spatial_mv_pred_flag;
  UCHAR  cabac_init_idc;
  UCHAR  disable_deblocking_filter_idc;
  USHORT slice_id;
} DXVA_Slice_H264_Long, *LPDXVA_Slice_H264_Long;

/* H.264/AVC macroblock control command data structure */
typedef struct _DXVA_MBctrl_H264 {
  union {
    struct {
      UINT  bSliceID                : 8;   /* 1 byte */
      UINT  MbType5Bits             : 5;
      UINT  IntraMbFlag             : 1;
      UINT  mb_field_decoding_flag  : 1;
      UINT  transform_size_8x8_flag : 1;   /* 2 bytes */
      UINT  HostResidDiff           : 1;
      UINT  DcBlockCodedCrFlag      : 1;
      UINT  DcBlockCodedCbFlag      : 1;
      UINT  DcBlockCodedYFlag       : 1;
      UINT  FilterInternalEdgesFlag : 1;
      UINT  FilterLeftMbEdgeFlag    : 1;
      UINT  FilterTopMbEdgeFlag     : 1;
      UINT  ReservedBit             : 1;
      UINT  bMvQuantity             : 8;   /* 4 bytes */
    };
    UINT  dwMBtype;                    /* 4 bytes so far */
  };
  USHORT  CurrMbAddr;                  /* 6 bytes so far */
  USHORT  wPatternCode[3];/* YCbCr, 16 4x4 blks, 1b each */
                                      /* 12 bytes so far */
  UCHAR   bQpPrime[3];    /* Y, Cb, Cr, need just 7b QpY */
  UCHAR   bMBresidDataQuantity;
  ULONG   dwMBdataLocation;  /* offset into resid buffer */
                                      /* 20 bytes so far */
  union {
    struct {
/* start here for Intra MB's  (9 useful bytes in branch) */
      USHORT LumaIntraPredModes[4];/* 16 blocks, 4b each */
                                      /* 28 bytes so far */
      union {
        struct {
          UCHAR  intra_chroma_pred_mode : 2;
          UCHAR  IntraPredAvailFlags    : 5;
          UCHAR  ReservedIntraBit       : 1;
        };
        UCHAR  bMbIntraStruct;        /* 29 bytes so far */
      };
      UCHAR ReservedIntra24Bits[3];   /* 32 bytes total  */
    };
    struct {
/* start here for non-Intra MB's (12 bytes in branch)    */
      UCHAR  bSubMbShapes;          /* 4 subMbs, 2b each */
      UCHAR  bSubMbPredModes;       /* 4 subMBs, 2b each */
                                      /* 22 bytes so far */
      USHORT wMvBuffOffset;     /* offset into MV buffer */
      UCHAR  bRefPicSelect[2][4];     /* 32 bytes total */
    };
  };
} DXVA_MBctrl_H264, *LPDXVA_MBctrl_H264;

/* H.264/AVC IndexA and IndexB data structure */
typedef struct _DXVA_DeblockIndexAB_H264 {
  UCHAR  bIndexAinternal; /* 6b - could get from MB CC */
  UCHAR  bIndexBinternal; /* 6b - could get from MB CC */

  UCHAR  bIndexAleft0;
  UCHAR  bIndexBleft0;

  UCHAR  bIndexAleft1;
  UCHAR  bIndexBleft1;

  UCHAR  bIndexAtop0;
  UCHAR  bIndexBtop0;

  UCHAR  bIndexAtop1;
  UCHAR  bIndexBtop1;
} DXVA_DeblockIndexAB_H264, *LPDXVA_DeblockIndexAB_H264;
                                /* 10 bytes in struct */

/* H.264/AVC deblocking filter control data structure */
typedef struct _DXVA_Deblock_H264 {
  USHORT  CurrMbAddr; /* dup info */   /* 2 bytes so far */
  union {
    struct {
      UCHAR  ReservedBit                : 1;
      UCHAR  FieldModeCurrentMbFlag     : 1; /* dup info */
      UCHAR  FieldModeLeftMbFlag        : 1;
      UCHAR  FieldModeAboveMbFlag       : 1;
      UCHAR  FilterInternal8x8EdgesFlag : 1;
      UCHAR  FilterInternal4x4EdgesFlag : 1;
      UCHAR  FilterLeftMbEdgeFlag       : 1;
      UCHAR  FilterTopMbEdgeFlag        : 1;
    };
    UCHAR  FirstByte;
  };
  UCHAR  Reserved8Bits;      /* 4 bytes so far */

  UCHAR  bbSinternalLeftVert; /* 2 bits per bS */
  UCHAR  bbSinternalMidVert;

  UCHAR  bbSinternalRightVert;
  UCHAR  bbSinternalTopHorz;  /* 8 bytes so far */

  UCHAR  bbSinternalMidHorz;
  UCHAR  bbSinternalBotHorz;       /* 10 bytes so far */

  USHORT wbSLeft0; /* 4 bits per bS (1 wasted) */
  USHORT wbSLeft1; /* 4 bits per bS (1 wasted) */

  USHORT wbSTop0;  /* 4 bits per bS (1 wasted) */
  USHORT wbSTop1;  /* 4b (2 wasted)  18 bytes so far*/

  DXVA_DeblockIndexAB_H264  IndexAB[3]; /* Y, Cb, Cr */

} DXVA_Deblock_H264, *LPDXVA_Deblock_H264;/* 48 bytes */

/* H.264/AVC film grain characteristics data structure */
typedef struct _DXVA_FilmGrainCharacteristics {

  USHORT  wFrameWidthInMbsMinus1;
  USHORT  wFrameHeightInMbsMinus1;

  DXVA_PicEntry_H264  InPic; /* flag is bot field flag */
  DXVA_PicEntry_H264  OutPic; /* flag is field pic flag */

  USHORT PicOrderCnt_offset;
  INT    CurrPicOrderCnt;
  UINT   StatusReportFeedbackNumber;

  UCHAR model_id;
  UCHAR separate_colour_description_present_flag;
  UCHAR film_grain_bit_depth_luma_minus8;
  UCHAR film_grain_bit_depth_chroma_minus8;

  UCHAR film_grain_full_range_flag;
  UCHAR film_grain_colour_primaries;
  UCHAR film_grain_transfer_characteristics;
  UCHAR film_grain_matrix_coefficients;

  UCHAR blending_mode_id;
  UCHAR log2_scale_factor;

  UCHAR comp_model_present_flag[4];
  UCHAR num_intensity_intervals_minus1[4];
  UCHAR num_model_values_minus1[4];

  UCHAR intensity_interval_lower_bound[3][16];
  UCHAR intensity_interval_upper_bound[3][16];
  SHORT comp_model_value[3][16][8];
} DXVA_FilmGrainChar_H264, *LPDXVA_FilmGrainChar_H264;

/* H.264/AVC status reporting data structure */
typedef struct _DXVA_Status_H264 {
  UINT   StatusReportFeedbackNumber;
  DXVA_PicEntry_H264  CurrPic; /* flag is bot field flag */
  UCHAR  field_pic_flag;
  UCHAR  bDXVA_Func;
  UCHAR  bBufType;
  UCHAR  bStatus;
  UCHAR  bReserved8Bits;
  USHORT wNumMbsAffected;
} DXVA_Status_H264, *LPDXVA_Status_H264;

/* VC-1 status reporting data structure */
typedef struct _DXVA_Status_VC1 {
  USHORT StatusReportFeedbackNumber;
  WORD   wDecodedPictureIndex;
  WORD   wDeblockedPictureIndex;
  UCHAR  bPicStructure;
  UCHAR  bBufType;
  UCHAR  bStatus;
  UCHAR  bReserved8Bits;
  USHORT wNumMbsAffected;
} DXVA_Status_VC1, *LPDXVA_Status_VC1;


#pragma pack(push, 16)


typedef DXVA_MBctrl_I_HostResidDiff_1 *
       LPDXVA_MBctrl_I_HostResidDiff_1;

typedef DXVA_MBctrl_I_OffHostIDCT_1 *
       LPDXVA_MBctrl_I_OffHostIDCT_1;

typedef DXVA_MBctrl_P_HostResidDiff_1 *
       LPDXVA_MBctrl_P_HostResidDiff_1;

typedef DXVA_MBctrl_P_OffHostIDCT_1 *
       LPDXVA_MBctrl_P_OffHostIDCT_1;


#pragma pack(pop)

/*
 * Other forms of pictures are constructed in the obvious way
 * from the above by adjusting the number of residual difference
 * blocks, the number of motion vectors per macroblock, etc.
 */

#define readDXVA_MBskipsFollowing(ptr)       (((ptr)->dwMB_SNL & 0xFF000000) >> 24)
#define readDXVA_MBdataLocation(ptr)         (((ptr)->dwMB_SNL & 0x00FFFFFF))

#define writeDXVA_MB_SNL(ptr, skips, dloc)   ((ptr)->dwMB_SNL = (((skips) << 24) | (dloc)))
#define setDXVA_MBskipsFollowing(ptr, skips) ((ptr)->dwMB_SNL |= ((skips) << 24))
#define setDXVA_MBdataLocation(ptr, dloc)    ((ptr)->dwMB_SNL |= (dloc))

#define readDXVA_MvertFieldSel_3(ptr)    (((ptr)->wMBtype & 0x8000) >> 15)
#define readDXVA_MvertFieldSel_2(ptr)    (((ptr)->wMBtype & 0x4000) >> 14)
#define readDXVA_MvertFieldSel_1(ptr)    (((ptr)->wMBtype & 0x2000) >> 13)
#define readDXVA_MvertFieldSel_0(ptr)    (((ptr)->wMBtype & 0x1000) >> 12)
#define readDXVA_ReservedBits(ptr)       (((ptr)->wMBtype & 0x0800) >> 11)
#define readDXVA_HostResidDiff(ptr)      (((ptr)->wMBtype & 0x0400) >> 10)
#define readDXVA_MotionType(ptr)         (((ptr)->wMBtype & 0x0300) >>  8)
#define readDXVA_MBscanMethod(ptr)       (((ptr)->wMBtype & 0x00C0) >>  6)
#define readDXVA_FieldResidual(ptr)      (((ptr)->wMBtype & 0x0020) >>  5)
#define readDXVA_H261LoopFilter(ptr)     (((ptr)->wMBtype & 0x0010) >>  4)
#define readDXVA_Motion4MV(ptr)          (((ptr)->wMBtype & 0x0008) >>  3)
#define readDXVA_MotionBackward(ptr)     (((ptr)->wMBtype & 0x0004) >>  2)
#define readDXVA_MotionForward(ptr)      (((ptr)->wMBtype & 0x0002) >>  1)
#define readDXVA_IntraMacroblock(ptr)    (((ptr)->wMBtype & 0x0001))

#define setDXVA_MvertFieldSel_3(ptr)     ((ptr)->wMBtype |= 0x8000)
#define setDXVA_MvertFieldSel_2(ptr)     ((ptr)->wMBtype |= 0x4000)
#define setDXVA_MvertFieldSel_1(ptr)     ((ptr)->wMBtype |= 0x2000)
#define setDXVA_MvertFieldSel_0(ptr)     ((ptr)->wMBtype |= 0x1000)
#define setDXVA_ReservedBits(ptr)        ((ptr)->wMBtype |= 0x0800)
#define setDXVA_HostResidDiff(ptr)       ((ptr)->wMBtype |= 0x0400)
#define setDXVA_MotionType(ptr, value)   ((ptr)->wMBtype |= ((value) << 8))
#define setDXVA_MBscanMethod(ptr, value) ((ptr)->wMBtype |= ((value) << 6))
#define setDXVA_FieldResidual(ptr)       ((ptr)->wMBtype |= 0x0020)
#define setDXVA_H261LoopFilter(ptr)      ((ptr)->wMBtype |= 0x0010)
#define setDXVA_Motion4MV(ptr)           ((ptr)->wMBtype |= 0x0008)
#define setDXVA_MotionBackward(ptr)      ((ptr)->wMBtype |= 0x0004)
#define setDXVA_MotionForward(ptr)       ((ptr)->wMBtype |= 0x0002)
#define setDXVA_IntraMacroblock(ptr)     ((ptr)->wMBtype |= 0x0001)

#define readDXVA_Y___0coded(ptr)        (((ptr)->wPatternCode & 0x0800) >> 11)
#define readDXVA_Y___1coded(ptr)        (((ptr)->wPatternCode & 0x0400) >> 10)
#define readDXVA_Y___2coded(ptr)        (((ptr)->wPatternCode & 0x0200) >>  9)
#define readDXVA_Y___3coded(ptr)        (((ptr)->wPatternCode & 0x0100) >>  8)
#define readDXVA_Cb__4coded(ptr)        (((ptr)->wPatternCode & 0x0080) >>  7)
#define readDXVA_Cr__5coded(ptr)        (((ptr)->wPatternCode & 0x0040) >>  6)
#define readDXVA_Cb__6coded(ptr)        (((ptr)->wPatternCode & 0x0020) >>  5)
#define readDXVA_Cr__7coded(ptr)        (((ptr)->wPatternCode & 0x0010) >>  4)
#define readDXVA_Cb__8coded(ptr)        (((ptr)->wPatternCode & 0x0008) >>  3)
#define readDXVA_Cb__9coded(ptr)        (((ptr)->wPatternCode & 0x0004) >>  2)
#define readDXVA_Cr_10coded(ptr)        (((ptr)->wPatternCode & 0x0002) >>  1)
#define readDXVA_Cr_11coded(ptr)        (((ptr)->wPatternCode & 0x0001))

#define readDXVA_Y___0oflow(ptr)        (((ptr)->wPC_Overflow & 0x0800) >> 11)
#define readDXVA_Y___1oflow(ptr)        (((ptr)->wPC_Overflow & 0x0400) >> 10)
#define readDXVA_Y___2oflow(ptr)        (((ptr)->wPC_Overflow & 0x0200) >>  9)
#define readDXVA_Y___3oflow(ptr)        (((ptr)->wPC_Overflow & 0x0100) >>  8)
#define readDXVA_Cb__4oflow(ptr)        (((ptr)->wPC_Overflow & 0x0080) >>  7)
#define readDXVA_Cr__5oflow(ptr)        (((ptr)->wPC_Overflow & 0x0040) >>  6)
#define readDXVA_Cb__6oflow(ptr)        (((ptr)->wPC_Overflow & 0x0020) >>  5)
#define readDXVA_Cr__7oflow(ptr)        (((ptr)->wPC_Overflow & 0x0010) >>  4)
#define readDXVA_Cb__8oflow(ptr)        (((ptr)->wPC_Overflow & 0x0008) >>  3)
#define readDXVA_Cb__9oflow(ptr)        (((ptr)->wPC_Overflow & 0x0004) >>  2)
#define readDXVA_Cr_10oflow(ptr)        (((ptr)->wPC_Overflow & 0x0002) >>  1)
#define readDXVA_Cr_11oflow(ptr)        (((ptr)->wPC_Overflow & 0x0001))

#pragma pack(pop, BeforeDXVApacking)
#endif  /*   __DIRECTX_VA_DECODER__   */


// -------------------------------------------------------------------------
//
// D3DFORMAT describes a pixel memory layout, DXVA sample format contains
// additional information that describes how the pixels should be interpreted.
//
// DXVA Extended color data - occupies the SampleFormat DWORD
// data fields.
// -------------------------------------------------------------------------
#ifndef __DIRECTX_VA_SAMPLEFORMAT__
#define __DIRECTX_VA_SAMPLEFORMAT__

typedef enum _DXVA_SampleFormat {
    DXVA_SampleFormatMask = 0xFF,   // 8 bits used for DXVA Sample format
    DXVA_SampleUnknown = 0,
    DXVA_SamplePreviousFrame = 1,
    DXVA_SampleProgressiveFrame = 2,
    DXVA_SampleFieldInterleavedEvenFirst = 3,
    DXVA_SampleFieldInterleavedOddFirst = 4,
    DXVA_SampleFieldSingleEven = 5,
    DXVA_SampleFieldSingleOdd = 6,
    DXVA_SampleSubStream = 7
} DXVA_SampleFormat;

#define DXVA_ExtractSampleFormat(_sf) ((_sf) & (DXVA_SampleFormatMask))

#define DXVA_ExtractExtColorData(_sf, _Mask, _Shift) \
    (((_sf) & (_Mask)) >> (_Shift))

#define DXVABitMask(__n) (~((~0) << __n))
#define DXVA_ExtColorData_ShiftBase 8
#define DXVAColorMask(__bits,__base) (DXVABitMask(__bits) << (__base))

typedef enum _DXVA_VideoTransferFunction
{
    DXVA_VideoTransFuncShift = (DXVA_ExtColorData_ShiftBase + 19),
    DXVA_VideoTransFuncMask = DXVAColorMask(5, DXVA_VideoTransFuncShift),

    DXVA_VideoTransFunc_Unknown = 0,
    DXVA_VideoTransFunc_10 = 1,
    DXVA_VideoTransFunc_18 = 2,
    DXVA_VideoTransFunc_20 = 3,
    DXVA_VideoTransFunc_22 = 4,
    DXVA_VideoTransFunc_22_709  = 5,
    DXVA_VideoTransFunc_22_240M = 6,
    DXVA_VideoTransFunc_22_8bit_sRGB = 7,
    DXVA_VideoTransFunc_28 = 8
} DXVA_VideoTransferFunction;

typedef enum _DXVA_VideoPrimaries
{
    DXVA_VideoPrimariesShift = (DXVA_ExtColorData_ShiftBase + 14),
    DXVA_VideoPrimariesMask = DXVAColorMask(5, DXVA_VideoPrimariesShift),

    DXVA_VideoPrimaries_Unknown = 0,
    DXVA_VideoPrimaries_reserved = 1,
    DXVA_VideoPrimaries_BT709 = 2,
    DXVA_VideoPrimaries_BT470_2_SysM = 3,
    DXVA_VideoPrimaries_BT470_2_SysBG = 4,
    DXVA_VideoPrimaries_SMPTE170M = 5,
    DXVA_VideoPrimaries_SMPTE240M = 6,
    DXVA_VideoPrimaries_EBU3213 = 7,
    DXVA_VideoPrimaries_SMPTE_C = 8
} DXVA_VideoPrimaries;

typedef enum _DXVA_VideoLighting
{
    DXVA_VideoLightingShift = (DXVA_ExtColorData_ShiftBase + 10),
    DXVA_VideoLightingMask = DXVAColorMask(4, DXVA_VideoLightingShift),

    DXVA_VideoLighting_Unknown = 0,
    DXVA_VideoLighting_bright = 1,
    DXVA_VideoLighting_office = 2,
    DXVA_VideoLighting_dim = 3,
    DXVA_VideoLighting_dark = 4
} DXVA_VideoLighting;

typedef enum _DXVA_VideoTransferMatrix
{
    DXVA_VideoTransferMatrixShift = (DXVA_ExtColorData_ShiftBase + 7),
    DXVA_VideoTransferMatrixMask = DXVAColorMask(3, DXVA_VideoTransferMatrixShift),

    DXVA_VideoTransferMatrix_Unknown = 0,
    DXVA_VideoTransferMatrix_BT709 = 1,
    DXVA_VideoTransferMatrix_BT601 = 2,
    DXVA_VideoTransferMatrix_SMPTE240M = 3
} DXVA_VideoTransferMatrix;

typedef enum _DXVA_NominalRange
{
    DXVA_NominalRangeShift = (DXVA_ExtColorData_ShiftBase + 4),
    DXVA_NominalRangeMask = DXVAColorMask(3, DXVA_NominalRangeShift),

    DXVA_NominalRange_Unknown = 0,
    DXVA_NominalRange_Normal = 1,
    DXVA_NominalRange_Wide = 2,

    DXVA_NominalRange_0_255 = 1,
    DXVA_NominalRange_16_235 = 2,
    DXVA_NominalRange_48_208 = 3
} DXVA_NominalRange;


typedef enum _DXVA_VideoChromaSubsampling
{
    DXVA_VideoChromaSubsamplingShift = (DXVA_ExtColorData_ShiftBase + 0),
    DXVA_VideoChromaSubsamplingMask = DXVAColorMask(4, DXVA_VideoChromaSubsamplingShift),

    DXVA_VideoChromaSubsampling_Unknown = 0,
    DXVA_VideoChromaSubsampling_ProgressiveChroma = 0x8,
    DXVA_VideoChromaSubsampling_Horizontally_Cosited = 0x4,
    DXVA_VideoChromaSubsampling_Vertically_Cosited = 0x2,
    DXVA_VideoChromaSubsampling_Vertically_AlignedChromaPlanes = 0x1,

    // 4:2:0 variations
    DXVA_VideoChromaSubsampling_MPEG2  =   DXVA_VideoChromaSubsampling_Horizontally_Cosited |
                                           DXVA_VideoChromaSubsampling_Vertically_AlignedChromaPlanes, 

    DXVA_VideoChromaSubsampling_MPEG1  =   DXVA_VideoChromaSubsampling_Vertically_AlignedChromaPlanes, 

    DXVA_VideoChromaSubsampling_DV_PAL  =  DXVA_VideoChromaSubsampling_Horizontally_Cosited |
                                           DXVA_VideoChromaSubsampling_Vertically_Cosited,
    // 4:4:4, 4:2:2, 4:1:1
    DXVA_VideoChromaSubsampling_Cosited =  DXVA_VideoChromaSubsampling_Horizontally_Cosited |
                                           DXVA_VideoChromaSubsampling_Vertically_Cosited |
                                           DXVA_VideoChromaSubsampling_Vertically_AlignedChromaPlanes,
} DXVA_VideoChromaSubsampling;

typedef struct _DXVA_ExtendedFormat
{
    UINT                        SampleFormat : 8;           // See DXVA_SampleFormat
    UINT                        VideoChromaSubsampling : 4; // See DXVA_VideoChromaSubSampling
    DXVA_NominalRange           NominalRange : 3;           // See DXVA_NominalRange
    DXVA_VideoTransferMatrix    VideoTransferMatrix : 3;    // See DXVA_VideoTransferMatrix
    DXVA_VideoLighting          VideoLighting : 4;          // See DXVA_VideoLighting
    DXVA_VideoPrimaries         VideoPrimaries : 5;         // See DXVA_VideoPrimaries
    DXVA_VideoTransferFunction  VideoTransferFunction : 5;  // See DXVA_VideoTransferFunction
} DXVA_ExtendedFormat;

#endif



// -------------------------------------------------------------------------
//
// The definitions that follow describe the video de-interlace interface
// between the VMR and the graphics device driver.  This interface is not
// accessable via the IAMVideoAccelerator interface.
//
// -------------------------------------------------------------------------
//
#ifndef __DIRECTX_VA_DEINTERLACE__
#define __DIRECTX_VA_DEINTERLACE__

typedef LONGLONG REFERENCE_TIME;

DEFINE_GUID(DXVA_DeinterlaceBobDevice,
    0x335aa36e,0x7884,0x43a4,0x9c,0x91,0x7f,0x87,0xfa,0xf3,0xe3,0x7e);

DEFINE_GUID(DXVA_DeinterlaceContainerDevice,
    0x0e85cb93,0x3046,0x4ff0,0xae,0xcc,0xd5,0x8c,0xb5,0xf0,0x35,0xfd);


#if (DIRECT3D_VERSION < 0x0800) || !defined(DIRECT3D_VERSION)
typedef DWORD D3DFORMAT;
enum {
    D3DPOOL_DEFAULT                 = 0,
    D3DPOOL_MANAGED                 = 1,
    D3DPOOL_SYSTEMMEM               = 2,
    D3DPOOL_SCRATCH                 = 3,
    D3DPOOL_LOCALVIDMEM             = 4,
    D3DPOOL_NONLOCALVIDMEM          = 5,
    D3DPOOL_FORCE_DWORD             = 0x7fffffff
};
#endif


// -------------------------------------------------------------------------
// data structures shared by User mode and Kernel mode.
// -------------------------------------------------------------------------
//

typedef struct _DXVA_Frequency {
    DWORD Numerator;
    DWORD Denominator;
} DXVA_Frequency;

typedef struct _DXVA_VideoDesc {
    DWORD               Size;
    DWORD               SampleWidth;
    DWORD               SampleHeight;
    DWORD               SampleFormat; // also contains extend color data
    D3DFORMAT           d3dFormat;
    DXVA_Frequency      InputSampleFreq;
    DXVA_Frequency      OutputFrameFreq;
} DXVA_VideoDesc, *LPDXVA_VideoDesc;

typedef enum _DXVA_VideoProcessCaps {
    DXVA_VideoProcess_None                  = 0x0000,
    DXVA_VideoProcess_YUV2RGB               = 0x0001,
    DXVA_VideoProcess_StretchX              = 0x0002,
    DXVA_VideoProcess_StretchY              = 0x0004,
    DXVA_VideoProcess_AlphaBlend            = 0x0008,
    DXVA_VideoProcess_SubRects              = 0x0010,
    DXVA_VideoProcess_SubStreams            = 0x0020,
    DXVA_VideoProcess_SubStreamsExtended    = 0x0040,
    DXVA_VideoProcess_YUV2RGBExtended       = 0x0080,
    DXVA_VideoProcess_AlphaBlendExtended    = 0x0100
} DXVA_VideoProcessCaps;

typedef enum _DXVA_DeinterlaceTech {

    // the algorithm is unknown or proprietary
    DXVA_DeinterlaceTech_Unknown                = 0x0000,

    // the algorithm creates the missing lines by repeating
    // the line either above or below it - this method will look very jaggy and
    // isn't recommended
    DXVA_DeinterlaceTech_BOBLineReplicate       = 0x0001,

    // The algorithm creates the missing lines by vertically stretching each
    // video field by a factor of two by averaging two lines
    DXVA_DeinterlaceTech_BOBVerticalStretch     = 0x0002,

    // or using a [-1, 9, 9, -1]/16 filter across four lines.
    DXVA_DeinterlaceTech_BOBVerticalStretch4Tap = 0x0100,

    // the pixels in the missing line are recreated by a median filtering operation
    DXVA_DeinterlaceTech_MedianFiltering        = 0x0004,

    // the pixels in the missing line are recreated by an edge filter.
    // In this process, spatial directional filters are applied to determine
    // the orientation of edges in the picture content, and missing
    // pixels are created by filtering along (rather than across) the
    // detected edges.
    DXVA_DeinterlaceTech_EdgeFiltering          = 0x0010,

    // the pixels in the missing line are recreated by switching on a field by
    // field basis between using either spatial or temporal interpolation
    // depending on the amount of motion.
    DXVA_DeinterlaceTech_FieldAdaptive          = 0x0020,

    // the pixels in the missing line are recreated by switching on a pixel by pixel
    // basis between using either spatial or temporal interpolation depending on
    // the amount of motion..
    DXVA_DeinterlaceTech_PixelAdaptive          = 0x0040,

    // Motion Vector Steering  identifies objects within a sequence of video
    // fields.  The missing pixels are recreated after first aligning the
    // movement axes of the individual objects in the scene to make them
    // parallel with the time axis.
    DXVA_DeinterlaceTech_MotionVectorSteered      = 0x0080

} DXVA_DeinterlaceTech;


typedef struct _DXVA_VideoSample {
    REFERENCE_TIME      rtStart;
    REFERENCE_TIME      rtEnd;
    DXVA_SampleFormat   SampleFormat;   // only lower 8 bits used
    VOID*               lpDDSSrcSurface;
} DXVA_VideoSample, *LPDXVA_VideoSample;



// -------------------------------------------------------------------------
// DeinterlaceBltEx declarations
// -------------------------------------------------------------------------
//

typedef enum _DXVA_SampleFlags {
    DXVA_SampleFlagsMask = DXVABit(3)|DXVABit(2)|DXVABit(1)|DXVABit(0),

    DXVA_SampleFlag_Palette_Changed         = 0x0001,
    DXVA_SampleFlag_SrcRect_Changed         = 0x0002,
    DXVA_SampleFlag_DstRect_Changed         = 0x0004,
    DXVA_SampleFlag_ColorData_Changed       = 0x0008,
} DXVA_SampleFlags;

typedef enum _DXVA_DestinationFlags {
    DXVA_DestinationFlagMask = DXVABit(3)|DXVABit(2)|DXVABit(1)|DXVABit(0),

    DXVA_DestinationFlag_Background_Changed = 0x0001,
    DXVA_DestinationFlag_TargetRect_Changed = 0x0002,
    DXVA_DestinationFlag_ColorData_Changed  = 0x0004,
    DXVA_DestinationFlag_Alpha_Changed      = 0x0008
} DXVA_DestinationFlags;




typedef struct _DXVA_VideoSample2 {
#ifdef _WIN64
    DWORD               Size;
    DWORD               Reserved;
#endif
    REFERENCE_TIME      rtStart;
    REFERENCE_TIME      rtEnd;
    DWORD               SampleFormat;   // cast to DXVA_ExtendedFormat, or use Extract macros
    DWORD               SampleFlags;
    VOID*               lpDDSSrcSurface;
    RECT                rcSrc;
    RECT                rcDst;
    DXVA_AYUVsample2    Palette[16];
} DXVA_VideoSample2, *LPDXVA_VideoSample2;

typedef struct _DXVA_DeinterlaceCaps {
    DWORD                   Size;
    DWORD                   NumPreviousOutputFrames;
    DWORD                   InputPool;
    DWORD                   NumForwardRefSamples;
    DWORD                   NumBackwardRefSamples;
    D3DFORMAT               d3dOutputFormat;
    DXVA_VideoProcessCaps   VideoProcessingCaps;
    DXVA_DeinterlaceTech    DeinterlaceTechnology;
} DXVA_DeinterlaceCaps, *LPDXVA_DeinterlaceCaps;




// -------------------------------------------------------------------------
// Data types used with RenderMoComp in kernel mode
// -------------------------------------------------------------------------
//

// Function codes for RenderMoComp

#define MAX_DEINTERLACE_SURFACES                        32

#ifdef _WIN64
//
// These structures are used for thunking 32 bit DeinterlaceBltEx calls on
// 64 bit drivers.
// 
typedef struct _DXVA_VideoSample32 {
    REFERENCE_TIME      rtStart;
    REFERENCE_TIME      rtEnd;
    DWORD               SampleFormat;
    DWORD               SampleFlags;
    DWORD               lpDDSSrcSurface;  // 32 bit pointer size
    RECT                rcSrc;
    RECT                rcDst;
    DXVA_AYUVsample2    Palette[16];
    // DWORD Pad; 
    // 4 bytes of padding added by the compiler to align the struct to 8 bytes.
} DXVA_VideoSample32;
 
typedef struct _DXVA_DeinterlaceBltEx32 {
    DWORD               Size;
    DXVA_AYUVsample2    BackgroundColor;
    RECT                rcTarget;
    REFERENCE_TIME      rtTarget;
    DWORD               NumSourceSurfaces;
    FLOAT               Alpha;
    DXVA_VideoSample32  Source[MAX_DEINTERLACE_SURFACES];
    DWORD               DestinationFormat;
    DWORD               DestinationFlags;
} DXVA_DeinterlaceBltEx32;
#endif


typedef struct _DXVA_DeinterlaceBlt {
    DWORD               Size;
    DWORD               Reserved;
    REFERENCE_TIME      rtTarget;
    RECT                DstRect;
    RECT                SrcRect;
    DWORD               NumSourceSurfaces;
    FLOAT               Alpha;
    DXVA_VideoSample    Source[MAX_DEINTERLACE_SURFACES];
} DXVA_DeinterlaceBlt;

#define DXVA_DeinterlaceBltFnCode                     0x01
// lpInput => DXVA_DeinterlaceBlt*
// lpOuput => NULL /* not currently used */


typedef struct _DXVA_DeinterlaceBltEx {
    DWORD               Size;
    DXVA_AYUVsample2    BackgroundColor;
    RECT                rcTarget;
    REFERENCE_TIME      rtTarget;
    DWORD               NumSourceSurfaces;
    FLOAT               Alpha;
    DXVA_VideoSample2   Source[MAX_DEINTERLACE_SURFACES];
    DWORD               DestinationFormat;
    DWORD               DestinationFlags;
} DXVA_DeinterlaceBltEx;

#define DXVA_DeinterlaceBltExFnCode                   0x02
// lpInput => DXVA_DeinterlaceBltEx*
// lpOuput => NULL /* not currently used */


#define MAX_DEINTERLACE_DEVICE_GUIDS                    32
typedef struct _DXVA_DeinterlaceQueryAvailableModes {
    DWORD               Size;
    DWORD               NumGuids;
    GUID                Guids[MAX_DEINTERLACE_DEVICE_GUIDS];
} DXVA_DeinterlaceQueryAvailableModes;

#define DXVA_DeinterlaceQueryAvailableModesFnCode     0x01
// lpInput => DXVA_VideoDesc*
// lpOuput => DXVA_DeinterlaceQueryAvailableModes*


typedef struct _DXVA_DeinterlaceQueryModeCaps {
    DWORD               Size;
    GUID                Guid;
    DXVA_VideoDesc      VideoDesc;
} DXVA_DeinterlaceQueryModeCaps;

#define DXVA_DeinterlaceQueryModeCapsFnCode           0x02
// lpInput => DXVA_DeinterlaceQueryModeCaps*
// lpOuput => DXVA_DeinterlaceCaps*

#endif /*  __DIRECTX_VA_DEINTERLACE__ */


// -------------------------------------------------------------------------
//
// The definitions that follow describe the video ProcAmp interface
// between the VMR and the graphics device driver.  This interface is not
// accessable via the IAMVideoAccelerator interface.
//
// -------------------------------------------------------------------------
//
#ifndef __DIRECTX_VA_PROCAMPCONTROL__
#define __DIRECTX_VA_PROCAMPCONTROL__

DEFINE_GUID(DXVA_ProcAmpControlDevice,
    0x9f200913,0x2ffd,0x4056,0x9f,0x1e,0xe1,0xb5,0x08,0xf2,0x2d,0xcf);

typedef enum _DXVA_ProcAmpControlProp {
    DXVA_ProcAmp_None       = 0x0000,
    DXVA_ProcAmp_Brightness = 0x0001,
    DXVA_ProcAmp_Contrast   = 0x0002,
    DXVA_ProcAmp_Hue        = 0x0004,
    DXVA_ProcAmp_Saturation = 0x0008
} DXVA_ProcAmpControlProp;


typedef struct _DXVA_ProcAmpControlCaps {
    DWORD                   Size;
    DWORD                   InputPool;
    D3DFORMAT               d3dOutputFormat;
    DWORD                   ProcAmpControlProps;// see DXVA_ProcAmpControlProp
    DWORD                   VideoProcessingCaps;// see DXVA_VideoProcessCaps
} DXVA_ProcAmpControlCaps, *LPDXVA_ProcAmpControlCaps;

#define DXVA_ProcAmpControlQueryCapsFnCode             0x03
// lpInput => DXVA_VideoDesc*
// lpOuput => DXVA_ProcAmpControlCaps*


typedef struct _DXVA_ProcAmpControlQueryRange {
    DWORD                   Size;
    DXVA_ProcAmpControlProp ProcAmpControlProp;
    DXVA_VideoDesc          VideoDesc;
} DXVA_ProcAmpControlQueryRange, *LPDXVA_ProcAmpControlQueryRange;

typedef struct _DXVA_VideoPropertyRange {
    FLOAT   MinValue;
    FLOAT   MaxValue;
    FLOAT   DefaultValue;
    FLOAT   StepSize;
} DXVA_VideoPropertyRange, *LPDXVA_VideoPropertyRange;

#define DXVA_ProcAmpControlQueryRangeFnCode            0x04
// lpInput => DXVA_ProcAmpControlQueryRange*
// lpOuput => DXVA_VideoPropertyRange*


typedef struct _DXVA_ProcAmpControlBlt {
    DWORD               Size;
    RECT                DstRect;
    RECT                SrcRect;
    FLOAT               Alpha;
    FLOAT               Brightness;
    FLOAT               Contrast;
    FLOAT               Hue;
    FLOAT               Saturation;
} DXVA_ProcAmpControlBlt;

#define DXVA_ProcAmpControlBltFnCode                   0x01
// lpInput => DXVA_ProcAmpControlBlt*
// lpOuput => NULL /* not currently used */

#endif /*  __DIRECTX_VA_PROCAMPCONTROL__ */


// -------------------------------------------------------------------------
//
// The definitions that follow describe the Certified Output Protection
// Protocol between the VMR and the graphics device driver.  This interface
// is not accessable via the IAMVideoAccelerator interface.
//
// -------------------------------------------------------------------------
//

#ifndef __DIRECTX_VA_CERTOUTPUTPROTECT__
#define __DIRECTX_VA_CERTOUTPUTPROTECT__


DEFINE_GUID(DXVA_COPPDevice,
    0xd2457add,0x8999,0x45ed,0x8a,0x8a,0xd1,0xaa,0x04,0x7b,0xa4,0xd5);


// -------------------------------------------------------------------------
// COPPGetCertificateLength
// -------------------------------------------------------------------------
#define DXVA_COPPGetCertificateLengthFnCode         0x01
// lpInput => NULL
// lpOuput => DWORD*


// -------------------------------------------------------------------------
// COPPKeyExchange
// -------------------------------------------------------------------------
#define DXVA_COPPKeyExchangeFnCode                  0x02
// lpInputData => NULL
// lpOuputData => GUID*


// -------------------------------------------------------------------------
// COPPSequenceStart
// -------------------------------------------------------------------------
typedef struct _DXVA_COPPSignature {
    UCHAR   Signature[256];
} DXVA_COPPSignature, *LPDXVA_COPPSignature;

#define DXVA_COPPSequenceStartFnCode                0x03
// lpInputData => DXVA_COPPSignature*
// lpOuputData => NULL



// -------------------------------------------------------------------------
// COPPCommand
// -------------------------------------------------------------------------
typedef struct _DXVA_COPPCommand {
    GUID    macKDI;             //   16 bytes
    GUID    guidCommandID;      //   16 bytes
    ULONG   dwSequence;         //    4 bytes
    ULONG   cbSizeData;         //    4 bytes
    UCHAR   CommandData[4056];  // 4056 bytes (4056+4+4+16+16 = 4096)
}  DXVA_COPPCommand, *LPDXVA_COPPCommand;

#define DXVA_COPPCommandFnCode                      0x04
// lpInputData => DXVA_COPPCommand*
// lpOuputData => NULL


DEFINE_GUID(DXVA_COPPSetProtectionLevel,
    0x9bb9327c,0x4eb5,0x4727,0x9f,0x00,0xb4,0x2b,0x09,0x19,0xc0,0xda);

typedef struct _DXVA_COPPSetProtectionLevelCmdData {
    ULONG   ProtType;
    ULONG   ProtLevel;
    ULONG   ExtendedInfoChangeMask;
    ULONG   ExtendedInfoData;
} DXVA_COPPSetProtectionLevelCmdData;

typedef enum _COPP_DPCP_Protection_Level {
    COPP_DPCP_Level0        = 0,
    COPP_DPCP_LevelMin      = COPP_DPCP_Level0,
    COPP_DPCP_Level1        = 1,
    COPP_DPCP_LevelMax      = COPP_DPCP_Level1,
    COPP_DPCP_ForceDWORD    = 0x7fffffff
} COPP_DPCP_Protection_Level;

// Set the HDCP protection level - (0 - 1 DWORD, 4 bytes)

typedef enum _COPP_HDCP_Protection_Level {
    COPP_HDCP_Level0    = 0,
    COPP_HDCP_LevelMin  = COPP_HDCP_Level0,
    COPP_HDCP_Level1    = 1,
    COPP_HDCP_LevelMax  = COPP_HDCP_Level1,
    COPP_HDCP_ForceDWORD = 0x7fffffff
} COPP_HDCP_Protection_Level;

typedef enum _COPP_CGMSA_Protection_Level {
    COPP_CGMSA_Disabled = 0,
    COPP_CGMSA_LevelMin = COPP_CGMSA_Disabled,
    COPP_CGMSA_CopyFreely = 1,
    COPP_CGMSA_CopyNoMore = 2,
    COPP_CGMSA_CopyOneGeneration   = 3,
    COPP_CGMSA_CopyNever = 4,
    COPP_CGMSA_RedistributionControlRequired = 0x08,
    COPP_CGMSA_LevelMax = (COPP_CGMSA_RedistributionControlRequired + COPP_CGMSA_CopyNever),
    COPP_CGMSA_ForceDWORD = 0x7fffffff
} COPP_CGMSA_Protection_Level;

typedef enum _COPP_ACP_Protection_Level {
    COPP_ACP_Level0     = 0,
    COPP_ACP_LevelMin   = COPP_ACP_Level0,
    COPP_ACP_Level1     = 1,
    COPP_ACP_Level2     = 2,
    COPP_ACP_Level3     = 3,
    COPP_ACP_LevelMax   = COPP_ACP_Level3,
    COPP_ACP_ForceDWORD = 0x7fffffff
} COPP_ACP_Protection_Level;

#define COPP_NoProtectionLevelAvailable  -1
#define COPP_DefaultProtectionLevel 0


//
// Bit flags of possible protection types.  Note that it is possible to apply
// different protection settings to a single connector.
//
enum {
    COPP_ProtectionType_Unknown      = 0x80000000,
    COPP_ProtectionType_None         = 0x00000000,
    COPP_ProtectionType_HDCP         = 0x00000001, 	
    COPP_ProtectionType_ACP          = 0x00000002,
    COPP_ProtectionType_CGMSA        = 0x00000004,
    COPP_ProtectionType_DPCP         = 0x00000010,
    COPP_ProtectionType_Mask         = 0x80000017,
    COPP_ProtectionType_Reserved     = 0x7FFFFFF8
};

DEFINE_GUID(DXVA_COPPSetSignaling,
    0x9a631a5, 0xd684, 0x4c60, 0x8e, 0x4d, 0xd3, 0xbb, 0xf, 0xb, 0xe3, 0xee);

typedef struct _DXVA_COPPSetSignalingCmdData {
    ULONG   ActiveTVProtectionStandard;           // See COPP_TVProtectionStandard
    ULONG   AspectRatioChangeMask1;
    ULONG   AspectRatioData1;                     // See COPP_ImageAspectRatio_EN300294 for ETSI EN 300 294 values
    ULONG   AspectRatioChangeMask2;
    ULONG   AspectRatioData2;
    ULONG   AspectRatioChangeMask3;
    ULONG   AspectRatioData3;
    ULONG   ExtendedInfoChangeMask[4];
    ULONG   ExtendedInfoData[4];
    ULONG   Reserved;
} DXVA_COPPSetSignalingCmdData;

// Add format enum and data enum
typedef enum _COPP_TVProtectionStandard {
    COPP_ProtectionStandard_Unknown                         = 0x80000000,
    COPP_ProtectionStandard_None                            = 0x00000000,
    COPP_ProtectionStandard_IEC61880_525i                   = 0x00000001,
    COPP_ProtectionStandard_IEC61880_2_525i                 = 0x00000002,
    COPP_ProtectionStandard_IEC62375_625p                   = 0x00000004,
    COPP_ProtectionStandard_EIA608B_525                     = 0x00000008,
    COPP_ProtectionStandard_EN300294_625i                   = 0x00000010,
    COPP_ProtectionStandard_CEA805A_TypeA_525p              = 0x00000020,
    COPP_ProtectionStandard_CEA805A_TypeA_750p              = 0x00000040,
    COPP_ProtectionStandard_CEA805A_TypeA_1125i             = 0x00000080,
    COPP_ProtectionStandard_CEA805A_TypeB_525p              = 0x00000100,
    COPP_ProtectionStandard_CEA805A_TypeB_750p              = 0x00000200,
    COPP_ProtectionStandard_CEA805A_TypeB_1125i             = 0x00000400,
    COPP_ProtectionStandard_ARIBTRB15_525i                  = 0x00000800,
    COPP_ProtectionStandard_ARIBTRB15_525p                  = 0x00001000,
    COPP_ProtectionStandard_ARIBTRB15_750p                  = 0x00002000,
    COPP_ProtectionStandard_ARIBTRB15_1125i                 = 0x00004000,
    COPP_ProtectionStandard_Mask                            = 0x80007FFF,
    COPP_ProtectionStandard_Reserved                        = 0x7FFF8000
} COPP_TVProtectionStandard;

#define COPP_ImageAspectRatio_EN300294_Mask                 0x00000007

typedef enum _COPP_ImageAspectRatio_EN300294 {
    COPP_AspectRatio_EN300294_FullFormat4by3                = 0,
    COPP_AspectRatio_EN300294_Box14by9Center                = 1,
    COPP_AspectRatio_EN300294_Box14by9Top                   = 2,
    COPP_AspectRatio_EN300294_Box16by9Center                = 3,
    COPP_AspectRatio_EN300294_Box16by9Top                   = 4,
    COPP_AspectRatio_EN300294_BoxGT16by9Center              = 5,
    COPP_AspectRatio_EN300294_FullFormat4by3ProtectedCenter = 6,
    COPP_AspectRatio_EN300294_FullFormat16by9Anamorphic     = 7,
    COPP_AspectRatio_ForceDWORD                             = 0x7fffffff
} COPP_ImageAspectRatio_EN300294;


// -------------------------------------------------------------------------
// COPPQueryStatus
// -------------------------------------------------------------------------
typedef struct _DXVA_COPPStatusInput {
    GUID    rApp;               //   16 bytes
    GUID    guidStatusRequestID;//   16 bytes
    ULONG   dwSequence;         //    4 bytes
    ULONG   cbSizeData;         //    4 bytes
    UCHAR   StatusData[4056];   // 4056 bytes (4056+4+4+16+16 = 4096)
} DXVA_COPPStatusInput, *LPDXVA_COPPStatusInput;

typedef struct _DXVA_COPPStatusOutput {
    GUID    macKDI;             //   16 bytes
    ULONG   cbSizeData;         //    4 bytes
    UCHAR   COPPStatus[4076];   // 4076 bytes (4076+16+4 = 4096)
} DXVA_COPPStatusOutput, *LPDXVA_COPPStatusOutput;

typedef enum _COPP_StatusFlags {
    COPP_StatusNormal           = 0x00,
    COPP_LinkLost               = 0x01,
    COPP_RenegotiationRequired  = 0x02,
    COPP_StatusFlagsReserved    = 0xFFFFFFFC
} COPP_StatusFlags;

typedef struct _DXVA_COPPStatusData {
    GUID    rApp;
    ULONG   dwFlags;    // See COPP_StatusFlags above
    ULONG   dwData;
    ULONG   ExtendedInfoValidMask;
    ULONG   ExtendedInfoData;
} DXVA_COPPStatusData;

typedef struct _DXVA_COPPStatusDisplayData {
    GUID    rApp;
    ULONG   dwFlags;    // See COPP_StatusFlags above
    ULONG   DisplayWidth;
    ULONG   DisplayHeight;
    ULONG   Format;     // also contains extended color data
    ULONG   d3dFormat;
    ULONG   FreqNumerator;
    ULONG   FreqDenominator;
} DXVA_COPPStatusDisplayData;

typedef enum _COPP_StatusHDCPFlags {
    COPP_HDCPRepeater       = 0x01,
    COPP_HDCPFlagsReserved  = 0xFFFFFFFE
} COPP_StatusHDCPFlags;

typedef struct _DXVA_COPPStatusHDCPKeyData {
    GUID    rApp;
    ULONG   dwFlags;        // See COPP_StatusFlags above
    ULONG   dwHDCPFlags;    // See COPP_StatusHDCPFlags above
    GUID    BKey;           // Lower 40 bits
    GUID    Reserved1;
    GUID    Reserved2;
} DXVA_COPPStatusHDCPKeyData;


#define DXVA_COPPQueryStatusFnCode 0x05
// lpInputData => DXVA_COPPStatusInput*
// lpOuputData => DXVA_COPPStatusOutput*


//
// Status GUID and enumerations
//
DEFINE_GUID(DXVA_COPPQueryConnectorType,
      0x81d0bfd5,0x6afe,0x48c2,0x99,0xc0,0x95,0xa0,0x8f,0x97,0xc5,0xda);

typedef enum _COPP_ConnectorType {
    COPP_ConnectorType_Unknown = -1,
    COPP_ConnectorType_VGA = 0,
    COPP_ConnectorType_SVideo = 1,
    COPP_ConnectorType_CompositeVideo = 2,
    COPP_ConnectorType_ComponentVideo = 3,
    COPP_ConnectorType_DVI = 4,
    COPP_ConnectorType_HDMI = 5,
    COPP_ConnectorType_LVDS = 6,
    COPP_ConnectorType_TMDS = 7,
    COPP_ConnectorType_D_JPN = 8,
    COPP_ConnectorType_SDI = 9,
    COPP_ConnectorType_DisplayPortExternal = 10,
    COPP_ConnectorType_DisplayPortEmbedded = 11,
    COPP_ConnectorType_UDIExternal = 12,
    COPP_ConnectorType_UDIEmbedded = 13,
    COPP_ConnectorType_Internal = 0x80000000,   // can be combined with the other connector types
    COPP_ConnectorType_ForceDWORD = 0x7fffffff  /* force 32-bit size enum */
} COPP_ConnectorType;

DEFINE_GUID(DXVA_COPPQueryProtectionType,
    0x38f2a801,0x9a6c,0x48bb,0x91,0x07,0xb6,0x69,0x6e,0x6f,0x17,0x97);

DEFINE_GUID(DXVA_COPPQueryLocalProtectionLevel,
    0xb2075857,0x3eda,0x4d5d,0x88,0xdb,0x74,0x8f,0x8c,0x1a,0x05,0x49);

DEFINE_GUID(DXVA_COPPQueryGlobalProtectionLevel,
    0x1957210a,0x7766,0x452a,0xb9,0x9a,0xd2,0x7a,0xed,0x54,0xf0,0x3a);

DEFINE_GUID(DXVA_COPPQueryDisplayData,
    0xd7bf1ba3,0xad13,0x4f8e,0xaf,0x98,0x0d,0xcb,0x3c,0xa2,0x04,0xcc);

DEFINE_GUID(DXVA_COPPQueryHDCPKeyData,
    0xdb59d74, 0xa992, 0x492e, 0xa0, 0xbd, 0xc2, 0x3f, 0xda, 0x56, 0x4e, 0x0);

DEFINE_GUID(DXVA_COPPQueryBusData,
    0xc6f4d673, 0x6174, 0x4184, 0x8e, 0x35, 0xf6, 0xdb, 0x52, 0x0, 0xbc, 0xba);

typedef enum _COPP_BusType {
    COPP_BusType_Unknown    = 0,
    COPP_BusType_PCI        = 1,
    COPP_BusType_PCIX       = 2,
    COPP_BusType_PCIExpress = 3,
    COPP_BusType_AGP        = 4,
    COPP_BusType_Integrated = 0x80000000, // can be combined with the other bus types
    COPP_BusType_ForceDWORD = 0x7fffffff  /* force 32-bit size enum */
} COPP_BusType;

DEFINE_GUID(DXVA_COPPQuerySignaling,
    0x6629a591, 0x3b79, 0x4cf3, 0x92, 0x4a, 0x11, 0xe8, 0xe7, 0x81, 0x16, 0x71);

typedef struct _DXVA_COPPStatusSignalingCmdData {
    GUID    rApp;
    ULONG   dwFlags;                                // See COPP_StatusFlags above
    ULONG   AvailableTVProtectionStandards;         // See COPP_TVProtectionStandard
    ULONG   ActiveTVProtectionStandard;             // See COPP_TVProtectionStandard
    ULONG   TVType;
    ULONG   AspectRatioValidMask1;
    ULONG   AspectRatioData1;                       // See COPP_AspectRatio_EN300294 for ETSI EN 300 294 values
    ULONG   AspectRatioValidMask2;
    ULONG   AspectRatioData2;
    ULONG   AspectRatioValidMask3;
    ULONG   AspectRatioData3;
    ULONG   ExtendedInfoValidMask[4];
    ULONG   ExtendedInfoData[4];
} DXVA_COPPStatusSignalingCmdData;


#endif /* __DIRECTX_VA_CERTOUTPUTPROTECT__ */

#ifdef __cplusplus
}
#endif

#ifdef __DXVA1_DEPRECATED_INTERFACES__   

#if !defined(__cplusplus)
#error C++ compiler required.
#endif

/* IID_IDirect3DVideoDevice9 */
DEFINE_GUID(IID_IDirect3DVideoDevice9, 
0x694036ac, 0x542a, 0x4a3a, 0x9a, 0x32, 0x53, 0xbc, 0x20, 0x0, 0x2c, 0x1b);

/* IID_IDirect3DDXVADevice9 */
DEFINE_GUID(IID_IDirect3DDXVADevice9, 
0x9f00c3d3, 0x5ab6, 0x465f, 0xb9, 0x55, 0x9f, 0xe, 0xbb, 0x2c, 0x56, 0x6);

interface IDirect3DVideoDevice9;
interface IDirect3DDXVADevice9;

typedef struct _DXVAUncompDataInfo
{
    DWORD       UncompWidth;    /* Width of uncompressed data */
    DWORD       UncompHeight;   /* Height of uncompressed data */
    D3DFORMAT   UncompFormat;   /* Format of uncompressed data */
} DXVAUncompDataInfo;

typedef struct _DXVACompBufferInfo
{
    DWORD       NumCompBuffers;     /* Number of buffers reqd for compressed data */
    DWORD       WidthToCreate;      /* Width of surface to create */
    DWORD       HeightToCreate;     /* Height of surface to create */
    DWORD       BytesToAllocate;    /* Total number of bytes used by each surface */
    DWORD       Usage;              /* Usage used to create the compressed buffer */
    D3DPOOL     Pool;               /* Pool where the compressed buffer belongs */
    D3DFORMAT   Format;             /* Format used to create the compressed buffer */
} DXVACompBufferInfo;

typedef struct _DXVABufferInfo
{
    VOID*               pCompSurface;   /* Pointer to buffer containing compressed data */
    DWORD               DataOffset;     /* Offset of relevant data from the beginning of buffer */
    DWORD               DataSize;       /* Size of relevant data */
} DXVABufferInfo;

#undef INTERFACE
#define INTERFACE IDirect3DVideoDevice9

DECLARE_INTERFACE_(IDirect3DVideoDevice9, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DVideoDevice9 methods ***/
    STDMETHOD(CreateSurface)(THIS_ UINT Width,UINT Height,UINT BackBuffers,
                             D3DFORMAT Format,D3DPOOL Pool,DWORD Usage,
                             IDirect3DSurface9** ppSurface,
                             HANDLE* pSharedHandle) PURE;
    STDMETHOD(GetDXVACompressedBufferInfo)(THIS_ GUID* pGuid,
                                           DXVAUncompDataInfo* pUncompData,
                                           DWORD* pNumBuffers,
                                           DXVACompBufferInfo* pBufferInfo) PURE;
    STDMETHOD(GetDXVAGuids)(THIS_ DWORD* pNumGuids,GUID* pGuids) PURE;
    STDMETHOD(GetDXVAInternalInfo)(THIS_ GUID* pGuid,
                                   DXVAUncompDataInfo* pUncompData,
                                   DWORD* pMemoryUsed) PURE;
    STDMETHOD(GetUncompressedDXVAFormats)(THIS_ GUID* pGuid,
                                          DWORD* pNumFormats,
                                          D3DFORMAT* pFormats) PURE;
    STDMETHOD(CreateDXVADevice)(THIS_ GUID* pGuid,
                                DXVAUncompDataInfo* pUncompData,
                                LPVOID pData,DWORD DataSize,
                                IDirect3DDXVADevice9** ppDXVADevice) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DDXVADevice9

DECLARE_INTERFACE_(IDirect3DDXVADevice9, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirect3DDXVADevice9 methods ***/
    STDMETHOD(BeginFrame)(THIS_ IDirect3DSurface9* pDstSurface,
                          DWORD SizeInputData,VOID* pInputData,
                          DWORD* pSizeOutputData,VOID* pOutputData) PURE;
    STDMETHOD(EndFrame)(THIS_ DWORD SizeMiscData,VOID* pMiscData) PURE;
    STDMETHOD(Execute)(THIS_ DWORD FunctionNum,VOID* pInputData,
                       DWORD InputSize,VOID* OuputData,DWORD OutputSize,
                       DWORD NumBuffers,DXVABufferInfo* pBufferInfo) PURE;
    STDMETHOD(QueryStatus)(THIS_ IDirect3DSurface9* pSurface,DWORD Flags) PURE;
};

#endif /* __DXVA1_DEPRECATED_INTERFACES__ */        

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

#endif /* __DIRECTX_VA__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dxgitype.h ===
#ifndef __dxgitype_h__
#define __dxgitype_h__


#include "dxgiformat.h"

#define _FACDXGI    0x87a
#define MAKE_DXGI_HRESULT(code) MAKE_HRESULT(1, _FACDXGI, code)
#define MAKE_DXGI_STATUS(code)  MAKE_HRESULT(0, _FACDXGI, code)

#define DXGI_STATUS_OCCLUDED                    MAKE_DXGI_STATUS(1)
#define DXGI_STATUS_CLIPPED                     MAKE_DXGI_STATUS(2)
#define DXGI_STATUS_NO_REDIRECTION              MAKE_DXGI_STATUS(4)
#define DXGI_STATUS_NO_DESKTOP_ACCESS           MAKE_DXGI_STATUS(5)
#define DXGI_STATUS_GRAPHICS_VIDPN_SOURCE_IN_USE MAKE_DXGI_STATUS(6)
#define DXGI_STATUS_MODE_CHANGED                MAKE_DXGI_STATUS(7)
#define DXGI_STATUS_MODE_CHANGE_IN_PROGRESS     MAKE_DXGI_STATUS(8)


#define DXGI_ERROR_INVALID_CALL                 MAKE_DXGI_HRESULT(1)
#define DXGI_ERROR_NOT_FOUND                    MAKE_DXGI_HRESULT(2)
#define DXGI_ERROR_MORE_DATA                    MAKE_DXGI_HRESULT(3)
#define DXGI_ERROR_UNSUPPORTED                  MAKE_DXGI_HRESULT(4)
#define DXGI_ERROR_DEVICE_REMOVED               MAKE_DXGI_HRESULT(5)
#define DXGI_ERROR_DEVICE_HUNG                  MAKE_DXGI_HRESULT(6)
#define DXGI_ERROR_DEVICE_RESET                 MAKE_DXGI_HRESULT(7)
#define DXGI_ERROR_WAS_STILL_DRAWING            MAKE_DXGI_HRESULT(10)
#define DXGI_ERROR_FRAME_STATISTICS_DISJOINT    MAKE_DXGI_HRESULT(11)
#define DXGI_ERROR_GRAPHICS_VIDPN_SOURCE_IN_USE MAKE_DXGI_HRESULT(12)
#define DXGI_ERROR_DRIVER_INTERNAL_ERROR        MAKE_DXGI_HRESULT(32)
#define DXGI_ERROR_NONEXCLUSIVE                 MAKE_DXGI_HRESULT(33)
#define DXGI_ERROR_NOT_CURRENTLY_AVAILABLE      MAKE_DXGI_HRESULT(34)
#define DXGI_ERROR_REMOTE_CLIENT_DISCONNECTED   MAKE_DXGI_HRESULT(35)
#define DXGI_ERROR_REMOTE_OUTOFMEMORY           MAKE_DXGI_HRESULT(36)



#define DXGI_CPU_ACCESS_NONE                    ( 0 )
#define DXGI_CPU_ACCESS_DYNAMIC                 ( 1 )
#define DXGI_CPU_ACCESS_READ_WRITE              ( 2 )
#define DXGI_CPU_ACCESS_SCRATCH                 ( 3 )
#define DXGI_CPU_ACCESS_FIELD                   15

#define DXGI_USAGE_SHADER_INPUT                 ( 1L << (0 + 4) )
#define DXGI_USAGE_RENDER_TARGET_OUTPUT         ( 1L << (1 + 4) )
#define DXGI_USAGE_BACK_BUFFER                  ( 1L << (2 + 4) )
#define DXGI_USAGE_SHARED                       ( 1L << (3 + 4) )
#define DXGI_USAGE_READ_ONLY                    ( 1L << (4 + 4) )
#define DXGI_USAGE_DISCARD_ON_PRESENT           ( 1L << (5 + 4) )
#define DXGI_USAGE_UNORDERED_ACCESS             ( 1L << (6 + 4) )

typedef struct DXGI_RGB
{
    float Red;
    float Green;
    float Blue;
} DXGI_RGB;

typedef struct DXGI_GAMMA_CONTROL
{
    DXGI_RGB Scale;
    DXGI_RGB Offset;
    DXGI_RGB GammaCurve[ 1025 ];
} DXGI_GAMMA_CONTROL;

typedef struct DXGI_GAMMA_CONTROL_CAPABILITIES
{
    BOOL ScaleAndOffsetSupported;
    float MaxConvertedValue;
    float MinConvertedValue;
    UINT NumGammaControlPoints;
    float ControlPointPositions[1025];
} DXGI_GAMMA_CONTROL_CAPABILITIES;

typedef struct DXGI_RATIONAL
{
    UINT Numerator;
    UINT Denominator;
} DXGI_RATIONAL;

typedef enum DXGI_MODE_SCANLINE_ORDER
{
    DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED        = 0,
    DXGI_MODE_SCANLINE_ORDER_PROGRESSIVE        = 1,
    DXGI_MODE_SCANLINE_ORDER_UPPER_FIELD_FIRST  = 2,
    DXGI_MODE_SCANLINE_ORDER_LOWER_FIELD_FIRST  = 3
} DXGI_MODE_SCANLINE_ORDER;

typedef enum DXGI_MODE_SCALING
{
    DXGI_MODE_SCALING_UNSPECIFIED   = 0,
    DXGI_MODE_SCALING_CENTERED      = 1,
    DXGI_MODE_SCALING_STRETCHED     = 2
} DXGI_MODE_SCALING;

typedef enum DXGI_MODE_ROTATION
{
    DXGI_MODE_ROTATION_UNSPECIFIED  = 0,
    DXGI_MODE_ROTATION_IDENTITY     = 1,
    DXGI_MODE_ROTATION_ROTATE90     = 2,
    DXGI_MODE_ROTATION_ROTATE180    = 3,
    DXGI_MODE_ROTATION_ROTATE270    = 4
} DXGI_MODE_ROTATION;

typedef struct DXGI_MODE_DESC
{
    UINT Width;
    UINT Height;
    DXGI_RATIONAL RefreshRate;
    DXGI_FORMAT Format;
    DXGI_MODE_SCANLINE_ORDER ScanlineOrdering;
    DXGI_MODE_SCALING Scaling;
} DXGI_MODE_DESC;

typedef struct DXGI_SAMPLE_DESC
{
    UINT Count;
    UINT Quality;
} DXGI_SAMPLE_DESC;

#endif // __dxgitype_h__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\dxvahd.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for dxvahd.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dxvahd_h__
#define __dxvahd_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDXVAHD_Device_FWD_DEFINED__
#define __IDXVAHD_Device_FWD_DEFINED__
typedef interface IDXVAHD_Device IDXVAHD_Device;
#endif 	/* __IDXVAHD_Device_FWD_DEFINED__ */


#ifndef __IDXVAHD_VideoProcessor_FWD_DEFINED__
#define __IDXVAHD_VideoProcessor_FWD_DEFINED__
typedef interface IDXVAHD_VideoProcessor IDXVAHD_VideoProcessor;
#endif 	/* __IDXVAHD_VideoProcessor_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_dxvahd_0000_0000 */
/* [local] */ 

#if 0
typedef DWORD IDirect3DDevice9Ex;

typedef DWORD IDirect3DSurface9;

typedef DWORD D3DCOLOR;

typedef DWORD D3DFORMAT;

typedef DWORD D3DPOOL;

#endif // 0
#if defined(_WIN32) && !defined(_NO_COM)




DEFINE_GUID(IID_IDXVAHD_Device,         0x95f12dfd,0xd77e,0x49be,0x81,0x5f,0x57,0xd5,0x79,0x63,0x4d,0x6d);

DEFINE_GUID(IID_IDXVAHD_VideoProcessor, 0x95f4edf4,0x6e03,0x4cd7,0xbe,0x1b,0x30,0x75,0xd6,0x65,0xaa,0x52);




#endif


typedef 
enum _DXVAHD_FRAME_FORMAT
    {	DXVAHD_FRAME_FORMAT_PROGRESSIVE	= 0,
	DXVAHD_FRAME_FORMAT_INTERLACED_TOP_FIELD_FIRST	= 1,
	DXVAHD_FRAME_FORMAT_INTERLACED_BOTTOM_FIELD_FIRST	= 2
    } 	DXVAHD_FRAME_FORMAT;

typedef 
enum _DXVAHD_DEVICE_USAGE
    {	DXVAHD_DEVICE_USAGE_PLAYBACK_NORMAL	= 0,
	DXVAHD_DEVICE_USAGE_OPTIMAL_SPEED	= 1,
	DXVAHD_DEVICE_USAGE_OPTIMAL_QUALITY	= 2
    } 	DXVAHD_DEVICE_USAGE;

typedef 
enum _DXVAHD_SURFACE_TYPE
    {	DXVAHD_SURFACE_TYPE_VIDEO_INPUT	= 0,
	DXVAHD_SURFACE_TYPE_VIDEO_INPUT_PRIVATE	= 1,
	DXVAHD_SURFACE_TYPE_VIDEO_OUTPUT	= 2
    } 	DXVAHD_SURFACE_TYPE;

typedef 
enum _DXVAHD_DEVICE_TYPE
    {	DXVAHD_DEVICE_TYPE_HARDWARE	= 0,
	DXVAHD_DEVICE_TYPE_SOFTWARE	= 1,
	DXVAHD_DEVICE_TYPE_REFERENCE	= 2,
	DXVAHD_DEVICE_TYPE_OTHER	= 3
    } 	DXVAHD_DEVICE_TYPE;

typedef 
enum _DXVAHD_DEVICE_CAPS
    {	DXVAHD_DEVICE_CAPS_LINEAR_SPACE	= 0x1,
	DXVAHD_DEVICE_CAPS_xvYCC	= 0x2,
	DXVAHD_DEVICE_CAPS_RGB_RANGE_CONVERSION	= 0x4,
	DXVAHD_DEVICE_CAPS_YCbCr_MATRIX_CONVERSION	= 0x8
    } 	DXVAHD_DEVICE_CAPS;

typedef 
enum _DXVAHD_FEATURE_CAPS
    {	DXVAHD_FEATURE_CAPS_ALPHA_FILL	= 0x1,
	DXVAHD_FEATURE_CAPS_CONSTRICTION	= 0x2,
	DXVAHD_FEATURE_CAPS_LUMA_KEY	= 0x4,
	DXVAHD_FEATURE_CAPS_ALPHA_PALETTE	= 0x8
    } 	DXVAHD_FEATURE_CAPS;

typedef 
enum _DXVAHD_FILTER_CAPS
    {	DXVAHD_FILTER_CAPS_BRIGHTNESS	= 0x1,
	DXVAHD_FILTER_CAPS_CONTRAST	= 0x2,
	DXVAHD_FILTER_CAPS_HUE	= 0x4,
	DXVAHD_FILTER_CAPS_SATURATION	= 0x8,
	DXVAHD_FILTER_CAPS_NOISE_REDUCTION	= 0x10,
	DXVAHD_FILTER_CAPS_EDGE_ENHANCEMENT	= 0x20,
	DXVAHD_FILTER_CAPS_ANAMORPHIC_SCALING	= 0x40
    } 	DXVAHD_FILTER_CAPS;

typedef 
enum _DXVAHD_INPUT_FORMAT_CAPS
    {	DXVAHD_INPUT_FORMAT_CAPS_RGB_INTERLACED	= 0x1,
	DXVAHD_INPUT_FORMAT_CAPS_RGB_PROCAMP	= 0x2,
	DXVAHD_INPUT_FORMAT_CAPS_RGB_LUMA_KEY	= 0x4,
	DXVAHD_INPUT_FORMAT_CAPS_PALETTE_INTERLACED	= 0x8
    } 	DXVAHD_INPUT_FORMAT_CAPS;

typedef 
enum _DXVAHD_PROCESSOR_CAPS
    {	DXVAHD_PROCESSOR_CAPS_DEINTERLACE_BLEND	= 0x1,
	DXVAHD_PROCESSOR_CAPS_DEINTERLACE_BOB	= 0x2,
	DXVAHD_PROCESSOR_CAPS_DEINTERLACE_ADAPTIVE	= 0x4,
	DXVAHD_PROCESSOR_CAPS_DEINTERLACE_MOTION_COMPENSATION	= 0x8,
	DXVAHD_PROCESSOR_CAPS_INVERSE_TELECINE	= 0x10,
	DXVAHD_PROCESSOR_CAPS_FRAME_RATE_CONVERSION	= 0x20
    } 	DXVAHD_PROCESSOR_CAPS;

typedef 
enum _DXVAHD_ITELECINE_CAPS
    {	DXVAHD_ITELECINE_CAPS_32	= 0x1,
	DXVAHD_ITELECINE_CAPS_22	= 0x2,
	DXVAHD_ITELECINE_CAPS_2224	= 0x4,
	DXVAHD_ITELECINE_CAPS_2332	= 0x8,
	DXVAHD_ITELECINE_CAPS_32322	= 0x10,
	DXVAHD_ITELECINE_CAPS_55	= 0x20,
	DXVAHD_ITELECINE_CAPS_64	= 0x40,
	DXVAHD_ITELECINE_CAPS_87	= 0x80,
	DXVAHD_ITELECINE_CAPS_222222222223	= 0x100,
	DXVAHD_ITELECINE_CAPS_OTHER	= 0x80000000
    } 	DXVAHD_ITELECINE_CAPS;

typedef 
enum _DXVAHD_FILTER
    {	DXVAHD_FILTER_BRIGHTNESS	= 0,
	DXVAHD_FILTER_CONTRAST	= 1,
	DXVAHD_FILTER_HUE	= 2,
	DXVAHD_FILTER_SATURATION	= 3,
	DXVAHD_FILTER_NOISE_REDUCTION	= 4,
	DXVAHD_FILTER_EDGE_ENHANCEMENT	= 5,
	DXVAHD_FILTER_ANAMORPHIC_SCALING	= 6
    } 	DXVAHD_FILTER;

typedef 
enum _DXVAHD_BLT_STATE
    {	DXVAHD_BLT_STATE_TARGET_RECT	= 0,
	DXVAHD_BLT_STATE_BACKGROUND_COLOR	= 1,
	DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE	= 2,
	DXVAHD_BLT_STATE_ALPHA_FILL	= 3,
	DXVAHD_BLT_STATE_CONSTRICTION	= 4,
	DXVAHD_BLT_STATE_PRIVATE	= 1000
    } 	DXVAHD_BLT_STATE;

typedef 
enum _DXVAHD_ALPHA_FILL_MODE
    {	DXVAHD_ALPHA_FILL_MODE_OPAQUE	= 0,
	DXVAHD_ALPHA_FILL_MODE_BACKGROUND	= 1,
	DXVAHD_ALPHA_FILL_MODE_DESTINATION	= 2,
	DXVAHD_ALPHA_FILL_MODE_SOURCE_STREAM	= 3
    } 	DXVAHD_ALPHA_FILL_MODE;

typedef 
enum _DXVAHD_STREAM_STATE
    {	DXVAHD_STREAM_STATE_D3DFORMAT	= 0,
	DXVAHD_STREAM_STATE_FRAME_FORMAT	= 1,
	DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE	= 2,
	DXVAHD_STREAM_STATE_OUTPUT_RATE	= 3,
	DXVAHD_STREAM_STATE_SOURCE_RECT	= 4,
	DXVAHD_STREAM_STATE_DESTINATION_RECT	= 5,
	DXVAHD_STREAM_STATE_ALPHA	= 6,
	DXVAHD_STREAM_STATE_PALETTE	= 7,
	DXVAHD_STREAM_STATE_LUMA_KEY	= 8,
	DXVAHD_STREAM_STATE_ASPECT_RATIO	= 9,
	DXVAHD_STREAM_STATE_FILTER_BRIGHTNESS	= 100,
	DXVAHD_STREAM_STATE_FILTER_CONTRAST	= 101,
	DXVAHD_STREAM_STATE_FILTER_HUE	= 102,
	DXVAHD_STREAM_STATE_FILTER_SATURATION	= 103,
	DXVAHD_STREAM_STATE_FILTER_NOISE_REDUCTION	= 104,
	DXVAHD_STREAM_STATE_FILTER_EDGE_ENHANCEMENT	= 105,
	DXVAHD_STREAM_STATE_FILTER_ANAMORPHIC_SCALING	= 106,
	DXVAHD_STREAM_STATE_PRIVATE	= 1000
    } 	DXVAHD_STREAM_STATE;

typedef 
enum _DXVAHD_OUTPUT_RATE
    {	DXVAHD_OUTPUT_RATE_NORMAL	= 0,
	DXVAHD_OUTPUT_RATE_HALF	= 1,
	DXVAHD_OUTPUT_RATE_CUSTOM	= 2
    } 	DXVAHD_OUTPUT_RATE;

typedef struct _DXVAHD_RATIONAL
    {
    UINT Numerator;
    UINT Denominator;
    } 	DXVAHD_RATIONAL;

typedef struct _DXVAHD_COLOR_RGBA
    {
    FLOAT R;
    FLOAT G;
    FLOAT B;
    FLOAT A;
    } 	DXVAHD_COLOR_RGBA;

typedef struct _DXVAHD_COLOR_YCbCrA
    {
    FLOAT Y;
    FLOAT Cb;
    FLOAT Cr;
    FLOAT A;
    } 	DXVAHD_COLOR_YCbCrA;

typedef union _DXVAHD_COLOR
    {
    DXVAHD_COLOR_RGBA RGB;
    DXVAHD_COLOR_YCbCrA YCbCr;
    } 	DXVAHD_COLOR;

typedef struct _DXVAHD_CONTENT_DESC
    {
    DXVAHD_FRAME_FORMAT InputFrameFormat;
    DXVAHD_RATIONAL InputFrameRate;
    UINT InputWidth;
    UINT InputHeight;
    DXVAHD_RATIONAL OutputFrameRate;
    UINT OutputWidth;
    UINT OutputHeight;
    } 	DXVAHD_CONTENT_DESC;

typedef struct _DXVAHD_VPDEVCAPS
    {
    DXVAHD_DEVICE_TYPE DeviceType;
    UINT DeviceCaps;
    UINT FeatureCaps;
    UINT FilterCaps;
    UINT InputFormatCaps;
    D3DPOOL InputPool;
    UINT OutputFormatCount;
    UINT InputFormatCount;
    UINT VideoProcessorCount;
    UINT MaxInputStreams;
    UINT MaxStreamStates;
    } 	DXVAHD_VPDEVCAPS;

typedef struct _DXVAHD_VPCAPS
    {
    GUID VPGuid;
    UINT PastFrames;
    UINT FutureFrames;
    UINT ProcessorCaps;
    UINT ITelecineCaps;
    UINT CustomRateCount;
    } 	DXVAHD_VPCAPS;

typedef struct _DXVAHD_CUSTOM_RATE_DATA
    {
    DXVAHD_RATIONAL CustomRate;
    UINT OutputFrames;
    BOOL InputInterlaced;
    UINT InputFramesOrFields;
    } 	DXVAHD_CUSTOM_RATE_DATA;

typedef struct _DXVAHD_FILTER_RANGE_DATA
    {
    INT Minimum;
    INT Maximum;
    INT Default;
    FLOAT Multiplier;
    } 	DXVAHD_FILTER_RANGE_DATA;

typedef struct _DXVAHD_BLT_STATE_TARGET_RECT_DATA
    {
    BOOL Enable;
    RECT TargetRect;
    } 	DXVAHD_BLT_STATE_TARGET_RECT_DATA;

typedef struct _DXVAHD_BLT_STATE_BACKGROUND_COLOR_DATA
    {
    BOOL YCbCr;
    DXVAHD_COLOR BackgroundColor;
    } 	DXVAHD_BLT_STATE_BACKGROUND_COLOR_DATA;

typedef struct _DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE_DATA
    {
    union 
        {
        struct 
            {
            UINT Usage	: 1;
            UINT RGB_Range	: 1;
            UINT YCbCr_Matrix	: 1;
            UINT YCbCr_xvYCC	: 1;
            UINT Reserved	: 28;
            } 	;
        UINT Value;
        } 	;
    } 	DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE_DATA;

typedef struct _DXVAHD_BLT_STATE_ALPHA_FILL_DATA
    {
    DXVAHD_ALPHA_FILL_MODE Mode;
    UINT StreamNumber;
    } 	DXVAHD_BLT_STATE_ALPHA_FILL_DATA;

typedef struct _DXVAHD_BLT_STATE_CONSTRICTION_DATA
    {
    BOOL Enable;
    SIZE Size;
    } 	DXVAHD_BLT_STATE_CONSTRICTION_DATA;

typedef struct _DXVAHD_BLT_STATE_PRIVATE_DATA
    {
    GUID Guid;
    UINT DataSize;
    void *pData;
    } 	DXVAHD_BLT_STATE_PRIVATE_DATA;

typedef struct _DXVAHD_STREAM_STATE_D3DFORMAT_DATA
    {
    D3DFORMAT Format;
    } 	DXVAHD_STREAM_STATE_D3DFORMAT_DATA;

typedef struct _DXVAHD_STREAM_STATE_FRAME_FORMAT_DATA
    {
    DXVAHD_FRAME_FORMAT FrameFormat;
    } 	DXVAHD_STREAM_STATE_FRAME_FORMAT_DATA;

typedef struct _DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE_DATA
    {
    union 
        {
        struct 
            {
            UINT Type	: 1;
            UINT RGB_Range	: 1;
            UINT YCbCr_Matrix	: 1;
            UINT YCbCr_xvYCC	: 1;
            UINT Reserved	: 28;
            } 	;
        UINT Value;
        } 	;
    } 	DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE_DATA;

typedef struct _DXVAHD_STREAM_STATE_OUTPUT_RATE_DATA
    {
    BOOL RepeatFrame;
    DXVAHD_OUTPUT_RATE OutputRate;
    DXVAHD_RATIONAL CustomRate;
    } 	DXVAHD_STREAM_STATE_OUTPUT_RATE_DATA;

typedef struct _DXVAHD_STREAM_STATE_SOURCE_RECT_DATA
    {
    BOOL Enable;
    RECT SourceRect;
    } 	DXVAHD_STREAM_STATE_SOURCE_RECT_DATA;

typedef struct _DXVAHD_STREAM_STATE_DESTINATION_RECT_DATA
    {
    BOOL Enable;
    RECT DestinationRect;
    } 	DXVAHD_STREAM_STATE_DESTINATION_RECT_DATA;

typedef struct _DXVAHD_STREAM_STATE_ALPHA_DATA
    {
    BOOL Enable;
    FLOAT Alpha;
    } 	DXVAHD_STREAM_STATE_ALPHA_DATA;

typedef struct _DXVAHD_STREAM_STATE_PALETTE_DATA
    {
    UINT Count;
    D3DCOLOR *pEntries;
    } 	DXVAHD_STREAM_STATE_PALETTE_DATA;

typedef struct _DXVAHD_STREAM_STATE_LUMA_KEY_DATA
    {
    BOOL Enable;
    FLOAT Lower;
    FLOAT Upper;
    } 	DXVAHD_STREAM_STATE_LUMA_KEY_DATA;

typedef struct _DXVAHD_STREAM_STATE_ASPECT_RATIO_DATA
    {
    BOOL Enable;
    DXVAHD_RATIONAL SourceAspectRatio;
    DXVAHD_RATIONAL DestinationAspectRatio;
    } 	DXVAHD_STREAM_STATE_ASPECT_RATIO_DATA;

typedef struct _DXVAHD_STREAM_STATE_FILTER_DATA
    {
    BOOL Enable;
    INT Level;
    } 	DXVAHD_STREAM_STATE_FILTER_DATA;

typedef struct _DXVAHD_STREAM_STATE_PRIVATE_DATA
    {
    GUID Guid;
    UINT DataSize;
    void *pData;
    } 	DXVAHD_STREAM_STATE_PRIVATE_DATA;

typedef struct _DXVAHD_STREAM_DATA
    {
    BOOL Enable;
    UINT OutputIndex;
    UINT InputFrameOrField;
    UINT PastFrames;
    UINT FutureFrames;
    IDirect3DSurface9 **ppPastSurfaces;
    IDirect3DSurface9 *pInputSurface;
    IDirect3DSurface9 **ppFutureSurfaces;
    } 	DXVAHD_STREAM_DATA;





DEFINE_GUID(DXVAHD_STREAM_STATE_PRIVATE_IVTC, 0x9c601e3c,0x0f33,0x414c,0xa7,0x39,0x99,0x54,0x0e,0xe4,0x2d,0xa5);




typedef struct _DXVAHD_STREAM_STATE_PRIVATE_IVTC_DATA
    {
    BOOL Enable;
    UINT ITelecineFlags;
    UINT Frames;
    UINT InputField;
    } 	DXVAHD_STREAM_STATE_PRIVATE_IVTC_DATA;



extern RPC_IF_HANDLE __MIDL_itf_dxvahd_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxvahd_0000_0000_v0_0_s_ifspec;

#ifndef __IDXVAHD_Device_INTERFACE_DEFINED__
#define __IDXVAHD_Device_INTERFACE_DEFINED__

/* interface IDXVAHD_Device */
/* [local][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXVAHD_Device;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("95f12dfd-d77e-49be-815f-57d579634d6d")
    IDXVAHD_Device : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateVideoSurface( 
            /* [annotation][in] */ 
            __in  UINT Width,
            /* [annotation][in] */ 
            __in  UINT Height,
            /* [annotation][in] */ 
            __in  D3DFORMAT Format,
            /* [annotation][in] */ 
            __in  D3DPOOL Pool,
            /* [annotation][in] */ 
            __in  DWORD Usage,
            /* [annotation][in] */ 
            __in  DXVAHD_SURFACE_TYPE Type,
            /* [annotation][in] */ 
            __in  UINT NumSurfaces,
            /* [annotation][size_is][out] */ 
            __out_ecount(NumSurfaces)  IDirect3DSurface9 **ppSurfaces,
            /* [annotation][out][in] */ 
            __inout_opt  HANDLE *pSharedHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoProcessorDeviceCaps( 
            /* [annotation][out] */ 
            __out  DXVAHD_VPDEVCAPS *pCaps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoProcessorOutputFormats( 
            /* [annotation][in] */ 
            __in  UINT Count,
            /* [annotation][size_is][out] */ 
            __out_ecount(Count)  D3DFORMAT *pFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoProcessorInputFormats( 
            /* [annotation][in] */ 
            __in  UINT Count,
            /* [annotation][size_is][out] */ 
            __out_ecount(Count)  D3DFORMAT *pFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoProcessorCaps( 
            /* [annotation][in] */ 
            __in  UINT Count,
            /* [annotation][size_is][out] */ 
            __out_ecount(Count)  DXVAHD_VPCAPS *pCaps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoProcessorCustomRates( 
            /* [annotation][in] */ 
            __in  const GUID *pVPGuid,
            /* [annotation][in] */ 
            __in  UINT Count,
            /* [annotation][size_is][out] */ 
            __out_ecount(Count)  DXVAHD_CUSTOM_RATE_DATA *pRates) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoProcessorFilterRange( 
            /* [annotation][in] */ 
            __in  DXVAHD_FILTER Filter,
            /* [annotation][out] */ 
            __out  DXVAHD_FILTER_RANGE_DATA *pRange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateVideoProcessor( 
            /* [annotation][in] */ 
            __in  const GUID *pVPGuid,
            /* [annotation][out] */ 
            __deref_out  IDXVAHD_VideoProcessor **ppVideoProcessor) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXVAHD_DeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXVAHD_Device * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXVAHD_Device * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXVAHD_Device * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateVideoSurface )( 
            IDXVAHD_Device * This,
            /* [annotation][in] */ 
            __in  UINT Width,
            /* [annotation][in] */ 
            __in  UINT Height,
            /* [annotation][in] */ 
            __in  D3DFORMAT Format,
            /* [annotation][in] */ 
            __in  D3DPOOL Pool,
            /* [annotation][in] */ 
            __in  DWORD Usage,
            /* [annotation][in] */ 
            __in  DXVAHD_SURFACE_TYPE Type,
            /* [annotation][in] */ 
            __in  UINT NumSurfaces,
            /* [annotation][size_is][out] */ 
            __out_ecount(NumSurfaces)  IDirect3DSurface9 **ppSurfaces,
            /* [annotation][out][in] */ 
            __inout_opt  HANDLE *pSharedHandle);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoProcessorDeviceCaps )( 
            IDXVAHD_Device * This,
            /* [annotation][out] */ 
            __out  DXVAHD_VPDEVCAPS *pCaps);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoProcessorOutputFormats )( 
            IDXVAHD_Device * This,
            /* [annotation][in] */ 
            __in  UINT Count,
            /* [annotation][size_is][out] */ 
            __out_ecount(Count)  D3DFORMAT *pFormats);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoProcessorInputFormats )( 
            IDXVAHD_Device * This,
            /* [annotation][in] */ 
            __in  UINT Count,
            /* [annotation][size_is][out] */ 
            __out_ecount(Count)  D3DFORMAT *pFormats);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoProcessorCaps )( 
            IDXVAHD_Device * This,
            /* [annotation][in] */ 
            __in  UINT Count,
            /* [annotation][size_is][out] */ 
            __out_ecount(Count)  DXVAHD_VPCAPS *pCaps);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoProcessorCustomRates )( 
            IDXVAHD_Device * This,
            /* [annotation][in] */ 
            __in  const GUID *pVPGuid,
            /* [annotation][in] */ 
            __in  UINT Count,
            /* [annotation][size_is][out] */ 
            __out_ecount(Count)  DXVAHD_CUSTOM_RATE_DATA *pRates);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoProcessorFilterRange )( 
            IDXVAHD_Device * This,
            /* [annotation][in] */ 
            __in  DXVAHD_FILTER Filter,
            /* [annotation][out] */ 
            __out  DXVAHD_FILTER_RANGE_DATA *pRange);
        
        HRESULT ( STDMETHODCALLTYPE *CreateVideoProcessor )( 
            IDXVAHD_Device * This,
            /* [annotation][in] */ 
            __in  const GUID *pVPGuid,
            /* [annotation][out] */ 
            __deref_out  IDXVAHD_VideoProcessor **ppVideoProcessor);
        
        END_INTERFACE
    } IDXVAHD_DeviceVtbl;

    interface IDXVAHD_Device
    {
        CONST_VTBL struct IDXVAHD_DeviceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXVAHD_Device_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDXVAHD_Device_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDXVAHD_Device_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDXVAHD_Device_CreateVideoSurface(This,Width,Height,Format,Pool,Usage,Type,NumSurfaces,ppSurfaces,pSharedHandle)	\
    ( (This)->lpVtbl -> CreateVideoSurface(This,Width,Height,Format,Pool,Usage,Type,NumSurfaces,ppSurfaces,pSharedHandle) ) 

#define IDXVAHD_Device_GetVideoProcessorDeviceCaps(This,pCaps)	\
    ( (This)->lpVtbl -> GetVideoProcessorDeviceCaps(This,pCaps) ) 

#define IDXVAHD_Device_GetVideoProcessorOutputFormats(This,Count,pFormats)	\
    ( (This)->lpVtbl -> GetVideoProcessorOutputFormats(This,Count,pFormats) ) 

#define IDXVAHD_Device_GetVideoProcessorInputFormats(This,Count,pFormats)	\
    ( (This)->lpVtbl -> GetVideoProcessorInputFormats(This,Count,pFormats) ) 

#define IDXVAHD_Device_GetVideoProcessorCaps(This,Count,pCaps)	\
    ( (This)->lpVtbl -> GetVideoProcessorCaps(This,Count,pCaps) ) 

#define IDXVAHD_Device_GetVideoProcessorCustomRates(This,pVPGuid,Count,pRates)	\
    ( (This)->lpVtbl -> GetVideoProcessorCustomRates(This,pVPGuid,Count,pRates) ) 

#define IDXVAHD_Device_GetVideoProcessorFilterRange(This,Filter,pRange)	\
    ( (This)->lpVtbl -> GetVideoProcessorFilterRange(This,Filter,pRange) ) 

#define IDXVAHD_Device_CreateVideoProcessor(This,pVPGuid,ppVideoProcessor)	\
    ( (This)->lpVtbl -> CreateVideoProcessor(This,pVPGuid,ppVideoProcessor) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDXVAHD_Device_INTERFACE_DEFINED__ */


#ifndef __IDXVAHD_VideoProcessor_INTERFACE_DEFINED__
#define __IDXVAHD_VideoProcessor_INTERFACE_DEFINED__

/* interface IDXVAHD_VideoProcessor */
/* [local][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXVAHD_VideoProcessor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("95f4edf4-6e03-4cd7-be1b-3075d665aa52")
    IDXVAHD_VideoProcessor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetVideoProcessBltState( 
            /* [annotation][in] */ 
            __in  DXVAHD_BLT_STATE State,
            /* [annotation][in] */ 
            __in  UINT DataSize,
            /* [annotation][in] */ 
            __in_bcount(DataSize)  const void *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoProcessBltState( 
            /* [annotation][in] */ 
            __in  DXVAHD_BLT_STATE State,
            /* [annotation][in] */ 
            __in  UINT DataSize,
            /* [annotation][out] */ 
            __inout_bcount(DataSize)  void *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVideoProcessStreamState( 
            /* [annotation][in] */ 
            __in  UINT StreamNumber,
            /* [annotation][in] */ 
            __in  DXVAHD_STREAM_STATE State,
            /* [annotation][in] */ 
            __in  UINT DataSize,
            /* [annotation][in] */ 
            __in_bcount(DataSize)  const void *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoProcessStreamState( 
            /* [annotation][in] */ 
            __in  UINT StreamNumber,
            /* [annotation][in] */ 
            __in  DXVAHD_STREAM_STATE State,
            /* [annotation][in] */ 
            __in  UINT DataSize,
            /* [annotation][out] */ 
            __inout_bcount(DataSize)  void *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE VideoProcessBltHD( 
            /* [annotation][in] */ 
            __in  IDirect3DSurface9 *pOutputSurface,
            /* [annotation][in] */ 
            __in  UINT OutputFrame,
            /* [annotation][in] */ 
            __in  UINT StreamCount,
            /* [annotation][size_is][in] */ 
            __in_ecount(StreamCount)  const DXVAHD_STREAM_DATA *pStreams) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXVAHD_VideoProcessorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXVAHD_VideoProcessor * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXVAHD_VideoProcessor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXVAHD_VideoProcessor * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetVideoProcessBltState )( 
            IDXVAHD_VideoProcessor * This,
            /* [annotation][in] */ 
            __in  DXVAHD_BLT_STATE State,
            /* [annotation][in] */ 
            __in  UINT DataSize,
            /* [annotation][in] */ 
            __in_bcount(DataSize)  const void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoProcessBltState )( 
            IDXVAHD_VideoProcessor * This,
            /* [annotation][in] */ 
            __in  DXVAHD_BLT_STATE State,
            /* [annotation][in] */ 
            __in  UINT DataSize,
            /* [annotation][out] */ 
            __inout_bcount(DataSize)  void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *SetVideoProcessStreamState )( 
            IDXVAHD_VideoProcessor * This,
            /* [annotation][in] */ 
            __in  UINT StreamNumber,
            /* [annotation][in] */ 
            __in  DXVAHD_STREAM_STATE State,
            /* [annotation][in] */ 
            __in  UINT DataSize,
            /* [annotation][in] */ 
            __in_bcount(DataSize)  const void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoProcessStreamState )( 
            IDXVAHD_VideoProcessor * This,
            /* [annotation][in] */ 
            __in  UINT StreamNumber,
            /* [annotation][in] */ 
            __in  DXVAHD_STREAM_STATE State,
            /* [annotation][in] */ 
            __in  UINT DataSize,
            /* [annotation][out] */ 
            __inout_bcount(DataSize)  void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *VideoProcessBltHD )( 
            IDXVAHD_VideoProcessor * This,
            /* [annotation][in] */ 
            __in  IDirect3DSurface9 *pOutputSurface,
            /* [annotation][in] */ 
            __in  UINT OutputFrame,
            /* [annotation][in] */ 
            __in  UINT StreamCount,
            /* [annotation][size_is][in] */ 
            __in_ecount(StreamCount)  const DXVAHD_STREAM_DATA *pStreams);
        
        END_INTERFACE
    } IDXVAHD_VideoProcessorVtbl;

    interface IDXVAHD_VideoProcessor
    {
        CONST_VTBL struct IDXVAHD_VideoProcessorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXVAHD_VideoProcessor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDXVAHD_VideoProcessor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDXVAHD_VideoProcessor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDXVAHD_VideoProcessor_SetVideoProcessBltState(This,State,DataSize,pData)	\
    ( (This)->lpVtbl -> SetVideoProcessBltState(This,State,DataSize,pData) ) 

#define IDXVAHD_VideoProcessor_GetVideoProcessBltState(This,State,DataSize,pData)	\
    ( (This)->lpVtbl -> GetVideoProcessBltState(This,State,DataSize,pData) ) 

#define IDXVAHD_VideoProcessor_SetVideoProcessStreamState(This,StreamNumber,State,DataSize,pData)	\
    ( (This)->lpVtbl -> SetVideoProcessStreamState(This,StreamNumber,State,DataSize,pData) ) 

#define IDXVAHD_VideoProcessor_GetVideoProcessStreamState(This,StreamNumber,State,DataSize,pData)	\
    ( (This)->lpVtbl -> GetVideoProcessStreamState(This,StreamNumber,State,DataSize,pData) ) 

#define IDXVAHD_VideoProcessor_VideoProcessBltHD(This,pOutputSurface,OutputFrame,StreamCount,pStreams)	\
    ( (This)->lpVtbl -> VideoProcessBltHD(This,pOutputSurface,OutputFrame,StreamCount,pStreams) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDXVAHD_VideoProcessor_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxvahd_0000_0002 */
/* [local] */ 





typedef HRESULT (CALLBACK* PDXVAHDSW_CreateDevice)(

    __in IDirect3DDevice9Ex* pD3DDevice,

    __out HANDLE* phDevice

    );



typedef HRESULT (CALLBACK* PDXVAHDSW_ProposeVideoPrivateFormat)(

    __in HANDLE hDevice,

    __inout D3DFORMAT* pFormat

    );



typedef HRESULT (CALLBACK* PDXVAHDSW_GetVideoProcessorDeviceCaps)(

    __in HANDLE hDevice,

    __in const DXVAHD_CONTENT_DESC* pContentDesc,

    __in DXVAHD_DEVICE_USAGE Usage,

    __out DXVAHD_VPDEVCAPS* pCaps

    );



typedef HRESULT (CALLBACK* PDXVAHDSW_GetVideoProcessorOutputFormats)(

    __in HANDLE hDevice,

    __in const DXVAHD_CONTENT_DESC* pContentDesc,

    __in DXVAHD_DEVICE_USAGE Usage,

    __in UINT Count,

    __out_ecount(Count) D3DFORMAT* pFormats

    );



typedef HRESULT (CALLBACK* PDXVAHDSW_GetVideoProcessorInputFormats)(

    __in HANDLE hDevice,

    __in const DXVAHD_CONTENT_DESC* pContentDesc,

    __in DXVAHD_DEVICE_USAGE Usage,

    __in UINT Count,

    __out_ecount(Count) D3DFORMAT* pFormats

    );



typedef HRESULT (CALLBACK* PDXVAHDSW_GetVideoProcessorCaps)(

    __in HANDLE hDevice,

    __in const DXVAHD_CONTENT_DESC* pContentDesc,

    __in DXVAHD_DEVICE_USAGE Usage,

    __in UINT Count,

    __out_ecount(Count) DXVAHD_VPCAPS* pCaps

    );



typedef HRESULT (CALLBACK* PDXVAHDSW_GetVideoProcessorCustomRates)(

    __in HANDLE hDevice,

    __in const GUID* pVPGuid,

    __in UINT Count,

    __out_ecount(Count) DXVAHD_CUSTOM_RATE_DATA* pRates

    );



typedef HRESULT (CALLBACK* PDXVAHDSW_GetVideoProcessorFilterRange)(

    __in HANDLE hDevice,

    __in DXVAHD_FILTER Filter,

    __out DXVAHD_FILTER_RANGE_DATA* pRange

    );



typedef HRESULT (CALLBACK* PDXVAHDSW_DestroyDevice)(

    __in HANDLE hDevice

    );



typedef HRESULT (CALLBACK* PDXVAHDSW_CreateVideoProcessor)(

    __in HANDLE hDevice,

    __in const GUID* pVPGuid,

    __out HANDLE* phVideoProcessor

    );



typedef HRESULT (CALLBACK* PDXVAHDSW_SetVideoProcessBltState)(

    __in HANDLE hVideoProcessor,

    __in DXVAHD_BLT_STATE State,

    __in UINT DataSize,

    __in_bcount(DataSize) const void* pData

    );



typedef HRESULT (CALLBACK* PDXVAHDSW_GetVideoProcessBltStatePrivate)(

    __in HANDLE hVideoProcessor,

    __inout DXVAHD_BLT_STATE_PRIVATE_DATA* pData

    );



typedef HRESULT (CALLBACK* PDXVAHDSW_SetVideoProcessStreamState)(

    __in HANDLE hVideoProcessor,

    __in UINT StreamNumber,

    __in DXVAHD_STREAM_STATE State,

    __in UINT DataSize,

    __in_bcount(DataSize) const void* pData

    );



typedef HRESULT (CALLBACK* PDXVAHDSW_GetVideoProcessStreamStatePrivate)(

    __in HANDLE hVideoProcessor,

    __in UINT StreamNumber,

    __inout DXVAHD_STREAM_STATE_PRIVATE_DATA* pData

    );



typedef HRESULT (CALLBACK* PDXVAHDSW_VideoProcessBltHD)(

    __in HANDLE hVideoProcessor,

    __in IDirect3DSurface9* pOutputSurface,

    __in UINT OutputFrame,

    __in UINT StreamCount,

    __in_ecount(StreamCount) const DXVAHD_STREAM_DATA* pStreams

    );



typedef HRESULT (CALLBACK* PDXVAHDSW_DestroyVideoProcessor)(

    __in HANDLE hVideoProcessor

    );



typedef struct _DXVAHDSW_CALLBACKS

{

    PDXVAHDSW_CreateDevice                      CreateDevice;

    PDXVAHDSW_ProposeVideoPrivateFormat         ProposeVideoPrivateFormat;

    PDXVAHDSW_GetVideoProcessorDeviceCaps       GetVideoProcessorDeviceCaps;

    PDXVAHDSW_GetVideoProcessorOutputFormats    GetVideoProcessorOutputFormats;

    PDXVAHDSW_GetVideoProcessorInputFormats     GetVideoProcessorInputFormats;

    PDXVAHDSW_GetVideoProcessorCaps             GetVideoProcessorCaps;

    PDXVAHDSW_GetVideoProcessorCustomRates      GetVideoProcessorCustomRates;

    PDXVAHDSW_GetVideoProcessorFilterRange      GetVideoProcessorFilterRange;

    PDXVAHDSW_DestroyDevice                     DestroyDevice;

    PDXVAHDSW_CreateVideoProcessor              CreateVideoProcessor;

    PDXVAHDSW_SetVideoProcessBltState           SetVideoProcessBltState;

    PDXVAHDSW_GetVideoProcessBltStatePrivate    GetVideoProcessBltStatePrivate;

    PDXVAHDSW_SetVideoProcessStreamState        SetVideoProcessStreamState;

    PDXVAHDSW_GetVideoProcessStreamStatePrivate GetVideoProcessStreamStatePrivate;

    PDXVAHDSW_VideoProcessBltHD                 VideoProcessBltHD;

    PDXVAHDSW_DestroyVideoProcessor             DestroyVideoProcessor;

} DXVAHDSW_CALLBACKS;



typedef HRESULT (CALLBACK* PDXVAHDSW_Plugin)(

    __in UINT Size,

    __out_bcount(Size) void* pCallbacks

    );








DEFINE_GUID(DXVAHDControlGuid, 0xa0386e75,0xf70c,0x464c,0xa9,0xce,0x33,0xc4,0x4e,0x09,0x16,0x23); 



DEFINE_GUID(DXVAHDETWGUID_CREATEVIDEOPROCESSOR,     0x681e3d1e,0x5674,0x4fb3,0xa5,0x03,0x2f,0x20,0x55,0xe9,0x1f,0x60);

DEFINE_GUID(DXVAHDETWGUID_VIDEOPROCESSBLTSTATE,     0x76c94b5a,0x193f,0x4692,0x94,0x84,0xa4,0xd9,0x99,0xda,0x81,0xa8);

DEFINE_GUID(DXVAHDETWGUID_VIDEOPROCESSSTREAMSTATE,  0x262c0b02,0x209d,0x47ed,0x94,0xd8,0x82,0xae,0x02,0xb8,0x4a,0xa7);

DEFINE_GUID(DXVAHDETWGUID_VIDEOPROCESSBLTHD,        0xbef3d435,0x78c7,0x4de3,0x97,0x07,0xcd,0x1b,0x08,0x3b,0x16,0x0a);

DEFINE_GUID(DXVAHDETWGUID_VIDEOPROCESSBLTHD_STREAM, 0x27ae473e,0xa5fc,0x4be5,0xb4,0xe3,0xf2,0x49,0x94,0xd3,0xc4,0x95);

DEFINE_GUID(DXVAHDETWGUID_DESTROYVIDEOPROCESSOR,    0xf943f0a0,0x3f16,0x43e0,0x80,0x93,0x10,0x5a,0x98,0x6a,0xa5,0xf1);




typedef struct _DXVAHDETW_CREATEVIDEOPROCESSOR
    {
    ULONGLONG pObject;
    ULONGLONG pD3D9Ex;
    GUID VPGuid;
    } 	DXVAHDETW_CREATEVIDEOPROCESSOR;

typedef struct _DXVAHDETW_VIDEOPROCESSBLTSTATE
    {
    ULONGLONG pObject;
    DXVAHD_BLT_STATE State;
    UINT DataSize;
    BOOL SetState;
    } 	DXVAHDETW_VIDEOPROCESSBLTSTATE;

typedef struct _DXVAHDETW_VIDEOPROCESSSTREAMSTATE
    {
    ULONGLONG pObject;
    UINT StreamNumber;
    DXVAHD_STREAM_STATE State;
    UINT DataSize;
    BOOL SetState;
    } 	DXVAHDETW_VIDEOPROCESSSTREAMSTATE;

typedef struct _DXVAHDETW_VIDEOPROCESSBLTHD
    {
    ULONGLONG pObject;
    ULONGLONG pOutputSurface;
    RECT TargetRect;
    D3DFORMAT OutputFormat;
    UINT ColorSpace;
    UINT OutputFrame;
    UINT StreamCount;
    BOOL Enter;
    } 	DXVAHDETW_VIDEOPROCESSBLTHD;

typedef struct _DXVAHDETW_VIDEOPROCESSBLTHD_STREAM
    {
    ULONGLONG pObject;
    ULONGLONG pInputSurface;
    RECT SourceRect;
    RECT DestinationRect;
    D3DFORMAT InputFormat;
    DXVAHD_FRAME_FORMAT FrameFormat;
    UINT ColorSpace;
    UINT StreamNumber;
    UINT OutputIndex;
    UINT InputFrameOrField;
    UINT PastFrames;
    UINT FutureFrames;
    } 	DXVAHDETW_VIDEOPROCESSBLTHD_STREAM;

typedef struct _DXVAHDETW_DESTROYVIDEOPROCESSOR
    {
    ULONGLONG pObject;
    } 	DXVAHDETW_DESTROYVIDEOPROCESSOR;





HRESULT WINAPI

DXVAHD_CreateDevice(

    __in IDirect3DDevice9Ex* pD3DDevice,

    __in const DXVAHD_CONTENT_DESC* pContentDesc,

    __in DXVAHD_DEVICE_USAGE Usage,

    __in_opt PDXVAHDSW_Plugin pPlugin,

    __deref_out IDXVAHD_Device** ppDevice

    );



typedef HRESULT (WINAPI* PDXVAHD_CreateDevice)(

    __in IDirect3DDevice9Ex* pD3DDevice,

    __in const DXVAHD_CONTENT_DESC* pContentDesc,

    __in DXVAHD_DEVICE_USAGE Usage,

    __in_opt PDXVAHDSW_Plugin pPlugin,

    __deref_out IDXVAHD_Device** ppDevice

    );






extern RPC_IF_HANDLE __MIDL_itf_dxvahd_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxvahd_0000_0002_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\EapAuthenticatorActionDefine.h ===
////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation.
//
// SYNOPSIS
//
//    IDL source for interaction with EAPHost supplicants.
//
////////////////////////////////////////////////////////////

#ifndef EAPAUTHENTICATORACTIONDEFINE_H
#define EAPAUTHENTICATORACTIONDEFINE_H

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

typedef
#ifdef __midl
   [v1_enum]
#endif
enum _EAP_METHOD_AUTHENTICATOR_RESPONSE_ACTION
{
   // Discard the request as EAP cannot use it.
   EAP_METHOD_AUTHENTICATOR_RESPONSE_DISCARD = 0,
   // Send the packet to the authenticator
   EAP_METHOD_AUTHENTICATOR_RESPONSE_SEND,
   // Respond to EAP by acting on the returned attributes
   EAP_METHOD_AUTHENTICATOR_RESPONSE_RESULT,
   // The supplicant needs to take an action based on the context.
   EAP_METHOD_AUTHENTICATOR_RESPONSE_RESPOND,
   EAP_METHOD_AUTHENTICATOR_RESPONSE_AUTHENTICATE,
   EAP_METHOD_AUTHENTICATOR_RESPONSE_HANDLE_IDENTITY
   // The supplicant needs to take no action at all.
   //EAP_METHOD_AUTHENTICATOR_RESPONSE_NONE
} EAP_METHOD_AUTHENTICATOR_RESPONSE_ACTION;

typedef struct _EAP_METHOD_AUTHENTICATOR_RESULT
{
   BOOL fIsSuccess;
   DWORD dwFailureReason;
   EAP_ATTRIBUTES* pAuthAttribs;
} EAP_METHOD_AUTHENTICATOR_RESULT;

typedef
#ifdef __midl
   [v1_enum]
#endif
enum tagEapPeerMethodResponseAction
{
        // Discard the request as EAP cannot use it.
        EapPeerMethodResponseActionDiscard = 0,
        // Send the packet to the authenticator
        EapPeerMethodResponseActionSend,
        // Respond to EAP by acting on the returned attributes
        EapPeerMethodResponseActionResult,
        // Invoke appropriate UI based on the context
        EapPeerMethodResponseActionInvokeUI,
        // The supplicant needs to take an action based on the context.
        EapPeerMethodResponseActionRespond,
        // The supplicant needs to take no action at all.
        EapPeerMethodResponseActionNone
} EapPeerMethodResponseAction;

// Structures used by EAP methods on the peer to communicate with the host.

typedef struct tagEapPeerMethodOuput 
{
        //EapPeerMethodDecision decision;
        //EapPeerMethodState state;
        EapPeerMethodResponseAction action;
        BOOL fAllowNotifications;
} EapPeerMethodOutput;

// ENUMERATIONS USED by EAP methods on the peer to communicate their status to
// EapHost.

typedef
#ifdef __midl
   [v1_enum]
#endif
enum tagEapPeerMethodResultReason
{
   EapPeerMethodResultUnknown = 1,
   EapPeerMethodResultSuccess,
   EapPeerMethodResultFailure
} EapPeerMethodResultReason, EapPeerMethodResultReasonOle;

#ifdef __cplusplus
}
#endif

#endif // EAPAUTHENTICATORACTIONDEFINE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\EapHostPeerTypes.h ===
////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation.
//
// SYNOPSIS
//
//    IDL source for interaction with EAPHost supplicants.
//
////////////////////////////////////////////////////////////

#ifndef EAPHOSTPEERTYPES_H
#define EAPHOSTPEERTYPES_H
#pragma once

// Request to provide guest access.
#define EAP_PEER_FLAG_GUEST_ACCESS           0x00000040 

typedef
#ifdef __midl
   [v1_enum]
#endif


// Possible reasons for which EAP-method can call getResult from EAPhost 
enum tagEapHostPeerMethodResultReason
{
   // if method has obtained success from some
   EapHostPeerMethodResultAltSuccessReceived = 1,

   // method timedout waiting for response
   EapHostPeerMethodResultTimeout,

   // normal completion of authentication process
   EapHostPeerMethodResultFromMethod
} EapHostPeerMethodResultReason;

   
typedef
#ifdef __midl
   [v1_enum]
#endif
enum tagEapHostPeerResponseAction
{
        // Discard the request as EAP cannot use it.
        EapHostPeerResponseDiscard = 0,
        // Send the packet to the authenticator
        EapHostPeerResponseSend,
        // Respond to EAP by acting on the returned attributes
        EapHostPeerResponseResult,
        // Invoke appropriate UI based on the context
        EapHostPeerResponseInvokeUi,
        // Display a string to the user received as part of a notification 
        // request
        // EapHostPeerResponseNotification,
        // The supplicant needs to take an action based on the context.
        EapHostPeerResponseRespond,
        // The supplicant needs to restart authentication with the same session. 
   //EapHostPeerResponseResetAuthentication,
        // The session could not be found. So the supplicant either needs to 
        // start session again with the same packet or discard the packet. 
   EapHostPeerResponseStartAuthentication,
        // The supplicant needs to take no action at all.
        EapHostPeerResponseNone
} EapHostPeerResponseAction;


typedef
#ifdef __midl
   [v1_enum]
#endif
enum tagEapHostPeerAuthParams {
   EapHostPeerAuthStatus = 1,    // current auth status
   EapHostPeerIdentity,           // obtain the inner method id
   EapHostPeerIdentityExtendedInfo, // obtained from Identity packet
                                                                  // This includes NLA information for wireless
   EapHostNapInfo //obtain the Nap details
} EapHostPeerAuthParams;


typedef
#ifdef __midl
   [v1_enum]
#endif

// possible values for EAP status during authentication process
enum _EAPHOST_AUTH_STATUS
{
   EapHostInvalidSession = 0,
   EapHostAuthNotStarted,
   EapHostAuthIdentityExchange,
   EapHostAuthNegotiatingType,
   EapHostAuthInProgress,
   EapHostAuthSucceeded,
   EapHostAuthFailed
} EAPHOST_AUTH_STATUS;


// describes the current authentication info through different stages
// of EAP authentication process.
typedef struct _EAPHOST_AUTH_INFO
{
   EAPHOST_AUTH_STATUS status;
   DWORD dwErrorCode;
   DWORD dwReasonCode;
} EAPHOST_AUTH_INFO;


// Describes the isolation state of a machine, i.e. 
// whether connectivity is affected.
typedef
#ifdef __midl
   [v1_enum]
#endif
enum _ISOLATION_STATE
{
   ISOLATION_STATE_UNKNOWN = 0,
   ISOLATION_STATE_NOT_RESTRICTED = 1,
   ISOLATION_STATE_IN_PROBATION = 2,
   ISOLATION_STATE_RESTRICTED_ACCESS = 3
} ISOLATION_STATE;

// This carries the result information passed from EAPHost to EAP-method,
// when EAP-method calls GetResult
typedef struct tagEapHostPeerMethodResult
{
   BOOL fIsSuccess;
   UINT32 dwFailureReasonCode;
   BOOL fSaveConnectionData;
   UINT32 dwSizeofConnectionData;
#ifdef __midl   
   [size_is(dwSizeofConnectionData)] BYTE* pConnectionData;
#else
   BYTE* pConnectionData;
#endif
   BOOL fSaveUserData;
   UINT32 dwSizeofUserData;
#ifdef __midl   
   [size_is(dwSizeofUserData)] BYTE* pUserData;
#else
   BYTE* pUserData;
#endif
   EAP_ATTRIBUTES* pAttribArray;
   ISOLATION_STATE isolationState;      
   EAP_METHOD_INFO* pEapMethodInfo;
   EAP_ERROR* pEapError;
} EapHostPeerMethodResult;

#endif //EAPHOSTPEERTYPES_IDL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\eaphostpeerconfigapis.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares methods that are used to configure EAP methods.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef EAPHOSTPEERCONFIGAPIS_H
#define EAPHOSTPEERCONFIGAPIS_H
#pragma once

#include "objbase.h"    //Required by msxml2.h
#include "msxml6.h"

#include "EapTypes.h"

#ifdef __cplusplus
extern "C" {
#endif


// This API is used to enumerate all the EAP Methods installed and available for use; this
// includes legacy EAP Methods too. Returns non zero return code up on error.
DWORD WINAPI EapHostPeerGetMethods(
                // API fills the structure to have installed EAP Methods. Caller should free the inner pointers
                // using EapHostPeerFreeMemory starting at the inner most pointer.
                OUT EAP_METHOD_INFO_ARRAY* pEapMethodInfoArray,
                // In case of error, API fills ppEapError if possible. Caller should free ppEapError using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** ppEapError
                );


// This API is used to retrieve the method properties for a specific configuration
// It returns non zero return code upon error.
DWORD WINAPI EapHostPeerGetMethodProperties(
                // The version number of the API.
                IN DWORD dwVersion,
                // A combination of EAP flags that describe the EAP authentication session behavior.
                IN DWORD dwFlags,
                // An EAP_METHOD_TYPE structure that identifies the EAP method the supplicant is to use.
                IN EAP_METHOD_TYPE eapMethodType,
                // A handle to the user impersonation token to use in this session.
                IN HANDLE hUserImpersonationToken,
                // The size, in bytes, of the connection data buffer provided in pbEapConnData.
                IN DWORD dwEapConnDataSize,
                // Connection data used for the EAP method.
                IN __in_ecount(dwEapConnDataSize) const BYTE* pbEapConnData,
                // The size in bytes of the user data buffer provided in pbUserData.
                IN DWORD dwUserDataSize,
                // A pointer to a byte buffer that contains the opaque user data BLOB.
                IN __in_ecount(dwUserDataSize) const BYTE* pbUserData,
                // A pointer to the method properties array. Caller should free the inner pointers using EapHostPeerFreeMemory starting
                // at the inner most pointer. The caller should free empvString value only when the type is empvtString.
                OUT EAP_METHOD_PROPERTY_ARRAY* pMethodPropertyArray,
                // A pointer to a pointer to an EAP_ERROR structure that contains any errors raised by EAPHost
                // during the execution of this function call.
                OUT EAP_ERROR** ppEapError
                );


// This API is used to invoke configure UI of the specified EAP Method.
// API Returns non zero return code up on error.
DWORD WINAPI EapHostPeerInvokeConfigUI(
                // window handle of the parent window under which configuration dialog will show up
                IN HWND hwndParent,
                // Flags to control the behavior of the EAP Method.
                IN DWORD dwFlags,
                // Identifies the EAP Method to configure
                IN EAP_METHOD_TYPE eapMethodType,
                // Size of input configuration; this could be 0 when there is no configuration
                IN DWORD dwSizeOfConfigIn,
                // input configuration, this couldb NULL when there is no configuration
                IN __in_ecount_opt(dwSizeOfConfigIn) const BYTE* pConfigIn,
                // pointer to DWORD that receives configuration after user updated using UI
                OUT DWORD* pdwSizeOfConfigOut,
                // buffer that receives updated configuration after user updated using UI.
                // Caller should free the memory using EapHostPeerFreeMemory.
                OUT BYTE** ppConfigOut,
                // In case of error, API fills ppEapError if possible. Caller should free ppEapError using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** ppEapError
                );

// This API is used to obtain the fields to be shown in Single Sign On scenario for
// showing UI in long screen. The structures returned have details on how to show the fields.
// API Returns non zero return code up on error.
DWORD WINAPI EapHostPeerQueryCredentialInputFields(
                // handle to the impersonation token that is used while signle sign on.
                IN HANDLE hUserImpersonationToken,
                // identifies the EAP Method supplicant wants to use
                IN EAP_METHOD_TYPE eapMethodType,
                // control the behavior of the EAP Methods
                IN DWORD dwFlags,
                // size of input configuration data
                IN DWORD dwEapConnDataSize,
                // configuration data that is used for the EAP method
                IN __in_ecount(dwEapConnDataSize) const BYTE* pbEapConnData,
                // structure that gets filled with fields and how they should be shown to the user.
                // Caller should free the inner pointers using EapHostPeerFreeMemory starting
                // at the inner most pointer.
                OUT EAP_CONFIG_INPUT_FIELD_ARRAY *pEapConfigInputFieldArray,
                // In case of error, API fills ppEapError if possible. Caller should free ppEapError using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** ppEapError
                );


// Supplicant up on receiving user inputs from Single Sign On UI, calls this API to obtain
// credential blob that could used start authentication
// API Returns non zero return code up on error.
DWORD WINAPI EapHostPeerQueryUserBlobFromCredentialInputFields(
                // handle to the impersonation token that is used while signle sign on.
                IN HANDLE hUserImpersonationToken,
                // identifies the EAP Method supplicant wants to use
                IN EAP_METHOD_TYPE eapMethodType,
                // control the behavior of the EAP Methods
                IN DWORD dwFlags,
                // size of input configuration data
                IN DWORD dwEapConnDataSize,
                // configuration data that is used for the EAP method
                IN __in_ecount(dwEapConnDataSize) const BYTE* pbEapConnData,
                // structure containing the data entered by the user in Single Sign On UI
                IN const EAP_CONFIG_INPUT_FIELD_ARRAY *pEapConfigInputFieldArray,
                // pointer to DWORD that receives the size of credential blob, if supplicant passes in
                // non-zero size and non-NULL data below, EAPHost will just attempt to Update
                // the blob with passed in values (if method supports) instead of creating a new one.
                IN OUT DWORD *pdwUserBlobSize,
                // Pointer that receives the credential blob that can be used in authentication.
                // For incoming data caller should always allocate this memory using LocalAlloc()
                // Caller should free the memory using EapHostPeerFreeMemory.
                IN OUT __deref_out_ecount(*pdwUserBlobSize) BYTE **ppbUserBlob,
                // In case of error, API fills ppEapError if possible. Caller should free ppEapError using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** ppEapError
                );


// Tunnel Methods call this function to invoke Identity UI of the inner Methods.
// This function returns the identity as well as the credentials to use to start the authentication.
DWORD WINAPI EapHostPeerInvokeIdentityUI (
                // API's version number for ease of interoperability. It must be 0.
                IN DWORD dwVersion,
                // identifies the EAP Method supplicant wants to use
                IN EAP_METHOD_TYPE eapMethodType,
                // EAP_FLAG_xxx defined in eaptypes.w
                IN DWORD dwFlags,
                // window handle of the parent window under which configuration dialog will show up
                IN HWND hwndParent,
                // size of the buffer (pConnectionData) in bytes
                IN DWORD dwSizeofConnectionData,
                // configuration data that is used for the EAP method
                IN __in_ecount(dwSizeofConnectionData) const BYTE* pConnectionData,
                // size of the ubuffer pUserData
                IN DWORD dwSizeofUserData,
                // user credential information pertinent to this auth
                IN __in_ecount_opt(dwSizeofUserData) const BYTE* pUserData,
                // size of the buffer pUserDataOut.
                IN OUT DWORD* pdwSizeOfUserDataOut,
                // user data information returned by method.
                // Caller should release this using EapHostPeerFreeMemory
                OUT __deref_out_ecount(*pdwSizeOfUserDataOut)BYTE** ppUserDataOut,
                // identity returned by method. Caller should release this using EapHostPeerFreeMemory
                OUT __deref_out LPWSTR* ppwszIdentity,
                // In case of error, API fills ppEapError if possible. Caller should free ppEapError
                // using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** ppEapError,
                // Reserved for future usage. It must be NULL.
                IN OUT LPVOID *ppvReserved
                );


// While doing authentication with EapHost, when supplicant receives action code of EapHostPeerResponseInvokeUi
// supplicant should call EapHostPeerGetUIContext to get UI context data. After that. it then should call this
// API from a process where UI can be brought up.
// API Returns non zero return code up on error.
DWORD WINAPI EapHostPeerInvokeInteractiveUI(
                // window handle of the parent window under which dialog will show up
                IN HWND hwndParent,
                // size of UIcontext data received from EapHostPeerGetUIContext call
                IN DWORD dwSizeofUIContextData,
                // UIcontext data received from EapHostPeerGetUIContext call
                IN __in_ecount_opt(dwSizeofUIContextData) const BYTE* pUIContextData,
                // pointer to DWORD that receives data from interactive UI that is used for authentication
                // to continue
                OUT DWORD* pdwSizeOfDataFromInteractiveUI,
                // pointer that receives buffer filled with interactive UI that is used for authentication
                // to continue. Caller should free the memory using EapHostPeerFreeMemory.
                OUT __deref_out_ecount(*pdwSizeOfDataFromInteractiveUI) BYTE** ppDataFromInteractiveUI,
                // In case of error, API fills ppEapError if possible. Caller should free ppEapError using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** ppEapError
                );

// This API will enable supplicants to collect necessary information from EAPHost to raise interactive UI and collect user information
// supplicant should call EapHostPeerQueryInteractiveUIInputFields() API first after it receives
// EapHostPeerResponseInvokeUi actionCode from EAPHost. If the return value from this API
// is EAP_E_EAPHOST_METHOD_OPERATION_NOT_SUPPORTED, then supplicant should fall back to
// traditional model of invoking method interactive UI, i.e. by calling EapHostPeerInvokeInteractiveUI()
// API Returns non zero return code up on error.
DWORD WINAPI EapHostPeerQueryInteractiveUIInputFields (
                // API's version number for ease of interoperability. It must be 0.
                IN DWORD dwVersion,
                // control the behavior of the EAP Methods
                IN DWORD dwFlags,
                // size of UIcontext data EAPHost runtime
                IN DWORD dwSizeofUIContextData,
                // UIContext data received from EAPHost runtime
                IN __in_ecount(dwSizeofUIContextData) const BYTE* pUIContextData,
                // structure that gets filled with fields and how they should be shown to the user.
                // Caller should free the inner pointers using EapHostPeerFreeMemory starting at the inner most pointer.
                OUT EAP_INTERACTIVE_UI_DATA *pEapInteractiveUIData,
                // In case of error, API fills ppEapError if possible.  Caller should free ppEapError using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** ppEapError,
                // Reserved for future usage. It must be NULL.
                IN OUT LPVOID *ppvReserved
                );

// This API will enable supplicants to convert user information into a user-blob which can be consumed by EAPHost runtime APIs
// API Returns non zero return code up on error.
DWORD WINAPI EapHostPeerQueryUIBlobFromInteractiveUIInputFields(
                // API's version number for ease of interoperability. It must be 0.
                IN DWORD dwVersion,
                // control the behavior of the EAP Methods
                IN DWORD dwFlags,
                // size of UIcontext data EAPHost runtime
                IN DWORD dwSizeofUIContextData,
                // UIContext data received from EAPHost runtime
                IN __in_ecount(dwSizeofUIContextData) const BYTE* pUIContextData,
                // structure that carries data provided by user
                IN const EAP_INTERACTIVE_UI_DATA *pEapInteractiveUIData,
                // pointer to DWORD that receives size of credential blob, if supplicant passes in
                // non-zero size and non-NULL data below, EAPHost will just attempt to Update
                // the blob with passed in values (if method supports) instead of creating a new one.
                IN OUT DWORD * pdwSizeOfDataFromInteractiveUI,
                // Pointer that receives the credential blob that can be used in authentication.
                // Caller should free the memory using EapHostPeerFreeMemory.
                IN OUT __deref_out_ecount(*pdwSizeOfDataFromInteractiveUI) BYTE ** ppDataFromInteractiveUI,
                // In case of error, API fills ppEapError if possible.  Caller should free ppEapError using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** ppEapError,
                // Reserved for future usage. It must be NULL.
                IN OUT LPVOID *ppvReserved
                );


// Supplicant can utilize XML based EAP configuration storing, managing, editing. When it wants to call EapHostPeerConfigureUI
// or when it has to start authentication, it calls this API to convert XML configuration into blob.
// API Returns non zero return code up on error.
DWORD WINAPI EapHostPeerConfigXml2Blob(
                // controls the behavior of the EAP Method
                IN DWORD dwFlags,
                // a node containing EAP XML configuration inside it
                IN IXMLDOMNode* pConfigDoc,
                // pointer to DWORD that receives the configuration blob size
                OUT DWORD* pdwSizeOfConfigOut,
                // pointer that receives configuration blob. Caller should free the memory using EapHostPeerFreeMemory.
                OUT __deref_out_ecount(*pdwSizeOfConfigOut) BYTE** ppConfigOut,
                // pointer that receives the EAP Method specified in the XML configuration
                OUT EAP_METHOD_TYPE* pEapMethodType,
                // In case of error, API fills ppEapError if possible. Caller should free ppEapError using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** ppEapError
                );


// Supplicant can utilize XML based EAP credentials storing, managing, editing. When it wants to start
// authentication, it calls this API to convert XML based credentials into blob.
// API Returns non zero return code up on error.
DWORD WINAPI EapHostPeerCredentialsXml2Blob(
                // controls the behavior of the EAP Method
                IN DWORD dwFlags,
                // XML node that contains credentials
                IN IXMLDOMNode* pCredentialsDoc,
                // size of configuration blob that the credentials are configured for
                IN DWORD dwSizeOfConfigIn,
                // configuration blob that the credentials are configured for
                IN __in_ecount(dwSizeOfConfigIn) BYTE* pConfigIn,
                // pointer to DWORD that receives size of the credentials blob.
                OUT  DWORD* pdwSizeOfCredentialsOut,
                // pointer that receives credential blob buffer.  Caller should free the memory using
                // EapHostPeerFreeMemory.
                OUT __deref_out_ecount(*pdwSizeOfCredentialsOut) BYTE** ppCredentialsOut,
                // pointer that receives the EAP Method specified in the XML configuration
                OUT EAP_METHOD_TYPE* pEapMethodType,
                // In case of error, API fills ppEapError if possible. Caller should free ppEapError using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** ppEapError
                );


// Supplicant can utilize XML based EAP credentials storing, managing, editing. When it wants to start
// convert configuration blob to XML, it can call this API.
// API Returns non zero return code up on error.
DWORD WINAPI EapHostPeerConfigBlob2Xml(
                // controls the behavior of the EAP Method
                IN DWORD dwFlags,
                // identifies the EAP Method
                IN EAP_METHOD_TYPE eapMethodType,
                // Size of configuration blob that supplicant wants to convert
                IN DWORD dwSizeOfConfigIn,
                // Configuration blob that supplicant wants to convert
                IN __in_ecount(dwSizeOfConfigDataIn) BYTE* pConfigIn,
                // XML document that contains XML form of the blob. If the EAP Method does not support
                // EapPeerConfigBlob2Xml function, the XML contains ConfigBlob node with blob in string form
                OUT IXMLDOMDocument2** ppConfigDoc,
                // In case of error, API fills ppEapError if possible. Caller should free ppEapError using EapHostPeerFreeErrorMemory
                OUT EAP_ERROR** ppEapError
                );

// Supplicant calls this API to free memory returned by Config APIs. Supplicant should not use this API
// for freeing EAP_ERROR structure.
VOID WINAPI EapHostPeerFreeMemory(BYTE* pData);

// Supplicant calls this API to free EAP_ERROR memory, which will get filled when an API fails.
VOID WINAPI EapHostPeerFreeErrorMemory(EAP_ERROR* pEapError);


#ifdef __cplusplus
}
#endif

#endif // EAPHOSTPEERCONFIGAPIS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\eapmethodtypes.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares datastructures that executes the peer eap state machine.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef EAPMETHODAPIS_H
#define EAPMETHODAPIS_H
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

// structure that represents EAP packet on the wire
typedef struct tagEapPacket
{
   BYTE Code;
   BYTE Id;
   BYTE Length[2];
   BYTE Data[1];
   // Any additional data following the first byte. The length of
   // the data can be deduced by the length fields.
} EapPacket;

//
// EAP packet codes from EAP spec.
//
typedef
#ifdef __midl
   [v1_enum]
#endif

// possible values for 'code' in EAPPacket
enum tagEapCode
{
   EapCodeMinimum = 1,
   EapCodeRequest = 1,
   EapCodeResponse,
   EapCodeSuccess,
   EapCodeFailure,
   EapCodeMaximum = EapCodeFailure
} EapCode;

// This is a handle to an eap session owned by the individual eap methods.
typedef VOID* EAP_SESSION_HANDLE;

   
#ifdef __cplusplus
}
#endif

#endif // EAPMETHODAPIS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\eapauthenticatortypes.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for eapauthenticatortypes.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __eapauthenticatortypes_h__
#define __eapauthenticatortypes_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_eapauthenticatortypes_0000_0000 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum _EAP_AUTHENTICATOR_SEND_TIMEOUT
    {	EAP_AUTHENTICATOR_SEND_TIMEOUT_NONE	= 0,
	EAP_AUTHENTICATOR_SEND_TIMEOUT_BASIC	= ( EAP_AUTHENTICATOR_SEND_TIMEOUT_NONE + 1 ) ,
	EAP_AUTHENTICATOR_SEND_TIMEOUT_INTERACTIVE	= ( EAP_AUTHENTICATOR_SEND_TIMEOUT_BASIC + 1 ) 
    } 	EAP_AUTHENTICATOR_SEND_TIMEOUT;



extern RPC_IF_HANDLE __MIDL_itf_eapauthenticatortypes_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_eapauthenticatortypes_0000_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\eapmethodpeerapis.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares datastructures that are needed by eap methods on the Peer.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef EAPPEERMETHODAPIS_H
#define EAPPEERMETHODAPIS_H
#pragma once

#include "objbase.h"
#include "msxml6.h"
#include "EapMethodTypes.h"

#ifndef EAPAUTHENTICATORACTIONDEFINE_H
#include "EapAuthenticatorActionDefine.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Defines used for installation of EAP DLL
// HKLM\System\CCS\Services\Eaphost\Methods\[AuthorId]\[EapTypeId])
//
// Custom EAP DLL registry installation example:
//                     Name      =  Sample.dll,
//                     AuthorId  =  311(Microsoft),
//                     EapTypeId = (decimal 40)
// HKLM\System\CCS\Services\Eaphost\Methods\311\40
//
//      PeerDllPath             (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      PeerConfigUIPath        (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      PeerInteractiveUIPath   (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      PeerIdentityPath        (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      PeerFriendlyName        (REG_SZ) Sample EAP Protocol
//      PeerRequireConfigUI     (REG_DWORD)     1

//
// Defines used for installation of EAP DLL
// HKLM\System\CCS\Services\Eaphost\Methods\[AuthorId]\254\[VendorId]\[EapTypeId])
//
// Custom Expanded EAP DLL registry installation example:
//                     Name      =  Sample.dll,
//                     AuthorId  =  311(Microsoft),
//                     VendorId  =  311(Microsoft),
//                     EapTypeId = (decimal 40)
// HKLM\System\CCS\Services\Eaphost\Methods\311\254\311\40
//
//      PeerDllPath             (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      PeerConfigUIPath        (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      PeerInteractiveUIPath   (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      PeerIdentityPath        (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      PeerFriendlyName        (REG_SZ) Sample EAP Protocol
//      PeerRequireConfigUI     (REG_DWORD)     1


#define EAP_REGISTRY_LOCATION   \
    TEXT("System\\CurrentControlSet\\Services\\EapHost\\Methods")

#define EAP_PEER_VALUENAME_DLL_PATH          TEXT("PeerDllPath")
#define EAP_PEER_VALUENAME_FRIENDLY_NAME     TEXT("PeerFriendlyName")
#define EAP_PEER_VALUENAME_CONFIGUI          TEXT("PeerConfigUIPath")
#define EAP_PEER_VALUENAME_REQUIRE_CONFIGUI  TEXT("PeerRequireConfigUI")
#define EAP_PEER_VALUENAME_IDENTITY          TEXT("PeerIdentityPath")
#define EAP_PEER_VALUENAME_INTERACTIVEUI     TEXT("PeerInteractiveUIPath")
#define EAP_PEER_VALUENAME_INVOKE_NAMEDLG    TEXT("PeerInvokeUsernameDialog")
#define EAP_PEER_VALUENAME_INVOKE_PWDDLG     TEXT("PeerInvokePasswordDialog")
#define EAP_PEER_VALUENAME_PROPERTIES        TEXT("Properties")

// This structure is used in EapPeerGetResult API to convey the authentication result and pass
// additional information to the EapHost and Supplicant.
typedef struct tagEapPeerMethodResult
{
        BOOL fIsSuccess;
   DWORD dwFailureReasonCode;
        BOOL fSaveConnectionData;
        DWORD dwSizeofConnectionData;
   __field_bcount(dwSizeofConnectionData) BYTE* pConnectionData;
        BOOL fSaveUserData;
        DWORD dwSizeofUserData;
   __field_bcount(dwSizeofUserData) BYTE* pUserData;
   EAP_ATTRIBUTES* pAttribArray;
    EAP_ERROR* pEapError;
} EapPeerMethodResult;



// List of functions corresponding to the particular EAP method
typedef struct _EAP_PEER_METHOD_ROUTINES
{
   DWORD dwVersion;
   EAP_TYPE* pEapType;

   DWORD (APIENTRY * EapPeerInitialize) (EAP_ERROR** ppEapError);

   DWORD (APIENTRY * EapPeerGetIdentity) (
                        IN DWORD flags,
                        IN DWORD dwSizeofConnectionData,
                        IN const BYTE* pConnectionData,
                        IN DWORD dwSizeofUserData,
                        IN const BYTE* pUserData,
                        IN HANDLE hTokenImpersonateUser,
                        OUT BOOL* pfInvokeUI,
                        IN OUT DWORD* pdwSizeOfUserDataOut,
                        OUT BYTE** ppUserDataOut,
                        OUT WCHAR** ppwszIdentity,
                        OUT EAP_ERROR** ppEapError
                        );

   DWORD (APIENTRY * EapPeerBeginSession) (
                        IN DWORD dwFlags,
                        IN const EapAttributes* const pAttributeArray,
                        IN HANDLE hTokenImpersonateUser,
                        IN DWORD dwSizeofConnectionData,
                        IN BYTE* pConnectionData,
                        IN DWORD dwSizeofUserData,
                        IN BYTE* pUserData,
                        IN DWORD dwMaxSendPacketSize,
                        OUT EAP_SESSION_HANDLE* pSessionHandle,
                        OUT EAP_ERROR** ppEapError
                        );

   DWORD (APIENTRY * EapPeerSetCredentials) (
                        IN EAP_SESSION_HANDLE sessionHandle,
                        IN WCHAR* pwszIdentity,
                        IN WCHAR* pwszPassword,
                        OUT EAP_ERROR** ppEapError
                        );
   DWORD (APIENTRY * EapPeerProcessRequestPacket) (
                        IN EAP_SESSION_HANDLE sessionHandle,
                        IN DWORD cbReceivePacket,
                        IN EapPacket* pReceivePacket,
                        OUT EapPeerMethodOutput* pEapOutput,
                        OUT EAP_ERROR** ppEapError
                        );

   DWORD (APIENTRY * EapPeerGetResponsePacket) (
                        IN EAP_SESSION_HANDLE sessionHandle,
                        IN OUT DWORD* pcbSendPacket,
                        OUT EapPacket* pSendPacket,
                        OUT EAP_ERROR** ppEapError
                        );

   DWORD (APIENTRY * EapPeerGetResult) (
                        IN EAP_SESSION_HANDLE sessionHandle,
                        IN EapPeerMethodResultReason reason,
                        OUT EapPeerMethodResult* ppResult,
                        OUT EAP_ERROR** ppEapError
                        );

   DWORD (APIENTRY * EapPeerGetUIContext) (
                        IN EAP_SESSION_HANDLE sessionHandle,
                        OUT DWORD* dwSizeOfUIContextData,
                        OUT BYTE** pUIContextData,
                        OUT EAP_ERROR** ppEapError
                        );

   DWORD (APIENTRY * EapPeerSetUIContext) (
                        IN EAP_SESSION_HANDLE sessionHandle,
                        IN DWORD dwSizeOfUIContextData,
                        IN const BYTE* pUIContextData,
                        OUT EapPeerMethodOutput* pEapOutput,
                        OUT EAP_ERROR** ppEapError
                        );

   DWORD (APIENTRY * EapPeerGetResponseAttributes) (
                        IN EAP_SESSION_HANDLE sessionHandle,
                        OUT EapAttributes* pAttribs,
                        OUT EAP_ERROR** ppEapError
                        );

   DWORD (APIENTRY * EapPeerSetResponseAttributes) (
                        IN EAP_SESSION_HANDLE sessionHandle,
                        IN EapAttributes* pAttribs,
                        OUT EapPeerMethodOutput* pEapOutput,
                        OUT EAP_ERROR** ppEapError
                        );

   DWORD (APIENTRY * EapPeerEndSession) (
                        IN EAP_SESSION_HANDLE sessionHandle,
                        OUT EAP_ERROR** ppEapError
                        );

   DWORD (APIENTRY * EapPeerShutdown) (OUT EAP_ERROR** ppEapError);
} EAP_PEER_METHOD_ROUTINES;



//
// EAP Functions
//

// General comment regarding all APIs defined in this file:
//
// If the function succeeds, it returns ERROR_SUCCESS. Otherwise, it is
// considered failure.
//
// If an error code is returned, the out parameter ppEapError will contain
// related error information. The caller is expected to look into it to
// find out the error informations.
// However, there are some situation that it may not be possible to fill
// out information for ppEapError. For example, in out of memory situation,
// the method implementation may not be able to allocate memory for
// ppEapError as well. If for any reason it is not possible to fill ppEapError,
// *ppEapError should be set to NULL.


// This function should be an exported function from the DLL
//
// If any other APIs in this file returns EAP_ERROR, use this
// function to free the memory allocated for it
VOID WINAPI EapPeerFreeErrorMemory(IN EAP_ERROR* pEapError);


// This function should be an exported function from the DLL
//
// Returns information related to a given EAP type.
// Parameters:
// - pEapType:
//   the EAP type for this EAP method. Implementation should check this input
//   to make sure that it is the same as the method being implemented.
//
// - pEapInfo:
//   returns all the information related for pEapType.
DWORD WINAPI EapPeerGetInfo(
         IN EAP_TYPE* pEapType,
         OUT EAP_PEER_METHOD_ROUTINES* pEapInfo,
         OUT EAP_ERROR** ppEapError
         );


// This is the first function that EAPHost should call on this method.
// The only exception is EapPeerFreeErrorMemory() and EapPeerGetInfo(),
// which can be called at any time.
// This function should be called only once and it should initialize
// everything needed for this method work properly.
DWORD WINAPI EapPeerInitialize(OUT EAP_ERROR** ppEapError);


// EAPHost will call this function, and it would return user data
// and user identity.
// Parameters:
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
//
// - dwSizeofConnectionData:
//   size of the buffer (pConnectionData) in bytes
//
// - pConnectionData:
//   connection data specific to this method. It will be used to decide
//   the user data returned from this API, when the user data depends on
//   certain connection data configuration. The method implementation should
//   have default values for connection data, and when this parameter
//   is NULL, the default connection data should be used.
//
// - dwSizeofUserData:
//   size of the buffer (pUserData) in bytes.
//
// - pUserData:
//   the user data specific to this authentication. It will be used to
//   pre-populate the user data.
//   When this API is called for the first time, or when it needs to start
//   a fresh authentication sessin, this parameter will be NULL.
//   When it is not NULL, its content should be the user data returned
//   from EapPeerGetResult() (*ppResult)->pUserData from previous successful
//   authentication session, if that session indicated that user data should be
//   saved.
//
// - pfInvokeUI:
//   should return true if the user identity and user data blob can not be
//   returned successfully and the method decides that it has to collect the
//   information from the user through UI.
//
// - pdwSizeOfUserDataOut:
//   *pdwSizeOfUserDataOut is the size of buffer *ppUserDataOut
//
// - ppUserDataOut:
//   returned user data. The data will be passed to EapPeerBeginSession()
//   as input pUserData
//
// - ppwszIdentity:
//   returned user identity. It will be included in the identity response packet
//   and returned to the server.
DWORD WINAPI EapPeerGetIdentity (
                IN DWORD dwFlags,
                IN DWORD dwSizeofConnectionData,
                IN const BYTE* pConnectionData,
                IN DWORD dwSizeofUserData,
                IN const BYTE* pUserData,
                IN HANDLE hTokenImpersonateUser,
                OUT BOOL* pfInvokeUI,
                IN OUT DWORD* pdwSizeOfUserDataOut,
                OUT BYTE** ppUserDataOut,
                OUT __out LPWSTR* ppwszIdentity,
                OUT EAP_ERROR** ppEapError
                );


// Start an authentication session.
// Parameters:
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
//
// - pAttributeArray:
//   attributes passed to the method.
//
// - hTokenImpersonateUser:
//   Impersonation token for the user to be authenticated.
//
// - dwSizeofConnectionData:
//   size of the buffer (pConnectionData) in bytes
//
// - pConnectionData:
//   See the comment for pConnectionData for EapPeerGetIdentity()
//
// - dwSizeofUserData:
//   size of the buffer (pUserData) in bytes
//
// - pUserData:
//   user data returned from EapPeerGetIdentity()
//
// - dwMaxSendPacketSize:
//   maximum packet size that the method can send. If the method needs to
//   send a message larger than this size, the method has to handle fragmentation
//   and resembling.
//
// - pSessionHandle:
//   This is an "identifier" of the authentication session.
//   When other EapPeerXxxx() functions with a sessionHandle parameter
//   being called, *pSessionHandle will be passed as the session handle.
//   The method should be able to use this to find the information related
//   the authentication session.
DWORD WINAPI EapPeerBeginSession(
         IN DWORD dwFlags,
         IN const EapAttributes* const pAttributeArray,
         IN HANDLE hTokenImpersonateUser,
         IN DWORD dwSizeofConnectionData,
         IN BYTE* pConnectionData,
         IN DWORD dwSizeofUserData,
         IN BYTE* pUserData,
         IN DWORD dwMaxSendPacketSize,
         OUT EAP_SESSION_HANDLE* pSessionHandle,
         OUT EAP_ERROR** ppEapError
         );


// A method exports either EapPeerGetIdentity (and EapPeerInvokeIdentityUI) or
// exports EapPeerSetCredentials (and sets the InvokeUserNameDlg regkey). The
// registry key controls which of the two apis will get called.
DWORD WINAPI EapPeerSetCredentials(
         IN EAP_SESSION_HANDLE sessionHandle,
         IN __in LPWSTR pwszIdentity,
         IN __in LPWSTR pwszPassword,
         OUT EAP_ERROR** ppEapError
         );


// EAPHost will pass the packet to the method for processing.
// Parameters:
// - sessionHandle:
//   the value returned through *pSessionHandle from EapPeerBeginSession()
//
// - cbRecevedPacket:
//   buffer size of (pReceivePacket) in bytes
//
// - pReceivedPacket:
//   pointer to received packet
//
// - pEapOutput:
//   the method should fill this struct to tell the supplicant what to do.
DWORD WINAPI EapPeerProcessRequestPacket(
         IN EAP_SESSION_HANDLE sessionHandle,
         IN DWORD cbReceivedPacket,
         IN EapPacket* pReceivedPacket,
         OUT EapPeerMethodOutput* pEapOutput,
         OUT EAP_ERROR** ppEapError
         );


// This function returns the packet to be sent to the server.
// Parameters:
// - sessionHandle:
//   the value returned through *pSessionHandle from EapPeerBeginSession()
//
// - pcbSendPacket:
//   *pcbSendPacket is the size of the buffer for (pSendPacket) when passed in.
//   Upon return, *pcbSendPacket is the sizeof the actual content in pSendPacket
//
// - pSendPacket:
//   pointer to a buffer that contains the packet to send upon return
DWORD WINAPI EapPeerGetResponsePacket(
         IN EAP_SESSION_HANDLE sessionHandle,
         IN OUT DWORD* pcbSendPacket,
         OUT EapPacket* pSendPacket,
         OUT EAP_ERROR** ppEapError
         );


// This will get called either when a method says that it has completed auth.
// or when the lower layer receives an alternative result.
// parameters:
// - sessionHandle:
//   the value returned through *pSessionHandle from EapPeerBeginSession()
//
// - reason:
//   one of the reason enum defined above in this file.
//
// - ppResult:
//   Method should fill this struct with related information as defined
//   by EapPeerMethodResult
DWORD WINAPI EapPeerGetResult(
         IN EAP_SESSION_HANDLE sessionHandle,
         IN EapPeerMethodResultReason reason,
         OUT EapPeerMethodResult* ppResult,
         OUT EAP_ERROR** ppEapError
         );

// This will get called if UI should be raised during authentication session.
// This function will always be followed by EapPeerInvokeInteractiveUI() and
// then followed by EapPeerSetUIContext()
// parameters:
// - sessionHandle:
//   the value returned through *pSessionHandle from EapPeerBeginSession()
//
// - pdwSizeOfUIContextData:
//   *pdwSizeOfUIContextData is the size of *ppUIContextData in bytes.
//
// - ppUIContextData:
//   It will be passed to EapPeerInvokeInteractiveUI() as IN parameter
//   pUIContextData
DWORD WINAPI EapPeerGetUIContext(
         IN EAP_SESSION_HANDLE sessionHandle,
         OUT DWORD* pdwSizeOfUIContextData,
         OUT BYTE** ppUIContextData,
         OUT EAP_ERROR** ppEapError
      );


// It will be called after UI has been raised. Refer to EapPeerGetUIContext()
// for more information.
// parameters:
// - sessionHandle:
//   the value returned through *pSessionHandle from EapPeerBeginSession()
//
// - dwSizeOfUIContextData:
//   size of pUIContextData in bytes.
//
// - pUIContextData:
//   This is the data returned from EapPeerInvokeInteractiveUI() OUT parameter
//   *ppDataFromInteractiveUI
//
// - pEapOutput:
//   the method should fill this struct to tell the supplicant what to do.
DWORD WINAPI EapPeerSetUIContext(
        IN EAP_SESSION_HANDLE sessionHandle,
        IN DWORD dwSizeOfUIContextData,
        IN const BYTE* pUIContextData,
        OUT EapPeerMethodOutput* pEapOutput,
        OUT EAP_ERROR** ppEapError
     );


// If EAPHost calls any of the EapPeerXxxx() function, and that function has
// pEapOutput as a OUT parameter, and the action code in it is
// EapPeerMethodResponseActionRespond, this function will be the next function
// that EAPHost will call.
// And it will be follow by a call to EapPeerSetResponseAttributes()
// parameters:
// - sessionHandle:
//   the value returned through *pSessionHandle from EapPeerBeginSession()
//
// - pAttributes:
//   method should fill this with the attributes it need to return.
DWORD WINAPI EapPeerGetResponseAttributes(
        IN EAP_SESSION_HANDLE sessionHandle,
        OUT EapAttributes* pAttribs,
        OUT EAP_ERROR** ppEapError
     );


// See EapPeerGetResponseAttributes() for when this function will be called.
// parameters:
// - sessionHandle:
//   the value returned through *pSessionHandle from EapPeerBeginSession()
//
// - pAttributes:
//   attributes passed to this method.
//
// - pEapOutput:
//   the method should fill this struct to tell the supplicant what to do.
DWORD WINAPI EapPeerSetResponseAttributes(
         IN EAP_SESSION_HANDLE sessionHandle,
         IN EapAttributes* pAttribs,
         OUT EapPeerMethodOutput* pEapOutput,
         OUT EAP_ERROR** ppEapError
      );

// The last function that will be called for this authentication session.
// - sessionHandle:
//   the value returned through *pSessionHandle from EapPeerBeginSession()
//
DWORD WINAPI EapPeerEndSession(
         IN EAP_SESSION_HANDLE sessionHandle,
         OUT EAP_ERROR** ppEapError
         );

// This is the last function that EAPHost should call on this method.
// The only exception is EapPeerFreeErrorMemory() and EapPeerGetInfo(),
// which can be called at any time.
// This function should be called only once and it should un-initialize
// everything for this method.
DWORD WINAPI EapPeerShutdown(OUT EAP_ERROR** ppEapError);


// It should raise a configuration UI so that the user can configure the method
// parameters:
// - pEapType:
//   method type for this method
//
// - hwndParent:
//   The parent window for the UI to be raised by this function.
//
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
//
// - dwSizeOfConnectionDataIn:
//   size of pConnectionDataIn in bytes
//
// - pConnectionDataIn:
//   Used to pre-populate the configuration UI. The first time this function
//   is called, or if it is desired to start from scratch, it will be NULL,
//   otherwise, it will be the data returned from previous
//   EapPeerInvokeConfigUI() ppConnectionDataOut OUT parameter
//
// - pdwSizeOfConnectionDataOut:
//   *pdwSizeOfConnectionDataOut is the size of *ppConnectionDataOut
//
// - ppConnectionDataOut:
//   *ppConnectionDataOut is configuration data returned from this functioin.
//   It will be used to pass to next EapPeerInvokeConfigUI() call.
DWORD WINAPI EapPeerInvokeConfigUI(
         IN EAP_METHOD_TYPE* pEapType,
         IN HWND hwndParent,
         IN DWORD dwFlags,
         IN DWORD dwSizeOfConnectionDataIn,
         IN BYTE* pConnectionDataIn,
         OUT DWORD* pdwSizeOfConnectionDataOut,
         OUT BYTE** ppConnectionDataOut,
         OUT EAP_ERROR** ppEapError
         );

// This function should raise interactive UI for the Method. What UI to be raised and how to raise
// is Method specific information that is embedded in pUIContextData.
//
// Parameters:
// - pEapType:
//   method type for this method
//
// - hwndParent:
//   The parent window for the UI to be raised by this function.
//
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
// - dwSizeofUIContextData:
//   Number of bytes of UIContext data referred by pUIContextData.
// - pUIContextData:
//   A blob that conveys the state of the authentication and describes what and how to show the UI
//   to the user.
// - pdwSizeOfDataFromInteractiveUI
//   Number of bytes of blob referred by *ppDataFromInteractiveUI.
// - ppDataFromInteractiveUI
//   A UI context blob that captures the result of UI interaction
// - pEapError
//   Pointer to pointer to EAP_ERROR that will be filled by the Method in the case of error. In some cases
//  the structure might not be filled.
DWORD WINAPI EapPeerInvokeInteractiveUI(
         IN EAP_METHOD_TYPE* pEapType,
         IN HWND hwndParent,
         IN DWORD dwSizeofUIContextData,
         IN BYTE* pUIContextData,
         OUT DWORD* pdwSizeOfDataFromInteractiveUI,
         OUT BYTE** ppDataFromInteractiveUI,
         OUT EAP_ERROR** ppEapError
         );


// This function should raise credential UI for the Method. Method can use the configuration passed in to
// decide what kind of UI should be shown to the user.
//
// Parameters:
// - pEapType:
//   method type for this method
//
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
//
// - hwndParent:
//   The parent window for the UI to be raised by this function.
//
// - dwSizeOfConnectionData:
//   Number of bytes of pConnectionData.
//
// - pConnectionData:
//   Configuration blob for the Method.
//
// - dwSizeOfUserData
//   Number of bytes of pUserData.
//
// - pUserData
//   Cached credential blob. This would be NULL if this is the first time successful authentication is being done.
//
// - ppwszIdentity
//   Pointer to unicode string that receives the identity that EapHost should use as part of EAP Identity reponse.
//
// - pEapError
//   Pointer to pointer to EAP_ERROR that will be filled by the Method in the case of error. In some cases
//  the structure might not be filled.
DWORD WINAPI EapPeerInvokeIdentityUI(
         IN EAP_METHOD_TYPE* pEapType,
         IN DWORD dwFlags,
         IN HWND hwndParent,
         IN DWORD dwSizeOfConnectionData,
         IN const BYTE* pConnectionData,
         IN DWORD dwSizeOfUserData,
         IN const BYTE* pUserData,
         OUT DWORD* pdwSizeOfUserDataOut,
         OUT BYTE** ppUserDataOut,
         OUT __out LPWSTR* ppwszIdentity,
         OUT EAP_ERROR** ppEapError
         );


// This function returns credential fields to be shown to the user for the authentication. As part of this function
// Method should not bring up UI instead it should describe what credentials are to be obtained. Based on the
// return values, Supplicant draws the UI to the user and obtains the requested credentials.
//
// Parameters:
// - hUserImpersonationToken:
//   Impersonation token of the user/machine who is being authenticated.
//
// - eapMethodType
//   method type for this method
//
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
//
 // - dwEapConnDataSize:
//   Number of bytes of pbEapConnData.
//
// - pbEapConnData:
//   Configuration blob for the Method.
//
// - dwSizeOfUserData
//   Number of bytes of pUserData.
//
// - pEapConfigFieldsArray
//   Pointer to EAP_CONFIG_INPUT_FIELD_ARRAY that receives array of credential fields.
//
// - pEapError
//   Pointer to pointer to EAP_ERROR that will be filled by the Method in the case of error. In some cases
//  the structure might not be filled.
DWORD WINAPI EapPeerQueryCredentialInputFields(
         IN HANDLE hUserImpersonationToken,
         IN EAP_METHOD_TYPE eapMethodType,
         IN DWORD dwFlags,
         IN DWORD dwEapConnDataSize,
         IN __in_ecount(dwEapConnDataSize) BYTE* pbEapConnData,
         OUT EAP_CONFIG_INPUT_FIELD_ARRAY* pEapConfigFieldsArray,
         OUT EAP_ERROR** ppEapError
         );


// This function returns credential blob based on the credentials passed in the credential array structure.
// Method should not bring up UI. It should convert the credentials in to a blob that could be passed to
// EapPeerBeginSession.
//
// Parameters:
// - hUserImpersonationToken:
//   Impersonation token of the user/machine who is being authenticated.
//
// - eapMethodType
//   method type for this method
//
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
//
 // - dwEapConnDataSize:
//   Number of bytes of pbEapConnData.
//
// - pbEapConnData:
//   Configuration blob for the Method.
//
// - dwSizeOfUserData
//   Number of bytes of pUserData.
//
// - pEapConfigFieldsArray
//   Pointer to EAP_CONFIG_INPUT_FIELD_ARRAY that contains array of credential fields filled by supplicant.
//
// - pdwUserBlobSize:
//  Pointer to DWORD that receives the size of the ppbUserBlob.
//
// - ppbUserBlob
//  Pointer to buffer that receives credential blob.
//
// - pEapError
//   Pointer to pointer to EAP_ERROR that will be filled by the Method in the case of error. In some cases
//  the structure might not be filled.
DWORD WINAPI EapPeerQueryUserBlobFromCredentialInputFields(
         IN HANDLE hUserImpersonationToken,
         IN EAP_METHOD_TYPE eapMethodType,
         IN DWORD dwFlags,
         IN DWORD dwEapConnDataSize,
         IN __in_ecount(dwEapConnDataSize) BYTE* pbEapConnData,
         IN const EAP_CONFIG_INPUT_FIELD_ARRAY *pEapConfigInputFieldArray,
         // pointer to DWORD that receives size of credential blob, if EAPHost passes in
         // non-zero size and non-NULL data below, EAP-method will just attempt to Update
         // the blob with passed in values (if supported) instead of creating a new one. EAP-method
         // is not expected to release the passed in buffer, EAPHost will release it after API completion..
         IN OUT DWORD *pdwUserBlobSize,
         IN OUT __deref_out_ecount(*pdwUserBlobSize) BYTE **ppbUserBlob,
         OUT EAP_ERROR** ppEapError
         );

// This function returns fields to be displayed during interactive time when alternative UI is used.
// Method should not bring up UI in this function.
//
DWORD WINAPI EapPeerQueryInteractiveUIInputFields(
        // API's version number for ease of interoperability. It must be 0.
        IN DWORD dwVersion,
        // control the behavior of the EAP Methods
        IN DWORD dwFlags,
        // size of UIcontext data EAPHost runtime
        IN DWORD dwSizeofUIContextData,
        // UIContext data received from EAPHost runtime
        IN __in_ecount(dwSizeofUIContextData) const BYTE* pUIContextData,
        //structure that gets filled with fields and how they should be shown to the user.
        // Caller (EapHost) should free the memory using EapPeerFreeMemory.
        OUT EAP_INTERACTIVE_UI_DATA* pEapInteractiveUIData,
        // In case of error, API fills ppEapError if possible.  Caller should free ppEapError using EapPeerFreeErrorMemory
        OUT EAP_ERROR** ppEapError,
        // Reserved for future usage. It must be NULL.
        IN OUT LPVOID *ppvReserved
        );

// This function returns interactive UI blob from the UI fields filled by the user
//
DWORD WINAPI EapPeerQueryUIBlobFromInteractiveUIInputFields(
        // API's version number for ease of interoperability. It must be 0.
        IN DWORD dwVersion,
        // control the behavior of the EAP Methods
        IN DWORD dwFlags,
        // size of UIcontext data EAPHost runtime
        IN DWORD dwSizeofUIContextData,
        // UIContext data received from EAPHost runtime
        IN __in_ecount(dwSizeofUIContextData) const BYTE* pUIContextData,
        // structure that carries data provided by user
        IN const EAP_INTERACTIVE_UI_DATA *pEapInteractiveUIData,
        // pointer to DWORD that receives size of credential blob
        OUT DWORD * pdwSizeOfDataFromInteractiveUI,
        // Pointer that receives the credential blob that can be used in authentication.
        // Caller (EapHost) should free the memory using EapPeerFreeMemory.
        OUT __deref_out_ecount(*pdwSizeOfDataFromInteractiveUI) BYTE ** ppDataFromInteractiveUI,
        // In case of error, API fills ppEapError if possible.  Caller should free ppEapError using EapPeerFreeErrorMemory
        OUT EAP_ERROR** ppEapError,
        // Reserved for future usage. It must be NULL.
        IN OUT LPVOID *ppvReserved
        );


// This function converts XML document containing configuration information into a blob that could be passed to other
// APIs that expect configuration blob.
//
// Parameters:
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
//
// - eapMethodType
//   method type for this method
//
 // - dwEapConnDataSize:
//   Number of bytes of pbEapConnData.
//
// - pConfigDoc:
//   Pointer to XMLDOMDocument2 that refers to the XML document containg the configuration XML
//
// - ppConfigOut
//   Pointer to buffer that receives configuration blob.
//
// - pdwSizeOfConfigOut
//   Pointer to DWORD that receives size of ppConfigOut.
//
// - pEapError
//   Pointer to pointer to EAP_ERROR that will be filled by the Method in the case of error. In some cases
//  the structure might not be filled.
DWORD WINAPI EapPeerConfigXml2Blob(
                IN DWORD dwFlags,
                IN EAP_METHOD_TYPE eapMethodType,
                IN IXMLDOMDocument2* pConfigDoc,
                OUT __out_ecount(*pdwSizeOfConfigOut) BYTE** ppConfigOut,
                OUT DWORD* pdwSizeOfConfigOut,
                OUT EAP_ERROR** ppEapError
                );


// This function converts XML document containing credential information into a blob that could be passed to other
// APIs that expect credential blob.
//
// Parameters:
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
//
// - eapMethodType
//   method type for this method
//
// - pCredentialsDoc:
//   Pointer to XMLDOMDocument2 that refers to the XML document containg the credential XML
//
// - pConfigIn
//   Pointer to buffer that contains configuration blob.
//
// - dwSizeOfConfigIn
//   Size of pConfigIn
//
// - ppCredentialsOut
//  Pointer to buffer that receives the credential blob
//
// - pdwSizeOfCredentialsOut
//  Pointer to DWORD that receives size of ppCredentialsOut
//
// - pEapError
//   Pointer to pointer to EAP_ERROR that will be filled by the Method in the case of error. In some cases
//  the structure might not be filled.
DWORD WINAPI EapPeerCredentialsXml2Blob(
                IN DWORD dwFlags,
                IN EAP_METHOD_TYPE eapMethodType,
                IN IXMLDOMDocument2* pCredentialsDoc,
                IN __in_ecount(dwSizeOfConfigIn) const BYTE* pConfigIn,
                IN DWORD dwSizeOfConfigIn,
                OUT __out_ecount(*pdwSizeOfCredentialsOut) BYTE** ppCredentialsOut,
                OUT DWORD* pdwSizeOfCredentialsOut,
                OUT EAP_ERROR** ppEapError
                );


// This function converts configuration blob into configuration XML document. Methods exporting this API
// will be supporting exporting of and importing of configuration with out problem. It also helps administrators
// modify the configuration.
//
// Parameters:
// - dwFlags:
//   EAP_FLAG_xxx defined in eaptypes.w
//
// - eapMethodType
//   method type for this method
//
// - pConfigIn:
//   Configuration blob
//
// - dwSizeOfConfigIn
//   Size of pConfigIn
//
// - ppConfigDoc
//  Pointer to IXMLDOMDocument2 that receives configuration XML for the given configuration blob.
//
// - pEapError
//   Pointer to pointer to EAP_ERROR that will be filled by the Method in the case of error. In some cases
//  the structure might not be filled.
DWORD WINAPI EapPeerConfigBlob2Xml(
                IN DWORD dwFlags,
                IN EAP_METHOD_TYPE eapMethodType,
                IN __in_ecount(dwSizeOfConfigIn) const BYTE* pConfigIn,
                IN DWORD dwSizeOfConfigIn,
                OUT IXMLDOMDocument2** ppConfigDoc,
                OUT EAP_ERROR** ppEapError
                );


// This function retrieves the method properties for a specific configuration data. The method properties
// returned by the API will be a subset of the properties value in the registry.
//
// Parameters:
// - dwVersion:
//   The version number of the API.
//
// - dwFlags
//   A combination of EAP flags that describe the EAP authentication session behavior.
//
// - hUserImpersonationToken
//   An impersonation token for the user whose credentials are to be requested and obtained.
//
// - eapMethodType
//   An EAP_METHOD_TYPE structure that contains vendor and author information about the 
//   EAP method used for authenticating the connection.
//
// - dwSizeOfConnectionDataIn
//   The size, in bytes, of the connection data buffer provided in pConnectionDataIn
//
// - pConnectionDataIn
//   Connection data used for the EAP method
//
// - dwSizeOfUserDataIn
//   The size in bytes of the user data buffer provided in pUserDataIn
//
// - pUserDataIn
//   A pointer to a byte buffer that contains the opaque user data BLOB
//
// - pMethodPropertyArray
//   A pointer to the method properties array.
//
// - ppEapError
//   A pointer to a pointer to an EAP_ERROR structure that contains any errors raised by 
//   EAPHost during the execution of this function call.
DWORD WINAPI EapPeerGetMethodProperties(
                IN DWORD dwVersion,
                IN DWORD dwFlags,
                IN EAP_METHOD_TYPE eapMethodType,
                IN HANDLE hUserImpersonationToken,
                IN DWORD dwSizeOfConnectionDataIn,
                IN BYTE* pConnectionDataIn,
                IN DWORD dwSizeOfUserDataIn,
                IN BYTE* pUserDataIn,
                OUT EAP_METHOD_PROPERTY_ARRAY* pMethodPropertyArray,
                OUT EAP_ERROR** ppEapError
                );


// This function frees memory returned by the configuration APIs. This function is called by EapHost when
// it is done with the memory returned by the Method.
//
// Parameters:
// - pUIContextData:
//   Any memory returned by configuration APIs.
//
VOID WINAPI EapPeerFreeMemory(
        IN void* pUIContextData
        );

#ifdef __cplusplus
}
#endif

#endif // EAP_PEER_METHOD_APIS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\EapHostError.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Scenario-specific error codes, reported by EapHost and Eap Method DLLs.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef EAPHOSTERROR_H
#define EAPHOSTERROR_H
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#define FACILITY_EAP                   0x0042  // 66L
#define FACILITY_EAP_MESSAGE           0x0842  // 66L + MessageId bit


// Errors common across different groups.
#define _EAP_CERT_FIRST     (+ 0x0)
#define _EAP_CERT_LAST      (+ 0xF)

#define _EAP_CERT_NOT_FOUND           (+ 0x1)
#define _EAP_CERT_INVALID             (+ 0x2)
#define _EAP_CERT_EXPIRED             (+ 0x3)
#define _EAP_CERT_REVOKED             (+ 0x4)
#define _EAP_CERT_OTHER_ERROR         (+ 0x5)
#define _EAP_CERT_REJECTED            (+ 0x6)
#define _EAP_CERT_NAME_REQUIRED       (+ 0x7)

#define _EAP_GENERAL_FIRST  (+ 0x10)   // (+16)
#define _EAP_GENERAL_LAST   (+ 0x3F)   // (+31)

//
// Individual groups of Eap-related Errors.
//

#define EAP_GROUP_MASK       0x0000FF00L


#define EAP_E_EAPHOST_FIRST  0x80420000L
#define EAP_E_EAPHOST_LAST   0x804200FFL
#define EAP_I_EAPHOST_FIRST  0x80420000L
#define EAP_I_EAPHOST_LAST   0x804200FFL

// Cert-Store can't be accessed on either authenticator or peer
#define EAP_E_CERT_STORE_INACCESSIBLE               0x80420010  // (EAP_E_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 0)

// Requested EAP-method is not installed
#define EAP_E_EAPHOST_METHOD_NOT_INSTALLED          0x80420011  // (EAP_E_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 1)

// 
#define EAP_E_EAPHOST_THIRDPARTY_METHOD_HOST_RESET  0x80420012  // (EAP_E_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 2)

// EAPHost not able to communicate with EAPQEC on a NAP enabled client
#define EAP_E_EAPHOST_EAPQEC_INACCESSIBLE           0x80420013  // (EAP_E_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 3)

// EAPHost returns this error, if the authenticator fails the authentication after peer sent its identity
#define EAP_E_EAPHOST_IDENTITY_UNKNOWN              0x80420014  // (EAP_E_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 4)

// EAPHost returns this error on authentication failure.
#define EAP_E_AUTHENTICATION_FAILED                 0x80420015  // (EAP_E_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 5)

// EAPHost returns this error, when the client & the server aren't configured with compatible EAP-types.
#define EAP_I_EAPHOST_EAP_NEGOTIATION_FAILED        0x40420016  // (EAP_I_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 6)

// EAPMethod received an EAP packet that can not be processed
#define EAP_E_EAPHOST_METHOD_INVALID_PACKET         0x80420017  // (EAP_E_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 7)

// EAPHost received a packet that can not be processed. 
#define EAP_E_EAPHOST_REMOTE_INVALID_PACKET         0x80420018  // (EAP_E_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 8)

// EAPHost ConfigSchema validation failed
#define EAP_E_EAPHOST_XML_MALFORMED                 0x80420019  // (EAP_E_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 9)

//Method doesn't support SSO for the provided config
#define EAP_E_METHOD_CONFIG_DOES_NOT_SUPPORT_SSO                  0x8042001A  // (EAP_E_EAPHOST_FIRST + _EAP_GENERAL_FIRST + A)

// EAPHost returns this error, when a configured EAP-method does not support a requested operation (procedure call)
#define EAP_E_EAPHOST_METHOD_OPERATION_NOT_SUPPORTED                 0x80420020  // (EAP_E_EAPHOST_FIRST + _EAP_GENERAL_FIRST + 10)


#define EAP_E_USER_FIRST  0x80420100L
#define EAP_E_USER_LAST   0x804201FFL
#define EAP_I_USER_FIRST  0x40420100L
#define EAP_I_USER_LAST   0x404201FFL

// EAPHost could not find user-certificate for authentication    
#define EAP_E_USER_CERT_NOT_FOUND           0x80420100  // (EAP_E_USER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_NOT_FOUND)

// user-cert being user for authentication does not have proper usage (EKU) set 
#define EAP_E_USER_CERT_INVALID             0x80420101  // (EAP_E_USER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_INVALID)

// EAPhost found user-cert which has expired already
#define EAP_E_USER_CERT_EXPIRED             0x80420102  // (EAP_E_USER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_EXPIRED)

// user-cert being used for authentication has been revoked
#define EAP_E_USER_CERT_REVOKED             0x80420103  // (EAP_E_USER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_REVOKED)

// unknown error occured with user-cert being used for authentication
#define EAP_E_USER_CERT_OTHER_ERROR         0x80420104  // (EAP_E_USER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_OTHER_ERROR)

// Authenticator rejected user-cert for authentication
#define EAP_E_USER_CERT_REJECTED            0x80420105  // (EAP_E_USER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_REJECTED)

// Received EAP-Failure after Identity exchange:  There is likely a problem with the authenticating user's account.
#define EAP_I_USER_ACCOUNT_OTHER_ERROR      0x40420110  // (EAP_I_USER_FIRST + _EAP_GENERAL_FIRST + 0

// Authenticator rejected user credentials for authentication 
#define EAP_E_USER_CREDENTIALS_REJECTED     0x80420111  // (EAP_E_USER_FIRST + _EAP_GENERAL_FIRST + 1)

// Authenticator rejected user credentials for authentication 
#define EAP_E_USER_NAME_PASSWORD_REJECTED   0x80420112  // (EAP_E_USER_FIRST + _EAP_GENERAL_FIRST + 2)

//No Smart Card Reader Present
#define EAP_E_NO_SMART_CARD_READER       0x80420113  // (EAP_E_USER_FIRST + _EAP_GENERAL_FIRST + 3)


#define EAP_E_SERVER_FIRST  0x80420200L
#define EAP_E_SERVER_LAST   0x804202FFL

// EAPHost could not find server-certificate for authentication    
#define EAP_E_SERVER_CERT_NOT_FOUND         0x80420200  // (EAP_E_SERVER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_NOT_FOUND)

// server-cert being user for authentication does not have proper usage (EKU) set  
#define EAP_E_SERVER_CERT_INVALID           0x80420201  // (EAP_E_SERVER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_INVALID)

// EAPhost found server-cert which has expired already
#define EAP_E_SERVER_CERT_EXPIRED           0x80420202  // (EAP_E_SERVER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_EXPIRED)

// server-cert being used for authentication has been revoked
#define EAP_E_SERVER_CERT_REVOKED           0x80420203  // (EAP_E_SERVER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_REVOKED)

// unknown error occured with server-cert being used for authentication
#define EAP_E_SERVER_CERT_OTHER_ERROR       0x80420204  // (EAP_E_SERVER_FIRST + _EAP_CERT_FIRST + _EAP_CERT_OTHER_ERROR)


#define EAP_E_USER_ROOT_CERT_FIRST  0x80420300L
#define EAP_E_USER_ROOT_CERT_LAST   0x804203FFL


// EAPHost could not find a certificate in trusted-root cert-store for user cert velidation
#define EAP_E_USER_ROOT_CERT_NOT_FOUND      0x80420300  // (EAP_E_USER_ROOT_CERT_FIRST + _EAP_CERT_FIRST + _EAP_CERT_NOT_FOUND)

// The authentication failed because the root certificate used for this network is invalid
#define EAP_E_USER_ROOT_CERT_INVALID        0x80420301  // (EAP_E_USER_ROOT_CERT_FIRST + _EAP_CERT_FIRST + _EAP_CERT_INVALID)

// Trusted root certificate needed for user-cert validation has been expired.
#define EAP_E_USER_ROOT_CERT_EXPIRED        0x80420302  // (EAP_E_USER_ROOT_CERT_FIRST + _EAP_CERT_FIRST + _EAP_CERT_EXPIRED)

#define EAP_E_SERVER_ROOT_CERT_FIRST  0x80420400L
#define EAP_E_SERVER_ROOT_CERT_LAST   0x804204FFL

// EAPHost could not find a Root certificate in trusted-root cert-store for server cert velidation
#define EAP_E_SERVER_ROOT_CERT_NOT_FOUND        0x80420400  // (EAP_E_SERVER_ROOT_CERT_FIRST + _EAP_CERT_FIRST + _EAP_CERT_NOT_FOUND)

// The authentication failed because the server certificate required for this network on the server computer is invalid
#define EAP_E_SERVER_ROOT_CERT_INVALID          0x80420401  // (EAP_E_SERVER_ROOT_CERT_FIRST + _EAP_CERT_FIRST + _EAP_CERT_INVALID)

// The authentication failed because the certificate on the server computer does not have a server name specified
#define EAP_E_SERVER_ROOT_CERT_NAME_REQUIRED    0x80420406  // (EAP_E_SERVER_ROOT_CERT_FIRST + _EAP_CERT_FIRST + _EAP_CERT_NAME_REQUIRED)


// Alternate names for certain errors.
#define EAP_METHOD_INVALID_PACKET  EAP_E_EAPHOST_METHOD_INVALID_PACKET
#define EAP_INVALID_PACKET         EAP_E_EAPHOST_REMOTE_INVALID_PACKET

// This is not a fixed GUID when it reaches supplicant, but 1st portion will be 
// filled by Generic Win32/Ras error. This helps create unique GUID for every 
// unique error that we don't understand. This helps collect SQM data.
EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Default \
        = { 0x00000000, 0x0000, 0x0000, 0, 0, 0, 0, 0, 0, 0, 0 };


EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_MethodDLLNotFound \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 1 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_ContactSysadmin \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 2 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_CertStoreInaccessible \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 4 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_Generic_AuthFailure \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 1, 4 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_IdentityUnknown \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 2, 4 } };


EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_Server_CertExpired \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 5 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_Server_CertInvalid \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 6 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_Server_CertNotFound \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 7 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_Server_CertRevoked \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 8 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_Server_CertOtherError \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 1, 8 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_CertExpired \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 9 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_CertInvalid \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0xA } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_CertNotFound \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0xB } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_CertOtherError \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0xC } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_CertRejected \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0xD } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_CertRevoked \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0xE } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_Account_OtherProblem \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 1, 0xE } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_CredsRejected \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 2, 0xE } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_Root_CertExpired \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0xF } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_Root_CertInvalid \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x10 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_User_Root_CertNotFound \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x11 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_Server_Root_CertNameRequired \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x12 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_Server_Root_CertNotFound \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 1, 0x12 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_ThirdPartyMethod_Host_Reset \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 2, 0x12 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_EapQecInaccessible \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 3, 0x12 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_Server_ClientSelectServerCert \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x18 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_User_AuthFailure \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x19 } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_User_GetNewCert \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x1A } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_User_SelectValidCert \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x1B } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_Retry_Authentication \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 1, 0x1B } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_EapNegotiationFailed \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x1C } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_XmlMalformed \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x1D } };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_MethodDoesNotSupportOperation \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x1E } };
      
EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_ContactAdmin_AuthFailure \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x1F } };
        
EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_ContactAdmin_IdentityUnknown \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x20 }};
        
EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_ContactAdmin_NegotiationFailed \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x21}};        
        
EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_ContactAdmin_MethodNotFound \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x22} };
        
EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_RestartNap \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x23} };
        
EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_ContactAdmin_CertStoreInaccessible \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x24} };
        
EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_ContactAdmin_InvalidUserAccount \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x25} };
        
EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_ContactAdmin_RootCertInvalid \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x26} };
        
EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_ContactAdmin_RootCertNotFound \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x27} };        

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_ContactAdmin_RootExpired \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x28} };
        
EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_ContactAdmin_CertNameAbsent \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x29} };
        
EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_ContactAdmin_NoSmartCardReader \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x2A} };

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_No_SmartCardReader_Found \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x2B }};

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_ContactAdmin_InvalidUserCert \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x2C }};

EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Repair_Method_Not_Support_Sso \
        = { 0x9612fc67, 0x6150, 0x4209, { 0xa8, 0x5e, 0xa8, 0xd8, 0, 0, 0, 0x2D }};

 EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Help_ObtainingCerts \
        = { 0xf535eea3, 0x1bdd, 0x46ca, { 0xa2, 0xfc, 0xa6, 0x65, 0x59, 0x39, 0xb7, 0xe8 } };
 
// This currently is a generic networking troubleshooting help page, not EAP specific.
EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Help_Troubleshooting \
        = { 0x33307acf, 0x0698, 0x41ba, { 0xb0, 0x14, 0xea, 0x0a, 0x2e, 0xb8, 0xd0, 0xa8 } };

// This is used when the method does not supportSSO for provided config.
EXTERN_C const CLSID DECLSPEC_SELECTANY GUID_EapHost_Cause_Method_Config_Does_Not_Support_Sso \
        = { 0xda18bd32, 0x004F, 0x41fa, { 0xae, 0x08, 0x0b, 0xc8, 0x5e, 0x58, 0x45, 0xac } };

#ifdef __cplusplus
}
#endif

#endif // EAPHOSTERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\eapmethodauthenticatorapis.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation
//
// SYNOPSIS
//
//   Declares datastructures that are needed by eap methods on the Peer.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef EAP_METHOD_AUTHENTICATOR_APIS_H
#define EAP_METHOD_AUTHENTICATOR_APIS_H
#pragma once

#ifndef __eapauthenticatortypes_h__
#include "EapAuthenticatorTypes.h"
#endif

#ifndef EAPAUTHENTICATORACTIONDEFINE_H
#include "EapAuthenticatorActionDefine.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Defines used for installation of EAP DLL
// HKLM\System\CCS\Services\Eaphost\Methods\[AuthorId]\[EapTypeId])
//
// Custom EAP DLL registry installation example:
//                     Name      =  Sample.dll, 
//                     AuthorId  =  311(Microsoft), 
//                     EapTypeId = (decimal 40) 
// HKLM\System\CCS\Services\Eaphost\Methods\311\40
//
//      AuthenticatorDllPath             (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      AuthenticatorFriendlyName        (REG_SZ) Sample EAP Protocol

//
// Defines used for installation of EAP DLL
// HKLM\System\CCS\Services\Eaphost\Methods\[AuthorId]\254\[VendorId]\[EapTypeId])
//
// Custom Expanded EAP DLL registry installation example:
//                     Name      =  Sample.dll, 
//                     AuthorId  =  311(Microsoft),
//                     VendorId  =  311(Microsoft),
//                     EapTypeId = (decimal 40) 
// HKLM\System\CCS\Services\Eaphost\Methods\311\254\311\40
//
//      AuthenticatorDllPath             (REG_EXPAND_SZ) %SystemRoot%\system32\sample.dll
//      AuthenticatorFriendlyName        (REG_SZ) Sample EAP Protocol


//      ConfigCLSID         (REG_SZ)        {0000031A-0000-0000-C000-000000000046}
//      StandaloneSupported (REG_DWORD)     1
//


#define EAP_REGISTRY_LOCATION   \
    TEXT("System\\CurrentControlSet\\Services\\EapHost\\Methods")

#define EAP_AUTHENTICATOR_VALUENAME_DLL_PATH      TEXT("AuthenticatorDllPath")
#define EAP_AUTHENTICATOR_VALUENAME_FRIENDLY_NAME TEXT("AuthenticatorFriendlyName")
#define EAP_AUTHENTICATOR_VALUENAME_PROPERTIES   TEXT("Properties")
#define EAP_AUTHENTICATOR_VALUENAME_CONFIGUI TEXT("AuthenticatorConfigUIPath")

//For authenticator
// Are these needed any more? Or are we going to define better ways of 
// encapsulating them.
//#define EAP_AUTHENTICATOR_VALUENAME_CONFIG_CLSID      TEXT("ConfigCLSID")
//#define EAP_AUTHENTICATOR_VALUENAME_PER_POLICY_CONFIG TEXT("PerPolicyConfig")


// Structures used by EAP methods on the peer to communicate with the host.

// List of functions corresponding to the particular EAP method 
typedef struct _EAP_AUTHENTICATOR_METHOD_ROUTINES 
{  
   // FIXME: Why is the size needed?
   DWORD dwSizeInBytes;
   EAP_METHOD_TYPE* pEapType;


   DWORD (APIENTRY * EapMethodAuthenticatorInitialize) (
            IN EAP_METHOD_TYPE* pEapType, 
            OUT EAP_ERROR** ppEapError
            );

   DWORD (APIENTRY * EapMethodAuthenticatorBeginSession) (
         // Flags to qualify the authentication process.
         IN DWORD dwFlags,
         // Identity of the user being authenticated
         IN LPCWSTR pwszIdentity,
         // Pointer to an array of attributes. This array contains attributes that 
         // describe the entity being authenticated. 
         IN const EapAttributes* const pAttributeArray,
         // Specifies the size in bytes of the data pointed to by pConnectionData. 
         // If pConnectionData is NULL, this member is zero. 
         IN DWORD dwSizeofConnectionData,
         // Pointer to connection data received from the authentication protocol's 
         // configuration user interface.
         IN const BYTE* const pConnectionData,
         // This is the maximum size of an eap packet that the authenticator can send.
         IN DWORD dwMaxSendPacketSize,
         // The session handle that identifies the current authentication session.
         OUT EAP_SESSION_HANDLE* pSessionHandle,
         // On an unsuccessful call, this will contain any error information about
         // the failure. This will be null on a successful call.
         OUT EAP_ERROR** ppEapError
         );

   DWORD (APIENTRY * EapMethodAuthenticatorUpdateInnerMethodParams)(
         // context handle as returned from a successful call to 
         // EapAuthenticatorBeginSession
         IN EAP_SESSION_HANDLE sessionHandle,
         IN DWORD dwFlags,
         IN CONST WCHAR* pwszIdentity,
         // Pointer to an array of attributes. This array contains attributes that 
         // describe the entity being authenticated. 
         IN const EapAttributes* const pAttributeArray,
         // On an unsuccessful call, this will contain any error information about
         // the failure. This will be null on a successful call.
         OUT EAP_ERROR** ppEapError         
         );

      // The authenticator calls this any time it receives a packet that the eaphost
      // needs to process. This should be called only after a successful call to
      // EapAuthenticatorBeginSession.
   DWORD (APIENTRY * EapMethodAuthenticatorReceivePacket) (
            // context handle as returned from a successful call to 
            // EapAuthenticatorBeginSession
            IN EAP_SESSION_HANDLE sessionHandle,
            // Specifies the size, in bytes, of the buffer pointed to by 
            // pReceivePacket
            IN DWORD cbReceivePacket,
            // Pointer to a buffer that contains the incoming EAP data received by 
            // the supplicant.
            IN const EapPacket* const pReceivePacket,
            // This enumeration tells the supplicant to take an appropriate action.
            // The supplicant will typically look at this action and either call 
            // another method on eaphost or do something else on its own.
            OUT EAP_METHOD_AUTHENTICATOR_RESPONSE_ACTION* pEapOutput,
            // On an unsuccessful call, this will contain any error information about
            // the failure. This will be null on a successful call.      
            OUT EAP_ERROR** ppEapError
            );


   DWORD (APIENTRY * EapMethodAuthenticatorSendPacket) (
            // context handle as returned from a successful call to 
            // EapHostAuthenticatorBeginSession
            IN EAP_SESSION_HANDLE sessionHandle,
            // Id to use when constructing the SendPacket
            IN BYTE bPacketId,
            // Specifies the limit on the size, in bytes, on the packet generated
            // by eaphost. On a successful return, this will contain the size of the 
            // data added by the eap module.
            OUT DWORD* pcbSendPacket,
            // Pointer to a buffer that is allocated by the client and populated
            // by the eap module. The value of the incoming buffer is ignored and
            // the method populates it from the beginning of the buffer.
            OUT EapPacket* pSendPacket,
            // Timeout option for sending the packet
            OUT EAP_AUTHENTICATOR_SEND_TIMEOUT* pTimeout,
            // On an unsuccessful call, this will contain any error information about
            // the failure. This will be null on a successful call.      
            OUT EAP_ERROR** ppEapError
            );


      // Returns an array of attributes that the caller needs to act on.
      // The supplicant will call this when a call to 
      // EapHostAuthenticatorProcessRequestPacket returns EapHostAuthenticatorResponseRespond. 
   DWORD (APIENTRY * EapMethodAuthenticatorGetAttributes) (
         // context handle as returned from a successful call to 
         // EapHostAuthenticatorBeginSession
         IN EAP_SESSION_HANDLE sessionHandle,
         // Array of attributes that the caller needs to act on.
         OUT EapAttributes* pAttribs,
         OUT EAP_ERROR** ppEapError
         );


      // Sets an array of attributes that the caller wants the eap method to act 
      // on. 
   DWORD (APIENTRY * EapMethodAuthenticatorSetAttributes) (
         // context handle as returned from a successful call to 
         // EapHostAuthenticatorBeginSession
         IN EAP_SESSION_HANDLE sessionHandle,
         IN const EapAttributes* const pAttribs,
         // This enumeration tells the supplicant to take an appropriate action.
         // The supplicant will typically look at this action and either call 
         // another method on eaphost or do something else on its own.
         OUT EAP_METHOD_AUTHENTICATOR_RESPONSE_ACTION* pEapOutput,
         // On an unsuccessful call, this will contain any error information about
         // the failure. This will be null on a successful call.      
         OUT EAP_ERROR** ppEapError
         );


      // The authenticator will call this on completion of an authentication. This 
      // can happen in any of the following scenarios:
      // 1. A call to EapHostAuthenticatorReceivePacket returned 
      //    EAP_HOST_AUTHENTICATOR_RESPONSE_SUCCESS or EAP_HOST_AUTHENTICATOR_RESPONSE_FAILURE
      //    Even if the action returned above was a success, the authenticator can choose to call
      //    this method with a failure.
      // 2. The server can choose to terminate an authentication with a failure in the middle of
      //    an authentication.
   DWORD (APIENTRY * EapMethodAuthenticatorGetResult) (
         // context handle as returned from a successful call to 
         // EapHostPeerBeginSession
         IN EAP_SESSION_HANDLE sessionHandle,
         // A structure that indicates the result and any state that the 
         // supplicant needs to save for future authentications.
         OUT EAP_METHOD_AUTHENTICATOR_RESULT* pResult, 
         // On an unsuccessful call, this will contain any error information about
         // the failure. This will be null on a successful call.      
         OUT EAP_ERROR** ppEapError         
         );


      // Ends the authentication session. This cleans up any state that the eap 
      // method or eaphost might be keeping.
   DWORD (APIENTRY * EapMethodAuthenticatorEndSession) (
         // context handle as returned from a successful call to 
         // EapHostPeerBeginSession. This will be set to NULL on a successful call.
         IN EAP_SESSION_HANDLE sessionHandle, 
         // On an unsuccessful call, this will contain any error information about
         // the failure. This will be null on a successful call.      
         OUT EAP_ERROR** ppEapError
      );


   DWORD (APIENTRY * EapMethodAuthenticatorShutdown) (
            IN EAP_METHOD_TYPE* pEapType, 
            OUT EAP_ERROR** ppEapError
            );

} EAP_AUTHENTICATOR_METHOD_ROUTINES, *PEAP_AUTHENTICATOR_METHOD_ROUTINES;


//
// EAP Functions
//
void WINAPI EapMethodAuthenticatorFreeErrorMemory(IN EAP_ERROR* pEapError);
void WINAPI EapMethodAuthenticatorFreeMemory(
        IN void* pUIContextData
        );

DWORD EapMethodAuthenticatorGetInfo(
         IN EAP_METHOD_TYPE* pEapType, 
         OUT EAP_AUTHENTICATOR_METHOD_ROUTINES* pEapInfo, 
         OUT EAP_ERROR** ppEapError
         );

DWORD EapMethodAuthenticatorInitialize(
         IN EAP_METHOD_TYPE* pEapType, 
         OUT EAP_ERROR** ppEapError
         );

DWORD EapMethodAuthenticatorBeginSession(
      // Flags to qualify the authentication process.
      IN DWORD dwFlags,
      // Initial Id
      IN BYTE bInitialId,
      // Identity of the user being authenticated
      IN LPCWSTR pwszIdentity,
      // Pointer to an array of attributes. This array contains attributes that 
      // describe the entity being authenticated. 
      IN const EapAttributes* const pAttributeArray,
      // Specifies the size in bytes of the data pointed to by pConnectionData. 
      // If pConnectionData is NULL, this member is zero. 
      IN DWORD dwSizeofConnectionData,
      // Pointer to connection data received from the authentication protocol's 
      // configuration user interface.
      IN const BYTE* const pConnectionData,
      // This is the maximum size of an eap packet that the authenticator can send.
      IN DWORD dwMaxSendPacketSize,
      // The session handle that identifies the current authentication session.
      OUT EAP_SESSION_HANDLE* pSessionHandle,
      // On an unsuccessful call, this will contain any error information about
      // the failure. This will be null on a successful call.
      OUT EAP_ERROR** ppEapError
      );

DWORD EapMethodAuthenticatorUpdateInnerMethodParams(
         // context handle as returned from a successful call to 
         // EapAuthenticatorBeginSession
         IN EAP_SESSION_HANDLE sessionHandle,
         IN DWORD dwFlags,
         IN CONST WCHAR* pwszIdentity,
         // Pointer to an array of attributes. This array contains attributes that 
         // describe the entity being authenticated. 
         IN const EapAttributes* const pAttributeArray,
         // On an unsuccessful call, this will contain any error information about
         // the failure. This will be null on a successful call.
         OUT EAP_ERROR** ppEapError         
         );


   // The authenticator calls this any time it receives a packet that the eaphost
   // needs to process. This should be called only after a successful call to
   // EapAuthenticatorBeginSession.
DWORD EapMethodAuthenticatorReceivePacket(
         // context handle as returned from a successful call to 
         // EapAuthenticatorBeginSession
         IN EAP_SESSION_HANDLE sessionHandle,
         // Specifies the size, in bytes, of the buffer pointed to by 
         // pReceivePacket
         IN DWORD cbReceivePacket,
         // Pointer to a buffer that contains the incoming EAP data received by 
         // the supplicant.
         IN const EapPacket* const pReceivePacket,
         // This enumeration tells the supplicant to take an appropriate action.
         // The supplicant will typically look at this action and either call 
         // another method on eaphost or do something else on its own.
         OUT EAP_METHOD_AUTHENTICATOR_RESPONSE_ACTION* pEapOutput,
         // On an unsuccessful call, this will contain any error information about
         // the failure. This will be null on a successful call.      
         OUT EAP_ERROR** ppEapError
         );


DWORD EapMethodAuthenticatorSendPacket(
         // context handle as returned from a successful call to 
         // EapHostAuthenticatorBeginSession
         IN EAP_SESSION_HANDLE sessionHandle,
         // Id to use when constructing the SendPacket
         IN BYTE bPacketId,
         // Specifies the limit on the size, in bytes, on the packet generated
         // by eaphost. On a successful return, this will contain the size of the 
         // data added by the eap module.
         IN OUT DWORD* pcbSendPacket,
         // Pointer to a buffer that is allocated by the client and populated
         // by the eap module. The value of the incoming buffer is ignored and
         // the method populates it from the beginning of the buffer.
         OUT EapPacket* pSendPacket,
         // Timeout option for sending the packet
         OUT EAP_AUTHENTICATOR_SEND_TIMEOUT* pTimeout,
         // On an unsuccessful call, this will contain any error information about
         // the failure. This will be null on a successful call.
         OUT EAP_ERROR** ppEapError
         );


   // Returns an array of attributes that the caller needs to act on.
   // The supplicant will call this when a call to 
   // EapHostAuthenticatorProcessRequestPacket returns EapHostAuthenticatorResponseRespond. 
DWORD EapMethodAuthenticatorGetAttributes(
      // context handle as returned from a successful call to 
      // EapHostAuthenticatorBeginSession
      IN EAP_SESSION_HANDLE sessionHandle,
      // Array of attributes that the caller needs to act on.
      OUT EapAttributes* pAttribs,
      OUT EAP_ERROR** ppEapError
      );



   // Sets an array of attributes that the caller wants the eap method to act 
   // on. 
DWORD EapMethodAuthenticatorSetAttributes(
      // context handle as returned from a successful call to 
      // EapHostAuthenticatorBeginSession
      IN EAP_SESSION_HANDLE sessionHandle,
      IN const EapAttributes* const pAttribs,
      // This enumeration tells the supplicant to take an appropriate action.
      // The supplicant will typically look at this action and either call 
      // another method on eaphost or do something else on its own.
      OUT EAP_METHOD_AUTHENTICATOR_RESPONSE_ACTION* pEapOutput,
      // On an unsuccessful call, this will contain any error information about
      // the failure. This will be null on a successful call.      
      OUT EAP_ERROR** ppEapError
      );



   // The authenticator will call this on completion of an authentication. This 
   // can happen in any of the following scenarios:
   // 1. A call to EapHostAuthenticatorReceivePacket returned 
   //    EAP_HOST_AUTHENTICATOR_RESPONSE_SUCCESS or EAP_HOST_AUTHENTICATOR_RESPONSE_FAILURE
   //    Even if the action returned above was a success, the authenticator can choose to call
   //    this method with a failure.
   // 2. The server can choose to terminate an authentication with a failure in the middle of
   //    an authentication.
DWORD EapMethodAuthenticatorGetResult(
      // context handle as returned from a successful call to 
      // EapHostPeerBeginSession
      IN EAP_SESSION_HANDLE sessionHandle,
      // A structure that indicates the result and any state that the 
      // supplicant needs to save for future authentications.
      OUT EAP_METHOD_AUTHENTICATOR_RESULT* pResult, 
      // On an unsuccessful call, this will contain any error information about
      // the failure. This will be null on a successful call.      
      OUT EAP_ERROR** ppEapError         
      );


   // Ends the authentication session. This cleans up any state that the eap 
   // method or eaphost might be keeping.
DWORD EapMethodAuthenticatorEndSession(
      // context handle as returned from a successful call to 
      // EapHostPeerBeginSession. This will be set to NULL on a successful call.
      IN EAP_SESSION_HANDLE sessionHandle, 
      // On an unsuccessful call, this will contain any error information about
      // the failure. This will be null on a successful call.      
      OUT EAP_ERROR** ppEapError
   );


DWORD EapMethodAuthenticatorShutdown(
         IN EAP_METHOD_TYPE* pEapType, 
         OUT EAP_ERROR** ppEapError
         );


/// Config API

#define EAP_METHOD_AUTHENTICATOR_CONFIG_IS_IDENTITY_PRIVACY    0x1

DWORD WINAPI EapMethodAuthenticatorInvokeConfigUI(
                IN EAP_METHOD_TYPE* pEapMethodType,
                IN HWND hwndParent,
                IN DWORD dwFlags,
                IN LPCWSTR pwszMachineName,
                IN DWORD dwSizeOfConfigIn,
                IN BYTE* pConfigIn,
                OUT DWORD* pdwSizeOfConfigOut,
                OUT BYTE** ppConfigOut,
                OUT EAP_ERROR** ppEapError
                );

#ifdef __cplusplus
}
#endif

#endif // EAP_METHOD_AUTHENTICATOR_APIS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\eaptypes.h ===
////////////////////////////////////////////////////////////
//
// Copyright (c) Microsoft Corporation.
//
// SYNOPSIS
//
//    IDL source for interaction with EAPHost supplicants.
//
////////////////////////////////////////////////////////////

#ifndef EAPTYPES_H
#define EAPTYPES_H
#pragma once

#include <guiddef.h>  // Used by EAP_ERROR structure.


// Properties that EAP Methods support
#define eapPropCipherSuiteNegotiation      0x00000001
#define eapPropMutualAuth                  0x00000002
#define eapPropIntegrity                   0x00000004
#define eapPropReplayProtection            0x00000008
#define eapPropConfidentiality             0x00000010
#define eapPropKeyDerivation               0x00000020
#define eapPropKeyStrength64               0x00000040
#define eapPropKeyStrength128              0x00000080
#define eapPropKeyStrength256              0x00000100
#define eapPropKeyStrength512              0x00000200
#define eapPropKeyStrength1024             0x00000400
#define eapPropDictionaryAttackResistance  0x00000800
#define eapPropFastReconnect               0x00001000
#define eapPropCryptoBinding               0x00002000
#define eapPropSessionIndependence         0x00004000
#define eapPropFragmentation               0x00008000
#define eapPropChannelBinding              0x00010000
#define eapPropNap                         0x00020000
#define eapPropStandalone                  0x00040000
#define eapPropMppeEncryption              0x00080000
#define eapPropTunnelMethod                0x00100000
#define eapPropSupportsConfig              0x00200000
#define eapPropCertifiedMethod             0x00400000
#define eapPropHiddenMethod                0x00800000
#define eapPropMachineAuth                 0x01000000
#define eapPropUserAuth                    0x02000000
#define eapPropIdentityPrivacy             0x04000000
#define eapPropMethodChaining              0x08000000
#define eapPropSharedStateEquivalence      0x10000000
#define eapPropReserved                    0x80000000

// Registry NameValue that stores Properties supported by EAP Method
#define EAP_VALUENAME_PROPERTIES L"Properties"

typedef DWORD EAP_SESSIONID;


typedef struct _EAP_TYPE
{
   BYTE type;
   DWORD dwVendorId;
   DWORD dwVendorType;
} EAP_TYPE;


// definition of EAP_METHOD_TYPE used for describing an EAP method
typedef struct _EAP_METHOD_TYPE
{
   EAP_TYPE eapType;
   DWORD dwAuthorId;
} EAP_METHOD_TYPE;


// Information pertaining to each EAP method is populated in this structure format
typedef struct _EAP_METHOD_INFO
{
   EAP_METHOD_TYPE eaptype;
   LPWSTR pwszAuthorName;
   LPWSTR pwszFriendlyName;
   DWORD eapProperties;
   struct _EAP_METHOD_INFO* pInnerMethodInfo;
} EAP_METHOD_INFO;


// EAPHost populates this array with the information for all the eap-methods installed
// on machine and passes it to a supplicant
struct _EAP_METHOD_INFO_ARRAY_EX;


typedef struct _EAP_METHOD_INFO_EX
{
   EAP_METHOD_TYPE eaptype;
   LPWSTR pwszAuthorName;
   LPWSTR pwszFriendlyName;
   DWORD eapProperties;
   struct _EAP_METHOD_INFO_ARRAY_EX* pInnerMethodInfoArray;
} EAP_METHOD_INFO_EX;


typedef struct _EAP_METHOD_INFO_ARRAY
{
   DWORD dwNumberOfMethods;
   EAP_METHOD_INFO* pEapMethods;
} EAP_METHOD_INFO_ARRAY;

// EAPHost populates this error structs with appropriate information and passes it to
// supplicant, which can use this information for error reporting and troubleshooting
typedef struct _EAP_METHOD_INFO_ARRAY_EX
{
   DWORD dwNumberOfMethods;
   EAP_METHOD_INFO_EX* pEapMethods;
} EAP_METHOD_INFO_ARRAY_EX;

typedef struct _EAP_ERROR
{
   DWORD dwWinError;
   EAP_METHOD_TYPE type;
   DWORD dwReasonCode;

   GUID   rootCauseGuid;
   GUID   repairGuid;
   GUID   helpLinkGuid;

   LPWSTR pRootCauseString;
   LPWSTR pRepairString;
} EAP_ERROR;


EXTERN_C const CLSID GUID_EapHost_Default;

EXTERN_C const CLSID GUID_EapHost_Cause_MethodDLLNotFound;
EXTERN_C const CLSID GUID_EapHost_Cause_EapNegotiationFailed;    //*!*
EXTERN_C const CLSID GUID_EapHost_Cause_ThirdPartyMethod_Host_Reset;
EXTERN_C const CLSID GUID_EapHost_Cause_XmlMalformed;
EXTERN_C const CLSID GUID_EapHost_Cause_MethodDoesNotSupportOperation;
EXTERN_C const CLSID GUID_EapHost_Cause_EapQecInaccessible;      //*!*

EXTERN_C const CLSID GUID_EapHost_Cause_Generic_AuthFailure;
EXTERN_C const CLSID GUID_EapHost_Cause_IdentityUnknown;

EXTERN_C const CLSID GUID_EapHost_Cause_CertStoreInaccessible;

EXTERN_C const CLSID GUID_EapHost_Cause_User_CertExpired;
EXTERN_C const CLSID GUID_EapHost_Cause_User_CertInvalid;
EXTERN_C const CLSID GUID_EapHost_Cause_User_CertNotFound;
EXTERN_C const CLSID GUID_EapHost_Cause_User_CertOtherError;
EXTERN_C const CLSID GUID_EapHost_Cause_User_CertRejected;
EXTERN_C const CLSID GUID_EapHost_Cause_User_CertRevoked;
EXTERN_C const CLSID GUID_EapHost_Cause_User_Account_OtherProblem;
EXTERN_C const CLSID GUID_EapHost_Cause_User_CredsRejected;

EXTERN_C const CLSID GUID_EapHost_Cause_Server_CertExpired;
EXTERN_C const CLSID GUID_EapHost_Cause_Server_CertInvalid;
EXTERN_C const CLSID GUID_EapHost_Cause_Server_CertNotFound;
EXTERN_C const CLSID GUID_EapHost_Cause_Server_CertOtherError;
EXTERN_C const CLSID GUID_EapHost_Cause_Server_CertRevoked;

EXTERN_C const CLSID GUID_EapHost_Cause_User_Root_CertExpired;
EXTERN_C const CLSID GUID_EapHost_Cause_User_Root_CertInvalid;
EXTERN_C const CLSID GUID_EapHost_Cause_User_Root_CertNotFound;

EXTERN_C const CLSID GUID_EapHost_Cause_Server_Root_CertNotFound;
EXTERN_C const CLSID GUID_EapHost_Cause_Server_Root_CertNameRequired;
EXTERN_C const CLSID GUID_EapHost_Cause_No_SmartCardReader_Found;

EXTERN_C const CLSID GUID_EapHost_Repair_ContactSysadmin;
EXTERN_C const CLSID GUID_EapHost_Repair_Retry_Authentication;

EXTERN_C const CLSID GUID_EapHost_Repair_User_AuthFailure;
EXTERN_C const CLSID GUID_EapHost_Repair_User_GetNewCert;
EXTERN_C const CLSID GUID_EapHost_Repair_User_SelectValidCert;

EXTERN_C const CLSID GUID_EapHost_Repair_Server_ClientSelectServerCert;

EXTERN_C const CLSID GUID_EapHost_Repair_ContactAdmin_AuthFailure;
EXTERN_C const CLSID GUID_EapHost_Repair_ContactAdmin_IdentityUnknown;
EXTERN_C const CLSID GUID_EapHost_Repair_ContactAdmin_NegotiationFailed;
EXTERN_C const CLSID GUID_EapHost_Repair_ContactAdmin_MethodNotFound;
EXTERN_C const CLSID GUID_EapHost_Repair_RestartNap;
EXTERN_C const CLSID GUID_EapHost_Repair_ContactAdmin_CertStoreInaccessible;
EXTERN_C const CLSID GUID_EapHost_Repair_ContactAdmin_InvalidUserAccount;
EXTERN_C const CLSID GUID_EapHost_Repair_ContactAdmin_InvalidUserCert;
EXTERN_C const CLSID GUID_EapHost_Repair_ContactAdmin_RootCertInvalid;
EXTERN_C const CLSID GUID_EapHost_Repair_ContactAdmin_RootCertNotFound;
EXTERN_C const CLSID GUID_EapHost_Repair_ContactAdmin_RootExpired;
EXTERN_C const CLSID GUID_EapHost_Repair_ContactAdmin_CertNameAbsent;
EXTERN_C const CLSID GUID_EapHost_Repair_ContactAdmin_NoSmartCardReader;
EXTERN_C const CLSID GUID_EapHost_Repair_Method_Not_Support_Sso;
      
EXTERN_C const CLSID GUID_EapHost_Help_ObtainingCerts;
EXTERN_C const CLSID GUID_EapHost_Help_Troubleshooting;
EXTERN_C const CLSID GUID_EapHost_Cause_Method_Config_Does_Not_Support_Sso;

//--------------------------


typedef
#ifdef __midl
   [v1_enum]
#endif

// Attributes that EAP Methods support
enum _EAP_ATTRIBUTE_TYPE
{
    eatMinimum = 0,                // Undefined
    eatUserName,                   // Value field is a Pointer
    eatUserPassword,               // Value field is a Pointer
    eatMD5CHAPPassword,            // Value field is a Pointer
    eatNASIPAddress,               // Value field is a 32 bit integral value
    eatNASPort,                    // Value field is a 32 bit integral value
    eatServiceType,                // Value field is a 32 bit integral value
    eatFramedProtocol,             // Value field is a 32 bit integral value
    eatFramedIPAddress,            // Value field is a 32 bit integral value
    eatFramedIPNetmask,            // Value field is a 32 bit integral value
    eatFramedRouting = 10,         // Value field is a 32 bit integral value
    eatFilterId,                   // Value field is a Pointer
    eatFramedMTU,                  // Value field is a 32 bit integral value
    eatFramedCompression,          // Value field is a 32 bit integral value
    eatLoginIPHost,                // Value field is a 32 bit integral value
    eatLoginService,               // Value field is a 32 bit integral value
    eatLoginTCPPort,               // Value field is a 32 bit integral value
    eatUnassigned17,               // Undefined
    eatReplyMessage,               // Value field is a Pointer
    eatCallbackNumber,             // Value field is a Pointer
    eatCallbackId =20,             // Value field is a Pointer
    eatUnassigned21,               // Undefined
    eatFramedRoute,                // Value field is a Pointer
    eatFramedIPXNetwork,           // Value field is a 32 bit integral value
    eatState,                      // Value field is a Pointer
    eatClass,                      // Value field is a Pointer
    eatVendorSpecific,             // Value field is a Pointer
    eatSessionTimeout,             // Value field is a 32 bit integral value
    eatIdleTimeout,                // Value field is a 32 bit integral value
    eatTerminationAction,          // Value field is a 32 bit integral value
    eatCalledStationId = 30,       // Value field is a Pointer
    eatCallingStationId,           // Value field is a Pointer
    eatNASIdentifier,              // Value field is a Pointer
    eatProxyState,                 // Value field is a Pointer
    eatLoginLATService,            // Value field is a Pointer
    eatLoginLATNode,               // Value field is a Pointer
    eatLoginLATGroup,              // Value field is a Pointer
    eatFramedAppleTalkLink,        // Value field is a 32 bit integral value
    eatFramedAppleTalkNetwork,     // Value field is a 32 bit integral value
    eatFramedAppleTalkZone,        // Value field is a Pointer
    eatAcctStatusType = 40,        // Value field is a 32 bit integral value
    eatAcctDelayTime,              // Value field is a 32 bit integral value
    eatAcctInputOctets,            // Value field is a 32 bit integral value
    eatAcctOutputOctets,           // Value field is a 32 bit integral value
    eatAcctSessionId,              // Value field is a Pointer
    eatAcctAuthentic,              // Value field is a 32 bit integral value
    eatAcctSessionTime,            // Value field is a 32 bit integral value
    eatAcctInputPackets,           // Value field is a 32 bit integral value
    eatAcctOutputPackets,          // Value field is a 32 bit integral value
    eatAcctTerminateCause,         // Value field is a 32 bit integral value
    eatAcctMultiSessionId = 50,    // Value field is a Pointer
    eatAcctLinkCount,              // Value field is a 32 bit integral value
    eatAcctEventTimeStamp = 55,    // Value field is a 32 bit integral value
    eatMD5CHAPChallenge = 60,      // Value field is a Pointer
    eatNASPortType,                // Value field is a 32 bit integral value
    eatPortLimit,                  // Value field is a 32 bit integral value
    eatLoginLATPort,               // Value field is a Pointer
    eatTunnelType,                 // Value field is a 32 bit integral value
    eatTunnelMediumType,           // Value field is a 32 bit integral value
    eatTunnelClientEndpoint,       // Value field is a Pointer
    eatTunnelServerEndpoint,       // Value field is a Pointer
    eatARAPPassword = 70,          // Value field is a Pointer
    eatARAPFeatures,               // Value field is a Pointer
    eatARAPZoneAccess,             // Value field is a 32 bit integral value
    eatARAPSecurity,               // Value field is a 32 bit integral value
    eatARAPSecurityData,           // Value field is a Pointer
    eatPasswordRetry,              // Value field is a 32 bit integral value
    eatPrompt,                     // Value field is a 32 bit integral value
    eatConnectInfo,                // Value field is a Pointer
    eatConfigurationToken,         // Value field is a Pointer
    eatEAPMessage,                 // Value field is a Pointer
    eatSignature = 80,             // Value field is a Pointer
    eatARAPChallengeResponse = 84, // Value field is a Pointer
    eatAcctInterimInterval = 85,   // Value field is a 32 bit integral value
    eatNASIPv6Address = 95,  // Value field is a Pointer
    eatFramedInterfaceId, // Value field is a Pointer
    eatFramedIPv6Prefix, // Value field is a Pointer
    eatLoginIPv6Host, // Value field is a Pointer
    eatFramedIPv6Route, // Value field is a Pointer
    eatFramedIPv6Pool, // Value field is a Pointer
    eatARAPGuestLogon = 8096,      // Value field is a 32 bit integral value
    eatCertificateOID,             // Value field is a Pointer
    eatEAPConfiguration,           // Value field is a Pointer
    eatPEAPEmbeddedEAPTypeId,      // Value field is a 32 bit integral value
    eatPEAPFastRoamedSession,      // Value field is a 32 bit integral value
    eatEAPTLV = 8102,              // Value field is a Pointer
    eatCredentialsChanged,        // Value field is a Integer with boolean
                                   // semantics
    eatInnerEapMethodType,         // Value field is a pointer
                                   // EapMethodType of the inner method in
                                   // case of Tunnelled method
    eatClearTextPassword = 8107,   // Value field is a pointer
                                   // Clear text password that can be used
                                   // by certain password based eap methods
                                   // to authenticate a user.
    eatQuarantineSoH     = 8150, // Value field is a pointer
    eatPeerId                 = 9000,  // Value field is a pointer
    eatServerId,                          // Value field is a pointer
    eatMethodId,                          // Value field is a pointer
    eatEMSK,                               // Value field is a pointer
    eatSessionId,                               // Value field is a pointer
    eatReserved = 0xFFFFFFFF       // Undefined
} EAP_ATTRIBUTE_TYPE, EapAttributeType;


// format for carrying EAP attribute TLV (type, length and value)
typedef struct _EAP_ATTRIBUTE
{
        EAP_ATTRIBUTE_TYPE eaType;
        DWORD dwLength;
#ifdef __midl
        [size_is(dwLength)] BYTE* pValue;
#else
    BYTE *pValue;
#endif
} EAP_ATTRIBUTE, EapAttribute;


// List of EAP-attributes
typedef struct _EAP_ATTRIBUTES
{
        DWORD dwNumberOfAttributes;
#ifdef __midl
        [size_is(dwNumberOfAttributes)] EAP_ATTRIBUTE* pAttribs;
#else
    EAP_ATTRIBUTE *pAttribs;
#endif
} EAP_ATTRIBUTES, EapAttributes;


// No UI should be displayed
#define EAP_FLAG_Reserved1              0x00000001
#define EAP_FLAG_NON_INTERACTIVE        0x00000002

// The user data was obtained from Winlogon
#define EAP_FLAG_LOGON                  0x00000004

// Show the Credentails UI before authenticating even if cached creds are present
#define EAP_FLAG_PREVIEW                0x00000008

#define EAP_FLAG_Reserved2              0x00000010

// Authentication is for machine, i.e. not for user. Not setting this flag means
// it is user authentication.
#define EAP_FLAG_MACHINE_AUTH           0x00000020

// Request to provide guest access
#define EAP_FLAG_GUEST_ACCESS           0x00000040

#define EAP_FLAG_Reserved3              0x00000080

#define EAP_FLAG_Reserved4              0x00000100

// Indicates this is the first call after m/c resumed from hibernation.
#define EAP_FLAG_RESUME_FROM_HIBERNATE  0x00000200

#define EAP_FLAG_Reserved5              0x00000400

#define EAP_FLAG_Reserved6              0x00000800

// Should have this or make it reserved?
#define EAP_FLAG_FULL_AUTH              0x00001000

///   New EapHost Flags

// Prefer Credentails passed in BeginSession instead of other form of
// credentials, even if config says use certain way of cred retrieval. If this fails, fallback to
// Method specific credentail retrieval
#define EAP_FLAG_PREFER_ALT_CREDENTIALS     0x00002000

#define EAP_FLAG_Reserved7                  0x00004000

// To inform the cause of reauth is a NAP callback
#define EAP_PEER_FLAG_HEALTH_STATE_CHANGE   0x00008000

// Continue authentication with information available. If can not proceed, fail
// the authentication
#define EAP_FLAG_SUPRESS_UI                 0x00010000

// Pre logon scenario like PLAP
#define EAP_FLAG_PRE_LOGON                  0x00020000

// User Authentication. For legacy Methods not setting EAP_FLAG_MACHINE_AUTH
// also means user authentication.
#define EAP_FLAG_USER_AUTH                  0x00040000

// Config can be viewed but not updated
#define EAP_FLAG_CONFG_READONLY             0x00080000

#define EAP_FLAG_Reserved8                  0x00100000

// the various states of the input fields
#define EAP_CONFIG_INPUT_FIELD_PROPS_DEFAULT                0X00000000
#define EAP_CONFIG_INPUT_FIELD_PROPS_NON_DISPLAYABLE        0X00000001

// This specifies that supplicant should cache this field data
#define EAP_CONFIG_INPUT_FIELD_PROPS_NON_PERSIST            0X00000002


// default property value for entries field to be shown in UI
#define EAP_UI_INPUT_FIELD_PROPS_DEFAULT          EAP_CONFIG_INPUT_FIELD_PROPS_DEFAULT
// To qualify certain entry data on UI is non-displayable (e.g. password)
#define EAP_UI_INPUT_FIELD_PROPS_NON_DISPLAYABLE  EAP_CONFIG_INPUT_FIELD_PROPS_NON_DISPLAYABLE
// This specifies that supplicant should cache this field data
#define EAP_UI_INPUT_FIELD_PROPS_NON_PERSIST            0X00000002
// This specifies that following field is read only (non-editable)
#define EAP_UI_INPUT_FIELD_PROPS_READ_ONLY              0X00000004


// the types of fields that eap can request to show
typedef enum _EAP_CONFIG_INPUT_FIELD_TYPE {
    EapConfigInputUsername,
    EapConfigInputPassword,
    EapConfigInputNetworkUsername,
    EapConfigInputNetworkPassword,
    EapConfigInputPin,
    EapConfigInputPSK,
    EapConfigInputEdit,
    EapConfigSmartCardUsername,
    EapConfigSmartCardError
} EAP_CONFIG_INPUT_FIELD_TYPE, *PEAP_CONFIG_INPUT_FIELD_TYPE;

#define EAP_CREDENTIAL_VERSION                     1
#define EAP_INTERACTIVE_UI_DATA_VERSION            1
#define EAPHOST_PEER_API_VERSION                   1
#define EAPHOST_METHOD_API_VERSION                 1
#define MAX_EAP_CONFIG_INPUT_FIELD_LENGTH          256
#define MAX_EAP_CONFIG_INPUT_FIELD_VALUE_LENGTH    1024


// structure for carrying EAP input field
typedef struct _EAP_CONFIG_INPUT_FIELD_DATA {
    DWORD dwSize;
    EAP_CONFIG_INPUT_FIELD_TYPE Type;
    DWORD dwFlagProps;
    LPWSTR pwszLabel;
    LPWSTR pwszData;
    DWORD dwMinDataLength;
    DWORD dwMaxDataLength;
} EAP_CONFIG_INPUT_FIELD_DATA, *PEAP_CONFIG_INPUT_FIELD_DATA;


// List of EAP input fields
typedef struct _EAP_CONFIG_INPUT_FIELD_ARRAY {
    DWORD dwVersion; // used for versioning
    DWORD dwNumberOfFields;
#ifdef __midl
    [size_is(dwNumberOfFields)] EAP_CONFIG_INPUT_FIELD_DATA* pFields;
#else
    EAP_CONFIG_INPUT_FIELD_DATA* pFields;
#endif
} EAP_CONFIG_INPUT_FIELD_ARRAY, *PEAP_CONFIG_INPUT_FIELD_ARRAY;


// provides type of data, EAP_INTERACTIVE_UI_DATA can carry
typedef enum _EAP_INTERACTIVE_UI_DATA_TYPE {
    EapCredReq,             // Credential request during retry
    EapCredResp,            // Credential response during retry
    EapCredExpiryReq,       // Credential request during cred expiry
    EapCredExpiryResp,      // Credential response during cred expiry
    EapCredLogonReq,        // Initial credential request during auth
    EapCredLogonResp,       // Initial credential response during auth
} EAP_INTERACTIVE_UI_DATA_TYPE;


// following determine type of data blob that can be pointed by
// pbUiData member of EAP_INTERACTIVE_UI_DATA
typedef EAP_CONFIG_INPUT_FIELD_ARRAY EAP_CRED_REQ;
typedef EAP_CONFIG_INPUT_FIELD_ARRAY EAP_CRED_RESP;
typedef EAP_CONFIG_INPUT_FIELD_ARRAY EAP_CRED_LOGON_REQ;
typedef EAP_CONFIG_INPUT_FIELD_ARRAY EAP_CRED_LOGON_RESP;

// pNewCreds can be NULL in case of EAP_CRED_EXPIRY_REQ
// in case of REQ, pNewCreds can be empty (will not be looked at)
typedef struct _EAP_CRED_EXPIRY_REQ {
    EAP_CONFIG_INPUT_FIELD_ARRAY curCreds;
    EAP_CONFIG_INPUT_FIELD_ARRAY newCreds;
} EAP_CRED_EXPIRY_REQ, EAP_CRED_EXPIRY_RESP;

#ifdef __midl
    typedef [switch_type(EAP_INTERACTIVE_UI_DATA_TYPE)]
    union {
       [case(EapCredReq, EapCredResp)]      EAP_CRED_REQ*  credData;
       [case(EapCredExpiryReq,EapCredExpiryResp)] EAP_CRED_EXPIRY_REQ* credExpiryData;
       [case(EapCredLogonReq,EapCredLogonResp)] EAP_CRED_LOGON_REQ* credLogonData;
       [default]      ;
    } EAP_UI_DATA_FORMAT;
#else
    typedef union {
       EAP_CRED_REQ*  credData;
       EAP_CRED_EXPIRY_REQ* credExpiryData;
       EAP_CRED_LOGON_REQ* credLogonData;
    } EAP_UI_DATA_FORMAT;
#endif


// Data carried from EAP-method to supplicant for interactive UI to raised
typedef struct _EAP_INTERACTIVE_UI_DATA {
    //specifies version of data structure. It must be 0.
    DWORD dwVersion;
    //specifies size of the entire structure.
    DWORD dwSize;
    // this determines what kind of interactive data is passed.
    EAP_INTERACTIVE_UI_DATA_TYPE dwDataType;
    // specifies size of the data pointed by pbUiByte.
    DWORD cbUiData;
    // pointer to a data blob of a type determined by dwDataType above.
    // This can be of type EAP_CRED_REQ/EAP_CRED_RESP or
    // EAP_CRED_EXPIRY_REQ/EAP_CRED_EXPIRY_RESP or
    // EAP_CRED_LOGON_REQ/EAP_CRED_LOGON_RESP depending on uiDataType above
#ifdef __midl
    [switch_is (dwDataType)] EAP_UI_DATA_FORMAT pbUiData;
#else
    EAP_UI_DATA_FORMAT pbUiData;
#endif
} EAP_INTERACTIVE_UI_DATA ;

typedef
#ifdef __midl
    [v1_enum]
#endif
// Property types that EAP methods support
enum _EAP_METHOD_PROPERTY_TYPE
{
    emptPropCipherSuiteNegotiation = 0,     // value field is boolean
    emptPropMutualAuth,                     // value field is boolean
    emptPropIntegrity,                      // value field is boolean
    emptPropReplayProtection,               // value field is boolean
    emptPropConfidentiality,                // value field is boolean
    emptPropKeyDerivation,                  // value field is boolean
    emptPropKeyStrength64,                  // value field is boolean
    emptPropKeyStrength128,                 // value field is boolean
    emptPropKeyStrength256,                 // value field is boolean
    emptPropKeyStrength512,                 // value field is boolean
    emptPropKeyStrength1024,                // value field is boolean
    emptPropDictionaryAttackResistance,     // value field is boolean
    emptPropFastReconnect,                  // value field is boolean
    emptPropCryptoBinding,                  // value field is boolean
    emptPropSessionIndependence,            // value field is boolean
    emptPropFragmentation,                  // value field is boolean
    emptPropChannelBinding,                 // value field is boolean
    emptPropNap,                            // value field is boolean
    emptPropStandalone,                     // value field is boolean
    emptPropMppeEncryption,                 // value field is boolean
    emptPropTunnelMethod,                   // value field is boolean
    emptPropSupportsConfig,                 // value field is boolean
    emptPropCertifiedMethod,                // value field is boolean
    emptPropHiddenMethod,                   // value field is boolean
    emptPropMachineAuth,                    // value field is boolean
    emptPropUserAuth,                       // value field is boolean
    emptPropIdentityPrivacy,                // value field is boolean
    emptPropMethodChaining,                 // value field is boolean
    emptPropSharedStateEquivalence,         // value field is boolean
    emptLegacyMethodPropertyFlag = 31,      // value field is dword
    emptPropVendorSpecific = 255            // value field is string
} EAP_METHOD_PROPERTY_TYPE;

typedef
#ifdef __midl
    [v1_enum]
#endif
// Method property value types that EAP methods support
enum _EAP_METHOD_PROPERTY_VALUE_TYPE
{
    empvtBool = 0,      // value type is boolean
    empvtDword,         // value type is dword
    empvtString         // value type is string
} EAP_METHOD_PROPERTY_VALUE_TYPE;

typedef struct _EAP_METHOD_PROPERTY_VALUE_BOOL
{
    DWORD length;
    BOOL value;
} EAP_METHOD_PROPERTY_VALUE_BOOL;

typedef struct _EAP_METHOD_PROPERTY_VALUE_DWORD
{
    DWORD length;
    DWORD value;
} EAP_METHOD_PROPERTY_VALUE_DWORD;

typedef struct _EAP_METHOD_PROPERTY_VALUE_STRING
{
    DWORD length;
#ifdef __midl
    [size_is(length)] BYTE* value;
#else
    BYTE* value;
#endif
} EAP_METHOD_PROPERTY_VALUE_STRING;

#ifdef __midl
typedef [switch_type(EAP_METHOD_PROPERTY_VALUE_TYPE)]
union {
    [case(empvtBool)]
        EAP_METHOD_PROPERTY_VALUE_BOOL empvBool;      // value is boolean type

    [case(empvtDword)]
        EAP_METHOD_PROPERTY_VALUE_DWORD empvDword;    // value is dword type

    [case(empvtString)]
        EAP_METHOD_PROPERTY_VALUE_STRING empvString;   // value is string type
} EAP_METHOD_PROPERTY_VALUE;
#else
typedef union _EAP_METHOD_PROPERTY_VALUE {
    EAP_METHOD_PROPERTY_VALUE_BOOL empvBool;      // value is boolean type
    EAP_METHOD_PROPERTY_VALUE_DWORD empvDword;    // value is dword type
    EAP_METHOD_PROPERTY_VALUE_STRING empvString;   // value is string type
} EAP_METHOD_PROPERTY_VALUE;
#endif

// Structure to represent a method property
typedef struct _EAP_METHOD_PROPERTY {
    // specifies the method property type
    EAP_METHOD_PROPERTY_TYPE eapMethodPropertyType;

    // specifies the data type of value
    EAP_METHOD_PROPERTY_VALUE_TYPE eapMethodPropertyValueType;
#ifdef __midl
    [switch_is(eapMethodPropertyValueType)] EAP_METHOD_PROPERTY_VALUE eapMethodPropertyValue;
#else
    // specifies the value of the method property
    EAP_METHOD_PROPERTY_VALUE eapMethodPropertyValue;
#endif
} EAP_METHOD_PROPERTY;

// Structure to represent an array of method properties
typedef struct _EAP_METHOD_PROPERTY_ARRAY {
    // specifies the number of method properties in array
    DWORD dwNumberOfProperties;

    // specifies the array of method property
#ifdef __midl
    [size_is(dwNumberOfProperties)] EAP_METHOD_PROPERTY* pFields;
#else
    EAP_METHOD_PROPERTY* pMethodProperty;
#endif
} EAP_METHOD_PROPERTY_ARRAY;


#endif //EAPTYPES_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\edevdefs.h ===
//------------------------------------------------------------------------------
// File: EDevDefs.h
//
// Desc: External Device (such as a VCR) control interface parameter and
//       value definitions.  
//
//       Note:  new constants added:  ED_BASE+800L -> ED_BASE+811L
//
// Copyright (c) 1992 - 2002, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef __EDEVDEFS__
#define __EDEVDEFS__


#define ED_BASE		        		0x1000L

// this is used to tell the device communications object which
// physical communications port to use.
#define DEV_PORT_SIM	1
#define DEV_PORT_COM1	2	// standard serial ports
#define DEV_PORT_COM2	3
#define DEV_PORT_COM3	4
#define DEV_PORT_COM4	5
#define DEV_PORT_DIAQ	6	// Diaquest driver
#define DEV_PORT_ARTI	7	// ARTI driver
#define DEV_PORT_1394	8	// IEEE 1394 Serial Bus
#define DEV_PORT_USB	9	// Universal Serial Bus
#define DEV_PORT_MIN	DEV_PORT_SIM
#define DEV_PORT_MAX	DEV_PORT_USB


//	IAMExtDevice Capability Items:  unless otherwise specified, these items return 
//	   OATRUE or OAFALSE.  All return values are in pdwValue unless otherwise specified:

#define ED_DEVCAP_CAN_RECORD			ED_BASE+1L
#define ED_DEVCAP_CAN_RECORD_STROBE		ED_BASE+2L	// for multitrack devices: 
													// switches currently recording tracks off 
													// and selected non-recording tracks into record
#define ED_DEVCAP_HAS_AUDIO			ED_BASE+3L
#define ED_DEVCAP_HAS_VIDEO			ED_BASE+4L
#define ED_DEVCAP_USES_FILES		ED_BASE+5L
#define ED_DEVCAP_CAN_SAVE			ED_BASE+6L

#define ED_DEVCAP_DEVICE_TYPE		ED_BASE+7L	// returns one of the following:
#define ED_DEVTYPE_VCR				ED_BASE+8L
#define ED_DEVTYPE_LASERDISK		ED_BASE+9L
#define ED_DEVTYPE_ATR 				ED_BASE+10L
#define ED_DEVTYPE_DDR				ED_BASE+11L
#define ED_DEVTYPE_ROUTER 			ED_BASE+12L
#define ED_DEVTYPE_KEYER 			ED_BASE+13L
#define ED_DEVTYPE_MIXER_VIDEO 		ED_BASE+14L
#define ED_DEVTYPE_DVE 				ED_BASE+15L
#define ED_DEVTYPE_WIPEGEN 			ED_BASE+16L
#define ED_DEVTYPE_MIXER_AUDIO 		ED_BASE+17L
#define ED_DEVTYPE_CG 				ED_BASE+18L
#define ED_DEVTYPE_TBC 				ED_BASE+19L
#define ED_DEVTYPE_TCG 				ED_BASE+20L
#define ED_DEVTYPE_GPI 				ED_BASE+21L
#define ED_DEVTYPE_JOYSTICK 		ED_BASE+22L
#define ED_DEVTYPE_KEYBOARD			ED_BASE+23L

// returns mfr-specific ID from external device.
#define ED_DEVCAP_EXTERNAL_DEVICE_ID	ED_BASE+24L

#define ED_DEVCAP_TIMECODE_READ		ED_BASE+25L
#define ED_DEVCAP_TIMECODE_WRITE	ED_BASE+26L
//	used for seekable non-timecode enabled devices
#define ED_DEVCAP_CTLTRK_READ		ED_BASE+27L
//	used for seekable non-timecode enabled devices
#define ED_DEVCAP_INDEX_READ		ED_BASE+28L

// returns device preroll time in current time format
#define ED_DEVCAP_PREROLL			ED_BASE+29L
// returns device postroll time in current time format
#define ED_DEVCAP_POSTROLL			ED_BASE+30L

// returns indication of device's synchronization accuracy.
#define ED_DEVCAP_SYNC_ACCURACY		ED_BASE+31L	// returns one of the following:
#define ED_SYNCACC_PRECISE			ED_BASE+32L
#define ED_SYNCACC_FRAME			ED_BASE+33L
#define ED_SYNCACC_ROUGH			ED_BASE+34L

// returns device's normal framerate.
#define ED_DEVCAP_NORMAL_RATE	ED_BASE+35L	// returns one of the following:
#define ED_RATE_24				ED_BASE+36L
#define ED_RATE_25				ED_BASE+37L
#define ED_RATE_2997			ED_BASE+38L
#define ED_RATE_30				ED_BASE+39L

#define ED_DEVCAP_CAN_PREVIEW	ED_BASE+40L
#define ED_DEVCAP_CAN_MONITOR_SOURCES	ED_BASE+41L

// indicates implementation allows testing of methods/parameters by
// setting the hi bit of a parm that makes sense - see individual methods
// for details.
#define ED_DEVCAP_CAN_TEST			ED_BASE+42L
	
// indicates device accepts video as an input.
#define ED_DEVCAP_VIDEO_INPUTS		ED_BASE+43L

// indicates device accepts audio as an input.
#define ED_DEVCAP_AUDIO_INPUTS		ED_BASE+44L

#define ED_DEVCAP_NEEDS_CALIBRATING	ED_BASE+45L

#define ED_DEVCAP_SEEK_TYPE			ED_BASE+46L	// returns one of the following:
#define ED_SEEK_PERFECT				ED_BASE+47L	// indicates device can execute seek 
												// within 1 video frames without signal 
												//	break (like a DDR)
#define ED_SEEK_FAST				ED_BASE+48L	// indicates device can move pretty quick 
												//  with short break in signal
#define ED_SEEK_SLOW				ED_BASE+49L	// seeks like a tape transport

#define ED_POWER_ON					ED_BASE+50L
#define ED_POWER_OFF				ED_BASE+51L
#define ED_POWER_STANDBY			ED_BASE+52L

#define ED_ACTIVE					ED_BASE+53L
#define ED_INACTIVE 				ED_BASE+54L
#define ED_ALL						ED_BASE+55L
#define ED_TEST						ED_BASE+56L

//	IAMExtTransport Capability Items:  unless otherwise specified, these items return 
//	   OATRUE or OAFALSE.  All return values are in pdwValue unless otherwise specified:

#define ED_TRANSCAP_CAN_EJECT			ED_BASE+100L
#define ED_TRANSCAP_CAN_BUMP_PLAY		ED_BASE+101L	// variable speed for synchronizing
#define ED_TRANSCAP_CAN_PLAY_BACKWARDS	ED_BASE+102L	// servo locked for use during an edit
#define ED_TRANSCAP_CAN_SET_EE			ED_BASE+103L	// show device's input on its output
#define ED_TRANSCAP_CAN_SET_PB			ED_BASE+104L	// show media playback on device's output
#define ED_TRANSCAP_CAN_DELAY_VIDEO_IN	ED_BASE+105L	// transport can do delayed-in video edits
#define ED_TRANSCAP_CAN_DELAY_VIDEO_OUT	ED_BASE+106L	// transport can do delayed-out video edits
#define ED_TRANSCAP_CAN_DELAY_AUDIO_IN	ED_BASE+107L	// transport can do delayed-in audio edits
#define ED_TRANSCAP_CAN_DELAY_AUDIO_OUT	ED_BASE+108L	// transport can do delayed-out audio edits
#define ED_TRANSCAP_FWD_VARIABLE_MAX	ED_BASE+109L	// max forward speed (multiple of play speed) 
														//  in pdblValue
#define ED_TRANSCAP_FWD_VARIABLE_MIN	ED_BASE+800L	// min forward speed (multiple of play speed) 
														//  in pdblValue
#define ED_TRANSCAP_REV_VARIABLE_MAX	ED_BASE+110L	// max reverse speed (multiple of play speed) in
														//  pdblValue
#define ED_TRANSCAP_REV_VARIABLE_MIN	ED_BASE+801L	// min reverse speed (multiple of play speed)
														//  in pdblValue
#define ED_TRANSCAP_FWD_SHUTTLE_MAX		ED_BASE+802L	// max forward speed in Shuttle mode (multiple
														//  of play speed) in pdblValue
#define ED_TRANSCAP_FWD_SHUTTLE_MIN		ED_BASE+803L	// min forward speed in Shuttle mode (multiple
														//  of play speed) in pdblValue
#define ED_TRANSCAP_REV_SHUTTLE_MAX		ED_BASE+804L	// max reverse speed in Shuttle mode (multiple
														//  of play speed) in pdblValue
#define ED_TRANSCAP_REV_SHUTTLE_MIN		ED_BASE+805L	// min reverse speed in Shuttle mode (multiple
														//  of play speed) in pdblValue
#define ED_TRANSCAP_NUM_AUDIO_TRACKS	ED_BASE+111L	// returns number of audio tracks
#define ED_TRANSCAP_LTC_TRACK			ED_BASE+112L	// returns track number of LTC timecode track.
														//  ED_ALL means no dedicated timecode track
#define ED_TRANSCAP_NEEDS_TBC			ED_BASE+113L	// device's output not stable
#define ED_TRANSCAP_NEEDS_CUEING		ED_BASE+114L	// device must be cued prior to performing edit
#define ED_TRANSCAP_CAN_INSERT			ED_BASE+115L
#define ED_TRANSCAP_CAN_ASSEMBLE		ED_BASE+116L
#define ED_TRANSCAP_FIELD_STEP			ED_BASE+117L	// device responds to Frame Advance command by 
														//  advancing one field
#define ED_TRANSCAP_CLOCK_INC_RATE		ED_BASE+118L	// VISCA command - keep for compatibility
#define ED_TRANSCAP_CAN_DETECT_LENGTH	ED_BASE+119L
#define ED_TRANSCAP_CAN_FREEZE			ED_BASE+120L
#define ED_TRANSCAP_HAS_TUNER			ED_BASE+121L
#define ED_TRANSCAP_HAS_TIMER			ED_BASE+122L
#define ED_TRANSCAP_HAS_CLOCK			ED_BASE+123L
#define ED_TRANSCAP_MULTIPLE_EDITS		ED_BASE+806L	// OATRUE means device/filter can support
														//  multiple edit events
#define ED_TRANSCAP_IS_MASTER			ED_BASE+807L	// OATRUE means device is the master clock
														//  for synchronizing (this sets timecode-to-
														//  reference clock offset for editing)
#define ED_TRANSCAP_HAS_DT				ED_BASE+814L	// OATRUE means device has Dynamic Tracking

//	IAMExtTransport Media States
#define ED_MEDIA_SPIN_UP			ED_BASE+130L
#define ED_MEDIA_SPIN_DOWN			ED_BASE+131L
#define ED_MEDIA_UNLOAD				ED_BASE+132L

//	IAMExtTransport Modes
#define	ED_MODE_PLAY				ED_BASE+200L
#define	ED_MODE_STOP				ED_BASE+201L
#define	ED_MODE_FREEZE				ED_BASE+202L	// really "pause"
#define	ED_MODE_THAW				ED_BASE+203L
#define	ED_MODE_FF					ED_BASE+204L
#define	ED_MODE_REW					ED_BASE+205L
#define	ED_MODE_RECORD				ED_BASE+206L
#define	ED_MODE_RECORD_STROBE		ED_BASE+207L
#define ED_MODE_RECORD_FREEZE		ED_BASE+808L    // pause recording	
#define	ED_MODE_STEP				ED_BASE+208L	// same as "jog"
#define	ED_MODE_STEP_FWD			ED_BASE+208L	// same as ED_MODE_STEP
#define	ED_MODE_STEP_REV			ED_BASE+809L
#define	ED_MODE_SHUTTLE				ED_BASE+209L
#define	ED_MODE_EDIT_CUE			ED_BASE+210L
#define ED_MODE_VAR_SPEED			ED_BASE+211L
#define ED_MODE_PERFORM				ED_BASE+212L	// returned status only
#define	ED_MODE_LINK_ON				ED_BASE+280L
#define	ED_MODE_LINK_OFF			ED_BASE+281L
#define ED_MODE_NOTIFY_ENABLE		ED_BASE+810L
#define ED_MODE_NOTIFY_DISABLE		ED_BASE+811L
#define ED_MODE_SHOT_SEARCH			ED_BASE+812L

//	IAMTimecodeReader/Generator/Display defines
//
// Timecode Generator Mode params and values:
//
#define ED_TCG_TIMECODE_TYPE		ED_BASE+400L	// can be one of the following:
#define ED_TCG_SMPTE_LTC			ED_BASE+401L
#define ED_TCG_SMPTE_VITC			ED_BASE+402L
#define ED_TCG_MIDI_QF				ED_BASE+403L
#define ED_TCG_MIDI_FULL			ED_BASE+404L

#define ED_TCG_FRAMERATE			ED_BASE+405L	// can be one of the following:
#define ED_FORMAT_SMPTE_30			ED_BASE+406L
#define ED_FORMAT_SMPTE_30DROP		ED_BASE+407L
#define ED_FORMAT_SMPTE_25			ED_BASE+408L
#define ED_FORMAT_SMPTE_24			ED_BASE+409L

#define ED_TCG_SYNC_SOURCE			ED_BASE+410L	// can be one of the following:
#define ED_TCG_VIDEO				ED_BASE+411L
#define ED_TCG_READER				ED_BASE+412L
#define ED_TCG_FREE					ED_BASE+413L

#define ED_TCG_REFERENCE_SOURCE		ED_BASE+414L	// can have one these values:
													//	ED_TCG_FREE || ED_TCG_READER 
													//	(for regen/jamsync)

// TimeCodeReader Mode params and values:
#define ED_TCR_SOURCE			ED_BASE+416L	// can be one of the following:
// ED_TCG (already defined)
#define ED_TCR_LTC				ED_BASE+417L
#define ED_TCR_VITC				ED_BASE+418L
#define ED_TCR_CT				ED_BASE+419L	// Control Track
#define ED_TCR_FTC				ED_BASE+420L	// File TimeCode - for file-based devices
												//  that wish they were transports
// ED_MODE_NOTIFY_ENABLE can be OATRUE or OAFALSE (defined in transport mode
//  section of this file).  
#define ED_TCR_LAST_VALUE		ED_BASE+421L	// for notification mode - 
												//  successive calls to GetTimecode
												//  return the last read value
// TimeCode Display Mode params and values:
//
#define ED_TCD_SOURCE			ED_BASE+422L	// can be one of the following:
#define ED_TCR					ED_BASE+423L
#define ED_TCG					ED_BASE+424L

#define ED_TCD_SIZE				ED_BASE+425L	// can be one of the following:
#define ED_SMALL				ED_BASE+426L
#define ED_MED					ED_BASE+427L
#define ED_LARGE				ED_BASE+428L

#define ED_TCD_POSITION			ED_BASE+429L	// can be one of the following:
#define ED_TOP					0x0001
#define ED_MIDDLE				0x0002
#define ED_BOTTOM				0x0004			// or'd  with
#define ED_LEFT					0x0100
#define ED_CENTER				0x0200
#define ED_RIGHT				0x0400

#define ED_TCD_INTENSITY		ED_BASE+436L	// can be one of the following:
#define ED_HIGH					ED_BASE+437L
#define ED_LOW					ED_BASE+438L

#define ED_TCD_TRANSPARENCY		ED_BASE+439L	// 0-4, 0 is opaque

#define ED_TCD_INVERT			ED_BASE+440L	// OATRUE=black on white
												// OAFALSE=white on black
//	IAMExtTransport defines
//
// Transport status, params and values
//

// IAMExtTransport Status items and and values:
#define ED_MODE					ED_BASE+500L	// see ED_MODE_xxx values above
#define	ED_ERROR				ED_BASE+501L
#define	ED_LOCAL				ED_BASE+502L
#define	ED_RECORD_INHIBIT		ED_BASE+503L
#define	ED_SERVO_LOCK			ED_BASE+504L
#define	ED_MEDIA_PRESENT		ED_BASE+505L
#define	ED_MEDIA_LENGTH			ED_BASE+506L
#define	ED_MEDIA_SIZE			ED_BASE+507L
#define	ED_MEDIA_TRACK_COUNT	ED_BASE+508L
#define	ED_MEDIA_TRACK_LENGTH	ED_BASE+509L
#define	ED_MEDIA_SIDE			ED_BASE+510L

#define	ED_MEDIA_TYPE			ED_BASE+511L	// can be one of the following:
#define	ED_MEDIA_VHS			ED_BASE+512L
#define	ED_MEDIA_SVHS			ED_BASE+513L
#define	ED_MEDIA_HI8			ED_BASE+514L
#define	ED_MEDIA_UMATIC			ED_BASE+515L
#define	ED_MEDIA_DVC			ED_BASE+516L
#define	ED_MEDIA_1_INCH			ED_BASE+517L
#define	ED_MEDIA_D1				ED_BASE+518L
#define	ED_MEDIA_D2				ED_BASE+519L
#define	ED_MEDIA_D3				ED_BASE+520L
#define	ED_MEDIA_D5				ED_BASE+521L
#define	ED_MEDIA_DBETA			ED_BASE+522L
#define	ED_MEDIA_BETA			ED_BASE+523L
#define	ED_MEDIA_8MM			ED_BASE+524L
#define	ED_MEDIA_DDR			ED_BASE+525L
#define	ED_MEDIA_SX				ED_BASE+813L
#define	ED_MEDIA_OTHER			ED_BASE+526L
#define	ED_MEDIA_CLV			ED_BASE+527L
#define	ED_MEDIA_CAV			ED_BASE+528L
#define ED_MEDIA_POSITION		ED_BASE+529L

#define ED_LINK_MODE			ED_BASE+530L	// OATRUE if transport controls
							 					// are linked to graph's RUN, 
							 					// STOP, and PAUSE methods

// IAMExtTransport Basic Parms
#define	ED_TRANSBASIC_TIME_FORMAT	ED_BASE+540L	// can be one of the following:
#define	ED_FORMAT_MILLISECONDS		ED_BASE+541L
#define	ED_FORMAT_FRAMES			ED_BASE+542L
#define ED_FORMAT_REFERENCE_TIME	ED_BASE+543L

#define	ED_FORMAT_HMSF				ED_BASE+547L
#define	ED_FORMAT_TMSF				ED_BASE+548L

#define	ED_TRANSBASIC_TIME_REFERENCE	ED_BASE+549L	// can be one of the following:
#define	ED_TIMEREF_TIMECODE			ED_BASE+550L
#define	ED_TIMEREF_CONTROL_TRACK	ED_BASE+551L
#define	ED_TIMEREF_INDEX			ED_BASE+552L

#define	ED_TRANSBASIC_SUPERIMPOSE		ED_BASE+553L	// enable/disable onscreen display
#define	ED_TRANSBASIC_END_STOP_ACTION	ED_BASE+554L	// can be one of: ED_MODE_STOP |
														//	ED_MODE_REWIND | ED_MODE_FREEZE
#define	ED_TRANSBASIC_RECORD_FORMAT	ED_BASE+555L	// can be one of the following:
#define	ED_RECORD_FORMAT_SP			ED_BASE+556L
#define	ED_RECORD_FORMAT_LP			ED_BASE+557L
#define	ED_RECORD_FORMAT_EP			ED_BASE+558L

#define	ED_TRANSBASIC_STEP_COUNT	ED_BASE+559L
#define	ED_TRANSBASIC_STEP_UNIT		ED_BASE+560L	// can be one of the following:
#define	ED_STEP_FIELD				ED_BASE+561L
#define	ED_STEP_FRAME				ED_BASE+562L
#define	ED_STEP_3_2					ED_BASE+563L

#define	ED_TRANSBASIC_PREROLL		ED_BASE+564L
#define	ED_TRANSBASIC_RECPREROLL	ED_BASE+565L
#define	ED_TRANSBASIC_POSTROLL		ED_BASE+566L
#define	ED_TRANSBASIC_EDIT_DELAY	ED_BASE+567L
#define	ED_TRANSBASIC_PLAYTC_DELAY	ED_BASE+568L
#define	ED_TRANSBASIC_RECTC_DELAY	ED_BASE+569L
#define ED_TRANSBASIC_EDIT_FIELD	ED_BASE+570L
#define	ED_TRANSBASIC_FRAME_SERVO	ED_BASE+571L
#define	ED_TRANSBASIC_CF_SERVO		ED_BASE+572L
#define	ED_TRANSBASIC_SERVO_REF		ED_BASE+573L	// can be one of the following:
#define	ED_REF_EXTERNAL				ED_BASE+574L
#define	ED_REF_INPUT				ED_BASE+575L
#define	ED_REF_INTERNAL				ED_BASE+576L
#define	ED_REF_AUTO					ED_BASE+577L

#define	ED_TRANSBASIC_WARN_GL		ED_BASE+578L
#define	ED_TRANSBASIC_SET_TRACKING	ED_BASE+579L	// can be one of the following:
#define	ED_TRACKING_PLUS			ED_BASE+580L
#define	ED_TRACKING_MINUS			ED_BASE+581L
#define	ED_TRACKING_RESET			ED_BASE+582L

#define	ED_TRANSBASIC_SET_FREEZE_TIMEOUT	ED_BASE+583L
#define	ED_TRANSBASIC_VOLUME_NAME		ED_BASE+584L
#define	ED_TRANSBASIC_BALLISTIC_1		ED_BASE+585L	// space for proprietary data
#define	ED_TRANSBASIC_BALLISTIC_2		ED_BASE+586L
#define	ED_TRANSBASIC_BALLISTIC_3		ED_BASE+587L
#define	ED_TRANSBASIC_BALLISTIC_4		ED_BASE+588L
#define	ED_TRANSBASIC_BALLISTIC_5		ED_BASE+589L
#define	ED_TRANSBASIC_BALLISTIC_6		ED_BASE+590L
#define	ED_TRANSBASIC_BALLISTIC_7		ED_BASE+591L
#define	ED_TRANSBASIC_BALLISTIC_8		ED_BASE+592L
#define	ED_TRANSBASIC_BALLISTIC_9		ED_BASE+593L
#define	ED_TRANSBASIC_BALLISTIC_10		ED_BASE+594L
#define	ED_TRANSBASIC_BALLISTIC_11		ED_BASE+595L
#define	ED_TRANSBASIC_BALLISTIC_12		ED_BASE+596L
#define	ED_TRANSBASIC_BALLISTIC_13		ED_BASE+597L
#define	ED_TRANSBASIC_BALLISTIC_14		ED_BASE+598L
#define	ED_TRANSBASIC_BALLISTIC_15		ED_BASE+599L
#define	ED_TRANSBASIC_BALLISTIC_16		ED_BASE+600L
#define	ED_TRANSBASIC_BALLISTIC_17		ED_BASE+601L
#define	ED_TRANSBASIC_BALLISTIC_18		ED_BASE+602L
#define	ED_TRANSBASIC_BALLISTIC_19		ED_BASE+603L
#define	ED_TRANSBASIC_BALLISTIC_20		ED_BASE+604L

// consumer VCR items
#define	ED_TRANSBASIC_SETCLOCK			ED_BASE+605L
#define	ED_TRANSBASIC_SET_COUNTER_FORMAT	ED_BASE+606L	// uses time format flags
#define	ED_TRANSBASIC_SET_COUNTER_VALUE	ED_BASE+607L

#define	ED_TRANSBASIC_SETTUNER_CH_UP	ED_BASE+608L
#define	ED_TRANSBASIC_SETTUNER_CH_DN	ED_BASE+609L
#define	ED_TRANSBASIC_SETTUNER_SK_UP	ED_BASE+610L
#define	ED_TRANSBASIC_SETTUNER_SK_DN	ED_BASE+611L
#define	ED_TRANSBASIC_SETTUNER_CH		ED_BASE+612L
#define	ED_TRANSBASIC_SETTUNER_NUM		ED_BASE+613L

#define	ED_TRANSBASIC_SETTIMER_EVENT	ED_BASE+614L
#define	ED_TRANSBASIC_SETTIMER_STARTDAY	ED_BASE+615L
#define	ED_TRANSBASIC_SETTIMER_STARTTIME	ED_BASE+616L
#define	ED_TRANSBASIC_SETTIMER_STOPDAY	ED_BASE+617L
#define	ED_TRANSBASIC_SETTIMER_STOPTIME	ED_BASE+618L

// IAMExtTransport video parameters
#define	ED_TRANSVIDEO_SET_OUTPUT	ED_BASE+630L	// can be one of the following:
#define	ED_E2E						ED_BASE+631L
#define	ED_PLAYBACK					ED_BASE+632L
#define	ED_OFF						ED_BASE+633L

#define	ED_TRANSVIDEO_SET_SOURCE	ED_BASE+634L

// IAMExtTransport audio parameters
#define	ED_TRANSAUDIO_ENABLE_OUTPUT	ED_BASE+640L	// can be the following:
#define	ED_AUDIO_ALL				0x10000000	//	or any of the following OR'd together
#define ED_AUDIO_1					0x0000001L
#define ED_AUDIO_2					0x0000002L
#define ED_AUDIO_3					0x0000004L
#define ED_AUDIO_4					0x0000008L
#define ED_AUDIO_5					0x0000010L
#define ED_AUDIO_6					0x0000020L
#define ED_AUDIO_7					0x0000040L
#define ED_AUDIO_8					0x0000080L
#define ED_AUDIO_9					0x0000100L
#define ED_AUDIO_10					0x0000200L
#define ED_AUDIO_11					0x0000400L
#define ED_AUDIO_12					0x0000800L
#define ED_AUDIO_13					0x0001000L
#define ED_AUDIO_14					0x0002000L
#define ED_AUDIO_15					0x0004000L
#define ED_AUDIO_16					0x0008000L
#define ED_AUDIO_17					0x0010000L
#define ED_AUDIO_18					0x0020000L
#define ED_AUDIO_19					0x0040000L
#define ED_AUDIO_20					0x0080000L
#define ED_AUDIO_21					0x0100000L
#define ED_AUDIO_22					0x0200000L
#define ED_AUDIO_23					0x0400000L
#define ED_AUDIO_24					0x0800000L
#define ED_VIDEO					0x2000000L	// for Edit props below

#define	ED_TRANSAUDIO_ENABLE_RECORD		ED_BASE+642L
#define	ED_TRANSAUDIO_ENABLE_SELSYNC	ED_BASE+643L
#define	ED_TRANSAUDIO_SET_SOURCE		ED_BASE+644L
#define	ED_TRANSAUDIO_SET_MONITOR		ED_BASE+645L


// Edit Property Set-related defs

// The following values reflect (and control) the state of an 
// edit property set
#define ED_INVALID		ED_BASE+652L
#define ED_EXECUTING	ED_BASE+653L
#define ED_REGISTER		ED_BASE+654L
#define ED_DELETE		ED_BASE+655L

// Edit property set parameters and values
#define ED_EDIT_HEVENT	ED_BASE+656L	// event handle to signal event 
										// completion
#define ED_EDIT_TEST	ED_BASE+657L	// returns OAFALSE if filter thinks
										//  edit can be done, OATRUE if not
#define ED_EDIT_IMMEDIATE	ED_BASE+658L	// OATRUE means start put the 
										// device into edit mode (editing
										// "on the fly") immediately upon
										//  execution of Mode(ED_MODE_EDIT_CUE)
#define ED_EDIT_MODE	ED_BASE+659L
// can be one of the following values:
#define ED_EDIT_MODE_ASSEMBLE		ED_BASE+660L
#define ED_EDIT_MODE_INSERT			ED_BASE+661L
#define ED_EDIT_MODE_CRASH_RECORD	ED_BASE+662L
#define ED_EDIT_MODE_BOOKMARK_TIME	ED_BASE+663L		// these two are for
#define ED_EDIT_MODE_BOOKMARK_CHAPTER	ED_BASE+664L	// laserdisks

#define ED_EDIT_MASTER	ED_BASE+666L	// OATRUE causes device 
										//  not to synchronize

#define ED_EDIT_TRACK		ED_BASE+667L
// can be one of the following possible OR'd values:
//	ED_VIDEO, ED_AUDIO_1 thru ED_AUDIO_24 (or ED_AUDIO_ALL)

#define ED_EDIT_SRC_INPOINT		ED_BASE+668L	// in current time format
#define ED_EDIT_SRC_OUTPOINT	ED_BASE+669L	// in current time format
#define ED_EDIT_REC_INPOINT		ED_BASE+670L	// in current time format
#define ED_EDIT_REC_OUTPOINT	ED_BASE+671L	// in current time format

#define ED_EDIT_REHEARSE_MODE	ED_BASE+672L
// can be one of the following possible values:
#define ED_EDIT_BVB		ED_BASE+673L	// means rehearse the edit with 
										//  "black-video-black"
#define ED_EDIT_VBV		ED_BASE+674L
#define ED_EDIT_VVV		ED_BASE+675L
#define ED_EDIT_PERFORM	ED_BASE+676L	// means perform the edit with no 
										//  rehearsal.

// Set this property to OATRUE to kill the edit if in progress
#define ED_EDIT_ABORT	ED_BASE+677L
// how long to wait for edit to complete
#define ED_EDIT_TIMEOUT	ED_BASE+678L		// in current time format

// This property causes the device to seek to a point specified by
// ED_EDIT_SEEK_MODE (see below).  NOTE: Only one event at a time can seek.
#define ED_EDIT_SEEK		ED_BASE+679L	// OATRUE means do it now.  
#define ED_EDIT_SEEK_MODE	ED_BASE+680L
//possible values:
#define ED_EDIT_SEEK_EDIT_IN	ED_BASE+681L	// seek to edit's inpoint
#define ED_EDIT_SEEK_EDIT_OUT	ED_BASE+682L	// seek to edit's outpoint
#define ED_EDIT_SEEK_PREROLL	ED_BASE+683L	// seek to edit's 
												//  inpoint-preroll
#define ED_EDIT_SEEK_PREROLL_CT	ED_BASE+684L	// seek to preroll point 
							// using control track (used for tapes with 
							// discontinuoustimecode before edit point: seek
							// to inpoint using timecode, then backup to 
							// preroll point using control track)
#define ED_EDIT_SEEK_BOOKMARK	ED_BASE+685L	// seek to bookmark (just like 
												//  timecode search)
// This property is used for multiple-VCR systems where each machine must
//  cue to a different location relative to the graph's reference clock.  The
//  basic idea is that an edit event is setup with an ED_EDIT_OFFSET property
//  that tells the VCR what offset to maintain between it's timecode (converted
//	to reference clock units) and the reference clock.
#define ED_EDIT_OFFSET	ED_BASE+686L		// in current time format

#define ED_EDIT_PREREAD	ED_BASE+815L		// OATRUE means device supports
											//  pre-read (recorder can also be
											//  player

//
// Some error codes:
// 
// device could be in local mode
#define ED_ERR_DEVICE_NOT_READY		ED_BASE+700L

#endif // __EDEVDEFS__

// eof edevdefs.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\ehstorextensions.h ===
/*++

Copyright (c) 2008 Microsoft Corporation

Module Name:

    EhStorExtensions.h

Abstract:

    This module defines the Enhanced Storage WPD interfaces for silo drivers.

Environment:

    User mode only.

--*/

#pragma once
#include <windows.h>
#include <propkey.h>

// ---------------------------------------------------------------------------
// 
// This section defines the device interfaces for Enhanced Storage devices.
// 
// ---------------------------------------------------------------------------
 
//
// {3897F6A4-FD35-4bc8-A0B7-5DBBA36ADAFA}
// 

DEFINE_GUID(
    GUID_DEVINTERFACE_ENHANCED_STORAGE_SILO, 
    0x3897f6a4, 0xfd35, 0x4bc8, 0xa0, 0xb7, 0x5d, 0xbb, 0xa3, 0x6a, 0xda, 0xfa);


// ---------------------------------------------------------------------------
// 
// This section defines all Commands, Parameters and Options essociated with: 
// WPD_CATEGORY_ENHANCED_STORAGE 
// 
// This category is for commands and parameters for storage functional objects.
// 
// ---------------------------------------------------------------------------

DEFINE_GUID(
    WPD_CATEGORY_ENHANCED_STORAGE,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c);


// ---------------------------------------------------------------------------
//
// Authentication specific commands
//
// ---------------------------------------------------------------------------

// 
// ENHANCED_STORAGE_COMMAND_SILO_IS_AUTHENTICATION_SILO
//     This command will return whether or not the silo is an authentication silo.
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//      None.
//  Results: 
//      WPD_PROPERTY_COMMON_HRESULT - The last status code for Authentication or UnAuthentication
//      ENHANCED_STORAGE_PROPERTY_IS_AUTHENTICATION_SILO [VT_BOOLEAN] - TRUE if an Auth-C silo, FALSE otherwise
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_COMMAND_SILO_IS_AUTHENTICATION_SILO,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    6);


// 
// ENHANCED_STORAGE_COMMAND_SILO_GET_AUTHENTICATION_STATE
//     This command will return the authentication state for the silo.
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     None.
//  Results: 
//      WPD_PROPERTY_COMMON_HRESULT - The last status code for Authentication or UnAuthentication
//      ENHANCED_STORAGE_PROPERTY_AUTHENTICATION_STATE [VT_UI4]
//

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_COMMAND_SILO_GET_AUTHENTICATION_STATE,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    7);

//
// ENHANCED_STORAGE_COMMAND_SILO_START_AUTHENTICATION
//     This command will begin authentication for the silo.
//      An application needs to register for callbacks to get authorization
//      state change notification
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     None.
//  Results: 
//     WPD_PROPERTY_COMMON_HRESULT
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_COMMAND_SILO_START_AUTHENTICATION,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    9);

//
// ENHANCED_STORAGE_COMMAND_SILO_START_UNAUTHENTICATION
//     This command will begin unauthentication for the silo.
//      An application needs to register for callbacks to get authorization
//      state change notification
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     None.
//  Results: 
//     WPD_PROPERTY_COMMON_HRESULT
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_COMMAND_SILO_START_UNAUTHENTICATION,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    10);

//
// ENHANCED_STORAGE_COMMAND_SILO_ENUMERATE_SILOS
//     This command will enumerate the silo information for the specified silo type
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//      [ Required ] ENHANCED_STORAGE_PROPERTY_QUERY_SILO_TYPE
//  Results: 
//     WPD_PROPERTY_COMMON_HRESULT
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_COMMAND_SILO_ENUMERATE_SILOS,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    11);

// ---------------------------------------------------------------------------
//
// Certificate specific commands
//
// ---------------------------------------------------------------------------


//
// ENHANCED_STORAGE_COMMAND_CERT_HOST_CERTIFICATE_AUTHENTICATION
//      This command will attempt to do a host authentication based on an HCh
//      (or XCh) from the device. If an index or certificate is specified, it
//      will use that certificate.
//      The default behavior is to authenticate any of the HCh certs present on
//      the device if possible (or XCh.)
//  Access: 
//      (FILE_READ_ACCESS) 
//  Parameters: 
//      [ Optional ] ENHANCED_STORAGE_PROPERTY_CERTIFICATE_INDEX [VT_UINT]
//      [ Optional ] ENHANCED_STORAGE_PROPERTY_CERTIFICATE [VT_VECTOR | VT_UI1]
//  Results: 
//      WPD_PROPERTY_COMMON_HRESULT
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_COMMAND_CERT_HOST_CERTIFICATE_AUTHENTICATION,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    101);

//
// DEVICE_AUTHENTICATION
// ENHANCED_STORAGE_COMMAND_CERT_DEVICE_CERTIFICATE_AUTHENTICATION
//      This command will attempt to do a device authentication operation. If
//      an index or certificate is specified, it will use that certificate. It
//      must be ASCm or ASCh.
//      The default behavior is to authenticate ASCm.
//  Access: 
//      (FILE_READ_ACCESS) 
//  Parameters: 
//      [ Optional ] ENHANCED_STORAGE_PROPERTY_CERTIFICATE_INDEX [VT_UINT]
//      [ Optional ] ENHANCED_STORAGE_PROPERTY_CERTIFICATE [VT_VECTOR | VT_UI1]
//  Results: 
//      WPD_PROPERTY_COMMON_HRESULT
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_COMMAND_CERT_DEVICE_CERTIFICATE_AUTHENTICATION,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    102);

//
// ENHANCED_STORAGE_COMMAND_CERT_ADMIN_CERTIFICATE_AUTHENTICATION
//      This command will attempt to do an admin authentication based on the PCp
//      (or XCp) from the device.
//      This is an admin command - it requires both read and write access.
//  Access: 
//      (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//      None
//  Results: 
//      WPD_PROPERTY_COMMON_HRESULT
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_COMMAND_CERT_ADMIN_CERTIFICATE_AUTHENTICATION,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    103);

//
// ENHANCED_STORAGE_COMMAND_CERT_INITIALIZE_TO_MANUFACTURER_STATE
//      This command will attempt to initialized to the manufacturer state.
//      Requires PCp authentication.
//  Access: 
//      (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//      None.
//  Results: 
//      WPD_PROPERTY_COMMON_HRESULT
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_COMMAND_CERT_INITIALIZE_TO_MANUFACTURER_STATE,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    104);

//
// ENHANCED_STORAGE_COMMAND_CERT_GET_CERTIFICATE_COUNT
//      This command will get the number of certificate slots on the device.
//  Access: 
//      (FILE_READ_ACCESS) 
//  Parameters: 
//      none.
//  Results: 
//      WPD_PROPERTY_COMMON_HRESULT
//      ENHANCED_STORAGE_PROPERTY_MAX_CERTIFICATE_COUNT [VT_UINT]
//      ENHANCED_STORAGE_PROPERTY_STORED_CERTIFICATE_COUNT [VT_UINT]
//

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_COMMAND_CERT_GET_CERTIFICATE_COUNT,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    105);

//
// ENHANCED_STORAGE_COMMAND_CERT_GET_CERTIFICATE
//      This command will return the certificate at the certificate index location.
//      Index 0 is a special location that returns the ASCm chain in PKCS7 format.
//  Access: 
//      (FILE_READ_ACCESS) 
//  Parameters: 
//      [ Required ] ENHANCED_STORAGE_PROPERTY_CERTIFICATE_INDEX [VT_UINT]
//  Results: 
//      WPD_PROPERTY_COMMON_HRESULT
//      ENHANCED_STORAGE_PROPERTY_CERTIFICATE_TYPE [VT_UINT]
//      ENHANCED_STORAGE_PROPERTY_VALIDATION_POLICY [VT_UINT]
//      ENHANCED_STORAGE_PROPERTY_SIGNER_CERTIFICATE_INDEX [VT_UINT]
//      ENHANCED_STORAGE_PROPERTY_NEXT_CERTIFICATE_INDEX [VT_UINT]
//      ENHANCED_STORAGE_PROPERTY_NEXT_CERTIFICATE_OF_TYPE_INDEX [VT_UINT]
//      ENHANCED_STORAGE_PROPERTY_CERTIFICATE_LENGTH [VT_UINT]
//      ENHANCED_STORAGE_PROPERTY_CERTIFICATE [VT_VECTOR | VT_UI1]

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_COMMAND_CERT_GET_CERTIFICATE,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    106);

//
// ENHANCED_STORAGE_COMMAND_CERT_SET_CERTIFICATE
//      This command will set a certificate to the certificate index location.
//      Requires admin authentication.
//  Access: 
//      (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//      [ Required ] ENHANCED_STORAGE_PROPERTY_CERTIFICATE_INDEX [VT_UINT]
//      [ Required ] ENHANCED_STORAGE_PROPERTY_CERTIFICATE_TYPE [VT_UINT]
//      [ Required ] ENHANCED_STORAGE_PROPERTY_VALIDATION_POLICY [VT_UINT]
//      [ Required ] ENHANCED_STORAGE_PROPERTY_SIGNER_CERTIFICATE_INDEX [VT_UINT]
//      [ Required ] ENHANCED_STORAGE_PROPERTY_CERTIFICATE [VT_VECTOR | VT_UI1]
//  Results: 
//      WPD_PROPERTY_COMMON_HRESULT
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_COMMAND_CERT_SET_CERTIFICATE,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    107);

//
// ENHANCED_STORAGE_COMMAND_CERT_CREATE_CERTIFICATE_REQUEST
//      This command will esk the device to create a certificate request. 
//      This will then be signed by the application's chosen CA.
//  Access: 
//      (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//      None.
//  Results:
//      WPD_PROPERTY_COMMON_HRESULT
//      ENHANCED_STORAGE_PROPERTY_CERTIFICATE_REQUEST [VT_VECTOR | VT_UI1]
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_COMMAND_CERT_CREATE_CERTIFICATE_REQUEST,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    108);

//
// ENHANCED_STORAGE_COMMAND_CERT_UNAUTHENTICATION
//      This command will issue a command to set the cert silo to the
//      initialized state.
//  Access: 
//      (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//      None
//  Results: 
//      WPD_PROPERTY_COMMON_HRESULT
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_COMMAND_CERT_UNAUTHENTICATION,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    110);

//
// ENHANCED_STORAGE_COMMAND_CERT_GET_SILO_CAPABILITY
//      This command will issue a command to get a silo capability from the
//      silo. Data returned is in the format returned from the silo.
//  Access: 
//      (FILE_READ_ACCESS) 
//  Parameters: 
//      [ Required ] ENHANCED_STORAGE_PROPERTY_CERTIFICATE_CAPABILITY_TYPE [VT_UINT]
//  Results: 
//      WPD_PROPERTY_COMMON_HRESULT
//      ENHANCED_STORAGE_PROPERTY_CERTIFICATE_SILO_CAPABILITY [VT_VECTOR | VT_UI1]
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_COMMAND_CERT_GET_SILO_CAPABILITY,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    111);

//
// ENHANCED_STORAGE_COMMAND_CERT_GET_SILO_CAPABILITIES
//      This command will return the silo capabilities as a collection of
//      capabilities.
//  Access: 
//      (FILE_READ_ACCESS) 
//  Parameters: 
//      None.
//  Results: 
//      WPD_PROPERTY_COMMON_HRESULT
//      ENHANCED_STORAGE_PROPERTY_CERTIFICATE_SILO_CAPABILITIES [VT_UNKNOWN]
//      - ENHANCED_STORAGE_CAPABILITY_HASH_ALGS [VT_LPWSTR - semi-colon delimited] 
//      - ENHANCED_STORAGE_CAPABILITY_ASYMMETRIC_KEY_CRYPTOGRAPHY [VT_LPWSTR - semi-colon delimited]
//      - ENHANCED_STORAGE_CAPABILITY_SIGNING_ALGS [VT_LPWSTR - semi-colon delimited]
//      - ENHANCED_STORAGE_CAPABILITY_RENDER_USER_DATA_UNUSABLE [ VT_BOOL ]
//      - ENHANCED_STORAGE_CAPABILITY_CERTIFICATE_EXTENSION_PARSING [ VT_BOOL ]
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_COMMAND_CERT_GET_SILO_CAPABILITIES,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    112);

//
// ENHANCED_STORAGE_COMMAND_CERT_GET_ACT_FRIENDLY_NAME
//      This command will return the friendly name of the ACT containing the silo.
//  Access: 
//      (FILE_READ_ACCESS) 
//  Parameters: 
//      None.
//  Results: 
//      WPD_PROPERTY_COMMON_HRESULT
//      [optional] ENHANCED_STORAGE_PROPERTY_CERTIFICATE_ACT_FRIENDLY_NAME [VT_LPWSTR]
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_COMMAND_CERT_GET_ACT_FRIENDLY_NAME,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    113);

//
// ENHANCED_STORAGE_COMMAND_CERT_GET_SILO_GUID
//      This command will return the silo's GUID.
//  Access: 
//      (FILE_READ_ACCESS) 
//  Parameters: 
//      None.
//  Results: 
//      WPD_PROPERTY_COMMON_HRESULT
//      ENHANCED_STORAGE_PROPERTY_CERTIFICATE_SILO_GUID [VT_LPWSTR]
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_COMMAND_CERT_GET_SILO_GUID,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    114);


// ---------------------------------------------------------------------------
//
// Password specific commands
//
// ---------------------------------------------------------------------------


//
// ENHANCED_STORAGE_COMMAND_PASSWORD_AUTHORIZE_ACT_ACCESS
//     This command attempts to authenticate to the silo for ACT's data access
//  Access:  
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] ENHANCED_STORAGE_PROPERTY_PASSWORD
//     [ Required ] ENHANCED_STORAGE_PROPERTY_PASSWORD_INDICATOR
//  Results: 
//      WPD_PROPERTY_COMMON_HRESULT - status code for the operation
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_COMMAND_PASSWORD_AUTHORIZE_ACT_ACCESS,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    203);

//
// ENHANCED_STORAGE_COMMAND_PASSWORD_UNAUTHORIZE_ACT_ACCESS
//     This command attempts to un-authenticate to the silo for ACT's data
//     access.
//  Access:  
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Optional ] ENHANCED_STORAGE_PROPERTY_PASSWORD
//     [ Optional ] ENHANCED_STORAGE_PROPERTY_PASSWORD_INDICATOR
//  Results: 
//      WPD_PROPERTY_COMMON_HRESULT - status code for the operation
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_COMMAND_PASSWORD_UNAUTHORIZE_ACT_ACCESS,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    204);

//
// ENHANCED_STORAGE_COMMAND_PASSWORD_QUERY_INFORMATION
//     This command queries the current password silo information
//  Access: 
//     (FILE_READ_ACCESS) 
//  Parameters: 
//      none
//  Results:
//      ENHANCED_STORAGE_PROPERTY_AUTHENTICATION_STATE
//      ENHANCED_STORAGE_PROPERTY_PASSWORD_SILO_INFO
//      ENHANCED_STORAGE_PROPERTY_ADMIN_HINT
//      ENHANCED_STORAGE_PROPERTY_USER_HINT
//      ENHANCED_STORAGE_PROPERTY_USER_NAME
//      WPD_PROPERTY_COMMON_HRESULT - status code for the operation
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_COMMAND_PASSWORD_QUERY_INFORMATION,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    205);

//
// ENHANCED_STORAGE_COMMAND_PASSWORD_CONFIG_ADMINISTRATOR
//     This command configures the administrator account
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Optional ] ENHANCED_STORAGE_PROPERTY_MAX_AUTH_FAILURES
//     [ Optional ] ENHANCED_STORAGE_PROPERTY_AUTH_REQUIRED_FOR_INITIALIZE
//  Results: 
//      WPD_PROPERTY_COMMON_HRESULT - status code for the operation
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_COMMAND_PASSWORD_CONFIG_ADMINISTRATOR,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    206);

//
// ENHANCED_STORAGE_COMMAND_PASSWORD_CREATE_USER
//     This command creates a user account
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] ENHANCED_STORAGE_PROPERTY_PASSWORD
//     [ Required ] ENHANCED_STORAGE_PROPERTY_NEW_PASSWORD
//     [ Required ] ENHANCED_STORAGE_PROPERTY_USER_HINT
//     [ Required ] ENHANCED_STORAGE_PROPERTY_USER_NAME 
//     [ Optional ] ENHANCED_STORAGE_PROPERTY_MAX_AUTH_FAILURES
//  Results: 
//      WPD_PROPERTY_COMMON_HRESULT - status code for the operation
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_COMMAND_PASSWORD_CREATE_USER,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    207);

//
// ENHANCED_STORAGE_COMMAND_PASSWORD_DELETE_USER
//     This command deletes the existing user account
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//      none
//  Results: 
//      WPD_PROPERTY_COMMON_HRESULT - status code for the operation
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_COMMAND_PASSWORD_DELETE_USER,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    208);


//
// ENHANCED_STORAGE_COMMAND_PASSWORD_CHANGE_PASSWORD
//     This command changes the password for adminstritor or user account
//  Access:
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] ENHANCED_STORAGE_PROPERTY_PASSWORD_INDICATOR
//     [ Required ] ENHANCED_STORAGE_PROPERTY_PASSWORD
//     [ Required ] ENHANCED_STORAGE_PROPERTY_NEW_PASSWORD
//     [ Required ] ENHANCED_STORAGE_PROPERTY_NEW_HINT
//     [ Required ] ENHANCED_STORAGE_PROPERTY_NEW_PASSWORD_INDICATOR 
//     [ Optional ] ENHANCED_STORAGE_PROPERTY_SECURITY_IDENTIFIER 
//  Results: 
//      WPD_PROPERTY_COMMON_HRESULT - status code for the operation
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_COMMAND_PASSWORD_CHANGE_PASSWORD,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    209);

//
// ENHANCED_STORAGE_COMMAND_PASSWORD_INITIALIZE_USER_PASSWORD
//     This command initializes the existing user password 
//  Access:
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] ENHANCED_STORAGE_PROPERTY_PASSWORD
//     [ Required ] ENHANCED_STORAGE_PROPERTY_NEW_PASSWORD
//     [ Required ] ENHANCED_STORAGE_PROPERTY_NEW_HINT
//  Results: 
//      WPD_PROPERTY_COMMON_HRESULT - status code for the operation
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_COMMAND_PASSWORD_INITIALIZE_USER_PASSWORD,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    210);

//
// ENHANCED_STORAGE_COMMAND_PASSWORD_START_INITIALIZE_TO_MANUFACTURER_STATE
//     This command starts the initialization process
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Optional ] ENHANCED_STORAGE_PROPERTY_SECURITY_IDENTIFIER 
//  Results: 
//      WPD_PROPERTY_COMMON_HRESULT - status code for the operation
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_COMMAND_PASSWORD_START_INITIALIZE_TO_MANUFACTURER_STATE,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    211);


// ---------------------------------------------------------------------------
//
// This section defines all WPD Enhanced Storage Properties
//
// ---------------------------------------------------------------------------

// 
// ENHANCED_STORAGE_PROPERTY_AUTHORIZATION_STATE
//   [ VT_UI4 ] Authorization status of the Enhanced Storage ACT.
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_AUTHORIZATION_STATE,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    1005);

// 
// ENHANCED_STORAGE_PROPERTY_AUTHENTICATION_STATE
//   [ VT_UI4 ] Authentication status of the Enhanced Storage Silo
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_AUTHENTICATION_STATE,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    1006);

// 
// ENHANCED_STORAGE_PROPERTY_DRIVER_STATE
//   [ VT_UI4 ] Current Operation for the ACT. 
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_ACT_DRIVER_STATE,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    1007);

// 
// ENHANCED_STORAGE_PROPERTY_IS_AUTHENTICATION_SILO
//   [ VT_BOOL ] Is this silo an authentication silo? 
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_IS_AUTHENTICATION_SILO,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    1009);

// 
// ENHANCED_STORAGE_PROPERTY_AUTHENTICATION_NEEDS_UI
//   [ VT_BOOL ] Is this silo an authentication silo? 
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_AUTHENTICATION_NEEDS_UI,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    1010);


// ---------------------------------------------------------------------------
//
// Password silo specific properties
//
// ---------------------------------------------------------------------------

// 
// ENHANCED_STORAGE_PROPERTY_MAX_AUTH_FAILURES
//   [ VT_UI4 ] Maximum number of password authentication failures
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_MAX_AUTH_FAILURES,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    2001);

// 
// ENHANCED_STORAGE_PROPERTY_PASSWORD
//   [ VT_BLOB ] The password to send or set
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_PASSWORD,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    2004);

// 
// ENHANCED_STORAGE_PROPERTY_OLD_PASSWORD
//   [ VT_BLOB ] The password used for changing password.
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_OLD_PASSWORD,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    2005);

//
// ENHANCED_STORAGE_PROPERTY_PASSWORD_INDICATOR
//   [ VT_BOOL ] TRUE: user, FALSE: admin
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_PASSWORD_INDICATOR,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    2006);

//
// ENHANCED_STORAGE_PROPERTY_NEW_PASSWORD_INDICATOR
//   [ VT_BOOL ] TRUE: user, FALSE: admin
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_NEW_PASSWORD_INDICATOR,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    2007);

// 
// ENHANCED_STORAGE_PROPERTY_NEW_PASSWORD
//   [ VT_BLOB ] The new password.  Used to re-set the password
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_NEW_PASSWORD,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    2008);

// 
// ENHANCED_STORAGE_PROPERTY_USER_HINT
//   [ VT_LPCSTR ] The user hint
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_USER_HINT,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    2009);

// 
// ENHANCED_STORAGE_PROPERTY_USER_NAME
//   [ VT_LPCSTR ] The friendly user name
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_USER_NAME,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    2010);

// 
// ENHANCED_STORAGE_PROPERTY_ADMIN_HINT
//   [ VT_LPCSTR ] The admin hint
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_ADMIN_HINT,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    2011);

// 
// ENHANCED_STORAGE_PROPERTY_SILO_NAME
//   [ VT_LPCSTR ] The friendly name for the silo
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_SILO_NAME,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c, 
    2012);

// 
// ENHANCED_STORAGE_PROPERTY_SILO_FRIENDLYNAME_SPECIFIED
//   [ VT_BOOL ] Flag to indicate if silo friendly name is given
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_SILO_FRIENDLYNAME_SPECIFIED,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    2013);

// 
// ENHANCED_STORAGE_PROPERTY_PASSWORD_SILO_INFO
//   [ VT_BLOB ] The password silo information
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_PASSWORD_SILO_INFO,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    2014);

// 
// ENHANCED_STORAGE_PROPERTY_SECURITY_IDENTIFIER
//   [ VT_BLOB ] Security Identifier for the password silo device
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_SECURITY_IDENTIFIER,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    2015);

// 
// ENHANCED_STORAGE_PROPERTY_QUERY_SILO_TYPE
//   [ VT_UINT ] Query Silo Type
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_QUERY_SILO_TYPE,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    2016);

// 
// ENHANCED_STORAGE_PROPERTY_QUERY_SILO_RESULTS
//   [ VT_BLOB ] Query Silo Properties result
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_QUERY_SILO_RESULTS,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    2017);

// 
// Data format used for the password silo information property
// 

typedef struct _ENHANCED_STORAGE_PASSWORD_SILO_INFORMATION {

    BYTE CurrentAdminFailures;
    BYTE CurrentUserFailures;
    DWORD TotalUserAuthenticationCount;
    DWORD TotalAdminAuthenticationCount;

    BOOL FipsCompliant;
    BOOL SecurityIDAvailable;
    BOOL InitializeInProgress;
    BOOL ITMSArmed;
    BOOL ITMSArmable;
    BOOL UserCreated;
    BOOL ResetOnPORDefault;
    BOOL ResetOnPORCurrent;
    
    BYTE MaxAdminFailures;
    BYTE MaxUserFailures;

    DWORD TimeToCompleteInitialization;
    DWORD TimeRemainingToCompleteInitialization;
    DWORD MinTimeToAuthenticate;

    //
    // Capabilities (never changed)
    // 

    BYTE MaxAdminPasswordSize;
    BYTE MinAdminPasswordSize;
    BYTE MaxAdminHintSize;
    BYTE MaxUserPasswordSize;
    BYTE MinUserPasswordSize;
    BYTE MaxUserHintSize;
    BYTE MaxUserNameSize;
    BYTE MaxSiloNameSize;
    WORD MaxChallengeSize;

} ENHANCED_STORAGE_PASSWORD_SILO_INFORMATION, *PENHANCED_STORAGE_PASSWORD_SILO_INFORMATION;

// ---------------------------------------------------------------------------
//
// Certificate silo specific properties.
//
// ---------------------------------------------------------------------------

//
// ENHANCED_STORAGE_PROPERTY_MAX_CERTIFICATE_COUNT
//   [ VT_UINT ] The number of certificate slots available on the device
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_MAX_CERTIFICATE_COUNT,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    3001);

//
// ENHANCED_STORAGE_PROPERTY_STORED_CERTIFICATE_COUNT
//   [ VT_UINT ] The number of certificate slots in use on the device
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_STORED_CERTIFICATE_COUNT,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    3002);

//
// ENHANCED_STORAGE_PROPERTY_CERTIFICATE_INDEX
//   [ VT_UINT ] The index for the certificate slot on the device
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_CERTIFICATE_INDEX,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    3003);

//
// ENHANCED_STORAGE_PROPERTY_CERTIFICATE_TYPE
//  [ VT_UINT ] The type of certificate
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_CERTIFICATE_TYPE,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    3004);

//
// Certificate Types defines
//
#define CERT_TYPE_EMPTY     0x00    // No certificate
#define CERT_TYPE_ASCm      0x01    // Manufacturer's certificate (ASCm)
#define CERT_TYPE_PCp       0x02    // Provisioning Certificate (PCp)
#define CERT_TYPE_ASCh      0x03    // Authentication Silo Certificate (ASCh)
#define CERT_TYPE_HCh       0x04    // Host certificate (HCh)
#define CERT_TYPE_SIGNER    0x06    // Signer certificate (SCh)

//
// ENHANCED_STORAGE_PROPERTY_VALIDATION_POLICY
//  [ VT_UINT ] The validation policy for the certificate
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_VALIDATION_POLICY,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    3005);

//
// Validation Policy values
// - None: the corresponding private key of the stored certificate shall be used
//         for authentication.
// - Basic: the certificate and certificate chain conforms to the basic validation
//         policy.
// - Extended: the certificate chain conforms to the extended validation policy.
//         The use of this validation policy must result in an error condition
//         of the Authentication Silo if it does not support parsing of certificate
//         extensions.
//
#define CERT_VALIDATION_POLICY_RESERVED             0x00
#define CERT_VALIDATION_POLICY_NONE                 0x01
#define CERT_VALIDATION_POLICY_BASIC                0x02
#define CERT_VALIDATION_POLICY_EXTENDED             0x03

//
// ENHANCED_STORAGE_PROPERTY_NEXT_CERTIFICATE_INDEX
//  [ VT_UINT ] The index of the next valid cert
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_NEXT_CERTIFICATE_INDEX,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    3006);

//
// ENHANCED_STORAGE_PROPERTY_NEXT_CERTIFICATE_OF_TYPE_INDEX
//  [ VT_UINT ] The index of the next valid cert of same type
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_NEXT_CERTIFICATE_OF_TYPE_INDEX,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    3007);

//
// ENHANCED_STORAGE_PROPERTY_CERTIFICATE_LENGTH
//  [ VT_UINT ] Length of the certificate in bytes
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_CERTIFICATE_LENGTH,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    3008);

//
// ENHANCED_STORAGE_PROPERTY_CERTIFICATE
//   [ VT_VECTOR | VT_UI1 ] The certificate buffer in X.509 format
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_CERTIFICATE,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    3009);

//
// ENHANCED_STORAGE_PROPERTY_CERTIFICATE_REQUEST
//   [ VT_VECTOR | VT_UI1 ] The certificate request buffer
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_CERTIFICATE_REQUEST,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    3010);

//
// ENHANCED_STORAGE_PROPERTY_CERTIFICATE_CAPABILITY_TYPE
//  [ VT_UINT ] Silo capability type
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_CERTIFICATE_CAPABILITY_TYPE,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    3011);

//
// ENHANCED_STORAGE_PROPERTY_CERTIFICATE_SILO_CAPABILITY
//  [ VT_VECTOR | VT_UINT ] The "raw" capability data return from the silo
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_CERTIFICATE_SILO_CAPABILITY,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    3012);

//
// ENHANCED_STORAGE_PROPERTY_CERTIFICATE_SILO_CAPABILITIES
//  [ VT_UNKNOWN ] The certificate silo capabilities returned in a collection
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_CERTIFICATE_SILO_CAPABILITIES,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    3013);

//
// Cert Silo Capability Types
// 
#define CERT_CAPABILITY_HASH_ALG                    0x1
#define CERT_CAPABILITY_ASYMMETRIC_KEY_CRYPTOGRAPHY 0x2
#define CERT_CAPABILITY_SIGNATURE_ALG               0x3
#define CERT_CAPABILITY_CERTIFICATE_SUPPORT         0x4
#define CERT_CAPABILITY_OPTIONAL_FEATURES           0x5
#define CERT_MAX_CAPABILITY                         0xFF    // Maximum capability value

//
// Supported identifiers defined in 1667 spec
//
#define CERT_RSA_1024_OID "1.2.840.113549.1.1.1,1024"
#define CERT_RSA_2048_OID "1.2.840.113549.1.1.1,2048"
#define CERT_RSA_3072_OID "1.2.840.113549.1.1.1,3072"
#define CERT_RSASSA_PSS_SHA1_OID "1.2.840.113549.1.1.10,1.3.14.3.2.26"
#define CERT_RSASSA_PSS_SHA256_OID "1.2.840.113549.1.1.10,2.16.840.1.101.3.4.2.1"
#define CERT_RSASSA_PSS_SHA384_OID "1.2.840.113549.1.1.10,2.16.840.1.101.3.4.2.2"
#define CERT_RSASSA_PSS_SHA512_OID "1.2.840.113549.1.1.10,2.16.840.1.101.3.4.2.3"

//
// ENHANCED_STORAGE_PROPERTY_CERTIFICATE_ACT_FRIENDLY_NAME
//  [ VT_LPWSTR ] The certificate silo's ACT friendly name
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_CERTIFICATE_ACT_FRIENDLY_NAME,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    3014);

//
// ENHANCED_STORAGE_PROPERTY_CERTIFICATE_SILO_GUID
//  [ VT_LPWSTR ] The certificate silo GUID
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_CERTIFICATE_SILO_GUID,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    3015);

//
// ENHANCED_STORAGE_PROPERTY_SIGNER CERTIFICATE_INDEX
//   [ VT_UINT ] The index for the signer certificate slot on the device
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_PROPERTY_SIGNER_CERTIFICATE_INDEX,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    3016);


// ---------------------------------------------------------------------------
//
// Silo capability specific properties.
//
// ---------------------------------------------------------------------------


//
// ENHANCED_STORAGE_CAPABILITY_HASH_ALGS
//  [VT_LPWSTR] Semi-colon delimited string of hash algorithm identifiers
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_CAPABILITY_HASH_ALGS,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    4001);

//
// ENHANCED_STORAGE_CAPABILITY_ASYMMETRIC_KEY_CRYPTOGRAPHY
//  [VT_LPWSTR] Semi-colon delimited string of asymmetric key cryptography supported
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_CAPABILITY_ASYMMETRIC_KEY_CRYPTOGRAPHY,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    4002);

//
// ENHANCED_STORAGE_CAPABILITY_SIGNING_ALGS
//  [VT_LPWSTR] Semi-colon delimited string of signing algorithm identifiers
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_CAPABILITY_SIGNING_ALGS,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    4003);

//
// ENHANCED_STORAGE_CAPABILITY_RENDER_USER_DATA_UNUSABLE
//  [ VT_BOOL ] Boolean indicating whether silo can render user data unusable
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_CAPABILITY_RENDER_USER_DATA_UNUSABLE,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    4004);

//
// ENHANCED_STORAGE_CAPABILITY_CERTIFICATE_EXTENSION_PARSING
//  [ VT_BOOL ] Boolean indicating whether certificate extension fields are supported
// 

DEFINE_PROPERTYKEY(
    ENHANCED_STORAGE_CAPABILITY_CERTIFICATE_EXTENSION_PARSING,
    0x91248166, 0xb832, 0x4ad4, 0xba, 0xa4, 0x7c, 0xa0, 0xb6, 0xb2, 0x79, 0x8c,
    4005);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\effects.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for effectspri.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __effectspri_h__
#define __effectspri_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWMPEffects_FWD_DEFINED__
#define __IWMPEffects_FWD_DEFINED__
typedef interface IWMPEffects IWMPEffects;
#endif 	/* __IWMPEffects_FWD_DEFINED__ */


#ifndef __IWMPEffects2_FWD_DEFINED__
#define __IWMPEffects2_FWD_DEFINED__
typedef interface IWMPEffects2 IWMPEffects2;
#endif 	/* __IWMPEffects2_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "wmp.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_effectspri_0000_0000 */
/* [local] */ 

//=========================================================================
//
// Microsoft Windows Media Technologies
// Copyright (C) Microsoft Corporation. All rights reserved.
//
//=========================================================================
#define	EFFECT_CANGOFULLSCREEN	( 0x1 )

#define	EFFECT_HASPROPERTYPAGE	( 0x2 )

#define	EFFECT_VARIABLEFREQSTEP	( 0x4 )

#define	EFFECT_WINDOWEDONLY	( 0x8 )

#define	EFFECT2_FULLSCREENEXCLUSIVE	( 0x10 )

#define	SA_BUFFER_SIZE	( 1024 )


enum PlayerState
    {	stop_state	= 0,
	pause_state	= 1,
	play_state	= 2
    } ;

//**********************************************************************
// Define the minimum and maximum frequency ranges returned in our
// TimedLevel frequency array (i.e. first index in TimedLevel.frequency
// is at 20Hz and last is at 22050Hz).
//**********************************************************************
static const float kfltTimedLevelMaximumFrequency = 22050.0F;
static const float kfltTimedLevelMinimumFrequency = 20.0F;

/*
 * FREQUENCY_INDEX() returns the index into TimedLevel.frequency[] where 
 * the specified frequency is located in the power spectrum
 */
#define FREQUENCY_INDEX(FREQ)\
  (int)(((FREQ) - kfltTimedLevelMinimumFrequency) /\
    (((kfltTimedLevelMaximumFrequency - kfltTimedLevelMinimumFrequency) / SA_BUFFER_SIZE)))

typedef struct tagTimedLevel
    {
    unsigned char frequency[ 2 ][ 1024 ];
    unsigned char waveform[ 2 ][ 1024 ];
    int state;
    hyper timeStamp;
    } 	TimedLevel;



extern RPC_IF_HANDLE __MIDL_itf_effectspri_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_effectspri_0000_0000_v0_0_s_ifspec;

#ifndef __IWMPEffects_INTERFACE_DEFINED__
#define __IWMPEffects_INTERFACE_DEFINED__

/* interface IWMPEffects */
/* [oleautomation][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMPEffects;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D3984C13-C3CB-48e2-8BE5-5168340B4F35")
    IWMPEffects : public IUnknown
    {
    public:
        virtual /* [helpstring][local] */ HRESULT STDMETHODCALLTYPE Render( 
            /* [in] */ TimedLevel *pLevels,
            /* [in] */ HDC hdc,
            /* [in] */ RECT *prc) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MediaInfo( 
            /* [in] */ LONG lChannelCount,
            /* [in] */ LONG lSampleRate,
            /* [in] */ BSTR bstrTitle) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCapabilities( 
            /* [out] */ DWORD *pdwCapabilities) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTitle( 
            /* [out] */ BSTR *bstrTitle) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPresetTitle( 
            /* [in] */ LONG nPreset,
            /* [out] */ BSTR *bstrPresetTitle) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPresetCount( 
            /* [out] */ LONG *pnPresetCount) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetCurrentPreset( 
            /* [in] */ LONG nPreset) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCurrentPreset( 
            /* [out] */ LONG *pnPreset) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DisplayPropertyPage( 
            /* [in] */ HWND hwndOwner) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GoFullscreen( 
            /* [in] */ BOOL fFullScreen) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RenderFullScreen( 
            /* [in] */ TimedLevel *pLevels) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPEffectsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPEffects * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPEffects * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPEffects * This);
        
        /* [helpstring][local] */ HRESULT ( STDMETHODCALLTYPE *Render )( 
            IWMPEffects * This,
            /* [in] */ TimedLevel *pLevels,
            /* [in] */ HDC hdc,
            /* [in] */ RECT *prc);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *MediaInfo )( 
            IWMPEffects * This,
            /* [in] */ LONG lChannelCount,
            /* [in] */ LONG lSampleRate,
            /* [in] */ BSTR bstrTitle);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCapabilities )( 
            IWMPEffects * This,
            /* [out] */ DWORD *pdwCapabilities);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTitle )( 
            IWMPEffects * This,
            /* [out] */ BSTR *bstrTitle);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPresetTitle )( 
            IWMPEffects * This,
            /* [in] */ LONG nPreset,
            /* [out] */ BSTR *bstrPresetTitle);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPresetCount )( 
            IWMPEffects * This,
            /* [out] */ LONG *pnPresetCount);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetCurrentPreset )( 
            IWMPEffects * This,
            /* [in] */ LONG nPreset);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCurrentPreset )( 
            IWMPEffects * This,
            /* [out] */ LONG *pnPreset);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DisplayPropertyPage )( 
            IWMPEffects * This,
            /* [in] */ HWND hwndOwner);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GoFullscreen )( 
            IWMPEffects * This,
            /* [in] */ BOOL fFullScreen);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RenderFullScreen )( 
            IWMPEffects * This,
            /* [in] */ TimedLevel *pLevels);
        
        END_INTERFACE
    } IWMPEffectsVtbl;

    interface IWMPEffects
    {
        CONST_VTBL struct IWMPEffectsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPEffects_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPEffects_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPEffects_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPEffects_Render(This,pLevels,hdc,prc)	\
    ( (This)->lpVtbl -> Render(This,pLevels,hdc,prc) ) 

#define IWMPEffects_MediaInfo(This,lChannelCount,lSampleRate,bstrTitle)	\
    ( (This)->lpVtbl -> MediaInfo(This,lChannelCount,lSampleRate,bstrTitle) ) 

#define IWMPEffects_GetCapabilities(This,pdwCapabilities)	\
    ( (This)->lpVtbl -> GetCapabilities(This,pdwCapabilities) ) 

#define IWMPEffects_GetTitle(This,bstrTitle)	\
    ( (This)->lpVtbl -> GetTitle(This,bstrTitle) ) 

#define IWMPEffects_GetPresetTitle(This,nPreset,bstrPresetTitle)	\
    ( (This)->lpVtbl -> GetPresetTitle(This,nPreset,bstrPresetTitle) ) 

#define IWMPEffects_GetPresetCount(This,pnPresetCount)	\
    ( (This)->lpVtbl -> GetPresetCount(This,pnPresetCount) ) 

#define IWMPEffects_SetCurrentPreset(This,nPreset)	\
    ( (This)->lpVtbl -> SetCurrentPreset(This,nPreset) ) 

#define IWMPEffects_GetCurrentPreset(This,pnPreset)	\
    ( (This)->lpVtbl -> GetCurrentPreset(This,pnPreset) ) 

#define IWMPEffects_DisplayPropertyPage(This,hwndOwner)	\
    ( (This)->lpVtbl -> DisplayPropertyPage(This,hwndOwner) ) 

#define IWMPEffects_GoFulls