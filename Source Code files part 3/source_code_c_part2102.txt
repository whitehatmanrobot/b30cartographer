*VoteRequest )( 
            __RPC__in ITransactionVoterNotifyAsync2 * This);
        
        END_INTERFACE
    } ITransactionVoterNotifyAsync2Vtbl;

    interface ITransactionVoterNotifyAsync2
    {
        CONST_VTBL struct ITransactionVoterNotifyAsync2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionVoterNotifyAsync2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionVoterNotifyAsync2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionVoterNotifyAsync2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionVoterNotifyAsync2_Committed(This,fRetaining,pNewUOW,hr)	\
    ( (This)->lpVtbl -> Committed(This,fRetaining,pNewUOW,hr) ) 

#define ITransactionVoterNotifyAsync2_Aborted(This,pboidReason,fRetaining,pNewUOW,hr)	\
    ( (This)->lpVtbl -> Aborted(This,pboidReason,fRetaining,pNewUOW,hr) ) 

#define ITransactionVoterNotifyAsync2_HeuristicDecision(This,dwDecision,pboidReason,hr)	\
    ( (This)->lpVtbl -> HeuristicDecision(This,dwDecision,pboidReason,hr) ) 

#define ITransactionVoterNotifyAsync2_Indoubt(This)	\
    ( (This)->lpVtbl -> Indoubt(This) ) 


#define ITransactionVoterNotifyAsync2_VoteRequest(This)	\
    ( (This)->lpVtbl -> VoteRequest(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionVoterNotifyAsync2_INTERFACE_DEFINED__ */


#ifndef __ITransactionVoterFactory2_INTERFACE_DEFINED__
#define __ITransactionVoterFactory2_INTERFACE_DEFINED__

/* interface ITransactionVoterFactory2 */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_ITransactionVoterFactory2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5433376A-414D-11d3-B206-00C04FC2F3EF")
    ITransactionVoterFactory2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ __RPC__in_opt ITransaction *pTransaction,
            /* [in] */ __RPC__in_opt ITransactionVoterNotifyAsync2 *pVoterNotify,
            /* [out] */ __RPC__deref_out_opt ITransactionVoterBallotAsync2 **ppVoterBallot) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionVoterFactory2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITransactionVoterFactory2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITransactionVoterFactory2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITransactionVoterFactory2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            __RPC__in ITransactionVoterFactory2 * This,
            /* [in] */ __RPC__in_opt ITransaction *pTransaction,
            /* [in] */ __RPC__in_opt ITransactionVoterNotifyAsync2 *pVoterNotify,
            /* [out] */ __RPC__deref_out_opt ITransactionVoterBallotAsync2 **ppVoterBallot);
        
        END_INTERFACE
    } ITransactionVoterFactory2Vtbl;

    interface ITransactionVoterFactory2
    {
        CONST_VTBL struct ITransactionVoterFactory2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionVoterFactory2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionVoterFactory2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionVoterFactory2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionVoterFactory2_Create(This,pTransaction,pVoterNotify,ppVoterBallot)	\
    ( (This)->lpVtbl -> Create(This,pTransaction,pVoterNotify,ppVoterBallot) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionVoterFactory2_INTERFACE_DEFINED__ */


#ifndef __ITransactionPhase0EnlistmentAsync_INTERFACE_DEFINED__
#define __ITransactionPhase0EnlistmentAsync_INTERFACE_DEFINED__

/* interface ITransactionPhase0EnlistmentAsync */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_ITransactionPhase0EnlistmentAsync;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("82DC88E1-A954-11d1-8F88-00600895E7D5")
    ITransactionPhase0EnlistmentAsync : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Enable( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WaitForEnlistment( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Phase0Done( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unenlist( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransaction( 
            /* [out] */ __RPC__deref_out_opt ITransaction **ppITransaction) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionPhase0EnlistmentAsyncVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITransactionPhase0EnlistmentAsync * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITransactionPhase0EnlistmentAsync * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITransactionPhase0EnlistmentAsync * This);
        
        HRESULT ( STDMETHODCALLTYPE *Enable )( 
            __RPC__in ITransactionPhase0EnlistmentAsync * This);
        
        HRESULT ( STDMETHODCALLTYPE *WaitForEnlistment )( 
            __RPC__in ITransactionPhase0EnlistmentAsync * This);
        
        HRESULT ( STDMETHODCALLTYPE *Phase0Done )( 
            __RPC__in ITransactionPhase0EnlistmentAsync * This);
        
        HRESULT ( STDMETHODCALLTYPE *Unenlist )( 
            __RPC__in ITransactionPhase0EnlistmentAsync * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransaction )( 
            __RPC__in ITransactionPhase0EnlistmentAsync * This,
            /* [out] */ __RPC__deref_out_opt ITransaction **ppITransaction);
        
        END_INTERFACE
    } ITransactionPhase0EnlistmentAsyncVtbl;

    interface ITransactionPhase0EnlistmentAsync
    {
        CONST_VTBL struct ITransactionPhase0EnlistmentAsyncVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionPhase0EnlistmentAsync_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionPhase0EnlistmentAsync_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionPhase0EnlistmentAsync_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionPhase0EnlistmentAsync_Enable(This)	\
    ( (This)->lpVtbl -> Enable(This) ) 

#define ITransactionPhase0EnlistmentAsync_WaitForEnlistment(This)	\
    ( (This)->lpVtbl -> WaitForEnlistment(This) ) 

#define ITransactionPhase0EnlistmentAsync_Phase0Done(This)	\
    ( (This)->lpVtbl -> Phase0Done(This) ) 

#define ITransactionPhase0EnlistmentAsync_Unenlist(This)	\
    ( (This)->lpVtbl -> Unenlist(This) ) 

#define ITransactionPhase0EnlistmentAsync_GetTransaction(This,ppITransaction)	\
    ( (This)->lpVtbl -> GetTransaction(This,ppITransaction) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionPhase0EnlistmentAsync_INTERFACE_DEFINED__ */


#ifndef __ITransactionPhase0NotifyAsync_INTERFACE_DEFINED__
#define __ITransactionPhase0NotifyAsync_INTERFACE_DEFINED__

/* interface ITransactionPhase0NotifyAsync */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_ITransactionPhase0NotifyAsync;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EF081809-0C76-11d2-87A6-00C04F990F34")
    ITransactionPhase0NotifyAsync : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Phase0Request( 
            BOOL fAbortingHint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnlistCompleted( 
            /* [in] */ HRESULT status) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionPhase0NotifyAsyncVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITransactionPhase0NotifyAsync * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITransactionPhase0NotifyAsync * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITransactionPhase0NotifyAsync * This);
        
        HRESULT ( STDMETHODCALLTYPE *Phase0Request )( 
            __RPC__in ITransactionPhase0NotifyAsync * This,
            BOOL fAbortingHint);
        
        HRESULT ( STDMETHODCALLTYPE *EnlistCompleted )( 
            __RPC__in ITransactionPhase0NotifyAsync * This,
            /* [in] */ HRESULT status);
        
        END_INTERFACE
    } ITransactionPhase0NotifyAsyncVtbl;

    interface ITransactionPhase0NotifyAsync
    {
        CONST_VTBL struct ITransactionPhase0NotifyAsyncVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionPhase0NotifyAsync_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionPhase0NotifyAsync_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionPhase0NotifyAsync_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionPhase0NotifyAsync_Phase0Request(This,fAbortingHint)	\
    ( (This)->lpVtbl -> Phase0Request(This,fAbortingHint) ) 

#define ITransactionPhase0NotifyAsync_EnlistCompleted(This,status)	\
    ( (This)->lpVtbl -> EnlistCompleted(This,status) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionPhase0NotifyAsync_INTERFACE_DEFINED__ */


#ifndef __ITransactionPhase0Factory_INTERFACE_DEFINED__
#define __ITransactionPhase0Factory_INTERFACE_DEFINED__

/* interface ITransactionPhase0Factory */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_ITransactionPhase0Factory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("82DC88E0-A954-11d1-8F88-00600895E7D5")
    ITransactionPhase0Factory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ __RPC__in_opt ITransactionPhase0NotifyAsync *pPhase0Notify,
            /* [out] */ __RPC__deref_out_opt ITransactionPhase0EnlistmentAsync **ppPhase0Enlistment) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionPhase0FactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITransactionPhase0Factory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITransactionPhase0Factory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITransactionPhase0Factory * This);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            __RPC__in ITransactionPhase0Factory * This,
            /* [in] */ __RPC__in_opt ITransactionPhase0NotifyAsync *pPhase0Notify,
            /* [out] */ __RPC__deref_out_opt ITransactionPhase0EnlistmentAsync **ppPhase0Enlistment);
        
        END_INTERFACE
    } ITransactionPhase0FactoryVtbl;

    interface ITransactionPhase0Factory
    {
        CONST_VTBL struct ITransactionPhase0FactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionPhase0Factory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionPhase0Factory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionPhase0Factory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionPhase0Factory_Create(This,pPhase0Notify,ppPhase0Enlistment)	\
    ( (This)->lpVtbl -> Create(This,pPhase0Notify,ppPhase0Enlistment) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionPhase0Factory_INTERFACE_DEFINED__ */


#ifndef __ITransactionTransmitter_INTERFACE_DEFINED__
#define __ITransactionTransmitter_INTERFACE_DEFINED__

/* interface ITransactionTransmitter */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_ITransactionTransmitter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("59313E01-B36C-11cf-A539-00AA006887C3")
    ITransactionTransmitter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ __RPC__in_opt ITransaction *pTransaction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropagationTokenSize( 
            /* [out] */ __RPC__out ULONG *pcbToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MarshalPropagationToken( 
            /* [in] */ ULONG cbToken,
            /* [size_is][out] */ __RPC__out_ecount_full(cbToken) byte *rgbToken,
            /* [out] */ __RPC__out ULONG *pcbUsed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnmarshalReturnToken( 
            /* [in] */ ULONG cbReturnToken,
            /* [size_is][in] */ __RPC__in_ecount_full(cbReturnToken) byte *rgbReturnToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionTransmitterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITransactionTransmitter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITransactionTransmitter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITransactionTransmitter * This);
        
        HRESULT ( STDMETHODCALLTYPE *Set )( 
            __RPC__in ITransactionTransmitter * This,
            /* [in] */ __RPC__in_opt ITransaction *pTransaction);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropagationTokenSize )( 
            __RPC__in ITransactionTransmitter * This,
            /* [out] */ __RPC__out ULONG *pcbToken);
        
        HRESULT ( STDMETHODCALLTYPE *MarshalPropagationToken )( 
            __RPC__in ITransactionTransmitter * This,
            /* [in] */ ULONG cbToken,
            /* [size_is][out] */ __RPC__out_ecount_full(cbToken) byte *rgbToken,
            /* [out] */ __RPC__out ULONG *pcbUsed);
        
        HRESULT ( STDMETHODCALLTYPE *UnmarshalReturnToken )( 
            __RPC__in ITransactionTransmitter * This,
            /* [in] */ ULONG cbReturnToken,
            /* [size_is][in] */ __RPC__in_ecount_full(cbReturnToken) byte *rgbReturnToken);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in ITransactionTransmitter * This);
        
        END_INTERFACE
    } ITransactionTransmitterVtbl;

    interface ITransactionTransmitter
    {
        CONST_VTBL struct ITransactionTransmitterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionTransmitter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionTransmitter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionTransmitter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionTransmitter_Set(This,pTransaction)	\
    ( (This)->lpVtbl -> Set(This,pTransaction) ) 

#define ITransactionTransmitter_GetPropagationTokenSize(This,pcbToken)	\
    ( (This)->lpVtbl -> GetPropagationTokenSize(This,pcbToken) ) 

#define ITransactionTransmitter_MarshalPropagationToken(This,cbToken,rgbToken,pcbUsed)	\
    ( (This)->lpVtbl -> MarshalPropagationToken(This,cbToken,rgbToken,pcbUsed) ) 

#define ITransactionTransmitter_UnmarshalReturnToken(This,cbReturnToken,rgbReturnToken)	\
    ( (This)->lpVtbl -> UnmarshalReturnToken(This,cbReturnToken,rgbReturnToken) ) 

#define ITransactionTransmitter_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionTransmitter_INTERFACE_DEFINED__ */


#ifndef __ITransactionTransmitterFactory_INTERFACE_DEFINED__
#define __ITransactionTransmitterFactory_INTERFACE_DEFINED__

/* interface ITransactionTransmitterFactory */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_ITransactionTransmitterFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("59313E00-B36C-11cf-A539-00AA006887C3")
    ITransactionTransmitterFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [out] */ __RPC__deref_out_opt ITransactionTransmitter **ppTransmitter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionTransmitterFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITransactionTransmitterFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITransactionTransmitterFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITransactionTransmitterFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            __RPC__in ITransactionTransmitterFactory * This,
            /* [out] */ __RPC__deref_out_opt ITransactionTransmitter **ppTransmitter);
        
        END_INTERFACE
    } ITransactionTransmitterFactoryVtbl;

    interface ITransactionTransmitterFactory
    {
        CONST_VTBL struct ITransactionTransmitterFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionTransmitterFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionTransmitterFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionTransmitterFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionTransmitterFactory_Create(This,ppTransmitter)	\
    ( (This)->lpVtbl -> Create(This,ppTransmitter) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionTransmitterFactory_INTERFACE_DEFINED__ */


#ifndef __ITransactionReceiver_INTERFACE_DEFINED__
#define __ITransactionReceiver_INTERFACE_DEFINED__

/* interface ITransactionReceiver */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_ITransactionReceiver;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("59313E03-B36C-11cf-A539-00AA006887C3")
    ITransactionReceiver : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE UnmarshalPropagationToken( 
            /* [in] */ ULONG cbToken,
            /* [size_is][in] */ __RPC__in_ecount_full(cbToken) byte *rgbToken,
            /* [out] */ __RPC__deref_out_opt ITransaction **ppTransaction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReturnTokenSize( 
            /* [out] */ __RPC__out ULONG *pcbReturnToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MarshalReturnToken( 
            /* [in] */ ULONG cbReturnToken,
            /* [size_is][out] */ __RPC__out_ecount_full(cbReturnToken) byte *rgbReturnToken,
            /* [out] */ __RPC__out ULONG *pcbUsed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionReceiverVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITransactionReceiver * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITransactionReceiver * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITransactionReceiver * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnmarshalPropagationToken )( 
            __RPC__in ITransactionReceiver * This,
            /* [in] */ ULONG cbToken,
            /* [size_is][in] */ __RPC__in_ecount_full(cbToken) byte *rgbToken,
            /* [out] */ __RPC__deref_out_opt ITransaction **ppTransaction);
        
        HRESULT ( STDMETHODCALLTYPE *GetReturnTokenSize )( 
            __RPC__in ITransactionReceiver * This,
            /* [out] */ __RPC__out ULONG *pcbReturnToken);
        
        HRESULT ( STDMETHODCALLTYPE *MarshalReturnToken )( 
            __RPC__in ITransactionReceiver * This,
            /* [in] */ ULONG cbReturnToken,
            /* [size_is][out] */ __RPC__out_ecount_full(cbReturnToken) byte *rgbReturnToken,
            /* [out] */ __RPC__out ULONG *pcbUsed);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in ITransactionReceiver * This);
        
        END_INTERFACE
    } ITransactionReceiverVtbl;

    interface ITransactionReceiver
    {
        CONST_VTBL struct ITransactionReceiverVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionReceiver_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionReceiver_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionReceiver_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionReceiver_UnmarshalPropagationToken(This,cbToken,rgbToken,ppTransaction)	\
    ( (This)->lpVtbl -> UnmarshalPropagationToken(This,cbToken,rgbToken,ppTransaction) ) 

#define ITransactionReceiver_GetReturnTokenSize(This,pcbReturnToken)	\
    ( (This)->lpVtbl -> GetReturnTokenSize(This,pcbReturnToken) ) 

#define ITransactionReceiver_MarshalReturnToken(This,cbReturnToken,rgbReturnToken,pcbUsed)	\
    ( (This)->lpVtbl -> MarshalReturnToken(This,cbReturnToken,rgbReturnToken,pcbUsed) ) 

#define ITransactionReceiver_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionReceiver_INTERFACE_DEFINED__ */


#ifndef __ITransactionReceiverFactory_INTERFACE_DEFINED__
#define __ITransactionReceiverFactory_INTERFACE_DEFINED__

/* interface ITransactionReceiverFactory */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_ITransactionReceiverFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("59313E02-B36C-11cf-A539-00AA006887C3")
    ITransactionReceiverFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [out] */ __RPC__deref_out_opt ITransactionReceiver **ppReceiver) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionReceiverFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITransactionReceiverFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITransactionReceiverFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITransactionReceiverFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            __RPC__in ITransactionReceiverFactory * This,
            /* [out] */ __RPC__deref_out_opt ITransactionReceiver **ppReceiver);
        
        END_INTERFACE
    } ITransactionReceiverFactoryVtbl;

    interface ITransactionReceiverFactory
    {
        CONST_VTBL struct ITransactionReceiverFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionReceiverFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransactionReceiverFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransactionReceiverFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransactionReceiverFactory_Create(This,ppReceiver)	\
    ( (This)->lpVtbl -> Create(This,ppReceiver) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransactionReceiverFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_txdtc_0000_0024 */
/* [local] */ 

typedef struct _ProxyConfigParams
    {
    WORD wcThreadsMax;
    } 	PROXY_CONFIG_PARAMS;



extern RPC_IF_HANDLE __MIDL_itf_txdtc_0000_0024_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_txdtc_0000_0024_v0_0_s_ifspec;

#ifndef __IDtcLuConfigure_INTERFACE_DEFINED__
#define __IDtcLuConfigure_INTERFACE_DEFINED__

/* interface IDtcLuConfigure */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IDtcLuConfigure;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4131E760-1AEA-11d0-944B-00A0C905416E")
    IDtcLuConfigure : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Add( 
            /* [size_is][in] */ __RPC__in_ecount_full(cbLuPair) byte *pucLuPair,
            /* [in] */ DWORD cbLuPair) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [size_is][in] */ __RPC__in_ecount_full(cbLuPair) byte *pucLuPair,
            /* [in] */ DWORD cbLuPair) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcLuConfigureVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDtcLuConfigure * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDtcLuConfigure * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDtcLuConfigure * This);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            __RPC__in IDtcLuConfigure * This,
            /* [size_is][in] */ __RPC__in_ecount_full(cbLuPair) byte *pucLuPair,
            /* [in] */ DWORD cbLuPair);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            __RPC__in IDtcLuConfigure * This,
            /* [size_is][in] */ __RPC__in_ecount_full(cbLuPair) byte *pucLuPair,
            /* [in] */ DWORD cbLuPair);
        
        END_INTERFACE
    } IDtcLuConfigureVtbl;

    interface IDtcLuConfigure
    {
        CONST_VTBL struct IDtcLuConfigureVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcLuConfigure_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcLuConfigure_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcLuConfigure_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcLuConfigure_Add(This,pucLuPair,cbLuPair)	\
    ( (This)->lpVtbl -> Add(This,pucLuPair,cbLuPair) ) 

#define IDtcLuConfigure_Delete(This,pucLuPair,cbLuPair)	\
    ( (This)->lpVtbl -> Delete(This,pucLuPair,cbLuPair) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcLuConfigure_INTERFACE_DEFINED__ */


#ifndef __IDtcLuRecovery_INTERFACE_DEFINED__
#define __IDtcLuRecovery_INTERFACE_DEFINED__

/* interface IDtcLuRecovery */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IDtcLuRecovery;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AC2B8AD2-D6F0-11d0-B386-00A0C9083365")
    IDtcLuRecovery : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDtcLuRecoveryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDtcLuRecovery * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDtcLuRecovery * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDtcLuRecovery * This);
        
        END_INTERFACE
    } IDtcLuRecoveryVtbl;

    interface IDtcLuRecovery
    {
        CONST_VTBL struct IDtcLuRecoveryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcLuRecovery_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcLuRecovery_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcLuRecovery_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcLuRecovery_INTERFACE_DEFINED__ */


#ifndef __IDtcLuRecoveryFactory_INTERFACE_DEFINED__
#define __IDtcLuRecoveryFactory_INTERFACE_DEFINED__

/* interface IDtcLuRecoveryFactory */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IDtcLuRecoveryFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4131E762-1AEA-11d0-944B-00A0C905416E")
    IDtcLuRecoveryFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [size_is][in] */ __RPC__in_ecount_full(cbLuPair) byte *pucLuPair,
            /* [in] */ DWORD cbLuPair,
            /* [out] */ __RPC__deref_out_opt IDtcLuRecovery **ppRecovery) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcLuRecoveryFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDtcLuRecoveryFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDtcLuRecoveryFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDtcLuRecoveryFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            __RPC__in IDtcLuRecoveryFactory * This,
            /* [size_is][in] */ __RPC__in_ecount_full(cbLuPair) byte *pucLuPair,
            /* [in] */ DWORD cbLuPair,
            /* [out] */ __RPC__deref_out_opt IDtcLuRecovery **ppRecovery);
        
        END_INTERFACE
    } IDtcLuRecoveryFactoryVtbl;

    interface IDtcLuRecoveryFactory
    {
        CONST_VTBL struct IDtcLuRecoveryFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcLuRecoveryFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcLuRecoveryFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcLuRecoveryFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcLuRecoveryFactory_Create(This,pucLuPair,cbLuPair,ppRecovery)	\
    ( (This)->lpVtbl -> Create(This,pucLuPair,cbLuPair,ppRecovery) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcLuRecoveryFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_txdtc_0000_0027 */
/* [local] */ 

typedef 
enum _DtcLu_LocalRecovery_Work
    {	DTCINITIATEDRECOVERYWORK_CHECKLUSTATUS	= 1,
	DTCINITIATEDRECOVERYWORK_TRANS	= ( DTCINITIATEDRECOVERYWORK_CHECKLUSTATUS + 1 ) ,
	DTCINITIATEDRECOVERYWORK_TMDOWN	= ( DTCINITIATEDRECOVERYWORK_TRANS + 1 ) 
    } 	DTCINITIATEDRECOVERYWORK;

typedef 
enum _DtcLu_Xln
    {	DTCLUXLN_COLD	= 1,
	DTCLUXLN_WARM	= ( DTCLUXLN_COLD + 1 ) 
    } 	DTCLUXLN;

typedef 
enum _DtcLu_Xln_Confirmation
    {	DTCLUXLNCONFIRMATION_CONFIRM	= 1,
	DTCLUXLNCONFIRMATION_LOGNAMEMISMATCH	= ( DTCLUXLNCONFIRMATION_CONFIRM + 1 ) ,
	DTCLUXLNCONFIRMATION_COLDWARMMISMATCH	= ( DTCLUXLNCONFIRMATION_LOGNAMEMISMATCH + 1 ) ,
	DTCLUXLNCONFIRMATION_OBSOLETE	= ( DTCLUXLNCONFIRMATION_COLDWARMMISMATCH + 1 ) 
    } 	DTCLUXLNCONFIRMATION;

typedef 
enum _DtcLu_Xln_Response
    {	DTCLUXLNRESPONSE_OK_SENDOURXLNBACK	= 1,
	DTCLUXLNRESPONSE_OK_SENDCONFIRMATION	= ( DTCLUXLNRESPONSE_OK_SENDOURXLNBACK + 1 ) ,
	DTCLUXLNRESPONSE_LOGNAMEMISMATCH	= ( DTCLUXLNRESPONSE_OK_SENDCONFIRMATION + 1 ) ,
	DTCLUXLNRESPONSE_COLDWARMMISMATCH	= ( DTCLUXLNRESPONSE_LOGNAMEMISMATCH + 1 ) 
    } 	DTCLUXLNRESPONSE;

typedef 
enum _DtcLu_Xln_Error
    {	DTCLUXLNERROR_PROTOCOL	= 1,
	DTCLUXLNERROR_LOGNAMEMISMATCH	= ( DTCLUXLNERROR_PROTOCOL + 1 ) ,
	DTCLUXLNERROR_COLDWARMMISMATCH	= ( DTCLUXLNERROR_LOGNAMEMISMATCH + 1 ) 
    } 	DTCLUXLNERROR;

typedef 
enum _DtcLu_CompareState
    {	DTCLUCOMPARESTATE_COMMITTED	= 1,
	DTCLUCOMPARESTATE_HEURISTICCOMMITTED	= ( DTCLUCOMPARESTATE_COMMITTED + 1 ) ,
	DTCLUCOMPARESTATE_HEURISTICMIXED	= ( DTCLUCOMPARESTATE_HEURISTICCOMMITTED + 1 ) ,
	DTCLUCOMPARESTATE_HEURISTICRESET	= ( DTCLUCOMPARESTATE_HEURISTICMIXED + 1 ) ,
	DTCLUCOMPARESTATE_INDOUBT	= ( DTCLUCOMPARESTATE_HEURISTICRESET + 1 ) ,
	DTCLUCOMPARESTATE_RESET	= ( DTCLUCOMPARESTATE_INDOUBT + 1 ) 
    } 	DTCLUCOMPARESTATE;

typedef 
enum _DtcLu_CompareStates_Confirmation
    {	DTCLUCOMPARESTATESCONFIRMATION_CONFIRM	= 1,
	DTCLUCOMPARESTATESCONFIRMATION_PROTOCOL	= ( DTCLUCOMPARESTATESCONFIRMATION_CONFIRM + 1 ) 
    } 	DTCLUCOMPARESTATESCONFIRMATION;

typedef 
enum _DtcLu_CompareStates_Error
    {	DTCLUCOMPARESTATESERROR_PROTOCOL	= 1
    } 	DTCLUCOMPARESTATESERROR;

typedef 
enum _DtcLu_CompareStates_Response
    {	DTCLUCOMPARESTATESRESPONSE_OK	= 1,
	DTCLUCOMPARESTATESRESPONSE_PROTOCOL	= ( DTCLUCOMPARESTATESRESPONSE_OK + 1 ) 
    } 	DTCLUCOMPARESTATESRESPONSE;



extern RPC_IF_HANDLE __MIDL_itf_txdtc_0000_0027_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_txdtc_0000_0027_v0_0_s_ifspec;

#ifndef __IDtcLuRecoveryInitiatedByDtcTransWork_INTERFACE_DEFINED__
#define __IDtcLuRecoveryInitiatedByDtcTransWork_INTERFACE_DEFINED__

/* interface IDtcLuRecoveryInitiatedByDtcTransWork */
/* [local][uuid][unique][object] */ 


EXTERN_C const IID IID_IDtcLuRecoveryInitiatedByDtcTransWork;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4131E765-1AEA-11d0-944B-00A0C905416E")
    IDtcLuRecoveryInitiatedByDtcTransWork : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLogNameSizes( 
            /* [out] */ DWORD *pcbOurLogName,
            /* [out] */ DWORD *pcbRemoteLogName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOurXln( 
            /* [out] */ DTCLUXLN *pXln,
            /* [out][in] */ unsigned char *pOurLogName,
            /* [out][in] */ unsigned char *pRemoteLogName,
            /* [out] */ DWORD *pdwProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleConfirmationFromOurXln( 
            /* [in] */ DTCLUXLNCONFIRMATION Confirmation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleTheirXlnResponse( 
            /* [in] */ DTCLUXLN Xln,
            /* [in] */ unsigned char *pRemoteLogName,
            /* [in] */ DWORD cbRemoteLogName,
            /* [in] */ DWORD dwProtocol,
            /* [out] */ DTCLUXLNCONFIRMATION *pConfirmation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleErrorFromOurXln( 
            /* [in] */ DTCLUXLNERROR Error) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CheckForCompareStates( 
            /* [out] */ BOOL *fCompareStates) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOurTransIdSize( 
            /* [out][in] */ DWORD *pcbOurTransId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOurCompareStates( 
            /* [out][in] */ unsigned char *pOurTransId,
            /* [out] */ DTCLUCOMPARESTATE *pCompareState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleTheirCompareStatesResponse( 
            /* [in] */ DTCLUCOMPARESTATE CompareState,
            /* [out] */ DTCLUCOMPARESTATESCONFIRMATION *pConfirmation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleErrorFromOurCompareStates( 
            /* [in] */ DTCLUCOMPARESTATESERROR Error) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConversationLost( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecoverySeqNum( 
            /* [out] */ LONG *plRecoverySeqNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ObsoleteRecoverySeqNum( 
            /* [in] */ LONG lNewRecoverySeqNum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcLuRecoveryInitiatedByDtcTransWorkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLogNameSizes )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This,
            /* [out] */ DWORD *pcbOurLogName,
            /* [out] */ DWORD *pcbRemoteLogName);
        
        HRESULT ( STDMETHODCALLTYPE *GetOurXln )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This,
            /* [out] */ DTCLUXLN *pXln,
            /* [out][in] */ unsigned char *pOurLogName,
            /* [out][in] */ unsigned char *pRemoteLogName,
            /* [out] */ DWORD *pdwProtocol);
        
        HRESULT ( STDMETHODCALLTYPE *HandleConfirmationFromOurXln )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This,
            /* [in] */ DTCLUXLNCONFIRMATION Confirmation);
        
        HRESULT ( STDMETHODCALLTYPE *HandleTheirXlnResponse )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This,
            /* [in] */ DTCLUXLN Xln,
            /* [in] */ unsigned char *pRemoteLogName,
            /* [in] */ DWORD cbRemoteLogName,
            /* [in] */ DWORD dwProtocol,
            /* [out] */ DTCLUXLNCONFIRMATION *pConfirmation);
        
        HRESULT ( STDMETHODCALLTYPE *HandleErrorFromOurXln )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This,
            /* [in] */ DTCLUXLNERROR Error);
        
        HRESULT ( STDMETHODCALLTYPE *CheckForCompareStates )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This,
            /* [out] */ BOOL *fCompareStates);
        
        HRESULT ( STDMETHODCALLTYPE *GetOurTransIdSize )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This,
            /* [out][in] */ DWORD *pcbOurTransId);
        
        HRESULT ( STDMETHODCALLTYPE *GetOurCompareStates )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This,
            /* [out][in] */ unsigned char *pOurTransId,
            /* [out] */ DTCLUCOMPARESTATE *pCompareState);
        
        HRESULT ( STDMETHODCALLTYPE *HandleTheirCompareStatesResponse )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This,
            /* [in] */ DTCLUCOMPARESTATE CompareState,
            /* [out] */ DTCLUCOMPARESTATESCONFIRMATION *pConfirmation);
        
        HRESULT ( STDMETHODCALLTYPE *HandleErrorFromOurCompareStates )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This,
            /* [in] */ DTCLUCOMPARESTATESERROR Error);
        
        HRESULT ( STDMETHODCALLTYPE *ConversationLost )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecoverySeqNum )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This,
            /* [out] */ LONG *plRecoverySeqNum);
        
        HRESULT ( STDMETHODCALLTYPE *ObsoleteRecoverySeqNum )( 
            IDtcLuRecoveryInitiatedByDtcTransWork * This,
            /* [in] */ LONG lNewRecoverySeqNum);
        
        END_INTERFACE
    } IDtcLuRecoveryInitiatedByDtcTransWorkVtbl;

    interface IDtcLuRecoveryInitiatedByDtcTransWork
    {
        CONST_VTBL struct IDtcLuRecoveryInitiatedByDtcTransWorkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcLuRecoveryInitiatedByDtcTransWork_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcLuRecoveryInitiatedByDtcTransWork_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcLuRecoveryInitiatedByDtcTransWork_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcLuRecoveryInitiatedByDtcTransWork_GetLogNameSizes(This,pcbOurLogName,pcbRemoteLogName)	\
    ( (This)->lpVtbl -> GetLogNameSizes(This,pcbOurLogName,pcbRemoteLogName) ) 

#define IDtcLuRecoveryInitiatedByDtcTransWork_GetOurXln(This,pXln,pOurLogName,pRemoteLogName,pdwProtocol)	\
    ( (This)->lpVtbl -> GetOurXln(This,pXln,pOurLogName,pRemoteLogName,pdwProtocol) ) 

#define IDtcLuRecoveryInitiatedByDtcTransWork_HandleConfirmationFromOurXln(This,Confirmation)	\
    ( (This)->lpVtbl -> HandleConfirmationFromOurXln(This,Confirmation) ) 

#define IDtcLuRecoveryInitiatedByDtcTransWork_HandleTheirXlnResponse(This,Xln,pRemoteLogName,cbRemoteLogName,dwProtocol,pConfirmation)	\
    ( (This)->lpVtbl -> HandleTheirXlnResponse(This,Xln,pRemoteLogName,cbRemoteLogName,dwProtocol,pConfirmation) ) 

#define IDtcLuRecoveryInitiatedByDtcTransWork_HandleErrorFromOurXln(This,Error)	\
    ( (This)->lpVtbl -> HandleErrorFromOurXln(This,Error) ) 

#define IDtcLuRecoveryInitiatedByDtcTransWork_CheckForCompareStates(This,fCompareStates)	\
    ( (This)->lpVtbl -> CheckForCompareStates(This,fCompareStates) ) 

#define IDtcLuRecoveryInitiatedByDtcTransWork_GetOurTransIdSize(This,pcbOurTransId)	\
    ( (This)->lpVtbl -> GetOurTransIdSize(This,pcbOurTransId) ) 

#define IDtcLuRecoveryInitiatedByDtcTransWork_GetOurCompareStates(This,pOurTransId,pCompareState)	\
    ( (This)->lpVtbl -> GetOurCompareStates(This,pOurTransId,pCompareState) ) 

#define IDtcLuRecoveryInitiatedByDtcTransWork_HandleTheirCompareStatesResponse(This,CompareState,pConfirmation)	\
    ( (This)->lpVtbl -> HandleTheirCompareStatesResponse(This,CompareState,pConfirmation) ) 

#define IDtcLuRecoveryInitiatedByDtcTransWork_HandleErrorFromOurCompareStates(This,Error)	\
    ( (This)->lpVtbl -> HandleErrorFromOurCompareStates(This,Error) ) 

#define IDtcLuRecoveryInitiatedByDtcTransWork_ConversationLost(This)	\
    ( (This)->lpVtbl -> ConversationLost(This) ) 

#define IDtcLuRecoveryInitiatedByDtcTransWork_GetRecoverySeqNum(This,plRecoverySeqNum)	\
    ( (This)->lpVtbl -> GetRecoverySeqNum(This,plRecoverySeqNum) ) 

#define IDtcLuRecoveryInitiatedByDtcTransWork_ObsoleteRecoverySeqNum(This,lNewRecoverySeqNum)	\
    ( (This)->lpVtbl -> ObsoleteRecoverySeqNum(This,lNewRecoverySeqNum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcLuRecoveryInitiatedByDtcTransWork_INTERFACE_DEFINED__ */


#ifndef __IDtcLuRecoveryInitiatedByDtcStatusWork_INTERFACE_DEFINED__
#define __IDtcLuRecoveryInitiatedByDtcStatusWork_INTERFACE_DEFINED__

/* interface IDtcLuRecoveryInitiatedByDtcStatusWork */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IDtcLuRecoveryInitiatedByDtcStatusWork;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4131E766-1AEA-11d0-944B-00A0C905416E")
    IDtcLuRecoveryInitiatedByDtcStatusWork : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE HandleCheckLuStatus( 
            /* [in] */ LONG lRecoverySeqNum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcLuRecoveryInitiatedByDtcStatusWorkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDtcLuRecoveryInitiatedByDtcStatusWork * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDtcLuRecoveryInitiatedByDtcStatusWork * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDtcLuRecoveryInitiatedByDtcStatusWork * This);
        
        HRESULT ( STDMETHODCALLTYPE *HandleCheckLuStatus )( 
            __RPC__in IDtcLuRecoveryInitiatedByDtcStatusWork * This,
            /* [in] */ LONG lRecoverySeqNum);
        
        END_INTERFACE
    } IDtcLuRecoveryInitiatedByDtcStatusWorkVtbl;

    interface IDtcLuRecoveryInitiatedByDtcStatusWork
    {
        CONST_VTBL struct IDtcLuRecoveryInitiatedByDtcStatusWorkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcLuRecoveryInitiatedByDtcStatusWork_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcLuRecoveryInitiatedByDtcStatusWork_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcLuRecoveryInitiatedByDtcStatusWork_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcLuRecoveryInitiatedByDtcStatusWork_HandleCheckLuStatus(This,lRecoverySeqNum)	\
    ( (This)->lpVtbl -> HandleCheckLuStatus(This,lRecoverySeqNum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcLuRecoveryInitiatedByDtcStatusWork_INTERFACE_DEFINED__ */


#ifndef __IDtcLuRecoveryInitiatedByDtc_INTERFACE_DEFINED__
#define __IDtcLuRecoveryInitiatedByDtc_INTERFACE_DEFINED__

/* interface IDtcLuRecoveryInitiatedByDtc */
/* [local][uuid][unique][object] */ 


EXTERN_C const IID IID_IDtcLuRecoveryInitiatedByDtc;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4131E764-1AEA-11d0-944B-00A0C905416E")
    IDtcLuRecoveryInitiatedByDtc : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetWork( 
            /* [out][in] */ DTCINITIATEDRECOVERYWORK *pWork,
            /* [out][in] */ void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcLuRecoveryInitiatedByDtcVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDtcLuRecoveryInitiatedByDtc * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDtcLuRecoveryInitiatedByDtc * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDtcLuRecoveryInitiatedByDtc * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWork )( 
            IDtcLuRecoveryInitiatedByDtc * This,
            /* [out][in] */ DTCINITIATEDRECOVERYWORK *pWork,
            /* [out][in] */ void **ppv);
        
        END_INTERFACE
    } IDtcLuRecoveryInitiatedByDtcVtbl;

    interface IDtcLuRecoveryInitiatedByDtc
    {
        CONST_VTBL struct IDtcLuRecoveryInitiatedByDtcVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcLuRecoveryInitiatedByDtc_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcLuRecoveryInitiatedByDtc_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcLuRecoveryInitiatedByDtc_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcLuRecoveryInitiatedByDtc_GetWork(This,pWork,ppv)	\
    ( (This)->lpVtbl -> GetWork(This,pWork,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcLuRecoveryInitiatedByDtc_INTERFACE_DEFINED__ */


#ifndef __IDtcLuRecoveryInitiatedByLuWork_INTERFACE_DEFINED__
#define __IDtcLuRecoveryInitiatedByLuWork_INTERFACE_DEFINED__

/* interface IDtcLuRecoveryInitiatedByLuWork */
/* [local][uuid][unique][object] */ 


EXTERN_C const IID IID_IDtcLuRecoveryInitiatedByLuWork;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AC2B8AD1-D6F0-11d0-B386-00A0C9083365")
    IDtcLuRecoveryInitiatedByLuWork : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE HandleTheirXln( 
            /* [in] */ LONG lRecoverySeqNum,
            /* [in] */ DTCLUXLN Xln,
            /* [in] */ unsigned char *pRemoteLogName,
            /* [in] */ DWORD cbRemoteLogName,
            /* [in] */ unsigned char *pOurLogName,
            /* [in] */ DWORD cbOurLogName,
            /* [in] */ DWORD dwProtocol,
            /* [out] */ DTCLUXLNRESPONSE *pResponse) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOurLogNameSize( 
            /* [out][in] */ DWORD *pcbOurLogName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOurXln( 
            /* [out] */ DTCLUXLN *pXln,
            /* [out][in] */ unsigned char *pOurLogName,
            /* [out] */ DWORD *pdwProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleConfirmationOfOurXln( 
            /* [in] */ DTCLUXLNCONFIRMATION Confirmation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleTheirCompareStates( 
            /* [out][in] */ unsigned char *pRemoteTransId,
            /* [in] */ DWORD cbRemoteTransId,
            /* [in] */ DTCLUCOMPARESTATE CompareState,
            /* [out] */ DTCLUCOMPARESTATESRESPONSE *pResponse,
            /* [out] */ DTCLUCOMPARESTATE *pCompareState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleConfirmationOfOurCompareStates( 
            /* [in] */ DTCLUCOMPARESTATESCONFIRMATION Confirmation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleErrorFromOurCompareStates( 
            /* [in] */ DTCLUCOMPARESTATESERROR Error) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConversationLost( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcLuRecoveryInitiatedByLuWorkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDtcLuRecoveryInitiatedByLuWork * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDtcLuRecoveryInitiatedByLuWork * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDtcLuRecoveryInitiatedByLuWork * This);
        
        HRESULT ( STDMETHODCALLTYPE *HandleTheirXln )( 
            IDtcLuRecoveryInitiatedByLuWork * This,
            /* [in] */ LONG lRecoverySeqNum,
            /* [in] */ DTCLUXLN Xln,
            /* [in] */ unsigned char *pRemoteLogName,
            /* [in] */ DWORD cbRemoteLogName,
            /* [in] */ unsigned char *pOurLogName,
            /* [in] */ DWORD cbOurLogName,
            /* [in] */ DWORD dwProtocol,
            /* [out] */ DTCLUXLNRESPONSE *pResponse);
        
        HRESULT ( STDMETHODCALLTYPE *GetOurLogNameSize )( 
            IDtcLuRecoveryInitiatedByLuWork * This,
            /* [out][in] */ DWORD *pcbOurLogName);
        
        HRESULT ( STDMETHODCALLTYPE *GetOurXln )( 
            IDtcLuRecoveryInitiatedByLuWork * This,
            /* [out] */ DTCLUXLN *pXln,
            /* [out][in] */ unsigned char *pOurLogName,
            /* [out] */ DWORD *pdwProtocol);
        
        HRESULT ( STDMETHODCALLTYPE *HandleConfirmationOfOurXln )( 
            IDtcLuRecoveryInitiatedByLuWork * This,
            /* [in] */ DTCLUXLNCONFIRMATION Confirmation);
        
        HRESULT ( STDMETHODCALLTYPE *HandleTheirCompareStates )( 
            IDtcLuRecoveryInitiatedByLuWork * This,
            /* [out][in] */ unsigned char *pRemoteTransId,
            /* [in] */ DWORD cbRemoteTransId,
            /* [in] */ DTCLUCOMPARESTATE CompareState,
            /* [out] */ DTCLUCOMPARESTATESRESPONSE *pResponse,
            /* [out] */ DTCLUCOMPARESTATE *pCompareState);
        
        HRESULT ( STDMETHODCALLTYPE *HandleConfirmationOfOurCompareStates )( 
            IDtcLuRecoveryInitiatedByLuWork * This,
            /* [in] */ DTCLUCOMPARESTATESCONFIRMATION Confirmation);
        
        HRESULT ( STDMETHODCALLTYPE *HandleErrorFromOurCompareStates )( 
            IDtcLuRecoveryInitiatedByLuWork * This,
            /* [in] */ DTCLUCOMPARESTATESERROR Error);
        
        HRESULT ( STDMETHODCALLTYPE *ConversationLost )( 
            IDtcLuRecoveryInitiatedByLuWork * This);
        
        END_INTERFACE
    } IDtcLuRecoveryInitiatedByLuWorkVtbl;

    interface IDtcLuRecoveryInitiatedByLuWork
    {
        CONST_VTBL struct IDtcLuRecoveryInitiatedByLuWorkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcLuRecoveryInitiatedByLuWork_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcLuRecoveryInitiatedByLuWork_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcLuRecoveryInitiatedByLuWork_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcLuRecoveryInitiatedByLuWork_HandleTheirXln(This,lRecoverySeqNum,Xln,pRemoteLogName,cbRemoteLogName,pOurLogName,cbOurLogName,dwProtocol,pResponse)	\
    ( (This)->lpVtbl -> HandleTheirXln(This,lRecoverySeqNum,Xln,pRemoteLogName,cbRemoteLogName,pOurLogName,cbOurLogName,dwProtocol,pResponse) ) 

#define IDtcLuRecoveryInitiatedByLuWork_GetOurLogNameSize(This,pcbOurLogName)	\
    ( (This)->lpVtbl -> GetOurLogNameSize(This,pcbOurLogName) ) 

#define IDtcLuRecoveryInitiatedByLuWork_GetOurXln(This,pXln,pOurLogName,pdwProtocol)	\
    ( (This)->lpVtbl -> GetOurXln(This,pXln,pOurLogName,pdwProtocol) ) 

#define IDtcLuRecoveryInitiatedByLuWork_HandleConfirmationOfOurXln(This,Confirmation)	\
    ( (This)->lpVtbl -> HandleConfirmationOfOurXln(This,Confirmation) ) 

#define IDtcLuRecoveryInitiatedByLuWork_HandleTheirCompareStates(This,pRemoteTransId,cbRemoteTransId,CompareState,pResponse,pCompareState)	\
    ( (This)->lpVtbl -> HandleTheirCompareStates(This,pRemoteTransId,cbRemoteTransId,CompareState,pResponse,pCompareState) ) 

#define IDtcLuRecoveryInitiatedByLuWork_HandleConfirmationOfOurCompareStates(This,Confirmation)	\
    ( (This)->lpVtbl -> HandleConfirmationOfOurCompareStates(This,Confirmation) ) 

#define IDtcLuRecoveryInitiatedByLuWork_HandleErrorFromOurCompareStates(This,Error)	\
    ( (This)->lpVtbl -> HandleErrorFromOurCompareStates(This,Error) ) 

#define IDtcLuRecoveryInitiatedByLuWork_ConversationLost(This)	\
    ( (This)->lpVtbl -> ConversationLost(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcLuRecoveryInitiatedByLuWork_INTERFACE_DEFINED__ */


#ifndef __IDtcLuRecoveryInitiatedByLu_INTERFACE_DEFINED__
#define __IDtcLuRecoveryInitiatedByLu_INTERFACE_DEFINED__

/* interface IDtcLuRecoveryInitiatedByLu */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IDtcLuRecoveryInitiatedByLu;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4131E768-1AEA-11d0-944B-00A0C905416E")
    IDtcLuRecoveryInitiatedByLu : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetObjectToHandleWorkFromLu( 
            /* [out] */ __RPC__deref_out_opt IDtcLuRecoveryInitiatedByLuWork **ppWork) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcLuRecoveryInitiatedByLuVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDtcLuRecoveryInitiatedByLu * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDtcLuRecoveryInitiatedByLu * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDtcLuRecoveryInitiatedByLu * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectToHandleWorkFromLu )( 
            __RPC__in IDtcLuRecoveryInitiatedByLu * This,
            /* [out] */ __RPC__deref_out_opt IDtcLuRecoveryInitiatedByLuWork **ppWork);
        
        END_INTERFACE
    } IDtcLuRecoveryInitiatedByLuVtbl;

    interface IDtcLuRecoveryInitiatedByLu
    {
        CONST_VTBL struct IDtcLuRecoveryInitiatedByLuVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcLuRecoveryInitiatedByLu_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcLuRecoveryInitiatedByLu_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcLuRecoveryInitiatedByLu_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcLuRecoveryInitiatedByLu_GetObjectToHandleWorkFromLu(This,ppWork)	\
    ( (This)->lpVtbl -> GetObjectToHandleWorkFromLu(This,ppWork) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcLuRecoveryInitiatedByLu_INTERFACE_DEFINED__ */


#ifndef __IDtcLuRmEnlistment_INTERFACE_DEFINED__
#define __IDtcLuRmEnlistment_INTERFACE_DEFINED__

/* interface IDtcLuRmEnlistment */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IDtcLuRmEnlistment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4131E769-1AEA-11d0-944B-00A0C905416E")
    IDtcLuRmEnlistment : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Unplug( 
            /* [in] */ BOOL fConversationLost) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BackedOut( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BackOut( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Committed( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Forget( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestCommit( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcLuRmEnlistmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDtcLuRmEnlistment * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDtcLuRmEnlistment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDtcLuRmEnlistment * This);
        
        HRESULT ( STDMETHODCALLTYPE *Unplug )( 
            __RPC__in IDtcLuRmEnlistment * This,
            /* [in] */ BOOL fConversationLost);
        
        HRESULT ( STDMETHODCALLTYPE *BackedOut )( 
            __RPC__in IDtcLuRmEnlistment * This);
        
        HRESULT ( STDMETHODCALLTYPE *BackOut )( 
            __RPC__in IDtcLuRmEnlistment * This);
        
        HRESULT ( STDMETHODCALLTYPE *Committed )( 
            __RPC__in IDtcLuRmEnlistment * This);
        
        HRESULT ( STDMETHODCALLTYPE *Forget )( 
            __RPC__in IDtcLuRmEnlistment * This);
        
        HRESULT ( STDMETHODCALLTYPE *RequestCommit )( 
            __RPC__in IDtcLuRmEnlistment * This);
        
        END_INTERFACE
    } IDtcLuRmEnlistmentVtbl;

    interface IDtcLuRmEnlistment
    {
        CONST_VTBL struct IDtcLuRmEnlistmentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcLuRmEnlistment_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcLuRmEnlistment_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcLuRmEnlistment_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcLuRmEnlistment_Unplug(This,fConversationLost)	\
    ( (This)->lpVtbl -> Unplug(This,fConversationLost) ) 

#define IDtcLuRmEnlistment_BackedOut(This)	\
    ( (This)->lpVtbl -> BackedOut(This) ) 

#define IDtcLuRmEnlistment_BackOut(This)	\
    ( (This)->lpVtbl -> BackOut(This) ) 

#define IDtcLuRmEnlistment_Committed(This)	\
    ( (This)->lpVtbl -> Committed(This) ) 

#define IDtcLuRmEnlistment_Forget(This)	\
    ( (This)->lpVtbl -> Forget(This) ) 

#define IDtcLuRmEnlistment_RequestCommit(This)	\
    ( (This)->lpVtbl -> RequestCommit(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcLuRmEnlistment_INTERFACE_DEFINED__ */


#ifndef __IDtcLuRmEnlistmentSink_INTERFACE_DEFINED__
#define __IDtcLuRmEnlistmentSink_INTERFACE_DEFINED__

/* interface IDtcLuRmEnlistmentSink */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IDtcLuRmEnlistmentSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4131E770-1AEA-11d0-944B-00A0C905416E")
    IDtcLuRmEnlistmentSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AckUnplug( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TmDown( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SessionLost( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BackedOut( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BackOut( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Committed( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Forget( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Prepare( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestCommit( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcLuRmEnlistmentSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDtcLuRmEnlistmentSink * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDtcLuRmEnlistmentSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDtcLuRmEnlistmentSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *AckUnplug )( 
            __RPC__in IDtcLuRmEnlistmentSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *TmDown )( 
            __RPC__in IDtcLuRmEnlistmentSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *SessionLost )( 
            __RPC__in IDtcLuRmEnlistmentSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *BackedOut )( 
            __RPC__in IDtcLuRmEnlistmentSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *BackOut )( 
            __RPC__in IDtcLuRmEnlistmentSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *Committed )( 
            __RPC__in IDtcLuRmEnlistmentSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *Forget )( 
            __RPC__in IDtcLuRmEnlistmentSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *Prepare )( 
            __RPC__in IDtcLuRmEnlistmentSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *RequestCommit )( 
            __RPC__in IDtcLuRmEnlistmentSink * This);
        
        END_INTERFACE
    } IDtcLuRmEnlistmentSinkVtbl;

    interface IDtcLuRmEnlistmentSink
    {
        CONST_VTBL struct IDtcLuRmEnlistmentSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcLuRmEnlistmentSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcLuRmEnlistmentSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcLuRmEnlistmentSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcLuRmEnlistmentSink_AckUnplug(This)	\
    ( (This)->lpVtbl -> AckUnplug(This) ) 

#define IDtcLuRmEnlistmentSink_TmDown(This)	\
    ( (This)->lpVtbl -> TmDown(This) ) 

#define IDtcLuRmEnlistmentSink_SessionLost(This)	\
    ( (This)->lpVtbl -> SessionLost(This) ) 

#define IDtcLuRmEnlistmentSink_BackedOut(This)	\
    ( (This)->lpVtbl -> BackedOut(This) ) 

#define IDtcLuRmEnlistmentSink_BackOut(This)	\
    ( (This)->lpVtbl -> BackOut(This) ) 

#define IDtcLuRmEnlistmentSink_Committed(This)	\
    ( (This)->lpVtbl -> Committed(This) ) 

#define IDtcLuRmEnlistmentSink_Forget(This)	\
    ( (This)->lpVtbl -> Forget(This) ) 

#define IDtcLuRmEnlistmentSink_Prepare(This)	\
    ( (This)->lpVtbl -> Prepare(This) ) 

#define IDtcLuRmEnlistmentSink_RequestCommit(This)	\
    ( (This)->lpVtbl -> RequestCommit(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcLuRmEnlistmentSink_INTERFACE_DEFINED__ */


#ifndef __IDtcLuRmEnlistmentFactory_INTERFACE_DEFINED__
#define __IDtcLuRmEnlistmentFactory_INTERFACE_DEFINED__

/* interface IDtcLuRmEnlistmentFactory */
/* [local][uuid][unique][object] */ 


EXTERN_C const IID IID_IDtcLuRmEnlistmentFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4131E771-1AEA-11d0-944B-00A0C905416E")
    IDtcLuRmEnlistmentFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ unsigned char *pucLuPair,
            /* [in] */ DWORD cbLuPair,
            /* [in] */ ITransaction *pITransaction,
            /* [in] */ unsigned char *pTransId,
            /* [in] */ DWORD cbTransId,
            /* [in] */ IDtcLuRmEnlistmentSink *pRmEnlistmentSink,
            /* [out][in] */ IDtcLuRmEnlistment **ppRmEnlistment) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcLuRmEnlistmentFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDtcLuRmEnlistmentFactory * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDtcLuRmEnlistmentFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDtcLuRmEnlistmentFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            IDtcLuRmEnlistmentFactory * This,
            /* [in] */ unsigned char *pucLuPair,
            /* [in] */ DWORD cbLuPair,
            /* [in] */ ITransaction *pITransaction,
            /* [in] */ unsigned char *pTransId,
            /* [in] */ DWORD cbTransId,
            /* [in] */ IDtcLuRmEnlistmentSink *pRmEnlistmentSink,
            /* [out][in] */ IDtcLuRmEnlistment **ppRmEnlistment);
        
        END_INTERFACE
    } IDtcLuRmEnlistmentFactoryVtbl;

    interface IDtcLuRmEnlistmentFactory
    {
        CONST_VTBL struct IDtcLuRmEnlistmentFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcLuRmEnlistmentFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcLuRmEnlistmentFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcLuRmEnlistmentFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcLuRmEnlistmentFactory_Create(This,pucLuPair,cbLuPair,pITransaction,pTransId,cbTransId,pRmEnlistmentSink,ppRmEnlistment)	\
    ( (This)->lpVtbl -> Create(This,pucLuPair,cbLuPair,pITransaction,pTransId,cbTransId,pRmEnlistmentSink,ppRmEnlistment) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcLuRmEnlistmentFactory_INTERFACE_DEFINED__ */


#ifndef __IDtcLuSubordinateDtc_INTERFACE_DEFINED__
#define __IDtcLuSubordinateDtc_INTERFACE_DEFINED__

/* interface IDtcLuSubordinateDtc */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IDtcLuSubordinateDtc;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4131E773-1AEA-11d0-944B-00A0C905416E")
    IDtcLuSubordinateDtc : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Unplug( 
            /* [in] */ BOOL fConversationLost) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BackedOut( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BackOut( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Committed( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Forget( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Prepare( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestCommit( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcLuSubordinateDtcVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDtcLuSubordinateDtc * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDtcLuSubordinateDtc * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDtcLuSubordinateDtc * This);
        
        HRESULT ( STDMETHODCALLTYPE *Unplug )( 
            __RPC__in IDtcLuSubordinateDtc * This,
            /* [in] */ BOOL fConversationLost);
        
        HRESULT ( STDMETHODCALLTYPE *BackedOut )( 
            __RPC__in IDtcLuSubordinateDtc * This);
        
        HRESULT ( STDMETHODCALLTYPE *BackOut )( 
            __RPC__in IDtcLuSubordinateDtc * This);
        
        HRESULT ( STDMETHODCALLTYPE *Committed )( 
            __RPC__in IDtcLuSubordinateDtc * This);
        
        HRESULT ( STDMETHODCALLTYPE *Forget )( 
            __RPC__in IDtcLuSubordinateDtc * This);
        
        HRESULT ( STDMETHODCALLTYPE *Prepare )( 
            __RPC__in IDtcLuSubordinateDtc * This);
        
        HRESULT ( STDMETHODCALLTYPE *RequestCommit )( 
            __RPC__in IDtcLuSubordinateDtc * This);
        
        END_INTERFACE
    } IDtcLuSubordinateDtcVtbl;

    interface IDtcLuSubordinateDtc
    {
        CONST_VTBL struct IDtcLuSubordinateDtcVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcLuSubordinateDtc_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcLuSubordinateDtc_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcLuSubordinateDtc_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcLuSubordinateDtc_Unplug(This,fConversationLost)	\
    ( (This)->lpVtbl -> Unplug(This,fConversationLost) ) 

#define IDtcLuSubordinateDtc_BackedOut(This)	\
    ( (This)->lpVtbl -> BackedOut(This) ) 

#define IDtcLuSubordinateDtc_BackOut(This)	\
    ( (This)->lpVtbl -> BackOut(This) ) 

#define IDtcLuSubordinateDtc_Committed(This)	\
    ( (This)->lpVtbl -> Committed(This) ) 

#define IDtcLuSubordinateDtc_Forget(This)	\
    ( (This)->lpVtbl -> Forget(This) ) 

#define IDtcLuSubordinateDtc_Prepare(This)	\
    ( (This)->lpVtbl -> Prepare(This) ) 

#define IDtcLuSubordinateDtc_RequestCommit(This)	\
    ( (This)->lpVtbl -> RequestCommit(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcLuSubordinateDtc_INTERFACE_DEFINED__ */


#ifndef __IDtcLuSubordinateDtcSink_INTERFACE_DEFINED__
#define __IDtcLuSubordinateDtcSink_INTERFACE_DEFINED__

/* interface IDtcLuSubordinateDtcSink */
/* [local][uuid][unique][object] */ 


EXTERN_C const IID IID_IDtcLuSubordinateDtcSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4131E774-1AEA-11d0-944B-00A0C905416E")
    IDtcLuSubordinateDtcSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AckUnplug( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TmDown( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SessionLost( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BackedOut( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BackOut( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Committed( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Forget( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestCommit( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcLuSubordinateDtcSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDtcLuSubordinateDtcSink * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDtcLuSubordinateDtcSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDtcLuSubordinateDtcSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *AckUnplug )( 
            IDtcLuSubordinateDtcSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *TmDown )( 
            IDtcLuSubordinateDtcSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *SessionLost )( 
            IDtcLuSubordinateDtcSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *BackedOut )( 
            IDtcLuSubordinateDtcSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *BackOut )( 
            IDtcLuSubordinateDtcSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *Committed )( 
            IDtcLuSubordinateDtcSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *Forget )( 
            IDtcLuSubordinateDtcSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *RequestCommit )( 
            IDtcLuSubordinateDtcSink * This);
        
        END_INTERFACE
    } IDtcLuSubordinateDtcSinkVtbl;

    interface IDtcLuSubordinateDtcSink
    {
        CONST_VTBL struct IDtcLuSubordinateDtcSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcLuSubordinateDtcSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcLuSubordinateDtcSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcLuSubordinateDtcSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcLuSubordinateDtcSink_AckUnplug(This)	\
    ( (This)->lpVtbl -> AckUnplug(This) ) 

#define IDtcLuSubordinateDtcSink_TmDown(This)	\
    ( (This)->lpVtbl -> TmDown(This) ) 

#define IDtcLuSubordinateDtcSink_SessionLost(This)	\
    ( (This)->lpVtbl -> SessionLost(This) ) 

#define IDtcLuSubordinateDtcSink_BackedOut(This)	\
    ( (This)->lpVtbl -> BackedOut(This) ) 

#define IDtcLuSubordinateDtcSink_BackOut(This)	\
    ( (This)->lpVtbl -> BackOut(This) ) 

#define IDtcLuSubordinateDtcSink_Committed(This)	\
    ( (This)->lpVtbl -> Committed(This) ) 

#define IDtcLuSubordinateDtcSink_Forget(This)	\
    ( (This)->lpVtbl -> Forget(This) ) 

#define IDtcLuSubordinateDtcSink_RequestCommit(This)	\
    ( (This)->lpVtbl -> RequestCommit(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcLuSubordinateDtcSink_INTERFACE_DEFINED__ */


#ifndef __IDtcLuSubordinateDtcFactory_INTERFACE_DEFINED__
#define __IDtcLuSubordinateDtcFactory_INTERFACE_DEFINED__

/* interface IDtcLuSubordinateDtcFactory */
/* [local][uuid][unique][object] */ 


EXTERN_C const IID IID_IDtcLuSubordinateDtcFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4131E775-1AEA-11d0-944B-00A0C905416E")
    IDtcLuSubordinateDtcFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ unsigned char *pucLuPair,
            /* [in] */ DWORD cbLuPair,
            /* [in] */ IUnknown *punkTransactionOuter,
            /* [in] */ ISOLEVEL isoLevel,
            /* [in] */ ULONG isoFlags,
            /* [in] */ ITransactionOptions *pOptions,
            /* [out] */ ITransaction **ppTransaction,
            /* [in] */ unsigned char *pTransId,
            /* [in] */ DWORD cbTransId,
            /* [in] */ IDtcLuSubordinateDtcSink *pSubordinateDtcSink,
            /* [out][in] */ IDtcLuSubordinateDtc **ppSubordinateDtc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDtcLuSubordinateDtcFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDtcLuSubordinateDtcFactory * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDtcLuSubordinateDtcFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDtcLuSubordinateDtcFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            IDtcLuSubordinateDtcFactory * This,
            /* [in] */ unsigned char *pucLuPair,
            /* [in] */ DWORD cbLuPair,
            /* [in] */ IUnknown *punkTransactionOuter,
            /* [in] */ ISOLEVEL isoLevel,
            /* [in] */ ULONG isoFlags,
            /* [in] */ ITransactionOptions *pOptions,
            /* [out] */ ITransaction **ppTransaction,
            /* [in] */ unsigned char *pTransId,
            /* [in] */ DWORD cbTransId,
            /* [in] */ IDtcLuSubordinateDtcSink *pSubordinateDtcSink,
            /* [out][in] */ IDtcLuSubordinateDtc **ppSubordinateDtc);
        
        END_INTERFACE
    } IDtcLuSubordinateDtcFactoryVtbl;

    interface IDtcLuSubordinateDtcFactory
    {
        CONST_VTBL struct IDtcLuSubordinateDtcFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDtcLuSubordinateDtcFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDtcLuSubordinateDtcFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDtcLuSubordinateDtcFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDtcLuSubordinateDtcFactory_Create(This,pucLuPair,cbLuPair,punkTransactionOuter,isoLevel,isoFlags,pOptions,ppTransaction,pTransId,cbTransId,pSubordinateDtcSink,ppSubordinateDtc)	\
    ( (This)->lpVtbl -> Create(This,pucLuPair,cbLuPair,punkTransactionOuter,isoLevel,isoFlags,pOptions,ppTransaction,pTransId,cbTransId,pSubordinateDtcSink,ppSubordinateDtc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDtcLuSubordinateDtcFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_txdtc_0000_0038 */
/* [local] */ 



#if _MSC_VER < 1100 || !defined(__cplusplus)

DEFINE_GUID(IID_IXATransLookup, 0xF3B1F131, 0xEEDA, 0x11ce, 0xAE, 0xD4, 0x00, 0xAA, 0x00, 0x51, 0xE2, 0xC4);
DEFINE_GUID(IID_IXATransLookup2,0xbf193c85, 0xd1a, 0x4290, 0xb8, 0x8f, 0xd2, 0xcb, 0x88, 0x73, 0xd1, 0xe7);
DEFINE_GUID(IID_IResourceManagerSink, 0x0D563181, 0xDEFB, 0x11ce, 0xAE, 0xD1, 0x00, 0xAA, 0x00, 0x51, 0xE2, 0xC4);
DEFINE_GUID(IID_IResourceManager, 0x3741d21, 0x87eb, 0x11ce, 0x80, 0x81, 0x00, 0x80, 0xc7, 0x58, 0x52, 0x7e);
DEFINE_GUID(IID_IResourceManager2, 0xd136c69a, 0xf749, 0x11d1, 0x8f, 0x47, 0x0, 0xc0, 0x4f, 0x8e, 0xe5, 0x7d);
DEFINE_GUID(IID_ILastResourceManager, 0x4d964ad4, 0x5b33, 0x11d3, 0x8a, 0x91, 0x00, 0xc0, 0x4f, 0x79, 0xeb, 0x6d);
DEFINE_GUID(IID_IXAConfig, 0xC8A6E3A1, 0x9A8C, 0x11cf, 0xA3, 0x08, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IRMHelper, 0xE793F6D1, 0xF53D, 0x11cf, 0xA6, 0x0D, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IXAObtainRMInfo, 0xE793F6D2, 0xF53D, 0x11cf, 0xA6, 0x0D, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IXAResourceManager, 0x4131E751, 0x1AEA, 0x11d0, 0x94, 0x4B, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IXAResourceManagerFactory, 0x4131E750, 0x1AEA, 0x11d0, 0x94, 0x4B, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IXATransaction, 0x4131E752, 0x1AEA, 0x11d0, 0x94, 0x4B, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IResourceManagerFactory, 0x13741d20, 0x87eb, 0x11ce, 0x80, 0x81, 0x00, 0x80, 0xc7, 0x58, 0x52, 0x7e);
DEFINE_GUID(IID_IResourceManagerFactory2, 0x6b369c21, 0xfbd2, 0x11d1, 0x8f, 0x47, 0x0, 0xc0, 0x4f, 0x8e, 0xe5, 0x7d);
DEFINE_GUID(IID_IPrepareInfo, 0x80c7bfd0, 0x87ee, 0x11ce, 0x80, 0x81, 0x00, 0x80, 0xc7, 0x58, 0x52, 0x7e);
DEFINE_GUID(IID_IPrepareInfo2, 0x5FAB2547, 0x9779, 0x11d1, 0xB8, 0x86, 0x00, 0xC0, 0x4F, 0xB9, 0x61, 0x8A);
DEFINE_GUID(IID_IGetDispenser, 0xc23cc370, 0x87ef, 0x11ce, 0x80, 0x81, 0x00, 0x80, 0xc7, 0x58, 0x52, 0x7e);
DEFINE_GUID(IID_ITransactionVoterNotifyAsync2, 0x5433376b, 0x414d, 0x11d3, 0xb2, 0x6, 0x0, 0xc0, 0x4f, 0xc2, 0xf3, 0xef);
DEFINE_GUID(IID_ITransactionVoterBallotAsync2, 0x5433376c, 0x414d, 0x11d3, 0xb2, 0x6, 0x0, 0xc0, 0x4f, 0xc2, 0xf3, 0xef);
DEFINE_GUID(IID_ITransactionVoterFactory2, 0x5433376a, 0x414d, 0x11d3, 0xb2, 0x6, 0x0, 0xc0, 0x4f, 0xc2, 0xf3, 0xef);
DEFINE_GUID(IID_ITransactionPhase0EnlistmentAsync, 0x82DC88E1, 0xA954, 0x11d1, 0x8F, 0x88, 0x00, 0x60, 0x08, 0x95, 0xE7, 0xD5);
DEFINE_GUID(IID_ITransactionPhase0NotifyAsync, 0xEF081809, 0x0C76, 0x11d2, 0x87, 0xA6, 0x00, 0xC0, 0x4F, 0x99, 0x0F, 0x34);
DEFINE_GUID(IID_ITransactionPhase0Factory, 0x82DC88E0, 0xA954, 0x11d1, 0x8F, 0x88, 0x00, 0x60, 0x08, 0x95, 0xE7, 0xD5);
DEFINE_GUID(IID_ITransactionTransmitter, 0x59313E01, 0xB36C, 0x11cf, 0xA5, 0x39, 0x00, 0xAA, 0x00, 0x68, 0x87, 0xC3);
DEFINE_GUID(IID_ITransactionTransmitterFactory, 0x59313E00, 0xB36C, 0x11cf, 0xA5, 0x39, 0x00, 0xAA, 0x00, 0x68, 0x87, 0xC3);
DEFINE_GUID(IID_ITransactionReceiver, 0x59313E03, 0xB36C, 0x11cf, 0xA5, 0x39, 0x00, 0xAA, 0x00, 0x68, 0x87, 0xC3);
DEFINE_GUID(IID_ITransactionReceiverFactory, 0x59313E02, 0xB36C, 0x11cf, 0xA5, 0x39, 0x00, 0xAA, 0x00, 0x68, 0x87, 0xC3);

DEFINE_GUID(IID_IDtcLuConfigure, 0x4131E760, 0x1AEA, 0x11d0, 0x94, 0x4B, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IDtcLuRecovery, 0xac2b8ad2, 0xd6f0, 0x11d0, 0xb3, 0x86, 0x0, 0xa0, 0xc9, 0x8, 0x33, 0x65);
DEFINE_GUID(IID_IDtcLuRecoveryFactory, 0x4131E762, 0x1AEA, 0x11d0, 0x94, 0x4B, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IDtcLuRecoveryInitiatedByDtcTransWork, 0x4131E765, 0x1AEA, 0x11d0, 0x94, 0x4B, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IDtcLuRecoveryInitiatedByDtcStatusWork, 0x4131E766, 0x1AEA, 0x11d0, 0x94, 0x4B, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IDtcLuRecoveryInitiatedByDtc, 0x4131E764, 0x1AEA, 0x11d0, 0x94, 0x4B, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IDtcLuRecoveryInitiatedByLuWork, 0xac2b8ad1, 0xd6f0, 0x11d0, 0xb3, 0x86, 0x0, 0xa0, 0xc9, 0x8, 0x33, 0x65);
DEFINE_GUID(IID_IDtcLuRecoveryInitiatedByLu, 0x4131E768, 0x1AEA, 0x11d0, 0x94, 0x4B, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IDtcLuRmEnlistment, 0x4131E769, 0x1AEA, 0x11d0, 0x94, 0x4B, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IDtcLuRmEnlistmentSink, 0x4131E770, 0x1AEA, 0x11d0, 0x94, 0x4B, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IDtcLuRmEnlistmentFactory, 0x4131E771, 0x1AEA, 0x11d0, 0x94, 0x4B, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IDtcLuSubordinateDtc, 0x4131E773, 0x1AEA, 0x11d0, 0x94, 0x4B, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IDtcLuSubordinateDtcSink, 0x4131E774, 0x1AEA, 0x11d0, 0x94, 0x4B, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);
DEFINE_GUID(IID_IDtcLuSubordinateDtcFactory, 0x4131E775, 0x1AEA, 0x11d0, 0x94, 0x4B, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x6E);

#else

#define  IID_IXATransLookup                          __uuidof(IXATransLookup)
#define  IID_IXATransLookup2                         __uuidof(IXATransLookup2)
#define  IID_IResourceManagerSink                    __uuidof(IResourceManagerSink)
#define  IID_IResourceManager                        __uuidof(IResourceManager)
#define  IID_IResourceManager2                       __uuidof(IResourceManager2)
#define  IID_ILastResourceManager                    __uuidof(ILastResourceManager)
#define  IID_IXAConfig                               __uuidof(IXAConfig)
#define  IID_IRMHelper                               __uuidof(IRMHelper)
#define  IID_IXAObtainRMInfo                         __uuidof(IXAObtainRMInfo)
#define  IID_IXAResourceManager                      __uuidof(IXAResourceManager)
#define  IID_IXAResourceManagerFactory               __uuidof(IXAResourceManagerFactory)
#define  IID_IXATransaction                          __uuidof(IXATransaction)
#define  IID_IResourceManagerFactory                 __uuidof(IResourceManagerFactory)
#define  IID_IResourceManagerFactory2                __uuidof(IResourceManagerFactory2)
#define  IID_IPrepareInfo                            __uuidof(IPrepareInfo)
#define  IID_IPrepareInfo2                           __uuidof(IPrepareInfo2)
#define  IID_IGetDispenser                           __uuidof(IGetDispenser)
#define  IID_ITransactionVoterNotifyAsync2           __uuidof(ITransactionVoterNotifyAsync2)
#define  IID_ITransactionVoterBallotAsync2           __uuidof(ITransactionVoterBallotAsync2)
#define  IID_ITransactionVoterFactory2               __uuidof(ITransactionVoterFactory2)
#define  IID_ITransactionPhase0EnlistmentAsync       __uuidof(ITransactionPhase0EnlistmentAsync)
#define  IID_ITransactionPhase0NotifyAsync           __uuidof(ITransactionPhase0NotifyAsync)
#define  IID_ITransactionPhase0Factory               __uuidof(ITransactionPhase0Factory)
#define  IID_ITransactionTransmitter                 __uuidof(ITransactionTransmitter)
#define  IID_ITransactionTransmitterFactory          __uuidof(ITransactionTransmitterFactory)
#define  IID_ITransactionReceiver                    __uuidof(ITransactionReceiver)
#define  IID_ITransactionReceiverFactory             __uuidof(ITransactionReceiverFactory)

#define  IID_IDtcLuConfigure                         __uuidof(IDtcLuConfigure)
#define  IID_IDtcLuRecovery                          __uuidof(IDtcLuRecovery)
#define  IID_IDtcLuRecoveryFactory                   __uuidof(IDtcLuRecoveryFactory)
#define  IID_IDtcLuRecoveryInitiatedByDtcTransWork   __uuidof(IDtcLuRecoveryInitiatedByDtcTransWork)
#define  IID_IDtcLuRecoveryInitiatedByDtcStatusWork  __uuidof(IDtcLuRecoveryInitiatedByDtcStatusWork)
#define  IID_IDtcLuRecoveryInitiatedByDtc            __uuidof(IDtcLuRecoveryInitiatedByDtc)
#define  IID_IDtcLuRecoveryInitiatedByLuWork         __uuidof(IDtcLuRecoveryInitiatedByLuWork)
#define  IID_IDtcLuRecoveryInitiatedByLu             __uuidof(IDtcLuRecoveryInitiatedByLu)
#define  IID_IDtcLuRmEnlistment                      __uuidof(IDtcLuRmEnlistment)
#define  IID_IDtcLuRmEnlistmentSink                  __uuidof(IDtcLuRmEnlistmentSink)
#define  IID_IDtcLuRmEnlistmentFactory               __uuidof(IDtcLuRmEnlistmentFactory)
#define  IID_IDtcLuSubordinateDtc                    __uuidof(IDtcLuSubordinateDtc)
#define  IID_IDtcLuSubordinateDtcSink                __uuidof(IDtcLuSubordinateDtcSink)
#define  IID_IDtcLuSubordinateDtcFactory             __uuidof(IDtcLuSubordinateDtcFactory)

#endif
#pragma deprecated (IXAConfig)


extern RPC_IF_HANDLE __MIDL_itf_txdtc_0000_0038_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_txdtc_0000_0038_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\txfw32.h ===
/*=============================================================================

    Copyright (c) 2002  Microsoft Corporation

    Module Name:

        Txfw32.h

    Abstract:

        Header for the exported API set for the Txf Win32
        API dynamic link library.

    Author:

        Jacob Lacouture [jacobl] May 9, 2002

    Environment:

        User Mode

    Revision History:


=============================================================================*/


#include <clfsw32.h>

#ifndef _TXF_W32_H_INCLUDED_
#define _TXF_W32_H_INCLUDED_


//
//  These are the different types of replication records that may be read from the log.
//

#define TXF_LOG_RECORD_TYPE_WRITE           0x01
#define TXF_LOG_RECORD_TYPE_TRUNCATE        0x02
#define TXF_LOG_RECORD_TYPE_AFFECTED_FILE   0x04

#define TXF_LOG_RECORD_GENERIC_TYPE_COMMIT  0x01
#define TXF_LOG_RECORD_GENERIC_TYPE_ABORT   0x02
#define TXF_LOG_RECORD_GENERIC_TYPE_PREPARE 0x04
#define TXF_LOG_RECORD_GENERIC_TYPE_DATA    0x08

//
//  Define alignment for all replication records.
//

#pragma pack(4)


//
//  The TXF_ID is exposed as a 128 bit structure.  This should NOT be treated as a GUID, in
//  that this is a unique identifier only within the context of the RM.  These may collide
//  between different RMs.
//


typedef struct _TXF_ID {
    struct {
        LONGLONG LowPart;
        LONGLONG HighPart;
    };
} TXF_ID, *PTXF_ID;

typedef GUID *PGUID;


//
//  This is the basic record.  If the entire record cannot be copied into the user's buffer,
//  at least this much may be copied if the buffer is big enough, so that the user can 
//  determine how large a buffer he needs.
//

typedef struct _TXF_LOG_RECORD_BASE {
    
    //
    //  This is a version identifier for the replication record generated by TXF.
    //

    USHORT Version;

    //
    //  Type of record, defined above.
    //
        
    USHORT RecordType;

    //
    //  Length of this record in bytes.
    //

    ULONG RecordLength;

} TXF_LOG_RECORD_BASE, *PTXF_LOG_RECORD_BASE;

//
//  This indicates a write.  If this write goes beyond the end of the file, that implies
//  an extension of the file.
//

typedef struct _TXF_LOG_RECORD_WRITE {

    //
    //  This is a version identifier for the replication record generated by TXF.
    //

    USHORT Version;

    //
    //  Type of record, defined above.
    //
        
    USHORT RecordType;

    //
    //  Length of this record in bytes.
    //

    ULONG RecordLength;

    //
    //  Record flags.  (none currently defined)
    //

    ULONG Flags;

    //
    //  TxfFileId for the file this record refers to.
    //

    TXF_ID TxfFileId;

    //
    //  This is the KTM transaction GUID for this update.
    //

    GUID KtmGuid;

    //
    //  Beginning location of the write, as an offset from the beginning of the file.
    //

    LONGLONG ByteOffsetInFile;

    //
    //  Number of bytes written.
    //

    ULONG NumBytesWritten;

    //
    //  Offset of the redo data (bytes written) from the beginning of this record.
    //
    
    ULONG ByteOffsetInStructure;
    
    //
    //  Length of the file name, in bytes.
    //

    ULONG FileNameLength;

    //
    //  Offset of the file name from the beginning of this record.
    //

    ULONG FileNameByteOffsetInStructure;


} TXF_LOG_RECORD_WRITE, *PTXF_LOG_RECORD_WRITE;

//
//  This is a truncate record.
//

typedef struct _TXF_LOG_RECORD_TRUNCATE {

    //
    //  This is a version identifier for the replication record generated by TXF.
    //

    USHORT Version;

    //
    //  Type of record, defined above.
    //
        
    USHORT RecordType;

    //
    //  Length of this record in bytes.
    //

    ULONG RecordLength;

    //
    //  Record flags.  (none currently defined)
    //

    ULONG Flags;

    //
    //  TxfFileId for the file this record refers to.
    //

    TXF_ID TxfFileId;

    //
    //  This is the KTM transaction GUID for this update.
    //

    GUID KtmGuid;

    //
    //  New size of the file.
    //

    LONGLONG NewFileSize;

    //
    //  Length of the file name, in bytes.
    //

    ULONG FileNameLength;

    //
    //  Offset of the file name from the beginning of this record.
    //

    ULONG FileNameByteOffsetInStructure;

} TXF_LOG_RECORD_TRUNCATE, *PTXF_LOG_RECORD_TRUNCATE;

//
//  This structure describes a file that was affected by
//  a transaction in a given virtual clock range.
//

typedef struct _TXF_LOG_RECORD_AFFECTED_FILE {

    //
    //  This is a version identifier for the replication record generated by TXF.
    //

    USHORT Version;

    //
    //  Length of this record in bytes.
    //

    ULONG RecordLength;

    //
    //  Record flags.  (none currently defined)
    //

    ULONG Flags;

    //
    //  TxfFileId for the file this record refers to.
    //

    TXF_ID TxfFileId;

    //
    //  This is the KTM transaction GUID for this update.
    //

    GUID KtmGuid;

    //
    //  Length of the file name, in bytes.
    //

    ULONG FileNameLength;

    //
    //  Offset of the file name from the beginning of this record.
    //

    ULONG FileNameByteOffsetInStructure;

} TXF_LOG_RECORD_AFFECTED_FILE, *PTXF_LOG_RECORD_AFFECTED_FILE;

#pragma pack()


//
//  The following are implemented in the TxfW32.dll module
//
#ifdef __cplusplus
extern "C" {
#endif

BOOL 
WINAPI
TxfLogCreateFileReadContext (
    __in LPCWSTR LogPath,
    __in CLFS_LSN BeginningLsn,
    __in CLFS_LSN EndingLsn,
    __in PTXF_ID TxfFileId,
    __deref_out PVOID *TxfLogContext
    );
/*

  Description:

    This context will be required to read any replication records.  In order to recover 
    resources, the context must later be closed by calling TxfLogDestroyReadContext.  
    Since the resources are allocated by a user-mode process, if that routine is not called, 
    the resources will be recovered automatically when the process hosting the DLL terminates.

  Parameter Definition:

    LogPath               - Location of the RM's CLFS BLF.

    BeginningLsn          - Start of LSN range to search. (inclusive)

    EndingLsn             - End of LSN range to search. (inclusive)

    TxfFileId             - TxfId to scan the log for.

    TxfLogContext - Pointer to new TxfLogContext

*/


BOOL 
WINAPI
TxfLogCreateRangeReadContext (
    __in LPCWSTR LogPath,
    __in CLFS_LSN BeginningLsn,
    __in CLFS_LSN EndingLsn,
    __in PLARGE_INTEGER BeginningVirtualClock,
    __in PLARGE_INTEGER EndingVirtualClock,
    __in ULONG RecordTypeMask,
    __deref_out PVOID *TxfLogContext
    );
/*

  Description:

    This context will be required to read any replication records.  In order to recover 
    resources, the context must later be closed by calling TxfLogDestroyReadContext.  
    Since the resources are allocated by a user-mode process, if that routine is not called, 
    the resources will be recovered automatically when the process hosting the DLL terminates.

  Parameter Definition:

    LogPath               - Location of the RM's CLFS BLF.

    BeginningLsn          - Start of LSN range to search. (inclusive)

    EndingLsn             - End of LSN range to search. (inclusive)

    TxfFileId             - TxfId to scan the log for.

    TxfLogContext - Pointer to new TxfLogContext

*/

BOOL 
WINAPI
TxfLogDestroyReadContext (
    __in PVOID TxfLogContext
    );
/*

  Description:

    See comments for TxfLogCreateReadContext

  Parameter Definition:

    TxfLogContext - Pointer to TxfLogContext to destroy.
  
*/


BOOL
WINAPI
TxfLogReadRecords (
    __in PVOID TxfLogContext,
    __in ULONG BufferLength,
    __out_bcount_part(BufferLength, *BytesUsed) PVOID Buffer,
    __out PULONG BytesUsed,
    __out PULONG RecordCount
    );
/*
  Description:

    If all of the available records were copied into the buffer, TRUE will be returned.  
    Otherwise, the return value will be FALSE.  If FALSE is returned, LastError should 
    be checked.

    Possible values for LastError are:

        ERROR_INVALID_HANDLE - The replication context is invalid.

        ERROR_MORE_DATA - Some records were copied into the buffer. 
            This routine should be called again to retrieve the rest.

        ERROR_INSUFFICIENT_BUFFER - There wasn't sufficient buffer 
            space to even copy one record.  If this is set, check the
            value of BytesUsed.  If this is nonzero, then there was 
            enough space to copy the TXF_LOG_RECORD_BASE
            record, which indicates how large a buffer is needed to
            read the next complete record.  Call back with a buffer 
            at least that size.  If BytesUsed is zero, the buffer
            provided to this routine was far too small.  Try again
            with a larger buffer.

        ERROR_FILE_CORRUPT - The format of the log file being 
            processed is unrecognized.

        Other error codes may be returned by CLFS.

    --------------------------------------------------------------------------------------
    NOTE: This routine will return all redo records in the log except for CLRs.  This 
          means that the replication client must be intelligent enough to discard records
          for transactions that will ultimately abort.  We provide the KTM GUID in each
          replication record to assist in this filtering.  Alternatively, the replication
          client could query the last LSN after each abort and commit are complete.  The
          scan could then be done only for ranges in which all the records are for 
          committed transactions.
    --------------------------------------------------------------------------------------

  Parameter Definition:

    TxfLogContext - Pointer to TxfLogContext

    BufferLength          - Length of buffer passed to this routine (in bytes)

    Buffer                - Address of buffer to copy records into.

    BytesUsed             - Amount of buffer actually used.

    RecordCount           - Number of records copied into the buffer.

*/


BOOL
WINAPI
TxfReadMetadataInfo (
    __in HANDLE FileHandle,
    __out PTXF_ID TxfFileId,
    __out PCLFS_LSN LastLsn,
    __out PULONG TransactionState,
    __out PGUID LockingTransaction
    );
/*
  Description:

    This routine will retrieve the TxfFileId, most recent LSN, and locking transaction (if
    applicable) for the specified file.  If the file has not had any transacted work done on
    it, it will have none of these properties and this call will return failure.

  Parameter Definition:

    FileHandle  - File to read the information for.

    TxfFileId   - Returned TxfId of the file.

    LastLsn     - Returned LastLsn for the file.

    TransactionState    - The state of the transaction locking this file.

    LockingTransaction  - If TransactionState != TXFS_TRANSACTION_STATE_NONE, the GUID of
                          the transaction locking the file.  Otherwise, this value has no
                          meaning.

*/


BOOL
WINAPI
TxfLogRecordGetFileName (
    __in_bcount(RecordBufferLengthInBytes) PVOID RecordBuffer,
    __in ULONG RecordBufferLengthInBytes,
    __out_bcount(NameBufferLengthInBytes) PWSTR NameBuffer,
    __inout PULONG NameBufferLengthInBytes,
    __out_opt PTXF_ID TxfId 
    );
/*
  Description:

    This routine will decode a TXF log record and copy the name of
    the file referred to by the record and optionally the TXF ID 
    for it.    

  Parameter Definition:

    RecordBuffer - The TXF log record.

    RecordBufferLengthInBytes - Length of RecordBuffer.

    NameBuffer - Returned name of the file referred to by RecordBuffer.

    NameBuffer - Supplied length of NameBuffer and returned length or
                 required length if buffer is too short.

    TxfFileId   - Returned TxfId of the file.

*/
    

BOOL
WINAPI
TxfLogRecordGetGenericType (
    __in PVOID RecordBuffer,
    __in ULONG RecordBufferLengthInBytes,
    __out PULONG GenericType,
    __out_opt PLARGE_INTEGER VirtualClock 
    );
/*
  Description:

    This routine will decode a TXF log record and determine what type
    of record it is (commit, undo, etc.).  If the type has a virtual
    clock associated with it, then that is returned as well.
    
  Parameter Definition:

    RecordBuffer - The TXF log record.

    RecordBufferLengthInBytes - Length of RecordBuffer.

    GenericType - Returned type of record.

    VirtualClock - Virtual clock if the type has one (0 if not present).

*/


VOID
WINAPI
TxfSetThreadMiniVersionForCreate (
    __in USHORT MiniVersion
    );
/*
  Description:

    This routine is used to set the MiniVersion that a subsequent create should open.
    It should be returned to its previous state after calling create.  Therefore, prior
    to calling this routine, the caller should invoke TxfGetThreadMiniVersionForCreate.

  Parameter Definition:

    MiniVersion - A USHORT identifying which version should be opened by create.

*/

VOID
WINAPI
TxfGetThreadMiniVersionForCreate (
    __out PUSHORT MiniVersion
    );
/*
  Description:

    This routine returns what MiniVersion a subsequent create is set to open.

  Parameter Definition:

    MiniVersion - Pointer to a USHORT which will receive the result.

*/


//
//  Either of these constants may be used to identify the miniversion to open.
//

#define TXFS_MINIVERSION_COMMITTED_VIEW                  (0x0000)
#define TXFS_MINIVERSION_DIRTY_VIEW                      (0xFFFF)
#define TXFS_MINIVERSION_DEFAULT_VIEW                    (0xFFFE)



#ifdef __cplusplus
//
//  extern "C"
//
}
#endif



//_TXF_W32_H_INCLUDED_
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\udpmib.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    udpmib.h

Abstract:

    This module contains the public definitions and structures for the
    UDP-specific parts of MIB-II.  These definitions were previously
    in iprtrmib.h, which now includes this file.

Environment:

    user mode or kernel mode

--*/

#ifndef _UDPMIB_
#define _UDPMIB_
#pragma once

#ifndef ANY_SIZE
#define ANY_SIZE 1
#endif

#define TCPIP_OWNING_MODULE_SIZE 16

typedef struct _MIB_UDPROW {
    DWORD dwLocalAddr;
    DWORD dwLocalPort;
} MIB_UDPROW, *PMIB_UDPROW;

typedef struct _MIB_UDPTABLE {
    DWORD dwNumEntries;
    MIB_UDPROW table[ANY_SIZE];
} MIB_UDPTABLE, *PMIB_UDPTABLE;

#define SIZEOF_UDPTABLE(X) (FIELD_OFFSET(MIB_UDPTABLE, table[0]) + \
						    ((X) * sizeof(MIB_UDPROW)) + ALIGN_SIZE)

typedef struct _MIB_UDPROW_OWNER_PID {
    DWORD dwLocalAddr;
    DWORD dwLocalPort;
    DWORD dwOwningPid;
} MIB_UDPROW_OWNER_PID, *PMIB_UDPROW_OWNER_PID;

typedef struct _MIB_UDPTABLE_OWNER_PID
{
    DWORD                   dwNumEntries;
    MIB_UDPROW_OWNER_PID    table[ANY_SIZE];
} MIB_UDPTABLE_OWNER_PID, *PMIB_UDPTABLE_OWNER_PID;

#define SIZEOF_UDPTABLE_OWNER_PID(X) (FIELD_OFFSET(MIB_UDPTABLE_OWNER_PID, table[0]) + \
									  ((X) * sizeof(MIB_UDPROW_OWNER_PID)) + ALIGN_SIZE)

typedef struct _MIB_UDPROW_OWNER_MODULE {
    DWORD           dwLocalAddr;
    DWORD           dwLocalPort;
    DWORD           dwOwningPid;
    LARGE_INTEGER   liCreateTimestamp;
    union {
        struct {
            int     SpecificPortBind : 1;
        };
        int         dwFlags;
    };
    ULONGLONG       OwningModuleInfo[TCPIP_OWNING_MODULE_SIZE];
} MIB_UDPROW_OWNER_MODULE, *PMIB_UDPROW_OWNER_MODULE;

typedef struct _MIB_UDPTABLE_OWNER_MODULE
{
    DWORD                   dwNumEntries;
    MIB_UDPROW_OWNER_MODULE table[ANY_SIZE];
} MIB_UDPTABLE_OWNER_MODULE, *PMIB_UDPTABLE_OWNER_MODULE;

#define SIZEOF_UDPTABLE_OWNER_MODULE(X) (FIELD_OFFSET(MIB_UDPTABLE_OWNER_MODULE, table[0]) + \
										 ((X) * sizeof(MIB_UDPROW_OWNER_MODULE)) + ALIGN_SIZE)

#ifdef _WS2IPDEF_
//
// The following definitions require Winsock2.
//

typedef struct _MIB_UDP6ROW {
    IN6_ADDR dwLocalAddr;
    DWORD dwLocalScopeId;
    DWORD dwLocalPort;
} MIB_UDP6ROW, *PMIB_UDP6ROW;

typedef struct _MIB_UDP6TABLE {
    DWORD dwNumEntries;
    MIB_UDP6ROW table[ANY_SIZE];
} MIB_UDP6TABLE, *PMIB_UDP6TABLE;

#define SIZEOF_UDP6TABLE(X) (FIELD_OFFSET(MIB_UDP6TABLE, table[0]) + \
							 ((X) * sizeof(MIB_UDP6ROW)) + ALIGN_SIZE)

typedef struct _MIB_UDP6ROW_OWNER_PID {
    UCHAR           ucLocalAddr[16];
    DWORD           dwLocalScopeId;
    DWORD           dwLocalPort;
    DWORD           dwOwningPid;
} MIB_UDP6ROW_OWNER_PID, *PMIB_UDP6ROW_OWNER_PID;

typedef struct _MIB_UDP6TABLE_OWNER_PID
{
    DWORD                   dwNumEntries;
    MIB_UDP6ROW_OWNER_PID   table[ANY_SIZE];
} MIB_UDP6TABLE_OWNER_PID, *PMIB_UDP6TABLE_OWNER_PID;

#define SIZEOF_UDP6TABLE_OWNER_PID(X) (FIELD_OFFSET(MIB_UDP6TABLE_OWNER_PID, table[0]) + \
									   ((X) * sizeof(MIB_UDP6ROW_OWNER_PID)) + ALIGN_SIZE)

typedef struct _MIB_UDP6ROW_OWNER_MODULE {
    UCHAR           ucLocalAddr[16];
    DWORD           dwLocalScopeId;
    DWORD           dwLocalPort;
    DWORD           dwOwningPid;
    LARGE_INTEGER   liCreateTimestamp;
    union {
        struct {
            int     SpecificPortBind : 1;
        };
        int         dwFlags;
    };
    ULONGLONG       OwningModuleInfo[TCPIP_OWNING_MODULE_SIZE];
} MIB_UDP6ROW_OWNER_MODULE, *PMIB_UDP6ROW_OWNER_MODULE;

typedef struct _MIB_UDP6TABLE_OWNER_MODULE
{
    DWORD                    dwNumEntries;
    MIB_UDP6ROW_OWNER_MODULE table[ANY_SIZE];
} MIB_UDP6TABLE_OWNER_MODULE, *PMIB_UDP6TABLE_OWNER_MODULE;

#define SIZEOF_UDP6TABLE_OWNER_MODULE(X) (FIELD_OFFSET(MIB_UDP6TABLE_OWNER_MODULE, table[0]) + \
										  ((X) * sizeof(MIB_UDP6ROW_OWNER_MODULE)) + ALIGN_SIZE)

#endif // _WS2IPDEF_

typedef struct _MIB_UDPSTATS {
    DWORD dwInDatagrams;
    DWORD dwNoPorts;
    DWORD dwInErrors;
    DWORD dwOutDatagrams;
    DWORD dwNumAddrs;
} MIB_UDPSTATS,*PMIB_UDPSTATS;

#endif // _UDPMIB_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\txlogpub.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for txlogpub.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __txlogpub_h__
#define __txlogpub_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ILog_FWD_DEFINED__
#define __ILog_FWD_DEFINED__
typedef interface ILog ILog;
#endif 	/* __ILog_FWD_DEFINED__ */


#ifndef __IFileBasedLogInit_FWD_DEFINED__
#define __IFileBasedLogInit_FWD_DEFINED__
typedef interface IFileBasedLogInit IFileBasedLogInit;
#endif 	/* __IFileBasedLogInit_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_txlogpub_0000_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------


// LSN
// LSN is the fundamental cookie returned from the log as the name of a
// newly-written  log record. LSNs from successively written records to a
// given log are always monotonically increasing. LSNs are directly
// comparable: lsn2 is later in the log than lsn1 if and only if as integers
// lsn2 > lsn1.
//
// Neither the value zero nor the value MAXLSN are ever used as the value of
// an actual LSN.

typedef LARGE_INTEGER LSN;

#define MAXLSN (0x7FFFFFFFFFFFFFFF)


// RECORD_READING_POLICY
// The RECORD_READING_POLICY enumeration values specify a hint about the
// order in which records will be read from a log.  It is used by
// ILog::SetAccessPolicyHint.

typedef 
enum RECORD_READING_POLICY
    {	RECORD_READING_POLICY_FORWARD	= 1,
	RECORD_READING_POLICY_BACKWARD	= 2,
	RECORD_READING_POLICY_RANDOM	= 3
    } 	RECORD_READING_POLICY;



// ILog
// An interface to the lowest level of a log implementation. This level
// takes care of writing the records to disk in a stable manner. Recovery
// protocols, transaction awareness, and the like are provided by a higher
// semantic level.


extern RPC_IF_HANDLE __MIDL_itf_txlogpub_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_txlogpub_0000_0000_v0_0_s_ifspec;

#ifndef __ILog_INTERFACE_DEFINED__
#define __ILog_INTERFACE_DEFINED__

/* interface ILog */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ILog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FF222117-0C6C-11d2-B89A-00C04FB9618A")
    ILog : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Force( 
            /* [in] */ LSN lsnMinToForce) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppendRecord( 
            /* [size_is][in] */ __RPC__in_ecount_full(cBlob) BLOB *rgBlob,
            /* [in] */ ULONG cBlob,
            /* [in] */ BOOL fForceNow,
            /* [unique][in][out] */ __RPC__inout_opt LSN *plsn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadRecord( 
            /* [in] */ LSN lsnToRead,
            /* [unique][in][out] */ __RPC__inout_opt LSN *plsnPrev,
            /* [unique][in][out] */ __RPC__inout_opt LSN *plsnNext,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcbData) BYTE **ppbData,
            /* [out] */ __RPC__out ULONG *pcbData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadRecordPrefix( 
            /* [in] */ LSN lsnToRead,
            /* [unique][in][out] */ __RPC__inout_opt LSN *plsnPrev,
            /* [unique][in][out] */ __RPC__inout_opt LSN *plsnNext,
            /* [size_is][out] */ __RPC__out_ecount_full(*pcbData) BYTE *pbData,
            /* [out][in] */ __RPC__inout ULONG *pcbData,
            /* [out] */ __RPC__out ULONG *pcbRecord) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLogLimits( 
            /* [unique][in][out] */ __RPC__inout_opt LSN *plsnFirst,
            /* [unique][in][out] */ __RPC__inout_opt LSN *plsnLast) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TruncatePrefix( 
            /* [in] */ LSN lsnFirstToKeep) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAccessPolicyHint( 
            /* [in] */ RECORD_READING_POLICY policy) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ILog * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ILog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ILog * This);
        
        HRESULT ( STDMETHODCALLTYPE *Force )( 
            __RPC__in ILog * This,
            /* [in] */ LSN lsnMinToForce);
        
        HRESULT ( STDMETHODCALLTYPE *AppendRecord )( 
            __RPC__in ILog * This,
            /* [size_is][in] */ __RPC__in_ecount_full(cBlob) BLOB *rgBlob,
            /* [in] */ ULONG cBlob,
            /* [in] */ BOOL fForceNow,
            /* [unique][in][out] */ __RPC__inout_opt LSN *plsn);
        
        HRESULT ( STDMETHODCALLTYPE *ReadRecord )( 
            __RPC__in ILog * This,
            /* [in] */ LSN lsnToRead,
            /* [unique][in][out] */ __RPC__inout_opt LSN *plsnPrev,
            /* [unique][in][out] */ __RPC__inout_opt LSN *plsnNext,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcbData) BYTE **ppbData,
            /* [out] */ __RPC__out ULONG *pcbData);
        
        HRESULT ( STDMETHODCALLTYPE *ReadRecordPrefix )( 
            __RPC__in ILog * This,
            /* [in] */ LSN lsnToRead,
            /* [unique][in][out] */ __RPC__inout_opt LSN *plsnPrev,
            /* [unique][in][out] */ __RPC__inout_opt LSN *plsnNext,
            /* [size_is][out] */ __RPC__out_ecount_full(*pcbData) BYTE *pbData,
            /* [out][in] */ __RPC__inout ULONG *pcbData,
            /* [out] */ __RPC__out ULONG *pcbRecord);
        
        HRESULT ( STDMETHODCALLTYPE *GetLogLimits )( 
            __RPC__in ILog * This,
            /* [unique][in][out] */ __RPC__inout_opt LSN *plsnFirst,
            /* [unique][in][out] */ __RPC__inout_opt LSN *plsnLast);
        
        HRESULT ( STDMETHODCALLTYPE *TruncatePrefix )( 
            __RPC__in ILog * This,
            /* [in] */ LSN lsnFirstToKeep);
        
        HRESULT ( STDMETHODCALLTYPE *SetAccessPolicyHint )( 
            __RPC__in ILog * This,
            /* [in] */ RECORD_READING_POLICY policy);
        
        END_INTERFACE
    } ILogVtbl;

    interface ILog
    {
        CONST_VTBL struct ILogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILog_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ILog_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ILog_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ILog_Force(This,lsnMinToForce)	\
    ( (This)->lpVtbl -> Force(This,lsnMinToForce) ) 

#define ILog_AppendRecord(This,rgBlob,cBlob,fForceNow,plsn)	\
    ( (This)->lpVtbl -> AppendRecord(This,rgBlob,cBlob,fForceNow,plsn) ) 

#define ILog_ReadRecord(This,lsnToRead,plsnPrev,plsnNext,ppbData,pcbData)	\
    ( (This)->lpVtbl -> ReadRecord(This,lsnToRead,plsnPrev,plsnNext,ppbData,pcbData) ) 

#define ILog_ReadRecordPrefix(This,lsnToRead,plsnPrev,plsnNext,pbData,pcbData,pcbRecord)	\
    ( (This)->lpVtbl -> ReadRecordPrefix(This,lsnToRead,plsnPrev,plsnNext,pbData,pcbData,pcbRecord) ) 

#define ILog_GetLogLimits(This,plsnFirst,plsnLast)	\
    ( (This)->lpVtbl -> GetLogLimits(This,plsnFirst,plsnLast) ) 

#define ILog_TruncatePrefix(This,lsnFirstToKeep)	\
    ( (This)->lpVtbl -> TruncatePrefix(This,lsnFirstToKeep) ) 

#define ILog_SetAccessPolicyHint(This,policy)	\
    ( (This)->lpVtbl -> SetAccessPolicyHint(This,policy) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ILog_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_txlogpub_0000_0001 */
/* [local] */ 



// IFileBasedLogInit
// An interface used to initialize an instance of a file based implementation of
// ILog.  This interface defines the single method InitNew, which is used to
// create a log on a new log file.  Objects that implement IFileBasedLogInit
// should also implement IPersistFile, to allow existing log files to be opened.


extern RPC_IF_HANDLE __MIDL_itf_txlogpub_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_txlogpub_0000_0001_v0_0_s_ifspec;

#ifndef __IFileBasedLogInit_INTERFACE_DEFINED__
#define __IFileBasedLogInit_INTERFACE_DEFINED__

/* interface IFileBasedLogInit */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IFileBasedLogInit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00951E8C-1294-11d1-97E4-00C04FB9618A")
    IFileBasedLogInit : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitNew( 
            /* [in] */ __RPC__in LPCWSTR filename,
            /* [in] */ ULONG cbCapacityHint) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileBasedLogInitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IFileBasedLogInit * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IFileBasedLogInit * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IFileBasedLogInit * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitNew )( 
            __RPC__in IFileBasedLogInit * This,
            /* [in] */ __RPC__in LPCWSTR filename,
            /* [in] */ ULONG cbCapacityHint);
        
        END_INTERFACE
    } IFileBasedLogInitVtbl;

    interface IFileBasedLogInit
    {
        CONST_VTBL struct IFileBasedLogInitVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileBasedLogInit_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileBasedLogInit_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileBasedLogInit_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileBasedLogInit_InitNew(This,filename,cbCapacityHint)	\
    ( (This)->lpVtbl -> InitNew(This,filename,cbCapacityHint) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileBasedLogInit_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_txlogpub_0000_0002 */
/* [local] */ 



EXTERN_C const CLSID CLSID_SimpleFileBasedLog;


extern RPC_IF_HANDLE __MIDL_itf_txlogpub_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_txlogpub_0000_0002_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\UaStrFnc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994-1999.
//
//  File:       uastrfnc.h
//
//  Contents:   Unaligned UNICODE lstr functions for MIPS, PPC, ALPHA, ...
//
//  Classes:
//
//  Functions:
//
//
//--------------------------------------------------------------------------

// NOTE: This file assumes it is included from shellprv.h

#ifndef _UASTRFNC_H_
#define _UASTRFNC_H_

#ifdef __cplusplus
extern "C" {
#endif

// If we are running on a platform that requires aligned data, we need
// to provide custom string functions that can deal with unaligned
// strings.  On other platforms, these call directly to the normal string
// functions.

#ifndef _X86_
#define ALIGNMENT_MACHINE
#endif

#ifdef ALIGNMENT_MACHINE

#define IS_ALIGNED(p)   (((ULONG_PTR)(p) & (sizeof(*(p))-1) )==0)

UNALIGNED WCHAR * ualstrcpynW(UNALIGNED WCHAR * lpString1,
    		  	      UNALIGNED const WCHAR * lpString2,
    			      int iMaxLength);

int 		  ualstrcmpiW (UNALIGNED const WCHAR * dst,
			       UNALIGNED const WCHAR * src);

int 		  ualstrcmpW  (UNALIGNED const WCHAR * src,
			       UNALIGNED const WCHAR * dst);

size_t 		  ualstrlenW  (UNALIGNED const WCHAR * wcs);

UNALIGNED WCHAR * ualstrcpyW  (UNALIGNED WCHAR * dst,
			       UNALIGNED const WCHAR * src);


#else

#define ualstrcpynW StrCpyNW     // lstrcpynW is stubbed out on Windows 95
#define ualstrcmpiW StrCmpIW     // lstrcmpiW is stubbed out on Windows 95
#define ualstrcmpW  StrCmpW      // lstrcmpW is stubbed out on Windows 95
#define ualstrlenW  lstrlenW
#define ualstrcpyW  StrCpyW      // lstrcpyW is stubbed out on Windows 95

#endif // ALIGNMENT_MACHINE

#define ualstrcpynA lstrcpynA
#define ualstrcmpiA lstrcmpiA
#define ualstrcmpA  lstrcmpA
#define ualstrlenA  lstrlenA
#define ualstrcpyA  lstrcpyA

#ifdef UNICODE
#define ualstrcpyn ualstrcpynW
#define ualstrcmpi ualstrcmpiW
#define ualstrcmp  ualstrcmpW
#define ualstrlen  ualstrlenW
#define ualstrcpy  ualstrcpyW
#else
#define ualstrcpyn ualstrcpynA
#define ualstrcmpi ualstrcmpiA
#define ualstrcmp  ualstrcmpA
#define ualstrlen  ualstrlenA
#define ualstrcpy  ualstrcpyA
#endif

#ifdef __cplusplus
}       // extern "C"
#endif

#endif // _UASTRFNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\UIAutomation.h ===
// -------------------------------------------------------------
// UIAutomation.h
//
// UIAutomation API Header, brings in all the other UIAutomation headers
//
// Copyright (c) Microsoft Corporation. All rights reserved.
// -------------------------------------------------------------

#include <UIAutomationCore.h>
#include <UIAutomationClient.h>
#include <UIAutomationCoreApi.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\UIAnimation.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for UIAnimation.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __UIAnimation_h__
#define __UIAnimation_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IUIAnimationManager_FWD_DEFINED__
#define __IUIAnimationManager_FWD_DEFINED__
typedef interface IUIAnimationManager IUIAnimationManager;
#endif 	/* __IUIAnimationManager_FWD_DEFINED__ */


#ifndef __IUIAnimationVariable_FWD_DEFINED__
#define __IUIAnimationVariable_FWD_DEFINED__
typedef interface IUIAnimationVariable IUIAnimationVariable;
#endif 	/* __IUIAnimationVariable_FWD_DEFINED__ */


#ifndef __IUIAnimationStoryboard_FWD_DEFINED__
#define __IUIAnimationStoryboard_FWD_DEFINED__
typedef interface IUIAnimationStoryboard IUIAnimationStoryboard;
#endif 	/* __IUIAnimationStoryboard_FWD_DEFINED__ */


#ifndef __IUIAnimationTransition_FWD_DEFINED__
#define __IUIAnimationTransition_FWD_DEFINED__
typedef interface IUIAnimationTransition IUIAnimationTransition;
#endif 	/* __IUIAnimationTransition_FWD_DEFINED__ */


#ifndef __IUIAnimationManagerEventHandler_FWD_DEFINED__
#define __IUIAnimationManagerEventHandler_FWD_DEFINED__
typedef interface IUIAnimationManagerEventHandler IUIAnimationManagerEventHandler;
#endif 	/* __IUIAnimationManagerEventHandler_FWD_DEFINED__ */


#ifndef __IUIAnimationVariableChangeHandler_FWD_DEFINED__
#define __IUIAnimationVariableChangeHandler_FWD_DEFINED__
typedef interface IUIAnimationVariableChangeHandler IUIAnimationVariableChangeHandler;
#endif 	/* __IUIAnimationVariableChangeHandler_FWD_DEFINED__ */


#ifndef __IUIAnimationVariableIntegerChangeHandler_FWD_DEFINED__
#define __IUIAnimationVariableIntegerChangeHandler_FWD_DEFINED__
typedef interface IUIAnimationVariableIntegerChangeHandler IUIAnimationVariableIntegerChangeHandler;
#endif 	/* __IUIAnimationVariableIntegerChangeHandler_FWD_DEFINED__ */


#ifndef __IUIAnimationStoryboardEventHandler_FWD_DEFINED__
#define __IUIAnimationStoryboardEventHandler_FWD_DEFINED__
typedef interface IUIAnimationStoryboardEventHandler IUIAnimationStoryboardEventHandler;
#endif 	/* __IUIAnimationStoryboardEventHandler_FWD_DEFINED__ */


#ifndef __IUIAnimationPriorityComparison_FWD_DEFINED__
#define __IUIAnimationPriorityComparison_FWD_DEFINED__
typedef interface IUIAnimationPriorityComparison IUIAnimationPriorityComparison;
#endif 	/* __IUIAnimationPriorityComparison_FWD_DEFINED__ */


#ifndef __IUIAnimationTransitionLibrary_FWD_DEFINED__
#define __IUIAnimationTransitionLibrary_FWD_DEFINED__
typedef interface IUIAnimationTransitionLibrary IUIAnimationTransitionLibrary;
#endif 	/* __IUIAnimationTransitionLibrary_FWD_DEFINED__ */


#ifndef __IUIAnimationInterpolator_FWD_DEFINED__
#define __IUIAnimationInterpolator_FWD_DEFINED__
typedef interface IUIAnimationInterpolator IUIAnimationInterpolator;
#endif 	/* __IUIAnimationInterpolator_FWD_DEFINED__ */


#ifndef __IUIAnimationTransitionFactory_FWD_DEFINED__
#define __IUIAnimationTransitionFactory_FWD_DEFINED__
typedef interface IUIAnimationTransitionFactory IUIAnimationTransitionFactory;
#endif 	/* __IUIAnimationTransitionFactory_FWD_DEFINED__ */


#ifndef __IUIAnimationTimer_FWD_DEFINED__
#define __IUIAnimationTimer_FWD_DEFINED__
typedef interface IUIAnimationTimer IUIAnimationTimer;
#endif 	/* __IUIAnimationTimer_FWD_DEFINED__ */


#ifndef __IUIAnimationTimerUpdateHandler_FWD_DEFINED__
#define __IUIAnimationTimerUpdateHandler_FWD_DEFINED__
typedef interface IUIAnimationTimerUpdateHandler IUIAnimationTimerUpdateHandler;
#endif 	/* __IUIAnimationTimerUpdateHandler_FWD_DEFINED__ */


#ifndef __IUIAnimationTimerClientEventHandler_FWD_DEFINED__
#define __IUIAnimationTimerClientEventHandler_FWD_DEFINED__
typedef interface IUIAnimationTimerClientEventHandler IUIAnimationTimerClientEventHandler;
#endif 	/* __IUIAnimationTimerClientEventHandler_FWD_DEFINED__ */


#ifndef __IUIAnimationTimerEventHandler_FWD_DEFINED__
#define __IUIAnimationTimerEventHandler_FWD_DEFINED__
typedef interface IUIAnimationTimerEventHandler IUIAnimationTimerEventHandler;
#endif 	/* __IUIAnimationTimerEventHandler_FWD_DEFINED__ */


#ifndef __UIAnimationManager_FWD_DEFINED__
#define __UIAnimationManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class UIAnimationManager UIAnimationManager;
#else
typedef struct UIAnimationManager UIAnimationManager;
#endif /* __cplusplus */

#endif 	/* __UIAnimationManager_FWD_DEFINED__ */


#ifndef __UIAnimationTransitionLibrary_FWD_DEFINED__
#define __UIAnimationTransitionLibrary_FWD_DEFINED__

#ifdef __cplusplus
typedef class UIAnimationTransitionLibrary UIAnimationTransitionLibrary;
#else
typedef struct UIAnimationTransitionLibrary UIAnimationTransitionLibrary;
#endif /* __cplusplus */

#endif 	/* __UIAnimationTransitionLibrary_FWD_DEFINED__ */


#ifndef __UIAnimationTransitionFactory_FWD_DEFINED__
#define __UIAnimationTransitionFactory_FWD_DEFINED__

#ifdef __cplusplus
typedef class UIAnimationTransitionFactory UIAnimationTransitionFactory;
#else
typedef struct UIAnimationTransitionFactory UIAnimationTransitionFactory;
#endif /* __cplusplus */

#endif 	/* __UIAnimationTransitionFactory_FWD_DEFINED__ */


#ifndef __UIAnimationTimer_FWD_DEFINED__
#define __UIAnimationTimer_FWD_DEFINED__

#ifdef __cplusplus
typedef class UIAnimationTimer UIAnimationTimer;
#else
typedef struct UIAnimationTimer UIAnimationTimer;
#endif /* __cplusplus */

#endif 	/* __UIAnimationTimer_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_UIAnimation_0000_0000 */
/* [local] */ 

//--------------------------------------------------------------------------
//
//  UIAnimation.h
//
//  Windows Animation interface definitions and related types and enums
//  (Generated from UIAnimation.idl)
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------
#pragma warning(push)
#pragma warning(disable:4001) 
#pragma once
#pragma warning(pop)
















typedef DOUBLE UI_ANIMATION_SECONDS;

#define	UI_ANIMATION_SECONDS_EVENTUALLY	( -1 )

typedef /* [public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_UIAnimation_0000_0000_0001
    {	UI_ANIMATION_UPDATE_NO_CHANGE	= 0,
	UI_ANIMATION_UPDATE_VARIABLES_CHANGED	= 1
    } 	UI_ANIMATION_UPDATE_RESULT;

typedef /* [public][public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_UIAnimation_0000_0000_0002
    {	UI_ANIMATION_MANAGER_IDLE	= 0,
	UI_ANIMATION_MANAGER_BUSY	= 1
    } 	UI_ANIMATION_MANAGER_STATUS;

typedef /* [public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_UIAnimation_0000_0000_0003
    {	UI_ANIMATION_MODE_DISABLED	= 0,
	UI_ANIMATION_MODE_SYSTEM_DEFAULT	= 1,
	UI_ANIMATION_MODE_ENABLED	= 2
    } 	UI_ANIMATION_MODE;



extern RPC_IF_HANDLE __MIDL_itf_UIAnimation_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_UIAnimation_0000_0000_v0_0_s_ifspec;

#ifndef __IUIAnimationManager_INTERFACE_DEFINED__
#define __IUIAnimationManager_INTERFACE_DEFINED__

/* interface IUIAnimationManager */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IUIAnimationManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9169896C-AC8D-4e7d-94E5-67FA4DC2F2E8")
    IUIAnimationManager : public IUnknown
    {
    public:
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE CreateAnimationVariable( 
            /* [annotation][in] */ 
            __in  DOUBLE initialValue,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationVariable **variable) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE ScheduleTransition( 
            /* [annotation][in] */ 
            __in  IUIAnimationVariable *variable,
            /* [annotation][in] */ 
            __in  IUIAnimationTransition *transition,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS timeNow) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE CreateStoryboard( 
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationStoryboard **storyboard) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE FinishAllStoryboards( 
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS completionDeadline) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE AbandonAllStoryboards( void) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE Update( 
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS timeNow,
            /* [annotation][defaultvalue][out] */ 
            __out_opt  UI_ANIMATION_UPDATE_RESULT *updateResult = 0) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE GetVariableFromTag( 
            /* [annotation][unique][in] */ 
            __in_opt  IUnknown *object,
            /* [annotation][in] */ 
            __in  UINT32 id,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationVariable **variable) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE GetStoryboardFromTag( 
            /* [annotation][unique][in] */ 
            __in_opt  IUnknown *object,
            /* [annotation][in] */ 
            __in  UINT32 id,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationStoryboard **storyboard) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [annotation][retval][out] */ 
            __out  UI_ANIMATION_MANAGER_STATUS *status) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE SetAnimationMode( 
            /* [annotation][in] */ 
            __in  UI_ANIMATION_MODE mode) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE SetManagerEventHandler( 
            /* [annotation][unique][in] */ 
            __in_opt  IUIAnimationManagerEventHandler *handler) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE SetCancelPriorityComparison( 
            /* [annotation][unique][in] */ 
            __in_opt  IUIAnimationPriorityComparison *comparison) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE SetTrimPriorityComparison( 
            /* [annotation][unique][in] */ 
            __in_opt  IUIAnimationPriorityComparison *comparison) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE SetCompressPriorityComparison( 
            /* [annotation][unique][in] */ 
            __in_opt  IUIAnimationPriorityComparison *comparison) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE SetConcludePriorityComparison( 
            /* [annotation][unique][in] */ 
            __in_opt  IUIAnimationPriorityComparison *comparison) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE SetDefaultLongestAcceptableDelay( 
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS delay) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE Shutdown( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAnimationManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUIAnimationManager * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUIAnimationManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUIAnimationManager * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *CreateAnimationVariable )( 
            IUIAnimationManager * This,
            /* [annotation][in] */ 
            __in  DOUBLE initialValue,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationVariable **variable);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *ScheduleTransition )( 
            IUIAnimationManager * This,
            /* [annotation][in] */ 
            __in  IUIAnimationVariable *variable,
            /* [annotation][in] */ 
            __in  IUIAnimationTransition *transition,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS timeNow);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *CreateStoryboard )( 
            IUIAnimationManager * This,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationStoryboard **storyboard);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *FinishAllStoryboards )( 
            IUIAnimationManager * This,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS completionDeadline);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *AbandonAllStoryboards )( 
            IUIAnimationManager * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *Update )( 
            IUIAnimationManager * This,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS timeNow,
            /* [annotation][defaultvalue][out] */ 
            __out_opt  UI_ANIMATION_UPDATE_RESULT *updateResult);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *GetVariableFromTag )( 
            IUIAnimationManager * This,
            /* [annotation][unique][in] */ 
            __in_opt  IUnknown *object,
            /* [annotation][in] */ 
            __in  UINT32 id,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationVariable **variable);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *GetStoryboardFromTag )( 
            IUIAnimationManager * This,
            /* [annotation][unique][in] */ 
            __in_opt  IUnknown *object,
            /* [annotation][in] */ 
            __in  UINT32 id,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationStoryboard **storyboard);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IUIAnimationManager * This,
            /* [annotation][retval][out] */ 
            __out  UI_ANIMATION_MANAGER_STATUS *status);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *SetAnimationMode )( 
            IUIAnimationManager * This,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_MODE mode);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IUIAnimationManager * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IUIAnimationManager * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *SetManagerEventHandler )( 
            IUIAnimationManager * This,
            /* [annotation][unique][in] */ 
            __in_opt  IUIAnimationManagerEventHandler *handler);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *SetCancelPriorityComparison )( 
            IUIAnimationManager * This,
            /* [annotation][unique][in] */ 
            __in_opt  IUIAnimationPriorityComparison *comparison);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *SetTrimPriorityComparison )( 
            IUIAnimationManager * This,
            /* [annotation][unique][in] */ 
            __in_opt  IUIAnimationPriorityComparison *comparison);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *SetCompressPriorityComparison )( 
            IUIAnimationManager * This,
            /* [annotation][unique][in] */ 
            __in_opt  IUIAnimationPriorityComparison *comparison);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *SetConcludePriorityComparison )( 
            IUIAnimationManager * This,
            /* [annotation][unique][in] */ 
            __in_opt  IUIAnimationPriorityComparison *comparison);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *SetDefaultLongestAcceptableDelay )( 
            IUIAnimationManager * This,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS delay);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            IUIAnimationManager * This);
        
        END_INTERFACE
    } IUIAnimationManagerVtbl;

    interface IUIAnimationManager
    {
        CONST_VTBL struct IUIAnimationManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAnimationManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAnimationManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAnimationManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAnimationManager_CreateAnimationVariable(This,initialValue,variable)	\
    ( (This)->lpVtbl -> CreateAnimationVariable(This,initialValue,variable) ) 

#define IUIAnimationManager_ScheduleTransition(This,variable,transition,timeNow)	\
    ( (This)->lpVtbl -> ScheduleTransition(This,variable,transition,timeNow) ) 

#define IUIAnimationManager_CreateStoryboard(This,storyboard)	\
    ( (This)->lpVtbl -> CreateStoryboard(This,storyboard) ) 

#define IUIAnimationManager_FinishAllStoryboards(This,completionDeadline)	\
    ( (This)->lpVtbl -> FinishAllStoryboards(This,completionDeadline) ) 

#define IUIAnimationManager_AbandonAllStoryboards(This)	\
    ( (This)->lpVtbl -> AbandonAllStoryboards(This) ) 

#define IUIAnimationManager_Update(This,timeNow,updateResult)	\
    ( (This)->lpVtbl -> Update(This,timeNow,updateResult) ) 

#define IUIAnimationManager_GetVariableFromTag(This,object,id,variable)	\
    ( (This)->lpVtbl -> GetVariableFromTag(This,object,id,variable) ) 

#define IUIAnimationManager_GetStoryboardFromTag(This,object,id,storyboard)	\
    ( (This)->lpVtbl -> GetStoryboardFromTag(This,object,id,storyboard) ) 

#define IUIAnimationManager_GetStatus(This,status)	\
    ( (This)->lpVtbl -> GetStatus(This,status) ) 

#define IUIAnimationManager_SetAnimationMode(This,mode)	\
    ( (This)->lpVtbl -> SetAnimationMode(This,mode) ) 

#define IUIAnimationManager_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IUIAnimationManager_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 

#define IUIAnimationManager_SetManagerEventHandler(This,handler)	\
    ( (This)->lpVtbl -> SetManagerEventHandler(This,handler) ) 

#define IUIAnimationManager_SetCancelPriorityComparison(This,comparison)	\
    ( (This)->lpVtbl -> SetCancelPriorityComparison(This,comparison) ) 

#define IUIAnimationManager_SetTrimPriorityComparison(This,comparison)	\
    ( (This)->lpVtbl -> SetTrimPriorityComparison(This,comparison) ) 

#define IUIAnimationManager_SetCompressPriorityComparison(This,comparison)	\
    ( (This)->lpVtbl -> SetCompressPriorityComparison(This,comparison) ) 

#define IUIAnimationManager_SetConcludePriorityComparison(This,comparison)	\
    ( (This)->lpVtbl -> SetConcludePriorityComparison(This,comparison) ) 

#define IUIAnimationManager_SetDefaultLongestAcceptableDelay(This,delay)	\
    ( (This)->lpVtbl -> SetDefaultLongestAcceptableDelay(This,delay) ) 

#define IUIAnimationManager_Shutdown(This)	\
    ( (This)->lpVtbl -> Shutdown(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAnimationManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_UIAnimation_0000_0001 */
/* [local] */ 

typedef /* [public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_UIAnimation_0000_0001_0001
    {	UI_ANIMATION_ROUNDING_NEAREST	= 0,
	UI_ANIMATION_ROUNDING_FLOOR	= 1,
	UI_ANIMATION_ROUNDING_CEILING	= 2
    } 	UI_ANIMATION_ROUNDING_MODE;



extern RPC_IF_HANDLE __MIDL_itf_UIAnimation_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_UIAnimation_0000_0001_v0_0_s_ifspec;

#ifndef __IUIAnimationVariable_INTERFACE_DEFINED__
#define __IUIAnimationVariable_INTERFACE_DEFINED__

/* interface IUIAnimationVariable */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IUIAnimationVariable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8CEEB155-2849-4ce5-9448-91FF70E1E4D9")
    IUIAnimationVariable : public IUnknown
    {
    public:
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE GetValue( 
            /* [annotation][retval][out] */ 
            __out  DOUBLE *value) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE GetFinalValue( 
            /* [annotation][retval][out] */ 
            __out  DOUBLE *finalValue) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE GetPreviousValue( 
            /* [annotation][retval][out] */ 
            __out  DOUBLE *previousValue) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE GetIntegerValue( 
            /* [annotation][retval][out] */ 
            __out  INT32 *value) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE GetFinalIntegerValue( 
            /* [annotation][retval][out] */ 
            __out  INT32 *finalValue) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE GetPreviousIntegerValue( 
            /* [annotation][retval][out] */ 
            __out  INT32 *previousValue) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE GetCurrentStoryboard( 
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationStoryboard **storyboard) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE SetLowerBound( 
            /* [annotation][in] */ 
            __in  DOUBLE bound) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE SetUpperBound( 
            /* [annotation][in] */ 
            __in  DOUBLE bound) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE SetRoundingMode( 
            /* [annotation][in] */ 
            __in  UI_ANIMATION_ROUNDING_MODE mode) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE SetTag( 
            /* [annotation][unique][in] */ 
            __in_opt  IUnknown *object,
            /* [annotation][in] */ 
            __in  UINT32 id) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE GetTag( 
            /* [annotation][out] */ 
            __deref_opt_out  IUnknown **object,
            /* [annotation][out] */ 
            __out_opt  UINT32 *id) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE SetVariableChangeHandler( 
            /* [annotation][unique][in] */ 
            __in_opt  IUIAnimationVariableChangeHandler *handler) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE SetVariableIntegerChangeHandler( 
            /* [annotation][unique][in] */ 
            __in_opt  IUIAnimationVariableIntegerChangeHandler *handler) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAnimationVariableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUIAnimationVariable * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUIAnimationVariable * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUIAnimationVariable * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IUIAnimationVariable * This,
            /* [annotation][retval][out] */ 
            __out  DOUBLE *value);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *GetFinalValue )( 
            IUIAnimationVariable * This,
            /* [annotation][retval][out] */ 
            __out  DOUBLE *finalValue);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *GetPreviousValue )( 
            IUIAnimationVariable * This,
            /* [annotation][retval][out] */ 
            __out  DOUBLE *previousValue);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *GetIntegerValue )( 
            IUIAnimationVariable * This,
            /* [annotation][retval][out] */ 
            __out  INT32 *value);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *GetFinalIntegerValue )( 
            IUIAnimationVariable * This,
            /* [annotation][retval][out] */ 
            __out  INT32 *finalValue);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *GetPreviousIntegerValue )( 
            IUIAnimationVariable * This,
            /* [annotation][retval][out] */ 
            __out  INT32 *previousValue);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *GetCurrentStoryboard )( 
            IUIAnimationVariable * This,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationStoryboard **storyboard);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *SetLowerBound )( 
            IUIAnimationVariable * This,
            /* [annotation][in] */ 
            __in  DOUBLE bound);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *SetUpperBound )( 
            IUIAnimationVariable * This,
            /* [annotation][in] */ 
            __in  DOUBLE bound);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *SetRoundingMode )( 
            IUIAnimationVariable * This,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_ROUNDING_MODE mode);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *SetTag )( 
            IUIAnimationVariable * This,
            /* [annotation][unique][in] */ 
            __in_opt  IUnknown *object,
            /* [annotation][in] */ 
            __in  UINT32 id);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IUIAnimationVariable * This,
            /* [annotation][out] */ 
            __deref_opt_out  IUnknown **object,
            /* [annotation][out] */ 
            __out_opt  UINT32 *id);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *SetVariableChangeHandler )( 
            IUIAnimationVariable * This,
            /* [annotation][unique][in] */ 
            __in_opt  IUIAnimationVariableChangeHandler *handler);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *SetVariableIntegerChangeHandler )( 
            IUIAnimationVariable * This,
            /* [annotation][unique][in] */ 
            __in_opt  IUIAnimationVariableIntegerChangeHandler *handler);
        
        END_INTERFACE
    } IUIAnimationVariableVtbl;

    interface IUIAnimationVariable
    {
        CONST_VTBL struct IUIAnimationVariableVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAnimationVariable_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAnimationVariable_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAnimationVariable_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAnimationVariable_GetValue(This,value)	\
    ( (This)->lpVtbl -> GetValue(This,value) ) 

#define IUIAnimationVariable_GetFinalValue(This,finalValue)	\
    ( (This)->lpVtbl -> GetFinalValue(This,finalValue) ) 

#define IUIAnimationVariable_GetPreviousValue(This,previousValue)	\
    ( (This)->lpVtbl -> GetPreviousValue(This,previousValue) ) 

#define IUIAnimationVariable_GetIntegerValue(This,value)	\
    ( (This)->lpVtbl -> GetIntegerValue(This,value) ) 

#define IUIAnimationVariable_GetFinalIntegerValue(This,finalValue)	\
    ( (This)->lpVtbl -> GetFinalIntegerValue(This,finalValue) ) 

#define IUIAnimationVariable_GetPreviousIntegerValue(This,previousValue)	\
    ( (This)->lpVtbl -> GetPreviousIntegerValue(This,previousValue) ) 

#define IUIAnimationVariable_GetCurrentStoryboard(This,storyboard)	\
    ( (This)->lpVtbl -> GetCurrentStoryboard(This,storyboard) ) 

#define IUIAnimationVariable_SetLowerBound(This,bound)	\
    ( (This)->lpVtbl -> SetLowerBound(This,bound) ) 

#define IUIAnimationVariable_SetUpperBound(This,bound)	\
    ( (This)->lpVtbl -> SetUpperBound(This,bound) ) 

#define IUIAnimationVariable_SetRoundingMode(This,mode)	\
    ( (This)->lpVtbl -> SetRoundingMode(This,mode) ) 

#define IUIAnimationVariable_SetTag(This,object,id)	\
    ( (This)->lpVtbl -> SetTag(This,object,id) ) 

#define IUIAnimationVariable_GetTag(This,object,id)	\
    ( (This)->lpVtbl -> GetTag(This,object,id) ) 

#define IUIAnimationVariable_SetVariableChangeHandler(This,handler)	\
    ( (This)->lpVtbl -> SetVariableChangeHandler(This,handler) ) 

#define IUIAnimationVariable_SetVariableIntegerChangeHandler(This,handler)	\
    ( (This)->lpVtbl -> SetVariableIntegerChangeHandler(This,handler) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAnimationVariable_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_UIAnimation_0000_0002 */
/* [local] */ 

typedef /* [public][public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_UIAnimation_0000_0002_0001
    {	UI_ANIMATION_STORYBOARD_BUILDING	= 0,
	UI_ANIMATION_STORYBOARD_SCHEDULED	= 1,
	UI_ANIMATION_STORYBOARD_CANCELLED	= 2,
	UI_ANIMATION_STORYBOARD_PLAYING	= 3,
	UI_ANIMATION_STORYBOARD_TRUNCATED	= 4,
	UI_ANIMATION_STORYBOARD_FINISHED	= 5,
	UI_ANIMATION_STORYBOARD_READY	= 6,
	UI_ANIMATION_STORYBOARD_INSUFFICIENT_PRIORITY	= 7
    } 	UI_ANIMATION_STORYBOARD_STATUS;

typedef /* [public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_UIAnimation_0000_0002_0002
    {	UI_ANIMATION_SCHEDULING_UNEXPECTED_FAILURE	= 0,
	UI_ANIMATION_SCHEDULING_INSUFFICIENT_PRIORITY	= 1,
	UI_ANIMATION_SCHEDULING_ALREADY_SCHEDULED	= 2,
	UI_ANIMATION_SCHEDULING_SUCCEEDED	= 3,
	UI_ANIMATION_SCHEDULING_DEFERRED	= 4
    } 	UI_ANIMATION_SCHEDULING_RESULT;

typedef struct __MIDL___MIDL_itf_UIAnimation_0000_0002_0003
    {
    int _;
    } 	*UI_ANIMATION_KEYFRAME;

#define	UI_ANIMATION_KEYFRAME_STORYBOARD_START	( ( UI_ANIMATION_KEYFRAME  )-1 )

#define	UI_ANIMATION_REPEAT_INDEFINITELY	( -1 )



extern RPC_IF_HANDLE __MIDL_itf_UIAnimation_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_UIAnimation_0000_0002_v0_0_s_ifspec;

#ifndef __IUIAnimationStoryboard_INTERFACE_DEFINED__
#define __IUIAnimationStoryboard_INTERFACE_DEFINED__

/* interface IUIAnimationStoryboard */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IUIAnimationStoryboard;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A8FF128F-9BF9-4af1-9E67-E5E410DEFB84")
    IUIAnimationStoryboard : public IUnknown
    {
    public:
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE AddTransition( 
            /* [annotation][in] */ 
            __in  IUIAnimationVariable *variable,
            /* [annotation][in] */ 
            __in  IUIAnimationTransition *transition) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE AddKeyframeAtOffset( 
            /* [annotation][in] */ 
            __in  UI_ANIMATION_KEYFRAME existingKeyframe,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS offset,
            /* [annotation][retval][out] */ 
            __out  UI_ANIMATION_KEYFRAME *keyframe) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE AddKeyframeAfterTransition( 
            /* [annotation][in] */ 
            __in  IUIAnimationTransition *transition,
            /* [annotation][retval][out] */ 
            __out  UI_ANIMATION_KEYFRAME *keyframe) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE AddTransitionAtKeyframe( 
            /* [annotation][in] */ 
            __in  IUIAnimationVariable *variable,
            /* [annotation][in] */ 
            __in  IUIAnimationTransition *transition,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_KEYFRAME startKeyframe) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE AddTransitionBetweenKeyframes( 
            /* [annotation][in] */ 
            __in  IUIAnimationVariable *variable,
            /* [annotation][in] */ 
            __in  IUIAnimationTransition *transition,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_KEYFRAME startKeyframe,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_KEYFRAME endKeyframe) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE RepeatBetweenKeyframes( 
            /* [annotation][in] */ 
            __in  UI_ANIMATION_KEYFRAME startKeyframe,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_KEYFRAME endKeyframe,
            /* [annotation][in] */ 
            __in  INT32 repetitionCount) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE HoldVariable( 
            /* [annotation][in] */ 
            __in  IUIAnimationVariable *variable) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE SetLongestAcceptableDelay( 
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS delay) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE Schedule( 
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS timeNow,
            /* [annotation][defaultvalue][out] */ 
            __out_opt  UI_ANIMATION_SCHEDULING_RESULT *schedulingResult = 0) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE Conclude( void) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE Finish( 
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS completionDeadline) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE Abandon( void) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE SetTag( 
            /* [annotation][unique][in] */ 
            __in_opt  IUnknown *object,
            /* [annotation][in] */ 
            __in  UINT32 id) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE GetTag( 
            /* [annotation][out] */ 
            __deref_opt_out  IUnknown **object,
            /* [annotation][out] */ 
            __out_opt  UINT32 *id) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [annotation][retval][out] */ 
            __out  UI_ANIMATION_STORYBOARD_STATUS *status) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE GetElapsedTime( 
            /* [annotation][out] */ 
            __out  UI_ANIMATION_SECONDS *elapsedTime) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE SetStoryboardEventHandler( 
            /* [annotation][unique][in] */ 
            __in_opt  IUIAnimationStoryboardEventHandler *handler) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAnimationStoryboardVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUIAnimationStoryboard * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUIAnimationStoryboard * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUIAnimationStoryboard * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *AddTransition )( 
            IUIAnimationStoryboard * This,
            /* [annotation][in] */ 
            __in  IUIAnimationVariable *variable,
            /* [annotation][in] */ 
            __in  IUIAnimationTransition *transition);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *AddKeyframeAtOffset )( 
            IUIAnimationStoryboard * This,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_KEYFRAME existingKeyframe,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS offset,
            /* [annotation][retval][out] */ 
            __out  UI_ANIMATION_KEYFRAME *keyframe);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *AddKeyframeAfterTransition )( 
            IUIAnimationStoryboard * This,
            /* [annotation][in] */ 
            __in  IUIAnimationTransition *transition,
            /* [annotation][retval][out] */ 
            __out  UI_ANIMATION_KEYFRAME *keyframe);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *AddTransitionAtKeyframe )( 
            IUIAnimationStoryboard * This,
            /* [annotation][in] */ 
            __in  IUIAnimationVariable *variable,
            /* [annotation][in] */ 
            __in  IUIAnimationTransition *transition,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_KEYFRAME startKeyframe);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *AddTransitionBetweenKeyframes )( 
            IUIAnimationStoryboard * This,
            /* [annotation][in] */ 
            __in  IUIAnimationVariable *variable,
            /* [annotation][in] */ 
            __in  IUIAnimationTransition *transition,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_KEYFRAME startKeyframe,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_KEYFRAME endKeyframe);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *RepeatBetweenKeyframes )( 
            IUIAnimationStoryboard * This,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_KEYFRAME startKeyframe,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_KEYFRAME endKeyframe,
            /* [annotation][in] */ 
            __in  INT32 repetitionCount);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *HoldVariable )( 
            IUIAnimationStoryboard * This,
            /* [annotation][in] */ 
            __in  IUIAnimationVariable *variable);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *SetLongestAcceptableDelay )( 
            IUIAnimationStoryboard * This,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS delay);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *Schedule )( 
            IUIAnimationStoryboard * This,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS timeNow,
            /* [annotation][defaultvalue][out] */ 
            __out_opt  UI_ANIMATION_SCHEDULING_RESULT *schedulingResult);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *Conclude )( 
            IUIAnimationStoryboard * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *Finish )( 
            IUIAnimationStoryboard * This,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS completionDeadline);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *Abandon )( 
            IUIAnimationStoryboard * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *SetTag )( 
            IUIAnimationStoryboard * This,
            /* [annotation][unique][in] */ 
            __in_opt  IUnknown *object,
            /* [annotation][in] */ 
            __in  UINT32 id);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *GetTag )( 
            IUIAnimationStoryboard * This,
            /* [annotation][out] */ 
            __deref_opt_out  IUnknown **object,
            /* [annotation][out] */ 
            __out_opt  UINT32 *id);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IUIAnimationStoryboard * This,
            /* [annotation][retval][out] */ 
            __out  UI_ANIMATION_STORYBOARD_STATUS *status);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *GetElapsedTime )( 
            IUIAnimationStoryboard * This,
            /* [annotation][out] */ 
            __out  UI_ANIMATION_SECONDS *elapsedTime);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *SetStoryboardEventHandler )( 
            IUIAnimationStoryboard * This,
            /* [annotation][unique][in] */ 
            __in_opt  IUIAnimationStoryboardEventHandler *handler);
        
        END_INTERFACE
    } IUIAnimationStoryboardVtbl;

    interface IUIAnimationStoryboard
    {
        CONST_VTBL struct IUIAnimationStoryboardVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAnimationStoryboard_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAnimationStoryboard_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAnimationStoryboard_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAnimationStoryboard_AddTransition(This,variable,transition)	\
    ( (This)->lpVtbl -> AddTransition(This,variable,transition) ) 

#define IUIAnimationStoryboard_AddKeyframeAtOffset(This,existingKeyframe,offset,keyframe)	\
    ( (This)->lpVtbl -> AddKeyframeAtOffset(This,existingKeyframe,offset,keyframe) ) 

#define IUIAnimationStoryboard_AddKeyframeAfterTransition(This,transition,keyframe)	\
    ( (This)->lpVtbl -> AddKeyframeAfterTransition(This,transition,keyframe) ) 

#define IUIAnimationStoryboard_AddTransitionAtKeyframe(This,variable,transition,startKeyframe)	\
    ( (This)->lpVtbl -> AddTransitionAtKeyframe(This,variable,transition,startKeyframe) ) 

#define IUIAnimationStoryboard_AddTransitionBetweenKeyframes(This,variable,transition,startKeyframe,endKeyframe)	\
    ( (This)->lpVtbl -> AddTransitionBetweenKeyframes(This,variable,transition,startKeyframe,endKeyframe) ) 

#define IUIAnimationStoryboard_RepeatBetweenKeyframes(This,startKeyframe,endKeyframe,repetitionCount)	\
    ( (This)->lpVtbl -> RepeatBetweenKeyframes(This,startKeyframe,endKeyframe,repetitionCount) ) 

#define IUIAnimationStoryboard_HoldVariable(This,variable)	\
    ( (This)->lpVtbl -> HoldVariable(This,variable) ) 

#define IUIAnimationStoryboard_SetLongestAcceptableDelay(This,delay)	\
    ( (This)->lpVtbl -> SetLongestAcceptableDelay(This,delay) ) 

#define IUIAnimationStoryboard_Schedule(This,timeNow,schedulingResult)	\
    ( (This)->lpVtbl -> Schedule(This,timeNow,schedulingResult) ) 

#define IUIAnimationStoryboard_Conclude(This)	\
    ( (This)->lpVtbl -> Conclude(This) ) 

#define IUIAnimationStoryboard_Finish(This,completionDeadline)	\
    ( (This)->lpVtbl -> Finish(This,completionDeadline) ) 

#define IUIAnimationStoryboard_Abandon(This)	\
    ( (This)->lpVtbl -> Abandon(This) ) 

#define IUIAnimationStoryboard_SetTag(This,object,id)	\
    ( (This)->lpVtbl -> SetTag(This,object,id) ) 

#define IUIAnimationStoryboard_GetTag(This,object,id)	\
    ( (This)->lpVtbl -> GetTag(This,object,id) ) 

#define IUIAnimationStoryboard_GetStatus(This,status)	\
    ( (This)->lpVtbl -> GetStatus(This,status) ) 

#define IUIAnimationStoryboard_GetElapsedTime(This,elapsedTime)	\
    ( (This)->lpVtbl -> GetElapsedTime(This,elapsedTime) ) 

#define IUIAnimationStoryboard_SetStoryboardEventHandler(This,handler)	\
    ( (This)->lpVtbl -> SetStoryboardEventHandler(This,handler) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAnimationStoryboard_INTERFACE_DEFINED__ */


#ifndef __IUIAnimationTransition_INTERFACE_DEFINED__
#define __IUIAnimationTransition_INTERFACE_DEFINED__

/* interface IUIAnimationTransition */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IUIAnimationTransition;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DC6CE252-F731-41cf-B610-614B6CA049AD")
    IUIAnimationTransition : public IUnknown
    {
    public:
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE SetInitialValue( 
            /* [annotation][in] */ 
            __in  DOUBLE value) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE SetInitialVelocity( 
            /* [annotation][in] */ 
            __in  DOUBLE velocity) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE IsDurationKnown( void) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE GetDuration( 
            /* [annotation][retval][out] */ 
            __out  UI_ANIMATION_SECONDS *duration) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAnimationTransitionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUIAnimationTransition * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUIAnimationTransition * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUIAnimationTransition * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *SetInitialValue )( 
            IUIAnimationTransition * This,
            /* [annotation][in] */ 
            __in  DOUBLE value);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *SetInitialVelocity )( 
            IUIAnimationTransition * This,
            /* [annotation][in] */ 
            __in  DOUBLE velocity);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *IsDurationKnown )( 
            IUIAnimationTransition * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *GetDuration )( 
            IUIAnimationTransition * This,
            /* [annotation][retval][out] */ 
            __out  UI_ANIMATION_SECONDS *duration);
        
        END_INTERFACE
    } IUIAnimationTransitionVtbl;

    interface IUIAnimationTransition
    {
        CONST_VTBL struct IUIAnimationTransitionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAnimationTransition_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAnimationTransition_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAnimationTransition_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAnimationTransition_SetInitialValue(This,value)	\
    ( (This)->lpVtbl -> SetInitialValue(This,value) ) 

#define IUIAnimationTransition_SetInitialVelocity(This,velocity)	\
    ( (This)->lpVtbl -> SetInitialVelocity(This,velocity) ) 

#define IUIAnimationTransition_IsDurationKnown(This)	\
    ( (This)->lpVtbl -> IsDurationKnown(This) ) 

#define IUIAnimationTransition_GetDuration(This,duration)	\
    ( (This)->lpVtbl -> GetDuration(This,duration) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAnimationTransition_INTERFACE_DEFINED__ */


#ifndef __IUIAnimationManagerEventHandler_INTERFACE_DEFINED__
#define __IUIAnimationManagerEventHandler_INTERFACE_DEFINED__

/* interface IUIAnimationManagerEventHandler */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IUIAnimationManagerEventHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("783321ED-78A3-4366-B574-6AF607A64788")
    IUIAnimationManagerEventHandler : public IUnknown
    {
    public:
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE OnManagerStatusChanged( 
            /* [annotation][in] */ 
            __in  UI_ANIMATION_MANAGER_STATUS newStatus,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_MANAGER_STATUS previousStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAnimationManagerEventHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUIAnimationManagerEventHandler * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUIAnimationManagerEventHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUIAnimationManagerEventHandler * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *OnManagerStatusChanged )( 
            IUIAnimationManagerEventHandler * This,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_MANAGER_STATUS newStatus,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_MANAGER_STATUS previousStatus);
        
        END_INTERFACE
    } IUIAnimationManagerEventHandlerVtbl;

    interface IUIAnimationManagerEventHandler
    {
        CONST_VTBL struct IUIAnimationManagerEventHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAnimationManagerEventHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAnimationManagerEventHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAnimationManagerEventHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAnimationManagerEventHandler_OnManagerStatusChanged(This,newStatus,previousStatus)	\
    ( (This)->lpVtbl -> OnManagerStatusChanged(This,newStatus,previousStatus) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAnimationManagerEventHandler_INTERFACE_DEFINED__ */


#ifndef __IUIAnimationVariableChangeHandler_INTERFACE_DEFINED__
#define __IUIAnimationVariableChangeHandler_INTERFACE_DEFINED__

/* interface IUIAnimationVariableChangeHandler */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IUIAnimationVariableChangeHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6358B7BA-87D2-42d5-BF71-82E919DD5862")
    IUIAnimationVariableChangeHandler : public IUnknown
    {
    public:
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE OnValueChanged( 
            /* [annotation][in] */ 
            __in  IUIAnimationStoryboard *storyboard,
            /* [annotation][in] */ 
            __in  IUIAnimationVariable *variable,
            /* [annotation][in] */ 
            __in  DOUBLE newValue,
            /* [annotation][in] */ 
            __in  DOUBLE previousValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAnimationVariableChangeHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUIAnimationVariableChangeHandler * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUIAnimationVariableChangeHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUIAnimationVariableChangeHandler * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *OnValueChanged )( 
            IUIAnimationVariableChangeHandler * This,
            /* [annotation][in] */ 
            __in  IUIAnimationStoryboard *storyboard,
            /* [annotation][in] */ 
            __in  IUIAnimationVariable *variable,
            /* [annotation][in] */ 
            __in  DOUBLE newValue,
            /* [annotation][in] */ 
            __in  DOUBLE previousValue);
        
        END_INTERFACE
    } IUIAnimationVariableChangeHandlerVtbl;

    interface IUIAnimationVariableChangeHandler
    {
        CONST_VTBL struct IUIAnimationVariableChangeHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAnimationVariableChangeHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAnimationVariableChangeHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAnimationVariableChangeHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAnimationVariableChangeHandler_OnValueChanged(This,storyboard,variable,newValue,previousValue)	\
    ( (This)->lpVtbl -> OnValueChanged(This,storyboard,variable,newValue,previousValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAnimationVariableChangeHandler_INTERFACE_DEFINED__ */


#ifndef __IUIAnimationVariableIntegerChangeHandler_INTERFACE_DEFINED__
#define __IUIAnimationVariableIntegerChangeHandler_INTERFACE_DEFINED__

/* interface IUIAnimationVariableIntegerChangeHandler */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IUIAnimationVariableIntegerChangeHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BB3E1550-356E-44b0-99DA-85AC6017865E")
    IUIAnimationVariableIntegerChangeHandler : public IUnknown
    {
    public:
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE OnIntegerValueChanged( 
            /* [annotation][in] */ 
            __in  IUIAnimationStoryboard *storyboard,
            /* [annotation][in] */ 
            __in  IUIAnimationVariable *variable,
            /* [annotation][in] */ 
            __in  INT32 newValue,
            /* [annotation][in] */ 
            __in  INT32 previousValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAnimationVariableIntegerChangeHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUIAnimationVariableIntegerChangeHandler * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUIAnimationVariableIntegerChangeHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUIAnimationVariableIntegerChangeHandler * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *OnIntegerValueChanged )( 
            IUIAnimationVariableIntegerChangeHandler * This,
            /* [annotation][in] */ 
            __in  IUIAnimationStoryboard *storyboard,
            /* [annotation][in] */ 
            __in  IUIAnimationVariable *variable,
            /* [annotation][in] */ 
            __in  INT32 newValue,
            /* [annotation][in] */ 
            __in  INT32 previousValue);
        
        END_INTERFACE
    } IUIAnimationVariableIntegerChangeHandlerVtbl;

    interface IUIAnimationVariableIntegerChangeHandler
    {
        CONST_VTBL struct IUIAnimationVariableIntegerChangeHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAnimationVariableIntegerChangeHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAnimationVariableIntegerChangeHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAnimationVariableIntegerChangeHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAnimationVariableIntegerChangeHandler_OnIntegerValueChanged(This,storyboard,variable,newValue,previousValue)	\
    ( (This)->lpVtbl -> OnIntegerValueChanged(This,storyboard,variable,newValue,previousValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAnimationVariableIntegerChangeHandler_INTERFACE_DEFINED__ */


#ifndef __IUIAnimationStoryboardEventHandler_INTERFACE_DEFINED__
#define __IUIAnimationStoryboardEventHandler_INTERFACE_DEFINED__

/* interface IUIAnimationStoryboardEventHandler */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IUIAnimationStoryboardEventHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3D5C9008-EC7C-4364-9F8A-9AF3C58CBAE6")
    IUIAnimationStoryboardEventHandler : public IUnknown
    {
    public:
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE OnStoryboardStatusChanged( 
            /* [annotation][in] */ 
            __in  IUIAnimationStoryboard *storyboard,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_STORYBOARD_STATUS newStatus,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_STORYBOARD_STATUS previousStatus) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE OnStoryboardUpdated( 
            /* [annotation][in] */ 
            __in  IUIAnimationStoryboard *storyboard) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAnimationStoryboardEventHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUIAnimationStoryboardEventHandler * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUIAnimationStoryboardEventHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUIAnimationStoryboardEventHandler * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *OnStoryboardStatusChanged )( 
            IUIAnimationStoryboardEventHandler * This,
            /* [annotation][in] */ 
            __in  IUIAnimationStoryboard *storyboard,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_STORYBOARD_STATUS newStatus,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_STORYBOARD_STATUS previousStatus);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *OnStoryboardUpdated )( 
            IUIAnimationStoryboardEventHandler * This,
            /* [annotation][in] */ 
            __in  IUIAnimationStoryboard *storyboard);
        
        END_INTERFACE
    } IUIAnimationStoryboardEventHandlerVtbl;

    interface IUIAnimationStoryboardEventHandler
    {
        CONST_VTBL struct IUIAnimationStoryboardEventHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAnimationStoryboardEventHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAnimationStoryboardEventHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAnimationStoryboardEventHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAnimationStoryboardEventHandler_OnStoryboardStatusChanged(This,storyboard,newStatus,previousStatus)	\
    ( (This)->lpVtbl -> OnStoryboardStatusChanged(This,storyboard,newStatus,previousStatus) ) 

#define IUIAnimationStoryboardEventHandler_OnStoryboardUpdated(This,storyboard)	\
    ( (This)->lpVtbl -> OnStoryboardUpdated(This,storyboard) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAnimationStoryboardEventHandler_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_UIAnimation_0000_0008 */
/* [local] */ 

typedef /* [public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_UIAnimation_0000_0008_0001
    {	UI_ANIMATION_PRIORITY_EFFECT_FAILURE	= 0,
	UI_ANIMATION_PRIORITY_EFFECT_DELAY	= 1
    } 	UI_ANIMATION_PRIORITY_EFFECT;



extern RPC_IF_HANDLE __MIDL_itf_UIAnimation_0000_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_UIAnimation_0000_0008_v0_0_s_ifspec;

#ifndef __IUIAnimationPriorityComparison_INTERFACE_DEFINED__
#define __IUIAnimationPriorityComparison_INTERFACE_DEFINED__

/* interface IUIAnimationPriorityComparison */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IUIAnimationPriorityComparison;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("83FA9B74-5F86-4618-BC6A-A2FAC19B3F44")
    IUIAnimationPriorityComparison : public IUnknown
    {
    public:
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE HasPriority( 
            /* [annotation][in] */ 
            __in  IUIAnimationStoryboard *scheduledStoryboard,
            /* [annotation][in] */ 
            __in  IUIAnimationStoryboard *newStoryboard,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_PRIORITY_EFFECT priorityEffect) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAnimationPriorityComparisonVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUIAnimationPriorityComparison * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUIAnimationPriorityComparison * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUIAnimationPriorityComparison * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *HasPriority )( 
            IUIAnimationPriorityComparison * This,
            /* [annotation][in] */ 
            __in  IUIAnimationStoryboard *scheduledStoryboard,
            /* [annotation][in] */ 
            __in  IUIAnimationStoryboard *newStoryboard,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_PRIORITY_EFFECT priorityEffect);
        
        END_INTERFACE
    } IUIAnimationPriorityComparisonVtbl;

    interface IUIAnimationPriorityComparison
    {
        CONST_VTBL struct IUIAnimationPriorityComparisonVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAnimationPriorityComparison_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAnimationPriorityComparison_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAnimationPriorityComparison_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAnimationPriorityComparison_HasPriority(This,scheduledStoryboard,newStoryboard,priorityEffect)	\
    ( (This)->lpVtbl -> HasPriority(This,scheduledStoryboard,newStoryboard,priorityEffect) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAnimationPriorityComparison_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_UIAnimation_0000_0009 */
/* [local] */ 

typedef /* [public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_UIAnimation_0000_0009_0001
    {	UI_ANIMATION_SLOPE_INCREASING	= 0,
	UI_ANIMATION_SLOPE_DECREASING	= 1
    } 	UI_ANIMATION_SLOPE;



extern RPC_IF_HANDLE __MIDL_itf_UIAnimation_0000_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_UIAnimation_0000_0009_v0_0_s_ifspec;

#ifndef __IUIAnimationTransitionLibrary_INTERFACE_DEFINED__
#define __IUIAnimationTransitionLibrary_INTERFACE_DEFINED__

/* interface IUIAnimationTransitionLibrary */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IUIAnimationTransitionLibrary;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CA5A14B1-D24F-48b8-8FE4-C78169BA954E")
    IUIAnimationTransitionLibrary : public IUnknown
    {
    public:
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE CreateInstantaneousTransition( 
            /* [annotation][in] */ 
            __in  DOUBLE finalValue,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationTransition **transition) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE CreateConstantTransition( 
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS duration,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationTransition **transition) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE CreateDiscreteTransition( 
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS delay,
            /* [annotation][in] */ 
            __in  DOUBLE finalValue,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS hold,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationTransition **transition) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE CreateLinearTransition( 
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS duration,
            /* [annotation][in] */ 
            __in  DOUBLE finalValue,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationTransition **transition) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE CreateLinearTransitionFromSpeed( 
            /* [annotation][in] */ 
            __in  DOUBLE speed,
            /* [annotation][in] */ 
            __in  DOUBLE finalValue,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationTransition **transition) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE CreateSinusoidalTransitionFromVelocity( 
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS duration,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS period,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationTransition **transition) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE CreateSinusoidalTransitionFromRange( 
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS duration,
            /* [annotation][in] */ 
            __in  DOUBLE minimumValue,
            /* [annotation][in] */ 
            __in  DOUBLE maximumValue,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS period,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SLOPE slope,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationTransition **transition) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE CreateAccelerateDecelerateTransition( 
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS duration,
            /* [annotation][in] */ 
            __in  DOUBLE finalValue,
            /* [annotation][in] */ 
            __in  DOUBLE accelerationRatio,
            /* [annotation][in] */ 
            __in  DOUBLE decelerationRatio,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationTransition **transition) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE CreateReversalTransition( 
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS duration,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationTransition **transition) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE CreateCubicTransition( 
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS duration,
            /* [annotation][in] */ 
            __in  DOUBLE finalValue,
            /* [annotation][in] */ 
            __in  DOUBLE finalVelocity,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationTransition **transition) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE CreateSmoothStopTransition( 
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS maximumDuration,
            /* [annotation][in] */ 
            __in  DOUBLE finalValue,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationTransition **transition) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE CreateParabolicTransitionFromAcceleration( 
            /* [annotation][in] */ 
            __in  DOUBLE finalValue,
            /* [annotation][in] */ 
            __in  DOUBLE finalVelocity,
            /* [annotation][in] */ 
            __in  DOUBLE acceleration,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationTransition **transition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAnimationTransitionLibraryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUIAnimationTransitionLibrary * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUIAnimationTransitionLibrary * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUIAnimationTransitionLibrary * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *CreateInstantaneousTransition )( 
            IUIAnimationTransitionLibrary * This,
            /* [annotation][in] */ 
            __in  DOUBLE finalValue,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationTransition **transition);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *CreateConstantTransition )( 
            IUIAnimationTransitionLibrary * This,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS duration,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationTransition **transition);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *CreateDiscreteTransition )( 
            IUIAnimationTransitionLibrary * This,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS delay,
            /* [annotation][in] */ 
            __in  DOUBLE finalValue,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS hold,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationTransition **transition);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *CreateLinearTransition )( 
            IUIAnimationTransitionLibrary * This,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS duration,
            /* [annotation][in] */ 
            __in  DOUBLE finalValue,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationTransition **transition);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *CreateLinearTransitionFromSpeed )( 
            IUIAnimationTransitionLibrary * This,
            /* [annotation][in] */ 
            __in  DOUBLE speed,
            /* [annotation][in] */ 
            __in  DOUBLE finalValue,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationTransition **transition);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *CreateSinusoidalTransitionFromVelocity )( 
            IUIAnimationTransitionLibrary * This,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS duration,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS period,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationTransition **transition);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *CreateSinusoidalTransitionFromRange )( 
            IUIAnimationTransitionLibrary * This,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS duration,
            /* [annotation][in] */ 
            __in  DOUBLE minimumValue,
            /* [annotation][in] */ 
            __in  DOUBLE maximumValue,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS period,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SLOPE slope,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationTransition **transition);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *CreateAccelerateDecelerateTransition )( 
            IUIAnimationTransitionLibrary * This,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS duration,
            /* [annotation][in] */ 
            __in  DOUBLE finalValue,
            /* [annotation][in] */ 
            __in  DOUBLE accelerationRatio,
            /* [annotation][in] */ 
            __in  DOUBLE decelerationRatio,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationTransition **transition);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *CreateReversalTransition )( 
            IUIAnimationTransitionLibrary * This,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS duration,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationTransition **transition);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *CreateCubicTransition )( 
            IUIAnimationTransitionLibrary * This,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS duration,
            /* [annotation][in] */ 
            __in  DOUBLE finalValue,
            /* [annotation][in] */ 
            __in  DOUBLE finalVelocity,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationTransition **transition);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *CreateSmoothStopTransition )( 
            IUIAnimationTransitionLibrary * This,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS maximumDuration,
            /* [annotation][in] */ 
            __in  DOUBLE finalValue,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationTransition **transition);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *CreateParabolicTransitionFromAcceleration )( 
            IUIAnimationTransitionLibrary * This,
            /* [annotation][in] */ 
            __in  DOUBLE finalValue,
            /* [annotation][in] */ 
            __in  DOUBLE finalVelocity,
            /* [annotation][in] */ 
            __in  DOUBLE acceleration,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationTransition **transition);
        
        END_INTERFACE
    } IUIAnimationTransitionLibraryVtbl;

    interface IUIAnimationTransitionLibrary
    {
        CONST_VTBL struct IUIAnimationTransitionLibraryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAnimationTransitionLibrary_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAnimationTransitionLibrary_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAnimationTransitionLibrary_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAnimationTransitionLibrary_CreateInstantaneousTransition(This,finalValue,transition)	\
    ( (This)->lpVtbl -> CreateInstantaneousTransition(This,finalValue,transition) ) 

#define IUIAnimationTransitionLibrary_CreateConstantTransition(This,duration,transition)	\
    ( (This)->lpVtbl -> CreateConstantTransition(This,duration,transition) ) 

#define IUIAnimationTransitionLibrary_CreateDiscreteTransition(This,delay,finalValue,hold,transition)	\
    ( (This)->lpVtbl -> CreateDiscreteTransition(This,delay,finalValue,hold,transition) ) 

#define IUIAnimationTransitionLibrary_CreateLinearTransition(This,duration,finalValue,transition)	\
    ( (This)->lpVtbl -> CreateLinearTransition(This,duration,finalValue,transition) ) 

#define IUIAnimationTransitionLibrary_CreateLinearTransitionFromSpeed(This,speed,finalValue,transition)	\
    ( (This)->lpVtbl -> CreateLinearTransitionFromSpeed(This,speed,finalValue,transition) ) 

#define IUIAnimationTransitionLibrary_CreateSinusoidalTransitionFromVelocity(This,duration,period,transition)	\
    ( (This)->lpVtbl -> CreateSinusoidalTransitionFromVelocity(This,duration,period,transition) ) 

#define IUIAnimationTransitionLibrary_CreateSinusoidalTransitionFromRange(This,duration,minimumValue,maximumValue,period,slope,transition)	\
    ( (This)->lpVtbl -> CreateSinusoidalTransitionFromRange(This,duration,minimumValue,maximumValue,period,slope,transition) ) 

#define IUIAnimationTransitionLibrary_CreateAccelerateDecelerateTransition(This,duration,finalValue,accelerationRatio,decelerationRatio,transition)	\
    ( (This)->lpVtbl -> CreateAccelerateDecelerateTransition(This,duration,finalValue,accelerationRatio,decelerationRatio,transition) ) 

#define IUIAnimationTransitionLibrary_CreateReversalTransition(This,duration,transition)	\
    ( (This)->lpVtbl -> CreateReversalTransition(This,duration,transition) ) 

#define IUIAnimationTransitionLibrary_CreateCubicTransition(This,duration,finalValue,finalVelocity,transition)	\
    ( (This)->lpVtbl -> CreateCubicTransition(This,duration,finalValue,finalVelocity,transition) ) 

#define IUIAnimationTransitionLibrary_CreateSmoothStopTransition(This,maximumDuration,finalValue,transition)	\
    ( (This)->lpVtbl -> CreateSmoothStopTransition(This,maximumDuration,finalValue,transition) ) 

#define IUIAnimationTransitionLibrary_CreateParabolicTransitionFromAcceleration(This,finalValue,finalVelocity,acceleration,transition)	\
    ( (This)->lpVtbl -> CreateParabolicTransitionFromAcceleration(This,finalValue,finalVelocity,acceleration,transition) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAnimationTransitionLibrary_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_UIAnimation_0000_0010 */
/* [local] */ 

typedef /* [public][public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_UIAnimation_0000_0010_0001
    {	UI_ANIMATION_DEPENDENCY_NONE	= 0,
	UI_ANIMATION_DEPENDENCY_INTERMEDIATE_VALUES	= 0x1,
	UI_ANIMATION_DEPENDENCY_FINAL_VALUE	= 0x2,
	UI_ANIMATION_DEPENDENCY_FINAL_VELOCITY	= 0x4,
	UI_ANIMATION_DEPENDENCY_DURATION	= 0x8
    } 	UI_ANIMATION_DEPENDENCIES;

DEFINE_ENUM_FLAG_OPERATORS(UI_ANIMATION_DEPENDENCIES);


extern RPC_IF_HANDLE __MIDL_itf_UIAnimation_0000_0010_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_UIAnimation_0000_0010_v0_0_s_ifspec;

#ifndef __IUIAnimationInterpolator_INTERFACE_DEFINED__
#define __IUIAnimationInterpolator_INTERFACE_DEFINED__

/* interface IUIAnimationInterpolator */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IUIAnimationInterpolator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7815CBBA-DDF7-478c-A46C-7B6C738B7978")
    IUIAnimationInterpolator : public IUnknown
    {
    public:
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE SetInitialValueAndVelocity( 
            /* [annotation][in] */ 
            __in  DOUBLE initialValue,
            /* [annotation][in] */ 
            __in  DOUBLE initialVelocity) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE SetDuration( 
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS duration) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE GetDuration( 
            /* [annotation][retval][out] */ 
            __out  UI_ANIMATION_SECONDS *duration) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE GetFinalValue( 
            /* [annotation][retval][out] */ 
            __out  DOUBLE *value) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE InterpolateValue( 
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS offset,
            /* [annotation][retval][out] */ 
            __out  DOUBLE *value) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE InterpolateVelocity( 
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS offset,
            /* [annotation][retval][out] */ 
            __out  DOUBLE *velocity) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE GetDependencies( 
            /* [annotation][out] */ 
            __out  UI_ANIMATION_DEPENDENCIES *initialValueDependencies,
            /* [annotation][out] */ 
            __out  UI_ANIMATION_DEPENDENCIES *initialVelocityDependencies,
            /* [annotation][out] */ 
            __out  UI_ANIMATION_DEPENDENCIES *durationDependencies) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAnimationInterpolatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUIAnimationInterpolator * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUIAnimationInterpolator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUIAnimationInterpolator * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *SetInitialValueAndVelocity )( 
            IUIAnimationInterpolator * This,
            /* [annotation][in] */ 
            __in  DOUBLE initialValue,
            /* [annotation][in] */ 
            __in  DOUBLE initialVelocity);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *SetDuration )( 
            IUIAnimationInterpolator * This,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS duration);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *GetDuration )( 
            IUIAnimationInterpolator * This,
            /* [annotation][retval][out] */ 
            __out  UI_ANIMATION_SECONDS *duration);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *GetFinalValue )( 
            IUIAnimationInterpolator * This,
            /* [annotation][retval][out] */ 
            __out  DOUBLE *value);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *InterpolateValue )( 
            IUIAnimationInterpolator * This,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS offset,
            /* [annotation][retval][out] */ 
            __out  DOUBLE *value);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *InterpolateVelocity )( 
            IUIAnimationInterpolator * This,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS offset,
            /* [annotation][retval][out] */ 
            __out  DOUBLE *velocity);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *GetDependencies )( 
            IUIAnimationInterpolator * This,
            /* [annotation][out] */ 
            __out  UI_ANIMATION_DEPENDENCIES *initialValueDependencies,
            /* [annotation][out] */ 
            __out  UI_ANIMATION_DEPENDENCIES *initialVelocityDependencies,
            /* [annotation][out] */ 
            __out  UI_ANIMATION_DEPENDENCIES *durationDependencies);
        
        END_INTERFACE
    } IUIAnimationInterpolatorVtbl;

    interface IUIAnimationInterpolator
    {
        CONST_VTBL struct IUIAnimationInterpolatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAnimationInterpolator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAnimationInterpolator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAnimationInterpolator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAnimationInterpolator_SetInitialValueAndVelocity(This,initialValue,initialVelocity)	\
    ( (This)->lpVtbl -> SetInitialValueAndVelocity(This,initialValue,initialVelocity) ) 

#define IUIAnimationInterpolator_SetDuration(This,duration)	\
    ( (This)->lpVtbl -> SetDuration(This,duration) ) 

#define IUIAnimationInterpolator_GetDuration(This,duration)	\
    ( (This)->lpVtbl -> GetDuration(This,duration) ) 

#define IUIAnimationInterpolator_GetFinalValue(This,value)	\
    ( (This)->lpVtbl -> GetFinalValue(This,value) ) 

#define IUIAnimationInterpolator_InterpolateValue(This,offset,value)	\
    ( (This)->lpVtbl -> InterpolateValue(This,offset,value) ) 

#define IUIAnimationInterpolator_InterpolateVelocity(This,offset,velocity)	\
    ( (This)->lpVtbl -> InterpolateVelocity(This,offset,velocity) ) 

#define IUIAnimationInterpolator_GetDependencies(This,initialValueDependencies,initialVelocityDependencies,durationDependencies)	\
    ( (This)->lpVtbl -> GetDependencies(This,initialValueDependencies,initialVelocityDependencies,durationDependencies) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAnimationInterpolator_INTERFACE_DEFINED__ */


#ifndef __IUIAnimationTransitionFactory_INTERFACE_DEFINED__
#define __IUIAnimationTransitionFactory_INTERFACE_DEFINED__

/* interface IUIAnimationTransitionFactory */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IUIAnimationTransitionFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FCD91E03-3E3B-45ad-BBB1-6DFC8153743D")
    IUIAnimationTransitionFactory : public IUnknown
    {
    public:
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE CreateTransition( 
            /* [annotation][in] */ 
            __in  IUIAnimationInterpolator *interpolator,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationTransition **transition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAnimationTransitionFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUIAnimationTransitionFactory * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUIAnimationTransitionFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUIAnimationTransitionFactory * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *CreateTransition )( 
            IUIAnimationTransitionFactory * This,
            /* [annotation][in] */ 
            __in  IUIAnimationInterpolator *interpolator,
            /* [annotation][retval][out] */ 
            __deref_out  IUIAnimationTransition **transition);
        
        END_INTERFACE
    } IUIAnimationTransitionFactoryVtbl;

    interface IUIAnimationTransitionFactory
    {
        CONST_VTBL struct IUIAnimationTransitionFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAnimationTransitionFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAnimationTransitionFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAnimationTransitionFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAnimationTransitionFactory_CreateTransition(This,interpolator,transition)	\
    ( (This)->lpVtbl -> CreateTransition(This,interpolator,transition) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAnimationTransitionFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_UIAnimation_0000_0012 */
/* [local] */ 

typedef /* [public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_UIAnimation_0000_0012_0001
    {	UI_ANIMATION_IDLE_BEHAVIOR_CONTINUE	= 0,
	UI_ANIMATION_IDLE_BEHAVIOR_DISABLE	= 1
    } 	UI_ANIMATION_IDLE_BEHAVIOR;



extern RPC_IF_HANDLE __MIDL_itf_UIAnimation_0000_0012_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_UIAnimation_0000_0012_v0_0_s_ifspec;

#ifndef __IUIAnimationTimer_INTERFACE_DEFINED__
#define __IUIAnimationTimer_INTERFACE_DEFINED__

/* interface IUIAnimationTimer */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IUIAnimationTimer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6B0EFAD1-A053-41d6-9085-33A689144665")
    IUIAnimationTimer : public IUnknown
    {
    public:
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE SetTimerUpdateHandler( 
            /* [annotation][unique][in] */ 
            __in_opt  IUIAnimationTimerUpdateHandler *updateHandler,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_IDLE_BEHAVIOR idleBehavior) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE SetTimerEventHandler( 
            /* [annotation][unique][in] */ 
            __in_opt  IUIAnimationTimerEventHandler *handler) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE Enable( void) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE Disable( void) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE IsEnabled( void) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE GetTime( 
            /* [annotation][out] */ 
            __out  UI_ANIMATION_SECONDS *seconds) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE SetFrameRateThreshold( 
            /* [annotation][in] */ 
            __in  UINT32 framesPerSecond) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAnimationTimerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUIAnimationTimer * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUIAnimationTimer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUIAnimationTimer * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *SetTimerUpdateHandler )( 
            IUIAnimationTimer * This,
            /* [annotation][unique][in] */ 
            __in_opt  IUIAnimationTimerUpdateHandler *updateHandler,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_IDLE_BEHAVIOR idleBehavior);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *SetTimerEventHandler )( 
            IUIAnimationTimer * This,
            /* [annotation][unique][in] */ 
            __in_opt  IUIAnimationTimerEventHandler *handler);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *Enable )( 
            IUIAnimationTimer * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *Disable )( 
            IUIAnimationTimer * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *IsEnabled )( 
            IUIAnimationTimer * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *GetTime )( 
            IUIAnimationTimer * This,
            /* [annotation][out] */ 
            __out  UI_ANIMATION_SECONDS *seconds);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *SetFrameRateThreshold )( 
            IUIAnimationTimer * This,
            /* [annotation][in] */ 
            __in  UINT32 framesPerSecond);
        
        END_INTERFACE
    } IUIAnimationTimerVtbl;

    interface IUIAnimationTimer
    {
        CONST_VTBL struct IUIAnimationTimerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAnimationTimer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAnimationTimer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAnimationTimer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAnimationTimer_SetTimerUpdateHandler(This,updateHandler,idleBehavior)	\
    ( (This)->lpVtbl -> SetTimerUpdateHandler(This,updateHandler,idleBehavior) ) 

#define IUIAnimationTimer_SetTimerEventHandler(This,handler)	\
    ( (This)->lpVtbl -> SetTimerEventHandler(This,handler) ) 

#define IUIAnimationTimer_Enable(This)	\
    ( (This)->lpVtbl -> Enable(This) ) 

#define IUIAnimationTimer_Disable(This)	\
    ( (This)->lpVtbl -> Disable(This) ) 

#define IUIAnimationTimer_IsEnabled(This)	\
    ( (This)->lpVtbl -> IsEnabled(This) ) 

#define IUIAnimationTimer_GetTime(This,seconds)	\
    ( (This)->lpVtbl -> GetTime(This,seconds) ) 

#define IUIAnimationTimer_SetFrameRateThreshold(This,framesPerSecond)	\
    ( (This)->lpVtbl -> SetFrameRateThreshold(This,framesPerSecond) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAnimationTimer_INTERFACE_DEFINED__ */


#ifndef __IUIAnimationTimerUpdateHandler_INTERFACE_DEFINED__
#define __IUIAnimationTimerUpdateHandler_INTERFACE_DEFINED__

/* interface IUIAnimationTimerUpdateHandler */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IUIAnimationTimerUpdateHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("195509B7-5D5E-4e3e-B278-EE3759B367AD")
    IUIAnimationTimerUpdateHandler : public IUnknown
    {
    public:
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE OnUpdate( 
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS timeNow,
            /* [annotation][retval][out] */ 
            __out  UI_ANIMATION_UPDATE_RESULT *result) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE SetTimerClientEventHandler( 
            /* [annotation][in] */ 
            __in  IUIAnimationTimerClientEventHandler *handler) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE ClearTimerClientEventHandler( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAnimationTimerUpdateHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUIAnimationTimerUpdateHandler * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUIAnimationTimerUpdateHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUIAnimationTimerUpdateHandler * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *OnUpdate )( 
            IUIAnimationTimerUpdateHandler * This,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_SECONDS timeNow,
            /* [annotation][retval][out] */ 
            __out  UI_ANIMATION_UPDATE_RESULT *result);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *SetTimerClientEventHandler )( 
            IUIAnimationTimerUpdateHandler * This,
            /* [annotation][in] */ 
            __in  IUIAnimationTimerClientEventHandler *handler);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *ClearTimerClientEventHandler )( 
            IUIAnimationTimerUpdateHandler * This);
        
        END_INTERFACE
    } IUIAnimationTimerUpdateHandlerVtbl;

    interface IUIAnimationTimerUpdateHandler
    {
        CONST_VTBL struct IUIAnimationTimerUpdateHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAnimationTimerUpdateHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAnimationTimerUpdateHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAnimationTimerUpdateHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAnimationTimerUpdateHandler_OnUpdate(This,timeNow,result)	\
    ( (This)->lpVtbl -> OnUpdate(This,timeNow,result) ) 

#define IUIAnimationTimerUpdateHandler_SetTimerClientEventHandler(This,handler)	\
    ( (This)->lpVtbl -> SetTimerClientEventHandler(This,handler) ) 

#define IUIAnimationTimerUpdateHandler_ClearTimerClientEventHandler(This)	\
    ( (This)->lpVtbl -> ClearTimerClientEventHandler(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAnimationTimerUpdateHandler_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_UIAnimation_0000_0014 */
/* [local] */ 

typedef /* [public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_UIAnimation_0000_0014_0001
    {	UI_ANIMATION_TIMER_CLIENT_IDLE	= 0,
	UI_ANIMATION_TIMER_CLIENT_BUSY	= 1
    } 	UI_ANIMATION_TIMER_CLIENT_STATUS;



extern RPC_IF_HANDLE __MIDL_itf_UIAnimation_0000_0014_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_UIAnimation_0000_0014_v0_0_s_ifspec;

#ifndef __IUIAnimationTimerClientEventHandler_INTERFACE_DEFINED__
#define __IUIAnimationTimerClientEventHandler_INTERFACE_DEFINED__

/* interface IUIAnimationTimerClientEventHandler */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IUIAnimationTimerClientEventHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BEDB4DB6-94FA-4bfb-A47F-EF2D9E408C25")
    IUIAnimationTimerClientEventHandler : public IUnknown
    {
    public:
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE OnTimerClientStatusChanged( 
            /* [annotation][in] */ 
            __in  UI_ANIMATION_TIMER_CLIENT_STATUS newStatus,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_TIMER_CLIENT_STATUS previousStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAnimationTimerClientEventHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUIAnimationTimerClientEventHandler * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUIAnimationTimerClientEventHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUIAnimationTimerClientEventHandler * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *OnTimerClientStatusChanged )( 
            IUIAnimationTimerClientEventHandler * This,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_TIMER_CLIENT_STATUS newStatus,
            /* [annotation][in] */ 
            __in  UI_ANIMATION_TIMER_CLIENT_STATUS previousStatus);
        
        END_INTERFACE
    } IUIAnimationTimerClientEventHandlerVtbl;

    interface IUIAnimationTimerClientEventHandler
    {
        CONST_VTBL struct IUIAnimationTimerClientEventHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAnimationTimerClientEventHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAnimationTimerClientEventHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAnimationTimerClientEventHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAnimationTimerClientEventHandler_OnTimerClientStatusChanged(This,newStatus,previousStatus)	\
    ( (This)->lpVtbl -> OnTimerClientStatusChanged(This,newStatus,previousStatus) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAnimationTimerClientEventHandler_INTERFACE_DEFINED__ */


#ifndef __IUIAnimationTimerEventHandler_INTERFACE_DEFINED__
#define __IUIAnimationTimerEventHandler_INTERFACE_DEFINED__

/* interface IUIAnimationTimerEventHandler */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IUIAnimationTimerEventHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("274A7DEA-D771-4095-ABBD-8DF7ABD23CE3")
    IUIAnimationTimerEventHandler : public IUnknown
    {
    public:
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE OnPreUpdate( void) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE OnPostUpdate( void) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE OnRenderingTooSlow( 
            /* [annotation][in] */ 
            __in  UINT32 framesPerSecond) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAnimationTimerEventHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUIAnimationTimerEventHandler * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUIAnimationTimerEventHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUIAnimationTimerEventHandler * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *OnPreUpdate )( 
            IUIAnimationTimerEventHandler * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *OnPostUpdate )( 
            IUIAnimationTimerEventHandler * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *OnRenderingTooSlow )( 
            IUIAnimationTimerEventHandler * This,
            /* [annotation][in] */ 
            __in  UINT32 framesPerSecond);
        
        END_INTERFACE
    } IUIAnimationTimerEventHandlerVtbl;

    interface IUIAnimationTimerEventHandler
    {
        CONST_VTBL struct IUIAnimationTimerEventHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAnimationTimerEventHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAnimationTimerEventHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAnimationTimerEventHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAnimationTimerEventHandler_OnPreUpdate(This)	\
    ( (This)->lpVtbl -> OnPreUpdate(This) ) 

#define IUIAnimationTimerEventHandler_OnPostUpdate(This)	\
    ( (This)->lpVtbl -> OnPostUpdate(This) ) 

#define IUIAnimationTimerEventHandler_OnRenderingTooSlow(This,framesPerSecond)	\
    ( (This)->lpVtbl -> OnRenderingTooSlow(This,framesPerSecond) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAnimationTimerEventHandler_INTERFACE_DEFINED__ */



#ifndef __UIAnimation_LIBRARY_DEFINED__
#define __UIAnimation_LIBRARY_DEFINED__

/* library UIAnimation */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_UIAnimation;

EXTERN_C const CLSID CLSID_UIAnimationManager;

#ifdef __cplusplus

class DECLSPEC_UUID("4C1FC63A-695C-47E8-A339-1A194BE3D0B8")
UIAnimationManager;
#endif

EXTERN_C const CLSID CLSID_UIAnimationTransitionLibrary;

#ifdef __cplusplus

class DECLSPEC_UUID("1D6322AD-AA85-4EF5-A828-86D71067D145")
UIAnimationTransitionLibrary;
#endif

EXTERN_C const CLSID CLSID_UIAnimationTransitionFactory;

#ifdef __cplusplus

class DECLSPEC_UUID("8A9B1CDD-FCD7-419c-8B44-42FD17DB1887")
UIAnimationTransitionFactory;
#endif

EXTERN_C const CLSID CLSID_UIAnimationTimer;

#ifdef __cplusplus

class DECLSPEC_UUID("BFCD4A0C-06B6-4384-B768-0DAA792C380E")
UIAnimationTimer;
#endif
#endif /* __UIAnimation_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\UIAutomationClient.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for uiautomationclient.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __uiautomationclient_h__
#define __uiautomationclient_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IUIAutomationElement_FWD_DEFINED__
#define __IUIAutomationElement_FWD_DEFINED__
typedef interface IUIAutomationElement IUIAutomationElement;
#endif 	/* __IUIAutomationElement_FWD_DEFINED__ */


#ifndef __IUIAutomationElementArray_FWD_DEFINED__
#define __IUIAutomationElementArray_FWD_DEFINED__
typedef interface IUIAutomationElementArray IUIAutomationElementArray;
#endif 	/* __IUIAutomationElementArray_FWD_DEFINED__ */


#ifndef __IUIAutomationCondition_FWD_DEFINED__
#define __IUIAutomationCondition_FWD_DEFINED__
typedef interface IUIAutomationCondition IUIAutomationCondition;
#endif 	/* __IUIAutomationCondition_FWD_DEFINED__ */


#ifndef __IUIAutomationBoolCondition_FWD_DEFINED__
#define __IUIAutomationBoolCondition_FWD_DEFINED__
typedef interface IUIAutomationBoolCondition IUIAutomationBoolCondition;
#endif 	/* __IUIAutomationBoolCondition_FWD_DEFINED__ */


#ifndef __IUIAutomationPropertyCondition_FWD_DEFINED__
#define __IUIAutomationPropertyCondition_FWD_DEFINED__
typedef interface IUIAutomationPropertyCondition IUIAutomationPropertyCondition;
#endif 	/* __IUIAutomationPropertyCondition_FWD_DEFINED__ */


#ifndef __IUIAutomationAndCondition_FWD_DEFINED__
#define __IUIAutomationAndCondition_FWD_DEFINED__
typedef interface IUIAutomationAndCondition IUIAutomationAndCondition;
#endif 	/* __IUIAutomationAndCondition_FWD_DEFINED__ */


#ifndef __IUIAutomationOrCondition_FWD_DEFINED__
#define __IUIAutomationOrCondition_FWD_DEFINED__
typedef interface IUIAutomationOrCondition IUIAutomationOrCondition;
#endif 	/* __IUIAutomationOrCondition_FWD_DEFINED__ */


#ifndef __IUIAutomationNotCondition_FWD_DEFINED__
#define __IUIAutomationNotCondition_FWD_DEFINED__
typedef interface IUIAutomationNotCondition IUIAutomationNotCondition;
#endif 	/* __IUIAutomationNotCondition_FWD_DEFINED__ */


#ifndef __IUIAutomationCacheRequest_FWD_DEFINED__
#define __IUIAutomationCacheRequest_FWD_DEFINED__
typedef interface IUIAutomationCacheRequest IUIAutomationCacheRequest;
#endif 	/* __IUIAutomationCacheRequest_FWD_DEFINED__ */


#ifndef __IUIAutomationTreeWalker_FWD_DEFINED__
#define __IUIAutomationTreeWalker_FWD_DEFINED__
typedef interface IUIAutomationTreeWalker IUIAutomationTreeWalker;
#endif 	/* __IUIAutomationTreeWalker_FWD_DEFINED__ */


#ifndef __IUIAutomationEventHandler_FWD_DEFINED__
#define __IUIAutomationEventHandler_FWD_DEFINED__
typedef interface IUIAutomationEventHandler IUIAutomationEventHandler;
#endif 	/* __IUIAutomationEventHandler_FWD_DEFINED__ */


#ifndef __IUIAutomationPropertyChangedEventHandler_FWD_DEFINED__
#define __IUIAutomationPropertyChangedEventHandler_FWD_DEFINED__
typedef interface IUIAutomationPropertyChangedEventHandler IUIAutomationPropertyChangedEventHandler;
#endif 	/* __IUIAutomationPropertyChangedEventHandler_FWD_DEFINED__ */


#ifndef __IUIAutomationStructureChangedEventHandler_FWD_DEFINED__
#define __IUIAutomationStructureChangedEventHandler_FWD_DEFINED__
typedef interface IUIAutomationStructureChangedEventHandler IUIAutomationStructureChangedEventHandler;
#endif 	/* __IUIAutomationStructureChangedEventHandler_FWD_DEFINED__ */


#ifndef __IUIAutomationFocusChangedEventHandler_FWD_DEFINED__
#define __IUIAutomationFocusChangedEventHandler_FWD_DEFINED__
typedef interface IUIAutomationFocusChangedEventHandler IUIAutomationFocusChangedEventHandler;
#endif 	/* __IUIAutomationFocusChangedEventHandler_FWD_DEFINED__ */


#ifndef __IUIAutomationInvokePattern_FWD_DEFINED__
#define __IUIAutomationInvokePattern_FWD_DEFINED__
typedef interface IUIAutomationInvokePattern IUIAutomationInvokePattern;
#endif 	/* __IUIAutomationInvokePattern_FWD_DEFINED__ */


#ifndef __IUIAutomationDockPattern_FWD_DEFINED__
#define __IUIAutomationDockPattern_FWD_DEFINED__
typedef interface IUIAutomationDockPattern IUIAutomationDockPattern;
#endif 	/* __IUIAutomationDockPattern_FWD_DEFINED__ */


#ifndef __IUIAutomationExpandCollapsePattern_FWD_DEFINED__
#define __IUIAutomationExpandCollapsePattern_FWD_DEFINED__
typedef interface IUIAutomationExpandCollapsePattern IUIAutomationExpandCollapsePattern;
#endif 	/* __IUIAutomationExpandCollapsePattern_FWD_DEFINED__ */


#ifndef __IUIAutomationGridPattern_FWD_DEFINED__
#define __IUIAutomationGridPattern_FWD_DEFINED__
typedef interface IUIAutomationGridPattern IUIAutomationGridPattern;
#endif 	/* __IUIAutomationGridPattern_FWD_DEFINED__ */


#ifndef __IUIAutomationGridItemPattern_FWD_DEFINED__
#define __IUIAutomationGridItemPattern_FWD_DEFINED__
typedef interface IUIAutomationGridItemPattern IUIAutomationGridItemPattern;
#endif 	/* __IUIAutomationGridItemPattern_FWD_DEFINED__ */


#ifndef __IUIAutomationMultipleViewPattern_FWD_DEFINED__
#define __IUIAutomationMultipleViewPattern_FWD_DEFINED__
typedef interface IUIAutomationMultipleViewPattern IUIAutomationMultipleViewPattern;
#endif 	/* __IUIAutomationMultipleViewPattern_FWD_DEFINED__ */


#ifndef __IUIAutomationRangeValuePattern_FWD_DEFINED__
#define __IUIAutomationRangeValuePattern_FWD_DEFINED__
typedef interface IUIAutomationRangeValuePattern IUIAutomationRangeValuePattern;
#endif 	/* __IUIAutomationRangeValuePattern_FWD_DEFINED__ */


#ifndef __IUIAutomationScrollPattern_FWD_DEFINED__
#define __IUIAutomationScrollPattern_FWD_DEFINED__
typedef interface IUIAutomationScrollPattern IUIAutomationScrollPattern;
#endif 	/* __IUIAutomationScrollPattern_FWD_DEFINED__ */


#ifndef __IUIAutomationScrollItemPattern_FWD_DEFINED__
#define __IUIAutomationScrollItemPattern_FWD_DEFINED__
typedef interface IUIAutomationScrollItemPattern IUIAutomationScrollItemPattern;
#endif 	/* __IUIAutomationScrollItemPattern_FWD_DEFINED__ */


#ifndef __IUIAutomationSelectionPattern_FWD_DEFINED__
#define __IUIAutomationSelectionPattern_FWD_DEFINED__
typedef interface IUIAutomationSelectionPattern IUIAutomationSelectionPattern;
#endif 	/* __IUIAutomationSelectionPattern_FWD_DEFINED__ */


#ifndef __IUIAutomationSelectionItemPattern_FWD_DEFINED__
#define __IUIAutomationSelectionItemPattern_FWD_DEFINED__
typedef interface IUIAutomationSelectionItemPattern IUIAutomationSelectionItemPattern;
#endif 	/* __IUIAutomationSelectionItemPattern_FWD_DEFINED__ */


#ifndef __IUIAutomationSynchronizedInputPattern_FWD_DEFINED__
#define __IUIAutomationSynchronizedInputPattern_FWD_DEFINED__
typedef interface IUIAutomationSynchronizedInputPattern IUIAutomationSynchronizedInputPattern;
#endif 	/* __IUIAutomationSynchronizedInputPattern_FWD_DEFINED__ */


#ifndef __IUIAutomationTablePattern_FWD_DEFINED__
#define __IUIAutomationTablePattern_FWD_DEFINED__
typedef interface IUIAutomationTablePattern IUIAutomationTablePattern;
#endif 	/* __IUIAutomationTablePattern_FWD_DEFINED__ */


#ifndef __IUIAutomationTableItemPattern_FWD_DEFINED__
#define __IUIAutomationTableItemPattern_FWD_DEFINED__
typedef interface IUIAutomationTableItemPattern IUIAutomationTableItemPattern;
#endif 	/* __IUIAutomationTableItemPattern_FWD_DEFINED__ */


#ifndef __IUIAutomationTogglePattern_FWD_DEFINED__
#define __IUIAutomationTogglePattern_FWD_DEFINED__
typedef interface IUIAutomationTogglePattern IUIAutomationTogglePattern;
#endif 	/* __IUIAutomationTogglePattern_FWD_DEFINED__ */


#ifndef __IUIAutomationTransformPattern_FWD_DEFINED__
#define __IUIAutomationTransformPattern_FWD_DEFINED__
typedef interface IUIAutomationTransformPattern IUIAutomationTransformPattern;
#endif 	/* __IUIAutomationTransformPattern_FWD_DEFINED__ */


#ifndef __IUIAutomationValuePattern_FWD_DEFINED__
#define __IUIAutomationValuePattern_FWD_DEFINED__
typedef interface IUIAutomationValuePattern IUIAutomationValuePattern;
#endif 	/* __IUIAutomationValuePattern_FWD_DEFINED__ */


#ifndef __IUIAutomationWindowPattern_FWD_DEFINED__
#define __IUIAutomationWindowPattern_FWD_DEFINED__
typedef interface IUIAutomationWindowPattern IUIAutomationWindowPattern;
#endif 	/* __IUIAutomationWindowPattern_FWD_DEFINED__ */


#ifndef __IUIAutomationTextRange_FWD_DEFINED__
#define __IUIAutomationTextRange_FWD_DEFINED__
typedef interface IUIAutomationTextRange IUIAutomationTextRange;
#endif 	/* __IUIAutomationTextRange_FWD_DEFINED__ */


#ifndef __IUIAutomationTextRangeArray_FWD_DEFINED__
#define __IUIAutomationTextRangeArray_FWD_DEFINED__
typedef interface IUIAutomationTextRangeArray IUIAutomationTextRangeArray;
#endif 	/* __IUIAutomationTextRangeArray_FWD_DEFINED__ */


#ifndef __IUIAutomationTextPattern_FWD_DEFINED__
#define __IUIAutomationTextPattern_FWD_DEFINED__
typedef interface IUIAutomationTextPattern IUIAutomationTextPattern;
#endif 	/* __IUIAutomationTextPattern_FWD_DEFINED__ */


#ifndef __IUIAutomationLegacyIAccessiblePattern_FWD_DEFINED__
#define __IUIAutomationLegacyIAccessiblePattern_FWD_DEFINED__
typedef interface IUIAutomationLegacyIAccessiblePattern IUIAutomationLegacyIAccessiblePattern;
#endif 	/* __IUIAutomationLegacyIAccessiblePattern_FWD_DEFINED__ */


#ifndef __IUIAutomationItemContainerPattern_FWD_DEFINED__
#define __IUIAutomationItemContainerPattern_FWD_DEFINED__
typedef interface IUIAutomationItemContainerPattern IUIAutomationItemContainerPattern;
#endif 	/* __IUIAutomationItemContainerPattern_FWD_DEFINED__ */


#ifndef __IUIAutomationVirtualizedItemPattern_FWD_DEFINED__
#define __IUIAutomationVirtualizedItemPattern_FWD_DEFINED__
typedef interface IUIAutomationVirtualizedItemPattern IUIAutomationVirtualizedItemPattern;
#endif 	/* __IUIAutomationVirtualizedItemPattern_FWD_DEFINED__ */


#ifndef __IUIAutomationProxyFactory_FWD_DEFINED__
#define __IUIAutomationProxyFactory_FWD_DEFINED__
typedef interface IUIAutomationProxyFactory IUIAutomationProxyFactory;
#endif 	/* __IUIAutomationProxyFactory_FWD_DEFINED__ */


#ifndef __IUIAutomationProxyFactoryEntry_FWD_DEFINED__
#define __IUIAutomationProxyFactoryEntry_FWD_DEFINED__
typedef interface IUIAutomationProxyFactoryEntry IUIAutomationProxyFactoryEntry;
#endif 	/* __IUIAutomationProxyFactoryEntry_FWD_DEFINED__ */


#ifndef __IUIAutomationProxyFactoryMapping_FWD_DEFINED__
#define __IUIAutomationProxyFactoryMapping_FWD_DEFINED__
typedef interface IUIAutomationProxyFactoryMapping IUIAutomationProxyFactoryMapping;
#endif 	/* __IUIAutomationProxyFactoryMapping_FWD_DEFINED__ */


#ifndef __IUIAutomation_FWD_DEFINED__
#define __IUIAutomation_FWD_DEFINED__
typedef interface IUIAutomation IUIAutomation;
#endif 	/* __IUIAutomation_FWD_DEFINED__ */


#ifndef __CUIAutomation_FWD_DEFINED__
#define __CUIAutomation_FWD_DEFINED__

#ifdef __cplusplus
typedef class CUIAutomation CUIAutomation;
#else
typedef struct CUIAutomation CUIAutomation;
#endif /* __cplusplus */

#endif 	/* __CUIAutomation_FWD_DEFINED__ */


/* header files for imported files */
#include "UIAutomationCore.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_uiautomationclient_0000_0000 */
/* [local] */ 

// -------------------------------------------------------------
// UIAutomationClient.H
//
// UIAutomation Client interface definitions and related types and enums
// (Generated from UIAutomationClient.idl)
//
// Copyright (c) Microsoft Corporation. All rights reserved.
// -------------------------------------------------------------


enum TreeScope
    {	TreeScope_Element	= 0x1,
	TreeScope_Children	= 0x2,
	TreeScope_Descendants	= 0x4,
	TreeScope_Parent	= 0x8,
	TreeScope_Ancestors	= 0x10,
	TreeScope_Subtree	= ( ( TreeScope_Element | TreeScope_Children )  | TreeScope_Descendants ) 
    } ;

enum PropertyConditionFlags
    {	PropertyConditionFlags_None	= 0,
	PropertyConditionFlags_IgnoreCase	= 0x1
    } ;

enum AutomationElementMode
    {	AutomationElementMode_None	= 0,
	AutomationElementMode_Full	= ( AutomationElementMode_None + 1 ) 
    } ;
typedef void *UIA_HWND;



extern RPC_IF_HANDLE __MIDL_itf_uiautomationclient_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_uiautomationclient_0000_0000_v0_0_s_ifspec;


#ifndef __UIAutomationClient_LIBRARY_DEFINED__
#define __UIAutomationClient_LIBRARY_DEFINED__

/* library UIAutomationClient */
/* [version][lcid][uuid] */ 




EXTERN_C const IID LIBID_UIAutomationClient;


#ifndef __UIA_PatternIds_MODULE_DEFINED__
#define __UIA_PatternIds_MODULE_DEFINED__


/* module UIA_PatternIds */
/* [dllname] */ 

const long UIA_InvokePatternId	=	10000;

const long UIA_SelectionPatternId	=	10001;

const long UIA_ValuePatternId	=	10002;

const long UIA_RangeValuePatternId	=	10003;

const long UIA_ScrollPatternId	=	10004;

const long UIA_ExpandCollapsePatternId	=	10005;

const long UIA_GridPatternId	=	10006;

const long UIA_GridItemPatternId	=	10007;

const long UIA_MultipleViewPatternId	=	10008;

const long UIA_WindowPatternId	=	10009;

const long UIA_SelectionItemPatternId	=	10010;

const long UIA_DockPatternId	=	10011;

const long UIA_TablePatternId	=	10012;

const long UIA_TableItemPatternId	=	10013;

const long UIA_TextPatternId	=	10014;

const long UIA_TogglePatternId	=	10015;

const long UIA_TransformPatternId	=	10016;

const long UIA_ScrollItemPatternId	=	10017;

const long UIA_LegacyIAccessiblePatternId	=	10018;

const long UIA_ItemContainerPatternId	=	10019;

const long UIA_VirtualizedItemPatternId	=	10020;

const long UIA_SynchronizedInputPatternId	=	10021;

#endif /* __UIA_PatternIds_MODULE_DEFINED__ */


#ifndef __UIA_EventIds_MODULE_DEFINED__
#define __UIA_EventIds_MODULE_DEFINED__


/* module UIA_EventIds */
/* [dllname] */ 

const long UIA_ToolTipOpenedEventId	=	20000;

const long UIA_ToolTipClosedEventId	=	20001;

const long UIA_StructureChangedEventId	=	20002;

const long UIA_MenuOpenedEventId	=	20003;

const long UIA_AutomationPropertyChangedEventId	=	20004;

const long UIA_AutomationFocusChangedEventId	=	20005;

const long UIA_AsyncContentLoadedEventId	=	20006;

const long UIA_MenuClosedEventId	=	20007;

const long UIA_LayoutInvalidatedEventId	=	20008;

const long UIA_Invoke_InvokedEventId	=	20009;

const long UIA_SelectionItem_ElementAddedToSelectionEventId	=	20010;

const long UIA_SelectionItem_ElementRemovedFromSelectionEventId	=	20011;

const long UIA_SelectionItem_ElementSelectedEventId	=	20012;

const long UIA_Selection_InvalidatedEventId	=	20013;

const long UIA_Text_TextSelectionChangedEventId	=	20014;

const long UIA_Text_TextChangedEventId	=	20015;

const long UIA_Window_WindowOpenedEventId	=	20016;

const long UIA_Window_WindowClosedEventId	=	20017;

const long UIA_MenuModeStartEventId	=	20018;

const long UIA_MenuModeEndEventId	=	20019;

const long UIA_InputReachedTargetEventId	=	20020;

const long UIA_InputReachedOtherElementEventId	=	20021;

const long UIA_InputDiscardedEventId	=	20022;

#endif /* __UIA_EventIds_MODULE_DEFINED__ */


#ifndef __UIA_PropertyIds_MODULE_DEFINED__
#define __UIA_PropertyIds_MODULE_DEFINED__


/* module UIA_PropertyIds */
/* [dllname] */ 

const long UIA_RuntimeIdPropertyId	=	30000;

const long UIA_BoundingRectanglePropertyId	=	30001;

const long UIA_ProcessIdPropertyId	=	30002;

const long UIA_ControlTypePropertyId	=	30003;

const long UIA_LocalizedControlTypePropertyId	=	30004;

const long UIA_NamePropertyId	=	30005;

const long UIA_AcceleratorKeyPropertyId	=	30006;

const long UIA_AccessKeyPropertyId	=	30007;

const long UIA_HasKeyboardFocusPropertyId	=	30008;

const long UIA_IsKeyboardFocusablePropertyId	=	30009;

const long UIA_IsEnabledPropertyId	=	30010;

const long UIA_AutomationIdPropertyId	=	30011;

const long UIA_ClassNamePropertyId	=	30012;

const long UIA_HelpTextPropertyId	=	30013;

const long UIA_ClickablePointPropertyId	=	30014;

const long UIA_CulturePropertyId	=	30015;

const long UIA_IsControlElementPropertyId	=	30016;

const long UIA_IsContentElementPropertyId	=	30017;

const long UIA_LabeledByPropertyId	=	30018;

const long UIA_IsPasswordPropertyId	=	30019;

const long UIA_NativeWindowHandlePropertyId	=	30020;

const long UIA_ItemTypePropertyId	=	30021;

const long UIA_IsOffscreenPropertyId	=	30022;

const long UIA_OrientationPropertyId	=	30023;

const long UIA_FrameworkIdPropertyId	=	30024;

const long UIA_IsRequiredForFormPropertyId	=	30025;

const long UIA_ItemStatusPropertyId	=	30026;

const long UIA_IsDockPatternAvailablePropertyId	=	30027;

const long UIA_IsExpandCollapsePatternAvailablePropertyId	=	30028;

const long UIA_IsGridItemPatternAvailablePropertyId	=	30029;

const long UIA_IsGridPatternAvailablePropertyId	=	30030;

const long UIA_IsInvokePatternAvailablePropertyId	=	30031;

const long UIA_IsMultipleViewPatternAvailablePropertyId	=	30032;

const long UIA_IsRangeValuePatternAvailablePropertyId	=	30033;

const long UIA_IsScrollPatternAvailablePropertyId	=	30034;

const long UIA_IsScrollItemPatternAvailablePropertyId	=	30035;

const long UIA_IsSelectionItemPatternAvailablePropertyId	=	30036;

const long UIA_IsSelectionPatternAvailablePropertyId	=	30037;

const long UIA_IsTablePatternAvailablePropertyId	=	30038;

const long UIA_IsTableItemPatternAvailablePropertyId	=	30039;

const long UIA_IsTextPatternAvailablePropertyId	=	30040;

const long UIA_IsTogglePatternAvailablePropertyId	=	30041;

const long UIA_IsTransformPatternAvailablePropertyId	=	30042;

const long UIA_IsValuePatternAvailablePropertyId	=	30043;

const long UIA_IsWindowPatternAvailablePropertyId	=	30044;

const long UIA_ValueValuePropertyId	=	30045;

const long UIA_ValueIsReadOnlyPropertyId	=	30046;

const long UIA_RangeValueValuePropertyId	=	30047;

const long UIA_RangeValueIsReadOnlyPropertyId	=	30048;

const long UIA_RangeValueMinimumPropertyId	=	30049;

const long UIA_RangeValueMaximumPropertyId	=	30050;

const long UIA_RangeValueLargeChangePropertyId	=	30051;

const long UIA_RangeValueSmallChangePropertyId	=	30052;

const long UIA_ScrollHorizontalScrollPercentPropertyId	=	30053;

const long UIA_ScrollHorizontalViewSizePropertyId	=	30054;

const long UIA_ScrollVerticalScrollPercentPropertyId	=	30055;

const long UIA_ScrollVerticalViewSizePropertyId	=	30056;

const long UIA_ScrollHorizontallyScrollablePropertyId	=	30057;

const long UIA_ScrollVerticallyScrollablePropertyId	=	30058;

const long UIA_SelectionSelectionPropertyId	=	30059;

const long UIA_SelectionCanSelectMultiplePropertyId	=	30060;

const long UIA_SelectionIsSelectionRequiredPropertyId	=	30061;

const long UIA_GridRowCountPropertyId	=	30062;

const long UIA_GridColumnCountPropertyId	=	30063;

const long UIA_GridItemRowPropertyId	=	30064;

const long UIA_GridItemColumnPropertyId	=	30065;

const long UIA_GridItemRowSpanPropertyId	=	30066;

const long UIA_GridItemColumnSpanPropertyId	=	30067;

const long UIA_GridItemContainingGridPropertyId	=	30068;

const long UIA_DockDockPositionPropertyId	=	30069;

const long UIA_ExpandCollapseExpandCollapseStatePropertyId	=	30070;

const long UIA_MultipleViewCurrentViewPropertyId	=	30071;

const long UIA_MultipleViewSupportedViewsPropertyId	=	30072;

const long UIA_WindowCanMaximizePropertyId	=	30073;

const long UIA_WindowCanMinimizePropertyId	=	30074;

const long UIA_WindowWindowVisualStatePropertyId	=	30075;

const long UIA_WindowWindowInteractionStatePropertyId	=	30076;

const long UIA_WindowIsModalPropertyId	=	30077;

const long UIA_WindowIsTopmostPropertyId	=	30078;

const long UIA_SelectionItemIsSelectedPropertyId	=	30079;

const long UIA_SelectionItemSelectionContainerPropertyId	=	30080;

const long UIA_TableRowHeadersPropertyId	=	30081;

const long UIA_TableColumnHeadersPropertyId	=	30082;

const long UIA_TableRowOrColumnMajorPropertyId	=	30083;

const long UIA_TableItemRowHeaderItemsPropertyId	=	30084;

const long UIA_TableItemColumnHeaderItemsPropertyId	=	30085;

const long UIA_ToggleToggleStatePropertyId	=	30086;

const long UIA_TransformCanMovePropertyId	=	30087;

const long UIA_TransformCanResizePropertyId	=	30088;

const long UIA_TransformCanRotatePropertyId	=	30089;

const long UIA_IsLegacyIAccessiblePatternAvailablePropertyId	=	30090;

const long UIA_LegacyIAccessibleChildIdPropertyId	=	30091;

const long UIA_LegacyIAccessibleNamePropertyId	=	30092;

const long UIA_LegacyIAccessibleValuePropertyId	=	30093;

const long UIA_LegacyIAccessibleDescriptionPropertyId	=	30094;

const long UIA_LegacyIAccessibleRolePropertyId	=	30095;

const long UIA_LegacyIAccessibleStatePropertyId	=	30096;

const long UIA_LegacyIAccessibleHelpPropertyId	=	30097;

const long UIA_LegacyIAccessibleKeyboardShortcutPropertyId	=	30098;

const long UIA_LegacyIAccessibleSelectionPropertyId	=	30099;

const long UIA_LegacyIAccessibleDefaultActionPropertyId	=	30100;

const long UIA_AriaRolePropertyId	=	30101;

const long UIA_AriaPropertiesPropertyId	=	30102;

const long UIA_IsDataValidForFormPropertyId	=	30103;

const long UIA_ControllerForPropertyId	=	30104;

const long UIA_DescribedByPropertyId	=	30105;

const long UIA_FlowsToPropertyId	=	30106;

const long UIA_ProviderDescriptionPropertyId	=	30107;

const long UIA_IsItemContainerPatternAvailablePropertyId	=	30108;

const long UIA_IsVirtualizedItemPatternAvailablePropertyId	=	30109;

const long UIA_IsSynchronizedInputPatternAvailablePropertyId	=	30110;

#endif /* __UIA_PropertyIds_MODULE_DEFINED__ */


#ifndef __UIA_TextAttributeIds_MODULE_DEFINED__
#define __UIA_TextAttributeIds_MODULE_DEFINED__


/* module UIA_TextAttributeIds */
/* [dllname] */ 

const long UIA_AnimationStyleAttributeId	=	40000;

const long UIA_BackgroundColorAttributeId	=	40001;

const long UIA_BulletStyleAttributeId	=	40002;

const long UIA_CapStyleAttributeId	=	40003;

const long UIA_CultureAttributeId	=	40004;

const long UIA_FontNameAttributeId	=	40005;

const long UIA_FontSizeAttributeId	=	40006;

const long UIA_FontWeightAttributeId	=	40007;

const long UIA_ForegroundColorAttributeId	=	40008;

const long UIA_HorizontalTextAlignmentAttributeId	=	40009;

const long UIA_IndentationFirstLineAttributeId	=	40010;

const long UIA_IndentationLeadingAttributeId	=	40011;

const long UIA_IndentationTrailingAttributeId	=	40012;

const long UIA_IsHiddenAttributeId	=	40013;

const long UIA_IsItalicAttributeId	=	40014;

const long UIA_IsReadOnlyAttributeId	=	40015;

const long UIA_IsSubscriptAttributeId	=	40016;

const long UIA_IsSuperscriptAttributeId	=	40017;

const long UIA_MarginBottomAttributeId	=	40018;

const long UIA_MarginLeadingAttributeId	=	40019;

const long UIA_MarginTopAttributeId	=	40020;

const long UIA_MarginTrailingAttributeId	=	40021;

const long UIA_OutlineStylesAttributeId	=	40022;

const long UIA_OverlineColorAttributeId	=	40023;

const long UIA_OverlineStyleAttributeId	=	40024;

const long UIA_StrikethroughColorAttributeId	=	40025;

const long UIA_StrikethroughStyleAttributeId	=	40026;

const long UIA_TabsAttributeId	=	40027;

const long UIA_TextFlowDirectionsAttributeId	=	40028;

const long UIA_UnderlineColorAttributeId	=	40029;

const long UIA_UnderlineStyleAttributeId	=	40030;

#endif /* __UIA_TextAttributeIds_MODULE_DEFINED__ */


#ifndef __UIA_ControlTypeIds_MODULE_DEFINED__
#define __UIA_ControlTypeIds_MODULE_DEFINED__


/* module UIA_ControlTypeIds */
/* [dllname] */ 

const long UIA_ButtonControlTypeId	=	50000;

const long UIA_CalendarControlTypeId	=	50001;

const long UIA_CheckBoxControlTypeId	=	50002;

const long UIA_ComboBoxControlTypeId	=	50003;

const long UIA_EditControlTypeId	=	50004;

const long UIA_HyperlinkControlTypeId	=	50005;

const long UIA_ImageControlTypeId	=	50006;

const long UIA_ListItemControlTypeId	=	50007;

const long UIA_ListControlTypeId	=	50008;

const long UIA_MenuControlTypeId	=	50009;

const long UIA_MenuBarControlTypeId	=	50010;

const long UIA_MenuItemControlTypeId	=	50011;

const long UIA_ProgressBarControlTypeId	=	50012;

const long UIA_RadioButtonControlTypeId	=	50013;

const long UIA_ScrollBarControlTypeId	=	50014;

const long UIA_SliderControlTypeId	=	50015;

const long UIA_SpinnerControlTypeId	=	50016;

const long UIA_StatusBarControlTypeId	=	50017;

const long UIA_TabControlTypeId	=	50018;

const long UIA_TabItemControlTypeId	=	50019;

const long UIA_TextControlTypeId	=	50020;

const long UIA_ToolBarControlTypeId	=	50021;

const long UIA_ToolTipControlTypeId	=	50022;

const long UIA_TreeControlTypeId	=	50023;

const long UIA_TreeItemControlTypeId	=	50024;

const long UIA_CustomControlTypeId	=	50025;

const long UIA_GroupControlTypeId	=	50026;

const long UIA_ThumbControlTypeId	=	50027;

const long UIA_DataGridControlTypeId	=	50028;

const long UIA_DataItemControlTypeId	=	50029;

const long UIA_DocumentControlTypeId	=	50030;

const long UIA_SplitButtonControlTypeId	=	50031;

const long UIA_WindowControlTypeId	=	50032;

const long UIA_PaneControlTypeId	=	50033;

const long UIA_HeaderControlTypeId	=	50034;

const long UIA_HeaderItemControlTypeId	=	50035;

const long UIA_TableControlTypeId	=	50036;

const long UIA_TitleBarControlTypeId	=	50037;

const long UIA_SeparatorControlTypeId	=	50038;

#endif /* __UIA_ControlTypeIds_MODULE_DEFINED__ */

#ifndef __IUIAutomationElement_INTERFACE_DEFINED__
#define __IUIAutomationElement_INTERFACE_DEFINED__

/* interface IUIAutomationElement */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d22108aa-8ac5-49a5-837b-37bbb3d7591e")
    IUIAutomationElement : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFocus( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRuntimeId( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *runtimeId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindFirst( 
            /* [in] */ enum TreeScope scope,
            /* [in] */ __RPC__in_opt IUIAutomationCondition *condition,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **found) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindAll( 
            /* [in] */ enum TreeScope scope,
            /* [in] */ __RPC__in_opt IUIAutomationCondition *condition,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **found) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindFirstBuildCache( 
            /* [in] */ enum TreeScope scope,
            /* [in] */ __RPC__in_opt IUIAutomationCondition *condition,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **found) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindAllBuildCache( 
            /* [in] */ enum TreeScope scope,
            /* [in] */ __RPC__in_opt IUIAutomationCondition *condition,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **found) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BuildUpdatedCache( 
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **updatedElement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentPropertyValue( 
            /* [in] */ PROPERTYID propertyId,
            /* [retval][out] */ __RPC__out VARIANT *retVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentPropertyValueEx( 
            /* [in] */ PROPERTYID propertyId,
            /* [in] */ BOOL ignoreDefaultValue,
            /* [retval][out] */ __RPC__out VARIANT *retVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCachedPropertyValue( 
            /* [in] */ PROPERTYID propertyId,
            /* [retval][out] */ __RPC__out VARIANT *retVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCachedPropertyValueEx( 
            /* [in] */ PROPERTYID propertyId,
            /* [in] */ BOOL ignoreDefaultValue,
            /* [retval][out] */ __RPC__out VARIANT *retVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentPatternAs( 
            /* [in] */ PATTERNID patternId,
            /* [in] */ __RPC__in REFIID riid,
            /* [retval][iid_is][out] */ __RPC__deref_out_opt void **patternObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCachedPatternAs( 
            /* [in] */ PATTERNID patternId,
            /* [in] */ __RPC__in REFIID riid,
            /* [retval][iid_is][out] */ __RPC__deref_out_opt void **patternObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentPattern( 
            /* [in] */ PATTERNID patternId,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **patternObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCachedPattern( 
            /* [in] */ PATTERNID patternId,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **patternObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCachedParent( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **parent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCachedChildren( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **children) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentProcessId( 
            /* [retval][out] */ __RPC__out int *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentControlType( 
            /* [retval][out] */ __RPC__out CONTROLTYPEID *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentLocalizedControlType( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentAcceleratorKey( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentAccessKey( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentHasKeyboardFocus( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentIsKeyboardFocusable( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentIsEnabled( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentAutomationId( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentClassName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentHelpText( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentCulture( 
            /* [retval][out] */ __RPC__out int *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentIsControlElement( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentIsContentElement( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentIsPassword( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentNativeWindowHandle( 
            /* [retval][out] */ __RPC__deref_out_opt UIA_HWND *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentItemType( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentIsOffscreen( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentOrientation( 
            /* [retval][out] */ __RPC__out enum OrientationType *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentFrameworkId( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentIsRequiredForForm( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentItemStatus( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentBoundingRectangle( 
            /* [retval][out] */ __RPC__out RECT *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentLabeledBy( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentAriaRole( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentAriaProperties( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentIsDataValidForForm( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentControllerFor( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentDescribedBy( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentFlowsTo( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentProviderDescription( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedProcessId( 
            /* [retval][out] */ __RPC__out int *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedControlType( 
            /* [retval][out] */ __RPC__out CONTROLTYPEID *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedLocalizedControlType( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedAcceleratorKey( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedAccessKey( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedHasKeyboardFocus( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedIsKeyboardFocusable( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedIsEnabled( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedAutomationId( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedClassName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedHelpText( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedCulture( 
            /* [retval][out] */ __RPC__out int *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedIsControlElement( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedIsContentElement( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedIsPassword( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedNativeWindowHandle( 
            /* [retval][out] */ __RPC__deref_out_opt UIA_HWND *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedItemType( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedIsOffscreen( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedOrientation( 
            /* [retval][out] */ __RPC__out enum OrientationType *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedFrameworkId( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedIsRequiredForForm( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedItemStatus( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedBoundingRectangle( 
            /* [retval][out] */ __RPC__out RECT *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedLabeledBy( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedAriaRole( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedAriaProperties( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedIsDataValidForForm( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedControllerFor( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedDescribedBy( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedFlowsTo( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedProviderDescription( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClickablePoint( 
            /* [out] */ __RPC__out POINT *clickable,
            /* [retval][out] */ __RPC__out BOOL *gotClickable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationElement * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationElement * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationElement * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFocus )( 
            __RPC__in IUIAutomationElement * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRuntimeId )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *runtimeId);
        
        HRESULT ( STDMETHODCALLTYPE *FindFirst )( 
            __RPC__in IUIAutomationElement * This,
            /* [in] */ enum TreeScope scope,
            /* [in] */ __RPC__in_opt IUIAutomationCondition *condition,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **found);
        
        HRESULT ( STDMETHODCALLTYPE *FindAll )( 
            __RPC__in IUIAutomationElement * This,
            /* [in] */ enum TreeScope scope,
            /* [in] */ __RPC__in_opt IUIAutomationCondition *condition,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **found);
        
        HRESULT ( STDMETHODCALLTYPE *FindFirstBuildCache )( 
            __RPC__in IUIAutomationElement * This,
            /* [in] */ enum TreeScope scope,
            /* [in] */ __RPC__in_opt IUIAutomationCondition *condition,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **found);
        
        HRESULT ( STDMETHODCALLTYPE *FindAllBuildCache )( 
            __RPC__in IUIAutomationElement * This,
            /* [in] */ enum TreeScope scope,
            /* [in] */ __RPC__in_opt IUIAutomationCondition *condition,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **found);
        
        HRESULT ( STDMETHODCALLTYPE *BuildUpdatedCache )( 
            __RPC__in IUIAutomationElement * This,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **updatedElement);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentPropertyValue )( 
            __RPC__in IUIAutomationElement * This,
            /* [in] */ PROPERTYID propertyId,
            /* [retval][out] */ __RPC__out VARIANT *retVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentPropertyValueEx )( 
            __RPC__in IUIAutomationElement * This,
            /* [in] */ PROPERTYID propertyId,
            /* [in] */ BOOL ignoreDefaultValue,
            /* [retval][out] */ __RPC__out VARIANT *retVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCachedPropertyValue )( 
            __RPC__in IUIAutomationElement * This,
            /* [in] */ PROPERTYID propertyId,
            /* [retval][out] */ __RPC__out VARIANT *retVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCachedPropertyValueEx )( 
            __RPC__in IUIAutomationElement * This,
            /* [in] */ PROPERTYID propertyId,
            /* [in] */ BOOL ignoreDefaultValue,
            /* [retval][out] */ __RPC__out VARIANT *retVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentPatternAs )( 
            __RPC__in IUIAutomationElement * This,
            /* [in] */ PATTERNID patternId,
            /* [in] */ __RPC__in REFIID riid,
            /* [retval][iid_is][out] */ __RPC__deref_out_opt void **patternObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetCachedPatternAs )( 
            __RPC__in IUIAutomationElement * This,
            /* [in] */ PATTERNID patternId,
            /* [in] */ __RPC__in REFIID riid,
            /* [retval][iid_is][out] */ __RPC__deref_out_opt void **patternObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentPattern )( 
            __RPC__in IUIAutomationElement * This,
            /* [in] */ PATTERNID patternId,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **patternObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetCachedPattern )( 
            __RPC__in IUIAutomationElement * This,
            /* [in] */ PATTERNID patternId,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **patternObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetCachedParent )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **parent);
        
        HRESULT ( STDMETHODCALLTYPE *GetCachedChildren )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **children);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentProcessId )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__out int *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentControlType )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__out CONTROLTYPEID *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentLocalizedControlType )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentName )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentAcceleratorKey )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentAccessKey )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentHasKeyboardFocus )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentIsKeyboardFocusable )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentIsEnabled )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentAutomationId )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentClassName )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentHelpText )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentCulture )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__out int *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentIsControlElement )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentIsContentElement )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentIsPassword )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentNativeWindowHandle )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt UIA_HWND *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentItemType )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentIsOffscreen )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentOrientation )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__out enum OrientationType *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentFrameworkId )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentIsRequiredForForm )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentItemStatus )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentBoundingRectangle )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__out RECT *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentLabeledBy )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentAriaRole )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentAriaProperties )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentIsDataValidForForm )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentControllerFor )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentDescribedBy )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentFlowsTo )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentProviderDescription )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedProcessId )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__out int *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedControlType )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__out CONTROLTYPEID *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedLocalizedControlType )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedName )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedAcceleratorKey )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedAccessKey )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedHasKeyboardFocus )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedIsKeyboardFocusable )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedIsEnabled )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedAutomationId )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedClassName )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedHelpText )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedCulture )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__out int *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedIsControlElement )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedIsContentElement )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedIsPassword )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedNativeWindowHandle )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt UIA_HWND *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedItemType )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedIsOffscreen )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedOrientation )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__out enum OrientationType *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedFrameworkId )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedIsRequiredForForm )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedItemStatus )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedBoundingRectangle )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__out RECT *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedLabeledBy )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedAriaRole )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedAriaProperties )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedIsDataValidForForm )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedControllerFor )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedDescribedBy )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedFlowsTo )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedProviderDescription )( 
            __RPC__in IUIAutomationElement * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetClickablePoint )( 
            __RPC__in IUIAutomationElement * This,
            /* [out] */ __RPC__out POINT *clickable,
            /* [retval][out] */ __RPC__out BOOL *gotClickable);
        
        END_INTERFACE
    } IUIAutomationElementVtbl;

    interface IUIAutomationElement
    {
        CONST_VTBL struct IUIAutomationElementVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationElement_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationElement_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationElement_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationElement_SetFocus(This)	\
    ( (This)->lpVtbl -> SetFocus(This) ) 

#define IUIAutomationElement_GetRuntimeId(This,runtimeId)	\
    ( (This)->lpVtbl -> GetRuntimeId(This,runtimeId) ) 

#define IUIAutomationElement_FindFirst(This,scope,condition,found)	\
    ( (This)->lpVtbl -> FindFirst(This,scope,condition,found) ) 

#define IUIAutomationElement_FindAll(This,scope,condition,found)	\
    ( (This)->lpVtbl -> FindAll(This,scope,condition,found) ) 

#define IUIAutomationElement_FindFirstBuildCache(This,scope,condition,cacheRequest,found)	\
    ( (This)->lpVtbl -> FindFirstBuildCache(This,scope,condition,cacheRequest,found) ) 

#define IUIAutomationElement_FindAllBuildCache(This,scope,condition,cacheRequest,found)	\
    ( (This)->lpVtbl -> FindAllBuildCache(This,scope,condition,cacheRequest,found) ) 

#define IUIAutomationElement_BuildUpdatedCache(This,cacheRequest,updatedElement)	\
    ( (This)->lpVtbl -> BuildUpdatedCache(This,cacheRequest,updatedElement) ) 

#define IUIAutomationElement_GetCurrentPropertyValue(This,propertyId,retVal)	\
    ( (This)->lpVtbl -> GetCurrentPropertyValue(This,propertyId,retVal) ) 

#define IUIAutomationElement_GetCurrentPropertyValueEx(This,propertyId,ignoreDefaultValue,retVal)	\
    ( (This)->lpVtbl -> GetCurrentPropertyValueEx(This,propertyId,ignoreDefaultValue,retVal) ) 

#define IUIAutomationElement_GetCachedPropertyValue(This,propertyId,retVal)	\
    ( (This)->lpVtbl -> GetCachedPropertyValue(This,propertyId,retVal) ) 

#define IUIAutomationElement_GetCachedPropertyValueEx(This,propertyId,ignoreDefaultValue,retVal)	\
    ( (This)->lpVtbl -> GetCachedPropertyValueEx(This,propertyId,ignoreDefaultValue,retVal) ) 

#define IUIAutomationElement_GetCurrentPatternAs(This,patternId,riid,patternObject)	\
    ( (This)->lpVtbl -> GetCurrentPatternAs(This,patternId,riid,patternObject) ) 

#define IUIAutomationElement_GetCachedPatternAs(This,patternId,riid,patternObject)	\
    ( (This)->lpVtbl -> GetCachedPatternAs(This,patternId,riid,patternObject) ) 

#define IUIAutomationElement_GetCurrentPattern(This,patternId,patternObject)	\
    ( (This)->lpVtbl -> GetCurrentPattern(This,patternId,patternObject) ) 

#define IUIAutomationElement_GetCachedPattern(This,patternId,patternObject)	\
    ( (This)->lpVtbl -> GetCachedPattern(This,patternId,patternObject) ) 

#define IUIAutomationElement_GetCachedParent(This,parent)	\
    ( (This)->lpVtbl -> GetCachedParent(This,parent) ) 

#define IUIAutomationElement_GetCachedChildren(This,children)	\
    ( (This)->lpVtbl -> GetCachedChildren(This,children) ) 

#define IUIAutomationElement_get_CurrentProcessId(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentProcessId(This,retVal) ) 

#define IUIAutomationElement_get_CurrentControlType(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentControlType(This,retVal) ) 

#define IUIAutomationElement_get_CurrentLocalizedControlType(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentLocalizedControlType(This,retVal) ) 

#define IUIAutomationElement_get_CurrentName(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentName(This,retVal) ) 

#define IUIAutomationElement_get_CurrentAcceleratorKey(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentAcceleratorKey(This,retVal) ) 

#define IUIAutomationElement_get_CurrentAccessKey(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentAccessKey(This,retVal) ) 

#define IUIAutomationElement_get_CurrentHasKeyboardFocus(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentHasKeyboardFocus(This,retVal) ) 

#define IUIAutomationElement_get_CurrentIsKeyboardFocusable(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentIsKeyboardFocusable(This,retVal) ) 

#define IUIAutomationElement_get_CurrentIsEnabled(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentIsEnabled(This,retVal) ) 

#define IUIAutomationElement_get_CurrentAutomationId(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentAutomationId(This,retVal) ) 

#define IUIAutomationElement_get_CurrentClassName(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentClassName(This,retVal) ) 

#define IUIAutomationElement_get_CurrentHelpText(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentHelpText(This,retVal) ) 

#define IUIAutomationElement_get_CurrentCulture(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentCulture(This,retVal) ) 

#define IUIAutomationElement_get_CurrentIsControlElement(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentIsControlElement(This,retVal) ) 

#define IUIAutomationElement_get_CurrentIsContentElement(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentIsContentElement(This,retVal) ) 

#define IUIAutomationElement_get_CurrentIsPassword(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentIsPassword(This,retVal) ) 

#define IUIAutomationElement_get_CurrentNativeWindowHandle(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentNativeWindowHandle(This,retVal) ) 

#define IUIAutomationElement_get_CurrentItemType(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentItemType(This,retVal) ) 

#define IUIAutomationElement_get_CurrentIsOffscreen(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentIsOffscreen(This,retVal) ) 

#define IUIAutomationElement_get_CurrentOrientation(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentOrientation(This,retVal) ) 

#define IUIAutomationElement_get_CurrentFrameworkId(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentFrameworkId(This,retVal) ) 

#define IUIAutomationElement_get_CurrentIsRequiredForForm(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentIsRequiredForForm(This,retVal) ) 

#define IUIAutomationElement_get_CurrentItemStatus(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentItemStatus(This,retVal) ) 

#define IUIAutomationElement_get_CurrentBoundingRectangle(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentBoundingRectangle(This,retVal) ) 

#define IUIAutomationElement_get_CurrentLabeledBy(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentLabeledBy(This,retVal) ) 

#define IUIAutomationElement_get_CurrentAriaRole(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentAriaRole(This,retVal) ) 

#define IUIAutomationElement_get_CurrentAriaProperties(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentAriaProperties(This,retVal) ) 

#define IUIAutomationElement_get_CurrentIsDataValidForForm(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentIsDataValidForForm(This,retVal) ) 

#define IUIAutomationElement_get_CurrentControllerFor(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentControllerFor(This,retVal) ) 

#define IUIAutomationElement_get_CurrentDescribedBy(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentDescribedBy(This,retVal) ) 

#define IUIAutomationElement_get_CurrentFlowsTo(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentFlowsTo(This,retVal) ) 

#define IUIAutomationElement_get_CurrentProviderDescription(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentProviderDescription(This,retVal) ) 

#define IUIAutomationElement_get_CachedProcessId(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedProcessId(This,retVal) ) 

#define IUIAutomationElement_get_CachedControlType(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedControlType(This,retVal) ) 

#define IUIAutomationElement_get_CachedLocalizedControlType(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedLocalizedControlType(This,retVal) ) 

#define IUIAutomationElement_get_CachedName(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedName(This,retVal) ) 

#define IUIAutomationElement_get_CachedAcceleratorKey(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedAcceleratorKey(This,retVal) ) 

#define IUIAutomationElement_get_CachedAccessKey(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedAccessKey(This,retVal) ) 

#define IUIAutomationElement_get_CachedHasKeyboardFocus(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedHasKeyboardFocus(This,retVal) ) 

#define IUIAutomationElement_get_CachedIsKeyboardFocusable(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedIsKeyboardFocusable(This,retVal) ) 

#define IUIAutomationElement_get_CachedIsEnabled(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedIsEnabled(This,retVal) ) 

#define IUIAutomationElement_get_CachedAutomationId(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedAutomationId(This,retVal) ) 

#define IUIAutomationElement_get_CachedClassName(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedClassName(This,retVal) ) 

#define IUIAutomationElement_get_CachedHelpText(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedHelpText(This,retVal) ) 

#define IUIAutomationElement_get_CachedCulture(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedCulture(This,retVal) ) 

#define IUIAutomationElement_get_CachedIsControlElement(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedIsControlElement(This,retVal) ) 

#define IUIAutomationElement_get_CachedIsContentElement(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedIsContentElement(This,retVal) ) 

#define IUIAutomationElement_get_CachedIsPassword(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedIsPassword(This,retVal) ) 

#define IUIAutomationElement_get_CachedNativeWindowHandle(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedNativeWindowHandle(This,retVal) ) 

#define IUIAutomationElement_get_CachedItemType(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedItemType(This,retVal) ) 

#define IUIAutomationElement_get_CachedIsOffscreen(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedIsOffscreen(This,retVal) ) 

#define IUIAutomationElement_get_CachedOrientation(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedOrientation(This,retVal) ) 

#define IUIAutomationElement_get_CachedFrameworkId(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedFrameworkId(This,retVal) ) 

#define IUIAutomationElement_get_CachedIsRequiredForForm(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedIsRequiredForForm(This,retVal) ) 

#define IUIAutomationElement_get_CachedItemStatus(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedItemStatus(This,retVal) ) 

#define IUIAutomationElement_get_CachedBoundingRectangle(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedBoundingRectangle(This,retVal) ) 

#define IUIAutomationElement_get_CachedLabeledBy(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedLabeledBy(This,retVal) ) 

#define IUIAutomationElement_get_CachedAriaRole(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedAriaRole(This,retVal) ) 

#define IUIAutomationElement_get_CachedAriaProperties(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedAriaProperties(This,retVal) ) 

#define IUIAutomationElement_get_CachedIsDataValidForForm(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedIsDataValidForForm(This,retVal) ) 

#define IUIAutomationElement_get_CachedControllerFor(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedControllerFor(This,retVal) ) 

#define IUIAutomationElement_get_CachedDescribedBy(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedDescribedBy(This,retVal) ) 

#define IUIAutomationElement_get_CachedFlowsTo(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedFlowsTo(This,retVal) ) 

#define IUIAutomationElement_get_CachedProviderDescription(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedProviderDescription(This,retVal) ) 

#define IUIAutomationElement_GetClickablePoint(This,clickable,gotClickable)	\
    ( (This)->lpVtbl -> GetClickablePoint(This,clickable,gotClickable) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationElement_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationElementArray_INTERFACE_DEFINED__
#define __IUIAutomationElementArray_INTERFACE_DEFINED__

/* interface IUIAutomationElementArray */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationElementArray;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("14314595-b4bc-4055-95f2-58f2e42c9855")
    IUIAutomationElementArray : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Length( 
            /* [retval][out] */ __RPC__out int *length) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetElement( 
            /* [in] */ int index,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **element) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationElementArrayVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationElementArray * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationElementArray * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationElementArray * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Length )( 
            __RPC__in IUIAutomationElementArray * This,
            /* [retval][out] */ __RPC__out int *length);
        
        HRESULT ( STDMETHODCALLTYPE *GetElement )( 
            __RPC__in IUIAutomationElementArray * This,
            /* [in] */ int index,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **element);
        
        END_INTERFACE
    } IUIAutomationElementArrayVtbl;

    interface IUIAutomationElementArray
    {
        CONST_VTBL struct IUIAutomationElementArrayVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationElementArray_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationElementArray_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationElementArray_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationElementArray_get_Length(This,length)	\
    ( (This)->lpVtbl -> get_Length(This,length) ) 

#define IUIAutomationElementArray_GetElement(This,index,element)	\
    ( (This)->lpVtbl -> GetElement(This,index,element) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationElementArray_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationCondition_INTERFACE_DEFINED__
#define __IUIAutomationCondition_INTERFACE_DEFINED__

/* interface IUIAutomationCondition */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationCondition;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("352ffba8-0973-437c-a61f-f64cafd81df9")
    IUIAutomationCondition : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationConditionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationCondition * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationCondition * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationCondition * This);
        
        END_INTERFACE
    } IUIAutomationConditionVtbl;

    interface IUIAutomationCondition
    {
        CONST_VTBL struct IUIAutomationConditionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationCondition_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationCondition_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationCondition_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationCondition_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationBoolCondition_INTERFACE_DEFINED__
#define __IUIAutomationBoolCondition_INTERFACE_DEFINED__

/* interface IUIAutomationBoolCondition */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationBoolCondition;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1b4e1f2e-75eb-4d0b-8952-5a69988e2307")
    IUIAutomationBoolCondition : public IUIAutomationCondition
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BooleanValue( 
            /* [retval][out] */ __RPC__out BOOL *boolVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationBoolConditionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationBoolCondition * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationBoolCondition * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationBoolCondition * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BooleanValue )( 
            __RPC__in IUIAutomationBoolCondition * This,
            /* [retval][out] */ __RPC__out BOOL *boolVal);
        
        END_INTERFACE
    } IUIAutomationBoolConditionVtbl;

    interface IUIAutomationBoolCondition
    {
        CONST_VTBL struct IUIAutomationBoolConditionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationBoolCondition_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationBoolCondition_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationBoolCondition_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 



#define IUIAutomationBoolCondition_get_BooleanValue(This,boolVal)	\
    ( (This)->lpVtbl -> get_BooleanValue(This,boolVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationBoolCondition_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationPropertyCondition_INTERFACE_DEFINED__
#define __IUIAutomationPropertyCondition_INTERFACE_DEFINED__

/* interface IUIAutomationPropertyCondition */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationPropertyCondition;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("99ebf2cb-5578-4267-9ad4-afd6ea77e94b")
    IUIAutomationPropertyCondition : public IUIAutomationCondition
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PropertyId( 
            /* [retval][out] */ __RPC__out PROPERTYID *propertyId) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PropertyValue( 
            /* [retval][out] */ __RPC__out VARIANT *propertyValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_PropertyConditionFlags( 
            /* [retval][out] */ __RPC__out enum PropertyConditionFlags *flags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationPropertyConditionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationPropertyCondition * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationPropertyCondition * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationPropertyCondition * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PropertyId )( 
            __RPC__in IUIAutomationPropertyCondition * This,
            /* [retval][out] */ __RPC__out PROPERTYID *propertyId);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PropertyValue )( 
            __RPC__in IUIAutomationPropertyCondition * This,
            /* [retval][out] */ __RPC__out VARIANT *propertyValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_PropertyConditionFlags )( 
            __RPC__in IUIAutomationPropertyCondition * This,
            /* [retval][out] */ __RPC__out enum PropertyConditionFlags *flags);
        
        END_INTERFACE
    } IUIAutomationPropertyConditionVtbl;

    interface IUIAutomationPropertyCondition
    {
        CONST_VTBL struct IUIAutomationPropertyConditionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationPropertyCondition_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationPropertyCondition_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationPropertyCondition_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 



#define IUIAutomationPropertyCondition_get_PropertyId(This,propertyId)	\
    ( (This)->lpVtbl -> get_PropertyId(This,propertyId) ) 

#define IUIAutomationPropertyCondition_get_PropertyValue(This,propertyValue)	\
    ( (This)->lpVtbl -> get_PropertyValue(This,propertyValue) ) 

#define IUIAutomationPropertyCondition_get_PropertyConditionFlags(This,flags)	\
    ( (This)->lpVtbl -> get_PropertyConditionFlags(This,flags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationPropertyCondition_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationAndCondition_INTERFACE_DEFINED__
#define __IUIAutomationAndCondition_INTERFACE_DEFINED__

/* interface IUIAutomationAndCondition */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationAndCondition;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a7d0af36-b912-45fe-9855-091ddc174aec")
    IUIAutomationAndCondition : public IUIAutomationCondition
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ChildCount( 
            /* [retval][out] */ __RPC__out int *childCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChildrenAsNativeArray( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*childArrayCount) IUIAutomationCondition ***childArray,
            /* [out] */ __RPC__out int *childArrayCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChildren( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *childArray) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationAndConditionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationAndCondition * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationAndCondition * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationAndCondition * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ChildCount )( 
            __RPC__in IUIAutomationAndCondition * This,
            /* [retval][out] */ __RPC__out int *childCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetChildrenAsNativeArray )( 
            __RPC__in IUIAutomationAndCondition * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*childArrayCount) IUIAutomationCondition ***childArray,
            /* [out] */ __RPC__out int *childArrayCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetChildren )( 
            __RPC__in IUIAutomationAndCondition * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *childArray);
        
        END_INTERFACE
    } IUIAutomationAndConditionVtbl;

    interface IUIAutomationAndCondition
    {
        CONST_VTBL struct IUIAutomationAndConditionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationAndCondition_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationAndCondition_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationAndCondition_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 



#define IUIAutomationAndCondition_get_ChildCount(This,childCount)	\
    ( (This)->lpVtbl -> get_ChildCount(This,childCount) ) 

#define IUIAutomationAndCondition_GetChildrenAsNativeArray(This,childArray,childArrayCount)	\
    ( (This)->lpVtbl -> GetChildrenAsNativeArray(This,childArray,childArrayCount) ) 

#define IUIAutomationAndCondition_GetChildren(This,childArray)	\
    ( (This)->lpVtbl -> GetChildren(This,childArray) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationAndCondition_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationOrCondition_INTERFACE_DEFINED__
#define __IUIAutomationOrCondition_INTERFACE_DEFINED__

/* interface IUIAutomationOrCondition */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationOrCondition;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8753f032-3db1-47b5-a1fc-6e34a266c712")
    IUIAutomationOrCondition : public IUIAutomationCondition
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ChildCount( 
            /* [retval][out] */ __RPC__out int *childCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChildrenAsNativeArray( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*childArrayCount) IUIAutomationCondition ***childArray,
            /* [out] */ __RPC__out int *childArrayCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChildren( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *childArray) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationOrConditionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationOrCondition * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationOrCondition * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationOrCondition * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ChildCount )( 
            __RPC__in IUIAutomationOrCondition * This,
            /* [retval][out] */ __RPC__out int *childCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetChildrenAsNativeArray )( 
            __RPC__in IUIAutomationOrCondition * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*childArrayCount) IUIAutomationCondition ***childArray,
            /* [out] */ __RPC__out int *childArrayCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetChildren )( 
            __RPC__in IUIAutomationOrCondition * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *childArray);
        
        END_INTERFACE
    } IUIAutomationOrConditionVtbl;

    interface IUIAutomationOrCondition
    {
        CONST_VTBL struct IUIAutomationOrConditionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationOrCondition_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationOrCondition_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationOrCondition_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 



#define IUIAutomationOrCondition_get_ChildCount(This,childCount)	\
    ( (This)->lpVtbl -> get_ChildCount(This,childCount) ) 

#define IUIAutomationOrCondition_GetChildrenAsNativeArray(This,childArray,childArrayCount)	\
    ( (This)->lpVtbl -> GetChildrenAsNativeArray(This,childArray,childArrayCount) ) 

#define IUIAutomationOrCondition_GetChildren(This,childArray)	\
    ( (This)->lpVtbl -> GetChildren(This,childArray) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationOrCondition_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationNotCondition_INTERFACE_DEFINED__
#define __IUIAutomationNotCondition_INTERFACE_DEFINED__

/* interface IUIAutomationNotCondition */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationNotCondition;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f528b657-847b-498c-8896-d52b565407a1")
    IUIAutomationNotCondition : public IUIAutomationCondition
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetChild( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **condition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationNotConditionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationNotCondition * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationNotCondition * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationNotCondition * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetChild )( 
            __RPC__in IUIAutomationNotCondition * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **condition);
        
        END_INTERFACE
    } IUIAutomationNotConditionVtbl;

    interface IUIAutomationNotCondition
    {
        CONST_VTBL struct IUIAutomationNotConditionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationNotCondition_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationNotCondition_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationNotCondition_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 



#define IUIAutomationNotCondition_GetChild(This,condition)	\
    ( (This)->lpVtbl -> GetChild(This,condition) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationNotCondition_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationCacheRequest_INTERFACE_DEFINED__
#define __IUIAutomationCacheRequest_INTERFACE_DEFINED__

/* interface IUIAutomationCacheRequest */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationCacheRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b32a92b5-bc25-4078-9c08-d7ee95c48e03")
    IUIAutomationCacheRequest : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddProperty( 
            /* [in] */ PROPERTYID propertyId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddPattern( 
            /* [in] */ PATTERNID patternId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCacheRequest **clonedRequest) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TreeScope( 
            /* [retval][out] */ __RPC__out enum TreeScope *scope) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_TreeScope( 
            /* [in] */ enum TreeScope scope) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TreeFilter( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **filter) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_TreeFilter( 
            /* [in] */ __RPC__in_opt IUIAutomationCondition *filter) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_AutomationElementMode( 
            /* [retval][out] */ __RPC__out enum AutomationElementMode *mode) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_AutomationElementMode( 
            /* [in] */ enum AutomationElementMode mode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationCacheRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationCacheRequest * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationCacheRequest * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationCacheRequest * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddProperty )( 
            __RPC__in IUIAutomationCacheRequest * This,
            /* [in] */ PROPERTYID propertyId);
        
        HRESULT ( STDMETHODCALLTYPE *AddPattern )( 
            __RPC__in IUIAutomationCacheRequest * This,
            /* [in] */ PATTERNID patternId);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IUIAutomationCacheRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCacheRequest **clonedRequest);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TreeScope )( 
            __RPC__in IUIAutomationCacheRequest * This,
            /* [retval][out] */ __RPC__out enum TreeScope *scope);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_TreeScope )( 
            __RPC__in IUIAutomationCacheRequest * This,
            /* [in] */ enum TreeScope scope);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TreeFilter )( 
            __RPC__in IUIAutomationCacheRequest * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **filter);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_TreeFilter )( 
            __RPC__in IUIAutomationCacheRequest * This,
            /* [in] */ __RPC__in_opt IUIAutomationCondition *filter);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_AutomationElementMode )( 
            __RPC__in IUIAutomationCacheRequest * This,
            /* [retval][out] */ __RPC__out enum AutomationElementMode *mode);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_AutomationElementMode )( 
            __RPC__in IUIAutomationCacheRequest * This,
            /* [in] */ enum AutomationElementMode mode);
        
        END_INTERFACE
    } IUIAutomationCacheRequestVtbl;

    interface IUIAutomationCacheRequest
    {
        CONST_VTBL struct IUIAutomationCacheRequestVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationCacheRequest_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationCacheRequest_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationCacheRequest_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationCacheRequest_AddProperty(This,propertyId)	\
    ( (This)->lpVtbl -> AddProperty(This,propertyId) ) 

#define IUIAutomationCacheRequest_AddPattern(This,patternId)	\
    ( (This)->lpVtbl -> AddPattern(This,patternId) ) 

#define IUIAutomationCacheRequest_Clone(This,clonedRequest)	\
    ( (This)->lpVtbl -> Clone(This,clonedRequest) ) 

#define IUIAutomationCacheRequest_get_TreeScope(This,scope)	\
    ( (This)->lpVtbl -> get_TreeScope(This,scope) ) 

#define IUIAutomationCacheRequest_put_TreeScope(This,scope)	\
    ( (This)->lpVtbl -> put_TreeScope(This,scope) ) 

#define IUIAutomationCacheRequest_get_TreeFilter(This,filter)	\
    ( (This)->lpVtbl -> get_TreeFilter(This,filter) ) 

#define IUIAutomationCacheRequest_put_TreeFilter(This,filter)	\
    ( (This)->lpVtbl -> put_TreeFilter(This,filter) ) 

#define IUIAutomationCacheRequest_get_AutomationElementMode(This,mode)	\
    ( (This)->lpVtbl -> get_AutomationElementMode(This,mode) ) 

#define IUIAutomationCacheRequest_put_AutomationElementMode(This,mode)	\
    ( (This)->lpVtbl -> put_AutomationElementMode(This,mode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationCacheRequest_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationTreeWalker_INTERFACE_DEFINED__
#define __IUIAutomationTreeWalker_INTERFACE_DEFINED__

/* interface IUIAutomationTreeWalker */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationTreeWalker;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4042c624-389c-4afc-a630-9df854a541fc")
    IUIAutomationTreeWalker : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetParentElement( 
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **parent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFirstChildElement( 
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **first) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastChildElement( 
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **last) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextSiblingElement( 
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **next) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPreviousSiblingElement( 
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **previous) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NormalizeElement( 
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **normalized) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParentElementBuildCache( 
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **parent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFirstChildElementBuildCache( 
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **first) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastChildElementBuildCache( 
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **last) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextSiblingElementBuildCache( 
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **next) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPreviousSiblingElementBuildCache( 
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **previous) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NormalizeElementBuildCache( 
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **normalized) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Condition( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **condition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationTreeWalkerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationTreeWalker * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationTreeWalker * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationTreeWalker * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetParentElement )( 
            __RPC__in IUIAutomationTreeWalker * This,
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **parent);
        
        HRESULT ( STDMETHODCALLTYPE *GetFirstChildElement )( 
            __RPC__in IUIAutomationTreeWalker * This,
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **first);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastChildElement )( 
            __RPC__in IUIAutomationTreeWalker * This,
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **last);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextSiblingElement )( 
            __RPC__in IUIAutomationTreeWalker * This,
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **next);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreviousSiblingElement )( 
            __RPC__in IUIAutomationTreeWalker * This,
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **previous);
        
        HRESULT ( STDMETHODCALLTYPE *NormalizeElement )( 
            __RPC__in IUIAutomationTreeWalker * This,
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **normalized);
        
        HRESULT ( STDMETHODCALLTYPE *GetParentElementBuildCache )( 
            __RPC__in IUIAutomationTreeWalker * This,
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **parent);
        
        HRESULT ( STDMETHODCALLTYPE *GetFirstChildElementBuildCache )( 
            __RPC__in IUIAutomationTreeWalker * This,
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **first);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastChildElementBuildCache )( 
            __RPC__in IUIAutomationTreeWalker * This,
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **last);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextSiblingElementBuildCache )( 
            __RPC__in IUIAutomationTreeWalker * This,
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **next);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreviousSiblingElementBuildCache )( 
            __RPC__in IUIAutomationTreeWalker * This,
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **previous);
        
        HRESULT ( STDMETHODCALLTYPE *NormalizeElementBuildCache )( 
            __RPC__in IUIAutomationTreeWalker * This,
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **normalized);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Condition )( 
            __RPC__in IUIAutomationTreeWalker * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **condition);
        
        END_INTERFACE
    } IUIAutomationTreeWalkerVtbl;

    interface IUIAutomationTreeWalker
    {
        CONST_VTBL struct IUIAutomationTreeWalkerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationTreeWalker_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationTreeWalker_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationTreeWalker_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationTreeWalker_GetParentElement(This,element,parent)	\
    ( (This)->lpVtbl -> GetParentElement(This,element,parent) ) 

#define IUIAutomationTreeWalker_GetFirstChildElement(This,element,first)	\
    ( (This)->lpVtbl -> GetFirstChildElement(This,element,first) ) 

#define IUIAutomationTreeWalker_GetLastChildElement(This,element,last)	\
    ( (This)->lpVtbl -> GetLastChildElement(This,element,last) ) 

#define IUIAutomationTreeWalker_GetNextSiblingElement(This,element,next)	\
    ( (This)->lpVtbl -> GetNextSiblingElement(This,element,next) ) 

#define IUIAutomationTreeWalker_GetPreviousSiblingElement(This,element,previous)	\
    ( (This)->lpVtbl -> GetPreviousSiblingElement(This,element,previous) ) 

#define IUIAutomationTreeWalker_NormalizeElement(This,element,normalized)	\
    ( (This)->lpVtbl -> NormalizeElement(This,element,normalized) ) 

#define IUIAutomationTreeWalker_GetParentElementBuildCache(This,element,cacheRequest,parent)	\
    ( (This)->lpVtbl -> GetParentElementBuildCache(This,element,cacheRequest,parent) ) 

#define IUIAutomationTreeWalker_GetFirstChildElementBuildCache(This,element,cacheRequest,first)	\
    ( (This)->lpVtbl -> GetFirstChildElementBuildCache(This,element,cacheRequest,first) ) 

#define IUIAutomationTreeWalker_GetLastChildElementBuildCache(This,element,cacheRequest,last)	\
    ( (This)->lpVtbl -> GetLastChildElementBuildCache(This,element,cacheRequest,last) ) 

#define IUIAutomationTreeWalker_GetNextSiblingElementBuildCache(This,element,cacheRequest,next)	\
    ( (This)->lpVtbl -> GetNextSiblingElementBuildCache(This,element,cacheRequest,next) ) 

#define IUIAutomationTreeWalker_GetPreviousSiblingElementBuildCache(This,element,cacheRequest,previous)	\
    ( (This)->lpVtbl -> GetPreviousSiblingElementBuildCache(This,element,cacheRequest,previous) ) 

#define IUIAutomationTreeWalker_NormalizeElementBuildCache(This,element,cacheRequest,normalized)	\
    ( (This)->lpVtbl -> NormalizeElementBuildCache(This,element,cacheRequest,normalized) ) 

#define IUIAutomationTreeWalker_get_Condition(This,condition)	\
    ( (This)->lpVtbl -> get_Condition(This,condition) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationTreeWalker_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationEventHandler_INTERFACE_DEFINED__
#define __IUIAutomationEventHandler_INTERFACE_DEFINED__

/* interface IUIAutomationEventHandler */
/* [oleautomation][unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationEventHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("146c3c17-f12e-4e22-8c27-f894b9b79c69")
    IUIAutomationEventHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE HandleAutomationEvent( 
            /* [in] */ __RPC__in_opt IUIAutomationElement *sender,
            /* [in] */ EVENTID eventId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationEventHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationEventHandler * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationEventHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationEventHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *HandleAutomationEvent )( 
            __RPC__in IUIAutomationEventHandler * This,
            /* [in] */ __RPC__in_opt IUIAutomationElement *sender,
            /* [in] */ EVENTID eventId);
        
        END_INTERFACE
    } IUIAutomationEventHandlerVtbl;

    interface IUIAutomationEventHandler
    {
        CONST_VTBL struct IUIAutomationEventHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationEventHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationEventHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationEventHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationEventHandler_HandleAutomationEvent(This,sender,eventId)	\
    ( (This)->lpVtbl -> HandleAutomationEvent(This,sender,eventId) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationEventHandler_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationPropertyChangedEventHandler_INTERFACE_DEFINED__
#define __IUIAutomationPropertyChangedEventHandler_INTERFACE_DEFINED__

/* interface IUIAutomationPropertyChangedEventHandler */
/* [oleautomation][unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationPropertyChangedEventHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("40cd37d4-c756-4b0c-8c6f-bddfeeb13b50")
    IUIAutomationPropertyChangedEventHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE HandlePropertyChangedEvent( 
            /* [in] */ __RPC__in_opt IUIAutomationElement *sender,
            /* [in] */ PROPERTYID propertyId,
            /* [in] */ VARIANT newValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationPropertyChangedEventHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationPropertyChangedEventHandler * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationPropertyChangedEventHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationPropertyChangedEventHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *HandlePropertyChangedEvent )( 
            __RPC__in IUIAutomationPropertyChangedEventHandler * This,
            /* [in] */ __RPC__in_opt IUIAutomationElement *sender,
            /* [in] */ PROPERTYID propertyId,
            /* [in] */ VARIANT newValue);
        
        END_INTERFACE
    } IUIAutomationPropertyChangedEventHandlerVtbl;

    interface IUIAutomationPropertyChangedEventHandler
    {
        CONST_VTBL struct IUIAutomationPropertyChangedEventHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationPropertyChangedEventHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationPropertyChangedEventHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationPropertyChangedEventHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationPropertyChangedEventHandler_HandlePropertyChangedEvent(This,sender,propertyId,newValue)	\
    ( (This)->lpVtbl -> HandlePropertyChangedEvent(This,sender,propertyId,newValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationPropertyChangedEventHandler_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationStructureChangedEventHandler_INTERFACE_DEFINED__
#define __IUIAutomationStructureChangedEventHandler_INTERFACE_DEFINED__

/* interface IUIAutomationStructureChangedEventHandler */
/* [oleautomation][unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationStructureChangedEventHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e81d1b4e-11c5-42f8-9754-e7036c79f054")
    IUIAutomationStructureChangedEventHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE HandleStructureChangedEvent( 
            /* [in] */ __RPC__in_opt IUIAutomationElement *sender,
            /* [in] */ enum StructureChangeType changeType,
            /* [in] */ __RPC__in SAFEARRAY * runtimeId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationStructureChangedEventHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationStructureChangedEventHandler * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationStructureChangedEventHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationStructureChangedEventHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *HandleStructureChangedEvent )( 
            __RPC__in IUIAutomationStructureChangedEventHandler * This,
            /* [in] */ __RPC__in_opt IUIAutomationElement *sender,
            /* [in] */ enum StructureChangeType changeType,
            /* [in] */ __RPC__in SAFEARRAY * runtimeId);
        
        END_INTERFACE
    } IUIAutomationStructureChangedEventHandlerVtbl;

    interface IUIAutomationStructureChangedEventHandler
    {
        CONST_VTBL struct IUIAutomationStructureChangedEventHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationStructureChangedEventHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationStructureChangedEventHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationStructureChangedEventHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationStructureChangedEventHandler_HandleStructureChangedEvent(This,sender,changeType,runtimeId)	\
    ( (This)->lpVtbl -> HandleStructureChangedEvent(This,sender,changeType,runtimeId) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationStructureChangedEventHandler_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationFocusChangedEventHandler_INTERFACE_DEFINED__
#define __IUIAutomationFocusChangedEventHandler_INTERFACE_DEFINED__

/* interface IUIAutomationFocusChangedEventHandler */
/* [oleautomation][unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationFocusChangedEventHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c270f6b5-5c69-4290-9745-7a7f97169468")
    IUIAutomationFocusChangedEventHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE HandleFocusChangedEvent( 
            /* [in] */ __RPC__in_opt IUIAutomationElement *sender) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationFocusChangedEventHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationFocusChangedEventHandler * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationFocusChangedEventHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationFocusChangedEventHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *HandleFocusChangedEvent )( 
            __RPC__in IUIAutomationFocusChangedEventHandler * This,
            /* [in] */ __RPC__in_opt IUIAutomationElement *sender);
        
        END_INTERFACE
    } IUIAutomationFocusChangedEventHandlerVtbl;

    interface IUIAutomationFocusChangedEventHandler
    {
        CONST_VTBL struct IUIAutomationFocusChangedEventHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationFocusChangedEventHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationFocusChangedEventHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationFocusChangedEventHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationFocusChangedEventHandler_HandleFocusChangedEvent(This,sender)	\
    ( (This)->lpVtbl -> HandleFocusChangedEvent(This,sender) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationFocusChangedEventHandler_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationInvokePattern_INTERFACE_DEFINED__
#define __IUIAutomationInvokePattern_INTERFACE_DEFINED__

/* interface IUIAutomationInvokePattern */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationInvokePattern;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fb377fbe-8ea6-46d5-9c73-6499642d3059")
    IUIAutomationInvokePattern : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Invoke( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationInvokePatternVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationInvokePattern * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationInvokePattern * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationInvokePattern * This);
        
        HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            __RPC__in IUIAutomationInvokePattern * This);
        
        END_INTERFACE
    } IUIAutomationInvokePatternVtbl;

    interface IUIAutomationInvokePattern
    {
        CONST_VTBL struct IUIAutomationInvokePatternVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationInvokePattern_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationInvokePattern_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationInvokePattern_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationInvokePattern_Invoke(This)	\
    ( (This)->lpVtbl -> Invoke(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationInvokePattern_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationDockPattern_INTERFACE_DEFINED__
#define __IUIAutomationDockPattern_INTERFACE_DEFINED__

/* interface IUIAutomationDockPattern */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationDockPattern;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fde5ef97-1464-48f6-90bf-43d0948e86ec")
    IUIAutomationDockPattern : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDockPosition( 
            /* [in] */ enum DockPosition dockPos) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentDockPosition( 
            /* [retval][out] */ __RPC__out enum DockPosition *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedDockPosition( 
            /* [retval][out] */ __RPC__out enum DockPosition *retVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationDockPatternVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationDockPattern * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationDockPattern * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationDockPattern * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDockPosition )( 
            __RPC__in IUIAutomationDockPattern * This,
            /* [in] */ enum DockPosition dockPos);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentDockPosition )( 
            __RPC__in IUIAutomationDockPattern * This,
            /* [retval][out] */ __RPC__out enum DockPosition *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedDockPosition )( 
            __RPC__in IUIAutomationDockPattern * This,
            /* [retval][out] */ __RPC__out enum DockPosition *retVal);
        
        END_INTERFACE
    } IUIAutomationDockPatternVtbl;

    interface IUIAutomationDockPattern
    {
        CONST_VTBL struct IUIAutomationDockPatternVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationDockPattern_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationDockPattern_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationDockPattern_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationDockPattern_SetDockPosition(This,dockPos)	\
    ( (This)->lpVtbl -> SetDockPosition(This,dockPos) ) 

#define IUIAutomationDockPattern_get_CurrentDockPosition(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentDockPosition(This,retVal) ) 

#define IUIAutomationDockPattern_get_CachedDockPosition(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedDockPosition(This,retVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationDockPattern_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationExpandCollapsePattern_INTERFACE_DEFINED__
#define __IUIAutomationExpandCollapsePattern_INTERFACE_DEFINED__

/* interface IUIAutomationExpandCollapsePattern */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationExpandCollapsePattern;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("619be086-1f4e-4ee4-bafa-210128738730")
    IUIAutomationExpandCollapsePattern : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Expand( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Collapse( void) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentExpandCollapseState( 
            /* [retval][out] */ __RPC__out enum ExpandCollapseState *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedExpandCollapseState( 
            /* [retval][out] */ __RPC__out enum ExpandCollapseState *retVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationExpandCollapsePatternVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationExpandCollapsePattern * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationExpandCollapsePattern * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationExpandCollapsePattern * This);
        
        HRESULT ( STDMETHODCALLTYPE *Expand )( 
            __RPC__in IUIAutomationExpandCollapsePattern * This);
        
        HRESULT ( STDMETHODCALLTYPE *Collapse )( 
            __RPC__in IUIAutomationExpandCollapsePattern * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentExpandCollapseState )( 
            __RPC__in IUIAutomationExpandCollapsePattern * This,
            /* [retval][out] */ __RPC__out enum ExpandCollapseState *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedExpandCollapseState )( 
            __RPC__in IUIAutomationExpandCollapsePattern * This,
            /* [retval][out] */ __RPC__out enum ExpandCollapseState *retVal);
        
        END_INTERFACE
    } IUIAutomationExpandCollapsePatternVtbl;

    interface IUIAutomationExpandCollapsePattern
    {
        CONST_VTBL struct IUIAutomationExpandCollapsePatternVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationExpandCollapsePattern_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationExpandCollapsePattern_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationExpandCollapsePattern_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationExpandCollapsePattern_Expand(This)	\
    ( (This)->lpVtbl -> Expand(This) ) 

#define IUIAutomationExpandCollapsePattern_Collapse(This)	\
    ( (This)->lpVtbl -> Collapse(This) ) 

#define IUIAutomationExpandCollapsePattern_get_CurrentExpandCollapseState(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentExpandCollapseState(This,retVal) ) 

#define IUIAutomationExpandCollapsePattern_get_CachedExpandCollapseState(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedExpandCollapseState(This,retVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationExpandCollapsePattern_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationGridPattern_INTERFACE_DEFINED__
#define __IUIAutomationGridPattern_INTERFACE_DEFINED__

/* interface IUIAutomationGridPattern */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationGridPattern;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("414c3cdc-856b-4f5b-8538-3131c6302550")
    IUIAutomationGridPattern : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetItem( 
            /* [in] */ int row,
            /* [in] */ int column,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **element) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentRowCount( 
            /* [retval][out] */ __RPC__out int *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentColumnCount( 
            /* [retval][out] */ __RPC__out int *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedRowCount( 
            /* [retval][out] */ __RPC__out int *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedColumnCount( 
            /* [retval][out] */ __RPC__out int *retVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationGridPatternVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationGridPattern * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationGridPattern * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationGridPattern * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            __RPC__in IUIAutomationGridPattern * This,
            /* [in] */ int row,
            /* [in] */ int column,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **element);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentRowCount )( 
            __RPC__in IUIAutomationGridPattern * This,
            /* [retval][out] */ __RPC__out int *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentColumnCount )( 
            __RPC__in IUIAutomationGridPattern * This,
            /* [retval][out] */ __RPC__out int *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedRowCount )( 
            __RPC__in IUIAutomationGridPattern * This,
            /* [retval][out] */ __RPC__out int *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedColumnCount )( 
            __RPC__in IUIAutomationGridPattern * This,
            /* [retval][out] */ __RPC__out int *retVal);
        
        END_INTERFACE
    } IUIAutomationGridPatternVtbl;

    interface IUIAutomationGridPattern
    {
        CONST_VTBL struct IUIAutomationGridPatternVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationGridPattern_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationGridPattern_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationGridPattern_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationGridPattern_GetItem(This,row,column,element)	\
    ( (This)->lpVtbl -> GetItem(This,row,column,element) ) 

#define IUIAutomationGridPattern_get_CurrentRowCount(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentRowCount(This,retVal) ) 

#define IUIAutomationGridPattern_get_CurrentColumnCount(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentColumnCount(This,retVal) ) 

#define IUIAutomationGridPattern_get_CachedRowCount(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedRowCount(This,retVal) ) 

#define IUIAutomationGridPattern_get_CachedColumnCount(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedColumnCount(This,retVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationGridPattern_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationGridItemPattern_INTERFACE_DEFINED__
#define __IUIAutomationGridItemPattern_INTERFACE_DEFINED__

/* interface IUIAutomationGridItemPattern */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationGridItemPattern;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("78f8ef57-66c3-4e09-bd7c-e79b2004894d")
    IUIAutomationGridItemPattern : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentContainingGrid( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentRow( 
            /* [retval][out] */ __RPC__out int *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentColumn( 
            /* [retval][out] */ __RPC__out int *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentRowSpan( 
            /* [retval][out] */ __RPC__out int *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentColumnSpan( 
            /* [retval][out] */ __RPC__out int *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedContainingGrid( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedRow( 
            /* [retval][out] */ __RPC__out int *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedColumn( 
            /* [retval][out] */ __RPC__out int *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedRowSpan( 
            /* [retval][out] */ __RPC__out int *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedColumnSpan( 
            /* [retval][out] */ __RPC__out int *retVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationGridItemPatternVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationGridItemPattern * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationGridItemPattern * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationGridItemPattern * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentContainingGrid )( 
            __RPC__in IUIAutomationGridItemPattern * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentRow )( 
            __RPC__in IUIAutomationGridItemPattern * This,
            /* [retval][out] */ __RPC__out int *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentColumn )( 
            __RPC__in IUIAutomationGridItemPattern * This,
            /* [retval][out] */ __RPC__out int *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentRowSpan )( 
            __RPC__in IUIAutomationGridItemPattern * This,
            /* [retval][out] */ __RPC__out int *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentColumnSpan )( 
            __RPC__in IUIAutomationGridItemPattern * This,
            /* [retval][out] */ __RPC__out int *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedContainingGrid )( 
            __RPC__in IUIAutomationGridItemPattern * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedRow )( 
            __RPC__in IUIAutomationGridItemPattern * This,
            /* [retval][out] */ __RPC__out int *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedColumn )( 
            __RPC__in IUIAutomationGridItemPattern * This,
            /* [retval][out] */ __RPC__out int *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedRowSpan )( 
            __RPC__in IUIAutomationGridItemPattern * This,
            /* [retval][out] */ __RPC__out int *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedColumnSpan )( 
            __RPC__in IUIAutomationGridItemPattern * This,
            /* [retval][out] */ __RPC__out int *retVal);
        
        END_INTERFACE
    } IUIAutomationGridItemPatternVtbl;

    interface IUIAutomationGridItemPattern
    {
        CONST_VTBL struct IUIAutomationGridItemPatternVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationGridItemPattern_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationGridItemPattern_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationGridItemPattern_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationGridItemPattern_get_CurrentContainingGrid(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentContainingGrid(This,retVal) ) 

#define IUIAutomationGridItemPattern_get_CurrentRow(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentRow(This,retVal) ) 

#define IUIAutomationGridItemPattern_get_CurrentColumn(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentColumn(This,retVal) ) 

#define IUIAutomationGridItemPattern_get_CurrentRowSpan(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentRowSpan(This,retVal) ) 

#define IUIAutomationGridItemPattern_get_CurrentColumnSpan(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentColumnSpan(This,retVal) ) 

#define IUIAutomationGridItemPattern_get_CachedContainingGrid(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedContainingGrid(This,retVal) ) 

#define IUIAutomationGridItemPattern_get_CachedRow(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedRow(This,retVal) ) 

#define IUIAutomationGridItemPattern_get_CachedColumn(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedColumn(This,retVal) ) 

#define IUIAutomationGridItemPattern_get_CachedRowSpan(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedRowSpan(This,retVal) ) 

#define IUIAutomationGridItemPattern_get_CachedColumnSpan(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedColumnSpan(This,retVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationGridItemPattern_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationMultipleViewPattern_INTERFACE_DEFINED__
#define __IUIAutomationMultipleViewPattern_INTERFACE_DEFINED__

/* interface IUIAutomationMultipleViewPattern */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationMultipleViewPattern;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8d253c91-1dc5-4bb5-b18f-ade16fa495e8")
    IUIAutomationMultipleViewPattern : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetViewName( 
            /* [in] */ int view,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCurrentView( 
            /* [in] */ int view) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentCurrentView( 
            /* [retval][out] */ __RPC__out int *retVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentSupportedViews( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedCurrentView( 
            /* [retval][out] */ __RPC__out int *retVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCachedSupportedViews( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *retVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationMultipleViewPatternVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationMultipleViewPattern * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationMultipleViewPattern * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationMultipleViewPattern * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewName )( 
            __RPC__in IUIAutomationMultipleViewPattern * This,
            /* [in] */ int view,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        HRESULT ( STDMETHODCALLTYPE *SetCurrentView )( 
            __RPC__in IUIAutomationMultipleViewPattern * This,
            /* [in] */ int view);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentCurrentView )( 
            __RPC__in IUIAutomationMultipleViewPattern * This,
            /* [retval][out] */ __RPC__out int *retVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentSupportedViews )( 
            __RPC__in IUIAutomationMultipleViewPattern * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedCurrentView )( 
            __RPC__in IUIAutomationMultipleViewPattern * This,
            /* [retval][out] */ __RPC__out int *retVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCachedSupportedViews )( 
            __RPC__in IUIAutomationMultipleViewPattern * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *retVal);
        
        END_INTERFACE
    } IUIAutomationMultipleViewPatternVtbl;

    interface IUIAutomationMultipleViewPattern
    {
        CONST_VTBL struct IUIAutomationMultipleViewPatternVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationMultipleViewPattern_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationMultipleViewPattern_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationMultipleViewPattern_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationMultipleViewPattern_GetViewName(This,view,name)	\
    ( (This)->lpVtbl -> GetViewName(This,view,name) ) 

#define IUIAutomationMultipleViewPattern_SetCurrentView(This,view)	\
    ( (This)->lpVtbl -> SetCurrentView(This,view) ) 

#define IUIAutomationMultipleViewPattern_get_CurrentCurrentView(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentCurrentView(This,retVal) ) 

#define IUIAutomationMultipleViewPattern_GetCurrentSupportedViews(This,retVal)	\
    ( (This)->lpVtbl -> GetCurrentSupportedViews(This,retVal) ) 

#define IUIAutomationMultipleViewPattern_get_CachedCurrentView(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedCurrentView(This,retVal) ) 

#define IUIAutomationMultipleViewPattern_GetCachedSupportedViews(This,retVal)	\
    ( (This)->lpVtbl -> GetCachedSupportedViews(This,retVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationMultipleViewPattern_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationRangeValuePattern_INTERFACE_DEFINED__
#define __IUIAutomationRangeValuePattern_INTERFACE_DEFINED__

/* interface IUIAutomationRangeValuePattern */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationRangeValuePattern;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("59213f4f-7346-49e5-b120-80555987a148")
    IUIAutomationRangeValuePattern : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ double val) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentValue( 
            /* [retval][out] */ __RPC__out double *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentIsReadOnly( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentMaximum( 
            /* [retval][out] */ __RPC__out double *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentMinimum( 
            /* [retval][out] */ __RPC__out double *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentLargeChange( 
            /* [retval][out] */ __RPC__out double *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentSmallChange( 
            /* [retval][out] */ __RPC__out double *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedValue( 
            /* [retval][out] */ __RPC__out double *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedIsReadOnly( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedMaximum( 
            /* [retval][out] */ __RPC__out double *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedMinimum( 
            /* [retval][out] */ __RPC__out double *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedLargeChange( 
            /* [retval][out] */ __RPC__out double *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedSmallChange( 
            /* [retval][out] */ __RPC__out double *retVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationRangeValuePatternVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationRangeValuePattern * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationRangeValuePattern * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationRangeValuePattern * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            __RPC__in IUIAutomationRangeValuePattern * This,
            /* [in] */ double val);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentValue )( 
            __RPC__in IUIAutomationRangeValuePattern * This,
            /* [retval][out] */ __RPC__out double *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentIsReadOnly )( 
            __RPC__in IUIAutomationRangeValuePattern * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentMaximum )( 
            __RPC__in IUIAutomationRangeValuePattern * This,
            /* [retval][out] */ __RPC__out double *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentMinimum )( 
            __RPC__in IUIAutomationRangeValuePattern * This,
            /* [retval][out] */ __RPC__out double *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentLargeChange )( 
            __RPC__in IUIAutomationRangeValuePattern * This,
            /* [retval][out] */ __RPC__out double *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentSmallChange )( 
            __RPC__in IUIAutomationRangeValuePattern * This,
            /* [retval][out] */ __RPC__out double *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedValue )( 
            __RPC__in IUIAutomationRangeValuePattern * This,
            /* [retval][out] */ __RPC__out double *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedIsReadOnly )( 
            __RPC__in IUIAutomationRangeValuePattern * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedMaximum )( 
            __RPC__in IUIAutomationRangeValuePattern * This,
            /* [retval][out] */ __RPC__out double *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedMinimum )( 
            __RPC__in IUIAutomationRangeValuePattern * This,
            /* [retval][out] */ __RPC__out double *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedLargeChange )( 
            __RPC__in IUIAutomationRangeValuePattern * This,
            /* [retval][out] */ __RPC__out double *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedSmallChange )( 
            __RPC__in IUIAutomationRangeValuePattern * This,
            /* [retval][out] */ __RPC__out double *retVal);
        
        END_INTERFACE
    } IUIAutomationRangeValuePatternVtbl;

    interface IUIAutomationRangeValuePattern
    {
        CONST_VTBL struct IUIAutomationRangeValuePatternVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationRangeValuePattern_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationRangeValuePattern_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationRangeValuePattern_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationRangeValuePattern_SetValue(This,val)	\
    ( (This)->lpVtbl -> SetValue(This,val) ) 

#define IUIAutomationRangeValuePattern_get_CurrentValue(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentValue(This,retVal) ) 

#define IUIAutomationRangeValuePattern_get_CurrentIsReadOnly(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentIsReadOnly(This,retVal) ) 

#define IUIAutomationRangeValuePattern_get_CurrentMaximum(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentMaximum(This,retVal) ) 

#define IUIAutomationRangeValuePattern_get_CurrentMinimum(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentMinimum(This,retVal) ) 

#define IUIAutomationRangeValuePattern_get_CurrentLargeChange(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentLargeChange(This,retVal) ) 

#define IUIAutomationRangeValuePattern_get_CurrentSmallChange(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentSmallChange(This,retVal) ) 

#define IUIAutomationRangeValuePattern_get_CachedValue(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedValue(This,retVal) ) 

#define IUIAutomationRangeValuePattern_get_CachedIsReadOnly(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedIsReadOnly(This,retVal) ) 

#define IUIAutomationRangeValuePattern_get_CachedMaximum(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedMaximum(This,retVal) ) 

#define IUIAutomationRangeValuePattern_get_CachedMinimum(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedMinimum(This,retVal) ) 

#define IUIAutomationRangeValuePattern_get_CachedLargeChange(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedLargeChange(This,retVal) ) 

#define IUIAutomationRangeValuePattern_get_CachedSmallChange(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedSmallChange(This,retVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationRangeValuePattern_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationScrollPattern_INTERFACE_DEFINED__
#define __IUIAutomationScrollPattern_INTERFACE_DEFINED__

/* interface IUIAutomationScrollPattern */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationScrollPattern;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("88f4d42a-e881-459d-a77c-73bbbb7e02dc")
    IUIAutomationScrollPattern : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Scroll( 
            /* [in] */ enum ScrollAmount horizontalAmount,
            /* [in] */ enum ScrollAmount verticalAmount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetScrollPercent( 
            /* [in] */ double horizontalPercent,
            /* [in] */ double verticalPercent) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentHorizontalScrollPercent( 
            /* [retval][out] */ __RPC__out double *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentVerticalScrollPercent( 
            /* [retval][out] */ __RPC__out double *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentHorizontalViewSize( 
            /* [retval][out] */ __RPC__out double *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentVerticalViewSize( 
            /* [retval][out] */ __RPC__out double *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentHorizontallyScrollable( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentVerticallyScrollable( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedHorizontalScrollPercent( 
            /* [retval][out] */ __RPC__out double *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedVerticalScrollPercent( 
            /* [retval][out] */ __RPC__out double *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedHorizontalViewSize( 
            /* [retval][out] */ __RPC__out double *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedVerticalViewSize( 
            /* [retval][out] */ __RPC__out double *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedHorizontallyScrollable( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedVerticallyScrollable( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationScrollPatternVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationScrollPattern * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationScrollPattern * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationScrollPattern * This);
        
        HRESULT ( STDMETHODCALLTYPE *Scroll )( 
            __RPC__in IUIAutomationScrollPattern * This,
            /* [in] */ enum ScrollAmount horizontalAmount,
            /* [in] */ enum ScrollAmount verticalAmount);
        
        HRESULT ( STDMETHODCALLTYPE *SetScrollPercent )( 
            __RPC__in IUIAutomationScrollPattern * This,
            /* [in] */ double horizontalPercent,
            /* [in] */ double verticalPercent);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentHorizontalScrollPercent )( 
            __RPC__in IUIAutomationScrollPattern * This,
            /* [retval][out] */ __RPC__out double *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentVerticalScrollPercent )( 
            __RPC__in IUIAutomationScrollPattern * This,
            /* [retval][out] */ __RPC__out double *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentHorizontalViewSize )( 
            __RPC__in IUIAutomationScrollPattern * This,
            /* [retval][out] */ __RPC__out double *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentVerticalViewSize )( 
            __RPC__in IUIAutomationScrollPattern * This,
            /* [retval][out] */ __RPC__out double *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentHorizontallyScrollable )( 
            __RPC__in IUIAutomationScrollPattern * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentVerticallyScrollable )( 
            __RPC__in IUIAutomationScrollPattern * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedHorizontalScrollPercent )( 
            __RPC__in IUIAutomationScrollPattern * This,
            /* [retval][out] */ __RPC__out double *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedVerticalScrollPercent )( 
            __RPC__in IUIAutomationScrollPattern * This,
            /* [retval][out] */ __RPC__out double *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedHorizontalViewSize )( 
            __RPC__in IUIAutomationScrollPattern * This,
            /* [retval][out] */ __RPC__out double *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedVerticalViewSize )( 
            __RPC__in IUIAutomationScrollPattern * This,
            /* [retval][out] */ __RPC__out double *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedHorizontallyScrollable )( 
            __RPC__in IUIAutomationScrollPattern * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedVerticallyScrollable )( 
            __RPC__in IUIAutomationScrollPattern * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        END_INTERFACE
    } IUIAutomationScrollPatternVtbl;

    interface IUIAutomationScrollPattern
    {
        CONST_VTBL struct IUIAutomationScrollPatternVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationScrollPattern_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationScrollPattern_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationScrollPattern_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationScrollPattern_Scroll(This,horizontalAmount,verticalAmount)	\
    ( (This)->lpVtbl -> Scroll(This,horizontalAmount,verticalAmount) ) 

#define IUIAutomationScrollPattern_SetScrollPercent(This,horizontalPercent,verticalPercent)	\
    ( (This)->lpVtbl -> SetScrollPercent(This,horizontalPercent,verticalPercent) ) 

#define IUIAutomationScrollPattern_get_CurrentHorizontalScrollPercent(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentHorizontalScrollPercent(This,retVal) ) 

#define IUIAutomationScrollPattern_get_CurrentVerticalScrollPercent(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentVerticalScrollPercent(This,retVal) ) 

#define IUIAutomationScrollPattern_get_CurrentHorizontalViewSize(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentHorizontalViewSize(This,retVal) ) 

#define IUIAutomationScrollPattern_get_CurrentVerticalViewSize(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentVerticalViewSize(This,retVal) ) 

#define IUIAutomationScrollPattern_get_CurrentHorizontallyScrollable(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentHorizontallyScrollable(This,retVal) ) 

#define IUIAutomationScrollPattern_get_CurrentVerticallyScrollable(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentVerticallyScrollable(This,retVal) ) 

#define IUIAutomationScrollPattern_get_CachedHorizontalScrollPercent(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedHorizontalScrollPercent(This,retVal) ) 

#define IUIAutomationScrollPattern_get_CachedVerticalScrollPercent(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedVerticalScrollPercent(This,retVal) ) 

#define IUIAutomationScrollPattern_get_CachedHorizontalViewSize(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedHorizontalViewSize(This,retVal) ) 

#define IUIAutomationScrollPattern_get_CachedVerticalViewSize(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedVerticalViewSize(This,retVal) ) 

#define IUIAutomationScrollPattern_get_CachedHorizontallyScrollable(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedHorizontallyScrollable(This,retVal) ) 

#define IUIAutomationScrollPattern_get_CachedVerticallyScrollable(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedVerticallyScrollable(This,retVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationScrollPattern_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationScrollItemPattern_INTERFACE_DEFINED__
#define __IUIAutomationScrollItemPattern_INTERFACE_DEFINED__

/* interface IUIAutomationScrollItemPattern */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationScrollItemPattern;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b488300f-d015-4f19-9c29-bb595e3645ef")
    IUIAutomationScrollItemPattern : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ScrollIntoView( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationScrollItemPatternVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationScrollItemPattern * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationScrollItemPattern * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationScrollItemPattern * This);
        
        HRESULT ( STDMETHODCALLTYPE *ScrollIntoView )( 
            __RPC__in IUIAutomationScrollItemPattern * This);
        
        END_INTERFACE
    } IUIAutomationScrollItemPatternVtbl;

    interface IUIAutomationScrollItemPattern
    {
        CONST_VTBL struct IUIAutomationScrollItemPatternVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationScrollItemPattern_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationScrollItemPattern_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationScrollItemPattern_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationScrollItemPattern_ScrollIntoView(This)	\
    ( (This)->lpVtbl -> ScrollIntoView(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationScrollItemPattern_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationSelectionPattern_INTERFACE_DEFINED__
#define __IUIAutomationSelectionPattern_INTERFACE_DEFINED__

/* interface IUIAutomationSelectionPattern */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationSelectionPattern;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5ed5202e-b2ac-47a6-b638-4b0bf140d78e")
    IUIAutomationSelectionPattern : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCurrentSelection( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentCanSelectMultiple( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentIsSelectionRequired( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCachedSelection( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedCanSelectMultiple( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedIsSelectionRequired( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationSelectionPatternVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationSelectionPattern * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationSelectionPattern * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationSelectionPattern * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentSelection )( 
            __RPC__in IUIAutomationSelectionPattern * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentCanSelectMultiple )( 
            __RPC__in IUIAutomationSelectionPattern * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentIsSelectionRequired )( 
            __RPC__in IUIAutomationSelectionPattern * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCachedSelection )( 
            __RPC__in IUIAutomationSelectionPattern * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedCanSelectMultiple )( 
            __RPC__in IUIAutomationSelectionPattern * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedIsSelectionRequired )( 
            __RPC__in IUIAutomationSelectionPattern * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        END_INTERFACE
    } IUIAutomationSelectionPatternVtbl;

    interface IUIAutomationSelectionPattern
    {
        CONST_VTBL struct IUIAutomationSelectionPatternVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationSelectionPattern_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationSelectionPattern_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationSelectionPattern_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationSelectionPattern_GetCurrentSelection(This,retVal)	\
    ( (This)->lpVtbl -> GetCurrentSelection(This,retVal) ) 

#define IUIAutomationSelectionPattern_get_CurrentCanSelectMultiple(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentCanSelectMultiple(This,retVal) ) 

#define IUIAutomationSelectionPattern_get_CurrentIsSelectionRequired(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentIsSelectionRequired(This,retVal) ) 

#define IUIAutomationSelectionPattern_GetCachedSelection(This,retVal)	\
    ( (This)->lpVtbl -> GetCachedSelection(This,retVal) ) 

#define IUIAutomationSelectionPattern_get_CachedCanSelectMultiple(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedCanSelectMultiple(This,retVal) ) 

#define IUIAutomationSelectionPattern_get_CachedIsSelectionRequired(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedIsSelectionRequired(This,retVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationSelectionPattern_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationSelectionItemPattern_INTERFACE_DEFINED__
#define __IUIAutomationSelectionItemPattern_INTERFACE_DEFINED__

/* interface IUIAutomationSelectionItemPattern */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationSelectionItemPattern;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a8efa66a-0fda-421a-9194-38021f3578ea")
    IUIAutomationSelectionItemPattern : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Select( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddToSelection( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveFromSelection( void) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentIsSelected( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentSelectionContainer( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedIsSelected( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedSelectionContainer( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **retVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationSelectionItemPatternVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationSelectionItemPattern * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationSelectionItemPattern * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationSelectionItemPattern * This);
        
        HRESULT ( STDMETHODCALLTYPE *Select )( 
            __RPC__in IUIAutomationSelectionItemPattern * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddToSelection )( 
            __RPC__in IUIAutomationSelectionItemPattern * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFromSelection )( 
            __RPC__in IUIAutomationSelectionItemPattern * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentIsSelected )( 
            __RPC__in IUIAutomationSelectionItemPattern * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentSelectionContainer )( 
            __RPC__in IUIAutomationSelectionItemPattern * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedIsSelected )( 
            __RPC__in IUIAutomationSelectionItemPattern * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedSelectionContainer )( 
            __RPC__in IUIAutomationSelectionItemPattern * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **retVal);
        
        END_INTERFACE
    } IUIAutomationSelectionItemPatternVtbl;

    interface IUIAutomationSelectionItemPattern
    {
        CONST_VTBL struct IUIAutomationSelectionItemPatternVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationSelectionItemPattern_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationSelectionItemPattern_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationSelectionItemPattern_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationSelectionItemPattern_Select(This)	\
    ( (This)->lpVtbl -> Select(This) ) 

#define IUIAutomationSelectionItemPattern_AddToSelection(This)	\
    ( (This)->lpVtbl -> AddToSelection(This) ) 

#define IUIAutomationSelectionItemPattern_RemoveFromSelection(This)	\
    ( (This)->lpVtbl -> RemoveFromSelection(This) ) 

#define IUIAutomationSelectionItemPattern_get_CurrentIsSelected(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentIsSelected(This,retVal) ) 

#define IUIAutomationSelectionItemPattern_get_CurrentSelectionContainer(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentSelectionContainer(This,retVal) ) 

#define IUIAutomationSelectionItemPattern_get_CachedIsSelected(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedIsSelected(This,retVal) ) 

#define IUIAutomationSelectionItemPattern_get_CachedSelectionContainer(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedSelectionContainer(This,retVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationSelectionItemPattern_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationSynchronizedInputPattern_INTERFACE_DEFINED__
#define __IUIAutomationSynchronizedInputPattern_INTERFACE_DEFINED__

/* interface IUIAutomationSynchronizedInputPattern */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationSynchronizedInputPattern;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2233be0b-afb7-448b-9fda-3b378aa5eae1")
    IUIAutomationSynchronizedInputPattern : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartListening( 
            /* [in] */ enum SynchronizedInputType inputType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationSynchronizedInputPatternVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationSynchronizedInputPattern * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationSynchronizedInputPattern * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationSynchronizedInputPattern * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartListening )( 
            __RPC__in IUIAutomationSynchronizedInputPattern * This,
            /* [in] */ enum SynchronizedInputType inputType);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            __RPC__in IUIAutomationSynchronizedInputPattern * This);
        
        END_INTERFACE
    } IUIAutomationSynchronizedInputPatternVtbl;

    interface IUIAutomationSynchronizedInputPattern
    {
        CONST_VTBL struct IUIAutomationSynchronizedInputPatternVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationSynchronizedInputPattern_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationSynchronizedInputPattern_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationSynchronizedInputPattern_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationSynchronizedInputPattern_StartListening(This,inputType)	\
    ( (This)->lpVtbl -> StartListening(This,inputType) ) 

#define IUIAutomationSynchronizedInputPattern_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationSynchronizedInputPattern_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationTablePattern_INTERFACE_DEFINED__
#define __IUIAutomationTablePattern_INTERFACE_DEFINED__

/* interface IUIAutomationTablePattern */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationTablePattern;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("620e691c-ea96-4710-a850-754b24ce2417")
    IUIAutomationTablePattern : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCurrentRowHeaders( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentColumnHeaders( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentRowOrColumnMajor( 
            /* [retval][out] */ __RPC__out enum RowOrColumnMajor *retVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCachedRowHeaders( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCachedColumnHeaders( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedRowOrColumnMajor( 
            /* [retval][out] */ __RPC__out enum RowOrColumnMajor *retVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationTablePatternVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationTablePattern * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationTablePattern * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationTablePattern * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentRowHeaders )( 
            __RPC__in IUIAutomationTablePattern * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentColumnHeaders )( 
            __RPC__in IUIAutomationTablePattern * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentRowOrColumnMajor )( 
            __RPC__in IUIAutomationTablePattern * This,
            /* [retval][out] */ __RPC__out enum RowOrColumnMajor *retVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCachedRowHeaders )( 
            __RPC__in IUIAutomationTablePattern * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCachedColumnHeaders )( 
            __RPC__in IUIAutomationTablePattern * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedRowOrColumnMajor )( 
            __RPC__in IUIAutomationTablePattern * This,
            /* [retval][out] */ __RPC__out enum RowOrColumnMajor *retVal);
        
        END_INTERFACE
    } IUIAutomationTablePatternVtbl;

    interface IUIAutomationTablePattern
    {
        CONST_VTBL struct IUIAutomationTablePatternVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationTablePattern_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationTablePattern_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationTablePattern_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationTablePattern_GetCurrentRowHeaders(This,retVal)	\
    ( (This)->lpVtbl -> GetCurrentRowHeaders(This,retVal) ) 

#define IUIAutomationTablePattern_GetCurrentColumnHeaders(This,retVal)	\
    ( (This)->lpVtbl -> GetCurrentColumnHeaders(This,retVal) ) 

#define IUIAutomationTablePattern_get_CurrentRowOrColumnMajor(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentRowOrColumnMajor(This,retVal) ) 

#define IUIAutomationTablePattern_GetCachedRowHeaders(This,retVal)	\
    ( (This)->lpVtbl -> GetCachedRowHeaders(This,retVal) ) 

#define IUIAutomationTablePattern_GetCachedColumnHeaders(This,retVal)	\
    ( (This)->lpVtbl -> GetCachedColumnHeaders(This,retVal) ) 

#define IUIAutomationTablePattern_get_CachedRowOrColumnMajor(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedRowOrColumnMajor(This,retVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationTablePattern_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationTableItemPattern_INTERFACE_DEFINED__
#define __IUIAutomationTableItemPattern_INTERFACE_DEFINED__

/* interface IUIAutomationTableItemPattern */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationTableItemPattern;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0b964eb3-ef2e-4464-9c79-61d61737a27e")
    IUIAutomationTableItemPattern : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCurrentRowHeaderItems( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentColumnHeaderItems( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCachedRowHeaderItems( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCachedColumnHeaderItems( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationTableItemPatternVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationTableItemPattern * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationTableItemPattern * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationTableItemPattern * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentRowHeaderItems )( 
            __RPC__in IUIAutomationTableItemPattern * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentColumnHeaderItems )( 
            __RPC__in IUIAutomationTableItemPattern * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCachedRowHeaderItems )( 
            __RPC__in IUIAutomationTableItemPattern * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCachedColumnHeaderItems )( 
            __RPC__in IUIAutomationTableItemPattern * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **retVal);
        
        END_INTERFACE
    } IUIAutomationTableItemPatternVtbl;

    interface IUIAutomationTableItemPattern
    {
        CONST_VTBL struct IUIAutomationTableItemPatternVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationTableItemPattern_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationTableItemPattern_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationTableItemPattern_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationTableItemPattern_GetCurrentRowHeaderItems(This,retVal)	\
    ( (This)->lpVtbl -> GetCurrentRowHeaderItems(This,retVal) ) 

#define IUIAutomationTableItemPattern_GetCurrentColumnHeaderItems(This,retVal)	\
    ( (This)->lpVtbl -> GetCurrentColumnHeaderItems(This,retVal) ) 

#define IUIAutomationTableItemPattern_GetCachedRowHeaderItems(This,retVal)	\
    ( (This)->lpVtbl -> GetCachedRowHeaderItems(This,retVal) ) 

#define IUIAutomationTableItemPattern_GetCachedColumnHeaderItems(This,retVal)	\
    ( (This)->lpVtbl -> GetCachedColumnHeaderItems(This,retVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationTableItemPattern_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationTogglePattern_INTERFACE_DEFINED__
#define __IUIAutomationTogglePattern_INTERFACE_DEFINED__

/* interface IUIAutomationTogglePattern */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationTogglePattern;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("94cf8058-9b8d-4ab9-8bfd-4cd0a33c8c70")
    IUIAutomationTogglePattern : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Toggle( void) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentToggleState( 
            /* [retval][out] */ __RPC__out enum ToggleState *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedToggleState( 
            /* [retval][out] */ __RPC__out enum ToggleState *retVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationTogglePatternVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationTogglePattern * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationTogglePattern * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationTogglePattern * This);
        
        HRESULT ( STDMETHODCALLTYPE *Toggle )( 
            __RPC__in IUIAutomationTogglePattern * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentToggleState )( 
            __RPC__in IUIAutomationTogglePattern * This,
            /* [retval][out] */ __RPC__out enum ToggleState *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedToggleState )( 
            __RPC__in IUIAutomationTogglePattern * This,
            /* [retval][out] */ __RPC__out enum ToggleState *retVal);
        
        END_INTERFACE
    } IUIAutomationTogglePatternVtbl;

    interface IUIAutomationTogglePattern
    {
        CONST_VTBL struct IUIAutomationTogglePatternVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationTogglePattern_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationTogglePattern_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationTogglePattern_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationTogglePattern_Toggle(This)	\
    ( (This)->lpVtbl -> Toggle(This) ) 

#define IUIAutomationTogglePattern_get_CurrentToggleState(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentToggleState(This,retVal) ) 

#define IUIAutomationTogglePattern_get_CachedToggleState(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedToggleState(This,retVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationTogglePattern_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationTransformPattern_INTERFACE_DEFINED__
#define __IUIAutomationTransformPattern_INTERFACE_DEFINED__

/* interface IUIAutomationTransformPattern */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationTransformPattern;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a9b55844-a55d-4ef0-926d-569c16ff89bb")
    IUIAutomationTransformPattern : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Move( 
            /* [in] */ double x,
            /* [in] */ double y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resize( 
            /* [in] */ double width,
            /* [in] */ double height) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Rotate( 
            /* [in] */ double degrees) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentCanMove( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentCanResize( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentCanRotate( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedCanMove( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedCanResize( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedCanRotate( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationTransformPatternVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationTransformPattern * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationTransformPattern * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationTransformPattern * This);
        
        HRESULT ( STDMETHODCALLTYPE *Move )( 
            __RPC__in IUIAutomationTransformPattern * This,
            /* [in] */ double x,
            /* [in] */ double y);
        
        HRESULT ( STDMETHODCALLTYPE *Resize )( 
            __RPC__in IUIAutomationTransformPattern * This,
            /* [in] */ double width,
            /* [in] */ double height);
        
        HRESULT ( STDMETHODCALLTYPE *Rotate )( 
            __RPC__in IUIAutomationTransformPattern * This,
            /* [in] */ double degrees);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentCanMove )( 
            __RPC__in IUIAutomationTransformPattern * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentCanResize )( 
            __RPC__in IUIAutomationTransformPattern * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentCanRotate )( 
            __RPC__in IUIAutomationTransformPattern * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedCanMove )( 
            __RPC__in IUIAutomationTransformPattern * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedCanResize )( 
            __RPC__in IUIAutomationTransformPattern * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedCanRotate )( 
            __RPC__in IUIAutomationTransformPattern * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        END_INTERFACE
    } IUIAutomationTransformPatternVtbl;

    interface IUIAutomationTransformPattern
    {
        CONST_VTBL struct IUIAutomationTransformPatternVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationTransformPattern_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationTransformPattern_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationTransformPattern_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationTransformPattern_Move(This,x,y)	\
    ( (This)->lpVtbl -> Move(This,x,y) ) 

#define IUIAutomationTransformPattern_Resize(This,width,height)	\
    ( (This)->lpVtbl -> Resize(This,width,height) ) 

#define IUIAutomationTransformPattern_Rotate(This,degrees)	\
    ( (This)->lpVtbl -> Rotate(This,degrees) ) 

#define IUIAutomationTransformPattern_get_CurrentCanMove(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentCanMove(This,retVal) ) 

#define IUIAutomationTransformPattern_get_CurrentCanResize(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentCanResize(This,retVal) ) 

#define IUIAutomationTransformPattern_get_CurrentCanRotate(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentCanRotate(This,retVal) ) 

#define IUIAutomationTransformPattern_get_CachedCanMove(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedCanMove(This,retVal) ) 

#define IUIAutomationTransformPattern_get_CachedCanResize(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedCanResize(This,retVal) ) 

#define IUIAutomationTransformPattern_get_CachedCanRotate(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedCanRotate(This,retVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationTransformPattern_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationValuePattern_INTERFACE_DEFINED__
#define __IUIAutomationValuePattern_INTERFACE_DEFINED__

/* interface IUIAutomationValuePattern */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationValuePattern;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a94cd8b1-0844-4cd6-9d2d-640537ab39e9")
    IUIAutomationValuePattern : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ __RPC__in BSTR val) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentValue( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentIsReadOnly( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedValue( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedIsReadOnly( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationValuePatternVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationValuePattern * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationValuePattern * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationValuePattern * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            __RPC__in IUIAutomationValuePattern * This,
            /* [in] */ __RPC__in BSTR val);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentValue )( 
            __RPC__in IUIAutomationValuePattern * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentIsReadOnly )( 
            __RPC__in IUIAutomationValuePattern * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedValue )( 
            __RPC__in IUIAutomationValuePattern * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedIsReadOnly )( 
            __RPC__in IUIAutomationValuePattern * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        END_INTERFACE
    } IUIAutomationValuePatternVtbl;

    interface IUIAutomationValuePattern
    {
        CONST_VTBL struct IUIAutomationValuePatternVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationValuePattern_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationValuePattern_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationValuePattern_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationValuePattern_SetValue(This,val)	\
    ( (This)->lpVtbl -> SetValue(This,val) ) 

#define IUIAutomationValuePattern_get_CurrentValue(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentValue(This,retVal) ) 

#define IUIAutomationValuePattern_get_CurrentIsReadOnly(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentIsReadOnly(This,retVal) ) 

#define IUIAutomationValuePattern_get_CachedValue(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedValue(This,retVal) ) 

#define IUIAutomationValuePattern_get_CachedIsReadOnly(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedIsReadOnly(This,retVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationValuePattern_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationWindowPattern_INTERFACE_DEFINED__
#define __IUIAutomationWindowPattern_INTERFACE_DEFINED__

/* interface IUIAutomationWindowPattern */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationWindowPattern;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0faef453-9208-43ef-bbb2-3b485177864f")
    IUIAutomationWindowPattern : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WaitForInputIdle( 
            /* [in] */ int milliseconds,
            /* [retval][out] */ __RPC__out BOOL *success) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWindowVisualState( 
            /* [in] */ enum WindowVisualState state) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentCanMaximize( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentCanMinimize( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentIsModal( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentIsTopmost( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentWindowVisualState( 
            /* [retval][out] */ __RPC__out enum WindowVisualState *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentWindowInteractionState( 
            /* [retval][out] */ __RPC__out enum WindowInteractionState *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedCanMaximize( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedCanMinimize( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedIsModal( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedIsTopmost( 
            /* [retval][out] */ __RPC__out BOOL *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedWindowVisualState( 
            /* [retval][out] */ __RPC__out enum WindowVisualState *retVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedWindowInteractionState( 
            /* [retval][out] */ __RPC__out enum WindowInteractionState *retVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationWindowPatternVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationWindowPattern * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationWindowPattern * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationWindowPattern * This);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            __RPC__in IUIAutomationWindowPattern * This);
        
        HRESULT ( STDMETHODCALLTYPE *WaitForInputIdle )( 
            __RPC__in IUIAutomationWindowPattern * This,
            /* [in] */ int milliseconds,
            /* [retval][out] */ __RPC__out BOOL *success);
        
        HRESULT ( STDMETHODCALLTYPE *SetWindowVisualState )( 
            __RPC__in IUIAutomationWindowPattern * This,
            /* [in] */ enum WindowVisualState state);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentCanMaximize )( 
            __RPC__in IUIAutomationWindowPattern * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentCanMinimize )( 
            __RPC__in IUIAutomationWindowPattern * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentIsModal )( 
            __RPC__in IUIAutomationWindowPattern * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentIsTopmost )( 
            __RPC__in IUIAutomationWindowPattern * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentWindowVisualState )( 
            __RPC__in IUIAutomationWindowPattern * This,
            /* [retval][out] */ __RPC__out enum WindowVisualState *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentWindowInteractionState )( 
            __RPC__in IUIAutomationWindowPattern * This,
            /* [retval][out] */ __RPC__out enum WindowInteractionState *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedCanMaximize )( 
            __RPC__in IUIAutomationWindowPattern * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedCanMinimize )( 
            __RPC__in IUIAutomationWindowPattern * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedIsModal )( 
            __RPC__in IUIAutomationWindowPattern * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedIsTopmost )( 
            __RPC__in IUIAutomationWindowPattern * This,
            /* [retval][out] */ __RPC__out BOOL *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedWindowVisualState )( 
            __RPC__in IUIAutomationWindowPattern * This,
            /* [retval][out] */ __RPC__out enum WindowVisualState *retVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedWindowInteractionState )( 
            __RPC__in IUIAutomationWindowPattern * This,
            /* [retval][out] */ __RPC__out enum WindowInteractionState *retVal);
        
        END_INTERFACE
    } IUIAutomationWindowPatternVtbl;

    interface IUIAutomationWindowPattern
    {
        CONST_VTBL struct IUIAutomationWindowPatternVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationWindowPattern_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationWindowPattern_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationWindowPattern_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationWindowPattern_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#define IUIAutomationWindowPattern_WaitForInputIdle(This,milliseconds,success)	\
    ( (This)->lpVtbl -> WaitForInputIdle(This,milliseconds,success) ) 

#define IUIAutomationWindowPattern_SetWindowVisualState(This,state)	\
    ( (This)->lpVtbl -> SetWindowVisualState(This,state) ) 

#define IUIAutomationWindowPattern_get_CurrentCanMaximize(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentCanMaximize(This,retVal) ) 

#define IUIAutomationWindowPattern_get_CurrentCanMinimize(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentCanMinimize(This,retVal) ) 

#define IUIAutomationWindowPattern_get_CurrentIsModal(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentIsModal(This,retVal) ) 

#define IUIAutomationWindowPattern_get_CurrentIsTopmost(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentIsTopmost(This,retVal) ) 

#define IUIAutomationWindowPattern_get_CurrentWindowVisualState(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentWindowVisualState(This,retVal) ) 

#define IUIAutomationWindowPattern_get_CurrentWindowInteractionState(This,retVal)	\
    ( (This)->lpVtbl -> get_CurrentWindowInteractionState(This,retVal) ) 

#define IUIAutomationWindowPattern_get_CachedCanMaximize(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedCanMaximize(This,retVal) ) 

#define IUIAutomationWindowPattern_get_CachedCanMinimize(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedCanMinimize(This,retVal) ) 

#define IUIAutomationWindowPattern_get_CachedIsModal(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedIsModal(This,retVal) ) 

#define IUIAutomationWindowPattern_get_CachedIsTopmost(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedIsTopmost(This,retVal) ) 

#define IUIAutomationWindowPattern_get_CachedWindowVisualState(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedWindowVisualState(This,retVal) ) 

#define IUIAutomationWindowPattern_get_CachedWindowInteractionState(This,retVal)	\
    ( (This)->lpVtbl -> get_CachedWindowInteractionState(This,retVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationWindowPattern_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationTextRange_INTERFACE_DEFINED__
#define __IUIAutomationTextRange_INTERFACE_DEFINED__

/* interface IUIAutomationTextRange */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationTextRange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a543cc6a-f4ae-494b-8239-c814481187a8")
    IUIAutomationTextRange : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationTextRange **clonedRange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Compare( 
            /* [in] */ __RPC__in_opt IUIAutomationTextRange *range,
            /* [retval][out] */ __RPC__out BOOL *areSame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompareEndpoints( 
            /* [in] */ enum TextPatternRangeEndpoint srcEndPoint,
            /* [in] */ __RPC__in_opt IUIAutomationTextRange *range,
            /* [in] */ enum TextPatternRangeEndpoint targetEndPoint,
            /* [retval][out] */ __RPC__out int *compValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExpandToEnclosingUnit( 
            /* [in] */ enum TextUnit textUnit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindAttribute( 
            /* [in] */ TEXTATTRIBUTEID attr,
            /* [in] */ VARIANT val,
            /* [in] */ BOOL backward,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationTextRange **found) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindText( 
            /* [in] */ __RPC__in BSTR text,
            /* [in] */ BOOL backward,
            /* [in] */ BOOL ignoreCase,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationTextRange **found) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeValue( 
            /* [in] */ TEXTATTRIBUTEID attr,
            /* [retval][out] */ __RPC__out VARIANT *value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBoundingRectangles( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *boundingRects) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnclosingElement( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **enclosingElement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetText( 
            /* [in] */ int maxLength,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *text) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Move( 
            /* [in] */ enum TextUnit unit,
            /* [in] */ int count,
            /* [retval][out] */ __RPC__out int *moved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MoveEndpointByUnit( 
            /* [in] */ enum TextPatternRangeEndpoint endpoint,
            /* [in] */ enum TextUnit unit,
            /* [in] */ int count,
            /* [retval][out] */ __RPC__out int *moved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MoveEndpointByRange( 
            /* [in] */ enum TextPatternRangeEndpoint srcEndPoint,
            /* [in] */ __RPC__in_opt IUIAutomationTextRange *range,
            /* [in] */ enum TextPatternRangeEndpoint targetEndPoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Select( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddToSelection( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveFromSelection( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ScrollIntoView( 
            /* [in] */ BOOL alignToTop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChildren( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **children) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationTextRangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationTextRange * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationTextRange * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationTextRange * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IUIAutomationTextRange * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationTextRange **clonedRange);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            __RPC__in IUIAutomationTextRange * This,
            /* [in] */ __RPC__in_opt IUIAutomationTextRange *range,
            /* [retval][out] */ __RPC__out BOOL *areSame);
        
        HRESULT ( STDMETHODCALLTYPE *CompareEndpoints )( 
            __RPC__in IUIAutomationTextRange * This,
            /* [in] */ enum TextPatternRangeEndpoint srcEndPoint,
            /* [in] */ __RPC__in_opt IUIAutomationTextRange *range,
            /* [in] */ enum TextPatternRangeEndpoint targetEndPoint,
            /* [retval][out] */ __RPC__out int *compValue);
        
        HRESULT ( STDMETHODCALLTYPE *ExpandToEnclosingUnit )( 
            __RPC__in IUIAutomationTextRange * This,
            /* [in] */ enum TextUnit textUnit);
        
        HRESULT ( STDMETHODCALLTYPE *FindAttribute )( 
            __RPC__in IUIAutomationTextRange * This,
            /* [in] */ TEXTATTRIBUTEID attr,
            /* [in] */ VARIANT val,
            /* [in] */ BOOL backward,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationTextRange **found);
        
        HRESULT ( STDMETHODCALLTYPE *FindText )( 
            __RPC__in IUIAutomationTextRange * This,
            /* [in] */ __RPC__in BSTR text,
            /* [in] */ BOOL backward,
            /* [in] */ BOOL ignoreCase,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationTextRange **found);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeValue )( 
            __RPC__in IUIAutomationTextRange * This,
            /* [in] */ TEXTATTRIBUTEID attr,
            /* [retval][out] */ __RPC__out VARIANT *value);
        
        HRESULT ( STDMETHODCALLTYPE *GetBoundingRectangles )( 
            __RPC__in IUIAutomationTextRange * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *boundingRects);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnclosingElement )( 
            __RPC__in IUIAutomationTextRange * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **enclosingElement);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            __RPC__in IUIAutomationTextRange * This,
            /* [in] */ int maxLength,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *text);
        
        HRESULT ( STDMETHODCALLTYPE *Move )( 
            __RPC__in IUIAutomationTextRange * This,
            /* [in] */ enum TextUnit unit,
            /* [in] */ int count,
            /* [retval][out] */ __RPC__out int *moved);
        
        HRESULT ( STDMETHODCALLTYPE *MoveEndpointByUnit )( 
            __RPC__in IUIAutomationTextRange * This,
            /* [in] */ enum TextPatternRangeEndpoint endpoint,
            /* [in] */ enum TextUnit unit,
            /* [in] */ int count,
            /* [retval][out] */ __RPC__out int *moved);
        
        HRESULT ( STDMETHODCALLTYPE *MoveEndpointByRange )( 
            __RPC__in IUIAutomationTextRange * This,
            /* [in] */ enum TextPatternRangeEndpoint srcEndPoint,
            /* [in] */ __RPC__in_opt IUIAutomationTextRange *range,
            /* [in] */ enum TextPatternRangeEndpoint targetEndPoint);
        
        HRESULT ( STDMETHODCALLTYPE *Select )( 
            __RPC__in IUIAutomationTextRange * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddToSelection )( 
            __RPC__in IUIAutomationTextRange * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFromSelection )( 
            __RPC__in IUIAutomationTextRange * This);
        
        HRESULT ( STDMETHODCALLTYPE *ScrollIntoView )( 
            __RPC__in IUIAutomationTextRange * This,
            /* [in] */ BOOL alignToTop);
        
        HRESULT ( STDMETHODCALLTYPE *GetChildren )( 
            __RPC__in IUIAutomationTextRange * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **children);
        
        END_INTERFACE
    } IUIAutomationTextRangeVtbl;

    interface IUIAutomationTextRange
    {
        CONST_VTBL struct IUIAutomationTextRangeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationTextRange_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationTextRange_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationTextRange_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationTextRange_Clone(This,clonedRange)	\
    ( (This)->lpVtbl -> Clone(This,clonedRange) ) 

#define IUIAutomationTextRange_Compare(This,range,areSame)	\
    ( (This)->lpVtbl -> Compare(This,range,areSame) ) 

#define IUIAutomationTextRange_CompareEndpoints(This,srcEndPoint,range,targetEndPoint,compValue)	\
    ( (This)->lpVtbl -> CompareEndpoints(This,srcEndPoint,range,targetEndPoint,compValue) ) 

#define IUIAutomationTextRange_ExpandToEnclosingUnit(This,textUnit)	\
    ( (This)->lpVtbl -> ExpandToEnclosingUnit(This,textUnit) ) 

#define IUIAutomationTextRange_FindAttribute(This,attr,val,backward,found)	\
    ( (This)->lpVtbl -> FindAttribute(This,attr,val,backward,found) ) 

#define IUIAutomationTextRange_FindText(This,text,backward,ignoreCase,found)	\
    ( (This)->lpVtbl -> FindText(This,text,backward,ignoreCase,found) ) 

#define IUIAutomationTextRange_GetAttributeValue(This,attr,value)	\
    ( (This)->lpVtbl -> GetAttributeValue(This,attr,value) ) 

#define IUIAutomationTextRange_GetBoundingRectangles(This,boundingRects)	\
    ( (This)->lpVtbl -> GetBoundingRectangles(This,boundingRects) ) 

#define IUIAutomationTextRange_GetEnclosingElement(This,enclosingElement)	\
    ( (This)->lpVtbl -> GetEnclosingElement(This,enclosingElement) ) 

#define IUIAutomationTextRange_GetText(This,maxLength,text)	\
    ( (This)->lpVtbl -> GetText(This,maxLength,text) ) 

#define IUIAutomationTextRange_Move(This,unit,count,moved)	\
    ( (This)->lpVtbl -> Move(This,unit,count,moved) ) 

#define IUIAutomationTextRange_MoveEndpointByUnit(This,endpoint,unit,count,moved)	\
    ( (This)->lpVtbl -> MoveEndpointByUnit(This,endpoint,unit,count,moved) ) 

#define IUIAutomationTextRange_MoveEndpointByRange(This,srcEndPoint,range,targetEndPoint)	\
    ( (This)->lpVtbl -> MoveEndpointByRange(This,srcEndPoint,range,targetEndPoint) ) 

#define IUIAutomationTextRange_Select(This)	\
    ( (This)->lpVtbl -> Select(This) ) 

#define IUIAutomationTextRange_AddToSelection(This)	\
    ( (This)->lpVtbl -> AddToSelection(This) ) 

#define IUIAutomationTextRange_RemoveFromSelection(This)	\
    ( (This)->lpVtbl -> RemoveFromSelection(This) ) 

#define IUIAutomationTextRange_ScrollIntoView(This,alignToTop)	\
    ( (This)->lpVtbl -> ScrollIntoView(This,alignToTop) ) 

#define IUIAutomationTextRange_GetChildren(This,children)	\
    ( (This)->lpVtbl -> GetChildren(This,children) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationTextRange_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationTextRangeArray_INTERFACE_DEFINED__
#define __IUIAutomationTextRangeArray_INTERFACE_DEFINED__

/* interface IUIAutomationTextRangeArray */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationTextRangeArray;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ce4ae76a-e717-4c98-81ea-47371d028eb6")
    IUIAutomationTextRangeArray : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Length( 
            /* [retval][out] */ __RPC__out int *length) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetElement( 
            /* [in] */ int index,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationTextRange **element) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationTextRangeArrayVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationTextRangeArray * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationTextRangeArray * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationTextRangeArray * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Length )( 
            __RPC__in IUIAutomationTextRangeArray * This,
            /* [retval][out] */ __RPC__out int *length);
        
        HRESULT ( STDMETHODCALLTYPE *GetElement )( 
            __RPC__in IUIAutomationTextRangeArray * This,
            /* [in] */ int index,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationTextRange **element);
        
        END_INTERFACE
    } IUIAutomationTextRangeArrayVtbl;

    interface IUIAutomationTextRangeArray
    {
        CONST_VTBL struct IUIAutomationTextRangeArrayVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationTextRangeArray_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationTextRangeArray_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationTextRangeArray_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationTextRangeArray_get_Length(This,length)	\
    ( (This)->lpVtbl -> get_Length(This,length) ) 

#define IUIAutomationTextRangeArray_GetElement(This,index,element)	\
    ( (This)->lpVtbl -> GetElement(This,index,element) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationTextRangeArray_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationTextPattern_INTERFACE_DEFINED__
#define __IUIAutomationTextPattern_INTERFACE_DEFINED__

/* interface IUIAutomationTextPattern */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationTextPattern;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("32eba289-3583-42c9-9c59-3b6d9a1e9b6a")
    IUIAutomationTextPattern : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RangeFromPoint( 
            /* [in] */ POINT pt,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationTextRange **range) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RangeFromChild( 
            /* [in] */ __RPC__in_opt IUIAutomationElement *child,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationTextRange **range) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelection( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationTextRangeArray **ranges) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVisibleRanges( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationTextRangeArray **ranges) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DocumentRange( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationTextRange **range) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SupportedTextSelection( 
            /* [retval][out] */ __RPC__out enum SupportedTextSelection *supportedTextSelection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationTextPatternVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationTextPattern * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationTextPattern * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationTextPattern * This);
        
        HRESULT ( STDMETHODCALLTYPE *RangeFromPoint )( 
            __RPC__in IUIAutomationTextPattern * This,
            /* [in] */ POINT pt,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationTextRange **range);
        
        HRESULT ( STDMETHODCALLTYPE *RangeFromChild )( 
            __RPC__in IUIAutomationTextPattern * This,
            /* [in] */ __RPC__in_opt IUIAutomationElement *child,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationTextRange **range);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelection )( 
            __RPC__in IUIAutomationTextPattern * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationTextRangeArray **ranges);
        
        HRESULT ( STDMETHODCALLTYPE *GetVisibleRanges )( 
            __RPC__in IUIAutomationTextPattern * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationTextRangeArray **ranges);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DocumentRange )( 
            __RPC__in IUIAutomationTextPattern * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationTextRange **range);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SupportedTextSelection )( 
            __RPC__in IUIAutomationTextPattern * This,
            /* [retval][out] */ __RPC__out enum SupportedTextSelection *supportedTextSelection);
        
        END_INTERFACE
    } IUIAutomationTextPatternVtbl;

    interface IUIAutomationTextPattern
    {
        CONST_VTBL struct IUIAutomationTextPatternVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationTextPattern_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationTextPattern_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationTextPattern_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationTextPattern_RangeFromPoint(This,pt,range)	\
    ( (This)->lpVtbl -> RangeFromPoint(This,pt,range) ) 

#define IUIAutomationTextPattern_RangeFromChild(This,child,range)	\
    ( (This)->lpVtbl -> RangeFromChild(This,child,range) ) 

#define IUIAutomationTextPattern_GetSelection(This,ranges)	\
    ( (This)->lpVtbl -> GetSelection(This,ranges) ) 

#define IUIAutomationTextPattern_GetVisibleRanges(This,ranges)	\
    ( (This)->lpVtbl -> GetVisibleRanges(This,ranges) ) 

#define IUIAutomationTextPattern_get_DocumentRange(This,range)	\
    ( (This)->lpVtbl -> get_DocumentRange(This,range) ) 

#define IUIAutomationTextPattern_get_SupportedTextSelection(This,supportedTextSelection)	\
    ( (This)->lpVtbl -> get_SupportedTextSelection(This,supportedTextSelection) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationTextPattern_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationLegacyIAccessiblePattern_INTERFACE_DEFINED__
#define __IUIAutomationLegacyIAccessiblePattern_INTERFACE_DEFINED__

/* interface IUIAutomationLegacyIAccessiblePattern */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationLegacyIAccessiblePattern;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("828055ad-355b-4435-86d5-3b51c14a9b1b")
    IUIAutomationLegacyIAccessiblePattern : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Select( 
            long flagsSelect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoDefaultAction( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            __RPC__in LPCWSTR szValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentChildId( 
            /* [retval][out] */ __RPC__out int *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentValue( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentDescription( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszDescription) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentRole( 
            /* [retval][out] */ __RPC__out DWORD *pdwRole) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentState( 
            /* [retval][out] */ __RPC__out DWORD *pdwState) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentHelp( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszHelp) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentKeyboardShortcut( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszKeyboardShortcut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentSelection( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **pvarSelectedChildren) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentDefaultAction( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszDefaultAction) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedChildId( 
            /* [retval][out] */ __RPC__out int *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedValue( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedDescription( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszDescription) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedRole( 
            /* [retval][out] */ __RPC__out DWORD *pdwRole) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedState( 
            /* [retval][out] */ __RPC__out DWORD *pdwState) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedHelp( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszHelp) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedKeyboardShortcut( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszKeyboardShortcut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCachedSelection( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **pvarSelectedChildren) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CachedDefaultAction( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszDefaultAction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIAccessible( 
            /* [retval][out] */ __RPC__deref_out_opt IAccessible **ppAccessible) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationLegacyIAccessiblePatternVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationLegacyIAccessiblePattern * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationLegacyIAccessiblePattern * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationLegacyIAccessiblePattern * This);
        
        HRESULT ( STDMETHODCALLTYPE *Select )( 
            __RPC__in IUIAutomationLegacyIAccessiblePattern * This,
            long flagsSelect);
        
        HRESULT ( STDMETHODCALLTYPE *DoDefaultAction )( 
            __RPC__in IUIAutomationLegacyIAccessiblePattern * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            __RPC__in IUIAutomationLegacyIAccessiblePattern * This,
            __RPC__in LPCWSTR szValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentChildId )( 
            __RPC__in IUIAutomationLegacyIAccessiblePattern * This,
            /* [retval][out] */ __RPC__out int *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentName )( 
            __RPC__in IUIAutomationLegacyIAccessiblePattern * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentValue )( 
            __RPC__in IUIAutomationLegacyIAccessiblePattern * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentDescription )( 
            __RPC__in IUIAutomationLegacyIAccessiblePattern * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszDescription);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentRole )( 
            __RPC__in IUIAutomationLegacyIAccessiblePattern * This,
            /* [retval][out] */ __RPC__out DWORD *pdwRole);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentState )( 
            __RPC__in IUIAutomationLegacyIAccessiblePattern * This,
            /* [retval][out] */ __RPC__out DWORD *pdwState);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentHelp )( 
            __RPC__in IUIAutomationLegacyIAccessiblePattern * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszHelp);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentKeyboardShortcut )( 
            __RPC__in IUIAutomationLegacyIAccessiblePattern * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszKeyboardShortcut);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentSelection )( 
            __RPC__in IUIAutomationLegacyIAccessiblePattern * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **pvarSelectedChildren);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentDefaultAction )( 
            __RPC__in IUIAutomationLegacyIAccessiblePattern * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszDefaultAction);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedChildId )( 
            __RPC__in IUIAutomationLegacyIAccessiblePattern * This,
            /* [retval][out] */ __RPC__out int *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedName )( 
            __RPC__in IUIAutomationLegacyIAccessiblePattern * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedValue )( 
            __RPC__in IUIAutomationLegacyIAccessiblePattern * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedDescription )( 
            __RPC__in IUIAutomationLegacyIAccessiblePattern * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszDescription);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedRole )( 
            __RPC__in IUIAutomationLegacyIAccessiblePattern * This,
            /* [retval][out] */ __RPC__out DWORD *pdwRole);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedState )( 
            __RPC__in IUIAutomationLegacyIAccessiblePattern * This,
            /* [retval][out] */ __RPC__out DWORD *pdwState);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedHelp )( 
            __RPC__in IUIAutomationLegacyIAccessiblePattern * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszHelp);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedKeyboardShortcut )( 
            __RPC__in IUIAutomationLegacyIAccessiblePattern * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszKeyboardShortcut);
        
        HRESULT ( STDMETHODCALLTYPE *GetCachedSelection )( 
            __RPC__in IUIAutomationLegacyIAccessiblePattern * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElementArray **pvarSelectedChildren);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CachedDefaultAction )( 
            __RPC__in IUIAutomationLegacyIAccessiblePattern * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszDefaultAction);
        
        HRESULT ( STDMETHODCALLTYPE *GetIAccessible )( 
            __RPC__in IUIAutomationLegacyIAccessiblePattern * This,
            /* [retval][out] */ __RPC__deref_out_opt IAccessible **ppAccessible);
        
        END_INTERFACE
    } IUIAutomationLegacyIAccessiblePatternVtbl;

    interface IUIAutomationLegacyIAccessiblePattern
    {
        CONST_VTBL struct IUIAutomationLegacyIAccessiblePatternVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationLegacyIAccessiblePattern_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationLegacyIAccessiblePattern_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationLegacyIAccessiblePattern_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationLegacyIAccessiblePattern_Select(This,flagsSelect)	\
    ( (This)->lpVtbl -> Select(This,flagsSelect) ) 

#define IUIAutomationLegacyIAccessiblePattern_DoDefaultAction(This)	\
    ( (This)->lpVtbl -> DoDefaultAction(This) ) 

#define IUIAutomationLegacyIAccessiblePattern_SetValue(This,szValue)	\
    ( (This)->lpVtbl -> SetValue(This,szValue) ) 

#define IUIAutomationLegacyIAccessiblePattern_get_CurrentChildId(This,pRetVal)	\
    ( (This)->lpVtbl -> get_CurrentChildId(This,pRetVal) ) 

#define IUIAutomationLegacyIAccessiblePattern_get_CurrentName(This,pszName)	\
    ( (This)->lpVtbl -> get_CurrentName(This,pszName) ) 

#define IUIAutomationLegacyIAccessiblePattern_get_CurrentValue(This,pszValue)	\
    ( (This)->lpVtbl -> get_CurrentValue(This,pszValue) ) 

#define IUIAutomationLegacyIAccessiblePattern_get_CurrentDescription(This,pszDescription)	\
    ( (This)->lpVtbl -> get_CurrentDescription(This,pszDescription) ) 

#define IUIAutomationLegacyIAccessiblePattern_get_CurrentRole(This,pdwRole)	\
    ( (This)->lpVtbl -> get_CurrentRole(This,pdwRole) ) 

#define IUIAutomationLegacyIAccessiblePattern_get_CurrentState(This,pdwState)	\
    ( (This)->lpVtbl -> get_CurrentState(This,pdwState) ) 

#define IUIAutomationLegacyIAccessiblePattern_get_CurrentHelp(This,pszHelp)	\
    ( (This)->lpVtbl -> get_CurrentHelp(This,pszHelp) ) 

#define IUIAutomationLegacyIAccessiblePattern_get_CurrentKeyboardShortcut(This,pszKeyboardShortcut)	\
    ( (This)->lpVtbl -> get_CurrentKeyboardShortcut(This,pszKeyboardShortcut) ) 

#define IUIAutomationLegacyIAccessiblePattern_GetCurrentSelection(This,pvarSelectedChildren)	\
    ( (This)->lpVtbl -> GetCurrentSelection(This,pvarSelectedChildren) ) 

#define IUIAutomationLegacyIAccessiblePattern_get_CurrentDefaultAction(This,pszDefaultAction)	\
    ( (This)->lpVtbl -> get_CurrentDefaultAction(This,pszDefaultAction) ) 

#define IUIAutomationLegacyIAccessiblePattern_get_CachedChildId(This,pRetVal)	\
    ( (This)->lpVtbl -> get_CachedChildId(This,pRetVal) ) 

#define IUIAutomationLegacyIAccessiblePattern_get_CachedName(This,pszName)	\
    ( (This)->lpVtbl -> get_CachedName(This,pszName) ) 

#define IUIAutomationLegacyIAccessiblePattern_get_CachedValue(This,pszValue)	\
    ( (This)->lpVtbl -> get_CachedValue(This,pszValue) ) 

#define IUIAutomationLegacyIAccessiblePattern_get_CachedDescription(This,pszDescription)	\
    ( (This)->lpVtbl -> get_CachedDescription(This,pszDescription) ) 

#define IUIAutomationLegacyIAccessiblePattern_get_CachedRole(This,pdwRole)	\
    ( (This)->lpVtbl -> get_CachedRole(This,pdwRole) ) 

#define IUIAutomationLegacyIAccessiblePattern_get_CachedState(This,pdwState)	\
    ( (This)->lpVtbl -> get_CachedState(This,pdwState) ) 

#define IUIAutomationLegacyIAccessiblePattern_get_CachedHelp(This,pszHelp)	\
    ( (This)->lpVtbl -> get_CachedHelp(This,pszHelp) ) 

#define IUIAutomationLegacyIAccessiblePattern_get_CachedKeyboardShortcut(This,pszKeyboardShortcut)	\
    ( (This)->lpVtbl -> get_CachedKeyboardShortcut(This,pszKeyboardShortcut) ) 

#define IUIAutomationLegacyIAccessiblePattern_GetCachedSelection(This,pvarSelectedChildren)	\
    ( (This)->lpVtbl -> GetCachedSelection(This,pvarSelectedChildren) ) 

#define IUIAutomationLegacyIAccessiblePattern_get_CachedDefaultAction(This,pszDefaultAction)	\
    ( (This)->lpVtbl -> get_CachedDefaultAction(This,pszDefaultAction) ) 

#define IUIAutomationLegacyIAccessiblePattern_GetIAccessible(This,ppAccessible)	\
    ( (This)->lpVtbl -> GetIAccessible(This,ppAccessible) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationLegacyIAccessiblePattern_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationItemContainerPattern_INTERFACE_DEFINED__
#define __IUIAutomationItemContainerPattern_INTERFACE_DEFINED__

/* interface IUIAutomationItemContainerPattern */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationItemContainerPattern;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c690fdb2-27a8-423c-812d-429773c9084e")
    IUIAutomationItemContainerPattern : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindItemByProperty( 
            /* [in] */ __RPC__in_opt IUIAutomationElement *pStartAfter,
            /* [in] */ PROPERTYID propertyId,
            /* [in] */ VARIANT value,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **pFound) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationItemContainerPatternVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationItemContainerPattern * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationItemContainerPattern * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationItemContainerPattern * This);
        
        HRESULT ( STDMETHODCALLTYPE *FindItemByProperty )( 
            __RPC__in IUIAutomationItemContainerPattern * This,
            /* [in] */ __RPC__in_opt IUIAutomationElement *pStartAfter,
            /* [in] */ PROPERTYID propertyId,
            /* [in] */ VARIANT value,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **pFound);
        
        END_INTERFACE
    } IUIAutomationItemContainerPatternVtbl;

    interface IUIAutomationItemContainerPattern
    {
        CONST_VTBL struct IUIAutomationItemContainerPatternVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationItemContainerPattern_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationItemContainerPattern_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationItemContainerPattern_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationItemContainerPattern_FindItemByProperty(This,pStartAfter,propertyId,value,pFound)	\
    ( (This)->lpVtbl -> FindItemByProperty(This,pStartAfter,propertyId,value,pFound) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationItemContainerPattern_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationVirtualizedItemPattern_INTERFACE_DEFINED__
#define __IUIAutomationVirtualizedItemPattern_INTERFACE_DEFINED__

/* interface IUIAutomationVirtualizedItemPattern */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationVirtualizedItemPattern;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6ba3d7a6-04cf-4f11-8793-a8d1cde9969f")
    IUIAutomationVirtualizedItemPattern : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Realize( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationVirtualizedItemPatternVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationVirtualizedItemPattern * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationVirtualizedItemPattern * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationVirtualizedItemPattern * This);
        
        HRESULT ( STDMETHODCALLTYPE *Realize )( 
            __RPC__in IUIAutomationVirtualizedItemPattern * This);
        
        END_INTERFACE
    } IUIAutomationVirtualizedItemPatternVtbl;

    interface IUIAutomationVirtualizedItemPattern
    {
        CONST_VTBL struct IUIAutomationVirtualizedItemPatternVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationVirtualizedItemPattern_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationVirtualizedItemPattern_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationVirtualizedItemPattern_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationVirtualizedItemPattern_Realize(This)	\
    ( (This)->lpVtbl -> Realize(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationVirtualizedItemPattern_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationProxyFactory_INTERFACE_DEFINED__
#define __IUIAutomationProxyFactory_INTERFACE_DEFINED__

/* interface IUIAutomationProxyFactory */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationProxyFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85b94ecd-849d-42b6-b94d-d6db23fdf5a4")
    IUIAutomationProxyFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateProvider( 
            /* [in] */ __RPC__in UIA_HWND hwnd,
            /* [in] */ LONG idObject,
            /* [in] */ LONG idChild,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderSimple **provider) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProxyFactoryId( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *factoryId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationProxyFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationProxyFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationProxyFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationProxyFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateProvider )( 
            __RPC__in IUIAutomationProxyFactory * This,
            /* [in] */ __RPC__in UIA_HWND hwnd,
            /* [in] */ LONG idObject,
            /* [in] */ LONG idChild,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderSimple **provider);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProxyFactoryId )( 
            __RPC__in IUIAutomationProxyFactory * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *factoryId);
        
        END_INTERFACE
    } IUIAutomationProxyFactoryVtbl;

    interface IUIAutomationProxyFactory
    {
        CONST_VTBL struct IUIAutomationProxyFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationProxyFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationProxyFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationProxyFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationProxyFactory_CreateProvider(This,hwnd,idObject,idChild,provider)	\
    ( (This)->lpVtbl -> CreateProvider(This,hwnd,idObject,idChild,provider) ) 

#define IUIAutomationProxyFactory_get_ProxyFactoryId(This,factoryId)	\
    ( (This)->lpVtbl -> get_ProxyFactoryId(This,factoryId) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationProxyFactory_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationProxyFactoryEntry_INTERFACE_DEFINED__
#define __IUIAutomationProxyFactoryEntry_INTERFACE_DEFINED__

/* interface IUIAutomationProxyFactoryEntry */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationProxyFactoryEntry;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d50e472e-b64b-490c-bca1-d30696f9f289")
    IUIAutomationProxyFactoryEntry : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProxyFactory( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationProxyFactory **factory) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ClassName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *className) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ImageName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *imageName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_AllowSubstringMatch( 
            /* [retval][out] */ __RPC__out BOOL *allowSubstringMatch) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CanCheckBaseClass( 
            /* [retval][out] */ __RPC__out BOOL *canCheckBaseClass) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_NeedsAdviseEvents( 
            /* [retval][out] */ __RPC__out BOOL *adviseEvents) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ClassName( 
            /* [in] */ __RPC__in LPCWSTR className) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ImageName( 
            /* [in] */ __RPC__in LPCWSTR imageName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_AllowSubstringMatch( 
            /* [in] */ BOOL allowSubstringMatch) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CanCheckBaseClass( 
            /* [in] */ BOOL canCheckBaseClass) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_NeedsAdviseEvents( 
            /* [in] */ BOOL adviseEvents) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWinEventsForAutomationEvent( 
            /* [in] */ EVENTID eventId,
            /* [in] */ PROPERTYID propertyId,
            /* [in] */ __RPC__in SAFEARRAY * winEvents) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWinEventsForAutomationEvent( 
            /* [in] */ EVENTID eventId,
            /* [in] */ PROPERTYID propertyId,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *winEvents) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationProxyFactoryEntryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationProxyFactoryEntry * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationProxyFactoryEntry * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationProxyFactoryEntry * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProxyFactory )( 
            __RPC__in IUIAutomationProxyFactoryEntry * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationProxyFactory **factory);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClassName )( 
            __RPC__in IUIAutomationProxyFactoryEntry * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *className);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ImageName )( 
            __RPC__in IUIAutomationProxyFactoryEntry * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *imageName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowSubstringMatch )( 
            __RPC__in IUIAutomationProxyFactoryEntry * This,
            /* [retval][out] */ __RPC__out BOOL *allowSubstringMatch);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CanCheckBaseClass )( 
            __RPC__in IUIAutomationProxyFactoryEntry * This,
            /* [retval][out] */ __RPC__out BOOL *canCheckBaseClass);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_NeedsAdviseEvents )( 
            __RPC__in IUIAutomationProxyFactoryEntry * This,
            /* [retval][out] */ __RPC__out BOOL *adviseEvents);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClassName )( 
            __RPC__in IUIAutomationProxyFactoryEntry * This,
            /* [in] */ __RPC__in LPCWSTR className);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ImageName )( 
            __RPC__in IUIAutomationProxyFactoryEntry * This,
            /* [in] */ __RPC__in LPCWSTR imageName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowSubstringMatch )( 
            __RPC__in IUIAutomationProxyFactoryEntry * This,
            /* [in] */ BOOL allowSubstringMatch);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CanCheckBaseClass )( 
            __RPC__in IUIAutomationProxyFactoryEntry * This,
            /* [in] */ BOOL canCheckBaseClass);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_NeedsAdviseEvents )( 
            __RPC__in IUIAutomationProxyFactoryEntry * This,
            /* [in] */ BOOL adviseEvents);
        
        HRESULT ( STDMETHODCALLTYPE *SetWinEventsForAutomationEvent )( 
            __RPC__in IUIAutomationProxyFactoryEntry * This,
            /* [in] */ EVENTID eventId,
            /* [in] */ PROPERTYID propertyId,
            /* [in] */ __RPC__in SAFEARRAY * winEvents);
        
        HRESULT ( STDMETHODCALLTYPE *GetWinEventsForAutomationEvent )( 
            __RPC__in IUIAutomationProxyFactoryEntry * This,
            /* [in] */ EVENTID eventId,
            /* [in] */ PROPERTYID propertyId,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *winEvents);
        
        END_INTERFACE
    } IUIAutomationProxyFactoryEntryVtbl;

    interface IUIAutomationProxyFactoryEntry
    {
        CONST_VTBL struct IUIAutomationProxyFactoryEntryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationProxyFactoryEntry_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationProxyFactoryEntry_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationProxyFactoryEntry_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationProxyFactoryEntry_get_ProxyFactory(This,factory)	\
    ( (This)->lpVtbl -> get_ProxyFactory(This,factory) ) 

#define IUIAutomationProxyFactoryEntry_get_ClassName(This,className)	\
    ( (This)->lpVtbl -> get_ClassName(This,className) ) 

#define IUIAutomationProxyFactoryEntry_get_ImageName(This,imageName)	\
    ( (This)->lpVtbl -> get_ImageName(This,imageName) ) 

#define IUIAutomationProxyFactoryEntry_get_AllowSubstringMatch(This,allowSubstringMatch)	\
    ( (This)->lpVtbl -> get_AllowSubstringMatch(This,allowSubstringMatch) ) 

#define IUIAutomationProxyFactoryEntry_get_CanCheckBaseClass(This,canCheckBaseClass)	\
    ( (This)->lpVtbl -> get_CanCheckBaseClass(This,canCheckBaseClass) ) 

#define IUIAutomationProxyFactoryEntry_get_NeedsAdviseEvents(This,adviseEvents)	\
    ( (This)->lpVtbl -> get_NeedsAdviseEvents(This,adviseEvents) ) 

#define IUIAutomationProxyFactoryEntry_put_ClassName(This,className)	\
    ( (This)->lpVtbl -> put_ClassName(This,className) ) 

#define IUIAutomationProxyFactoryEntry_put_ImageName(This,imageName)	\
    ( (This)->lpVtbl -> put_ImageName(This,imageName) ) 

#define IUIAutomationProxyFactoryEntry_put_AllowSubstringMatch(This,allowSubstringMatch)	\
    ( (This)->lpVtbl -> put_AllowSubstringMatch(This,allowSubstringMatch) ) 

#define IUIAutomationProxyFactoryEntry_put_CanCheckBaseClass(This,canCheckBaseClass)	\
    ( (This)->lpVtbl -> put_CanCheckBaseClass(This,canCheckBaseClass) ) 

#define IUIAutomationProxyFactoryEntry_put_NeedsAdviseEvents(This,adviseEvents)	\
    ( (This)->lpVtbl -> put_NeedsAdviseEvents(This,adviseEvents) ) 

#define IUIAutomationProxyFactoryEntry_SetWinEventsForAutomationEvent(This,eventId,propertyId,winEvents)	\
    ( (This)->lpVtbl -> SetWinEventsForAutomationEvent(This,eventId,propertyId,winEvents) ) 

#define IUIAutomationProxyFactoryEntry_GetWinEventsForAutomationEvent(This,eventId,propertyId,winEvents)	\
    ( (This)->lpVtbl -> GetWinEventsForAutomationEvent(This,eventId,propertyId,winEvents) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationProxyFactoryEntry_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationProxyFactoryMapping_INTERFACE_DEFINED__
#define __IUIAutomationProxyFactoryMapping_INTERFACE_DEFINED__

/* interface IUIAutomationProxyFactoryMapping */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationProxyFactoryMapping;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("09e31e18-872d-4873-93d1-1e541ec133fd")
    IUIAutomationProxyFactoryMapping : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out UINT *count) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTable( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *table) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEntry( 
            /* [in] */ UINT index,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationProxyFactoryEntry **entry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTable( 
            /* [in] */ __RPC__in_opt SAFEARRAY * factoryList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertEntries( 
            /* [in] */ UINT before,
            /* [in] */ __RPC__in_opt SAFEARRAY * factoryList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertEntry( 
            /* [in] */ UINT before,
            /* [in] */ __RPC__in_opt IUIAutomationProxyFactoryEntry *factory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveEntry( 
            /* [in] */ UINT index) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearTable( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestoreDefaultTable( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationProxyFactoryMappingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationProxyFactoryMapping * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationProxyFactoryMapping * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationProxyFactoryMapping * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in IUIAutomationProxyFactoryMapping * This,
            /* [retval][out] */ __RPC__out UINT *count);
        
        HRESULT ( STDMETHODCALLTYPE *GetTable )( 
            __RPC__in IUIAutomationProxyFactoryMapping * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *table);
        
        HRESULT ( STDMETHODCALLTYPE *GetEntry )( 
            __RPC__in IUIAutomationProxyFactoryMapping * This,
            /* [in] */ UINT index,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationProxyFactoryEntry **entry);
        
        HRESULT ( STDMETHODCALLTYPE *SetTable )( 
            __RPC__in IUIAutomationProxyFactoryMapping * This,
            /* [in] */ __RPC__in_opt SAFEARRAY * factoryList);
        
        HRESULT ( STDMETHODCALLTYPE *InsertEntries )( 
            __RPC__in IUIAutomationProxyFactoryMapping * This,
            /* [in] */ UINT before,
            /* [in] */ __RPC__in_opt SAFEARRAY * factoryList);
        
        HRESULT ( STDMETHODCALLTYPE *InsertEntry )( 
            __RPC__in IUIAutomationProxyFactoryMapping * This,
            /* [in] */ UINT before,
            /* [in] */ __RPC__in_opt IUIAutomationProxyFactoryEntry *factory);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveEntry )( 
            __RPC__in IUIAutomationProxyFactoryMapping * This,
            /* [in] */ UINT index);
        
        HRESULT ( STDMETHODCALLTYPE *ClearTable )( 
            __RPC__in IUIAutomationProxyFactoryMapping * This);
        
        HRESULT ( STDMETHODCALLTYPE *RestoreDefaultTable )( 
            __RPC__in IUIAutomationProxyFactoryMapping * This);
        
        END_INTERFACE
    } IUIAutomationProxyFactoryMappingVtbl;

    interface IUIAutomationProxyFactoryMapping
    {
        CONST_VTBL struct IUIAutomationProxyFactoryMappingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationProxyFactoryMapping_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationProxyFactoryMapping_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationProxyFactoryMapping_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationProxyFactoryMapping_get_Count(This,count)	\
    ( (This)->lpVtbl -> get_Count(This,count) ) 

#define IUIAutomationProxyFactoryMapping_GetTable(This,table)	\
    ( (This)->lpVtbl -> GetTable(This,table) ) 

#define IUIAutomationProxyFactoryMapping_GetEntry(This,index,entry)	\
    ( (This)->lpVtbl -> GetEntry(This,index,entry) ) 

#define IUIAutomationProxyFactoryMapping_SetTable(This,factoryList)	\
    ( (This)->lpVtbl -> SetTable(This,factoryList) ) 

#define IUIAutomationProxyFactoryMapping_InsertEntries(This,before,factoryList)	\
    ( (This)->lpVtbl -> InsertEntries(This,before,factoryList) ) 

#define IUIAutomationProxyFactoryMapping_InsertEntry(This,before,factory)	\
    ( (This)->lpVtbl -> InsertEntry(This,before,factory) ) 

#define IUIAutomationProxyFactoryMapping_RemoveEntry(This,index)	\
    ( (This)->lpVtbl -> RemoveEntry(This,index) ) 

#define IUIAutomationProxyFactoryMapping_ClearTable(This)	\
    ( (This)->lpVtbl -> ClearTable(This) ) 

#define IUIAutomationProxyFactoryMapping_RestoreDefaultTable(This)	\
    ( (This)->lpVtbl -> RestoreDefaultTable(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationProxyFactoryMapping_INTERFACE_DEFINED__ */


#ifndef __IUIAutomation_INTERFACE_DEFINED__
#define __IUIAutomation_INTERFACE_DEFINED__

/* interface IUIAutomation */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("30cbe57d-d9d0-452a-ab13-7ac5ac4825ee")
    IUIAutomation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CompareElements( 
            /* [in] */ __RPC__in_opt IUIAutomationElement *el1,
            /* [in] */ __RPC__in_opt IUIAutomationElement *el2,
            /* [retval][out] */ __RPC__out BOOL *areSame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompareRuntimeIds( 
            /* [in] */ __RPC__in SAFEARRAY * runtimeId1,
            /* [in] */ __RPC__in SAFEARRAY * runtimeId2,
            /* [retval][out] */ __RPC__out BOOL *areSame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRootElement( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **root) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ElementFromHandle( 
            /* [in] */ __RPC__in UIA_HWND hwnd,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **element) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ElementFromPoint( 
            /* [in] */ POINT pt,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **element) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFocusedElement( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **element) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRootElementBuildCache( 
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **root) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ElementFromHandleBuildCache( 
            /* [in] */ __RPC__in UIA_HWND hwnd,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **element) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ElementFromPointBuildCache( 
            /* [in] */ POINT pt,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **element) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFocusedElementBuildCache( 
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **element) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateTreeWalker( 
            /* [in] */ __RPC__in_opt IUIAutomationCondition *pCondition,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationTreeWalker **walker) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ControlViewWalker( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationTreeWalker **walker) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ContentViewWalker( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationTreeWalker **walker) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RawViewWalker( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationTreeWalker **walker) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RawViewCondition( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **condition) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ControlViewCondition( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **condition) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ContentViewCondition( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **condition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateCacheRequest( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCacheRequest **cacheRequest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateTrueCondition( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateFalseCondition( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePropertyCondition( 
            /* [in] */ PROPERTYID propertyId,
            /* [in] */ VARIANT value,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePropertyConditionEx( 
            /* [in] */ PROPERTYID propertyId,
            /* [in] */ VARIANT value,
            /* [in] */ enum PropertyConditionFlags flags,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAndCondition( 
            /* [in] */ __RPC__in_opt IUIAutomationCondition *condition1,
            /* [in] */ __RPC__in_opt IUIAutomationCondition *condition2,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAndConditionFromArray( 
            /* [in] */ __RPC__in_opt SAFEARRAY * conditions,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAndConditionFromNativeArray( 
            /* [size_is][in] */ __RPC__in_ecount_full(conditionCount) IUIAutomationCondition **conditions,
            /* [in] */ int conditionCount,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateOrCondition( 
            /* [in] */ __RPC__in_opt IUIAutomationCondition *condition1,
            /* [in] */ __RPC__in_opt IUIAutomationCondition *condition2,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateOrConditionFromArray( 
            /* [in] */ __RPC__in_opt SAFEARRAY * conditions,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateOrConditionFromNativeArray( 
            /* [size_is][in] */ __RPC__in_ecount_full(conditionCount) IUIAutomationCondition **conditions,
            /* [in] */ int conditionCount,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNotCondition( 
            /* [in] */ __RPC__in_opt IUIAutomationCondition *condition,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **newCondition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddAutomationEventHandler( 
            /* [in] */ EVENTID eventId,
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [in] */ enum TreeScope scope,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [in] */ __RPC__in_opt IUIAutomationEventHandler *handler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAutomationEventHandler( 
            /* [in] */ EVENTID eventId,
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [in] */ __RPC__in_opt IUIAutomationEventHandler *handler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddPropertyChangedEventHandlerNativeArray( 
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [in] */ enum TreeScope scope,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [in] */ __RPC__in_opt IUIAutomationPropertyChangedEventHandler *handler,
            /* [size_is][in] */ __RPC__in_ecount_full(propertyCount) PROPERTYID *propertyArray,
            /* [in] */ int propertyCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddPropertyChangedEventHandler( 
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [in] */ enum TreeScope scope,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [in] */ __RPC__in_opt IUIAutomationPropertyChangedEventHandler *handler,
            /* [in] */ __RPC__in SAFEARRAY * propertyArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemovePropertyChangedEventHandler( 
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [in] */ __RPC__in_opt IUIAutomationPropertyChangedEventHandler *handler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStructureChangedEventHandler( 
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [in] */ enum TreeScope scope,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [in] */ __RPC__in_opt IUIAutomationStructureChangedEventHandler *handler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStructureChangedEventHandler( 
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [in] */ __RPC__in_opt IUIAutomationStructureChangedEventHandler *handler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddFocusChangedEventHandler( 
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [in] */ __RPC__in_opt IUIAutomationFocusChangedEventHandler *handler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveFocusChangedEventHandler( 
            /* [in] */ __RPC__in_opt IUIAutomationFocusChangedEventHandler *handler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllEventHandlers( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IntNativeArrayToSafeArray( 
            /* [size_is][in] */ __RPC__in_ecount_full(arrayCount) int *array,
            /* [in] */ int arrayCount,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *safeArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IntSafeArrayToNativeArray( 
            /* [in] */ __RPC__in SAFEARRAY * intArray,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*arrayCount) int **array,
            /* [retval][out] */ __RPC__out int *arrayCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RectToVariant( 
            /* [in] */ RECT rc,
            /* [retval][out] */ __RPC__out VARIANT *var) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE VariantToRect( 
            /* [in] */ VARIANT var,
            /* [retval][out] */ __RPC__out RECT *rc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SafeArrayToRectNativeArray( 
            /* [in] */ __RPC__in SAFEARRAY * rects,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*rectArrayCount) RECT **rectArray,
            /* [retval][out] */ __RPC__out int *rectArrayCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateProxyFactoryEntry( 
            /* [in] */ __RPC__in_opt IUIAutomationProxyFactory *factory,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationProxyFactoryEntry **factoryEntry) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProxyFactoryMapping( 
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationProxyFactoryMapping **factoryMapping) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyProgrammaticName( 
            /* [in] */ PROPERTYID property,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPatternProgrammaticName( 
            /* [in] */ PATTERNID pattern,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PollForPotentialSupportedPatterns( 
            /* [in] */ __RPC__in_opt IUIAutomationElement *pElement,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *patternIds,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *patternNames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PollForPotentialSupportedProperties( 
            /* [in] */ __RPC__in_opt IUIAutomationElement *pElement,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *propertyIds,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *propertyNames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CheckNotSupported( 
            /* [in] */ VARIANT value,
            /* [retval][out] */ __RPC__out BOOL *isNotSupported) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ReservedNotSupportedValue( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **notSupportedValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ReservedMixedAttributeValue( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **mixedAttributeValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ElementFromIAccessible( 
            /* [in] */ __RPC__in_opt IAccessible *accessible,
            /* [in] */ int childId,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **element) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ElementFromIAccessibleBuildCache( 
            /* [in] */ __RPC__in_opt IAccessible *accessible,
            /* [in] */ int childId,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **element) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomation * This);
        
        HRESULT ( STDMETHODCALLTYPE *CompareElements )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ __RPC__in_opt IUIAutomationElement *el1,
            /* [in] */ __RPC__in_opt IUIAutomationElement *el2,
            /* [retval][out] */ __RPC__out BOOL *areSame);
        
        HRESULT ( STDMETHODCALLTYPE *CompareRuntimeIds )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ __RPC__in SAFEARRAY * runtimeId1,
            /* [in] */ __RPC__in SAFEARRAY * runtimeId2,
            /* [retval][out] */ __RPC__out BOOL *areSame);
        
        HRESULT ( STDMETHODCALLTYPE *GetRootElement )( 
            __RPC__in IUIAutomation * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **root);
        
        HRESULT ( STDMETHODCALLTYPE *ElementFromHandle )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ __RPC__in UIA_HWND hwnd,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **element);
        
        HRESULT ( STDMETHODCALLTYPE *ElementFromPoint )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ POINT pt,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **element);
        
        HRESULT ( STDMETHODCALLTYPE *GetFocusedElement )( 
            __RPC__in IUIAutomation * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **element);
        
        HRESULT ( STDMETHODCALLTYPE *GetRootElementBuildCache )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **root);
        
        HRESULT ( STDMETHODCALLTYPE *ElementFromHandleBuildCache )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ __RPC__in UIA_HWND hwnd,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **element);
        
        HRESULT ( STDMETHODCALLTYPE *ElementFromPointBuildCache )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ POINT pt,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **element);
        
        HRESULT ( STDMETHODCALLTYPE *GetFocusedElementBuildCache )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **element);
        
        HRESULT ( STDMETHODCALLTYPE *CreateTreeWalker )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ __RPC__in_opt IUIAutomationCondition *pCondition,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationTreeWalker **walker);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ControlViewWalker )( 
            __RPC__in IUIAutomation * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationTreeWalker **walker);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContentViewWalker )( 
            __RPC__in IUIAutomation * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationTreeWalker **walker);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawViewWalker )( 
            __RPC__in IUIAutomation * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationTreeWalker **walker);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RawViewCondition )( 
            __RPC__in IUIAutomation * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **condition);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ControlViewCondition )( 
            __RPC__in IUIAutomation * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **condition);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContentViewCondition )( 
            __RPC__in IUIAutomation * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **condition);
        
        HRESULT ( STDMETHODCALLTYPE *CreateCacheRequest )( 
            __RPC__in IUIAutomation * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCacheRequest **cacheRequest);
        
        HRESULT ( STDMETHODCALLTYPE *CreateTrueCondition )( 
            __RPC__in IUIAutomation * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **newCondition);
        
        HRESULT ( STDMETHODCALLTYPE *CreateFalseCondition )( 
            __RPC__in IUIAutomation * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **newCondition);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePropertyCondition )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ PROPERTYID propertyId,
            /* [in] */ VARIANT value,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **newCondition);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePropertyConditionEx )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ PROPERTYID propertyId,
            /* [in] */ VARIANT value,
            /* [in] */ enum PropertyConditionFlags flags,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **newCondition);
        
        HRESULT ( STDMETHODCALLTYPE *CreateAndCondition )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ __RPC__in_opt IUIAutomationCondition *condition1,
            /* [in] */ __RPC__in_opt IUIAutomationCondition *condition2,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **newCondition);
        
        HRESULT ( STDMETHODCALLTYPE *CreateAndConditionFromArray )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ __RPC__in_opt SAFEARRAY * conditions,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **newCondition);
        
        HRESULT ( STDMETHODCALLTYPE *CreateAndConditionFromNativeArray )( 
            __RPC__in IUIAutomation * This,
            /* [size_is][in] */ __RPC__in_ecount_full(conditionCount) IUIAutomationCondition **conditions,
            /* [in] */ int conditionCount,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **newCondition);
        
        HRESULT ( STDMETHODCALLTYPE *CreateOrCondition )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ __RPC__in_opt IUIAutomationCondition *condition1,
            /* [in] */ __RPC__in_opt IUIAutomationCondition *condition2,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **newCondition);
        
        HRESULT ( STDMETHODCALLTYPE *CreateOrConditionFromArray )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ __RPC__in_opt SAFEARRAY * conditions,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **newCondition);
        
        HRESULT ( STDMETHODCALLTYPE *CreateOrConditionFromNativeArray )( 
            __RPC__in IUIAutomation * This,
            /* [size_is][in] */ __RPC__in_ecount_full(conditionCount) IUIAutomationCondition **conditions,
            /* [in] */ int conditionCount,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **newCondition);
        
        HRESULT ( STDMETHODCALLTYPE *CreateNotCondition )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ __RPC__in_opt IUIAutomationCondition *condition,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationCondition **newCondition);
        
        HRESULT ( STDMETHODCALLTYPE *AddAutomationEventHandler )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ EVENTID eventId,
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [in] */ enum TreeScope scope,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [in] */ __RPC__in_opt IUIAutomationEventHandler *handler);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAutomationEventHandler )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ EVENTID eventId,
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [in] */ __RPC__in_opt IUIAutomationEventHandler *handler);
        
        HRESULT ( STDMETHODCALLTYPE *AddPropertyChangedEventHandlerNativeArray )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [in] */ enum TreeScope scope,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [in] */ __RPC__in_opt IUIAutomationPropertyChangedEventHandler *handler,
            /* [size_is][in] */ __RPC__in_ecount_full(propertyCount) PROPERTYID *propertyArray,
            /* [in] */ int propertyCount);
        
        HRESULT ( STDMETHODCALLTYPE *AddPropertyChangedEventHandler )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [in] */ enum TreeScope scope,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [in] */ __RPC__in_opt IUIAutomationPropertyChangedEventHandler *handler,
            /* [in] */ __RPC__in SAFEARRAY * propertyArray);
        
        HRESULT ( STDMETHODCALLTYPE *RemovePropertyChangedEventHandler )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [in] */ __RPC__in_opt IUIAutomationPropertyChangedEventHandler *handler);
        
        HRESULT ( STDMETHODCALLTYPE *AddStructureChangedEventHandler )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [in] */ enum TreeScope scope,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [in] */ __RPC__in_opt IUIAutomationStructureChangedEventHandler *handler);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStructureChangedEventHandler )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ __RPC__in_opt IUIAutomationElement *element,
            /* [in] */ __RPC__in_opt IUIAutomationStructureChangedEventHandler *handler);
        
        HRESULT ( STDMETHODCALLTYPE *AddFocusChangedEventHandler )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [in] */ __RPC__in_opt IUIAutomationFocusChangedEventHandler *handler);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFocusChangedEventHandler )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ __RPC__in_opt IUIAutomationFocusChangedEventHandler *handler);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAllEventHandlers )( 
            __RPC__in IUIAutomation * This);
        
        HRESULT ( STDMETHODCALLTYPE *IntNativeArrayToSafeArray )( 
            __RPC__in IUIAutomation * This,
            /* [size_is][in] */ __RPC__in_ecount_full(arrayCount) int *array,
            /* [in] */ int arrayCount,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *safeArray);
        
        HRESULT ( STDMETHODCALLTYPE *IntSafeArrayToNativeArray )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ __RPC__in SAFEARRAY * intArray,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*arrayCount) int **array,
            /* [retval][out] */ __RPC__out int *arrayCount);
        
        HRESULT ( STDMETHODCALLTYPE *RectToVariant )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ RECT rc,
            /* [retval][out] */ __RPC__out VARIANT *var);
        
        HRESULT ( STDMETHODCALLTYPE *VariantToRect )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ VARIANT var,
            /* [retval][out] */ __RPC__out RECT *rc);
        
        HRESULT ( STDMETHODCALLTYPE *SafeArrayToRectNativeArray )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ __RPC__in SAFEARRAY * rects,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*rectArrayCount) RECT **rectArray,
            /* [retval][out] */ __RPC__out int *rectArrayCount);
        
        HRESULT ( STDMETHODCALLTYPE *CreateProxyFactoryEntry )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ __RPC__in_opt IUIAutomationProxyFactory *factory,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationProxyFactoryEntry **factoryEntry);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProxyFactoryMapping )( 
            __RPC__in IUIAutomation * This,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationProxyFactoryMapping **factoryMapping);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyProgrammaticName )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ PROPERTYID property,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        HRESULT ( STDMETHODCALLTYPE *GetPatternProgrammaticName )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ PATTERNID pattern,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        HRESULT ( STDMETHODCALLTYPE *PollForPotentialSupportedPatterns )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ __RPC__in_opt IUIAutomationElement *pElement,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *patternIds,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *patternNames);
        
        HRESULT ( STDMETHODCALLTYPE *PollForPotentialSupportedProperties )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ __RPC__in_opt IUIAutomationElement *pElement,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *propertyIds,
            /* [out] */ __RPC__deref_out_opt SAFEARRAY * *propertyNames);
        
        HRESULT ( STDMETHODCALLTYPE *CheckNotSupported )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ VARIANT value,
            /* [retval][out] */ __RPC__out BOOL *isNotSupported);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReservedNotSupportedValue )( 
            __RPC__in IUIAutomation * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **notSupportedValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReservedMixedAttributeValue )( 
            __RPC__in IUIAutomation * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **mixedAttributeValue);
        
        HRESULT ( STDMETHODCALLTYPE *ElementFromIAccessible )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ __RPC__in_opt IAccessible *accessible,
            /* [in] */ int childId,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **element);
        
        HRESULT ( STDMETHODCALLTYPE *ElementFromIAccessibleBuildCache )( 
            __RPC__in IUIAutomation * This,
            /* [in] */ __RPC__in_opt IAccessible *accessible,
            /* [in] */ int childId,
            /* [in] */ __RPC__in_opt IUIAutomationCacheRequest *cacheRequest,
            /* [retval][out] */ __RPC__deref_out_opt IUIAutomationElement **element);
        
        END_INTERFACE
    } IUIAutomationVtbl;

    interface IUIAutomation
    {
        CONST_VTBL struct IUIAutomationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomation_CompareElements(This,el1,el2,areSame)	\
    ( (This)->lpVtbl -> CompareElements(This,el1,el2,areSame) ) 

#define IUIAutomation_CompareRuntimeIds(This,runtimeId1,runtimeId2,areSame)	\
    ( (This)->lpVtbl -> CompareRuntimeIds(This,runtimeId1,runtimeId2,areSame) ) 

#define IUIAutomation_GetRootElement(This,root)	\
    ( (This)->lpVtbl -> GetRootElement(This,root) ) 

#define IUIAutomation_ElementFromHandle(This,hwnd,element)	\
    ( (This)->lpVtbl -> ElementFromHandle(This,hwnd,element) ) 

#define IUIAutomation_ElementFromPoint(This,pt,element)	\
    ( (This)->lpVtbl -> ElementFromPoint(This,pt,element) ) 

#define IUIAutomation_GetFocusedElement(This,element)	\
    ( (This)->lpVtbl -> GetFocusedElement(This,element) ) 

#define IUIAutomation_GetRootElementBuildCache(This,cacheRequest,root)	\
    ( (This)->lpVtbl -> GetRootElementBuildCache(This,cacheRequest,root) ) 

#define IUIAutomation_ElementFromHandleBuildCache(This,hwnd,cacheRequest,element)	\
    ( (This)->lpVtbl -> ElementFromHandleBuildCache(This,hwnd,cacheRequest,element) ) 

#define IUIAutomation_ElementFromPointBuildCache(This,pt,cacheRequest,element)	\
    ( (This)->lpVtbl -> ElementFromPointBuildCache(This,pt,cacheRequest,element) ) 

#define IUIAutomation_GetFocusedElementBuildCache(This,cacheRequest,element)	\
    ( (This)->lpVtbl -> GetFocusedElementBuildCache(This,cacheRequest,element) ) 

#define IUIAutomation_CreateTreeWalker(This,pCondition,walker)	\
    ( (This)->lpVtbl -> CreateTreeWalker(This,pCondition,walker) ) 

#define IUIAutomation_get_ControlViewWalker(This,walker)	\
    ( (This)->lpVtbl -> get_ControlViewWalker(This,walker) ) 

#define IUIAutomation_get_ContentViewWalker(This,walker)	\
    ( (This)->lpVtbl -> get_ContentViewWalker(This,walker) ) 

#define IUIAutomation_get_RawViewWalker(This,walker)	\
    ( (This)->lpVtbl -> get_RawViewWalker(This,walker) ) 

#define IUIAutomation_get_RawViewCondition(This,condition)	\
    ( (This)->lpVtbl -> get_RawViewCondition(This,condition) ) 

#define IUIAutomation_get_ControlViewCondition(This,condition)	\
    ( (This)->lpVtbl -> get_ControlViewCondition(This,condition) ) 

#define IUIAutomation_get_ContentViewCondition(This,condition)	\
    ( (This)->lpVtbl -> get_ContentViewCondition(This,condition) ) 

#define IUIAutomation_CreateCacheRequest(This,cacheRequest)	\
    ( (This)->lpVtbl -> CreateCacheRequest(This,cacheRequest) ) 

#define IUIAutomation_CreateTrueCondition(This,newCondition)	\
    ( (This)->lpVtbl -> CreateTrueCondition(This,newCondition) ) 

#define IUIAutomation_CreateFalseCondition(This,newCondition)	\
    ( (This)->lpVtbl -> CreateFalseCondition(This,newCondition) ) 

#define IUIAutomation_CreatePropertyCondition(This,propertyId,value,newCondition)	\
    ( (This)->lpVtbl -> CreatePropertyCondition(This,propertyId,value,newCondition) ) 

#define IUIAutomation_CreatePropertyConditionEx(This,propertyId,value,flags,newCondition)	\
    ( (This)->lpVtbl -> CreatePropertyConditionEx(This,propertyId,value,flags,newCondition) ) 

#define IUIAutomation_CreateAndCondition(This,condition1,condition2,newCondition)	\
    ( (This)->lpVtbl -> CreateAndCondition(This,condition1,condition2,newCondition) ) 

#define IUIAutomation_CreateAndConditionFromArray(This,conditions,newCondition)	\
    ( (This)->lpVtbl -> CreateAndConditionFromArray(This,conditions,newCondition) ) 

#define IUIAutomation_CreateAndConditionFromNativeArray(This,conditions,conditionCount,newCondition)	\
    ( (This)->lpVtbl -> CreateAndConditionFromNativeArray(This,conditions,conditionCount,newCondition) ) 

#define IUIAutomation_CreateOrCondition(This,condition1,condition2,newCondition)	\
    ( (This)->lpVtbl -> CreateOrCondition(This,condition1,condition2,newCondition) ) 

#define IUIAutomation_CreateOrConditionFromArray(This,conditions,newCondition)	\
    ( (This)->lpVtbl -> CreateOrConditionFromArray(This,conditions,newCondition) ) 

#define IUIAutomation_CreateOrConditionFromNativeArray(This,conditions,conditionCount,newCondition)	\
    ( (This)->lpVtbl -> CreateOrConditionFromNativeArray(This,conditions,conditionCount,newCondition) ) 

#define IUIAutomation_CreateNotCondition(This,condition,newCondition)	\
    ( (This)->lpVtbl -> CreateNotCondition(This,condition,newCondition) ) 

#define IUIAutomation_AddAutomationEventHandler(This,eventId,element,scope,cacheRequest,handler)	\
    ( (This)->lpVtbl -> AddAutomationEventHandler(This,eventId,element,scope,cacheRequest,handler) ) 

#define IUIAutomation_RemoveAutomationEventHandler(This,eventId,element,handler)	\
    ( (This)->lpVtbl -> RemoveAutomationEventHandler(This,eventId,element,handler) ) 

#define IUIAutomation_AddPropertyChangedEventHandlerNativeArray(This,element,scope,cacheRequest,handler,propertyArray,propertyCount)	\
    ( (This)->lpVtbl -> AddPropertyChangedEventHandlerNativeArray(This,element,scope,cacheRequest,handler,propertyArray,propertyCount) ) 

#define IUIAutomation_AddPropertyChangedEventHandler(This,element,scope,cacheRequest,handler,propertyArray)	\
    ( (This)->lpVtbl -> AddPropertyChangedEventHandler(This,element,scope,cacheRequest,handler,propertyArray) ) 

#define IUIAutomation_RemovePropertyChangedEventHandler(This,element,handler)	\
    ( (This)->lpVtbl -> RemovePropertyChangedEventHandler(This,element,handler) ) 

#define IUIAutomation_AddStructureChangedEventHandler(This,element,scope,cacheRequest,handler)	\
    ( (This)->lpVtbl -> AddStructureChangedEventHandler(This,element,scope,cacheRequest,handler) ) 

#define IUIAutomation_RemoveStructureChangedEventHandler(This,element,handler)	\
    ( (This)->lpVtbl -> RemoveStructureChangedEventHandler(This,element,handler) ) 

#define IUIAutomation_AddFocusChangedEventHandler(This,cacheRequest,handler)	\
    ( (This)->lpVtbl -> AddFocusChangedEventHandler(This,cacheRequest,handler) ) 

#define IUIAutomation_RemoveFocusChangedEventHandler(This,handler)	\
    ( (This)->lpVtbl -> RemoveFocusChangedEventHandler(This,handler) ) 

#define IUIAutomation_RemoveAllEventHandlers(This)	\
    ( (This)->lpVtbl -> RemoveAllEventHandlers(This) ) 

#define IUIAutomation_IntNativeArrayToSafeArray(This,array,arrayCount,safeArray)	\
    ( (This)->lpVtbl -> IntNativeArrayToSafeArray(This,array,arrayCount,safeArray) ) 

#define IUIAutomation_IntSafeArrayToNativeArray(This,intArray,array,arrayCount)	\
    ( (This)->lpVtbl -> IntSafeArrayToNativeArray(This,intArray,array,arrayCount) ) 

#define IUIAutomation_RectToVariant(This,rc,var)	\
    ( (This)->lpVtbl -> RectToVariant(This,rc,var) ) 

#define IUIAutomation_VariantToRect(This,var,rc)	\
    ( (This)->lpVtbl -> VariantToRect(This,var,rc) ) 

#define IUIAutomation_SafeArrayToRectNativeArray(This,rects,rectArray,rectArrayCount)	\
    ( (This)->lpVtbl -> SafeArrayToRectNativeArray(This,rects,rectArray,rectArrayCount) ) 

#define IUIAutomation_CreateProxyFactoryEntry(This,factory,factoryEntry)	\
    ( (This)->lpVtbl -> CreateProxyFactoryEntry(This,factory,factoryEntry) ) 

#define IUIAutomation_get_ProxyFactoryMapping(This,factoryMapping)	\
    ( (This)->lpVtbl -> get_ProxyFactoryMapping(This,factoryMapping) ) 

#define IUIAutomation_GetPropertyProgrammaticName(This,property,name)	\
    ( (This)->lpVtbl -> GetPropertyProgrammaticName(This,property,name) ) 

#define IUIAutomation_GetPatternProgrammaticName(This,pattern,name)	\
    ( (This)->lpVtbl -> GetPatternProgrammaticName(This,pattern,name) ) 

#define IUIAutomation_PollForPotentialSupportedPatterns(This,pElement,patternIds,patternNames)	\
    ( (This)->lpVtbl -> PollForPotentialSupportedPatterns(This,pElement,patternIds,patternNames) ) 

#define IUIAutomation_PollForPotentialSupportedProperties(This,pElement,propertyIds,propertyNames)	\
    ( (This)->lpVtbl -> PollForPotentialSupportedProperties(This,pElement,propertyIds,propertyNames) ) 

#define IUIAutomation_CheckNotSupported(This,value,isNotSupported)	\
    ( (This)->lpVtbl -> CheckNotSupported(This,value,isNotSupported) ) 

#define IUIAutomation_get_ReservedNotSupportedValue(This,notSupportedValue)	\
    ( (This)->lpVtbl -> get_ReservedNotSupportedValue(This,notSupportedValue) ) 

#define IUIAutomation_get_ReservedMixedAttributeValue(This,mixedAttributeValue)	\
    ( (This)->lpVtbl -> get_ReservedMixedAttributeValue(This,mixedAttributeValue) ) 

#define IUIAutomation_ElementFromIAccessible(This,accessible,childId,element)	\
    ( (This)->lpVtbl -> ElementFromIAccessible(This,accessible,childId,element) ) 

#define IUIAutomation_ElementFromIAccessibleBuildCache(This,accessible,childId,cacheRequest,element)	\
    ( (This)->lpVtbl -> ElementFromIAccessibleBuildCache(This,accessible,childId,cacheRequest,element) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomation_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_CUIAutomation;

#ifdef __cplusplus

class DECLSPEC_UUID("ff48dba4-60ef-4201-aa87-54103eef594e")
CUIAutomation;
#endif
#endif /* __UIAutomationClient_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\UIAutomationCoreApi.h ===
// -------------------------------------------------------------
// UIAutomationCoreAPI.h
//
// UIAutomation core APIs, types and enums
//
// Copyright (c) Microsoft Corporation. All rights reserved.
// -------------------------------------------------------------


#ifndef _INC_UIAUTOMATIONCOREAPI
#define _INC_UIAUTOMATIONCOREAPI
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

// --------------------------------------------------------------------------
//
// General constants and types
//
// --------------------------------------------------------------------------

// These are all in FACILITY_ITF
#define UIA_E_ELEMENTNOTENABLED      0x80040200
#define UIA_E_ELEMENTNOTAVAILABLE    0x80040201
#define UIA_E_NOCLICKABLEPOINT       0x80040202
#define UIA_E_PROXYASSEMBLYNOTLOADED 0x80040203

// Can be thrown by providers to indicate they
// explicitly don't support a pattern or property
#define UIA_E_NOTSUPPORTED           0x80040204

// The following are COR error codes, included here as a convenience
// (equivalent codes are in <corerror.h>)
#define UIA_E_INVALIDOPERATION       0x80131509 // COR_E_INVALIDOPERATION
#define UIA_E_TIMEOUT                0x80131505 // COR_E_TIMEOUT

// The following common managed exceptions are not represented here
// since they already have standard COM  error codes assigned to them
// by COM Interop:
//   ArgumentException          E_INVALIDARG
//   ArgumentNullException      - maps to ArgumentException

// Other constants
#define UiaAppendRuntimeId     3
#define UiaRootObjectId        -25

DECLARE_HANDLE(HUIANODE);
DECLARE_HANDLE(HUIAPATTERNOBJECT);
DECLARE_HANDLE(HUIATEXTRANGE);
DECLARE_HANDLE(HUIAEVENT);

#ifndef __uiautomationclient_h__
enum TreeScope
{
    TreeScope_Element =       0x1,
    TreeScope_Children =      0x2,
    TreeScope_Descendants =   0x4,
    TreeScope_Parent =        0x8,
    TreeScope_Ancestors =     0x10,
    TreeScope_Subtree = TreeScope_Element | TreeScope_Children | TreeScope_Descendants
};
#endif

// --------------------------------------------------------------------------
//
// Automation Identifier GUIDs
//
// --------------------------------------------------------------------------

DEFINE_GUID(RuntimeId_Property_GUID,                                    0xa39eebfa, 0x7fba, 0x4c89, 0xb4, 0xd4, 0xb9, 0x9e, 0x2d, 0xe7, 0xd1, 0x60);
DEFINE_GUID(BoundingRectangle_Property_GUID,                            0x7bbfe8b2, 0x3bfc, 0x48dd, 0xb7, 0x29, 0xc7, 0x94, 0xb8, 0x46, 0xe9, 0xa1);
DEFINE_GUID(ProcessId_Property_GUID,                                    0x40499998, 0x9c31, 0x4245, 0xa4, 0x03, 0x87, 0x32, 0x0e, 0x59, 0xea, 0xf6);
DEFINE_GUID(ControlType_Property_GUID,                                  0xca774fea, 0x28ac, 0x4bc2, 0x94, 0xca, 0xac, 0xec, 0x6d, 0x6c, 0x10, 0xa3);
DEFINE_GUID(LocalizedControlType_Property_GUID,                         0x8763404f, 0xa1bd, 0x452a, 0x89, 0xc4, 0x3f, 0x01, 0xd3, 0x83, 0x38, 0x06);
DEFINE_GUID(Name_Property_GUID,                                         0xc3a6921b, 0x4a99, 0x44f1, 0xbc, 0xa6, 0x61, 0x18, 0x70, 0x52, 0xc4, 0x31);
DEFINE_GUID(AcceleratorKey_Property_GUID,                               0x514865df, 0x2557, 0x4cb9, 0xae, 0xed, 0x6c, 0xed, 0x08, 0x4c, 0xe5, 0x2c);
DEFINE_GUID(AccessKey_Property_GUID,                                    0x06827b12, 0xa7f9, 0x4a15, 0x91, 0x7c, 0xff, 0xa5, 0xad, 0x3e, 0xb0, 0xa7);
DEFINE_GUID(HasKeyboardFocus_Property_GUID,                             0xcf8afd39, 0x3f46, 0x4800, 0x96, 0x56, 0xb2, 0xbf, 0x12, 0x52, 0x99, 0x05);
DEFINE_GUID(IsKeyboardFocusable_Property_GUID,                          0xf7b8552a, 0x0859, 0x4b37, 0xb9, 0xcb, 0x51, 0xe7, 0x20, 0x92, 0xf2, 0x9f);
DEFINE_GUID(IsEnabled_Property_GUID,                                    0x2109427f, 0xda60, 0x4fed, 0xbf, 0x1b, 0x26, 0x4b, 0xdc, 0xe6, 0xeb, 0x3a);
DEFINE_GUID(AutomationId_Property_GUID,                                 0xc82c0500, 0xb60e, 0x4310, 0xa2, 0x67, 0x30, 0x3c, 0x53, 0x1f, 0x8e, 0xe5);
DEFINE_GUID(ClassName_Property_GUID,                                    0x157b7215, 0x894f, 0x4b65, 0x84, 0xe2, 0xaa, 0xc0, 0xda, 0x08, 0xb1, 0x6b);
DEFINE_GUID(HelpText_Property_GUID,                                     0x08555685, 0x0977, 0x45c7, 0xa7, 0xa6, 0xab, 0xaf, 0x56, 0x84, 0x12, 0x1a);
DEFINE_GUID(ClickablePoint_Property_GUID,                               0x0196903b, 0xb203, 0x4818, 0xa9, 0xf3, 0xf0, 0x8e, 0x67, 0x5f, 0x23, 0x41);
DEFINE_GUID(Culture_Property_GUID,                                      0xe2d74f27, 0x3d79, 0x4dc2, 0xb8, 0x8b, 0x30, 0x44, 0x96, 0x3a, 0x8a, 0xfb);
DEFINE_GUID(IsControlElement_Property_GUID,                             0x95f35085, 0xabcc, 0x4afd, 0xa5, 0xf4, 0xdb, 0xb4, 0x6c, 0x23, 0x0f, 0xdb);
DEFINE_GUID(IsContentElement_Property_GUID,                             0x4bda64a8, 0xf5d8, 0x480b, 0x81, 0x55, 0xef, 0x2e, 0x89, 0xad, 0xb6, 0x72);
DEFINE_GUID(LabeledBy_Property_GUID,                                    0xe5b8924b, 0xfc8a, 0x4a35, 0x80, 0x31, 0xcf, 0x78, 0xac, 0x43, 0xe5, 0x5e);
DEFINE_GUID(IsPassword_Property_GUID,                                   0xe8482eb1, 0x687c, 0x497b, 0xbe, 0xbc, 0x03, 0xbe, 0x53, 0xec, 0x14, 0x54);
DEFINE_GUID(NewNativeWindowHandle_Property_GUID,                        0x5196b33b, 0x380a, 0x4982, 0x95, 0xe1, 0x91, 0xf3, 0xef, 0x60, 0xe0, 0x24);
DEFINE_GUID(ItemType_Property_GUID,                                     0xcdda434d, 0x6222, 0x413b, 0xa6, 0x8a, 0x32, 0x5d, 0xd1, 0xd4, 0x0f, 0x39);
DEFINE_GUID(IsOffscreen_Property_GUID,                                  0x03c3d160, 0xdb79, 0x42db, 0xa2, 0xef, 0x1c, 0x23, 0x1e, 0xed, 0xe5, 0x07);
DEFINE_GUID(Orientation_Property_GUID,                                  0xa01eee62, 0x3884, 0x4415, 0x88, 0x7e, 0x67, 0x8e, 0xc2, 0x1e, 0x39, 0xba);
DEFINE_GUID(FrameworkId_Property_GUID,                                  0xdbfd9900, 0x7e1a, 0x4f58, 0xb6, 0x1b, 0x70, 0x63, 0x12, 0x0f, 0x77, 0x3b);
DEFINE_GUID(IsRequiredForForm_Property_GUID,                            0x4f5f43cf, 0x59fb, 0x4bde, 0xa2, 0x70, 0x60, 0x2e, 0x5e, 0x11, 0x41, 0xe9);
DEFINE_GUID(ItemStatus_Property_GUID,                                   0x51de0321, 0x3973, 0x43e7, 0x89, 0x13, 0x0b, 0x08, 0xe8, 0x13, 0xc3, 0x7f);
DEFINE_GUID(IsDockPatternAvailable_Property_GUID,                       0x2600a4c4, 0x2ff8, 0x4c96, 0xae, 0x31, 0x8f, 0xe6, 0x19, 0xa1, 0x3c, 0x6c);
DEFINE_GUID(IsExpandCollapsePatternAvailable_Property_GUID,             0x929d3806, 0x5287, 0x4725, 0xaa, 0x16, 0x22, 0x2a, 0xfc, 0x63, 0xd5, 0x95);
DEFINE_GUID(IsGridItemPatternAvailable_Property_GUID,                   0x5a43e524, 0xf9a2, 0x4b12, 0x84, 0xc8, 0xb4, 0x8a, 0x3e, 0xfe, 0xdd, 0x34);
DEFINE_GUID(IsGridPatternAvailable_Property_GUID,                       0x5622c26c, 0xf0ef, 0x4f3b, 0x97, 0xcb, 0x71, 0x4c, 0x08, 0x68, 0x58, 0x8b);
DEFINE_GUID(IsInvokePatternAvailable_Property_GUID,                     0x4e725738, 0x8364, 0x4679, 0xaa, 0x6c, 0xf3, 0xf4, 0x19, 0x31, 0xf7, 0x50);
DEFINE_GUID(IsMultipleViewPatternAvailable_Property_GUID,               0xff0a31eb, 0x8e25, 0x469d, 0x8d, 0x6e, 0xe7, 0x71, 0xa2, 0x7c, 0x1b, 0x90);
DEFINE_GUID(IsRangeValuePatternAvailable_Property_GUID,                 0xfda4244a, 0xeb4d, 0x43ff, 0xb5, 0xad, 0xed, 0x36, 0xd3, 0x73, 0xec, 0x4c);
DEFINE_GUID(IsScrollPatternAvailable_Property_GUID,                     0x3ebb7b4a, 0x828a, 0x4b57, 0x9d, 0x22, 0x2f, 0xea, 0x16, 0x32, 0xed, 0x0d);
DEFINE_GUID(IsScrollItemPatternAvailable_Property_GUID,                 0x1cad1a05, 0x0927, 0x4b76, 0x97, 0xe1, 0x0f, 0xcd, 0xb2, 0x09, 0xb9, 0x8a);
DEFINE_GUID(IsSelectionItemPatternAvailable_Property_GUID,              0x8becd62d, 0x0bc3, 0x4109, 0xbe, 0xe2, 0x8e, 0x67, 0x15, 0x29, 0x0e, 0x68);
DEFINE_GUID(IsSelectionPatternAvailable_Property_GUID,                  0xf588acbe, 0xc769, 0x4838, 0x9a, 0x60, 0x26, 0x86, 0xdc, 0x11, 0x88, 0xc4);
DEFINE_GUID(IsTablePatternAvailable_Property_GUID,                      0xcb83575f, 0x45c2, 0x4048, 0x9c, 0x76, 0x15, 0x97, 0x15, 0xa1, 0x39, 0xdf);
DEFINE_GUID(IsTableItemPatternAvailable_Property_GUID,                  0xeb36b40d, 0x8ea4, 0x489b, 0xa0, 0x13, 0xe6, 0x0d, 0x59, 0x51, 0xfe, 0x34);
DEFINE_GUID(IsTextPatternAvailable_Property_GUID,                       0xfbe2d69d, 0xaff6, 0x4a45, 0x82, 0xe2, 0xfc, 0x92, 0xa8, 0x2f, 0x59, 0x17);
DEFINE_GUID(IsTogglePatternAvailable_Property_GUID,                     0x78686d53, 0xfcd0, 0x4b83, 0x9b, 0x78, 0x58, 0x32, 0xce, 0x63, 0xbb, 0x5b);
DEFINE_GUID(IsTransformPatternAvailable_Property_GUID,                  0xa7f78804, 0xd68b, 0x4077, 0xa5, 0xc6, 0x7a, 0x5e, 0xa1, 0xac, 0x31, 0xc5);
DEFINE_GUID(IsValuePatternAvailable_Property_GUID,                      0x0b5020a7, 0x2119, 0x473b, 0xbe, 0x37, 0x5c, 0xeb, 0x98, 0xbb, 0xfb, 0x22);
DEFINE_GUID(IsWindowPatternAvailable_Property_GUID,                     0xe7a57bb1, 0x5888, 0x4155, 0x98, 0xdc, 0xb4, 0x22, 0xfd, 0x57, 0xf2, 0xbc);
DEFINE_GUID(IsLegacyIAccessiblePatternAvailable_Property_GUID,          0xd8ebd0c7, 0x929a, 0x4ee7, 0x8d, 0x3a, 0xd3, 0xd9, 0x44, 0x13, 0x02, 0x7b);
DEFINE_GUID(IsItemContainerPatternAvailable_Property_GUID,              0x624b5ca7, 0xfe40, 0x4957, 0xa0, 0x19, 0x20, 0xc4, 0xcf, 0x11, 0x92, 0x0f);
DEFINE_GUID(IsVirtualizedItemPatternAvailable_Property_GUID,            0x302cb151, 0x2ac8, 0x45d6, 0x97, 0x7b, 0xd2, 0xb3, 0xa5, 0xa5, 0x3f, 0x20);
DEFINE_GUID(IsSynchronizedInputPatternAvailable_Property_GUID,          0x75d69cc5, 0xd2bf, 0x4943, 0x87, 0x6e, 0xb4, 0x5b, 0x62, 0xa6, 0xcc, 0x66);
DEFINE_GUID(Value_Value_Property_GUID,                                  0xe95f5e64, 0x269f, 0x4a85, 0xba, 0x99, 0x40, 0x92, 0xc3, 0xea, 0x29, 0x86);
DEFINE_GUID(Value_IsReadOnly_Property_GUID,                             0xeb090f30, 0xe24c, 0x4799, 0xa7, 0x05, 0x0d, 0x24, 0x7b, 0xc0, 0x37, 0xf8);
DEFINE_GUID(RangeValue_Value_Property_GUID,                             0x131f5d98, 0xc50c, 0x489d, 0xab, 0xe5, 0xae, 0x22, 0x08, 0x98, 0xc5, 0xf7);
DEFINE_GUID(RangeValue_IsReadOnly_Property_GUID,                        0x25fa1055, 0xdebf, 0x4373, 0xa7, 0x9e, 0x1f, 0x1a, 0x19, 0x08, 0xd3, 0xc4);
DEFINE_GUID(RangeValue_Minimum_Property_GUID,                           0x78cbd3b2, 0x684d, 0x4860, 0xaf, 0x93, 0xd1, 0xf9, 0x5c, 0xb0, 0x22, 0xfd);
DEFINE_GUID(RangeValue_Maximum_Property_GUID,                           0x19319914, 0xf979, 0x4b35, 0xa1, 0xa6, 0xd3, 0x7e, 0x05, 0x43, 0x34, 0x73);
DEFINE_GUID(RangeValue_LargeChange_Property_GUID,                       0xa1f96325, 0x3a3d, 0x4b44, 0x8e, 0x1f, 0x4a, 0x46, 0xd9, 0x84, 0x40, 0x19);
DEFINE_GUID(RangeValue_SmallChange_Property_GUID,                       0x81c2c457, 0x3941, 0x4107, 0x99, 0x75, 0x13, 0x97, 0x60, 0xf7, 0xc0, 0x72);
DEFINE_GUID(Scroll_HorizontalScrollPercent_Property_GUID,               0xc7c13c0e, 0xeb21, 0x47ff, 0xac, 0xc4, 0xb5, 0xa3, 0x35, 0x0f, 0x51, 0x91);
DEFINE_GUID(Scroll_HorizontalViewSize_Property_GUID,                    0x70c2e5d4, 0xfcb0, 0x4713, 0xa9, 0xaa, 0xaf, 0x92, 0xff, 0x79, 0xe4, 0xcd);
DEFINE_GUID(Scroll_VerticalScrollPercent_Property_GUID,                 0x6c8d7099, 0xb2a8, 0x4948, 0xbf, 0xf7, 0x3c, 0xf9, 0x05, 0x8b, 0xfe, 0xfb);
DEFINE_GUID(Scroll_VerticalViewSize_Property_GUID,                      0xde6a2e22, 0xd8c7, 0x40c5, 0x83, 0xba, 0xe5, 0xf6, 0x81, 0xd5, 0x31, 0x08);
DEFINE_GUID(Scroll_HorizontallyScrollable_Property_GUID,                0x8b925147, 0x28cd, 0x49ae, 0xbd, 0x63, 0xf4, 0x41, 0x18, 0xd2, 0xe7, 0x19);
DEFINE_GUID(Scroll_VerticallyScrollable_Property_GUID,                  0x89164798, 0x0068, 0x4315, 0xb8, 0x9a, 0x1e, 0x7c, 0xfb, 0xbc, 0x3d, 0xfc);
DEFINE_GUID(Selection_Selection_Property_GUID,                          0xaa6dc2a2, 0x0e2b, 0x4d38, 0x96, 0xd5, 0x34, 0xe4, 0x70, 0xb8, 0x18, 0x53);
DEFINE_GUID(Selection_CanSelectMultiple_Property_GUID,                  0x49d73da5, 0xc883, 0x4500, 0x88, 0x3d, 0x8f, 0xcf, 0x8d, 0xaf, 0x6c, 0xbe);
DEFINE_GUID(Selection_IsSelectionRequired_Property_GUID,                0xb1ae4422, 0x63fe, 0x44e7, 0xa5, 0xa5, 0xa7, 0x38, 0xc8, 0x29, 0xb1, 0x9a);
DEFINE_GUID(Grid_RowCount_Property_GUID,                                0x2a9505bf, 0xc2eb, 0x4fb6, 0xb3, 0x56, 0x82, 0x45, 0xae, 0x53, 0x70, 0x3e);
DEFINE_GUID(Grid_ColumnCount_Property_GUID,                             0xfe96f375, 0x44aa, 0x4536, 0xac, 0x7a, 0x2a, 0x75, 0xd7, 0x1a, 0x3e, 0xfc);
DEFINE_GUID(GridItem_Row_Property_GUID,                                 0x6223972a, 0xc945, 0x4563, 0x93, 0x29, 0xfd, 0xc9, 0x74, 0xaf, 0x25, 0x53);
DEFINE_GUID(GridItem_Column_Property_GUID,                              0xc774c15c, 0x62c0, 0x4519, 0x8b, 0xdc, 0x47, 0xbe, 0x57, 0x3c, 0x8a, 0xd5);
DEFINE_GUID(GridItem_RowSpan_Property_GUID,                             0x4582291c, 0x466b, 0x4e93, 0x8e, 0x83, 0x3d, 0x17, 0x15, 0xec, 0x0c, 0x5e);
DEFINE_GUID(GridItem_ColumnSpan_Property_GUID,                          0x583ea3f5, 0x86d0, 0x4b08, 0xa6, 0xec, 0x2c, 0x54, 0x63, 0xff, 0xc1, 0x09);
DEFINE_GUID(GridItem_Parent_Property_GUID,                              0x9d912252, 0xb97f, 0x4ecc, 0x85, 0x10, 0xea, 0x0e, 0x33, 0x42, 0x7c, 0x72);
DEFINE_GUID(Dock_DockPosition_Property_GUID,                            0x6d67f02e, 0xc0b0, 0x4b10, 0xb5, 0xb9, 0x18, 0xd6, 0xec, 0xf9, 0x87, 0x60);
DEFINE_GUID(ExpandCollapse_ExpandCollapseState_Property_GUID,           0x275a4c48, 0x85a7, 0x4f69, 0xab, 0xa0, 0xaf, 0x15, 0x76, 0x10, 0x00, 0x2b);
DEFINE_GUID(MultipleView_CurrentView_Property_GUID,                     0x7a81a67a, 0xb94f, 0x4875, 0x91, 0x8b, 0x65, 0xc8, 0xd2, 0xf9, 0x98, 0xe5);
DEFINE_GUID(MultipleView_SupportedViews_Property_GUID,                  0x8d5db9fd, 0xce3c, 0x4ae7, 0xb7, 0x88, 0x40, 0x0a, 0x3c, 0x64, 0x55, 0x47);
DEFINE_GUID(Window_CanMaximize_Property_GUID,                           0x64fff53f, 0x635d, 0x41c1, 0x95, 0x0c, 0xcb, 0x5a, 0xdf, 0xbe, 0x28, 0xe3);
DEFINE_GUID(Window_CanMinimize_Property_GUID,                           0xb73b4625, 0x5988, 0x4b97, 0xb4, 0xc2, 0xa6, 0xfe, 0x6e, 0x78, 0xc8, 0xc6);
DEFINE_GUID(Window_WindowVisualState_Property_GUID,                     0x4ab7905f, 0xe860, 0x453e, 0xa3, 0x0a, 0xf6, 0x43, 0x1e, 0x5d, 0xaa, 0xd5);
DEFINE_GUID(Window_WindowInteractionState_Property_GUID,                0x4fed26a4, 0x0455, 0x4fa2, 0xb2, 0x1c, 0xc4, 0xda, 0x2d, 0xb1, 0xff, 0x9c);
DEFINE_GUID(Window_IsModal_Property_GUID,                               0xff4e6892, 0x37b9, 0x4fca, 0x85, 0x32, 0xff, 0xe6, 0x74, 0xec, 0xfe, 0xed);
DEFINE_GUID(Window_IsTopmost_Property_GUID,                             0xef7d85d3, 0x0937, 0x4962, 0x92, 0x41, 0xb6, 0x23, 0x45, 0xf2, 0x40, 0x41);
DEFINE_GUID(SelectionItem_IsSelected_Property_GUID,                     0xf122835f, 0xcd5f, 0x43df, 0xb7, 0x9d, 0x4b, 0x84, 0x9e, 0x9e, 0x60, 0x20);
DEFINE_GUID(SelectionItem_SelectionContainer_Property_GUID,             0xa4365b6e, 0x9c1e, 0x4b63, 0x8b, 0x53, 0xc2, 0x42, 0x1d, 0xd1, 0xe8, 0xfb);
DEFINE_GUID(Table_RowHeaders_Property_GUID,                             0xd9e35b87, 0x6eb8, 0x4562, 0xaa, 0xc6, 0xa8, 0xa9, 0x07, 0x52, 0x36, 0xa8);
DEFINE_GUID(Table_ColumnHeaders_Property_GUID,                          0xaff1d72b, 0x968d, 0x42b1, 0xb4, 0x59, 0x15, 0x0b, 0x29, 0x9d, 0xa6, 0x64);
DEFINE_GUID(Table_RowOrColumnMajor_Property_GUID,                       0x83be75c3, 0x29fe, 0x4a30, 0x85, 0xe1, 0x2a, 0x62, 0x77, 0xfd, 0x10, 0x6e);
DEFINE_GUID(TableItem_RowHeaderItems_Property_GUID,                     0xb3f853a0, 0x0574, 0x4cd8, 0xbc, 0xd7, 0xed, 0x59, 0x23, 0x57, 0x2d, 0x97);
DEFINE_GUID(TableItem_ColumnHeaderItems_Property_GUID,                  0x967a56a3, 0x74b6, 0x431e, 0x8d, 0xe6, 0x99, 0xc4, 0x11, 0x03, 0x1c, 0x58);
DEFINE_GUID(Toggle_ToggleState_Property_GUID,                           0xb23cdc52, 0x22c2, 0x4c6c, 0x9d, 0xed, 0xf5, 0xc4, 0x22, 0x47, 0x9e, 0xde);
DEFINE_GUID(Transform_CanMove_Property_GUID,                            0x1b75824d, 0x208b, 0x4fdf, 0xbc, 0xcd, 0xf1, 0xf4, 0xe5, 0x74, 0x1f, 0x4f);
DEFINE_GUID(Transform_CanResize_Property_GUID,                          0xbb98dca5, 0x4c1a, 0x41d4, 0xa4, 0xf6, 0xeb, 0xc1, 0x28, 0x64, 0x41, 0x80);
DEFINE_GUID(Transform_CanRotate_Property_GUID,                          0x10079b48, 0x3849, 0x476f, 0xac, 0x96, 0x44, 0xa9, 0x5c, 0x84, 0x40, 0xd9);
DEFINE_GUID(LegacyIAccessible_ChildId_Property_GUID,                    0x9a191b5d, 0x9ef2, 0x4787, 0xa4, 0x59, 0xdc, 0xde, 0x88, 0x5d, 0xd4, 0xe8);
DEFINE_GUID(LegacyIAccessible_Name_Property_GUID,                       0xcaeb063d, 0x40ae, 0x4869, 0xaa, 0x5a, 0x1b, 0x8e, 0x5d, 0x66, 0x67, 0x39);
DEFINE_GUID(LegacyIAccessible_Value_Property_GUID,                      0xb5c5b0b6, 0x8217, 0x4a77, 0x97, 0xa5, 0x19, 0x0a, 0x85, 0xed, 0x01, 0x56);
DEFINE_GUID(LegacyIAccessible_Description_Property_GUID,                0x46448418, 0x7d70, 0x4ea9, 0x9d, 0x27, 0xb7, 0xe7, 0x75, 0xcf, 0x2a, 0xd7);
DEFINE_GUID(LegacyIAccessible_Role_Property_GUID,                       0x6856e59f, 0xcbaf, 0x4e31, 0x93, 0xe8, 0xbc, 0xbf, 0x6f, 0x7e, 0x49, 0x1c);
DEFINE_GUID(LegacyIAccessible_State_Property_GUID,                      0xdf985854, 0x2281, 0x4340, 0xab, 0x9c, 0xc6, 0x0e, 0x2c, 0x58, 0x03, 0xf6);
DEFINE_GUID(LegacyIAccessible_Help_Property_GUID,                       0x94402352, 0x161c, 0x4b77, 0xa9, 0x8d, 0xa8, 0x72, 0xcc, 0x33, 0x94, 0x7a);
DEFINE_GUID(LegacyIAccessible_KeyboardShortcut_Property_GUID,           0x8f6909ac, 0x00b8, 0x4259, 0xa4, 0x1c, 0x96, 0x62, 0x66, 0xd4, 0x3a, 0x8a);
DEFINE_GUID(LegacyIAccessible_Selection_Property_GUID,                  0x8aa8b1e0, 0x0891, 0x40cc, 0x8b, 0x06, 0x90, 0xd7, 0xd4, 0x16, 0x62, 0x19);
DEFINE_GUID(LegacyIAccessible_DefaultAction_Property_GUID,              0x3b331729, 0xeaad, 0x4502, 0xb8, 0x5f, 0x92, 0x61, 0x56, 0x22, 0x91, 0x3c);
DEFINE_GUID(AriaRole_Property_GUID,                                     0xdd207b95, 0xbe4a, 0x4e0d, 0xb7, 0x27, 0x63, 0xac, 0xe9, 0x4b, 0x69, 0x16);
DEFINE_GUID(AriaProperties_Property_GUID,                               0x4213678c, 0xe025, 0x4922, 0xbe, 0xb5, 0xe4, 0x3b, 0xa0, 0x8e, 0x62, 0x21);
DEFINE_GUID(IsDataValidForForm_Property_GUID,                           0x445ac684, 0xc3fc, 0x4dd9, 0xac, 0xf8, 0x84, 0x5a, 0x57, 0x92, 0x96, 0xba);
DEFINE_GUID(ControllerFor_Property_GUID,                                0x51124c8a, 0xa5d2, 0x4f13, 0x9b, 0xe6, 0x7f, 0xa8, 0xba, 0x9d, 0x3a, 0x90);
DEFINE_GUID(DescribedBy_Property_GUID,                                  0x7c5865b8, 0x9992, 0x40fd, 0x8d, 0xb0, 0x6b, 0xf1, 0xd3, 0x17, 0xf9, 0x98);
DEFINE_GUID(FlowsTo_Property_GUID,                                      0xe4f33d20, 0x559a, 0x47fb, 0xa8, 0x30, 0xf9, 0xcb, 0x4f, 0xf1, 0xa7, 0x0a);
DEFINE_GUID(ProviderDescription_Property_GUID,                          0xdca5708a, 0xc16b, 0x4cd9, 0xb8, 0x89, 0xbe, 0xb1, 0x6a, 0x80, 0x49, 0x04);
DEFINE_GUID(ToolTipOpened_Event_GUID,                                   0x3f4b97ff, 0x2edc, 0x451d, 0xbc, 0xa4, 0x95, 0xa3, 0x18, 0x8d, 0x5b, 0x03);
DEFINE_GUID(ToolTipClosed_Event_GUID,                                   0x276d71ef, 0x24a9, 0x49b6, 0x8e, 0x97, 0xda, 0x98, 0xb4, 0x01, 0xbb, 0xcd);
DEFINE_GUID(StructureChanged_Event_GUID,                                0x59977961, 0x3edd, 0x4b11, 0xb1, 0x3b, 0x67, 0x6b, 0x2a, 0x2a, 0x6c, 0xa9);
DEFINE_GUID(MenuOpened_Event_GUID,                                      0xebe2e945, 0x66ca, 0x4ed1, 0x9f, 0xf8, 0x2a, 0xd7, 0xdf, 0x0a, 0x1b, 0x08);
DEFINE_GUID(AutomationPropertyChanged_Event_GUID,                       0x2527fba1, 0x8d7a, 0x4630, 0xa4, 0xcc, 0xe6, 0x63, 0x15, 0x94, 0x2f, 0x52);
DEFINE_GUID(AutomationFocusChanged_Event_GUID,                          0xb68a1f17, 0xf60d, 0x41a7, 0xa3, 0xcc, 0xb0, 0x52, 0x92, 0x15, 0x5f, 0xe0);
DEFINE_GUID(AsyncContentLoaded_Event_GUID,                              0x5fdee11c, 0xd2fa, 0x4fb9, 0x90, 0x4e, 0x5c, 0xbe, 0xe8, 0x94, 0xd5, 0xef);
DEFINE_GUID(MenuClosed_Event_GUID,                                      0x3cf1266e, 0x1582, 0x4041, 0xac, 0xd7, 0x88, 0xa3, 0x5a, 0x96, 0x52, 0x97);
DEFINE_GUID(LayoutInvalidated_Event_GUID,                               0xed7d6544, 0xa6bd, 0x4595, 0x9b, 0xae, 0x3d, 0x28, 0x94, 0x6c, 0xc7, 0x15);
DEFINE_GUID(Invoke_Invoked_Event_GUID,                                  0xdfd699f0, 0xc915, 0x49dd, 0xb4, 0x22, 0xdd, 0xe7, 0x85, 0xc3, 0xd2, 0x4b);
DEFINE_GUID(SelectionItem_ElementAddedToSelectionEvent_Event_GUID,      0x3c822dd1, 0xc407, 0x4dba, 0x91, 0xdd, 0x79, 0xd4, 0xae, 0xd0, 0xae, 0xc6);
DEFINE_GUID(SelectionItem_ElementRemovedFromSelectionEvent_Event_GUID,  0x097fa8a9, 0x7079, 0x41af, 0x8b, 0x9c, 0x09, 0x34, 0xd8, 0x30, 0x5e, 0x5c);
DEFINE_GUID(SelectionItem_ElementSelectedEvent_Event_GUID,              0xb9c7dbfb, 0x4ebe, 0x4532, 0xaa, 0xf4, 0x00, 0x8c, 0xf6, 0x47, 0x23, 0x3c);
DEFINE_GUID(Selection_InvalidatedEvent_Event_GUID,                      0xcac14904, 0x16b4, 0x4b53, 0x8e, 0x47, 0x4c, 0xb1, 0xdf, 0x26, 0x7b, 0xb7);
DEFINE_GUID(Text_TextSelectionChangedEvent_Event_GUID,                  0x918edaa1, 0x71b3, 0x49ae, 0x97, 0x41, 0x79, 0xbe, 0xb8, 0xd3, 0x58, 0xf3);
DEFINE_GUID(Text_TextChangedEvent_Event_GUID,                           0x4a342082, 0xf483, 0x48c4, 0xac, 0x11, 0xa8, 0x4b, 0x43, 0x5e, 0x2a, 0x84);
DEFINE_GUID(Window_WindowOpened_Event_GUID,                             0xd3e81d06, 0xde45, 0x4f2f, 0x96, 0x33, 0xde, 0x9e, 0x02, 0xfb, 0x65, 0xaf);
DEFINE_GUID(Window_WindowClosed_Event_GUID,                             0xedf141f8, 0xfa67, 0x4e22, 0xbb, 0xf7, 0x94, 0x4e, 0x05, 0x73, 0x5e, 0xe2);
DEFINE_GUID(MenuModeStart_Event_GUID,                                   0x18d7c631, 0x166a, 0x4ac9, 0xae, 0x3b, 0xef, 0x4b, 0x54, 0x20, 0xe6, 0x81);
DEFINE_GUID(MenuModeEnd_Event_GUID,                                     0x9ecd4c9f, 0x80dd, 0x47b8, 0x82, 0x67, 0x5a, 0xec, 0x06, 0xbb, 0x2c, 0xff);
DEFINE_GUID(InputReachedTarget_Event_GUID,                              0x93ed549a, 0x0549, 0x40f0, 0xbe, 0xdb, 0x28, 0xe4, 0x4f, 0x7d, 0xe2, 0xa3);
DEFINE_GUID(InputReachedOtherElement_Event_GUID,                        0xed201d8a, 0x4e6c, 0x415e, 0xa8, 0x74, 0x24, 0x60, 0xc9, 0xb6, 0x6b, 0xa8);
DEFINE_GUID(InputDiscarded_Event_GUID,                                  0x7f36c367, 0x7b18, 0x417c, 0x97, 0xe3, 0x9d, 0x58, 0xdd, 0xc9, 0x44, 0xab);
DEFINE_GUID(Invoke_Pattern_GUID,                                        0xd976c2fc, 0x66ea, 0x4a6e, 0xb2, 0x8f, 0xc2, 0x4c, 0x75, 0x46, 0xad, 0x37);
DEFINE_GUID(Selection_Pattern_GUID,                                     0x66e3b7e8, 0xd821, 0x4d25, 0x87, 0x61, 0x43, 0x5d, 0x2c, 0x8b, 0x25, 0x3f);
DEFINE_GUID(Value_Pattern_GUID,                                         0x17faad9e, 0xc877, 0x475b, 0xb9, 0x33, 0x77, 0x33, 0x27, 0x79, 0xb6, 0x37);
DEFINE_GUID(RangeValue_Pattern_GUID,                                    0x18b00d87, 0xb1c9, 0x476a, 0xbf, 0xbd, 0x5f, 0x0b, 0xdb, 0x92, 0x6f, 0x63);
DEFINE_GUID(Scroll_Pattern_GUID,                                        0x895fa4b4, 0x759d, 0x4c50, 0x8e, 0x15, 0x03, 0x46, 0x06, 0x72, 0x00, 0x3c);
DEFINE_GUID(ExpandCollapse_Pattern_GUID,                                0xae05efa2, 0xf9d1, 0x428a, 0x83, 0x4c, 0x53, 0xa5, 0xc5, 0x2f, 0x9b, 0x8b);
DEFINE_GUID(Grid_Pattern_GUID,                                          0x260a2ccb, 0x93a8, 0x4e44, 0xa4, 0xc1, 0x3d, 0xf3, 0x97, 0xf2, 0xb0, 0x2b);
DEFINE_GUID(GridItem_Pattern_GUID,                                      0xf2d5c877, 0xa462, 0x4957, 0xa2, 0xa5, 0x2c, 0x96, 0xb3, 0x03, 0xbc, 0x63);
DEFINE_GUID(MultipleView_Pattern_GUID,                                  0x547a6ae4, 0x113f, 0x47c4, 0x85, 0x0f, 0xdb, 0x4d, 0xfa, 0x46, 0x6b, 0x1d);
DEFINE_GUID(Window_Pattern_GUID,                                        0x27901735, 0xc760, 0x4994, 0xad, 0x11, 0x59, 0x19, 0xe6, 0x06, 0xb1, 0x10);
DEFINE_GUID(SelectionItem_Pattern_GUID,                                 0x9bc64eeb, 0x87c7, 0x4b28, 0x94, 0xbb, 0x4d, 0x9f, 0xa4, 0x37, 0xb6, 0xef);
DEFINE_GUID(Dock_Pattern_GUID,                                          0x9cbaa846, 0x83c8, 0x428d, 0x82, 0x7f, 0x7e, 0x60, 0x63, 0xfe, 0x06, 0x20);
DEFINE_GUID(Table_Pattern_GUID,                                         0xc415218e, 0xa028, 0x461e, 0xaa, 0x92, 0x8f, 0x92, 0x5c, 0xf7, 0x93, 0x51);
DEFINE_GUID(TableItem_Pattern_GUID,                                     0xdf1343bd, 0x1888, 0x4a29, 0xa5, 0x0c, 0xb9, 0x2e, 0x6d, 0xe3, 0x7f, 0x6f);
DEFINE_GUID(Text_Pattern_GUID,                                          0x8615f05d, 0x7de5, 0x44fd, 0xa6, 0x79, 0x2c, 0xa4, 0xb4, 0x60, 0x33, 0xa8);
DEFINE_GUID(Toggle_Pattern_GUID,                                        0x0b419760, 0xe2f4, 0x43ff, 0x8c, 0x5f, 0x94, 0x57, 0xc8, 0x2b, 0x56, 0xe9);
DEFINE_GUID(Transform_Pattern_GUID,                                     0x24b46fdb, 0x587e, 0x49f1, 0x9c, 0x4a, 0xd8, 0xe9, 0x8b, 0x66, 0x4b, 0x7b);
DEFINE_GUID(ScrollItem_Pattern_GUID,                                    0x4591d005, 0xa803, 0x4d5c, 0xb4, 0xd5, 0x8d, 0x28, 0x00, 0xf9, 0x06, 0xa7);
DEFINE_GUID(LegacyIAccessible_Pattern_GUID,                             0x54cc0a9f, 0x3395, 0x48af, 0xba, 0x8d, 0x73, 0xf8, 0x56, 0x90, 0xf3, 0xe0);
DEFINE_GUID(ItemContainer_Pattern_GUID,                                 0x3d13da0f, 0x8b9a, 0x4a99, 0x85, 0xfa, 0xc5, 0xc9, 0xa6, 0x9f, 0x1e, 0xd4);
DEFINE_GUID(VirtualizedItem_Pattern_GUID,                               0xf510173e, 0x2e71, 0x45e9, 0xa6, 0xe5, 0x62, 0xf6, 0xed, 0x82, 0x89, 0xd5);
DEFINE_GUID(SynchronizedInput_Pattern_GUID,                             0x05c288a6, 0xc47b, 0x488b, 0xb6, 0x53, 0x33, 0x97, 0x7a, 0x55, 0x1b, 0x8b);
DEFINE_GUID(Button_Control_GUID,                                        0x5a78e369, 0xc6a1, 0x4f33, 0xa9, 0xd7, 0x79, 0xf2, 0x0d, 0x0c, 0x78, 0x8e);
DEFINE_GUID(Calendar_Control_GUID,                                      0x8913eb88, 0x00e5, 0x46bc, 0x8e, 0x4e, 0x14, 0xa7, 0x86, 0xe1, 0x65, 0xa1);
DEFINE_GUID(CheckBox_Control_GUID,                                      0xfb50f922, 0xa3db, 0x49c0, 0x8b, 0xc3, 0x06, 0xda, 0xd5, 0x57, 0x78, 0xe2);
DEFINE_GUID(ComboBox_Control_GUID,                                      0x54cb426c, 0x2f33, 0x4fff, 0xaa, 0xa1, 0xae, 0xf6, 0x0d, 0xac, 0x5d, 0xeb);
DEFINE_GUID(Edit_Control_GUID,                                          0x6504a5c8, 0x2c86, 0x4f87, 0xae, 0x7b, 0x1a, 0xbd, 0xdc, 0x81, 0x0c, 0xf9);
DEFINE_GUID(Hyperlink_Control_GUID,                                     0x8a56022c, 0xb00d, 0x4d15, 0x8f, 0xf0, 0x5b, 0x6b, 0x26, 0x6e, 0x5e, 0x02);
DEFINE_GUID(Image_Control_GUID,                                         0x2d3736e4, 0x6b16, 0x4c57, 0xa9, 0x62, 0xf9, 0x32, 0x60, 0xa7, 0x52, 0x43);
DEFINE_GUID(ListItem_Control_GUID,                                      0x7b3717f2, 0x44d1, 0x4a58, 0x98, 0xa8, 0xf1, 0x2a, 0x9b, 0x8f, 0x78, 0xe2);
DEFINE_GUID(List_Control_GUID,                                          0x9b149ee1, 0x7cca, 0x4cfc, 0x9a, 0xf1, 0xca, 0xc7, 0xbd, 0xdd, 0x30, 0x31);
DEFINE_GUID(Menu_Control_GUID,                                          0x2e9b1440, 0x0ea8, 0x41fd, 0xb3, 0x74, 0xc1, 0xea, 0x6f, 0x50, 0x3c, 0xd1);
DEFINE_GUID(MenuBar_Control_GUID,                                       0xcc384250, 0x0e7b, 0x4ae8, 0x95, 0xae, 0xa0, 0x8f, 0x26, 0x1b, 0x52, 0xee);
DEFINE_GUID(MenuItem_Control_GUID,                                      0xf45225d3, 0xd0a0, 0x49d8, 0x98, 0x34, 0x9a, 0x00, 0x0d, 0x2a, 0xed, 0xdc);
DEFINE_GUID(ProgressBar_Control_GUID,                                   0x228c9f86, 0xc36c, 0x47bb, 0x9f, 0xb6, 0xa5, 0x83, 0x4b, 0xfc, 0x53, 0xa4);
DEFINE_GUID(RadioButton_Control_GUID,                                   0x3bdb49db, 0xfe2c, 0x4483, 0xb3, 0xe1, 0xe5, 0x7f, 0x21, 0x94, 0x40, 0xc6);
DEFINE_GUID(ScrollBar_Control_GUID,                                     0xdaf34b36, 0x5065, 0x4946, 0xb2, 0x2f, 0x92, 0x59, 0x5f, 0xc0, 0x75, 0x1a);
DEFINE_GUID(Slider_Control_GUID,                                        0xb033c24b, 0x3b35, 0x4cea, 0xb6, 0x09, 0x76, 0x36, 0x82, 0xfa, 0x66, 0x0b);
DEFINE_GUID(Spinner_Control_GUID,                                       0x60cc4b38, 0x3cb1, 0x4161, 0xb4, 0x42, 0xc6, 0xb7, 0x26, 0xc1, 0x78, 0x25);
DEFINE_GUID(StatusBar_Control_GUID,                                     0xd45e7d1b, 0x5873, 0x475f, 0x95, 0xa4, 0x04, 0x33, 0xe1, 0xf1, 0xb0, 0x0a);
DEFINE_GUID(Tab_Control_GUID,                                           0x38cd1f2d, 0x337a, 0x4bd2, 0xa5, 0xe3, 0xad, 0xb4, 0x69, 0xe3, 0x0b, 0xd3);
DEFINE_GUID(TabItem_Control_GUID,                                       0x2c6a634f, 0x921b, 0x4e6e, 0xb2, 0x6e, 0x08, 0xfc, 0xb0, 0x79, 0x8f, 0x4c);
DEFINE_GUID(Text_Control_GUID,                                          0xae9772dc, 0xd331, 0x4f09, 0xbe, 0x20, 0x7e, 0x6d, 0xfa, 0xf0, 0x7b, 0x0a);
DEFINE_GUID(ToolBar_Control_GUID,                                       0x8f06b751, 0xe182, 0x4e98, 0x88, 0x93, 0x22, 0x84, 0x54, 0x3a, 0x7d, 0xce);
DEFINE_GUID(ToolTip_Control_GUID,                                       0x05ddc6d1, 0x2137, 0x4768, 0x98, 0xea, 0x73, 0xf5, 0x2f, 0x71, 0x34, 0xf3);
DEFINE_GUID(Tree_Control_GUID,                                          0x7561349c, 0xd241, 0x43f4, 0x99, 0x08, 0xb5, 0xf0, 0x91, 0xbe, 0xe6, 0x11);
DEFINE_GUID(TreeItem_Control_GUID,                                      0x62c9feb9, 0x8ffc, 0x4878, 0xa3, 0xa4, 0x96, 0xb0, 0x30, 0x31, 0x5c, 0x18);
DEFINE_GUID(Custom_Control_GUID,                                        0xf29ea0c3, 0xadb7, 0x430a, 0xba, 0x90, 0xe5, 0x2c, 0x73, 0x13, 0xe6, 0xed);
DEFINE_GUID(Group_Control_GUID,                                         0xad50aa1c, 0xe8c8, 0x4774, 0xae, 0x1b, 0xdd, 0x86, 0xdf, 0x0b, 0x3b, 0xdc);
DEFINE_GUID(Thumb_Control_GUID,                                         0x701ca877, 0xe310, 0x4dd6, 0xb6, 0x44, 0x79, 0x7e, 0x4f, 0xae, 0xa2, 0x13);
DEFINE_GUID(DataGrid_Control_GUID,                                      0x84b783af, 0xd103, 0x4b0a, 0x84, 0x15, 0xe7, 0x39, 0x42, 0x41, 0x0f, 0x4b);
DEFINE_GUID(DataItem_Control_GUID,                                      0xa0177842, 0xd94f, 0x42a5, 0x81, 0x4b, 0x60, 0x68, 0xad, 0xdc, 0x8d, 0xa5);
DEFINE_GUID(Document_Control_GUID,                                      0x3cd6bb6f, 0x6f08, 0x4562, 0xb2, 0x29, 0xe4, 0xe2, 0xfc, 0x7a, 0x9e, 0xb4);
DEFINE_GUID(SplitButton_Control_GUID,                                   0x7011f01f, 0x4ace, 0x4901, 0xb4, 0x61, 0x92, 0x0a, 0x6f, 0x1c, 0xa6, 0x50);
DEFINE_GUID(Window_Control_GUID,                                        0xe13a7242, 0xf462, 0x4f4d, 0xae, 0xc1, 0x53, 0xb2, 0x8d, 0x6c, 0x32, 0x90);
DEFINE_GUID(Pane_Control_GUID,                                          0x5c2b3f5b, 0x9182, 0x42a3, 0x8d, 0xec, 0x8c, 0x04, 0xc1, 0xee, 0x63, 0x4d);
DEFINE_GUID(Header_Control_GUID,                                        0x5b90cbce, 0x78fb, 0x4614, 0x82, 0xb6, 0x55, 0x4d, 0x74, 0x71, 0x8e, 0x67);
DEFINE_GUID(HeaderItem_Control_GUID,                                    0xe6bc12cb, 0x7c8e, 0x49cf, 0xb1, 0x68, 0x4a, 0x93, 0xa3, 0x2b, 0xeb, 0xb0);
DEFINE_GUID(Table_Control_GUID,                                         0x773bfa0e, 0x5bc4, 0x4deb, 0x92, 0x1b, 0xde, 0x7b, 0x32, 0x06, 0x22, 0x9e);
DEFINE_GUID(TitleBar_Control_GUID,                                      0x98aa55bf, 0x3bb0, 0x4b65, 0x83, 0x6e, 0x2e, 0xa3, 0x0d, 0xbc, 0x17, 0x1f);
DEFINE_GUID(Separator_Control_GUID,                                     0x8767eba3, 0x2a63, 0x4ab0, 0xac, 0x8d, 0xaa, 0x50, 0xe2, 0x3d, 0xe9, 0x78);
DEFINE_GUID(Text_AnimationStyle_Attribute_GUID,                         0x628209f0, 0x7c9a, 0x4d57, 0xbe, 0x64, 0x1f, 0x18, 0x36, 0x57, 0x1f, 0xf5);
DEFINE_GUID(Text_BackgroundColor_Attribute_GUID,                        0xfdc49a07, 0x583d, 0x4f17, 0xad, 0x27, 0x77, 0xfc, 0x83, 0x2a, 0x3c, 0x0b);
DEFINE_GUID(Text_BulletStyle_Attribute_GUID,                            0xc1097c90, 0xd5c4, 0x4237, 0x97, 0x81, 0x3b, 0xec, 0x8b, 0xa5, 0x4e, 0x48);
DEFINE_GUID(Text_CapStyle_Attribute_GUID,                               0xfb059c50, 0x92cc, 0x49a5, 0xba, 0x8f, 0x0a, 0xa8, 0x72, 0xbb, 0xa2, 0xf3);
DEFINE_GUID(Text_Culture_Attribute_GUID,                                0xc2025af9, 0xa42d, 0x4ced, 0xa1, 0xfb, 0xc6, 0x74, 0x63, 0x15, 0x22, 0x2e);
DEFINE_GUID(Text_FontName_Attribute_GUID,                               0x64e63ba8, 0xf2e5, 0x476e, 0xa4, 0x77, 0x17, 0x34, 0xfe, 0xaa, 0xf7, 0x26);
DEFINE_GUID(Text_FontSize_Attribute_GUID,                               0xdc5eeeff, 0x0506, 0x4673, 0x93, 0xf2, 0x37, 0x7e, 0x4a, 0x8e, 0x01, 0xf1);
DEFINE_GUID(Text_FontWeight_Attribute_GUID,                             0x6fc02359, 0xb316, 0x4f5f, 0xb4, 0x01, 0xf1, 0xce, 0x55, 0x74, 0x18, 0x53);
DEFINE_GUID(Text_ForegroundColor_Attribute_GUID,                        0x72d1c95d, 0x5e60, 0x471a, 0x96, 0xb1, 0x6c, 0x1b, 0x3b, 0x77, 0xa4, 0x36);
DEFINE_GUID(Text_HorizontalTextAlignment_Attribute_GUID,                0x04ea6161, 0xfba3, 0x477a, 0x95, 0x2a, 0xbb, 0x32, 0x6d, 0x02, 0x6a, 0x5b);
DEFINE_GUID(Text_IndentationFirstLine_Attribute_GUID,                   0x206f9ad5, 0xc1d3, 0x424a, 0x81, 0x82, 0x6d, 0xa9, 0xa7, 0xf3, 0xd6, 0x32);
DEFINE_GUID(Text_IndentationLeading_Attribute_GUID,                     0x5cf66bac, 0x2d45, 0x4a4b, 0xb6, 0xc9, 0xf7, 0x22, 0x1d, 0x28, 0x15, 0xb0);
DEFINE_GUID(Text_IndentationTrailing_Attribute_GUID,                    0x97ff6c0f, 0x1ce4, 0x408a, 0xb6, 0x7b, 0x94, 0xd8, 0x3e, 0xb6, 0x9b, 0xf2);
DEFINE_GUID(Text_IsHidden_Attribute_GUID,                               0x360182fb, 0xbdd7, 0x47f6, 0xab, 0x69, 0x19, 0xe3, 0x3f, 0x8a, 0x33, 0x44);
DEFINE_GUID(Text_IsItalic_Attribute_GUID,                               0xfce12a56, 0x1336, 0x4a34, 0x96, 0x63, 0x1b, 0xab, 0x47, 0x23, 0x93, 0x20);
DEFINE_GUID(Text_IsReadOnly_Attribute_GUID,                             0xa738156b, 0xca3e, 0x495e, 0x95, 0x14, 0x83, 0x3c, 0x44, 0x0f, 0xeb, 0x11);
DEFINE_GUID(Text_IsSubscript_Attribute_GUID,                            0xf0ead858, 0x8f53, 0x413c, 0x87, 0x3f, 0x1a, 0x7d, 0x7f, 0x5e, 0x0d, 0xe4);
DEFINE_GUID(Text_IsSuperscript_Attribute_GUID,                          0xda706ee4, 0xb3aa, 0x4645, 0xa4, 0x1f, 0xcd, 0x25, 0x15, 0x7d, 0xea, 0x76);
DEFINE_GUID(Text_MarginBottom_Attribute_GUID,                           0x7ee593c4, 0x72b4, 0x4cac, 0x92, 0x71, 0x3e, 0xd2, 0x4b, 0x0e, 0x4d, 0x42);
DEFINE_GUID(Text_MarginLeading_Attribute_GUID,                          0x9e9242d0, 0x5ed0, 0x4900, 0x8e, 0x8a, 0xee, 0xcc, 0x03, 0x83, 0x5a, 0xfc);
DEFINE_GUID(Text_MarginTop_Attribute_GUID,                              0x683d936f, 0xc9b9, 0x4a9a, 0xb3, 0xd9, 0xd2, 0x0d, 0x33, 0x31, 0x1e, 0x2a);
DEFINE_GUID(Text_MarginTrailing_Attribute_GUID,                         0xaf522f98, 0x999d, 0x40af, 0xa5, 0xb2, 0x01, 0x69, 0xd0, 0x34, 0x20, 0x02);
DEFINE_GUID(Text_OutlineStyles_Attribute_GUID,                          0x5b675b27, 0xdb89, 0x46fe, 0x97, 0x0c, 0x61, 0x4d, 0x52, 0x3b, 0xb9, 0x7d);
DEFINE_GUID(Text_OverlineColor_Attribute_GUID,                          0x83ab383a, 0xfd43, 0x40da, 0xab, 0x3e, 0xec, 0xf8, 0x16, 0x5c, 0xbb, 0x6d);
DEFINE_GUID(Text_OverlineStyle_Attribute_GUID,                          0x0a234d66, 0x617e, 0x427f, 0x87, 0x1d, 0xe1, 0xff, 0x1e, 0x0c, 0x21, 0x3f);
DEFINE_GUID(Text_StrikethroughColor_Attribute_GUID,                     0xbfe15a18, 0x8c41, 0x4c5a, 0x9a, 0x0b, 0x04, 0xaf, 0x0e, 0x07, 0xf4, 0x87);
DEFINE_GUID(Text_StrikethroughStyle_Attribute_GUID,                     0x72913ef1, 0xda00, 0x4f01, 0x89, 0x9c, 0xac, 0x5a, 0x85, 0x77, 0xa3, 0x07);
DEFINE_GUID(Text_Tabs_Attribute_GUID,                                   0x2e68d00b, 0x92fe, 0x42d8, 0x89, 0x9a, 0xa7, 0x84, 0xaa, 0x44, 0x54, 0xa1);
DEFINE_GUID(Text_TextFlowDirections_Attribute_GUID,                     0x8bdf8739, 0xf420, 0x423e, 0xaf, 0x77, 0x20, 0xa5, 0xd9, 0x73, 0xa9, 0x07);
DEFINE_GUID(Text_UnderlineColor_Attribute_GUID,                         0xbfa12c73, 0xfde2, 0x4473, 0xbf, 0x64, 0x10, 0x36, 0xd6, 0xaa, 0x0f, 0x45);
DEFINE_GUID(Text_UnderlineStyle_Attribute_GUID,                         0x5f3b21c0, 0xede4, 0x44bd, 0x9c, 0x36, 0x38, 0x53, 0x03, 0x8c, 0xbf, 0xeb);

DEFINE_GUID(SID_IsUIAutomationObject,                                   0xb96fdb85, 0x7204, 0x4724, 0x84, 0x2b, 0xc7, 0x05, 0x9d, 0xed, 0xb9, 0xd0);

// --------------------------------------------------------------------------
//
// Error handling
//
// --------------------------------------------------------------------------

BOOL WINAPI UiaGetErrorDescription(BSTR * pDescription);

// --------------------------------------------------------------------------
//
// Conditions
//
// --------------------------------------------------------------------------

enum ConditionType
{
    ConditionType_True = 0,
    ConditionType_False = 1,
    ConditionType_Property = 2,
    ConditionType_And = 3,
    ConditionType_Or = 4,
    ConditionType_Not = 5,
};

struct UiaCondition
{
    ConditionType ConditionType;
};

#ifndef __uiautomationclient_h__
enum PropertyConditionFlags
{
    PropertyConditionFlags_None = 0x00,
    PropertyConditionFlags_IgnoreCase = 0x01,
};
#endif

struct UiaPropertyCondition
{
    ConditionType ConditionType;
    PROPERTYID PropertyId;
    VARIANT Value;
    PropertyConditionFlags Flags;
};

struct UiaAndOrCondition
{
    ConditionType ConditionType;
    UiaCondition ** ppConditions; // ptr to array-of-ptrs to conditions
    int cConditions;
};

struct UiaNotCondition
{
    ConditionType ConditionType;
    UiaCondition * pCondition;
};


// --------------------------------------------------------------------------
//
// Cache request/response
//
// --------------------------------------------------------------------------

#ifndef __uiautomationclient_h__
enum AutomationElementMode
{
    AutomationElementMode_None,
    AutomationElementMode_Full
};
#endif

struct UiaCacheRequest
{
    UiaCondition *  pViewCondition;
    TreeScope       Scope;

    PROPERTYID *    pProperties;
    int             cProperties;
    PATTERNID *     pPatterns;
    int             cPatterns;
    AutomationElementMode automationElementMode;
};

HRESULT WINAPI UiaHUiaNodeFromVariant(VARIANT * pvar, HUIANODE *phnode);
HRESULT WINAPI UiaHPatternObjectFromVariant(VARIANT * pvar, HUIAPATTERNOBJECT *phobj);
HRESULT WINAPI UiaHTextRangeFromVariant(VARIANT * pvar, HUIATEXTRANGE *phtextrange);

// --------------------------------------------------------------------------
//
// UiaNode methods
//
// --------------------------------------------------------------------------

// Used by UiaGetUpdatedCache
enum NormalizeState
{
    NormalizeState_None,    // Don't normalize
    NormalizeState_View,    // Normalize against condition in UiaCacheRequest
    NormalizeState_Custom   // Normalize against supplied condition
};

struct UiaFindParams
{
    int MaxDepth;
    BOOL FindFirst;
    BOOL ExcludeRoot;
    UiaCondition * pFindCondition;
};

BOOL WINAPI UiaNodeRelease(HUIANODE hnode);

HRESULT WINAPI UiaGetPropertyValue(HUIANODE hnode, PROPERTYID propertyId, VARIANT * pValue);
HRESULT WINAPI UiaGetPatternProvider(HUIANODE hnode, PATTERNID patternId, HUIAPATTERNOBJECT * phobj);
HRESULT WINAPI UiaGetRuntimeId(HUIANODE hnode, SAFEARRAY ** pruntimeId);
HRESULT WINAPI UiaSetFocus(HUIANODE hnode);
HRESULT WINAPI UiaNavigate(HUIANODE hnode, NavigateDirection direction, UiaCondition * pCondition, UiaCacheRequest * pRequest, SAFEARRAY ** ppRequestedData, BSTR * ppTreeStructure);
HRESULT WINAPI UiaGetUpdatedCache(HUIANODE hnode, UiaCacheRequest * pRequest, NormalizeState normalizeState, UiaCondition * pNormalizeCondition, SAFEARRAY ** ppRequestedData, BSTR * ppTreeStructure);
HRESULT WINAPI UiaFind(HUIANODE hnode, UiaFindParams * pParams, UiaCacheRequest * pRequest, SAFEARRAY ** ppRequestedData, SAFEARRAY ** ppOffsets, SAFEARRAY ** ppTreeStructures);

HRESULT WINAPI UiaNodeFromPoint(double x, double y, UiaCacheRequest * pRequest, SAFEARRAY ** ppRequestedData, BSTR * ppTreeStructure);
HRESULT WINAPI UiaNodeFromFocus(UiaCacheRequest * pRequest, SAFEARRAY ** ppRequestedData, BSTR * ppTreeStructure);
HRESULT WINAPI UiaNodeFromHandle(HWND hwnd, HUIANODE * phnode);
HRESULT WINAPI UiaNodeFromProvider(IRawElementProviderSimple * pProvider, HUIANODE * phnode);
HRESULT WINAPI UiaGetRootNode(HUIANODE * phnode);


#ifdef __cplusplus
inline void UiaRectSetEmpty(UiaRect & rc)
{
    rc.left = 0;
    rc.top = 0;
    rc.width = 0;
    rc.height = 0;
}

inline bool UiaRectIsEmpty(const UiaRect & rc)
{
    return rc.width <= 0 || rc.height <= 0;
}
#endif

// --------------------------------------------------------------------------
//
// Client-side provider support
//
// --------------------------------------------------------------------------

enum ProviderType
{
    ProviderType_BaseHwnd,
    ProviderType_Proxy,
    ProviderType_NonClientArea,
};

typedef SAFEARRAY * WINAPI UiaProviderCallback(HWND hwnd, ProviderType providerType);

void WINAPI UiaRegisterProviderCallback(UiaProviderCallback * pCallback);


// --------------------------------------------------------------------------
//
// Identifier mapping
//
// --------------------------------------------------------------------------

enum AutomationIdentifierType
{
    AutomationIdentifierType_Property,
    AutomationIdentifierType_Pattern,
    AutomationIdentifierType_Event,
    AutomationIdentifierType_ControlType,
    AutomationIdentifierType_TextAttribute
};

int WINAPI UiaLookupId(AutomationIdentifierType type, const GUID* pGuid);

HRESULT WINAPI UiaGetReservedNotSupportedValue(IUnknown **punkNotSupportedValue);
HRESULT WINAPI UiaGetReservedMixedAttributeValue(IUnknown **punkMixedAttributeValue);

// --------------------------------------------------------------------------
//
// Event methods
//
// --------------------------------------------------------------------------

//
// Event structs and enums
//

enum EventArgsType
{
    EventArgsType_Simple,
    EventArgsType_PropertyChanged,
    EventArgsType_StructureChanged,
    EventArgsType_AsyncContentLoaded,
    EventArgsType_WindowClosed,
};

enum AsyncContentLoadedState
{
    AsyncContentLoadedState_Beginning,
    AsyncContentLoadedState_Progress,
    AsyncContentLoadedState_Completed
};

struct UiaEventArgs
{
    EventArgsType Type;
    int EventId;
};

struct UiaPropertyChangedEventArgs
{
    EventArgsType Type;
    int EventId;
    PROPERTYID PropertyId;
    VARIANT OldValue;
    VARIANT NewValue;
};

struct UiaStructureChangedEventArgs
{
    EventArgsType Type;
    int EventId;
    StructureChangeType StructureChangeType;
    int * pRuntimeId;
    int cRuntimeIdLen;
};

struct UiaAsyncContentLoadedEventArgs
{
    EventArgsType Type;
    int EventId;
    AsyncContentLoadedState AsyncContentLoadedState;
    double PercentComplete;
};

struct UiaWindowClosedEventArgs
{
    EventArgsType Type;
    int EventId;
    int * pRuntimeId;
    int cRuntimeIdLen;
};

//
// Provider Event APIs
//
BOOL WINAPI UiaClientsAreListening();
HRESULT WINAPI UiaRaiseAutomationPropertyChangedEvent(IRawElementProviderSimple * pProvider, PROPERTYID id, VARIANT oldValue, VARIANT newValue);
HRESULT WINAPI UiaRaiseAutomationEvent(IRawElementProviderSimple * pProvider, EVENTID id);
HRESULT WINAPI UiaRaiseStructureChangedEvent(IRawElementProviderSimple * pProvider, StructureChangeType structureChangeType, int * pRuntimeId, int cRuntimeIdLen);
HRESULT WINAPI UiaRaiseAsyncContentLoadedEvent(IRawElementProviderSimple * pProvider, AsyncContentLoadedState asyncContentLoadedState, double percentComplete);

//
// Client Event APIs
//
typedef void WINAPI UiaEventCallback(UiaEventArgs * pArgs, SAFEARRAY * pRequestedData, BSTR pTreeStructure);
HRESULT WINAPI UiaAddEvent(HUIANODE hnode, EVENTID eventId, UiaEventCallback * pCallback, TreeScope scope, PROPERTYID * pProperties, int cProperties, UiaCacheRequest * pRequest, HUIAEVENT * phEvent);
HRESULT WINAPI UiaRemoveEvent(HUIAEVENT hEvent);
HRESULT WINAPI UiaEventAddWindow(HUIAEVENT hEvent, HWND hwnd);
HRESULT WINAPI UiaEventRemoveWindow(HUIAEVENT hEvent, HWND hwnd);


// --------------------------------------------------------------------------
//
// Pattern methods
//
// --------------------------------------------------------------------------

HRESULT WINAPI DockPattern_SetDockPosition(HUIAPATTERNOBJECT hobj, DockPosition dockPosition);
HRESULT WINAPI ExpandCollapsePattern_Collapse(HUIAPATTERNOBJECT hobj);
HRESULT WINAPI ExpandCollapsePattern_Expand(HUIAPATTERNOBJECT hobj);
HRESULT WINAPI GridPattern_GetItem(HUIAPATTERNOBJECT hobj, int row, int column, HUIANODE * pResult);
HRESULT WINAPI InvokePattern_Invoke(HUIAPATTERNOBJECT hobj);
HRESULT WINAPI MultipleViewPattern_GetViewName(HUIAPATTERNOBJECT hobj, int viewId, BSTR * ppStr);
HRESULT WINAPI MultipleViewPattern_SetCurrentView(HUIAPATTERNOBJECT hobj, int viewId);
HRESULT WINAPI RangeValuePattern_SetValue(HUIAPATTERNOBJECT hobj, double val);
HRESULT WINAPI ScrollItemPattern_ScrollIntoView(HUIAPATTERNOBJECT hobj);
HRESULT WINAPI ScrollPattern_Scroll(HUIAPATTERNOBJECT hobj, ScrollAmount horizontalAmount, ScrollAmount verticalAmount);
HRESULT WINAPI ScrollPattern_SetScrollPercent(HUIAPATTERNOBJECT hobj, double horizontalPercent, double verticalPercent);
HRESULT WINAPI SelectionItemPattern_AddToSelection(HUIAPATTERNOBJECT hobj);
HRESULT WINAPI SelectionItemPattern_RemoveFromSelection(HUIAPATTERNOBJECT hobj);
HRESULT WINAPI SelectionItemPattern_Select(HUIAPATTERNOBJECT hobj);
HRESULT WINAPI TogglePattern_Toggle(HUIAPATTERNOBJECT hobj);
HRESULT WINAPI TransformPattern_Move(HUIAPATTERNOBJECT hobj, double x, double y);
HRESULT WINAPI TransformPattern_Resize(HUIAPATTERNOBJECT hobj, double width, double height);
HRESULT WINAPI TransformPattern_Rotate(HUIAPATTERNOBJECT hobj, double degrees);
HRESULT WINAPI ValuePattern_SetValue(HUIAPATTERNOBJECT hobj, LPCWSTR pVal);
HRESULT WINAPI WindowPattern_Close(HUIAPATTERNOBJECT hobj);
HRESULT WINAPI WindowPattern_SetWindowVisualState(HUIAPATTERNOBJECT hobj, WindowVisualState state);
HRESULT WINAPI WindowPattern_WaitForInputIdle(HUIAPATTERNOBJECT hobj, int milliseconds, BOOL * pResult);

HRESULT WINAPI TextPattern_GetSelection(HUIAPATTERNOBJECT hobj, SAFEARRAY** pRetVal);
HRESULT WINAPI TextPattern_GetVisibleRanges(HUIAPATTERNOBJECT hobj, SAFEARRAY** pRetVal);
HRESULT WINAPI TextPattern_RangeFromChild(HUIAPATTERNOBJECT hobj, HUIANODE hnodeChild, HUIATEXTRANGE* pRetVal);
HRESULT WINAPI TextPattern_RangeFromPoint(HUIAPATTERNOBJECT hobj, UiaPoint point, HUIATEXTRANGE* pRetVal);
HRESULT WINAPI TextPattern_get_DocumentRange(HUIAPATTERNOBJECT hobj, HUIATEXTRANGE* pRetVal);
HRESULT WINAPI TextPattern_get_SupportedTextSelection(HUIAPATTERNOBJECT hobj, SupportedTextSelection* pRetVal);
HRESULT WINAPI TextRange_Clone(HUIATEXTRANGE hobj, HUIATEXTRANGE* pRetVal);
HRESULT WINAPI TextRange_Compare(HUIATEXTRANGE hobj, HUIATEXTRANGE range, BOOL* pRetVal);
HRESULT WINAPI TextRange_CompareEndpoints(HUIATEXTRANGE hobj, TextPatternRangeEndpoint endpoint, HUIATEXTRANGE targetRange, TextPatternRangeEndpoint targetEndpoint, int* pRetVal);
HRESULT WINAPI TextRange_ExpandToEnclosingUnit(HUIATEXTRANGE hobj, TextUnit unit);
HRESULT WINAPI TextRange_GetAttributeValue(HUIATEXTRANGE hobj, TEXTATTRIBUTEID attributeId, VARIANT * pRetVal);
HRESULT WINAPI TextRange_FindAttribute(HUIATEXTRANGE hobj, TEXTATTRIBUTEID attributeId, VARIANT val, BOOL backward, HUIATEXTRANGE * pRetVal);
HRESULT WINAPI TextRange_FindText(HUIATEXTRANGE hobj, BSTR text, BOOL backward, BOOL ignoreCase, HUIATEXTRANGE* pRetVal);
HRESULT WINAPI TextRange_GetBoundingRectangles(HUIATEXTRANGE hobj, SAFEARRAY** pRetVal);
HRESULT WINAPI TextRange_GetEnclosingElement(HUIATEXTRANGE hobj, HUIANODE* pRetVal);
HRESULT WINAPI TextRange_GetText(HUIATEXTRANGE hobj, int maxLength, BSTR* pRetVal);
HRESULT WINAPI TextRange_Move(HUIATEXTRANGE hobj, TextUnit unit, int count, int* pRetVal);
HRESULT WINAPI TextRange_MoveEndpointByUnit(HUIATEXTRANGE hobj, TextPatternRangeEndpoint endpoint, TextUnit unit, int count, int* pRetVal);
HRESULT WINAPI TextRange_MoveEndpointByRange(HUIATEXTRANGE hobj, TextPatternRangeEndpoint endpoint, HUIATEXTRANGE targetRange, TextPatternRangeEndpoint targetEndpoint);
HRESULT WINAPI TextRange_Select(HUIATEXTRANGE hobj);
HRESULT WINAPI TextRange_AddToSelection(HUIATEXTRANGE hobj);
HRESULT WINAPI TextRange_RemoveFromSelection(HUIATEXTRANGE hobj);
HRESULT WINAPI TextRange_ScrollIntoView(HUIATEXTRANGE hobj, BOOL alignToTop);
HRESULT WINAPI TextRange_GetChildren(HUIATEXTRANGE hobj, SAFEARRAY** pRetVal);

HRESULT WINAPI ItemContainerPattern_FindItemByProperty(HUIAPATTERNOBJECT hobj, HUIANODE hnodeStartAfter, PROPERTYID propertyId, VARIANT value, HUIANODE *pFound);
HRESULT WINAPI LegacyIAccessiblePattern_Select(HUIAPATTERNOBJECT hobj, long flagsSelect);
HRESULT WINAPI LegacyIAccessiblePattern_DoDefaultAction(HUIAPATTERNOBJECT hobj);
HRESULT WINAPI LegacyIAccessiblePattern_SetValue(HUIAPATTERNOBJECT hobj, LPCWSTR szValue);
HRESULT WINAPI LegacyIAccessiblePattern_GetIAccessible(HUIAPATTERNOBJECT hobj, IAccessible ** pAccessible);
HRESULT WINAPI SynchronizedInputPattern_StartListening(HUIAPATTERNOBJECT hobj, SynchronizedInputType inputType);
HRESULT WINAPI SynchronizedInputPattern_Cancel(HUIAPATTERNOBJECT hobj);
HRESULT WINAPI VirtualizedItemPattern_Realize(HUIAPATTERNOBJECT hobj);

BOOL WINAPI UiaPatternRelease(HUIAPATTERNOBJECT hobj);
BOOL WINAPI UiaTextRangeRelease(HUIATEXTRANGE hobj);


// --------------------------------------------------------------------------
//
// Provider methods
// 
// --------------------------------------------------------------------------

LRESULT WINAPI UiaReturnRawElementProvider(HWND hwnd, WPARAM wParam, LPARAM lParam, IRawElementProviderSimple * el);
HRESULT WINAPI UiaHostProviderFromHwnd(HWND hwnd, IRawElementProviderSimple ** pProvider);

// --------------------------------------------------------------------------
//
// Other APIs...
//
// --------------------------------------------------------------------------

BOOL WINAPI UiaHasServerSideProvider(HWND hwnd);

#ifdef __cplusplus
}
#endif


#endif // !_INC_UIAUTOMATIONCOREAPI
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\UIAutomationCore.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for uiautomationcore.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __uiautomationcore_h__
#define __uiautomationcore_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IRawElementProviderSimple_FWD_DEFINED__
#define __IRawElementProviderSimple_FWD_DEFINED__
typedef interface IRawElementProviderSimple IRawElementProviderSimple;
#endif 	/* __IRawElementProviderSimple_FWD_DEFINED__ */


#ifndef __IAccessibleEx_FWD_DEFINED__
#define __IAccessibleEx_FWD_DEFINED__
typedef interface IAccessibleEx IAccessibleEx;
#endif 	/* __IAccessibleEx_FWD_DEFINED__ */


#ifndef __IRawElementProviderFragmentRoot_FWD_DEFINED__
#define __IRawElementProviderFragmentRoot_FWD_DEFINED__
typedef interface IRawElementProviderFragmentRoot IRawElementProviderFragmentRoot;
#endif 	/* __IRawElementProviderFragmentRoot_FWD_DEFINED__ */


#ifndef __IRawElementProviderFragment_FWD_DEFINED__
#define __IRawElementProviderFragment_FWD_DEFINED__
typedef interface IRawElementProviderFragment IRawElementProviderFragment;
#endif 	/* __IRawElementProviderFragment_FWD_DEFINED__ */


#ifndef __IRawElementProviderAdviseEvents_FWD_DEFINED__
#define __IRawElementProviderAdviseEvents_FWD_DEFINED__
typedef interface IRawElementProviderAdviseEvents IRawElementProviderAdviseEvents;
#endif 	/* __IRawElementProviderAdviseEvents_FWD_DEFINED__ */


#ifndef __IRawElementProviderHwndOverride_FWD_DEFINED__
#define __IRawElementProviderHwndOverride_FWD_DEFINED__
typedef interface IRawElementProviderHwndOverride IRawElementProviderHwndOverride;
#endif 	/* __IRawElementProviderHwndOverride_FWD_DEFINED__ */


#ifndef __IProxyProviderWinEventSink_FWD_DEFINED__
#define __IProxyProviderWinEventSink_FWD_DEFINED__
typedef interface IProxyProviderWinEventSink IProxyProviderWinEventSink;
#endif 	/* __IProxyProviderWinEventSink_FWD_DEFINED__ */


#ifndef __IProxyProviderWinEventHandler_FWD_DEFINED__
#define __IProxyProviderWinEventHandler_FWD_DEFINED__
typedef interface IProxyProviderWinEventHandler IProxyProviderWinEventHandler;
#endif 	/* __IProxyProviderWinEventHandler_FWD_DEFINED__ */


#ifndef __IDockProvider_FWD_DEFINED__
#define __IDockProvider_FWD_DEFINED__
typedef interface IDockProvider IDockProvider;
#endif 	/* __IDockProvider_FWD_DEFINED__ */


#ifndef __IExpandCollapseProvider_FWD_DEFINED__
#define __IExpandCollapseProvider_FWD_DEFINED__
typedef interface IExpandCollapseProvider IExpandCollapseProvider;
#endif 	/* __IExpandCollapseProvider_FWD_DEFINED__ */


#ifndef __IGridProvider_FWD_DEFINED__
#define __IGridProvider_FWD_DEFINED__
typedef interface IGridProvider IGridProvider;
#endif 	/* __IGridProvider_FWD_DEFINED__ */


#ifndef __IGridItemProvider_FWD_DEFINED__
#define __IGridItemProvider_FWD_DEFINED__
typedef interface IGridItemProvider IGridItemProvider;
#endif 	/* __IGridItemProvider_FWD_DEFINED__ */


#ifndef __IInvokeProvider_FWD_DEFINED__
#define __IInvokeProvider_FWD_DEFINED__
typedef interface IInvokeProvider IInvokeProvider;
#endif 	/* __IInvokeProvider_FWD_DEFINED__ */


#ifndef __IMultipleViewProvider_FWD_DEFINED__
#define __IMultipleViewProvider_FWD_DEFINED__
typedef interface IMultipleViewProvider IMultipleViewProvider;
#endif 	/* __IMultipleViewProvider_FWD_DEFINED__ */


#ifndef __IRangeValueProvider_FWD_DEFINED__
#define __IRangeValueProvider_FWD_DEFINED__
typedef interface IRangeValueProvider IRangeValueProvider;
#endif 	/* __IRangeValueProvider_FWD_DEFINED__ */


#ifndef __IScrollItemProvider_FWD_DEFINED__
#define __IScrollItemProvider_FWD_DEFINED__
typedef interface IScrollItemProvider IScrollItemProvider;
#endif 	/* __IScrollItemProvider_FWD_DEFINED__ */


#ifndef __ISelectionProvider_FWD_DEFINED__
#define __ISelectionProvider_FWD_DEFINED__
typedef interface ISelectionProvider ISelectionProvider;
#endif 	/* __ISelectionProvider_FWD_DEFINED__ */


#ifndef __IScrollProvider_FWD_DEFINED__
#define __IScrollProvider_FWD_DEFINED__
typedef interface IScrollProvider IScrollProvider;
#endif 	/* __IScrollProvider_FWD_DEFINED__ */


#ifndef __ISelectionItemProvider_FWD_DEFINED__
#define __ISelectionItemProvider_FWD_DEFINED__
typedef interface ISelectionItemProvider ISelectionItemProvider;
#endif 	/* __ISelectionItemProvider_FWD_DEFINED__ */


#ifndef __ISynchronizedInputProvider_FWD_DEFINED__
#define __ISynchronizedInputProvider_FWD_DEFINED__
typedef interface ISynchronizedInputProvider ISynchronizedInputProvider;
#endif 	/* __ISynchronizedInputProvider_FWD_DEFINED__ */


#ifndef __ITableProvider_FWD_DEFINED__
#define __ITableProvider_FWD_DEFINED__
typedef interface ITableProvider ITableProvider;
#endif 	/* __ITableProvider_FWD_DEFINED__ */


#ifndef __ITableItemProvider_FWD_DEFINED__
#define __ITableItemProvider_FWD_DEFINED__
typedef interface ITableItemProvider ITableItemProvider;
#endif 	/* __ITableItemProvider_FWD_DEFINED__ */


#ifndef __IToggleProvider_FWD_DEFINED__
#define __IToggleProvider_FWD_DEFINED__
typedef interface IToggleProvider IToggleProvider;
#endif 	/* __IToggleProvider_FWD_DEFINED__ */


#ifndef __ITransformProvider_FWD_DEFINED__
#define __ITransformProvider_FWD_DEFINED__
typedef interface ITransformProvider ITransformProvider;
#endif 	/* __ITransformProvider_FWD_DEFINED__ */


#ifndef __IValueProvider_FWD_DEFINED__
#define __IValueProvider_FWD_DEFINED__
typedef interface IValueProvider IValueProvider;
#endif 	/* __IValueProvider_FWD_DEFINED__ */


#ifndef __IWindowProvider_FWD_DEFINED__
#define __IWindowProvider_FWD_DEFINED__
typedef interface IWindowProvider IWindowProvider;
#endif 	/* __IWindowProvider_FWD_DEFINED__ */


#ifndef __ILegacyIAccessibleProvider_FWD_DEFINED__
#define __ILegacyIAccessibleProvider_FWD_DEFINED__
typedef interface ILegacyIAccessibleProvider ILegacyIAccessibleProvider;
#endif 	/* __ILegacyIAccessibleProvider_FWD_DEFINED__ */


#ifndef __IItemContainerProvider_FWD_DEFINED__
#define __IItemContainerProvider_FWD_DEFINED__
typedef interface IItemContainerProvider IItemContainerProvider;
#endif 	/* __IItemContainerProvider_FWD_DEFINED__ */


#ifndef __IVirtualizedItemProvider_FWD_DEFINED__
#define __IVirtualizedItemProvider_FWD_DEFINED__
typedef interface IVirtualizedItemProvider IVirtualizedItemProvider;
#endif 	/* __IVirtualizedItemProvider_FWD_DEFINED__ */


#ifndef __ITextRangeProvider_FWD_DEFINED__
#define __ITextRangeProvider_FWD_DEFINED__
typedef interface ITextRangeProvider ITextRangeProvider;
#endif 	/* __ITextRangeProvider_FWD_DEFINED__ */


#ifndef __ITextProvider_FWD_DEFINED__
#define __ITextProvider_FWD_DEFINED__
typedef interface ITextProvider ITextProvider;
#endif 	/* __ITextProvider_FWD_DEFINED__ */


#ifndef __IUIAutomationPatternInstance_FWD_DEFINED__
#define __IUIAutomationPatternInstance_FWD_DEFINED__
typedef interface IUIAutomationPatternInstance IUIAutomationPatternInstance;
#endif 	/* __IUIAutomationPatternInstance_FWD_DEFINED__ */


#ifndef __IUIAutomationPatternHandler_FWD_DEFINED__
#define __IUIAutomationPatternHandler_FWD_DEFINED__
typedef interface IUIAutomationPatternHandler IUIAutomationPatternHandler;
#endif 	/* __IUIAutomationPatternHandler_FWD_DEFINED__ */


#ifndef __IUIAutomationRegistrar_FWD_DEFINED__
#define __IUIAutomationRegistrar_FWD_DEFINED__
typedef interface IUIAutomationRegistrar IUIAutomationRegistrar;
#endif 	/* __IUIAutomationRegistrar_FWD_DEFINED__ */


#ifndef __CUIAutomationRegistrar_FWD_DEFINED__
#define __CUIAutomationRegistrar_FWD_DEFINED__

#ifdef __cplusplus
typedef class CUIAutomationRegistrar CUIAutomationRegistrar;
#else
typedef struct CUIAutomationRegistrar CUIAutomationRegistrar;
#endif /* __cplusplus */

#endif 	/* __CUIAutomationRegistrar_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "oleacc.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_uiautomationcore_0000_0000 */
/* [local] */ 

// -------------------------------------------------------------
// UIAutomationCore.H
//
// UIAutomation interface definitions and related types and enums
// (Generated from UIAutomationCore.idl)
//
// Copyright (c) Microsoft Corporation. All rights reserved.
// -------------------------------------------------------------

enum NavigateDirection
    {	NavigateDirection_Parent	= 0,
	NavigateDirection_NextSibling	= 1,
	NavigateDirection_PreviousSibling	= 2,
	NavigateDirection_FirstChild	= 3,
	NavigateDirection_LastChild	= 4
    } ;

enum ProviderOptions
    {	ProviderOptions_ClientSideProvider	= 0x1,
	ProviderOptions_ServerSideProvider	= 0x2,
	ProviderOptions_NonClientAreaProvider	= 0x4,
	ProviderOptions_OverrideProvider	= 0x8,
	ProviderOptions_ProviderOwnsSetFocus	= 0x10,
	ProviderOptions_UseComThreading	= 0x20
    } ;
DEFINE_ENUM_FLAG_OPERATORS(ProviderOptions)

enum StructureChangeType
    {	StructureChangeType_ChildAdded	= 0,
	StructureChangeType_ChildRemoved	= ( StructureChangeType_ChildAdded + 1 ) ,
	StructureChangeType_ChildrenInvalidated	= ( StructureChangeType_ChildRemoved + 1 ) ,
	StructureChangeType_ChildrenBulkAdded	= ( StructureChangeType_ChildrenInvalidated + 1 ) ,
	StructureChangeType_ChildrenBulkRemoved	= ( StructureChangeType_ChildrenBulkAdded + 1 ) ,
	StructureChangeType_ChildrenReordered	= ( StructureChangeType_ChildrenBulkRemoved + 1 ) 
    } ;

enum OrientationType
    {	OrientationType_None	= 0,
	OrientationType_Horizontal	= 1,
	OrientationType_Vertical	= 2
    } ;

enum DockPosition
    {	DockPosition_Top	= 0,
	DockPosition_Left	= 1,
	DockPosition_Bottom	= 2,
	DockPosition_Right	= 3,
	DockPosition_Fill	= 4,
	DockPosition_None	= 5
    } ;

enum ExpandCollapseState
    {	ExpandCollapseState_Collapsed	= 0,
	ExpandCollapseState_Expanded	= 1,
	ExpandCollapseState_PartiallyExpanded	= 2,
	ExpandCollapseState_LeafNode	= 3
    } ;

enum ScrollAmount
    {	ScrollAmount_LargeDecrement	= 0,
	ScrollAmount_SmallDecrement	= 1,
	ScrollAmount_NoAmount	= 2,
	ScrollAmount_LargeIncrement	= 3,
	ScrollAmount_SmallIncrement	= 4
    } ;

enum RowOrColumnMajor
    {	RowOrColumnMajor_RowMajor	= 0,
	RowOrColumnMajor_ColumnMajor	= 1,
	RowOrColumnMajor_Indeterminate	= 2
    } ;

enum ToggleState
    {	ToggleState_Off	= 0,
	ToggleState_On	= 1,
	ToggleState_Indeterminate	= 2
    } ;

enum WindowVisualState
    {	WindowVisualState_Normal	= 0,
	WindowVisualState_Maximized	= 1,
	WindowVisualState_Minimized	= 2
    } ;

enum SynchronizedInputType
    {	SynchronizedInputType_KeyUp	= 0x1,
	SynchronizedInputType_KeyDown	= 0x2,
	SynchronizedInputType_LeftMouseUp	= 0x4,
	SynchronizedInputType_LeftMouseDown	= 0x8,
	SynchronizedInputType_RightMouseUp	= 0x10,
	SynchronizedInputType_RightMouseDown	= 0x20
    } ;
DEFINE_ENUM_FLAG_OPERATORS(SynchronizedInputType)

enum WindowInteractionState
    {	WindowInteractionState_Running	= 0,
	WindowInteractionState_Closing	= 1,
	WindowInteractionState_ReadyForUserInteraction	= 2,
	WindowInteractionState_BlockedByModalWindow	= 3,
	WindowInteractionState_NotResponding	= 4
    } ;

enum TextUnit
    {	TextUnit_Character	= 0,
	TextUnit_Format	= 1,
	TextUnit_Word	= 2,
	TextUnit_Line	= 3,
	TextUnit_Paragraph	= 4,
	TextUnit_Page	= 5,
	TextUnit_Document	= 6
    } ;

enum TextPatternRangeEndpoint
    {	TextPatternRangeEndpoint_Start	= 0,
	TextPatternRangeEndpoint_End	= 1
    } ;

enum SupportedTextSelection
    {	SupportedTextSelection_None	= 0,
	SupportedTextSelection_Single	= 1,
	SupportedTextSelection_Multiple	= 2
    } ;

enum AnimationStyle
    {	AnimationStyle_None	= 0,
	AnimationStyle_LasVegasLights	= 1,
	AnimationStyle_BlinkingBackground	= 2,
	AnimationStyle_SparkleText	= 3,
	AnimationStyle_MarchingBlackAnts	= 4,
	AnimationStyle_MarchingRedAnts	= 5,
	AnimationStyle_Shimmer	= 6,
	AnimationStyle_Other	= -1
    } ;

enum BulletStyle
    {	BulletStyle_None	= 0,
	BulletStyle_HollowRoundBullet	= 1,
	BulletStyle_FilledRoundBullet	= 2,
	BulletStyle_HollowSquareBullet	= 3,
	BulletStyle_FilledSquareBullet	= 4,
	BulletStyle_DashBullet	= 5,
	BulletStyle_Other	= -1
    } ;

enum CapStyle
    {	CapStyle_None	= 0,
	CapStyle_SmallCap	= 1,
	CapStyle_AllCap	= 2,
	CapStyle_AllPetiteCaps	= 3,
	CapStyle_PetiteCaps	= 4,
	CapStyle_Unicase	= 5,
	CapStyle_Titling	= 6,
	CapStyle_Other	= -1
    } ;

enum FlowDirections
    {	FlowDirections_Default	= 0,
	FlowDirections_RightToLeft	= 1,
	FlowDirections_BottomToTop	= 2,
	FlowDirections_Vertical	= 4
    } ;

enum HorizontalTextAlignment
    {	HorizontalTextAlignment_Left	= 0,
	HorizontalTextAlignment_Centered	= 1,
	HorizontalTextAlignment_Right	= 2,
	HorizontalTextAlignment_Justified	= 3
    } ;

enum OutlineStyles
    {	OutlineStyles_None	= 0,
	OutlineStyles_Outline	= 1,
	OutlineStyles_Shadow	= 2,
	OutlineStyles_Engraved	= 4,
	OutlineStyles_Embossed	= 8
    } ;

enum TextDecorationLineStyle
    {	TextDecorationLineStyle_None	= 0,
	TextDecorationLineStyle_Single	= 1,
	TextDecorationLineStyle_WordsOnly	= 2,
	TextDecorationLineStyle_Double	= 3,
	TextDecorationLineStyle_Dot	= 4,
	TextDecorationLineStyle_Dash	= 5,
	TextDecorationLineStyle_DashDot	= 6,
	TextDecorationLineStyle_DashDotDot	= 7,
	TextDecorationLineStyle_Wavy	= 8,
	TextDecorationLineStyle_ThickSingle	= 9,
	TextDecorationLineStyle_DoubleWavy	= 11,
	TextDecorationLineStyle_ThickWavy	= 12,
	TextDecorationLineStyle_LongDash	= 13,
	TextDecorationLineStyle_ThickDash	= 14,
	TextDecorationLineStyle_ThickDashDot	= 15,
	TextDecorationLineStyle_ThickDashDotDot	= 16,
	TextDecorationLineStyle_ThickDot	= 17,
	TextDecorationLineStyle_ThickLongDash	= 18,
	TextDecorationLineStyle_Other	= -1
    } ;
typedef int PROPERTYID;

typedef int PATTERNID;

typedef int EVENTID;

typedef int TEXTATTRIBUTEID;

typedef int CONTROLTYPEID;

struct UiaRect
    {
    double left;
    double top;
    double width;
    double height;
    } ;
struct UiaPoint
    {
    double x;
    double y;
    } ;


extern RPC_IF_HANDLE __MIDL_itf_uiautomationcore_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_uiautomationcore_0000_0000_v0_0_s_ifspec;


#ifndef __UIA_LIBRARY_DEFINED__
#define __UIA_LIBRARY_DEFINED__

/* library UIA */
/* [hidden][version][lcid][uuid] */ 




enum UIAutomationType
    {	UIAutomationType_Int	= 0x1,
	UIAutomationType_Bool	= 0x2,
	UIAutomationType_String	= 0x3,
	UIAutomationType_Double	= 0x4,
	UIAutomationType_Point	= 0x5,
	UIAutomationType_Rect	= 0x6,
	UIAutomationType_Element	= 0x7,
	UIAutomationType_Array	= 0x10000,
	UIAutomationType_Out	= 0x20000,
	UIAutomationType_IntArray	= ( UIAutomationType_Int | UIAutomationType_Array ) ,
	UIAutomationType_BoolArray	= ( UIAutomationType_Bool | UIAutomationType_Array ) ,
	UIAutomationType_StringArray	= ( UIAutomationType_String | UIAutomationType_Array ) ,
	UIAutomationType_DoubleArray	= ( UIAutomationType_Double | UIAutomationType_Array ) ,
	UIAutomationType_PointArray	= ( UIAutomationType_Point | UIAutomationType_Array ) ,
	UIAutomationType_RectArray	= ( UIAutomationType_Rect | UIAutomationType_Array ) ,
	UIAutomationType_ElementArray	= ( UIAutomationType_Element | UIAutomationType_Array ) ,
	UIAutomationType_OutInt	= ( UIAutomationType_Int | UIAutomationType_Out ) ,
	UIAutomationType_OutBool	= ( UIAutomationType_Bool | UIAutomationType_Out ) ,
	UIAutomationType_OutString	= ( UIAutomationType_String | UIAutomationType_Out ) ,
	UIAutomationType_OutDouble	= ( UIAutomationType_Double | UIAutomationType_Out ) ,
	UIAutomationType_OutPoint	= ( UIAutomationType_Point | UIAutomationType_Out ) ,
	UIAutomationType_OutRect	= ( UIAutomationType_Rect | UIAutomationType_Out ) ,
	UIAutomationType_OutElement	= ( UIAutomationType_Element | UIAutomationType_Out ) ,
	UIAutomationType_OutIntArray	= ( ( UIAutomationType_Int | UIAutomationType_Array )  | UIAutomationType_Out ) ,
	UIAutomationType_OutBoolArray	= ( ( UIAutomationType_Bool | UIAutomationType_Array )  | UIAutomationType_Out ) ,
	UIAutomationType_OutStringArray	= ( ( UIAutomationType_String | UIAutomationType_Array )  | UIAutomationType_Out ) ,
	UIAutomationType_OutDoubleArray	= ( ( UIAutomationType_Double | UIAutomationType_Array )  | UIAutomationType_Out ) ,
	UIAutomationType_OutPointArray	= ( ( UIAutomationType_Point | UIAutomationType_Array )  | UIAutomationType_Out ) ,
	UIAutomationType_OutRectArray	= ( ( UIAutomationType_Rect | UIAutomationType_Array )  | UIAutomationType_Out ) ,
	UIAutomationType_OutElementArray	= ( ( UIAutomationType_Element | UIAutomationType_Array )  | UIAutomationType_Out ) 
    } ;
DEFINE_ENUM_FLAG_OPERATORS(UIAutomationType)
struct UIAutomationParameter
    {
    enum UIAutomationType type;
    void *pData;
    } ;
struct UIAutomationPropertyInfo
    {
    GUID guid;
    LPCWSTR pProgrammaticName;
    enum UIAutomationType type;
    } ;
struct UIAutomationEventInfo
    {
    GUID guid;
    LPCWSTR pProgrammaticName;
    } ;
struct UIAutomationMethodInfo
    {
    LPCWSTR pProgrammaticName;
    BOOL doSetFocus;
    UINT cInParameters;
    UINT cOutParameters;
    enum UIAutomationType *pParameterTypes;
    LPCWSTR *pParameterNames;
    } ;
struct UIAutomationPatternInfo
    {
    GUID guid;
    LPCWSTR pProgrammaticName;
    GUID providerInterfaceId;
    GUID clientInterfaceId;
    UINT cProperties;
    struct UIAutomationPropertyInfo *pProperties;
    UINT cMethods;
    struct UIAutomationMethodInfo *pMethods;
    UINT cEvents;
    struct UIAutomationEventInfo *pEvents;
    IUIAutomationPatternHandler *pPatternHandler;
    } ;

EXTERN_C const IID LIBID_UIA;


#ifndef __UIA_OtherConstants_MODULE_DEFINED__
#define __UIA_OtherConstants_MODULE_DEFINED__


/* module UIA_OtherConstants */
/* [dllname] */ 

const double UIA_ScrollPatternNoScroll	=	-1;

#endif /* __UIA_OtherConstants_MODULE_DEFINED__ */

#ifndef __IRawElementProviderSimple_INTERFACE_DEFINED__
#define __IRawElementProviderSimple_INTERFACE_DEFINED__

/* interface IRawElementProviderSimple */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IRawElementProviderSimple;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d6dd68d1-86fd-4332-8666-9abedea2d24c")
    IRawElementProviderSimple : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ProviderOptions( 
            /* [retval][out] */ __RPC__out enum ProviderOptions *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPatternProvider( 
            /* [in] */ PATTERNID patternId,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyValue( 
            /* [in] */ PROPERTYID propertyId,
            /* [retval][out] */ __RPC__out VARIANT *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_HostRawElementProvider( 
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderSimple **pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRawElementProviderSimpleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRawElementProviderSimple * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRawElementProviderSimple * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRawElementProviderSimple * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProviderOptions )( 
            __RPC__in IRawElementProviderSimple * This,
            /* [retval][out] */ __RPC__out enum ProviderOptions *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetPatternProvider )( 
            __RPC__in IRawElementProviderSimple * This,
            /* [in] */ PATTERNID patternId,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyValue )( 
            __RPC__in IRawElementProviderSimple * This,
            /* [in] */ PROPERTYID propertyId,
            /* [retval][out] */ __RPC__out VARIANT *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HostRawElementProvider )( 
            __RPC__in IRawElementProviderSimple * This,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderSimple **pRetVal);
        
        END_INTERFACE
    } IRawElementProviderSimpleVtbl;

    interface IRawElementProviderSimple
    {
        CONST_VTBL struct IRawElementProviderSimpleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRawElementProviderSimple_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRawElementProviderSimple_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRawElementProviderSimple_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRawElementProviderSimple_get_ProviderOptions(This,pRetVal)	\
    ( (This)->lpVtbl -> get_ProviderOptions(This,pRetVal) ) 

#define IRawElementProviderSimple_GetPatternProvider(This,patternId,pRetVal)	\
    ( (This)->lpVtbl -> GetPatternProvider(This,patternId,pRetVal) ) 

#define IRawElementProviderSimple_GetPropertyValue(This,propertyId,pRetVal)	\
    ( (This)->lpVtbl -> GetPropertyValue(This,propertyId,pRetVal) ) 

#define IRawElementProviderSimple_get_HostRawElementProvider(This,pRetVal)	\
    ( (This)->lpVtbl -> get_HostRawElementProvider(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRawElementProviderSimple_INTERFACE_DEFINED__ */


#ifndef __IAccessibleEx_INTERFACE_DEFINED__
#define __IAccessibleEx_INTERFACE_DEFINED__

/* interface IAccessibleEx */
/* [oleautomation][unique][uuid][object] */ 


EXTERN_C const IID IID_IAccessibleEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f8b80ada-2c44-48d0-89be-5ff23c9cd875")
    IAccessibleEx : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetObjectForChild( 
            /* [in] */ long idChild,
            /* [retval][out] */ __RPC__deref_out_opt IAccessibleEx **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIAccessiblePair( 
            /* [out] */ __RPC__deref_out_opt IAccessible **ppAcc,
            /* [out] */ __RPC__out long *pidChild) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRuntimeId( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertReturnedElement( 
            /* [in] */ __RPC__in_opt IRawElementProviderSimple *pIn,
            /* [out] */ __RPC__deref_out_opt IAccessibleEx **ppRetValOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAccessibleExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IAccessibleEx * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IAccessibleEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IAccessibleEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectForChild )( 
            __RPC__in IAccessibleEx * This,
            /* [in] */ long idChild,
            /* [retval][out] */ __RPC__deref_out_opt IAccessibleEx **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetIAccessiblePair )( 
            __RPC__in IAccessibleEx * This,
            /* [out] */ __RPC__deref_out_opt IAccessible **ppAcc,
            /* [out] */ __RPC__out long *pidChild);
        
        HRESULT ( STDMETHODCALLTYPE *GetRuntimeId )( 
            __RPC__in IAccessibleEx * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertReturnedElement )( 
            __RPC__in IAccessibleEx * This,
            /* [in] */ __RPC__in_opt IRawElementProviderSimple *pIn,
            /* [out] */ __RPC__deref_out_opt IAccessibleEx **ppRetValOut);
        
        END_INTERFACE
    } IAccessibleExVtbl;

    interface IAccessibleEx
    {
        CONST_VTBL struct IAccessibleExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAccessibleEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAccessibleEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAccessibleEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAccessibleEx_GetObjectForChild(This,idChild,pRetVal)	\
    ( (This)->lpVtbl -> GetObjectForChild(This,idChild,pRetVal) ) 

#define IAccessibleEx_GetIAccessiblePair(This,ppAcc,pidChild)	\
    ( (This)->lpVtbl -> GetIAccessiblePair(This,ppAcc,pidChild) ) 

#define IAccessibleEx_GetRuntimeId(This,pRetVal)	\
    ( (This)->lpVtbl -> GetRuntimeId(This,pRetVal) ) 

#define IAccessibleEx_ConvertReturnedElement(This,pIn,ppRetValOut)	\
    ( (This)->lpVtbl -> ConvertReturnedElement(This,pIn,ppRetValOut) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAccessibleEx_INTERFACE_DEFINED__ */


#ifndef __IRawElementProviderFragmentRoot_INTERFACE_DEFINED__
#define __IRawElementProviderFragmentRoot_INTERFACE_DEFINED__

/* interface IRawElementProviderFragmentRoot */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IRawElementProviderFragmentRoot;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("620ce2a5-ab8f-40a9-86cb-de3c75599b58")
    IRawElementProviderFragmentRoot : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ElementProviderFromPoint( 
            /* [in] */ double x,
            /* [in] */ double y,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderFragment **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFocus( 
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderFragment **pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRawElementProviderFragmentRootVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRawElementProviderFragmentRoot * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRawElementProviderFragmentRoot * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRawElementProviderFragmentRoot * This);
        
        HRESULT ( STDMETHODCALLTYPE *ElementProviderFromPoint )( 
            __RPC__in IRawElementProviderFragmentRoot * This,
            /* [in] */ double x,
            /* [in] */ double y,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderFragment **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetFocus )( 
            __RPC__in IRawElementProviderFragmentRoot * This,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderFragment **pRetVal);
        
        END_INTERFACE
    } IRawElementProviderFragmentRootVtbl;

    interface IRawElementProviderFragmentRoot
    {
        CONST_VTBL struct IRawElementProviderFragmentRootVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRawElementProviderFragmentRoot_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRawElementProviderFragmentRoot_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRawElementProviderFragmentRoot_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRawElementProviderFragmentRoot_ElementProviderFromPoint(This,x,y,pRetVal)	\
    ( (This)->lpVtbl -> ElementProviderFromPoint(This,x,y,pRetVal) ) 

#define IRawElementProviderFragmentRoot_GetFocus(This,pRetVal)	\
    ( (This)->lpVtbl -> GetFocus(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRawElementProviderFragmentRoot_INTERFACE_DEFINED__ */


#ifndef __IRawElementProviderFragment_INTERFACE_DEFINED__
#define __IRawElementProviderFragment_INTERFACE_DEFINED__

/* interface IRawElementProviderFragment */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IRawElementProviderFragment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f7063da8-8359-439c-9297-bbc5299a7d87")
    IRawElementProviderFragment : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Navigate( 
            /* [in] */ enum NavigateDirection direction,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderFragment **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRuntimeId( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_BoundingRectangle( 
            /* [retval][out] */ __RPC__out struct UiaRect *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEmbeddedFragmentRoots( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFocus( void) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FragmentRoot( 
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderFragmentRoot **pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRawElementProviderFragmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRawElementProviderFragment * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRawElementProviderFragment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRawElementProviderFragment * This);
        
        HRESULT ( STDMETHODCALLTYPE *Navigate )( 
            __RPC__in IRawElementProviderFragment * This,
            /* [in] */ enum NavigateDirection direction,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderFragment **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRuntimeId )( 
            __RPC__in IRawElementProviderFragment * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *get_BoundingRectangle )( 
            __RPC__in IRawElementProviderFragment * This,
            /* [retval][out] */ __RPC__out struct UiaRect *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetEmbeddedFragmentRoots )( 
            __RPC__in IRawElementProviderFragment * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *SetFocus )( 
            __RPC__in IRawElementProviderFragment * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_FragmentRoot )( 
            __RPC__in IRawElementProviderFragment * This,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderFragmentRoot **pRetVal);
        
        END_INTERFACE
    } IRawElementProviderFragmentVtbl;

    interface IRawElementProviderFragment
    {
        CONST_VTBL struct IRawElementProviderFragmentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRawElementProviderFragment_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRawElementProviderFragment_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRawElementProviderFragment_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRawElementProviderFragment_Navigate(This,direction,pRetVal)	\
    ( (This)->lpVtbl -> Navigate(This,direction,pRetVal) ) 

#define IRawElementProviderFragment_GetRuntimeId(This,pRetVal)	\
    ( (This)->lpVtbl -> GetRuntimeId(This,pRetVal) ) 

#define IRawElementProviderFragment_get_BoundingRectangle(This,pRetVal)	\
    ( (This)->lpVtbl -> get_BoundingRectangle(This,pRetVal) ) 

#define IRawElementProviderFragment_GetEmbeddedFragmentRoots(This,pRetVal)	\
    ( (This)->lpVtbl -> GetEmbeddedFragmentRoots(This,pRetVal) ) 

#define IRawElementProviderFragment_SetFocus(This)	\
    ( (This)->lpVtbl -> SetFocus(This) ) 

#define IRawElementProviderFragment_get_FragmentRoot(This,pRetVal)	\
    ( (This)->lpVtbl -> get_FragmentRoot(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRawElementProviderFragment_INTERFACE_DEFINED__ */


#ifndef __IRawElementProviderAdviseEvents_INTERFACE_DEFINED__
#define __IRawElementProviderAdviseEvents_INTERFACE_DEFINED__

/* interface IRawElementProviderAdviseEvents */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IRawElementProviderAdviseEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a407b27b-0f6d-4427-9292-473c7bf93258")
    IRawElementProviderAdviseEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseEventAdded( 
            /* [in] */ EVENTID eventId,
            /* [in] */ __RPC__in SAFEARRAY * propertyIDs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AdviseEventRemoved( 
            /* [in] */ EVENTID eventId,
            /* [in] */ __RPC__in SAFEARRAY * propertyIDs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRawElementProviderAdviseEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRawElementProviderAdviseEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRawElementProviderAdviseEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRawElementProviderAdviseEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseEventAdded )( 
            __RPC__in IRawElementProviderAdviseEvents * This,
            /* [in] */ EVENTID eventId,
            /* [in] */ __RPC__in SAFEARRAY * propertyIDs);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseEventRemoved )( 
            __RPC__in IRawElementProviderAdviseEvents * This,
            /* [in] */ EVENTID eventId,
            /* [in] */ __RPC__in SAFEARRAY * propertyIDs);
        
        END_INTERFACE
    } IRawElementProviderAdviseEventsVtbl;

    interface IRawElementProviderAdviseEvents
    {
        CONST_VTBL struct IRawElementProviderAdviseEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRawElementProviderAdviseEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRawElementProviderAdviseEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRawElementProviderAdviseEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRawElementProviderAdviseEvents_AdviseEventAdded(This,eventId,propertyIDs)	\
    ( (This)->lpVtbl -> AdviseEventAdded(This,eventId,propertyIDs) ) 

#define IRawElementProviderAdviseEvents_AdviseEventRemoved(This,eventId,propertyIDs)	\
    ( (This)->lpVtbl -> AdviseEventRemoved(This,eventId,propertyIDs) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRawElementProviderAdviseEvents_INTERFACE_DEFINED__ */


#ifndef __IRawElementProviderHwndOverride_INTERFACE_DEFINED__
#define __IRawElementProviderHwndOverride_INTERFACE_DEFINED__

/* interface IRawElementProviderHwndOverride */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IRawElementProviderHwndOverride;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1d5df27c-8947-4425-b8d9-79787bb460b8")
    IRawElementProviderHwndOverride : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOverrideProviderForHwnd( 
            /* [in] */ __RPC__in HWND hwnd,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderSimple **pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRawElementProviderHwndOverrideVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRawElementProviderHwndOverride * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRawElementProviderHwndOverride * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRawElementProviderHwndOverride * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOverrideProviderForHwnd )( 
            __RPC__in IRawElementProviderHwndOverride * This,
            /* [in] */ __RPC__in HWND hwnd,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderSimple **pRetVal);
        
        END_INTERFACE
    } IRawElementProviderHwndOverrideVtbl;

    interface IRawElementProviderHwndOverride
    {
        CONST_VTBL struct IRawElementProviderHwndOverrideVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRawElementProviderHwndOverride_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRawElementProviderHwndOverride_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRawElementProviderHwndOverride_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRawElementProviderHwndOverride_GetOverrideProviderForHwnd(This,hwnd,pRetVal)	\
    ( (This)->lpVtbl -> GetOverrideProviderForHwnd(This,hwnd,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRawElementProviderHwndOverride_INTERFACE_DEFINED__ */


#ifndef __IProxyProviderWinEventSink_INTERFACE_DEFINED__
#define __IProxyProviderWinEventSink_INTERFACE_DEFINED__

/* interface IProxyProviderWinEventSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IProxyProviderWinEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4fd82b78-a43e-46ac-9803-0a6969c7c183")
    IProxyProviderWinEventSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddAutomationPropertyChangedEvent( 
            /* [in] */ __RPC__in_opt IRawElementProviderSimple *pProvider,
            /* [in] */ PROPERTYID id,
            /* [in] */ VARIANT newValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddAutomationEvent( 
            /* [in] */ __RPC__in_opt IRawElementProviderSimple *pProvider,
            /* [in] */ EVENTID id) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStructureChangedEvent( 
            /* [in] */ __RPC__in_opt IRawElementProviderSimple *pProvider,
            /* [in] */ enum StructureChangeType structureChangeType,
            /* [in] */ __RPC__in SAFEARRAY * runtimeId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProxyProviderWinEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IProxyProviderWinEventSink * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IProxyProviderWinEventSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IProxyProviderWinEventSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddAutomationPropertyChangedEvent )( 
            __RPC__in IProxyProviderWinEventSink * This,
            /* [in] */ __RPC__in_opt IRawElementProviderSimple *pProvider,
            /* [in] */ PROPERTYID id,
            /* [in] */ VARIANT newValue);
        
        HRESULT ( STDMETHODCALLTYPE *AddAutomationEvent )( 
            __RPC__in IProxyProviderWinEventSink * This,
            /* [in] */ __RPC__in_opt IRawElementProviderSimple *pProvider,
            /* [in] */ EVENTID id);
        
        HRESULT ( STDMETHODCALLTYPE *AddStructureChangedEvent )( 
            __RPC__in IProxyProviderWinEventSink * This,
            /* [in] */ __RPC__in_opt IRawElementProviderSimple *pProvider,
            /* [in] */ enum StructureChangeType structureChangeType,
            /* [in] */ __RPC__in SAFEARRAY * runtimeId);
        
        END_INTERFACE
    } IProxyProviderWinEventSinkVtbl;

    interface IProxyProviderWinEventSink
    {
        CONST_VTBL struct IProxyProviderWinEventSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProxyProviderWinEventSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IProxyProviderWinEventSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IProxyProviderWinEventSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IProxyProviderWinEventSink_AddAutomationPropertyChangedEvent(This,pProvider,id,newValue)	\
    ( (This)->lpVtbl -> AddAutomationPropertyChangedEvent(This,pProvider,id,newValue) ) 

#define IProxyProviderWinEventSink_AddAutomationEvent(This,pProvider,id)	\
    ( (This)->lpVtbl -> AddAutomationEvent(This,pProvider,id) ) 

#define IProxyProviderWinEventSink_AddStructureChangedEvent(This,pProvider,structureChangeType,runtimeId)	\
    ( (This)->lpVtbl -> AddStructureChangedEvent(This,pProvider,structureChangeType,runtimeId) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IProxyProviderWinEventSink_INTERFACE_DEFINED__ */


#ifndef __IProxyProviderWinEventHandler_INTERFACE_DEFINED__
#define __IProxyProviderWinEventHandler_INTERFACE_DEFINED__

/* interface IProxyProviderWinEventHandler */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IProxyProviderWinEventHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("89592ad4-f4e0-43d5-a3b6-bad7e111b435")
    IProxyProviderWinEventHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RespondToWinEvent( 
            /* [in] */ DWORD idWinEvent,
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ LONG idObject,
            /* [in] */ LONG idChild,
            /* [in] */ __RPC__in_opt IProxyProviderWinEventSink *pSink) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProxyProviderWinEventHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IProxyProviderWinEventHandler * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IProxyProviderWinEventHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IProxyProviderWinEventHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *RespondToWinEvent )( 
            __RPC__in IProxyProviderWinEventHandler * This,
            /* [in] */ DWORD idWinEvent,
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ LONG idObject,
            /* [in] */ LONG idChild,
            /* [in] */ __RPC__in_opt IProxyProviderWinEventSink *pSink);
        
        END_INTERFACE
    } IProxyProviderWinEventHandlerVtbl;

    interface IProxyProviderWinEventHandler
    {
        CONST_VTBL struct IProxyProviderWinEventHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProxyProviderWinEventHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IProxyProviderWinEventHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IProxyProviderWinEventHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IProxyProviderWinEventHandler_RespondToWinEvent(This,idWinEvent,hwnd,idObject,idChild,pSink)	\
    ( (This)->lpVtbl -> RespondToWinEvent(This,idWinEvent,hwnd,idObject,idChild,pSink) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IProxyProviderWinEventHandler_INTERFACE_DEFINED__ */


#ifndef __IDockProvider_INTERFACE_DEFINED__
#define __IDockProvider_INTERFACE_DEFINED__

/* interface IDockProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDockProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("159bc72c-4ad3-485e-9637-d7052edf0146")
    IDockProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDockPosition( 
            /* [in] */ enum DockPosition dockPosition) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DockPosition( 
            /* [retval][out] */ __RPC__out enum DockPosition *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDockProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDockProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDockProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDockProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDockPosition )( 
            __RPC__in IDockProvider * This,
            /* [in] */ enum DockPosition dockPosition);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DockPosition )( 
            __RPC__in IDockProvider * This,
            /* [retval][out] */ __RPC__out enum DockPosition *pRetVal);
        
        END_INTERFACE
    } IDockProviderVtbl;

    interface IDockProvider
    {
        CONST_VTBL struct IDockProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDockProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDockProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDockProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDockProvider_SetDockPosition(This,dockPosition)	\
    ( (This)->lpVtbl -> SetDockPosition(This,dockPosition) ) 

#define IDockProvider_get_DockPosition(This,pRetVal)	\
    ( (This)->lpVtbl -> get_DockPosition(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDockProvider_INTERFACE_DEFINED__ */


#ifndef __IExpandCollapseProvider_INTERFACE_DEFINED__
#define __IExpandCollapseProvider_INTERFACE_DEFINED__

/* interface IExpandCollapseProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IExpandCollapseProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d847d3a5-cab0-4a98-8c32-ecb45c59ad24")
    IExpandCollapseProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Expand( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Collapse( void) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ExpandCollapseState( 
            /* [retval][out] */ __RPC__out enum ExpandCollapseState *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExpandCollapseProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IExpandCollapseProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IExpandCollapseProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IExpandCollapseProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Expand )( 
            __RPC__in IExpandCollapseProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Collapse )( 
            __RPC__in IExpandCollapseProvider * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExpandCollapseState )( 
            __RPC__in IExpandCollapseProvider * This,
            /* [retval][out] */ __RPC__out enum ExpandCollapseState *pRetVal);
        
        END_INTERFACE
    } IExpandCollapseProviderVtbl;

    interface IExpandCollapseProvider
    {
        CONST_VTBL struct IExpandCollapseProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExpandCollapseProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IExpandCollapseProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IExpandCollapseProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IExpandCollapseProvider_Expand(This)	\
    ( (This)->lpVtbl -> Expand(This) ) 

#define IExpandCollapseProvider_Collapse(This)	\
    ( (This)->lpVtbl -> Collapse(This) ) 

#define IExpandCollapseProvider_get_ExpandCollapseState(This,pRetVal)	\
    ( (This)->lpVtbl -> get_ExpandCollapseState(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IExpandCollapseProvider_INTERFACE_DEFINED__ */


#ifndef __IGridProvider_INTERFACE_DEFINED__
#define __IGridProvider_INTERFACE_DEFINED__

/* interface IGridProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IGridProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b17d6187-0907-464b-a168-0ef17a1572b1")
    IGridProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetItem( 
            /* [in] */ int row,
            /* [in] */ int column,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderSimple **pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RowCount( 
            /* [retval][out] */ __RPC__out int *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ColumnCount( 
            /* [retval][out] */ __RPC__out int *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGridProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IGridProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IGridProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IGridProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            __RPC__in IGridProvider * This,
            /* [in] */ int row,
            /* [in] */ int column,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderSimple **pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RowCount )( 
            __RPC__in IGridProvider * This,
            /* [retval][out] */ __RPC__out int *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ColumnCount )( 
            __RPC__in IGridProvider * This,
            /* [retval][out] */ __RPC__out int *pRetVal);
        
        END_INTERFACE
    } IGridProviderVtbl;

    interface IGridProvider
    {
        CONST_VTBL struct IGridProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGridProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IGridProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IGridProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IGridProvider_GetItem(This,row,column,pRetVal)	\
    ( (This)->lpVtbl -> GetItem(This,row,column,pRetVal) ) 

#define IGridProvider_get_RowCount(This,pRetVal)	\
    ( (This)->lpVtbl -> get_RowCount(This,pRetVal) ) 

#define IGridProvider_get_ColumnCount(This,pRetVal)	\
    ( (This)->lpVtbl -> get_ColumnCount(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IGridProvider_INTERFACE_DEFINED__ */


#ifndef __IGridItemProvider_INTERFACE_DEFINED__
#define __IGridItemProvider_INTERFACE_DEFINED__

/* interface IGridItemProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IGridItemProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d02541f1-fb81-4d64-ae32-f520f8a6dbd1")
    IGridItemProvider : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Row( 
            /* [retval][out] */ __RPC__out int *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Column( 
            /* [retval][out] */ __RPC__out int *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RowSpan( 
            /* [retval][out] */ __RPC__out int *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ColumnSpan( 
            /* [retval][out] */ __RPC__out int *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ContainingGrid( 
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderSimple **pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGridItemProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IGridItemProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IGridItemProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IGridItemProvider * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Row )( 
            __RPC__in IGridItemProvider * This,
            /* [retval][out] */ __RPC__out int *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Column )( 
            __RPC__in IGridItemProvider * This,
            /* [retval][out] */ __RPC__out int *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RowSpan )( 
            __RPC__in IGridItemProvider * This,
            /* [retval][out] */ __RPC__out int *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ColumnSpan )( 
            __RPC__in IGridItemProvider * This,
            /* [retval][out] */ __RPC__out int *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ContainingGrid )( 
            __RPC__in IGridItemProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderSimple **pRetVal);
        
        END_INTERFACE
    } IGridItemProviderVtbl;

    interface IGridItemProvider
    {
        CONST_VTBL struct IGridItemProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGridItemProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IGridItemProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IGridItemProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IGridItemProvider_get_Row(This,pRetVal)	\
    ( (This)->lpVtbl -> get_Row(This,pRetVal) ) 

#define IGridItemProvider_get_Column(This,pRetVal)	\
    ( (This)->lpVtbl -> get_Column(This,pRetVal) ) 

#define IGridItemProvider_get_RowSpan(This,pRetVal)	\
    ( (This)->lpVtbl -> get_RowSpan(This,pRetVal) ) 

#define IGridItemProvider_get_ColumnSpan(This,pRetVal)	\
    ( (This)->lpVtbl -> get_ColumnSpan(This,pRetVal) ) 

#define IGridItemProvider_get_ContainingGrid(This,pRetVal)	\
    ( (This)->lpVtbl -> get_ContainingGrid(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IGridItemProvider_INTERFACE_DEFINED__ */


#ifndef __IInvokeProvider_INTERFACE_DEFINED__
#define __IInvokeProvider_INTERFACE_DEFINED__

/* interface IInvokeProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IInvokeProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("54fcb24b-e18e-47a2-b4d3-eccbe77599a2")
    IInvokeProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Invoke( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInvokeProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IInvokeProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IInvokeProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IInvokeProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            __RPC__in IInvokeProvider * This);
        
        END_INTERFACE
    } IInvokeProviderVtbl;

    interface IInvokeProvider
    {
        CONST_VTBL struct IInvokeProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInvokeProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInvokeProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInvokeProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInvokeProvider_Invoke(This)	\
    ( (This)->lpVtbl -> Invoke(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInvokeProvider_INTERFACE_DEFINED__ */


#ifndef __IMultipleViewProvider_INTERFACE_DEFINED__
#define __IMultipleViewProvider_INTERFACE_DEFINED__

/* interface IMultipleViewProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMultipleViewProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6278cab1-b556-4a1a-b4e0-418acc523201")
    IMultipleViewProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetViewName( 
            /* [in] */ int viewId,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCurrentView( 
            /* [in] */ int viewId) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentView( 
            /* [retval][out] */ __RPC__out int *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupportedViews( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMultipleViewProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMultipleViewProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMultipleViewProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMultipleViewProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewName )( 
            __RPC__in IMultipleViewProvider * This,
            /* [in] */ int viewId,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *SetCurrentView )( 
            __RPC__in IMultipleViewProvider * This,
            /* [in] */ int viewId);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentView )( 
            __RPC__in IMultipleViewProvider * This,
            /* [retval][out] */ __RPC__out int *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedViews )( 
            __RPC__in IMultipleViewProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal);
        
        END_INTERFACE
    } IMultipleViewProviderVtbl;

    interface IMultipleViewProvider
    {
        CONST_VTBL struct IMultipleViewProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMultipleViewProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMultipleViewProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMultipleViewProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMultipleViewProvider_GetViewName(This,viewId,pRetVal)	\
    ( (This)->lpVtbl -> GetViewName(This,viewId,pRetVal) ) 

#define IMultipleViewProvider_SetCurrentView(This,viewId)	\
    ( (This)->lpVtbl -> SetCurrentView(This,viewId) ) 

#define IMultipleViewProvider_get_CurrentView(This,pRetVal)	\
    ( (This)->lpVtbl -> get_CurrentView(This,pRetVal) ) 

#define IMultipleViewProvider_GetSupportedViews(This,pRetVal)	\
    ( (This)->lpVtbl -> GetSupportedViews(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMultipleViewProvider_INTERFACE_DEFINED__ */


#ifndef __IRangeValueProvider_INTERFACE_DEFINED__
#define __IRangeValueProvider_INTERFACE_DEFINED__

/* interface IRangeValueProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IRangeValueProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("36dc7aef-33e6-4691-afe1-2be7274b3d33")
    IRangeValueProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ double val) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ __RPC__out double *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IsReadOnly( 
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Maximum( 
            /* [retval][out] */ __RPC__out double *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Minimum( 
            /* [retval][out] */ __RPC__out double *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LargeChange( 
            /* [retval][out] */ __RPC__out double *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SmallChange( 
            /* [retval][out] */ __RPC__out double *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRangeValueProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRangeValueProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRangeValueProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRangeValueProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            __RPC__in IRangeValueProvider * This,
            /* [in] */ double val);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Value )( 
            __RPC__in IRangeValueProvider * This,
            /* [retval][out] */ __RPC__out double *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsReadOnly )( 
            __RPC__in IRangeValueProvider * This,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Maximum )( 
            __RPC__in IRangeValueProvider * This,
            /* [retval][out] */ __RPC__out double *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Minimum )( 
            __RPC__in IRangeValueProvider * This,
            /* [retval][out] */ __RPC__out double *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LargeChange )( 
            __RPC__in IRangeValueProvider * This,
            /* [retval][out] */ __RPC__out double *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SmallChange )( 
            __RPC__in IRangeValueProvider * This,
            /* [retval][out] */ __RPC__out double *pRetVal);
        
        END_INTERFACE
    } IRangeValueProviderVtbl;

    interface IRangeValueProvider
    {
        CONST_VTBL struct IRangeValueProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRangeValueProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRangeValueProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRangeValueProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRangeValueProvider_SetValue(This,val)	\
    ( (This)->lpVtbl -> SetValue(This,val) ) 

#define IRangeValueProvider_get_Value(This,pRetVal)	\
    ( (This)->lpVtbl -> get_Value(This,pRetVal) ) 

#define IRangeValueProvider_get_IsReadOnly(This,pRetVal)	\
    ( (This)->lpVtbl -> get_IsReadOnly(This,pRetVal) ) 

#define IRangeValueProvider_get_Maximum(This,pRetVal)	\
    ( (This)->lpVtbl -> get_Maximum(This,pRetVal) ) 

#define IRangeValueProvider_get_Minimum(This,pRetVal)	\
    ( (This)->lpVtbl -> get_Minimum(This,pRetVal) ) 

#define IRangeValueProvider_get_LargeChange(This,pRetVal)	\
    ( (This)->lpVtbl -> get_LargeChange(This,pRetVal) ) 

#define IRangeValueProvider_get_SmallChange(This,pRetVal)	\
    ( (This)->lpVtbl -> get_SmallChange(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRangeValueProvider_INTERFACE_DEFINED__ */


#ifndef __IScrollItemProvider_INTERFACE_DEFINED__
#define __IScrollItemProvider_INTERFACE_DEFINED__

/* interface IScrollItemProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IScrollItemProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2360c714-4bf1-4b26-ba65-9b21316127eb")
    IScrollItemProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ScrollIntoView( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScrollItemProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IScrollItemProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IScrollItemProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IScrollItemProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *ScrollIntoView )( 
            __RPC__in IScrollItemProvider * This);
        
        END_INTERFACE
    } IScrollItemProviderVtbl;

    interface IScrollItemProvider
    {
        CONST_VTBL struct IScrollItemProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScrollItemProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IScrollItemProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IScrollItemProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IScrollItemProvider_ScrollIntoView(This)	\
    ( (This)->lpVtbl -> ScrollIntoView(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IScrollItemProvider_INTERFACE_DEFINED__ */


#ifndef __ISelectionProvider_INTERFACE_DEFINED__
#define __ISelectionProvider_INTERFACE_DEFINED__

/* interface ISelectionProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISelectionProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fb8b03af-3bdf-48d4-bd36-1a65793be168")
    ISelectionProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSelection( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CanSelectMultiple( 
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IsSelectionRequired( 
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISelectionProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ISelectionProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ISelectionProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ISelectionProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelection )( 
            __RPC__in ISelectionProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CanSelectMultiple )( 
            __RPC__in ISelectionProvider * This,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsSelectionRequired )( 
            __RPC__in ISelectionProvider * This,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        END_INTERFACE
    } ISelectionProviderVtbl;

    interface ISelectionProvider
    {
        CONST_VTBL struct ISelectionProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISelectionProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISelectionProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISelectionProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISelectionProvider_GetSelection(This,pRetVal)	\
    ( (This)->lpVtbl -> GetSelection(This,pRetVal) ) 

#define ISelectionProvider_get_CanSelectMultiple(This,pRetVal)	\
    ( (This)->lpVtbl -> get_CanSelectMultiple(This,pRetVal) ) 

#define ISelectionProvider_get_IsSelectionRequired(This,pRetVal)	\
    ( (This)->lpVtbl -> get_IsSelectionRequired(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISelectionProvider_INTERFACE_DEFINED__ */


#ifndef __IScrollProvider_INTERFACE_DEFINED__
#define __IScrollProvider_INTERFACE_DEFINED__

/* interface IScrollProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IScrollProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b38b8077-1fc3-42a5-8cae-d40c2215055a")
    IScrollProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Scroll( 
            /* [in] */ enum ScrollAmount horizontalAmount,
            /* [in] */ enum ScrollAmount verticalAmount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetScrollPercent( 
            /* [in] */ double horizontalPercent,
            /* [in] */ double verticalPercent) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_HorizontalScrollPercent( 
            /* [retval][out] */ __RPC__out double *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_VerticalScrollPercent( 
            /* [retval][out] */ __RPC__out double *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_HorizontalViewSize( 
            /* [retval][out] */ __RPC__out double *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_VerticalViewSize( 
            /* [retval][out] */ __RPC__out double *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_HorizontallyScrollable( 
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_VerticallyScrollable( 
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScrollProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IScrollProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IScrollProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IScrollProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Scroll )( 
            __RPC__in IScrollProvider * This,
            /* [in] */ enum ScrollAmount horizontalAmount,
            /* [in] */ enum ScrollAmount verticalAmount);
        
        HRESULT ( STDMETHODCALLTYPE *SetScrollPercent )( 
            __RPC__in IScrollProvider * This,
            /* [in] */ double horizontalPercent,
            /* [in] */ double verticalPercent);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HorizontalScrollPercent )( 
            __RPC__in IScrollProvider * This,
            /* [retval][out] */ __RPC__out double *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VerticalScrollPercent )( 
            __RPC__in IScrollProvider * This,
            /* [retval][out] */ __RPC__out double *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HorizontalViewSize )( 
            __RPC__in IScrollProvider * This,
            /* [retval][out] */ __RPC__out double *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VerticalViewSize )( 
            __RPC__in IScrollProvider * This,
            /* [retval][out] */ __RPC__out double *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_HorizontallyScrollable )( 
            __RPC__in IScrollProvider * This,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_VerticallyScrollable )( 
            __RPC__in IScrollProvider * This,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        END_INTERFACE
    } IScrollProviderVtbl;

    interface IScrollProvider
    {
        CONST_VTBL struct IScrollProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScrollProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IScrollProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IScrollProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IScrollProvider_Scroll(This,horizontalAmount,verticalAmount)	\
    ( (This)->lpVtbl -> Scroll(This,horizontalAmount,verticalAmount) ) 

#define IScrollProvider_SetScrollPercent(This,horizontalPercent,verticalPercent)	\
    ( (This)->lpVtbl -> SetScrollPercent(This,horizontalPercent,verticalPercent) ) 

#define IScrollProvider_get_HorizontalScrollPercent(This,pRetVal)	\
    ( (This)->lpVtbl -> get_HorizontalScrollPercent(This,pRetVal) ) 

#define IScrollProvider_get_VerticalScrollPercent(This,pRetVal)	\
    ( (This)->lpVtbl -> get_VerticalScrollPercent(This,pRetVal) ) 

#define IScrollProvider_get_HorizontalViewSize(This,pRetVal)	\
    ( (This)->lpVtbl -> get_HorizontalViewSize(This,pRetVal) ) 

#define IScrollProvider_get_VerticalViewSize(This,pRetVal)	\
    ( (This)->lpVtbl -> get_VerticalViewSize(This,pRetVal) ) 

#define IScrollProvider_get_HorizontallyScrollable(This,pRetVal)	\
    ( (This)->lpVtbl -> get_HorizontallyScrollable(This,pRetVal) ) 

#define IScrollProvider_get_VerticallyScrollable(This,pRetVal)	\
    ( (This)->lpVtbl -> get_VerticallyScrollable(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IScrollProvider_INTERFACE_DEFINED__ */


#ifndef __ISelectionItemProvider_INTERFACE_DEFINED__
#define __ISelectionItemProvider_INTERFACE_DEFINED__

/* interface ISelectionItemProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISelectionItemProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2acad808-b2d4-452d-a407-91ff1ad167b2")
    ISelectionItemProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Select( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddToSelection( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveFromSelection( void) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IsSelected( 
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SelectionContainer( 
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderSimple **pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISelectionItemProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ISelectionItemProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ISelectionItemProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ISelectionItemProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Select )( 
            __RPC__in ISelectionItemProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddToSelection )( 
            __RPC__in ISelectionItemProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFromSelection )( 
            __RPC__in ISelectionItemProvider * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsSelected )( 
            __RPC__in ISelectionItemProvider * This,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SelectionContainer )( 
            __RPC__in ISelectionItemProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderSimple **pRetVal);
        
        END_INTERFACE
    } ISelectionItemProviderVtbl;

    interface ISelectionItemProvider
    {
        CONST_VTBL struct ISelectionItemProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISelectionItemProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISelectionItemProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISelectionItemProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISelectionItemProvider_Select(This)	\
    ( (This)->lpVtbl -> Select(This) ) 

#define ISelectionItemProvider_AddToSelection(This)	\
    ( (This)->lpVtbl -> AddToSelection(This) ) 

#define ISelectionItemProvider_RemoveFromSelection(This)	\
    ( (This)->lpVtbl -> RemoveFromSelection(This) ) 

#define ISelectionItemProvider_get_IsSelected(This,pRetVal)	\
    ( (This)->lpVtbl -> get_IsSelected(This,pRetVal) ) 

#define ISelectionItemProvider_get_SelectionContainer(This,pRetVal)	\
    ( (This)->lpVtbl -> get_SelectionContainer(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISelectionItemProvider_INTERFACE_DEFINED__ */


#ifndef __ISynchronizedInputProvider_INTERFACE_DEFINED__
#define __ISynchronizedInputProvider_INTERFACE_DEFINED__

/* interface ISynchronizedInputProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISynchronizedInputProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("29db1a06-02ce-4cf7-9b42-565d4fab20ee")
    ISynchronizedInputProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartListening( 
            /* [in] */ enum SynchronizedInputType inputType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISynchronizedInputProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ISynchronizedInputProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ISynchronizedInputProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ISynchronizedInputProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartListening )( 
            __RPC__in ISynchronizedInputProvider * This,
            /* [in] */ enum SynchronizedInputType inputType);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            __RPC__in ISynchronizedInputProvider * This);
        
        END_INTERFACE
    } ISynchronizedInputProviderVtbl;

    interface ISynchronizedInputProvider
    {
        CONST_VTBL struct ISynchronizedInputProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISynchronizedInputProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISynchronizedInputProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISynchronizedInputProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISynchronizedInputProvider_StartListening(This,inputType)	\
    ( (This)->lpVtbl -> StartListening(This,inputType) ) 

#define ISynchronizedInputProvider_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISynchronizedInputProvider_INTERFACE_DEFINED__ */


#ifndef __ITableProvider_INTERFACE_DEFINED__
#define __ITableProvider_INTERFACE_DEFINED__

/* interface ITableProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITableProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9c860395-97b3-490a-b52a-858cc22af166")
    ITableProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRowHeaders( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColumnHeaders( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RowOrColumnMajor( 
            /* [retval][out] */ __RPC__out enum RowOrColumnMajor *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITableProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITableProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITableProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITableProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRowHeaders )( 
            __RPC__in ITableProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnHeaders )( 
            __RPC__in ITableProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RowOrColumnMajor )( 
            __RPC__in ITableProvider * This,
            /* [retval][out] */ __RPC__out enum RowOrColumnMajor *pRetVal);
        
        END_INTERFACE
    } ITableProviderVtbl;

    interface ITableProvider
    {
        CONST_VTBL struct ITableProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITableProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITableProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITableProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITableProvider_GetRowHeaders(This,pRetVal)	\
    ( (This)->lpVtbl -> GetRowHeaders(This,pRetVal) ) 

#define ITableProvider_GetColumnHeaders(This,pRetVal)	\
    ( (This)->lpVtbl -> GetColumnHeaders(This,pRetVal) ) 

#define ITableProvider_get_RowOrColumnMajor(This,pRetVal)	\
    ( (This)->lpVtbl -> get_RowOrColumnMajor(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITableProvider_INTERFACE_DEFINED__ */


#ifndef __ITableItemProvider_INTERFACE_DEFINED__
#define __ITableItemProvider_INTERFACE_DEFINED__

/* interface ITableItemProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITableItemProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b9734fa6-771f-4d78-9c90-2517999349cd")
    ITableItemProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRowHeaderItems( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColumnHeaderItems( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITableItemProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITableItemProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITableItemProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITableItemProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRowHeaderItems )( 
            __RPC__in ITableItemProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnHeaderItems )( 
            __RPC__in ITableItemProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal);
        
        END_INTERFACE
    } ITableItemProviderVtbl;

    interface ITableItemProvider
    {
        CONST_VTBL struct ITableItemProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITableItemProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITableItemProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITableItemProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITableItemProvider_GetRowHeaderItems(This,pRetVal)	\
    ( (This)->lpVtbl -> GetRowHeaderItems(This,pRetVal) ) 

#define ITableItemProvider_GetColumnHeaderItems(This,pRetVal)	\
    ( (This)->lpVtbl -> GetColumnHeaderItems(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITableItemProvider_INTERFACE_DEFINED__ */


#ifndef __IToggleProvider_INTERFACE_DEFINED__
#define __IToggleProvider_INTERFACE_DEFINED__

/* interface IToggleProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IToggleProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56d00bd0-c4f4-433c-a836-1a52a57e0892")
    IToggleProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Toggle( void) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ToggleState( 
            /* [retval][out] */ __RPC__out enum ToggleState *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IToggleProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IToggleProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IToggleProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IToggleProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Toggle )( 
            __RPC__in IToggleProvider * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ToggleState )( 
            __RPC__in IToggleProvider * This,
            /* [retval][out] */ __RPC__out enum ToggleState *pRetVal);
        
        END_INTERFACE
    } IToggleProviderVtbl;

    interface IToggleProvider
    {
        CONST_VTBL struct IToggleProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IToggleProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IToggleProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IToggleProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IToggleProvider_Toggle(This)	\
    ( (This)->lpVtbl -> Toggle(This) ) 

#define IToggleProvider_get_ToggleState(This,pRetVal)	\
    ( (This)->lpVtbl -> get_ToggleState(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IToggleProvider_INTERFACE_DEFINED__ */


#ifndef __ITransformProvider_INTERFACE_DEFINED__
#define __ITransformProvider_INTERFACE_DEFINED__

/* interface ITransformProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITransformProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6829ddc4-4f91-4ffa-b86f-bd3e2987cb4c")
    ITransformProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Move( 
            /* [in] */ double x,
            /* [in] */ double y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resize( 
            /* [in] */ double width,
            /* [in] */ double height) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Rotate( 
            /* [in] */ double degrees) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CanMove( 
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CanResize( 
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CanRotate( 
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransformProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITransformProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITransformProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITransformProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Move )( 
            __RPC__in ITransformProvider * This,
            /* [in] */ double x,
            /* [in] */ double y);
        
        HRESULT ( STDMETHODCALLTYPE *Resize )( 
            __RPC__in ITransformProvider * This,
            /* [in] */ double width,
            /* [in] */ double height);
        
        HRESULT ( STDMETHODCALLTYPE *Rotate )( 
            __RPC__in ITransformProvider * This,
            /* [in] */ double degrees);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CanMove )( 
            __RPC__in ITransformProvider * This,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CanResize )( 
            __RPC__in ITransformProvider * This,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CanRotate )( 
            __RPC__in ITransformProvider * This,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        END_INTERFACE
    } ITransformProviderVtbl;

    interface ITransformProvider
    {
        CONST_VTBL struct ITransformProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransformProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITransformProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITransformProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITransformProvider_Move(This,x,y)	\
    ( (This)->lpVtbl -> Move(This,x,y) ) 

#define ITransformProvider_Resize(This,width,height)	\
    ( (This)->lpVtbl -> Resize(This,width,height) ) 

#define ITransformProvider_Rotate(This,degrees)	\
    ( (This)->lpVtbl -> Rotate(This,degrees) ) 

#define ITransformProvider_get_CanMove(This,pRetVal)	\
    ( (This)->lpVtbl -> get_CanMove(This,pRetVal) ) 

#define ITransformProvider_get_CanResize(This,pRetVal)	\
    ( (This)->lpVtbl -> get_CanResize(This,pRetVal) ) 

#define ITransformProvider_get_CanRotate(This,pRetVal)	\
    ( (This)->lpVtbl -> get_CanRotate(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITransformProvider_INTERFACE_DEFINED__ */


#ifndef __IValueProvider_INTERFACE_DEFINED__
#define __IValueProvider_INTERFACE_DEFINED__

/* interface IValueProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IValueProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c7935180-6fb3-4201-b174-7df73adbf64a")
    IValueProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ __RPC__in LPCWSTR val) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IsReadOnly( 
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IValueProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IValueProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IValueProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IValueProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            __RPC__in IValueProvider * This,
            /* [in] */ __RPC__in LPCWSTR val);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Value )( 
            __RPC__in IValueProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsReadOnly )( 
            __RPC__in IValueProvider * This,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        END_INTERFACE
    } IValueProviderVtbl;

    interface IValueProvider
    {
        CONST_VTBL struct IValueProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IValueProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IValueProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IValueProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IValueProvider_SetValue(This,val)	\
    ( (This)->lpVtbl -> SetValue(This,val) ) 

#define IValueProvider_get_Value(This,pRetVal)	\
    ( (This)->lpVtbl -> get_Value(This,pRetVal) ) 

#define IValueProvider_get_IsReadOnly(This,pRetVal)	\
    ( (This)->lpVtbl -> get_IsReadOnly(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IValueProvider_INTERFACE_DEFINED__ */


#ifndef __IWindowProvider_INTERFACE_DEFINED__
#define __IWindowProvider_INTERFACE_DEFINED__

/* interface IWindowProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWindowProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("987df77b-db06-4d77-8f8a-86a9c3bb90b9")
    IWindowProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetVisualState( 
            /* [in] */ enum WindowVisualState state) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WaitForInputIdle( 
            /* [in] */ int milliseconds,
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CanMaximize( 
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CanMinimize( 
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IsModal( 
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WindowVisualState( 
            /* [retval][out] */ __RPC__out enum WindowVisualState *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_WindowInteractionState( 
            /* [retval][out] */ __RPC__out enum WindowInteractionState *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IsTopmost( 
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWindowProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWindowProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWindowProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWindowProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetVisualState )( 
            __RPC__in IWindowProvider * This,
            /* [in] */ enum WindowVisualState state);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            __RPC__in IWindowProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *WaitForInputIdle )( 
            __RPC__in IWindowProvider * This,
            /* [in] */ int milliseconds,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CanMaximize )( 
            __RPC__in IWindowProvider * This,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CanMinimize )( 
            __RPC__in IWindowProvider * This,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsModal )( 
            __RPC__in IWindowProvider * This,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WindowVisualState )( 
            __RPC__in IWindowProvider * This,
            /* [retval][out] */ __RPC__out enum WindowVisualState *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_WindowInteractionState )( 
            __RPC__in IWindowProvider * This,
            /* [retval][out] */ __RPC__out enum WindowInteractionState *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsTopmost )( 
            __RPC__in IWindowProvider * This,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        END_INTERFACE
    } IWindowProviderVtbl;

    interface IWindowProvider
    {
        CONST_VTBL struct IWindowProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWindowProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWindowProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWindowProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWindowProvider_SetVisualState(This,state)	\
    ( (This)->lpVtbl -> SetVisualState(This,state) ) 

#define IWindowProvider_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#define IWindowProvider_WaitForInputIdle(This,milliseconds,pRetVal)	\
    ( (This)->lpVtbl -> WaitForInputIdle(This,milliseconds,pRetVal) ) 

#define IWindowProvider_get_CanMaximize(This,pRetVal)	\
    ( (This)->lpVtbl -> get_CanMaximize(This,pRetVal) ) 

#define IWindowProvider_get_CanMinimize(This,pRetVal)	\
    ( (This)->lpVtbl -> get_CanMinimize(This,pRetVal) ) 

#define IWindowProvider_get_IsModal(This,pRetVal)	\
    ( (This)->lpVtbl -> get_IsModal(This,pRetVal) ) 

#define IWindowProvider_get_WindowVisualState(This,pRetVal)	\
    ( (This)->lpVtbl -> get_WindowVisualState(This,pRetVal) ) 

#define IWindowProvider_get_WindowInteractionState(This,pRetVal)	\
    ( (This)->lpVtbl -> get_WindowInteractionState(This,pRetVal) ) 

#define IWindowProvider_get_IsTopmost(This,pRetVal)	\
    ( (This)->lpVtbl -> get_IsTopmost(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWindowProvider_INTERFACE_DEFINED__ */


#ifndef __ILegacyIAccessibleProvider_INTERFACE_DEFINED__
#define __ILegacyIAccessibleProvider_INTERFACE_DEFINED__

/* interface ILegacyIAccessibleProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ILegacyIAccessibleProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e44c3566-915d-4070-99c6-047bff5a08f5")
    ILegacyIAccessibleProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Select( 
            long flagsSelect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoDefaultAction( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            __RPC__in LPCWSTR szValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIAccessible( 
            /* [retval][out] */ __RPC__deref_out_opt IAccessible **ppAccessible) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ChildId( 
            /* [retval][out] */ __RPC__out int *pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszValue) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszDescription) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Role( 
            /* [retval][out] */ __RPC__out DWORD *pdwRole) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ __RPC__out DWORD *pdwState) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Help( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszHelp) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_KeyboardShortcut( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszKeyboardShortcut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelection( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pvarSelectedChildren) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DefaultAction( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszDefaultAction) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILegacyIAccessibleProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ILegacyIAccessibleProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ILegacyIAccessibleProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ILegacyIAccessibleProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Select )( 
            __RPC__in ILegacyIAccessibleProvider * This,
            long flagsSelect);
        
        HRESULT ( STDMETHODCALLTYPE *DoDefaultAction )( 
            __RPC__in ILegacyIAccessibleProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            __RPC__in ILegacyIAccessibleProvider * This,
            __RPC__in LPCWSTR szValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetIAccessible )( 
            __RPC__in ILegacyIAccessibleProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt IAccessible **ppAccessible);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ChildId )( 
            __RPC__in ILegacyIAccessibleProvider * This,
            /* [retval][out] */ __RPC__out int *pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in ILegacyIAccessibleProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Value )( 
            __RPC__in ILegacyIAccessibleProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszValue);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            __RPC__in ILegacyIAccessibleProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszDescription);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Role )( 
            __RPC__in ILegacyIAccessibleProvider * This,
            /* [retval][out] */ __RPC__out DWORD *pdwRole);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_State )( 
            __RPC__in ILegacyIAccessibleProvider * This,
            /* [retval][out] */ __RPC__out DWORD *pdwState);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Help )( 
            __RPC__in ILegacyIAccessibleProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszHelp);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_KeyboardShortcut )( 
            __RPC__in ILegacyIAccessibleProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszKeyboardShortcut);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelection )( 
            __RPC__in ILegacyIAccessibleProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pvarSelectedChildren);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultAction )( 
            __RPC__in ILegacyIAccessibleProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pszDefaultAction);
        
        END_INTERFACE
    } ILegacyIAccessibleProviderVtbl;

    interface ILegacyIAccessibleProvider
    {
        CONST_VTBL struct ILegacyIAccessibleProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILegacyIAccessibleProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ILegacyIAccessibleProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ILegacyIAccessibleProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ILegacyIAccessibleProvider_Select(This,flagsSelect)	\
    ( (This)->lpVtbl -> Select(This,flagsSelect) ) 

#define ILegacyIAccessibleProvider_DoDefaultAction(This)	\
    ( (This)->lpVtbl -> DoDefaultAction(This) ) 

#define ILegacyIAccessibleProvider_SetValue(This,szValue)	\
    ( (This)->lpVtbl -> SetValue(This,szValue) ) 

#define ILegacyIAccessibleProvider_GetIAccessible(This,ppAccessible)	\
    ( (This)->lpVtbl -> GetIAccessible(This,ppAccessible) ) 

#define ILegacyIAccessibleProvider_get_ChildId(This,pRetVal)	\
    ( (This)->lpVtbl -> get_ChildId(This,pRetVal) ) 

#define ILegacyIAccessibleProvider_get_Name(This,pszName)	\
    ( (This)->lpVtbl -> get_Name(This,pszName) ) 

#define ILegacyIAccessibleProvider_get_Value(This,pszValue)	\
    ( (This)->lpVtbl -> get_Value(This,pszValue) ) 

#define ILegacyIAccessibleProvider_get_Description(This,pszDescription)	\
    ( (This)->lpVtbl -> get_Description(This,pszDescription) ) 

#define ILegacyIAccessibleProvider_get_Role(This,pdwRole)	\
    ( (This)->lpVtbl -> get_Role(This,pdwRole) ) 

#define ILegacyIAccessibleProvider_get_State(This,pdwState)	\
    ( (This)->lpVtbl -> get_State(This,pdwState) ) 

#define ILegacyIAccessibleProvider_get_Help(This,pszHelp)	\
    ( (This)->lpVtbl -> get_Help(This,pszHelp) ) 

#define ILegacyIAccessibleProvider_get_KeyboardShortcut(This,pszKeyboardShortcut)	\
    ( (This)->lpVtbl -> get_KeyboardShortcut(This,pszKeyboardShortcut) ) 

#define ILegacyIAccessibleProvider_GetSelection(This,pvarSelectedChildren)	\
    ( (This)->lpVtbl -> GetSelection(This,pvarSelectedChildren) ) 

#define ILegacyIAccessibleProvider_get_DefaultAction(This,pszDefaultAction)	\
    ( (This)->lpVtbl -> get_DefaultAction(This,pszDefaultAction) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ILegacyIAccessibleProvider_INTERFACE_DEFINED__ */


#ifndef __IItemContainerProvider_INTERFACE_DEFINED__
#define __IItemContainerProvider_INTERFACE_DEFINED__

/* interface IItemContainerProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IItemContainerProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e747770b-39ce-4382-ab30-d8fb3f336f24")
    IItemContainerProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindItemByProperty( 
            /* [in] */ __RPC__in_opt IRawElementProviderSimple *pStartAfter,
            /* [in] */ PROPERTYID propertyId,
            /* [in] */ VARIANT value,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderSimple **pFound) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IItemContainerProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IItemContainerProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IItemContainerProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IItemContainerProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *FindItemByProperty )( 
            __RPC__in IItemContainerProvider * This,
            /* [in] */ __RPC__in_opt IRawElementProviderSimple *pStartAfter,
            /* [in] */ PROPERTYID propertyId,
            /* [in] */ VARIANT value,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderSimple **pFound);
        
        END_INTERFACE
    } IItemContainerProviderVtbl;

    interface IItemContainerProvider
    {
        CONST_VTBL struct IItemContainerProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IItemContainerProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IItemContainerProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IItemContainerProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IItemContainerProvider_FindItemByProperty(This,pStartAfter,propertyId,value,pFound)	\
    ( (This)->lpVtbl -> FindItemByProperty(This,pStartAfter,propertyId,value,pFound) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IItemContainerProvider_INTERFACE_DEFINED__ */


#ifndef __IVirtualizedItemProvider_INTERFACE_DEFINED__
#define __IVirtualizedItemProvider_INTERFACE_DEFINED__

/* interface IVirtualizedItemProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVirtualizedItemProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cb98b665-2d35-4fac-ad35-f3c60d0c0b8b")
    IVirtualizedItemProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Realize( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVirtualizedItemProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVirtualizedItemProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVirtualizedItemProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVirtualizedItemProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Realize )( 
            __RPC__in IVirtualizedItemProvider * This);
        
        END_INTERFACE
    } IVirtualizedItemProviderVtbl;

    interface IVirtualizedItemProvider
    {
        CONST_VTBL struct IVirtualizedItemProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVirtualizedItemProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVirtualizedItemProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVirtualizedItemProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVirtualizedItemProvider_Realize(This)	\
    ( (This)->lpVtbl -> Realize(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVirtualizedItemProvider_INTERFACE_DEFINED__ */


#ifndef __ITextRangeProvider_INTERFACE_DEFINED__
#define __ITextRangeProvider_INTERFACE_DEFINED__

/* interface ITextRangeProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITextRangeProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5347ad7b-c355-46f8-aff5-909033582f63")
    ITextRangeProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt ITextRangeProvider **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Compare( 
            /* [in] */ __RPC__in_opt ITextRangeProvider *range,
            /* [retval][out] */ __RPC__out BOOL *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompareEndpoints( 
            /* [in] */ enum TextPatternRangeEndpoint endpoint,
            /* [in] */ __RPC__in_opt ITextRangeProvider *targetRange,
            /* [in] */ enum TextPatternRangeEndpoint targetEndpoint,
            /* [retval][out] */ __RPC__out int *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExpandToEnclosingUnit( 
            /* [in] */ enum TextUnit unit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindAttribute( 
            /* [in] */ TEXTATTRIBUTEID attributeId,
            /* [in] */ VARIANT val,
            /* [in] */ BOOL backward,
            /* [retval][out] */ __RPC__deref_out_opt ITextRangeProvider **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindText( 
            /* [in] */ __RPC__in BSTR text,
            /* [in] */ BOOL backward,
            /* [in] */ BOOL ignoreCase,
            /* [retval][out] */ __RPC__deref_out_opt ITextRangeProvider **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeValue( 
            /* [in] */ TEXTATTRIBUTEID attributeId,
            /* [retval][out] */ __RPC__out VARIANT *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBoundingRectangles( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnclosingElement( 
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderSimple **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetText( 
            /* [in] */ int maxLength,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Move( 
            /* [in] */ enum TextUnit unit,
            /* [in] */ int count,
            /* [retval][out] */ __RPC__out int *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MoveEndpointByUnit( 
            /* [in] */ enum TextPatternRangeEndpoint endpoint,
            /* [in] */ enum TextUnit unit,
            /* [in] */ int count,
            /* [retval][out] */ __RPC__out int *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MoveEndpointByRange( 
            /* [in] */ enum TextPatternRangeEndpoint endpoint,
            /* [in] */ __RPC__in_opt ITextRangeProvider *targetRange,
            /* [in] */ enum TextPatternRangeEndpoint targetEndpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Select( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddToSelection( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveFromSelection( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ScrollIntoView( 
            /* [in] */ BOOL alignToTop) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChildren( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextRangeProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITextRangeProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITextRangeProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITextRangeProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in ITextRangeProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt ITextRangeProvider **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            __RPC__in ITextRangeProvider * This,
            /* [in] */ __RPC__in_opt ITextRangeProvider *range,
            /* [retval][out] */ __RPC__out BOOL *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *CompareEndpoints )( 
            __RPC__in ITextRangeProvider * This,
            /* [in] */ enum TextPatternRangeEndpoint endpoint,
            /* [in] */ __RPC__in_opt ITextRangeProvider *targetRange,
            /* [in] */ enum TextPatternRangeEndpoint targetEndpoint,
            /* [retval][out] */ __RPC__out int *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *ExpandToEnclosingUnit )( 
            __RPC__in ITextRangeProvider * This,
            /* [in] */ enum TextUnit unit);
        
        HRESULT ( STDMETHODCALLTYPE *FindAttribute )( 
            __RPC__in ITextRangeProvider * This,
            /* [in] */ TEXTATTRIBUTEID attributeId,
            /* [in] */ VARIANT val,
            /* [in] */ BOOL backward,
            /* [retval][out] */ __RPC__deref_out_opt ITextRangeProvider **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *FindText )( 
            __RPC__in ITextRangeProvider * This,
            /* [in] */ __RPC__in BSTR text,
            /* [in] */ BOOL backward,
            /* [in] */ BOOL ignoreCase,
            /* [retval][out] */ __RPC__deref_out_opt ITextRangeProvider **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeValue )( 
            __RPC__in ITextRangeProvider * This,
            /* [in] */ TEXTATTRIBUTEID attributeId,
            /* [retval][out] */ __RPC__out VARIANT *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetBoundingRectangles )( 
            __RPC__in ITextRangeProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnclosingElement )( 
            __RPC__in ITextRangeProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt IRawElementProviderSimple **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            __RPC__in ITextRangeProvider * This,
            /* [in] */ int maxLength,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *Move )( 
            __RPC__in ITextRangeProvider * This,
            /* [in] */ enum TextUnit unit,
            /* [in] */ int count,
            /* [retval][out] */ __RPC__out int *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *MoveEndpointByUnit )( 
            __RPC__in ITextRangeProvider * This,
            /* [in] */ enum TextPatternRangeEndpoint endpoint,
            /* [in] */ enum TextUnit unit,
            /* [in] */ int count,
            /* [retval][out] */ __RPC__out int *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *MoveEndpointByRange )( 
            __RPC__in ITextRangeProvider * This,
            /* [in] */ enum TextPatternRangeEndpoint endpoint,
            /* [in] */ __RPC__in_opt ITextRangeProvider *targetRange,
            /* [in] */ enum TextPatternRangeEndpoint targetEndpoint);
        
        HRESULT ( STDMETHODCALLTYPE *Select )( 
            __RPC__in ITextRangeProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddToSelection )( 
            __RPC__in ITextRangeProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFromSelection )( 
            __RPC__in ITextRangeProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *ScrollIntoView )( 
            __RPC__in ITextRangeProvider * This,
            /* [in] */ BOOL alignToTop);
        
        HRESULT ( STDMETHODCALLTYPE *GetChildren )( 
            __RPC__in ITextRangeProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal);
        
        END_INTERFACE
    } ITextRangeProviderVtbl;

    interface ITextRangeProvider
    {
        CONST_VTBL struct ITextRangeProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextRangeProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITextRangeProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITextRangeProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITextRangeProvider_Clone(This,pRetVal)	\
    ( (This)->lpVtbl -> Clone(This,pRetVal) ) 

#define ITextRangeProvider_Compare(This,range,pRetVal)	\
    ( (This)->lpVtbl -> Compare(This,range,pRetVal) ) 

#define ITextRangeProvider_CompareEndpoints(This,endpoint,targetRange,targetEndpoint,pRetVal)	\
    ( (This)->lpVtbl -> CompareEndpoints(This,endpoint,targetRange,targetEndpoint,pRetVal) ) 

#define ITextRangeProvider_ExpandToEnclosingUnit(This,unit)	\
    ( (This)->lpVtbl -> ExpandToEnclosingUnit(This,unit) ) 

#define ITextRangeProvider_FindAttribute(This,attributeId,val,backward,pRetVal)	\
    ( (This)->lpVtbl -> FindAttribute(This,attributeId,val,backward,pRetVal) ) 

#define ITextRangeProvider_FindText(This,text,backward,ignoreCase,pRetVal)	\
    ( (This)->lpVtbl -> FindText(This,text,backward,ignoreCase,pRetVal) ) 

#define ITextRangeProvider_GetAttributeValue(This,attributeId,pRetVal)	\
    ( (This)->lpVtbl -> GetAttributeValue(This,attributeId,pRetVal) ) 

#define ITextRangeProvider_GetBoundingRectangles(This,pRetVal)	\
    ( (This)->lpVtbl -> GetBoundingRectangles(This,pRetVal) ) 

#define ITextRangeProvider_GetEnclosingElement(This,pRetVal)	\
    ( (This)->lpVtbl -> GetEnclosingElement(This,pRetVal) ) 

#define ITextRangeProvider_GetText(This,maxLength,pRetVal)	\
    ( (This)->lpVtbl -> GetText(This,maxLength,pRetVal) ) 

#define ITextRangeProvider_Move(This,unit,count,pRetVal)	\
    ( (This)->lpVtbl -> Move(This,unit,count,pRetVal) ) 

#define ITextRangeProvider_MoveEndpointByUnit(This,endpoint,unit,count,pRetVal)	\
    ( (This)->lpVtbl -> MoveEndpointByUnit(This,endpoint,unit,count,pRetVal) ) 

#define ITextRangeProvider_MoveEndpointByRange(This,endpoint,targetRange,targetEndpoint)	\
    ( (This)->lpVtbl -> MoveEndpointByRange(This,endpoint,targetRange,targetEndpoint) ) 

#define ITextRangeProvider_Select(This)	\
    ( (This)->lpVtbl -> Select(This) ) 

#define ITextRangeProvider_AddToSelection(This)	\
    ( (This)->lpVtbl -> AddToSelection(This) ) 

#define ITextRangeProvider_RemoveFromSelection(This)	\
    ( (This)->lpVtbl -> RemoveFromSelection(This) ) 

#define ITextRangeProvider_ScrollIntoView(This,alignToTop)	\
    ( (This)->lpVtbl -> ScrollIntoView(This,alignToTop) ) 

#define ITextRangeProvider_GetChildren(This,pRetVal)	\
    ( (This)->lpVtbl -> GetChildren(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITextRangeProvider_INTERFACE_DEFINED__ */


#ifndef __ITextProvider_INTERFACE_DEFINED__
#define __ITextProvider_INTERFACE_DEFINED__

/* interface ITextProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITextProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3589c92c-63f3-4367-99bb-ada653b77cf2")
    ITextProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSelection( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVisibleRanges( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RangeFromChild( 
            /* [in] */ __RPC__in_opt IRawElementProviderSimple *childElement,
            /* [retval][out] */ __RPC__deref_out_opt ITextRangeProvider **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RangeFromPoint( 
            /* [in] */ struct UiaPoint point,
            /* [retval][out] */ __RPC__deref_out_opt ITextRangeProvider **pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DocumentRange( 
            /* [retval][out] */ __RPC__deref_out_opt ITextRangeProvider **pRetVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SupportedTextSelection( 
            /* [retval][out] */ __RPC__out enum SupportedTextSelection *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITextProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITextProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITextProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelection )( 
            __RPC__in ITextProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetVisibleRanges )( 
            __RPC__in ITextProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *RangeFromChild )( 
            __RPC__in ITextProvider * This,
            /* [in] */ __RPC__in_opt IRawElementProviderSimple *childElement,
            /* [retval][out] */ __RPC__deref_out_opt ITextRangeProvider **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *RangeFromPoint )( 
            __RPC__in ITextProvider * This,
            /* [in] */ struct UiaPoint point,
            /* [retval][out] */ __RPC__deref_out_opt ITextRangeProvider **pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DocumentRange )( 
            __RPC__in ITextProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt ITextRangeProvider **pRetVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SupportedTextSelection )( 
            __RPC__in ITextProvider * This,
            /* [retval][out] */ __RPC__out enum SupportedTextSelection *pRetVal);
        
        END_INTERFACE
    } ITextProviderVtbl;

    interface ITextProvider
    {
        CONST_VTBL struct ITextProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITextProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITextProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITextProvider_GetSelection(This,pRetVal)	\
    ( (This)->lpVtbl -> GetSelection(This,pRetVal) ) 

#define ITextProvider_GetVisibleRanges(This,pRetVal)	\
    ( (This)->lpVtbl -> GetVisibleRanges(This,pRetVal) ) 

#define ITextProvider_RangeFromChild(This,childElement,pRetVal)	\
    ( (This)->lpVtbl -> RangeFromChild(This,childElement,pRetVal) ) 

#define ITextProvider_RangeFromPoint(This,point,pRetVal)	\
    ( (This)->lpVtbl -> RangeFromPoint(This,point,pRetVal) ) 

#define ITextProvider_get_DocumentRange(This,pRetVal)	\
    ( (This)->lpVtbl -> get_DocumentRange(This,pRetVal) ) 

#define ITextProvider_get_SupportedTextSelection(This,pRetVal)	\
    ( (This)->lpVtbl -> get_SupportedTextSelection(This,pRetVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITextProvider_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationPatternInstance_INTERFACE_DEFINED__
#define __IUIAutomationPatternInstance_INTERFACE_DEFINED__

/* interface IUIAutomationPatternInstance */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationPatternInstance;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c03a7fe4-9431-409f-bed8-ae7c2299bc8d")
    IUIAutomationPatternInstance : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ UINT index,
            /* [in] */ BOOL cached,
            /* [in] */ enum UIAutomationType type,
            /* [out] */ void *pPtr) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CallMethod( 
            /* [in] */ UINT index,
            /* [in] */ const struct UIAutomationParameter *pParams,
            /* [in] */ UINT cParams) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationPatternInstanceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationPatternInstance * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationPatternInstance * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationPatternInstance * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IUIAutomationPatternInstance * This,
            /* [in] */ UINT index,
            /* [in] */ BOOL cached,
            /* [in] */ enum UIAutomationType type,
            /* [out] */ void *pPtr);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CallMethod )( 
            IUIAutomationPatternInstance * This,
            /* [in] */ UINT index,
            /* [in] */ const struct UIAutomationParameter *pParams,
            /* [in] */ UINT cParams);
        
        END_INTERFACE
    } IUIAutomationPatternInstanceVtbl;

    interface IUIAutomationPatternInstance
    {
        CONST_VTBL struct IUIAutomationPatternInstanceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationPatternInstance_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationPatternInstance_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationPatternInstance_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationPatternInstance_GetProperty(This,index,cached,type,pPtr)	\
    ( (This)->lpVtbl -> GetProperty(This,index,cached,type,pPtr) ) 

#define IUIAutomationPatternInstance_CallMethod(This,index,pParams,cParams)	\
    ( (This)->lpVtbl -> CallMethod(This,index,pParams,cParams) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationPatternInstance_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationPatternHandler_INTERFACE_DEFINED__
#define __IUIAutomationPatternHandler_INTERFACE_DEFINED__

/* interface IUIAutomationPatternHandler */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationPatternHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d97022f3-a947-465e-8b2a-ac4315fa54e8")
    IUIAutomationPatternHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateClientWrapper( 
            /* [in] */ __RPC__in_opt IUIAutomationPatternInstance *pPatternInstance,
            /* [out] */ __RPC__deref_out_opt IUnknown **pClientWrapper) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Dispatch( 
            /* [in] */ IUnknown *pTarget,
            /* [in] */ UINT index,
            /* [in] */ const struct UIAutomationParameter *pParams,
            /* [in] */ UINT cParams) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationPatternHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationPatternHandler * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationPatternHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationPatternHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateClientWrapper )( 
            __RPC__in IUIAutomationPatternHandler * This,
            /* [in] */ __RPC__in_opt IUIAutomationPatternInstance *pPatternInstance,
            /* [out] */ __RPC__deref_out_opt IUnknown **pClientWrapper);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Dispatch )( 
            IUIAutomationPatternHandler * This,
            /* [in] */ IUnknown *pTarget,
            /* [in] */ UINT index,
            /* [in] */ const struct UIAutomationParameter *pParams,
            /* [in] */ UINT cParams);
        
        END_INTERFACE
    } IUIAutomationPatternHandlerVtbl;

    interface IUIAutomationPatternHandler
    {
        CONST_VTBL struct IUIAutomationPatternHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationPatternHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationPatternHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationPatternHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationPatternHandler_CreateClientWrapper(This,pPatternInstance,pClientWrapper)	\
    ( (This)->lpVtbl -> CreateClientWrapper(This,pPatternInstance,pClientWrapper) ) 

#define IUIAutomationPatternHandler_Dispatch(This,pTarget,index,pParams,cParams)	\
    ( (This)->lpVtbl -> Dispatch(This,pTarget,index,pParams,cParams) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationPatternHandler_INTERFACE_DEFINED__ */


#ifndef __IUIAutomationRegistrar_INTERFACE_DEFINED__
#define __IUIAutomationRegistrar_INTERFACE_DEFINED__

/* interface IUIAutomationRegistrar */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUIAutomationRegistrar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8609c4ec-4a1a-4d88-a357-5a66e060e1cf")
    IUIAutomationRegistrar : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterProperty( 
            /* [in] */ __RPC__in const struct UIAutomationPropertyInfo *property,
            /* [out] */ __RPC__out PROPERTYID *propertyId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterEvent( 
            /* [in] */ __RPC__in const struct UIAutomationEventInfo *event,
            /* [out] */ __RPC__out EVENTID *eventId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterPattern( 
            /* [in] */ __RPC__in const struct UIAutomationPatternInfo *pattern,
            /* [out] */ __RPC__out PATTERNID *pPatternId,
            /* [out] */ __RPC__out PROPERTYID *pPatternAvailablePropertyId,
            /* [in] */ UINT propertyIdCount,
            /* [size_is][out] */ __RPC__out_ecount_full(propertyIdCount) PROPERTYID *pPropertyIds,
            /* [in] */ UINT eventIdCount,
            /* [size_is][out] */ __RPC__out_ecount_full(eventIdCount) EVENTID *pEventIds) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIAutomationRegistrarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUIAutomationRegistrar * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUIAutomationRegistrar * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUIAutomationRegistrar * This);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterProperty )( 
            __RPC__in IUIAutomationRegistrar * This,
            /* [in] */ __RPC__in const struct UIAutomationPropertyInfo *property,
            /* [out] */ __RPC__out PROPERTYID *propertyId);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterEvent )( 
            __RPC__in IUIAutomationRegistrar * This,
            /* [in] */ __RPC__in const struct UIAutomationEventInfo *event,
            /* [out] */ __RPC__out EVENTID *eventId);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterPattern )( 
            __RPC__in IUIAutomationRegistrar * This,
            /* [in] */ __RPC__in const struct UIAutomationPatternInfo *pattern,
            /* [out] */ __RPC__out PATTERNID *pPatternId,
            /* [out] */ __RPC__out PROPERTYID *pPatternAvailablePropertyId,
            /* [in] */ UINT propertyIdCount,
            /* [size_is][out] */ __RPC__out_ecount_full(propertyIdCount) PROPERTYID *pPropertyIds,
            /* [in] */ UINT eventIdCount,
            /* [size_is][out] */ __RPC__out_ecount_full(eventIdCount) EVENTID *pEventIds);
        
        END_INTERFACE
    } IUIAutomationRegistrarVtbl;

    interface IUIAutomationRegistrar
    {
        CONST_VTBL struct IUIAutomationRegistrarVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIAutomationRegistrar_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIAutomationRegistrar_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIAutomationRegistrar_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIAutomationRegistrar_RegisterProperty(This,property,propertyId)	\
    ( (This)->lpVtbl -> RegisterProperty(This,property,propertyId) ) 

#define IUIAutomationRegistrar_RegisterEvent(This,event,eventId)	\
    ( (This)->lpVtbl -> RegisterEvent(This,event,eventId) ) 

#define IUIAutomationRegistrar_RegisterPattern(This,pattern,pPatternId,pPatternAvailablePropertyId,propertyIdCount,pPropertyIds,eventIdCount,pEventIds)	\
    ( (This)->lpVtbl -> RegisterPattern(This,pattern,pPatternId,pPatternAvailablePropertyId,propertyIdCount,pPropertyIds,eventIdCount,pEventIds) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIAutomationRegistrar_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_CUIAutomationRegistrar;

#ifdef __cplusplus

class DECLSPEC_UUID("6e29fabf-9977-42d1-8d0e-ca7e61ad87e6")
CUIAutomationRegistrar;
#endif
#endif /* __UIA_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Umx.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**          Copyright(c) Microsoft Corporation 1992 - 1999          **/
/**********************************************************************/

/*
    umx.h
    This file contains the common messages, manifests, types, and
    structures used by User Manager Extensions.

    NOTE:  You must include windows.h and lmcons.h *before* this file.
*/



#ifndef _UMX_H_
#define _UMX_H_



//
//  This is the maximum length allowed for an extension menu item.
//

#define UME_MENU_TEXT_LEN               50



//
//  This is the current version number of the extension interface.
//

#define UME_VERSION                     0


//
//  These are the two listboxes in the User Manager main window.
//

#define UMS_LISTBOX_USERS               0
#define UMS_LISTBOX_GROUPS              1


//
//  These are the messages sent from the extension to the
//  User Manager application.
//
//      UM_GETSELCOUNT
//
//              Purpose - Retrieves the number of selected items in
//                        the specified listbox.
//
//              wParam  - Listbox index.  This 0-based index specifies
//                        the listbox to query.  For the User Manager,
//                        this may be either UMS_LISTBOX_USERS or
//                        UMS_LISTBOX_GROUPS.
//
//              lParam  - Points to a UMS_GETSELCOUNT structure.
//
//              Returns - TRUE if successful, FALSE if unsuccessful.
//
//
//      UM_GETUSERSEL[AW]
//
//              Purpose - Retrieves a particular selection.
//
//              wParam  - Selection index.  This 0-based index specifies
//                        the selected item to query.  This is used here
//                        since the Users listbox is multiple-select.
//
//              lParam  - Points to a UMS_GETSEL[AW] structure.
//
//              Returns - TRUE if successful, FALSE if unsuccessful.
//
//
//      UM_GETGROUPSEL[AW]
//
//              Purpose - Retrieves a particular selection.
//
//              wParam  - Selection index.  This 0-based index specifies
//                        the selected item to query.  This is useful
//                        for muliple-select listboxes.  Since the Groups
//                        listbox is single-select, this value must always
//                        be zero.
//
//              lParam  - Points to a UMS_GETSEL[AW] structure.
//
//              Returns - TRUE if successful, FALSE if unsuccessful.
//
//
//      UM_GETCURFOCUS[AW]
//
//              Purpose - Retrieves the current application focus.
//
//              wParam  - Must be zero.
//
//              lParam  - Points to a UMS_GETCURFOCUS structure.
//
//              Returns - TRUE if successful, FALSE if unsuccessful.
//
//
//      UM_GETOPTIONS[2]
//
//              Purpose - Retrieves the current option settings
//
//              wParam  - Must be zero.
//
//              lParam  - Points to a UMS_GETOPTIONS[2] structure.
//
//              Returns - TRUE if successful, FALSE if unsuccessful.
//

#define UM_GETSELCOUNT                  (WM_USER + 1000)
#define UM_GETUSERSELA                  (WM_USER + 1001)
#define UM_GETUSERSELW                  (WM_USER + 1002)
#define UM_GETGROUPSELA                 (WM_USER + 1003)
#define UM_GETGROUPSELW                 (WM_USER + 1004)
#define UM_GETCURFOCUSA                 (WM_USER + 1005)
#define UM_GETCURFOCUSW                 (WM_USER + 1006)
#define UM_GETOPTIONS                   (WM_USER + 1007)
#define UM_GETOPTIONS2                  (WM_USER + 1008)

#ifdef UNICODE
#define UM_GETUSERSEL                 UM_GETUSERSELW
#define UM_GETGROUPSEL                UM_GETGROUPSELW
#define UM_GETCURFOCUS                UM_GETCURFOCUSW
#else   // !UNICODE
#define UM_GETUSERSEL                 UM_GETUSERSELA
#define UM_GETGROUPSEL                UM_GETGROUPSELA
#define UM_GETCURFOCUS                UM_GETCURFOCUSA
#endif  // UNICODE



//
//  These structures are used when the extension is
//  communicating with the application.
//


//
//  The UMS_LOADMENU[AW] structure is passed to the extension's
//  UMELoadMenu[AW] entrypoint when the extension is loaded.
//
//      dwVersion       - On entry to UMELoadMenu[AW], this will
//                        contain the maximum extension version
//                        supported by the User Manager.  If the
//                        extension supports a lower version, it
//                        should set this field appropriately before
//                        returning.  The User Manager will use
//                        the returned value to determine the
//                        capabilities of the extension.
//
//      szMenuName      - The name of the menu item that is to appear
//                        in the app's main menu.  This value will also
//                        appear in the "Help On Extensions" submene and
//                        the "View" menu.
//
//      hMenu           - A valid HMENU for the popup-menu to be inserted
//                        into the app's main menu.  Ownership of this
//                        handle transfers to the User Manager.  The
//                        extension should *not* destroy this handle.
//
//      szHelpFileName  - The name of the help file associated with this
//                        extension.  This file will be used for the
//                        "Help On Extensions" menu.  This will also be
//                        used when the user presses [F1] while the
//                        extension's menu is dropped.
//
//      dwMenuDelta     - The User Manager will apply this delta
//                        to each menu ID present in hMenu.  This is
//                        to prevent conflicts with other extension's
//                        menu IDs.
//

typedef struct _UMS_LOADMENUA
{
    DWORD       dwVersion;
    CHAR        szMenuName[UME_MENU_TEXT_LEN + 1];
    HMENU       hMenu;
    CHAR        szHelpFileName[MAX_PATH];
    DWORD       dwMenuDelta;

} UMS_LOADMENUA, * PUMS_LOADMENUA;

typedef struct _UMS_LOADMENUW
{
    DWORD       dwVersion;
    WCHAR       szMenuName[UME_MENU_TEXT_LEN + 1];
    HMENU       hMenu;
    WCHAR       szHelpFileName[MAX_PATH];
    DWORD       dwMenuDelta;

} UMS_LOADMENUW, * PUMS_LOADMENUW;

#ifdef UNICODE
#define UMS_LOADMENU                    UMS_LOADMENUW
#define PUMS_LOADMENU                   PUMS_LOADMENUW
#else   // !UNICODE
#define UMS_LOADMENU                    UMS_LOADMENUA
#define PUMS_LOADMENU                   PUMS_LOADMENUA
#endif  // UNICODE

#define UM_SELTYPE_USER     0x10
#define UM_SELTYPE_NORMALUSER   0x1 | UM_SELTYPE_USER
#define UM_SELTYPE_REMOTEUSER   0x2 | UM_SELTYPE_USER
#define UM_SELTYPE_GROUP    0x20
#define UM_SELTYPE_LOCALGROUP   0x4 | UM_SELTYPE_GROUP
#define UM_SELTYPE_GLOBALGROUP  0x8 | UM_SELTYPE_GROUP


//
//  The UMS_GETSEL[AW] structure is filled in by the User Manager
//  when it handles UM_GETUSERSEL[AW] or UM_GETGROUPSEL[AW] messages.
//  This is used to return the current selection to the extension.
//  Note that this structure contains pointers.  The extension should not
//  assume that these pointers will be valid forever, instead the
//  extension should promptly copy these strings and use the copies.
//
//      dwRID         - The RID of the item.  Note that the RID is not
//                      valid when the UMS_GETSEL describes a group.
//
//      pchName       - Will receive the name of the selected account.
//
//      dwSelType     - Will receive the account type mask associated
//                      with the account.
//
//      pchName       - Will receive the fullname of the selected account.
//                      Note that groups do not have fullnames.
//
//      pchComment    - Will receive the comment of the selected account.
//

typedef struct _UMS_GETSELA
{
    DWORD       dwRID;
    LPSTR       pchName;
    DWORD       dwSelType;
    LPSTR       pchFullName;
    LPSTR       pchComment;

} UMS_GETSELA, * PUMS_GETSELA;

typedef struct _UMS_GETSELW
{
    DWORD       dwRID;
    LPWSTR      pchName;
    DWORD       dwSelType;
    LPWSTR      pchFullName;
    LPWSTR      pchComment;

} UMS_GETSELW, * PUMS_GETSELW;

#ifdef UNICODE
#define UMS_GETSEL                  UMS_GETSELW
#define PUMS_GETSEL                 PUMS_GETSELW
#else   // !UNICODE
#define UMS_GETSEL                  UMS_GETSELA
#define PUMS_GETSEL                 PUMS_GETSELA
#endif  // UNICODE


//
//  The UMS_GETSELCOUNT structure is filled in by the User Manager
//  when it handles the UM_GETSELCOUNT message.  This is used to
//  return the number of selected items to the extension.  This could
//  be more than 1 for the user listbox.
//
//      dwItems         - The number of selected items in the listbox.
//

typedef struct _UMS_GETSELCOUNT
{
    DWORD       dwItems;
} UMS_GETSELCOUNT, * PUMS_GETSELCOUNT;


//
//  The UMS_GETCURFOCUS structure is filled in by the User Manager
//  when it handles the UM_GETCURFOCUS message.  This is used to
//  return the current focus of the User Manager application.
//
//      szFocus         - The domain name or server name of the current
//                        focus.  Server names can be distinguished
//                        by the leading backslashes, or by dwFocusType.
//
//      dwFocusType     - This is the type of focus, either
//                        UM_FOCUS_TYPE_DOMAIN (and szFocus is a domain name)
//                        UM_FOCUS_TYPE_WINNT  (and szFocus is a server name)
//                        UM_FOCUS_TYPE_LM     (and szFocus is a server name)
//                        UM_FOCUS_TYPE_UNKNOWN
//
//      szFocusPDC      - This is the PDC of the domain of focus, and is valid
//                        only if focus is set to UM_FOCUS_TYPE_DOMAIN.
//
//      psidFocus       - This points to the SID of the domain of focus.  It
//                        may be NULL.  Note that this pointer will not be
//                        valid forever, the extension should copy the SID
//                        immediately if it intends to use it.
//

#define UM_FOCUS_TYPE_DOMAIN    1
#define UM_FOCUS_TYPE_WINNT     2
#define UM_FOCUS_TYPE_LM        3
#define UM_FOCUS_TYPE_UNKNOWN   4

typedef struct _UMS_GETCURFOCUSA
{
    CHAR        szFocus[MAX_PATH];
    DWORD       dwFocusType;
    CHAR        szFocusPDC[MAX_PATH];
    PVOID       psidFocus;  // actually a SID pointer
} UMS_GETCURFOCUSA, * PUMS_GETCURFOCUSA;

typedef struct _UMS_GETCURFOCUSW
{
    WCHAR       szFocus[MAX_PATH];
    DWORD       dwFocusType;
    WCHAR       szFocusPDC[MAX_PATH];
    PVOID       psidFocus;  // actually a SID pointer
} UMS_GETCURFOCUSW, * PUMS_GETCURFOCUSW;

#ifdef UNICODE
#define UMS_GETCURFOCUS             UMS_GETCURFOCUSW
#define PUMS_GETCURFOCUS            PUMS_GETCURFOCUSW
#else   // UNICODE
#define UMS_GETCURFOCUS             UMS_GETCURFOCUSA
#define PUMS_GETCURFOCUS            PUMS_GETCURFOCUSA
#endif  // UNICODE


//
//  The UMS_GETOPTIONS[2] structure is filled in by the User Manager
//  when it handles the UM_GETOPTIONS[2] message.  This is used to
//  return the current option settings of the User Manager application.
//
//      fSaveSettingsOnExit - Should User Manager settings be saved on exit?
//
//      fConfirmation   - Should permanent and/or dangerous actions be
//                        confirmed?
//
//      fSortByFullName - Should the main user listbox be sorted by
//                        fullname rather than by user name?
//
//      fMiniUserManager - (UMS_GETOPTIONS2 only) Is this the User Manager
//                         rather than the User Manager for Domains?
//
//      fLowSpeedConnection - (UMS_GETOPTIONS2 only) Is the User Manager
//                            optimized for use across a slow network link?
//

typedef struct _UMS_GETOPTIONS
{
    BOOL        fSaveSettingsOnExit;
    BOOL        fConfirmation;
    BOOL        fSortByFullName;
} UMS_GETOPTIONS, * PUMS_GETOPTIONS;

typedef struct _UMS_GETOPTIONS2
{
    BOOL        fSaveSettingsOnExit;
    BOOL        fConfirmation;
    BOOL        fSortByFullName;
    BOOL        fMiniUserManager;
    BOOL        fLowSpeedConnection;
} UMS_GETOPTIONS2, * PUMS_GETOPTIONS2;




//
//  These are the names of the extension entrypoints.
//

#define SZ_UME_UNLOADMENU               "UMEUnloadMenu"
#define SZ_UME_INITIALIZEMENU           "UMEInitializeMenu"
#define SZ_UME_REFRESH                  "UMERefresh"
#define SZ_UME_MENUACTION               "UMEMenuAction"

#define SZ_UME_LOADMENUW                "UMELoadMenuW"
#define SZ_UME_GETEXTENDEDERRORSTRINGW  "UMEGetExtendedErrorStringW"
#define SZ_UME_CREATEW                  "UMECreateW"
#define SZ_UME_DELETEW                  "UMEDeleteW"
#define SZ_UME_RENAMEW                  "UMERenameW"

#define SZ_UME_LOADMENUA                "UMELoadMenuA"
#define SZ_UME_GETEXTENDEDERRORSTRINGA  "UMEGetExtendedErrorStringA"
#define SZ_UME_CREATEA                  "UMECreateA"
#define SZ_UME_DELETEA                  "UMEDeleteA"
#define SZ_UME_RENAMEA                  "UMERenameA"

#ifdef UNICODE
#define SZ_UME_LOADMENU                 SZ_UME_LOADMENUW
#define SZ_UME_GETEXTENDEDERRORSTRING   SZ_UME_GETEXTENDEDERRORSTRINGW
#define SZ_UME_CREATE                   SZ_UME_CREATEW
#define SZ_UME_DELETE                   SZ_UME_DELETEW
#define SZ_UME_RENAME                   SZ_UME_RENAMEW
#else   // !UNICODE
#define SZ_UME_LOADMENU                 SZ_UME_LOADMENUA
#define SZ_UME_GETEXTENDEDERRORSTRING   SZ_UME_GETEXTENDEDERRORSTRINGA
#define SZ_UME_CREATE                   SZ_UME_CREATEA
#define SZ_UME_DELETE                   SZ_UME_DELETEA
#define SZ_UME_RENAME                   SZ_UME_RENAMEA
#endif  // UNICODE



//
//  Typedefs for the extension entrypoints.
//

typedef DWORD (PASCAL * PUMX_LOADMENUW)( HWND          hWnd,
                                         PUMS_LOADMENUW pumsload );
typedef DWORD (PASCAL * PUMX_LOADMENUA)( HWND          hWnd,
                                         PUMS_LOADMENUA pumsload );

typedef LPWSTR (PASCAL * PUMX_GETEXTENDEDERRORSTRINGW)( VOID );
typedef LPSTR  (PASCAL * PUMX_GETEXTENDEDERRORSTRINGA)( VOID );

typedef VOID (PASCAL * PUMX_UNLOADMENU)( VOID );

typedef VOID (PASCAL * PUMX_INITIALIZEMENU)( VOID );

typedef VOID (PASCAL * PUMX_REFRESH)( HWND hwndParent );

typedef VOID (PASCAL * PUMX_MENUACTION)( HWND  hwndParent,
                                         DWORD dwEventId );

typedef VOID (PASCAL * PUMX_CREATEW)( HWND hwndParent,
                                      PUMS_GETSELW pumsSelection );
typedef VOID (PASCAL * PUMX_CREATEA)( HWND hwndParent,
                                      PUMS_GETSELA pumsSelection );

typedef VOID (PASCAL * PUMX_DELETEW)( HWND hwndParent,
                                      PUMS_GETSELW pumsSelection );
typedef VOID (PASCAL * PUMX_DELETEA)( HWND hwndParent,
                                      PUMS_GETSELA pumsSelection );

typedef VOID (PASCAL * PUMX_RENAMEW)( HWND hwndParent,
                                      PUMS_GETSELW pumsSelection,
                                      LPWSTR       pchNewName    );
typedef VOID (PASCAL * PUMX_RENAMEA)( HWND hwndParent,
                                      PUMS_GETSELA pumsSelection,
                                      LPSTR        pchNewName    );


#ifdef  UNICODE
#define PUMX_LOADMENU                   PUMX_LOADMENUW
#define PUMX_GETEXTENDEDERRORSTRING     PUMX_GETEXTENDEDERRORSTRINGW
#define PUMX_CREATE                     PUMX_CREATEW
#define PUMX_DELETE                     PUMX_DELETEW
#define PUMX_RENAME                     PUMX_RENAMEW
#else   // !UNICODE
#define PUMX_LOADMENU                   PUMX_LOADMENUA
#define PUMX_GETEXTENDEDERRORSTRING     PUMX_GETEXTENDEDERRORSTRINGA
#define PUMX_CREATE                     PUMX_CREATEA
#define PUMX_DELETE                     PUMX_DELETEA
#define PUMX_RENAME                     PUMX_RENAMEA
#endif  // UNICODE



//
//  Prototypes for the extension entrypoints.
//

DWORD PASCAL UMELoadMenuA( HWND           hwndMessage,
                           PUMS_LOADMENUA pumsload );

DWORD PASCAL UMELoadMenuW( HWND           hwndMessage,
                           PUMS_LOADMENUW pumsload );

LPSTR  PASCAL UMEGetExtendedErrorStringA( VOID );

LPWSTR PASCAL UMEGetExtendedErrorStringW( VOID );

VOID PASCAL UMEUnloadMenu( VOID );

VOID PASCAL UMEInitializeMenu( VOID );

VOID PASCAL UMERefresh( HWND hwndParent );

VOID PASCAL UMEMenuAction( HWND hwndParent,
                           DWORD dwEventId );

VOID PASCAL UMECreateA( HWND hwndParent,
                        PUMS_GETSELA pumsSelection );
VOID PASCAL UMECreateW( HWND hwndParent,
                        PUMS_GETSELW pumsSelection );

VOID PASCAL UMEDeleteA( HWND hwndParent,
                        PUMS_GETSELA pumsSelection );
VOID PASCAL UMEDeleteW( HWND hwndParent,
                        PUMS_GETSELW pumsSelection );

VOID PASCAL UMERenameA( HWND hwndParent,
                        PUMS_GETSELA pumsSelection,
                        LPSTR pchNewName );
VOID PASCAL UMERenameW( HWND hwndParent,
                        PUMS_GETSELW pumsSelection,
                        LPWSTR pchNewName );


#endif  // _UMX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\UIRibbonKeydef.h ===
//****************************************************************************
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:       UIRibbonKeyDef.h
//
//  Contents:   Windows Ribbon Framework Property Key Definition Macros
//
//****************************************************************************

#pragma once

#include <propkeydef.h>

#ifdef __cplusplus

extern "C++"
{

#ifndef TUIPROPERTYKEYDEFINED
// A version of PROPERTYKEY whose VARTYPE can be tested at compile time.
#include <pshpack8.h>
template<VARTYPE T>
struct TUIPROPERTYKEY
{ 
  GUID fmtid;
  DWORD pid;
  inline operator const PROPERTYKEY&() const { return reinterpret_cast<const PROPERTYKEY&>(*this); }
  inline const PROPERTYKEY* operator&() const { return reinterpret_cast<const PROPERTYKEY*>(this); }
};
#include <poppack.h>

C_ASSERT(sizeof(TUIPROPERTYKEY<VT_BOOL>) == sizeof(PROPERTYKEY));

#define TUIPROPERTYKEYDEFINED
#endif // TUIPROPERTYKEYDEFINED

#define DEFINE_UIPROPERTYKEY(name, type, index) \
    extern const TUIPROPERTYKEY<type> DECLSPEC_SELECTANY name = { { 0x00000000 + index, 0x7363, 0x696e, { 0x84, 0x41, 0x79, 0x8a, 0xcf, 0x5a, 0xeb, 0xb7 } }, type };

} // extern "C++"

#else // __cplusplus

#define DEFINE_UIPROPERTYKEY(name, type, index) EXTERN_C const PROPERTYKEY DECLSPEC_SELECTANY name = { { 0x00000000 + index, 0x7363, 0x696e, { 0x84, 0x41, 0x79, 0x8a, 0xcf, 0x5a, 0xeb, 0xb7 } }, type }

#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\UIRibbon.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for UIRibbon.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __UIRibbon_h__
#define __UIRibbon_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IUISimplePropertySet_FWD_DEFINED__
#define __IUISimplePropertySet_FWD_DEFINED__
typedef interface IUISimplePropertySet IUISimplePropertySet;
#endif 	/* __IUISimplePropertySet_FWD_DEFINED__ */


#ifndef __IUIRibbon_FWD_DEFINED__
#define __IUIRibbon_FWD_DEFINED__
typedef interface IUIRibbon IUIRibbon;
#endif 	/* __IUIRibbon_FWD_DEFINED__ */


#ifndef __IUIFramework_FWD_DEFINED__
#define __IUIFramework_FWD_DEFINED__
typedef interface IUIFramework IUIFramework;
#endif 	/* __IUIFramework_FWD_DEFINED__ */


#ifndef __IUIContextualUI_FWD_DEFINED__
#define __IUIContextualUI_FWD_DEFINED__
typedef interface IUIContextualUI IUIContextualUI;
#endif 	/* __IUIContextualUI_FWD_DEFINED__ */


#ifndef __IUICollection_FWD_DEFINED__
#define __IUICollection_FWD_DEFINED__
typedef interface IUICollection IUICollection;
#endif 	/* __IUICollection_FWD_DEFINED__ */


#ifndef __IUICollectionChangedEvent_FWD_DEFINED__
#define __IUICollectionChangedEvent_FWD_DEFINED__
typedef interface IUICollectionChangedEvent IUICollectionChangedEvent;
#endif 	/* __IUICollectionChangedEvent_FWD_DEFINED__ */


#ifndef __IUICommandHandler_FWD_DEFINED__
#define __IUICommandHandler_FWD_DEFINED__
typedef interface IUICommandHandler IUICommandHandler;
#endif 	/* __IUICommandHandler_FWD_DEFINED__ */


#ifndef __IUIApplication_FWD_DEFINED__
#define __IUIApplication_FWD_DEFINED__
typedef interface IUIApplication IUIApplication;
#endif 	/* __IUIApplication_FWD_DEFINED__ */


#ifndef __IUIImage_FWD_DEFINED__
#define __IUIImage_FWD_DEFINED__
typedef interface IUIImage IUIImage;
#endif 	/* __IUIImage_FWD_DEFINED__ */


#ifndef __IUIImageFromBitmap_FWD_DEFINED__
#define __IUIImageFromBitmap_FWD_DEFINED__
typedef interface IUIImageFromBitmap IUIImageFromBitmap;
#endif 	/* __IUIImageFromBitmap_FWD_DEFINED__ */


#ifndef __UIRibbonFramework_FWD_DEFINED__
#define __UIRibbonFramework_FWD_DEFINED__

#ifdef __cplusplus
typedef class UIRibbonFramework UIRibbonFramework;
#else
typedef struct UIRibbonFramework UIRibbonFramework;
#endif /* __cplusplus */

#endif 	/* __UIRibbonFramework_FWD_DEFINED__ */


#ifndef __UIRibbonImageFromBitmapFactory_FWD_DEFINED__
#define __UIRibbonImageFromBitmapFactory_FWD_DEFINED__

#ifdef __cplusplus
typedef class UIRibbonImageFromBitmapFactory UIRibbonImageFromBitmapFactory;
#else
typedef struct UIRibbonImageFromBitmapFactory UIRibbonImageFromBitmapFactory;
#endif /* __cplusplus */

#endif 	/* __UIRibbonImageFromBitmapFactory_FWD_DEFINED__ */


/* header files for imported files */
#include "propsys.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_UIRibbon_0000_0000 */
/* [local] */ 

//****************************************************************************
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:       UIRibbon.h (Generated from UIRibbon.idl)
//
//  Contents:   Interfaces for the Windows Ribbon Framework
//
//****************************************************************************
#pragma warning(push)
#pragma warning(disable:4001) 
#pragma once
#pragma warning(pop)
#include <UIRibbonKeyDef.h>
DEFINE_UIPROPERTYKEY(UI_PKEY_Enabled,                      VT_BOOL,                1); 
DEFINE_UIPROPERTYKEY(UI_PKEY_LabelDescription,             VT_LPWSTR,              2); 
DEFINE_UIPROPERTYKEY(UI_PKEY_Keytip,                       VT_LPWSTR,              3); 
DEFINE_UIPROPERTYKEY(UI_PKEY_Label,                        VT_LPWSTR,              4); 
DEFINE_UIPROPERTYKEY(UI_PKEY_TooltipDescription,           VT_LPWSTR,              5); 
DEFINE_UIPROPERTYKEY(UI_PKEY_TooltipTitle,                 VT_LPWSTR,              6); 
DEFINE_UIPROPERTYKEY(UI_PKEY_LargeImage,                   VT_UNKNOWN,             7); 
DEFINE_UIPROPERTYKEY(UI_PKEY_LargeHighContrastImage,       VT_UNKNOWN,             8); 
DEFINE_UIPROPERTYKEY(UI_PKEY_SmallImage,                   VT_UNKNOWN,             9); 
DEFINE_UIPROPERTYKEY(UI_PKEY_SmallHighContrastImage,       VT_UNKNOWN,             10); 
DEFINE_UIPROPERTYKEY(UI_PKEY_CommandId,                    VT_UI4,                 100); 
DEFINE_UIPROPERTYKEY(UI_PKEY_ItemsSource,                  VT_UNKNOWN,             101); 
DEFINE_UIPROPERTYKEY(UI_PKEY_Categories,                   VT_UNKNOWN,             102); 
DEFINE_UIPROPERTYKEY(UI_PKEY_CategoryId,                   VT_UI4,                 103); 
DEFINE_UIPROPERTYKEY(UI_PKEY_SelectedItem,                 VT_UI4,                 104); 
DEFINE_UIPROPERTYKEY(UI_PKEY_CommandType,                  VT_UI4,                 105); 
DEFINE_UIPROPERTYKEY(UI_PKEY_ItemImage,                    VT_UNKNOWN,             106); 
DEFINE_UIPROPERTYKEY(UI_PKEY_BooleanValue,                 VT_BOOL,                200); 
DEFINE_UIPROPERTYKEY(UI_PKEY_DecimalValue,                 VT_DECIMAL,             201); 
DEFINE_UIPROPERTYKEY(UI_PKEY_StringValue,                  VT_LPWSTR,              202); 
DEFINE_UIPROPERTYKEY(UI_PKEY_MaxValue,                     VT_DECIMAL,             203); 
DEFINE_UIPROPERTYKEY(UI_PKEY_MinValue,                     VT_DECIMAL,             204); 
DEFINE_UIPROPERTYKEY(UI_PKEY_Increment,                    VT_DECIMAL,             205); 
DEFINE_UIPROPERTYKEY(UI_PKEY_DecimalPlaces,                VT_UI4,                 206); 
DEFINE_UIPROPERTYKEY(UI_PKEY_FormatString,                 VT_LPWSTR,              207); 
DEFINE_UIPROPERTYKEY(UI_PKEY_RepresentativeString,         VT_LPWSTR,              208); 
DEFINE_UIPROPERTYKEY(UI_PKEY_FontProperties,                     VT_UNKNOWN,             300); 
DEFINE_UIPROPERTYKEY(UI_PKEY_FontProperties_Family,              VT_LPWSTR,              301); 
DEFINE_UIPROPERTYKEY(UI_PKEY_FontProperties_Size,                VT_DECIMAL,             302); 
DEFINE_UIPROPERTYKEY(UI_PKEY_FontProperties_Bold,                VT_UI4,                 303); 
DEFINE_UIPROPERTYKEY(UI_PKEY_FontProperties_Italic,              VT_UI4,                 304); 
DEFINE_UIPROPERTYKEY(UI_PKEY_FontProperties_Underline,           VT_UI4,                 305); 
DEFINE_UIPROPERTYKEY(UI_PKEY_FontProperties_Strikethrough,       VT_UI4,                 306); 
DEFINE_UIPROPERTYKEY(UI_PKEY_FontProperties_VerticalPositioning, VT_UI4,                 307); 
DEFINE_UIPROPERTYKEY(UI_PKEY_FontProperties_ForegroundColor,     VT_UI4,                 308); 
DEFINE_UIPROPERTYKEY(UI_PKEY_FontProperties_BackgroundColor,     VT_UI4,                 309); 
DEFINE_UIPROPERTYKEY(UI_PKEY_FontProperties_ForegroundColorType, VT_UI4,                 310); 
DEFINE_UIPROPERTYKEY(UI_PKEY_FontProperties_BackgroundColorType, VT_UI4,                 311); 
DEFINE_UIPROPERTYKEY(UI_PKEY_FontProperties_ChangedProperties,   VT_UNKNOWN,             312); 
DEFINE_UIPROPERTYKEY(UI_PKEY_FontProperties_DeltaSize,           VT_UI4,                 313); 
DEFINE_UIPROPERTYKEY(UI_PKEY_RecentItems,                  VT_ARRAY|VT_UNKNOWN,    350); 
DEFINE_UIPROPERTYKEY(UI_PKEY_Pinned,                       VT_BOOL,                351); 
DEFINE_UIPROPERTYKEY(UI_PKEY_Color,                        VT_UI4,                 400); 
DEFINE_UIPROPERTYKEY(UI_PKEY_ColorType,                    VT_UI4,                 401); 
DEFINE_UIPROPERTYKEY(UI_PKEY_ColorMode,                    VT_UI4,                 402); 
DEFINE_UIPROPERTYKEY(UI_PKEY_ThemeColorsCategoryLabel,     VT_LPWSTR,              403); 
DEFINE_UIPROPERTYKEY(UI_PKEY_StandardColorsCategoryLabel,  VT_LPWSTR,              404); 
DEFINE_UIPROPERTYKEY(UI_PKEY_RecentColorsCategoryLabel,    VT_LPWSTR,              405); 
DEFINE_UIPROPERTYKEY(UI_PKEY_AutomaticColorLabel,          VT_LPWSTR,              406); 
DEFINE_UIPROPERTYKEY(UI_PKEY_NoColorLabel,                 VT_LPWSTR,              407); 
DEFINE_UIPROPERTYKEY(UI_PKEY_MoreColorsLabel,              VT_LPWSTR,              408); 
DEFINE_UIPROPERTYKEY(UI_PKEY_ThemeColors,                  VT_VECTOR|VT_UI4,       409); 
DEFINE_UIPROPERTYKEY(UI_PKEY_StandardColors,               VT_VECTOR|VT_UI4,       410); 
DEFINE_UIPROPERTYKEY(UI_PKEY_ThemeColorsTooltips,          VT_VECTOR|VT_LPWSTR,    411); 
DEFINE_UIPROPERTYKEY(UI_PKEY_StandardColorsTooltips,       VT_VECTOR|VT_LPWSTR,    412); 
DEFINE_UIPROPERTYKEY(UI_PKEY_Viewable,                     VT_BOOL,                1000); 
DEFINE_UIPROPERTYKEY(UI_PKEY_Minimized,                    VT_BOOL,                1001); 
DEFINE_UIPROPERTYKEY(UI_PKEY_QuickAccessToolbarDock,       VT_UI4,                 1002); 
DEFINE_UIPROPERTYKEY(UI_PKEY_ContextAvailable,             VT_UI4,                 1100); 
DEFINE_UIPROPERTYKEY(UI_PKEY_GlobalBackgroundColor,        VT_UI4,                 2000); 
DEFINE_UIPROPERTYKEY(UI_PKEY_GlobalHighlightColor,         VT_UI4,                 2001); 
DEFINE_UIPROPERTYKEY(UI_PKEY_GlobalTextColor,              VT_UI4,                 2002); 
typedef DWORD UI_HSBCOLOR;
__inline UI_HSBCOLOR UI_HSB(BYTE hue, BYTE saturation, BYTE brightness)
{
    return hue | (saturation << 8) | (brightness << 16);
}
typedef /* [v1_enum] */ 
enum UI_CONTEXTAVAILABILITY
    {	UI_CONTEXTAVAILABILITY_NOTAVAILABLE	= 0,
	UI_CONTEXTAVAILABILITY_AVAILABLE	= 1,
	UI_CONTEXTAVAILABILITY_ACTIVE	= 2
    } 	UI_CONTEXTAVAILABILITY;

typedef /* [v1_enum] */ 
enum UI_FONTPROPERTIES
    {	UI_FONTPROPERTIES_NOTAVAILABLE	= 0,
	UI_FONTPROPERTIES_NOTSET	= 1,
	UI_FONTPROPERTIES_SET	= 2
    } 	UI_FONTPROPERTIES;

typedef /* [v1_enum] */ 
enum UI_FONTVERTICALPOSITION
    {	UI_FONTVERTICALPOSITION_NOTAVAILABLE	= 0,
	UI_FONTVERTICALPOSITION_NOTSET	= 1,
	UI_FONTVERTICALPOSITION_SUPERSCRIPT	= 2,
	UI_FONTVERTICALPOSITION_SUBSCRIPT	= 3
    } 	UI_FONTVERTICALPOSITION;

typedef /* [v1_enum] */ 
enum UI_FONTUNDERLINE
    {	UI_FONTUNDERLINE_NOTAVAILABLE	= 0,
	UI_FONTUNDERLINE_NOTSET	= 1,
	UI_FONTUNDERLINE_SET	= 2
    } 	UI_FONTUNDERLINE;

typedef /* [v1_enum] */ 
enum UI_FONTDELTASIZE
    {	UI_FONTDELTASIZE_GROW	= 0,
	UI_FONTDELTASIZE_SHRINK	= 1
    } 	UI_FONTDELTASIZE;

typedef /* [v1_enum] */ 
enum UI_CONTROLDOCK
    {	UI_CONTROLDOCK_TOP	= 1,
	UI_CONTROLDOCK_BOTTOM	= 3
    } 	UI_CONTROLDOCK;

typedef /* [v1_enum] */ 
enum UI_SWATCHCOLORTYPE
    {	UI_SWATCHCOLORTYPE_NOCOLOR	= 0,
	UI_SWATCHCOLORTYPE_AUTOMATIC	= 1,
	UI_SWATCHCOLORTYPE_RGB	= 2
    } 	UI_SWATCHCOLORTYPE;

typedef /* [v1_enum] */ 
enum UI_SWATCHCOLORMODE
    {	UI_SWATCHCOLORMODE_NORMAL	= 0,
	UI_SWATCHCOLORMODE_MONOCHROME	= 1
    } 	UI_SWATCHCOLORMODE;



extern RPC_IF_HANDLE __MIDL_itf_UIRibbon_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_UIRibbon_0000_0000_v0_0_s_ifspec;

#ifndef __IUISimplePropertySet_INTERFACE_DEFINED__
#define __IUISimplePropertySet_INTERFACE_DEFINED__

/* interface IUISimplePropertySet */
/* [local][unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IUISimplePropertySet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c205bb48-5b1c-4219-a106-15bd0a5f24e2")
    IUISimplePropertySet : public IUnknown
    {
    public:
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE GetValue( 
            /* [in] */ REFPROPERTYKEY key,
            /* [out] */ PROPVARIANT *value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUISimplePropertySetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUISimplePropertySet * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUISimplePropertySet * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUISimplePropertySet * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IUISimplePropertySet * This,
            /* [in] */ REFPROPERTYKEY key,
            /* [out] */ PROPVARIANT *value);
        
        END_INTERFACE
    } IUISimplePropertySetVtbl;

    interface IUISimplePropertySet
    {
        CONST_VTBL struct IUISimplePropertySetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUISimplePropertySet_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUISimplePropertySet_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUISimplePropertySet_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUISimplePropertySet_GetValue(This,key,value)	\
    ( (This)->lpVtbl -> GetValue(This,key,value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUISimplePropertySet_INTERFACE_DEFINED__ */


#ifndef __IUIRibbon_INTERFACE_DEFINED__
#define __IUIRibbon_INTERFACE_DEFINED__

/* interface IUIRibbon */
/* [local][unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IUIRibbon;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("803982ab-370a-4f7e-a9e7-8784036a6e26")
    IUIRibbon : public IUnknown
    {
    public:
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE GetHeight( 
            /* [out] */ UINT32 *cy) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE LoadSettingsFromStream( 
            /* [in] */ IStream *pStream) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE SaveSettingsToStream( 
            /* [in] */ IStream *pStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIRibbonVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUIRibbon * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUIRibbon * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUIRibbon * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *GetHeight )( 
            IUIRibbon * This,
            /* [out] */ UINT32 *cy);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *LoadSettingsFromStream )( 
            IUIRibbon * This,
            /* [in] */ IStream *pStream);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *SaveSettingsToStream )( 
            IUIRibbon * This,
            /* [in] */ IStream *pStream);
        
        END_INTERFACE
    } IUIRibbonVtbl;

    interface IUIRibbon
    {
        CONST_VTBL struct IUIRibbonVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIRibbon_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIRibbon_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIRibbon_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIRibbon_GetHeight(This,cy)	\
    ( (This)->lpVtbl -> GetHeight(This,cy) ) 

#define IUIRibbon_LoadSettingsFromStream(This,pStream)	\
    ( (This)->lpVtbl -> LoadSettingsFromStream(This,pStream) ) 

#define IUIRibbon_SaveSettingsToStream(This,pStream)	\
    ( (This)->lpVtbl -> SaveSettingsToStream(This,pStream) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIRibbon_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_UIRibbon_0000_0002 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_UIRibbon_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_UIRibbon_0000_0002_v0_0_s_ifspec;

#ifndef __IUIFramework_INTERFACE_DEFINED__
#define __IUIFramework_INTERFACE_DEFINED__

/* interface IUIFramework */
/* [local][unique][object][uuid][helpstring] */ 

typedef /* [v1_enum] */ 
enum UI_INVALIDATIONS
    {	UI_INVALIDATIONS_STATE	= 0x1,
	UI_INVALIDATIONS_VALUE	= 0x2,
	UI_INVALIDATIONS_PROPERTY	= 0x4,
	UI_INVALIDATIONS_ALLPROPERTIES	= 0x8
    } 	UI_INVALIDATIONS;

DEFINE_ENUM_FLAG_OPERATORS(UI_INVALIDATIONS)
#define	UI_ALL_COMMANDS	( 0 )


EXTERN_C const IID IID_IUIFramework;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F4F0385D-6872-43a8-AD09-4C339CB3F5C5")
    IUIFramework : public IUnknown
    {
    public:
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ HWND frameWnd,
            /* [in] */ IUIApplication *application) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Destroy( void) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE LoadUI( 
            /* [in] */ HINSTANCE instance,
            /* [in] */ LPCWSTR resourceName) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE GetView( 
            UINT32 viewId,
            REFIID riid,
            /* [annotation][iid_is][out] */ 
            __deref_out  void **ppv) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE GetUICommandProperty( 
            UINT32 commandId,
            /* [in] */ REFPROPERTYKEY key,
            /* [out] */ PROPVARIANT *value) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE SetUICommandProperty( 
            UINT32 commandId,
            /* [in] */ REFPROPERTYKEY key,
            /* [in] */ REFPROPVARIANT value) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE InvalidateUICommand( 
            UINT32 commandId,
            UI_INVALIDATIONS flags,
            /* [annotation][in] */ 
            __in_opt  const PROPERTYKEY *key) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FlushPendingInvalidations( void) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE SetModes( 
            INT32 iModes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIFrameworkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUIFramework * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUIFramework * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUIFramework * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IUIFramework * This,
            /* [in] */ HWND frameWnd,
            /* [in] */ IUIApplication *application);
        
        HRESULT ( STDMETHODCALLTYPE *Destroy )( 
            IUIFramework * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *LoadUI )( 
            IUIFramework * This,
            /* [in] */ HINSTANCE instance,
            /* [in] */ LPCWSTR resourceName);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *GetView )( 
            IUIFramework * This,
            UINT32 viewId,
            REFIID riid,
            /* [annotation][iid_is][out] */ 
            __deref_out  void **ppv);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *GetUICommandProperty )( 
            IUIFramework * This,
            UINT32 commandId,
            /* [in] */ REFPROPERTYKEY key,
            /* [out] */ PROPVARIANT *value);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *SetUICommandProperty )( 
            IUIFramework * This,
            UINT32 commandId,
            /* [in] */ REFPROPERTYKEY key,
            /* [in] */ REFPROPVARIANT value);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *InvalidateUICommand )( 
            IUIFramework * This,
            UINT32 commandId,
            UI_INVALIDATIONS flags,
            /* [annotation][in] */ 
            __in_opt  const PROPERTYKEY *key);
        
        HRESULT ( STDMETHODCALLTYPE *FlushPendingInvalidations )( 
            IUIFramework * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *SetModes )( 
            IUIFramework * This,
            INT32 iModes);
        
        END_INTERFACE
    } IUIFrameworkVtbl;

    interface IUIFramework
    {
        CONST_VTBL struct IUIFrameworkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIFramework_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIFramework_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIFramework_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIFramework_Initialize(This,frameWnd,application)	\
    ( (This)->lpVtbl -> Initialize(This,frameWnd,application) ) 

#define IUIFramework_Destroy(This)	\
    ( (This)->lpVtbl -> Destroy(This) ) 

#define IUIFramework_LoadUI(This,instance,resourceName)	\
    ( (This)->lpVtbl -> LoadUI(This,instance,resourceName) ) 

#define IUIFramework_GetView(This,viewId,riid,ppv)	\
    ( (This)->lpVtbl -> GetView(This,viewId,riid,ppv) ) 

#define IUIFramework_GetUICommandProperty(This,commandId,key,value)	\
    ( (This)->lpVtbl -> GetUICommandProperty(This,commandId,key,value) ) 

#define IUIFramework_SetUICommandProperty(This,commandId,key,value)	\
    ( (This)->lpVtbl -> SetUICommandProperty(This,commandId,key,value) ) 

#define IUIFramework_InvalidateUICommand(This,commandId,flags,key)	\
    ( (This)->lpVtbl -> InvalidateUICommand(This,commandId,flags,key) ) 

#define IUIFramework_FlushPendingInvalidations(This)	\
    ( (This)->lpVtbl -> FlushPendingInvalidations(This) ) 

#define IUIFramework_SetModes(This,iModes)	\
    ( (This)->lpVtbl -> SetModes(This,iModes) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIFramework_INTERFACE_DEFINED__ */


#ifndef __IUIContextualUI_INTERFACE_DEFINED__
#define __IUIContextualUI_INTERFACE_DEFINED__

/* interface IUIContextualUI */
/* [local][unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IUIContextualUI;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EEA11F37-7C46-437c-8E55-B52122B29293")
    IUIContextualUI : public IUnknown
    {
    public:
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE ShowAtLocation( 
            INT32 x,
            INT32 y) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIContextualUIVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUIContextualUI * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUIContextualUI * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUIContextualUI * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *ShowAtLocation )( 
            IUIContextualUI * This,
            INT32 x,
            INT32 y);
        
        END_INTERFACE
    } IUIContextualUIVtbl;

    interface IUIContextualUI
    {
        CONST_VTBL struct IUIContextualUIVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIContextualUI_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIContextualUI_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIContextualUI_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIContextualUI_ShowAtLocation(This,x,y)	\
    ( (This)->lpVtbl -> ShowAtLocation(This,x,y) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIContextualUI_INTERFACE_DEFINED__ */


#ifndef __IUICollection_INTERFACE_DEFINED__
#define __IUICollection_INTERFACE_DEFINED__

/* interface IUICollection */
/* [local][unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IUICollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DF4F45BF-6F9D-4dd7-9D68-D8F9CD18C4DB")
    IUICollection : public IUnknown
    {
    public:
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ UINT32 *count) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE GetItem( 
            UINT32 index,
            /* [annotation][out] */ 
            __deref_out  IUnknown **item) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ IUnknown *item) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE Insert( 
            UINT32 index,
            /* [in] */ IUnknown *item) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE RemoveAt( 
            UINT32 index) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE Replace( 
            UINT32 indexReplaced,
            /* [in] */ IUnknown *itemReplaceWith) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUICollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUICollection * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUICollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUICollection * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IUICollection * This,
            /* [out] */ UINT32 *count);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IUICollection * This,
            UINT32 index,
            /* [annotation][out] */ 
            __deref_out  IUnknown **item);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            IUICollection * This,
            /* [in] */ IUnknown *item);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *Insert )( 
            IUICollection * This,
            UINT32 index,
            /* [in] */ IUnknown *item);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            IUICollection * This,
            UINT32 index);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *Replace )( 
            IUICollection * This,
            UINT32 indexReplaced,
            /* [in] */ IUnknown *itemReplaceWith);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IUICollection * This);
        
        END_INTERFACE
    } IUICollectionVtbl;

    interface IUICollection
    {
        CONST_VTBL struct IUICollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUICollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUICollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUICollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUICollection_GetCount(This,count)	\
    ( (This)->lpVtbl -> GetCount(This,count) ) 

#define IUICollection_GetItem(This,index,item)	\
    ( (This)->lpVtbl -> GetItem(This,index,item) ) 

#define IUICollection_Add(This,item)	\
    ( (This)->lpVtbl -> Add(This,item) ) 

#define IUICollection_Insert(This,index,item)	\
    ( (This)->lpVtbl -> Insert(This,index,item) ) 

#define IUICollection_RemoveAt(This,index)	\
    ( (This)->lpVtbl -> RemoveAt(This,index) ) 

#define IUICollection_Replace(This,indexReplaced,itemReplaceWith)	\
    ( (This)->lpVtbl -> Replace(This,indexReplaced,itemReplaceWith) ) 

#define IUICollection_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUICollection_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_UIRibbon_0000_0005 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum UI_COLLECTIONCHANGE
    {	UI_COLLECTIONCHANGE_INSERT	= 0,
	UI_COLLECTIONCHANGE_REMOVE	= 1,
	UI_COLLECTIONCHANGE_REPLACE	= 2,
	UI_COLLECTIONCHANGE_RESET	= 3
    } 	UI_COLLECTIONCHANGE;

#define	UI_COLLECTION_INVALIDINDEX	( 0xffffffff )



extern RPC_IF_HANDLE __MIDL_itf_UIRibbon_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_UIRibbon_0000_0005_v0_0_s_ifspec;

#ifndef __IUICollectionChangedEvent_INTERFACE_DEFINED__
#define __IUICollectionChangedEvent_INTERFACE_DEFINED__

/* interface IUICollectionChangedEvent */
/* [local][unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IUICollectionChangedEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6502AE91-A14D-44b5-BBD0-62AACC581D52")
    IUICollectionChangedEvent : public IUnknown
    {
    public:
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE OnChanged( 
            UI_COLLECTIONCHANGE action,
            UINT32 oldIndex,
            /* [annotation][in] */ 
            __in_opt  IUnknown *oldItem,
            UINT32 newIndex,
            /* [annotation][in] */ 
            __in_opt  IUnknown *newItem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUICollectionChangedEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUICollectionChangedEvent * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUICollectionChangedEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUICollectionChangedEvent * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *OnChanged )( 
            IUICollectionChangedEvent * This,
            UI_COLLECTIONCHANGE action,
            UINT32 oldIndex,
            /* [annotation][in] */ 
            __in_opt  IUnknown *oldItem,
            UINT32 newIndex,
            /* [annotation][in] */ 
            __in_opt  IUnknown *newItem);
        
        END_INTERFACE
    } IUICollectionChangedEventVtbl;

    interface IUICollectionChangedEvent
    {
        CONST_VTBL struct IUICollectionChangedEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUICollectionChangedEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUICollectionChangedEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUICollectionChangedEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUICollectionChangedEvent_OnChanged(This,action,oldIndex,oldItem,newIndex,newItem)	\
    ( (This)->lpVtbl -> OnChanged(This,action,oldIndex,oldItem,newIndex,newItem) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUICollectionChangedEvent_INTERFACE_DEFINED__ */


#ifndef __IUICommandHandler_INTERFACE_DEFINED__
#define __IUICommandHandler_INTERFACE_DEFINED__

/* interface IUICommandHandler */
/* [local][unique][object][uuid][helpstring] */ 

typedef /* [v1_enum] */ 
enum UI_EXECUTIONVERB
    {	UI_EXECUTIONVERB_EXECUTE	= 0,
	UI_EXECUTIONVERB_PREVIEW	= 1,
	UI_EXECUTIONVERB_CANCELPREVIEW	= 2
    } 	UI_EXECUTIONVERB;


EXTERN_C const IID IID_IUICommandHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("75ae0a2d-dc03-4c9f-8883-069660d0beb6")
    IUICommandHandler : public IUnknown
    {
    public:
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE Execute( 
            UINT32 commandId,
            UI_EXECUTIONVERB verb,
            /* [annotation][in] */ 
            __in_opt  const PROPERTYKEY *key,
            /* [annotation][in] */ 
            __in_opt  const PROPVARIANT *currentValue,
            /* [annotation][in] */ 
            __in_opt  IUISimplePropertySet *commandExecutionProperties) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE UpdateProperty( 
            UINT32 commandId,
            /* [in] */ REFPROPERTYKEY key,
            /* [annotation][in] */ 
            __in_opt  const PROPVARIANT *currentValue,
            /* [out] */ PROPVARIANT *newValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUICommandHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUICommandHandler * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUICommandHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUICommandHandler * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *Execute )( 
            IUICommandHandler * This,
            UINT32 commandId,
            UI_EXECUTIONVERB verb,
            /* [annotation][in] */ 
            __in_opt  const PROPERTYKEY *key,
            /* [annotation][in] */ 
            __in_opt  const PROPVARIANT *currentValue,
            /* [annotation][in] */ 
            __in_opt  IUISimplePropertySet *commandExecutionProperties);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *UpdateProperty )( 
            IUICommandHandler * This,
            UINT32 commandId,
            /* [in] */ REFPROPERTYKEY key,
            /* [annotation][in] */ 
            __in_opt  const PROPVARIANT *currentValue,
            /* [out] */ PROPVARIANT *newValue);
        
        END_INTERFACE
    } IUICommandHandlerVtbl;

    interface IUICommandHandler
    {
        CONST_VTBL struct IUICommandHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUICommandHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUICommandHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUICommandHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUICommandHandler_Execute(This,commandId,verb,key,currentValue,commandExecutionProperties)	\
    ( (This)->lpVtbl -> Execute(This,commandId,verb,key,currentValue,commandExecutionProperties) ) 

#define IUICommandHandler_UpdateProperty(This,commandId,key,currentValue,newValue)	\
    ( (This)->lpVtbl -> UpdateProperty(This,commandId,key,currentValue,newValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUICommandHandler_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_UIRibbon_0000_0007 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum UI_COMMANDTYPE
    {	UI_COMMANDTYPE_UNKNOWN	= 0,
	UI_COMMANDTYPE_GROUP	= 1,
	UI_COMMANDTYPE_ACTION	= 2,
	UI_COMMANDTYPE_ANCHOR	= 3,
	UI_COMMANDTYPE_CONTEXT	= 4,
	UI_COMMANDTYPE_COLLECTION	= 5,
	UI_COMMANDTYPE_COMMANDCOLLECTION	= 6,
	UI_COMMANDTYPE_DECIMAL	= 7,
	UI_COMMANDTYPE_BOOLEAN	= 8,
	UI_COMMANDTYPE_FONT	= 9,
	UI_COMMANDTYPE_RECENTITEMS	= 10,
	UI_COMMANDTYPE_COLORANCHOR	= 11,
	UI_COMMANDTYPE_COLORCOLLECTION	= 12
    } 	UI_COMMANDTYPE;

typedef /* [v1_enum] */ 
enum UI_VIEWTYPE
    {	UI_VIEWTYPE_RIBBON	= 1
    } 	UI_VIEWTYPE;



extern RPC_IF_HANDLE __MIDL_itf_UIRibbon_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_UIRibbon_0000_0007_v0_0_s_ifspec;

#ifndef __IUIApplication_INTERFACE_DEFINED__
#define __IUIApplication_INTERFACE_DEFINED__

/* interface IUIApplication */
/* [local][unique][object][uuid][helpstring] */ 

typedef /* [v1_enum] */ 
enum UI_VIEWVERB
    {	UI_VIEWVERB_CREATE	= 0,
	UI_VIEWVERB_DESTROY	= 1,
	UI_VIEWVERB_SIZE	= 2,
	UI_VIEWVERB_ERROR	= 3
    } 	UI_VIEWVERB;


EXTERN_C const IID IID_IUIApplication;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D428903C-729A-491d-910D-682A08FF2522")
    IUIApplication : public IUnknown
    {
    public:
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE OnViewChanged( 
            UINT32 viewId,
            UI_VIEWTYPE typeID,
            /* [in] */ IUnknown *view,
            UI_VIEWVERB verb,
            INT32 uReasonCode) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE OnCreateUICommand( 
            UINT32 commandId,
            UI_COMMANDTYPE typeID,
            /* [out] */ IUICommandHandler **commandHandler) = 0;
        
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE OnDestroyUICommand( 
            UINT32 commandId,
            UI_COMMANDTYPE typeID,
            /* [annotation][in] */ 
            __in_opt  IUICommandHandler *commandHandler) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIApplicationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUIApplication * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUIApplication * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUIApplication * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *OnViewChanged )( 
            IUIApplication * This,
            UINT32 viewId,
            UI_VIEWTYPE typeID,
            /* [in] */ IUnknown *view,
            UI_VIEWVERB verb,
            INT32 uReasonCode);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *OnCreateUICommand )( 
            IUIApplication * This,
            UINT32 commandId,
            UI_COMMANDTYPE typeID,
            /* [out] */ IUICommandHandler **commandHandler);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *OnDestroyUICommand )( 
            IUIApplication * This,
            UINT32 commandId,
            UI_COMMANDTYPE typeID,
            /* [annotation][in] */ 
            __in_opt  IUICommandHandler *commandHandler);
        
        END_INTERFACE
    } IUIApplicationVtbl;

    interface IUIApplication
    {
        CONST_VTBL struct IUIApplicationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIApplication_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIApplication_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIApplication_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIApplication_OnViewChanged(This,viewId,typeID,view,verb,uReasonCode)	\
    ( (This)->lpVtbl -> OnViewChanged(This,viewId,typeID,view,verb,uReasonCode) ) 

#define IUIApplication_OnCreateUICommand(This,commandId,typeID,commandHandler)	\
    ( (This)->lpVtbl -> OnCreateUICommand(This,commandId,typeID,commandHandler) ) 

#define IUIApplication_OnDestroyUICommand(This,commandId,typeID,commandHandler)	\
    ( (This)->lpVtbl -> OnDestroyUICommand(This,commandId,typeID,commandHandler) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIApplication_INTERFACE_DEFINED__ */


#ifndef __IUIImage_INTERFACE_DEFINED__
#define __IUIImage_INTERFACE_DEFINED__

/* interface IUIImage */
/* [local][unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IUIImage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("23c8c838-4de6-436b-ab01-5554bb7c30dd")
    IUIImage : public IUnknown
    {
    public:
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE GetBitmap( 
            /* [out] */ HBITMAP *bitmap) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIImageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUIImage * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUIImage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUIImage * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *GetBitmap )( 
            IUIImage * This,
            /* [out] */ HBITMAP *bitmap);
        
        END_INTERFACE
    } IUIImageVtbl;

    interface IUIImage
    {
        CONST_VTBL struct IUIImageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIImage_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIImage_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIImage_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIImage_GetBitmap(This,bitmap)	\
    ( (This)->lpVtbl -> GetBitmap(This,bitmap) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIImage_INTERFACE_DEFINED__ */


#ifndef __IUIImageFromBitmap_INTERFACE_DEFINED__
#define __IUIImageFromBitmap_INTERFACE_DEFINED__

/* interface IUIImageFromBitmap */
/* [local][unique][object][uuid][helpstring] */ 

typedef /* [v1_enum] */ 
enum UI_OWNERSHIP
    {	UI_OWNERSHIP_TRANSFER	= 0,
	UI_OWNERSHIP_COPY	= 1
    } 	UI_OWNERSHIP;


EXTERN_C const IID IID_IUIImageFromBitmap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("18aba7f3-4c1c-4ba2-bf6c-f5c3326fa816")
    IUIImageFromBitmap : public IUnknown
    {
    public:
        virtual /* [annotation] */ 
        __checkReturn
        HRESULT STDMETHODCALLTYPE CreateImage( 
            /* [in] */ HBITMAP bitmap,
            UI_OWNERSHIP options,
            /* [out] */ IUIImage **image) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIImageFromBitmapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUIImageFromBitmap * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUIImageFromBitmap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUIImageFromBitmap * This);
        
        /* [annotation] */ 
        __checkReturn
        HRESULT ( STDMETHODCALLTYPE *CreateImage )( 
            IUIImageFromBitmap * This,
            /* [in] */ HBITMAP bitmap,
            UI_OWNERSHIP options,
            /* [out] */ IUIImage **image);
        
        END_INTERFACE
    } IUIImageFromBitmapVtbl;

    interface IUIImageFromBitmap
    {
        CONST_VTBL struct IUIImageFromBitmapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIImageFromBitmap_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUIImageFromBitmap_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUIImageFromBitmap_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUIImageFromBitmap_CreateImage(This,bitmap,options,image)	\
    ( (This)->lpVtbl -> CreateImage(This,bitmap,options,image) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUIImageFromBitmap_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_UIRibbon_0000_0010 */
/* [local] */ 

#define UI_MAKEAPPMODE(x) (1 << (x))
DEFINE_GUID(CLSID_UIRibbonFramework,0x926749fa, 0x2615, 0x4987, 0x88, 0x45, 0xc3, 0x3e, 0x65, 0xf2, 0xb9, 0x57);
DEFINE_GUID(CLSID_UIRibbonImageFromBitmapFactory,
                                    0x0f7434b6, 0x59b6, 0x4250, 0x99, 0x9e, 0xd1, 0x68, 0xd6, 0xae, 0x42, 0x93);
DEFINE_GUID(LIBID_UIRibbon,         0x942f35c2, 0xe83b, 0x45ef, 0xb0, 0x85, 0xac, 0x29, 0x5d, 0xd6, 0x3d, 0x5b);


extern RPC_IF_HANDLE __MIDL_itf_UIRibbon_0000_0010_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_UIRibbon_0000_0010_v0_0_s_ifspec;


#ifndef __UIRibbon_LIBRARY_DEFINED__
#define __UIRibbon_LIBRARY_DEFINED__

/* library UIRibbon */
/* [version][lcid][uuid] */ 


EXTERN_C const IID LIBID_UIRibbon;

EXTERN_C const CLSID CLSID_UIRibbonFramework;

#ifdef __cplusplus

class DECLSPEC_UUID("926749fa-2615-4987-8845-c33e65f2b957")
UIRibbonFramework;
#endif

EXTERN_C const CLSID CLSID_UIRibbonImageFromBitmapFactory;

#ifdef __cplusplus

class DECLSPEC_UUID("0F7434B6-59B6-4250-999E-D168D6AE4293")
UIRibbonImageFromBitmapFactory;
#endif
#endif /* __UIRibbon_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Unknwn.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for unknwn.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __unknwn_h__
#define __unknwn_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IUnknown_FWD_DEFINED__
#define __IUnknown_FWD_DEFINED__
typedef interface IUnknown IUnknown;
#endif 	/* __IUnknown_FWD_DEFINED__ */


#ifndef __AsyncIUnknown_FWD_DEFINED__
#define __AsyncIUnknown_FWD_DEFINED__
typedef interface AsyncIUnknown AsyncIUnknown;
#endif 	/* __AsyncIUnknown_FWD_DEFINED__ */


#ifndef __IClassFactory_FWD_DEFINED__
#define __IClassFactory_FWD_DEFINED__
typedef interface IClassFactory IClassFactory;
#endif 	/* __IClassFactory_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_unknwn_0000_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------
#if ( _MSC_VER >= 1020 )
#pragma once
#endif


extern RPC_IF_HANDLE __MIDL_itf_unknwn_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_unknwn_0000_0000_v0_0_s_ifspec;

#ifndef __IUnknown_INTERFACE_DEFINED__
#define __IUnknown_INTERFACE_DEFINED__

/* interface IUnknown */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IUnknown *LPUNKNOWN;

//////////////////////////////////////////////////////////////////
// IID_IUnknown and all other system IIDs are provided in UUID.LIB
// Link that library in with your proxies, clients and servers
//////////////////////////////////////////////////////////////////

#if (_MSC_VER >= 1100) && defined(__cplusplus) && !defined(CINTERFACE)
    EXTERN_C const IID IID_IUnknown;
    extern "C++"
    {
        MIDL_INTERFACE("00000000-0000-0000-C000-000000000046")
        IUnknown
        {
        public:
            BEGIN_INTERFACE
            virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
                /* [in] */ REFIID riid,
                /* [iid_is][out] */ __RPC__deref_out void __RPC_FAR *__RPC_FAR *ppvObject) = 0;

            virtual ULONG STDMETHODCALLTYPE AddRef( void) = 0;

            virtual ULONG STDMETHODCALLTYPE Release( void) = 0;

            template<class Q>
            HRESULT
#ifdef _M_CEE_PURE
            __clrcall
#else
            STDMETHODCALLTYPE
#endif
            QueryInterface(Q** pp)
            {
                return QueryInterface(__uuidof(Q), (void **)pp);
            }

            END_INTERFACE
        };
    } // extern C++
    HRESULT STDMETHODCALLTYPE IUnknown_QueryInterface_Proxy(
        IUnknown __RPC_FAR * This,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ __RPC__deref_out void __RPC_FAR *__RPC_FAR *ppvObject);
    
    void __RPC_STUB IUnknown_QueryInterface_Stub(
        IRpcStubBuffer *This,
        IRpcChannelBuffer *_pRpcChannelBuffer,
        PRPC_MESSAGE _pRpcMessage,
        DWORD *_pdwStubPhase);
    
    ULONG STDMETHODCALLTYPE IUnknown_AddRef_Proxy(
        IUnknown __RPC_FAR * This);
    
    void __RPC_STUB IUnknown_AddRef_Stub(
        IRpcStubBuffer *This,
        IRpcChannelBuffer *_pRpcChannelBuffer,
        PRPC_MESSAGE _pRpcMessage,
        DWORD *_pdwStubPhase);
    
    ULONG STDMETHODCALLTYPE IUnknown_Release_Proxy(
        IUnknown __RPC_FAR * This);
    
    void __RPC_STUB IUnknown_Release_Stub(
        IRpcStubBuffer *This,
        IRpcChannelBuffer *_pRpcChannelBuffer,
        PRPC_MESSAGE _pRpcMessage,
        DWORD *_pdwStubPhase);
#else

EXTERN_C const IID IID_IUnknown;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000000-0000-0000-C000-000000000046")
    IUnknown
    {
    public:
        BEGIN_INTERFACE
        virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject) = 0;
        
        virtual ULONG STDMETHODCALLTYPE AddRef( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE Release( void) = 0;
        
        END_INTERFACE
    };
    
#else 	/* C style interface */

    typedef struct IUnknownVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUnknown * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUnknown * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUnknown * This);
        
        END_INTERFACE
    } IUnknownVtbl;

    interface IUnknown
    {
        CONST_VTBL struct IUnknownVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUnknown_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUnknown_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUnknown_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUnknown_QueryInterface_Proxy( 
    IUnknown * This,
    /* [in] */ REFIID riid,
    /* [annotation][iid_is][out] */ 
    __RPC__deref_out  void **ppvObject);


void __RPC_STUB IUnknown_QueryInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IUnknown_AddRef_Proxy( 
    IUnknown * This);


void __RPC_STUB IUnknown_AddRef_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IUnknown_Release_Proxy( 
    IUnknown * This);


void __RPC_STUB IUnknown_Release_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUnknown_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_unknwn_0000_0001 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_unknwn_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_unknwn_0000_0001_v0_0_s_ifspec;

#ifndef __AsyncIUnknown_INTERFACE_DEFINED__
#define __AsyncIUnknown_INTERFACE_DEFINED__

/* interface AsyncIUnknown */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_AsyncIUnknown;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000e0000-0000-0000-C000-000000000046")
    AsyncIUnknown : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Begin_QueryInterface( 
            /* [in] */ REFIID riid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Finish_QueryInterface( 
            /* [annotation][out] */ 
            __RPC__deref_out  void **ppvObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Begin_AddRef( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE Finish_AddRef( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Begin_Release( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE Finish_Release( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct AsyncIUnknownVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            AsyncIUnknown * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            AsyncIUnknown * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            AsyncIUnknown * This);
        
        HRESULT ( STDMETHODCALLTYPE *Begin_QueryInterface )( 
            AsyncIUnknown * This,
            /* [in] */ REFIID riid);
        
        HRESULT ( STDMETHODCALLTYPE *Finish_QueryInterface )( 
            AsyncIUnknown * This,
            /* [annotation][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE *Begin_AddRef )( 
            AsyncIUnknown * This);
        
        ULONG ( STDMETHODCALLTYPE *Finish_AddRef )( 
            AsyncIUnknown * This);
        
        HRESULT ( STDMETHODCALLTYPE *Begin_Release )( 
            AsyncIUnknown * This);
        
        ULONG ( STDMETHODCALLTYPE *Finish_Release )( 
            AsyncIUnknown * This);
        
        END_INTERFACE
    } AsyncIUnknownVtbl;

    interface AsyncIUnknown
    {
        CONST_VTBL struct AsyncIUnknownVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define AsyncIUnknown_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define AsyncIUnknown_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define AsyncIUnknown_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define AsyncIUnknown_Begin_QueryInterface(This,riid)	\
    ( (This)->lpVtbl -> Begin_QueryInterface(This,riid) ) 

#define AsyncIUnknown_Finish_QueryInterface(This,ppvObject)	\
    ( (This)->lpVtbl -> Finish_QueryInterface(This,ppvObject) ) 

#define AsyncIUnknown_Begin_AddRef(This)	\
    ( (This)->lpVtbl -> Begin_AddRef(This) ) 

#define AsyncIUnknown_Finish_AddRef(This)	\
    ( (This)->lpVtbl -> Finish_AddRef(This) ) 

#define AsyncIUnknown_Begin_Release(This)	\
    ( (This)->lpVtbl -> Begin_Release(This) ) 

#define AsyncIUnknown_Finish_Release(This)	\
    ( (This)->lpVtbl -> Finish_Release(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __AsyncIUnknown_INTERFACE_DEFINED__ */


#ifndef __IClassFactory_INTERFACE_DEFINED__
#define __IClassFactory_INTERFACE_DEFINED__

/* interface IClassFactory */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IClassFactory *LPCLASSFACTORY;


EXTERN_C const IID IID_IClassFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000001-0000-0000-C000-000000000046")
    IClassFactory : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateInstance( 
            /* [unique][in] */ IUnknown *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE LockServer( 
            /* [in] */ BOOL fLock) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IClassFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IClassFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IClassFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IClassFactory * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CreateInstance )( 
            IClassFactory * This,
            /* [unique][in] */ IUnknown *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *LockServer )( 
            IClassFactory * This,
            /* [in] */ BOOL fLock);
        
        END_INTERFACE
    } IClassFactoryVtbl;

    interface IClassFactory
    {
        CONST_VTBL struct IClassFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IClassFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IClassFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IClassFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IClassFactory_CreateInstance(This,pUnkOuter,riid,ppvObject)	\
    ( (This)->lpVtbl -> CreateInstance(This,pUnkOuter,riid,ppvObject) ) 

#define IClassFactory_LockServer(This,fLock)	\
    ( (This)->lpVtbl -> LockServer(This,fLock) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IClassFactory_RemoteCreateInstance_Proxy( 
    __RPC__in IClassFactory * This,
    /* [in] */ __RPC__in REFIID riid,
    /* [iid_is][out] */ __RPC__deref_out_opt IUnknown **ppvObject);


void __RPC_STUB IClassFactory_RemoteCreateInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT __stdcall IClassFactory_RemoteLockServer_Proxy( 
    __RPC__in IClassFactory * This,
    /* [in] */ BOOL fLock);


void __RPC_STUB IClassFactory_RemoteLockServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IClassFactory_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* [local] */ HRESULT STDMETHODCALLTYPE IClassFactory_CreateInstance_Proxy( 
    IClassFactory * This,
    /* [unique][in] */ IUnknown *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppvObject);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IClassFactory_CreateInstance_Stub( 
    __RPC__in IClassFactory * This,
    /* [in] */ __RPC__in REFIID riid,
    /* [iid_is][out] */ __RPC__deref_out_opt IUnknown **ppvObject);

/* [local] */ HRESULT STDMETHODCALLTYPE IClassFactory_LockServer_Proxy( 
    IClassFactory * This,
    /* [in] */ BOOL fLock);


/* [call_as] */ HRESULT __stdcall IClassFactory_LockServer_Stub( 
    __RPC__in IClassFactory * This,
    /* [in] */ BOOL fLock);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\unexposeenums2managed.h ===
//------------------------------------------------------------------------------
// File: expose.h
//
// Desc: macros to allow the same enum to be exposed to native and managed.  
//
// USAGE:
//
// see comments at top of exposeenums2managed.h
//
// Copyright (c) 2003-2004, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------

// !!! do not pragma once or macro guard this file.
// it gets used multiple times by the same compilation units

#undef V1_ENUM
#undef V1_ENUMG
#undef ENUM
#undef ENUMG
#undef ENUM16
#undef FLAGS
#undef FLAGS16
#undef TAG
#undef EHRECVR_MGD_NAMESPACE
#undef ANALOG_VIDEO_STANDARD_NAMESPACE
#undef RATLEVEL
#undef RATATTR

// end of file - expose.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\UPnP.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for upnp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __upnp_h__
#define __upnp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IUPnPDeviceFinder_FWD_DEFINED__
#define __IUPnPDeviceFinder_FWD_DEFINED__
typedef interface IUPnPDeviceFinder IUPnPDeviceFinder;
#endif 	/* __IUPnPDeviceFinder_FWD_DEFINED__ */


#ifndef __IUPnPAddressFamilyControl_FWD_DEFINED__
#define __IUPnPAddressFamilyControl_FWD_DEFINED__
typedef interface IUPnPAddressFamilyControl IUPnPAddressFamilyControl;
#endif 	/* __IUPnPAddressFamilyControl_FWD_DEFINED__ */


#ifndef __IUPnPHttpHeaderControl_FWD_DEFINED__
#define __IUPnPHttpHeaderControl_FWD_DEFINED__
typedef interface IUPnPHttpHeaderControl IUPnPHttpHeaderControl;
#endif 	/* __IUPnPHttpHeaderControl_FWD_DEFINED__ */


#ifndef __IUPnPDeviceFinderCallback_FWD_DEFINED__
#define __IUPnPDeviceFinderCallback_FWD_DEFINED__
typedef interface IUPnPDeviceFinderCallback IUPnPDeviceFinderCallback;
#endif 	/* __IUPnPDeviceFinderCallback_FWD_DEFINED__ */


#ifndef __IUPnPServices_FWD_DEFINED__
#define __IUPnPServices_FWD_DEFINED__
typedef interface IUPnPServices IUPnPServices;
#endif 	/* __IUPnPServices_FWD_DEFINED__ */


#ifndef __IUPnPService_FWD_DEFINED__
#define __IUPnPService_FWD_DEFINED__
typedef interface IUPnPService IUPnPService;
#endif 	/* __IUPnPService_FWD_DEFINED__ */


#ifndef __IUPnPServiceCallback_FWD_DEFINED__
#define __IUPnPServiceCallback_FWD_DEFINED__
typedef interface IUPnPServiceCallback IUPnPServiceCallback;
#endif 	/* __IUPnPServiceCallback_FWD_DEFINED__ */


#ifndef __IUPnPDevices_FWD_DEFINED__
#define __IUPnPDevices_FWD_DEFINED__
typedef interface IUPnPDevices IUPnPDevices;
#endif 	/* __IUPnPDevices_FWD_DEFINED__ */


#ifndef __IUPnPDevice_FWD_DEFINED__
#define __IUPnPDevice_FWD_DEFINED__
typedef interface IUPnPDevice IUPnPDevice;
#endif 	/* __IUPnPDevice_FWD_DEFINED__ */


#ifndef __IUPnPDeviceDocumentAccess_FWD_DEFINED__
#define __IUPnPDeviceDocumentAccess_FWD_DEFINED__
typedef interface IUPnPDeviceDocumentAccess IUPnPDeviceDocumentAccess;
#endif 	/* __IUPnPDeviceDocumentAccess_FWD_DEFINED__ */


#ifndef __IUPnPDeviceDocumentAccessEx_FWD_DEFINED__
#define __IUPnPDeviceDocumentAccessEx_FWD_DEFINED__
typedef interface IUPnPDeviceDocumentAccessEx IUPnPDeviceDocumentAccessEx;
#endif 	/* __IUPnPDeviceDocumentAccessEx_FWD_DEFINED__ */


#ifndef __IUPnPDescriptionDocument_FWD_DEFINED__
#define __IUPnPDescriptionDocument_FWD_DEFINED__
typedef interface IUPnPDescriptionDocument IUPnPDescriptionDocument;
#endif 	/* __IUPnPDescriptionDocument_FWD_DEFINED__ */


#ifndef __IUPnPDeviceFinderAddCallbackWithInterface_FWD_DEFINED__
#define __IUPnPDeviceFinderAddCallbackWithInterface_FWD_DEFINED__
typedef interface IUPnPDeviceFinderAddCallbackWithInterface IUPnPDeviceFinderAddCallbackWithInterface;
#endif 	/* __IUPnPDeviceFinderAddCallbackWithInterface_FWD_DEFINED__ */


#ifndef __IUPnPDescriptionDocumentCallback_FWD_DEFINED__
#define __IUPnPDescriptionDocumentCallback_FWD_DEFINED__
typedef interface IUPnPDescriptionDocumentCallback IUPnPDescriptionDocumentCallback;
#endif 	/* __IUPnPDescriptionDocumentCallback_FWD_DEFINED__ */


#ifndef __UPnPDeviceFinder_FWD_DEFINED__
#define __UPnPDeviceFinder_FWD_DEFINED__

#ifdef __cplusplus
typedef class UPnPDeviceFinder UPnPDeviceFinder;
#else
typedef struct UPnPDeviceFinder UPnPDeviceFinder;
#endif /* __cplusplus */

#endif 	/* __UPnPDeviceFinder_FWD_DEFINED__ */


#ifndef __UPnPDevices_FWD_DEFINED__
#define __UPnPDevices_FWD_DEFINED__

#ifdef __cplusplus
typedef class UPnPDevices UPnPDevices;
#else
typedef struct UPnPDevices UPnPDevices;
#endif /* __cplusplus */

#endif 	/* __UPnPDevices_FWD_DEFINED__ */


#ifndef __UPnPDevice_FWD_DEFINED__
#define __UPnPDevice_FWD_DEFINED__

#ifdef __cplusplus
typedef class UPnPDevice UPnPDevice;
#else
typedef struct UPnPDevice UPnPDevice;
#endif /* __cplusplus */

#endif 	/* __UPnPDevice_FWD_DEFINED__ */


#ifndef __UPnPServices_FWD_DEFINED__
#define __UPnPServices_FWD_DEFINED__

#ifdef __cplusplus
typedef class UPnPServices UPnPServices;
#else
typedef struct UPnPServices UPnPServices;
#endif /* __cplusplus */

#endif 	/* __UPnPServices_FWD_DEFINED__ */


#ifndef __UPnPService_FWD_DEFINED__
#define __UPnPService_FWD_DEFINED__

#ifdef __cplusplus
typedef class UPnPService UPnPService;
#else
typedef struct UPnPService UPnPService;
#endif /* __cplusplus */

#endif 	/* __UPnPService_FWD_DEFINED__ */


#ifndef __UPnPDescriptionDocument_FWD_DEFINED__
#define __UPnPDescriptionDocument_FWD_DEFINED__

#ifdef __cplusplus
typedef class UPnPDescriptionDocument UPnPDescriptionDocument;
#else
typedef struct UPnPDescriptionDocument UPnPDescriptionDocument;
#endif /* __cplusplus */

#endif 	/* __UPnPDescriptionDocument_FWD_DEFINED__ */


#ifndef __IUPnPDeviceDocumentAccess_FWD_DEFINED__
#define __IUPnPDeviceDocumentAccess_FWD_DEFINED__
typedef interface IUPnPDeviceDocumentAccess IUPnPDeviceDocumentAccess;
#endif 	/* __IUPnPDeviceDocumentAccess_FWD_DEFINED__ */


#ifndef __IUPnPDeviceDocumentAccessEx_FWD_DEFINED__
#define __IUPnPDeviceDocumentAccessEx_FWD_DEFINED__
typedef interface IUPnPDeviceDocumentAccessEx IUPnPDeviceDocumentAccessEx;
#endif 	/* __IUPnPDeviceDocumentAccessEx_FWD_DEFINED__ */


#ifndef __IUPnPDeviceFinderCallback_FWD_DEFINED__
#define __IUPnPDeviceFinderCallback_FWD_DEFINED__
typedef interface IUPnPDeviceFinderCallback IUPnPDeviceFinderCallback;
#endif 	/* __IUPnPDeviceFinderCallback_FWD_DEFINED__ */


#ifndef __IUPnPDeviceFinderAddCallbackWithInterface_FWD_DEFINED__
#define __IUPnPDeviceFinderAddCallbackWithInterface_FWD_DEFINED__
typedef interface IUPnPDeviceFinderAddCallbackWithInterface IUPnPDeviceFinderAddCallbackWithInterface;
#endif 	/* __IUPnPDeviceFinderAddCallbackWithInterface_FWD_DEFINED__ */


#ifndef __IUPnPServiceCallback_FWD_DEFINED__
#define __IUPnPServiceCallback_FWD_DEFINED__
typedef interface IUPnPServiceCallback IUPnPServiceCallback;
#endif 	/* __IUPnPServiceCallback_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_upnp_0000_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------














#define UPNP_E_ROOT_ELEMENT_EXPECTED     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0200)
#define UPNP_E_DEVICE_ELEMENT_EXPECTED   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0201)
#define UPNP_E_SERVICE_ELEMENT_EXPECTED  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0202)
#define UPNP_E_SERVICE_NODE_INCOMPLETE   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0203)
#define UPNP_E_DEVICE_NODE_INCOMPLETE    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0204)
#define UPNP_E_ICON_ELEMENT_EXPECTED     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0205)
#define UPNP_E_ICON_NODE_INCOMPLETE      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0206)
#define UPNP_E_INVALID_ACTION            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0207)
#define UPNP_E_INVALID_ARGUMENTS         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0208)
#define UPNP_E_OUT_OF_SYNC               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0209)
#define UPNP_E_ACTION_REQUEST_FAILED     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0210)
#define UPNP_E_TRANSPORT_ERROR           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0211)
#define UPNP_E_VARIABLE_VALUE_UNKNOWN    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0212)
#define UPNP_E_INVALID_VARIABLE          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0213)
#define UPNP_E_DEVICE_ERROR              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0214)
#define UPNP_E_PROTOCOL_ERROR            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0215)
#define UPNP_E_ERROR_PROCESSING_RESPONSE MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0216)
#define UPNP_E_DEVICE_TIMEOUT            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0217)
#define UPNP_E_INVALID_DOCUMENT          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0500)
#define UPNP_E_EVENT_SUBSCRIPTION_FAILED MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0501)
#define FAULT_INVALID_ACTION             401
#define FAULT_INVALID_ARG                402
#define FAULT_INVALID_SEQUENCE_NUMBER    403
#define FAULT_INVALID_VARIABLE           404
#define FAULT_DEVICE_INTERNAL_ERROR      501
#define FAULT_ACTION_SPECIFIC_BASE       600
#define FAULT_ACTION_SPECIFIC_MAX        899
#define UPNP_E_ACTION_SPECIFIC_BASE      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0300)
#define UPNP_E_ACTION_SPECIFIC_MAX       (UPNP_E_ACTION_SPECIFIC_BASE + (FAULT_ACTION_SPECIFIC_MAX - FAULT_ACTION_SPECIFIC_BASE))
#ifndef UPNP_ADDRESSFAMILY_IPv4
#define UPNP_ADDRESSFAMILY_IPv4		0x1
#endif
#ifndef UPNP_ADDRESSFAMILY_IPv6
#define UPNP_ADDRESSFAMILY_IPv6		0x2
#endif
#ifndef UPNP_ADDRESSFAMILY_BOTH
#define UPNP_ADDRESSFAMILY_BOTH		0x3
#endif


extern RPC_IF_HANDLE __MIDL_itf_upnp_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_upnp_0000_0000_v0_0_s_ifspec;

#ifndef __IUPnPDeviceFinder_INTERFACE_DEFINED__
#define __IUPnPDeviceFinder_INTERFACE_DEFINED__

/* interface IUPnPDeviceFinder */
/* [nonextensible][unique][oleautomation][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IUPnPDeviceFinder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ADDA3D55-6F72-4319-BFF9-18600A539B10")
    IUPnPDeviceFinder : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FindByType( 
            /* [in] */ __RPC__in BSTR bstrTypeURI,
            /* [in] */ DWORD dwFlags,
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevices **pDevices) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateAsyncFind( 
            /* [in] */ __RPC__in BSTR bstrTypeURI,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IUnknown *punkDeviceFinderCallback,
            /* [retval][out] */ __RPC__out LONG *plFindData) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StartAsyncFind( 
            /* [in] */ LONG lFindData) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CancelAsyncFind( 
            /* [in] */ LONG lFindData) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FindByUDN( 
            /* [in] */ __RPC__in BSTR bstrUDN,
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevice **pDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPDeviceFinderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUPnPDeviceFinder * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUPnPDeviceFinder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUPnPDeviceFinder * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IUPnPDeviceFinder * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IUPnPDeviceFinder * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IUPnPDeviceFinder * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUPnPDeviceFinder * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *FindByType )( 
            __RPC__in IUPnPDeviceFinder * This,
            /* [in] */ __RPC__in BSTR bstrTypeURI,
            /* [in] */ DWORD dwFlags,
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevices **pDevices);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateAsyncFind )( 
            __RPC__in IUPnPDeviceFinder * This,
            /* [in] */ __RPC__in BSTR bstrTypeURI,
            /* [in] */ DWORD dwFlags,
            /* [in] */ __RPC__in_opt IUnknown *punkDeviceFinderCallback,
            /* [retval][out] */ __RPC__out LONG *plFindData);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StartAsyncFind )( 
            __RPC__in IUPnPDeviceFinder * This,
            /* [in] */ LONG lFindData);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CancelAsyncFind )( 
            __RPC__in IUPnPDeviceFinder * This,
            /* [in] */ LONG lFindData);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *FindByUDN )( 
            __RPC__in IUPnPDeviceFinder * This,
            /* [in] */ __RPC__in BSTR bstrUDN,
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevice **pDevice);
        
        END_INTERFACE
    } IUPnPDeviceFinderVtbl;

    interface IUPnPDeviceFinder
    {
        CONST_VTBL struct IUPnPDeviceFinderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPDeviceFinder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPDeviceFinder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPDeviceFinder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPDeviceFinder_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUPnPDeviceFinder_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUPnPDeviceFinder_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUPnPDeviceFinder_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUPnPDeviceFinder_FindByType(This,bstrTypeURI,dwFlags,pDevices)	\
    ( (This)->lpVtbl -> FindByType(This,bstrTypeURI,dwFlags,pDevices) ) 

#define IUPnPDeviceFinder_CreateAsyncFind(This,bstrTypeURI,dwFlags,punkDeviceFinderCallback,plFindData)	\
    ( (This)->lpVtbl -> CreateAsyncFind(This,bstrTypeURI,dwFlags,punkDeviceFinderCallback,plFindData) ) 

#define IUPnPDeviceFinder_StartAsyncFind(This,lFindData)	\
    ( (This)->lpVtbl -> StartAsyncFind(This,lFindData) ) 

#define IUPnPDeviceFinder_CancelAsyncFind(This,lFindData)	\
    ( (This)->lpVtbl -> CancelAsyncFind(This,lFindData) ) 

#define IUPnPDeviceFinder_FindByUDN(This,bstrUDN,pDevice)	\
    ( (This)->lpVtbl -> FindByUDN(This,bstrUDN,pDevice) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPDeviceFinder_INTERFACE_DEFINED__ */


#ifndef __IUPnPAddressFamilyControl_INTERFACE_DEFINED__
#define __IUPnPAddressFamilyControl_INTERFACE_DEFINED__

/* interface IUPnPAddressFamilyControl */
/* [unique][oleautomation][uuid][object] */ 


EXTERN_C const IID IID_IUPnPAddressFamilyControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E3BF6178-694E-459F-A5A6-191EA0FFA1C7")
    IUPnPAddressFamilyControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAddressFamily( 
            /* [in] */ LONG dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAddressFamily( 
            /* [out] */ __RPC__out LONG *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPAddressFamilyControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUPnPAddressFamilyControl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUPnPAddressFamilyControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUPnPAddressFamilyControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAddressFamily )( 
            __RPC__in IUPnPAddressFamilyControl * This,
            /* [in] */ LONG dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddressFamily )( 
            __RPC__in IUPnPAddressFamilyControl * This,
            /* [out] */ __RPC__out LONG *pdwFlags);
        
        END_INTERFACE
    } IUPnPAddressFamilyControlVtbl;

    interface IUPnPAddressFamilyControl
    {
        CONST_VTBL struct IUPnPAddressFamilyControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPAddressFamilyControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPAddressFamilyControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPAddressFamilyControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPAddressFamilyControl_SetAddressFamily(This,dwFlags)	\
    ( (This)->lpVtbl -> SetAddressFamily(This,dwFlags) ) 

#define IUPnPAddressFamilyControl_GetAddressFamily(This,pdwFlags)	\
    ( (This)->lpVtbl -> GetAddressFamily(This,pdwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPAddressFamilyControl_INTERFACE_DEFINED__ */


#ifndef __IUPnPHttpHeaderControl_INTERFACE_DEFINED__
#define __IUPnPHttpHeaderControl_INTERFACE_DEFINED__

/* interface IUPnPHttpHeaderControl */
/* [unique][oleautomation][uuid][object] */ 


EXTERN_C const IID IID_IUPnPHttpHeaderControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0405AF4F-8B5C-447C-80F2-B75984A31F3C")
    IUPnPHttpHeaderControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddRequestHeaders( 
            /* [in] */ __RPC__in BSTR bstrHttpHeaders) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPHttpHeaderControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUPnPHttpHeaderControl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUPnPHttpHeaderControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUPnPHttpHeaderControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddRequestHeaders )( 
            __RPC__in IUPnPHttpHeaderControl * This,
            /* [in] */ __RPC__in BSTR bstrHttpHeaders);
        
        END_INTERFACE
    } IUPnPHttpHeaderControlVtbl;

    interface IUPnPHttpHeaderControl
    {
        CONST_VTBL struct IUPnPHttpHeaderControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPHttpHeaderControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPHttpHeaderControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPHttpHeaderControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPHttpHeaderControl_AddRequestHeaders(This,bstrHttpHeaders)	\
    ( (This)->lpVtbl -> AddRequestHeaders(This,bstrHttpHeaders) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPHttpHeaderControl_INTERFACE_DEFINED__ */


#ifndef __IUPnPDeviceFinderCallback_INTERFACE_DEFINED__
#define __IUPnPDeviceFinderCallback_INTERFACE_DEFINED__

/* interface IUPnPDeviceFinderCallback */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUPnPDeviceFinderCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("415A984A-88B3-49F3-92AF-0508BEDF0D6C")
    IUPnPDeviceFinderCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DeviceAdded( 
            /* [in] */ LONG lFindData,
            /* [in] */ __RPC__in_opt IUPnPDevice *pDevice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeviceRemoved( 
            /* [in] */ LONG lFindData,
            /* [in] */ __RPC__in BSTR bstrUDN) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SearchComplete( 
            /* [in] */ LONG lFindData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPDeviceFinderCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUPnPDeviceFinderCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUPnPDeviceFinderCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUPnPDeviceFinderCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *DeviceAdded )( 
            __RPC__in IUPnPDeviceFinderCallback * This,
            /* [in] */ LONG lFindData,
            /* [in] */ __RPC__in_opt IUPnPDevice *pDevice);
        
        HRESULT ( STDMETHODCALLTYPE *DeviceRemoved )( 
            __RPC__in IUPnPDeviceFinderCallback * This,
            /* [in] */ LONG lFindData,
            /* [in] */ __RPC__in BSTR bstrUDN);
        
        HRESULT ( STDMETHODCALLTYPE *SearchComplete )( 
            __RPC__in IUPnPDeviceFinderCallback * This,
            /* [in] */ LONG lFindData);
        
        END_INTERFACE
    } IUPnPDeviceFinderCallbackVtbl;

    interface IUPnPDeviceFinderCallback
    {
        CONST_VTBL struct IUPnPDeviceFinderCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPDeviceFinderCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPDeviceFinderCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPDeviceFinderCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPDeviceFinderCallback_DeviceAdded(This,lFindData,pDevice)	\
    ( (This)->lpVtbl -> DeviceAdded(This,lFindData,pDevice) ) 

#define IUPnPDeviceFinderCallback_DeviceRemoved(This,lFindData,bstrUDN)	\
    ( (This)->lpVtbl -> DeviceRemoved(This,lFindData,bstrUDN) ) 

#define IUPnPDeviceFinderCallback_SearchComplete(This,lFindData)	\
    ( (This)->lpVtbl -> SearchComplete(This,lFindData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPDeviceFinderCallback_INTERFACE_DEFINED__ */


#ifndef __IUPnPServices_INTERFACE_DEFINED__
#define __IUPnPServices_INTERFACE_DEFINED__

/* interface IUPnPServices */
/* [nonextensible][unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IUPnPServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3F8C8E9E-9A7A-4DC8-BC41-FF31FA374956")
    IUPnPServices : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *plCount) = 0;
        
        virtual /* [helpstring][hidden][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt LPUNKNOWN *ppunk) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ __RPC__in BSTR bstrServiceId,
            /* [retval][out] */ __RPC__deref_out_opt IUPnPService **ppService) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUPnPServices * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUPnPServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUPnPServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IUPnPServices * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IUPnPServices * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IUPnPServices * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUPnPServices * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in IUPnPServices * This,
            /* [retval][out] */ __RPC__out long *plCount);
        
        /* [helpstring][hidden][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IUPnPServices * This,
            /* [retval][out] */ __RPC__deref_out_opt LPUNKNOWN *ppunk);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IUPnPServices * This,
            /* [in] */ __RPC__in BSTR bstrServiceId,
            /* [retval][out] */ __RPC__deref_out_opt IUPnPService **ppService);
        
        END_INTERFACE
    } IUPnPServicesVtbl;

    interface IUPnPServices
    {
        CONST_VTBL struct IUPnPServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPServices_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPServices_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPServices_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPServices_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUPnPServices_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUPnPServices_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUPnPServices_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUPnPServices_get_Count(This,plCount)	\
    ( (This)->lpVtbl -> get_Count(This,plCount) ) 

#define IUPnPServices_get__NewEnum(This,ppunk)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppunk) ) 

#define IUPnPServices_get_Item(This,bstrServiceId,ppService)	\
    ( (This)->lpVtbl -> get_Item(This,bstrServiceId,ppService) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPServices_INTERFACE_DEFINED__ */


#ifndef __IUPnPService_INTERFACE_DEFINED__
#define __IUPnPService_INTERFACE_DEFINED__

/* interface IUPnPService */
/* [nonextensible][unique][oleautomation][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IUPnPService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A295019C-DC65-47DD-90DC-7FE918A1AB44")
    IUPnPService : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE QueryStateVariable( 
            /* [in] */ __RPC__in BSTR bstrVariableName,
            /* [retval][out] */ __RPC__out VARIANT *pValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InvokeAction( 
            /* [in] */ __RPC__in BSTR bstrActionName,
            /* [in] */ VARIANT vInActionArgs,
            /* [out][in] */ __RPC__inout VARIANT *pvOutActionArgs,
            /* [retval][out] */ __RPC__out VARIANT *pvRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ServiceTypeIdentifier( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddCallback( 
            /* [in] */ __RPC__in_opt IUnknown *pUnkCallback) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Id( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LastTransportStatus( 
            /* [retval][out] */ __RPC__out long *plValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUPnPService * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUPnPService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUPnPService * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IUPnPService * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IUPnPService * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IUPnPService * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUPnPService * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *QueryStateVariable )( 
            __RPC__in IUPnPService * This,
            /* [in] */ __RPC__in BSTR bstrVariableName,
            /* [retval][out] */ __RPC__out VARIANT *pValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *InvokeAction )( 
            __RPC__in IUPnPService * This,
            /* [in] */ __RPC__in BSTR bstrActionName,
            /* [in] */ VARIANT vInActionArgs,
            /* [out][in] */ __RPC__inout VARIANT *pvOutActionArgs,
            /* [retval][out] */ __RPC__out VARIANT *pvRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceTypeIdentifier )( 
            __RPC__in IUPnPService * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddCallback )( 
            __RPC__in IUPnPService * This,
            /* [in] */ __RPC__in_opt IUnknown *pUnkCallback);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Id )( 
            __RPC__in IUPnPService * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastTransportStatus )( 
            __RPC__in IUPnPService * This,
            /* [retval][out] */ __RPC__out long *plValue);
        
        END_INTERFACE
    } IUPnPServiceVtbl;

    interface IUPnPService
    {
        CONST_VTBL struct IUPnPServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPService_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPService_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPService_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPService_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUPnPService_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUPnPService_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUPnPService_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUPnPService_QueryStateVariable(This,bstrVariableName,pValue)	\
    ( (This)->lpVtbl -> QueryStateVariable(This,bstrVariableName,pValue) ) 

#define IUPnPService_InvokeAction(This,bstrActionName,vInActionArgs,pvOutActionArgs,pvRetVal)	\
    ( (This)->lpVtbl -> InvokeAction(This,bstrActionName,vInActionArgs,pvOutActionArgs,pvRetVal) ) 

#define IUPnPService_get_ServiceTypeIdentifier(This,pVal)	\
    ( (This)->lpVtbl -> get_ServiceTypeIdentifier(This,pVal) ) 

#define IUPnPService_AddCallback(This,pUnkCallback)	\
    ( (This)->lpVtbl -> AddCallback(This,pUnkCallback) ) 

#define IUPnPService_get_Id(This,pbstrId)	\
    ( (This)->lpVtbl -> get_Id(This,pbstrId) ) 

#define IUPnPService_get_LastTransportStatus(This,plValue)	\
    ( (This)->lpVtbl -> get_LastTransportStatus(This,plValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPService_INTERFACE_DEFINED__ */


#ifndef __IUPnPServiceCallback_INTERFACE_DEFINED__
#define __IUPnPServiceCallback_INTERFACE_DEFINED__

/* interface IUPnPServiceCallback */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUPnPServiceCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("31fadca9-ab73-464b-b67d-5c1d0f83c8b8")
    IUPnPServiceCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StateVariableChanged( 
            /* [in] */ __RPC__in_opt IUPnPService *pus,
            /* [in] */ __RPC__in LPCWSTR pcwszStateVarName,
            /* [in] */ VARIANT vaValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ServiceInstanceDied( 
            /* [in] */ __RPC__in_opt IUPnPService *pus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPServiceCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUPnPServiceCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUPnPServiceCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUPnPServiceCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *StateVariableChanged )( 
            __RPC__in IUPnPServiceCallback * This,
            /* [in] */ __RPC__in_opt IUPnPService *pus,
            /* [in] */ __RPC__in LPCWSTR pcwszStateVarName,
            /* [in] */ VARIANT vaValue);
        
        HRESULT ( STDMETHODCALLTYPE *ServiceInstanceDied )( 
            __RPC__in IUPnPServiceCallback * This,
            /* [in] */ __RPC__in_opt IUPnPService *pus);
        
        END_INTERFACE
    } IUPnPServiceCallbackVtbl;

    interface IUPnPServiceCallback
    {
        CONST_VTBL struct IUPnPServiceCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPServiceCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPServiceCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPServiceCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPServiceCallback_StateVariableChanged(This,pus,pcwszStateVarName,vaValue)	\
    ( (This)->lpVtbl -> StateVariableChanged(This,pus,pcwszStateVarName,vaValue) ) 

#define IUPnPServiceCallback_ServiceInstanceDied(This,pus)	\
    ( (This)->lpVtbl -> ServiceInstanceDied(This,pus) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPServiceCallback_INTERFACE_DEFINED__ */


#ifndef __IUPnPDevices_INTERFACE_DEFINED__
#define __IUPnPDevices_INTERFACE_DEFINED__

/* interface IUPnPDevices */
/* [nonextensible][unique][oleautomation][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IUPnPDevices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FDBC0C73-BDA3-4C66-AC4F-F2D96FDAD68C")
    IUPnPDevices : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *plCount) = 0;
        
        virtual /* [helpstring][hidden][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt LPUNKNOWN *ppunk) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ __RPC__in BSTR bstrUDN,
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevice **ppDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPDevicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUPnPDevices * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUPnPDevices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUPnPDevices * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IUPnPDevices * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IUPnPDevices * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IUPnPDevices * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUPnPDevices * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in IUPnPDevices * This,
            /* [retval][out] */ __RPC__out long *plCount);
        
        /* [helpstring][hidden][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IUPnPDevices * This,
            /* [retval][out] */ __RPC__deref_out_opt LPUNKNOWN *ppunk);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IUPnPDevices * This,
            /* [in] */ __RPC__in BSTR bstrUDN,
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevice **ppDevice);
        
        END_INTERFACE
    } IUPnPDevicesVtbl;

    interface IUPnPDevices
    {
        CONST_VTBL struct IUPnPDevicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPDevices_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPDevices_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPDevices_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPDevices_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUPnPDevices_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUPnPDevices_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUPnPDevices_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUPnPDevices_get_Count(This,plCount)	\
    ( (This)->lpVtbl -> get_Count(This,plCount) ) 

#define IUPnPDevices_get__NewEnum(This,ppunk)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppunk) ) 

#define IUPnPDevices_get_Item(This,bstrUDN,ppDevice)	\
    ( (This)->lpVtbl -> get_Item(This,bstrUDN,ppDevice) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPDevices_INTERFACE_DEFINED__ */


#ifndef __IUPnPDevice_INTERFACE_DEFINED__
#define __IUPnPDevice_INTERFACE_DEFINED__

/* interface IUPnPDevice */
/* [nonextensible][unique][oleautomation][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IUPnPDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3D44D0D1-98C9-4889-ACD1-F9D674BF2221")
    IUPnPDevice : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsRootDevice( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pvarb) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RootDevice( 
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevice **ppudRootDevice) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ParentDevice( 
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevice **ppudDeviceParent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HasChildren( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pvarb) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Children( 
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevices **ppudChildren) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UniqueDeviceName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FriendlyName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PresentationURL( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ManufacturerName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ManufacturerURL( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ModelName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ModelNumber( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ModelURL( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UPC( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SerialNumber( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IconURL( 
            /* [in] */ __RPC__in BSTR bstrEncodingFormat,
            /* [in] */ LONG lSizeX,
            /* [in] */ LONG lSizeY,
            /* [in] */ LONG lBitDepth,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrIconURL) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Services( 
            /* [retval][out] */ __RPC__deref_out_opt IUPnPServices **ppusServices) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUPnPDevice * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUPnPDevice * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUPnPDevice * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IUPnPDevice * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IUPnPDevice * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IUPnPDevice * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUPnPDevice * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsRootDevice )( 
            __RPC__in IUPnPDevice * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pvarb);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RootDevice )( 
            __RPC__in IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevice **ppudRootDevice);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ParentDevice )( 
            __RPC__in IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevice **ppudDeviceParent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HasChildren )( 
            __RPC__in IUPnPDevice * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pvarb);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Children )( 
            __RPC__in IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevices **ppudChildren);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UniqueDeviceName )( 
            __RPC__in IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FriendlyName )( 
            __RPC__in IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            __RPC__in IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PresentationURL )( 
            __RPC__in IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ManufacturerName )( 
            __RPC__in IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ManufacturerURL )( 
            __RPC__in IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ModelName )( 
            __RPC__in IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ModelNumber )( 
            __RPC__in IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            __RPC__in IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ModelURL )( 
            __RPC__in IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UPC )( 
            __RPC__in IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SerialNumber )( 
            __RPC__in IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IconURL )( 
            __RPC__in IUPnPDevice * This,
            /* [in] */ __RPC__in BSTR bstrEncodingFormat,
            /* [in] */ LONG lSizeX,
            /* [in] */ LONG lSizeY,
            /* [in] */ LONG lBitDepth,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrIconURL);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Services )( 
            __RPC__in IUPnPDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt IUPnPServices **ppusServices);
        
        END_INTERFACE
    } IUPnPDeviceVtbl;

    interface IUPnPDevice
    {
        CONST_VTBL struct IUPnPDeviceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPDevice_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPDevice_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPDevice_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPDevice_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUPnPDevice_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUPnPDevice_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUPnPDevice_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUPnPDevice_get_IsRootDevice(This,pvarb)	\
    ( (This)->lpVtbl -> get_IsRootDevice(This,pvarb) ) 

#define IUPnPDevice_get_RootDevice(This,ppudRootDevice)	\
    ( (This)->lpVtbl -> get_RootDevice(This,ppudRootDevice) ) 

#define IUPnPDevice_get_ParentDevice(This,ppudDeviceParent)	\
    ( (This)->lpVtbl -> get_ParentDevice(This,ppudDeviceParent) ) 

#define IUPnPDevice_get_HasChildren(This,pvarb)	\
    ( (This)->lpVtbl -> get_HasChildren(This,pvarb) ) 

#define IUPnPDevice_get_Children(This,ppudChildren)	\
    ( (This)->lpVtbl -> get_Children(This,ppudChildren) ) 

#define IUPnPDevice_get_UniqueDeviceName(This,pbstr)	\
    ( (This)->lpVtbl -> get_UniqueDeviceName(This,pbstr) ) 

#define IUPnPDevice_get_FriendlyName(This,pbstr)	\
    ( (This)->lpVtbl -> get_FriendlyName(This,pbstr) ) 

#define IUPnPDevice_get_Type(This,pbstr)	\
    ( (This)->lpVtbl -> get_Type(This,pbstr) ) 

#define IUPnPDevice_get_PresentationURL(This,pbstr)	\
    ( (This)->lpVtbl -> get_PresentationURL(This,pbstr) ) 

#define IUPnPDevice_get_ManufacturerName(This,pbstr)	\
    ( (This)->lpVtbl -> get_ManufacturerName(This,pbstr) ) 

#define IUPnPDevice_get_ManufacturerURL(This,pbstr)	\
    ( (This)->lpVtbl -> get_ManufacturerURL(This,pbstr) ) 

#define IUPnPDevice_get_ModelName(This,pbstr)	\
    ( (This)->lpVtbl -> get_ModelName(This,pbstr) ) 

#define IUPnPDevice_get_ModelNumber(This,pbstr)	\
    ( (This)->lpVtbl -> get_ModelNumber(This,pbstr) ) 

#define IUPnPDevice_get_Description(This,pbstr)	\
    ( (This)->lpVtbl -> get_Description(This,pbstr) ) 

#define IUPnPDevice_get_ModelURL(This,pbstr)	\
    ( (This)->lpVtbl -> get_ModelURL(This,pbstr) ) 

#define IUPnPDevice_get_UPC(This,pbstr)	\
    ( (This)->lpVtbl -> get_UPC(This,pbstr) ) 

#define IUPnPDevice_get_SerialNumber(This,pbstr)	\
    ( (This)->lpVtbl -> get_SerialNumber(This,pbstr) ) 

#define IUPnPDevice_IconURL(This,bstrEncodingFormat,lSizeX,lSizeY,lBitDepth,pbstrIconURL)	\
    ( (This)->lpVtbl -> IconURL(This,bstrEncodingFormat,lSizeX,lSizeY,lBitDepth,pbstrIconURL) ) 

#define IUPnPDevice_get_Services(This,ppusServices)	\
    ( (This)->lpVtbl -> get_Services(This,ppusServices) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPDevice_INTERFACE_DEFINED__ */


#ifndef __IUPnPDeviceDocumentAccess_INTERFACE_DEFINED__
#define __IUPnPDeviceDocumentAccess_INTERFACE_DEFINED__

/* interface IUPnPDeviceDocumentAccess */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUPnPDeviceDocumentAccess;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E7772804-3287-418e-9072-CF2B47238981")
    IUPnPDeviceDocumentAccess : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDocumentURL( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDocument) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPDeviceDocumentAccessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUPnPDeviceDocumentAccess * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUPnPDeviceDocumentAccess * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUPnPDeviceDocumentAccess * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentURL )( 
            __RPC__in IUPnPDeviceDocumentAccess * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDocument);
        
        END_INTERFACE
    } IUPnPDeviceDocumentAccessVtbl;

    interface IUPnPDeviceDocumentAccess
    {
        CONST_VTBL struct IUPnPDeviceDocumentAccessVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPDeviceDocumentAccess_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPDeviceDocumentAccess_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPDeviceDocumentAccess_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPDeviceDocumentAccess_GetDocumentURL(This,pbstrDocument)	\
    ( (This)->lpVtbl -> GetDocumentURL(This,pbstrDocument) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPDeviceDocumentAccess_INTERFACE_DEFINED__ */


#ifndef __IUPnPDeviceDocumentAccessEx_INTERFACE_DEFINED__
#define __IUPnPDeviceDocumentAccessEx_INTERFACE_DEFINED__

/* interface IUPnPDeviceDocumentAccessEx */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUPnPDeviceDocumentAccessEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C4BC4050-6178-4BD1-A4B8-6398321F3247")
    IUPnPDeviceDocumentAccessEx : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDocument( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDocument) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPDeviceDocumentAccessExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUPnPDeviceDocumentAccessEx * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUPnPDeviceDocumentAccessEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUPnPDeviceDocumentAccessEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocument )( 
            __RPC__in IUPnPDeviceDocumentAccessEx * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDocument);
        
        END_INTERFACE
    } IUPnPDeviceDocumentAccessExVtbl;

    interface IUPnPDeviceDocumentAccessEx
    {
        CONST_VTBL struct IUPnPDeviceDocumentAccessExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPDeviceDocumentAccessEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPDeviceDocumentAccessEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPDeviceDocumentAccessEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPDeviceDocumentAccessEx_GetDocument(This,pbstrDocument)	\
    ( (This)->lpVtbl -> GetDocument(This,pbstrDocument) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPDeviceDocumentAccessEx_INTERFACE_DEFINED__ */


#ifndef __IUPnPDescriptionDocument_INTERFACE_DEFINED__
#define __IUPnPDescriptionDocument_INTERFACE_DEFINED__

/* interface IUPnPDescriptionDocument */
/* [nonextensible][unique][oleautomation][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IUPnPDescriptionDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("11d1c1b2-7daa-4c9e-9595-7f82ed206d1e")
    IUPnPDescriptionDocument : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReadyState( 
            /* [retval][out] */ __RPC__out LONG *plReadyState) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Load( 
            /* [in] */ __RPC__in BSTR bstrUrl) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LoadAsync( 
            /* [in] */ __RPC__in BSTR bstrUrl,
            /* [in] */ __RPC__in_opt IUnknown *punkCallback) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LoadResult( 
            /* [retval][out] */ __RPC__out long *phrError) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RootDevice( 
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevice **ppudRootDevice) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DeviceByUDN( 
            /* [in] */ __RPC__in BSTR bstrUDN,
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevice **ppudDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPDescriptionDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUPnPDescriptionDocument * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUPnPDescriptionDocument * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUPnPDescriptionDocument * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IUPnPDescriptionDocument * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IUPnPDescriptionDocument * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IUPnPDescriptionDocument * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUPnPDescriptionDocument * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReadyState )( 
            __RPC__in IUPnPDescriptionDocument * This,
            /* [retval][out] */ __RPC__out LONG *plReadyState);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Load )( 
            __RPC__in IUPnPDescriptionDocument * This,
            /* [in] */ __RPC__in BSTR bstrUrl);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LoadAsync )( 
            __RPC__in IUPnPDescriptionDocument * This,
            /* [in] */ __RPC__in BSTR bstrUrl,
            /* [in] */ __RPC__in_opt IUnknown *punkCallback);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LoadResult )( 
            __RPC__in IUPnPDescriptionDocument * This,
            /* [retval][out] */ __RPC__out long *phrError);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Abort )( 
            __RPC__in IUPnPDescriptionDocument * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RootDevice )( 
            __RPC__in IUPnPDescriptionDocument * This,
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevice **ppudRootDevice);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DeviceByUDN )( 
            __RPC__in IUPnPDescriptionDocument * This,
            /* [in] */ __RPC__in BSTR bstrUDN,
            /* [retval][out] */ __RPC__deref_out_opt IUPnPDevice **ppudDevice);
        
        END_INTERFACE
    } IUPnPDescriptionDocumentVtbl;

    interface IUPnPDescriptionDocument
    {
        CONST_VTBL struct IUPnPDescriptionDocumentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPDescriptionDocument_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPDescriptionDocument_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPDescriptionDocument_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPDescriptionDocument_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IUPnPDescriptionDocument_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IUPnPDescriptionDocument_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IUPnPDescriptionDocument_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IUPnPDescriptionDocument_get_ReadyState(This,plReadyState)	\
    ( (This)->lpVtbl -> get_ReadyState(This,plReadyState) ) 

#define IUPnPDescriptionDocument_Load(This,bstrUrl)	\
    ( (This)->lpVtbl -> Load(This,bstrUrl) ) 

#define IUPnPDescriptionDocument_LoadAsync(This,bstrUrl,punkCallback)	\
    ( (This)->lpVtbl -> LoadAsync(This,bstrUrl,punkCallback) ) 

#define IUPnPDescriptionDocument_get_LoadResult(This,phrError)	\
    ( (This)->lpVtbl -> get_LoadResult(This,phrError) ) 

#define IUPnPDescriptionDocument_Abort(This)	\
    ( (This)->lpVtbl -> Abort(This) ) 

#define IUPnPDescriptionDocument_RootDevice(This,ppudRootDevice)	\
    ( (This)->lpVtbl -> RootDevice(This,ppudRootDevice) ) 

#define IUPnPDescriptionDocument_DeviceByUDN(This,bstrUDN,ppudDevice)	\
    ( (This)->lpVtbl -> DeviceByUDN(This,bstrUDN,ppudDevice) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPDescriptionDocument_INTERFACE_DEFINED__ */


#ifndef __IUPnPDeviceFinderAddCallbackWithInterface_INTERFACE_DEFINED__
#define __IUPnPDeviceFinderAddCallbackWithInterface_INTERFACE_DEFINED__

/* interface IUPnPDeviceFinderAddCallbackWithInterface */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUPnPDeviceFinderAddCallbackWithInterface;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("983dfc0b-1796-44df-8975-ca545b620ee5")
    IUPnPDeviceFinderAddCallbackWithInterface : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DeviceAddedWithInterface( 
            /* [in] */ LONG lFindData,
            /* [in] */ __RPC__in_opt IUPnPDevice *pDevice,
            /* [in] */ __RPC__in GUID *pguidInterface) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPDeviceFinderAddCallbackWithInterfaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUPnPDeviceFinderAddCallbackWithInterface * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUPnPDeviceFinderAddCallbackWithInterface * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUPnPDeviceFinderAddCallbackWithInterface * This);
        
        HRESULT ( STDMETHODCALLTYPE *DeviceAddedWithInterface )( 
            __RPC__in IUPnPDeviceFinderAddCallbackWithInterface * This,
            /* [in] */ LONG lFindData,
            /* [in] */ __RPC__in_opt IUPnPDevice *pDevice,
            /* [in] */ __RPC__in GUID *pguidInterface);
        
        END_INTERFACE
    } IUPnPDeviceFinderAddCallbackWithInterfaceVtbl;

    interface IUPnPDeviceFinderAddCallbackWithInterface
    {
        CONST_VTBL struct IUPnPDeviceFinderAddCallbackWithInterfaceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPDeviceFinderAddCallbackWithInterface_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPDeviceFinderAddCallbackWithInterface_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPDeviceFinderAddCallbackWithInterface_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPDeviceFinderAddCallbackWithInterface_DeviceAddedWithInterface(This,lFindData,pDevice,pguidInterface)	\
    ( (This)->lpVtbl -> DeviceAddedWithInterface(This,lFindData,pDevice,pguidInterface) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPDeviceFinderAddCallbackWithInterface_INTERFACE_DEFINED__ */


#ifndef __IUPnPDescriptionDocumentCallback_INTERFACE_DEFINED__
#define __IUPnPDescriptionDocumentCallback_INTERFACE_DEFINED__

/* interface IUPnPDescriptionDocumentCallback */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IUPnPDescriptionDocumentCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77394c69-5486-40d6-9bc3-4991983e02da")
    IUPnPDescriptionDocumentCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE LoadComplete( 
            /* [in] */ HRESULT hrLoadResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPDescriptionDocumentCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUPnPDescriptionDocumentCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUPnPDescriptionDocumentCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUPnPDescriptionDocumentCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *LoadComplete )( 
            __RPC__in IUPnPDescriptionDocumentCallback * This,
            /* [in] */ HRESULT hrLoadResult);
        
        END_INTERFACE
    } IUPnPDescriptionDocumentCallbackVtbl;

    interface IUPnPDescriptionDocumentCallback
    {
        CONST_VTBL struct IUPnPDescriptionDocumentCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPDescriptionDocumentCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPDescriptionDocumentCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPDescriptionDocumentCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPDescriptionDocumentCallback_LoadComplete(This,hrLoadResult)	\
    ( (This)->lpVtbl -> LoadComplete(This,hrLoadResult) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPDescriptionDocumentCallback_INTERFACE_DEFINED__ */



#ifndef __UPNPLib_LIBRARY_DEFINED__
#define __UPNPLib_LIBRARY_DEFINED__

/* library UPNPLib */
/* [helpstring][version][uuid] */ 







EXTERN_C const IID LIBID_UPNPLib;

EXTERN_C const CLSID CLSID_UPnPDeviceFinder;

#ifdef __cplusplus

class DECLSPEC_UUID("E2085F28-FEB7-404A-B8E7-E659BDEAAA02")
UPnPDeviceFinder;
#endif

EXTERN_C const CLSID CLSID_UPnPDevices;

#ifdef __cplusplus

class DECLSPEC_UUID("B9E84FFD-AD3C-40A4-B835-0882EBCBAAA8")
UPnPDevices;
#endif

EXTERN_C const CLSID CLSID_UPnPDevice;

#ifdef __cplusplus

class DECLSPEC_UUID("A32552C5-BA61-457A-B59A-A2561E125E33")
UPnPDevice;
#endif

EXTERN_C const CLSID CLSID_UPnPServices;

#ifdef __cplusplus

class DECLSPEC_UUID("C0BC4B4A-A406-4EFC-932F-B8546B8100CC")
UPnPServices;
#endif

EXTERN_C const CLSID CLSID_UPnPService;

#ifdef __cplusplus

class DECLSPEC_UUID("C624BA95-FBCB-4409-8C03-8CCEEC533EF1")
UPnPService;
#endif

EXTERN_C const CLSID CLSID_UPnPDescriptionDocument;

#ifdef __cplusplus

class DECLSPEC_UUID("1d8a9b47-3a28-4ce2-8a4b-bd34e45bceeb")
UPnPDescriptionDocument;
#endif
#endif /* __UPNPLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     __RPC__in unsigned long *, __RPC__in VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     __RPC__in unsigned long *, __RPC__in VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\UIRibbonPropertyHelpers.h ===
//****************************************************************************
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:       UIRibbonPropertyHelpers.h
//
//  Contents:   Property helper functions for the Windows Ribbon Framework
//
//****************************************************************************

#pragma once

#include <propvarutil.h>

interface IUIImage;

#ifndef TUIPROPERTYKEYDEFINED
// A version of PROPERTYKEY whose VARTYPE can be tested at compile time.
#include <pshpack8.h>
template<VARTYPE T>
struct TUIPROPERTYKEY
{ 
  GUID fmtid;
  DWORD pid;
  inline operator const PROPERTYKEY&() const { return reinterpret_cast<const PROPERTYKEY&>(*this); }
  inline const PROPERTYKEY* operator&() const { return reinterpret_cast<const PROPERTYKEY*>(this); }
};
#include <poppack.h>

C_ASSERT(sizeof(TUIPROPERTYKEY<VT_BOOL>) == sizeof(PROPERTYKEY));

#define TUIPROPERTYKEYDEFINED
#endif // TUIPROPERTYKEYDEFINED

// UIBreakCheckType is being used to do both Compilation and Runtime checking of types on PROPVARIANTs

struct UIWrongType {};

template<class A, VARTYPE B>
struct UIBreakCheckType 
{ 
    // If a PROPERTYKEY/type combination is invalid, compilation will break (it will try to cast a bool to UIWrongType)
    typedef UIWrongType _Type; 
    static bool Validate(REFPROPERTYKEY key) { UNREFERENCED_PARAMETER(key); return false; }
};

#define UI_REGISTER_TYPE( type ) \
    template<> struct UIBreakCheckType< TUIPROPERTYKEY<type>, type > \
    { \
        typedef bool _Type; \
        static bool Validate(REFPROPERTYKEY key) { UNREFERENCED_PARAMETER(key); return true; } \
    }; \
    template<> struct UIBreakCheckType< PROPERTYKEY, type > \
    { \
        typedef bool _Type; \
        /* we cannot catch at compilation time when PROPERTYKEYs are by reference, so check at runtime */ \
        static bool Validate(REFPROPERTYKEY key) { return (type) == key.pid; }\
    }; 
    
// Register known types
UI_REGISTER_TYPE( VT_BOOL )
UI_REGISTER_TYPE( VT_UI4 )
UI_REGISTER_TYPE( VT_LPWSTR )
UI_REGISTER_TYPE( VT_DECIMAL )
UI_REGISTER_TYPE( VT_UNKNOWN )
UI_REGISTER_TYPE( VT_ARRAY|VT_UNKNOWN )

//======================================================================================
// PROPVARIANT initializer helpers

template<class T>
HRESULT UIInitPropertyFromBoolean(const T& propertyKey, BOOL fVal, __out PROPVARIANT* pPropVar)
{
    // If this fails to compile, it means this property is not of type VT_BOOL
    UIBreakCheckType<T, VT_BOOL>::_Type valid = UIBreakCheckType<T, VT_BOOL>::Validate(propertyKey);
    return valid ? InitPropVariantFromBoolean(fVal, pPropVar) : E_INVALIDARG;
}

template<class T>
HRESULT UIInitPropertyFromUInt32(const T& propertyKey, UINT ulVal, __out PROPVARIANT* pPropVar)
{
    // If this fails to compile, it means this property is not of type VT_UI4
    UIBreakCheckType<T, VT_UI4>::_Type valid = UIBreakCheckType<T, VT_UI4>::Validate(propertyKey);
    return valid ? InitPropVariantFromUInt32(ulVal, pPropVar) : E_INVALIDARG;
}

template<class T>
HRESULT UIInitPropertyFromString(const T& propertyKey, __in PCWSTR psz, __out PROPVARIANT* pPropVar)
{
    // If this fails to compile, it means this property is not of type VT_LPWSTR
    UIBreakCheckType<T, VT_LPWSTR>::_Type valid = UIBreakCheckType<T, VT_LPWSTR>::Validate(propertyKey);
    return valid ? InitPropVariantFromString(psz, pPropVar) : E_INVALIDARG;
}

template<class T>
HRESULT UIInitPropertyFromDecimal(const T& propertyKey, const DECIMAL& decValue, __out PROPVARIANT* pPropVar)
{
    // If this fails to compile, it means this property is not of type VT_DECIMAL
    UIBreakCheckType<T, VT_DECIMAL>::_Type valid = UIBreakCheckType<T, VT_DECIMAL>::Validate(propertyKey);
    if (valid)
    {
        //  Must set decVal before vt because the two overlap.
        pPropVar->decVal = decValue;
        pPropVar->vt = VT_DECIMAL;
        return S_OK;
    }
    return E_INVALIDARG;
}

template<class T>
HRESULT UIInitPropertyFromInterface(const T& propertyKey, __in IUnknown* pUnk, __out PROPVARIANT* pPropVar)
{
    // If this fails to compile, it means this property is not of type VT_UNKNOWN
    UIBreakCheckType<T, VT_UNKNOWN>::_Type valid = UIBreakCheckType<T, VT_UNKNOWN>::Validate(propertyKey);
    if (valid)
    {
        pPropVar->vt = VT_UNKNOWN;
        pPropVar->punkVal = pUnk;
        if (pUnk)
        {
            pUnk->AddRef();
        }
        return S_OK;
    }
    return E_INVALIDARG;
}

template<class T>
HRESULT UIInitPropertyFromImage(const T& propertyKey, __in IUIImage* pImage, __out PROPVARIANT* pPropVar)
{
    return UIInitPropertyFromInterface(propertyKey, pImage, pPropVar);
}

template<class T>
HRESULT UIInitPropertyFromIUnknownArray(const T& propertyKey, __in SAFEARRAY* psa, __out PROPVARIANT* pPropVar)
{
    // If this fails to compile, it means this property is not of type VT_ARRAY
    UIBreakCheckType<T, VT_ARRAY|VT_UNKNOWN>::_Type valid = UIBreakCheckType<T, VT_ARRAY|VT_UNKNOWN>::Validate(propertyKey);
    if (valid && (psa->fFeatures & FADF_UNKNOWN) )
    {
        HRESULT hr = ::SafeArrayCopy(psa, &pPropVar->parray);
        if (SUCCEEDED(hr))
        {
            pPropVar->vt = VT_ARRAY|VT_UNKNOWN;
        }
        return hr;
    }
    return E_INVALIDARG;
}

//======================================================================================
// Extract value from PROPVARIANT

template<class T>
HRESULT UIPropertyToBoolean(const T& propertyKey, REFPROPVARIANT propvarIn, __out BOOL *pfRet)
{
    // If this fails to compile, it means this property is not of type VT_BOOL
    UIBreakCheckType<T, VT_BOOL>::_Type valid = UIBreakCheckType<T, VT_BOOL>::Validate(propertyKey);
    return valid ? PropVariantToBoolean(propvarIn, pfRet) : E_INVALIDARG;
}

template<class T>
HRESULT UIPropertyToUInt32(const T& propertyKey, REFPROPVARIANT propvarIn, __out UINT *pulVal)
{
    // If this fails to compile, it means this property is not of type VT_UI4
    UIBreakCheckType<T, VT_UI4>::_Type valid = UIBreakCheckType<T, VT_UI4>::Validate(propertyKey);
    return valid ? PropVariantToUInt32(propvarIn, pulVal) : E_INVALIDARG;
}

// Allocate a new string and return it in ppszOut
template<class T>
HRESULT UIPropertyToStringAlloc(const T& propertyKey, REFPROPVARIANT propvarIn, __deref_out PWSTR *ppszOut)
{
    // If this fails to compile, it means this property is not of type VT_LPWSTR
    UIBreakCheckType<T, VT_LPWSTR>::_Type valid = UIBreakCheckType<T, VT_LPWSTR>::Validate(propertyKey);
    return valid ? PropVariantToStringAlloc(propvarIn, ppszOut) : E_INVALIDARG;
}

template<class T>
HRESULT UIPropertyToDecimal(const T& propertyKey, REFPROPVARIANT propvarIn, __out DECIMAL *pDecValue)
{
    // If this fails to compile, it means this property is not of type VT_DECIMAL
    UIBreakCheckType<T, VT_DECIMAL>::_Type valid = UIBreakCheckType<T, VT_DECIMAL>::Validate(propertyKey);
    if (valid && propvarIn.vt == VT_DECIMAL)
    {
        *pDecValue = propvarIn.decVal;
        return S_OK;
    }
    return E_INVALIDARG;
}

template<class T, class TInterface>
HRESULT UIPropertyToInterface(const T& propertyKey, REFPROPVARIANT propvarIn, __deref_out TInterface** ppObj)
{
    *ppObj = NULL;
    // If this fails to compile, it means this property is not of type VT_UNKNOWN
    UIBreakCheckType<T, VT_UNKNOWN>::_Type valid = UIBreakCheckType<T, VT_UNKNOWN>::Validate(propertyKey);
    if (valid && propvarIn.vt == VT_UNKNOWN)
    {
        if (propvarIn.punkVal)
        {
            return propvarIn.punkVal->QueryInterface(__uuidof(TInterface), (void**)ppObj);
        }
        return S_OK;
    }
    return E_INVALIDARG;
}

template<class T>
HRESULT UIPropertyToImage(const T& propertyKey, REFPROPVARIANT propvarIn, __deref_out IUIImage** ppImage)
{
    return UIPropertyToInterface(propertyKey, propvarIn, ppImage);
}

template<class T>
HRESULT UIPropertyToIUnknownArrayAlloc(const T& propertyKey, REFPROPVARIANT propvarIn, __deref_out SAFEARRAY** ppsa)
{
    // If this fails to compile, it means this property is not of type VT_ARRAY
    UIBreakCheckType<T, VT_ARRAY|VT_UNKNOWN>::_Type valid = UIBreakCheckType<T, VT_ARRAY|VT_UNKNOWN>::Validate(propertyKey);
    if (valid && propvarIn.vt == (VT_ARRAY|VT_UNKNOWN) )
    {
        return ::SafeArrayCopy(propvarIn.parray, ppsa);
    }
    return E_INVALIDARG;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\upnphost.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for upnphost.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __upnphost_h__
#define __upnphost_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IUPnPEventSink_FWD_DEFINED__
#define __IUPnPEventSink_FWD_DEFINED__
typedef interface IUPnPEventSink IUPnPEventSink;
#endif 	/* __IUPnPEventSink_FWD_DEFINED__ */


#ifndef __IUPnPEventSource_FWD_DEFINED__
#define __IUPnPEventSource_FWD_DEFINED__
typedef interface IUPnPEventSource IUPnPEventSource;
#endif 	/* __IUPnPEventSource_FWD_DEFINED__ */


#ifndef __IUPnPRegistrar_FWD_DEFINED__
#define __IUPnPRegistrar_FWD_DEFINED__
typedef interface IUPnPRegistrar IUPnPRegistrar;
#endif 	/* __IUPnPRegistrar_FWD_DEFINED__ */


#ifndef __IUPnPReregistrar_FWD_DEFINED__
#define __IUPnPReregistrar_FWD_DEFINED__
typedef interface IUPnPReregistrar IUPnPReregistrar;
#endif 	/* __IUPnPReregistrar_FWD_DEFINED__ */


#ifndef __IUPnPDeviceControl_FWD_DEFINED__
#define __IUPnPDeviceControl_FWD_DEFINED__
typedef interface IUPnPDeviceControl IUPnPDeviceControl;
#endif 	/* __IUPnPDeviceControl_FWD_DEFINED__ */


#ifndef __IUPnPDeviceProvider_FWD_DEFINED__
#define __IUPnPDeviceProvider_FWD_DEFINED__
typedef interface IUPnPDeviceProvider IUPnPDeviceProvider;
#endif 	/* __IUPnPDeviceProvider_FWD_DEFINED__ */


#ifndef __IUPnPRemoteEndpointInfo_FWD_DEFINED__
#define __IUPnPRemoteEndpointInfo_FWD_DEFINED__
typedef interface IUPnPRemoteEndpointInfo IUPnPRemoteEndpointInfo;
#endif 	/* __IUPnPRemoteEndpointInfo_FWD_DEFINED__ */


#ifndef __IUPnPEventSink_FWD_DEFINED__
#define __IUPnPEventSink_FWD_DEFINED__
typedef interface IUPnPEventSink IUPnPEventSink;
#endif 	/* __IUPnPEventSink_FWD_DEFINED__ */


#ifndef __IUPnPEventSource_FWD_DEFINED__
#define __IUPnPEventSource_FWD_DEFINED__
typedef interface IUPnPEventSource IUPnPEventSource;
#endif 	/* __IUPnPEventSource_FWD_DEFINED__ */


#ifndef __IUPnPRegistrar_FWD_DEFINED__
#define __IUPnPRegistrar_FWD_DEFINED__
typedef interface IUPnPRegistrar IUPnPRegistrar;
#endif 	/* __IUPnPRegistrar_FWD_DEFINED__ */


#ifndef __IUPnPReregistrar_FWD_DEFINED__
#define __IUPnPReregistrar_FWD_DEFINED__
typedef interface IUPnPReregistrar IUPnPReregistrar;
#endif 	/* __IUPnPReregistrar_FWD_DEFINED__ */


#ifndef __IUPnPDeviceControl_FWD_DEFINED__
#define __IUPnPDeviceControl_FWD_DEFINED__
typedef interface IUPnPDeviceControl IUPnPDeviceControl;
#endif 	/* __IUPnPDeviceControl_FWD_DEFINED__ */


#ifndef __IUPnPDeviceProvider_FWD_DEFINED__
#define __IUPnPDeviceProvider_FWD_DEFINED__
typedef interface IUPnPDeviceProvider IUPnPDeviceProvider;
#endif 	/* __IUPnPDeviceProvider_FWD_DEFINED__ */


#ifndef __IUPnPRemoteEndpointInfo_FWD_DEFINED__
#define __IUPnPRemoteEndpointInfo_FWD_DEFINED__
typedef interface IUPnPRemoteEndpointInfo IUPnPRemoteEndpointInfo;
#endif 	/* __IUPnPRemoteEndpointInfo_FWD_DEFINED__ */


#ifndef __UPnPRegistrar_FWD_DEFINED__
#define __UPnPRegistrar_FWD_DEFINED__

#ifdef __cplusplus
typedef class UPnPRegistrar UPnPRegistrar;
#else
typedef struct UPnPRegistrar UPnPRegistrar;
#endif /* __cplusplus */

#endif 	/* __UPnPRegistrar_FWD_DEFINED__ */


#ifndef __UPnPRemoteEndpointInfo_FWD_DEFINED__
#define __UPnPRemoteEndpointInfo_FWD_DEFINED__

#ifdef __cplusplus
typedef class UPnPRemoteEndpointInfo UPnPRemoteEndpointInfo;
#else
typedef struct UPnPRemoteEndpointInfo UPnPRemoteEndpointInfo;
#endif /* __cplusplus */

#endif 	/* __UPnPRemoteEndpointInfo_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_upnphost_0000_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------







#define UPNP_E_REQUIRED_ELEMENT_ERROR        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA020)
#define UPNP_E_DUPLICATE_NOT_ALLOWED         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA021)
#define UPNP_E_DUPLICATE_SERVICE_ID          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA022)
#define UPNP_E_INVALID_DESCRIPTION           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA023)
#define UPNP_E_INVALID_SERVICE               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA024)
#define UPNP_E_INVALID_ICON                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA025)
#define UPNP_E_INVALID_XML                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA026)
#define UPNP_E_INVALID_ROOT_NAMESPACE        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA027)
#define UPNP_E_SUFFIX_TOO_LONG               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA028)
#define UPNP_E_URLBASE_PRESENT               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA029)
#define UPNP_E_VALUE_TOO_LONG                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA030)
#define UPNP_E_DEVICE_RUNNING                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA031)
#define UPNP_E_DEVICE_NOTREGISTERED          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA032)
// Remote address value is a string
#define REMOTE_ADDRESS_VALUE_NAME L"RemoteAddress"
// Address family value is a DWORD
#define ADDRESS_FAMILY_VALUE_NAME L"AddressFamily"


extern RPC_IF_HANDLE __MIDL_itf_upnphost_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_upnphost_0000_0000_v0_0_s_ifspec;

#ifndef __IUPnPEventSink_INTERFACE_DEFINED__
#define __IUPnPEventSink_INTERFACE_DEFINED__

/* interface IUPnPEventSink */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IUPnPEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("204810b4-73b2-11d4-bf42-00b0d0118b56")
    IUPnPEventSink : public IUnknown
    {
    public:
        virtual /* [hidden][helpstring] */ HRESULT STDMETHODCALLTYPE OnStateChanged( 
            /* [in] */ DWORD cChanges,
            /* [size_is][in] */ __RPC__in_ecount_full(cChanges) DISPID rgdispidChanges[  ]) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnStateChangedSafe( 
            /* [in] */ VARIANT varsadispidChanges) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUPnPEventSink * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUPnPEventSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUPnPEventSink * This);
        
        /* [hidden][helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnStateChanged )( 
            __RPC__in IUPnPEventSink * This,
            /* [in] */ DWORD cChanges,
            /* [size_is][in] */ __RPC__in_ecount_full(cChanges) DISPID rgdispidChanges[  ]);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnStateChangedSafe )( 
            __RPC__in IUPnPEventSink * This,
            /* [in] */ VARIANT varsadispidChanges);
        
        END_INTERFACE
    } IUPnPEventSinkVtbl;

    interface IUPnPEventSink
    {
        CONST_VTBL struct IUPnPEventSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPEventSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPEventSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPEventSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPEventSink_OnStateChanged(This,cChanges,rgdispidChanges)	\
    ( (This)->lpVtbl -> OnStateChanged(This,cChanges,rgdispidChanges) ) 

#define IUPnPEventSink_OnStateChangedSafe(This,varsadispidChanges)	\
    ( (This)->lpVtbl -> OnStateChangedSafe(This,varsadispidChanges) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPEventSink_INTERFACE_DEFINED__ */


#ifndef __IUPnPEventSource_INTERFACE_DEFINED__
#define __IUPnPEventSource_INTERFACE_DEFINED__

/* interface IUPnPEventSource */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IUPnPEventSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("204810b5-73b2-11d4-bf42-00b0d0118b56")
    IUPnPEventSource : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ __RPC__in_opt IUPnPEventSink *pesSubscriber) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ __RPC__in_opt IUPnPEventSink *pesSubscriber) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPEventSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUPnPEventSource * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUPnPEventSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUPnPEventSource * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Advise )( 
            __RPC__in IUPnPEventSource * This,
            /* [in] */ __RPC__in_opt IUPnPEventSink *pesSubscriber);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            __RPC__in IUPnPEventSource * This,
            /* [in] */ __RPC__in_opt IUPnPEventSink *pesSubscriber);
        
        END_INTERFACE
    } IUPnPEventSourceVtbl;

    interface IUPnPEventSource
    {
        CONST_VTBL struct IUPnPEventSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPEventSource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPEventSource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPEventSource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPEventSource_Advise(This,pesSubscriber)	\
    ( (This)->lpVtbl -> Advise(This,pesSubscriber) ) 

#define IUPnPEventSource_Unadvise(This,pesSubscriber)	\
    ( (This)->lpVtbl -> Unadvise(This,pesSubscriber) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPEventSource_INTERFACE_DEFINED__ */


#ifndef __IUPnPRegistrar_INTERFACE_DEFINED__
#define __IUPnPRegistrar_INTERFACE_DEFINED__

/* interface IUPnPRegistrar */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IUPnPRegistrar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("204810b6-73b2-11d4-bf42-00b0d0118b56")
    IUPnPRegistrar : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterDevice( 
            /* [in] */ __RPC__in BSTR bstrXMLDesc,
            /* [in] */ __RPC__in BSTR bstrProgIDDeviceControlClass,
            /* [in] */ __RPC__in BSTR bstrInitString,
            /* [in] */ __RPC__in BSTR bstrContainerId,
            /* [in] */ __RPC__in BSTR bstrResourcePath,
            /* [in] */ long nLifeTime,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDeviceIdentifier) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterRunningDevice( 
            /* [in] */ __RPC__in BSTR bstrXMLDesc,
            /* [in] */ __RPC__in_opt IUnknown *punkDeviceControl,
            /* [in] */ __RPC__in BSTR bstrInitString,
            /* [in] */ __RPC__in BSTR bstrResourcePath,
            /* [in] */ long nLifeTime,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDeviceIdentifier) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterDeviceProvider( 
            /* [in] */ __RPC__in BSTR bstrProviderName,
            /* [in] */ __RPC__in BSTR bstrProgIDProviderClass,
            /* [in] */ __RPC__in BSTR bstrInitString,
            /* [in] */ __RPC__in BSTR bstrContainerId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUniqueDeviceName( 
            /* [in] */ __RPC__in BSTR bstrDeviceIdentifier,
            /* [in] */ __RPC__in BSTR bstrTemplateUDN,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrUDN) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterDevice( 
            /* [in] */ __RPC__in BSTR bstrDeviceIdentifier,
            /* [in] */ BOOL fPermanent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterDeviceProvider( 
            /* [in] */ __RPC__in BSTR bstrProviderName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPRegistrarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUPnPRegistrar * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUPnPRegistrar * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUPnPRegistrar * This);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterDevice )( 
            __RPC__in IUPnPRegistrar * This,
            /* [in] */ __RPC__in BSTR bstrXMLDesc,
            /* [in] */ __RPC__in BSTR bstrProgIDDeviceControlClass,
            /* [in] */ __RPC__in BSTR bstrInitString,
            /* [in] */ __RPC__in BSTR bstrContainerId,
            /* [in] */ __RPC__in BSTR bstrResourcePath,
            /* [in] */ long nLifeTime,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDeviceIdentifier);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterRunningDevice )( 
            __RPC__in IUPnPRegistrar * This,
            /* [in] */ __RPC__in BSTR bstrXMLDesc,
            /* [in] */ __RPC__in_opt IUnknown *punkDeviceControl,
            /* [in] */ __RPC__in BSTR bstrInitString,
            /* [in] */ __RPC__in BSTR bstrResourcePath,
            /* [in] */ long nLifeTime,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDeviceIdentifier);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterDeviceProvider )( 
            __RPC__in IUPnPRegistrar * This,
            /* [in] */ __RPC__in BSTR bstrProviderName,
            /* [in] */ __RPC__in BSTR bstrProgIDProviderClass,
            /* [in] */ __RPC__in BSTR bstrInitString,
            /* [in] */ __RPC__in BSTR bstrContainerId);
        
        HRESULT ( STDMETHODCALLTYPE *GetUniqueDeviceName )( 
            __RPC__in IUPnPRegistrar * This,
            /* [in] */ __RPC__in BSTR bstrDeviceIdentifier,
            /* [in] */ __RPC__in BSTR bstrTemplateUDN,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrUDN);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterDevice )( 
            __RPC__in IUPnPRegistrar * This,
            /* [in] */ __RPC__in BSTR bstrDeviceIdentifier,
            /* [in] */ BOOL fPermanent);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterDeviceProvider )( 
            __RPC__in IUPnPRegistrar * This,
            /* [in] */ __RPC__in BSTR bstrProviderName);
        
        END_INTERFACE
    } IUPnPRegistrarVtbl;

    interface IUPnPRegistrar
    {
        CONST_VTBL struct IUPnPRegistrarVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPRegistrar_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPRegistrar_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPRegistrar_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPRegistrar_RegisterDevice(This,bstrXMLDesc,bstrProgIDDeviceControlClass,bstrInitString,bstrContainerId,bstrResourcePath,nLifeTime,pbstrDeviceIdentifier)	\
    ( (This)->lpVtbl -> RegisterDevice(This,bstrXMLDesc,bstrProgIDDeviceControlClass,bstrInitString,bstrContainerId,bstrResourcePath,nLifeTime,pbstrDeviceIdentifier) ) 

#define IUPnPRegistrar_RegisterRunningDevice(This,bstrXMLDesc,punkDeviceControl,bstrInitString,bstrResourcePath,nLifeTime,pbstrDeviceIdentifier)	\
    ( (This)->lpVtbl -> RegisterRunningDevice(This,bstrXMLDesc,punkDeviceControl,bstrInitString,bstrResourcePath,nLifeTime,pbstrDeviceIdentifier) ) 

#define IUPnPRegistrar_RegisterDeviceProvider(This,bstrProviderName,bstrProgIDProviderClass,bstrInitString,bstrContainerId)	\
    ( (This)->lpVtbl -> RegisterDeviceProvider(This,bstrProviderName,bstrProgIDProviderClass,bstrInitString,bstrContainerId) ) 

#define IUPnPRegistrar_GetUniqueDeviceName(This,bstrDeviceIdentifier,bstrTemplateUDN,pbstrUDN)	\
    ( (This)->lpVtbl -> GetUniqueDeviceName(This,bstrDeviceIdentifier,bstrTemplateUDN,pbstrUDN) ) 

#define IUPnPRegistrar_UnregisterDevice(This,bstrDeviceIdentifier,fPermanent)	\
    ( (This)->lpVtbl -> UnregisterDevice(This,bstrDeviceIdentifier,fPermanent) ) 

#define IUPnPRegistrar_UnregisterDeviceProvider(This,bstrProviderName)	\
    ( (This)->lpVtbl -> UnregisterDeviceProvider(This,bstrProviderName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPRegistrar_INTERFACE_DEFINED__ */


#ifndef __IUPnPReregistrar_INTERFACE_DEFINED__
#define __IUPnPReregistrar_INTERFACE_DEFINED__

/* interface IUPnPReregistrar */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IUPnPReregistrar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("204810b7-73b2-11d4-bf42-00b0d0118b56")
    IUPnPReregistrar : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReregisterDevice( 
            /* [in] */ __RPC__in BSTR bstrDeviceIdentifier,
            /* [in] */ __RPC__in BSTR bstrXMLDesc,
            /* [in] */ __RPC__in BSTR bstrProgIDDeviceControlClass,
            /* [in] */ __RPC__in BSTR bstrInitString,
            /* [in] */ __RPC__in BSTR bstrContainerId,
            /* [in] */ __RPC__in BSTR bstrResourcePath,
            /* [in] */ long nLifeTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReregisterRunningDevice( 
            /* [in] */ __RPC__in BSTR bstrDeviceIdentifier,
            /* [in] */ __RPC__in BSTR bstrXMLDesc,
            /* [in] */ __RPC__in_opt IUnknown *punkDeviceControl,
            /* [in] */ __RPC__in BSTR bstrInitString,
            /* [in] */ __RPC__in BSTR bstrResourcePath,
            /* [in] */ long nLifeTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPReregistrarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUPnPReregistrar * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUPnPReregistrar * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUPnPReregistrar * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReregisterDevice )( 
            __RPC__in IUPnPReregistrar * This,
            /* [in] */ __RPC__in BSTR bstrDeviceIdentifier,
            /* [in] */ __RPC__in BSTR bstrXMLDesc,
            /* [in] */ __RPC__in BSTR bstrProgIDDeviceControlClass,
            /* [in] */ __RPC__in BSTR bstrInitString,
            /* [in] */ __RPC__in BSTR bstrContainerId,
            /* [in] */ __RPC__in BSTR bstrResourcePath,
            /* [in] */ long nLifeTime);
        
        HRESULT ( STDMETHODCALLTYPE *ReregisterRunningDevice )( 
            __RPC__in IUPnPReregistrar * This,
            /* [in] */ __RPC__in BSTR bstrDeviceIdentifier,
            /* [in] */ __RPC__in BSTR bstrXMLDesc,
            /* [in] */ __RPC__in_opt IUnknown *punkDeviceControl,
            /* [in] */ __RPC__in BSTR bstrInitString,
            /* [in] */ __RPC__in BSTR bstrResourcePath,
            /* [in] */ long nLifeTime);
        
        END_INTERFACE
    } IUPnPReregistrarVtbl;

    interface IUPnPReregistrar
    {
        CONST_VTBL struct IUPnPReregistrarVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPReregistrar_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPReregistrar_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPReregistrar_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPReregistrar_ReregisterDevice(This,bstrDeviceIdentifier,bstrXMLDesc,bstrProgIDDeviceControlClass,bstrInitString,bstrContainerId,bstrResourcePath,nLifeTime)	\
    ( (This)->lpVtbl -> ReregisterDevice(This,bstrDeviceIdentifier,bstrXMLDesc,bstrProgIDDeviceControlClass,bstrInitString,bstrContainerId,bstrResourcePath,nLifeTime) ) 

#define IUPnPReregistrar_ReregisterRunningDevice(This,bstrDeviceIdentifier,bstrXMLDesc,punkDeviceControl,bstrInitString,bstrResourcePath,nLifeTime)	\
    ( (This)->lpVtbl -> ReregisterRunningDevice(This,bstrDeviceIdentifier,bstrXMLDesc,punkDeviceControl,bstrInitString,bstrResourcePath,nLifeTime) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPReregistrar_INTERFACE_DEFINED__ */


#ifndef __IUPnPDeviceControl_INTERFACE_DEFINED__
#define __IUPnPDeviceControl_INTERFACE_DEFINED__

/* interface IUPnPDeviceControl */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IUPnPDeviceControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("204810ba-73b2-11d4-bf42-00b0d0118b56")
    IUPnPDeviceControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in BSTR bstrXMLDesc,
            /* [in] */ __RPC__in BSTR bstrDeviceIdentifier,
            /* [in] */ __RPC__in BSTR bstrInitString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServiceObject( 
            /* [in] */ __RPC__in BSTR bstrUDN,
            /* [in] */ __RPC__in BSTR bstrServiceId,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppdispService) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPDeviceControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUPnPDeviceControl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUPnPDeviceControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUPnPDeviceControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in IUPnPDeviceControl * This,
            /* [in] */ __RPC__in BSTR bstrXMLDesc,
            /* [in] */ __RPC__in BSTR bstrDeviceIdentifier,
            /* [in] */ __RPC__in BSTR bstrInitString);
        
        HRESULT ( STDMETHODCALLTYPE *GetServiceObject )( 
            __RPC__in IUPnPDeviceControl * This,
            /* [in] */ __RPC__in BSTR bstrUDN,
            /* [in] */ __RPC__in BSTR bstrServiceId,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppdispService);
        
        END_INTERFACE
    } IUPnPDeviceControlVtbl;

    interface IUPnPDeviceControl
    {
        CONST_VTBL struct IUPnPDeviceControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPDeviceControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPDeviceControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPDeviceControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPDeviceControl_Initialize(This,bstrXMLDesc,bstrDeviceIdentifier,bstrInitString)	\
    ( (This)->lpVtbl -> Initialize(This,bstrXMLDesc,bstrDeviceIdentifier,bstrInitString) ) 

#define IUPnPDeviceControl_GetServiceObject(This,bstrUDN,bstrServiceId,ppdispService)	\
    ( (This)->lpVtbl -> GetServiceObject(This,bstrUDN,bstrServiceId,ppdispService) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPDeviceControl_INTERFACE_DEFINED__ */


#ifndef __IUPnPDeviceProvider_INTERFACE_DEFINED__
#define __IUPnPDeviceProvider_INTERFACE_DEFINED__

/* interface IUPnPDeviceProvider */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IUPnPDeviceProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("204810b8-73b2-11d4-bf42-00b0d0118b56")
    IUPnPDeviceProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [in] */ __RPC__in BSTR bstrInitString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPDeviceProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUPnPDeviceProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUPnPDeviceProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUPnPDeviceProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            __RPC__in IUPnPDeviceProvider * This,
            /* [in] */ __RPC__in BSTR bstrInitString);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            __RPC__in IUPnPDeviceProvider * This);
        
        END_INTERFACE
    } IUPnPDeviceProviderVtbl;

    interface IUPnPDeviceProvider
    {
        CONST_VTBL struct IUPnPDeviceProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPDeviceProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPDeviceProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPDeviceProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPDeviceProvider_Start(This,bstrInitString)	\
    ( (This)->lpVtbl -> Start(This,bstrInitString) ) 

#define IUPnPDeviceProvider_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPDeviceProvider_INTERFACE_DEFINED__ */


#ifndef __IUPnPRemoteEndpointInfo_INTERFACE_DEFINED__
#define __IUPnPRemoteEndpointInfo_INTERFACE_DEFINED__

/* interface IUPnPRemoteEndpointInfo */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IUPnPRemoteEndpointInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c92eb863-0269-4aff-9c72-75321bba2952")
    IUPnPRemoteEndpointInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDwordValue( 
            /* [in] */ __RPC__in BSTR bstrValueName,
            /* [out] */ __RPC__out DWORD *pdwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStringValue( 
            /* [in] */ __RPC__in BSTR bstrValueName,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuidValue( 
            /* [in] */ __RPC__in BSTR bstrValueName,
            /* [out] */ __RPC__out GUID *pguidValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUPnPRemoteEndpointInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUPnPRemoteEndpointInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUPnPRemoteEndpointInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUPnPRemoteEndpointInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDwordValue )( 
            __RPC__in IUPnPRemoteEndpointInfo * This,
            /* [in] */ __RPC__in BSTR bstrValueName,
            /* [out] */ __RPC__out DWORD *pdwValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringValue )( 
            __RPC__in IUPnPRemoteEndpointInfo * This,
            /* [in] */ __RPC__in BSTR bstrValueName,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuidValue )( 
            __RPC__in IUPnPRemoteEndpointInfo * This,
            /* [in] */ __RPC__in BSTR bstrValueName,
            /* [out] */ __RPC__out GUID *pguidValue);
        
        END_INTERFACE
    } IUPnPRemoteEndpointInfoVtbl;

    interface IUPnPRemoteEndpointInfo
    {
        CONST_VTBL struct IUPnPRemoteEndpointInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUPnPRemoteEndpointInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUPnPRemoteEndpointInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUPnPRemoteEndpointInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUPnPRemoteEndpointInfo_GetDwordValue(This,bstrValueName,pdwValue)	\
    ( (This)->lpVtbl -> GetDwordValue(This,bstrValueName,pdwValue) ) 

#define IUPnPRemoteEndpointInfo_GetStringValue(This,bstrValueName,pbstrValue)	\
    ( (This)->lpVtbl -> GetStringValue(This,bstrValueName,pbstrValue) ) 

#define IUPnPRemoteEndpointInfo_GetGuidValue(This,bstrValueName,pguidValue)	\
    ( (This)->lpVtbl -> GetGuidValue(This,bstrValueName,pguidValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUPnPRemoteEndpointInfo_INTERFACE_DEFINED__ */



#ifndef __UPnPHostLib_LIBRARY_DEFINED__
#define __UPnPHostLib_LIBRARY_DEFINED__

/* library UPnPHostLib */
/* [helpstring][version][uuid] */ 









EXTERN_C const IID LIBID_UPnPHostLib;

EXTERN_C const CLSID CLSID_UPnPRegistrar;

#ifdef __cplusplus

class DECLSPEC_UUID("204810b9-73b2-11d4-bf42-00b0d0118b56")
UPnPRegistrar;
#endif

EXTERN_C const CLSID CLSID_UPnPRemoteEndpointInfo;

#ifdef __cplusplus

class DECLSPEC_UUID("2e5e84e9-4049-4244-b728-2d24227157c7")
UPnPRemoteEndpointInfo;
#endif
#endif /* __UPnPHostLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     __RPC__in unsigned long *, __RPC__in VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     __RPC__in unsigned long *, __RPC__in VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\UrlHist.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for urlhist.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __urlhist_h__
#define __urlhist_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IEnumSTATURL_FWD_DEFINED__
#define __IEnumSTATURL_FWD_DEFINED__
typedef interface IEnumSTATURL IEnumSTATURL;
#endif 	/* __IEnumSTATURL_FWD_DEFINED__ */


#ifndef __IUrlHistoryStg_FWD_DEFINED__
#define __IUrlHistoryStg_FWD_DEFINED__
typedef interface IUrlHistoryStg IUrlHistoryStg;
#endif 	/* __IUrlHistoryStg_FWD_DEFINED__ */


#ifndef __IUrlHistoryStg2_FWD_DEFINED__
#define __IUrlHistoryStg2_FWD_DEFINED__
typedef interface IUrlHistoryStg2 IUrlHistoryStg2;
#endif 	/* __IUrlHistoryStg2_FWD_DEFINED__ */


#ifndef __IUrlHistoryNotify_FWD_DEFINED__
#define __IUrlHistoryNotify_FWD_DEFINED__
typedef interface IUrlHistoryNotify IUrlHistoryNotify;
#endif 	/* __IUrlHistoryNotify_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"
#include "oaidl.h"
#include "docobj.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_urlhist_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// UrlHist.h
//=--------------------------------------------------------------------------=
// (C) Copyright Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// Url History Interfaces.



#define STATURL_QUERYFLAG_ISCACHED		0x00010000
#define STATURL_QUERYFLAG_NOURL              0x00020000
#define STATURL_QUERYFLAG_NOTITLE            0x00040000
#define STATURL_QUERYFLAG_TOPLEVEL           0x00080000
#define STATURLFLAG_ISCACHED		0x00000001
#define STATURLFLAG_ISTOPLEVEL       0x00000002
typedef 
enum _ADDURL_FLAG
    {	ADDURL_FIRST	= 0,
	ADDURL_ADDTOHISTORYANDCACHE	= 0,
	ADDURL_ADDTOCACHE	= 1,
	ADDURL_Max	= 2147483647L
    } 	ADDURL_FLAG;


////////////////////////////////////////////////////////////////////////////
//  Interface Definitions
#ifndef _LPENUMSTATURL_DEFINED
#define _LPENUMSTATURL_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlhist_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlhist_0000_0000_v0_0_s_ifspec;

#ifndef __IEnumSTATURL_INTERFACE_DEFINED__
#define __IEnumSTATURL_INTERFACE_DEFINED__

/* interface IEnumSTATURL */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IEnumSTATURL *LPENUMSTATURL;

typedef struct _STATURL
    {
    DWORD cbSize;
    LPWSTR pwcsUrl;
    LPWSTR pwcsTitle;
    FILETIME ftLastVisited;
    FILETIME ftLastUpdated;
    FILETIME ftExpires;
    DWORD dwFlags;
    } 	STATURL;

typedef struct _STATURL *LPSTATURL;


EXTERN_C const IID IID_IEnumSTATURL;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3C374A42-BAE4-11CF-BF7D-00AA006946EE")
    IEnumSTATURL : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out][in] */ __RPC__inout LPSTATURL rgelt,
            /* [out][in] */ __RPC__inout ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumSTATURL **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFilter( 
            /* [unique][in] */ __RPC__in_opt LPCOLESTR poszFilter,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumSTATURLVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumSTATURL * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumSTATURL * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumSTATURL * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumSTATURL * This,
            /* [in] */ ULONG celt,
            /* [out][in] */ __RPC__inout LPSTATURL rgelt,
            /* [out][in] */ __RPC__inout ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumSTATURL * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumSTATURL * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumSTATURL * This,
            /* [out] */ __RPC__deref_out_opt IEnumSTATURL **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *SetFilter )( 
            __RPC__in IEnumSTATURL * This,
            /* [unique][in] */ __RPC__in_opt LPCOLESTR poszFilter,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IEnumSTATURLVtbl;

    interface IEnumSTATURL
    {
        CONST_VTBL struct IEnumSTATURLVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumSTATURL_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumSTATURL_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumSTATURL_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumSTATURL_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumSTATURL_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumSTATURL_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumSTATURL_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#define IEnumSTATURL_SetFilter(This,poszFilter,dwFlags)	\
    ( (This)->lpVtbl -> SetFilter(This,poszFilter,dwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumSTATURL_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlhist_0000_0001 */
/* [local] */ 

#endif
#ifndef _LPURLHISTORYSTG_DEFINED
#define _LPURLHISTORYSTG_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlhist_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlhist_0000_0001_v0_0_s_ifspec;

#ifndef __IUrlHistoryStg_INTERFACE_DEFINED__
#define __IUrlHistoryStg_INTERFACE_DEFINED__

/* interface IUrlHistoryStg */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IUrlHistoryStg *LPURLHISTORYSTG;


EXTERN_C const IID IID_IUrlHistoryStg;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3C374A41-BAE4-11CF-BF7D-00AA006946EE")
    IUrlHistoryStg : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddUrl( 
            /* [in] */ __RPC__in LPCOLESTR pocsUrl,
            /* [unique][in] */ __RPC__in_opt LPCOLESTR pocsTitle,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteUrl( 
            /* [in] */ __RPC__in LPCOLESTR pocsUrl,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryUrl( 
            /* [in] */ __RPC__in LPCOLESTR pocsUrl,
            /* [in] */ DWORD dwFlags,
            /* [unique][out][in] */ __RPC__inout_opt LPSTATURL lpSTATURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BindToObject( 
            /* [in] */ __RPC__in LPCOLESTR pocsUrl,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumUrls( 
            /* [out] */ __RPC__deref_out_opt IEnumSTATURL **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUrlHistoryStgVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUrlHistoryStg * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUrlHistoryStg * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUrlHistoryStg * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddUrl )( 
            __RPC__in IUrlHistoryStg * This,
            /* [in] */ __RPC__in LPCOLESTR pocsUrl,
            /* [unique][in] */ __RPC__in_opt LPCOLESTR pocsTitle,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteUrl )( 
            __RPC__in IUrlHistoryStg * This,
            /* [in] */ __RPC__in LPCOLESTR pocsUrl,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *QueryUrl )( 
            __RPC__in IUrlHistoryStg * This,
            /* [in] */ __RPC__in LPCOLESTR pocsUrl,
            /* [in] */ DWORD dwFlags,
            /* [unique][out][in] */ __RPC__inout_opt LPSTATURL lpSTATURL);
        
        HRESULT ( STDMETHODCALLTYPE *BindToObject )( 
            __RPC__in IUrlHistoryStg * This,
            /* [in] */ __RPC__in LPCOLESTR pocsUrl,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvOut);
        
        HRESULT ( STDMETHODCALLTYPE *EnumUrls )( 
            __RPC__in IUrlHistoryStg * This,
            /* [out] */ __RPC__deref_out_opt IEnumSTATURL **ppEnum);
        
        END_INTERFACE
    } IUrlHistoryStgVtbl;

    interface IUrlHistoryStg
    {
        CONST_VTBL struct IUrlHistoryStgVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUrlHistoryStg_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUrlHistoryStg_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUrlHistoryStg_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUrlHistoryStg_AddUrl(This,pocsUrl,pocsTitle,dwFlags)	\
    ( (This)->lpVtbl -> AddUrl(This,pocsUrl,pocsTitle,dwFlags) ) 

#define IUrlHistoryStg_DeleteUrl(This,pocsUrl,dwFlags)	\
    ( (This)->lpVtbl -> DeleteUrl(This,pocsUrl,dwFlags) ) 

#define IUrlHistoryStg_QueryUrl(This,pocsUrl,dwFlags,lpSTATURL)	\
    ( (This)->lpVtbl -> QueryUrl(This,pocsUrl,dwFlags,lpSTATURL) ) 

#define IUrlHistoryStg_BindToObject(This,pocsUrl,riid,ppvOut)	\
    ( (This)->lpVtbl -> BindToObject(This,pocsUrl,riid,ppvOut) ) 

#define IUrlHistoryStg_EnumUrls(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumUrls(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUrlHistoryStg_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlhist_0000_0002 */
/* [local] */ 

#endif
#ifndef _LPURLHISTORYSTG2_DEFINED
#define _LPURLHISTORYSTG2_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlhist_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlhist_0000_0002_v0_0_s_ifspec;

#ifndef __IUrlHistoryStg2_INTERFACE_DEFINED__
#define __IUrlHistoryStg2_INTERFACE_DEFINED__

/* interface IUrlHistoryStg2 */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IUrlHistoryStg2 *LPURLHISTORYSTG2;


EXTERN_C const IID IID_IUrlHistoryStg2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AFA0DC11-C313-11d0-831A-00C04FD5AE38")
    IUrlHistoryStg2 : public IUrlHistoryStg
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddUrlAndNotify( 
            /* [in] */ __RPC__in LPCOLESTR pocsUrl,
            /* [unique][in] */ __RPC__in_opt LPCOLESTR pocsTitle,
            /* [in] */ DWORD dwFlags,
            /* [in] */ BOOL fWriteHistory,
            /* [in] */ __RPC__in_opt IOleCommandTarget *poctNotify,
            /* [unique][in] */ __RPC__in_opt IUnknown *punkISFolder) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearHistory( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUrlHistoryStg2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUrlHistoryStg2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUrlHistoryStg2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUrlHistoryStg2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddUrl )( 
            __RPC__in IUrlHistoryStg2 * This,
            /* [in] */ __RPC__in LPCOLESTR pocsUrl,
            /* [unique][in] */ __RPC__in_opt LPCOLESTR pocsTitle,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteUrl )( 
            __RPC__in IUrlHistoryStg2 * This,
            /* [in] */ __RPC__in LPCOLESTR pocsUrl,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *QueryUrl )( 
            __RPC__in IUrlHistoryStg2 * This,
            /* [in] */ __RPC__in LPCOLESTR pocsUrl,
            /* [in] */ DWORD dwFlags,
            /* [unique][out][in] */ __RPC__inout_opt LPSTATURL lpSTATURL);
        
        HRESULT ( STDMETHODCALLTYPE *BindToObject )( 
            __RPC__in IUrlHistoryStg2 * This,
            /* [in] */ __RPC__in LPCOLESTR pocsUrl,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvOut);
        
        HRESULT ( STDMETHODCALLTYPE *EnumUrls )( 
            __RPC__in IUrlHistoryStg2 * This,
            /* [out] */ __RPC__deref_out_opt IEnumSTATURL **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *AddUrlAndNotify )( 
            __RPC__in IUrlHistoryStg2 * This,
            /* [in] */ __RPC__in LPCOLESTR pocsUrl,
            /* [unique][in] */ __RPC__in_opt LPCOLESTR pocsTitle,
            /* [in] */ DWORD dwFlags,
            /* [in] */ BOOL fWriteHistory,
            /* [in] */ __RPC__in_opt IOleCommandTarget *poctNotify,
            /* [unique][in] */ __RPC__in_opt IUnknown *punkISFolder);
        
        HRESULT ( STDMETHODCALLTYPE *ClearHistory )( 
            __RPC__in IUrlHistoryStg2 * This);
        
        END_INTERFACE
    } IUrlHistoryStg2Vtbl;

    interface IUrlHistoryStg2
    {
        CONST_VTBL struct IUrlHistoryStg2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUrlHistoryStg2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUrlHistoryStg2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUrlHistoryStg2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUrlHistoryStg2_AddUrl(This,pocsUrl,pocsTitle,dwFlags)	\
    ( (This)->lpVtbl -> AddUrl(This,pocsUrl,pocsTitle,dwFlags) ) 

#define IUrlHistoryStg2_DeleteUrl(This,pocsUrl,dwFlags)	\
    ( (This)->lpVtbl -> DeleteUrl(This,pocsUrl,dwFlags) ) 

#define IUrlHistoryStg2_QueryUrl(This,pocsUrl,dwFlags,lpSTATURL)	\
    ( (This)->lpVtbl -> QueryUrl(This,pocsUrl,dwFlags,lpSTATURL) ) 

#define IUrlHistoryStg2_BindToObject(This,pocsUrl,riid,ppvOut)	\
    ( (This)->lpVtbl -> BindToObject(This,pocsUrl,riid,ppvOut) ) 

#define IUrlHistoryStg2_EnumUrls(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumUrls(This,ppEnum) ) 


#define IUrlHistoryStg2_AddUrlAndNotify(This,pocsUrl,pocsTitle,dwFlags,fWriteHistory,poctNotify,punkISFolder)	\
    ( (This)->lpVtbl -> AddUrlAndNotify(This,pocsUrl,pocsTitle,dwFlags,fWriteHistory,poctNotify,punkISFolder) ) 

#define IUrlHistoryStg2_ClearHistory(This)	\
    ( (This)->lpVtbl -> ClearHistory(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUrlHistoryStg2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlhist_0000_0003 */
/* [local] */ 

#endif
#ifndef _LPURLHISTORYNOTIFY_DEFINED
#define _LPURLHISTORYNOTIFY_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlhist_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlhist_0000_0003_v0_0_s_ifspec;

#ifndef __IUrlHistoryNotify_INTERFACE_DEFINED__
#define __IUrlHistoryNotify_INTERFACE_DEFINED__

/* interface IUrlHistoryNotify */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IUrlHistoryNotify *LPURLHISTORYNOTIFY;


EXTERN_C const IID IID_IUrlHistoryNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BC40BEC1-C493-11d0-831B-00C04FD5AE38")
    IUrlHistoryNotify : public IOleCommandTarget
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IUrlHistoryNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUrlHistoryNotify * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUrlHistoryNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUrlHistoryNotify * This);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE *QueryStatus )( 
            __RPC__in IUrlHistoryNotify * This,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidCmdGroup,
            /* [in] */ ULONG cCmds,
            /* [out][in][size_is] */ __RPC__inout_ecount_full(cCmds) OLECMD prgCmds[  ],
            /* [unique][out][in] */ __RPC__inout_opt OLECMDTEXT *pCmdText);
        
        HRESULT ( STDMETHODCALLTYPE *Exec )( 
            __RPC__in IUrlHistoryNotify * This,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidCmdGroup,
            /* [in] */ DWORD nCmdID,
            /* [in] */ DWORD nCmdexecopt,
            /* [unique][in] */ __RPC__in_opt VARIANT *pvaIn,
            /* [unique][out][in] */ __RPC__inout_opt VARIANT *pvaOut);
        
        END_INTERFACE
    } IUrlHistoryNotifyVtbl;

    interface IUrlHistoryNotify
    {
        CONST_VTBL struct IUrlHistoryNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUrlHistoryNotify_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUrlHistoryNotify_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUrlHistoryNotify_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUrlHistoryNotify_QueryStatus(This,pguidCmdGroup,cCmds,prgCmds,pCmdText)	\
    ( (This)->lpVtbl -> QueryStatus(This,pguidCmdGroup,cCmds,prgCmds,pCmdText) ) 

#define IUrlHistoryNotify_Exec(This,pguidCmdGroup,nCmdID,nCmdexecopt,pvaIn,pvaOut)	\
    ( (This)->lpVtbl -> Exec(This,pguidCmdGroup,nCmdID,nCmdexecopt,pvaIn,pvaOut) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUrlHistoryNotify_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlhist_0000_0004 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_urlhist_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlhist_0000_0004_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\UserEnv.h ===
//=============================================================================
//  userenv.h   -   Header file for user environment API.
//                  User Profiles, environment variables, and Group Policy
//
//  Copyright (c) Microsoft Corporation 1995-2002
//  All rights reserved
//
//=============================================================================


#ifndef _INC_USERENV
#define _INC_USERENV

#include <wbemcli.h>

//
// Define API decoration for direct importing of DLL references.
//

#if !defined(_USERENV_)
#define USERENVAPI DECLSPEC_IMPORT
#else
#define USERENVAPI
#endif


#ifdef __cplusplus
extern "C" {
#endif

//=============================================================================
//
// LoadUserProfile
//
// Loads the specified user's profile.
//
// Most applications should not need to use this function.  It's used
// when a user has logged onto the system or a service starts in a named
// user account.
//
// hToken        - Token for the user, returned from LogonUser()
// lpProfileInfo - Address of a PROFILEINFO structure
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Note:  The caller of this function must have admin privileges on the machine.
//
//        Upon successful return, the hProfile member of the PROFILEINFO
//        structure is a registry key handle opened to the root
//        of the user's hive.  It has been opened with full access. If
//        you need to read or write to the user's registry file, use
//        this key instead of HKEY_CURRENT_USER.  Do not close this
//        handle.  Instead pass it to UnloadUserProfile to close
//        the handle.
//
//=============================================================================

#include <profinfo.h>

#define PI_NOUI         0x00000001      // Prevents displaying of messages
#define PI_APPLYPOLICY  0x00000002      // Apply NT4 style policy

USERENVAPI
BOOL
WINAPI
LoadUserProfileA(
    __in    HANDLE          hToken,
    __inout LPPROFILEINFOA  lpProfileInfo);
USERENVAPI
BOOL
WINAPI
LoadUserProfileW(
    __in    HANDLE          hToken,
    __inout LPPROFILEINFOW  lpProfileInfo);
#ifdef UNICODE
#define LoadUserProfile  LoadUserProfileW
#else
#define LoadUserProfile  LoadUserProfileA
#endif // !UNICODE

//=============================================================================
//
// UnloadUserProfile
//
// Unloads a user's profile that was loaded by LoadUserProfile()
//
// hToken        -  Token for the user, returned from LogonUser()
// hProfile      -  hProfile member of the PROFILEINFO structure
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Note:     The caller of this function must have admin privileges on the machine.
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
UnloadUserProfile(
    __in    HANDLE  hToken,
    __in    HANDLE  hProfile);

//=============================================================================
//
// GetProfilesDirectory
//
// Returns the path to the root of where all user profiles are stored.
//
// lpProfilesDir  -  Receives the path
// lpcchSize      -  Size of lpProfilesDir
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Note:     If lpProfilesDir is not large enough or NULL, the function will fail,
//           and lpcchSize will contain the necessary buffer size.
//
// Example return value: C:\Users
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
GetProfilesDirectoryA(
    __out_ecount_opt(*lpcchSize)    LPSTR lpProfileDir,
    __inout                         LPDWORD lpcchSize);
USERENVAPI
BOOL
WINAPI
GetProfilesDirectoryW(
    __out_ecount_opt(*lpcchSize)    LPWSTR lpProfileDir,
    __inout                         LPDWORD lpcchSize);
#ifdef UNICODE
#define GetProfilesDirectory  GetProfilesDirectoryW
#else
#define GetProfilesDirectory  GetProfilesDirectoryA
#endif // !UNICODE

//=============================================================================
//
//  GetProfileType()
//
//  Returns the type of the profile that is loaded for a user.
//
//  dwFlags   - Returns the profile flags
//
//  Return:     TRUE if successful
//              FALSE if an error occurs. Call GetLastError for more details
//
//  Comments:   if profile is not already loaded the function will return an error.
//              The caller needs to have access to HKLM part of the registry.
//              (exists by default)
//
//=============================================================================

#if(WINVER >= 0x0500)

//
// Flags that can be set in the dwFlags field
//

#define PT_TEMPORARY         0x00000001      // A profile has been allocated that will be deleted at logoff.
#define PT_ROAMING           0x00000002      // The loaded profile is a roaming profile.
#define PT_MANDATORY         0x00000004      // The loaded profile is mandatory.

USERENVAPI
BOOL
WINAPI
GetProfileType(
    __out DWORD *dwFlags);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
//  DeleteProfile()
//
//  Deletes the profile and all other user related settings from the machine
//
//  lpSidString    - String form of the user sid.
//  lpProfilePath  - ProfilePath (if Null, lookup in the registry)
//  lpComputerName - Computer Name from which profile has to be deleted
//
//  Return:     TRUE if successful
//              FALSE if an error occurs. Call GetLastError for more details
//
//  Comments:   Deletes the profile directory, registry and appmgmt stuff
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
DeleteProfileA (
    __in        LPCSTR    lpSidString,
    __in_opt    LPCSTR    lpProfilePath,
    __in_opt    LPCSTR    lpComputerName);
USERENVAPI
BOOL
WINAPI
DeleteProfileW (
    __in        LPCWSTR    lpSidString,
    __in_opt    LPCWSTR    lpProfilePath,
    __in_opt    LPCWSTR    lpComputerName);
#ifdef UNICODE
#define DeleteProfile  DeleteProfileW
#else
#define DeleteProfile  DeleteProfileA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
//  CreateProfile()
//
//  Creating a user profile without loading it. 
//
//  pszUserSid     - String form of the user sid.
//  pszUserName    - Name of the user, used as the base name to create the 
//                   profile directory
//  pszProfilePath - Returned full profile path 
//  cchProfilePath - Size of pszProfilePath buffer
//
//  Return:     S_OK : Successfully created the profile
//              E_ACCESSDENIED : The caller does not have enough permission to
//                     create the profile. The caller has to be administrators
//                     in order for this API to succeed.
//              HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) : a profile is 
//                     already exists for the given user.
//              Others : Standard HRESULT error codes.
//                          
//  Comments:   
//=============================================================================

#if(WINVER >= 0x0600)

USERENVAPI
HRESULT
WINAPI
CreateProfile(
    __in                            LPCWSTR pszUserSid,
    __in                            LPCWSTR pszUserName,
    __out_ecount(cchProfilePath)    LPWSTR  pszProfilePath,
    __in                            DWORD   cchProfilePath);

#endif /* WINVER >= 0x0600 */

//=============================================================================
//
// GetDefaultUserProfilesDirectory
//
// Returns the path to the root of the default user profile
//
// lpProfileDir   -  Receives the path
// lpcchSize      -  Size of lpProfileDir
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Note:     If lpProfileDir is not large enough or NULL, the function will fail,
//           and lpcchSize will contain the necessary buffer size.
//
// Example return value: C:\Users\Default
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
GetDefaultUserProfileDirectoryA(
    __out_ecount_opt(*lpcchSize)    LPSTR lpProfileDir,
    __inout                         LPDWORD lpcchSize);
USERENVAPI
BOOL
WINAPI
GetDefaultUserProfileDirectoryW(
    __out_ecount_opt(*lpcchSize)    LPWSTR lpProfileDir,
    __inout                         LPDWORD lpcchSize);
#ifdef UNICODE
#define GetDefaultUserProfileDirectory  GetDefaultUserProfileDirectoryW
#else
#define GetDefaultUserProfileDirectory  GetDefaultUserProfileDirectoryA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// GetAllUsersProfilesDirectory
//
// Returns the path to the root of the All Users profile
//
// lpProfileDir   -  Receives the path
// lpcchSize      -  Size of lpProfileDir
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Note:     If lpProfileDir is not large enough or NULL, the function will fail,
//           and lpcchSize will contain the necessary buffer size.
//
// Example return value: C:\Program Data
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
GetAllUsersProfileDirectoryA(
    __out_ecount_opt(*lpcchSize)    LPSTR lpProfileDir,
    __inout                         LPDWORD lpcchSize);
USERENVAPI
BOOL
WINAPI
GetAllUsersProfileDirectoryW(
    __out_ecount_opt(*lpcchSize)    LPWSTR lpProfileDir,
    __inout                         LPDWORD lpcchSize);
#ifdef UNICODE
#define GetAllUsersProfileDirectory  GetAllUsersProfileDirectoryW
#else
#define GetAllUsersProfileDirectory  GetAllUsersProfileDirectoryA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// GetUserProfileDirectory
//
// Returns the path to the root of the requested user's profile
//
// hToken         -  User's token returned from LogonUser()
// lpProfileDir   -  Receives the path
// lpcchSize      -  Size of lpProfileDir
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Note:     If lpProfileDir is not large enough or NULL, the function will fail,
//           and lpcchSize will contain the necessary buffer size.
//
// Example return value: C:\Users\Joe
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
GetUserProfileDirectoryA(
    __in                            HANDLE  hToken,
    __out_ecount_opt(*lpcchSize)    LPSTR lpProfileDir,
    __inout                         LPDWORD lpcchSize);
USERENVAPI
BOOL
WINAPI
GetUserProfileDirectoryW(
    __in                            HANDLE  hToken,
    __out_ecount_opt(*lpcchSize)    LPWSTR lpProfileDir,
    __inout                         LPDWORD lpcchSize);
#ifdef UNICODE
#define GetUserProfileDirectory  GetUserProfileDirectoryW
#else
#define GetUserProfileDirectory  GetUserProfileDirectoryA
#endif // !UNICODE

//=============================================================================
//
// CreateEnvironmentBlock
//
// Returns the environment variables for the specified user.  This block
// can then be passed to CreateProcessAsUser().
//
// lpEnvironment  -  Receives a pointer to the new environment block
// hToken         -  User's token returned from LogonUser() (optional, can be NULL)
// bInherit       -  Inherit from the current process's environment block
//                   or start from a clean state.
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Note:     If hToken is NULL, the returned environment block will contain
//           system variables only.
//
//           Call DestroyEnvironmentBlock to free the buffer when finished.
//
//           If this block is passed to CreateProcessAsUser, the
//           CREATE_UNICODE_ENVIRONMENT flag must also be set.
//
//=============================================================================

BOOL
WINAPI
CreateEnvironmentBlock(
    __out       LPVOID  *lpEnvironment,
    __in_opt    HANDLE  hToken,
    __in        BOOL    bInherit);

//=============================================================================
//
// DestroyEnvironmentBlock
//
// Frees environment variables created by CreateEnvironmentBlock
//
// lpEnvironment  -  A pointer to the environment block
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
//=============================================================================

BOOL
WINAPI
DestroyEnvironmentBlock(
    __in    LPVOID  lpEnvironment);

//=============================================================================
//
// ExpandEnvironmentStringsForUser
//
// Expands the source string using the environment block for the
// specified user.  If hToken is null, the system environment block
// will be used (no user environment variables).
//
// hToken         -  User's token returned from LogonUser() (optional, can be NULL)
// lpSrc          -  Pointer to the string with environment variables
// lpDest         -  Buffer that receives the expanded string
// dwSize         -  Size of lpDest in characters (max chars)
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Note:     If the user profile for hToken is not loaded, this api will fail.
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
ExpandEnvironmentStringsForUserA(
    __in_opt                HANDLE      hToken,
    __in                    LPCSTR    lpSrc,
    __out_ecount(dwSize)    LPSTR     lpDest,
    __in                    DWORD       dwSize);
USERENVAPI
BOOL
WINAPI
ExpandEnvironmentStringsForUserW(
    __in_opt                HANDLE      hToken,
    __in                    LPCWSTR    lpSrc,
    __out_ecount(dwSize)    LPWSTR     lpDest,
    __in                    DWORD       dwSize);
#ifdef UNICODE
#define ExpandEnvironmentStringsForUser  ExpandEnvironmentStringsForUserW
#else
#define ExpandEnvironmentStringsForUser  ExpandEnvironmentStringsForUserA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// RefreshPolicy()
//
// Causes group policy to be applied immediately on the client machine
//
// bMachine  -  Refresh machine or user policy
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
RefreshPolicy(
    __in        BOOL bMachine);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// RefreshPolicyEx()
//
// Causes group policy to be applied immediately on the client machine. 
//
// bMachine  -  Refresh machine or user policy
// dwOptions -  Option specifying the kind of refresh that needs to be done.
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
//=============================================================================

#if(WINVER >= 0x0500)

#define RP_FORCE            1      // Refresh policies without any optimisations.
#define RP_SYNC             2      // Refresh Policy sync; the call does not return till the time policy processing is completed

USERENVAPI
BOOL
WINAPI
RefreshPolicyEx(
    __in        BOOL    bMachine, 
    __in        DWORD   dwOptions);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// EnterCriticalPolicySection
//
// Pauses the background application of group policy to allow safe
// reading of the registry.  Applications that need to read multiple
// policy entries and ensure that the values are not changed while reading
// them should use this function.
//
// The maximum amount of time an application can hold a critical section
// is 10 minutes.  After 10 minutes, policy can be applied again.
//
// bMachine -  Pause machine or user policy
//
// Returns:  Handle if successful
//           NULL if not.  Call GetLastError() for more details
//
// Note 1:  The handle returned should be passed to LeaveCriticalPolicySection
// when finished.  Do not close this handle, LeaveCriticalPolicySection
// will do that.
//
// Note 2:  If both user and machine critical sections need to be acquired then
// they should be done in this order: first acquire user critical section and
// then acquire machine critical section.
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
HANDLE
WINAPI
EnterCriticalPolicySection(
    __in        BOOL    bMachine);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// LeaveCriticalPolicySection
//
// Resumes the background application of group policy.  See
// EnterCriticalPolicySection for more details.
//
// hSection - Handle returned from EnterCriticalPolicySection
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Note:  This function will close the handle.
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
LeaveCriticalPolicySection(
    __in        HANDLE  hSection);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// RegisterGPNotification
//
// Entry point for registering for Group Policy change notification.
//
// Parameters: hEvent     -   Event to be notified, by calling SetEvent(hEvent)
//             bMachine   -   If true, then register machine policy notification
//                                     else register user policy notification
//
// Returns:    True if successful
//             False if error occurs
//
// Notes:      Group Policy Notifications.  There are 2 ways an application can
//             be notify when Group Policy is finished being applied.
//
//             1) Using the RegisterGPNotifcation function and waiting for the
//                event to be signalled.
//
//             2) A WM_SETTINGCHANGE message is broadcast to all desktops.
//                wParam - 1 if machine policy was applied, 0 if user policy was applied.
//                lParam - Points to the string "Policy"
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
RegisterGPNotification(
    __in        HANDLE  hEvent,
    __in        BOOL    bMachine);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// UnregisterGPNotification
//
// Removes registration for a Group Policy change notification.
//
// Parameters: hEvent    -   Event to be removed
//
// Returns:    True if successful
//             False if error occurs
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
UnregisterGPNotification(
    __in        HANDLE  hEvent);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// GPOptions flags
//
// These are the flags found in the GPOptions property of a DS object
//
// For a given DS object (Site, Domain, OU), the GPOptions property
// contains options that effect all the GPOs link to this SDOU.
//
// This is a DWORD type
//
//=============================================================================

#if(WINVER >= 0x0500)

#define GPC_BLOCK_POLICY        0x00000001  // Block all non-forced policy from above

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// GPLink flags
//
// These are the flags found on the GPLink property of a DS object after
// the GPO path.
//
// For a given DS object (Site, Domain, OU), the GPLink property will
// be in this text format
//
// [LDAP://CN={E615A0E3-C4F1-11D1-A3A7-00AA00615092},CN=Policies,CN=System,DC=mydomain,DC=Microsoft,DC=Com;1]
//
// The GUID is the GPO name, and the number following the LDAP path are the options
// for that link from this DS object.  Note, there can be multiple GPOs
// each in their own square brackets in a prioritized list.
//
//=============================================================================

#if(WINVER >= 0x0500)

//
// Options for a GPO link
//

#define GPO_FLAG_DISABLE        0x00000001  // This GPO is disabled
#define GPO_FLAG_FORCE          0x00000002  // Don't override the settings in
                                            // this GPO with settings from
                                            // a GPO below it.
#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// GetGPOList
//
//
// Queries for the list of Group Policy Objects for the specified
// user or machine.  This function will return a link list
// of Group Policy Objects.  Call FreeGPOList to free the list.
//
// Note, most applications will not need to call this function.
// This will primarily be used by services acting on behalf of
// another user or machine.  The caller of this function will
// need to look in each GPO for their specific policy
//
// This function can be called in two different ways.  Either the hToken for
// a user or machine can be supplied and the correct name and domain
// controller name will be generated, or hToken is NULL and the caller
// must supply the name and the domain controller name.
//
// Calling this function with an hToken ensures the list of Group Policy
// Objects is correct for the user or machine since security access checking
// can be perfomed.  If hToken is not supplied, the security of the caller
// is used instead which means that list may or may not be 100% correct
// for the intended user / machine.  However, this is the fastest way
// to call this function.
//
// hToken           - User or machine token, if NULL, lpName and lpHostName must be supplied
// lpName           - User or machine name in DN format, if hToken is supplied, this must be NULL
// lpHostName       - Domain DN name or domain controller name. If hToken is supplied, this must be NULL
// lpComputerName   - Computer name to use to determine site location.  If NULL,
//                    the local computer is used as the reference. Format:  \\machinename
// dwFlags          - Flags field.  See flags definition below
// pGPOList         - Address of a pointer which receives the link list of GPOs
//
//
// Returns:  TRUE if successful
//           FALSE if not.  Use GetLastError() for more details.
//
// Examples:
//
// Here's how this function will typically be called for
// looking up the list of GPOs for a user:
//
//      LPGROUP_POLICY_OBJECT  pGPOList;
//
//      if (GetGPOList (hToken, NULL, NULL, NULL, 0, &pGPOList))
//      {
//          // do processing here...
//          FreeGPOList (pGPOList);
//      }
//
//
// Here's how this function will typically be called for
// looking up the list of GPOs for a machine:
//
//      LPGROUP_POLICY_OBJECT  pGPOList;
//
//      if (GetGPOList (NULL, lpMachineName, lpHostName, lpMachineName,
//                      GPO_LIST_FLAG_MACHINE, &pGPOList))
//      {
//          // do processing here...
//          FreeGPOList (pGPOList);
//      }
//
//=============================================================================

#if(WINVER >= 0x0500)

//
// Each Group Policy Object is associated (linked) with a site, domain,
// organizational unit, or machine.
//

typedef enum _GPO_LINK {
    GPLinkUnknown = 0,                     // No link information available
    GPLinkMachine,                         // GPO linked to a machine (local or remote)
    GPLinkSite,                            // GPO linked to a site
    GPLinkDomain,                          // GPO linked to a domain
    GPLinkOrganizationalUnit               // GPO linked to a organizational unit
} GPO_LINK, *PGPO_LINK;

typedef struct _GROUP_POLICY_OBJECTA {
    DWORD       dwOptions;                  // See GPLink option flags above
    DWORD       dwVersion;                  // Revision number of the GPO
    LPSTR       lpDSPath;                   // Path to the Active Directory portion of the GPO
    LPSTR       lpFileSysPath;              // Path to the file system portion of the GPO
    LPSTR       lpDisplayName;              // Friendly display name
    CHAR        szGPOName[50];              // Unique name
    GPO_LINK    GPOLink;                    // Link information
    LPARAM      lParam;                     // Free space for the caller to store GPO specific information
    struct _GROUP_POLICY_OBJECTA * pNext;   // Next GPO in the list
    struct _GROUP_POLICY_OBJECTA * pPrev;   // Previous GPO in the list
    LPSTR       lpExtensions;               // Extensions that are relevant for this GPO
    LPARAM      lParam2;                    // Free space for the caller to store GPO specific information
    LPSTR       lpLink;                     // Path to the Active Directory site, domain, or organizational unit this GPO is linked to
                                            // If this is the local GPO, this points to the word "Local"
} GROUP_POLICY_OBJECTA, *PGROUP_POLICY_OBJECTA;
typedef struct _GROUP_POLICY_OBJECTW {
    DWORD       dwOptions;                  // See GPLink option flags above
    DWORD       dwVersion;                  // Revision number of the GPO
    LPWSTR      lpDSPath;                   // Path to the Active Directory portion of the GPO
    LPWSTR      lpFileSysPath;              // Path to the file system portion of the GPO
    LPWSTR      lpDisplayName;              // Friendly display name
    WCHAR       szGPOName[50];              // Unique name
    GPO_LINK    GPOLink;                    // Link information
    LPARAM      lParam;                     // Free space for the caller to store GPO specific information
    struct _GROUP_POLICY_OBJECTW * pNext;   // Next GPO in the list
    struct _GROUP_POLICY_OBJECTW * pPrev;   // Previous GPO in the list
    LPWSTR      lpExtensions;               // Extensions that are relevant for this GPO
    LPARAM      lParam2;                    // Free space for the caller to store GPO specific information
    LPWSTR      lpLink;                     // Path to the Active Directory site, domain, or organizational unit this GPO is linked to
                                            // If this is the local GPO, this points to the word "Local"
} GROUP_POLICY_OBJECTW, *PGROUP_POLICY_OBJECTW;
#ifdef UNICODE
typedef GROUP_POLICY_OBJECTW GROUP_POLICY_OBJECT;
typedef PGROUP_POLICY_OBJECTW PGROUP_POLICY_OBJECT;
#else
typedef GROUP_POLICY_OBJECTA GROUP_POLICY_OBJECT;
typedef PGROUP_POLICY_OBJECTA PGROUP_POLICY_OBJECT;
#endif // UNICODE


//
// dwFlags for GetGPOList()
//

#define GPO_LIST_FLAG_MACHINE        0x00000001  // Return machine policy information
#define GPO_LIST_FLAG_SITEONLY       0x00000002  // Return site policy information only
#define GPO_LIST_FLAG_NO_WMIFILTERS  0x00000004  // Ignore WMI filters when filtering GPO's
#define GPO_LIST_FLAG_NO_SECURITYFILTERS 0x00000008 // Ignore security filters

USERENVAPI
BOOL
WINAPI
GetGPOListA (
    __in_opt    HANDLE      hToken,
    __in_opt    LPCSTR    lpName,
    __in_opt    LPCSTR    lpHostName,
    __in_opt    LPCSTR    lpComputerName,
    __in        DWORD       dwFlags,
    __deref_out PGROUP_POLICY_OBJECTA * pGPOList);
USERENVAPI
BOOL
WINAPI
GetGPOListW (
    __in_opt    HANDLE      hToken,
    __in_opt    LPCWSTR    lpName,
    __in_opt    LPCWSTR    lpHostName,
    __in_opt    LPCWSTR    lpComputerName,
    __in        DWORD       dwFlags,
    __deref_out PGROUP_POLICY_OBJECTW * pGPOList);
#ifdef UNICODE
#define GetGPOList  GetGPOListW
#else
#define GetGPOList  GetGPOListA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// FreeGPOList
//
//
// Frees the linked list returned from GetGPOList
//
// pGPOList - Pointer to the linked list of GPOs
//
//
// Returns:  TRUE if successful
//           FALSE if not
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
FreeGPOListA (
    __in        PGROUP_POLICY_OBJECTA   pGPOList);
USERENVAPI
BOOL
WINAPI
FreeGPOListW (
    __in        PGROUP_POLICY_OBJECTW   pGPOList);
#ifdef UNICODE
#define FreeGPOList  FreeGPOListW
#else
#define FreeGPOList  FreeGPOListA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// GetAppliedGPOList
//
// Queries for the list of applied Group Policy Objects for the specified
// user or machine and specified client side extension. This function will return
// a linked list of Group Policy Objects.  Call FreeGPOList to free the list.
//
// dwFlags          - User or machine policy, if it is GPO_LIST_FLAG_MACHINE then
//                    return machine policy information
// pMachineName     - Name of remote computer in the form \\computername. If null
//                    then local computer is used.
// pSidUser         - Security id of user (relevant for user policy). If pMachineName is
//                    null and pSidUser is null then it means current logged on user.
//                    If pMachine is null and pSidUser is non-null then it means user
//                    represented by pSidUser on local machine. If pMachineName is non-null
//                    then and if dwFlags specifies user policy, then pSidUser must be
//                    non-null.
// pGuidExtension   - Guid of the specified extension
// ppGPOList        - Address of a pointer which receives the link list of GPOs
//
// The return value is a Win32 error code. ERROR_SUCCESS means the GetAppliedGPOList
// function completed successfully. Otherwise it indicates that the function failed.
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
DWORD
WINAPI
GetAppliedGPOListA (
    __in        DWORD       dwFlags,
    __in_opt    LPCSTR    pMachineName,
    __in_opt    PSID        pSidUser,
    __in        GUID        *pGuidExtension,
    __deref_out PGROUP_POLICY_OBJECTA   *ppGPOList);
USERENVAPI
DWORD
WINAPI
GetAppliedGPOListW (
    __in        DWORD       dwFlags,
    __in_opt    LPCWSTR    pMachineName,
    __in_opt    PSID        pSidUser,
    __in        GUID        *pGuidExtension,
    __deref_out PGROUP_POLICY_OBJECTW   *ppGPOList);
#ifdef UNICODE
#define GetAppliedGPOList  GetAppliedGPOListW
#else
#define GetAppliedGPOList  GetAppliedGPOListA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// Group Policy Object client side extension support
//
// Flags, data structures and function prototype
//
// To register your extension, create a subkey under this key
//
// Software\Microsoft\Windows NT\CurrentVersion\Winlogon\GPExtensions
//
// The subkey needs to be a guid so that it is unique. The noname value of the subkey
// can be the friendly name of the extension. Then add these values:
//
//     DllName                      REG_EXPAND_SZ  Path to your DLL
//     ProcessGroupPolicy           REG_SZ       Function name (see PFNPROCESSGROUPPOLICY prototype). This
//                                                 is obsolete, it has been superseded by ProcessGroupPolicyEx.
//                                                 It's here for backward compatibility reasons only.
//     ProcessGroupPolicyEx         REG_SZ       Function name (see PFNPROCESSGROUPPOLICYEX prototype)
//     GenerateGroupPolicy          REG_SZ       Function name for Rsop (see PFNGENERATEGROUPPOLICY prototype)
//     NoMachinePolicy              REG_DWORD    True, if extension does not have to be called when
//                                                 machine policies are being processed.
//     NoUserPolicy                 REG_DWORD    True, if extension does not have to be called when
//                                                 user policies are being processed.
//     NoSlowLink                   REG_DWORD    True, if extension does not have to be called on a slow link
//     NoBackgroundPolicy           REG_DWORD    True, if extension does not have to be called 
//                                                 for background policy processing.
//     NoGPOListChanges             REG_DWORD    True, if extension does not have to be called when
//                                                 there are no changes between cached and current GPO lists.
//     PerUserLocalSettings         REG_DWORD    True, if user policies have to be cached on a per user and
//                                                 per machine basis.
//     RequiresSuccessfulRegistry   REG_DWORD    True, if extension should be called only if registry extension
//                                                 was successfully processed.
//     EnableAsynchronousProcessing REG_DWORD    True, if registry extension will complete its processing
//                                                 asynchronously.
//     NotifyLinkTransition         REG_DWORD    True, if extension should be called when a change in link
//                                                 speed is detected between previous policy application and
//                                                 current policy application.
//
// The return value is a Win32 error code. ERROR_SUCCESS means the ProcessGroupPolicy
// function completed successfully. If return value is ERROR_OVERRIDE_NOCHANGES then it
// means that the extension will be called the next time even if NoGPOListChanges is set
// and there are no changes to the GPO list. Any other return value indicates that the
// ProcessGroupPolicy or ProcessGroupPolicyEx function failed.
//
//=============================================================================

#if(WINVER >= 0x0500)

#define GP_DLLNAME                         TEXT("DllName")
#define GP_ENABLEASYNCHRONOUSPROCESSING    TEXT("EnableAsynchronousProcessing")
#define GP_MAXNOGPOLISTCHANGESINTERVAL     TEXT("MaxNoGPOListChangesInterval")
#define GP_NOBACKGROUNDPOLICY              TEXT("NoBackgroundPolicy")
#define GP_NOGPOLISTCHANGES                TEXT("NoGPOListChanges")
#define GP_NOMACHINEPOLICY                 TEXT("NoMachinePolicy")
#define GP_NOSLOWLINK                      TEXT("NoSlowLink")
#define GP_NOTIFYLINKTRANSITION            TEXT("NotifyLinkTransition")
#define GP_NOUSERPOLICY                    TEXT("NoUserPolicy")
#define GP_PERUSERLOCALSETTINGS            TEXT("PerUserLocalSettings")
#define GP_PROCESSGROUPPOLICY              TEXT("ProcessGroupPolicy")
#define GP_REQUIRESSUCCESSFULREGISTRY      TEXT("RequiresSuccessfulRegistry")

#define GPO_INFO_FLAG_MACHINE              0x00000001  // Apply machine policy rather than user policy
#define GPO_INFO_FLAG_BACKGROUND           0x00000010  // Background refresh of policy (ok to do slow stuff)
#define GPO_INFO_FLAG_SLOWLINK             0x00000020  // Policy is being applied across a slow link
#define GPO_INFO_FLAG_VERBOSE              0x00000040  // Verbose output to the eventlog
#define GPO_INFO_FLAG_NOCHANGES            0x00000080  // No changes were detected to the Group Policy Objects
#define GPO_INFO_FLAG_LINKTRANSITION       0x00000100  // A change in link speed was detected between previous policy
                                                       // application and current policy application
#define GPO_INFO_FLAG_LOGRSOP_TRANSITION   0x00000200  // A Change in Rsop Logging was detected between previous policy
                                                       // application and current policy application, (new intf only)
#define GPO_INFO_FLAG_FORCED_REFRESH       0x00000400  // Forced Refresh is being applied. redo policies.
#define GPO_INFO_FLAG_SAFEMODE_BOOT        0x00000800  // windows safe mode boot flag
#define GPO_INFO_FLAG_ASYNC_FOREGROUND     0x00001000  // Asynchronous foreground refresh of policy

typedef UINT_PTR ASYNCCOMPLETIONHANDLE;
typedef DWORD (*PFNSTATUSMESSAGECALLBACK)(__in BOOL bVerbose, __in LPWSTR lpMessage);

typedef DWORD(*PFNPROCESSGROUPPOLICY)(
    __in DWORD dwFlags,                              // GPO_INFO_FLAGS
    __in HANDLE hToken,                              // User or machine token
    __in HKEY hKeyRoot,                              // Root of registry
    __in PGROUP_POLICY_OBJECT  pDeletedGPOList,      // Linked list of deleted GPOs
    __in PGROUP_POLICY_OBJECT  pChangedGPOList,      // Linked list of changed GPOs
    __in ASYNCCOMPLETIONHANDLE pHandle,              // For asynchronous completion
    __inout BOOL *pbAbort,                           // If true, then abort GPO processing
    __in_opt PFNSTATUSMESSAGECALLBACK pStatusCallback);  // Callback function for displaying status messages
                                                     // Note, this can be NULL

typedef DWORD(*PFNPROCESSGROUPPOLICYEX)(
    __in DWORD dwFlags,                              // GPO_INFO_FLAGS
    __in HANDLE hToken,                              // User or machine token
    __in HKEY hKeyRoot,                              // Root of registry
    __in PGROUP_POLICY_OBJECT  pDeletedGPOList,      // Linked list of deleted GPOs
    __in PGROUP_POLICY_OBJECT  pChangedGPOList,      // Linked list of changed GPOs
    __in ASYNCCOMPLETIONHANDLE pHandle,              // For asynchronous completion
    __inout BOOL *pbAbort,                           // If true, then abort GPO processing
    __in_opt PFNSTATUSMESSAGECALLBACK pStatusCallback,   // Callback function for displaying status messages
                                                     // Note, this can be NULL
    __in_opt IWbemServices *pWbemServices,           // Pointer to namespace to log diagnostic mode data
                                                     // Note, this will be NULL when Rsop logging is disabled
    __out HRESULT *pRsopStatus);                     // RSOP Logging succeeded or not.

typedef PVOID PRSOPTOKEN;

typedef struct _RSOP_TARGET {
    WCHAR *     pwszAccountName;                   // Account name
    WCHAR *     pwszNewSOM;                        // New domain or OU location for account
    SAFEARRAY * psaSecurityGroups;                 // New security groups
    PRSOPTOKEN  pRsopToken;                        // Rsop token for use with Rsop security Api's
    PGROUP_POLICY_OBJECT pGPOList;                 // Linked list of GPOs
    IWbemServices *      pWbemServices;            // Pointer to namespace to log planning mode data
} RSOP_TARGET, *PRSOP_TARGET;

typedef DWORD(*PFNGENERATEGROUPPOLICY)(
    __in DWORD dwFlags,                            // GPO_INFO_FLAGS
    __inout BOOL  *pbAbort,                        // If true, then abort GPO processing
    __in_opt WCHAR *pwszSite,                      // Site the target computer is in
    __in_opt PRSOP_TARGET pComputerTarget,         // Computer target info, can be null
    __in_opt PRSOP_TARGET pUserTarget );           // User target info, can be null

//
// GUID that identifies the registry extension
//

#define REGISTRY_EXTENSION_GUID  { 0x35378EAC, 0x683F, 0x11D2, 0xA8, 0x9A, 0x00, 0xC0, 0x4F, 0xBB, 0xCF, 0xA2 }

//
// UBPM trigger provider and event GUIDs
//
#define GROUP_POLICY_TRIGGER_EVENT_PROVIDER_GUID  { 0xBD2F4252, 0x5E1E, 0x49FC, 0x9A, 0x30, 0xF3, 0x97, 0x8A, 0xD8, 0x9E, 0xE2 }
#define MACHINE_POLICY_PRESENT_TRIGGER_GUID  { 0x659FCAE6, 0x5BDB, 0x4DA9, 0xB1, 0xFF, 0xCA, 0x2A, 0x17, 0x8D, 0x46, 0xE0 }
#define USER_POLICY_PRESENT_TRIGGER_GUID  { 0x54FB46C8, 0xF089, 0x464C, 0xB1, 0xFD, 0x59, 0xD1, 0xB6, 0x2C, 0x3B, 0x50 }

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// Group Policy Object client side asynchronous extension processing
//
// extensionId    - Unique guid identifying the extension
// pAsyncHandle   - Asynchronous completion handle that was passed to extension in
//                  ProcessGroupPolicy call
// dwStatus       - Completion status of asynchronous processing
//
// The return value is a Win32 error code. ERROR_SUCCESS means the ProcessGroupPolicyCompleted
// function completed successfully. Otherwise it indicates that the function failed.
//
//=============================================================================

#if(WINVER >= 0x0500)

typedef GUID *REFGPEXTENSIONID;

USERENVAPI
DWORD
WINAPI
ProcessGroupPolicyCompleted(
    __in REFGPEXTENSIONID extensionId,
    __in ASYNCCOMPLETIONHANDLE pAsyncHandle,
    __in DWORD dwStatus);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// Group Policy Object client side asynchronous extension processing
//
// extensionId    - Unique guid identifying the extension
// pAsyncHandle   - Asynchronous completion handle that was passed to extension in
//                  ProcessGroupPolicy call
// dwStatus       - Completion status of asynchronous processing
// RsopStatus     - RSoP Logging status
//
// The return value is a Win32 error code. ERROR_SUCCESS means the ProcessGroupPolicyCompleted
// function completed successfully. Otherwise it indicates that the function failed.
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
DWORD
WINAPI
ProcessGroupPolicyCompletedEx(
    __in REFGPEXTENSIONID extensionId,
    __in ASYNCCOMPLETIONHANDLE pAsyncHandle,
    __in DWORD dwStatus,
    __in HRESULT RsopStatus);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// Function:    RsopAccessCheckByType
//
// Description: Determines whether the security descriptor pointed to by pSecurityDescriptor
//                              grants the set of access rights specified in dwDesiredAccessMask
//                              to the client identified by the RSOPTOKEN pointed to by pRsopToken.
//
// pSecurityDescriptor  - Security Descriptor on the object
// pPrincipalSelfSid    - Principal Sid
// pRsopToken           - Pointer to a valid RSOPTOKEN against which access needs to be checked
// dwDesiredAccessMask  - Mask of requested generic and/or standard and or specific access rights
// pObjectTypeList      - Object Type List
// ObjectTypeListLength - Object Type List Length
// pGenericMapping      - Generic Mapping
// pPrivilegeSet        - privilege set
// pdwPrivilegeSetLength- privilege set length
// pdwGrantedAccessMask - On success, if pbAccessStatus is true, it contains
//                                         the mask of standard and specific rights granted.
//                                         If pbAccessStatus is false, it is set to 0.
//                                         On failure, it is not modified.
// pbAccessStatus       - On success, indicates wether the requested set
//                                    of access rights was granted.
//                                    On failure, it is not modified
//
// Returns S_OK on success or appropriate error code.
// For additional details, look at the documentation of AccessCheckByType
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
HRESULT 
WINAPI
RsopAccessCheckByType(  
    __in       PSECURITY_DESCRIPTOR pSecurityDescriptor,
    __in_opt   PSID pPrincipalSelfSid,
    __in       PRSOPTOKEN pRsopToken,
    __in       DWORD dwDesiredAccessMask,
    __in_ecount_opt(ObjectTypeListLength)   POBJECT_TYPE_LIST pObjectTypeList,
    __in       DWORD ObjectTypeListLength,
    __in       PGENERIC_MAPPING pGenericMapping,
    __in_bcount_opt(*pdwPrivilegeSetLength) PPRIVILEGE_SET pPrivilegeSet,
    __in_opt   LPDWORD pdwPrivilegeSetLength,
    __out LPDWORD pdwGrantedAccessMask,
    __out LPBOOL pbAccessStatus);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// Function:    RsopFileAccessCheck
//
// Description: Determines whether the security descriptor on the file grants the set of file access 
//                              rights specified in dwDesiredAccessMask
//                              to the client identified by the RSOPTOKEN pointed to by pRsopToken.
//
// pszFileName          - Name of an existing filename
// pRsopToken           - Pointer to a valid RSOPTOKEN against which access needs to be checked
// dwDesiredAccessMask  - Mask of requested generic and/or standard and or specific access rights
// pdwGrantedAccessMask - On success, if pbAccessStatus is true, it contains
//                                         the mask of standard and specific rights granted.
//                                         If pbAccessStatus is false, it is set to 0.
//                                         On failure, it is not modified.
// pbAccessStatus       - On success, indicates wether the requested set
//                                    of access rights was granted.
//                                    On failure, it is not modified
//
// Returns S_OK on success or appropriate error code
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
HRESULT 
WINAPI
RsopFileAccessCheck(
    __in  LPWSTR pszFileName,
    __in  PRSOPTOKEN pRsopToken,
    __in  DWORD dwDesiredAccessMask,
    __out LPDWORD pdwGrantedAccessMask,
    __out LPBOOL pbAccessStatus);

#endif /* WINVER >= 0x0500 */

typedef enum _SETTINGSTATUS
{
        RSOPUnspecified = 0,
        RSOPApplied,
        RSOPIgnored,
        RSOPFailed,
        RSOPSubsettingFailed
} SETTINGSTATUS;

//=============================================================================
//
//  POLICYSETTINGSTATUSINFO
//
//  Describes the instance of RSOP_PolicySettingStatus
//
//  szKey               - OPTIONAL, if NULL, the key is generated on the fly
//  szEventSource       - name of the source generation event log messages
//  szEventLogName      - name of the event log database where the messages are logged
//  dwEventID           - event log message ID
//  status              - status of the policy setting
//  timeLogged          - time at which the event log message was logged
//
//=============================================================================

typedef struct _POLICYSETTINGSTATUSINFO
{
        LPWSTR                  szKey;
        LPWSTR                  szEventSource;
        LPWSTR                  szEventLogName;
        DWORD                   dwEventID;
        DWORD                   dwErrorCode;
        SETTINGSTATUS   status;
        SYSTEMTIME              timeLogged;
} POLICYSETTINGSTATUSINFO, *LPPOLICYSETTINGSTATUSINFO;

//=============================================================================
//
//  RsopSetPolicySettingStatus
//
//  Creates an instance of RSOP_PolicySettingStatus and RSOP_PolicySettingLink
//  and links RSOP_PolicySettingStatus to RSOP_PolicySetting
//
//  dwFlags             - flags
//  pServices           - RSOP namespace
//  pSettingInstance    - instance of RSOP_PolicySetting or its children
//  nInfo               - number of PolicySettingStatusInfo
//  pStatus             - array of PolicySettingStatusInfo
//
//  Return:     S_OK if successful, HRESULT otherwise
//
//=============================================================================

USERENVAPI
HRESULT
WINAPI
RsopSetPolicySettingStatus( __in DWORD                       dwFlags,
                            __in IWbemServices*              pServices,
                            __in IWbemClassObject*           pSettingInstance,
                            __in DWORD                       nInfo,
                            __in_ecount(nInfo) POLICYSETTINGSTATUSINFO*    pStatus );

//=============================================================================
//
//  RsopResetPolicySettingStatus
//
//  Unlinks RSOP_PolicySettingStatus from RSOP_PolicySetting,
//  deletes the instance of RSOP_PolicySettingStatus and RSOP_PolicySettingLink
//  and optionally deletes the instance of RSOP_PolicySetting
//
//  dwFlags             - flags
//  pServices           - RSOP namespace
//  pSettingInstance    - instance of RSOP_PolicySetting or its children
//
//  Return:     S_OK if successful, HRESULT otherwise
//
//=============================================================================

USERENVAPI
HRESULT
WINAPI
RsopResetPolicySettingStatus( __in DWORD               dwFlags,
                              __in IWbemServices*      pServices,
                              __in IWbemClassObject*   pSettingInstance );

//=============================================================================
//
// Flags for RSoP WMI providers
//
//=============================================================================

// planning mode provider flags
#define FLAG_NO_GPO_FILTER      0x80000000  // GPOs are not filtered, implies FLAG_NO_CSE_INVOKE
#define FLAG_NO_CSE_INVOKE      0x40000000  // only GP processing done for planning mode
#define FLAG_ASSUME_SLOW_LINK   0x20000000  // planning mode RSoP assumes slow link
#define FLAG_LOOPBACK_MERGE     0x10000000  // planning mode RSoP assumes merge loop back
#define FLAG_LOOPBACK_REPLACE   0x08000000  // planning mode RSoP assumes replace loop back

#define FLAG_ASSUME_USER_WQLFILTER_TRUE   0x04000000  // planning mode RSoP assumes all comp filters to be true
#define FLAG_ASSUME_COMP_WQLFILTER_TRUE   0x02000000  // planning mode RSoP assumes all user filters to be true

#define FLAG_PLANNING_MODE                0x01000000  // flag that indicates that a given namespace was created
                                                      // for planning mode. This flag cannot be passed in but the
                                                      // relevant subnamespace will be marked with this flag

// diagnostic mode provider flags
#define FLAG_NO_USER                      0x00000001  // Don't get any user data
#define FLAG_NO_COMPUTER                  0x00000002  // Don't get any machine data
#define FLAG_FORCE_CREATENAMESPACE        0x00000004  
                   // Delete and recreate the namespace for this snapshot.

//=============================================================================
//
// Extended Errors returned by RSoP WMI Providers
//
//=============================================================================

// User accessing the rsop provider doesn't have access to user data.
#define RSOP_USER_ACCESS_DENIED         0x00000001  

// User accessing the rsop provider doesn't have access to computer data.
#define RSOP_COMPUTER_ACCESS_DENIED     0x00000002  

// This user is an interactive non admin user, the temp snapshot namespace already exists
// and the FLAG_FORCE_CREATENAMESPACE was not passed in
#define RSOP_TEMPNAMESPACE_EXISTS        0x00000004



#ifdef __cplusplus
}
#endif


#endif // _INC_USERENV
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\UtilLib.h ===
//***************************************************************************
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  utillib.h
//
//  Purpose: gather up utillib headers into one catch-all
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef UTILLIB_HEADERFILE_IS_INCLUDED
#define UTILLIB_HEADERFILE_IS_INCLUDED

#include <ProvExce.h>

#include <GenLex.h>
#include <ObjPath.h> 
#include <OPathLex.h> 

#include <CHString.h>
#include <CHStrArr.h>
#include <CHPtrArr.h>
#include <Polarity.h>
#include <WbemTime.h>


#ifndef _DBG_ASSERT
  #ifdef DBG
    #define _DBG_ASSERT(X) { if (!(X)) { DebugBreak(); } }
  #else
    #define _DBG_ASSERT(X)
  #endif
#endif

// MACRO for tracing the safe string return failure  -- currently empty
#ifndef DoTraceHRFailureEmpty
#define DoTraceHRFailureEmpty(hr1, szTraceInfo, hr2)    ;
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\usp10.h ===
/*++

   Copyright (c) Microsoft Corporation. All rights reserved.

*/

#ifndef __usp10__
#define __usp10__
#if _MSC_VER > 1000
#pragma once
#endif

#include <windows.h>
#include <specstrings.h>
#ifdef __cplusplus
extern "C" {
#endif


/////   USP - Unicode Complex Script processor
//
//      Copyright (c) Microsoft Corporation. All rights reserved.




/////   SCRIPT
//
//      The SCRIPT enum is an opaque type used internally to identify
//      which shaping engine functions are used to process a given run.
//
//
#define SCRIPT_UNDEFINED  0
//
//p     SCRIPT_UNDEFINED: This is the only public script ordinal. May be
//      forced into the eScript field of a SCRIPT_ANALYSIS to disable shaping.
//      SCRIPT_UNDEFINED is supported by all fonts - ScriptShape will display
//      whatever glyph is defined in the font CMAP table, or, if none, the
//      missing glyph.







/////   USP Status Codes
//
#define USP_E_SCRIPT_NOT_IN_FONT   \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,0x200)    // Script doesn't exist in font






/////   SCRIPT_CACHE
//
//      Many script APIs take a combination of HDC and SCRIPT_CACHE parameter.
//
//      A SCRIPT_CACHE is an opaque pointer to a Uniscribe font metric cache
//      structure.


typedef void *SCRIPT_CACHE;


//      The client must allocate and retain one SCRIPT_CACHE variable for each
//      character style used. It must be initialised by the client to NULL.
//
//      APIs are passed an HDC and the address of a SCRIPT_CACHE variable.
//      Uniscribe will first attempt to access font data via the SCRIPT_CACHE
//      and will only inspect the HDC if the required data is not already
//      cached.
//
//      The HDC may be passed as NULL. If data required by Uniscribe is
//      already cached, the HDC won't be accessed and operation continues
//      normally.
//
//      If the HDC is passed as NULL, and Uniscribe needs to access it for
//      any reason, Uniscribe will return E_PENDING.
//
//      E_PENDING is returned quickly, allowing the client to avoid time
//      consuming SelectObject calls. The following example applies to all
//      APIs that take a SCRIPT_CACHE and an optional HDC.
//
//c     hr = ScriptShape(NULL, &sc, ..);
//c     if (hr == E_PENDING) {
//c         ... select font into hdc ...
//c         hr = ScriptShape(hdc, &sc, ...);
//c     }






/////   ScriptFreeCache
//
//      The client may free a SCRIPT_CACHE at any time. Uniscribe maintains
//      reference counts in it's font and shaper caches, and frees font data
//      only when all sizes of the font are free, and shaper data only when
//      all fonts it supports are freed.
//
//      The client should free the SCRIPT_CACHE for a style when it discards
//      that style.
//
//      ScriptFreeCache always sets it's parameter to NULL to help avoid
//      mis-referencing.


__checkReturn HRESULT WINAPI ScriptFreeCache(
    __deref_inout_ecount(1) SCRIPT_CACHE   *psc);       //InOut  Cache handle






/////   SCRIPT_CONTROL
//
//      The SCRIPT_CONTROL structure provides itemization control flags to the
//      ScriptItemize function.
//
//
typedef struct tag_SCRIPT_CONTROL {
    DWORD   uDefaultLanguage    :16; // For NADS, also default for context
    DWORD   fContextDigits      :1;  // Means use previous script instead of uDefaultLanguage

    // The following flags provide legacy support for GetCharacterPlacement features
    DWORD   fInvertPreBoundDir  :1;  // Reading order of virtual item immediately prior to string
    DWORD   fInvertPostBoundDir :1;  // Reading order of virtual item immediately following string
    DWORD   fLinkStringBefore   :1;  // Equivalent to presence of ZWJ before string
    DWORD   fLinkStringAfter    :1;  // Equivalent to presence of ZWJ after string
    DWORD   fNeutralOverride    :1;  // Causes all neutrals to be strong in the current embedding direction
    DWORD   fNumericOverride    :1;  // Causes all numerals to be strong in the current embedding direction
    DWORD   fLegacyBidiClass    :1;  // Causes plus and minus to be reated as neutrals, slash as a common separator
    DWORD   fMergeNeutralItems  :1;  // Causes merging neutral characters into strong items, when possible
    DWORD   fReserved           :7;  
} SCRIPT_CONTROL;
//
//
//p     uDefaultLanguage: Language to use when Unicode values are ambiguous.
//              Used by numeric processing to select digit shape when
//              fDigitSubstitute (see SCRIPT_STATE) is in force.
//
//p     fContextDigits: Specifies that national digits are chosen according to
//              the nearest previous strong text, rather than using
//              uDefaultLanguage.
//
//p     fInvertPreBoundDir: By default text at the start of the string is
//              laid out as if it follows strong text of the same direction
//              as the base embedding level. Set fInvertPreBoundDir to change
//              the initial context to the opposite of the base embedding
//              level. This flag is for GetCharacterPlacement legacy support.
//
//p     fInvertPostBoundDir: By default text at the end of the string is
//              laid out as if it preceeds strong text of the same direction
//              as the base embedding level. Set fInvertPostBoundDir to change
//              the final context to the opposite of the base embedding
//              level. This flag is for GetCharacterPlacement legacy support.
//
//p     fLinkStringBefore: Causes the first character of the string to be
//              shaped as if were joined to a previous character.
//
//p     fLinkStringAfter: Causes the last character of the string to be
//              shaped as if were joined to a following character.
//
//p     fNeutralOverride: Causes all neutral characters in the string to be
//              treated as if they were strong characters of their enclosing
//              embedding level. This effectively locks neutrals in place,
//              reordering occuring only between neutrals.
//
//p     fNumericOverride: Causes all numeric characters in the string to be
//              treated as if they were strong characters of their enclosing
//              embedding level. This effectively locks numerics in place,
//              reordering occuring only between numerics.
//
//p     fReserved: Reserved. Always initialise to 0.






/////   SCRIPT_STATE
//
//      The SCRIPT_STATE structure is used both to initialise the unicode
//      algorithm state as an input parameter to ScriptItemize, and is also
//      a component of each item analysis returned by ScriptItemize.
//
//
typedef struct tag_SCRIPT_STATE {
    WORD    uBidiLevel         :5;  // Unicode Bidi algorithm embedding level (0-16)
    WORD    fOverrideDirection :1;  // Set when in LRO/RLO embedding
    WORD    fInhibitSymSwap    :1;  // Set by U+206A (ISS), cleared by U+206B (ASS)
    WORD    fCharShape         :1;  // Set by U+206D (AAFS), cleared by U+206C (IAFS)
    WORD    fDigitSubstitute   :1;  // Set by U+206E (NADS), cleared by U+206F (NODS)
    WORD    fInhibitLigate     :1;  // Equiv !GCP_Ligate, no Unicode control chars yet
    WORD    fDisplayZWG        :1;  // Equiv GCP_DisplayZWG, no Unicode control characters yet
    WORD    fArabicNumContext  :1;  // For EN->AN Unicode rule
    WORD    fGcpClusters       :1;  // For Generating Backward Compatible GCP Clusters (legacy Apps)
    WORD    fReserved          :1;
    WORD    fEngineReserved    :2;  // For use by shaping engine
} SCRIPT_STATE;
//
//
//p     uBidiLevel: The embedding level associated with all characters in this
//              run according to the Unicode bidi algorithm. When passed to
//              ScriptItemize, should be initialised to 0 for an LTR base
//              embedding level, or 1 for RTL.
//
//p     fOverrideDirection: TRUE if this level is an override level (LRO/RLO).
//              In an override level, characters are layed out purely
//              left to right, or purely right to left. No reordering of digits
//              or strong characters of opposing direction takes place.
//              Note that this initial value is reset by LRE, RLE, LRO or
//              RLO codes in the string.
//
//p     fInhibitSymSwap: TRUE if the shaping engine is to bypass mirroring of
//              Unicode Mirrored glyphs such as brackets. Set by Unicode
//              character ISS, cleared by ASS.
//
//p     fCharShape: TRUE if character codes in the Arabic Presentation Forms
//              areas of Unicode should be shaped. (Not implemented).
//
//p     fDigitSubstitute: TRUE if character codes U+0030 through U+0039
//              (European digits) are to be substituted by national digits.
//              Set by Unicode NADS, Cleared by NODS.
//
//p     fInhibitLigate: TRUE if ligatures are not to be used in the shaping
//              of Arabic or Hebrew characters.
//
//p     fDisplayZWG: TRUE if control characters are to be shaped as
//              representational glyphs. (Normally, control characters are
//              shaped to the blank glyph and given a width of zero).
//
//p     fArabicNumContext: TRUE indicates prior strong characters were Arabic
//              for the purposes of rule P0 on page 3-19 of 'The Unicode
//              Standard, version 2.0'. Should normally be set TRUE before
//              itemizing an RTL paragraph in an Arabic language, FALSE
//              otherwise.
//
//p     fGcpClusters: For GetCharaterPlacement legacy support only.
//              Initialise to TRUE to request ScriptShape to generate
//              the LogClust array the same way as GetCharacterPlacement
//              does in Arabic and Hebrew Windows95. Affects only Arabic
//              and Hebrew items.
//
//p     fReserved: Reserved. Always initialise to 0.
//
//p     fEngineReserved: Reserved. Always initialise to 0.






/////   SCRIPT_ANALYSIS
//
//      Each analysed item is described by a SCRIPT_ANALYSIS structure.
//      It also includes a copy of the Unicode algorithm state (SCRIPT_STATE).
//
//
typedef struct tag_SCRIPT_ANALYSIS {
    WORD    eScript         :10;    // Shaping engine
    WORD    fRTL            :1;     // Rendering direction
    WORD    fLayoutRTL      :1;     // Set for GCP classes ARABIC/HEBREW and LOCALNUMBER
    WORD    fLinkBefore     :1;     // Implies there was a ZWJ before this item
    WORD    fLinkAfter      :1;     // Implies there is a ZWJ following this item.
    WORD    fLogicalOrder   :1;     // Set by client as input to ScriptShape/Place
    WORD    fNoGlyphIndex   :1;     // Generated by ScriptShape/Place - this item does not use glyph indices
    SCRIPT_STATE s;
} SCRIPT_ANALYSIS;
//
//
//p     eScript: Opaque value identifying which engine Uniscribe will use to
//              Shape, Place and TextOut this item. The value of eScript is
//              undefined, and will change in future releases, but attributes
//              of eScript may be obtained by calling ScriptGetProperties.
//
//p     fRTL: Rendering direction. Normally identical to the parity of the
//              Unicode embedding level, but may differ if overridden by
//              GetCharacterPlacement legacy support.
//
//p     fLayoutRTL: Logical direction - whether conceptually part of a
//              left-to-right sequenece or a right-to-left sequence. Although
//              this is usually the same as fRTL, for a number in a
//              right-to-left run, fRTL is False (because digits are always
//              displayed LTR), but fLayoutRTL is True (because the number is
//              read as part of the right-to-left sequence).
//
//p     fLinkBefore: If set, the shaping engine will shape the first character
//              of this item as if it were joining with a previous character.
//              Set by ScriptItemize, may be overriden before calling ScriptShape.
//
//p     fLinkAfter: If set, the shaping engine will shape the last character
//              of this item as if it were joining with a subsequient character.
//              Set by ScriptItemize, may be overriden before calling ScriptShape.
//
//p     fLogicalOrder: If set, the shaping engine will generate all glyph
//              related arrays in logical order. By default glyph related
//              arrays are in visual order, the first array entry corresponding
//              to the leftmost glyph.
//              Set to FALSE by ScriptItemize, may be overriden before calling
//              ScriptShape.
//
//p     fNoGlyphIndex: May be set TRUE on input to ScriptShape to disable use
//              of glyphs for this item. Additionally, ScriptShape will set it
//              TRUE for hdcs containing symbolic, unrecognised and device fonts.
//              Disabling glyphing disables complex script shaping. When set,
//              shaping and placing for this item is implemented directly by
//              calls to GetTextExtentExPoint and ExtTextOut.
/////   SCRIPT_ITEM
//
//      The SCRIPT_ITEM structure includes a SCRIPT_ANALYSIS with the string
//      ofset of the first character of the item.
//
//
typedef struct tag_SCRIPT_ITEM {
    int              iCharPos;      // Logical offset to first character in this item
    SCRIPT_ANALYSIS  a;
} SCRIPT_ITEM;
//
//
//p     iCharPos: Offset from beginning of itemised string to first character
//              of this item, counted in Unicode codepoints (i.e. words).
//
//p     a: Script analysis structure containing analysis specific to this
//              item, to be passed to ScriptShape, ScriptPlace etc.






/////   ScriptItemize - break text into items
//
//      Breaks a run of unicode into individually shapeable items.
//      Items are delimited by
//
//      o Change of shaping engine
//      o Change of direction
//
//      The client may create multiple runs from each item returned by
//      ScriptItemize, but should not combine multiple items into a single run.
//
//      Later the client will call ScriptShape for each run (when measuring or
//      rendering), and must pass the SCRIPT_ANALYSIS that ScriptItemize
//      returned.


__checkReturn HRESULT WINAPI ScriptItemize(
    __in_ecount(cInChars) const WCHAR                   *pwcInChars,    // In   Unicode string to be itemized
    int                                                 cInChars,       // In   Codepoint count to itemize
    int                                                 cMaxItems,      // In   Max length of itemization array
    __in_ecount_opt(1) const SCRIPT_CONTROL             *psControl,     // In   Analysis control (optional)
    __in_ecount_opt(1) const SCRIPT_STATE               *psState,       // In   Initial bidi algorithm state (optional)
    __out_ecount_part(cMaxItems, *pcItems) SCRIPT_ITEM  *pItems,        // Out  Array to receive itemization
    __out_ecount(1) int                                 *pcItems);      // Out  Count of items processed (optional)






/////
//
//
//      Returns E_INVALIDARG if pwcInChars == NULL or cInChars == 0
//          or pItems == NULL or cMaxItems < 2.
//
//      Returns E_OUTOFMEMORY if the output buffer length (cMaxItems) is
//          insufficient. Note that in this case, as in all error cases, no
//          items have been fully processed so no part of the output array
//          contains defined values.
//
//      If psControl and psState are NULL on entry, ScriptItemize
//      breaks the unicode string purely by character code.  If they are all
//      non-null, it performs a full Unicode bidi analysis.
//
//      ScriptItemize always adds a terminal item to the item analysis array
//      (pItems) such that the length of an item at pItem is always available as:
//
//c     pItem[1].iCharPos - pItem[0].iCharPos
//
//      For this reason, it is invalid to call ScriptItemize with a buffer
//      of less than two SCRIPT_ANALYSIS items.
//
//      To perform a correct Unicode Bidi analysis, the SCRIPT_STATE should
//      be initialised according to the paragraph reading order at paragraph
//      start, and ScriptItemize should be passed the whole paragraph.
//
//      fRTL and fNumeric together provide the same classification as
//      the lpClass output from GetCharacterPlacement.
//
//      European digits U+0030 through U+0039 may be rendered as national
//      digits as follows:
//
//t     fDigitSubstitute | FContextDigits | Digit shapes displayed for Unicode U+0030 through U+0039
//t     ---------------- | -------------- | ------------------------------------
//t     False            | Any            | Western (European / American) digits
//t     True             | False          | As specified in SCRIPT_CONTROL.uDefaultLanguage
//t     True             | True           | As prior strong text, defaulting to SCRIPT_CONTROL.uDefaultLanguage
//
//
//      For fContextDigits, any Western digits (U+0030 - U+0039) encountered
//      before the first strongly directed character are substituted by the
//      traditional digits of the SCRIPT_CONTROL.uDefaultLanguage when that
//      language is written in the same direction as SCRIPT_STATE.uBidiLevel.
//
//      Thus, in a right-to-left string, if SCRIPT_CONTROL.uDefaultLanguage is
//      1 (LANG_ARABIC), then leading Western digits will be substituted by
//      traditional Arabic digits.
//
//      However, also in a right-to-left string, if SCRIPT_CONTROL.uDefaultLanguage
//      is 0x1e (LANG_THAI), then no substitution occurs on leading Western
//      digits because the Thai language is written left-to-right.
//
//      Following strongly directed characters, digits are substituted
//      by the traditional digits associated with the closest prior strongly
//      directed character.
//
//      The left-to-right mark (LRM) and right-to-left mark (RLM) are strong
//      characters whose language depends on the SCRIPT_CONTROL.uDefaultLangauge.
//
//      If SCRIPT_CONTROL.uDefaultLangauge is a left-to-right langauge, then
//      LRM causes subsequent Western digits to be substituted by the
//      traditional digits associated with that language, while Western
//      digits following RLM are not substituted.
//
//      Conversly, if SCRIPT_CONTROL.uDefaultLangauge is a right-to-left
//      langauge, then Western digits following LRM are not substituted, while
//      Western digits following RLM are substituted by the traditional digits
//      associated with that language.
//
//
//
//      Effect of Unicode control characters on SCRIPT_STATE:
//
//t     SCRIPT_STATE flag | Set by | Cleared by
//t     ----------------- | ------   ----------
//t     fDigitSubstitute  |  NADS  |   NODS
//t     fInhibitSymSwap   |  ISS   |   ASS
//t     fCharShape        |  AAFS  |   IAFS
//
//      SCRIPT_STATE.fArabicNumContext controls the Unicode EN->AN rule.
//      It should normally be initialised to TRUE
//      before itemizing an RTL paragraph in an Arabic language, FALSE
//      otherwise.
/////   ScriptLayout
//
//      The ScriptLayout function converts an array of run embedding levels to
//      a map of visual to logical position, and/or logical to visual position.
//
//      pbLevel must contain the embedding levels for all runs on the line,
//      ordered logically.
//
//      On output, piVisualToLogical[0] is the logical index of the run to
//      display at the far left. Subsequent entries should be displayed
//      progressing from left to right.
//
//      piLogicalToVisual[0] is the relative visual position where the first
//      logical run should be displayed - the leftmost display position being zero.
//
//      The caller may request either piLogicalToVisual or piVisualToLogical
//      or both.
//
//      Note: No other input is required since the embedding levels give all
//      necessary information for layout.


__checkReturn HRESULT WINAPI ScriptLayout(
    int                             cRuns,                  // In   Number of runs to process
    __in_ecount(cRuns) const BYTE   *pbLevel,               // In   Array of run embedding levels
    __out_ecount_full_opt(cRuns) int    *piVisualToLogical,     // Out  List of run indices in visual order
    __out_ecount_full_opt(cRuns) int    *piLogicalToVisual);    // Out  List of visual run positions






/////   SCRIPT_JUSTIFY
//
//      The script justification enumeration provides the client with the
//      glyph characteristic information it needs to implement justification.


typedef enum tag_SCRIPT_JUSTIFY {
    SCRIPT_JUSTIFY_NONE           = 0,   // Justification can't be applied at this glyph
    SCRIPT_JUSTIFY_ARABIC_BLANK   = 1,   // This glyph represents a blank in an Arabic run
    SCRIPT_JUSTIFY_CHARACTER      = 2,   // Inter-character justification point follows this glyph
    SCRIPT_JUSTIFY_RESERVED1      = 3,   // Reserved #1
    SCRIPT_JUSTIFY_BLANK          = 4,   // This glyph represents a blank outside an Arabic run
    SCRIPT_JUSTIFY_RESERVED2      = 5,   // Reserved #2
    SCRIPT_JUSTIFY_RESERVED3      = 6,   // Reserved #3
    SCRIPT_JUSTIFY_ARABIC_NORMAL  = 7,   // Normal Middle-Of-Word glyph that connects to the right (begin)
    SCRIPT_JUSTIFY_ARABIC_KASHIDA = 8,   // Kashida(U+640) in middle of word
    SCRIPT_JUSTIFY_ARABIC_ALEF    = 9,   // Final form of Alef-like (U+627, U+625, U+623, U+632)
    SCRIPT_JUSTIFY_ARABIC_HA      = 10,  // Final form of Ha (U+647)
    SCRIPT_JUSTIFY_ARABIC_RA      = 11,  // Final form of Ra (U+631)
    SCRIPT_JUSTIFY_ARABIC_BA      = 12,  // Middle-Of-Word form of Ba (U+628)
    SCRIPT_JUSTIFY_ARABIC_BARA    = 13,  // Ligature of alike (U+628,U+631)
    SCRIPT_JUSTIFY_ARABIC_SEEN    = 14,  // Highest priority: Initial shape of Seen(U+633) (end)
    SCRIPT_JUSTIFY_ARABIC_SEEN_M  = 15,  // Reserved #4
} SCRIPT_JUSTIFY;



/////   SCRIPT_VISATTR
//
//      The visual (glyph) attribute buffer generated by ScriptShape
//      identifies clusters and justification points:


typedef struct tag_SCRIPT_VISATTR {
    WORD           uJustification   :4;  // Justification class
    WORD           fClusterStart    :1;  // First glyph of representation of cluster
    WORD           fDiacritic       :1;  // Diacritic
    WORD           fZeroWidth       :1;  // Blank, ZWJ, ZWNJ etc, with no width
    WORD           fReserved        :1;  // General reserved
    WORD           fShapeReserved   :8;  // Reserved for use by shaping engines
} SCRIPT_VISATTR;
//
//
//p     uJustification: Justification class for this glyph. See SCRIPT_JUSTIFY.
//
//p     fClusterStart: Set for the logically first glyph in every cluster,
//          even for clusters containing just one glyph.
//
//p     fDiacritic: Set for glyphs that combine with base characters.
//
//p     fZeroWidth: Set by the shaping engine for some, but not all, zero
//          width characters.


/////   ScriptShape
//
//      The ScriptShape function takes a Unicode run and generates glyphs and
//      visual attributes.
//
//      The number of glyphs generated varies according to the script and the
//      font. Only for simple scripts and fonts does each Unicode code point
//      generates a single glyph.
//
//      There is no limit on the number of glyphs generated by a codepoint.
//      For example, a sophisticated complex script font might choose to
//      constuct characters from components, and so generate many times as
//      many glyphs as characters.
//
//      There are also special cases like invalid character representations,
//      where extra glyphs are added to represent the invalid sequence.
//
//      A reasonable guess might be to provide a glyph buffer 1.5 times the
//      length of the character buffer, plus a 16 glyph fixed addition for
//      rare cases like invalid sequenece representation.
//
//      If ScriptShape returns E_OUTOFMEMORY it will be necessary to recall
//      it, possibly more than once, until a large enough buffer is found.


__checkReturn HRESULT WINAPI ScriptShape(
    HDC                                                     hdc,            // In    Optional (see under caching)
    __deref_inout_ecount(1) SCRIPT_CACHE                    *psc,           // InOut Cache handle
    __in_ecount(cChars) const WCHAR                         *pwcChars,      // In    Logical unicode run
    int                                                     cChars,         // In    Length of unicode run
    int                                                     cMaxGlyphs,     // In    Max glyphs to generate
    __inout_ecount(1) SCRIPT_ANALYSIS                       *psa,           // InOut Result of ScriptItemize (may have fNoGlyphIndex set)
    __out_ecount_part(cMaxGlyphs, *pcGlyphs) WORD           *pwOutGlyphs,   // Out   Output glyph buffer
    __out_ecount_full(cChars) WORD                          *pwLogClust,    // Out   Logical clusters
    __out_ecount_part(cMaxGlyphs, *pcGlyphs) SCRIPT_VISATTR *psva,          // Out   Visual glyph attributes
    __out_ecount(1) int                                     *pcGlyphs);     // Out   Count of glyphs generated






/////
//
//      Returns E_OUTOFMEMORY if the output buffer length (cMaxGlyphs) is
//          insufficient. Note that in this case, as in all error cases, the
//          content of all output parameters are undefined.
//
//p     psa: Pass the SCRIPT_ANALYSIS field of the SCRIPT_ITEM entry for this
//          item. (The SCRIPT_ITEM array is returned by ScriptItemize.)
//
//      Clusters are sequenced uniformly within the run, as are glyphs within
//      the cluster - the fRTL item flag (from ScriptItemize) identifies
//      whether left to right, or right to left.
//
//p     pwLogClust: has cChars elements - each entry in pwLogClust corresponds
//          to a character in the input string (pwcChars). The value in each
//          pwLogCLust entry is the offset of the first glyph in the cluster
//          that contains this character.
//
//      Example: In the following example, there are four clusters:
//      1st cluster: one character represented by one glyph
//      2nd cluster: one character represented by 3 glyphs
//      3rd cluster: three characters represented by one glyph
//      4th cluster: 2 characters represented by three glyphs
//
//      Glyph array: (c<n>g<m> means cluster n glyph m)
//c        0      1    2    3      4      5    6    7
//c     -------------------------------------------------
//c     | c1g1 | c2g1 c2g2 c2g3 | c3g1 | c4g1 c4g2 c4g3 |
//c     -------------------------------------------------
//
//      Character array: (c<n>u<m> means cluster n Unicode codepoint m)
//c        0      1      2    3    4      5    6
//c     --------------------------------------------
//c     | c1u1 | c2u1 | c3u1 c3u2 c3u3 | c4u1 c4u2 |
//c     --------------------------------------------
//
//      LogClust: (one entry per character gives 1st glyph in cluster
//c     --------------------------------------------
//c     |   0  |   1  |   4    4    4  |   5    5  |
//c     --------------------------------------------
//
//      Note that for an RTL run (SCRIPT_ANALYSIS.a.fRTL == TRUE) and when
//      fLogicalOrder == FALSE (the default), glyphs are generated in visual
//      order - the reverse of the codepoint order, and the values in the
//      LogClust array will be descending.
//
//
//p     psva: has one visual attribute per glyph and so has maxGlyphs entries.
//
//
//      ScriptShape may set the fNoGlyphIndex flag in psa if the font or
//      OS cannot support glyph indices.
//
//      If fLogicalOrder is requested in psa, glyphs will be always be
//      generated in the same order as the original Unicode characters.
//
//      If fLogicalOrder is not set, right to left items are generated in
//      reverse order, so ScriptTextOut does not need to reverse them before
//      calling ExtTextOut.
/////   ScriptPlace
//
//      The ScriptPlace function takes the output of a ScriptShape call and
//      generates glyph advance width and 2D offset information.
//
//      The composite ABC width for the whole item identifies how much the
//      glyphs overhang to the left of the start position and to the right of
//      the length implied by the sum of the advance widths.
//
//      The total advance width of the line is exactly abcA + abcB + abcC.
//
//      abcA and abcC are maintained internally by Uniscribe as proportions
//      of the cell height represented in 8 bits and are thus roughly +/- 1%.
//      The total width returned (as the sum of piAdvance, and as the sum of
//      abcA+abcB+abcC) is accurate to the resolution of the TrueType shaping
//      engine.
//
//      All glyph related arrays are in visual order unless the fLogicalOrder
//      flag is set in psa.


#ifndef LSDEFS_DEFINED
typedef struct tagGOFFSET {
    LONG  du;
    LONG  dv;
} GOFFSET;
#endif


__checkReturn HRESULT WINAPI ScriptPlace(
    HDC                                         hdc,        // In    Optional (see under caching)
    __deref_inout_ecount(1) SCRIPT_CACHE        *psc,       // InOut Cache handle
    __in_ecount(cGlyphs) const WORD             *pwGlyphs,  // In    Glyph buffer from prior ScriptShape call
    int                                         cGlyphs,    // In    Number of glyphs
    __in_ecount(cGlyphs) const SCRIPT_VISATTR   *psva,      // In    Visual glyph attributes
    __inout_ecount(1) SCRIPT_ANALYSIS           *psa,       // InOut Result of ScriptItemize (may have fNoGlyphIndex set)
    __out_ecount_full(cGlyphs) int              *piAdvance, // Out   Advance wdiths
    __out_ecount_full_opt(cGlyphs) GOFFSET      *pGoffset,  // Out   x,y offset for combining glyph
    __out_ecount(1) ABC                         *pABC);     // Out   Composite ABC for the whole run (Optional)






/////   ScriptTextOut
//
//      The ScriptTextOut function takes the output of both ScriptShape and
//      ScriptPlace calls and calls the operating system ExtTextOut function
//      appropriately. If the last parameter is not null, GDI's ExtTextOutW calls
//      are routed to this function.
//
//      All arrays are in visual order unless the fLogicalOrder flag is set in
//      psa.


__checkReturn HRESULT WINAPI ScriptTextOut(
    const HDC                               hdc,            // In     OS handle to device context (required)
    __deref_inout_ecount(1) SCRIPT_CACHE    *psc,           // InOut  Cache handle
    int                                     x,              // In     x,y position for first glyph
    int                                     y,              // In
    UINT                                    fuOptions,      // In     ExtTextOut options
    __in_ecount_opt(1) const RECT           *lprc,          // In     optional clipping/opaquing rectangle
    __in_ecount(1) const SCRIPT_ANALYSIS    *psa,           // In     Result of ScriptItemize
    __reserved const WCHAR                  *pwcReserved,   // In     Reserved (requires NULL)
    __reserved int                          iReserved,      // In     Reserved (requires 0)
    __in_ecount(cGlyphs) const WORD         *pwGlyphs,      // In     Glyph buffer from prior ScriptShape call
    int                                     cGlyphs,        // In     Number of glyphs
    __in_ecount(cGlyphs) const int          *piAdvance,     // In     Advance widths from ScriptPlace
    __in_ecount_opt(cGlyphs) const int      *piJustify,     // In     Justified advance widths (optional)
    __in_ecount(cGlyphs) const GOFFSET      *pGoffset);     // In     x,y offset for combining glyph






/////
//
//      The caller should normally use SetTextAlign(hdc, TA_RIGHT) before
//      calling ScriptTextOut with an RTL item inlogical order.
//
//      The piJustify array provides requested cell widths for each glyph.
//      When the piJustify width of a glyph differs from the unjustified
//      width (in PiAdvance), space is added to or removed from the glyph
//      cell at it's trailing edge. The glyph is always aligned with the
//      leading edge of it's cell. (This rule applies even in visual order.)
//
//      When a glyph cell is extended the extra space is uaually made up by
//      the addition of white space, however for Arabic scripts, the extra
//      space is made up by one or more kashida glyphs, unless the extra space
//      is insufficient for the shortest kashida glyph in the font. (The
//      width of the shortest kashida is available by calling
//      ScriptGetFontProperties.)
//
//      piJustify should only be passed if re-justification of the string is
//      required. Normally pass NULL to this parameter.
//
//      fuOptions may contain ETO_CLIPPED or ETO_OPAQUE (or neither or both).
//
//      Do not use ScriptTextOut to write to a metafile unless you are sure
//      that the metafile will eventually be played back without any font
//      substitution. ScriptTextOut record glyph numbers in the metafile.
//      Since glyph numbers vary considerably from one font to another
//      such a metafile is unlikely to play back correctly when differant
//      fonts are substituted.
//
//      For example when a metafile is played back at a different scale
//      CreateFont requests recorded in the metafile may resolve to bitmap
//      instead of truetype fonts, or if the metafile is played back on
//      a different machine requested fonts may not be installed.//
//
//      To write complex scripts in a metafile in a font independant manner,
//      use ExtTextOut to write the logical characters directly, so that
//      glyph generation and placement does not occur until the text is
//      played back.
/////   ScriptJustify
//
//      ScriptJustify provides a simple minded implementation of multilingual
//      justification.
//
//      Sophisticated text formatters may prefer to generate their own delta
//      dx array by combining their own features with the information returned
//      by ScriptShape in the SCRIPT_VISATTR array.
//
//      ScriptJustify establishes how much adjustment to make at each glyph
//      position on the line. It interprets the SCRIPT_VISATTR array generated
//      by a call to ScriptShape, and gives top priority to kashida, then uses
//      inter word spacing if there's no kashida points, then uses
//      intercharacter spacing if there are no inter-word points.
//
//      The justified advance widths generated in ScriptJustify should be
//      passed to ScriptTextOut in the piJustify paramter.
//
//      ScriptJustify creates a justify array containing updated advance
//      widths for each glyph. Where a glyphs advance width is increased, it
//      is expected that the extra width will be rendered to the right of the
//      glyph, with as white space or, for Arabic text, as kashida.
/////
__checkReturn HRESULT WINAPI ScriptJustify(
    __in_ecount(cGlyphs) const SCRIPT_VISATTR   *psva,          // In   Collected visual attributes for entire line
    __in_ecount(cGlyphs) const int              *piAdvance,     // In   Advance widths from ScriptPlace
    int                                         cGlyphs,        // In   Size of all arrays
    int                                         iDx,            // In   Desired width change, either increase or descrease
    int                                         iMinKashida,    // In   Minimum length of continuous kashida glyph to generate
    __out_ecount_full(cGlyphs) int              *piJustify);    // Out  Updated advance widths to pass to ScriptTextOut






/////   SCRIPT_LOGATTR
//
//      The SCRIPT_LOGATTR structure describes attributes of logical
//      characters useful when editing and formatting text.
//
//      Note that for wordbreaking and linebreaking, if the first character of
//      the run passed in is not whitespace, the client needs to check whether
//      the last character of the previous run is whitespace to determine if
//      the first character of this run is the start of a word.
//
//
typedef struct tag_SCRIPT_LOGATTR {
    BYTE    fSoftBreak      :1;     // Potential linebreak point
    BYTE    fWhiteSpace     :1;     // A unicode whitespace character, except NBSP, ZWNBSP
    BYTE    fCharStop       :1;     // Valid cursor position (for left/right arrow)
    BYTE    fWordStop       :1;     // Valid cursor position (for ctrl + left/right arrow)
    BYTE    fInvalid        :1;     // Invalid character sequence
    BYTE    fReserved       :3;
} SCRIPT_LOGATTR;
//
//
//p     fSoftBreak: It would be valid to break the line in front of this
//              character. This flag is set on the first character of
//              South-East Asian words. Note that when linebreaking the
//              client would usually also treat any nonblank following a blank
//              as a softbreak position, by inspecting the fWhiteSPace flag
//              below.
//
//p     fWhiteSpace: This character is one of the many Unicode character
//              that are classified as breakable whitespace.
//
//p     fCharStop: Valid cursor position. Set on most characters, but not
//              on codepoints inside Indian and South East Asian character
//              clusters. May be used to implement left and right arrow
//              operation in editors.
//
//p     fWordStop: Valid position following word advance/retire commonly
//              implemented at ctrl/left-arrow and ctrl/right-arrow.
//              May be used to implement ctrl+left and ctrl+right arrow
//              operation in editors. As with fSoftBreak clients should
//              normally also inspect the fWhiteSpace flag and treat the
//              first character after a run of whitespace as the start of a
//              word.
//
//p     fInvalid: Marks characters which form an invalid or undisplayable
//              combination. Scripts which can set this flag have the flag
//              fInvalidLogAttr set in their SCRIPT_PROPERTIES.






/////   ScriptBreak
//
//      The ScriptBreak function returns cursor movement and formatting break
//      positions for an item as an array of SCRIPT_LOGATTRs. To support
//      mixed formatting within a single word correctly, ScriptBreak should
//      be passed whole items as returned by ScriptItemize.
//
//      ScriptBreak does not require an hdc and does not execute glyph shaping.
//
//      The fCharStop flag marks cluster boundaries for those scripts where
//      it is conventional to restrict from moving inside clusters. The same
//      boundaries could also be inferred by inspecting the pLogCLust array
//      returned by ScriptShape, however ScriptBreak is considerably faster in
//      implementation and does not require an hdc to be prepared.
//
//      The fWordStop, fSoftBreak and fWhiteSpace flags are only available
//      through ScriptBreak.
//
//      Most shaping engines that identify invalid sequences do so by setting
//      the fInvalid flag in ScriptBreak. The fInvalidLogAttr flag in
//      ScriptProperties identifies which scripts do this.


__checkReturn HRESULT WINAPI ScriptBreak(
    __in_ecount(cChars) const WCHAR             *pwcChars,  // In   Logical unicode item
    int                                         cChars,     // In   Length of unicode item
    __in_ecount(1) const SCRIPT_ANALYSIS        *psa,       // In   Result of earlier ScriptItemize call
    __out_ecount_full(cChars) SCRIPT_LOGATTR    *psla);     // Out  Logical character attributes






/////   ScriptCPtoX
//
//      The ScriptCPtoX function returns the x offset from the left end
//      (!fLogical) or leading edge (fLogical) of a run to either the leading
//      or the trailing edge of a logical character cluster.
//
//      iCP is the offset of any logical character in the cluster.
//
//      For scripts where the caret may conventionally be placed into the
//      middle of clusters (e.g. Arabic, Hebrew), the returned X may be
//      an interpolated position for any codepoint in the line.
//
//      For scripts where the caret is conventionally snapped to the boundaries
//      of clusters, (e.g. Thai, Indian), the resulting X position will be
//      snapped to the requested edge of the cluster containing CP.


__checkReturn HRESULT WINAPI ScriptCPtoX(
    int                                         iCP,            // In   Logical character position in run
    BOOL                                        fTrailing,      // In   Which edge (default - leading)
    int                                         cChars,         // In   Count of logical codepoints in run
    int                                         cGlyphs,        // In   Count of glyphs in run
    __in_ecount(cChars) const WORD              *pwLogClust,    // In   Logical clusters
    __in_ecount(cGlyphs) const SCRIPT_VISATTR   *psva,          // In   Visual glyph attributes array
    __in_ecount(cGlyphs) const int              *piAdvance,     // In   Advance widths
    __in_ecount(1) const SCRIPT_ANALYSIS        *psa,           // In   Script analysis from item attributes
    int                                         *piX);          // Out  Resulting X position






/////   ScriptXtoCP
//
//      The ScriptXtoCP function converts an x offset from the left end
//      (!fLogical) or leading edge (fLogical) of a run to a logical
//      character position and a flag that indicates whether the X position
//      fell in the leading or the trailing half of the character.
//
//      For scripts where the cursor may conventionally be placed into the
//      middle of clusters (e.g. Arabic, Hebrew), the returned CP may be
//      for any codepoint in the line, and fTrailing will be either zero
//      or one.
//
//      For scripts where the cursor is conventionally snapped to the
//      boundaries of a cluster, the returned CP is always the position of
//      the logically first codepoint in a cluster, and fTrailing is either
//      zero, or the number of codepoints in the cluster.
//
//      Thus the appropriate cursor position for a mouse hit is always the
//      returned CP plus the value of fTrailing.
//
//      If the X positition passed is not in the item at all, the resulting
//      position will be the trailing edge of character -1 (for X positions
//      before the item), or the leading edge of character 'cChars' (for
//      X positions following the item).


__checkReturn HRESULT WINAPI ScriptXtoCP(
    int                                         iX,             // In   X offset from left of run
    int                                         cChars,         // In   Count of logical codepoints in run
    int                                         cGlyphs,        // In   Count of glyphs in run
    __in_ecount(cChars) const WORD              *pwLogClust,    // In   Logical clusters
    __in_ecount(cGlyphs) const SCRIPT_VISATTR   *psva,          // In   Visual glyph attributes
    __in_ecount(cGlyphs) const int              *piAdvance,     // In   Advance widths
    __in_ecount(1) const SCRIPT_ANALYSIS        *psa,           // In   Script analysis from item attributes
    __out_ecount(1) int                         *piCP,          // Out  Resulting character position
    __out_ecount(1) int                         *piTrailing);   // Out  Leading or trailing half flag






/////   Relationship between caret positions, justifications points and clusters
//
//
//t     Job                              | Uniscribe support
//t     -------------------------------- | --------------------------------------------------------
//t     Caret move by character cluster  | LogClust or VISATTR.fClusterStart or LOGATTR.fCharStop
//t     Line breaking between characters | LogClust or VISATTR.fClusterStart or LOGATTR.fCharStop
//t     Caret move by word               | LOGATTR.fWordStop
//t     Line breaking between words      | LOGATTR.fWordStop
//t     Justification                    | VISATTR.uJustification
//
//
//
/////   Character clusters
//
//      Character clusters are glyph sequences that cannot be split between
//      lines.
//
//      Some languages (e.g. Thai, Indic) restrict caret placement to points
//      betwen clusters. This applies both to keyboard initiated caret
//      movement (e.g. cursor keys) and pointing and clicking with the mouse
//      (hit testing).
//
//      Uniscribe provides cluster information in both the visual and logical
//      attributes. If you've called ScriptShape you'll find the cluster
//      information represented both by sequences of the same value in the
//      pwLogClust array, and by the fClusterStart flag in the psva
//      SCRIPT_VISATTR array.
//
//      ScriptBreak also returns the fCharStop flag in the SCRIPT_LOGATTR
//      array to identify cluster positions.
//
//
//
/////   Word break points
//
//      Valid positions for moving the caret when moving in whole words are
//      marked by the fWordStop flag returned by ScriptBreak.
//
//      Valid positions for breaking lines between words are marked by the
//      fSoftBreak flag returned by ScriptBreak.
//
//
//
/////   Justification
//
//      Justification space or kashida should be inserted where identified by
//      the uJustificaion field of the SCRIPT_VISATTR.
//
//      When performing inter-character justification, insert extra space
//      only after glyphs marked with uJustify == SCRIPT_JUSTIFY_CHARACTER.
//
//
//
/////   Script specific processing
//
//      Uniscribe provides information about special processing for each
//      script in the SCRIPT_PROPERTIES array.
//
//      Use the following code during initialisation to get a pointer to
//      the SCRIPT_PROPERTIES array:
//
//c     const SCRIPT_PROPERTIES **g_ppScriptProperties; // Array of pointers to properties
//c     int iMaxScript;
//c     HRESULT hr;
//
//c     hr = ScriptGetProperties(&g_ppScriptProperties, &g_iMaxScript);
//
//      Then inspect the properties of the script of an item 'iItem' as follows:
//
//c     hr = ScriptItemize( ... , pItems, ... );
//c     ...
//c     if (g_ppScriptProperties[pItems[iItem].a.eScript]->fNeedsCaretInfo) {
//c         // Use ScriptBreak to restrict the caret from entering clusters (for example).
//c     }
//
//
//      SCRIPT_PROPERTIES.fNeedsCaretInfo
//
//      Caret placement should be restricted to cluster
//      edges for scripts such as Thai and Indian. The fNeedsCaretInfo flag
//      in SCRIPT_PROPERTIES identifies such languages.
//
//      Note that ScriptXtoCP and ScriptCPtoX automatically apply caret
//      placement restictions.
//
//
//      SCRIPT_PROPERTIES.fNeedsWordBreaking
//
//      For most scripts, word break placement  may be
//      identified by scanning for characters marked as fWhiteSpace in
//      SCRIPT_LOGATTR, or for glyphs marked as uJustify ==
//      SCRIPT_JUSTIFY_BLANK or SCRIPT_JUSTIFY_ARABIC_BLANK in SCRIPT_VISATTR.
//
//      For languages such as Thai, it is also necessary to call ScriptBreak,
//      and include character positions marked as fWordStop in SCRIPT_LOGATTR.
//      Such scripts are marked as fNeedsWordbreaking in SCRIPT_PROPERTIES.
//
//
//      SCRIPT_PROPERTIES.fNeedsCharacterJustify
//
//      Languages such as Thai also require inter-character spacing when
//      justifying (where uJustify == SCRIPT_JUSTIFY_CHARACTER in the
//      SCRIPT_VISATTR). Such languages are marked as fNeedsCharacterJustify
//      in SCRIPT_PROPERTIES.
//
//
//      SCRIPT_PROPERTIES.fAmbiguousCharSet
//
//      Many Uniscribe scripts do not correspond directly to 8 bit character
//      sets. For example Unicode characters in the range U+100 through U+024F
//      represent extended latin shapes used for many languages, including
//      those supported by EASTEUROPE_CHARSET, TURKISH_CHARSET and
//      VIETNAMESE_CHARSET. However many of these characters are supported by
//      more han one of thsese charsets.
//      fAmbiguousCharset is set for any script token which could contain
//      characters from a number of these charsets. In these cases the bCharSet
//      field may contain ANSI_CHARSET or DEFAULT_CHARSET. The Uniscribe client
//      will generally need to apply futher processing to determine which charset
//      to use when requesting a font suitable for this run. For example it
//      determine that the run consists of multiple languages and split it up
//      to use a different font for each language.






/////   Notes on ScriptXtoCP and ScriptCPtoX
//
//      Both functions work only within runs and require the results of a
//      previous ScriptShape call.
//
//      The client must establish which run a given cursor offset or x
//      position is within before passing it to ScriptCPtoX or ScriptXtoCP.
//
//      Cluster information in the logical cluster array is used to share
//      the width of a cluster of glyphs equally among the logical characters
//      they represent.
//
//      For example, the lam alif glyph is divided into four areas: the
//      leading half of the lam, the trailing half of the lam, the leading
//      half of the alif and the trailing half of the alif.
//
//      ScriptXtoCP Understands the caret position conventions of each script.
//      For Indian and Thai, caret positions are snapped to cluster boundaries,
//      for Arabic and Hebrew, caret positions are interpolated within clusters.
//
//
/////   Translating mouse hit 'x' offset to caret position
//
//      Conventionally, caret position 'cp' may be selected by clicking either
//      on the trailing half of character 'cp-1' or on the leading half of
//      character 'cp'. This may easily be implemented as follows:
//
//c     int iCharPos;
//c     int iCaretPos
//c     int fTrailing;
//
//c     ScriptXtoCP(iMouseX, ..., &iCharPos, &fTrailing);
//c     iCaretPos = iCharPos + fTrailing;
//
//      For scripts that snap the caret to cluster boundaries, ScriptXtoCP
//      returns ftrailing set to either 0, or the width of the cluster in
//      codepoints. Thus the above code correctly returns only valid
//      caret positions.
//
//
/////   Displaying the caret in bidi strings
//
//      In unidirectional text, the leading edge of a character is at the same
//      place as the trailing edge of the previous character, so there is no
//      ambiguity in placing the caret between characters.
//
//      In bidirectional text, the caret position between runs of opposing
//      direction may be ambiguous.
//
//      For example in the left to right paragraph 'helloMAALAS', the last
//      letter of 'hello' immediately preceeds the first letter of 'salaam'.
//      The best position to display the caret depends on whether it is
//      considered to follow the 'o' of 'hello', or to preceed the 's' of
//      'salaam'.
//
/////   Commonly used caret positioning conventions
//
//t     Situation       | Visual caret placement
//t     ---------       | -------------------------------------------
//t     Typing          | Trailing edge of last character typed
//t     Pasting         | Trailing edge of last character pasted
//t     Caret advancing | Trailing edge of last character passed over
//t     Caret retiring  | Leading edge of last character passed over
//t     Home            | Leading edge of line
//t     End             | Trailing edge of line
//
//      The caret may be positioned as follows:
//
//c     if (advancing) {
//c         ScriptCPtoX(iCharPos-1, TRUE, ..., &iCaretX);
//c     } else {
//c         ScriptCPtoX(iCharPos, FALSE, ..., &iCaretX);
//c     }
//
//      Or, more simply, given an fAdvancing BOOL restricted to TRUE or FALSE:
//
//c     ScriptCPtoX(iCharPos-fAdvancing, fAdvancing, ..., &iCaretX);
//
//      ScriptCPtoX handles out of range positions logically: it returns the
//      leading edge of the run for iCharPos <0, and the trailing edge of the
//      run for iCharPos >=length.
/////   ScriptGetLogicalWidths
//
//      Converts visual withs in piAdvance into logical widths,
//      one per original character, in logical order.
//
//      Ligature glyphs widths are divided evenly amongst the characters
//      they represent.


__checkReturn HRESULT WINAPI ScriptGetLogicalWidths(
    __in_ecount(1) const SCRIPT_ANALYSIS        *psa,           // In   Script analysis from item attributes
    int                                         cChars,         // In   Count of logical codepoints in run
    int                                         cGlyphs,        // In   Count of glyphs in run
    __in_ecount(cGlyphs) const int              *piGlyphWidth,  // In   Advance widths
    __in_ecount(cChars) const WORD              *pwLogClust,    // In   Logical clusters
    __in_ecount(cGlyphs) const SCRIPT_VISATTR   *psva,          // In   Visual glyph attributes
    __in_ecount(cChars) int                     *piDx);         // Out  Logical widths






/////
//      ScriptGetLogicalWidths is useful for recording widths in a
//      font independant manner. By passing the recorded logical widths
//      to ScriptApplyLogicalWidths, a block of text can be replayed in the
//      same boundaries with acceptable loss of quality even when the original
//      font is not available.
/////   ScriptApplyLogicalWidth
//
//      Accepts an array of advance widths in logical order, corresponding
//      one to one with codepoints, and generates an array of glyph widths
//      suitable for passing to the piJustify parameter of ScriptTextOut.
//
//      ScriptApplyLogicalWidth may be used to reapply logical widths
//      obtained with ScriptGetLogicalWidths. It may be useful in situations
//      such as metafiling, where it is necessary to record and reapply
//      advance width information in a font independant manner.



__checkReturn HRESULT WINAPI ScriptApplyLogicalWidth(
    __in_ecount(cChars) const int               *piDx,          // In     Logical dx array to apply
    int                                         cChars,         // In     Count of logical codepoints in run
    int                                         cGlyphs,        // In     Glyph count
    __in_ecount(cChars) const WORD              *pwLogClust,    // In     Logical clusters
    __in_ecount(cGlyphs) const SCRIPT_VISATTR   *psva,          // In     Visual attributes from ScriptShape/Place
    __in_ecount(cGlyphs) const int              *piAdvance,     // In     Glyph advance widths from ScriptPlace
    __in_ecount(1) const SCRIPT_ANALYSIS        *psa,           // In     Script analysis from item attributes
    __inout_ecount_opt(1) ABC                   *pABC,          // InOut  Updated item ABC width (optional)
    __out_ecount_full(cGlyphs) int              *piJustify);    // Out    Resulting glyph advance widths for ScriptTextOut






/////
//p     piDx: Pointer to an array of dx widths in logical order, one per codepoint.
//
//p     cChars: Count of the logical codepoints in the run.
//
//p     cGlyphs: Glyph count.
//
//p     pwLogClust: Pointer to an array of logical clusters from ScriptShape
//
//p     psva: Pointer to an array of visual attributes from ScriptShape and
//          updated by ScriptPlace.
//
//p     piAdvance: Pointer to an array of glyph advance widths from ScriptPlace.
//
//p     psa: Pointer to a SCRIPT_ANALYSIS structure from ScriptItemize and
//          updated by ScriptShape and SriptPlace..
//
//p     pABC: Pointer to the run overall ABC width (optional). If present,
//          when the function is called, it should contain the run ABC width
//          returned by ScriptPlace; when the function returns, the ABC width
//          has been updated to match the new widths.
//
//p     piJustify:Pointer to an array of the resulting glyph advance widths.
//          This is suitable for passing to the piJustify parameter of ScriptTextOut.
/////   ScriptGetCMap
//
//      ScriptGetCMap may be used to determine which characters in a run
//      are supported by the selected font.
//
//      It returns glyph indices of Unicode characters according to Truetype
//      Cmap table, or standard Cmap implemented for old style fonts. The
//      glyph indices are returned in the same order as the input string.
//
//      The caller may scan the returned glyph buffer looking for the default
//      glyph to determine which characters are not available. (The default
//      glyph index for the selected font should be determined by calling
//      ScriptGetFontProperties).
//
//      The return value indicates the presence of any missing glyphs.


#define SGCM_RTL  0x00000001      // Return mirrored glyph for mirrorable Unicode codepoints


__checkReturn HRESULT WINAPI ScriptGetCMap(
    HDC                                     hdc,            // In    Optional (see notes on caching)
    __deref_inout_ecount(1) SCRIPT_CACHE    *psc,           // InOut Address of Cache handle
    __in_ecount(cChars) const WCHAR         *pwcInChars,    // In    Unicode codepoint(s) to look up
    int                                     cChars,         // In    Number of characters
    DWORD                                   dwFlags,        // In    Flags such as SGCM_RTL
    __out_ecount(cChars) WORD               *pwOutGlyphs);  // Out   Array of glyphs, one per input character






/////
//  returns S_OK     - All unicode codepoints were present in the font
//          S_FALSE  - Some of the Unicode codepoints were mapped to the default glyph
//          E_HANDLE - font or system does not support glyph indices
/////   ScriptGetGlyphABCWidth
//
//      Returns ABC width of a given glyph.
//      May be useful for drawing glyph charts. Should not be used for
//      run of the mill complex script text formatting.


__checkReturn HRESULT WINAPI ScriptGetGlyphABCWidth(
    HDC                                     hdc,        // In    Optional (see notes on caching)
    __deref_inout_ecount(1) SCRIPT_CACHE    *psc,       // InOut Address of Cache handle
    WORD                                    wGlyph,     // In    Glyph
    __out_ecount(1) ABC                     *pABC);     // Out   ABC width






/////
//  returns S_OK     - Glyph width returned
//          E_HANDLE - font or system does not support glyph indices
/////   SCRIPT_PROPERTIES
//
typedef struct {
    DWORD   langid                 :16; // Primary and sublanguage associated with script
    DWORD   fNumeric               :1;
    DWORD   fComplex               :1;  // Script requires special shaping or layout
    DWORD   fNeedsWordBreaking     :1;  // Requires ScriptBreak for word breaking information
    DWORD   fNeedsCaretInfo        :1;  // Requires caret restriction to cluster boundaries
    DWORD   bCharSet               :8;  // Charset to use when creating font
    DWORD   fControl               :1;  // Contains only control characters
    DWORD   fPrivateUseArea        :1;  // This item is from the Unicode range U+E000 through U+F8FF
    DWORD   fNeedsCharacterJustify :1;  // Requires inter-character justification
    DWORD   fInvalidGlyph          :1;  // Invalid combinations generate glyph wgInvalid in the glyph buffer
    DWORD   fInvalidLogAttr        :1;  // Invalid combinations are marked by fInvalid in the logical attributes
    DWORD   fCDM                   :1;  // Contains Combining Diacritical Marks
    DWORD   fAmbiguousCharSet      :1;  // Script does not correspond 1:1 with a charset
    DWORD   fClusterSizeVaries     :1;  // Measured cluster width depends on adjacent clusters
    DWORD   fRejectInvalid         :1;  // Invalid combinations should be rejected
} SCRIPT_PROPERTIES;
//
//p     langid: Language associated with this script. When a script is used for many languages,
//          langid id represents a default language. For example, Western script is represented
//          by LANG_ENGLISH although it is also used for French, German, Spanish etc.
//
//p     fNumeric: Script contains numerics and characters used in conjunction with numerics
//          by the rules of the Unicode bidirectional algorithm. For example
//          dollar sign and period are classified as numeric when adjacent to or in between
//          digits.
//
//p     fComplex: Indicates a script that requires complex script handling. If fComplex is false
//          the script contains no combining characters and requires no contextual shaping or reordering.
//
//p     fNeedsWordBreaking: A script, such as Thai, which requires algorithmic wordbreaking.
//          Use ScriptBreak to obtain a wordbreak points using the standard system wordbreaker.
//
//p     fNeedsCaretInfo: A script, such as Thai and Indian, where the caret may not be placed
//          inside a cluster. To determine valid caret positions inspect the fCharStop flag in the
//          logical attributes returned by ScriptBreak, or compare adjacent values in the pwLogClust
//          array returned by ScriptShape.
//
//p     bCharSet: Nominal charset associated with script. May be used in a logfont when creating
//          a font suitable for displaying this script. Note that for new scripts where there
//          is no charset defined, bCharSet may be innapropriate and DEFAULT_CHARSET should
//          be used instead - see the description of fAmbiguousCharSet below.
//
//p     fControl: contains control characters.
//
//p     fPrivateUseArea: The Unicode range U+E000 through U+F8FF.
//
//p     fNeedsCharacterJustify: A script, such as Thai, where justification is conventionally
//          achieved by increasing the space between all letters, not just between words.
//
//p     fInvalidGlyph: A script for which ScriptShape generates an invalid glyph
//          to represent invalid sequences. The glyph index of the invalid glyph for
//          a particular font may be obtained by calling ScriptGetFontProperties.
//
//p     fInvalidLogAttr: A script for which ScriptBreak sets the fInvalid flag
//          in the logical attributes to mark invalid sequences.
//
//p     fCDM: Implies that an item analysed by ScriptItemize included combining
//          diacritical marks (U+0300 through U+36F).
//
//p     fAmbiguousCharSet: No single legacy charset supports this script.
//          For example the extended Latin Extended-A Unicode range includes
//          characters from the EASTUROPE_CHARSET, the TURKISH_CHARSET and the
//          BALTIC_CHARSET. It also contains characters that are not available
//          in any legacy charset. Use DEFAULT_CHARSET when creating fonts to
//          display parts of this run.
//
//p     fClusterSizeVaries: A script, such as Arabic, where contextual shaping
//          may cause a string to increase in size when removing characters.
//
//p     fRejectInvalid: A script, such as Thai, where invalid sequences conventionally
//          cause an editor such as notepad to beep, and ignore keypresses.


/////   ScriptGetProperties
//
//      ScriptGetProperties returns the address of a table that maps a
//      script in a SCRIPT_ANALYSIS uScript field to properties including
//      the primary language associated with that script, whether it's
//      numeric and whether it's complex.


__checkReturn HRESULT WINAPI ScriptGetProperties(
    __deref_out_ecount(1) const SCRIPT_PROPERTIES   ***ppSp,        // Out  Receives pointer to table of pointers to properties indexed by script
    __out_ecount(1) int                             *piNumScripts); // Out  Receives number of scripts (valid values are 0 through NumScripts-1)






/////   SCRIPT_FONTPROPERTIES
//
typedef struct {
    int     cBytes;         // Structure length
    WORD    wgBlank;        // Blank glyph
    WORD    wgDefault;      // Glyph used for Unicode values not present in the font
    WORD    wgInvalid;      // Glyph used for invalid character combinations (especially in Thai)
    WORD    wgKashida;      // Shortest continuous kashida glyph in the font, -1 if doesn't exist
    int     iKashidaWidth;  // Widths of shortest continuous kashida glyph in the font
} SCRIPT_FONTPROPERTIES;


/////   ScriptGetFontProperties
//
//      Returns information from the font cache


__checkReturn HRESULT WINAPI ScriptGetFontProperties(
    HDC                                     hdc,    // In    Optional (see notes on caching)
    __deref_inout_ecount(1) SCRIPT_CACHE    *psc,   // InOut Address of Cache handle
    __out_ecount(1) SCRIPT_FONTPROPERTIES   *sfp);  // Out   Receives properties for this font






/////   ScriptCacheGetHeight
//
//


__checkReturn HRESULT WINAPI ScriptCacheGetHeight(
    HDC                                     hdc,        // In    Optional (see notes on caching)
    __deref_inout_ecount(1) SCRIPT_CACHE    *psc,       // InOut Address of Cache handle
    __out_ecount(1) long                    *tmHeight); // Out   Receives font height in pixels






/////   ScriptStringAnalyse
//
//
#define SSA_PASSWORD         0x00000001  // Input string contains a single character to be duplicated iLength times
#define SSA_TAB              0x00000002  // Expand tabs
#define SSA_CLIP             0x00000004  // Clip string at iReqWidth
#define SSA_FIT              0x00000008  // Justify string to iReqWidth
#define SSA_DZWG             0x00000010  // Provide representation glyphs for control characters
#define SSA_FALLBACK         0x00000020  // Use fallback fonts
#define SSA_BREAK            0x00000040  // Return break flags (character and word stops)
#define SSA_GLYPHS           0x00000080  // Generate glyphs, positions and attributes
#define SSA_RTL              0x00000100  // Base embedding level 1
#define SSA_GCP              0x00000200  // Return missing glyphs and LogCLust with GetCharacterPlacement conventions
#define SSA_HOTKEY           0x00000400  // Replace '&' with underline on subsequent codepoint
#define SSA_METAFILE         0x00000800  // Write items with ExtTextOutW Unicode calls, not glyphs
#define SSA_LINK             0x00001000  // Apply FE font linking/association to non-complex text
#define SSA_HIDEHOTKEY       0x00002000  // Remove first '&' from displayed string
#define SSA_HOTKEYONLY       0x00002400  // Display underline only.

#define SSA_FULLMEASURE      0x04000000  // Internal - calculate full width and out the number of chars can fit in iReqWidth.
#define SSA_LPKANSIFALLBACK  0x08000000  // Internal - enable FallBack for all LPK Ansi calls Except BiDi hDC calls
#define SSA_PIDX             0x10000000  // Internal
#define SSA_LAYOUTRTL        0x20000000  // Internal - Used when DC is mirrored
#define SSA_DONTGLYPH        0x40000000  // Internal - Used only by GDI during metafiling - Use ExtTextOutA for positioning
#define SSA_NOKASHIDA        0x80000000  // Internal - Used by GCP to justify the non Arabic glyphs only.
//
//
//p     SSA_HOTKEY: Note that SSA_HOTKEY and SSA_HIDEHOTKEY remove the
//          hotkey '&' character from further processing, so functions
//          such as ScriptString_pLogAttr return arrays based on a string
//          which excludes the '&'.




/////   SCRIPT_TABDEF
//
//      Defines tabstop positions for ScriptStringAnalyse (ignored unless SSA_TAB passed)
//
typedef struct tag_SCRIPT_TABDEF {
    int   cTabStops;        // Number of entries in pTabStops array
    int   iScale;           // Scale factor for pTabStops (see below)
    int  *pTabStops;        // Pointer to array of one or more tab stops
    int   iTabOrigin;       // Initial offset for tab stops (logical units)
} SCRIPT_TABDEF;
//
//
//p     cTabStops: Number of entries in the pTabStops array. If zero, tabstops
//          are every 8 average character widths. If one, all tabstops are
//          the length of the first entry in pTabStops. If more than one,
//          the first cTabStops are as specified in the pTabStops array,
//          subsequent tabstops are every 8 average characters from the last
//          tabstop in the array.
//
//p     iScale: Scale factor for iTabOrigin and pTabStops entries. Values are
//          converted to device coordinates by multiplying by iScale then
//          dividing by 4. If values are already in device units, set iScale to
//          4. If values are in dialog units, set iScale to the average char
//          width of the dialog font. If values are multiples of the average
//          character width for the selected font, set iScale to 0.
//
//p     pTabStops: Array of cTabStops entries. Each entry specifies a
//          tabstop position. Positive values give nearedge alignment,
//          negative values give faredge alignment.
//
//p     iTabOrigin: Tabs are considered to start iTabOrigin before the
//          beginning of the string. Helps with multiple tabbed
//          outputs on the same line.






/////   ScriptStringAnalyse
//
//      cString - Input string must contain at least one character
//
//      hdc - required if SSA_GLYPH requested. Optional for SSA_BREAK.
//      If present the current font in the hdc is inspected and if a symbolic
//      font the character string is treated as a single neutral SCRIPT_UNDEFINED item.
//
//      Note that the uBidiLevel field in the initial SCRIPT_STATE value
//      is ignored - the uBidiLevel used is derived from the SSA_RTL
//      flag in combination with the layout of the hdc.


typedef void* SCRIPT_STRING_ANALYSIS;


__checkReturn HRESULT WINAPI ScriptStringAnalyse(
    HDC                                             hdc,        //In  Device context (required)
    const void                                      *pString,   //In  String in 8 or 16 bit characters
    int                                             cString,    //In  Length in characters (Must be at least 1)
    int                                             cGlyphs,    //In  Required glyph buffer size (default cString*1.5 + 16)
    int                                             iCharset,   //In  Charset if an ANSI string, -1 for a Unicode string
    DWORD                                           dwFlags,    //In  Analysis required
    int                                             iReqWidth,  //In  Required width for fit and/or clip
    __in_ecount_opt(1) SCRIPT_CONTROL               *psControl, //In  Analysis control (optional)
    __in_ecount_opt(1) SCRIPT_STATE                 *psState,   //In  Analysis initial state (optional)
    __in_ecount_opt(cString) const int              *piDx,      //In  Requested logical dx array
    __in_ecount_opt(1) SCRIPT_TABDEF                *pTabdef,   //In  Tab positions (optional)
    const BYTE                                      *pbInClass, //In  Legacy GetCharacterPlacement character classifications (deprecated)
    __deref_out_ecount(1) SCRIPT_STRING_ANALYSIS    *pssa);     //Out Analysis of string






/////   ScriptStringFree - free a string analysis
//
//


__checkReturn HRESULT WINAPI ScriptStringFree(
    __deref_inout_ecount(1) SCRIPT_STRING_ANALYSIS  *pssa);  //InOut Address of pointer to analysis






/////   ScriptStringSize
//
//      returns a pointer to the size (width and height) of an analysed string
//
//      Note that the SIZE pointer remains valid only until the
//      SCRIPT_STRING_ANALYSIS is passed to ScriptStringFree.


const SIZE* WINAPI ScriptString_pSize(
    __in_ecount(1) SCRIPT_STRING_ANALYSIS   ssa); 






/////   ScriptString_pcOutChars
//
//      returns pointer to length of string after clipping (requires SSA_CLIP set)
//
//      Note that the int pointer remains valid only until the
//      SCRIPT_STRING_ANALYSIS is passed to ScriptStringFree.


const int* WINAPI ScriptString_pcOutChars(
    __in_ecount(1) SCRIPT_STRING_ANALYSIS   ssa); 






/////   ScriptString_pLogAttr
//
//      returns pointer to logical attributes buffer in a SCRIPT_STRING_ANALYSIS
//
//      Note that the buffer pointer remains valid only until the
//      SCRIPT_STRING_ANALYSIS is passed to ScriptStringFree.
//
//      The logical attribute array contains *ScriptString_pcOutChars(ssa)
//      entries.


const SCRIPT_LOGATTR* WINAPI ScriptString_pLogAttr(
    __in_ecount(1) SCRIPT_STRING_ANALYSIS   ssa); 






/////   ScriptStringGetOrder
//
//      Creates an array mapping original character position to glyph position.
//
//      Treats clusters as they were in legacy systems - Unless a cluster
//      contains more glyphs than codepoints, each glyph is referenced at
//      least once from the puOrder array.
//
//      Requires SSA_GLYPHS requested in original ScriptStringAnalyse call.
//
//      The puOrder parameter should address a buffer containing room for
//      at least *ScriptString_pcOutChars(ssa) ints.


__checkReturn HRESULT WINAPI ScriptStringGetOrder(
    __in_ecount(1) SCRIPT_STRING_ANALYSIS   ssa,
    UINT                                    *puOrder); 






/////   ScriptStringCPtoX
//
//      Return x coordinate for leading or trailing edge of character icp.


__checkReturn HRESULT WINAPI ScriptStringCPtoX(
    __in_ecount(1) SCRIPT_STRING_ANALYSIS   ssa,        //In  String analysis
    int                                     icp,        //In  Caret character position
    BOOL                                    fTrailing,  //In  Which edge of icp
    __out_ecount(1) int                     *pX);       //Out Corresponding x offset






/////   ScriptStringXtoCP
//
//


__checkReturn HRESULT WINAPI ScriptStringXtoCP(
    __in_ecount(1) SCRIPT_STRING_ANALYSIS   ssa,            // In
    int                                     iX,             // In
    __out_ecount(1) int                     *piCh,          // Out
    __out_ecount(1) int                     *piTrailing);   // Out






/////   ScriptStringGetLogicalWidths
//
//      Converts visual withs in psa->piAdvance into logical widths,
//      one per original character, in logical order.
//
//      Requires SSA_GLYPHS requested in original ScriptStringAnalyse call.
//
//      The piDx parameter should address a buffer containing room for
//      at least *ScriptString_pcOutChars(ssa) ints.


__checkReturn HRESULT WINAPI ScriptStringGetLogicalWidths(
    __in_ecount(1) SCRIPT_STRING_ANALYSIS   ssa,
    int                                     *piDx); 






/////   ScriptStringValidate
//
//      Scans the string analysis for invalid glyphs.
//
//      Only glyphs generated by scripts that can generate invalid glyphs
//      are scanned.
//
//      returns S_OK    - no invalid glyphs are present
//              S_FALSE - one or more invalid glyphs are present


__checkReturn HRESULT WINAPI ScriptStringValidate(
    __in_ecount(1) SCRIPT_STRING_ANALYSIS   ssa); 






/////   ScriptStringOut
//
//      Displays the string generated by a prior ScriptStringAnalyze call,
//      then optionally adds highlighting corresponding to a logical selection.
//
//      Requires SSA_GLYPHS requested in original ScriptStringAnalyse call.


__checkReturn HRESULT WINAPI ScriptStringOut(
    __in_ecount(1) SCRIPT_STRING_ANALYSIS   ssa,            //In  Analysis with glyphs
    int                                     iX,             //In
    int                                     iY,             //In
    UINT                                    uOptions,       //In  ExtTextOut options
    __in_ecount_opt(1) const RECT           *prc,           //In  Clipping rectangle (iff ETO_CLIPPED)
    int                                     iMinSel,        //In  Logical selection. Set iMinSel>=iMaxSel for no selection
    int                                     iMaxSel,        //In
    BOOL                                    fDisabled);     //In  If disabled, only the background is highlighted.






/////
//      uOptions may nclude only ETO_CLIPPED or ETO_OPAQUE.
/////   ScriptIsComplex
//
//      Determines whether a Unicode string requires complex script processing
//
//      The dwFlags parameter may include the following requests
//
#define SIC_COMPLEX     1   // Treat complex script letters as complex
#define SIC_ASCIIDIGIT  2   // Treat digits U+0030 through U+0039 as complex
#define SIC_NEUTRAL     4   // Treat neutrals as complex
//
//      SIC_COMPLEX: Should normally set. Causes complex script letters to
//      be treated as complex.
//
//      SIC_ASCIIDIGIT: Set this flag if the string would be displayed with
//      digit substitution enabled. If you are following the users NLS
//      settings using the ScriptRecordDigitSubstitution API, you can pass
//      scriptDigitSubstitute.DigitSubstitute != SCRIPT_DIGITSUBSTITUTE_NONE.
//
//      SIC_NEUTRAL: Set this flag if you may be displaying the string with
//      right-to-left reading order. When this flag is set, neutral characters
//      are considered as complex.
//
//
//      Returns S_OK     if string requires complex script processing,
//              S_FALSE  if string contains only characters laid out side by
//                       side from left to right.


__checkReturn HRESULT WINAPI ScriptIsComplex(
    __in_ecount(cInChars) const WCHAR   *pwcInChars,    //In  String to be tested
    int                                 cInChars,       //In  Length in characters
    DWORD                               dwFlags);       //In  Flags (see above)






/////   ScriptRecordDigitSubstitution
//
//      Reads NLS native digit and digit substitution settings and records
//      them in the SCRIPT_DIGITSUBSTITUTE structure.
//
//
typedef struct tag_SCRIPT_DIGITSUBSTITUTE {
    DWORD  NationalDigitLanguage    :16;   // Language for native substitution
    DWORD  TraditionalDigitLanguage :16;   // Language for traditional substitution
    DWORD  DigitSubstitute          :8;    // Substitution type
    DWORD  dwReserved;                     // Reserved
} SCRIPT_DIGITSUBSTITUTE;
//
//
//p     NationalDigitLanguage: Standard digits for the selected locale as
//          defined by the countries standard setting authority.
//
//p     TraditionalDigitLangauge: Digits originally used with the locales
//          script.
//
//p     DigitSubstitute: Selects between None, Context, National and
//          Traditional. See ScriptApplyDigitSubstitution below for
//          constant definitions.
//
//      Although most complex scripts have their own associated digits, many
//      countries using those scripts use western (so called
//      'Arabic') digits as their standard. NationalDigitLanguage reflects the
//      digits used as standard, and is set from
//      the NLS data for the locale.
//      On Windows 2000 the national digit langauge can be
//      adjusted to any digit script with the control panel/regional
//      options/numbers/Standard digits listbox.
//
//      The TraditionalDigitLanguage for a locale is derived directly from the
//      script used by that locale.


__checkReturn HRESULT WINAPI ScriptRecordDigitSubstitution(
    LCID                                    Locale,     // In   LOCALE_USER_DEFAULT or desired locale
    __out_ecount(1) SCRIPT_DIGITSUBSTITUTE  *psds);     // Out  Digit substitution settings






/////
//p     Locale: NLS locale to be queried. Should usually be set to
//          LOCALE_USER_DEFAULT. Alternatively may be passed as a locale
//          combined with LOCALE_NOUSEROVERRIDE to obtain default settings
//          for a given locale. Note that context digit substitution is
//          supported only in ARABIC and FARSI locales. In other locales,
//          context digit is mapped to no substitution.
//
//p     psds: Pointer to SCRIPT_DIGITSUBSTITUTE. This structure may be passed
//          later to ScriptApplyDigitSubstitution.
//
//p     returns: E_INVALIDARG if Locale is invalid or not installed. E_POINTER
//          if psds is NULL. Otherwise S_OK.
//
//      For performance reasons, you should not call
//      ScriptRecordDigitSubstitution frequently. In particular it would be a
//      considerable overhead to call it every time you call ScriptItemize
//      or ScriptStringAnalyse.
//
//      Instead, you may choose to save the SCRIPT_DIGITSUBSTITUTE
//      structure, and update it only when you receive a
//      WM_SETTINGCHANGE message or when a RegNotifyChangeKeyValue
//      call in a dedicated thread indicates a change in the registry
//      under HKCU\Control Panel\\International.
//
//      The normal way to call this function is simply
//
//c     SCRIPT_DIGITSUBSTITUTE sds;
//c     ScriptRecordDigitSubstitution(LOCALE_USER_DEFAULT, &sds);
//
//      Then every time you itemize, you'd use the results like this:
//
//c     SCRIPT_CONTROL  sc = {0};
//c     SCRIPT_STATE    ss = {0};
//
//c     ScriptApplyDigitSubstitution(&sds, &sc, &ss);
//
//
/////   ScriptApplyDigitSubstitution
//
//      Aplies the digit substitution settings recorded in a
//      SCRIPT_DIGIT_SUBSTITUTE structure to the SCRIPT_CONTROL and
//      SCRIPT_STATE structures.
//
//      The DigitSubstitute field of the SCRIPT_DIGITSUBSTITUTE structure
//      is normally set by ScriptRecordDigitSubstitution, however it may
//      be replaced by any one of the following values:
//
//
#define SCRIPT_DIGITSUBSTITUTE_CONTEXT      0  // Substitute to match preceeding letters
#define SCRIPT_DIGITSUBSTITUTE_NONE         1  // No substitution
#define SCRIPT_DIGITSUBSTITUTE_NATIONAL     2  // Substitute with official national digits
#define SCRIPT_DIGITSUBSTITUTE_TRADITIONAL  3  // Substitute with traditional digits of the locale
//
//
//p     SCRIPT_DIGITSUBSTITUTE_CONTEXT: Digits U+0030 - U+0039 will be
//          substituted according to the language of prior letters. Before
//          any letters, digits will be substituted according to the
//          TraditionalDigitLangauge field of the SCRIPT_DIGIT_SUBSTITUTE
//          structure. This field is normally set to the primary language of
//          the Locale passed to ScriptRecordDigitSubstitution.
//
//p     SCRIPT_DIGITSUBSTITUTE_NONE: Digits will not be substituted. Unicode
//          values U+0030 to U+0039 will be displayed with Arabic (i.e.
//          Western) numerals.
//
//p     SCRIPT_DIGITSUBSTITUTE_NATIONAL: Digits U+0030 - U+0039 will be
//          substituted according to the NationalDigitLangauge field of
//          the SCRIPT_DIGIT_SUBSTITUTE structure. This field is normally
//          set to the national digits returned for the NLS LCTYPE
//          LOCALE_SNATIVEDIGITS by ScriptRecordDigitSubstitution.
//
//p     SCRIPT_DIGITSUBSTITUTE_TRADITIONAL: Digits U+0030 - U+0039 will be
//          substituted according to the TraditionalDigitLangauge field of
//          the SCRIPT_DIGIT_SUBSTITUTE structure. This field is normally
//          set to the primary language of the Locale passed to
//          ScriptRecordDigitSubstitution.


__checkReturn HRESULT WINAPI ScriptApplyDigitSubstitution(
    __in_ecount(1) const SCRIPT_DIGITSUBSTITUTE *psds,  // In   Digit substitution settings
    __out_ecount(1) SCRIPT_CONTROL              *psc,   // Out  Script control structure
    __out_ecount(1) SCRIPT_STATE                *pss);  // Out  Script state structure






/////
//p     psds: Pointer to SCRIPT_DIGITSUBSTITUTE structure recorded earlier.
//          If NULL, ScriptApplyDigitSubstitution calls
//          ScriptRecordDigitSubstitution with LOCALE_USER_DEFAULT.
//
//p     psc: SCRIPT_CONTROL structure. The fContextDigits and uDefaultLanguage
//          fields will be updated.
//
//p     pss: SCRIPT_CONTROL structure. The fDigitSubstitute field will be
//          updated.
//
//p     returns: E_INVALIDARG if the DigitSubstitute field of the
//          SCRIPT_DIGITSUBSTITUTE structure is unrecognised, else S_OK;



//******************************************************
//
//          OpenType enabled Uniscribe APIs
//
//******************************************************

#ifndef UNISCRIBE_OPENTYPE
#if (_WIN32_WINNT >= 0x0600)
#define UNISCRIBE_OPENTYPE 0x0100
#endif
#endif

#if (UNISCRIBE_OPENTYPE >= 0x0100)

// 4-byte OpenType tag used to identify Script, LangSys or Feature
typedef ULONG OPENTYPE_TAG;

// Undefined script tag.
#define SCRIPT_TAG_UNKNOWN   0x00000000

// Single OpenType feature
typedef struct opentype_feature_record{

    OPENTYPE_TAG    tagFeature;     // Feature tag
    LONG            lParameter;     // Feature parameter (0 - disabled)

} OPENTYPE_FEATURE_RECORD;

// Set of OpenType properties applied to the range of characters
typedef struct textrange_properties{

    OPENTYPE_FEATURE_RECORD   *potfRecords;
    int                        cotfRecords;

} TEXTRANGE_PROPERTIES;

//
// Character properties
//
// Used by shaping engines to pass shaping information between calls
//
typedef struct script_charprop{

    WORD           fCanGlyphAlone : 1;

    WORD           reserved       : 15; // Reserved

} SCRIPT_CHARPROP;

//
// Glyph properties
//
typedef struct script_glyphprop{

    SCRIPT_VISATTR sva;
    WORD           reserved; // Reserved

} SCRIPT_GLYPHPROP;

// 
// ScriptShapeOpenType
// 
// New parameters comparing to ScriptShape:
//
// tagScript            - script tag to be used by OpenType layout
// tagLangSys           - language system tag to be used by OpenType layout
// rcRangeChars         - Number of characters in each range
//                                          (total should be equal to cChars)
//
// rpRangeProperties     - Range properties for each range
//
// cRanges              - Number of ranges
//
//
// New output parameters:
//
// pCharProps           - array of character properties, generated by Uniscribe
//
// pGlyphProps          - array of glyph properties, replaces visual attributes (4 bytes now)
// pfCanGlyphAlone      - flag per character, indicate that char can be shaped independently 
//
__checkReturn HRESULT WINAPI ScriptShapeOpenType(
    __in_opt                   HDC                     hdc,            // In    Optional (see under caching)
    __inout                    SCRIPT_CACHE           *psc,            // InOut Cache handle
    __inout                    SCRIPT_ANALYSIS        *psa,            // InOut Result of ScriptItemize (may have fNoGlyphIndex set)

    __in                       OPENTYPE_TAG            tagScript,      // In    Font script tag for shaping
    __in                       OPENTYPE_TAG            tagLangSys,     // In    Font language system tag for shaping
    __in_ecount_opt(cRanges)   int                    *rcRangeChars,      // In    Array of number of characters per range
    __in_ecount_opt(cRanges)   TEXTRANGE_PROPERTIES  **rpRangeProperties, // In    Array of range properties (for each range)
    __in                       int                     cRanges,           // In    Number of ranges

    __in_ecount(cChars)        const WCHAR            *pwcChars,       // In    Logical unicode run
    __in                       int                     cChars,         // In    Length of unicode run
    __in                       int                     cMaxGlyphs,     // In    Max glyphs to generate

    __out_ecount_full(cChars)  WORD                   *pwLogClust,     // Out   Logical clusters
    __out_ecount_full(cChars)  SCRIPT_CHARPROP        *pCharProps,     // Out   Output buffer for character properties
    
    __out_ecount_part(cMaxGlyphs, *pcGlyphs) WORD                   *pwOutGlyphs,    // Out   Output glyph buffer
    __out_ecount_part(cMaxGlyphs, *pcGlyphs) SCRIPT_GLYPHPROP       *pOutGlyphProps, // Out   Visual glyph attributes
    __out                                    int                    *pcGlyphs);      // Out   Count of glyphs generated

// 
// ScriptPlaceOpenType
// 
// New parameters comparing to ScriptPlace:
//
// tagScript            - script tag to be used by OpenType layout
// tagLangSys           - language system tag to be used by OpenType layout
// rcRangeChars         - Number of characters in each range
//                                          (total should be equal to cChars)
//
// rpRangeProperties    - Range properties for each range
//
// cRanges              - Number of ranges
//
//
// New output parameters:
//
// Character information - pwcChars, pwLogClust, pCharProps are now passed to ScriptPlace
// pGlyphProps           - array of glyph properties, replaces visual attributes (4 bytes now)
//
__checkReturn HRESULT WINAPI ScriptPlaceOpenType(
    __in_opt                   HDC                     hdc,            // In    Optional (see under caching)
    __inout                    SCRIPT_CACHE           *psc,            // InOut Cache handle
    __inout                    SCRIPT_ANALYSIS        *psa,            // InOut Result of ScriptItemize (may have fNoGlyphIndex set)

    __in                       OPENTYPE_TAG            tagScript,      // In    Font script tag for shaping
    __in                       OPENTYPE_TAG            tagLangSys,     // In    Font language system tag for shaping
    __in_ecount_opt(cRanges)   int                    *rcRangeChars,      // In    Array of number of characters per range
    __in_ecount_opt(cRanges)   TEXTRANGE_PROPERTIES  **rpRangeProperties, // In    Array of range properties (for each range)
    __in                       int                     cRanges,           // In    Number of ranges

    __in_ecount(cChars)        const WCHAR            *pwcChars,       // In    Logical unicode run
    __in_ecount(cChars)        WORD                   *pwLogClust,     // In    Logical clusters
    __in_ecount(cChars)        SCRIPT_CHARPROP        *pCharProps,     // In    Output buffer for character properties
    __in                       int                     cChars,         // In    Length of unicode run
    
    __in_ecount(cGlyphs)       const WORD             *pwGlyphs,       // In    Glyph buffer from prior ScriptShape call
    __in_ecount(cGlyphs)       const SCRIPT_GLYPHPROP *pGlyphProps,    // In    Glyph properties
    __in                       int                     cGlyphs,        // In    Number of glyphs
    
    __out_ecount_full(cGlyphs) int                    *piAdvance,      // Out   Advance widths
    __out_ecount_full(cGlyphs) GOFFSET                *pGoffset,       // Out   x,y offset for combining glyph
    __out_opt                  ABC                    *pABC);          // Out   Composite ABC for the whole run (Optional)

//
// ScriptItemizeOpenType
//
// New parameter comapring to ScriptItemize:
//
// pScriptTags -- array parallel to items, contains script tags
//                                              to be passed to ScriptShapeOpenType.
//
__checkReturn HRESULT WINAPI ScriptItemizeOpenType(
    __in_ecount(cInChars) const WCHAR                   *pwcInChars,    // In   Unicode string to be itemized
    __in                  int                            cInChars,      // In   Codepoint count to itemize
    __in                  int                            cMaxItems,     // In   Max length of itemization array
    __in_opt              const SCRIPT_CONTROL          *psControl,     // In   Analysis control (optional)
    __in_opt              const SCRIPT_STATE            *psState,       // In   Initial bidi algorithm state (optional)
    __out_ecount_part(cMaxItems, *pcItems) SCRIPT_ITEM  *pItems,        // Out  Array to receive itemization
    __out_ecount_part(cMaxItems, *pcItems) OPENTYPE_TAG *pScriptTags,   // Out  Array of script tags - parallel to items
    __out                 int                           *pcItems);      // Out  Count of items processed (optional)


// ScriptGetFontScriptList
// 
// Returns list of script tags supported by layout tables. 
// Only scripts that can be shaped by eScript will be returned ( or full list if psa==NULL).
// Usually complex scripts return single tag and neutral (like digits) return all tags from the font
//
// Note: If tag coresponding to some script is present it does not guarantee
//       that font won't be rejected by particular shaping engine because 
//       shaping engine may require particular language system or feature
//       to be present.
//
__checkReturn HRESULT WINAPI ScriptGetFontScriptTags(
    __in_opt           HDC                              hdc,             // In    Optional (see under caching)
    __inout            SCRIPT_CACHE                    *psc,             // InOut Cache handle
    __in_opt           SCRIPT_ANALYSIS                 *psa,             // In    Result of ScriptItemize (can be NULL)
    __in               int                              cMaxTags,        // In    Length of pScriptTags array
    __out_ecount_part(cMaxTags, *pcTags) OPENTYPE_TAG  *pScriptTags,     // Out:  list of script tags in the font
    __out              int                             *pcTags           // Out:  Number of tags returned
);

//
// ScriptGetFontLanguageTags
// 
// Returns list of language system tags supported by layout tables for particular script.
//
__checkReturn HRESULT WINAPI ScriptGetFontLanguageTags(
    __in_opt           HDC                    hdc,             // In    Optional (see under caching)
    __inout            SCRIPT_CACHE          *psc,             // InOut Cache handle
    __in_opt           SCRIPT_ANALYSIS       *psa,             // In    Result of ScriptItemize  (can be NULL)
    __in               OPENTYPE_TAG           tagScript,       // In    Font script tag
    
    __in               int                    cMaxTags,        // In    Length of pLangsys tags array
    __out_ecount_part(cMaxTags, *pcTags) OPENTYPE_TAG *pLangsysTags,    // Out:  list of Langsys tags in the font
    __out              int                   *pcTags           // Out:  Number of tags returned
);

//
// ScriptGetFontFeatureTags
// 
// Returns list of feature tags supported by layout tables for particular language system.
//
// This method will hide features that are language specific, because they are 
// controlled by shaping engines and can not be switched on or off by the client.
// Example of such features are initial, medial and final forms for Arabic script
//
// If psa==NULL function returns unfiltered feature list
//
__checkReturn HRESULT WINAPI ScriptGetFontFeatureTags(
    __in_opt           HDC                    hdc,             // In    Optional (see under caching)
    __inout            SCRIPT_CACHE          *psc,             // InOut Cache handle
    __in_opt           SCRIPT_ANALYSIS       *psa,             // In    Result of ScriptItemize  (can be NULL)
    __in               OPENTYPE_TAG           tagScript,       // In    Font script tag
    __in               OPENTYPE_TAG           tagLangSys,      // In    Font language system tag for shaping
    
    __in               int                    cMaxTags,        // In    Length of pLangsys tags array
    __out_ecount_part(cMaxTags, *pcTags) OPENTYPE_TAG *pFeatureTags,   // Out:  list of feature tags in the font
    __out              int                   *pcTags           // Out:  Number of tags returned
);

//
//  ScriptGetFontAlternateGlyphs
// 
//  Returns list alternates for particular glyph. 
//
//  Original glyph is always added as a first element. Index in this array 
//  is exactly the feature parameter that should be passed to ScriptShape.
//
//  To get variants it is a good idea to reshape input without feature 
//  applied to current glyph so it will be always alternates for default 
//  glyph for this position. Original glyph could have variants, while 
//  variants may not. So UI will stick with this final form wihtout ability 
//  to choose another one.
//
//  Note: It theoretically can be emulated by ScriptSubstituteSingleGlyph. 
//        Just try parameters one by one while glyphs are substituted.
//
__checkReturn HRESULT WINAPI ScriptGetFontAlternateGlyphs(
    __in_opt           HDC                    hdc,             // In    Optional (see under caching)
    __inout            SCRIPT_CACHE          *psc,             // InOut Cache handle
    __in_opt           SCRIPT_ANALYSIS       *psa,             // In    Result of ScriptItemize  (can be NULL)
    __in               OPENTYPE_TAG           tagScript,       // In    Font script tag
    __in               OPENTYPE_TAG           tagLangSys,      // In    Font language system tag for shaping
    __in               OPENTYPE_TAG           tagFeature,      // In    Feature tag to test for alternates
    
    __in               WORD                   wGlyphId,        // In    Original glyph
    
    __in               int                    cMaxAlternates,  // In    Length of pAlternateGlyphs tags array
    __out_ecount_part(cMaxAlternates, *pcAlternates) WORD *pAlternateGlyphs, // Out:  list of feature tags in the font
    __out              int                   *pcAlternates     // Out:  Number of alternates returned
);

//
//  ScriptSubstituteSingleGlyph
//
//  Apply partcular feature to single glyph, assuming that 
//  expected result is one-to-one substitution
//
__checkReturn HRESULT WINAPI ScriptSubstituteSingleGlyph(
    __in_opt           HDC                    hdc,             // In    Optional (see under caching)
    __inout            SCRIPT_CACHE          *psc,             // InOut Cache handle
    __in_opt           SCRIPT_ANALYSIS       *psa,             // In    Result of ScriptItemize  (can be NULL)
    __in               OPENTYPE_TAG           tagScript,       // In    Font script tag
    __in               OPENTYPE_TAG           tagLangSys,      // In    Font language system tag for shaping
    __in               OPENTYPE_TAG           tagFeature,      // In    Feature tag to test for alternates
    __in               LONG                   lParameter,      // In    Feature parameter

    __in               WORD                   wGlyphId,         // In    Original glyph id
    __out              WORD                  *pwOutGlyphId      // Out   Substituted glyph id
);

//
//  ScriptPositionSingleGlyph
//
//  Apply particular feature to single glyph, assuming that 
//  expected result is single position adjustment.
//
__checkReturn HRESULT WINAPI ScriptPositionSingleGlyph(
    __in_opt           HDC                    hdc,             // In    Optional (see under caching)
    __inout            SCRIPT_CACHE          *psc,             // InOut Cache handle
    __in_opt           SCRIPT_ANALYSIS       *psa,             // In    Result of ScriptItemize  (can be NULL)
    __in               OPENTYPE_TAG           tagScript,       // In    Font script tag
    __in               OPENTYPE_TAG           tagLangSys,      // In    Font language system tag for shaping
    __in               OPENTYPE_TAG           tagFeature,      // In    Feature tag to test for alternates
    __in               LONG                   lParameter,      // In    Feature parameter

    __in               WORD                   wGlyphId,         // In    Glyph id to be moved
    __in               int                    iAdvance,         // In    Original glyph advance width
    __in               GOFFSET                GOffset,          // In    Original glyph offset
    
    __out              int                   *piOutAdvance,     // Out   Adjusted advance width
    __out              GOFFSET               *pOutGoffset       // Out   Adjusted offset
);

#endif // (UNISCRIBE_OPENTYPE >= 0x0100)

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Uxtheme.h ===
//---------------------------------------------------------------------------
//
// uxtheme.h - theming API header file.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
//---------------------------------------------------------------------------

#ifndef _UXTHEME_H_
#define _UXTHEME_H_

#include <commctrl.h>
#include <SpecStrings.h>

#ifndef THEMEAPI
#if !defined(_UXTHEME_)
#define THEMEAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define THEMEAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#else
#define THEMEAPI          STDAPI
#define THEMEAPI_(type)   STDAPI_(type)
#endif /* _UXTHEME_ */
#endif /* THEMEAPI */

typedef HANDLE HTHEME;          // handle to a section of theme data for class

#if (_WIN32_WINNT >= 0x0600)
#define MAX_THEMECOLOR  64
#define MAX_THEMESIZE   64
#endif

#if (NTDDI_VERSION>= NTDDI_WIN7)
//---------------------------------------------------------------------------
// BeginPanningFeedback - Visual feedback init function related to pan gesture
//   - internally called by DefaultGestureHandler
//   - called by application
//
//  HWND hwnd - The handle to the Target window that will receive feedback
//                                                                                                 
//---------------------------------------------------------------------------
BOOL WINAPI 
BeginPanningFeedback(
__in HWND hwnd); 
//---------------------------------------------------------------------------
// UpdatePanningFeedback : Visual feedback function related to pan gesture
// Can Be called only after a BeginPanningFeedback call 
//   - internally called by DefaultGestureHandler
//   - called by application
//
// HWND hwnd                 - The handle to the Target window that will receive feedback                                                
//                             For the method to succeed this must be the same hwnd as provided in 
//                             BeginPanningFeedback
//  
// LONG lTotalOverpanOffsetX - The Total displacement that the window has moved in the horizontal direction
//                             since the end of scrollable region was reached. The API would move the window by the distance specified                                                  
//                             A maximum displacement of 30 pixels is allowed
//
// LONG lTotalOverpanOffsetY - The Total displacement that the window has moved in the horizontal direction
//                             since the end of scrollable
//                             region was reached. The API would move the window by the distance specified                                                
//                             A maximum displacement of 30 pixels is allowed
//           
// BOOL fInInertia           - Flag dictating whether the Application is handling a WM_GESTURE message with the 
//                             GF_INERTIA FLAG set 
//
//   Incremental calls to UpdatePanningFeedback should make sure they always pass
//   the sum of the increments and not just the increment themselves
//   Eg : If the initial displacement is 10 pixels and the next displacement 10 pixels
//        the second call would be with the parameter as 20 pixels as opposed to 10
//   Eg : UpdatePanningFeedback(hwnd, 10, 10, TRUE)
// 
BOOL WINAPI
UpdatePanningFeedback(
	__in HWND hwnd,
	__in LONG lTotalOverpanOffsetX, 
	__in LONG lTotalOverpanOffsetY, 
	__in BOOL fInInertia);

//---------------------------------------------------------------------------
//
// EndPanningFeedback :Visual feedback reset function related to pan gesture
//   - internally called by DefaultGestureHandler
//   - called by application
//   Terminates any existing animation that was in process or set up by BeginPanningFeedback and UpdatePanningFeedback
//   The EndPanningFeedBack needs to be called Prior to calling any BeginPanningFeedBack if we have already
//   called a BeginPanningFeedBack followed by one/ more UpdatePanningFeedback calls
//
//  HWND hwnd         - The handle to the Target window that will receive feedback
//
//  BOOL fAnimateBack - Flag to indicate whether you wish the displaced window to move back
//                      to the original position via animation or a direct jump.
//                      Either ways the method will try to restore the moved window.
//                      The latter case exists for compatibility with legacy apps. 
//
BOOL WINAPI
EndPanningFeedback(
	__in HWND hwnd, 
	__in BOOL fAnimateBack);
#endif

//---------------------------------------------------------------------------
// NOTE: PartId's and StateId's used in the theme API are defined in the 
//       hdr file <vssym32.h> using the TM_PART and TM_STATE macros.  For
//       example, "TM_PART(BP, PUSHBUTTON)" defines the PartId "BP_PUSHBUTTON".

//---------------------------------------------------------------------------
//  OpenThemeData()     - Open the theme data for the specified HWND and 
//                        semi-colon separated list of class names. 
// 
//                        OpenThemeData() will try each class name, one at 
//                        a time, and use the first matching theme info
//                        found.  If a match is found, a theme handle
//                        to the data is returned.  If no match is found,
//                        a "NULL" handle is returned. 
//
//                        When the window is destroyed or a WM_THEMECHANGED
//                        msg is received, "CloseThemeData()" should be 
//                        called to close the theme handle.
//
//  hwnd                - window handle of the control/window to be themed
//
//  pszClassList        - class name (or list of names) to match to theme data
//                        section.  if the list contains more than one name, 
//                        the names are tested one at a time for a match.  
//                        If a match is found, OpenThemeData() returns a 
//                        theme handle associated with the matching class. 
//                        This param is a list (instead of just a single 
//                        class name) to provide the class an opportunity 
//                        to get the "best" match between the class and 
//                        the current theme.  For example, a button might
//                        pass L"OkButton, Button" if its ID=ID_OK.  If 
//                        the current theme has an entry for OkButton, 
//                        that will be used.  Otherwise, we fall back on 
//                        the normal Button entry.
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME)
OpenThemeData(
    HWND hwnd,
    LPCWSTR pszClassList
    );

#define OTD_FORCE_RECT_SIZING   0x00000001          // make all parts size to rect
#define OTD_NONCLIENT           0x00000002          // set if hTheme to be used for nonclient area
#define OTD_VALIDBITS           (OTD_FORCE_RECT_SIZING | \
                                 OTD_NONCLIENT)

//---------------------------------------------------------------------------
//  OpenThemeDataEx     - Open the theme data for the specified HWND and 
//                        semi-colon separated list of class names. 
// 
//                        OpenThemeData() will try each class name, one at 
//                        a time, and use the first matching theme info
//                        found.  If a match is found, a theme handle
//                        to the data is returned.  If no match is found,
//                        a "NULL" handle is returned. 
//
//                        When the window is destroyed or a WM_THEMECHANGED
//                        msg is received, "CloseThemeData()" should be 
//                        called to close the theme handle.
//
//  hwnd                - window handle of the control/window to be themed
//
//  pszClassList        - class name (or list of names) to match to theme data
//                        section.  if the list contains more than one name, 
//                        the names are tested one at a time for a match.  
//                        If a match is found, OpenThemeData() returns a 
//                        theme handle associated with the matching class. 
//                        This param is a list (instead of just a single 
//                        class name) to provide the class an opportunity 
//                        to get the "best" match between the class and 
//                        the current theme.  For example, a button might
//                        pass L"OkButton, Button" if its ID=ID_OK.  If 
//                        the current theme has an entry for OkButton, 
//                        that will be used.  Otherwise, we fall back on 
//                        the normal Button entry.
//
//  dwFlags              - allows certain overrides of std features
//                         (see OTD_XXX defines above)
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME)
OpenThemeDataEx(
    HWND hwnd,
    LPCWSTR pszClassList,
    DWORD dwFlags
    );

//---------------------------------------------------------------------------
//  CloseThemeData()    - closes the theme data handle.  This should be done 
//                        when the window being themed is destroyed or
//                        whenever a WM_THEMECHANGED msg is received 
//                        (followed by an attempt to create a new Theme data 
//                        handle).
//
//  hTheme              - open theme data handle (returned from prior call
//                        to OpenThemeData() API).
//---------------------------------------------------------------------------
THEMEAPI
CloseThemeData(
    HTHEME hTheme
    );

//---------------------------------------------------------------------------
//    functions for basic drawing support 
//---------------------------------------------------------------------------
// The following methods are the theme-aware drawing services.
// Controls/Windows are defined in drawable "parts" by their author: a 
// parent part and 0 or more child parts.  Each of the parts can be 
// described in "states" (ex: disabled, hot, pressed).  
//---------------------------------------------------------------------------
// For the list of all themed classes and the definition of all
// parts and states, see the file "tmschmea.h".
//---------------------------------------------------------------------------
// Each of the below methods takes a "iPartId" param to specify the 
// part and a "iStateId" to specify the state of the part.  
// "iStateId=0" refers to the root part.  "iPartId" = "0" refers to 
// the root class.  
//-----------------------------------------------------------------------
// Note: draw operations are always scaled to fit (and not to exceed)  
// the specified "Rect".
//-----------------------------------------------------------------------

//------------------------------------------------------------------------
//  DrawThemeBackground()   
//                      - draws the theme-specified border and fill for 
//                        the "iPartId" and "iStateId".  This could be 
//                        based on a bitmap file, a border and fill, or 
//                        other image description.  
//
//  hTheme              - theme data handle
//  hdc                 - HDC to draw into
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) to draw
//  pRect               - defines the size/location of the part
//  pClipRect           - optional clipping rect (don't draw outside it)
//------------------------------------------------------------------------
THEMEAPI
DrawThemeBackground(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    LPCRECT pRect,
    __in_opt LPCRECT pClipRect
    );

//------------------------------------------------------------------------
//---- bits used in dwFlags of DTBGOPTS ----
#define DTBG_CLIPRECT           0x00000001  // rcClip has been specified
#define DTBG_DRAWSOLID          0x00000002  // DEPRECATED: draw transparent/alpha images as solid
#define DTBG_OMITBORDER         0x00000004  // don't draw border of part
#define DTBG_OMITCONTENT        0x00000008  // don't draw content area of part
#define DTBG_COMPUTINGREGION    0x00000010  // TRUE if calling to compute region
#define DTBG_MIRRORDC           0x00000020  // assume the hdc is mirrorred and
                                            // flip images as appropriate (currently 
                                            // only supported for bgtype=imagefile)
#define DTBG_NOMIRROR           0x00000040  // don't mirror the output, overrides everything else 
#define DTBG_VALIDBITS          (DTBG_CLIPRECT | \
                                 DTBG_DRAWSOLID | \
                                 DTBG_OMITBORDER | \
                                 DTBG_OMITCONTENT | \
                                 DTBG_COMPUTINGREGION | \
                                 DTBG_MIRRORDC | \
                                 DTBG_NOMIRROR)

typedef struct _DTBGOPTS
{
    DWORD dwSize;           // size of the struct
    DWORD dwFlags;          // which options have been specified
    RECT rcClip;            // clipping rectangle
} DTBGOPTS, *PDTBGOPTS;

//------------------------------------------------------------------------
//  DrawThemeBackgroundEx()   
//                      - draws the theme-specified border and fill for 
//                        the "iPartId" and "iStateId".  This could be 
//                        based on a bitmap file, a border and fill, or 
//                        other image description.  NOTE: This will be
//                        merged back into DrawThemeBackground() after 
//                        BETA 2.
//
//  hTheme              - theme data handle
//  hdc                 - HDC to draw into
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) to draw
//  pRect               - defines the size/location of the part
//  pOptions            - ptr to optional params
//------------------------------------------------------------------------
THEMEAPI
DrawThemeBackgroundEx(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    LPCRECT pRect,
    __in_opt const DTBGOPTS *pOptions
    );

//---------------------------------------------------------------------------
//----- DrawThemeText() flags ----
#define DTT_GRAYED              0x00000001          // draw a grayed-out string (this is deprecated)
#define DTT_FLAGS2VALIDBITS     (DTT_GRAYED)

//-------------------------------------------------------------------------
//  DrawThemeText()     - draws the text using the theme-specified 
//                        color and font for the "iPartId" and 
//                        "iStateId".  
//
//  hTheme              - theme data handle
//  hdc                 - HDC to draw into
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) to draw
//  pszText             - actual text to draw
//  dwCharCount         - number of chars to draw (-1 for all)
//  dwTextFlags         - same as DrawText() "uFormat" param
//  dwTextFlags2        - additional drawing options 
//  pRect               - defines the size/location of the part
//-------------------------------------------------------------------------
THEMEAPI
DrawThemeText(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    __in_ecount(cchText) LPCWSTR pszText,
    int cchText,
    DWORD dwTextFlags,
    DWORD dwTextFlags2,
    LPCRECT pRect
    );

//-------------------------------------------------------------------------
//  GetThemeBackgroundContentRect()
//                      - gets the size of the content for the theme-defined 
//                        background.  This is usually the area inside
//                        the borders or Margins.  
//
//      hTheme          - theme data handle
//      hdc             - (optional) device content to be used for drawing
//      iPartId         - part number to draw
//      iStateId        - state number (of the part) to draw
//      pBoundingRect   - the outer RECT of the part being drawn
//      pContentRect    - RECT to receive the content area
//-------------------------------------------------------------------------
THEMEAPI
GetThemeBackgroundContentRect(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    LPCRECT pBoundingRect,
    __out LPRECT pContentRect
    );

//-------------------------------------------------------------------------
//  GetThemeBackgroundExtent() - calculates the size/location of the theme-
//                               specified background based on the 
//                               "pContentRect".
//
//      hTheme          - theme data handle
//      hdc             - (optional) device content to be used for drawing
//      iPartId         - part number to draw
//      iStateId        - state number (of the part) to draw
//      pContentRect    - RECT that defines the content area
//      pBoundingRect   - RECT to receive the overall size/location of part
//-------------------------------------------------------------------------
THEMEAPI
GetThemeBackgroundExtent(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    LPCRECT pContentRect,
    __out LPRECT pExtentRect
    );

//-------------------------------------------------------------------------
//  GetThemeBackgroundRegion()
//                      - computes the region for a regular or partially 
//                        transparent theme-specified background that is 
//                        bound by the specified "pRect".
//                        If the rectangle is empty, sets the HRGN to NULL 
//                        and return S_FALSE.
//
//  hTheme              - theme data handle
//  hdc                 - optional HDC to draw into (DPI scaling)
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) 
//  pRect               - the RECT used to draw the part
//  pRegion             - receives handle to calculated region
//-------------------------------------------------------------------------
THEMEAPI
GetThemeBackgroundRegion(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    LPCRECT pRect,
    __out HRGN *pRegion
    );

enum THEMESIZE
{
    TS_MIN,             // minimum size
    TS_TRUE,            // size without stretching
    TS_DRAW             // size that theme mgr will use to draw part
};

//-------------------------------------------------------------------------
//  GetThemePartSize() - returns the specified size of the theme part
//
//  hTheme              - theme data handle
//  hdc                 - HDC to select font into & measure against
//  iPartId             - part number to retrieve size for
//  iStateId            - state number (of the part) 
//  prc                 - (optional) rect for part drawing destination
//  eSize               - the type of size to be retreived
//  psz                 - receives the specified size of the part 
//-------------------------------------------------------------------------
THEMEAPI
GetThemePartSize(
    HTHEME hTheme,
    __in_opt HDC hdc,
    int iPartId,
    int iStateId,
    __in_opt LPCRECT prc,
    enum THEMESIZE eSize,
    __out SIZE *psz
    );

//-------------------------------------------------------------------------
//  GetThemeTextExtent() - calculates the size/location of the specified 
//                         text when rendered in the Theme Font. 
//
//  hTheme              - theme data handle
//  hdc                 - HDC to select font & measure into
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) 
//  pszText             - the text to be measured
//  dwCharCount         - number of chars to draw (-1 for all)
//  dwTextFlags         - same as DrawText() "uFormat" param
//  pszBoundingRect     - optional: to control layout of text
//  pszExtentRect       - receives the RECT for text size/location
//-------------------------------------------------------------------------
THEMEAPI
GetThemeTextExtent(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    __in_ecount(cchCharCount) LPCWSTR pszText,
    int cchCharCount,
    DWORD dwTextFlags,
    __in_opt LPCRECT pBoundingRect,
    __out LPRECT pExtentRect
    );

//-------------------------------------------------------------------------
//  GetThemeTextMetrics()
//                      - returns info about the theme-specified font
//                        for the part/state passed in.
//
//  hTheme              - theme data handle
//  hdc                 - optional: HDC for screen context
//  iPartId             - part number to draw
//  iStateId            - state number (of the part) 
//  ptm                 - receives the font info
//-------------------------------------------------------------------------
THEMEAPI
GetThemeTextMetrics(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    __out TEXTMETRICW *ptm
    );

//-------------------------------------------------------------------------
//----- HitTestThemeBackground, HitTestThemeBackgroundRegion flags ----

//  Theme background segment hit test flag (default). possible return values are:
//  HTCLIENT: hit test succeeded in the middle background segment
//  HTTOP, HTLEFT, HTTOPLEFT, etc:  // hit test succeeded in the the respective theme background segment.
#define HTTB_BACKGROUNDSEG          0x00000000
//  Fixed border hit test option.  possible return values are:
//  HTCLIENT: hit test succeeded in the middle background segment
//  HTBORDER: hit test succeeded in any other background segment
#define HTTB_FIXEDBORDER            0x00000002      // Return code may be either HTCLIENT or HTBORDER. 
//  Caption hit test option.  Possible return values are:
//  HTCAPTION: hit test succeeded in the top, top left, or top right background segments
//  HTNOWHERE or another return code, depending on absence or presence of accompanying flags, resp.
#define HTTB_CAPTION                0x00000004
//  Resizing border hit test flags.  Possible return values are:
//  HTCLIENT: hit test succeeded in middle background segment
//  HTTOP, HTTOPLEFT, HTLEFT, HTRIGHT, etc:    hit test succeeded in the respective system resizing zone
//  HTBORDER: hit test failed in middle segment and resizing zones, but succeeded in a background border segment
#define HTTB_RESIZINGBORDER_LEFT    0x00000010      // Hit test left resizing border, 
#define HTTB_RESIZINGBORDER_TOP     0x00000020      // Hit test top resizing border
#define HTTB_RESIZINGBORDER_RIGHT   0x00000040      // Hit test right resizing border
#define HTTB_RESIZINGBORDER_BOTTOM  0x00000080      // Hit test bottom resizing border
#define HTTB_RESIZINGBORDER         (HTTB_RESIZINGBORDER_LEFT | \
                                     HTTB_RESIZINGBORDER_TOP | \
                                     HTTB_RESIZINGBORDER_RIGHT | \
                                     HTTB_RESIZINGBORDER_BOTTOM)
// Resizing border is specified as a template, not just window edges.
// This option is mutually exclusive with HTTB_SYSTEMSIZINGWIDTH; HTTB_SIZINGTEMPLATE takes precedence  
#define HTTB_SIZINGTEMPLATE         0x00000100
// Use system resizing border width rather than theme content margins.   
// This option is mutually exclusive with HTTB_SIZINGTEMPLATE, which takes precedence.
#define HTTB_SYSTEMSIZINGMARGINS    0x00000200

//-------------------------------------------------------------------------
//  HitTestThemeBackground()
//                      - returns a HitTestCode (a subset of the values 
//                        returned by WM_NCHITTEST) for the point "ptTest" 
//                        within the theme-specified background
//                        (bound by pRect).  "pRect" and "ptTest" should 
//                        both be in the same coordinate system 
//                        (client, screen, etc).
//
//      hTheme          - theme data handle
//      hdc             - HDC to draw into
//      iPartId         - part number to test against
//      iStateId        - state number (of the part) 
//      pRect           - the RECT used to draw the part
//      hrgn            - optional region to use; must be in same coordinates as
//                      -    pRect and pTest.
//      ptTest          - the hit point to be tested
//      dwOptions       - HTTB_xxx constants
//      pwHitTestCode   - receives the returned hit test code - one of:
//  
//                        HTNOWHERE, HTLEFT, HTTOPLEFT, HTBOTTOMLEFT,
//                        HTRIGHT, HTTOPRIGHT, HTBOTTOMRIGHT,
//                        HTTOP, HTBOTTOM, HTCLIENT
//-------------------------------------------------------------------------
THEMEAPI
HitTestThemeBackground(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    DWORD dwOptions,
    LPCRECT pRect,
    HRGN hrgn,
    POINT ptTest,
    __out WORD *pwHitTestCode
    );

//------------------------------------------------------------------------
//  DrawThemeEdge()     - Similar to the DrawEdge() API, but uses part colors
//                        and is high-DPI aware
//  hTheme              - theme data handle
//  hdc                 - HDC to draw into
//  iPartId             - part number to draw
//  iStateId            - state number of part
//  pDestRect           - the RECT used to draw the line(s)
//  uEdge               - Same as DrawEdge() API
//  uFlags              - Same as DrawEdge() API
//  pContentRect        - Receives the interior rect if (uFlags & BF_ADJUST)
//------------------------------------------------------------------------
THEMEAPI
DrawThemeEdge(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    LPCRECT pDestRect,
    UINT uEdge,
    UINT uFlags,
    __out_opt LPRECT pContentRect
    );

//------------------------------------------------------------------------
//  DrawThemeIcon()     - draws an image within an imagelist based on 
//                        a (possible) theme-defined effect. 
//
//  hTheme              - theme data handle
//  hdc                 - HDC to draw into
//  iPartId             - part number to draw
//  iStateId            - state number of part
//  pRect               - the RECT to draw the image within
//  himl                - handle to IMAGELIST 
//  iImageIndex         - index into IMAGELIST (which icon to draw)
//------------------------------------------------------------------------
THEMEAPI
DrawThemeIcon(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    LPCRECT pRect,
    HIMAGELIST himl,
    int iImageIndex
    );

//---------------------------------------------------------------------------
//  IsThemePartDefined() - returns TRUE if the theme has defined parameters
//                         for the specified "iPartId" and "iStateId".
//
//  hTheme              - theme data handle
//  iPartId             - part number to find definition for
//  iStateId            - state number of part
//---------------------------------------------------------------------------
THEMEAPI_(BOOL)
IsThemePartDefined(
    HTHEME hTheme,
    int iPartId,
    int iStateId
    );

//---------------------------------------------------------------------------
//  IsThemeBackgroundPartiallyTransparent()
//                      - returns TRUE if the theme specified background for 
//                        the part/state has transparent pieces or 
//                        alpha-blended pieces.
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//---------------------------------------------------------------------------
THEMEAPI_(BOOL)
IsThemeBackgroundPartiallyTransparent(
    HTHEME hTheme,
    int iPartId,
    int iStateId
    );

//---------------------------------------------------------------------------
//    lower-level theme information services
//---------------------------------------------------------------------------
// The following methods are getter routines for each of the Theme Data types.
// Controls/Windows are defined in drawable "parts" by their author: a 
// parent part and 0 or more child parts.  Each of the parts can be 
// described in "states" (ex: disabled, hot, pressed).  
//---------------------------------------------------------------------------
// Each of the below methods takes a "iPartId" param to specify the 
// part and a "iStateId" to specify the state of the part.  
// "iStateId=0" refers to the root part.  "iPartId" = "0" refers to 
// the root class.  
//-----------------------------------------------------------------------
// Each method also take a "iPropId" param because multiple instances of 
// the same primitive type can be defined in the theme schema.
//-----------------------------------------------------------------------

//-----------------------------------------------------------------------
//  GetThemeColor()     - Get the value for the specified COLOR property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pColor              - receives the value of the property
//-----------------------------------------------------------------------
THEMEAPI
GetThemeColor(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out COLORREF *pColor
    );

//-----------------------------------------------------------------------
//  GetThemeMetric()    - Get the value for the specified metric/size
//                        property
//
//  hTheme              - theme data handle
//  hdc                 - (optional) hdc to be drawn into (DPI scaling)
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  piVal               - receives the value of the property
//-----------------------------------------------------------------------
THEMEAPI
GetThemeMetric(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    int iPropId,
    __out int *piVal
    );

//-----------------------------------------------------------------------
//  GetThemeString()    - Get the value for the specified string property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pszBuff             - receives the string property value
//  cchMaxBuffChars     - max. number of chars allowed in pszBuff
//-----------------------------------------------------------------------
THEMEAPI
GetThemeString(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out_ecount(cchMaxBuffChars) LPWSTR pszBuff,
    int cchMaxBuffChars
    );

//-----------------------------------------------------------------------
//  GetThemeBool()      - Get the value for the specified BOOL property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pfVal               - receives the value of the property
//-----------------------------------------------------------------------
THEMEAPI
GetThemeBool(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out BOOL *pfVal
    );

//-----------------------------------------------------------------------
//  GetThemeInt()       - Get the value for the specified int property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  piVal               - receives the value of the property
//-----------------------------------------------------------------------
THEMEAPI
GetThemeInt(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out int *piVal
    );

//-----------------------------------------------------------------------
//  GetThemeEnumValue() - Get the value for the specified ENUM property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  piVal               - receives the value of the enum (cast to int*)
//-----------------------------------------------------------------------
THEMEAPI
GetThemeEnumValue(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out int *piVal
    );

//-----------------------------------------------------------------------
//  GetThemePosition()  - Get the value for the specified position
//                        property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pPoint              - receives the value of the position property
//-----------------------------------------------------------------------
THEMEAPI
GetThemePosition(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out POINT *pPoint
    );

//-----------------------------------------------------------------------
//  GetThemeFont()      - Get the value for the specified font property
//
//  hTheme              - theme data handle
//  hdc                 - (optional) hdc to be drawn to (DPI scaling)
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pFont               - receives the value of the LOGFONT property
//                        (scaled for the current logical screen dpi) 
//-----------------------------------------------------------------------
THEMEAPI
GetThemeFont(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    int iPropId,
    __out LOGFONTW *pFont
    );

//-----------------------------------------------------------------------
//  GetThemeRect()      - Get the value for the specified RECT property
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to get the value for
//  pRect               - receives the value of the RECT property
//-----------------------------------------------------------------------
THEMEAPI
GetThemeRect(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out LPRECT pRect
    );

typedef struct _MARGINS
{
    int cxLeftWidth;      // width of left border that retains its size
    int cxRightWidth;     // width of right border that retains its size
    int cyTopHeight;      // height of top border that retains its size
    int cyBottomHeight;   // height of bottom border that retains its size
} MARGINS, *PMARGINS;

//-----------------------------------------------------------------------
//  GetThemeMargins()   - Get the value for the specified MARGINS property
//
//      hTheme          - theme data handle
//      hdc             - (optional) hdc to be used for drawing
//      iPartId         - part number 
//      iStateId        - state number of part
//      iPropId         - the property number to get the value for
//      prc             - RECT for area to be drawn into
//      pMargins        - receives the value of the MARGINS property
//-----------------------------------------------------------------------
THEMEAPI
GetThemeMargins(
    HTHEME hTheme,
    __in_opt HDC hdc,
    int iPartId,
    int iStateId,
    int iPropId,
    __in_opt LPCRECT prc,
    __out MARGINS *pMargins
    );

#if (_WIN32_WINNT >= 0x0600)
#define MAX_INTLIST_COUNT 402
#else
#define MAX_INTLIST_COUNT 10
#endif

typedef struct _INTLIST
{
    int iValueCount;      // number of values in iValues
    int iValues[MAX_INTLIST_COUNT];
} INTLIST, *PINTLIST;

//-----------------------------------------------------------------------
//  GetThemeIntList()   - Get the value for the specified INTLIST struct
//
//      hTheme          - theme data handle
//      iPartId         - part number 
//      iStateId        - state number of part
//      iPropId         - the property number to get the value for
//      pIntList        - receives the value of the INTLIST property
//-----------------------------------------------------------------------
THEMEAPI
GetThemeIntList(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out INTLIST *pIntList
    );

enum PROPERTYORIGIN
{
    PO_STATE,           // property was found in the state section
    PO_PART,            // property was found in the part section
    PO_CLASS,           // property was found in the class section
    PO_GLOBAL,          // property was found in [globals] section
    PO_NOTFOUND         // property was not found
};

//-----------------------------------------------------------------------
//  GetThemePropertyOrigin()
//                      - searches for the specified theme property
//                        and sets "pOrigin" to indicate where it was 
//                        found (or not found)
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to search for
//  pOrigin             - receives the value of the property origin
//-----------------------------------------------------------------------
THEMEAPI
GetThemePropertyOrigin(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out enum PROPERTYORIGIN *pOrigin
    );

//---------------------------------------------------------------------------
//  SetWindowTheme()
//                      - redirects an existing Window to use a different 
//                        section of the current theme information than its 
//                        class normally asks for.
//
//  hwnd                - the handle of the window (cannot be NULL)
//
//  pszSubAppName       - app (group) name to use in place of the calling
//                        app's name.  If NULL, the actual calling app 
//                        name will be used.
//
//  pszSubIdList        - semicolon separated list of class Id names to 
//                        use in place of actual list passed by the 
//                        window's class.  if NULL, the id list from the 
//                        calling class is used.
//---------------------------------------------------------------------------
// The Theme Manager will remember the "pszSubAppName" and the
// "pszSubIdList" associations thru the lifetime of the window (even 
// if themes are subsequently changed).  The window is sent a 
// "WM_THEMECHANGED" msg at the end of this call, so that the new
// theme can be found and applied.
//---------------------------------------------------------------------------
// When "pszSubAppName" or "pszSubIdList" are NULL, the Theme Manager 
// removes the previously remember association.  To turn off theme-ing for 
// the specified window, you can pass an empty string (L"") so it 
// won't match any section entries.
//---------------------------------------------------------------------------
THEMEAPI
SetWindowTheme(
    HWND hwnd,
    LPCWSTR pszSubAppName,
    LPCWSTR pszSubIdList
    );


//---------------------------------------------------------------------------
//  GetThemeFilename()  - Get the value for the specified FILENAME property.
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateId            - state number of part
//  iPropId             - the property number to search for
//  pszThemeFileName    - output buffer to receive the filename
//  cchMaxBuffChars     - the size of the return buffer, in chars
//---------------------------------------------------------------------------
THEMEAPI
GetThemeFilename(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out_ecount(cchMaxBuffChars) LPWSTR pszThemeFileName,
    int cchMaxBuffChars
    );

//---------------------------------------------------------------------------
//  GetThemeSysColor()  - Get the value of the specified System color. 
//
//  hTheme              - the theme data handle.  if non-NULL, will return
//                        color from [SysMetrics] section of theme.
//                        if NULL, will return the global system color.
//
//  iColorId            - the system color index defined in winuser.h
//---------------------------------------------------------------------------
THEMEAPI_(COLORREF)
GetThemeSysColor(
    HTHEME hTheme,
    int iColorId
    );

//---------------------------------------------------------------------------
//  GetThemeSysColorBrush() 
//                      - Get the brush for the specified System color. 
//
//  hTheme              - the theme data handle.  if non-NULL, will return
//                        brush matching color from [SysMetrics] section of 
//                        theme.  if NULL, will return the brush matching
//                        global system color.
//
//  iColorId            - the system color index defined in winuser.h
//---------------------------------------------------------------------------
THEMEAPI_(HBRUSH)
GetThemeSysColorBrush(
    HTHEME hTheme,
    int iColorId
    );

//---------------------------------------------------------------------------
//  GetThemeSysBool()   - Get the boolean value of specified System metric. 
//
//  hTheme              - the theme data handle.  if non-NULL, will return
//                        BOOL from [SysMetrics] section of theme.
//                        if NULL, will return the specified system boolean.
//
//  iBoolId             - the TMT_XXX BOOL number (first BOOL
//                        is TMT_FLATMENUS)
//---------------------------------------------------------------------------
THEMEAPI_(BOOL)
GetThemeSysBool(
    HTHEME hTheme,
    int iBoolId
    );

//---------------------------------------------------------------------------
//  GetThemeSysSize()   - Get the value of the specified System size metric. 
//                        (scaled for the current logical screen dpi) 
//
//  hTheme              - the theme data handle.  if non-NULL, will return
//                        size from [SysMetrics] section of theme.
//                        if NULL, will return the global system metric.
//
//  iSizeId             - the following values are supported when 
//                        hTheme is non-NULL:
//
//                          SM_CXBORDER       (border width)
//                          SM_CXVSCROLL      (scrollbar width)
//                          SM_CYHSCROLL      (scrollbar height)
//                          SM_CXSIZE         (caption width)
//                          SM_CYSIZE         (caption height)
//                          SM_CXSMSIZE       (small caption width)
//                          SM_CYSMSIZE       (small caption height)
//                          SM_CXMENUSIZE     (menubar width)
//                          SM_CYMENUSIZE     (menubar height)
//                          SM_CXPADDEDBORDER (padded border width)
//
//                        when hTheme is NULL, iSizeId is passed directly
//                        to the GetSystemMetrics() function
//---------------------------------------------------------------------------
THEMEAPI_(int)
GetThemeSysSize(
    HTHEME hTheme,
    int iSizeId
    );

//---------------------------------------------------------------------------
//  GetThemeSysFont()   - Get the LOGFONT for the specified System font. 
//
//  hTheme              - the theme data handle.  if non-NULL, will return
//                        font from [SysMetrics] section of theme.
//                        if NULL, will return the specified system font.
//
//  iFontId             - the TMT_XXX font number (first font
//                        is TMT_CAPTIONFONT)
//
//  plf                 - ptr to LOGFONT to receive the font value.
//                        (scaled for the current logical screen dpi) 
//---------------------------------------------------------------------------
THEMEAPI
GetThemeSysFont(
    HTHEME hTheme,
    int iFontId,
    __out LOGFONTW *plf
    );

//---------------------------------------------------------------------------
//  GetThemeSysString() - Get the value of specified System string metric. 
//
//  hTheme              - the theme data handle (required)
//
//  iStringId           - must be one of the following values:
//
//                          TMT_CSSNAME
//                          TMT_XMLNAME
//
//  pszStringBuff       - the buffer to receive the string value
//
//  cchMaxStringChars   - max. number of chars that pszStringBuff can hold
//---------------------------------------------------------------------------
THEMEAPI
GetThemeSysString(
    HTHEME hTheme,
    int iStringId,
    __out_ecount(cchMaxStringChars) LPWSTR pszStringBuff,
    int cchMaxStringChars
    );

//---------------------------------------------------------------------------
//  GetThemeSysInt() - Get the value of specified System int.
//
//  hTheme              - the theme data handle (required)
//
//  iIntId              - must be one of the following values:
//
//                          TMT_DPIX
//                          TMT_DPIY
//                          TMT_MINCOLORDEPTH
//
//  piValue             - ptr to int to receive value
//---------------------------------------------------------------------------
THEMEAPI
GetThemeSysInt(
    HTHEME hTheme,
    int iIntId,
    __out int *piValue
    );

//---------------------------------------------------------------------------
//  IsThemeActive()     - can be used to test if a system theme is active
//                        for the current user session.  
//
//                        use the API "IsAppThemed()" to test if a theme is
//                        active for the calling process.
//---------------------------------------------------------------------------
THEMEAPI_(BOOL)
IsThemeActive(
    VOID
    );

//---------------------------------------------------------------------------
//  IsAppThemed()       - returns TRUE if a theme is active and available to
//                        the current process
//---------------------------------------------------------------------------
THEMEAPI_(BOOL)
IsAppThemed(
    VOID
    );

//---------------------------------------------------------------------------
//  GetWindowTheme()    - if window is themed, returns its most recent
//                        HTHEME from OpenThemeData() - otherwise, returns
//                        NULL.
//
//      hwnd            - the window to get the HTHEME of
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME)
GetWindowTheme(
    HWND hwnd
    );

#define ETDT_DISABLE                    0x00000001
#define ETDT_ENABLE                     0x00000002
#define ETDT_USETABTEXTURE              0x00000004

#define ETDT_ENABLETAB              (ETDT_ENABLE | \
                                     ETDT_USETABTEXTURE)

#if (_WIN32_WINNT >= 0x0600)
#define ETDT_USEAEROWIZARDTABTEXTURE    0x00000008

#define ETDT_ENABLEAEROWIZARDTAB    (ETDT_ENABLE | \
                                     ETDT_USEAEROWIZARDTABTEXTURE)

#define ETDT_VALIDBITS              (ETDT_DISABLE | \
                                     ETDT_ENABLE | \
                                     ETDT_USETABTEXTURE | \
                                     ETDT_USEAEROWIZARDTABTEXTURE)
#endif

//---------------------------------------------------------------------------
//  EnableThemeDialogTexture() 
//
//  - Enables/disables dialog background theme.  This method can be used to 
//    tailor dialog compatibility with child windows and controls that 
//    may or may not coordinate the rendering of their client area backgrounds 
//    with that of their parent dialog in a manner that supports seamless 
//    background texturing.
//
//      hdlg         - the window handle of the target dialog
//      dwFlags      - ETDT_ENABLE to enable the theme-defined dialog background texturing,
//                     ETDT_DISABLE to disable background texturing,
//                     ETDT_ENABLETAB to enable the theme-defined background 
//                          texturing using the Tab texture
//---------------------------------------------------------------------------
THEMEAPI
EnableThemeDialogTexture(
    __in HWND hwnd,
    __in DWORD dwFlags
    );

//---------------------------------------------------------------------------
//  IsThemeDialogTextureEnabled() 
//
//  - Reports whether the dialog supports background texturing.
//
//      hdlg         - the window handle of the target dialog
//---------------------------------------------------------------------------
THEMEAPI_(BOOL)
IsThemeDialogTextureEnabled(
    __in HWND hwnd
    );

//---------------------------------------------------------------------------
//---- flags to control theming within an app ----

#define STAP_ALLOW_NONCLIENT    (1UL << 0)
#define STAP_ALLOW_CONTROLS     (1UL << 1)
#define STAP_ALLOW_WEBCONTENT   (1UL << 2)
#define STAP_VALIDBITS          (STAP_ALLOW_NONCLIENT | \
                                 STAP_ALLOW_CONTROLS | \
                                 STAP_ALLOW_WEBCONTENT)

//---------------------------------------------------------------------------
//  GetThemeAppProperties()
//                      - returns the app property flags that control theming
//---------------------------------------------------------------------------
THEMEAPI_(DWORD)
GetThemeAppProperties(
    VOID
    );

//---------------------------------------------------------------------------
//  SetThemeAppProperties()
//                      - sets the flags that control theming within the app
//
//      dwFlags         - the flag values to be set
//---------------------------------------------------------------------------
THEMEAPI_(void)
SetThemeAppProperties(
    DWORD dwFlags
    );

//---------------------------------------------------------------------------
//  GetCurrentThemeName()
//                      - Get the name of the current theme in-use.  
//                        Optionally, return the ColorScheme name and the 
//                        Size name of the theme.
//
//  pszThemeFileName    - receives the theme path & filename
//  cchMaxNameChars     - max chars allowed in pszNameBuff
//
//  pszColorBuff        - (optional) receives the canonical color scheme name
//                        (not the display name)
//  cchMaxColorChars    - max chars allowed in pszColorBuff
//
//  pszSizeBuff         - (optional) receives the canonical size name 
//                        (not the display name)
//  cchMaxSizeChars     - max chars allowed in pszSizeBuff
//---------------------------------------------------------------------------
THEMEAPI GetCurrentThemeName(
    __out_ecount(cchMaxNameChars) LPWSTR pszThemeFileName,
    int cchMaxNameChars,
    __out_ecount_opt(cchMaxColorChars) LPWSTR pszColorBuff,
    int cchMaxColorChars,
    __out_ecount_opt(cchMaxSizeChars) LPWSTR pszSizeBuff,
    int cchMaxSizeChars
    );

#define SZ_THDOCPROP_DISPLAYNAME    L"DisplayName"
#define SZ_THDOCPROP_CANONICALNAME  L"ThemeName"
#define SZ_THDOCPROP_TOOLTIP        L"ToolTip"
#define SZ_THDOCPROP_AUTHOR         L"author"

THEMEAPI
GetThemeDocumentationProperty(
    LPCWSTR pszThemeName,
    LPCWSTR pszPropertyName,
    __out_ecount(cchMaxValChars) LPWSTR pszValueBuff,
    int cchMaxValChars
    );

//---------------------------------------------------------------------------
//  Theme API Error Handling
//
//      All functions in the Theme API not returning an HRESULT (THEMEAPI_) 
//      use the WIN32 function "SetLastError()" to record any call failures.  
//
//      To retreive the error code of the last failure on the
//      current thread for these type of API's, use the WIN32 function 
//      "GetLastError()".
//
//      All Theme API error codes (HRESULT's and GetLastError() values)
//      should be normal win32 errors which can be formatted into
//      strings using the Win32 API FormatMessage().
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// DrawThemeParentBackground()
//                      - used by partially-transparent or alpha-blended
//                        child controls to draw the part of their parent
//                        that they appear in front of.
//
//  hwnd                - handle of the child control
//
//  hdc                 - hdc of the child control
//
//  prc                 - (optional) rect that defines the area to be 
//                        drawn (CHILD coordinates)
//---------------------------------------------------------------------------
THEMEAPI
DrawThemeParentBackground(
    HWND hwnd,
    HDC hdc,
    __in_opt const RECT* prc
    );


//---------------------------------------------------------------------------
//  EnableTheming()     - enables or disables themeing for the current user
//                        in the current and future sessions.
//
//  fEnable             - if FALSE, disable theming & turn themes off.
//                      - if TRUE, enable themeing and, if user previously
//                        had a theme active, make it active now.
//---------------------------------------------------------------------------
THEMEAPI
EnableTheming(
    BOOL fEnable
    );

#define GBF_DIRECT      0x00000001      // direct dereferencing.
#define GBF_COPY        0x00000002      // create a copy of the bitmap
#define GBF_VALIDBITS   (GBF_DIRECT | \
                         GBF_COPY)

#if (_WIN32_WINNT >= 0x0600)

#define DTPB_WINDOWDC           0x00000001
#define DTPB_USECTLCOLORSTATIC  0x00000002
#define DTPB_USEERASEBKGND      0x00000004

//---------------------------------------------------------------------------
// DrawThemeParentBackgroundEx()
//                      - used by partially-transparent or alpha-blended
//                        child controls to draw the part of their parent
//                        that they appear in front of.
//                        Sends a WM_ERASEBKGND message followed by a WM_PRINTCLIENT.
//
//  hwnd                - handle of the child control
//
//  hdc                 - hdc of the child control
//
//  dwFlags             - if 0, only returns S_OK if the parent handled 
//                        WM_PRINTCLIENT.
//                      - if DTPB_WINDOWDC is set, hdc is assumed to be a window DC,
//                        not a client DC.
//                      - if DTPB_USEERASEBKGND is set, the function will return S_OK 
//                        without sending a WM_CTLCOLORSTATIC message if the parent 
//                        actually painted on WM_ERASEBKGND.
//                      - if DTPB_CTLCOLORSTATIC is set, the function will send
//                        a WM_CTLCOLORSTATIC message to the parent and use the 
//                        brush if one is provided, else COLOR_BTNFACE.
//
//  prc                 - (optional) rect that defines the area to be 
//                        drawn (CHILD coordinates)
//
//  Return value        - S_OK if something was painted, S_FALSE if not.
//---------------------------------------------------------------------------
THEMEAPI
DrawThemeParentBackgroundEx(
    HWND hwnd,
    HDC hdc,
    DWORD dwFlags,
    __in_opt const RECT* prc
    );


enum WINDOWTHEMEATTRIBUTETYPE
{
    WTA_NONCLIENT = 1
};

typedef struct _WTA_OPTIONS
{
    DWORD dwFlags;          // values for each style option specified in the bitmask
    DWORD dwMask;           // bitmask for flags that are changing
                            // valid options are: WTNCA_NODRAWCAPTION, WTNCA_NODRAWICON, WTNCA_NOSYSMENU
} WTA_OPTIONS, *PWTA_OPTIONS;

#define WTNCA_NODRAWCAPTION       0x00000001    // don't draw the window caption
#define WTNCA_NODRAWICON          0x00000002    // don't draw the system icon
#define WTNCA_NOSYSMENU           0x00000004    // don't expose the system menu icon functionality
#define WTNCA_NOMIRRORHELP        0x00000008    // don't mirror the question mark, even in RTL layout
#define WTNCA_VALIDBITS           (WTNCA_NODRAWCAPTION | \
                                   WTNCA_NODRAWICON | \
                                   WTNCA_NOSYSMENU | \
                                   WTNCA_NOMIRRORHELP)

THEMEAPI
SetWindowThemeAttribute(
    HWND hwnd,
    enum WINDOWTHEMEATTRIBUTETYPE eAttribute,
    __in_bcount(cbAttribute) PVOID pvAttribute,
    DWORD cbAttribute
    );

__inline HRESULT SetWindowThemeNonClientAttributes(HWND hwnd, DWORD dwMask, DWORD dwAttributes)    
{
    WTA_OPTIONS wta;
    wta.dwFlags = dwAttributes;
    wta.dwMask = dwMask;
    return SetWindowThemeAttribute(hwnd, WTA_NONCLIENT, (void*)&(wta), sizeof(wta));
}

#endif // #if (_WIN32_WINNT >= 0x0600)

//---------------------------------------------------------------------------
//
// DrawThemeTextEx
//
// Note: DrawThemeTextEx only exists on Windows Vista and higher, but the 
// following declarations are provided to enable declaring its prototype when
// compiling for all platforms.

// Callback function used by DrawThemeTextEx, instead of DrawText
typedef 
int
(WINAPI *DTT_CALLBACK_PROC)
(
    __in HDC hdc,
    __inout_ecount(cchText) LPWSTR pszText,
    __in int cchText,
    __inout LPRECT prc,
    __in UINT dwFlags,
    __in LPARAM lParam);

//---- bits used in dwFlags of DTTOPTS ----
#define DTT_TEXTCOLOR       (1UL << 0)      // crText has been specified
#define DTT_BORDERCOLOR     (1UL << 1)      // crBorder has been specified
#define DTT_SHADOWCOLOR     (1UL << 2)      // crShadow has been specified
#define DTT_SHADOWTYPE      (1UL << 3)      // iTextShadowType has been specified
#define DTT_SHADOWOFFSET    (1UL << 4)      // ptShadowOffset has been specified
#define DTT_BORDERSIZE      (1UL << 5)      // iBorderSize has been specified
#define DTT_FONTPROP        (1UL << 6)      // iFontPropId has been specified
#define DTT_COLORPROP       (1UL << 7)      // iColorPropId has been specified
#define DTT_STATEID         (1UL << 8)      // IStateId has been specified
#define DTT_CALCRECT        (1UL << 9)      // Use pRect as and in/out parameter
#define DTT_APPLYOVERLAY    (1UL << 10)     // fApplyOverlay has been specified
#define DTT_GLOWSIZE        (1UL << 11)     // iGlowSize has been specified
#define DTT_CALLBACK        (1UL << 12)     // pfnDrawTextCallback has been specified
#define DTT_COMPOSITED      (1UL << 13)     // Draws text with antialiased alpha (needs a DIB section)
#define DTT_VALIDBITS       (DTT_TEXTCOLOR | \
                             DTT_BORDERCOLOR | \
                             DTT_SHADOWCOLOR | \
                             DTT_SHADOWTYPE | \
                             DTT_SHADOWOFFSET | \
                             DTT_BORDERSIZE | \
                             DTT_FONTPROP | \
                             DTT_COLORPROP | \
                             DTT_STATEID | \
                             DTT_CALCRECT | \
                             DTT_APPLYOVERLAY | \
                             DTT_GLOWSIZE | \
                             DTT_COMPOSITED)

typedef struct _DTTOPTS
{
    DWORD             dwSize;              // size of the struct
    DWORD             dwFlags;             // which options have been specified
    COLORREF          crText;              // color to use for text fill
    COLORREF          crBorder;            // color to use for text outline
    COLORREF          crShadow;            // color to use for text shadow
    int               iTextShadowType;     // TST_SINGLE or TST_CONTINUOUS
    POINT             ptShadowOffset;      // where shadow is drawn (relative to text)
    int               iBorderSize;         // Border radius around text
    int               iFontPropId;         // Font property to use for the text instead of TMT_FONT
    int               iColorPropId;        // Color property to use for the text instead of TMT_TEXTCOLOR
    int               iStateId;            // Alternate state id
    BOOL              fApplyOverlay;       // Overlay text on top of any text effect?
    int               iGlowSize;           // Glow radious around text
    DTT_CALLBACK_PROC pfnDrawTextCallback; // Callback for DrawText
    LPARAM            lParam;              // Parameter for callback
} DTTOPTS, *PDTTOPTS; 

#if (_WIN32_WINNT >= 0x0600)

THEMEAPI
DrawThemeTextEx(
    HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    __in_ecount(cchText) LPCWSTR pszText,
    int cchText,
    DWORD dwTextFlags,
    __inout LPRECT pRect,
    __in_opt const DTTOPTS *pOptions
    );


//-----------------------------------------------------------------------
//  GetThemeStream() - Get the value for the specified STREAM property
//
//      hTheme      - theme data handle
//      iPartId     - part number 
//      iStateId    - state number of part
//      iPropId     - the property number to get the value for
//      ppvStream   - if non-null receives the value of the STREAM property (not to be freed)
//      pcbStream   - if non-null receives the size of the STREAM property
//      hInst       - NULL when iPropId==TMT_STREAM, HINSTANCE of a loaded msstyles 
//                    file when iPropId==TMT_DISKSTREAM (use GetCurrentThemeName 
//                    and LoadLibraryEx(LOAD_LIBRARY_AS_DATAFILE)
//-----------------------------------------------------------------------
THEMEAPI
GetThemeBitmap(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    ULONG dwFlags,
    __out HBITMAP* phBitmap
    );

//-----------------------------------------------------------------------
//  GetThemeStream() - Get the value for the specified STREAM property
//
//      hTheme      - theme data handle
//      iPartId     - part number 
//      iStateId    - state number of part
//      iPropId     - the property number to get the value for
//      ppvStream   - if non-null receives the value of the STREAM property (not to be freed)
//      pcbStream   - if non-null receives the size of the STREAM property
//      hInst       - NULL when iPropId==TMT_STREAM, HINSTANCE of a loaded msstyles 
//                    file when iPropId==TMT_DISKSTREAM (use GetCurrentThemeName 
//                    and LoadLibraryEx(LOAD_LIBRARY_AS_DATAFILE)
//-----------------------------------------------------------------------
THEMEAPI
GetThemeStream(
    HTHEME hTheme,
    int iPartId,
    int iStateId,
    int iPropId,
    __out VOID **ppvStream,
    __out_opt DWORD *pcbStream,
    __in_opt HINSTANCE hInst
    );


//------------------------------------------------------------------------
//  BufferedPaintInit() - Initialize the Buffered Paint API.
//                        Should be called prior to BeginBufferedPaint,
//                        and should have a matching BufferedPaintUnInit.
//------------------------------------------------------------------------
THEMEAPI
BufferedPaintInit(
    VOID
    );

//------------------------------------------------------------------------
//  BufferedPaintUnInit() - Uninitialize the Buffered Paint API.
//                          Should be called once for each call to BufferedPaintInit,
//                          when calls to BeginBufferedPaint are no longer needed.
//------------------------------------------------------------------------
THEMEAPI
BufferedPaintUnInit(
    VOID
    );

//------------------------------------------------------------------------
//  BeginBufferedPaint() - Begins a buffered paint operation.
//
//    hdcTarget          - Target DC on which the buffer will be painted
//    rcTarget           - Rectangle specifying the area of the target DC to paint to
//    dwFormat           - Format of the buffer (see BP_BUFFERFORMAT)
//    pPaintParams       - Paint operation parameters (see BP_PAINTPARAMS)
//    phBufferedPaint    - Pointer to receive handle to new buffered paint context
//------------------------------------------------------------------------

// HPAINTBUFFER
typedef HANDLE HPAINTBUFFER;  // handle to a buffered paint context


// BP_BUFFERFORMAT
typedef enum _BP_BUFFERFORMAT
{
    BPBF_COMPATIBLEBITMAP,    // Compatible bitmap
    BPBF_DIB,                 // Device-independent bitmap
    BPBF_TOPDOWNDIB,          // Top-down device-independent bitmap
    BPBF_TOPDOWNMONODIB       // Top-down monochrome device-independent bitmap
} BP_BUFFERFORMAT;

#define BPBF_COMPOSITED BPBF_TOPDOWNDIB


// BP_ANIMATIONSTYLE
typedef enum _BP_ANIMATIONSTYLE
{
    BPAS_NONE,                // No animation
    BPAS_LINEAR,              // Linear fade animation
    BPAS_CUBIC,               // Cubic fade animation
    BPAS_SINE                 // Sinusoid fade animation
} BP_ANIMATIONSTYLE;


// BP_ANIMATIONPARAMS
typedef struct _BP_ANIMATIONPARAMS
{
    DWORD               cbSize;
    DWORD               dwFlags; // BPAF_ flags
    BP_ANIMATIONSTYLE   style;
    DWORD               dwDuration;
} BP_ANIMATIONPARAMS, *PBP_ANIMATIONPARAMS;

#define BPPF_ERASE               0x0001 // Empty the buffer during BeginBufferedPaint()
#define BPPF_NOCLIP              0x0002 // Don't apply the target DC's clip region to the double buffer
#define BPPF_NONCLIENT           0x0004 // Using a non-client DC

                                        
// BP_PAINTPARAMS
typedef struct _BP_PAINTPARAMS
{
    DWORD                       cbSize;
    DWORD                       dwFlags; // BPPF_ flags
    const RECT *                prcExclude;
    const BLENDFUNCTION *       pBlendFunction;
} BP_PAINTPARAMS, *PBP_PAINTPARAMS;

THEMEAPI_(__success(return != NULL) HPAINTBUFFER)
BeginBufferedPaint(
    HDC hdcTarget,
    const RECT* prcTarget,
    BP_BUFFERFORMAT dwFormat,
    __in_opt BP_PAINTPARAMS *pPaintParams,
    __out HDC *phdc
    );


//------------------------------------------------------------------------
//  EndBufferedPaint() - Ends a buffered paint operation.
//
//    hBufferedPaint   - handle to buffered paint context
//    fUpdateTarget    - update target DC
//------------------------------------------------------------------------
THEMEAPI
EndBufferedPaint(
    HPAINTBUFFER hBufferedPaint,
    BOOL fUpdateTarget
    );

//------------------------------------------------------------------------
//  GetBufferedPaintTargetRect() - Returns the target rectangle specified during BeginBufferedPaint
//
//    hBufferedPaint             - handle to buffered paint context
//    prc                        - pointer to receive target rectangle
//------------------------------------------------------------------------
THEMEAPI
GetBufferedPaintTargetRect(
    HPAINTBUFFER hBufferedPaint,
    __out RECT *prc
    );

//------------------------------------------------------------------------
//  GetBufferedPaintTargetDC() - Returns the target DC specified during BeginBufferedPaint
//
//    hBufferedPaint           - handle to buffered paint context
//------------------------------------------------------------------------
THEMEAPI_(HDC)
GetBufferedPaintTargetDC(
    HPAINTBUFFER hBufferedPaint
    );

//------------------------------------------------------------------------
//  GetBufferedPaintDC() - Returns the same paint DC returned by BeginBufferedPaint
//
//    hBufferedPaint     - handle to buffered paint context
//------------------------------------------------------------------------
THEMEAPI_(HDC)
GetBufferedPaintDC(
    HPAINTBUFFER hBufferedPaint
    );

//------------------------------------------------------------------------
//  GetBufferedPaintBits() - Obtains a pointer to the buffer bitmap, if the buffer is a DIB
//
//    hBufferedPaint       - handle to buffered paint context
//    ppbBuffer            - pointer to receive pointer to buffer bitmap pixels
//    pcxRow               - pointer to receive width of buffer bitmap, in pixels;
//                           this value may not necessarily be equal to the buffer width
//------------------------------------------------------------------------
THEMEAPI
GetBufferedPaintBits(
    HPAINTBUFFER hBufferedPaint,
    __out RGBQUAD **ppbBuffer,
    __out int *pcxRow
    );

//------------------------------------------------------------------------
//  BufferedPaintClear() - Clears given rectangle to ARGB = {0, 0, 0, 0}
//
//    hBufferedPaint     - handle to buffered paint context
//    prc                - rectangle to clear; NULL specifies entire buffer
//------------------------------------------------------------------------
THEMEAPI
BufferedPaintClear(
    HPAINTBUFFER hBufferedPaint,
    __in_opt const RECT *prc
    );

//------------------------------------------------------------------------
//  BufferedPaintSetAlpha() - Set alpha to given value in given rectangle
//
//    hBufferedPaint        - handle to buffered paint context
//    prc                   - rectangle to set alpha in; NULL specifies entire buffer
//    alpha                 - alpha value to set in the given rectangle
//------------------------------------------------------------------------
THEMEAPI
BufferedPaintSetAlpha(
    HPAINTBUFFER hBufferedPaint,
    __in_opt const RECT *prc,
    BYTE alpha
    );

// Macro for setting the buffer to opaque (alpha = 255)
#define BufferedPaintMakeOpaque(hBufferedPaint, prc) BufferedPaintSetAlpha(hBufferedPaint, prc, 255)

//------------------------------------------------------------------------
//  BufferedPaintStopAllAnimations() - Stop all buffer animations for the given window
//
//    hwnd                           - window on which to stop all animations
//------------------------------------------------------------------------
THEMEAPI
BufferedPaintStopAllAnimations(
    HWND hwnd
    );

typedef HANDLE HANIMATIONBUFFER;  // handle to a buffered paint animation

THEMEAPI_(HANIMATIONBUFFER)
BeginBufferedAnimation(
    HWND hwnd,
    HDC hdcTarget,
    const RECT* prcTarget,
    BP_BUFFERFORMAT dwFormat,
    __in_opt BP_PAINTPARAMS *pPaintParams,
    __in BP_ANIMATIONPARAMS *pAnimationParams,
    __out HDC *phdcFrom,
    __out HDC *phdcTo
    );

THEMEAPI
EndBufferedAnimation(
    HANIMATIONBUFFER hbpAnimation,
    BOOL fUpdateTarget
    );

THEMEAPI_(BOOL)
BufferedPaintRenderAnimation(
    HWND hwnd,
    HDC hdcTarget
    );
    
//----------------------------------------------------------------------------
// Tells if the DWM is running, and composition effects are possible for this 
// process (themes are active). 
// Roughly equivalent to "DwmIsCompositionEnabled() && IsAppthemed()"
//----------------------------------------------------------------------------
THEMEAPI_(BOOL) IsCompositionActive();

//------------------------------------------------------------------------
//  GetThemeTransitionDuration()
//                      - Gets the duration for the specified transition
//
//  hTheme              - theme data handle
//  iPartId             - part number 
//  iStateIdFrom        - starting state number of part
//  iStateIdTo          - ending state number of part
//  iPropId             - property id 
//  pdwDuration         - receives the transition duration
//------------------------------------------------------------------------
THEMEAPI
GetThemeTransitionDuration(
    HTHEME hTheme,
    int iPartId,
    int iStateIdFrom,
    int iStateIdTo,
    int iPropId,
    __out DWORD *pdwDuration
    );  

#endif // #if (_WIN32_WINNT >= 0x0600)

#endif /* _UXTHEME_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\uuids.h ===
//------------------------------------------------------------------------------
// File: uuids.h
//
// Desc: Contains the GUIDs for the MediaType type, subtype fields and format
//       types for standard media types, and also class ids for well-known
//       components.
//
// Copyright (c) 1992 - 2002, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


//
//  We want to use this list for generating strings for debugging too
//  so we redefine OUR_GUID_ENTRY depending on what we want to do
//
//  It is imperative that all entries in this file are declared using
//  OUR_GUID_ENTRY as that macro might have been defined in advance of
//  including this file.  See wxdebug.cpp in sdk\classes\base.
//

#ifndef OUR_GUID_ENTRY
    #define OUR_GUID_ENTRY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8);
#endif


// -- to allow consistent labeling of Media types and subtypes --

#define MEDIATYPE_NULL       GUID_NULL
#define MEDIASUBTYPE_NULL    GUID_NULL

// -- Use this subtype if you don't have a use for a subtype for your type
// e436eb8e-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_None
OUR_GUID_ENTRY(MEDIASUBTYPE_None,
0xe436eb8e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)


// -- major types ---


// 73646976-0000-0010-8000-00AA00389B71  'vids' == MEDIATYPE_Video
OUR_GUID_ENTRY(MEDIATYPE_Video,
0x73646976, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 73647561-0000-0010-8000-00AA00389B71  'auds' == MEDIATYPE_Audio
OUR_GUID_ENTRY(MEDIATYPE_Audio,
0x73647561, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 73747874-0000-0010-8000-00AA00389B71  'txts' == MEDIATYPE_Text
OUR_GUID_ENTRY(MEDIATYPE_Text,
0x73747874, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 7364696D-0000-0010-8000-00AA00389B71  'mids' == MEDIATYPE_Midi
OUR_GUID_ENTRY(MEDIATYPE_Midi,
0x7364696D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// e436eb83-524f-11ce-9f53-0020af0ba770            MEDIATYPE_Stream
OUR_GUID_ENTRY(MEDIATYPE_Stream,
0xe436eb83, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 73(s)76(v)61(a)69(i)-0000-0010-8000-00AA00389B71  'iavs' == MEDIATYPE_Interleaved
OUR_GUID_ENTRY(MEDIATYPE_Interleaved,
0x73766169, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 656c6966-0000-0010-8000-00AA00389B71  'file' == MEDIATYPE_File
OUR_GUID_ENTRY(MEDIATYPE_File,
0x656c6966, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 73636d64-0000-0010-8000-00AA00389B71  'scmd' == MEDIATYPE_ScriptCommand
OUR_GUID_ENTRY(MEDIATYPE_ScriptCommand,
0x73636d64, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 670AEA80-3A82-11d0-B79B-00AA003767A7            MEDIATYPE_AUXLine21Data
OUR_GUID_ENTRY(MEDIATYPE_AUXLine21Data,
0x670aea80, 0x3a82, 0x11d0, 0xb7, 0x9b, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// {11264ACB-37DE-4eba-8C35-7F04A1A68332}
OUR_GUID_ENTRY(MEDIATYPE_AUXTeletextPage,
0x11264acb, 0x37de, 0x4eba, 0x8c, 0x35, 0x7f, 0x4, 0xa1, 0xa6, 0x83, 0x32)

// AEB312E9-3357-43ca-B701-97EC198E2B62            MEDIATYPE_CC_CONTAINER
OUR_GUID_ENTRY(MEDIATYPE_CC_CONTAINER,
0xaeb312e9, 0x3357, 0x43ca, 0xb7, 0x1, 0x97, 0xec, 0x19, 0x8e, 0x2b, 0x62)

// FB77E152-53B2-499c-B46B-509FC33EDFD7             MEDIATYPE_DTVCCData
OUR_GUID_ENTRY(MEDIATYPE_DTVCCData,
0xfb77e152, 0x53b2, 0x499c, 0xb4, 0x6b, 0x50, 0x9f, 0xc3, 0x3e, 0xdf, 0xd7)

// B88B8A89-B049-4C80-ADCF-5898985E22C1             MEDIATYPE_MSTVCaption
OUR_GUID_ENTRY(MEDIATYPE_MSTVCaption,
0xB88B8A89, 0xB049, 0x4C80, 0xAD, 0xCF, 0x58, 0x98, 0x98, 0x5E, 0x22, 0xC1)

// F72A76E1-EB0A-11D0-ACE4-0000C0CC16BA            MEDIATYPE_VBI
OUR_GUID_ENTRY(MEDIATYPE_VBI,
0xf72a76e1, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// 34FFCBC3-D5B3-4171-9002-D4C60301697F             DVB_SUBTITLES
OUR_GUID_ENTRY(MEDIASUBTYPE_DVB_SUBTITLES,
0x34FFCBC3, 0xD5B3, 0x4171, 0x90, 0x02, 0xD4, 0xC6, 0x03, 0x01, 0x69, 0x7F)

// 059DD67D-2E55-4d41-8D1B-01F5E4F50607            ISDB_CAPTIONS
OUR_GUID_ENTRY(MEDIASUBTYPE_ISDB_CAPTIONS,
0x059dd67d, 0x2e55, 0x4d41, 0x8d, 0x1b, 0x01, 0xf5, 0xe4, 0xf5, 0x06, 0x07)

// 36dc6d28-f1a6-4216-9048-9cfcefeb5eba            ISDB_SUPERIMPOSE
OUR_GUID_ENTRY(MEDIASUBTYPE_ISDB_SUPERIMPOSE,
0x36dc6d28, 0xf1a6, 0x4216, 0x90, 0x48, 0x9c, 0xfc, 0xef, 0xeb, 0x5e, 0xba)

// 0482DEE3-7817-11cf-8a03-00aa006ecb65            MEDIATYPE_Timecode
OUR_GUID_ENTRY(MEDIATYPE_Timecode,
0x482dee3, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 74726c6d-0000-0010-8000-00AA00389B71  'lmrt' == MEDIATYPE_LMRT
OUR_GUID_ENTRY(MEDIATYPE_LMRT,
0x74726c6d, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 74726c6d-0000-0010-8000-00AA00389B71  'urls' == MEDIATYPE_URL_STREAM
OUR_GUID_ENTRY(MEDIATYPE_URL_STREAM,
0x736c7275, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// -- sub types ---

// 4C504C43-0000-0010-8000-00AA00389B71  'CLPL' == MEDIASUBTYPE_CLPL
OUR_GUID_ENTRY(MEDIASUBTYPE_CLPL,
0x4C504C43, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 56595559-0000-0010-8000-00AA00389B71  'YUYV' == MEDIASUBTYPE_YUYV
OUR_GUID_ENTRY(MEDIASUBTYPE_YUYV,
0x56595559, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 56555949-0000-0010-8000-00AA00389B71  'IYUV' == MEDIASUBTYPE_IYUV
OUR_GUID_ENTRY(MEDIASUBTYPE_IYUV,
0x56555949, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 39555659-0000-0010-8000-00AA00389B71  'YVU9' == MEDIASUBTYPE_YVU9
OUR_GUID_ENTRY(MEDIASUBTYPE_YVU9,
0x39555659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 31313459-0000-0010-8000-00AA00389B71  'Y411' == MEDIASUBTYPE_Y411
OUR_GUID_ENTRY(MEDIASUBTYPE_Y411,
0x31313459, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 50313459-0000-0010-8000-00AA00389B71  'Y41P' == MEDIASUBTYPE_Y41P
OUR_GUID_ENTRY(MEDIASUBTYPE_Y41P,
0x50313459, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 32595559-0000-0010-8000-00AA00389B71  'YUY2' == MEDIASUBTYPE_YUY2
OUR_GUID_ENTRY(MEDIASUBTYPE_YUY2,
0x32595559, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 55595659-0000-0010-8000-00AA00389B71  'YVYU' == MEDIASUBTYPE_YVYU
OUR_GUID_ENTRY(MEDIASUBTYPE_YVYU,
0x55595659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 59565955-0000-0010-8000-00AA00389B71  'UYVY' ==  MEDIASUBTYPE_UYVY
OUR_GUID_ENTRY(MEDIASUBTYPE_UYVY,
0x59565955, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 31313259-0000-0010-8000-00AA00389B71  'Y211' ==  MEDIASUBTYPE_Y211
OUR_GUID_ENTRY(MEDIASUBTYPE_Y211,
0x31313259, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 524a4c43-0000-0010-8000-00AA00389B71  'CLJR' ==  MEDIASUBTYPE_CLJR
OUR_GUID_ENTRY(MEDIASUBTYPE_CLJR,
0x524a4c43, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 39304649-0000-0010-8000-00AA00389B71  'IF09' ==  MEDIASUBTYPE_IF09
OUR_GUID_ENTRY(MEDIASUBTYPE_IF09,
0x39304649, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 414c5043-0000-0010-8000-00AA00389B71  'CPLA' ==  MEDIASUBTYPE_CPLA
OUR_GUID_ENTRY(MEDIASUBTYPE_CPLA,
0x414c5043, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 47504A4D-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_MJPG
OUR_GUID_ENTRY(MEDIASUBTYPE_MJPG,
0x47504A4D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 4A4D5654-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_TVMJ
OUR_GUID_ENTRY(MEDIASUBTYPE_TVMJ,
0x4A4D5654, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 454B4157-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_WAKE
OUR_GUID_ENTRY(MEDIASUBTYPE_WAKE,
0x454B4157, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 43434643-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_CFCC
OUR_GUID_ENTRY(MEDIASUBTYPE_CFCC,
0x43434643, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 47504A49-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_IJPG
OUR_GUID_ENTRY(MEDIASUBTYPE_IJPG,
0x47504A49, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 6D756C50-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_Plum
OUR_GUID_ENTRY(MEDIASUBTYPE_Plum,
0x6D756C50, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// FAST DV-Master
// 53435644-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_DVCS
OUR_GUID_ENTRY(MEDIASUBTYPE_DVCS,
0x53435644, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// H.264 compressed video stream
// 34363248-0000-0010-8000-00AA00389B71  'H264' == MEDIASUBTYPE_H264
OUR_GUID_ENTRY(MEDIASUBTYPE_H264,
0x34363248, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// FAST DV-Master
// 44535644-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_DVSD
OUR_GUID_ENTRY(MEDIASUBTYPE_DVSD,
0x44535644, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// MIROVideo DV
// 4656444D-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_MDVF
OUR_GUID_ENTRY(MEDIASUBTYPE_MDVF,
0x4656444D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// e436eb78-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB1
// e436eb78-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB1
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB1,
0xe436eb78, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb79-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB4
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB4,
0xe436eb79, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7a-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB8
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB8,
0xe436eb7a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7b-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB565
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB565,
0xe436eb7b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7c-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB555
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB555,
0xe436eb7c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7d-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB24
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB24,
0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb7e-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB32
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB32,
0xe436eb7e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)


//
// RGB surfaces that contain per pixel alpha values.
//

// 297C55AF-E209-4cb3-B757-C76D6B9C88A8            MEDIASUBTYPE_ARGB1555
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB1555,
0x297c55af, 0xe209, 0x4cb3, 0xb7, 0x57, 0xc7, 0x6d, 0x6b, 0x9c, 0x88, 0xa8)

// 6E6415E6-5C24-425f-93CD-80102B3D1CCA            MEDIASUBTYPE_ARGB4444
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB4444,
0x6e6415e6, 0x5c24, 0x425f, 0x93, 0xcd, 0x80, 0x10, 0x2b, 0x3d, 0x1c, 0xca)

// 773c9ac0-3274-11d0-B724-00aa006c1A01            MEDIASUBTYPE_ARGB32
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB32,
0x773c9ac0, 0x3274, 0x11d0, 0xb7, 0x24, 0x0, 0xaa, 0x0, 0x6c, 0x1a, 0x1 )


// 2f8bb76d-b644-4550-acf3-d30caa65d5c5            MEDIASUBTYPE_A2R10G10B10
OUR_GUID_ENTRY(MEDIASUBTYPE_A2R10G10B10,
0x2f8bb76d, 0xb644, 0x4550, 0xac, 0xf3, 0xd3, 0x0c, 0xaa, 0x65, 0xd5, 0xc5)

// 576f7893-bdf6-48c4-875f-ae7b81834567            MEDIASUBTYPE_A2B10G10R10
OUR_GUID_ENTRY(MEDIASUBTYPE_A2B10G10R10,
0x576f7893, 0xbdf6, 0x48c4, 0x87, 0x5f, 0xae, 0x7b, 0x81, 0x83, 0x45, 0x67)


// 56555941-0000-0010-8000-00AA00389B71  'AYUV' == MEDIASUBTYPE_AYUV
//
// See the DX-VA header and documentation for a description of this format.
//
OUR_GUID_ENTRY(MEDIASUBTYPE_AYUV,
0x56555941, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 34344941-0000-0010-8000-00AA00389B71  'AI44' == MEDIASUBTYPE_AI44
//
// See the DX-VA header and documentation for a description of this format.
//
OUR_GUID_ENTRY(MEDIASUBTYPE_AI44,
0x34344941, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 34344149-0000-0010-8000-00AA00389B71  'IA44' == MEDIASUBTYPE_IA44
//
// See the DX-VA header and documentation for a description of this format.
//
OUR_GUID_ENTRY(MEDIASUBTYPE_IA44,
0x34344149, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)


//
// DirectX7 D3D Render Target media subtypes.
//

// 32335237-0000-0010-8000-00AA00389B71  '7R32' == MEDIASUBTYPE_RGB32_D3D_DX7_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB32_D3D_DX7_RT,
0x32335237, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 36315237-0000-0010-8000-00AA00389B71  '7R16' == MEDIASUBTYPE_RGB16_D3D_DX7_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB16_D3D_DX7_RT,
0x36315237, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 38384137-0000-0010-8000-00AA00389B71  '7A88' == MEDIASUBTYPE_ARGB32_D3D_DX7_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB32_D3D_DX7_RT,
0x38384137, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 34344137-0000-0010-8000-00AA00389B71  '7A44' == MEDIASUBTYPE_ARGB4444_D3D_DX7_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB4444_D3D_DX7_RT,
0x34344137, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 35314137-0000-0010-8000-00AA00389B71  '7A15' == MEDIASUBTYPE_ARGB1555_D3D_DX7_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB1555_D3D_DX7_RT,
0x35314137, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)


//
// DirectX9 D3D Render Target media subtypes.
//

// 32335239-0000-0010-8000-00AA00389B71  '9R32' == MEDIASUBTYPE_RGB32_D3D_DX9_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB32_D3D_DX9_RT,
0x32335239, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 36315239-0000-0010-8000-00AA00389B71  '9R16' == MEDIASUBTYPE_RGB16_D3D_DX9_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_RGB16_D3D_DX9_RT,
0x36315239, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 38384139-0000-0010-8000-00AA00389B71  '9A88' == MEDIASUBTYPE_ARGB32_D3D_DX9_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB32_D3D_DX9_RT,
0x38384139, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 34344139-0000-0010-8000-00AA00389B71  '9A44' == MEDIASUBTYPE_ARGB4444_D3D_DX9_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB4444_D3D_DX9_RT,
0x34344139, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 35314139-0000-0010-8000-00AA00389B71  '9A15' == MEDIASUBTYPE_ARGB1555_D3D_DX9_RT
OUR_GUID_ENTRY(MEDIASUBTYPE_ARGB1555_D3D_DX9_RT,
0x35314139, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)


#define MEDIASUBTYPE_HASALPHA(mt) ( ((mt).subtype == MEDIASUBTYPE_ARGB4444)            || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB32)              || \
                                    ((mt).subtype == MEDIASUBTYPE_AYUV)                || \
                                    ((mt).subtype == MEDIASUBTYPE_AI44)                || \
                                    ((mt).subtype == MEDIASUBTYPE_IA44)                || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB1555)            || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB32_D3D_DX7_RT)   || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB4444_D3D_DX7_RT) || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB1555_D3D_DX7_RT) || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB32_D3D_DX9_RT)   || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB4444_D3D_DX9_RT) || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB1555_D3D_DX9_RT) )

#define MEDIASUBTYPE_HASALPHA7(mt) (((mt).subtype == MEDIASUBTYPE_ARGB32_D3D_DX7_RT)   || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB4444_D3D_DX7_RT) || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB1555_D3D_DX7_RT) )

#define MEDIASUBTYPE_D3D_DX7_RT(mt) (((mt).subtype == MEDIASUBTYPE_ARGB32_D3D_DX7_RT)   || \
                                     ((mt).subtype == MEDIASUBTYPE_ARGB4444_D3D_DX7_RT) || \
                                     ((mt).subtype == MEDIASUBTYPE_ARGB1555_D3D_DX7_RT) || \
                                     ((mt).subtype == MEDIASUBTYPE_RGB32_D3D_DX7_RT)    || \
                                     ((mt).subtype == MEDIASUBTYPE_RGB16_D3D_DX7_RT))

#define MEDIASUBTYPE_HASALPHA9(mt) (((mt).subtype == MEDIASUBTYPE_ARGB32_D3D_DX9_RT)   || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB4444_D3D_DX9_RT) || \
                                    ((mt).subtype == MEDIASUBTYPE_ARGB1555_D3D_DX9_RT) )


#define MEDIASUBTYPE_D3D_DX9_RT(mt) (((mt).subtype == MEDIASUBTYPE_ARGB32_D3D_DX9_RT)   || \
                                     ((mt).subtype == MEDIASUBTYPE_ARGB4444_D3D_DX9_RT) || \
                                     ((mt).subtype == MEDIASUBTYPE_ARGB1555_D3D_DX9_RT) || \
                                     ((mt).subtype == MEDIASUBTYPE_RGB32_D3D_DX9_RT)    || \
                                     ((mt).subtype == MEDIASUBTYPE_RGB16_D3D_DX9_RT))


//
// DX-VA uncompressed surface formats
//

// 32315659-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_YV12
OUR_GUID_ENTRY(MEDIASUBTYPE_YV12,
0x32315659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 3231564E-0000-0010-8000-00AA00389B71  'NV12' ==  MEDIASUBTYPE_NV12
OUR_GUID_ENTRY(MEDIASUBTYPE_NV12,
0x3231564E, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 3131564E-0000-0010-8000-00AA00389B71  'NV11' ==  MEDIASUBTYPE_NV11
#ifndef MEDIASUBTYPE_NV11_DEFINED
#define MEDIASUBTYPE_NV11_DEFINED
OUR_GUID_ENTRY(MEDIASUBTYPE_NV11,
0x3131564E, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)
#endif

// 38303250-0000-0010-8000-00AA00389B71  'P208' ==  MEDIASUBTYPE_P208
OUR_GUID_ENTRY(MEDIASUBTYPE_P208,
'802P', 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 38303250-0000-0010-8000-00AA00389B71  'P210' ==  MEDIASUBTYPE_P210
OUR_GUID_ENTRY(MEDIASUBTYPE_P210,
'012P', 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 38303250-0000-0010-8000-00AA00389B71  'P216' ==  MEDIASUBTYPE_P216
OUR_GUID_ENTRY(MEDIASUBTYPE_P216,
'612P', 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 38303250-0000-0010-8000-00AA00389B71  'P010' ==  MEDIASUBTYPE_P010
OUR_GUID_ENTRY(MEDIASUBTYPE_P010,
'010P', 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 38303250-0000-0010-8000-00AA00389B71  'P016' ==  MEDIASUBTYPE_P016
OUR_GUID_ENTRY(MEDIASUBTYPE_P016,
'610P', 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 38303250-0000-0010-8000-00AA00389B71  'Y210' ==  MEDIASUBTYPE_Y210
OUR_GUID_ENTRY(MEDIASUBTYPE_Y210,
'012Y', 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 38303250-0000-0010-8000-00AA00389B71  'Y216' ==  MEDIASUBTYPE_Y216
OUR_GUID_ENTRY(MEDIASUBTYPE_Y216,
'612Y', 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 38303450-0000-0010-8000-00AA00389B71  'P408' ==  MEDIASUBTYPE_P408
OUR_GUID_ENTRY(MEDIASUBTYPE_P408,
'804P', 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 3231564E-0000-0010-8000-00AA00389B71  'NV24' ==  MEDIASUBTYPE_NV24
OUR_GUID_ENTRY(MEDIASUBTYPE_NV24,
0x3432564E, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 31434D49-0000-0010-8000-00AA00389B71  'IMC1' ==  MEDIASUBTYPE_IMC1
OUR_GUID_ENTRY(MEDIASUBTYPE_IMC1,
0x31434D49, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 32434d49-0000-0010-8000-00AA00389B71  'IMC2' ==  MEDIASUBTYPE_IMC2
OUR_GUID_ENTRY(MEDIASUBTYPE_IMC2,
0x32434D49, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 33434d49-0000-0010-8000-00AA00389B71  'IMC3' ==  MEDIASUBTYPE_IMC3
OUR_GUID_ENTRY(MEDIASUBTYPE_IMC3,
0x33434D49, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 34434d49-0000-0010-8000-00AA00389B71  'IMC4' ==  MEDIASUBTYPE_IMC4
OUR_GUID_ENTRY(MEDIASUBTYPE_IMC4,
0x34434D49, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 30343353-0000-0010-8000-00AA00389B71  'S340' ==  MEDIASUBTYPE_S340
OUR_GUID_ENTRY(MEDIASUBTYPE_S340,
0x30343353, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 32343353-0000-0010-8000-00AA00389B71  'S342' ==  MEDIASUBTYPE_S342
OUR_GUID_ENTRY(MEDIASUBTYPE_S342,
0x32343353, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)


// e436eb7f-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_Overlay
OUR_GUID_ENTRY(MEDIASUBTYPE_Overlay,
0xe436eb7f, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb80-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEGPacket
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Packet,
0xe436eb80, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb81-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1Payload
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Payload,
0xe436eb81, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 00000050-0000-0010-8000-00AA00389B71         MEDIASUBTYPE_MPEG1AudioPayload
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1AudioPayload,
0x00000050, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71)

// e436eb82-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1SystemStream
OUR_GUID_ENTRY(MEDIATYPE_MPEG1SystemStream,
0xe436eb82, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// the next consecutive number is assigned to MEDIATYPE_Stream and appears higher up
// e436eb84-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1System
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1System,
0xe436eb84, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb85-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1VideoCD
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1VideoCD,
0xe436eb85, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb86-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1Video
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Video,
0xe436eb86, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb87-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_MPEG1Audio
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG1Audio,
0xe436eb87, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb88-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_Avi
OUR_GUID_ENTRY(MEDIASUBTYPE_Avi,
0xe436eb88, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {3DB80F90-9412-11d1-ADED-0000F8754B99}          MEDIASUBTYPE_Asf
OUR_GUID_ENTRY(MEDIASUBTYPE_Asf,
0x3db80f90, 0x9412, 0x11d1, 0xad, 0xed, 0x0, 0x0, 0xf8, 0x75, 0x4b, 0x99)

// e436eb89-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_QTMovie
OUR_GUID_ENTRY(MEDIASUBTYPE_QTMovie,
0xe436eb89, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 617a7072-0000-0010-8000-00AA00389B71         MEDIASUBTYPE_Rpza
OUR_GUID_ENTRY(MEDIASUBTYPE_QTRpza,
0x617a7072, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 20636d73-0000-0010-8000-00AA00389B71         MEDIASUBTYPE_Smc
OUR_GUID_ENTRY(MEDIASUBTYPE_QTSmc,
0x20636d73, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 20656c72-0000-0010-8000-00AA00389B71        MEDIASUBTYPE_Rle
OUR_GUID_ENTRY(MEDIASUBTYPE_QTRle,
0x20656c72, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 6765706a-0000-0010-8000-00AA00389B71        MEDIASUBTYPE_Jpeg
OUR_GUID_ENTRY(MEDIASUBTYPE_QTJpeg,
0x6765706a, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// e436eb8a-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_PCMAudio_Obsolete
OUR_GUID_ENTRY(MEDIASUBTYPE_PCMAudio_Obsolete,
0xe436eb8a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 00000001-0000-0010-8000-00AA00389B71            MEDIASUBTYPE_PCM
OUR_GUID_ENTRY(MEDIASUBTYPE_PCM,
0x00000001, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71)

// e436eb8b-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_WAVE
OUR_GUID_ENTRY(MEDIASUBTYPE_WAVE,
0xe436eb8b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb8c-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_AU
OUR_GUID_ENTRY(MEDIASUBTYPE_AU,
0xe436eb8c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436eb8d-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_AIFF
OUR_GUID_ENTRY(MEDIASUBTYPE_AIFF,
0xe436eb8d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 64(d)73(s)76(v)64(d)-0000-0010-8000-00AA00389B71  'dvsd' == MEDIASUBTYPE_dvsd
OUR_GUID_ENTRY(MEDIASUBTYPE_dvsd,
0x64737664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 64(d)68(h)76(v)64(d)-0000-0010-8000-00AA00389B71  'dvhd' == MEDIASUBTYPE_dvhd
OUR_GUID_ENTRY(MEDIASUBTYPE_dvhd,
0x64687664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 6c(l)73(s)76(v)64(d)-0000-0010-8000-00AA00389B71  'dvsl' == MEDIASUBTYPE_dvsl
OUR_GUID_ENTRY(MEDIASUBTYPE_dvsl,
0x6c737664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 35(5)32(2)76(v)64(d)-0000-0010-8000-00AA00389B71  'dv25' ==  MEDIASUBTYPE_dv25
OUR_GUID_ENTRY(MEDIASUBTYPE_dv25,
0x35327664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 30(0)35(5)76(v)64(d)-0000-0010-8000-00AA00389B71  'dv50' ==  MEDIASUBTYPE_dv50
OUR_GUID_ENTRY(MEDIASUBTYPE_dv50,
0x30357664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 31(1)68(h)76(v)64(d)-0000-0010-8000-00AA00389B71  'dvh1' ==  MEDIASUBTYPE_dvh1
OUR_GUID_ENTRY(MEDIASUBTYPE_dvh1,
0x31687664, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// 6E8D4A22-310C-11d0-B79A-00AA003767A7         MEDIASUBTYPE_Line21_BytePair
OUR_GUID_ENTRY(MEDIASUBTYPE_Line21_BytePair,
0x6e8d4a22, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// 6E8D4A23-310C-11d0-B79A-00AA003767A7         MEDIASUBTYPE_Line21_GOPPacket
OUR_GUID_ENTRY(MEDIASUBTYPE_Line21_GOPPacket,
0x6e8d4a23, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// 6E8D4A24-310C-11d0-B79A-00AA003767A7         MEDIASUBTYPE_Line21_VBIRawData
OUR_GUID_ENTRY(MEDIASUBTYPE_Line21_VBIRawData,
0x6e8d4a24, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

//0AF414BC-4ED2-445e-9839-8F095568AB3C          MEDIASUBTYPE_708_608Data
OUR_GUID_ENTRY(MEDIASUBTYPE_708_608Data,
0xaf414bc, 0x4ed2, 0x445e, 0x98, 0x39, 0x8f, 0x9, 0x55, 0x68, 0xab, 0x3c)

// F52ADDAA-36F0-43F5-95EA-6D866484262A         MEDIASUBTYPE_DtvCcData
OUR_GUID_ENTRY(MEDIASUBTYPE_DtvCcData,
0xF52ADDAA, 0x36F0, 0x43F5, 0x95, 0xEA, 0x6D, 0x86, 0x64, 0x84, 0x26, 0x2A)

// 7EA626DB-54DA-437b-BE9F-F73073ADFA3C         MEDIASUBTYPE_CC_CONTAINER
OUR_GUID_ENTRY(MEDIASUBTYPE_CC_CONTAINER,
0x7ea626db, 0x54da, 0x437b, 0xbe, 0x9f, 0xf7, 0x30, 0x73, 0xad, 0xfa, 0x3c)

// F72A76E3-EB0A-11D0-ACE4-0000C0CC16BA         MEDIASUBTYPE_TELETEXT
OUR_GUID_ENTRY(MEDIASUBTYPE_TELETEXT,
0xf72a76e3, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// 663DA43C-03E8-4e9a-9CD5-BF11ED0DEF76         MEDIASUBTYPE_VBI
OUR_GUID_ENTRY(MEDIASUBTYPE_VBI,
0x663da43c, 0x3e8, 0x4e9a, 0x9c, 0xd5, 0xbf, 0x11, 0xed, 0xd, 0xef, 0x76)

// 2791D576-8E7A-466F-9E90-5D3F3083738B         MEDIASUBTYPE_WSS
OUR_GUID_ENTRY(MEDIASUBTYPE_WSS,
0x2791D576, 0x8E7A, 0x466F, 0x9E, 0x90, 0x5D, 0x3F, 0x30, 0x83, 0x73, 0x8B)

// 01CA73E3-DCE6-4575-AFE1-2BF1C902CAF3         MEDIASUBTYPE_XDS
OUR_GUID_ENTRY(MEDIASUBTYPE_XDS,
0x1ca73e3, 0xdce6, 0x4575, 0xaf, 0xe1, 0x2b, 0xf1, 0xc9, 0x2, 0xca, 0xf3)

// A1B3F620-9792-4d8d-81A4-86AF25772090         MEDIASUBTYPE_VPS
OUR_GUID_ENTRY(MEDIASUBTYPE_VPS,
0xa1b3f620, 0x9792, 0x4d8d, 0x81, 0xa4, 0x86, 0xaf, 0x25, 0x77, 0x20, 0x90)

// derived from WAVE_FORMAT_DRM
// 00000009-0000-0010-8000-00aa00389b71
OUR_GUID_ENTRY(MEDIASUBTYPE_DRM_Audio,
0x00000009, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// derived from WAVE_FORMAT_IEEE_FLOAT
// 00000003-0000-0010-8000-00aa00389b71
OUR_GUID_ENTRY(MEDIASUBTYPE_IEEE_FLOAT,
0x00000003, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// derived from WAVE_FORMAT_DOLBY_AC3_SPDIF
// 00000092-0000-0010-8000-00aa00389b71
OUR_GUID_ENTRY(MEDIASUBTYPE_DOLBY_AC3_SPDIF,
0x00000092, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// derived from WAVE_FORMAT_RAW_SPORT
// 00000240-0000-0010-8000-00aa00389b71
OUR_GUID_ENTRY(MEDIASUBTYPE_RAW_SPORT,
0x00000240, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)

// derived from wave format tag 0x241, call it SPDIF_TAG_241h for now
// 00000241-0000-0010-8000-00aa00389b71
OUR_GUID_ENTRY(MEDIASUBTYPE_SPDIF_TAG_241h,
0x00000241, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71)



// DirectShow DSS definitions

// A0AF4F81-E163-11d0-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_DssVideo,
0xa0af4f81, 0xe163, 0x11d0, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// A0AF4F82-E163-11d0-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_DssAudio,
0xa0af4f82, 0xe163, 0x11d0, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// 5A9B6A40-1A22-11D1-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_VPVideo,
0x5a9b6a40, 0x1a22, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// 5A9B6A41-1A22-11D1-BAD9-00609744111A
OUR_GUID_ENTRY(MEDIASUBTYPE_VPVBI,
0x5a9b6a41, 0x1a22, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// BF87B6E0-8C27-11d0-B3F0-00AA003761C5     Capture graph building
OUR_GUID_ENTRY(CLSID_CaptureGraphBuilder,
0xBF87B6E0, 0x8C27, 0x11d0, 0xB3, 0xF0, 0x0, 0xAA, 0x00, 0x37, 0x61, 0xC5)

// BF87B6E1-8C27-11d0-B3F0-00AA003761C5     New Capture graph building
OUR_GUID_ENTRY(CLSID_CaptureGraphBuilder2,
0xBF87B6E1, 0x8C27, 0x11d0, 0xB3, 0xF0, 0x0, 0xAA, 0x00, 0x37, 0x61, 0xC5)

// e436ebb0-524f-11ce-9f53-0020af0ba770            Prototype filtergraph
OUR_GUID_ENTRY(CLSID_ProtoFilterGraph,
0xe436ebb0, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb1-524f-11ce-9f53-0020af0ba770            Reference clock
OUR_GUID_ENTRY(CLSID_SystemClock,
0xe436ebb1, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb2-524f-11ce-9f53-0020af0ba770           Filter Mapper
OUR_GUID_ENTRY(CLSID_FilterMapper,
0xe436ebb2, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb3-524f-11ce-9f53-0020af0ba770           Filter Graph
OUR_GUID_ENTRY(CLSID_FilterGraph,
0xe436ebb3, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// e436ebb8-524f-11ce-9f53-0020af0ba770           Filter Graph no thread
OUR_GUID_ENTRY(CLSID_FilterGraphNoThread,
0xe436ebb8, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// a3ecbc41-581a-4476-b693-a63340462d8b
OUR_GUID_ENTRY(CLSID_FilterGraphPrivateThread,
0xa3ecbc41, 0x581a, 0x4476, 0xb6, 0x93, 0xa6, 0x33, 0x40, 0x46, 0x2d, 0x8b)

// e4bbd160-4269-11ce-838d-00aa0055595a           MPEG System stream
OUR_GUID_ENTRY(CLSID_MPEG1Doc,
0xe4bbd160, 0x4269, 0x11ce, 0x83, 0x8d, 0x0, 0xaa, 0x0, 0x55, 0x59, 0x5a)

// 701722e0-8ae3-11ce-a85c-00aa002feab5           MPEG file reader
OUR_GUID_ENTRY(CLSID_FileSource,
0x701722e0, 0x8ae3, 0x11ce, 0xa8, 0x5c, 0x00, 0xaa, 0x00, 0x2f, 0xea, 0xb5)

// 26C25940-4CA9-11ce-A828-00AA002FEAB5           Takes MPEG1 packets as input
OUR_GUID_ENTRY(CLSID_MPEG1PacketPlayer,
0x26c25940, 0x4ca9, 0x11ce, 0xa8, 0x28, 0x0, 0xaa, 0x0, 0x2f, 0xea, 0xb5)

// 336475d0-942a-11ce-a870-00aa002feab5           MPEG splitter
OUR_GUID_ENTRY(CLSID_MPEG1Splitter,
0x336475d0, 0x942a, 0x11ce, 0xa8, 0x70, 0x00, 0xaa, 0x00, 0x2f, 0xea, 0xb5)

// feb50740-7bef-11ce-9bd9-0000e202599c           MPEG video decoder
OUR_GUID_ENTRY(CLSID_CMpegVideoCodec,
0xfeb50740, 0x7bef, 0x11ce, 0x9b, 0xd9, 0x0, 0x0, 0xe2, 0x2, 0x59, 0x9c)

// 4a2286e0-7bef-11ce-9bd9-0000e202599c           MPEG audio decoder
OUR_GUID_ENTRY(CLSID_CMpegAudioCodec,
0x4a2286e0, 0x7bef, 0x11ce, 0x9b, 0xd9, 0x0, 0x0, 0xe2, 0x2, 0x59, 0x9c)

// e30629d3-27e5-11ce-875d-00608cb78066           Text renderer
OUR_GUID_ENTRY(CLSID_TextRender,
0xe30629d3, 0x27e5, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66)



// {F8388A40-D5BB-11d0-BE5A-0080C706568E}
OUR_GUID_ENTRY(CLSID_InfTee,
0xf8388a40, 0xd5bb, 0x11d0, 0xbe, 0x5a, 0x0, 0x80, 0xc7, 0x6, 0x56, 0x8e)

// 1b544c20-fd0b-11ce-8c63-00aa0044b51e           Avi Stream Splitter
OUR_GUID_ENTRY(CLSID_AviSplitter,
0x1b544c20, 0xfd0b, 0x11ce, 0x8c, 0x63, 0x0, 0xaa, 0x00, 0x44, 0xb5, 0x1e)

// 1b544c21-fd0b-11ce-8c63-00aa0044b51e           Avi File Reader
OUR_GUID_ENTRY(CLSID_AviReader,
0x1b544c21, 0xfd0b, 0x11ce, 0x8c, 0x63, 0x0, 0xaa, 0x00, 0x44, 0xb5, 0x1e)

// 1b544c22-fd0b-11ce-8c63-00aa0044b51e           Vfw 2.0 Capture Driver
OUR_GUID_ENTRY(CLSID_VfwCapture,
0x1b544c22, 0xfd0b, 0x11ce, 0x8c, 0x63, 0x0, 0xaa, 0x00, 0x44, 0xb5, 0x1e)

OUR_GUID_ENTRY(CLSID_CaptureProperties,
0x1B544c22, 0xFD0B, 0x11ce, 0x8C, 0x63, 0x00, 0xAA, 0x00, 0x44, 0xB5, 0x1F)

//e436ebb4-524f-11ce-9f53-0020af0ba770            Control Distributor
OUR_GUID_ENTRY(CLSID_FGControl,
0xe436ebb4, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// 44584800-F8EE-11ce-B2D4-00DD01101B85           .MOV reader (old)
OUR_GUID_ENTRY(CLSID_MOVReader,
0x44584800, 0xf8ee, 0x11ce, 0xb2, 0xd4, 0x00, 0xdd, 0x1, 0x10, 0x1b, 0x85)

// D51BD5A0-7548-11cf-A520-0080C77EF58A           QT Splitter
OUR_GUID_ENTRY(CLSID_QuickTimeParser,
0xd51bd5a0, 0x7548, 0x11cf, 0xa5, 0x20, 0x0, 0x80, 0xc7, 0x7e, 0xf5, 0x8a)

// FDFE9681-74A3-11d0-AFA7-00AA00B67A42           QT Decoder
OUR_GUID_ENTRY(CLSID_QTDec,
0xfdfe9681, 0x74a3, 0x11d0, 0xaf, 0xa7, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// D3588AB0-0781-11ce-B03A-0020AF0BA770           AVIFile-based reader
OUR_GUID_ENTRY(CLSID_AVIDoc,
0xd3588ab0, 0x0781, 0x11ce, 0xb0, 0x3a, 0x00, 0x20, 0xaf, 0xb, 0xa7, 0x70)

// 70e102b0-5556-11ce-97c0-00aa0055595a           Video renderer
OUR_GUID_ENTRY(CLSID_VideoRenderer,
0x70e102b0, 0x5556, 0x11ce, 0x97, 0xc0, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 1643e180-90f5-11ce-97d5-00aa0055595a           Colour space convertor
OUR_GUID_ENTRY(CLSID_Colour,
0x1643e180, 0x90f5, 0x11ce, 0x97, 0xd5, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 1da08500-9edc-11cf-bc10-00aa00ac74f6           VGA 16 color ditherer
OUR_GUID_ENTRY(CLSID_Dither,
0x1da08500, 0x9edc, 0x11cf, 0xbc, 0x10, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6)

// 07167665-5011-11cf-BF33-00AA0055595A           Modex video renderer
OUR_GUID_ENTRY(CLSID_ModexRenderer,
0x7167665, 0x5011, 0x11cf, 0xbf, 0x33, 0x0, 0xaa, 0x0, 0x55, 0x59, 0x5a)

// e30629d1-27e5-11ce-875d-00608cb78066           Waveout audio renderer
OUR_GUID_ENTRY(CLSID_AudioRender,
0xe30629d1, 0x27e5, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66)

// 05589faf-c356-11ce-bf01-00aa0055595a           Audio Renderer Property Page
OUR_GUID_ENTRY(CLSID_AudioProperties,
0x05589faf, 0xc356, 0x11ce, 0xbf, 0x01, 0x0, 0xaa, 0x0, 0x55, 0x59, 0x5a)

// 79376820-07D0-11cf-A24D-0020AFD79767           DSound audio renderer
OUR_GUID_ENTRY(CLSID_DSoundRender,
0x79376820, 0x07D0, 0x11CF, 0xA2, 0x4D, 0x0, 0x20, 0xAF, 0xD7, 0x97, 0x67)

// e30629d2-27e5-11ce-875d-00608cb78066           Wavein audio recorder
OUR_GUID_ENTRY(CLSID_AudioRecord,
0xe30629d2, 0x27e5, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66)

// {2CA8CA52-3C3F-11d2-B73D-00C04FB6BD3D}         IAMAudioInputMixer property page
OUR_GUID_ENTRY(CLSID_AudioInputMixerProperties,
0x2ca8ca52, 0x3c3f, 0x11d2, 0xb7, 0x3d, 0x0, 0xc0, 0x4f, 0xb6, 0xbd, 0x3d)

// {CF49D4E0-1115-11ce-B03A-0020AF0BA770}         AVI Decoder
OUR_GUID_ENTRY(CLSID_AVIDec,
0xcf49d4e0, 0x1115, 0x11ce, 0xb0, 0x3a, 0x0, 0x20, 0xaf, 0xb, 0xa7, 0x70)

// {A888DF60-1E90-11cf-AC98-00AA004C0FA9}         AVI ICDraw* wrapper
OUR_GUID_ENTRY(CLSID_AVIDraw,
0xa888df60, 0x1e90, 0x11cf, 0xac, 0x98, 0x0, 0xaa, 0x0, 0x4c, 0xf, 0xa9)

// 6a08cf80-0e18-11cf-a24d-0020afd79767       ACM Wrapper
OUR_GUID_ENTRY(CLSID_ACMWrapper,
0x6a08cf80, 0x0e18, 0x11cf, 0xa2, 0x4d, 0x0, 0x20, 0xaf, 0xd7, 0x97, 0x67)

// {e436ebb5-524f-11ce-9f53-0020af0ba770}    Async File Reader
OUR_GUID_ENTRY(CLSID_AsyncReader,
0xe436ebb5, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {e436ebb6-524f-11ce-9f53-0020af0ba770}    Async URL Reader
OUR_GUID_ENTRY(CLSID_URLReader,
0xe436ebb6, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {e436ebb7-524f-11ce-9f53-0020af0ba770}    IPersistMoniker PID
OUR_GUID_ENTRY(CLSID_PersistMonikerPID,
0xe436ebb7, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70)

// {D76E2820-1563-11cf-AC98-00AA004C0FA9}
OUR_GUID_ENTRY(CLSID_AVICo,
0xd76e2820, 0x1563, 0x11cf, 0xac, 0x98, 0x0, 0xaa, 0x0, 0x4c, 0xf, 0xa9)

// {8596E5F0-0DA5-11d0-BD21-00A0C911CE86}
OUR_GUID_ENTRY(CLSID_FileWriter,
0x8596e5f0, 0xda5, 0x11d0, 0xbd, 0x21, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// {E2510970-F137-11CE-8B67-00AA00A3F1A6}     AVI mux filter
OUR_GUID_ENTRY(CLSID_AviDest,
0xe2510970, 0xf137, 0x11ce, 0x8b, 0x67, 0x0, 0xaa, 0x0, 0xa3, 0xf1, 0xa6)

// {C647B5C0-157C-11d0-BD23-00A0C911CE86}
OUR_GUID_ENTRY(CLSID_AviMuxProptyPage,
0xc647b5c0, 0x157c, 0x11d0, 0xbd, 0x23, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// {0A9AE910-85C0-11d0-BD42-00A0C911CE86}
OUR_GUID_ENTRY(CLSID_AviMuxProptyPage1,
0xa9ae910, 0x85c0, 0x11d0, 0xbd, 0x42, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// {07b65360-c445-11ce-afde-00aa006c14f4}
OUR_GUID_ENTRY(CLSID_AVIMIDIRender,
0x07b65360, 0xc445, 0x11ce, 0xaf, 0xde, 0x00, 0xaa, 0x00, 0x6c, 0x14, 0xf4)

// {187463A0-5BB7-11d3-ACBE-0080C75E246E}    WMSDK-based ASF reader
OUR_GUID_ENTRY(CLSID_WMAsfReader,
0x187463a0, 0x5bb7, 0x11d3, 0xac, 0xbe, 0x0, 0x80, 0xc7, 0x5e, 0x24, 0x6e)

// {7c23220e-55bb-11d3-8b16-00c04fb6bd3d}    WMSDK-based ASF writer
OUR_GUID_ENTRY(CLSID_WMAsfWriter,
0x7c23220e, 0x55bb, 0x11d3, 0x8b, 0x16, 0x0, 0xc0, 0x4f, 0xb6, 0xbd, 0x3d)

//  {afb6c280-2c41-11d3-8a60-0000f81e0e4a}
OUR_GUID_ENTRY(CLSID_MPEG2Demultiplexer,
0xafb6c280, 0x2c41, 0x11d3, 0x8a, 0x60, 0x00, 0x00, 0xf8, 0x1e, 0x0e, 0x4a)

// {687D3367-3644-467a-ADFE-6CD7A85C4A2C}
OUR_GUID_ENTRY(CLSID_MPEG2Demultiplexer_NoClock, 
0x687d3367, 0x3644, 0x467a, 0xad, 0xfe, 0x6c, 0xd7, 0xa8, 0x5c, 0x4a, 0x2c)

// {3ae86b20-7be8-11d1-abe6-00a0c905f375}
OUR_GUID_ENTRY(CLSID_MMSPLITTER,
0x3ae86b20, 0x7be8, 0x11d1, 0xab, 0xe6, 0x00, 0xa0, 0xc9, 0x05, 0xf3, 0x75)

// {2DB47AE5-CF39-43c2-B4D6-0CD8D90946F4}
OUR_GUID_ENTRY(CLSID_StreamBufferSink,
0x2db47ae5, 0xcf39, 0x43c2, 0xb4, 0xd6, 0xc, 0xd8, 0xd9, 0x9, 0x46, 0xf4)

// {E2448508-95DA-4205-9A27-7EC81E723B1A}
OUR_GUID_ENTRY(CLSID_SBE2Sink,
0xe2448508, 0x95da, 0x4205, 0x9a, 0x27, 0x7e, 0xc8, 0x1e, 0x72, 0x3b, 0x1a)

// {C9F5FE02-F851-4eb5-99EE-AD602AF1E619}
OUR_GUID_ENTRY(CLSID_StreamBufferSource,
0xc9f5fe02, 0xf851, 0x4eb5, 0x99, 0xee, 0xad, 0x60, 0x2a, 0xf1, 0xe6, 0x19)

// {FA8A68B2-C864-4ba2-AD53-D3876A87494B}
OUR_GUID_ENTRY(CLSID_StreamBufferConfig,
0xfa8a68b2, 0xc864, 0x4ba2, 0xad, 0x53, 0xd3, 0x87, 0x6a, 0x87, 0x49, 0x4b)

// {E37A73F8-FB01-43dc-914E-AAEE76095AB9}
OUR_GUID_ENTRY(CLSID_StreamBufferPropertyHandler,
0xe37a73f8, 0xfb01, 0x43dc, 0x91, 0x4e, 0xaa, 0xee, 0x76, 0x9, 0x5a, 0xb9)

// {713790EE-5EE1-45ba-8070-A1337D2762FA}
OUR_GUID_ENTRY(CLSID_StreamBufferThumbnailHandler,
0x713790ee, 0x5ee1, 0x45ba, 0x80, 0x70, 0xa1, 0x33, 0x7d, 0x27, 0x62, 0xfa)

// {6CFAD761-735D-4aa5-8AFC-AF91A7D61EBA}
OUR_GUID_ENTRY(CLSID_Mpeg2VideoStreamAnalyzer,
0x6cfad761, 0x735d, 0x4aa5, 0x8a, 0xfc, 0xaf, 0x91, 0xa7, 0xd6, 0x1e, 0xba)

// {CCAA63AC-1057-4778-AE92-1206AB9ACEE6}
OUR_GUID_ENTRY(CLSID_StreamBufferRecordingAttributes,
0xccaa63ac, 0x1057, 0x4778, 0xae, 0x92, 0x12, 0x6, 0xab, 0x9a, 0xce, 0xe6)

// {D682C4BA-A90A-42fe-B9E1-03109849C423}
OUR_GUID_ENTRY(CLSID_StreamBufferComposeRecording,
0xd682c4ba, 0xa90a, 0x42fe, 0xb9, 0xe1, 0x3, 0x10, 0x98, 0x49, 0xc4, 0x23)

// {93A094D7-51E8-485b-904A-8D6B97DC6B39}
OUR_GUID_ENTRY(CLSID_SBE2File,
0x93a094d7, 0x51e8, 0x485b, 0x90, 0x4a, 0x8d, 0x6b, 0x97, 0xdc, 0x6b, 0x39)

// {B1B77C00-C3E4-11cf-AF79-00AA00B67A42}               DV video decoder
OUR_GUID_ENTRY(CLSID_DVVideoCodec,
0xb1b77c00, 0xc3e4, 0x11cf, 0xaf, 0x79, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {13AA3650-BB6F-11d0-AFB9-00AA00B67A42}               DV video encoder
OUR_GUID_ENTRY(CLSID_DVVideoEnc,
0x13aa3650, 0xbb6f, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {4EB31670-9FC6-11cf-AF6E-00AA00B67A42}               DV splitter
OUR_GUID_ENTRY(CLSID_DVSplitter,
0x4eb31670, 0x9fc6, 0x11cf, 0xaf, 0x6e, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {129D7E40-C10D-11d0-AFB9-00AA00B67A42}               DV muxer
OUR_GUID_ENTRY(CLSID_DVMux,
0x129d7e40, 0xc10d, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {060AF76C-68DD-11d0-8FC1-00C04FD9189D}
OUR_GUID_ENTRY(CLSID_SeekingPassThru,
0x60af76c, 0x68dd, 0x11d0, 0x8f, 0xc1, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d)

// 6E8D4A20-310C-11d0-B79A-00AA003767A7                 Line21 (CC) Decoder
OUR_GUID_ENTRY(CLSID_Line21Decoder,
0x6e8d4a20, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// E4206432-01A1-4BEE-B3E1-3702C8EDC574                 Line21 (CC) Decoder v2
OUR_GUID_ENTRY(CLSID_Line21Decoder2,
0xe4206432, 0x01a1, 0x4bee, 0xb3, 0xe1, 0x37, 0x02, 0xc8, 0xed, 0xc5, 0x74)

OUR_GUID_ENTRY(CLSID_CCAFilter,
0x3d07a539, 0x35ca, 0x447c, 0x9b, 0x5,  0x8d, 0x85, 0xce, 0x92,  0x4f,  0x9e)

// {CD8743A1-3736-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(CLSID_OverlayMixer,
0xcd8743a1, 0x3736, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {814B9800-1C88-11d1-BAD9-00609744111A}
OUR_GUID_ENTRY(CLSID_VBISurfaces,
0x814b9800, 0x1c88, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {70BC06E0-5666-11d3-A184-00105AEF9F33}               WST Teletext Decoder
OUR_GUID_ENTRY(CLSID_WSTDecoder,
0x70bc06e0, 0x5666, 0x11d3, 0xa1, 0x84, 0x0, 0x10, 0x5a, 0xef, 0x9f, 0x33)

// {301056D0-6DFF-11d2-9EEB-006008039E37}
OUR_GUID_ENTRY(CLSID_MjpegDec,
0x301056d0, 0x6dff, 0x11d2, 0x9e, 0xeb, 0x0, 0x60, 0x8, 0x3, 0x9e, 0x37)

// {B80AB0A0-7416-11d2-9EEB-006008039E37}
OUR_GUID_ENTRY(CLSID_MJPGEnc,
0xb80ab0a0, 0x7416, 0x11d2, 0x9e, 0xeb, 0x0, 0x60, 0x8, 0x3, 0x9e, 0x37)



// pnp objects and categories
// 62BE5D10-60EB-11d0-BD3B-00A0C911CE86                 ICreateDevEnum
OUR_GUID_ENTRY(CLSID_SystemDeviceEnum,
0x62BE5D10,0x60EB,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 4315D437-5B8C-11d0-BD3B-00A0C911CE86
OUR_GUID_ENTRY(CLSID_CDeviceMoniker,
0x4315D437,0x5B8C,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 860BB310-5D01-11d0-BD3B-00A0C911CE86                 Video capture category
OUR_GUID_ENTRY(CLSID_VideoInputDeviceCategory,
0x860BB310,0x5D01,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)
OUR_GUID_ENTRY(CLSID_CVidCapClassManager,
0x860BB310,0x5D01,0x11d0,0xBD,0x3B,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 083863F1-70DE-11d0-BD40-00A0C911CE86                 Filter category
OUR_GUID_ENTRY(CLSID_LegacyAmFilterCategory,
0x083863F1,0x70DE,0x11d0,0xBD,0x40,0x00,0xA0,0xC9,0x11,0xCE,0x86)
OUR_GUID_ENTRY(CLSID_CQzFilterClassManager,
0x083863F1,0x70DE,0x11d0,0xBD,0x40,0x00,0xA0,0xC9,0x11,0xCE,0x86)

// 33D9A760-90C8-11d0-BD43-00A0C911CE86
OUR_GUID_ENTRY(CLSID_VideoCompressorCategory,
0x33d9a760, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CIcmCoClassManager,
0x33d9a760, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 33D9A761-90C8-11d0-BD43-00A0C911CE86
OUR_GUID_ENTRY(CLSID_AudioCompressorCategory,
0x33d9a761, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CAcmCoClassManager,
0x33d9a761, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 33D9A762-90C8-11d0-BD43-00A0C911CE86                 Audio source cateogry
OUR_GUID_ENTRY(CLSID_AudioInputDeviceCategory,
0x33d9a762, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CWaveinClassManager,
0x33d9a762, 0x90c8, 0x11d0, 0xbd, 0x43, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// E0F158E1-CB04-11d0-BD4E-00A0C911CE86                 Audio renderer category
OUR_GUID_ENTRY(CLSID_AudioRendererCategory,
0xe0f158e1, 0xcb04, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)
OUR_GUID_ENTRY(CLSID_CWaveOutClassManager,
0xe0f158e1, 0xcb04, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 4EFE2452-168A-11d1-BC76-00C04FB9453B                 Midi renderer category
OUR_GUID_ENTRY(CLSID_MidiRendererCategory,
0x4EfE2452, 0x168A, 0x11d1, 0xBC, 0x76, 0x0, 0xc0, 0x4F, 0xB9, 0x45, 0x3B)
OUR_GUID_ENTRY(CLSID_CMidiOutClassManager,
0x4EfE2452, 0x168A, 0x11d1, 0xBC, 0x76, 0x0, 0xc0, 0x4F, 0xB9, 0x45, 0x3B)

// CC7BFB41-F175-11d1-A392-00E0291F3959     External Renderers Category
OUR_GUID_ENTRY(CLSID_TransmitCategory,
0xcc7bfb41, 0xf175, 0x11d1, 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59)

// CC7BFB46-F175-11d1-A392-00E0291F3959     Device Control Filters
OUR_GUID_ENTRY(CLSID_DeviceControlCategory,
0xcc7bfb46, 0xf175, 0x11d1, 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59)

// DA4E3DA0-D07D-11d0-BD50-00A0C911CE86
OUR_GUID_ENTRY(CLSID_ActiveMovieCategories,
0xda4e3da0, 0xd07d, 0x11d0, 0xbd, 0x50, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// 2721AE20-7E70-11D0-A5D6-28DB04C10000
OUR_GUID_ENTRY(CLSID_DVDHWDecodersCategory,
0x2721AE20, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00)

// 7D22E920-5CA9-4787-8C2B-A6779BD11781     Encoder API encoder category
OUR_GUID_ENTRY(CLSID_MediaEncoderCategory,
0x7D22E920, 0x5CA9, 0x4787, 0x8C, 0x2B, 0xA6, 0x77, 0x9B, 0xD1, 0x17, 0x81)

// 236C9559-ADCE-4736-BF72-BAB34E392196     Encoder API multiplexer category
OUR_GUID_ENTRY(CLSID_MediaMultiplexerCategory,
0x236C9559, 0xADCE, 0x4736, 0xBF, 0x72, 0xBA, 0xB3, 0x4E, 0x39, 0x21, 0x96)

// CDA42200-BD88-11d0-BD4E-00A0C911CE86
OUR_GUID_ENTRY(CLSID_FilterMapper2,
0xcda42200, 0xbd88, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)


// 1e651cc0-b199-11d0-8212-00c04fc32c45
OUR_GUID_ENTRY(CLSID_MemoryAllocator,
0x1e651cc0, 0xb199, 0x11d0, 0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45)

// CDBD8D00-C193-11d0-BD4E-00A0C911CE86
OUR_GUID_ENTRY(CLSID_MediaPropertyBag,
0xcdbd8d00, 0xc193, 0x11d0, 0xbd, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0xce, 0x86)

// FCC152B7-F372-11d0-8E00-00C04FD7C08B
OUR_GUID_ENTRY(CLSID_DvdGraphBuilder,
0xFCC152B7, 0xF372, 0x11d0, 0x8E, 0x00, 0x00, 0xC0, 0x4F, 0xD7, 0xC0, 0x8B)

// 9B8C4620-2C1A-11d0-8493-00A02438AD48
OUR_GUID_ENTRY(CLSID_DVDNavigator,
0x9b8c4620, 0x2c1a, 0x11d0, 0x84, 0x93, 0x0, 0xa0, 0x24, 0x38, 0xad, 0x48)

// f963c5cf-a659-4a93-9638-caf3cd277d13
OUR_GUID_ENTRY(CLSID_DVDState,
0xf963c5cf, 0xa659, 0x4a93, 0x96, 0x38, 0xca, 0xf3, 0xcd, 0x27, 0x7d, 0x13)

// CC58E280-8AA1-11d1-B3F1-00AA003761C5
OUR_GUID_ENTRY(CLSID_SmartTee,
0xcc58e280, 0x8aa1, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// FB056BA0-2502-45B9-8E86-2B40DE84AD29
OUR_GUID_ENTRY(CLSID_DtvCcFilter,
0xfb056ba0, 0x2502, 0x45b9, 0x8e, 0x86, 0x2b, 0x40, 0xde, 0x84, 0xad, 0x29)

// 2F7EE4B6-6FF5-4EB4-B24A-2BFC41117171
OUR_GUID_ENTRY(CLSID_CaptionsFilter,
0x2F7EE4B6, 0x6FF5, 0x4EB4, 0xB2, 0x4A, 0x2B, 0xFC, 0x41, 0x11, 0x71, 0x71)

// {9F22CFEA-CE07-41ab-8BA0-C7364AF90AF9}
OUR_GUID_ENTRY(CLSID_SubtitlesFilter,
0x9f22cfea, 0xce07, 0x41ab, 0x8b, 0xa0, 0xc7, 0x36, 0x4a, 0xf9, 0x0a, 0xf9)

// {8670C736-F614-427b-8ADA-BBADC587194B}
OUR_GUID_ENTRY(CLSID_DirectShowPluginControl, 
0x8670c736, 0xf614, 0x427b, 0x8a, 0xda, 0xbb, 0xad, 0xc5, 0x87, 0x19, 0x4b)


// -- format types ---

// 0F6417D6-C318-11D0-A43F-00A0C9223196        FORMAT_None
OUR_GUID_ENTRY(FORMAT_None,
0x0F6417D6, 0xc318, 0x11d0, 0xa4, 0x3f, 0x00, 0xa0, 0xc9, 0x22, 0x31, 0x96)

// 05589f80-c356-11ce-bf01-00aa0055595a        FORMAT_VideoInfo
OUR_GUID_ENTRY(FORMAT_VideoInfo,
0x05589f80, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// F72A76A0-EB0A-11d0-ACE4-0000C0CC16BA        FORMAT_VideoInfo2
OUR_GUID_ENTRY(FORMAT_VideoInfo2,
0xf72a76A0, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// 05589f81-c356-11ce-bf01-00aa0055595a        FORMAT_WaveFormatEx
OUR_GUID_ENTRY(FORMAT_WaveFormatEx,
0x05589f81, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 05589f82-c356-11ce-bf01-00aa0055595a        FORMAT_MPEGVideo
OUR_GUID_ENTRY(FORMAT_MPEGVideo,
0x05589f82, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 05589f83-c356-11ce-bf01-00aa0055595a        FORMAT_MPEGStreams
OUR_GUID_ENTRY(FORMAT_MPEGStreams,
0x05589f83, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 05589f84-c356-11ce-bf01-00aa0055595a        FORMAT_DvInfo, DVINFO
OUR_GUID_ENTRY(FORMAT_DvInfo,
0x05589f84, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// C7ECF04D-4582-4869-9ABB-BFB523B62EDF       FORMAT_525WSS
OUR_GUID_ENTRY(FORMAT_525WSS,
0xc7ecf04d, 0x4582, 0x4869, 0x9a, 0xbb, 0xbf, 0xb5, 0x23, 0xb6, 0x2e, 0xdf)

// -- Video related GUIDs ---

// 944d4c00-dd52-11ce-bf0e-00aa0055595a
OUR_GUID_ENTRY(CLSID_DirectDrawProperties,
0x944d4c00, 0xdd52, 0x11ce, 0xbf, 0x0e, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 59ce6880-acf8-11cf-b56e-0080c7c4b68a
OUR_GUID_ENTRY(CLSID_PerformanceProperties,
0x59ce6880, 0xacf8, 0x11cf, 0xb5, 0x6e, 0x00, 0x80, 0xc7, 0xc4, 0xb6, 0x8a)

// 418afb70-f8b8-11ce-aac6-0020af0b99a3
OUR_GUID_ENTRY(CLSID_QualityProperties,
0x418afb70, 0xf8b8, 0x11ce, 0xaa, 0xc6, 0x00, 0x20, 0xaf, 0x0b, 0x99, 0xa3)

// 61ded640-e912-11ce-a099-00aa00479a58
OUR_GUID_ENTRY(IID_IBaseVideoMixer,
0x61ded640, 0xe912, 0x11ce, 0xa0, 0x99, 0x00, 0xaa, 0x00, 0x47, 0x9a, 0x58)

// 36d39eb0-dd75-11ce-bf0e-00aa0055595a
OUR_GUID_ENTRY(IID_IDirectDrawVideo,
0x36d39eb0, 0xdd75, 0x11ce, 0xbf, 0x0e, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// bd0ecb0-f8e2-11ce-aac6-0020af0b99a3
OUR_GUID_ENTRY(IID_IQualProp,
0x1bd0ecb0, 0xf8e2, 0x11ce, 0xaa, 0xc6, 0x00, 0x20, 0xaf, 0x0b, 0x99, 0xa3)

// {CE292861-FC88-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(CLSID_VPObject,
0xce292861, 0xfc88, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {CE292862-FC88-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPObject,
0xce292862, 0xfc88, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {25DF12C1-3DE0-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPControl,
0x25df12c1, 0x3de0, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {814B9801-1C88-11d1-BAD9-00609744111A}
OUR_GUID_ENTRY(CLSID_VPVBIObject,
0x814b9801, 0x1c88, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {814B9802-1C88-11d1-BAD9-00609744111A}
OUR_GUID_ENTRY(IID_IVPVBIObject,
0x814b9802, 0x1c88, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {BC29A660-30E3-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPConfig,
0xbc29a660, 0x30e3, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {C76794A1-D6C5-11d0-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPNotify,
0xc76794a1, 0xd6c5, 0x11d0, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {EBF47183-8764-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IVPNotify2,
0xebf47183, 0x8764, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)


// {EC529B00-1A1F-11D1-BAD9-00609744111A}
OUR_GUID_ENTRY(IID_IVPVBIConfig,
0xec529b00, 0x1a1f, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {EC529B01-1A1F-11D1-BAD9-00609744111A}
OUR_GUID_ENTRY(IID_IVPVBINotify,
0xec529b01, 0x1a1f, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a)

// {593CDDE1-0759-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IMixerPinConfig,
0x593cdde1, 0x759, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)

// {EBF47182-8764-11d1-9E69-00C04FD7C15B}
OUR_GUID_ENTRY(IID_IMixerPinConfig2,
0xebf47182, 0x8764, 0x11d1, 0x9e, 0x69, 0x0, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b)


// This is a real pain in the neck. The OLE GUIDs are separated out into a
// different file from the main header files. The header files can then be
// included multiple times and are protected with the following statements,
//
//      #ifndef __SOMETHING_DEFINED__
//      #define __SOMETHING_DEFINED__
//          all the header contents
//      #endif // __SOMETHING_DEFINED__
//
// When the actual GUIDs are to be defined (using initguid) the GUID header
// file can then be included to really define them just once. Unfortunately
// DirectDraw has the GUIDs defined in the main header file. So if the base
// classes bring in ddraw.h to get at the DirectDraw structures and so on
// nobody would then be able to really include ddraw.h to allocate the GUID
// memory structures because of the aforementioned header file protection
// Therefore the DirectDraw GUIDs are defined and allocated for real here

#ifndef __DDRAW_INCLUDED__
OUR_GUID_ENTRY(CLSID_DirectDraw,            0xD7B70EE0,0x4340,0x11CF,0xB0,0x63,0x00,0x20,0xAF,0xC2,0xCD,0x35)
OUR_GUID_ENTRY(CLSID_DirectDrawClipper,     0x593817A0,0x7DB3,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xb9,0x33,0x56)
OUR_GUID_ENTRY(IID_IDirectDraw,             0x6C14DB80,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDraw2,            0xB3A6F3E0,0x2B43,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xB9,0x33,0x56)
OUR_GUID_ENTRY(IID_IDirectDrawSurface,      0x6C14DB81,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDrawSurface2,     0x57805885,0x6eec,0x11cf,0x94,0x41,0xa8,0x23,0x03,0xc1,0x0e,0x27)
OUR_GUID_ENTRY(IID_IDirectDrawSurface3,     0xDA044E00,0x69B2,0x11D0,0xA1,0xD5,0x00,0xAA,0x00,0xB8,0xDF,0xBB)
OUR_GUID_ENTRY(IID_IDirectDrawSurface4,     0x0B2B8630,0xAD35,0x11D0,0x8E,0xA6,0x00,0x60,0x97,0x97,0xEA,0x5B)
OUR_GUID_ENTRY(IID_IDirectDrawSurface7,     0x06675a80,0x3b9b,0x11d2,0xb9,0x2f,0x00,0x60,0x97,0x97,0xea,0x5b)
OUR_GUID_ENTRY(IID_IDirectDrawPalette,      0x6C14DB84,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDrawClipper,      0x6C14DB85,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDrawColorControl, 0x4B9F0EE0,0x0D7E,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8)
#endif

#ifndef __DVP_INCLUDED__
OUR_GUID_ENTRY(IID_IDDVideoPortContainer,    0x6C142760,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
#endif

#ifndef __DDKM_INCLUDED__
OUR_GUID_ENTRY(IID_IDirectDrawKernel,        0x8D56C120,0x6A08,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8)
OUR_GUID_ENTRY(IID_IDirectDrawSurfaceKernel, 0x60755DA0,0x6A40,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8)
#endif

// 0618aa30-6bc4-11cf-bf36-00aa0055595a
OUR_GUID_ENTRY(CLSID_ModexProperties,
0x0618aa30, 0x6bc4, 0x11cf, 0xbf, 0x36, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// dd1d7110-7836-11cf-bf47-00aa0055595a
OUR_GUID_ENTRY(IID_IFullScreenVideo,
0xdd1d7110, 0x7836, 0x11cf, 0xbf, 0x47, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a)

// 53479470-f1dd-11cf-bc42-00aa00ac74f6
OUR_GUID_ENTRY(IID_IFullScreenVideoEx,
0x53479470, 0xf1dd, 0x11cf, 0xbc, 0x42, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6)

// {101193C0-0BFE-11d0-AF91-00AA00B67A42}           DV decoder property
OUR_GUID_ENTRY(CLSID_DVDecPropertiesPage,
0x101193c0, 0xbfe, 0x11d0, 0xaf, 0x91, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {4150F050-BB6F-11d0-AFB9-00AA00B67A42}           DV encoder property
OUR_GUID_ENTRY(CLSID_DVEncPropertiesPage,
0x4150f050, 0xbb6f, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)

// {4DB880E0-C10D-11d0-AFB9-00AA00B67A42}           DV Muxer property
OUR_GUID_ENTRY(CLSID_DVMuxPropertyPage,
0x4db880e0, 0xc10d, 0x11d0, 0xaf, 0xb9, 0x0, 0xaa, 0x0, 0xb6, 0x7a, 0x42)


// -- Direct Sound Audio related GUID ---

// 546F4260-D53E-11cf-B3F0-00AA003761C5
OUR_GUID_ENTRY(IID_IAMDirectSound,
0x546f4260, 0xd53e, 0x11cf, 0xb3, 0xf0, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// -- MPEG audio decoder properties

// {b45dd570-3c77-11d1-abe1-00a0c905f375}
OUR_GUID_ENTRY(IID_IMpegAudioDecoder,
0xb45dd570, 0x3c77, 0x11d1, 0xab, 0xe1, 0x00, 0xa0, 0xc9, 0x05, 0xf3, 0x75)

// --- Line21 Decoder interface GUID ---

// 6E8D4A21-310C-11d0-B79A-00AA003767A7            IID_IAMLine21Decoder
OUR_GUID_ENTRY(IID_IAMLine21Decoder,
0x6e8d4a21, 0x310c, 0x11d0, 0xb7, 0x9a, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7)

// --- WST Decoder interface GUID ---

// C056DE21-75C2-11d3-A184-00105AEF9F33            IID_IAMWstDecoder
OUR_GUID_ENTRY(IID_IAMWstDecoder,
0xc056de21, 0x75c2, 0x11d3, 0xa1, 0x84, 0x0, 0x10, 0x5a, 0xef, 0x9f, 0x33)

// --- WST Decoder Property Page ---

// 04E27F80-91E4-11d3-A184-00105AEF9F33            WST Decoder Property Page
OUR_GUID_ENTRY(CLSID_WstDecoderPropertyPage,
0x4e27f80, 0x91e4, 0x11d3, 0xa1, 0x84, 0x0, 0x10, 0x5a, 0xef, 0x9f, 0x33)


// -- Analog video related GUIDs ---


// -- format types ---
// 0482DDE0-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(FORMAT_AnalogVideo,
0x482dde0, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)


// -- major type, Analog Video

// 0482DDE1-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIATYPE_AnalogVideo,
0x482dde1, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)


// -- Analog Video subtypes, NTSC

// 0482DDE2-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_NTSC_M,
0x482dde2, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// -- Analog Video subtypes, PAL

// 0482DDE5-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_B,
0x482dde5, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE6-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_D,
0x482dde6, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE7-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_G,
0x482dde7, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE8-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_H,
0x482dde8, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDE9-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_I,
0x482dde9, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDEA-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_M,
0x482ddea, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDEB-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_N,
0x482ddeb, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDEC-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_PAL_N_COMBO,
0x482ddec, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// -- Analog Video subtypes, SECAM

// 0482DDF0-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_B,
0x482ddf0, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF1-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_D,
0x482ddf1, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF2-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_G,
0x482ddf2, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF3-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_H,
0x482ddf3, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF4-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_K,
0x482ddf4, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF5-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_K1,
0x482ddf5, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// 0482DDF6-7817-11cf-8A03-00AA006ECB65
OUR_GUID_ENTRY(MEDIASUBTYPE_AnalogVideo_SECAM_L,
0x482ddf6, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)


// --  External audio related GUIDs ---

// -- major types, Analog Audio

// 0482DEE1-7817-11cf-8a03-00aa006ecb65
OUR_GUID_ENTRY(MEDIATYPE_AnalogAudio,
0x482dee1, 0x7817, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// --  Video analysis related GUIDs ---

// -- format types used by VA -- H.264, captioning

// {A4EFC024-873E-4da3-898B-474DDBD79FD0}
OUR_GUID_ENTRY(FORMAT_CAPTIONED_H264VIDEO,
0xa4efc024, 0x873e, 0x4da3, 0x89, 0x8b, 0x47, 0x4d, 0xdb, 0xd7, 0x9f, 0xd0)

// -- media, media subtype, and format types, CC container

// {50997A4A-E508-4054-A2B2-10FF0AC1A69A}
OUR_GUID_ENTRY(FORMAT_CC_CONTAINER,
0x50997a4a, 0xe508, 0x4054, 0xa2, 0xb2, 0x10, 0xff, 0xa, 0xc1, 0xa6, 0x9a)

// {3ED9CB31-FD10-4ade-BCCC-FB9105D2F3EF}
OUR_GUID_ENTRY(CAPTION_FORMAT_ATSC,
0x3ed9cb31, 0xfd10, 0x4ade, 0xbc, 0xcc, 0xfb, 0x91, 0x5, 0xd2, 0xf3, 0xef)

// {12230DB4-FF2A-447e-BB88-6841C416D068}
OUR_GUID_ENTRY(CAPTION_FORMAT_DVB,
0x12230db4, 0xff2a, 0x447e, 0xbb, 0x88, 0x68, 0x41, 0xc4, 0x16, 0xd0, 0x68)

// {E9CA1CE7-915E-47be-9BB9-BF1D8A13A5EC}
OUR_GUID_ENTRY(CAPTION_FORMAT_DIRECTV,
0xe9ca1ce7, 0x915e, 0x47be, 0x9b, 0xb9, 0xbf, 0x1d, 0x8a, 0x13, 0xa5, 0xec)

// {EBB1A262-1158-4b99-AE80-92AC776952C4}
OUR_GUID_ENTRY(CAPTION_FORMAT_ECHOSTAR,
0xebb1a262, 0x1158, 0x4b99, 0xae, 0x80, 0x92, 0xac, 0x77, 0x69, 0x52, 0xc4)

// -- format types, MPEG-2

// {7AB2ADA2-81B6-4f14-B3C8-D0C486393B67}
OUR_GUID_ENTRY(FORMAT_CAPTIONED_MPEG2VIDEO,
0x7ab2ada2, 0x81b6, 0x4f14, 0xb3, 0xc8, 0xd0, 0xc4, 0x86, 0x39, 0x3b, 0x67)

//
// DirectShow's include file based on ksmedia.h from WDM DDK
//
#include "ksuuids.h"


// -- Well known time format GUIDs ---


// 00000000-0000-0000-0000-000000000000
OUR_GUID_ENTRY(TIME_FORMAT_NONE,
0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

// 7b785570-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_FRAME,
0x7b785570, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)

// 7b785571-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_BYTE,
0x7b785571, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)

// 7b785572-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_SAMPLE,
0x7b785572, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)

// 7b785573-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_FIELD,
0x7b785573, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)


// 7b785574-8c82-11cf-bc0c-00aa00ac74f6
OUR_GUID_ENTRY(TIME_FORMAT_MEDIA_TIME,
0x7b785574, 0x8c82, 0x11cf, 0xbc, 0xc, 0x0, 0xaa, 0x0, 0xac, 0x74, 0xf6)


// for IKsPropertySet

// 9B00F101-1567-11d1-B3F1-00AA003761C5
OUR_GUID_ENTRY(AMPROPSETID_Pin,
0x9b00f101, 0x1567, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// fb6c4281-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_CAPTURE,
0xfb6c4281, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4282-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_PREVIEW,
0xfb6c4282, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4283-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_ANALOGVIDEOIN,
0xfb6c4283, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4284-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_VBI,
0xfb6c4284, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4285-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_VIDEOPORT,
0xfb6c4285, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4286-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_NABTS,
0xfb6c4286, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4287-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_EDS,
0xfb6c4287, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4288-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_TELETEXT,
0xfb6c4288, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c4289-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_CC,
0xfb6c4289, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c428a-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_STILL,
0xfb6c428a, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c428b-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_TIMECODE,
0xfb6c428b, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)

// fb6c428c-0353-11d1-905f-0000c0cc16ba
OUR_GUID_ENTRY(PIN_CATEGORY_VIDEOPORT_VBI,
0xfb6c428c, 0x0353, 0x11d1, 0x90, 0x5f, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba)


// the following special GUIDS are used by ICaptureGraphBuilder::FindInterface

// {AC798BE0-98E3-11d1-B3F1-00AA003761C5}
OUR_GUID_ENTRY(LOOK_UPSTREAM_ONLY,
0xac798be0, 0x98e3, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// {AC798BE1-98E3-11d1-B3F1-00AA003761C5}
OUR_GUID_ENTRY(LOOK_DOWNSTREAM_ONLY,
0xac798be1, 0x98e3, 0x11d1, 0xb3, 0xf1, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5)

// -------------------------------------------------------------------------
// KSProxy GUIDS
// -------------------------------------------------------------------------

// {266EEE41-6C63-11cf-8A03-00AA006ECB65}
OUR_GUID_ENTRY(CLSID_TVTunerFilterPropertyPage,
0x266eee41, 0x6c63, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65)

// {71F96461-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_CrossbarFilterPropertyPage,
0x71f96461, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96463-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_TVAudioFilterPropertyPage,
0x71f96463, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96464-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_VideoProcAmpPropertyPage,
0x71f96464, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96465-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_CameraControlPropertyPage,
0x71f96465, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96466-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_AnalogVideoDecoderPropertyPage,
0x71f96466, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {71F96467-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_VideoStreamConfigPropertyPage,
0x71f96467, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56)

// {37E92A92-D9AA-11d2-BF84-8EF2B1555AED} Audio Renderer Advanced Property Page
OUR_GUID_ENTRY(CLSID_AudioRendererAdvancedProperties,
0x37e92a92, 0xd9aa, 0x11d2, 0xbf, 0x84, 0x8e, 0xf2, 0xb1, 0x55, 0x5a, 0xed)


// -------------------------------------------------------------------------
// VMR GUIDS
// -------------------------------------------------------------------------

// {B87BEB7B-8D29-423f-AE4D-6582C10175AC}
OUR_GUID_ENTRY(CLSID_VideoMixingRenderer,
0xB87BEB7B, 0x8D29, 0x423f, 0xAE, 0x4D, 0x65, 0x82, 0xC1, 0x01, 0x75, 0xAC)

// {6BC1CFFA-8FC1-4261-AC22-CFB4CC38DB50}
OUR_GUID_ENTRY(CLSID_VideoRendererDefault,
0x6BC1CFFA, 0x8FC1, 0x4261, 0xAC, 0x22, 0xCF, 0xB4, 0xCC, 0x38, 0xDB, 0x50)

// {99d54f63-1a69-41ae-aa4d-c976eb3f0713}
OUR_GUID_ENTRY(CLSID_AllocPresenter,
0x99d54f63, 0x1a69, 0x41ae, 0xaa, 0x4d, 0xc9, 0x76, 0xeb, 0x3f, 0x07, 0x13)

// {4444ac9e-242e-471b-a3c7-45dcd46352bc}
OUR_GUID_ENTRY(CLSID_AllocPresenterDDXclMode,
0x4444ac9e, 0x242e, 0x471b, 0xa3, 0xc7, 0x45, 0xdc, 0xd4, 0x63, 0x52, 0xbc)

// {6f26a6cd-967b-47fd-874a-7aed2c9d25a2}
OUR_GUID_ENTRY(CLSID_VideoPortManager,
0x6f26a6cd, 0x967b, 0x47fd, 0x87, 0x4a, 0x7a, 0xed, 0x2c, 0x9d, 0x25, 0xa2)


// -------------------------------------------------------------------------
// VMR GUIDS for DX9
// -------------------------------------------------------------------------

// {51b4abf3-748f-4e3b-a276-c828330e926a}
OUR_GUID_ENTRY(CLSID_VideoMixingRenderer9,
0x51b4abf3, 0x748f, 0x4e3b, 0xa2, 0x76, 0xc8, 0x28, 0x33, 0x0e, 0x92, 0x6a)


// -------------------------------------------------------------------------
// EVR GUIDS
// -------------------------------------------------------------------------

// {FA10746C-9B63-4b6c-BC49-FC300EA5F256}
OUR_GUID_ENTRY(CLSID_EnhancedVideoRenderer,
0xfa10746c, 0x9b63, 0x4b6c, 0xbc, 0x49, 0xfc, 0x30, 0xe, 0xa5, 0xf2, 0x56)

// {E474E05A-AB65-4f6a-827C-218B1BAAF31F}
OUR_GUID_ENTRY(CLSID_MFVideoMixer9,
0xE474E05A, 0xAB65, 0x4f6a, 0x82, 0x7C, 0x21, 0x8B, 0x1B, 0xAA, 0xF3, 0x1F)

// {98455561-5136-4d28-AB08-4CEE40EA2781}
OUR_GUID_ENTRY(CLSID_MFVideoPresenter9,
0x98455561, 0x5136, 0x4d28, 0xab, 0x8, 0x4c, 0xee, 0x40, 0xea, 0x27, 0x81)

// {a0a7a57b-59b2-4919-a694-add0a526c373}
OUR_GUID_ENTRY(CLSID_EVRTearlessWindowPresenter9,
0xa0a7a57b, 0x59b2, 0x4919, 0xa6, 0x94, 0xad, 0xd0, 0xa5, 0x26, 0xc3, 0x73)

// {62079164-233b-41f8-a80f-f01705f514a8}
OUR_GUID_ENTRY(CLSID_EVRPlaybackPipelineOptimizer,
0x62079164, 0x233b, 0x41f8, 0xa8, 0x0f, 0xf0, 0x17, 0x05, 0xf5, 0x14, 0xa8)

// {e447df01-10ca-4d17-b17e-6a840f8a3a4c}
// {e447df02-10ca-4d17-b17e-6a840f8a3a4c}
// {e447df03-10ca-4d17-b17e-6a840f8a3a4c}
// {e447df04-10ca-4d17-b17e-6a840f8a3a4c}
// {e447df05-10ca-4d17-b17e-6a840f8a3a4c}
// {e447df06-10ca-4d17-b17e-6a840f8a3a4c}
// {e447df07-10ca-4d17-b17e-6a840f8a3a4c}
// {e447df08-10ca-4d17-b17e-6a840f8a3a4c}
// {e447df09-10ca-4d17-b17e-6a840f8a3a4c}
// {e447df0a-10ca-4d17-b17e-6a840f8a3a4c}
OUR_GUID_ENTRY( EVRConfig_ForceBob,                0xe447df01,0x10ca,0x4d17,0xb1, 0x7e, 0x6a, 0x84, 0x0f, 0x8a, 0x3a, 0x4c)
OUR_GUID_ENTRY( EVRConfig_AllowDropToBob,          0xe447df02,0x10ca,0x4d17,0xb1, 0x7e, 0x6a, 0x84, 0x0f, 0x8a, 0x3a, 0x4c)
OUR_GUID_ENTRY( EVRConfig_ForceThrottle,           0xe447df03,0x10ca,0x4d17,0xb1, 0x7e, 0x6a, 0x84, 0x0f, 0x8a, 0x3a, 0x4c)
OUR_GUID_ENTRY( EVRConfig_AllowDropToThrottle,     0xe447df04,0x10ca,0x4d17,0xb1, 0x7e, 0x6a, 0x84, 0x0f, 0x8a, 0x3a, 0x4c)
OUR_GUID_ENTRY( EVRConfig_ForceHalfInterlace,      0xe447df05,0x10ca,0x4d17,0xb1, 0x7e, 0x6a, 0x84, 0x0f, 0x8a, 0x3a, 0x4c)
OUR_GUID_ENTRY( EVRConfig_AllowDropToHalfInterlace,0xe447df06,0x10ca,0x4d17,0xb1, 0x7e, 0x6a, 0x84, 0x0f, 0x8a, 0x3a, 0x4c)
OUR_GUID_ENTRY( EVRConfig_ForceScaling,            0xe447df07,0x10ca,0x4d17,0xb1, 0x7e, 0x6a, 0x84, 0x0f, 0x8a, 0x3a, 0x4c)
OUR_GUID_ENTRY( EVRConfig_AllowScaling,            0xe447df08,0x10ca,0x4d17,0xb1, 0x7e, 0x6a, 0x84, 0x0f, 0x8a, 0x3a, 0x4c)
OUR_GUID_ENTRY( EVRConfig_ForceBatching,           0xe447df09,0x10ca,0x4d17,0xb1, 0x7e, 0x6a, 0x84, 0x0f, 0x8a, 0x3a, 0x4c)
OUR_GUID_ENTRY( EVRConfig_AllowBatching,           0xe447df0a,0x10ca,0x4d17,0xb1, 0x7e, 0x6a, 0x84, 0x0f, 0x8a, 0x3a, 0x4c)


// -------------------------------------------------------------------------
// BDA Network Provider GUIDS
// -------------------------------------------------------------------------

// This is the GUID for the generic NP which would replace ATSC, DVBT, DVBS
// and DVBC NP. All the other GUIDs are still kept for backward compatibility
// {B2F3A67C-29DA-4c78-8831-091ED509A475}
OUR_GUID_ENTRY(CLSID_NetworkProvider,
0xb2f3a67c, 0x29da, 0x4c78, 0x88, 0x31, 0x9, 0x1e, 0xd5, 0x9, 0xa4, 0x75)

// {0DAD2FDD-5FD7-11D3-8F50-00C04F7971E2}
OUR_GUID_ENTRY(CLSID_ATSCNetworkProvider,
0x0dad2fdd, 0x5fd7, 0x11d3, 0x8f, 0x50, 0x00, 0xc0, 0x4f, 0x79, 0x71, 0xe2)

// {E3444D16-5AC4-4386-88DF-13FD230E1DDA}
OUR_GUID_ENTRY(CLSID_ATSCNetworkPropertyPage,
0xe3444d16, 0x5ac4, 0x4386, 0x88, 0xdf, 0x13, 0xfd, 0x23, 0x0e, 0x1d, 0xda)

// {FA4B375A-45B4-4d45-8440-263957B11623}
OUR_GUID_ENTRY(CLSID_DVBSNetworkProvider,
0xfa4b375a, 0x45b4, 0x4d45, 0x84, 0x40, 0x26, 0x39, 0x57, 0xb1, 0x16, 0x23)

// {216C62DF-6D7F-4e9a-8571-05F14EDB766A}
OUR_GUID_ENTRY(CLSID_DVBTNetworkProvider,
0x216c62df, 0x6d7f, 0x4e9a, 0x85, 0x71, 0x5, 0xf1, 0x4e, 0xdb, 0x76, 0x6a)

// {DC0C0FE7-0485-4266-B93F-68FBF80ED834}
OUR_GUID_ENTRY(CLSID_DVBCNetworkProvider,
0xdc0c0fe7, 0x485, 0x4266, 0xb9, 0x3f, 0x68, 0xfb, 0xf8, 0xe, 0xd8, 0x34)

// -------------------------------------------------------------------------
// attribute GUIDs
// -------------------------------------------------------------------------

// {EB7836CA-14FF-4919-BCE7-3AF12319E50C}
OUR_GUID_ENTRY(DSATTRIB_UDCRTag,
0xEB7836CA, 0x14FF, 0x4919, 0xbc, 0xe7, 0x3a, 0xf1, 0x23, 0x19, 0xe5, 0x0c)

// {2F5BAE02-7B8F-4f60-82D6-E4EA2F1F4C99}
OUR_GUID_ENTRY(DSATTRIB_PicSampleSeq,
0x2f5bae02, 0x7b8f, 0x4f60, 0x82, 0xd6, 0xe4, 0xea, 0x2f, 0x1f, 0x4c, 0x99)

// {5A5F08CA-55C2-4033-92AB-55DB8F781226}
OUR_GUID_ENTRY(DSATTRIB_OptionalVideoAttributes,
0x5A5F08CA, 0x55C2, 0x4033, 0x92, 0xAB, 0x55, 0xDB, 0x8F, 0x78, 0x12, 0x26)

// {e7e050fb-dd5d-40dd-9915-35dcb81bdc8a}
OUR_GUID_ENTRY(DSATTRIB_CC_CONTAINER_INFO,
0xe7e050fb, 0xdd5d, 0x40dd, 0x99, 0x15, 0x35, 0xDC, 0xB8, 0x1B, 0xDC, 0x8a)

// {B622F612-47AD-4671-AD6C-05A98E65DE3A}
OUR_GUID_ENTRY(DSATTRIB_TRANSPORT_PROPERTIES,
0xb622f612, 0x47ad, 0x4671, 0xad, 0x6c, 0x5, 0xa9, 0x8e, 0x65, 0xde, 0x3a)

// {e0b56679-12b9-43cc-b7df-578caa5a7b63}
OUR_GUID_ENTRY(DSATTRIB_PBDATAG_ATTRIBUTE,
0xe0b56679, 0x12b9, 0x43cc, 0xb7, 0xdf, 0x57, 0x8c, 0xaa, 0x5a, 0x7b, 0x63)

// {0c1a5614-30cd-4f40-bcbf-d03e52306207}
OUR_GUID_ENTRY( DSATTRIB_CAPTURE_STREAMTIME,
0x0c1a5614, 0x30cd, 0x4f40, 0xbc, 0xbf, 0xd0, 0x3e, 0x52, 0x30, 0x62, 0x07)

// {5FB5673B-0A2A-4565-827B-6853FD75E611}               DSATTRIB_DSHOW_STREAM_DESC
OUR_GUID_ENTRY(DSATTRIB_DSHOW_STREAM_DESC,
0x5fb5673b, 0xa2a, 0x4565, 0x82, 0x7b, 0x68, 0x53, 0xfd, 0x75, 0xe6, 0x11)

// {892CD111-72F3-411d-8B91-A9E9123AC29A}
OUR_GUID_ENTRY(DSATTRIB_SAMPLE_LIVE_STREAM_TIME,
0x892cd111, 0x72f3, 0x411d, 0x8b, 0x91, 0xa9, 0xe9, 0x12, 0x3a, 0xc2, 0x9a)

// UUID for supported UDRI TAG tables
OUR_GUID_ENTRY( UUID_UdriTagTables,
0xe1b98d74, 0x9778, 0x4878, 0xb6, 0x64, 0xeb, 0x20, 0x20, 0x36, 0x4d, 0x88)

// UUID for supported WMDRM TAG tables
OUR_GUID_ENTRY( UUID_WMDRMTagTables,
0x5DCD1101, 0x9263, 0x45bb, 0xa4, 0xd5, 0xc4, 0x15, 0xab, 0x8c, 0x58, 0x9c)

// -------------------------------------------------------------------------
// TVE Receiver filter guids
// -------------------------------------------------------------------------

// The CLSID used by the TVE Receiver filter
// {05500280-FAA5-4DF9-8246-BFC23AC5CEA8}
OUR_GUID_ENTRY(CLSID_DShowTVEFilter,
0x05500280, 0xFAA5, 0x4DF9, 0x82, 0x46, 0xBF, 0xC2, 0x3A, 0xC5, 0xCE, 0xA8)

// {05500281-FAA5-4DF9-8246-BFC23AC5CEA8}
OUR_GUID_ENTRY(CLSID_TVEFilterTuneProperties,
0x05500281, 0xFAA5, 0x4DF9, 0x82, 0x46, 0xBF, 0xC2, 0x3A, 0xC5, 0xCE, 0xA8)


// {05500282-FAA5-4DF9-8246-BFC23AC5CEA8}
OUR_GUID_ENTRY(CLSID_TVEFilterCCProperties,
0x05500282, 0xFAA5, 0x4DF9, 0x82, 0x46, 0xBF, 0xC2, 0x3A, 0xC5, 0xCE, 0xA8)

// {05500283-FAA5-4DF9-8246-BFC23AC5CEA8}
OUR_GUID_ENTRY(CLSID_TVEFilterStatsProperties,
0x05500283, 0xFAA5, 0x4DF9, 0x82, 0x46, 0xBF, 0xC2, 0x3A, 0xC5, 0xCE, 0xA8)

// -------------------------------------------------------------------------
// Defined ENCAPI parameter GUIDs
// -------------------------------------------------------------------------

// The CLSID for the original IVideoEncoder proxy plug-in
// {B43C4EEC-8C32-4791-9102-508ADA5EE8E7}
OUR_GUID_ENTRY(CLSID_IVideoEncoderProxy,
0xb43c4eec, 0x8c32, 0x4791, 0x91, 0x2, 0x50, 0x8a, 0xda, 0x5e, 0xe8, 0xe7)

// The CLSID for the ICodecAPI proxy plug-in
// {7ff0997a-1999-4286-a73c-622b8814e7eb}
OUR_GUID_ENTRY(CLSID_ICodecAPIProxy,
0x7ff0997a, 0x1999, 0x4286, 0xa7, 0x3c, 0x62, 0x2b, 0x88, 0x14, 0xe7, 0xeb )

// The CLSID for the combination ICodecAPI/IVideoEncoder proxy plug-in
// {b05dabd9-56e5-4fdc-afa4-8a47e91f1c9c}
OUR_GUID_ENTRY(CLSID_IVideoEncoderCodecAPIProxy,
0xb05dabd9, 0x56e5, 0x4fdc, 0xaf, 0xa4, 0x8a, 0x47, 0xe9, 0x1f, 0x1c, 0x9c )

#ifndef __ENCODER_API_GUIDS__
#define __ENCODER_API_GUIDS__

// {49CC4C43-CA83-4ad4-A9AF-F3696AF666DF}
OUR_GUID_ENTRY(ENCAPIPARAM_BITRATE,
0x49cc4c43, 0xca83, 0x4ad4, 0xa9, 0xaf, 0xf3, 0x69, 0x6a, 0xf6, 0x66, 0xdf)

// {703F16A9-3D48-44a1-B077-018DFF915D19}
OUR_GUID_ENTRY(ENCAPIPARAM_PEAK_BITRATE,
0x703f16a9, 0x3d48, 0x44a1, 0xb0, 0x77, 0x1, 0x8d, 0xff, 0x91, 0x5d, 0x19)

// {EE5FB25C-C713-40d1-9D58-C0D7241E250F}
OUR_GUID_ENTRY(ENCAPIPARAM_BITRATE_MODE,
0xee5fb25c, 0xc713, 0x40d1, 0x9d, 0x58, 0xc0, 0xd7, 0x24, 0x1e, 0x25, 0xf)

// {0C0171DB-FEFC-4af7-9991-A5657C191CD1}
OUR_GUID_ENTRY(ENCAPIPARAM_SAP_MODE,
0xc0171db, 0xfefc, 0x4af7, 0x99, 0x91, 0xa5, 0x65, 0x7c, 0x19, 0x1c, 0xd1)

// for kernel control

// {62b12acf-f6b0-47d9-9456-96f22c4e0b9d}
OUR_GUID_ENTRY(CODECAPI_CHANGELISTS,
0x62b12acf, 0xf6b0, 0x47d9, 0x94, 0x56, 0x96, 0xf2, 0x2c, 0x4e, 0x0b, 0x9d)

// {7112e8e1-3d03-47ef-8e60-03f1cf537301 }
OUR_GUID_ENTRY(CODECAPI_VIDEO_ENCODER,
0x7112e8e1, 0x3d03, 0x47ef, 0x8e, 0x60, 0x03, 0xf1, 0xcf, 0x53, 0x73, 0x01)

// {b9d19a3e-f897-429c-bc46-8138b7272b2d }
OUR_GUID_ENTRY(CODECAPI_AUDIO_ENCODER,
0xb9d19a3e, 0xf897, 0x429c, 0xbc, 0x46, 0x81, 0x38, 0xb7, 0x27, 0x2b, 0x2d)

// {6c5e6a7c-acf8-4f55-a999-1a628109051b }
OUR_GUID_ENTRY(CODECAPI_SETALLDEFAULTS,
0x6c5e6a7c, 0xacf8, 0x4f55, 0xa9, 0x99, 0x1a, 0x62, 0x81, 0x09, 0x05, 0x1b)

// {6a577e92-83e1-4113-adc2-4fcec32f83a1 }
OUR_GUID_ENTRY(CODECAPI_ALLSETTINGS,
0x6a577e92, 0x83e1, 0x4113, 0xad, 0xc2, 0x4f, 0xce, 0xc3, 0x2f, 0x83, 0xa1)

// {0581af97-7693-4dbd-9dca-3f9ebd6585a1 }
OUR_GUID_ENTRY(CODECAPI_SUPPORTSEVENTS,
0x0581af97, 0x7693, 0x4dbd, 0x9d, 0xca, 0x3f, 0x9e, 0xbd, 0x65, 0x85, 0xa1 )

// {1cb14e83-7d72-4657-83fd-47a2c5b9d13d }
OUR_GUID_ENTRY(CODECAPI_CURRENTCHANGELIST,
0x1cb14e83, 0x7d72, 0x4657, 0x83, 0xfd, 0x47, 0xa2, 0xc5, 0xb9, 0xd1, 0x3d )

// {1f26a602-2b5c-4b63-b8e8-9ea5c1a7dc2e}
OUR_GUID_ENTRY(CLSID_SBE2MediaTypeProfile,
0x1f26a602, 0x2b5c, 0x4b63, 0xb8, 0xe8, 0x9e, 0xa5, 0xc1, 0xa7, 0xdc, 0x2e )

// {3E458037-0CA6-41aa-A594-2AA6C02D709B}
OUR_GUID_ENTRY(CLSID_SBE2FileScan,
0x3e458037, 0xca6, 0x41aa, 0xa5, 0x94, 0x2a, 0xa6, 0xc0, 0x2d, 0x70, 0x9b) ;

// When generating strmiids.lib, include codecapi definitions
#ifdef INITGUID
#define UUID_GEN
#include <codecapi.h>
#endif

#endif // __ENCODER_API_GUIDS__

// -----------------------------------------------
// Used for decoders that exposing ICodecAPI
// -----------------------------------------------
OUR_GUID_ENTRY(CODECAPI_AVDecMmcssClass,
0xe0ad4828, 0xdf66, 0x4893, 0x9f, 0x33, 0x78, 0x8a, 0xa4, 0xec, 0x40, 0x82)

#undef OUR_GUID_ENTRY
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\UrlMon.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for urlmon.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __urlmon_h__
#define __urlmon_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IPersistMoniker_FWD_DEFINED__
#define __IPersistMoniker_FWD_DEFINED__
typedef interface IPersistMoniker IPersistMoniker;
#endif 	/* __IPersistMoniker_FWD_DEFINED__ */


#ifndef __IMonikerProp_FWD_DEFINED__
#define __IMonikerProp_FWD_DEFINED__
typedef interface IMonikerProp IMonikerProp;
#endif 	/* __IMonikerProp_FWD_DEFINED__ */


#ifndef __IBindProtocol_FWD_DEFINED__
#define __IBindProtocol_FWD_DEFINED__
typedef interface IBindProtocol IBindProtocol;
#endif 	/* __IBindProtocol_FWD_DEFINED__ */


#ifndef __IBinding_FWD_DEFINED__
#define __IBinding_FWD_DEFINED__
typedef interface IBinding IBinding;
#endif 	/* __IBinding_FWD_DEFINED__ */


#ifndef __IBindStatusCallback_FWD_DEFINED__
#define __IBindStatusCallback_FWD_DEFINED__
typedef interface IBindStatusCallback IBindStatusCallback;
#endif 	/* __IBindStatusCallback_FWD_DEFINED__ */


#ifndef __IBindStatusCallbackEx_FWD_DEFINED__
#define __IBindStatusCallbackEx_FWD_DEFINED__
typedef interface IBindStatusCallbackEx IBindStatusCallbackEx;
#endif 	/* __IBindStatusCallbackEx_FWD_DEFINED__ */


#ifndef __IAuthenticate_FWD_DEFINED__
#define __IAuthenticate_FWD_DEFINED__
typedef interface IAuthenticate IAuthenticate;
#endif 	/* __IAuthenticate_FWD_DEFINED__ */


#ifndef __IAuthenticateEx_FWD_DEFINED__
#define __IAuthenticateEx_FWD_DEFINED__
typedef interface IAuthenticateEx IAuthenticateEx;
#endif 	/* __IAuthenticateEx_FWD_DEFINED__ */


#ifndef __IHttpNegotiate_FWD_DEFINED__
#define __IHttpNegotiate_FWD_DEFINED__
typedef interface IHttpNegotiate IHttpNegotiate;
#endif 	/* __IHttpNegotiate_FWD_DEFINED__ */


#ifndef __IHttpNegotiate2_FWD_DEFINED__
#define __IHttpNegotiate2_FWD_DEFINED__
typedef interface IHttpNegotiate2 IHttpNegotiate2;
#endif 	/* __IHttpNegotiate2_FWD_DEFINED__ */


#ifndef __IHttpNegotiate3_FWD_DEFINED__
#define __IHttpNegotiate3_FWD_DEFINED__
typedef interface IHttpNegotiate3 IHttpNegotiate3;
#endif 	/* __IHttpNegotiate3_FWD_DEFINED__ */


#ifndef __IWinInetFileStream_FWD_DEFINED__
#define __IWinInetFileStream_FWD_DEFINED__
typedef interface IWinInetFileStream IWinInetFileStream;
#endif 	/* __IWinInetFileStream_FWD_DEFINED__ */


#ifndef __IWindowForBindingUI_FWD_DEFINED__
#define __IWindowForBindingUI_FWD_DEFINED__
typedef interface IWindowForBindingUI IWindowForBindingUI;
#endif 	/* __IWindowForBindingUI_FWD_DEFINED__ */


#ifndef __ICodeInstall_FWD_DEFINED__
#define __ICodeInstall_FWD_DEFINED__
typedef interface ICodeInstall ICodeInstall;
#endif 	/* __ICodeInstall_FWD_DEFINED__ */


#ifndef __IUri_FWD_DEFINED__
#define __IUri_FWD_DEFINED__
typedef interface IUri IUri;
#endif 	/* __IUri_FWD_DEFINED__ */


#ifndef __IUriContainer_FWD_DEFINED__
#define __IUriContainer_FWD_DEFINED__
typedef interface IUriContainer IUriContainer;
#endif 	/* __IUriContainer_FWD_DEFINED__ */


#ifndef __IUriBuilder_FWD_DEFINED__
#define __IUriBuilder_FWD_DEFINED__
typedef interface IUriBuilder IUriBuilder;
#endif 	/* __IUriBuilder_FWD_DEFINED__ */


#ifndef __IUriBuilderFactory_FWD_DEFINED__
#define __IUriBuilderFactory_FWD_DEFINED__
typedef interface IUriBuilderFactory IUriBuilderFactory;
#endif 	/* __IUriBuilderFactory_FWD_DEFINED__ */


#ifndef __IWinInetInfo_FWD_DEFINED__
#define __IWinInetInfo_FWD_DEFINED__
typedef interface IWinInetInfo IWinInetInfo;
#endif 	/* __IWinInetInfo_FWD_DEFINED__ */


#ifndef __IHttpSecurity_FWD_DEFINED__
#define __IHttpSecurity_FWD_DEFINED__
typedef interface IHttpSecurity IHttpSecurity;
#endif 	/* __IHttpSecurity_FWD_DEFINED__ */


#ifndef __IWinInetHttpInfo_FWD_DEFINED__
#define __IWinInetHttpInfo_FWD_DEFINED__
typedef interface IWinInetHttpInfo IWinInetHttpInfo;
#endif 	/* __IWinInetHttpInfo_FWD_DEFINED__ */


#ifndef __IWinInetCacheHints_FWD_DEFINED__
#define __IWinInetCacheHints_FWD_DEFINED__
typedef interface IWinInetCacheHints IWinInetCacheHints;
#endif 	/* __IWinInetCacheHints_FWD_DEFINED__ */


#ifndef __IWinInetCacheHints2_FWD_DEFINED__
#define __IWinInetCacheHints2_FWD_DEFINED__
typedef interface IWinInetCacheHints2 IWinInetCacheHints2;
#endif 	/* __IWinInetCacheHints2_FWD_DEFINED__ */


#ifndef __IBindHost_FWD_DEFINED__
#define __IBindHost_FWD_DEFINED__
typedef interface IBindHost IBindHost;
#endif 	/* __IBindHost_FWD_DEFINED__ */


#ifndef __IInternet_FWD_DEFINED__
#define __IInternet_FWD_DEFINED__
typedef interface IInternet IInternet;
#endif 	/* __IInternet_FWD_DEFINED__ */


#ifndef __IInternetBindInfo_FWD_DEFINED__
#define __IInternetBindInfo_FWD_DEFINED__
typedef interface IInternetBindInfo IInternetBindInfo;
#endif 	/* __IInternetBindInfo_FWD_DEFINED__ */


#ifndef __IInternetBindInfoEx_FWD_DEFINED__
#define __IInternetBindInfoEx_FWD_DEFINED__
typedef interface IInternetBindInfoEx IInternetBindInfoEx;
#endif 	/* __IInternetBindInfoEx_FWD_DEFINED__ */


#ifndef __IInternetProtocolRoot_FWD_DEFINED__
#define __IInternetProtocolRoot_FWD_DEFINED__
typedef interface IInternetProtocolRoot IInternetProtocolRoot;
#endif 	/* __IInternetProtocolRoot_FWD_DEFINED__ */


#ifndef __IInternetProtocol_FWD_DEFINED__
#define __IInternetProtocol_FWD_DEFINED__
typedef interface IInternetProtocol IInternetProtocol;
#endif 	/* __IInternetProtocol_FWD_DEFINED__ */


#ifndef __IInternetProtocolEx_FWD_DEFINED__
#define __IInternetProtocolEx_FWD_DEFINED__
typedef interface IInternetProtocolEx IInternetProtocolEx;
#endif 	/* __IInternetProtocolEx_FWD_DEFINED__ */


#ifndef __IInternetProtocolSink_FWD_DEFINED__
#define __IInternetProtocolSink_FWD_DEFINED__
typedef interface IInternetProtocolSink IInternetProtocolSink;
#endif 	/* __IInternetProtocolSink_FWD_DEFINED__ */


#ifndef __IInternetProtocolSinkStackable_FWD_DEFINED__
#define __IInternetProtocolSinkStackable_FWD_DEFINED__
typedef interface IInternetProtocolSinkStackable IInternetProtocolSinkStackable;
#endif 	/* __IInternetProtocolSinkStackable_FWD_DEFINED__ */


#ifndef __IInternetSession_FWD_DEFINED__
#define __IInternetSession_FWD_DEFINED__
typedef interface IInternetSession IInternetSession;
#endif 	/* __IInternetSession_FWD_DEFINED__ */


#ifndef __IInternetThreadSwitch_FWD_DEFINED__
#define __IInternetThreadSwitch_FWD_DEFINED__
typedef interface IInternetThreadSwitch IInternetThreadSwitch;
#endif 	/* __IInternetThreadSwitch_FWD_DEFINED__ */


#ifndef __IInternetPriority_FWD_DEFINED__
#define __IInternetPriority_FWD_DEFINED__
typedef interface IInternetPriority IInternetPriority;
#endif 	/* __IInternetPriority_FWD_DEFINED__ */


#ifndef __IInternetProtocolInfo_FWD_DEFINED__
#define __IInternetProtocolInfo_FWD_DEFINED__
typedef interface IInternetProtocolInfo IInternetProtocolInfo;
#endif 	/* __IInternetProtocolInfo_FWD_DEFINED__ */


#ifndef __IInternetSecurityMgrSite_FWD_DEFINED__
#define __IInternetSecurityMgrSite_FWD_DEFINED__
typedef interface IInternetSecurityMgrSite IInternetSecurityMgrSite;
#endif 	/* __IInternetSecurityMgrSite_FWD_DEFINED__ */


#ifndef __IInternetSecurityManager_FWD_DEFINED__
#define __IInternetSecurityManager_FWD_DEFINED__
typedef interface IInternetSecurityManager IInternetSecurityManager;
#endif 	/* __IInternetSecurityManager_FWD_DEFINED__ */


#ifndef __IInternetSecurityManagerEx_FWD_DEFINED__
#define __IInternetSecurityManagerEx_FWD_DEFINED__
typedef interface IInternetSecurityManagerEx IInternetSecurityManagerEx;
#endif 	/* __IInternetSecurityManagerEx_FWD_DEFINED__ */


#ifndef __IInternetSecurityManagerEx2_FWD_DEFINED__
#define __IInternetSecurityManagerEx2_FWD_DEFINED__
typedef interface IInternetSecurityManagerEx2 IInternetSecurityManagerEx2;
#endif 	/* __IInternetSecurityManagerEx2_FWD_DEFINED__ */


#ifndef __IZoneIdentifier_FWD_DEFINED__
#define __IZoneIdentifier_FWD_DEFINED__
typedef interface IZoneIdentifier IZoneIdentifier;
#endif 	/* __IZoneIdentifier_FWD_DEFINED__ */


#ifndef __IInternetHostSecurityManager_FWD_DEFINED__
#define __IInternetHostSecurityManager_FWD_DEFINED__
typedef interface IInternetHostSecurityManager IInternetHostSecurityManager;
#endif 	/* __IInternetHostSecurityManager_FWD_DEFINED__ */


#ifndef __IInternetZoneManager_FWD_DEFINED__
#define __IInternetZoneManager_FWD_DEFINED__
typedef interface IInternetZoneManager IInternetZoneManager;
#endif 	/* __IInternetZoneManager_FWD_DEFINED__ */


#ifndef __IInternetZoneManagerEx_FWD_DEFINED__
#define __IInternetZoneManagerEx_FWD_DEFINED__
typedef interface IInternetZoneManagerEx IInternetZoneManagerEx;
#endif 	/* __IInternetZoneManagerEx_FWD_DEFINED__ */


#ifndef __IInternetZoneManagerEx2_FWD_DEFINED__
#define __IInternetZoneManagerEx2_FWD_DEFINED__
typedef interface IInternetZoneManagerEx2 IInternetZoneManagerEx2;
#endif 	/* __IInternetZoneManagerEx2_FWD_DEFINED__ */


#ifndef __ISoftDistExt_FWD_DEFINED__
#define __ISoftDistExt_FWD_DEFINED__
typedef interface ISoftDistExt ISoftDistExt;
#endif 	/* __ISoftDistExt_FWD_DEFINED__ */


#ifndef __ICatalogFileInfo_FWD_DEFINED__
#define __ICatalogFileInfo_FWD_DEFINED__
typedef interface ICatalogFileInfo ICatalogFileInfo;
#endif 	/* __ICatalogFileInfo_FWD_DEFINED__ */


#ifndef __IDataFilter_FWD_DEFINED__
#define __IDataFilter_FWD_DEFINED__
typedef interface IDataFilter IDataFilter;
#endif 	/* __IDataFilter_FWD_DEFINED__ */


#ifndef __IEncodingFilterFactory_FWD_DEFINED__
#define __IEncodingFilterFactory_FWD_DEFINED__
typedef interface IEncodingFilterFactory IEncodingFilterFactory;
#endif 	/* __IEncodingFilterFactory_FWD_DEFINED__ */


#ifndef __IWrappedProtocol_FWD_DEFINED__
#define __IWrappedProtocol_FWD_DEFINED__
typedef interface IWrappedProtocol IWrappedProtocol;
#endif 	/* __IWrappedProtocol_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"
#include "servprov.h"
#include "msxml.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_urlmon_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// UrlMon.h
//=--------------------------------------------------------------------------=
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// URL Moniker Interfaces.















// Side-by-Side clsid
EXTERN_C const IID CLSID_SBS_StdURLMoniker;  
EXTERN_C const IID CLSID_SBS_HttpProtocol;   
EXTERN_C const IID CLSID_SBS_FtpProtocol;    
EXTERN_C const IID CLSID_SBS_GopherProtocol; 
EXTERN_C const IID CLSID_SBS_HttpSProtocol;  
EXTERN_C const IID CLSID_SBS_FileProtocol;   
EXTERN_C const IID CLSID_SBS_MkProtocol;     
EXTERN_C const IID CLSID_SBS_UrlMkBindCtx;   
EXTERN_C const IID CLSID_SBS_SoftDistExt;  
EXTERN_C const IID CLSID_SBS_StdEncodingFilterFac; 
EXTERN_C const IID CLSID_SBS_DeCompMimeFilter;     
EXTERN_C const IID CLSID_SBS_CdlProtocol;          
EXTERN_C const IID CLSID_SBS_ClassInstallFilter;   
EXTERN_C const IID CLSID_SBS_InternetSecurityManager;  
EXTERN_C const IID CLSID_SBS_InternetZoneManager;  
// END Side-by-Side clsid
// These are for backwards compatibility with previous URLMON versions
#define BINDF_DONTUSECACHE BINDF_GETNEWESTVERSION
#define BINDF_DONTPUTINCACHE BINDF_NOWRITECACHE
#define BINDF_NOCOPYDATA BINDF_PULLDATA
#define INVALID_P_ROOT_SECURITY_ID ((BYTE*)-1)
#define PI_DOCFILECLSIDLOOKUP PI_CLSIDLOOKUP
EXTERN_C const IID IID_IAsyncMoniker;    
EXTERN_C const IID CLSID_StdURLMoniker;  
EXTERN_C const IID CLSID_HttpProtocol;   
EXTERN_C const IID CLSID_FtpProtocol;    
EXTERN_C const IID CLSID_GopherProtocol; 
EXTERN_C const IID CLSID_HttpSProtocol;  
EXTERN_C const IID CLSID_FileProtocol;   
EXTERN_C const IID CLSID_MkProtocol;     
EXTERN_C const IID CLSID_StdURLProtocol; 
EXTERN_C const IID CLSID_UrlMkBindCtx;   
EXTERN_C const IID CLSID_StdEncodingFilterFac; 
EXTERN_C const IID CLSID_DeCompMimeFilter;     
EXTERN_C const IID CLSID_CdlProtocol;          
EXTERN_C const IID CLSID_ClassInstallFilter;   
EXTERN_C const IID IID_IAsyncBindCtx;    
 
#define SZ_URLCONTEXT           OLESTR("URL Context")
#define SZ_ASYNC_CALLEE         OLESTR("AsyncCallee")
#define MKSYS_URLMONIKER         6            
#define URL_MK_LEGACY            0            
#define URL_MK_UNIFORM           1            
#define URL_MK_NO_CANONICALIZE   2            
 
STDAPI CreateURLMoniker(LPMONIKER pMkCtx, LPCWSTR szURL, LPMONIKER FAR * ppmk);             
STDAPI CreateURLMonikerEx(LPMONIKER pMkCtx, LPCWSTR szURL, LPMONIKER FAR * ppmk, DWORD dwFlags);             
STDAPI GetClassURL(LPCWSTR szURL, CLSID *pClsID);                                           
STDAPI CreateAsyncBindCtx(DWORD reserved, IBindStatusCallback *pBSCb,                       
                                IEnumFORMATETC *pEFetc, IBindCtx **ppBC);                   
#if (_WIN32_IE >= _WIN32_IE_IE70)
STDAPI CreateURLMonikerEx2(LPMONIKER pMkCtx, IUri* pUri, LPMONIKER FAR * ppmk, DWORD dwFlags);             
#endif
STDAPI CreateAsyncBindCtxEx(IBindCtx *pbc, DWORD dwOptions, IBindStatusCallback *pBSCb, IEnumFORMATETC *pEnum,   
                            IBindCtx **ppBC, DWORD reserved);                                                     
STDAPI MkParseDisplayNameEx(IBindCtx *pbc, LPCWSTR szDisplayName, ULONG *pchEaten,          
                                LPMONIKER *ppmk);                                           
STDAPI RegisterBindStatusCallback(LPBC pBC, IBindStatusCallback *pBSCb,                     
                                IBindStatusCallback**  ppBSCBPrev, DWORD dwReserved);       
STDAPI RevokeBindStatusCallback(LPBC pBC, IBindStatusCallback *pBSCb);                      
STDAPI GetClassFileOrMime(LPBC pBC, LPCWSTR szFilename, LPVOID pBuffer, DWORD cbSize, LPCWSTR szMime, DWORD dwReserved, CLSID *pclsid); 
STDAPI IsValidURL(LPBC pBC, LPCWSTR szURL, DWORD dwReserved);                               
STDAPI CoGetClassObjectFromURL( REFCLSID rCLASSID,
            LPCWSTR szCODE, DWORD dwFileVersionMS, 
            DWORD dwFileVersionLS, LPCWSTR szTYPE,
            LPBINDCTX pBindCtx, DWORD dwClsContext,
            LPVOID pvReserved, REFIID riid, LPVOID * ppv);
STDAPI IEInstallScope(__out LPDWORD pdwScope);
STDAPI FaultInIEFeature( HWND hWnd,
            __in uCLSSPEC *pClassSpec,
            __inout_opt QUERYCONTEXT *pQuery, DWORD dwFlags);                                           
STDAPI GetComponentIDFromCLSSPEC(__in uCLSSPEC *pClassspec,
            __deref_out LPSTR * ppszComponentID);                                                      
// flags for FaultInIEFeature
#define FIEF_FLAG_FORCE_JITUI               0x1     // force JIT ui even if
                                                 // previoulsy rejected by 
                                                 // user in this session or
                                                 // marked as Never Ask Again
#define FIEF_FLAG_PEEK                      0x2     // just peek, don't faultin
#define FIEF_FLAG_SKIP_INSTALLED_VERSION_CHECK        0x4     // force JIT without checking local version
 
//helper apis                                                                               
STDAPI IsAsyncMoniker(IMoniker* pmk);                                                       
STDAPI CreateURLBinding(LPCWSTR lpszUrl, __in IBindCtx *pbc, __deref_inout IBinding **ppBdg);
 
STDAPI RegisterMediaTypes(UINT ctypes, const LPCSTR* rgszTypes, CLIPFORMAT* rgcfTypes);            
STDAPI FindMediaType(LPCSTR rgszTypes, __out CLIPFORMAT* rgcfTypes);                                       
STDAPI CreateFormatEnumerator( UINT cfmtetc, FORMATETC* rgfmtetc, IEnumFORMATETC** ppenumfmtetc); 
STDAPI RegisterFormatEnumerator(LPBC pBC, IEnumFORMATETC *pEFetc, DWORD reserved);          
STDAPI RevokeFormatEnumerator(LPBC pBC, IEnumFORMATETC *pEFetc);                            
STDAPI RegisterMediaTypeClass(LPBC pBC,UINT ctypes, const LPCSTR* rgszTypes, CLSID *rgclsID, DWORD reserved);    
STDAPI FindMediaTypeClass(LPBC pBC, LPCSTR szType, CLSID *pclsID, DWORD reserved);                          
STDAPI UrlMkSetSessionOption(DWORD dwOption, __in_bcount_opt(dwBufferLength) LPVOID pBuffer, DWORD dwBufferLength, __reserved DWORD dwReserved);       
STDAPI UrlMkGetSessionOption(DWORD dwOption, __out_bcount_part_opt(dwBufferLength,*pdwBufferLengthOut) LPVOID pBuffer, DWORD dwBufferLength, __out DWORD *pdwBufferLengthOut, __reserved DWORD dwReserved);       
STDAPI FindMimeFromData(                                                                                                                  
    __in_opt                LPBC    pBC,                   // bind context - can be NULL                                                 
    __in_opt                LPCWSTR pwzUrl,                // url - can be null                                                          
    __in_bcount_opt(cbSize) LPVOID  pBuffer,               // buffer with data to sniff - can be null (pwzUrl must be valid)             
                            DWORD   cbSize,                // size of buffer                                                             
    __in_opt                LPCWSTR pwzMimeProposed,       // proposed mime if - can be null                                             
                            DWORD   dwMimeFlags,           // will be defined                                                            
    __deref_out             LPWSTR  *ppwzMimeOut,          // the suggested mime                                                         
    __reserved              DWORD   dwReserved);           // must be 0                                                                  
#define     FMFD_DEFAULT             0x00000000 
#define     FMFD_URLASFILENAME       0x00000001 
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#define     FMFD_ENABLEMIMESNIFFING  0x00000002 
#define     FMFD_IGNOREMIMETEXTPLAIN  0x00000004 
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
#define     FMFD_SERVERMIME   0x00000008 
#define     UAS_EXACTLEGACY   0x00001000 
STDAPI ObtainUserAgentString(                           
                                        DWORD dwOption, 
    __out_ecount_part(*cbSize, *cbSize) LPSTR pszUAOut, 
    __inout                             DWORD *cbSize); 
STDAPI CompareSecurityIds(BYTE* pbSecurityId1, DWORD dwLen1, BYTE* pbSecurityId2, DWORD dwLen2, DWORD dwReserved);    
STDAPI CompatFlagsFromClsid(CLSID *pclsid, LPDWORD pdwCompatFlags, LPDWORD pdwMiscStatusFlags);             
 
// URLMON-specific defines for UrlMkSetSessionOption() above
#define URLMON_OPTION_USERAGENT           0x10000001
#define URLMON_OPTION_USERAGENT_REFRESH   0x10000002
#define URLMON_OPTION_URL_ENCODING        0x10000004
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#define URLMON_OPTION_USE_BINDSTRINGCREDS 0x10000008
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define URLMON_OPTION_USE_BROWSERAPPSDOCUMENTS 0x10000010
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
 
#define CF_NULL                 0                                  
#define CFSTR_MIME_NULL         NULL                               
#define CFSTR_MIME_TEXT         (TEXT("text/plain"))             
#define CFSTR_MIME_RICHTEXT     (TEXT("text/richtext"))          
#define CFSTR_MIME_X_BITMAP     (TEXT("image/x-xbitmap"))        
#define CFSTR_MIME_POSTSCRIPT   (TEXT("application/postscript")) 
#define CFSTR_MIME_AIFF         (TEXT("audio/aiff"))             
#define CFSTR_MIME_BASICAUDIO   (TEXT("audio/basic"))            
#define CFSTR_MIME_WAV          (TEXT("audio/wav"))              
#define CFSTR_MIME_X_WAV        (TEXT("audio/x-wav"))            
#define CFSTR_MIME_GIF          (TEXT("image/gif"))              
#define CFSTR_MIME_PJPEG        (TEXT("image/pjpeg"))            
#define CFSTR_MIME_JPEG         (TEXT("image/jpeg"))             
#define CFSTR_MIME_TIFF         (TEXT("image/tiff"))             
#define CFSTR_MIME_X_PNG        (TEXT("image/x-png"))            
#define CFSTR_MIME_BMP          (TEXT("image/bmp"))              
#define CFSTR_MIME_X_ART        (TEXT("image/x-jg"))             
#define CFSTR_MIME_X_EMF        (TEXT("image/x-emf"))            
#define CFSTR_MIME_X_WMF        (TEXT("image/x-wmf"))            
#define CFSTR_MIME_AVI          (TEXT("video/avi"))              
#define CFSTR_MIME_MPEG         (TEXT("video/mpeg"))             
#define CFSTR_MIME_FRACTALS     (TEXT("application/fractals"))   
#define CFSTR_MIME_RAWDATA      (TEXT("application/octet-stream"))
#define CFSTR_MIME_RAWDATASTRM  (TEXT("application/octet-stream"))
#define CFSTR_MIME_PDF          (TEXT("application/pdf"))        
#define CFSTR_MIME_HTA          (TEXT("application/hta"))        
#define CFSTR_MIME_X_AIFF       (TEXT("audio/x-aiff"))           
#define CFSTR_MIME_X_REALAUDIO  (TEXT("audio/x-pn-realaudio"))   
#define CFSTR_MIME_XBM          (TEXT("image/xbm"))              
#define CFSTR_MIME_QUICKTIME    (TEXT("video/quicktime"))        
#define CFSTR_MIME_X_MSVIDEO    (TEXT("video/x-msvideo"))        
#define CFSTR_MIME_X_SGI_MOVIE  (TEXT("video/x-sgi-movie"))      
#define CFSTR_MIME_HTML         (TEXT("text/html"))              
#define CFSTR_MIME_XML          (TEXT("text/xml"))               
 
// MessageId: MK_S_ASYNCHRONOUS                                              
// MessageText: Operation is successful, but will complete asynchronously.   
//                                                                           
#define MK_S_ASYNCHRONOUS    _HRESULT_TYPEDEF_(0x000401E8L)                  
#ifndef S_ASYNCHRONOUS                                                       
#define S_ASYNCHRONOUS       MK_S_ASYNCHRONOUS                               
#endif                                                                       
                                                                             
#ifndef E_PENDING                                                            
#define E_PENDING _HRESULT_TYPEDEF_(0x8000000AL)                             
#endif                                                                       
                                                                             
//                                                                           
//                                                                           
// WinINet and protocol specific errors are mapped to one of the following   
// error which are returned in IBSC::OnStopBinding                           
//                                                                           
//                                                                           
// Note: FACILITY C is split into ranges of 1k                               
// C0000 - C03FF  INET_E_ (URLMON's original hresult)                        
// C0400 - C07FF  INET_E_CLIENT_xxx                                          
// C0800 - C0BFF  INET_E_SERVER_xxx                                          
// C0C00 - C0FFF  INET_E_????                                                
// C1000 - C13FF  INET_E_AGENT_xxx (info delivery agents)                    
#define INET_E_INVALID_URL               _HRESULT_TYPEDEF_(0x800C0002L)      
#define INET_E_NO_SESSION                _HRESULT_TYPEDEF_(0x800C0003L)      
#define INET_E_CANNOT_CONNECT            _HRESULT_TYPEDEF_(0x800C0004L)      
#define INET_E_RESOURCE_NOT_FOUND        _HRESULT_TYPEDEF_(0x800C0005L)      
#define INET_E_OBJECT_NOT_FOUND          _HRESULT_TYPEDEF_(0x800C0006L)      
#define INET_E_DATA_NOT_AVAILABLE        _HRESULT_TYPEDEF_(0x800C0007L)      
#define INET_E_DOWNLOAD_FAILURE          _HRESULT_TYPEDEF_(0x800C0008L)      
#define INET_E_AUTHENTICATION_REQUIRED   _HRESULT_TYPEDEF_(0x800C0009L)      
#define INET_E_NO_VALID_MEDIA            _HRESULT_TYPEDEF_(0x800C000AL)      
#define INET_E_CONNECTION_TIMEOUT        _HRESULT_TYPEDEF_(0x800C000BL)      
#define INET_E_INVALID_REQUEST           _HRESULT_TYPEDEF_(0x800C000CL)      
#define INET_E_UNKNOWN_PROTOCOL          _HRESULT_TYPEDEF_(0x800C000DL)      
#define INET_E_SECURITY_PROBLEM          _HRESULT_TYPEDEF_(0x800C000EL)      
#define INET_E_CANNOT_LOAD_DATA          _HRESULT_TYPEDEF_(0x800C000FL)      
#define INET_E_CANNOT_INSTANTIATE_OBJECT _HRESULT_TYPEDEF_(0x800C0010L)      
#define INET_E_INVALID_CERTIFICATE       _HRESULT_TYPEDEF_(0x800C0019L)      
#define INET_E_REDIRECT_FAILED           _HRESULT_TYPEDEF_(0x800C0014L)      
#define INET_E_REDIRECT_TO_DIR           _HRESULT_TYPEDEF_(0x800C0015L)      
#define INET_E_CANNOT_LOCK_REQUEST                   _HRESULT_TYPEDEF_(0x800C0016L)      
#define INET_E_USE_EXTEND_BINDING                    _HRESULT_TYPEDEF_(0x800C0017L)      
#define INET_E_TERMINATED_BIND                       _HRESULT_TYPEDEF_(0x800C0018L)      
#define INET_E_RESERVED_1                            _HRESULT_TYPEDEF_(0x800C001AL)      
#define INET_E_BLOCKED_REDIRECT_XSECURITYID          _HRESULT_TYPEDEF_(0x800C001BL)      
#define INET_E_ERROR_FIRST                           _HRESULT_TYPEDEF_(0x800C0002L)      
#define INET_E_CODE_DOWNLOAD_DECLINED                _HRESULT_TYPEDEF_(0x800C0100L)      
#define INET_E_RESULT_DISPATCHED                     _HRESULT_TYPEDEF_(0x800C0200L)      
#define INET_E_CANNOT_REPLACE_SFP_FILE               _HRESULT_TYPEDEF_(0x800C0300L)      
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#define INET_E_CODE_INSTALL_SUPPRESSED               _HRESULT_TYPEDEF_(0x800C0400L)      
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
#define INET_E_CODE_INSTALL_BLOCKED_BY_HASH_POLICY   _HRESULT_TYPEDEF_(0x800C0500L)      
#define INET_E_DOWNLOAD_BLOCKED_BY_INPRIVATE         _HRESULT_TYPEDEF_(0x800C0501L)      
#define INET_E_ERROR_LAST                INET_E_DOWNLOAD_BLOCKED_BY_INPRIVATE
#ifndef _LPPERSISTMONIKER_DEFINED
#define _LPPERSISTMONIKER_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0000_v0_0_s_ifspec;

#ifndef __IPersistMoniker_INTERFACE_DEFINED__
#define __IPersistMoniker_INTERFACE_DEFINED__

/* interface IPersistMoniker */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IPersistMoniker *LPPERSISTMONIKER;


EXTERN_C const IID IID_IPersistMoniker;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9c9-baf9-11ce-8c82-00aa004ba90b")
    IPersistMoniker : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClassID( 
            /* [out] */ __RPC__out CLSID *pClassID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsDirty( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Load( 
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ __RPC__in_opt IMoniker *pimkName,
            /* [in] */ __RPC__in_opt LPBC pibc,
            /* [in] */ DWORD grfMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Save( 
            /* [in] */ __RPC__in_opt IMoniker *pimkName,
            /* [in] */ __RPC__in_opt LPBC pbc,
            /* [in] */ BOOL fRemember) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveCompleted( 
            /* [in] */ __RPC__in_opt IMoniker *pimkName,
            /* [in] */ __RPC__in_opt LPBC pibc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurMoniker( 
            /* [out] */ __RPC__deref_out_opt IMoniker **ppimkName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersistMonikerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IPersistMoniker * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IPersistMoniker * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IPersistMoniker * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            __RPC__in IPersistMoniker * This,
            /* [out] */ __RPC__out CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *IsDirty )( 
            __RPC__in IPersistMoniker * This);
        
        HRESULT ( STDMETHODCALLTYPE *Load )( 
            __RPC__in IPersistMoniker * This,
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ __RPC__in_opt IMoniker *pimkName,
            /* [in] */ __RPC__in_opt LPBC pibc,
            /* [in] */ DWORD grfMode);
        
        HRESULT ( STDMETHODCALLTYPE *Save )( 
            __RPC__in IPersistMoniker * This,
            /* [in] */ __RPC__in_opt IMoniker *pimkName,
            /* [in] */ __RPC__in_opt LPBC pbc,
            /* [in] */ BOOL fRemember);
        
        HRESULT ( STDMETHODCALLTYPE *SaveCompleted )( 
            __RPC__in IPersistMoniker * This,
            /* [in] */ __RPC__in_opt IMoniker *pimkName,
            /* [in] */ __RPC__in_opt LPBC pibc);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurMoniker )( 
            __RPC__in IPersistMoniker * This,
            /* [out] */ __RPC__deref_out_opt IMoniker **ppimkName);
        
        END_INTERFACE
    } IPersistMonikerVtbl;

    interface IPersistMoniker
    {
        CONST_VTBL struct IPersistMonikerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistMoniker_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPersistMoniker_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPersistMoniker_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPersistMoniker_GetClassID(This,pClassID)	\
    ( (This)->lpVtbl -> GetClassID(This,pClassID) ) 

#define IPersistMoniker_IsDirty(This)	\
    ( (This)->lpVtbl -> IsDirty(This) ) 

#define IPersistMoniker_Load(This,fFullyAvailable,pimkName,pibc,grfMode)	\
    ( (This)->lpVtbl -> Load(This,fFullyAvailable,pimkName,pibc,grfMode) ) 

#define IPersistMoniker_Save(This,pimkName,pbc,fRemember)	\
    ( (This)->lpVtbl -> Save(This,pimkName,pbc,fRemember) ) 

#define IPersistMoniker_SaveCompleted(This,pimkName,pibc)	\
    ( (This)->lpVtbl -> SaveCompleted(This,pimkName,pibc) ) 

#define IPersistMoniker_GetCurMoniker(This,ppimkName)	\
    ( (This)->lpVtbl -> GetCurMoniker(This,ppimkName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPersistMoniker_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0001 */
/* [local] */ 

#endif
#ifndef _LPMONIKERPROP_DEFINED
#define _LPMONIKERPROP_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0001_v0_0_s_ifspec;

#ifndef __IMonikerProp_INTERFACE_DEFINED__
#define __IMonikerProp_INTERFACE_DEFINED__

/* interface IMonikerProp */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IMonikerProp *LPMONIKERPROP;

typedef /* [public][public] */ 
enum __MIDL_IMonikerProp_0001
    {	MIMETYPEPROP	= 0,
	USE_SRC_URL	= 0x1,
	CLASSIDPROP	= 0x2,
	TRUSTEDDOWNLOADPROP	= 0x3,
	POPUPLEVELPROP	= 0x4
    } 	MONIKERPROPERTY;


EXTERN_C const IID IID_IMonikerProp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a5ca5f7f-1847-4d87-9c5b-918509f7511d")
    IMonikerProp : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PutProperty( 
            /* [in] */ MONIKERPROPERTY mkp,
            /* [in] */ __RPC__in LPCWSTR val) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMonikerPropVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMonikerProp * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMonikerProp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMonikerProp * This);
        
        HRESULT ( STDMETHODCALLTYPE *PutProperty )( 
            __RPC__in IMonikerProp * This,
            /* [in] */ MONIKERPROPERTY mkp,
            /* [in] */ __RPC__in LPCWSTR val);
        
        END_INTERFACE
    } IMonikerPropVtbl;

    interface IMonikerProp
    {
        CONST_VTBL struct IMonikerPropVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMonikerProp_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMonikerProp_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMonikerProp_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMonikerProp_PutProperty(This,mkp,val)	\
    ( (This)->lpVtbl -> PutProperty(This,mkp,val) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMonikerProp_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0002 */
/* [local] */ 

#endif
#ifndef _LPBINDPROTOCOL_DEFINED
#define _LPBINDPROTOCOL_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0002_v0_0_s_ifspec;

#ifndef __IBindProtocol_INTERFACE_DEFINED__
#define __IBindProtocol_INTERFACE_DEFINED__

/* interface IBindProtocol */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IBindProtocol *LPBINDPROTOCOL;


EXTERN_C const IID IID_IBindProtocol;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9cd-baf9-11ce-8c82-00aa004ba90b")
    IBindProtocol : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateBinding( 
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IBindCtx *pbc,
            /* [out] */ IBinding **ppb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBindProtocolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBindProtocol * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBindProtocol * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBindProtocol * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBinding )( 
            IBindProtocol * This,
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IBindCtx *pbc,
            /* [out] */ IBinding **ppb);
        
        END_INTERFACE
    } IBindProtocolVtbl;

    interface IBindProtocol
    {
        CONST_VTBL struct IBindProtocolVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBindProtocol_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBindProtocol_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBindProtocol_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBindProtocol_CreateBinding(This,szUrl,pbc,ppb)	\
    ( (This)->lpVtbl -> CreateBinding(This,szUrl,pbc,ppb) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBindProtocol_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0003 */
/* [local] */ 

#endif
#ifndef _LPBINDING_DEFINED
#define _LPBINDING_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0003_v0_0_s_ifspec;

#ifndef __IBinding_INTERFACE_DEFINED__
#define __IBinding_INTERFACE_DEFINED__

/* interface IBinding */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IBinding *LPBINDING;


EXTERN_C const IID IID_IBinding;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9c0-baf9-11ce-8c82-00aa004ba90b")
    IBinding : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPriority( 
            /* [in] */ LONG nPriority) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPriority( 
            /* [out] */ __RPC__out LONG *pnPriority) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetBindResult( 
            /* [out] */ CLSID *pclsidProtocol,
            /* [out] */ DWORD *pdwResult,
            /* [annotation][out] */ 
            __RPC__out  LPOLESTR *pszResult,
            /* [out][in] */ DWORD *pdwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBindingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IBinding * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IBinding * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            __RPC__in IBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            __RPC__in IBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            __RPC__in IBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPriority )( 
            __RPC__in IBinding * This,
            /* [in] */ LONG nPriority);
        
        HRESULT ( STDMETHODCALLTYPE *GetPriority )( 
            __RPC__in IBinding * This,
            /* [out] */ __RPC__out LONG *pnPriority);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetBindResult )( 
            IBinding * This,
            /* [out] */ CLSID *pclsidProtocol,
            /* [out] */ DWORD *pdwResult,
            /* [annotation][out] */ 
            __RPC__out  LPOLESTR *pszResult,
            /* [out][in] */ DWORD *pdwReserved);
        
        END_INTERFACE
    } IBindingVtbl;

    interface IBinding
    {
        CONST_VTBL struct IBindingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBinding_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBinding_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBinding_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBinding_Abort(This)	\
    ( (This)->lpVtbl -> Abort(This) ) 

#define IBinding_Suspend(This)	\
    ( (This)->lpVtbl -> Suspend(This) ) 

#define IBinding_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 

#define IBinding_SetPriority(This,nPriority)	\
    ( (This)->lpVtbl -> SetPriority(This,nPriority) ) 

#define IBinding_GetPriority(This,pnPriority)	\
    ( (This)->lpVtbl -> GetPriority(This,pnPriority) ) 

#define IBinding_GetBindResult(This,pclsidProtocol,pdwResult,pszResult,pdwReserved)	\
    ( (This)->lpVtbl -> GetBindResult(This,pclsidProtocol,pdwResult,pszResult,pdwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IBinding_RemoteGetBindResult_Proxy( 
    __RPC__in IBinding * This,
    /* [out] */ __RPC__out CLSID *pclsidProtocol,
    /* [out] */ __RPC__out DWORD *pdwResult,
    /* [out] */ __RPC__deref_out_opt LPOLESTR *pszResult,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IBinding_RemoteGetBindResult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBinding_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0004 */
/* [local] */ 

#endif
#ifndef _LPBINDSTATUSCALLBACK_DEFINED
#define _LPBINDSTATUSCALLBACK_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0004_v0_0_s_ifspec;

#ifndef __IBindStatusCallback_INTERFACE_DEFINED__
#define __IBindStatusCallback_INTERFACE_DEFINED__

/* interface IBindStatusCallback */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IBindStatusCallback *LPBINDSTATUSCALLBACK;

typedef /* [public] */ 
enum __MIDL_IBindStatusCallback_0001
    {	BINDVERB_GET	= 0,
	BINDVERB_POST	= 0x1,
	BINDVERB_PUT	= 0x2,
	BINDVERB_CUSTOM	= 0x3,
	BINDVERB_RESERVED1	= 0x4
    } 	BINDVERB;

typedef /* [public] */ 
enum __MIDL_IBindStatusCallback_0002
    {	BINDINFOF_URLENCODESTGMEDDATA	= 0x1,
	BINDINFOF_URLENCODEDEXTRAINFO	= 0x2
    } 	BINDINFOF;

typedef /* [public] */ 
enum __MIDL_IBindStatusCallback_0003
    {	BINDF_ASYNCHRONOUS	= 0x1,
	BINDF_ASYNCSTORAGE	= 0x2,
	BINDF_NOPROGRESSIVERENDERING	= 0x4,
	BINDF_OFFLINEOPERATION	= 0x8,
	BINDF_GETNEWESTVERSION	= 0x10,
	BINDF_NOWRITECACHE	= 0x20,
	BINDF_NEEDFILE	= 0x40,
	BINDF_PULLDATA	= 0x80,
	BINDF_IGNORESECURITYPROBLEM	= 0x100,
	BINDF_RESYNCHRONIZE	= 0x200,
	BINDF_HYPERLINK	= 0x400,
	BINDF_NO_UI	= 0x800,
	BINDF_SILENTOPERATION	= 0x1000,
	BINDF_PRAGMA_NO_CACHE	= 0x2000,
	BINDF_GETCLASSOBJECT	= 0x4000,
	BINDF_RESERVED_1	= 0x8000,
	BINDF_FREE_THREADED	= 0x10000,
	BINDF_DIRECT_READ	= 0x20000,
	BINDF_FORMS_SUBMIT	= 0x40000,
	BINDF_GETFROMCACHE_IF_NET_FAIL	= 0x80000,
	BINDF_FROMURLMON	= 0x100000,
	BINDF_FWD_BACK	= 0x200000,
	BINDF_PREFERDEFAULTHANDLER	= 0x400000,
	BINDF_ENFORCERESTRICTED	= 0x800000
    } 	BINDF;

typedef /* [public] */ 
enum __MIDL_IBindStatusCallback_0004
    {	URL_ENCODING_NONE	= 0,
	URL_ENCODING_ENABLE_UTF8	= 0x10000000,
	URL_ENCODING_DISABLE_UTF8	= 0x20000000
    } 	URL_ENCODING;

typedef struct _tagBINDINFO
    {
    ULONG cbSize;
    LPWSTR szExtraInfo;
    STGMEDIUM stgmedData;
    DWORD grfBindInfoF;
    DWORD dwBindVerb;
    LPWSTR szCustomVerb;
    DWORD cbstgmedData;
    DWORD dwOptions;
    DWORD dwOptionsFlags;
    DWORD dwCodePage;
    SECURITY_ATTRIBUTES securityAttributes;
    IID iid;
    IUnknown *pUnk;
    DWORD dwReserved;
    } 	BINDINFO;

typedef struct _REMSECURITY_ATTRIBUTES
    {
    DWORD nLength;
    DWORD lpSecurityDescriptor;
    BOOL bInheritHandle;
    } 	REMSECURITY_ATTRIBUTES;

typedef struct _REMSECURITY_ATTRIBUTES *PREMSECURITY_ATTRIBUTES;

typedef struct _REMSECURITY_ATTRIBUTES *LPREMSECURITY_ATTRIBUTES;

typedef struct _tagRemBINDINFO
    {
    ULONG cbSize;
    LPWSTR szExtraInfo;
    DWORD grfBindInfoF;
    DWORD dwBindVerb;
    LPWSTR szCustomVerb;
    DWORD cbstgmedData;
    DWORD dwOptions;
    DWORD dwOptionsFlags;
    DWORD dwCodePage;
    REMSECURITY_ATTRIBUTES securityAttributes;
    IID iid;
    IUnknown *pUnk;
    DWORD dwReserved;
    } 	RemBINDINFO;

typedef struct tagRemFORMATETC
    {
    DWORD cfFormat;
    DWORD ptd;
    DWORD dwAspect;
    LONG lindex;
    DWORD tymed;
    } 	RemFORMATETC;

typedef struct tagRemFORMATETC *LPREMFORMATETC;

typedef /* [public] */ 
enum __MIDL_IBindStatusCallback_0005
    {	BINDINFO_OPTIONS_WININETFLAG	= 0x10000,
	BINDINFO_OPTIONS_ENABLE_UTF8	= 0x20000,
	BINDINFO_OPTIONS_DISABLE_UTF8	= 0x40000,
	BINDINFO_OPTIONS_USE_IE_ENCODING	= 0x80000,
	BINDINFO_OPTIONS_BINDTOOBJECT	= 0x100000,
	BINDINFO_OPTIONS_SECURITYOPTOUT	= 0x200000,
	BINDINFO_OPTIONS_IGNOREMIMETEXTPLAIN	= 0x400000,
	BINDINFO_OPTIONS_USEBINDSTRINGCREDS	= 0x800000,
	BINDINFO_OPTIONS_IGNOREHTTPHTTPSREDIRECTS	= 0x1000000,
	BINDINFO_OPTIONS_IGNORE_SSLERRORS_ONCE	= 0x2000000,
	BINDINFO_WPC_DOWNLOADBLOCKED	= 0x8000000,
	BINDINFO_WPC_LOGGING_ENABLED	= 0x10000000,
	BINDINFO_OPTIONS_ALLOWCONNECTDATA	= 0x20000000,
	BINDINFO_OPTIONS_DISABLEAUTOREDIRECTS	= 0x40000000,
	BINDINFO_OPTIONS_SHDOCVW_NAVIGATE	= ( int  )0x80000000
    } 	BINDINFO_OPTIONS;

typedef /* [public] */ 
enum __MIDL_IBindStatusCallback_0006
    {	BSCF_FIRSTDATANOTIFICATION	= 0x1,
	BSCF_INTERMEDIATEDATANOTIFICATION	= 0x2,
	BSCF_LASTDATANOTIFICATION	= 0x4,
	BSCF_DATAFULLYAVAILABLE	= 0x8,
	BSCF_AVAILABLEDATASIZEUNKNOWN	= 0x10,
	BSCF_SKIPDRAINDATAFORFILEURLS	= 0x20,
	BSCF_64BITLENGTHDOWNLOAD	= 0x40
    } 	BSCF;

typedef 
enum tagBINDSTATUS
    {	BINDSTATUS_FINDINGRESOURCE	= 1,
	BINDSTATUS_CONNECTING	= ( BINDSTATUS_FINDINGRESOURCE + 1 ) ,
	BINDSTATUS_REDIRECTING	= ( BINDSTATUS_CONNECTING + 1 ) ,
	BINDSTATUS_BEGINDOWNLOADDATA	= ( BINDSTATUS_REDIRECTING + 1 ) ,
	BINDSTATUS_DOWNLOADINGDATA	= ( BINDSTATUS_BEGINDOWNLOADDATA + 1 ) ,
	BINDSTATUS_ENDDOWNLOADDATA	= ( BINDSTATUS_DOWNLOADINGDATA + 1 ) ,
	BINDSTATUS_BEGINDOWNLOADCOMPONENTS	= ( BINDSTATUS_ENDDOWNLOADDATA + 1 ) ,
	BINDSTATUS_INSTALLINGCOMPONENTS	= ( BINDSTATUS_BEGINDOWNLOADCOMPONENTS + 1 ) ,
	BINDSTATUS_ENDDOWNLOADCOMPONENTS	= ( BINDSTATUS_INSTALLINGCOMPONENTS + 1 ) ,
	BINDSTATUS_USINGCACHEDCOPY	= ( BINDSTATUS_ENDDOWNLOADCOMPONENTS + 1 ) ,
	BINDSTATUS_SENDINGREQUEST	= ( BINDSTATUS_USINGCACHEDCOPY + 1 ) ,
	BINDSTATUS_CLASSIDAVAILABLE	= ( BINDSTATUS_SENDINGREQUEST + 1 ) ,
	BINDSTATUS_MIMETYPEAVAILABLE	= ( BINDSTATUS_CLASSIDAVAILABLE + 1 ) ,
	BINDSTATUS_CACHEFILENAMEAVAILABLE	= ( BINDSTATUS_MIMETYPEAVAILABLE + 1 ) ,
	BINDSTATUS_BEGINSYNCOPERATION	= ( BINDSTATUS_CACHEFILENAMEAVAILABLE + 1 ) ,
	BINDSTATUS_ENDSYNCOPERATION	= ( BINDSTATUS_BEGINSYNCOPERATION + 1 ) ,
	BINDSTATUS_BEGINUPLOADDATA	= ( BINDSTATUS_ENDSYNCOPERATION + 1 ) ,
	BINDSTATUS_UPLOADINGDATA	= ( BINDSTATUS_BEGINUPLOADDATA + 1 ) ,
	BINDSTATUS_ENDUPLOADDATA	= ( BINDSTATUS_UPLOADINGDATA + 1 ) ,
	BINDSTATUS_PROTOCOLCLASSID	= ( BINDSTATUS_ENDUPLOADDATA + 1 ) ,
	BINDSTATUS_ENCODING	= ( BINDSTATUS_PROTOCOLCLASSID + 1 ) ,
	BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE	= ( BINDSTATUS_ENCODING + 1 ) ,
	BINDSTATUS_CLASSINSTALLLOCATION	= ( BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE + 1 ) ,
	BINDSTATUS_DECODING	= ( BINDSTATUS_CLASSINSTALLLOCATION + 1 ) ,
	BINDSTATUS_LOADINGMIMEHANDLER	= ( BINDSTATUS_DECODING + 1 ) ,
	BINDSTATUS_CONTENTDISPOSITIONATTACH	= ( BINDSTATUS_LOADINGMIMEHANDLER + 1 ) ,
	BINDSTATUS_FILTERREPORTMIMETYPE	= ( BINDSTATUS_CONTENTDISPOSITIONATTACH + 1 ) ,
	BINDSTATUS_CLSIDCANINSTANTIATE	= ( BINDSTATUS_FILTERREPORTMIMETYPE + 1 ) ,
	BINDSTATUS_IUNKNOWNAVAILABLE	= ( BINDSTATUS_CLSIDCANINSTANTIATE + 1 ) ,
	BINDSTATUS_DIRECTBIND	= ( BINDSTATUS_IUNKNOWNAVAILABLE + 1 ) ,
	BINDSTATUS_RAWMIMETYPE	= ( BINDSTATUS_DIRECTBIND + 1 ) ,
	BINDSTATUS_PROXYDETECTING	= ( BINDSTATUS_RAWMIMETYPE + 1 ) ,
	BINDSTATUS_ACCEPTRANGES	= ( BINDSTATUS_PROXYDETECTING + 1 ) ,
	BINDSTATUS_COOKIE_SENT	= ( BINDSTATUS_ACCEPTRANGES + 1 ) ,
	BINDSTATUS_COMPACT_POLICY_RECEIVED	= ( BINDSTATUS_COOKIE_SENT + 1 ) ,
	BINDSTATUS_COOKIE_SUPPRESSED	= ( BINDSTATUS_COMPACT_POLICY_RECEIVED + 1 ) ,
	BINDSTATUS_COOKIE_STATE_UNKNOWN	= ( BINDSTATUS_COOKIE_SUPPRESSED + 1 ) ,
	BINDSTATUS_COOKIE_STATE_ACCEPT	= ( BINDSTATUS_COOKIE_STATE_UNKNOWN + 1 ) ,
	BINDSTATUS_COOKIE_STATE_REJECT	= ( BINDSTATUS_COOKIE_STATE_ACCEPT + 1 ) ,
	BINDSTATUS_COOKIE_STATE_PROMPT	= ( BINDSTATUS_COOKIE_STATE_REJECT + 1 ) ,
	BINDSTATUS_COOKIE_STATE_LEASH	= ( BINDSTATUS_COOKIE_STATE_PROMPT + 1 ) ,
	BINDSTATUS_COOKIE_STATE_DOWNGRADE	= ( BINDSTATUS_COOKIE_STATE_LEASH + 1 ) ,
	BINDSTATUS_POLICY_HREF	= ( BINDSTATUS_COOKIE_STATE_DOWNGRADE + 1 ) ,
	BINDSTATUS_P3P_HEADER	= ( BINDSTATUS_POLICY_HREF + 1 ) ,
	BINDSTATUS_SESSION_COOKIE_RECEIVED	= ( BINDSTATUS_P3P_HEADER + 1 ) ,
	BINDSTATUS_PERSISTENT_COOKIE_RECEIVED	= ( BINDSTATUS_SESSION_COOKIE_RECEIVED + 1 ) ,
	BINDSTATUS_SESSION_COOKIES_ALLOWED	= ( BINDSTATUS_PERSISTENT_COOKIE_RECEIVED + 1 ) ,
	BINDSTATUS_CACHECONTROL	= ( BINDSTATUS_SESSION_COOKIES_ALLOWED + 1 ) ,
	BINDSTATUS_CONTENTDISPOSITIONFILENAME	= ( BINDSTATUS_CACHECONTROL + 1 ) ,
	BINDSTATUS_MIMETEXTPLAINMISMATCH	= ( BINDSTATUS_CONTENTDISPOSITIONFILENAME + 1 ) ,
	BINDSTATUS_PUBLISHERAVAILABLE	= ( BINDSTATUS_MIMETEXTPLAINMISMATCH + 1 ) ,
	BINDSTATUS_DISPLAYNAMEAVAILABLE	= ( BINDSTATUS_PUBLISHERAVAILABLE + 1 ) ,
	BINDSTATUS_SSLUX_NAVBLOCKED	= ( BINDSTATUS_DISPLAYNAMEAVAILABLE + 1 ) ,
	BINDSTATUS_SERVER_MIMETYPEAVAILABLE	= ( BINDSTATUS_SSLUX_NAVBLOCKED + 1 ) ,
	BINDSTATUS_SNIFFED_CLASSIDAVAILABLE	= ( BINDSTATUS_SERVER_MIMETYPEAVAILABLE + 1 ) ,
	BINDSTATUS_64BIT_PROGRESS	= ( BINDSTATUS_SNIFFED_CLASSIDAVAILABLE + 1 ) 
    } 	BINDSTATUS;


EXTERN_C const IID IID_IBindStatusCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9c1-baf9-11ce-8c82-00aa004ba90b")
    IBindStatusCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStartBinding( 
            /* [in] */ DWORD dwReserved,
            /* [in] */ __RPC__in_opt IBinding *pib) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPriority( 
            /* [out] */ __RPC__out LONG *pnPriority) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnLowResource( 
            /* [in] */ DWORD reserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnProgress( 
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [unique][in] */ __RPC__in_opt LPCWSTR szStatusText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStopBinding( 
            /* [in] */ HRESULT hresult,
            /* [unique][in] */ __RPC__in_opt LPCWSTR szError) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetBindInfo( 
            /* [out] */ DWORD *grfBINDF,
            /* [unique][out][in] */ BINDINFO *pbindinfo) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE OnDataAvailable( 
            /* [in] */ DWORD grfBSCF,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC *pformatetc,
            /* [in] */ STGMEDIUM *pstgmed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnObjectAvailable( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][in] */ __RPC__in_opt IUnknown *punk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBindStatusCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IBindStatusCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IBindStatusCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IBindStatusCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStartBinding )( 
            __RPC__in IBindStatusCallback * This,
            /* [in] */ DWORD dwReserved,
            /* [in] */ __RPC__in_opt IBinding *pib);
        
        HRESULT ( STDMETHODCALLTYPE *GetPriority )( 
            __RPC__in IBindStatusCallback * This,
            /* [out] */ __RPC__out LONG *pnPriority);
        
        HRESULT ( STDMETHODCALLTYPE *OnLowResource )( 
            __RPC__in IBindStatusCallback * This,
            /* [in] */ DWORD reserved);
        
        HRESULT ( STDMETHODCALLTYPE *OnProgress )( 
            __RPC__in IBindStatusCallback * This,
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [unique][in] */ __RPC__in_opt LPCWSTR szStatusText);
        
        HRESULT ( STDMETHODCALLTYPE *OnStopBinding )( 
            __RPC__in IBindStatusCallback * This,
            /* [in] */ HRESULT hresult,
            /* [unique][in] */ __RPC__in_opt LPCWSTR szError);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetBindInfo )( 
            IBindStatusCallback * This,
            /* [out] */ DWORD *grfBINDF,
            /* [unique][out][in] */ BINDINFO *pbindinfo);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *OnDataAvailable )( 
            IBindStatusCallback * This,
            /* [in] */ DWORD grfBSCF,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC *pformatetc,
            /* [in] */ STGMEDIUM *pstgmed);
        
        HRESULT ( STDMETHODCALLTYPE *OnObjectAvailable )( 
            __RPC__in IBindStatusCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][in] */ __RPC__in_opt IUnknown *punk);
        
        END_INTERFACE
    } IBindStatusCallbackVtbl;

    interface IBindStatusCallback
    {
        CONST_VTBL struct IBindStatusCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBindStatusCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBindStatusCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBindStatusCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBindStatusCallback_OnStartBinding(This,dwReserved,pib)	\
    ( (This)->lpVtbl -> OnStartBinding(This,dwReserved,pib) ) 

#define IBindStatusCallback_GetPriority(This,pnPriority)	\
    ( (This)->lpVtbl -> GetPriority(This,pnPriority) ) 

#define IBindStatusCallback_OnLowResource(This,reserved)	\
    ( (This)->lpVtbl -> OnLowResource(This,reserved) ) 

#define IBindStatusCallback_OnProgress(This,ulProgress,ulProgressMax,ulStatusCode,szStatusText)	\
    ( (This)->lpVtbl -> OnProgress(This,ulProgress,ulProgressMax,ulStatusCode,szStatusText) ) 

#define IBindStatusCallback_OnStopBinding(This,hresult,szError)	\
    ( (This)->lpVtbl -> OnStopBinding(This,hresult,szError) ) 

#define IBindStatusCallback_GetBindInfo(This,grfBINDF,pbindinfo)	\
    ( (This)->lpVtbl -> GetBindInfo(This,grfBINDF,pbindinfo) ) 

#define IBindStatusCallback_OnDataAvailable(This,grfBSCF,dwSize,pformatetc,pstgmed)	\
    ( (This)->lpVtbl -> OnDataAvailable(This,grfBSCF,dwSize,pformatetc,pstgmed) ) 

#define IBindStatusCallback_OnObjectAvailable(This,riid,punk)	\
    ( (This)->lpVtbl -> OnObjectAvailable(This,riid,punk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_RemoteGetBindInfo_Proxy( 
    __RPC__in IBindStatusCallback * This,
    /* [out] */ __RPC__out DWORD *grfBINDF,
    /* [unique][out][in] */ __RPC__inout_opt RemBINDINFO *pbindinfo,
    /* [unique][out][in] */ __RPC__inout_opt RemSTGMEDIUM *pstgmed);


void __RPC_STUB IBindStatusCallback_RemoteGetBindInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_RemoteOnDataAvailable_Proxy( 
    __RPC__in IBindStatusCallback * This,
    /* [in] */ DWORD grfBSCF,
    /* [in] */ DWORD dwSize,
    /* [in] */ __RPC__in RemFORMATETC *pformatetc,
    /* [in] */ __RPC__in RemSTGMEDIUM *pstgmed);


void __RPC_STUB IBindStatusCallback_RemoteOnDataAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBindStatusCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0005 */
/* [local] */ 

#endif
#ifndef _LPBINDSTATUSCALLBACKEX_DEFINED
#define _LPBINDSTATUSCALLBACKEX_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0005_v0_0_s_ifspec;

#ifndef __IBindStatusCallbackEx_INTERFACE_DEFINED__
#define __IBindStatusCallbackEx_INTERFACE_DEFINED__

/* interface IBindStatusCallbackEx */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IBindStatusCallbackEx *LPBINDSTATUSCALLBACKEX;

typedef /* [public] */ 
enum __MIDL_IBindStatusCallbackEx_0001
    {	BINDF2_DISABLEBASICOVERHTTP	= 0x1,
	BINDF2_DISABLEAUTOCOOKIEHANDLING	= 0x2,
	BINDF2_READ_DATA_GREATER_THAN_4GB	= 0x4,
	BINDF2_DISABLE_HTTP_REDIRECT_XSECURITYID	= 0x8,
	BINDF2_RESERVED_3	= 0x20000000,
	BINDF2_RESERVED_2	= 0x40000000,
	BINDF2_RESERVED_1	= 0x80000000
    } 	BINDF2;


EXTERN_C const IID IID_IBindStatusCallbackEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aaa74ef9-8ee7-4659-88d9-f8c504da73cc")
    IBindStatusCallbackEx : public IBindStatusCallback
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetBindInfoEx( 
            /* [out] */ DWORD *grfBINDF,
            /* [unique][out][in] */ BINDINFO *pbindinfo,
            /* [out] */ DWORD *grfBINDF2,
            /* [out] */ DWORD *pdwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBindStatusCallbackExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IBindStatusCallbackEx * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IBindStatusCallbackEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IBindStatusCallbackEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStartBinding )( 
            __RPC__in IBindStatusCallbackEx * This,
            /* [in] */ DWORD dwReserved,
            /* [in] */ __RPC__in_opt IBinding *pib);
        
        HRESULT ( STDMETHODCALLTYPE *GetPriority )( 
            __RPC__in IBindStatusCallbackEx * This,
            /* [out] */ __RPC__out LONG *pnPriority);
        
        HRESULT ( STDMETHODCALLTYPE *OnLowResource )( 
            __RPC__in IBindStatusCallbackEx * This,
            /* [in] */ DWORD reserved);
        
        HRESULT ( STDMETHODCALLTYPE *OnProgress )( 
            __RPC__in IBindStatusCallbackEx * This,
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [unique][in] */ __RPC__in_opt LPCWSTR szStatusText);
        
        HRESULT ( STDMETHODCALLTYPE *OnStopBinding )( 
            __RPC__in IBindStatusCallbackEx * This,
            /* [in] */ HRESULT hresult,
            /* [unique][in] */ __RPC__in_opt LPCWSTR szError);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetBindInfo )( 
            IBindStatusCallbackEx * This,
            /* [out] */ DWORD *grfBINDF,
            /* [unique][out][in] */ BINDINFO *pbindinfo);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *OnDataAvailable )( 
            IBindStatusCallbackEx * This,
            /* [in] */ DWORD grfBSCF,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC *pformatetc,
            /* [in] */ STGMEDIUM *pstgmed);
        
        HRESULT ( STDMETHODCALLTYPE *OnObjectAvailable )( 
            __RPC__in IBindStatusCallbackEx * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][in] */ __RPC__in_opt IUnknown *punk);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetBindInfoEx )( 
            IBindStatusCallbackEx * This,
            /* [out] */ DWORD *grfBINDF,
            /* [unique][out][in] */ BINDINFO *pbindinfo,
            /* [out] */ DWORD *grfBINDF2,
            /* [out] */ DWORD *pdwReserved);
        
        END_INTERFACE
    } IBindStatusCallbackExVtbl;

    interface IBindStatusCallbackEx
    {
        CONST_VTBL struct IBindStatusCallbackExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBindStatusCallbackEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBindStatusCallbackEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBindStatusCallbackEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBindStatusCallbackEx_OnStartBinding(This,dwReserved,pib)	\
    ( (This)->lpVtbl -> OnStartBinding(This,dwReserved,pib) ) 

#define IBindStatusCallbackEx_GetPriority(This,pnPriority)	\
    ( (This)->lpVtbl -> GetPriority(This,pnPriority) ) 

#define IBindStatusCallbackEx_OnLowResource(This,reserved)	\
    ( (This)->lpVtbl -> OnLowResource(This,reserved) ) 

#define IBindStatusCallbackEx_OnProgress(This,ulProgress,ulProgressMax,ulStatusCode,szStatusText)	\
    ( (This)->lpVtbl -> OnProgress(This,ulProgress,ulProgressMax,ulStatusCode,szStatusText) ) 

#define IBindStatusCallbackEx_OnStopBinding(This,hresult,szError)	\
    ( (This)->lpVtbl -> OnStopBinding(This,hresult,szError) ) 

#define IBindStatusCallbackEx_GetBindInfo(This,grfBINDF,pbindinfo)	\
    ( (This)->lpVtbl -> GetBindInfo(This,grfBINDF,pbindinfo) ) 

#define IBindStatusCallbackEx_OnDataAvailable(This,grfBSCF,dwSize,pformatetc,pstgmed)	\
    ( (This)->lpVtbl -> OnDataAvailable(This,grfBSCF,dwSize,pformatetc,pstgmed) ) 

#define IBindStatusCallbackEx_OnObjectAvailable(This,riid,punk)	\
    ( (This)->lpVtbl -> OnObjectAvailable(This,riid,punk) ) 


#define IBindStatusCallbackEx_GetBindInfoEx(This,grfBINDF,pbindinfo,grfBINDF2,pdwReserved)	\
    ( (This)->lpVtbl -> GetBindInfoEx(This,grfBINDF,pbindinfo,grfBINDF2,pdwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindStatusCallbackEx_RemoteGetBindInfoEx_Proxy( 
    __RPC__in IBindStatusCallbackEx * This,
    /* [out] */ __RPC__out DWORD *grfBINDF,
    /* [unique][out][in] */ __RPC__inout_opt RemBINDINFO *pbindinfo,
    /* [unique][out][in] */ __RPC__inout_opt RemSTGMEDIUM *pstgmed,
    /* [out] */ __RPC__out DWORD *grfBINDF2,
    /* [out] */ __RPC__out DWORD *pdwReserved);


void __RPC_STUB IBindStatusCallbackEx_RemoteGetBindInfoEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBindStatusCallbackEx_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0006 */
/* [local] */ 

#endif
#ifndef _LPAUTHENTICATION_DEFINED
#define _LPAUTHENTICATION_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0006_v0_0_s_ifspec;

#ifndef __IAuthenticate_INTERFACE_DEFINED__
#define __IAuthenticate_INTERFACE_DEFINED__

/* interface IAuthenticate */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IAuthenticate *LPAUTHENTICATION;


EXTERN_C const IID IID_IAuthenticate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9d0-baf9-11ce-8c82-00aa004ba90b")
    IAuthenticate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Authenticate( 
            /* [out] */ __RPC__deref_out_opt HWND *phwnd,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pszUsername,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pszPassword) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAuthenticateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IAuthenticate * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IAuthenticate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IAuthenticate * This);
        
        HRESULT ( STDMETHODCALLTYPE *Authenticate )( 
            __RPC__in IAuthenticate * This,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pszUsername,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pszPassword);
        
        END_INTERFACE
    } IAuthenticateVtbl;

    interface IAuthenticate
    {
        CONST_VTBL struct IAuthenticateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAuthenticate_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAuthenticate_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAuthenticate_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAuthenticate_Authenticate(This,phwnd,pszUsername,pszPassword)	\
    ( (This)->lpVtbl -> Authenticate(This,phwnd,pszUsername,pszPassword) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAuthenticate_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0007 */
/* [local] */ 

#endif
#ifndef _LPAUTHENTICATIONEX_DEFINED
#define _LPAUTHENTICATIONEX_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0007_v0_0_s_ifspec;

#ifndef __IAuthenticateEx_INTERFACE_DEFINED__
#define __IAuthenticateEx_INTERFACE_DEFINED__

/* interface IAuthenticateEx */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IAuthenticateEx *LPAUTHENTICATIONEX;

typedef /* [public] */ 
enum __MIDL_IAuthenticateEx_0001
    {	AUTHENTICATEF_PROXY	= 0x1,
	AUTHENTICATEF_BASIC	= 0x2,
	AUTHENTICATEF_HTTP	= 0x4
    } 	AUTHENTICATEF;

typedef struct _tagAUTHENTICATEINFO
    {
    DWORD dwFlags;
    DWORD dwReserved;
    } 	AUTHENTICATEINFO;


EXTERN_C const IID IID_IAuthenticateEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2ad1edaf-d83d-48b5-9adf-03dbe19f53bd")
    IAuthenticateEx : public IAuthenticate
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AuthenticateEx( 
            /* [out] */ __RPC__deref_out_opt HWND *phwnd,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pszUsername,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pszPassword,
            /* [in] */ __RPC__in AUTHENTICATEINFO *pauthinfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAuthenticateExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IAuthenticateEx * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IAuthenticateEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IAuthenticateEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *Authenticate )( 
            __RPC__in IAuthenticateEx * This,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pszUsername,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pszPassword);
        
        HRESULT ( STDMETHODCALLTYPE *AuthenticateEx )( 
            __RPC__in IAuthenticateEx * This,
            /* [out] */ __RPC__deref_out_opt HWND *phwnd,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pszUsername,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pszPassword,
            /* [in] */ __RPC__in AUTHENTICATEINFO *pauthinfo);
        
        END_INTERFACE
    } IAuthenticateExVtbl;

    interface IAuthenticateEx
    {
        CONST_VTBL struct IAuthenticateExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAuthenticateEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAuthenticateEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAuthenticateEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAuthenticateEx_Authenticate(This,phwnd,pszUsername,pszPassword)	\
    ( (This)->lpVtbl -> Authenticate(This,phwnd,pszUsername,pszPassword) ) 


#define IAuthenticateEx_AuthenticateEx(This,phwnd,pszUsername,pszPassword,pauthinfo)	\
    ( (This)->lpVtbl -> AuthenticateEx(This,phwnd,pszUsername,pszPassword,pauthinfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAuthenticateEx_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0008 */
/* [local] */ 

#endif
#ifndef _LPHTTPNEGOTIATE_DEFINED
#define _LPHTTPNEGOTIATE_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0008_v0_0_s_ifspec;

#ifndef __IHttpNegotiate_INTERFACE_DEFINED__
#define __IHttpNegotiate_INTERFACE_DEFINED__

/* interface IHttpNegotiate */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IHttpNegotiate *LPHTTPNEGOTIATE;


EXTERN_C const IID IID_IHttpNegotiate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9d2-baf9-11ce-8c82-00aa004ba90b")
    IHttpNegotiate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BeginningTransaction( 
            /* [in] */ __RPC__in LPCWSTR szURL,
            /* [unique][in] */ __RPC__in_opt LPCWSTR szHeaders,
            /* [in] */ DWORD dwReserved,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pszAdditionalHeaders) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnResponse( 
            /* [in] */ DWORD dwResponseCode,
            /* [unique][in] */ __RPC__in_opt LPCWSTR szResponseHeaders,
            /* [unique][in] */ __RPC__in_opt LPCWSTR szRequestHeaders,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pszAdditionalRequestHeaders) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHttpNegotiateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IHttpNegotiate * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IHttpNegotiate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IHttpNegotiate * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginningTransaction )( 
            __RPC__in IHttpNegotiate * This,
            /* [in] */ __RPC__in LPCWSTR szURL,
            /* [unique][in] */ __RPC__in_opt LPCWSTR szHeaders,
            /* [in] */ DWORD dwReserved,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pszAdditionalHeaders);
        
        HRESULT ( STDMETHODCALLTYPE *OnResponse )( 
            __RPC__in IHttpNegotiate * This,
            /* [in] */ DWORD dwResponseCode,
            /* [unique][in] */ __RPC__in_opt LPCWSTR szResponseHeaders,
            /* [unique][in] */ __RPC__in_opt LPCWSTR szRequestHeaders,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pszAdditionalRequestHeaders);
        
        END_INTERFACE
    } IHttpNegotiateVtbl;

    interface IHttpNegotiate
    {
        CONST_VTBL struct IHttpNegotiateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHttpNegotiate_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHttpNegotiate_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHttpNegotiate_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHttpNegotiate_BeginningTransaction(This,szURL,szHeaders,dwReserved,pszAdditionalHeaders)	\
    ( (This)->lpVtbl -> BeginningTransaction(This,szURL,szHeaders,dwReserved,pszAdditionalHeaders) ) 

#define IHttpNegotiate_OnResponse(This,dwResponseCode,szResponseHeaders,szRequestHeaders,pszAdditionalRequestHeaders)	\
    ( (This)->lpVtbl -> OnResponse(This,dwResponseCode,szResponseHeaders,szRequestHeaders,pszAdditionalRequestHeaders) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHttpNegotiate_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0009 */
/* [local] */ 

#endif
#ifndef _LPHTTPNEGOTIATE2_DEFINED
#define _LPHTTPNEGOTIATE2_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0009_v0_0_s_ifspec;

#ifndef __IHttpNegotiate2_INTERFACE_DEFINED__
#define __IHttpNegotiate2_INTERFACE_DEFINED__

/* interface IHttpNegotiate2 */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IHttpNegotiate2 *LPHTTPNEGOTIATE2;


EXTERN_C const IID IID_IHttpNegotiate2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4F9F9FCB-E0F4-48eb-B7AB-FA2EA9365CB4")
    IHttpNegotiate2 : public IHttpNegotiate
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRootSecurityId( 
            /* [size_is][out] */ __RPC__out_ecount_full(*pcbSecurityId) BYTE *pbSecurityId,
            /* [out][in] */ __RPC__inout DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHttpNegotiate2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IHttpNegotiate2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IHttpNegotiate2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IHttpNegotiate2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginningTransaction )( 
            __RPC__in IHttpNegotiate2 * This,
            /* [in] */ __RPC__in LPCWSTR szURL,
            /* [unique][in] */ __RPC__in_opt LPCWSTR szHeaders,
            /* [in] */ DWORD dwReserved,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pszAdditionalHeaders);
        
        HRESULT ( STDMETHODCALLTYPE *OnResponse )( 
            __RPC__in IHttpNegotiate2 * This,
            /* [in] */ DWORD dwResponseCode,
            /* [unique][in] */ __RPC__in_opt LPCWSTR szResponseHeaders,
            /* [unique][in] */ __RPC__in_opt LPCWSTR szRequestHeaders,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pszAdditionalRequestHeaders);
        
        HRESULT ( STDMETHODCALLTYPE *GetRootSecurityId )( 
            __RPC__in IHttpNegotiate2 * This,
            /* [size_is][out] */ __RPC__out_ecount_full(*pcbSecurityId) BYTE *pbSecurityId,
            /* [out][in] */ __RPC__inout DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved);
        
        END_INTERFACE
    } IHttpNegotiate2Vtbl;

    interface IHttpNegotiate2
    {
        CONST_VTBL struct IHttpNegotiate2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHttpNegotiate2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHttpNegotiate2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHttpNegotiate2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHttpNegotiate2_BeginningTransaction(This,szURL,szHeaders,dwReserved,pszAdditionalHeaders)	\
    ( (This)->lpVtbl -> BeginningTransaction(This,szURL,szHeaders,dwReserved,pszAdditionalHeaders) ) 

#define IHttpNegotiate2_OnResponse(This,dwResponseCode,szResponseHeaders,szRequestHeaders,pszAdditionalRequestHeaders)	\
    ( (This)->lpVtbl -> OnResponse(This,dwResponseCode,szResponseHeaders,szRequestHeaders,pszAdditionalRequestHeaders) ) 


#define IHttpNegotiate2_GetRootSecurityId(This,pbSecurityId,pcbSecurityId,dwReserved)	\
    ( (This)->lpVtbl -> GetRootSecurityId(This,pbSecurityId,pcbSecurityId,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHttpNegotiate2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0010 */
/* [local] */ 

#endif
#ifndef _LPHTTPNEGOTIATE3_DEFINED
#define _LPHTTPNEGOTIATE3_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0010_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0010_v0_0_s_ifspec;

#ifndef __IHttpNegotiate3_INTERFACE_DEFINED__
#define __IHttpNegotiate3_INTERFACE_DEFINED__

/* interface IHttpNegotiate3 */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IHttpNegotiate3 *LPHTTPNEGOTIATE3;


EXTERN_C const IID IID_IHttpNegotiate3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("57b6c80a-34c2-4602-bc26-66a02fc57153")
    IHttpNegotiate3 : public IHttpNegotiate2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSerializedClientCertContext( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcbCert) BYTE **ppbCert,
            /* [out] */ __RPC__out DWORD *pcbCert) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHttpNegotiate3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IHttpNegotiate3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IHttpNegotiate3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IHttpNegotiate3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginningTransaction )( 
            __RPC__in IHttpNegotiate3 * This,
            /* [in] */ __RPC__in LPCWSTR szURL,
            /* [unique][in] */ __RPC__in_opt LPCWSTR szHeaders,
            /* [in] */ DWORD dwReserved,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pszAdditionalHeaders);
        
        HRESULT ( STDMETHODCALLTYPE *OnResponse )( 
            __RPC__in IHttpNegotiate3 * This,
            /* [in] */ DWORD dwResponseCode,
            /* [unique][in] */ __RPC__in_opt LPCWSTR szResponseHeaders,
            /* [unique][in] */ __RPC__in_opt LPCWSTR szRequestHeaders,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pszAdditionalRequestHeaders);
        
        HRESULT ( STDMETHODCALLTYPE *GetRootSecurityId )( 
            __RPC__in IHttpNegotiate3 * This,
            /* [size_is][out] */ __RPC__out_ecount_full(*pcbSecurityId) BYTE *pbSecurityId,
            /* [out][in] */ __RPC__inout DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetSerializedClientCertContext )( 
            __RPC__in IHttpNegotiate3 * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcbCert) BYTE **ppbCert,
            /* [out] */ __RPC__out DWORD *pcbCert);
        
        END_INTERFACE
    } IHttpNegotiate3Vtbl;

    interface IHttpNegotiate3
    {
        CONST_VTBL struct IHttpNegotiate3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHttpNegotiate3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHttpNegotiate3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHttpNegotiate3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHttpNegotiate3_BeginningTransaction(This,szURL,szHeaders,dwReserved,pszAdditionalHeaders)	\
    ( (This)->lpVtbl -> BeginningTransaction(This,szURL,szHeaders,dwReserved,pszAdditionalHeaders) ) 

#define IHttpNegotiate3_OnResponse(This,dwResponseCode,szResponseHeaders,szRequestHeaders,pszAdditionalRequestHeaders)	\
    ( (This)->lpVtbl -> OnResponse(This,dwResponseCode,szResponseHeaders,szRequestHeaders,pszAdditionalRequestHeaders) ) 


#define IHttpNegotiate3_GetRootSecurityId(This,pbSecurityId,pcbSecurityId,dwReserved)	\
    ( (This)->lpVtbl -> GetRootSecurityId(This,pbSecurityId,pcbSecurityId,dwReserved) ) 


#define IHttpNegotiate3_GetSerializedClientCertContext(This,ppbCert,pcbCert)	\
    ( (This)->lpVtbl -> GetSerializedClientCertContext(This,ppbCert,pcbCert) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHttpNegotiate3_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0011 */
/* [local] */ 

#endif
#ifndef _LPWININETFILESTREAM_DEFINED
#define _LPWININETFILESTREAM_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0011_v0_0_s_ifspec;

#ifndef __IWinInetFileStream_INTERFACE_DEFINED__
#define __IWinInetFileStream_INTERFACE_DEFINED__

/* interface IWinInetFileStream */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IWinInetFileStream *LPWININETFILESTREAM;


EXTERN_C const IID IID_IWinInetFileStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F134C4B7-B1F8-4e75-B886-74B90943BECB")
    IWinInetFileStream : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetHandleForUnlock( 
            /* [in] */ DWORD_PTR hWinInetLockHandle,
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDeleteFile( 
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWinInetFileStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWinInetFileStream * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWinInetFileStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWinInetFileStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetHandleForUnlock )( 
            __RPC__in IWinInetFileStream * This,
            /* [in] */ DWORD_PTR hWinInetLockHandle,
            /* [in] */ DWORD_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *SetDeleteFile )( 
            __RPC__in IWinInetFileStream * This,
            /* [in] */ DWORD_PTR dwReserved);
        
        END_INTERFACE
    } IWinInetFileStreamVtbl;

    interface IWinInetFileStream
    {
        CONST_VTBL struct IWinInetFileStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWinInetFileStream_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWinInetFileStream_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWinInetFileStream_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWinInetFileStream_SetHandleForUnlock(This,hWinInetLockHandle,dwReserved)	\
    ( (This)->lpVtbl -> SetHandleForUnlock(This,hWinInetLockHandle,dwReserved) ) 

#define IWinInetFileStream_SetDeleteFile(This,dwReserved)	\
    ( (This)->lpVtbl -> SetDeleteFile(This,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWinInetFileStream_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0012 */
/* [local] */ 

#endif
#ifndef _LPWINDOWFORBINDINGUI_DEFINED
#define _LPWINDOWFORBINDINGUI_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0012_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0012_v0_0_s_ifspec;

#ifndef __IWindowForBindingUI_INTERFACE_DEFINED__
#define __IWindowForBindingUI_INTERFACE_DEFINED__

/* interface IWindowForBindingUI */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IWindowForBindingUI *LPWINDOWFORBINDINGUI;


EXTERN_C const IID IID_IWindowForBindingUI;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9d5-bafa-11ce-8c82-00aa004ba90b")
    IWindowForBindingUI : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetWindow( 
            /* [in] */ REFGUID rguidReason,
            /* [out] */ HWND *phwnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWindowForBindingUIVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWindowForBindingUI * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWindowForBindingUI * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWindowForBindingUI * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IWindowForBindingUI * This,
            /* [in] */ REFGUID rguidReason,
            /* [out] */ HWND *phwnd);
        
        END_INTERFACE
    } IWindowForBindingUIVtbl;

    interface IWindowForBindingUI
    {
        CONST_VTBL struct IWindowForBindingUIVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWindowForBindingUI_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWindowForBindingUI_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWindowForBindingUI_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWindowForBindingUI_GetWindow(This,rguidReason,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,rguidReason,phwnd) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWindowForBindingUI_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0013 */
/* [local] */ 

#endif
#ifndef _LPCODEINSTALL_DEFINED
#define _LPCODEINSTALL_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0013_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0013_v0_0_s_ifspec;

#ifndef __ICodeInstall_INTERFACE_DEFINED__
#define __ICodeInstall_INTERFACE_DEFINED__

/* interface ICodeInstall */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ ICodeInstall *LPCODEINSTALL;

typedef /* [public] */ 
enum __MIDL_ICodeInstall_0001
    {	CIP_DISK_FULL	= 0,
	CIP_ACCESS_DENIED	= ( CIP_DISK_FULL + 1 ) ,
	CIP_NEWER_VERSION_EXISTS	= ( CIP_ACCESS_DENIED + 1 ) ,
	CIP_OLDER_VERSION_EXISTS	= ( CIP_NEWER_VERSION_EXISTS + 1 ) ,
	CIP_NAME_CONFLICT	= ( CIP_OLDER_VERSION_EXISTS + 1 ) ,
	CIP_TRUST_VERIFICATION_COMPONENT_MISSING	= ( CIP_NAME_CONFLICT + 1 ) ,
	CIP_EXE_SELF_REGISTERATION_TIMEOUT	= ( CIP_TRUST_VERIFICATION_COMPONENT_MISSING + 1 ) ,
	CIP_UNSAFE_TO_ABORT	= ( CIP_EXE_SELF_REGISTERATION_TIMEOUT + 1 ) ,
	CIP_NEED_REBOOT	= ( CIP_UNSAFE_TO_ABORT + 1 ) ,
	CIP_NEED_REBOOT_UI_PERMISSION	= ( CIP_NEED_REBOOT + 1 ) 
    } 	CIP_STATUS;


EXTERN_C const IID IID_ICodeInstall;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9d1-baf9-11ce-8c82-00aa004ba90b")
    ICodeInstall : public IWindowForBindingUI
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnCodeInstallProblem( 
            /* [in] */ ULONG ulStatusCode,
            /* [unique][in] */ LPCWSTR szDestination,
            /* [unique][in] */ LPCWSTR szSource,
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICodeInstallVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICodeInstall * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICodeInstall * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICodeInstall * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            ICodeInstall * This,
            /* [in] */ REFGUID rguidReason,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *OnCodeInstallProblem )( 
            ICodeInstall * This,
            /* [in] */ ULONG ulStatusCode,
            /* [unique][in] */ LPCWSTR szDestination,
            /* [unique][in] */ LPCWSTR szSource,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } ICodeInstallVtbl;

    interface ICodeInstall
    {
        CONST_VTBL struct ICodeInstallVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICodeInstall_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICodeInstall_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICodeInstall_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICodeInstall_GetWindow(This,rguidReason,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,rguidReason,phwnd) ) 


#define ICodeInstall_OnCodeInstallProblem(This,ulStatusCode,szDestination,szSource,dwReserved)	\
    ( (This)->lpVtbl -> OnCodeInstallProblem(This,ulStatusCode,szDestination,szSource,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICodeInstall_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0014 */
/* [local] */ 

#endif
#if (_WIN32_IE >= _WIN32_IE_IE70)
#ifndef _LPUri_DEFINED
#define _LPUri_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0014_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0014_v0_0_s_ifspec;

#ifndef __IUri_INTERFACE_DEFINED__
#define __IUri_INTERFACE_DEFINED__

/* interface IUri */
/* [unique][uuid][object] */ 

typedef /* [public][public][public][public][public][helpstring] */ 
enum __MIDL_IUri_0001
    {	Uri_PROPERTY_ABSOLUTE_URI	= 0,
	Uri_PROPERTY_STRING_START	= Uri_PROPERTY_ABSOLUTE_URI,
	Uri_PROPERTY_AUTHORITY	= 1,
	Uri_PROPERTY_DISPLAY_URI	= 2,
	Uri_PROPERTY_DOMAIN	= 3,
	Uri_PROPERTY_EXTENSION	= 4,
	Uri_PROPERTY_FRAGMENT	= 5,
	Uri_PROPERTY_HOST	= 6,
	Uri_PROPERTY_PASSWORD	= 7,
	Uri_PROPERTY_PATH	= 8,
	Uri_PROPERTY_PATH_AND_QUERY	= 9,
	Uri_PROPERTY_QUERY	= 10,
	Uri_PROPERTY_RAW_URI	= 11,
	Uri_PROPERTY_SCHEME_NAME	= 12,
	Uri_PROPERTY_USER_INFO	= 13,
	Uri_PROPERTY_USER_NAME	= 14,
	Uri_PROPERTY_STRING_LAST	= Uri_PROPERTY_USER_NAME,
	Uri_PROPERTY_HOST_TYPE	= 15,
	Uri_PROPERTY_DWORD_START	= Uri_PROPERTY_HOST_TYPE,
	Uri_PROPERTY_PORT	= 16,
	Uri_PROPERTY_SCHEME	= 17,
	Uri_PROPERTY_ZONE	= 18,
	Uri_PROPERTY_DWORD_LAST	= Uri_PROPERTY_ZONE
    } 	Uri_PROPERTY;

typedef /* [public][helpstring] */ 
enum __MIDL_IUri_0002
    {	Uri_HOST_UNKNOWN	= 0,
	Uri_HOST_DNS	= ( Uri_HOST_UNKNOWN + 1 ) ,
	Uri_HOST_IPV4	= ( Uri_HOST_DNS + 1 ) ,
	Uri_HOST_IPV6	= ( Uri_HOST_IPV4 + 1 ) ,
	Uri_HOST_IDN	= ( Uri_HOST_IPV6 + 1 ) 
    } 	Uri_HOST_TYPE;


EXTERN_C const IID IID_IUri;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A39EE748-6A27-4817-A6F2-13914BEF5890")
    IUri : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPropertyBSTR( 
            /* [range][in] */ Uri_PROPERTY uriProp,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrProperty,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPropertyLength( 
            /* [range][in] */ Uri_PROPERTY uriProp,
            /* [out] */ __RPC__out DWORD *pcchProperty,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPropertyDWORD( 
            /* [range][in] */ Uri_PROPERTY uriProp,
            /* [out] */ __RPC__out DWORD *pdwProperty,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE HasProperty( 
            /* [range][in] */ Uri_PROPERTY uriProp,
            /* [out] */ __RPC__out BOOL *pfHasProperty) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAbsoluteUri( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrAbsoluteUri) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAuthority( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrAuthority) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayUri( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrDisplayString) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDomain( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrDomain) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetExtension( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrExtension) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetFragment( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrFragment) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetHost( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrHost) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPassword( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrPassword) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPath( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrPath) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPathAndQuery( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrPathAndQuery) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetQuery( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrQuery) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetRawUri( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrRawUri) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSchemeName( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrSchemeName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetUserInfo( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrUserInfo) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetUserName( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrUserName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetHostType( 
            /* [out] */ __RPC__out DWORD *pdwHostType) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPort( 
            /* [out] */ __RPC__out DWORD *pdwPort) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetScheme( 
            /* [out] */ __RPC__out DWORD *pdwScheme) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetZone( 
            /* [out] */ __RPC__out DWORD *pdwZone) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out LPDWORD pdwFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsEqual( 
            /* [in] */ __RPC__in_opt IUri *pUri,
            /* [out] */ __RPC__out BOOL *pfEqual) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUriVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IUri * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IUri * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IUri * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPropertyBSTR )( 
            __RPC__in IUri * This,
            /* [range][in] */ Uri_PROPERTY uriProp,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrProperty,
            /* [in] */ DWORD dwFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPropertyLength )( 
            __RPC__in IUri * This,
            /* [range][in] */ Uri_PROPERTY uriProp,
            /* [out] */ __RPC__out DWORD *pcchProperty,
            /* [in] */ DWORD dwFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPropertyDWORD )( 
            __RPC__in IUri * This,
            /* [range][in] */ Uri_PROPERTY uriProp,
            /* [out] */ __RPC__out DWORD *pdwProperty,
            /* [in] */ DWORD dwFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *HasProperty )( 
            __RPC__in IUri * This,
            /* [range][in] */ Uri_PROPERTY uriProp,
            /* [out] */ __RPC__out BOOL *pfHasProperty);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAbsoluteUri )( 
            __RPC__in IUri * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrAbsoluteUri);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAuthority )( 
            __RPC__in IUri * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrAuthority);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDisplayUri )( 
            __RPC__in IUri * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrDisplayString);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDomain )( 
            __RPC__in IUri * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrDomain);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetExtension )( 
            __RPC__in IUri * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrExtension);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetFragment )( 
            __RPC__in IUri * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrFragment);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetHost )( 
            __RPC__in IUri * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrHost);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPassword )( 
            __RPC__in IUri * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrPassword);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPath )( 
            __RPC__in IUri * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrPath);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPathAndQuery )( 
            __RPC__in IUri * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrPathAndQuery);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetQuery )( 
            __RPC__in IUri * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrQuery);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetRawUri )( 
            __RPC__in IUri * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrRawUri);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSchemeName )( 
            __RPC__in IUri * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrSchemeName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetUserInfo )( 
            __RPC__in IUri * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrUserInfo);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetUserName )( 
            __RPC__in IUri * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrUserName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetHostType )( 
            __RPC__in IUri * This,
            /* [out] */ __RPC__out DWORD *pdwHostType);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPort )( 
            __RPC__in IUri * This,
            /* [out] */ __RPC__out DWORD *pdwPort);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetScheme )( 
            __RPC__in IUri * This,
            /* [out] */ __RPC__out DWORD *pdwScheme);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetZone )( 
            __RPC__in IUri * This,
            /* [out] */ __RPC__out DWORD *pdwZone);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IUri * This,
            /* [out] */ __RPC__out LPDWORD pdwFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsEqual )( 
            __RPC__in IUri * This,
            /* [in] */ __RPC__in_opt IUri *pUri,
            /* [out] */ __RPC__out BOOL *pfEqual);
        
        END_INTERFACE
    } IUriVtbl;

    interface IUri
    {
        CONST_VTBL struct IUriVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUri_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUri_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUri_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUri_GetPropertyBSTR(This,uriProp,pbstrProperty,dwFlags)	\
    ( (This)->lpVtbl -> GetPropertyBSTR(This,uriProp,pbstrProperty,dwFlags) ) 

#define IUri_GetPropertyLength(This,uriProp,pcchProperty,dwFlags)	\
    ( (This)->lpVtbl -> GetPropertyLength(This,uriProp,pcchProperty,dwFlags) ) 

#define IUri_GetPropertyDWORD(This,uriProp,pdwProperty,dwFlags)	\
    ( (This)->lpVtbl -> GetPropertyDWORD(This,uriProp,pdwProperty,dwFlags) ) 

#define IUri_HasProperty(This,uriProp,pfHasProperty)	\
    ( (This)->lpVtbl -> HasProperty(This,uriProp,pfHasProperty) ) 

#define IUri_GetAbsoluteUri(This,pbstrAbsoluteUri)	\
    ( (This)->lpVtbl -> GetAbsoluteUri(This,pbstrAbsoluteUri) ) 

#define IUri_GetAuthority(This,pbstrAuthority)	\
    ( (This)->lpVtbl -> GetAuthority(This,pbstrAuthority) ) 

#define IUri_GetDisplayUri(This,pbstrDisplayString)	\
    ( (This)->lpVtbl -> GetDisplayUri(This,pbstrDisplayString) ) 

#define IUri_GetDomain(This,pbstrDomain)	\
    ( (This)->lpVtbl -> GetDomain(This,pbstrDomain) ) 

#define IUri_GetExtension(This,pbstrExtension)	\
    ( (This)->lpVtbl -> GetExtension(This,pbstrExtension) ) 

#define IUri_GetFragment(This,pbstrFragment)	\
    ( (This)->lpVtbl -> GetFragment(This,pbstrFragment) ) 

#define IUri_GetHost(This,pbstrHost)	\
    ( (This)->lpVtbl -> GetHost(This,pbstrHost) ) 

#define IUri_GetPassword(This,pbstrPassword)	\
    ( (This)->lpVtbl -> GetPassword(This,pbstrPassword) ) 

#define IUri_GetPath(This,pbstrPath)	\
    ( (This)->lpVtbl -> GetPath(This,pbstrPath) ) 

#define IUri_GetPathAndQuery(This,pbstrPathAndQuery)	\
    ( (This)->lpVtbl -> GetPathAndQuery(This,pbstrPathAndQuery) ) 

#define IUri_GetQuery(This,pbstrQuery)	\
    ( (This)->lpVtbl -> GetQuery(This,pbstrQuery) ) 

#define IUri_GetRawUri(This,pbstrRawUri)	\
    ( (This)->lpVtbl -> GetRawUri(This,pbstrRawUri) ) 

#define IUri_GetSchemeName(This,pbstrSchemeName)	\
    ( (This)->lpVtbl -> GetSchemeName(This,pbstrSchemeName) ) 

#define IUri_GetUserInfo(This,pbstrUserInfo)	\
    ( (This)->lpVtbl -> GetUserInfo(This,pbstrUserInfo) ) 

#define IUri_GetUserName(This,pbstrUserName)	\
    ( (This)->lpVtbl -> GetUserName(This,pbstrUserName) ) 

#define IUri_GetHostType(This,pdwHostType)	\
    ( (This)->lpVtbl -> GetHostType(This,pdwHostType) ) 

#define IUri_GetPort(This,pdwPort)	\
    ( (This)->lpVtbl -> GetPort(This,pdwPort) ) 

#define IUri_GetScheme(This,pdwScheme)	\
    ( (This)->lpVtbl -> GetScheme(This,pdwScheme) ) 

#define IUri_GetZone(This,pdwZone)	\
    ( (This)->lpVtbl -> GetZone(This,pdwZone) ) 

#define IUri_GetProperties(This,pdwFlags)	\
    ( (This)->lpVtbl -> GetProperties(This,pdwFlags) ) 

#define IUri_IsEqual(This,pUri,pfEqual)	\
    ( (This)->lpVtbl -> IsEqual(This,pUri,pfEqual) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUri_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0015 */
/* [local] */ 

STDAPI CreateUri(__in LPCWSTR pwzURI,
                 __in DWORD dwFlags,
                 __reserved DWORD_PTR dwReserved,   // must be 0
                 __out IUri** ppURI);

STDAPI CreateUriWithFragment(
                 __in LPCWSTR pwzURI,
                 __in_opt LPCWSTR pwzFragment,        // can be NULL
                 __in DWORD dwFlags,
                 __reserved DWORD_PTR dwReserved,   // must be 0
                 __out IUri** ppURI);

STDAPI CreateUriFromMultiByteString(
    __in       LPCSTR    pszANSIInputUri,
               DWORD     dwEncodingFlags, // ORed set of Uri_ENCODING_ flags
               DWORD     dwCodePage,
               DWORD     dwCreateFlags,
    __reserved DWORD_PTR dwReserved,   // must be 0
    __out      IUri**    ppUri);

//The following flags are used with IUri::GetProperties.
#define Uri_HAS_ABSOLUTE_URI    (1 << Uri_PROPERTY_ABSOLUTE_URI)
#define Uri_HAS_AUTHORITY       (1 << Uri_PROPERTY_AUTHORITY)
#define Uri_HAS_DISPLAY_URI     (1 << Uri_PROPERTY_DISPLAY_URI)
#define Uri_HAS_DOMAIN          (1 << Uri_PROPERTY_DOMAIN)
#define Uri_HAS_EXTENSION       (1 << Uri_PROPERTY_EXTENSION)
#define Uri_HAS_FRAGMENT        (1 << Uri_PROPERTY_FRAGMENT)
#define Uri_HAS_HOST            (1 << Uri_PROPERTY_HOST)
#define Uri_HAS_PASSWORD        (1 << Uri_PROPERTY_PASSWORD)
#define Uri_HAS_PATH            (1 << Uri_PROPERTY_PATH)
#define Uri_HAS_QUERY           (1 << Uri_PROPERTY_QUERY)
#define Uri_HAS_RAW_URI         (1 << Uri_PROPERTY_RAW_URI)
#define Uri_HAS_SCHEME_NAME     (1 << Uri_PROPERTY_SCHEME_NAME)
#define Uri_HAS_USER_NAME       (1 << Uri_PROPERTY_USER_NAME)
#define Uri_HAS_PATH_AND_QUERY  (1 << Uri_PROPERTY_PATH_AND_QUERY)
#define Uri_HAS_USER_INFO       (1 << Uri_PROPERTY_USER_INFO)
#define Uri_HAS_HOST_TYPE       (1 << Uri_PROPERTY_HOST_TYPE)
#define Uri_HAS_PORT            (1 << Uri_PROPERTY_PORT)
#define Uri_HAS_SCHEME          (1 << Uri_PROPERTY_SCHEME)
#define Uri_HAS_ZONE            (1 << Uri_PROPERTY_ZONE)

//The following public Uri_CREATE flags may be passed in 
//through the dwFlags parameter of the CreateUri functions.
//Note that ALLOW_RELATIVE and ALLOW_IMPLICIT_WILDCARD_SCHEME are mutually exclusive and may not be passed together.
#define Uri_CREATE_ALLOW_RELATIVE                 0x00000001    // When the scheme is unspecified and not implicit file, assume relative.
#define Uri_CREATE_ALLOW_IMPLICIT_WILDCARD_SCHEME 0x00000002    // When the scheme is unspecified and not implicit file, assume wildcard.
#define Uri_CREATE_ALLOW_IMPLICIT_FILE_SCHEME     0x00000004    // When the scheme is unspecified and it starts with X: or \\ assume its a file scheme.
#define Uri_CREATE_NOFRAG                         0x00000008    // If there's a query string don't look for a fragment
#define Uri_CREATE_NO_CANONICALIZE                0x00000010    // Do not canonicalize the scheme, host, authority, or path
#define Uri_CREATE_CANONICALIZE                   0x00000100    // DEFAULT: Canonicalize the scheme, host, authority, and path
#define Uri_CREATE_FILE_USE_DOS_PATH              0x00000020    // Use DOS path compat mode for file URI creation
#define Uri_CREATE_DECODE_EXTRA_INFO              0x00000040    // Beta2 DEFAULT: Decode the contents of query and fragment, then re-encode reserved characters
#define Uri_CREATE_NO_DECODE_EXTRA_INFO           0x00000080    // Beta1 DEFAULT: Neither decode nor re-encode any part of the query or fragment
#define Uri_CREATE_CRACK_UNKNOWN_SCHEMES          0x00000200    // Beta2 DEFAULT: Heirarchical URIs with present and unknown schemes will be treated like heirarchical URIs
#define Uri_CREATE_NO_CRACK_UNKNOWN_SCHEMES       0x00000400    // Beta1 DEFAULT: Heirarchical URIs with present and unknown schemes will be treated like opaque URIs
#define Uri_CREATE_PRE_PROCESS_HTML_URI           0x00000800    // DEFAULT:  Perform pre-processing on the URI to remove control characters and whitespace as if the URI comes from the raw href value of an HTML page.
#define Uri_CREATE_NO_PRE_PROCESS_HTML_URI        0x00001000    // Don't perform pre-processing to remove control characters and whitespace as appropriate.
#define Uri_CREATE_IE_SETTINGS                    0x00002000    // Use IE registry settings for such things as whether or not to use IDN.
#define Uri_CREATE_NO_IE_SETTINGS                 0x00004000    // DEFAULT: Don't use IE registry settings.
#define Uri_CREATE_NO_ENCODE_FORBIDDEN_CHARACTERS 0x00008000    // Don't percent-encode characters that are forbidden by the RFC.
//The following flags may be passed in through the dwFlags 
//parameter of the IUri::GetPropertyBSTR or IUri::GetPropertyLength functions.
//The following flags apply only to the property Uri_PROPERTY_DISPLAY_URI:
#define Uri_DISPLAY_NO_FRAGMENT               0x00000001    // Exclude fragment from the DisplayUri, if one exists
#define Uri_PUNYCODE_IDN_HOST                 0x00000002    // Show the hostname encoded as punycode inside the Host, Domain, or AbsoluteUri properties, if the Uri is IDN
#define Uri_DISPLAY_IDN_HOST                  0x00000004    // Show the hostname encoded as punycode or Unicode as it would appear in the DisplayUri property. This applies to the Host, Domain, and AbsoluteUri properties.
// The following are Uri_ENCODING_ flags for use with the function CreateUriFromMultiByteString
#define Uri_ENCODING_USER_INFO_AND_PATH_IS_PERCENT_ENCODED_UTF8  0x00000001
#define Uri_ENCODING_USER_INFO_AND_PATH_IS_CP                    0x00000002
#define Uri_ENCODING_HOST_IS_IDN                                 0x00000004
#define Uri_ENCODING_HOST_IS_PERCENT_ENCODED_UTF8                0x00000008
#define Uri_ENCODING_HOST_IS_PERCENT_ENCODED_CP                  0x00000010
#define Uri_ENCODING_QUERY_AND_FRAGMENT_IS_PERCENT_ENCODED_UTF8  0x00000020
#define Uri_ENCODING_QUERY_AND_FRAGMENT_IS_CP                    0x00000040
#define Uri_ENCODING_RFC (Uri_ENCODING_USER_INFO_AND_PATH_IS_PERCENT_ENCODED_UTF8 | Uri_ENCODING_HOST_IS_PERCENT_ENCODED_UTF8 | Uri_ENCODING_QUERY_AND_FRAGMENT_IS_PERCENT_ENCODED_UTF8)

//The following flags may be passed in through the dwUriBuilderFlags 
//parameter of the IUriBuilder::CreateUri
#define UriBuilder_USE_ORIGINAL_FLAGS             0x00000001    // Use the create flags from the underlying IUri if they are available.

#endif


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0015_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0015_v0_0_s_ifspec;

#ifndef __IUriContainer_INTERFACE_DEFINED__
#define __IUriContainer_INTERFACE_DEFINED__

/* interface IUriContainer */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IUriContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a158a630-ed6f-45fb-b987-f68676f57752")
    IUriContainer : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIUri( 
            /* [out] */ IUri **ppIUri) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUriContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUriContainer * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUriContainer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUriContainer * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetIUri )( 
            IUriContainer * This,
            /* [out] */ IUri **ppIUri);
        
        END_INTERFACE
    } IUriContainerVtbl;

    interface IUriContainer
    {
        CONST_VTBL struct IUriContainerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUriContainer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUriContainer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUriContainer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUriContainer_GetIUri(This,ppIUri)	\
    ( (This)->lpVtbl -> GetIUri(This,ppIUri) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUriContainer_INTERFACE_DEFINED__ */


#ifndef __IUriBuilder_INTERFACE_DEFINED__
#define __IUriBuilder_INTERFACE_DEFINED__

/* interface IUriBuilder */
/* [unique][uuid][object][local][helpstring] */ 


EXTERN_C const IID IID_IUriBuilder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4221B2E1-8955-46c0-BD5B-DE9897565DE7")
    IUriBuilder : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateUriSimple( 
            /* [in] */ DWORD dwAllowEncodingPropertyMask,
            /* [in] */ DWORD_PTR dwReserved,
            /* [annotation][out] */ 
            __deref_out  IUri **ppIUri) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateUri( 
            /* [in] */ DWORD dwCreateFlags,
            /* [in] */ DWORD dwAllowEncodingPropertyMask,
            /* [in] */ DWORD_PTR dwReserved,
            /* [annotation][out] */ 
            __deref_out  IUri **ppIUri) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateUriWithFlags( 
            /* [in] */ DWORD dwCreateFlags,
            /* [in] */ DWORD dwUriBuilderFlags,
            /* [in] */ DWORD dwAllowEncodingPropertyMask,
            /* [in] */ DWORD_PTR dwReserved,
            /* [annotation][out] */ 
            __deref_out  IUri **ppIUri) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIUri( 
            /* [annotation][out] */ 
            __deref_out_opt  IUri **ppIUri) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetIUri( 
            /* [annotation][unique][in] */ 
            __in_opt  IUri *pIUri) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetFragment( 
            /* [annotation][out] */ 
            __out  DWORD *pcchFragment,
            /* [annotation][out] */ 
            __deref_out_opt  LPCWSTR *ppwzFragment) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetHost( 
            /* [annotation][out] */ 
            __out  DWORD *pcchHost,
            /* [annotation][out] */ 
            __deref_out_opt  LPCWSTR *ppwzHost) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPassword( 
            /* [annotation][out] */ 
            __out  DWORD *pcchPassword,
            /* [annotation][out] */ 
            __deref_out_opt  LPCWSTR *ppwzPassword) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPath( 
            /* [annotation][out] */ 
            __out  DWORD *pcchPath,
            /* [annotation][out] */ 
            __deref_out_opt  LPCWSTR *ppwzPath) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPort( 
            /* [annotation][out] */ 
            __out  BOOL *pfHasPort,
            /* [annotation][out] */ 
            __out  DWORD *pdwPort) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetQuery( 
            /* [annotation][out] */ 
            __out  DWORD *pcchQuery,
            /* [annotation][out] */ 
            __deref_out_opt  LPCWSTR *ppwzQuery) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSchemeName( 
            /* [annotation][out] */ 
            __out  DWORD *pcchSchemeName,
            /* [annotation][out] */ 
            __deref_out_opt  LPCWSTR *ppwzSchemeName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetUserName( 
            /* [annotation][out] */ 
            __out  DWORD *pcchUserName,
            /* [annotation][out] */ 
            __deref_out_opt  LPCWSTR *ppwzUserName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetFragment( 
            /* [annotation][in] */ 
            __in_opt  LPCWSTR pwzNewValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetHost( 
            /* [annotation][in] */ 
            __in  LPCWSTR pwzNewValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetPassword( 
            /* [annotation][in] */ 
            __in_opt  LPCWSTR pwzNewValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetPath( 
            /* [annotation][in] */ 
            __in_opt  LPCWSTR pwzNewValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetPort( 
            /* [in] */ BOOL fHasPort,
            /* [in] */ DWORD dwNewValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetQuery( 
            /* [annotation][in] */ 
            __in_opt  LPCWSTR pwzNewValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSchemeName( 
            /* [annotation][in] */ 
            __in  LPCWSTR pwzNewValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetUserName( 
            /* [annotation][in] */ 
            __in_opt  LPCWSTR pwzNewValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveProperties( 
            /* [in] */ DWORD dwPropertyMask) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE HasBeenModified( 
            /* [annotation][out] */ 
            __out  BOOL *pfModified) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUriBuilderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUriBuilder * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUriBuilder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUriBuilder * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateUriSimple )( 
            IUriBuilder * This,
            /* [in] */ DWORD dwAllowEncodingPropertyMask,
            /* [in] */ DWORD_PTR dwReserved,
            /* [annotation][out] */ 
            __deref_out  IUri **ppIUri);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateUri )( 
            IUriBuilder * This,
            /* [in] */ DWORD dwCreateFlags,
            /* [in] */ DWORD dwAllowEncodingPropertyMask,
            /* [in] */ DWORD_PTR dwReserved,
            /* [annotation][out] */ 
            __deref_out  IUri **ppIUri);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateUriWithFlags )( 
            IUriBuilder * This,
            /* [in] */ DWORD dwCreateFlags,
            /* [in] */ DWORD dwUriBuilderFlags,
            /* [in] */ DWORD dwAllowEncodingPropertyMask,
            /* [in] */ DWORD_PTR dwReserved,
            /* [annotation][out] */ 
            __deref_out  IUri **ppIUri);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetIUri )( 
            IUriBuilder * This,
            /* [annotation][out] */ 
            __deref_out_opt  IUri **ppIUri);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetIUri )( 
            IUriBuilder * This,
            /* [annotation][unique][in] */ 
            __in_opt  IUri *pIUri);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetFragment )( 
            IUriBuilder * This,
            /* [annotation][out] */ 
            __out  DWORD *pcchFragment,
            /* [annotation][out] */ 
            __deref_out_opt  LPCWSTR *ppwzFragment);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetHost )( 
            IUriBuilder * This,
            /* [annotation][out] */ 
            __out  DWORD *pcchHost,
            /* [annotation][out] */ 
            __deref_out_opt  LPCWSTR *ppwzHost);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPassword )( 
            IUriBuilder * This,
            /* [annotation][out] */ 
            __out  DWORD *pcchPassword,
            /* [annotation][out] */ 
            __deref_out_opt  LPCWSTR *ppwzPassword);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPath )( 
            IUriBuilder * This,
            /* [annotation][out] */ 
            __out  DWORD *pcchPath,
            /* [annotation][out] */ 
            __deref_out_opt  LPCWSTR *ppwzPath);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPort )( 
            IUriBuilder * This,
            /* [annotation][out] */ 
            __out  BOOL *pfHasPort,
            /* [annotation][out] */ 
            __out  DWORD *pdwPort);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetQuery )( 
            IUriBuilder * This,
            /* [annotation][out] */ 
            __out  DWORD *pcchQuery,
            /* [annotation][out] */ 
            __deref_out_opt  LPCWSTR *ppwzQuery);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSchemeName )( 
            IUriBuilder * This,
            /* [annotation][out] */ 
            __out  DWORD *pcchSchemeName,
            /* [annotation][out] */ 
            __deref_out_opt  LPCWSTR *ppwzSchemeName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetUserName )( 
            IUriBuilder * This,
            /* [annotation][out] */ 
            __out  DWORD *pcchUserName,
            /* [annotation][out] */ 
            __deref_out_opt  LPCWSTR *ppwzUserName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetFragment )( 
            IUriBuilder * This,
            /* [annotation][in] */ 
            __in_opt  LPCWSTR pwzNewValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetHost )( 
            IUriBuilder * This,
            /* [annotation][in] */ 
            __in  LPCWSTR pwzNewValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetPassword )( 
            IUriBuilder * This,
            /* [annotation][in] */ 
            __in_opt  LPCWSTR pwzNewValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetPath )( 
            IUriBuilder * This,
            /* [annotation][in] */ 
            __in_opt  LPCWSTR pwzNewValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetPort )( 
            IUriBuilder * This,
            /* [in] */ BOOL fHasPort,
            /* [in] */ DWORD dwNewValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetQuery )( 
            IUriBuilder * This,
            /* [annotation][in] */ 
            __in_opt  LPCWSTR pwzNewValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetSchemeName )( 
            IUriBuilder * This,
            /* [annotation][in] */ 
            __in  LPCWSTR pwzNewValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetUserName )( 
            IUriBuilder * This,
            /* [annotation][in] */ 
            __in_opt  LPCWSTR pwzNewValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveProperties )( 
            IUriBuilder * This,
            /* [in] */ DWORD dwPropertyMask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *HasBeenModified )( 
            IUriBuilder * This,
            /* [annotation][out] */ 
            __out  BOOL *pfModified);
        
        END_INTERFACE
    } IUriBuilderVtbl;

    interface IUriBuilder
    {
        CONST_VTBL struct IUriBuilderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUriBuilder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUriBuilder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUriBuilder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUriBuilder_CreateUriSimple(This,dwAllowEncodingPropertyMask,dwReserved,ppIUri)	\
    ( (This)->lpVtbl -> CreateUriSimple(This,dwAllowEncodingPropertyMask,dwReserved,ppIUri) ) 

#define IUriBuilder_CreateUri(This,dwCreateFlags,dwAllowEncodingPropertyMask,dwReserved,ppIUri)	\
    ( (This)->lpVtbl -> CreateUri(This,dwCreateFlags,dwAllowEncodingPropertyMask,dwReserved,ppIUri) ) 

#define IUriBuilder_CreateUriWithFlags(This,dwCreateFlags,dwUriBuilderFlags,dwAllowEncodingPropertyMask,dwReserved,ppIUri)	\
    ( (This)->lpVtbl -> CreateUriWithFlags(This,dwCreateFlags,dwUriBuilderFlags,dwAllowEncodingPropertyMask,dwReserved,ppIUri) ) 

#define IUriBuilder_GetIUri(This,ppIUri)	\
    ( (This)->lpVtbl -> GetIUri(This,ppIUri) ) 

#define IUriBuilder_SetIUri(This,pIUri)	\
    ( (This)->lpVtbl -> SetIUri(This,pIUri) ) 

#define IUriBuilder_GetFragment(This,pcchFragment,ppwzFragment)	\
    ( (This)->lpVtbl -> GetFragment(This,pcchFragment,ppwzFragment) ) 

#define IUriBuilder_GetHost(This,pcchHost,ppwzHost)	\
    ( (This)->lpVtbl -> GetHost(This,pcchHost,ppwzHost) ) 

#define IUriBuilder_GetPassword(This,pcchPassword,ppwzPassword)	\
    ( (This)->lpVtbl -> GetPassword(This,pcchPassword,ppwzPassword) ) 

#define IUriBuilder_GetPath(This,pcchPath,ppwzPath)	\
    ( (This)->lpVtbl -> GetPath(This,pcchPath,ppwzPath) ) 

#define IUriBuilder_GetPort(This,pfHasPort,pdwPort)	\
    ( (This)->lpVtbl -> GetPort(This,pfHasPort,pdwPort) ) 

#define IUriBuilder_GetQuery(This,pcchQuery,ppwzQuery)	\
    ( (This)->lpVtbl -> GetQuery(This,pcchQuery,ppwzQuery) ) 

#define IUriBuilder_GetSchemeName(This,pcchSchemeName,ppwzSchemeName)	\
    ( (This)->lpVtbl -> GetSchemeName(This,pcchSchemeName,ppwzSchemeName) ) 

#define IUriBuilder_GetUserName(This,pcchUserName,ppwzUserName)	\
    ( (This)->lpVtbl -> GetUserName(This,pcchUserName,ppwzUserName) ) 

#define IUriBuilder_SetFragment(This,pwzNewValue)	\
    ( (This)->lpVtbl -> SetFragment(This,pwzNewValue) ) 

#define IUriBuilder_SetHost(This,pwzNewValue)	\
    ( (This)->lpVtbl -> SetHost(This,pwzNewValue) ) 

#define IUriBuilder_SetPassword(This,pwzNewValue)	\
    ( (This)->lpVtbl -> SetPassword(This,pwzNewValue) ) 

#define IUriBuilder_SetPath(This,pwzNewValue)	\
    ( (This)->lpVtbl -> SetPath(This,pwzNewValue) ) 

#define IUriBuilder_SetPort(This,fHasPort,dwNewValue)	\
    ( (This)->lpVtbl -> SetPort(This,fHasPort,dwNewValue) ) 

#define IUriBuilder_SetQuery(This,pwzNewValue)	\
    ( (This)->lpVtbl -> SetQuery(This,pwzNewValue) ) 

#define IUriBuilder_SetSchemeName(This,pwzNewValue)	\
    ( (This)->lpVtbl -> SetSchemeName(This,pwzNewValue) ) 

#define IUriBuilder_SetUserName(This,pwzNewValue)	\
    ( (This)->lpVtbl -> SetUserName(This,pwzNewValue) ) 

#define IUriBuilder_RemoveProperties(This,dwPropertyMask)	\
    ( (This)->lpVtbl -> RemoveProperties(This,dwPropertyMask) ) 

#define IUriBuilder_HasBeenModified(This,pfModified)	\
    ( (This)->lpVtbl -> HasBeenModified(This,pfModified) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUriBuilder_INTERFACE_DEFINED__ */


#ifndef __IUriBuilderFactory_INTERFACE_DEFINED__
#define __IUriBuilderFactory_INTERFACE_DEFINED__

/* interface IUriBuilderFactory */
/* [unique][uuid][object][local][helpstring] */ 


EXTERN_C const IID IID_IUriBuilderFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E982CE48-0B96-440c-BC37-0C869B27A29E")
    IUriBuilderFactory : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateIUriBuilder( 
            /* [annotation][in] */ 
            __in  DWORD dwFlags,
            /* [annotation][in] */ 
            __in  DWORD_PTR dwReserved,
            /* [annotation][out] */ 
            __deref_out  IUriBuilder **ppIUriBuilder) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateInitializedIUriBuilder( 
            /* [annotation][in] */ 
            __in  DWORD dwFlags,
            /* [annotation][in] */ 
            __in  DWORD_PTR dwReserved,
            /* [annotation][out] */ 
            __deref_out  IUriBuilder **ppIUriBuilder) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUriBuilderFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUriBuilderFactory * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUriBuilderFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUriBuilderFactory * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateIUriBuilder )( 
            IUriBuilderFactory * This,
            /* [annotation][in] */ 
            __in  DWORD dwFlags,
            /* [annotation][in] */ 
            __in  DWORD_PTR dwReserved,
            /* [annotation][out] */ 
            __deref_out  IUriBuilder **ppIUriBuilder);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateInitializedIUriBuilder )( 
            IUriBuilderFactory * This,
            /* [annotation][in] */ 
            __in  DWORD dwFlags,
            /* [annotation][in] */ 
            __in  DWORD_PTR dwReserved,
            /* [annotation][out] */ 
            __deref_out  IUriBuilder **ppIUriBuilder);
        
        END_INTERFACE
    } IUriBuilderFactoryVtbl;

    interface IUriBuilderFactory
    {
        CONST_VTBL struct IUriBuilderFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUriBuilderFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUriBuilderFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUriBuilderFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUriBuilderFactory_CreateIUriBuilder(This,dwFlags,dwReserved,ppIUriBuilder)	\
    ( (This)->lpVtbl -> CreateIUriBuilder(This,dwFlags,dwReserved,ppIUriBuilder) ) 

#define IUriBuilderFactory_CreateInitializedIUriBuilder(This,dwFlags,dwReserved,ppIUriBuilder)	\
    ( (This)->lpVtbl -> CreateInitializedIUriBuilder(This,dwFlags,dwReserved,ppIUriBuilder) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IUriBuilderFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0018 */
/* [local] */ 

STDAPI CreateIUriBuilder(
    __in_opt    IUri         *pIUri,
    __in        DWORD         dwFlags,
    __in        DWORD_PTR     dwReserved,
    __deref_out IUriBuilder **ppIUriBuilder
    );
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
#ifndef _LPWININETINFO_DEFINED
#define _LPWININETINFO_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0018_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0018_v0_0_s_ifspec;

#ifndef __IWinInetInfo_INTERFACE_DEFINED__
#define __IWinInetInfo_INTERFACE_DEFINED__

/* interface IWinInetInfo */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IWinInetInfo *LPWININETINFO;


EXTERN_C const IID IID_IWinInetInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9d6-bafa-11ce-8c82-00aa004ba90b")
    IWinInetInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE QueryOption( 
            /* [in] */ DWORD dwOption,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD *pcbBuf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWinInetInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWinInetInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWinInetInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWinInetInfo * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *QueryOption )( 
            IWinInetInfo * This,
            /* [in] */ DWORD dwOption,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD *pcbBuf);
        
        END_INTERFACE
    } IWinInetInfoVtbl;

    interface IWinInetInfo
    {
        CONST_VTBL struct IWinInetInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWinInetInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWinInetInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWinInetInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWinInetInfo_QueryOption(This,dwOption,pBuffer,pcbBuf)	\
    ( (This)->lpVtbl -> QueryOption(This,dwOption,pBuffer,pcbBuf) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IWinInetInfo_RemoteQueryOption_Proxy( 
    __RPC__in IWinInetInfo * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ __RPC__inout_ecount_full(*pcbBuf) BYTE *pBuffer,
    /* [out][in] */ __RPC__inout DWORD *pcbBuf);


void __RPC_STUB IWinInetInfo_RemoteQueryOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWinInetInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0019 */
/* [local] */ 

#endif
#define WININETINFO_OPTION_LOCK_HANDLE 65534
#ifndef _LPHTTPSECURITY_DEFINED
#define _LPHTTPSECURITY_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0019_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0019_v0_0_s_ifspec;

#ifndef __IHttpSecurity_INTERFACE_DEFINED__
#define __IHttpSecurity_INTERFACE_DEFINED__

/* interface IHttpSecurity */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IHttpSecurity *LPHTTPSECURITY;


EXTERN_C const IID IID_IHttpSecurity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9d7-bafa-11ce-8c82-00aa004ba90b")
    IHttpSecurity : public IWindowForBindingUI
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnSecurityProblem( 
            /* [in] */ DWORD dwProblem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHttpSecurityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHttpSecurity * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHttpSecurity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHttpSecurity * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IHttpSecurity * This,
            /* [in] */ REFGUID rguidReason,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *OnSecurityProblem )( 
            IHttpSecurity * This,
            /* [in] */ DWORD dwProblem);
        
        END_INTERFACE
    } IHttpSecurityVtbl;

    interface IHttpSecurity
    {
        CONST_VTBL struct IHttpSecurityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHttpSecurity_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHttpSecurity_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHttpSecurity_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHttpSecurity_GetWindow(This,rguidReason,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,rguidReason,phwnd) ) 


#define IHttpSecurity_OnSecurityProblem(This,dwProblem)	\
    ( (This)->lpVtbl -> OnSecurityProblem(This,dwProblem) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHttpSecurity_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0020 */
/* [local] */ 

#endif
#ifndef _LPWININETHTTPINFO_DEFINED
#define _LPWININETHTTPINFO_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0020_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0020_v0_0_s_ifspec;

#ifndef __IWinInetHttpInfo_INTERFACE_DEFINED__
#define __IWinInetHttpInfo_INTERFACE_DEFINED__

/* interface IWinInetHttpInfo */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IWinInetHttpInfo *LPWININETHTTPINFO;


EXTERN_C const IID IID_IWinInetHttpInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9d8-bafa-11ce-8c82-00aa004ba90b")
    IWinInetHttpInfo : public IWinInetInfo
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE QueryInfo( 
            /* [in] */ DWORD dwOption,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD *pcbBuf,
            /* [out][in] */ DWORD *pdwFlags,
            /* [out][in] */ DWORD *pdwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWinInetHttpInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWinInetHttpInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWinInetHttpInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWinInetHttpInfo * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *QueryOption )( 
            IWinInetHttpInfo * This,
            /* [in] */ DWORD dwOption,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD *pcbBuf);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *QueryInfo )( 
            IWinInetHttpInfo * This,
            /* [in] */ DWORD dwOption,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD *pcbBuf,
            /* [out][in] */ DWORD *pdwFlags,
            /* [out][in] */ DWORD *pdwReserved);
        
        END_INTERFACE
    } IWinInetHttpInfoVtbl;

    interface IWinInetHttpInfo
    {
        CONST_VTBL struct IWinInetHttpInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWinInetHttpInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWinInetHttpInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWinInetHttpInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWinInetHttpInfo_QueryOption(This,dwOption,pBuffer,pcbBuf)	\
    ( (This)->lpVtbl -> QueryOption(This,dwOption,pBuffer,pcbBuf) ) 


#define IWinInetHttpInfo_QueryInfo(This,dwOption,pBuffer,pcbBuf,pdwFlags,pdwReserved)	\
    ( (This)->lpVtbl -> QueryInfo(This,dwOption,pBuffer,pcbBuf,pdwFlags,pdwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IWinInetHttpInfo_RemoteQueryInfo_Proxy( 
    __RPC__in IWinInetHttpInfo * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ __RPC__inout_ecount_full(*pcbBuf) BYTE *pBuffer,
    /* [out][in] */ __RPC__inout DWORD *pcbBuf,
    /* [out][in] */ __RPC__inout DWORD *pdwFlags,
    /* [out][in] */ __RPC__inout DWORD *pdwReserved);


void __RPC_STUB IWinInetHttpInfo_RemoteQueryInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWinInetHttpInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0021 */
/* [local] */ 

#endif
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#ifndef _LPWININETCACHEHINTS_DEFINED
#define _LPWININETCACHEHINTS_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0021_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0021_v0_0_s_ifspec;

#ifndef __IWinInetCacheHints_INTERFACE_DEFINED__
#define __IWinInetCacheHints_INTERFACE_DEFINED__

/* interface IWinInetCacheHints */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IWinInetCacheHints *LPWININETCACHEHINTS;


EXTERN_C const IID IID_IWinInetCacheHints;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DD1EC3B3-8391-4fdb-A9E6-347C3CAAA7DD")
    IWinInetCacheHints : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCacheExtension( 
            /* [in] */ LPCWSTR pwzExt,
            /* [size_is][out][in] */ LPVOID pszCacheFile,
            /* [out][in] */ DWORD *pcbCacheFile,
            /* [out][in] */ DWORD *pdwWinInetError,
            /* [out][in] */ DWORD *pdwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWinInetCacheHintsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWinInetCacheHints * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWinInetCacheHints * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWinInetCacheHints * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCacheExtension )( 
            IWinInetCacheHints * This,
            /* [in] */ LPCWSTR pwzExt,
            /* [size_is][out][in] */ LPVOID pszCacheFile,
            /* [out][in] */ DWORD *pcbCacheFile,
            /* [out][in] */ DWORD *pdwWinInetError,
            /* [out][in] */ DWORD *pdwReserved);
        
        END_INTERFACE
    } IWinInetCacheHintsVtbl;

    interface IWinInetCacheHints
    {
        CONST_VTBL struct IWinInetCacheHintsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWinInetCacheHints_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWinInetCacheHints_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWinInetCacheHints_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWinInetCacheHints_SetCacheExtension(This,pwzExt,pszCacheFile,pcbCacheFile,pdwWinInetError,pdwReserved)	\
    ( (This)->lpVtbl -> SetCacheExtension(This,pwzExt,pszCacheFile,pcbCacheFile,pdwWinInetError,pdwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWinInetCacheHints_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0022 */
/* [local] */ 

#endif
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
#if (_WIN32_IE >= _WIN32_IE_IE70)
#ifndef _LPWININETCACHEHINTS2_DEFINED
#define _LPWININETCACHEHINTS2_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0022_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0022_v0_0_s_ifspec;

#ifndef __IWinInetCacheHints2_INTERFACE_DEFINED__
#define __IWinInetCacheHints2_INTERFACE_DEFINED__

/* interface IWinInetCacheHints2 */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IWinInetCacheHints2 *LPWININETCACHEHINTS2;


EXTERN_C const IID IID_IWinInetCacheHints2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7857AEAC-D31F-49bf-884E-DD46DF36780A")
    IWinInetCacheHints2 : public IWinInetCacheHints
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCacheExtension2( 
            /* [in] */ LPCWSTR pwzExt,
            /* [annotation][size_is][out] */ 
            __RPC__out_ecount(*pcchCacheFile)  WCHAR *pwzCacheFile,
            /* [out][in] */ DWORD *pcchCacheFile,
            /* [out] */ DWORD *pdwWinInetError,
            /* [out] */ DWORD *pdwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWinInetCacheHints2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWinInetCacheHints2 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWinInetCacheHints2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWinInetCacheHints2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCacheExtension )( 
            IWinInetCacheHints2 * This,
            /* [in] */ LPCWSTR pwzExt,
            /* [size_is][out][in] */ LPVOID pszCacheFile,
            /* [out][in] */ DWORD *pcbCacheFile,
            /* [out][in] */ DWORD *pdwWinInetError,
            /* [out][in] */ DWORD *pdwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *SetCacheExtension2 )( 
            IWinInetCacheHints2 * This,
            /* [in] */ LPCWSTR pwzExt,
            /* [annotation][size_is][out] */ 
            __RPC__out_ecount(*pcchCacheFile)  WCHAR *pwzCacheFile,
            /* [out][in] */ DWORD *pcchCacheFile,
            /* [out] */ DWORD *pdwWinInetError,
            /* [out] */ DWORD *pdwReserved);
        
        END_INTERFACE
    } IWinInetCacheHints2Vtbl;

    interface IWinInetCacheHints2
    {
        CONST_VTBL struct IWinInetCacheHints2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWinInetCacheHints2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWinInetCacheHints2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWinInetCacheHints2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWinInetCacheHints2_SetCacheExtension(This,pwzExt,pszCacheFile,pcbCacheFile,pdwWinInetError,pdwReserved)	\
    ( (This)->lpVtbl -> SetCacheExtension(This,pwzExt,pszCacheFile,pcbCacheFile,pdwWinInetError,pdwReserved) ) 


#define IWinInetCacheHints2_SetCacheExtension2(This,pwzExt,pwzCacheFile,pcchCacheFile,pdwWinInetError,pdwReserved)	\
    ( (This)->lpVtbl -> SetCacheExtension2(This,pwzExt,pwzCacheFile,pcchCacheFile,pdwWinInetError,pdwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWinInetCacheHints2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0023 */
/* [local] */ 

#endif
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
#define SID_IBindHost IID_IBindHost
#define SID_SBindHost IID_IBindHost
#ifndef _LPBINDHOST_DEFINED
#define _LPBINDHOST_DEFINED
EXTERN_C const GUID SID_BindHost;


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0023_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0023_v0_0_s_ifspec;

#ifndef __IBindHost_INTERFACE_DEFINED__
#define __IBindHost_INTERFACE_DEFINED__

/* interface IBindHost */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IBindHost *LPBINDHOST;


EXTERN_C const IID IID_IBindHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fc4801a1-2ba9-11cf-a229-00aa003d7352")
    IBindHost : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateMoniker( 
            /* [in] */ __RPC__in LPOLESTR szName,
            /* [in] */ __RPC__in_opt IBindCtx *pBC,
            /* [out] */ __RPC__deref_out_opt IMoniker **ppmk,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE MonikerBindToStorage( 
            /* [in] */ IMoniker *pMk,
            /* [in] */ IBindCtx *pBC,
            /* [in] */ IBindStatusCallback *pBSC,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObj) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE MonikerBindToObject( 
            /* [in] */ IMoniker *pMk,
            /* [in] */ IBindCtx *pBC,
            /* [in] */ IBindStatusCallback *pBSC,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObj) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBindHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IBindHost * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IBindHost * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IBindHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateMoniker )( 
            __RPC__in IBindHost * This,
            /* [in] */ __RPC__in LPOLESTR szName,
            /* [in] */ __RPC__in_opt IBindCtx *pBC,
            /* [out] */ __RPC__deref_out_opt IMoniker **ppmk,
            /* [in] */ DWORD dwReserved);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *MonikerBindToStorage )( 
            IBindHost * This,
            /* [in] */ IMoniker *pMk,
            /* [in] */ IBindCtx *pBC,
            /* [in] */ IBindStatusCallback *pBSC,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObj);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *MonikerBindToObject )( 
            IBindHost * This,
            /* [in] */ IMoniker *pMk,
            /* [in] */ IBindCtx *pBC,
            /* [in] */ IBindStatusCallback *pBSC,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppvObj);
        
        END_INTERFACE
    } IBindHostVtbl;

    interface IBindHost
    {
        CONST_VTBL struct IBindHostVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBindHost_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBindHost_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBindHost_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBindHost_CreateMoniker(This,szName,pBC,ppmk,dwReserved)	\
    ( (This)->lpVtbl -> CreateMoniker(This,szName,pBC,ppmk,dwReserved) ) 

#define IBindHost_MonikerBindToStorage(This,pMk,pBC,pBSC,riid,ppvObj)	\
    ( (This)->lpVtbl -> MonikerBindToStorage(This,pMk,pBC,pBSC,riid,ppvObj) ) 

#define IBindHost_MonikerBindToObject(This,pMk,pBC,pBSC,riid,ppvObj)	\
    ( (This)->lpVtbl -> MonikerBindToObject(This,pMk,pBC,pBSC,riid,ppvObj) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindHost_RemoteMonikerBindToStorage_Proxy( 
    __RPC__in IBindHost * This,
    /* [unique][in] */ __RPC__in_opt IMoniker *pMk,
    /* [unique][in] */ __RPC__in_opt IBindCtx *pBC,
    /* [unique][in] */ __RPC__in_opt IBindStatusCallback *pBSC,
    /* [in] */ __RPC__in REFIID riid,
    /* [iid_is][out] */ __RPC__deref_out_opt IUnknown **ppvObj);


void __RPC_STUB IBindHost_RemoteMonikerBindToStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindHost_RemoteMonikerBindToObject_Proxy( 
    __RPC__in IBindHost * This,
    /* [unique][in] */ __RPC__in_opt IMoniker *pMk,
    /* [unique][in] */ __RPC__in_opt IBindCtx *pBC,
    /* [unique][in] */ __RPC__in_opt IBindStatusCallback *pBSC,
    /* [in] */ __RPC__in REFIID riid,
    /* [iid_is][out] */ __RPC__deref_out_opt IUnknown **ppvObj);


void __RPC_STUB IBindHost_RemoteMonikerBindToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBindHost_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0024 */
/* [local] */ 

#endif
                                                                                                           
// These are for backwards compatibility with previous URLMON versions
// Flags for the UrlDownloadToCacheFile                                                                    
#define URLOSTRM_USECACHEDCOPY_ONLY             0x1      // Only get from cache                            
#define URLOSTRM_USECACHEDCOPY                  0x2      // Get from cache if available else download      
#define URLOSTRM_GETNEWESTVERSION               0x3      // Get new version only. But put it in cache too  
                                                                                                           
                                                                                                           
struct IBindStatusCallback;                                                                                
STDAPI HlinkSimpleNavigateToString(                                                                        
    /* [in] */ LPCWSTR szTarget,         // required - target document - null if local jump w/in doc       
    /* [in] */ LPCWSTR szLocation,       // optional, for navigation into middle of a doc                  
    /* [in] */ LPCWSTR szTargetFrameName,// optional, for targeting frame-sets                             
    /* [in] */ IUnknown *pUnk,           // required - we'll search this for other necessary interfaces    
    /* [in] */ IBindCtx *pbc,            // optional. caller may register an IBSC in this                  
    /* [in] */ IBindStatusCallback *,                                                                      
    /* [in] */ DWORD grfHLNF,            // flags                                                          
    /* [in] */ DWORD dwReserved          // for future use, must be NULL                                   
);                                                                                                         
                                                                                                           
STDAPI HlinkSimpleNavigateToMoniker(                                                                       
    /* [in] */ IMoniker *pmkTarget,      // required - target document - (may be null                      
    /* [in] */ LPCWSTR szLocation,       // optional, for navigation into middle of a doc                  
    /* [in] */ LPCWSTR szTargetFrameName,// optional, for targeting frame-sets                             
    /* [in] */ IUnknown *pUnk,           // required - we'll search this for other necessary interfaces    
    /* [in] */ IBindCtx *pbc,            // optional. caller may register an IBSC in this                  
    /* [in] */ IBindStatusCallback *,                                                                      
    /* [in] */ DWORD grfHLNF,            // flags                                                          
    /* [in] */ DWORD dwReserved          // for future use, must be NULL                                   
);                                                                                                         
                                                                                                           
STDAPI URLOpenStreamA(LPUNKNOWN,LPCSTR,DWORD,LPBINDSTATUSCALLBACK);                                        
STDAPI URLOpenStreamW(LPUNKNOWN,LPCWSTR,DWORD,LPBINDSTATUSCALLBACK);                                       
STDAPI URLOpenPullStreamA(LPUNKNOWN,LPCSTR,DWORD,LPBINDSTATUSCALLBACK);                                    
STDAPI URLOpenPullStreamW(LPUNKNOWN,LPCWSTR,DWORD,LPBINDSTATUSCALLBACK);                                   
STDAPI URLDownloadToFileA(LPUNKNOWN,LPCSTR,LPCSTR,DWORD,LPBINDSTATUSCALLBACK);                             
STDAPI URLDownloadToFileW(LPUNKNOWN,LPCWSTR,LPCWSTR,DWORD,LPBINDSTATUSCALLBACK);                           
STDAPI URLDownloadToCacheFileA(__in_opt LPUNKNOWN, __in LPCSTR,  __out_ecount(cchFileName) LPSTR,  DWORD cchFileName, DWORD, __in_opt LPBINDSTATUSCALLBACK);
STDAPI URLDownloadToCacheFileW(__in_opt LPUNKNOWN, __in LPCWSTR, __out_ecount(cchFileName) LPWSTR, DWORD cchFileName, DWORD, __in_opt LPBINDSTATUSCALLBACK);
STDAPI URLOpenBlockingStreamA(LPUNKNOWN,LPCSTR,LPSTREAM*,DWORD,LPBINDSTATUSCALLBACK);                      
STDAPI URLOpenBlockingStreamW(LPUNKNOWN,LPCWSTR,LPSTREAM*,DWORD,LPBINDSTATUSCALLBACK);                     
                                                                                                           
#ifdef UNICODE                                                                                             
#define URLOpenStream            URLOpenStreamW                                                            
#define URLOpenPullStream        URLOpenPullStreamW                                                        
#define URLDownloadToFile        URLDownloadToFileW                                                        
#define URLDownloadToCacheFile   URLDownloadToCacheFileW                                                   
#define URLOpenBlockingStream    URLOpenBlockingStreamW                                                    
#else                                                                                                      
#define URLOpenStream            URLOpenStreamA                                                            
#define URLOpenPullStream        URLOpenPullStreamA                                                        
#define URLDownloadToFile        URLDownloadToFileA                                                        
#define URLDownloadToCacheFile   URLDownloadToCacheFileA                                                   
#define URLOpenBlockingStream    URLOpenBlockingStreamA                                                    
#endif // !UNICODE                                                                                         
                                                                                                           
                                                                                                           
STDAPI HlinkGoBack(IUnknown *pUnk);                                                                        
STDAPI HlinkGoForward(IUnknown *pUnk);                                                                     
STDAPI HlinkNavigateString(IUnknown *pUnk, LPCWSTR szTarget);                                              
STDAPI HlinkNavigateMoniker(IUnknown *pUnk, IMoniker *pmkTarget);                                          
                                                                                                           
#ifndef  _URLMON_NO_ASYNC_PLUGABLE_PROTOCOLS_   










#ifndef _LPIINTERNET
#define _LPIINTERNET


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0024_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0024_v0_0_s_ifspec;

#ifndef __IInternet_INTERFACE_DEFINED__
#define __IInternet_INTERFACE_DEFINED__

/* interface IInternet */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternet *LPIINTERNET;


EXTERN_C const IID IID_IInternet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9e0-baf9-11ce-8c82-00aa004ba90b")
    IInternet : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IInternetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternet * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternet * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternet * This);
        
        END_INTERFACE
    } IInternetVtbl;

    interface IInternet
    {
        CONST_VTBL struct IInternetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternet_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternet_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternet_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternet_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0025 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETBINDINFO
#define _LPIINTERNETBINDINFO


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0025_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0025_v0_0_s_ifspec;

#ifndef __IInternetBindInfo_INTERFACE_DEFINED__
#define __IInternetBindInfo_INTERFACE_DEFINED__

/* interface IInternetBindInfo */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetBindInfo *LPIINTERNETBINDINFO;

typedef 
enum tagBINDSTRING
    {	BINDSTRING_HEADERS	= 1,
	BINDSTRING_ACCEPT_MIMES	= ( BINDSTRING_HEADERS + 1 ) ,
	BINDSTRING_EXTRA_URL	= ( BINDSTRING_ACCEPT_MIMES + 1 ) ,
	BINDSTRING_LANGUAGE	= ( BINDSTRING_EXTRA_URL + 1 ) ,
	BINDSTRING_USERNAME	= ( BINDSTRING_LANGUAGE + 1 ) ,
	BINDSTRING_PASSWORD	= ( BINDSTRING_USERNAME + 1 ) ,
	BINDSTRING_UA_PIXELS	= ( BINDSTRING_PASSWORD + 1 ) ,
	BINDSTRING_UA_COLOR	= ( BINDSTRING_UA_PIXELS + 1 ) ,
	BINDSTRING_OS	= ( BINDSTRING_UA_COLOR + 1 ) ,
	BINDSTRING_USER_AGENT	= ( BINDSTRING_OS + 1 ) ,
	BINDSTRING_ACCEPT_ENCODINGS	= ( BINDSTRING_USER_AGENT + 1 ) ,
	BINDSTRING_POST_COOKIE	= ( BINDSTRING_ACCEPT_ENCODINGS + 1 ) ,
	BINDSTRING_POST_DATA_MIME	= ( BINDSTRING_POST_COOKIE + 1 ) ,
	BINDSTRING_URL	= ( BINDSTRING_POST_DATA_MIME + 1 ) ,
	BINDSTRING_IID	= ( BINDSTRING_URL + 1 ) ,
	BINDSTRING_FLAG_BIND_TO_OBJECT	= ( BINDSTRING_IID + 1 ) ,
	BINDSTRING_PTR_BIND_CONTEXT	= ( BINDSTRING_FLAG_BIND_TO_OBJECT + 1 ) ,
	BINDSTRING_XDR_ORIGIN	= ( BINDSTRING_PTR_BIND_CONTEXT + 1 ) 
    } 	BINDSTRING;


EXTERN_C const IID IID_IInternetBindInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9e1-baf9-11ce-8c82-00aa004ba90b")
    IInternetBindInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetBindInfo( 
            /* [out] */ DWORD *grfBINDF,
            /* [unique][out][in] */ BINDINFO *pbindinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBindString( 
            /* [in] */ ULONG ulStringType,
            /* [annotation][out][in] */ 
            __RPC__out  LPOLESTR *ppwzStr,
            /* [in] */ ULONG cEl,
            /* [out][in] */ ULONG *pcElFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetBindInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetBindInfo * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetBindInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetBindInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetBindInfo )( 
            IInternetBindInfo * This,
            /* [out] */ DWORD *grfBINDF,
            /* [unique][out][in] */ BINDINFO *pbindinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetBindString )( 
            IInternetBindInfo * This,
            /* [in] */ ULONG ulStringType,
            /* [annotation][out][in] */ 
            __RPC__out  LPOLESTR *ppwzStr,
            /* [in] */ ULONG cEl,
            /* [out][in] */ ULONG *pcElFetched);
        
        END_INTERFACE
    } IInternetBindInfoVtbl;

    interface IInternetBindInfo
    {
        CONST_VTBL struct IInternetBindInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetBindInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetBindInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetBindInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetBindInfo_GetBindInfo(This,grfBINDF,pbindinfo)	\
    ( (This)->lpVtbl -> GetBindInfo(This,grfBINDF,pbindinfo) ) 

#define IInternetBindInfo_GetBindString(This,ulStringType,ppwzStr,cEl,pcElFetched)	\
    ( (This)->lpVtbl -> GetBindString(This,ulStringType,ppwzStr,cEl,pcElFetched) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetBindInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0026 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETBINDINFOEX
#define _LPIINTERNETBINDINFOEX


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0026_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0026_v0_0_s_ifspec;

#ifndef __IInternetBindInfoEx_INTERFACE_DEFINED__
#define __IInternetBindInfoEx_INTERFACE_DEFINED__

/* interface IInternetBindInfoEx */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetBindInfoEx *LPIINTERNETBINDINFOEX;


EXTERN_C const IID IID_IInternetBindInfoEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a3e015b7-a82c-4dcd-a150-569aeeed36ab")
    IInternetBindInfoEx : public IInternetBindInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetBindInfoEx( 
            /* [out] */ DWORD *grfBINDF,
            /* [unique][out][in] */ BINDINFO *pbindinfo,
            /* [out] */ DWORD *grfBINDF2,
            /* [out] */ DWORD *pdwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetBindInfoExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetBindInfoEx * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetBindInfoEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetBindInfoEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetBindInfo )( 
            IInternetBindInfoEx * This,
            /* [out] */ DWORD *grfBINDF,
            /* [unique][out][in] */ BINDINFO *pbindinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetBindString )( 
            IInternetBindInfoEx * This,
            /* [in] */ ULONG ulStringType,
            /* [annotation][out][in] */ 
            __RPC__out  LPOLESTR *ppwzStr,
            /* [in] */ ULONG cEl,
            /* [out][in] */ ULONG *pcElFetched);
        
        HRESULT ( STDMETHODCALLTYPE *GetBindInfoEx )( 
            IInternetBindInfoEx * This,
            /* [out] */ DWORD *grfBINDF,
            /* [unique][out][in] */ BINDINFO *pbindinfo,
            /* [out] */ DWORD *grfBINDF2,
            /* [out] */ DWORD *pdwReserved);
        
        END_INTERFACE
    } IInternetBindInfoExVtbl;

    interface IInternetBindInfoEx
    {
        CONST_VTBL struct IInternetBindInfoExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetBindInfoEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetBindInfoEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetBindInfoEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetBindInfoEx_GetBindInfo(This,grfBINDF,pbindinfo)	\
    ( (This)->lpVtbl -> GetBindInfo(This,grfBINDF,pbindinfo) ) 

#define IInternetBindInfoEx_GetBindString(This,ulStringType,ppwzStr,cEl,pcElFetched)	\
    ( (This)->lpVtbl -> GetBindString(This,ulStringType,ppwzStr,cEl,pcElFetched) ) 


#define IInternetBindInfoEx_GetBindInfoEx(This,grfBINDF,pbindinfo,grfBINDF2,pdwReserved)	\
    ( (This)->lpVtbl -> GetBindInfoEx(This,grfBINDF,pbindinfo,grfBINDF2,pdwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetBindInfoEx_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0027 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETPROTOCOLROOT_DEFINED
#define _LPIINTERNETPROTOCOLROOT_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0027_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0027_v0_0_s_ifspec;

#ifndef __IInternetProtocolRoot_INTERFACE_DEFINED__
#define __IInternetProtocolRoot_INTERFACE_DEFINED__

/* interface IInternetProtocolRoot */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetProtocolRoot *LPIINTERNETPROTOCOLROOT;

typedef 
enum _tagPI_FLAGS
    {	PI_PARSE_URL	= 0x1,
	PI_FILTER_MODE	= 0x2,
	PI_FORCE_ASYNC	= 0x4,
	PI_USE_WORKERTHREAD	= 0x8,
	PI_MIMEVERIFICATION	= 0x10,
	PI_CLSIDLOOKUP	= 0x20,
	PI_DATAPROGRESS	= 0x40,
	PI_SYNCHRONOUS	= 0x80,
	PI_APARTMENTTHREADED	= 0x100,
	PI_CLASSINSTALL	= 0x200,
	PI_PASSONBINDCTX	= 0x2000,
	PI_NOMIMEHANDLER	= 0x8000,
	PI_LOADAPPDIRECT	= 0x4000,
	PD_FORCE_SWITCH	= 0x10000,
	PI_PREFERDEFAULTHANDLER	= 0x20000
    } 	PI_FLAGS;

typedef struct _tagPROTOCOLDATA
    {
    DWORD grfFlags;
    DWORD dwState;
    LPVOID pData;
    ULONG cbData;
    } 	PROTOCOLDATA;

typedef struct _tagStartParam
    {
    IID iid;
    IBindCtx *pIBindCtx;
    IUnknown *pItf;
    } 	StartParam;


EXTERN_C const IID IID_IInternetProtocolRoot;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9e3-baf9-11ce-8c82-00aa004ba90b")
    IInternetProtocolRoot : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IInternetProtocolSink *pOIProtSink,
            /* [in] */ IInternetBindInfo *pOIBindInfo,
            /* [in] */ DWORD grfPI,
            /* [in] */ HANDLE_PTR dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Continue( 
            /* [in] */ PROTOCOLDATA *pProtocolData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( 
            /* [in] */ HRESULT hrReason,
            /* [in] */ DWORD dwOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Terminate( 
            /* [in] */ DWORD dwOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetProtocolRootVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetProtocolRoot * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetProtocolRoot * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetProtocolRoot * This);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IInternetProtocolRoot * This,
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IInternetProtocolSink *pOIProtSink,
            /* [in] */ IInternetBindInfo *pOIBindInfo,
            /* [in] */ DWORD grfPI,
            /* [in] */ HANDLE_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *Continue )( 
            IInternetProtocolRoot * This,
            /* [in] */ PROTOCOLDATA *pProtocolData);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IInternetProtocolRoot * This,
            /* [in] */ HRESULT hrReason,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            IInternetProtocolRoot * This,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IInternetProtocolRoot * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IInternetProtocolRoot * This);
        
        END_INTERFACE
    } IInternetProtocolRootVtbl;

    interface IInternetProtocolRoot
    {
        CONST_VTBL struct IInternetProtocolRootVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetProtocolRoot_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetProtocolRoot_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetProtocolRoot_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetProtocolRoot_Start(This,szUrl,pOIProtSink,pOIBindInfo,grfPI,dwReserved)	\
    ( (This)->lpVtbl -> Start(This,szUrl,pOIProtSink,pOIBindInfo,grfPI,dwReserved) ) 

#define IInternetProtocolRoot_Continue(This,pProtocolData)	\
    ( (This)->lpVtbl -> Continue(This,pProtocolData) ) 

#define IInternetProtocolRoot_Abort(This,hrReason,dwOptions)	\
    ( (This)->lpVtbl -> Abort(This,hrReason,dwOptions) ) 

#define IInternetProtocolRoot_Terminate(This,dwOptions)	\
    ( (This)->lpVtbl -> Terminate(This,dwOptions) ) 

#define IInternetProtocolRoot_Suspend(This)	\
    ( (This)->lpVtbl -> Suspend(This) ) 

#define IInternetProtocolRoot_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetProtocolRoot_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0028 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETPROTOCOL_DEFINED
#define _LPIINTERNETPROTOCOL_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0028_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0028_v0_0_s_ifspec;

#ifndef __IInternetProtocol_INTERFACE_DEFINED__
#define __IInternetProtocol_INTERFACE_DEFINED__

/* interface IInternetProtocol */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetProtocol *LPIINTERNETPROTOCOL;


EXTERN_C const IID IID_IInternetProtocol;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9e4-baf9-11ce-8c82-00aa004ba90b")
    IInternetProtocol : public IInternetProtocolRoot
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Read( 
            /* [length_is][size_is][out][in] */ void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbRead) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Seek( 
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER *plibNewPosition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockRequest( 
            /* [in] */ DWORD dwOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockRequest( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetProtocolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetProtocol * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetProtocol * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetProtocol * This);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IInternetProtocol * This,
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IInternetProtocolSink *pOIProtSink,
            /* [in] */ IInternetBindInfo *pOIBindInfo,
            /* [in] */ DWORD grfPI,
            /* [in] */ HANDLE_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *Continue )( 
            IInternetProtocol * This,
            /* [in] */ PROTOCOLDATA *pProtocolData);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IInternetProtocol * This,
            /* [in] */ HRESULT hrReason,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            IInternetProtocol * This,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IInternetProtocol * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IInternetProtocol * This);
        
        HRESULT ( STDMETHODCALLTYPE *Read )( 
            IInternetProtocol * This,
            /* [length_is][size_is][out][in] */ void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbRead);
        
        HRESULT ( STDMETHODCALLTYPE *Seek )( 
            IInternetProtocol * This,
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER *plibNewPosition);
        
        HRESULT ( STDMETHODCALLTYPE *LockRequest )( 
            IInternetProtocol * This,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockRequest )( 
            IInternetProtocol * This);
        
        END_INTERFACE
    } IInternetProtocolVtbl;

    interface IInternetProtocol
    {
        CONST_VTBL struct IInternetProtocolVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetProtocol_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetProtocol_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetProtocol_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetProtocol_Start(This,szUrl,pOIProtSink,pOIBindInfo,grfPI,dwReserved)	\
    ( (This)->lpVtbl -> Start(This,szUrl,pOIProtSink,pOIBindInfo,grfPI,dwReserved) ) 

#define IInternetProtocol_Continue(This,pProtocolData)	\
    ( (This)->lpVtbl -> Continue(This,pProtocolData) ) 

#define IInternetProtocol_Abort(This,hrReason,dwOptions)	\
    ( (This)->lpVtbl -> Abort(This,hrReason,dwOptions) ) 

#define IInternetProtocol_Terminate(This,dwOptions)	\
    ( (This)->lpVtbl -> Terminate(This,dwOptions) ) 

#define IInternetProtocol_Suspend(This)	\
    ( (This)->lpVtbl -> Suspend(This) ) 

#define IInternetProtocol_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 


#define IInternetProtocol_Read(This,pv,cb,pcbRead)	\
    ( (This)->lpVtbl -> Read(This,pv,cb,pcbRead) ) 

#define IInternetProtocol_Seek(This,dlibMove,dwOrigin,plibNewPosition)	\
    ( (This)->lpVtbl -> Seek(This,dlibMove,dwOrigin,plibNewPosition) ) 

#define IInternetProtocol_LockRequest(This,dwOptions)	\
    ( (This)->lpVtbl -> LockRequest(This,dwOptions) ) 

#define IInternetProtocol_UnlockRequest(This)	\
    ( (This)->lpVtbl -> UnlockRequest(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetProtocol_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0029 */
/* [local] */ 

#endif
#if (_WIN32_IE >= _WIN32_IE_IE70)
#ifndef _LPIINTERNETPROTOCOLEX_DEFINED
#define _LPIINTERNETPROTOCOLEX_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0029_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0029_v0_0_s_ifspec;

#ifndef __IInternetProtocolEx_INTERFACE_DEFINED__
#define __IInternetProtocolEx_INTERFACE_DEFINED__

/* interface IInternetProtocolEx */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IInternetProtocolEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C7A98E66-1010-492c-A1C8-C809E1F75905")
    IInternetProtocolEx : public IInternetProtocol
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartEx( 
            /* [in] */ IUri *pUri,
            /* [in] */ IInternetProtocolSink *pOIProtSink,
            /* [in] */ IInternetBindInfo *pOIBindInfo,
            /* [in] */ DWORD grfPI,
            /* [in] */ HANDLE_PTR dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetProtocolExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetProtocolEx * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetProtocolEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetProtocolEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IInternetProtocolEx * This,
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IInternetProtocolSink *pOIProtSink,
            /* [in] */ IInternetBindInfo *pOIBindInfo,
            /* [in] */ DWORD grfPI,
            /* [in] */ HANDLE_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *Continue )( 
            IInternetProtocolEx * This,
            /* [in] */ PROTOCOLDATA *pProtocolData);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IInternetProtocolEx * This,
            /* [in] */ HRESULT hrReason,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            IInternetProtocolEx * This,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IInternetProtocolEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IInternetProtocolEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *Read )( 
            IInternetProtocolEx * This,
            /* [length_is][size_is][out][in] */ void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbRead);
        
        HRESULT ( STDMETHODCALLTYPE *Seek )( 
            IInternetProtocolEx * This,
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER *plibNewPosition);
        
        HRESULT ( STDMETHODCALLTYPE *LockRequest )( 
            IInternetProtocolEx * This,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockRequest )( 
            IInternetProtocolEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartEx )( 
            IInternetProtocolEx * This,
            /* [in] */ IUri *pUri,
            /* [in] */ IInternetProtocolSink *pOIProtSink,
            /* [in] */ IInternetBindInfo *pOIBindInfo,
            /* [in] */ DWORD grfPI,
            /* [in] */ HANDLE_PTR dwReserved);
        
        END_INTERFACE
    } IInternetProtocolExVtbl;

    interface IInternetProtocolEx
    {
        CONST_VTBL struct IInternetProtocolExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetProtocolEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetProtocolEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetProtocolEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetProtocolEx_Start(This,szUrl,pOIProtSink,pOIBindInfo,grfPI,dwReserved)	\
    ( (This)->lpVtbl -> Start(This,szUrl,pOIProtSink,pOIBindInfo,grfPI,dwReserved) ) 

#define IInternetProtocolEx_Continue(This,pProtocolData)	\
    ( (This)->lpVtbl -> Continue(This,pProtocolData) ) 

#define IInternetProtocolEx_Abort(This,hrReason,dwOptions)	\
    ( (This)->lpVtbl -> Abort(This,hrReason,dwOptions) ) 

#define IInternetProtocolEx_Terminate(This,dwOptions)	\
    ( (This)->lpVtbl -> Terminate(This,dwOptions) ) 

#define IInternetProtocolEx_Suspend(This)	\
    ( (This)->lpVtbl -> Suspend(This) ) 

#define IInternetProtocolEx_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 


#define IInternetProtocolEx_Read(This,pv,cb,pcbRead)	\
    ( (This)->lpVtbl -> Read(This,pv,cb,pcbRead) ) 

#define IInternetProtocolEx_Seek(This,dlibMove,dwOrigin,plibNewPosition)	\
    ( (This)->lpVtbl -> Seek(This,dlibMove,dwOrigin,plibNewPosition) ) 

#define IInternetProtocolEx_LockRequest(This,dwOptions)	\
    ( (This)->lpVtbl -> LockRequest(This,dwOptions) ) 

#define IInternetProtocolEx_UnlockRequest(This)	\
    ( (This)->lpVtbl -> UnlockRequest(This) ) 


#define IInternetProtocolEx_StartEx(This,pUri,pOIProtSink,pOIBindInfo,grfPI,dwReserved)	\
    ( (This)->lpVtbl -> StartEx(This,pUri,pOIProtSink,pOIBindInfo,grfPI,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetProtocolEx_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0030 */
/* [local] */ 

#endif
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
#ifndef _LPIINTERNETPROTOCOLSINK_DEFINED
#define _LPIINTERNETPROTOCOLSINK_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0030_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0030_v0_0_s_ifspec;

#ifndef __IInternetProtocolSink_INTERFACE_DEFINED__
#define __IInternetProtocolSink_INTERFACE_DEFINED__

/* interface IInternetProtocolSink */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetProtocolSink *LPIINTERNETPROTOCOLSINK;


EXTERN_C const IID IID_IInternetProtocolSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9e5-baf9-11ce-8c82-00aa004ba90b")
    IInternetProtocolSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Switch( 
            /* [in] */ PROTOCOLDATA *pProtocolData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReportProgress( 
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReportData( 
            /* [in] */ DWORD grfBSCF,
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReportResult( 
            /* [in] */ HRESULT hrResult,
            /* [in] */ DWORD dwError,
            /* [in] */ LPCWSTR szResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetProtocolSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetProtocolSink * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetProtocolSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetProtocolSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *Switch )( 
            IInternetProtocolSink * This,
            /* [in] */ PROTOCOLDATA *pProtocolData);
        
        HRESULT ( STDMETHODCALLTYPE *ReportProgress )( 
            IInternetProtocolSink * This,
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText);
        
        HRESULT ( STDMETHODCALLTYPE *ReportData )( 
            IInternetProtocolSink * This,
            /* [in] */ DWORD grfBSCF,
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax);
        
        HRESULT ( STDMETHODCALLTYPE *ReportResult )( 
            IInternetProtocolSink * This,
            /* [in] */ HRESULT hrResult,
            /* [in] */ DWORD dwError,
            /* [in] */ LPCWSTR szResult);
        
        END_INTERFACE
    } IInternetProtocolSinkVtbl;

    interface IInternetProtocolSink
    {
        CONST_VTBL struct IInternetProtocolSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetProtocolSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetProtocolSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetProtocolSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetProtocolSink_Switch(This,pProtocolData)	\
    ( (This)->lpVtbl -> Switch(This,pProtocolData) ) 

#define IInternetProtocolSink_ReportProgress(This,ulStatusCode,szStatusText)	\
    ( (This)->lpVtbl -> ReportProgress(This,ulStatusCode,szStatusText) ) 

#define IInternetProtocolSink_ReportData(This,grfBSCF,ulProgress,ulProgressMax)	\
    ( (This)->lpVtbl -> ReportData(This,grfBSCF,ulProgress,ulProgressMax) ) 

#define IInternetProtocolSink_ReportResult(This,hrResult,dwError,szResult)	\
    ( (This)->lpVtbl -> ReportResult(This,hrResult,dwError,szResult) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetProtocolSink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0031 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETPROTOCOLSINKSTACKABLE_DEFINED
#define _LPIINTERNETPROTOCOLSINKSTACKABLE_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0031_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0031_v0_0_s_ifspec;

#ifndef __IInternetProtocolSinkStackable_INTERFACE_DEFINED__
#define __IInternetProtocolSinkStackable_INTERFACE_DEFINED__

/* interface IInternetProtocolSinkStackable */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetProtocolSinkStackable *LPIINTERNETPROTOCOLSINKStackable;


EXTERN_C const IID IID_IInternetProtocolSinkStackable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9f0-baf9-11ce-8c82-00aa004ba90b")
    IInternetProtocolSinkStackable : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SwitchSink( 
            /* [in] */ IInternetProtocolSink *pOIProtSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommitSwitch( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RollbackSwitch( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetProtocolSinkStackableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetProtocolSinkStackable * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetProtocolSinkStackable * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetProtocolSinkStackable * This);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchSink )( 
            IInternetProtocolSinkStackable * This,
            /* [in] */ IInternetProtocolSink *pOIProtSink);
        
        HRESULT ( STDMETHODCALLTYPE *CommitSwitch )( 
            IInternetProtocolSinkStackable * This);
        
        HRESULT ( STDMETHODCALLTYPE *RollbackSwitch )( 
            IInternetProtocolSinkStackable * This);
        
        END_INTERFACE
    } IInternetProtocolSinkStackableVtbl;

    interface IInternetProtocolSinkStackable
    {
        CONST_VTBL struct IInternetProtocolSinkStackableVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetProtocolSinkStackable_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetProtocolSinkStackable_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetProtocolSinkStackable_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetProtocolSinkStackable_SwitchSink(This,pOIProtSink)	\
    ( (This)->lpVtbl -> SwitchSink(This,pOIProtSink) ) 

#define IInternetProtocolSinkStackable_CommitSwitch(This)	\
    ( (This)->lpVtbl -> CommitSwitch(This) ) 

#define IInternetProtocolSinkStackable_RollbackSwitch(This)	\
    ( (This)->lpVtbl -> RollbackSwitch(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetProtocolSinkStackable_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0032 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETSESSION_DEFINED
#define _LPIINTERNETSESSION_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0032_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0032_v0_0_s_ifspec;

#ifndef __IInternetSession_INTERFACE_DEFINED__
#define __IInternetSession_INTERFACE_DEFINED__

/* interface IInternetSession */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetSession *LPIINTERNETSESSION;

typedef 
enum _tagOIBDG_FLAGS
    {	OIBDG_APARTMENTTHREADED	= 0x100,
	OIBDG_DATAONLY	= 0x1000
    } 	OIBDG_FLAGS;


EXTERN_C const IID IID_IInternetSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9e7-baf9-11ce-8c82-00aa004ba90b")
    IInternetSession : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterNameSpace( 
            /* [in] */ IClassFactory *pCF,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LPCWSTR pwzProtocol,
            /* [in] */ ULONG cPatterns,
            /* [in] */ const LPCWSTR *ppwzPatterns,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterNameSpace( 
            /* [in] */ IClassFactory *pCF,
            /* [in] */ LPCWSTR pszProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterMimeFilter( 
            /* [in] */ IClassFactory *pCF,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LPCWSTR pwzType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterMimeFilter( 
            /* [in] */ IClassFactory *pCF,
            /* [in] */ LPCWSTR pwzType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBinding( 
            /* [in] */ LPBC pBC,
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IUnknown *pUnkOuter,
            /* [unique][out] */ IUnknown **ppUnk,
            /* [unique][out] */ IInternetProtocol **ppOInetProt,
            /* [in] */ DWORD dwOption) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSessionOption( 
            /* [in] */ DWORD dwOption,
            /* [in] */ LPVOID pBuffer,
            /* [in] */ DWORD dwBufferLength,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSessionOption( 
            /* [in] */ DWORD dwOption,
            /* [out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD *pdwBufferLength,
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetSession * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterNameSpace )( 
            IInternetSession * This,
            /* [in] */ IClassFactory *pCF,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LPCWSTR pwzProtocol,
            /* [in] */ ULONG cPatterns,
            /* [in] */ const LPCWSTR *ppwzPatterns,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterNameSpace )( 
            IInternetSession * This,
            /* [in] */ IClassFactory *pCF,
            /* [in] */ LPCWSTR pszProtocol);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterMimeFilter )( 
            IInternetSession * This,
            /* [in] */ IClassFactory *pCF,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LPCWSTR pwzType);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterMimeFilter )( 
            IInternetSession * This,
            /* [in] */ IClassFactory *pCF,
            /* [in] */ LPCWSTR pwzType);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBinding )( 
            IInternetSession * This,
            /* [in] */ LPBC pBC,
            /* [in] */ LPCWSTR szUrl,
            /* [in] */ IUnknown *pUnkOuter,
            /* [unique][out] */ IUnknown **ppUnk,
            /* [unique][out] */ IInternetProtocol **ppOInetProt,
            /* [in] */ DWORD dwOption);
        
        HRESULT ( STDMETHODCALLTYPE *SetSessionOption )( 
            IInternetSession * This,
            /* [in] */ DWORD dwOption,
            /* [in] */ LPVOID pBuffer,
            /* [in] */ DWORD dwBufferLength,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetSessionOption )( 
            IInternetSession * This,
            /* [in] */ DWORD dwOption,
            /* [out][in] */ LPVOID pBuffer,
            /* [out][in] */ DWORD *pdwBufferLength,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } IInternetSessionVtbl;

    interface IInternetSession
    {
        CONST_VTBL struct IInternetSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetSession_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetSession_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetSession_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetSession_RegisterNameSpace(This,pCF,rclsid,pwzProtocol,cPatterns,ppwzPatterns,dwReserved)	\
    ( (This)->lpVtbl -> RegisterNameSpace(This,pCF,rclsid,pwzProtocol,cPatterns,ppwzPatterns,dwReserved) ) 

#define IInternetSession_UnregisterNameSpace(This,pCF,pszProtocol)	\
    ( (This)->lpVtbl -> UnregisterNameSpace(This,pCF,pszProtocol) ) 

#define IInternetSession_RegisterMimeFilter(This,pCF,rclsid,pwzType)	\
    ( (This)->lpVtbl -> RegisterMimeFilter(This,pCF,rclsid,pwzType) ) 

#define IInternetSession_UnregisterMimeFilter(This,pCF,pwzType)	\
    ( (This)->lpVtbl -> UnregisterMimeFilter(This,pCF,pwzType) ) 

#define IInternetSession_CreateBinding(This,pBC,szUrl,pUnkOuter,ppUnk,ppOInetProt,dwOption)	\
    ( (This)->lpVtbl -> CreateBinding(This,pBC,szUrl,pUnkOuter,ppUnk,ppOInetProt,dwOption) ) 

#define IInternetSession_SetSessionOption(This,dwOption,pBuffer,dwBufferLength,dwReserved)	\
    ( (This)->lpVtbl -> SetSessionOption(This,dwOption,pBuffer,dwBufferLength,dwReserved) ) 

#define IInternetSession_GetSessionOption(This,dwOption,pBuffer,pdwBufferLength,dwReserved)	\
    ( (This)->lpVtbl -> GetSessionOption(This,dwOption,pBuffer,pdwBufferLength,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetSession_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0033 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETTHREADSWITCH_DEFINED
#define _LPIINTERNETTHREADSWITCH_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0033_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0033_v0_0_s_ifspec;

#ifndef __IInternetThreadSwitch_INTERFACE_DEFINED__
#define __IInternetThreadSwitch_INTERFACE_DEFINED__

/* interface IInternetThreadSwitch */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetThreadSwitch *LPIINTERNETTHREADSWITCH;


EXTERN_C const IID IID_IInternetThreadSwitch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9e8-baf9-11ce-8c82-00aa004ba90b")
    IInternetThreadSwitch : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Prepare( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Continue( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetThreadSwitchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetThreadSwitch * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetThreadSwitch * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetThreadSwitch * This);
        
        HRESULT ( STDMETHODCALLTYPE *Prepare )( 
            IInternetThreadSwitch * This);
        
        HRESULT ( STDMETHODCALLTYPE *Continue )( 
            IInternetThreadSwitch * This);
        
        END_INTERFACE
    } IInternetThreadSwitchVtbl;

    interface IInternetThreadSwitch
    {
        CONST_VTBL struct IInternetThreadSwitchVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetThreadSwitch_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetThreadSwitch_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetThreadSwitch_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetThreadSwitch_Prepare(This)	\
    ( (This)->lpVtbl -> Prepare(This) ) 

#define IInternetThreadSwitch_Continue(This)	\
    ( (This)->lpVtbl -> Continue(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetThreadSwitch_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0034 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETPRIORITY_DEFINED
#define _LPIINTERNETPRIORITY_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0034_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0034_v0_0_s_ifspec;

#ifndef __IInternetPriority_INTERFACE_DEFINED__
#define __IInternetPriority_INTERFACE_DEFINED__

/* interface IInternetPriority */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetPriority *LPIINTERNETPRIORITY;


EXTERN_C const IID IID_IInternetPriority;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9eb-baf9-11ce-8c82-00aa004ba90b")
    IInternetPriority : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPriority( 
            /* [in] */ LONG nPriority) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPriority( 
            /* [out] */ LONG *pnPriority) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetPriorityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetPriority * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetPriority * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetPriority * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPriority )( 
            IInternetPriority * This,
            /* [in] */ LONG nPriority);
        
        HRESULT ( STDMETHODCALLTYPE *GetPriority )( 
            IInternetPriority * This,
            /* [out] */ LONG *pnPriority);
        
        END_INTERFACE
    } IInternetPriorityVtbl;

    interface IInternetPriority
    {
        CONST_VTBL struct IInternetPriorityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetPriority_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetPriority_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetPriority_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetPriority_SetPriority(This,nPriority)	\
    ( (This)->lpVtbl -> SetPriority(This,nPriority) ) 

#define IInternetPriority_GetPriority(This,pnPriority)	\
    ( (This)->lpVtbl -> GetPriority(This,pnPriority) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetPriority_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0035 */
/* [local] */ 

#endif
#ifndef _LPIINTERNETPROTOCOLINFO_DEFINED
#define _LPIINTERNETPROTOCOLINFO_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0035_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0035_v0_0_s_ifspec;

#ifndef __IInternetProtocolInfo_INTERFACE_DEFINED__
#define __IInternetProtocolInfo_INTERFACE_DEFINED__

/* interface IInternetProtocolInfo */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IInternetProtocolInfo *LPIINTERNETPROTOCOLINFO;

typedef 
enum _tagPARSEACTION
    {	PARSE_CANONICALIZE	= 1,
	PARSE_FRIENDLY	= ( PARSE_CANONICALIZE + 1 ) ,
	PARSE_SECURITY_URL	= ( PARSE_FRIENDLY + 1 ) ,
	PARSE_ROOTDOCUMENT	= ( PARSE_SECURITY_URL + 1 ) ,
	PARSE_DOCUMENT	= ( PARSE_ROOTDOCUMENT + 1 ) ,
	PARSE_ANCHOR	= ( PARSE_DOCUMENT + 1 ) ,
	PARSE_ENCODE_IS_UNESCAPE	= ( PARSE_ANCHOR + 1 ) ,
	PARSE_DECODE_IS_ESCAPE	= ( PARSE_ENCODE_IS_UNESCAPE + 1 ) ,
	PARSE_PATH_FROM_URL	= ( PARSE_DECODE_IS_ESCAPE + 1 ) ,
	PARSE_URL_FROM_PATH	= ( PARSE_PATH_FROM_URL + 1 ) ,
	PARSE_MIME	= ( PARSE_URL_FROM_PATH + 1 ) ,
	PARSE_SERVER	= ( PARSE_MIME + 1 ) ,
	PARSE_SCHEMA	= ( PARSE_SERVER + 1 ) ,
	PARSE_SITE	= ( PARSE_SCHEMA + 1 ) ,
	PARSE_DOMAIN	= ( PARSE_SITE + 1 ) ,
	PARSE_LOCATION	= ( PARSE_DOMAIN + 1 ) ,
	PARSE_SECURITY_DOMAIN	= ( PARSE_LOCATION + 1 ) ,
	PARSE_ESCAPE	= ( PARSE_SECURITY_DOMAIN + 1 ) ,
	PARSE_UNESCAPE	= ( PARSE_ESCAPE + 1 ) 
    } 	PARSEACTION;

typedef 
enum _tagPSUACTION
    {	PSU_DEFAULT	= 1,
	PSU_SECURITY_URL_ONLY	= ( PSU_DEFAULT + 1 ) 
    } 	PSUACTION;

typedef 
enum _tagQUERYOPTION
    {	QUERY_EXPIRATION_DATE	= 1,
	QUERY_TIME_OF_LAST_CHANGE	= ( QUERY_EXPIRATION_DATE + 1 ) ,
	QUERY_CONTENT_ENCODING	= ( QUERY_TIME_OF_LAST_CHANGE + 1 ) ,
	QUERY_CONTENT_TYPE	= ( QUERY_CONTENT_ENCODING + 1 ) ,
	QUERY_REFRESH	= ( QUERY_CONTENT_TYPE + 1 ) ,
	QUERY_RECOMBINE	= ( QUERY_REFRESH + 1 ) ,
	QUERY_CAN_NAVIGATE	= ( QUERY_RECOMBINE + 1 ) ,
	QUERY_USES_NETWORK	= ( QUERY_CAN_NAVIGATE + 1 ) ,
	QUERY_IS_CACHED	= ( QUERY_USES_NETWORK + 1 ) ,
	QUERY_IS_INSTALLEDENTRY	= ( QUERY_IS_CACHED + 1 ) ,
	QUERY_IS_CACHED_OR_MAPPED	= ( QUERY_IS_INSTALLEDENTRY + 1 ) ,
	QUERY_USES_CACHE	= ( QUERY_IS_CACHED_OR_MAPPED + 1 ) ,
	QUERY_IS_SECURE	= ( QUERY_USES_CACHE + 1 ) ,
	QUERY_IS_SAFE	= ( QUERY_IS_SECURE + 1 ) ,
	QUERY_USES_HISTORYFOLDER	= ( QUERY_IS_SAFE + 1 ) 
    } 	QUERYOPTION;


EXTERN_C const IID IID_IInternetProtocolInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9ec-baf9-11ce-8c82-00aa004ba90b")
    IInternetProtocolInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParseUrl( 
            /* [in] */ LPCWSTR pwzUrl,
            /* [in] */ PARSEACTION ParseAction,
            /* [in] */ DWORD dwParseFlags,
            /* [annotation][out] */ 
            __RPC__out  LPWSTR pwzResult,
            /* [in] */ DWORD cchResult,
            /* [out] */ DWORD *pcchResult,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CombineUrl( 
            /* [in] */ LPCWSTR pwzBaseUrl,
            /* [in] */ LPCWSTR pwzRelativeUrl,
            /* [in] */ DWORD dwCombineFlags,
            /* [annotation][out] */ 
            __RPC__in  LPWSTR pwzResult,
            /* [in] */ DWORD cchResult,
            /* [out] */ DWORD *pcchResult,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompareUrl( 
            /* [in] */ LPCWSTR pwzUrl1,
            /* [in] */ LPCWSTR pwzUrl2,
            /* [in] */ DWORD dwCompareFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryInfo( 
            /* [in] */ LPCWSTR pwzUrl,
            /* [in] */ QUERYOPTION OueryOption,
            /* [in] */ DWORD dwQueryFlags,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [in] */ DWORD cbBuffer,
            /* [out][in] */ DWORD *pcbBuf,
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetProtocolInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetProtocolInfo * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetProtocolInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetProtocolInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParseUrl )( 
            IInternetProtocolInfo * This,
            /* [in] */ LPCWSTR pwzUrl,
            /* [in] */ PARSEACTION ParseAction,
            /* [in] */ DWORD dwParseFlags,
            /* [annotation][out] */ 
            __RPC__out  LPWSTR pwzResult,
            /* [in] */ DWORD cchResult,
            /* [out] */ DWORD *pcchResult,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *CombineUrl )( 
            IInternetProtocolInfo * This,
            /* [in] */ LPCWSTR pwzBaseUrl,
            /* [in] */ LPCWSTR pwzRelativeUrl,
            /* [in] */ DWORD dwCombineFlags,
            /* [annotation][out] */ 
            __RPC__in  LPWSTR pwzResult,
            /* [in] */ DWORD cchResult,
            /* [out] */ DWORD *pcchResult,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *CompareUrl )( 
            IInternetProtocolInfo * This,
            /* [in] */ LPCWSTR pwzUrl1,
            /* [in] */ LPCWSTR pwzUrl2,
            /* [in] */ DWORD dwCompareFlags);
        
        HRESULT ( STDMETHODCALLTYPE *QueryInfo )( 
            IInternetProtocolInfo * This,
            /* [in] */ LPCWSTR pwzUrl,
            /* [in] */ QUERYOPTION OueryOption,
            /* [in] */ DWORD dwQueryFlags,
            /* [size_is][out][in] */ LPVOID pBuffer,
            /* [in] */ DWORD cbBuffer,
            /* [out][in] */ DWORD *pcbBuf,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } IInternetProtocolInfoVtbl;

    interface IInternetProtocolInfo
    {
        CONST_VTBL struct IInternetProtocolInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetProtocolInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetProtocolInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetProtocolInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetProtocolInfo_ParseUrl(This,pwzUrl,ParseAction,dwParseFlags,pwzResult,cchResult,pcchResult,dwReserved)	\
    ( (This)->lpVtbl -> ParseUrl(This,pwzUrl,ParseAction,dwParseFlags,pwzResult,cchResult,pcchResult,dwReserved) ) 

#define IInternetProtocolInfo_CombineUrl(This,pwzBaseUrl,pwzRelativeUrl,dwCombineFlags,pwzResult,cchResult,pcchResult,dwReserved)	\
    ( (This)->lpVtbl -> CombineUrl(This,pwzBaseUrl,pwzRelativeUrl,dwCombineFlags,pwzResult,cchResult,pcchResult,dwReserved) ) 

#define IInternetProtocolInfo_CompareUrl(This,pwzUrl1,pwzUrl2,dwCompareFlags)	\
    ( (This)->lpVtbl -> CompareUrl(This,pwzUrl1,pwzUrl2,dwCompareFlags) ) 

#define IInternetProtocolInfo_QueryInfo(This,pwzUrl,OueryOption,dwQueryFlags,pBuffer,cbBuffer,pcbBuf,dwReserved)	\
    ( (This)->lpVtbl -> QueryInfo(This,pwzUrl,OueryOption,dwQueryFlags,pBuffer,cbBuffer,pcbBuf,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetProtocolInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0036 */
/* [local] */ 

#ifndef URLMON_STRICT
// PARSE_ENCODE was misnamed and is deprecated for PARSE_UNESCAPE
#define PARSE_ENCODE PARSE_ENCODE_IS_UNESCAPE
// PARSE_DECODE was misnamed and is deprecated for PARSE_ESCAPE
#define PARSE_DECODE PARSE_DECODE_IS_ESCAPE
#endif //!URLMON_STRICT
#endif
#define IOInet               IInternet            
#define IOInetBindInfo       IInternetBindInfo    
#define IOInetBindInfoEx     IInternetBindInfoEx  
#define IOInetProtocolRoot   IInternetProtocolRoot
#define IOInetProtocol       IInternetProtocol    
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define IOInetProtocolEx     IInternetProtocolEx  
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
#define IOInetProtocolSink   IInternetProtocolSink
#define IOInetProtocolInfo   IInternetProtocolInfo
#define IOInetSession        IInternetSession     
#define IOInetPriority       IInternetPriority    
#define IOInetThreadSwitch   IInternetThreadSwitch
#define IOInetProtocolSinkStackable   IInternetProtocolSinkStackable
#define LPOINET              LPIINTERNET             
#define LPOINETPROTOCOLINFO  LPIINTERNETPROTOCOLINFO 
#define LPOINETBINDINFO      LPIINTERNETBINDINFO     
#define LPOINETPROTOCOLROOT  LPIINTERNETPROTOCOLROOT 
#define LPOINETPROTOCOL      LPIINTERNETPROTOCOL     
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define LPOINETPROTOCOLEX    LPIINTERNETPROTOCOLEX   
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
#define LPOINETPROTOCOLSINK  LPIINTERNETPROTOCOLSINK 
#define LPOINETSESSION       LPIINTERNETSESSION      
#define LPOINETTHREADSWITCH  LPIINTERNETTHREADSWITCH 
#define LPOINETPRIORITY      LPIINTERNETPRIORITY     
#define LPOINETPROTOCOLINFO  LPIINTERNETPROTOCOLINFO 
#define LPOINETPROTOCOLSINKSTACKABLE  LPIINTERNETPROTOCOLSINKSTACKABLE 
#define IID_IOInet               IID_IInternet            
#define IID_IOInetBindInfo       IID_IInternetBindInfo    
#define IID_IOInetBindInfoEx     IID_IInternetBindInfoEx  
#define IID_IOInetProtocolRoot   IID_IInternetProtocolRoot
#define IID_IOInetProtocol       IID_IInternetProtocol    
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define IID_IOInetProtocolEx     IID_IInternetProtocolEx  
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
#define IID_IOInetProtocolSink   IID_IInternetProtocolSink
#define IID_IOInetProtocolInfo   IID_IInternetProtocolInfo
#define IID_IOInetSession        IID_IInternetSession     
#define IID_IOInetPriority       IID_IInternetPriority    
#define IID_IOInetThreadSwitch   IID_IInternetThreadSwitch
#define IID_IOInetProtocolSinkStackable   IID_IInternetProtocolSinkStackable
STDAPI CoInternetParseUrl(                              
                            LPCWSTR      pwzUrl,        
                            PARSEACTION  ParseAction,   
                            DWORD        dwFlags,       
    __out_ecount_part(cchResult,*pcchResult+1) LPWSTR       pszResult,     
                            DWORD        cchResult,     
                      __out DWORD       *pcchResult,    
                            DWORD        dwReserved     
    );                                                  
#if (_WIN32_IE >= _WIN32_IE_IE70)
STDAPI CoInternetParseIUri(                             
                       __in IUri        *pIUri,         
                            PARSEACTION  ParseAction,   
                            DWORD        dwFlags,       
    __out_ecount_part(cchResult,*pcchResult+1) LPWSTR       pwzResult,     
                            DWORD        cchResult,     
                      __out DWORD       *pcchResult,    
                            DWORD_PTR    dwReserved     
    );                                                  
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
STDAPI CoInternetCombineUrl(                                             
                                               LPCWSTR   pwzBaseUrl,     
                                               LPCWSTR   pwzRelativeUrl, 
                                               DWORD     dwCombineFlags, 
    __out_ecount_part(cchResult,*pcchResult+1) LPWSTR    pszResult,      
                                               DWORD     cchResult,      
    __out_opt                                  DWORD     *pcchResult,    
    __reserved                                 DWORD     dwReserved      
    );                                                                   
#if (_WIN32_IE >= _WIN32_IE_IE70)
STDAPI CoInternetCombineUrlEx(              
    __in_opt    IUri       *pBaseUri,       
    __in_opt    LPCWSTR     pwzRelativeUrl, 
                DWORD       dwCombineFlags, 
    __deref_out IUri      **ppCombinedUri,  
    __in_opt    DWORD_PTR   dwReserved      
    );                                      
STDAPI CoInternetCombineIUri (              
    __in        IUri       *pBaseUri,       
    __in        IUri       *pRelativeUri,   
                DWORD       dwCombineFlags, 
    __deref_out IUri      **ppCombinedUri,  
    __in_opt    DWORD_PTR   dwReserved      
    );                                      
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
STDAPI CoInternetCompareUrl(             
    LPCWSTR pwzUrl1,                     
    LPCWSTR pwzUrl2,                     
    DWORD dwFlags                        
    );                                   
STDAPI CoInternetGetProtocolFlags(       
    LPCWSTR     pwzUrl,                  
    __out DWORD      *pdwFlags,          
    DWORD       dwReserved               
    );                                   
STDAPI CoInternetQueryInfo(              
    LPCWSTR     pwzUrl,                  
    QUERYOPTION QueryOptions,            
    DWORD       dwQueryFlags,            
    __out_bcount_part(cbBuffer, *pcbBuffer) LPVOID pvBuffer,
    __in_range(>=, sizeof(DWORD))  DWORD       cbBuffer,                
    __out_opt DWORD      *pcbBuffer,     
    DWORD       dwReserved               
    );                                   
STDAPI CoInternetGetSession(             
    DWORD       dwSessionMode,           
    __deref_out IInternetSession **ppIInternetSession,
    DWORD       dwReserved               
    );                                   
STDAPI CoInternetGetSecurityUrl(         
    LPCWSTR pwszUrl,                     
    __deref_out LPWSTR *ppwszSecUrl,     
    __in PSUACTION   psuAction,          
    __reserved DWORD dwReserved          
    );                                   
STDAPI AsyncInstallDistributionUnit(     
    LPCWSTR szDistUnit,                  
    LPCWSTR szTYPE,                      
    LPCWSTR szExt,                       
    DWORD dwFileVersionMS,               
    DWORD dwFileVersionLS,               
    LPCWSTR szURL,                       
    IBindCtx *pbc,                       
    LPVOID   pvReserved,                 
    DWORD   flags                        
    );                                   
#if (_WIN32_IE >= _WIN32_IE_IE70)
STDAPI CoInternetGetSecurityUrlEx(       
    __in IUri         *pUri,             
    __deref_out IUri **ppSecUri,         
    PSUACTION          psuAction,        
    __reserved  DWORD_PTR dwReserved 

    
    );                                   
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#ifndef _INTERNETFEATURELIST_DEFINED
#define _INTERNETFEATURELIST_DEFINED
typedef 
enum _tagINTERNETFEATURELIST
    {	FEATURE_OBJECT_CACHING	= 0,
	FEATURE_ZONE_ELEVATION	= ( FEATURE_OBJECT_CACHING + 1 ) ,
	FEATURE_MIME_HANDLING	= ( FEATURE_ZONE_ELEVATION + 1 ) ,
	FEATURE_MIME_SNIFFING	= ( FEATURE_MIME_HANDLING + 1 ) ,
	FEATURE_WINDOW_RESTRICTIONS	= ( FEATURE_MIME_SNIFFING + 1 ) ,
	FEATURE_WEBOC_POPUPMANAGEMENT	= ( FEATURE_WINDOW_RESTRICTIONS + 1 ) ,
	FEATURE_BEHAVIORS	= ( FEATURE_WEBOC_POPUPMANAGEMENT + 1 ) ,
	FEATURE_DISABLE_MK_PROTOCOL	= ( FEATURE_BEHAVIORS + 1 ) ,
	FEATURE_LOCALMACHINE_LOCKDOWN	= ( FEATURE_DISABLE_MK_PROTOCOL + 1 ) ,
	FEATURE_SECURITYBAND	= ( FEATURE_LOCALMACHINE_LOCKDOWN + 1 ) ,
	FEATURE_RESTRICT_ACTIVEXINSTALL	= ( FEATURE_SECURITYBAND + 1 ) ,
	FEATURE_VALIDATE_NAVIGATE_URL	= ( FEATURE_RESTRICT_ACTIVEXINSTALL + 1 ) ,
	FEATURE_RESTRICT_FILEDOWNLOAD	= ( FEATURE_VALIDATE_NAVIGATE_URL + 1 ) ,
	FEATURE_ADDON_MANAGEMENT	= ( FEATURE_RESTRICT_FILEDOWNLOAD + 1 ) ,
	FEATURE_PROTOCOL_LOCKDOWN	= ( FEATURE_ADDON_MANAGEMENT + 1 ) ,
	FEATURE_HTTP_USERNAME_PASSWORD_DISABLE	= ( FEATURE_PROTOCOL_LOCKDOWN + 1 ) ,
	FEATURE_SAFE_BINDTOOBJECT	= ( FEATURE_HTTP_USERNAME_PASSWORD_DISABLE + 1 ) ,
	FEATURE_UNC_SAVEDFILECHECK	= ( FEATURE_SAFE_BINDTOOBJECT + 1 ) ,
	FEATURE_GET_URL_DOM_FILEPATH_UNENCODED	= ( FEATURE_UNC_SAVEDFILECHECK + 1 ) ,
	FEATURE_TABBED_BROWSING	= ( FEATURE_GET_URL_DOM_FILEPATH_UNENCODED + 1 ) ,
	FEATURE_SSLUX	= ( FEATURE_TABBED_BROWSING + 1 ) ,
	FEATURE_DISABLE_NAVIGATION_SOUNDS	= ( FEATURE_SSLUX + 1 ) ,
	FEATURE_DISABLE_LEGACY_COMPRESSION	= ( FEATURE_DISABLE_NAVIGATION_SOUNDS + 1 ) ,
	FEATURE_FORCE_ADDR_AND_STATUS	= ( FEATURE_DISABLE_LEGACY_COMPRESSION + 1 ) ,
	FEATURE_XMLHTTP	= ( FEATURE_FORCE_ADDR_AND_STATUS + 1 ) ,
	FEATURE_DISABLE_TELNET_PROTOCOL	= ( FEATURE_XMLHTTP + 1 ) ,
	FEATURE_FEEDS	= ( FEATURE_DISABLE_TELNET_PROTOCOL + 1 ) ,
	FEATURE_BLOCK_INPUT_PROMPTS	= ( FEATURE_FEEDS + 1 ) ,
	FEATURE_ENTRY_COUNT	= ( FEATURE_BLOCK_INPUT_PROMPTS + 1 ) 
    } 	INTERNETFEATURELIST;


// CoInternetSetFeatureEnabled can be used to set/reset features. 
// The following flags control where the feature is set

#define SET_FEATURE_ON_THREAD                       0x00000001
#define SET_FEATURE_ON_PROCESS                      0x00000002
#define SET_FEATURE_IN_REGISTRY                     0x00000004
#define SET_FEATURE_ON_THREAD_LOCALMACHINE          0x00000008
#define SET_FEATURE_ON_THREAD_INTRANET              0x00000010
#define SET_FEATURE_ON_THREAD_TRUSTED               0x00000020
#define SET_FEATURE_ON_THREAD_INTERNET              0x00000040
#define SET_FEATURE_ON_THREAD_RESTRICTED            0x00000080

// CoInternetIsFeatureEnabled can be used to get features. 
// The following flags control where the feature is obtained from
// default is from process

#define GET_FEATURE_FROM_THREAD                      0x00000001
#define GET_FEATURE_FROM_PROCESS                     0x00000002
#define GET_FEATURE_FROM_REGISTRY                    0x00000004
#define GET_FEATURE_FROM_THREAD_LOCALMACHINE         0x00000008
#define GET_FEATURE_FROM_THREAD_INTRANET             0x00000010
#define GET_FEATURE_FROM_THREAD_TRUSTED              0x00000020
#define GET_FEATURE_FROM_THREAD_INTERNET             0x00000040
#define GET_FEATURE_FROM_THREAD_RESTRICTED           0x00000080
#endif
STDAPI CoInternetSetFeatureEnabled(      
    INTERNETFEATURELIST FeatureEntry,    
    DWORD dwFlags,                       
    BOOL fEnable                         
    );                                   
STDAPI CoInternetIsFeatureEnabled(       
    INTERNETFEATURELIST FeatureEntry,    
    DWORD dwFlags                        
    );                                   
STDAPI CoInternetIsFeatureEnabledForUrl( 
    INTERNETFEATURELIST FeatureEntry,    
    DWORD dwFlags,                       
    LPCWSTR szURL,                       
    IInternetSecurityManager *pSecMgr    
    );                                   
STDAPI CoInternetIsFeatureEnabledForIUri( 
    INTERNETFEATURELIST FeatureEntry,     
    DWORD dwFlags,                        
    IUri * pIUri,                         
    IInternetSecurityManagerEx2 *pSecMgr  
    );                                    
STDAPI CoInternetIsFeatureZoneElevationEnabled( 
    LPCWSTR szFromURL,                          
    LPCWSTR szToURL,                            
    IInternetSecurityManager *pSecMgr,          
    DWORD dwFlags                               
    );                                          
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
 
STDAPI CopyStgMedium(const STGMEDIUM * pcstgmedSrc,  
                           STGMEDIUM * pstgmedDest); 
STDAPI CopyBindInfo( const BINDINFO * pcbiSrc,   
                           BINDINFO * pbiDest ); 
STDAPI_(void) ReleaseBindInfo( BINDINFO * pbindinfo );  
 
#define INET_E_USE_DEFAULT_PROTOCOLHANDLER _HRESULT_TYPEDEF_(0x800C0011L)      
#define INET_E_USE_DEFAULT_SETTING         _HRESULT_TYPEDEF_(0x800C0012L)      
#define INET_E_DEFAULT_ACTION              INET_E_USE_DEFAULT_PROTOCOLHANDLER  
#define INET_E_QUERYOPTION_UNKNOWN         _HRESULT_TYPEDEF_(0x800C0013L)      
#define INET_E_REDIRECTING                 _HRESULT_TYPEDEF_(0x800C0014L)      
#define OInetParseUrl               CoInternetParseUrl               
#define OInetCombineUrl             CoInternetCombineUrl             
#if (_WIN32_IE >= _WIN32_IE_IE70)
#define OInetCombineUrlEx           CoInternetCombineUrlEx           
#define OInetCombineIUri            CoInternetCombineIUri            
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
#define OInetCompareUrl             CoInternetCompareUrl             
#define OInetQueryInfo              CoInternetQueryInfo              
#define OInetGetSession             CoInternetGetSession             
#endif // !_URLMON_NO_ASYNC_PLUGABLE_PROTOCOLS_ 
//
// Static Protocol flags
//
#define PROTOCOLFLAG_NO_PICS_CHECK     0x00000001

// Creates the security manager object. The first argument is the Service provider
// to allow for delegation
STDAPI CoInternetCreateSecurityManager(IServiceProvider *pSP, IInternetSecurityManager **ppSM, DWORD dwReserved);

STDAPI CoInternetCreateZoneManager(IServiceProvider *pSP, IInternetZoneManager **ppZM, DWORD dwReserved);


// Security manager CLSID's
EXTERN_C const IID CLSID_InternetSecurityManager;  
EXTERN_C const IID CLSID_InternetZoneManager;  
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
EXTERN_C const IID CLSID_PersistentZoneIdentifier;  
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
// This service is used for delegation support on the Security Manager interface
#define SID_SInternetSecurityManager         IID_IInternetSecurityManager

#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#define SID_SInternetSecurityManagerEx         IID_IInternetSecurityManagerEx
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)

#if (_WIN32_IE >= _WIN32_IE_IE70)
#define SID_SInternetSecurityManagerEx2         IID_IInternetSecurityManagerEx2
#endif //(_WIN32_IE >= _WIN32_IE_IE70)

#define SID_SInternetHostSecurityManager     IID_IInternetHostSecurityManager

#ifndef _LPINTERNETSECURITYMGRSITE_DEFINED
#define _LPINTERNETSECURITYMGRSITE_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0036_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0036_v0_0_s_ifspec;

#ifndef __IInternetSecurityMgrSite_INTERFACE_DEFINED__
#define __IInternetSecurityMgrSite_INTERFACE_DEFINED__

/* interface IInternetSecurityMgrSite */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IInternetSecurityMgrSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9ed-baf9-11ce-8c82-00aa004ba90b")
    IInternetSecurityMgrSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetWindow( 
            /* [out] */ HWND *phwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableModeless( 
            /* [in] */ BOOL fEnable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetSecurityMgrSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetSecurityMgrSite * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetSecurityMgrSite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetSecurityMgrSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IInternetSecurityMgrSite * This,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *EnableModeless )( 
            IInternetSecurityMgrSite * This,
            /* [in] */ BOOL fEnable);
        
        END_INTERFACE
    } IInternetSecurityMgrSiteVtbl;

    interface IInternetSecurityMgrSite
    {
        CONST_VTBL struct IInternetSecurityMgrSiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetSecurityMgrSite_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetSecurityMgrSite_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetSecurityMgrSite_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetSecurityMgrSite_GetWindow(This,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,phwnd) ) 

#define IInternetSecurityMgrSite_EnableModeless(This,fEnable)	\
    ( (This)->lpVtbl -> EnableModeless(This,fEnable) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetSecurityMgrSite_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0037 */
/* [local] */ 

#endif
#ifndef _LPINTERNETSECURITYMANANGER_DEFINED
#define _LPINTERNETSECURITYMANANGER_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0037_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0037_v0_0_s_ifspec;

#ifndef __IInternetSecurityManager_INTERFACE_DEFINED__
#define __IInternetSecurityManager_INTERFACE_DEFINED__

/* interface IInternetSecurityManager */
/* [object][unique][helpstring][uuid] */ 

#define MUTZ_NOSAVEDFILECHECK        0x00000001 // don't check file: for saved file comment
#define MUTZ_ISFILE                  0x00000002 // Assume URL if File, url does not need file://
#define MUTZ_ACCEPT_WILDCARD_SCHEME  0x00000080 // Accept a wildcard scheme
#define MUTZ_ENFORCERESTRICTED       0x00000100 // enforce restricted zone independent of URL
#define MUTZ_RESERVED                0x00000200 // This is same as PUAF_NOSAVEDFILECHECK. However we already have MUTZ_NOSAVEDFILECHECK for this.
#define MUTZ_REQUIRESAVEDFILECHECK   0x00000400 // always check the file for MOTW (overriding FEATURE_UNC_SAVEDFILECHECK)
#define MUTZ_DONT_UNESCAPE           0x00000800 // Do not unescape the url
#define MUTZ_DONT_USE_CACHE          0x00001000 // Do not check the cache
#define MUTZ_FORCE_INTRANET_FLAGS    0x00002000 // Force the intranet flags to be active
#define MUTZ_IGNORE_ZONE_MAPPINGS    0x00004000 // Don't look up the Zone Mappings
// MapUrlToZone returns the zone index given a URL
#define MAX_SIZE_SECURITY_ID 512 // bytes
typedef /* [public] */ 
enum __MIDL_IInternetSecurityManager_0001
    {	PUAF_DEFAULT	= 0,
	PUAF_NOUI	= 0x1,
	PUAF_ISFILE	= 0x2,
	PUAF_WARN_IF_DENIED	= 0x4,
	PUAF_FORCEUI_FOREGROUND	= 0x8,
	PUAF_CHECK_TIFS	= 0x10,
	PUAF_DONTCHECKBOXINDIALOG	= 0x20,
	PUAF_TRUSTED	= 0x40,
	PUAF_ACCEPT_WILDCARD_SCHEME	= 0x80,
	PUAF_ENFORCERESTRICTED	= 0x100,
	PUAF_NOSAVEDFILECHECK	= 0x200,
	PUAF_REQUIRESAVEDFILECHECK	= 0x400,
	PUAF_DONT_USE_CACHE	= 0x1000,
	PUAF_RESERVED1	= 0x2000,
	PUAF_RESERVED2	= 0x4000,
	PUAF_LMZ_UNLOCKED	= 0x10000,
	PUAF_LMZ_LOCKED	= 0x20000,
	PUAF_DEFAULTZONEPOL	= 0x40000,
	PUAF_NPL_USE_LOCKED_IF_RESTRICTED	= 0x80000,
	PUAF_NOUIIFLOCKED	= 0x100000,
	PUAF_DRAGPROTOCOLCHECK	= 0x200000
    } 	PUAF;

typedef /* [public] */ 
enum __MIDL_IInternetSecurityManager_0002
    {	PUAFOUT_DEFAULT	= 0,
	PUAFOUT_ISLOCKZONEPOLICY	= 0x1
    } 	PUAFOUT;

// This is the wrapper function that most clients will use.
// It figures out the current Policy for the passed in Action,
// and puts up UI if the current Policy indicates that the user
// should be queried. It returns back the Policy which the caller
// will use to determine if the action should be allowed
// This is the wrapper function to conveniently read a custom policy.
typedef /* [public] */ 
enum __MIDL_IInternetSecurityManager_0003
    {	SZM_CREATE	= 0,
	SZM_DELETE	= 0x1
    } 	SZM_FLAGS;

// SetZoneMapping
//    lpszPattern: string denoting a URL pattern
//        Examples of valid patterns:   
//            *://*.msn.com             
//            http://*.sony.co.jp       
//            *://et.msn.com            
//            ftp://157.54.23.41/       
//            https://localsvr          
//            file:\localsvr\share     
//            *://157.54.100-200.*      
//        Examples of invalid patterns: 
//            http://*.lcs.mit.edu      
//            ftp://*                   
//    dwFlags: SZM_FLAGS values         

EXTERN_C const IID IID_IInternetSecurityManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9ee-baf9-11ce-8c82-00aa004ba90b")
    IInternetSecurityManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetSecuritySite( 
            /* [unique][in] */ __RPC__in_opt IInternetSecurityMgrSite *pSite) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSecuritySite( 
            /* [out] */ __RPC__deref_out_opt IInternetSecurityMgrSite **ppSite) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapUrlToZone( 
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [out] */ __RPC__out DWORD *pdwZone,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSecurityId( 
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [size_is][out] */ __RPC__out_ecount_full(*pcbSecurityId) BYTE *pbSecurityId,
            /* [out][in] */ __RPC__inout DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessUrlAction( 
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ __RPC__out_ecount_full(cbPolicy) BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [unique][in] */ __RPC__in_opt BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryCustomPolicy( 
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [in] */ __RPC__in REFGUID guidKey,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcbPolicy) BYTE **ppPolicy,
            /* [out] */ __RPC__out DWORD *pcbPolicy,
            /* [in] */ __RPC__in BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetZoneMapping( 
            /* [in] */ DWORD dwZone,
            /* [in] */ __RPC__in LPCWSTR lpszPattern,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetZoneMappings( 
            /* [in] */ DWORD dwZone,
            /* [out] */ __RPC__deref_out_opt IEnumString **ppenumString,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetSecurityManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IInternetSecurityManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IInternetSecurityManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IInternetSecurityManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSecuritySite )( 
            __RPC__in IInternetSecurityManager * This,
            /* [unique][in] */ __RPC__in_opt IInternetSecurityMgrSite *pSite);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecuritySite )( 
            __RPC__in IInternetSecurityManager * This,
            /* [out] */ __RPC__deref_out_opt IInternetSecurityMgrSite **ppSite);
        
        HRESULT ( STDMETHODCALLTYPE *MapUrlToZone )( 
            __RPC__in IInternetSecurityManager * This,
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [out] */ __RPC__out DWORD *pdwZone,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecurityId )( 
            __RPC__in IInternetSecurityManager * This,
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [size_is][out] */ __RPC__out_ecount_full(*pcbSecurityId) BYTE *pbSecurityId,
            /* [out][in] */ __RPC__inout DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessUrlAction )( 
            __RPC__in IInternetSecurityManager * This,
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ __RPC__out_ecount_full(cbPolicy) BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [unique][in] */ __RPC__in_opt BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *QueryCustomPolicy )( 
            __RPC__in IInternetSecurityManager * This,
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [in] */ __RPC__in REFGUID guidKey,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcbPolicy) BYTE **ppPolicy,
            /* [out] */ __RPC__out DWORD *pcbPolicy,
            /* [in] */ __RPC__in BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneMapping )( 
            __RPC__in IInternetSecurityManager * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ __RPC__in LPCWSTR lpszPattern,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneMappings )( 
            __RPC__in IInternetSecurityManager * This,
            /* [in] */ DWORD dwZone,
            /* [out] */ __RPC__deref_out_opt IEnumString **ppenumString,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IInternetSecurityManagerVtbl;

    interface IInternetSecurityManager
    {
        CONST_VTBL struct IInternetSecurityManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetSecurityManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetSecurityManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetSecurityManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetSecurityManager_SetSecuritySite(This,pSite)	\
    ( (This)->lpVtbl -> SetSecuritySite(This,pSite) ) 

#define IInternetSecurityManager_GetSecuritySite(This,ppSite)	\
    ( (This)->lpVtbl -> GetSecuritySite(This,ppSite) ) 

#define IInternetSecurityManager_MapUrlToZone(This,pwszUrl,pdwZone,dwFlags)	\
    ( (This)->lpVtbl -> MapUrlToZone(This,pwszUrl,pdwZone,dwFlags) ) 

#define IInternetSecurityManager_GetSecurityId(This,pwszUrl,pbSecurityId,pcbSecurityId,dwReserved)	\
    ( (This)->lpVtbl -> GetSecurityId(This,pwszUrl,pbSecurityId,pcbSecurityId,dwReserved) ) 

#define IInternetSecurityManager_ProcessUrlAction(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved)	\
    ( (This)->lpVtbl -> ProcessUrlAction(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved) ) 

#define IInternetSecurityManager_QueryCustomPolicy(This,pwszUrl,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved)	\
    ( (This)->lpVtbl -> QueryCustomPolicy(This,pwszUrl,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved) ) 

#define IInternetSecurityManager_SetZoneMapping(This,dwZone,lpszPattern,dwFlags)	\
    ( (This)->lpVtbl -> SetZoneMapping(This,dwZone,lpszPattern,dwFlags) ) 

#define IInternetSecurityManager_GetZoneMappings(This,dwZone,ppenumString,dwFlags)	\
    ( (This)->lpVtbl -> GetZoneMappings(This,dwZone,ppenumString,dwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetSecurityManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0038 */
/* [local] */ 

#endif
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#ifndef _LPINTERNETSECURITYMANANGEREX_DEFINED
#define _LPINTERNETSECURITYMANANGEREX_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0038_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0038_v0_0_s_ifspec;

#ifndef __IInternetSecurityManagerEx_INTERFACE_DEFINED__
#define __IInternetSecurityManagerEx_INTERFACE_DEFINED__

/* interface IInternetSecurityManagerEx */
/* [object][unique][helpstring][uuid] */ 

// This is the wrapper function that most clients will use.
// It figures out the current Policy for the passed in Action,
// and puts up UI if the current Policy indicates that the user
// should be queried. It returns back the Policy which the caller
// will use to determine if the action should be allowed

EXTERN_C const IID IID_IInternetSecurityManagerEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F164EDF1-CC7C-4f0d-9A94-34222625C393")
    IInternetSecurityManagerEx : public IInternetSecurityManager
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ProcessUrlActionEx( 
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ __RPC__out_ecount_full(cbPolicy) BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ __RPC__in BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved,
            /* [out] */ __RPC__out DWORD *pdwOutFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetSecurityManagerExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IInternetSecurityManagerEx * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IInternetSecurityManagerEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IInternetSecurityManagerEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSecuritySite )( 
            __RPC__in IInternetSecurityManagerEx * This,
            /* [unique][in] */ __RPC__in_opt IInternetSecurityMgrSite *pSite);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecuritySite )( 
            __RPC__in IInternetSecurityManagerEx * This,
            /* [out] */ __RPC__deref_out_opt IInternetSecurityMgrSite **ppSite);
        
        HRESULT ( STDMETHODCALLTYPE *MapUrlToZone )( 
            __RPC__in IInternetSecurityManagerEx * This,
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [out] */ __RPC__out DWORD *pdwZone,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecurityId )( 
            __RPC__in IInternetSecurityManagerEx * This,
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [size_is][out] */ __RPC__out_ecount_full(*pcbSecurityId) BYTE *pbSecurityId,
            /* [out][in] */ __RPC__inout DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessUrlAction )( 
            __RPC__in IInternetSecurityManagerEx * This,
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ __RPC__out_ecount_full(cbPolicy) BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [unique][in] */ __RPC__in_opt BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *QueryCustomPolicy )( 
            __RPC__in IInternetSecurityManagerEx * This,
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [in] */ __RPC__in REFGUID guidKey,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcbPolicy) BYTE **ppPolicy,
            /* [out] */ __RPC__out DWORD *pcbPolicy,
            /* [in] */ __RPC__in BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneMapping )( 
            __RPC__in IInternetSecurityManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ __RPC__in LPCWSTR lpszPattern,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneMappings )( 
            __RPC__in IInternetSecurityManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [out] */ __RPC__deref_out_opt IEnumString **ppenumString,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessUrlActionEx )( 
            __RPC__in IInternetSecurityManagerEx * This,
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ __RPC__out_ecount_full(cbPolicy) BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ __RPC__in BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved,
            /* [out] */ __RPC__out DWORD *pdwOutFlags);
        
        END_INTERFACE
    } IInternetSecurityManagerExVtbl;

    interface IInternetSecurityManagerEx
    {
        CONST_VTBL struct IInternetSecurityManagerExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetSecurityManagerEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetSecurityManagerEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetSecurityManagerEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetSecurityManagerEx_SetSecuritySite(This,pSite)	\
    ( (This)->lpVtbl -> SetSecuritySite(This,pSite) ) 

#define IInternetSecurityManagerEx_GetSecuritySite(This,ppSite)	\
    ( (This)->lpVtbl -> GetSecuritySite(This,ppSite) ) 

#define IInternetSecurityManagerEx_MapUrlToZone(This,pwszUrl,pdwZone,dwFlags)	\
    ( (This)->lpVtbl -> MapUrlToZone(This,pwszUrl,pdwZone,dwFlags) ) 

#define IInternetSecurityManagerEx_GetSecurityId(This,pwszUrl,pbSecurityId,pcbSecurityId,dwReserved)	\
    ( (This)->lpVtbl -> GetSecurityId(This,pwszUrl,pbSecurityId,pcbSecurityId,dwReserved) ) 

#define IInternetSecurityManagerEx_ProcessUrlAction(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved)	\
    ( (This)->lpVtbl -> ProcessUrlAction(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved) ) 

#define IInternetSecurityManagerEx_QueryCustomPolicy(This,pwszUrl,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved)	\
    ( (This)->lpVtbl -> QueryCustomPolicy(This,pwszUrl,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved) ) 

#define IInternetSecurityManagerEx_SetZoneMapping(This,dwZone,lpszPattern,dwFlags)	\
    ( (This)->lpVtbl -> SetZoneMapping(This,dwZone,lpszPattern,dwFlags) ) 

#define IInternetSecurityManagerEx_GetZoneMappings(This,dwZone,ppenumString,dwFlags)	\
    ( (This)->lpVtbl -> GetZoneMappings(This,dwZone,ppenumString,dwFlags) ) 


#define IInternetSecurityManagerEx_ProcessUrlActionEx(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved,pdwOutFlags)	\
    ( (This)->lpVtbl -> ProcessUrlActionEx(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved,pdwOutFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetSecurityManagerEx_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0039 */
/* [local] */ 

#endif
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
#if (_WIN32_IE >= _WIN32_IE_IE70)
#ifndef _LPINTERNETSECURITYMANANGEREx2_DEFINED
#define _LPINTERNETSECURITYMANANGEREx2_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0039_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0039_v0_0_s_ifspec;

#ifndef __IInternetSecurityManagerEx2_INTERFACE_DEFINED__
#define __IInternetSecurityManagerEx2_INTERFACE_DEFINED__

/* interface IInternetSecurityManagerEx2 */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IInternetSecurityManagerEx2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F1E50292-A795-4117-8E09-2B560A72AC60")
    IInternetSecurityManagerEx2 : public IInternetSecurityManagerEx
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MapUrlToZoneEx2( 
            /* [in] */ __RPC__in_opt IUri *pUri,
            /* [out] */ __RPC__out DWORD *pdwZone,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppwszMappedUrl,
            /* [out] */ __RPC__out DWORD *pdwOutFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessUrlActionEx2( 
            /* [in] */ __RPC__in_opt IUri *pUri,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ __RPC__out_ecount_full(cbPolicy) BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [unique][in] */ __RPC__in_opt BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD_PTR dwReserved,
            /* [out] */ __RPC__out DWORD *pdwOutFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSecurityIdEx2( 
            /* [in] */ __RPC__in_opt IUri *pUri,
            /* [size_is][out] */ __RPC__out_ecount_full(*pcbSecurityId) BYTE *pbSecurityId,
            /* [out][in] */ __RPC__inout DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryCustomPolicyEx2( 
            /* [in] */ __RPC__in_opt IUri *pUri,
            /* [in] */ __RPC__in REFGUID guidKey,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcbPolicy) BYTE **ppPolicy,
            /* [out] */ __RPC__out DWORD *pcbPolicy,
            /* [in] */ __RPC__in BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetSecurityManagerEx2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IInternetSecurityManagerEx2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IInternetSecurityManagerEx2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IInternetSecurityManagerEx2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSecuritySite )( 
            __RPC__in IInternetSecurityManagerEx2 * This,
            /* [unique][in] */ __RPC__in_opt IInternetSecurityMgrSite *pSite);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecuritySite )( 
            __RPC__in IInternetSecurityManagerEx2 * This,
            /* [out] */ __RPC__deref_out_opt IInternetSecurityMgrSite **ppSite);
        
        HRESULT ( STDMETHODCALLTYPE *MapUrlToZone )( 
            __RPC__in IInternetSecurityManagerEx2 * This,
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [out] */ __RPC__out DWORD *pdwZone,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecurityId )( 
            __RPC__in IInternetSecurityManagerEx2 * This,
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [size_is][out] */ __RPC__out_ecount_full(*pcbSecurityId) BYTE *pbSecurityId,
            /* [out][in] */ __RPC__inout DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessUrlAction )( 
            __RPC__in IInternetSecurityManagerEx2 * This,
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ __RPC__out_ecount_full(cbPolicy) BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [unique][in] */ __RPC__in_opt BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *QueryCustomPolicy )( 
            __RPC__in IInternetSecurityManagerEx2 * This,
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [in] */ __RPC__in REFGUID guidKey,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcbPolicy) BYTE **ppPolicy,
            /* [out] */ __RPC__out DWORD *pcbPolicy,
            /* [in] */ __RPC__in BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneMapping )( 
            __RPC__in IInternetSecurityManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ __RPC__in LPCWSTR lpszPattern,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneMappings )( 
            __RPC__in IInternetSecurityManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [out] */ __RPC__deref_out_opt IEnumString **ppenumString,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessUrlActionEx )( 
            __RPC__in IInternetSecurityManagerEx2 * This,
            /* [in] */ __RPC__in LPCWSTR pwszUrl,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ __RPC__out_ecount_full(cbPolicy) BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ __RPC__in BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved,
            /* [out] */ __RPC__out DWORD *pdwOutFlags);
        
        HRESULT ( STDMETHODCALLTYPE *MapUrlToZoneEx2 )( 
            __RPC__in IInternetSecurityManagerEx2 * This,
            /* [in] */ __RPC__in_opt IUri *pUri,
            /* [out] */ __RPC__out DWORD *pdwZone,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppwszMappedUrl,
            /* [out] */ __RPC__out DWORD *pdwOutFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessUrlActionEx2 )( 
            __RPC__in IInternetSecurityManagerEx2 * This,
            /* [in] */ __RPC__in_opt IUri *pUri,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ __RPC__out_ecount_full(cbPolicy) BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [unique][in] */ __RPC__in_opt BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD_PTR dwReserved,
            /* [out] */ __RPC__out DWORD *pdwOutFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecurityIdEx2 )( 
            __RPC__in IInternetSecurityManagerEx2 * This,
            /* [in] */ __RPC__in_opt IUri *pUri,
            /* [size_is][out] */ __RPC__out_ecount_full(*pcbSecurityId) BYTE *pbSecurityId,
            /* [out][in] */ __RPC__inout DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *QueryCustomPolicyEx2 )( 
            __RPC__in IInternetSecurityManagerEx2 * This,
            /* [in] */ __RPC__in_opt IUri *pUri,
            /* [in] */ __RPC__in REFGUID guidKey,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcbPolicy) BYTE **ppPolicy,
            /* [out] */ __RPC__out DWORD *pcbPolicy,
            /* [in] */ __RPC__in BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD_PTR dwReserved);
        
        END_INTERFACE
    } IInternetSecurityManagerEx2Vtbl;

    interface IInternetSecurityManagerEx2
    {
        CONST_VTBL struct IInternetSecurityManagerEx2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetSecurityManagerEx2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetSecurityManagerEx2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetSecurityManagerEx2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetSecurityManagerEx2_SetSecuritySite(This,pSite)	\
    ( (This)->lpVtbl -> SetSecuritySite(This,pSite) ) 

#define IInternetSecurityManagerEx2_GetSecuritySite(This,ppSite)	\
    ( (This)->lpVtbl -> GetSecuritySite(This,ppSite) ) 

#define IInternetSecurityManagerEx2_MapUrlToZone(This,pwszUrl,pdwZone,dwFlags)	\
    ( (This)->lpVtbl -> MapUrlToZone(This,pwszUrl,pdwZone,dwFlags) ) 

#define IInternetSecurityManagerEx2_GetSecurityId(This,pwszUrl,pbSecurityId,pcbSecurityId,dwReserved)	\
    ( (This)->lpVtbl -> GetSecurityId(This,pwszUrl,pbSecurityId,pcbSecurityId,dwReserved) ) 

#define IInternetSecurityManagerEx2_ProcessUrlAction(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved)	\
    ( (This)->lpVtbl -> ProcessUrlAction(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved) ) 

#define IInternetSecurityManagerEx2_QueryCustomPolicy(This,pwszUrl,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved)	\
    ( (This)->lpVtbl -> QueryCustomPolicy(This,pwszUrl,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved) ) 

#define IInternetSecurityManagerEx2_SetZoneMapping(This,dwZone,lpszPattern,dwFlags)	\
    ( (This)->lpVtbl -> SetZoneMapping(This,dwZone,lpszPattern,dwFlags) ) 

#define IInternetSecurityManagerEx2_GetZoneMappings(This,dwZone,ppenumString,dwFlags)	\
    ( (This)->lpVtbl -> GetZoneMappings(This,dwZone,ppenumString,dwFlags) ) 


#define IInternetSecurityManagerEx2_ProcessUrlActionEx(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved,pdwOutFlags)	\
    ( (This)->lpVtbl -> ProcessUrlActionEx(This,pwszUrl,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved,pdwOutFlags) ) 


#define IInternetSecurityManagerEx2_MapUrlToZoneEx2(This,pUri,pdwZone,dwFlags,ppwszMappedUrl,pdwOutFlags)	\
    ( (This)->lpVtbl -> MapUrlToZoneEx2(This,pUri,pdwZone,dwFlags,ppwszMappedUrl,pdwOutFlags) ) 

#define IInternetSecurityManagerEx2_ProcessUrlActionEx2(This,pUri,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved,pdwOutFlags)	\
    ( (This)->lpVtbl -> ProcessUrlActionEx2(This,pUri,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved,pdwOutFlags) ) 

#define IInternetSecurityManagerEx2_GetSecurityIdEx2(This,pUri,pbSecurityId,pcbSecurityId,dwReserved)	\
    ( (This)->lpVtbl -> GetSecurityIdEx2(This,pUri,pbSecurityId,pcbSecurityId,dwReserved) ) 

#define IInternetSecurityManagerEx2_QueryCustomPolicyEx2(This,pUri,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved)	\
    ( (This)->lpVtbl -> QueryCustomPolicyEx2(This,pUri,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetSecurityManagerEx2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0040 */
/* [local] */ 

#endif
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0040_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0040_v0_0_s_ifspec;

#ifndef __IZoneIdentifier_INTERFACE_DEFINED__
#define __IZoneIdentifier_INTERFACE_DEFINED__

/* interface IZoneIdentifier */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IZoneIdentifier;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cd45f185-1b21-48e2-967b-ead743a8914e")
    IZoneIdentifier : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetId( 
            /* [out] */ __RPC__out DWORD *pdwZone) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetId( 
            /* [in] */ DWORD dwZone) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IZoneIdentifierVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IZoneIdentifier * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IZoneIdentifier * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IZoneIdentifier * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetId )( 
            __RPC__in IZoneIdentifier * This,
            /* [out] */ __RPC__out DWORD *pdwZone);
        
        HRESULT ( STDMETHODCALLTYPE *SetId )( 
            __RPC__in IZoneIdentifier * This,
            /* [in] */ DWORD dwZone);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            __RPC__in IZoneIdentifier * This);
        
        END_INTERFACE
    } IZoneIdentifierVtbl;

    interface IZoneIdentifier
    {
        CONST_VTBL struct IZoneIdentifierVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IZoneIdentifier_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IZoneIdentifier_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IZoneIdentifier_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IZoneIdentifier_GetId(This,pdwZone)	\
    ( (This)->lpVtbl -> GetId(This,pdwZone) ) 

#define IZoneIdentifier_SetId(This,dwZone)	\
    ( (This)->lpVtbl -> SetId(This,dwZone) ) 

#define IZoneIdentifier_Remove(This)	\
    ( (This)->lpVtbl -> Remove(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IZoneIdentifier_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0041 */
/* [local] */ 

#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
#ifndef _LPINTERNETHOSTSECURITYMANANGER_DEFINED
#define _LPINTERNETHOSTSECURITYMANANGER_DEFINED
//This is the interface MSHTML exposes to its clients
//The clients need not pass in a URL to these functions
//since MSHTML maintains the notion of the current URL


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0041_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0041_v0_0_s_ifspec;

#ifndef __IInternetHostSecurityManager_INTERFACE_DEFINED__
#define __IInternetHostSecurityManager_INTERFACE_DEFINED__

/* interface IInternetHostSecurityManager */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IInternetHostSecurityManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3af280b6-cb3f-11d0-891e-00c04fb6bfc4")
    IInternetHostSecurityManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSecurityId( 
            /* [size_is][out] */ BYTE *pbSecurityId,
            /* [out][in] */ DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessUrlAction( 
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryCustomPolicy( 
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetHostSecurityManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetHostSecurityManager * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetHostSecurityManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetHostSecurityManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecurityId )( 
            IInternetHostSecurityManager * This,
            /* [size_is][out] */ BYTE *pbSecurityId,
            /* [out][in] */ DWORD *pcbSecurityId,
            /* [in] */ DWORD_PTR dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessUrlAction )( 
            IInternetHostSecurityManager * This,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *QueryCustomPolicy )( 
            IInternetHostSecurityManager * This,
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ BYTE *pContext,
            /* [in] */ DWORD cbContext,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } IInternetHostSecurityManagerVtbl;

    interface IInternetHostSecurityManager
    {
        CONST_VTBL struct IInternetHostSecurityManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetHostSecurityManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetHostSecurityManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetHostSecurityManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetHostSecurityManager_GetSecurityId(This,pbSecurityId,pcbSecurityId,dwReserved)	\
    ( (This)->lpVtbl -> GetSecurityId(This,pbSecurityId,pcbSecurityId,dwReserved) ) 

#define IInternetHostSecurityManager_ProcessUrlAction(This,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved)	\
    ( (This)->lpVtbl -> ProcessUrlAction(This,dwAction,pPolicy,cbPolicy,pContext,cbContext,dwFlags,dwReserved) ) 

#define IInternetHostSecurityManager_QueryCustomPolicy(This,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved)	\
    ( (This)->lpVtbl -> QueryCustomPolicy(This,guidKey,ppPolicy,pcbPolicy,pContext,cbContext,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetHostSecurityManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0042 */
/* [local] */ 

#endif

// The zone manager maintains policies for a set of standard actions. 
// These actions are identified by integral values (called action indexes)
// specified below.

// Minimum legal value for an action    
#define URLACTION_MIN                                          0x00001000

#define URLACTION_DOWNLOAD_MIN                                 0x00001000
#define URLACTION_DOWNLOAD_SIGNED_ACTIVEX                      0x00001001
#define URLACTION_DOWNLOAD_UNSIGNED_ACTIVEX                    0x00001004
#define URLACTION_DOWNLOAD_CURR_MAX                            0x00001004
#define URLACTION_DOWNLOAD_MAX                                 0x000011FF

#define URLACTION_ACTIVEX_MIN                                  0x00001200
#define URLACTION_ACTIVEX_RUN                                  0x00001200
#define URLPOLICY_ACTIVEX_CHECK_LIST                           0x00010000
#define URLACTION_ACTIVEX_OVERRIDE_OBJECT_SAFETY               0x00001201 // aggregate next four
#define URLACTION_ACTIVEX_OVERRIDE_DATA_SAFETY                 0x00001202 //
#define URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY               0x00001203 //
#define URLACTION_SCRIPT_OVERRIDE_SAFETY                       0x00001401 //
#define URLACTION_ACTIVEX_CONFIRM_NOOBJECTSAFETY               0x00001204 //
#define URLACTION_ACTIVEX_TREATASUNTRUSTED                     0x00001205
#define URLACTION_ACTIVEX_NO_WEBOC_SCRIPT                      0x00001206
#define URLACTION_ACTIVEX_OVERRIDE_REPURPOSEDETECTION          0x00001207
#define URLACTION_ACTIVEX_OVERRIDE_OPTIN                       0x00001208
#define URLACTION_ACTIVEX_SCRIPTLET_RUN                        0x00001209
#define URLACTION_ACTIVEX_DYNSRC_VIDEO_AND_ANIMATION           0x0000120A //
#define URLACTION_ACTIVEX_OVERRIDE_DOMAINLIST                  0x0000120B
#define URLACTION_ACTIVEX_CURR_MAX                             0x0000120B
#define URLACTION_ACTIVEX_MAX                                  0x000013ff

#define URLACTION_SCRIPT_MIN                                   0x00001400
#define URLACTION_SCRIPT_RUN                                   0x00001400
#define URLACTION_SCRIPT_JAVA_USE                              0x00001402
#define URLACTION_SCRIPT_SAFE_ACTIVEX                          0x00001405
#define URLACTION_CROSS_DOMAIN_DATA                            0x00001406
#define URLACTION_SCRIPT_PASTE                                 0x00001407
#define URLACTION_ALLOW_XDOMAIN_SUBFRAME_RESIZE                0x00001408
#define URLACTION_SCRIPT_XSSFILTER                             0x00001409
#define URLACTION_SCRIPT_CURR_MAX                              0x00001409
#define URLACTION_SCRIPT_MAX                                   0x000015ff

#define URLACTION_HTML_MIN                                     0x00001600
#define URLACTION_HTML_SUBMIT_FORMS                            0x00001601 // aggregate next two
#define URLACTION_HTML_SUBMIT_FORMS_FROM                       0x00001602 //
#define URLACTION_HTML_SUBMIT_FORMS_TO                         0x00001603 //
#define URLACTION_HTML_FONT_DOWNLOAD                           0x00001604
#define URLACTION_HTML_JAVA_RUN                                0x00001605 // derive from Java custom policy
#define URLACTION_HTML_USERDATA_SAVE                           0x00001606
#define URLACTION_HTML_SUBFRAME_NAVIGATE                       0x00001607
#define URLACTION_HTML_META_REFRESH                            0x00001608
#define URLACTION_HTML_MIXED_CONTENT                           0x00001609
#define URLACTION_HTML_INCLUDE_FILE_PATH                       0x0000160A
#define URLACTION_HTML_MAX                                     0x000017ff

#define URLACTION_SHELL_MIN                                    0x00001800
#define URLACTION_SHELL_INSTALL_DTITEMS                        0x00001800
#define URLACTION_SHELL_MOVE_OR_COPY                           0x00001802
#define URLACTION_SHELL_FILE_DOWNLOAD                          0x00001803
#define URLACTION_SHELL_VERB                                   0x00001804
#define URLACTION_SHELL_WEBVIEW_VERB                           0x00001805
#define URLACTION_SHELL_SHELLEXECUTE                           0x00001806
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#define URLACTION_SHELL_EXECUTE_HIGHRISK                       0x00001806
#define URLACTION_SHELL_EXECUTE_MODRISK                        0x00001807
#define URLACTION_SHELL_EXECUTE_LOWRISK                        0x00001808
#define URLACTION_SHELL_POPUPMGR                               0x00001809
#define URLACTION_SHELL_RTF_OBJECTS_LOAD                       0x0000180A
#define URLACTION_SHELL_ENHANCED_DRAGDROP_SECURITY             0x0000180B
#define URLACTION_SHELL_EXTENSIONSECURITY                      0x0000180C
#define URLACTION_SHELL_SECURE_DRAGSOURCE                      0x0000180D
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
#if (_WIN32_IE >= _WIN32_IE_WIN7)
#define URLACTION_SHELL_REMOTEQUERY                            0x0000180E
#define URLACTION_SHELL_PREVIEW                                0x0000180F
#endif //(_WIN32_IE >= _WIN32_IE_WIN7)
#define URLACTION_SHELL_CURR_MAX                               0x0000180F
#define URLACTION_SHELL_MAX                                    0x000019ff

#define URLACTION_NETWORK_MIN                                  0x00001A00

#define URLACTION_CREDENTIALS_USE                              0x00001A00
#define URLPOLICY_CREDENTIALS_SILENT_LOGON_OK        0x00000000
#define URLPOLICY_CREDENTIALS_MUST_PROMPT_USER       0x00010000
#define URLPOLICY_CREDENTIALS_CONDITIONAL_PROMPT     0x00020000
#define URLPOLICY_CREDENTIALS_ANONYMOUS_ONLY         0x00030000

#define URLACTION_AUTHENTICATE_CLIENT                          0x00001A01
#define URLPOLICY_AUTHENTICATE_CLEARTEXT_OK          0x00000000
#define URLPOLICY_AUTHENTICATE_CHALLENGE_RESPONSE    0x00010000
#define URLPOLICY_AUTHENTICATE_MUTUAL_ONLY           0x00030000


#define URLACTION_COOKIES                                      0x00001A02
#define URLACTION_COOKIES_SESSION                              0x00001A03

#define URLACTION_CLIENT_CERT_PROMPT                           0x00001A04

#define URLACTION_COOKIES_THIRD_PARTY                          0x00001A05
#define URLACTION_COOKIES_SESSION_THIRD_PARTY                  0x00001A06

#define URLACTION_COOKIES_ENABLED                              0x00001A10

#define URLACTION_NETWORK_CURR_MAX                             0x00001A10
#define URLACTION_NETWORK_MAX                                  0x00001Bff


#define URLACTION_JAVA_MIN                                     0x00001C00
#define URLACTION_JAVA_PERMISSIONS                             0x00001C00
#define URLPOLICY_JAVA_PROHIBIT                      0x00000000
#define URLPOLICY_JAVA_HIGH                          0x00010000
#define URLPOLICY_JAVA_MEDIUM                        0x00020000
#define URLPOLICY_JAVA_LOW                           0x00030000
#define URLPOLICY_JAVA_CUSTOM                        0x00800000
#define URLACTION_JAVA_CURR_MAX                                0x00001C00
#define URLACTION_JAVA_MAX                                     0x00001Cff


// The following Infodelivery actions should have no default policies
// in the registry.  They assume that no default policy means fall
// back to the global restriction.  If an admin sets a policy per
// zone, then it overrides the global restriction.

#define URLACTION_INFODELIVERY_MIN                           0x00001D00
#define URLACTION_INFODELIVERY_NO_ADDING_CHANNELS            0x00001D00
#define URLACTION_INFODELIVERY_NO_EDITING_CHANNELS           0x00001D01
#define URLACTION_INFODELIVERY_NO_REMOVING_CHANNELS          0x00001D02
#define URLACTION_INFODELIVERY_NO_ADDING_SUBSCRIPTIONS       0x00001D03
#define URLACTION_INFODELIVERY_NO_EDITING_SUBSCRIPTIONS      0x00001D04
#define URLACTION_INFODELIVERY_NO_REMOVING_SUBSCRIPTIONS     0x00001D05
#define URLACTION_INFODELIVERY_NO_CHANNEL_LOGGING            0x00001D06
#define URLACTION_INFODELIVERY_CURR_MAX                      0x00001D06
#define URLACTION_INFODELIVERY_MAX                           0x00001Dff
#define URLACTION_CHANNEL_SOFTDIST_MIN                       0x00001E00
#define URLACTION_CHANNEL_SOFTDIST_PERMISSIONS               0x00001E05
#define URLPOLICY_CHANNEL_SOFTDIST_PROHIBIT          0x00010000
#define URLPOLICY_CHANNEL_SOFTDIST_PRECACHE          0x00020000
#define URLPOLICY_CHANNEL_SOFTDIST_AUTOINSTALL       0x00030000
#define URLACTION_CHANNEL_SOFTDIST_MAX                       0x00001Eff
#if (_WIN32_IE >= _WIN32_IE_IE80)
#define URLACTION_DOTNET_USERCONTROLS                        0x00002005
#endif //(_WIN32_IE >= _WIN32_IE_IE80)
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#define URLACTION_BEHAVIOR_MIN                               0x00002000
#define URLACTION_BEHAVIOR_RUN                               0x00002000
#define URLPOLICY_BEHAVIOR_CHECK_LIST                        0x00010000

// The following actions correspond to the Feature options above.
// However, they are NOT in the same order.
#define URLACTION_FEATURE_MIN                                0x00002100
#define URLACTION_FEATURE_MIME_SNIFFING                      0x00002100
#define URLACTION_FEATURE_ZONE_ELEVATION                     0x00002101
#define URLACTION_FEATURE_WINDOW_RESTRICTIONS                0x00002102
#define URLACTION_FEATURE_SCRIPT_STATUS_BAR                  0x00002103
#define URLACTION_FEATURE_FORCE_ADDR_AND_STATUS              0x00002104
#define URLACTION_FEATURE_BLOCK_INPUT_PROMPTS                0x00002105
#define URLACTION_FEATURE_DATA_BINDING                       0x00002106

#define URLACTION_AUTOMATIC_DOWNLOAD_UI_MIN                  0x00002200
#define URLACTION_AUTOMATIC_DOWNLOAD_UI                      0x00002200
#define URLACTION_AUTOMATIC_ACTIVEX_UI                       0x00002201

#define URLACTION_ALLOW_RESTRICTEDPROTOCOLS                0x00002300

#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
#if (_WIN32_IE >= _WIN32_IE_IE70)
// Whether to do the Anti-Phishing check.
#define URLACTION_ALLOW_APEVALUATION                       0x00002301

// The following ExpressAPP and XPS actions are trumped by registry in
// case of Internet Explorer upgrade from IE 6.0 which honors registry.
#define URLACTION_WINDOWS_BROWSER_APPLICATIONS             0x00002400
#define URLACTION_XPS_DOCUMENTS                            0x00002401
#define URLACTION_LOOSE_XAML                               0x00002402
#define URLACTION_LOWRIGHTS                                0x00002500
// The following action belong to WinFX Bootstrapper
#define URLACTION_WINFX_SETUP                              0x00002600

#define URLACTION_INPRIVATE_BLOCKING                       0x00002700
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
// For each action specified above the system maintains
// a set of policies for the action. 
// The only policies supported currently are permissions (i.e. is something allowed)
// and logging status. 
// IMPORTANT: If you are defining your own policies don't overload the meaning of the
// loword of the policy. You can use the hiword to store any policy bits which are only
// meaningful to your action.
// For an example of how to do this look at the URLPOLICY_JAVA above

// Permissions 
#define URLPOLICY_ALLOW                0x00
#define URLPOLICY_QUERY                0x01
#define URLPOLICY_DISALLOW             0x03

// Notifications are not done when user already queried.
#define URLPOLICY_NOTIFY_ON_ALLOW      0x10
#define URLPOLICY_NOTIFY_ON_DISALLOW   0x20

// Logging is done regardless of whether user was queried.
#define URLPOLICY_LOG_ON_ALLOW         0x40
#define URLPOLICY_LOG_ON_DISALLOW      0x80

#define URLPOLICY_MASK_PERMISSIONS     0x0f
#define GetUrlPolicyPermissions(dw)        (dw & URLPOLICY_MASK_PERMISSIONS)
#define SetUrlPolicyPermissions(dw,dw2)    ((dw) = ((dw) & ~(URLPOLICY_MASK_PERMISSIONS)) | (dw2))


#define URLPOLICY_DONTCHECKDLGBOX     0x100
// The ordinal #'s that define the predefined zones internet explorer knows about. 
// When we support user-defined zones their zone numbers should be between 
// URLZONE_USER_MIN and URLZONE_USER_MAX
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
// Custom policy to query whether the local machine zone
// has been unlocked for current document.
EXTERN_C const GUID GUID_CUSTOM_LOCALMACHINEZONEUNLOCKED; 
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
#ifndef _LPINTERNETZONEMANAGER_DEFINED
#define _LPINTERNETZONEMANAGER_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0042_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0042_v0_0_s_ifspec;

#ifndef __IInternetZoneManager_INTERFACE_DEFINED__
#define __IInternetZoneManager_INTERFACE_DEFINED__

/* interface IInternetZoneManager */
/* [unique][helpstring][uuid][object][local] */ 

typedef /* [unique] */ IInternetZoneManager *LPURLZONEMANAGER;

typedef 
enum tagURLZONE
    {	URLZONE_INVALID	= -1,
	URLZONE_PREDEFINED_MIN	= 0,
	URLZONE_LOCAL_MACHINE	= 0,
	URLZONE_INTRANET	= ( URLZONE_LOCAL_MACHINE + 1 ) ,
	URLZONE_TRUSTED	= ( URLZONE_INTRANET + 1 ) ,
	URLZONE_INTERNET	= ( URLZONE_TRUSTED + 1 ) ,
	URLZONE_UNTRUSTED	= ( URLZONE_INTERNET + 1 ) ,
	URLZONE_PREDEFINED_MAX	= 999,
	URLZONE_USER_MIN	= 1000,
	URLZONE_USER_MAX	= 10000
    } 	URLZONE;

// Enhanced Security Configuration zone mapping flag for IInternetSecurityManager::SetZoneMapping
#define URLZONE_ESC_FLAG     0x100
typedef 
enum tagURLTEMPLATE
    {	URLTEMPLATE_CUSTOM	= 0,
	URLTEMPLATE_PREDEFINED_MIN	= 0x10000,
	URLTEMPLATE_LOW	= 0x10000,
	URLTEMPLATE_MEDLOW	= 0x10500,
	URLTEMPLATE_MEDIUM	= 0x11000,
	URLTEMPLATE_MEDHIGH	= 0x11500,
	URLTEMPLATE_HIGH	= 0x12000,
	URLTEMPLATE_PREDEFINED_MAX	= 0x20000
    } 	URLTEMPLATE;


enum __MIDL_IInternetZoneManager_0001
    {	MAX_ZONE_PATH	= 260,
	MAX_ZONE_DESCRIPTION	= 200
    } ;
typedef /* [public] */ 
enum __MIDL_IInternetZoneManager_0002
    {	ZAFLAGS_CUSTOM_EDIT	= 0x1,
	ZAFLAGS_ADD_SITES	= 0x2,
	ZAFLAGS_REQUIRE_VERIFICATION	= 0x4,
	ZAFLAGS_INCLUDE_PROXY_OVERRIDE	= 0x8,
	ZAFLAGS_INCLUDE_INTRANET_SITES	= 0x10,
	ZAFLAGS_NO_UI	= 0x20,
	ZAFLAGS_SUPPORTS_VERIFICATION	= 0x40,
	ZAFLAGS_UNC_AS_INTRANET	= 0x80,
	ZAFLAGS_DETECT_INTRANET	= 0x100,
	ZAFLAGS_USE_LOCKED_ZONES	= 0x10000,
	ZAFLAGS_VERIFY_TEMPLATE_SETTINGS	= 0x20000,
	ZAFLAGS_NO_CACHE	= 0x40000
    } 	ZAFLAGS;

typedef struct _ZONEATTRIBUTES
    {
    ULONG cbSize;
    WCHAR szDisplayName[ 260 ];
    WCHAR szDescription[ 200 ];
    WCHAR szIconPath[ 260 ];
    DWORD dwTemplateMinLevel;
    DWORD dwTemplateRecommended;
    DWORD dwTemplateCurrentLevel;
    DWORD dwFlags;
    } 	ZONEATTRIBUTES;

typedef struct _ZONEATTRIBUTES *LPZONEATTRIBUTES;

// Gets the zone attributes (information in registry other than actual security
// policies associated with the zone).  Zone attributes are fixed as:
// Sets the zone attributes (information in registry other than actual security
// policies associated with the zone).  Zone attributes as above.
// Returns S_OK or ??? if failed to write the zone attributes.
/* Registry Flags

    When reading, default behavior is:
        If HKLM allows override and HKCU value exists
            Then use HKCU value
            Else use HKLM value
    When writing, default behavior is same as HKCU
        If HKLM allows override
           Then Write to HKCU
           Else Fail
*/
typedef 
enum _URLZONEREG
    {	URLZONEREG_DEFAULT	= 0,
	URLZONEREG_HKLM	= ( URLZONEREG_DEFAULT + 1 ) ,
	URLZONEREG_HKCU	= ( URLZONEREG_HKLM + 1 ) 
    } 	URLZONEREG;

// Gets a named custom policy associated with a zone;
// e.g. the Java VM settings can be defined with a unique key such as 'Java'.
// Custom policy support is intended to allow extensibility from the predefined
// set of policies that IE4 has built in.
// 
// pwszKey is the string name designating the custom policy.  Components are
//   responsible for having unique names.
// ppPolicy is the callee allocated buffer for the policy byte blob; caller is
//   responsible for freeing this buffer eventually.
// pcbPolicy is the size of the byte blob returned.
// dwRegFlags determines how registry is accessed (see above).
// Returns S_OK if key is found and buffer allocated; ??? if key is not found (no buffer alloced).
// Sets a named custom policy associated with a zone;
// e.g. the Java VM settings can be defined with a unique key such as 'Java'.
// Custom policy support is intended to allow extensibility from the predefined
// set of policies that IE4 has built in.  
// 
// pwszKey is the string name designating the custom policy.  Components are
//   responsible for having unique names.
// ppPolicy is the caller allocated buffer for the policy byte blob.
// pcbPolicy is the size of the byte blob to be set.
// dwRegFlags determines if HTCU or HKLM is set.
// Returns S_OK or ??? if failed to write the zone custom policy.
// Gets action policy associated with a zone, the builtin, fixed-length policies info.

// dwAction is the action code for the action as defined above.
// pPolicy is the caller allocated buffer for the policy data.
// cbPolicy is the size of the caller allocated buffer.
// dwRegFlags determines how registry is accessed (see above).
// Returns S_OK if action is valid; ??? if action is not valid.

EXTERN_C const IID IID_IInternetZoneManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79eac9ef-baf9-11ce-8c82-00aa004ba90b")
    IInternetZoneManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetZoneAttributes( 
            /* [in] */ DWORD dwZone,
            /* [unique][out][in] */ ZONEATTRIBUTES *pZoneAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetZoneAttributes( 
            /* [in] */ DWORD dwZone,
            /* [in] */ ZONEATTRIBUTES *pZoneAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetZoneCustomPolicy( 
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ URLZONEREG urlZoneReg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetZoneCustomPolicy( 
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetZoneActionPolicy( 
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetZoneActionPolicy( 
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PromptAction( 
            /* [in] */ DWORD dwAction,
            /* [in] */ HWND hwndParent,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwPromptFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LogAction( 
            /* [in] */ DWORD dwAction,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwLogFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateZoneEnumerator( 
            /* [out] */ DWORD *pdwEnum,
            /* [out] */ DWORD *pdwCount,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetZoneAt( 
            /* [in] */ DWORD dwEnum,
            /* [in] */ DWORD dwIndex,
            /* [out] */ DWORD *pdwZone) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyZoneEnumerator( 
            /* [in] */ DWORD dwEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyTemplatePoliciesToZone( 
            /* [in] */ DWORD dwTemplate,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetZoneManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetZoneManager * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetZoneManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetZoneManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneAttributes )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwZone,
            /* [unique][out][in] */ ZONEATTRIBUTES *pZoneAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneAttributes )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ ZONEATTRIBUTES *pZoneAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneCustomPolicy )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneCustomPolicy )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneActionPolicy )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneActionPolicy )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *PromptAction )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwAction,
            /* [in] */ HWND hwndParent,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwPromptFlags);
        
        HRESULT ( STDMETHODCALLTYPE *LogAction )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwAction,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwLogFlags);
        
        HRESULT ( STDMETHODCALLTYPE *CreateZoneEnumerator )( 
            IInternetZoneManager * This,
            /* [out] */ DWORD *pdwEnum,
            /* [out] */ DWORD *pdwCount,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneAt )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwEnum,
            /* [in] */ DWORD dwIndex,
            /* [out] */ DWORD *pdwZone);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyZoneEnumerator )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CopyTemplatePoliciesToZone )( 
            IInternetZoneManager * This,
            /* [in] */ DWORD dwTemplate,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } IInternetZoneManagerVtbl;

    interface IInternetZoneManager
    {
        CONST_VTBL struct IInternetZoneManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetZoneManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetZoneManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetZoneManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetZoneManager_GetZoneAttributes(This,dwZone,pZoneAttributes)	\
    ( (This)->lpVtbl -> GetZoneAttributes(This,dwZone,pZoneAttributes) ) 

#define IInternetZoneManager_SetZoneAttributes(This,dwZone,pZoneAttributes)	\
    ( (This)->lpVtbl -> SetZoneAttributes(This,dwZone,pZoneAttributes) ) 

#define IInternetZoneManager_GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg) ) 

#define IInternetZoneManager_SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManager_GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManager_SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManager_PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags)	\
    ( (This)->lpVtbl -> PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags) ) 

#define IInternetZoneManager_LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags)	\
    ( (This)->lpVtbl -> LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags) ) 

#define IInternetZoneManager_CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags)	\
    ( (This)->lpVtbl -> CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags) ) 

#define IInternetZoneManager_GetZoneAt(This,dwEnum,dwIndex,pdwZone)	\
    ( (This)->lpVtbl -> GetZoneAt(This,dwEnum,dwIndex,pdwZone) ) 

#define IInternetZoneManager_DestroyZoneEnumerator(This,dwEnum)	\
    ( (This)->lpVtbl -> DestroyZoneEnumerator(This,dwEnum) ) 

#define IInternetZoneManager_CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved)	\
    ( (This)->lpVtbl -> CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetZoneManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0043 */
/* [local] */ 

#endif
#if (_WIN32_IE >= _WIN32_IE_IE60SP2)
#ifndef _LPINTERNETZONEMANAGEREX_DEFINED
#define _LPINTERNETZONEMANAGEREX_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0043_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0043_v0_0_s_ifspec;

#ifndef __IInternetZoneManagerEx_INTERFACE_DEFINED__
#define __IInternetZoneManagerEx_INTERFACE_DEFINED__

/* interface IInternetZoneManagerEx */
/* [unique][helpstring][uuid][object][local] */ 

// Gets action policy associated with a zone, the builtin, fixed-length policies info.

// dwAction is the action code for the action as defined above.
// pPolicy is the caller allocated buffer for the policy data.
// cbPolicy is the size of the caller allocated buffer.
// dwRegFlags determines how registry is accessed (see above).
// dwFlags determine which registry policies are accessed (see above).
// Returns S_OK if action is valid; ??? if action is not valid.

EXTERN_C const IID IID_IInternetZoneManagerEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A4C23339-8E06-431e-9BF4-7E711C085648")
    IInternetZoneManagerEx : public IInternetZoneManager
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetZoneActionPolicyEx( 
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetZoneActionPolicyEx( 
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetZoneManagerExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetZoneManagerEx * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetZoneManagerEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetZoneManagerEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneAttributes )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [unique][out][in] */ ZONEATTRIBUTES *pZoneAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneAttributes )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ ZONEATTRIBUTES *pZoneAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneCustomPolicy )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneCustomPolicy )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneActionPolicy )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneActionPolicy )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *PromptAction )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwAction,
            /* [in] */ HWND hwndParent,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwPromptFlags);
        
        HRESULT ( STDMETHODCALLTYPE *LogAction )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwAction,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwLogFlags);
        
        HRESULT ( STDMETHODCALLTYPE *CreateZoneEnumerator )( 
            IInternetZoneManagerEx * This,
            /* [out] */ DWORD *pdwEnum,
            /* [out] */ DWORD *pdwCount,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneAt )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwEnum,
            /* [in] */ DWORD dwIndex,
            /* [out] */ DWORD *pdwZone);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyZoneEnumerator )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CopyTemplatePoliciesToZone )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwTemplate,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneActionPolicyEx )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneActionPolicyEx )( 
            IInternetZoneManagerEx * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IInternetZoneManagerExVtbl;

    interface IInternetZoneManagerEx
    {
        CONST_VTBL struct IInternetZoneManagerExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetZoneManagerEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetZoneManagerEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetZoneManagerEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetZoneManagerEx_GetZoneAttributes(This,dwZone,pZoneAttributes)	\
    ( (This)->lpVtbl -> GetZoneAttributes(This,dwZone,pZoneAttributes) ) 

#define IInternetZoneManagerEx_SetZoneAttributes(This,dwZone,pZoneAttributes)	\
    ( (This)->lpVtbl -> SetZoneAttributes(This,dwZone,pZoneAttributes) ) 

#define IInternetZoneManagerEx_GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx_SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx_GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx_SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx_PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags)	\
    ( (This)->lpVtbl -> PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags) ) 

#define IInternetZoneManagerEx_LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags)	\
    ( (This)->lpVtbl -> LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags) ) 

#define IInternetZoneManagerEx_CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags)	\
    ( (This)->lpVtbl -> CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags) ) 

#define IInternetZoneManagerEx_GetZoneAt(This,dwEnum,dwIndex,pdwZone)	\
    ( (This)->lpVtbl -> GetZoneAt(This,dwEnum,dwIndex,pdwZone) ) 

#define IInternetZoneManagerEx_DestroyZoneEnumerator(This,dwEnum)	\
    ( (This)->lpVtbl -> DestroyZoneEnumerator(This,dwEnum) ) 

#define IInternetZoneManagerEx_CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved)	\
    ( (This)->lpVtbl -> CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved) ) 


#define IInternetZoneManagerEx_GetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags)	\
    ( (This)->lpVtbl -> GetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags) ) 

#define IInternetZoneManagerEx_SetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags)	\
    ( (This)->lpVtbl -> SetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetZoneManagerEx_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0044 */
/* [local] */ 

#endif
#endif //(_WIN32_IE >= _WIN32_IE_IE60SP2)
#if (_WIN32_IE >= _WIN32_IE_IE70)
#ifndef _LPINTERNETZONEMANAGEREX2_DEFINED
#define _LPINTERNETZONEMANAGEREX2_DEFINED
#define SECURITY_IE_STATE_GREEN 0x00000000
#define SECURITY_IE_STATE_RED   0x00000001


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0044_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0044_v0_0_s_ifspec;

#ifndef __IInternetZoneManagerEx2_INTERFACE_DEFINED__
#define __IInternetZoneManagerEx2_INTERFACE_DEFINED__

/* interface IInternetZoneManagerEx2 */
/* [unique][helpstring][uuid][object][local] */ 

// Gets the zone attributes (information in registry other than actual security
// policies associated with the zone).  Zone attributes are fixed as:
// Can also verify template settings by matching current settings with security template

EXTERN_C const IID IID_IInternetZoneManagerEx2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EDC17559-DD5D-4846-8EEF-8BECBA5A4ABF")
    IInternetZoneManagerEx2 : public IInternetZoneManagerEx
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetZoneAttributesEx( 
            /* [in] */ DWORD dwZone,
            /* [unique][out][in] */ ZONEATTRIBUTES *pZoneAttributes,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetZoneSecurityState( 
            /* [in] */ DWORD dwZoneIndex,
            /* [in] */ BOOL fRespectPolicy,
            /* [out][in] */ LPDWORD pdwState,
            /* [out][in] */ BOOL *pfPolicyEncountered) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIESecurityState( 
            /* [in] */ BOOL fRespectPolicy,
            /* [out][in] */ LPDWORD pdwState,
            /* [out][in] */ BOOL *pfPolicyEncountered,
            /* [in] */ BOOL fNoCache) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FixUnsecureSettings( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternetZoneManagerEx2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInternetZoneManagerEx2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInternetZoneManagerEx2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneAttributes )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [unique][out][in] */ ZONEATTRIBUTES *pZoneAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneAttributes )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ ZONEATTRIBUTES *pZoneAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneCustomPolicy )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][size_is][out] */ BYTE **ppPolicy,
            /* [out] */ DWORD *pcbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneCustomPolicy )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ REFGUID guidKey,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneActionPolicy )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneActionPolicy )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg);
        
        HRESULT ( STDMETHODCALLTYPE *PromptAction )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwAction,
            /* [in] */ HWND hwndParent,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwPromptFlags);
        
        HRESULT ( STDMETHODCALLTYPE *LogAction )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwAction,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ LPCWSTR pwszText,
            /* [in] */ DWORD dwLogFlags);
        
        HRESULT ( STDMETHODCALLTYPE *CreateZoneEnumerator )( 
            IInternetZoneManagerEx2 * This,
            /* [out] */ DWORD *pdwEnum,
            /* [out] */ DWORD *pdwCount,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneAt )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwEnum,
            /* [in] */ DWORD dwIndex,
            /* [out] */ DWORD *pdwZone);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyZoneEnumerator )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CopyTemplatePoliciesToZone )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwTemplate,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneActionPolicyEx )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][out] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetZoneActionPolicyEx )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [in] */ DWORD dwAction,
            /* [size_is][in] */ BYTE *pPolicy,
            /* [in] */ DWORD cbPolicy,
            /* [in] */ URLZONEREG urlZoneReg,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneAttributesEx )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZone,
            /* [unique][out][in] */ ZONEATTRIBUTES *pZoneAttributes,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetZoneSecurityState )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ DWORD dwZoneIndex,
            /* [in] */ BOOL fRespectPolicy,
            /* [out][in] */ LPDWORD pdwState,
            /* [out][in] */ BOOL *pfPolicyEncountered);
        
        HRESULT ( STDMETHODCALLTYPE *GetIESecurityState )( 
            IInternetZoneManagerEx2 * This,
            /* [in] */ BOOL fRespectPolicy,
            /* [out][in] */ LPDWORD pdwState,
            /* [out][in] */ BOOL *pfPolicyEncountered,
            /* [in] */ BOOL fNoCache);
        
        HRESULT ( STDMETHODCALLTYPE *FixUnsecureSettings )( 
            IInternetZoneManagerEx2 * This);
        
        END_INTERFACE
    } IInternetZoneManagerEx2Vtbl;

    interface IInternetZoneManagerEx2
    {
        CONST_VTBL struct IInternetZoneManagerEx2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternetZoneManagerEx2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInternetZoneManagerEx2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInternetZoneManagerEx2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInternetZoneManagerEx2_GetZoneAttributes(This,dwZone,pZoneAttributes)	\
    ( (This)->lpVtbl -> GetZoneAttributes(This,dwZone,pZoneAttributes) ) 

#define IInternetZoneManagerEx2_SetZoneAttributes(This,dwZone,pZoneAttributes)	\
    ( (This)->lpVtbl -> SetZoneAttributes(This,dwZone,pZoneAttributes) ) 

#define IInternetZoneManagerEx2_GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> GetZoneCustomPolicy(This,dwZone,guidKey,ppPolicy,pcbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx2_SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> SetZoneCustomPolicy(This,dwZone,guidKey,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx2_GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> GetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx2_SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg)	\
    ( (This)->lpVtbl -> SetZoneActionPolicy(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg) ) 

#define IInternetZoneManagerEx2_PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags)	\
    ( (This)->lpVtbl -> PromptAction(This,dwAction,hwndParent,pwszUrl,pwszText,dwPromptFlags) ) 

#define IInternetZoneManagerEx2_LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags)	\
    ( (This)->lpVtbl -> LogAction(This,dwAction,pwszUrl,pwszText,dwLogFlags) ) 

#define IInternetZoneManagerEx2_CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags)	\
    ( (This)->lpVtbl -> CreateZoneEnumerator(This,pdwEnum,pdwCount,dwFlags) ) 

#define IInternetZoneManagerEx2_GetZoneAt(This,dwEnum,dwIndex,pdwZone)	\
    ( (This)->lpVtbl -> GetZoneAt(This,dwEnum,dwIndex,pdwZone) ) 

#define IInternetZoneManagerEx2_DestroyZoneEnumerator(This,dwEnum)	\
    ( (This)->lpVtbl -> DestroyZoneEnumerator(This,dwEnum) ) 

#define IInternetZoneManagerEx2_CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved)	\
    ( (This)->lpVtbl -> CopyTemplatePoliciesToZone(This,dwTemplate,dwZone,dwReserved) ) 


#define IInternetZoneManagerEx2_GetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags)	\
    ( (This)->lpVtbl -> GetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags) ) 

#define IInternetZoneManagerEx2_SetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags)	\
    ( (This)->lpVtbl -> SetZoneActionPolicyEx(This,dwZone,dwAction,pPolicy,cbPolicy,urlZoneReg,dwFlags) ) 


#define IInternetZoneManagerEx2_GetZoneAttributesEx(This,dwZone,pZoneAttributes,dwFlags)	\
    ( (This)->lpVtbl -> GetZoneAttributesEx(This,dwZone,pZoneAttributes,dwFlags) ) 

#define IInternetZoneManagerEx2_GetZoneSecurityState(This,dwZoneIndex,fRespectPolicy,pdwState,pfPolicyEncountered)	\
    ( (This)->lpVtbl -> GetZoneSecurityState(This,dwZoneIndex,fRespectPolicy,pdwState,pfPolicyEncountered) ) 

#define IInternetZoneManagerEx2_GetIESecurityState(This,fRespectPolicy,pdwState,pfPolicyEncountered,fNoCache)	\
    ( (This)->lpVtbl -> GetIESecurityState(This,fRespectPolicy,pdwState,pfPolicyEncountered,fNoCache) ) 

#define IInternetZoneManagerEx2_FixUnsecureSettings(This)	\
    ( (This)->lpVtbl -> FixUnsecureSettings(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInternetZoneManagerEx2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0045 */
/* [local] */ 

#endif
#endif //(_WIN32_IE >= _WIN32_IE_IE70)
EXTERN_C const IID CLSID_SoftDistExt;  
#ifndef _LPSOFTDISTEXT_DEFINED
#define _LPSOFTDISTEXT_DEFINED

#define SOFTDIST_FLAG_USAGE_EMAIL        0x00000001
#define SOFTDIST_FLAG_USAGE_PRECACHE     0x00000002
#define SOFTDIST_FLAG_USAGE_AUTOINSTALL  0x00000004
#define SOFTDIST_FLAG_DELETE_SUBSCRIPTION 0x00000008


#define SOFTDIST_ADSTATE_NONE                0x00000000
#define SOFTDIST_ADSTATE_AVAILABLE       0x00000001
#define SOFTDIST_ADSTATE_DOWNLOADED      0x00000002
#define SOFTDIST_ADSTATE_INSTALLED           0x00000003

typedef struct _tagCODEBASEHOLD
    {
    ULONG cbSize;
    LPWSTR szDistUnit;
    LPWSTR szCodeBase;
    DWORD dwVersionMS;
    DWORD dwVersionLS;
    DWORD dwStyle;
    } 	CODEBASEHOLD;

typedef struct _tagCODEBASEHOLD *LPCODEBASEHOLD;

typedef struct _tagSOFTDISTINFO
    {
    ULONG cbSize;
    DWORD dwFlags;
    DWORD dwAdState;
    LPWSTR szTitle;
    LPWSTR szAbstract;
    LPWSTR szHREF;
    DWORD dwInstalledVersionMS;
    DWORD dwInstalledVersionLS;
    DWORD dwUpdateVersionMS;
    DWORD dwUpdateVersionLS;
    DWORD dwAdvertisedVersionMS;
    DWORD dwAdvertisedVersionLS;
    DWORD dwReserved;
    } 	SOFTDISTINFO;

typedef struct _tagSOFTDISTINFO *LPSOFTDISTINFO;



extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0045_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0045_v0_0_s_ifspec;

#ifndef __ISoftDistExt_INTERFACE_DEFINED__
#define __ISoftDistExt_INTERFACE_DEFINED__

/* interface ISoftDistExt */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_ISoftDistExt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B15B8DC1-C7E1-11d0-8680-00AA00BDCB71")
    ISoftDistExt : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ProcessSoftDist( 
            /* [in] */ LPCWSTR szCDFURL,
            /* [in] */ IXMLElement *pSoftDistElement,
            /* [out][in] */ LPSOFTDISTINFO lpsdi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFirstCodeBase( 
            /* [annotation][in] */ 
            __RPC__in  LPWSTR *szCodeBase,
            /* [in] */ LPDWORD dwMaxSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextCodeBase( 
            /* [annotation][in] */ 
            __RPC__in  LPWSTR *szCodeBase,
            /* [in] */ LPDWORD dwMaxSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AsyncInstallDistributionUnit( 
            /* [in] */ IBindCtx *pbc,
            /* [in] */ LPVOID pvReserved,
            /* [in] */ DWORD flags,
            /* [in] */ LPCODEBASEHOLD lpcbh) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftDistExtVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftDistExt * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftDistExt * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftDistExt * This);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessSoftDist )( 
            ISoftDistExt * This,
            /* [in] */ LPCWSTR szCDFURL,
            /* [in] */ IXMLElement *pSoftDistElement,
            /* [out][in] */ LPSOFTDISTINFO lpsdi);
        
        HRESULT ( STDMETHODCALLTYPE *GetFirstCodeBase )( 
            ISoftDistExt * This,
            /* [annotation][in] */ 
            __RPC__in  LPWSTR *szCodeBase,
            /* [in] */ LPDWORD dwMaxSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextCodeBase )( 
            ISoftDistExt * This,
            /* [annotation][in] */ 
            __RPC__in  LPWSTR *szCodeBase,
            /* [in] */ LPDWORD dwMaxSize);
        
        HRESULT ( STDMETHODCALLTYPE *AsyncInstallDistributionUnit )( 
            ISoftDistExt * This,
            /* [in] */ IBindCtx *pbc,
            /* [in] */ LPVOID pvReserved,
            /* [in] */ DWORD flags,
            /* [in] */ LPCODEBASEHOLD lpcbh);
        
        END_INTERFACE
    } ISoftDistExtVtbl;

    interface ISoftDistExt
    {
        CONST_VTBL struct ISoftDistExtVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftDistExt_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftDistExt_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftDistExt_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftDistExt_ProcessSoftDist(This,szCDFURL,pSoftDistElement,lpsdi)	\
    ( (This)->lpVtbl -> ProcessSoftDist(This,szCDFURL,pSoftDistElement,lpsdi) ) 

#define ISoftDistExt_GetFirstCodeBase(This,szCodeBase,dwMaxSize)	\
    ( (This)->lpVtbl -> GetFirstCodeBase(This,szCodeBase,dwMaxSize) ) 

#define ISoftDistExt_GetNextCodeBase(This,szCodeBase,dwMaxSize)	\
    ( (This)->lpVtbl -> GetNextCodeBase(This,szCodeBase,dwMaxSize) ) 

#define ISoftDistExt_AsyncInstallDistributionUnit(This,pbc,pvReserved,flags,lpcbh)	\
    ( (This)->lpVtbl -> AsyncInstallDistributionUnit(This,pbc,pvReserved,flags,lpcbh) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftDistExt_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0046 */
/* [local] */ 

STDAPI GetSoftwareUpdateInfo( LPCWSTR szDistUnit, LPSOFTDISTINFO psdi );
STDAPI SetSoftwareUpdateAdvertisementState( LPCWSTR szDistUnit, DWORD dwAdState, DWORD dwAdvertisedVersionMS, DWORD dwAdvertisedVersionLS );
#endif
#ifndef _LPCATALOGFILEINFO_DEFINED
#define _LPCATALOGFILEINFO_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0046_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0046_v0_0_s_ifspec;

#ifndef __ICatalogFileInfo_INTERFACE_DEFINED__
#define __ICatalogFileInfo_INTERFACE_DEFINED__

/* interface ICatalogFileInfo */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ ICatalogFileInfo *LPCATALOGFILEINFO;


EXTERN_C const IID IID_ICatalogFileInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("711C7600-6B48-11d1-B403-00AA00B92AF1")
    ICatalogFileInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCatalogFile( 
            /* [annotation][out] */ 
            __RPC__out  LPSTR *ppszCatalogFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetJavaTrust( 
            /* [out] */ void **ppJavaTrust) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatalogFileInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICatalogFileInfo * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICatalogFileInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICatalogFileInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCatalogFile )( 
            ICatalogFileInfo * This,
            /* [annotation][out] */ 
            __RPC__out  LPSTR *ppszCatalogFile);
        
        HRESULT ( STDMETHODCALLTYPE *GetJavaTrust )( 
            ICatalogFileInfo * This,
            /* [out] */ void **ppJavaTrust);
        
        END_INTERFACE
    } ICatalogFileInfoVtbl;

    interface ICatalogFileInfo
    {
        CONST_VTBL struct ICatalogFileInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatalogFileInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICatalogFileInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICatalogFileInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICatalogFileInfo_GetCatalogFile(This,ppszCatalogFile)	\
    ( (This)->lpVtbl -> GetCatalogFile(This,ppszCatalogFile) ) 

#define ICatalogFileInfo_GetJavaTrust(This,ppJavaTrust)	\
    ( (This)->lpVtbl -> GetJavaTrust(This,ppJavaTrust) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICatalogFileInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0047 */
/* [local] */ 

#endif
#ifndef _LPDATAFILTER_DEFINED
#define _LPDATAFILTER_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0047_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0047_v0_0_s_ifspec;

#ifndef __IDataFilter_INTERFACE_DEFINED__
#define __IDataFilter_INTERFACE_DEFINED__

/* interface IDataFilter */
/* [unique][uuid][object] */ 

typedef /* [unique] */  __RPC_unique_pointer IDataFilter *LPDATAFILTER;


EXTERN_C const IID IID_IDataFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("69d14c80-c18e-11d0-a9ce-006097942311")
    IDataFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DoEncode( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LONG lInBufferSize,
            /* [size_is][in] */ __RPC__in_ecount_full(lInBufferSize) BYTE *pbInBuffer,
            /* [in] */ LONG lOutBufferSize,
            /* [size_is][out] */ __RPC__out_ecount_full(lOutBufferSize) BYTE *pbOutBuffer,
            /* [in] */ LONG lInBytesAvailable,
            /* [out] */ __RPC__out LONG *plInBytesRead,
            /* [out] */ __RPC__out LONG *plOutBytesWritten,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoDecode( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LONG lInBufferSize,
            /* [size_is][in] */ __RPC__in_ecount_full(lInBufferSize) BYTE *pbInBuffer,
            /* [in] */ LONG lOutBufferSize,
            /* [size_is][out] */ __RPC__out_ecount_full(lOutBufferSize) BYTE *pbOutBuffer,
            /* [in] */ LONG lInBytesAvailable,
            /* [out] */ __RPC__out LONG *plInBytesRead,
            /* [out] */ __RPC__out LONG *plOutBytesWritten,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEncodingLevel( 
            /* [in] */ DWORD dwEncLevel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDataFilter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDataFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDataFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *DoEncode )( 
            __RPC__in IDataFilter * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LONG lInBufferSize,
            /* [size_is][in] */ __RPC__in_ecount_full(lInBufferSize) BYTE *pbInBuffer,
            /* [in] */ LONG lOutBufferSize,
            /* [size_is][out] */ __RPC__out_ecount_full(lOutBufferSize) BYTE *pbOutBuffer,
            /* [in] */ LONG lInBytesAvailable,
            /* [out] */ __RPC__out LONG *plInBytesRead,
            /* [out] */ __RPC__out LONG *plOutBytesWritten,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *DoDecode )( 
            __RPC__in IDataFilter * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LONG lInBufferSize,
            /* [size_is][in] */ __RPC__in_ecount_full(lInBufferSize) BYTE *pbInBuffer,
            /* [in] */ LONG lOutBufferSize,
            /* [size_is][out] */ __RPC__out_ecount_full(lOutBufferSize) BYTE *pbOutBuffer,
            /* [in] */ LONG lInBytesAvailable,
            /* [out] */ __RPC__out LONG *plInBytesRead,
            /* [out] */ __RPC__out LONG *plOutBytesWritten,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *SetEncodingLevel )( 
            __RPC__in IDataFilter * This,
            /* [in] */ DWORD dwEncLevel);
        
        END_INTERFACE
    } IDataFilterVtbl;

    interface IDataFilter
    {
        CONST_VTBL struct IDataFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataFilter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDataFilter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDataFilter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDataFilter_DoEncode(This,dwFlags,lInBufferSize,pbInBuffer,lOutBufferSize,pbOutBuffer,lInBytesAvailable,plInBytesRead,plOutBytesWritten,dwReserved)	\
    ( (This)->lpVtbl -> DoEncode(This,dwFlags,lInBufferSize,pbInBuffer,lOutBufferSize,pbOutBuffer,lInBytesAvailable,plInBytesRead,plOutBytesWritten,dwReserved) ) 

#define IDataFilter_DoDecode(This,dwFlags,lInBufferSize,pbInBuffer,lOutBufferSize,pbOutBuffer,lInBytesAvailable,plInBytesRead,plOutBytesWritten,dwReserved)	\
    ( (This)->lpVtbl -> DoDecode(This,dwFlags,lInBufferSize,pbInBuffer,lOutBufferSize,pbOutBuffer,lInBytesAvailable,plInBytesRead,plOutBytesWritten,dwReserved) ) 

#define IDataFilter_SetEncodingLevel(This,dwEncLevel)	\
    ( (This)->lpVtbl -> SetEncodingLevel(This,dwEncLevel) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDataFilter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0048 */
/* [local] */ 

#endif
#ifndef _LPENCODINGFILTERFACTORY_DEFINED
#define _LPENCODINGFILTERFACTORY_DEFINED
typedef struct _tagPROTOCOLFILTERDATA
    {
    DWORD cbSize;
    IInternetProtocolSink *pProtocolSink;
    IInternetProtocol *pProtocol;
    IUnknown *pUnk;
    DWORD dwFilterFlags;
    } 	PROTOCOLFILTERDATA;



extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0048_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0048_v0_0_s_ifspec;

#ifndef __IEncodingFilterFactory_INTERFACE_DEFINED__
#define __IEncodingFilterFactory_INTERFACE_DEFINED__

/* interface IEncodingFilterFactory */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IEncodingFilterFactory *LPENCODINGFILTERFACTORY;

typedef struct _tagDATAINFO
    {
    ULONG ulTotalSize;
    ULONG ulavrPacketSize;
    ULONG ulConnectSpeed;
    ULONG ulProcessorSpeed;
    } 	DATAINFO;


EXTERN_C const IID IID_IEncodingFilterFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70bdde00-c18e-11d0-a9ce-006097942311")
    IEncodingFilterFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindBestFilter( 
            /* [in] */ LPCWSTR pwzCodeIn,
            /* [in] */ LPCWSTR pwzCodeOut,
            /* [in] */ DATAINFO info,
            /* [out] */ IDataFilter **ppDF) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultFilter( 
            /* [in] */ LPCWSTR pwzCodeIn,
            /* [in] */ LPCWSTR pwzCodeOut,
            /* [out] */ IDataFilter **ppDF) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEncodingFilterFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEncodingFilterFactory * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEncodingFilterFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEncodingFilterFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *FindBestFilter )( 
            IEncodingFilterFactory * This,
            /* [in] */ LPCWSTR pwzCodeIn,
            /* [in] */ LPCWSTR pwzCodeOut,
            /* [in] */ DATAINFO info,
            /* [out] */ IDataFilter **ppDF);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultFilter )( 
            IEncodingFilterFactory * This,
            /* [in] */ LPCWSTR pwzCodeIn,
            /* [in] */ LPCWSTR pwzCodeOut,
            /* [out] */ IDataFilter **ppDF);
        
        END_INTERFACE
    } IEncodingFilterFactoryVtbl;

    interface IEncodingFilterFactory
    {
        CONST_VTBL struct IEncodingFilterFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEncodingFilterFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEncodingFilterFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEncodingFilterFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEncodingFilterFactory_FindBestFilter(This,pwzCodeIn,pwzCodeOut,info,ppDF)	\
    ( (This)->lpVtbl -> FindBestFilter(This,pwzCodeIn,pwzCodeOut,info,ppDF) ) 

#define IEncodingFilterFactory_GetDefaultFilter(This,pwzCodeIn,pwzCodeOut,ppDF)	\
    ( (This)->lpVtbl -> GetDefaultFilter(This,pwzCodeIn,pwzCodeOut,ppDF) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEncodingFilterFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0049 */
/* [local] */ 

#endif
#ifndef _HITLOGGING_DEFINED
#define _HITLOGGING_DEFINED
// Logging-specific apis
BOOL WINAPI IsLoggingEnabledA(__in LPCSTR  pszUrl);                    
BOOL WINAPI IsLoggingEnabledW(__in LPCWSTR  pwszUrl);                  
#ifdef UNICODE                                                       
#define IsLoggingEnabled         IsLoggingEnabledW                   
#else                                                                
#define IsLoggingEnabled         IsLoggingEnabledA                   
#endif // !UNICODE                                                   
typedef struct _tagHIT_LOGGING_INFO
    {
    DWORD dwStructSize;
    LPSTR lpszLoggedUrlName;
    SYSTEMTIME StartTime;
    SYSTEMTIME EndTime;
    LPSTR lpszExtendedInfo;
    } 	HIT_LOGGING_INFO;

typedef struct _tagHIT_LOGGING_INFO *LPHIT_LOGGING_INFO;

BOOL WINAPI WriteHitLogging(__in LPHIT_LOGGING_INFO lpLogginginfo);    
#define CONFIRMSAFETYACTION_LOADOBJECT  0x00000001
struct CONFIRMSAFETY
    {
    CLSID clsid;
    IUnknown *pUnk;
    DWORD dwFlags;
    } ;
EXTERN_C const GUID GUID_CUSTOM_CONFIRMOBJECTSAFETY; 
#endif
#ifndef _LPIWRAPPEDPROTOCOL_DEFINED
#define _LPIWRAPPEDPROTOCOL_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0049_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0049_v0_0_s_ifspec;

#ifndef __IWrappedProtocol_INTERFACE_DEFINED__
#define __IWrappedProtocol_INTERFACE_DEFINED__

/* interface IWrappedProtocol */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IWrappedProtocol *LPIWRAPPEDPROTOCOL;


EXTERN_C const IID IID_IWrappedProtocol;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("53c84785-8425-4dc5-971b-e58d9c19f9b6")
    IWrappedProtocol : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetWrapperCode( 
            /* [out] */ LONG *pnCode,
            /* [in] */ DWORD_PTR dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWrappedProtocolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWrappedProtocol * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWrappedProtocol * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWrappedProtocol * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWrapperCode )( 
            IWrappedProtocol * This,
            /* [out] */ LONG *pnCode,
            /* [in] */ DWORD_PTR dwReserved);
        
        END_INTERFACE
    } IWrappedProtocolVtbl;

    interface IWrappedProtocol
    {
        CONST_VTBL struct IWrappedProtocolVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWrappedProtocol_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWrappedProtocol_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWrappedProtocol_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWrappedProtocol_GetWrapperCode(This,pnCode,dwReserved)	\
    ( (This)->lpVtbl -> GetWrapperCode(This,pnCode,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWrappedProtocol_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_urlmon_0000_0050 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0050_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0050_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HWND * ); 
void                      __RPC_USER  HWND_UserFree(     __RPC__in unsigned long *, __RPC__in HWND * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HWND * ); 
void                      __RPC_USER  HWND_UserFree64(     __RPC__in unsigned long *, __RPC__in HWND * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IBinding_GetBindResult_Proxy( 
    IBinding * This,
    /* [out] */ CLSID *pclsidProtocol,
    /* [out] */ DWORD *pdwResult,
    /* [annotation][out] */ 
    __RPC__out  LPOLESTR *pszResult,
    /* [out][in] */ DWORD *pdwReserved);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBinding_GetBindResult_Stub( 
    __RPC__in IBinding * This,
    /* [out] */ __RPC__out CLSID *pclsidProtocol,
    /* [out] */ __RPC__out DWORD *pdwResult,
    /* [out] */ __RPC__deref_out_opt LPOLESTR *pszResult,
    /* [in] */ DWORD dwReserved);

/* [local] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_GetBindInfo_Proxy( 
    IBindStatusCallback * This,
    /* [out] */ DWORD *grfBINDF,
    /* [unique][out][in] */ BINDINFO *pbindinfo);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_GetBindInfo_Stub( 
    __RPC__in IBindStatusCallback * This,
    /* [out] */ __RPC__out DWORD *grfBINDF,
    /* [unique][out][in] */ __RPC__inout_opt RemBINDINFO *pbindinfo,
    /* [unique][out][in] */ __RPC__inout_opt RemSTGMEDIUM *pstgmed);

/* [local] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_OnDataAvailable_Proxy( 
    IBindStatusCallback * This,
    /* [in] */ DWORD grfBSCF,
    /* [in] */ DWORD dwSize,
    /* [in] */ FORMATETC *pformatetc,
    /* [in] */ STGMEDIUM *pstgmed);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindStatusCallback_OnDataAvailable_Stub( 
    __RPC__in IBindStatusCallback * This,
    /* [in] */ DWORD grfBSCF,
    /* [in] */ DWORD dwSize,
    /* [in] */ __RPC__in RemFORMATETC *pformatetc,
    /* [in] */ __RPC__in RemSTGMEDIUM *pstgmed);

/* [local] */ HRESULT STDMETHODCALLTYPE IBindStatusCallbackEx_GetBindInfoEx_Proxy( 
    IBindStatusCallbackEx * This,
    /* [out] */ DWORD *grfBINDF,
    /* [unique][out][in] */ BINDINFO *pbindinfo,
    /* [out] */ DWORD *grfBINDF2,
    /* [out] */ DWORD *pdwReserved);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindStatusCallbackEx_GetBindInfoEx_Stub( 
    __RPC__in IBindStatusCallbackEx * This,
    /* [out] */ __RPC__out DWORD *grfBINDF,
    /* [unique][out][in] */ __RPC__inout_opt RemBINDINFO *pbindinfo,
    /* [unique][out][in] */ __RPC__inout_opt RemSTGMEDIUM *pstgmed,
    /* [out] */ __RPC__out DWORD *grfBINDF2,
    /* [out] */ __RPC__out DWORD *pdwReserved);

/* [local] */ HRESULT STDMETHODCALLTYPE IWinInetInfo_QueryOption_Proxy( 
    IWinInetInfo * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ LPVOID pBuffer,
    /* [out][in] */ DWORD *pcbBuf);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IWinInetInfo_QueryOption_Stub( 
    __RPC__in IWinInetInfo * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ __RPC__inout_ecount_full(*pcbBuf) BYTE *pBuffer,
    /* [out][in] */ __RPC__inout DWORD *pcbBuf);

/* [local] */ HRESULT STDMETHODCALLTYPE IWinInetHttpInfo_QueryInfo_Proxy( 
    IWinInetHttpInfo * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ LPVOID pBuffer,
    /* [out][in] */ DWORD *pcbBuf,
    /* [out][in] */ DWORD *pdwFlags,
    /* [out][in] */ DWORD *pdwReserved);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IWinInetHttpInfo_QueryInfo_Stub( 
    __RPC__in IWinInetHttpInfo * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out][in] */ __RPC__inout_ecount_full(*pcbBuf) BYTE *pBuffer,
    /* [out][in] */ __RPC__inout DWORD *pcbBuf,
    /* [out][in] */ __RPC__inout DWORD *pdwFlags,
    /* [out][in] */ __RPC__inout DWORD *pdwReserved);

/* [local] */ HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToStorage_Proxy( 
    IBindHost * This,
    /* [in] */ IMoniker *pMk,
    /* [in] */ IBindCtx *pBC,
    /* [in] */ IBindStatusCallback *pBSC,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppvObj);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToStorage_Stub( 
    __RPC__in IBindHost * This,
    /* [unique][in] */ __RPC__in_opt IMoniker *pMk,
    /* [unique][in] */ __RPC__in_opt IBindCtx *pBC,
    /* [unique][in] */ __RPC__in_opt IBindStatusCallback *pBSC,
    /* [in] */ __RPC__in REFIID riid,
    /* [iid_is][out] */ __RPC__deref_out_opt IUnknown **ppvObj);

/* [local] */ HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToObject_Proxy( 
    IBindHost * This,
    /* [in] */ IMoniker *pMk,
    /* [in] */ IBindCtx *pBC,
    /* [in] */ IBindStatusCallback *pBSC,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppvObj);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToObject_Stub( 
    __RPC__in IBindHost * This,
    /* [unique][in] */ __RPC__in_opt IMoniker *pMk,
    /* [unique][in] */ __RPC__in_opt IBindCtx *pBC,
    /* [unique][in] */ __RPC__in_opt IBindStatusCallback *pBSC,
    /* [in] */ __RPC__in REFIID riid,
    /* [iid_is][out] */ __RPC__deref_out_opt IUnknown **ppvObj);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\vbinterf.h ===
//---------------------------------------------------------------------------
// IVBGetControl
//---------------------------------------------------------------------------
// This interface lives on the Extender Object
//---------------------------------------------------------------------------

// Constants for dwWhich parameter:
#define GC_WCH_SIBLING          0x00000001L
#define GC_WCH_CONTAINER        0x00000002L   // no FONLYAFTER/BEFORE
#define GC_WCH_CONTAINED        0x00000003L   // no FONLYAFTER/BEFORE
#define GC_WCH_ALL              0x00000004L
#define GC_WCH_FREVERSEDIR      0x08000000L   // OR'd with others
#define GC_WCH_FONLYAFTER       0x10000000L   // OR'd with others
#define GC_WCH_FONLYBEFORE      0x20000000L   // OR'd with others
#define GC_WCH_FSELECTED        0x40000000L   // OR'd with others

DECLARE_INTERFACE_(IVBGetControl, IUnknown)
    {
    // *** IUnknown methods ****
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IVBGetControl methods ****
    STDMETHOD(EnumControls)(THIS_ DWORD dwOleContF, DWORD dwWhich, LPENUMUNKNOWN FAR *ppenumUnk) PURE;
    };

//---------------------------------------------------------------------------
// IGetOleObject
//---------------------------------------------------------------------------
// This interface lives on the Extender Object (X-Object / hctl)
//---------------------------------------------------------------------------
DECLARE_INTERFACE_(IGetOleObject, IUnknown)
    {
    // *** IUnknown methods ****
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IGetOleObject methods ****
    STDMETHOD(GetOleObject)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    };

DECLARE_INTERFACE_(IVBFormat,IUnknown)
  {
  /* IUnknown methods */
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, void FAR* FAR* ppvObj) PURE;
  STDMETHOD_(unsigned long, AddRef)(THIS) PURE;
  STDMETHOD_(unsigned long, Release)(THIS) PURE;
  STDMETHOD(Format)(VARIANT FAR *vData,  BSTR bstrFormat, LPVOID lpBuffer,
	USHORT cb,  LONG lcid, SHORT sFirstDayOfWeek,
	USHORT sFirstWeekOfYear, USHORT * rcb) PURE;
  };

DECLARE_INTERFACE_(IGetVBAObject,IUnknown)
  {
  /* IUnknown methods */
  STDMETHOD(QueryInterface)(THIS_ REFIID riid, void FAR* FAR* ppvObj) PURE;
  STDMETHOD_(unsigned long, AddRef)(THIS) PURE;
  STDMETHOD_(unsigned long, Release)(THIS) PURE;

  STDMETHOD(GetObject)(THIS_ REFIID riid, void FAR* FAR* ppvObj, DWORD dwReserved) PURE;
  };

#include <initguid.h>

//IVBGetControl & IGetOleObject
DEFINE_GUID(IID_IVBGetControl, 0x40A050A0L, 0x3C31, 0x101B, 0xA8, 0x2E, 0x08, 0x00, 0x2B, 0x2B, 0x23, 0x37);
DEFINE_GUID(IID_IGetOleObject, 0x8A701DA0L, 0x4FEB, 0x101B, 0xA8, 0x2E, 0x08, 0x00, 0x2B, 0x2B, 0x23, 0x37);

//Format
DEFINE_GUID(IID_IGetVBAObject, 0x91733A60L, 0x3F4C, 0x101B, 0xA3, 0xF6, 0x00, 0xAA, 0x00, 0x34, 0xE4, 0xE9);
DEFINE_GUID(IID_IVBFormat, 0x9849FD60L, 0x3768, 0x101B, 0x8D, 0x72, 0xAE, 0x61,0x64, 0xFF, 0xE3, 0xCF);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Vcr.h ===
/***************************************************************************
 *                                                                         *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY  *
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE    *
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR  *
 *  PURPOSE.                                                               *
 *                                                                         *
 *  Copyright (c) 1993 - 1999 Microsoft Corporation.  All Rights Reserved. *
 *                                                                         *
 * File:  vcr.h                                                            *
 * Title:           VCR-MCI Command Table Include File                     *
 *                                                                         *
 ***************************************************************************/

#ifndef __VCR_H__
#define __VCR_H__

/* string resource base for vcr device type */
#define MCI_VCR_OFFSET                          1280

/* system MCI commands */
#define MCI_LIST                                0x0878
#define MCI_SETAUDIO                            0x0873 
#define MCI_SETVIDEO                            0x0876 
#define MCI_SIGNAL                              0x0875 

/* custom MCI commands for VCRs */
#define MCI_MARK                                (MCI_USER_MESSAGES + 0)
#define MCI_INDEX                               (MCI_USER_MESSAGES + 1)
#define MCI_SETTUNER                            (MCI_USER_MESSAGES + 2)
#define MCI_SETVCR                              (MCI_USER_MESSAGES + 3)
#define MCI_SETTIMECODE                         (MCI_USER_MESSAGES + 4)

/* Test is appplicable to all commands */
#define MCI_TEST                                0x00000020L

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_VCR_GETDEVCAPS_CAN_DETECT_LENGTH    0x00004001L
#define MCI_VCR_GETDEVCAPS_SEEK_ACCURACY        0x00004002L
#define MCI_VCR_GETDEVCAPS_HAS_CLOCK            0x00004003L
#define MCI_VCR_GETDEVCAPS_CAN_REVERSE          0x00004004L
#define MCI_VCR_GETDEVCAPS_NUMBER_OF_MARKS      0x00004005L
#define MCI_VCR_GETDEVCAPS_CAN_TEST             0x00004006L
#define MCI_VCR_GETDEVCAPS_CAN_PREROLL          0x00004007L
#define MCI_VCR_GETDEVCAPS_CAN_PREVIEW          0x00004008L
#define MCI_VCR_GETDEVCAPS_CAN_MONITOR_SOURCES  0x00004009L
#define MCI_VCR_GETDEVCAPS_HAS_TIMECODE         0x0000400AL
#define MCI_VCR_GETDEVCAPS_CAN_FREEZE           0x0000401BL
#define MCI_VCR_GETDEVCAPS_CLOCK_INCREMENT_RATE 0x0000401CL

/* flags for dwFlags parameter of MCI_INFO command message */
#define MCI_VCR_INFO_VERSION                    0x00010000L

/* flags for dwFlags parameter of MCI_PLAY command message */
#define MCI_VCR_PLAY_REVERSE                    0x00010000L
#define MCI_VCR_PLAY_AT                         0x00020000L
#define MCI_VCR_PLAY_SCAN                       0x00040000L

/* flags for dwFlags parameter of MCI_RECORD command message */
#define MCI_VCR_RECORD_INITIALIZE               0x00010000L
#define MCI_VCR_RECORD_AT                       0x00020000L
#define MCI_VCR_RECORD_PREVIEW                  0x00040000L

/* flags for dwFlags parameter of MCI_CUE command message */
#define MCI_VCR_CUE_INPUT                       0x00010000L
#define MCI_VCR_CUE_OUTPUT                      0x00020000L
#define MCI_VCR_CUE_PREROLL                     0x00040000L
#define MCI_VCR_CUE_REVERSE                     0x00080000L

/* flags for dwFlags parameter of MCI_SEEK command message */
#define MCI_VCR_SEEK_REVERSE                    0x00010000L
#define MCI_VCR_SEEK_MARK                       0x00020000L
#define MCI_VCR_SEEK_AT                         0x00040000L
                                               
/* flags for dwFlags parameter of MCI_SETTUNER command message */
#define MCI_VCR_SETTUNER_CHANNEL                0x00010000L
#define MCI_VCR_SETTUNER_CHANNEL_UP             0x00020000L
#define MCI_VCR_SETTUNER_CHANNEL_DOWN           0x00040000L
#define MCI_VCR_SETTUNER_CHANNEL_SEEK_UP        0x00080000L
#define MCI_VCR_SETTUNER_CHANNEL_SEEK_DOWN      0x00100000L
#define MCI_VCR_SETTUNER_NUMBER                 0x00200000L

/* flags for dwFlags parameter of MCI_SET command message */
#define MCI_VCR_SET_TIME_MODE                   0x00010000L
#define MCI_VCR_SET_POWER                       0x00020000L
#define MCI_VCR_SET_RECORD_FORMAT               0x00040000L
#define MCI_VCR_SET_COUNTER_FORMAT              0x00080000L
#define MCI_VCR_SET_INDEX                       0x00100000L
#define MCI_VCR_SET_ASSEMBLE_RECORD             0x00200000L
#define MCI_VCR_SET_TRACKING                    0x00400000L
#define MCI_VCR_SET_SPEED                       0x00800000L
#define MCI_VCR_SET_TAPE_LENGTH                 0x01000000L
#define MCI_VCR_SET_COUNTER_VALUE               0x02000000L
#define MCI_VCR_SET_CLOCK                       0x04000000L
#define MCI_VCR_SET_PAUSE_TIMEOUT               0x08000000L
#define MCI_VCR_SET_PREROLL_DURATION            0x10000000L
#define MCI_VCR_SET_POSTROLL_DURATION           0x20000000L

/* flags for dwItem parameter of MCI_SETTIMECODE commmand message */
#define MCI_VCR_SETTIMECODE_RECORD              0x00010000L

/* flags for dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_VCR_STATUS_FRAME_RATE               0x00004001L /* Frame rate   */
#define MCI_VCR_STATUS_SPEED                    0x00004002L /* Speed        */
#define MCI_VCR_STATUS_MEDIA_TYPE               0x00004003L
#define MCI_VCR_STATUS_RECORD_FORMAT            0x00004004L
#define MCI_VCR_STATUS_PLAY_FORMAT              0x00004005L
#define MCI_VCR_STATUS_AUDIO_SOURCE             0x00004006L
#define MCI_VCR_STATUS_AUDIO_SOURCE_NUMBER      0x00004007L
#define MCI_VCR_STATUS_VIDEO_SOURCE             0x00004008L
#define MCI_VCR_STATUS_VIDEO_SOURCE_NUMBER      0x00004009L
#define MCI_VCR_STATUS_AUDIO_MONITOR            0x0000400AL
#define MCI_VCR_STATUS_AUDIO_MONITOR_NUMBER     0x0000400BL
#define MCI_VCR_STATUS_VIDEO_MONITOR            0x0000400CL
#define MCI_VCR_STATUS_VIDEO_MONITOR_NUMBER     0x0000400DL
#define MCI_VCR_STATUS_INDEX_ON                 0x0000400EL
#define MCI_VCR_STATUS_INDEX                    0x0000400FL
#define MCI_VCR_STATUS_COUNTER_FORMAT           0x00004010L
#define MCI_VCR_STATUS_COUNTER_RESOLUTION       0x00004011L
#define MCI_VCR_STATUS_TIMECODE_TYPE            0x00004012L
#define MCI_VCR_STATUS_COUNTER_VALUE            0x00004013L
#define MCI_VCR_STATUS_TUNER_CHANNEL            0x00004014L
#define MCI_VCR_STATUS_WRITE_PROTECTED          0x00004015L
#define MCI_VCR_STATUS_TIMECODE_RECORD          0x00004016L
#define MCI_VCR_STATUS_VIDEO_RECORD             0x00004017L
#define MCI_VCR_STATUS_AUDIO_RECORD             0x00004018L
#define MCI_VCR_STATUS_TIME_TYPE                0x00004019L
#define MCI_VCR_STATUS_TIME_MODE                0x0000401AL
#define MCI_VCR_STATUS_POWER_ON                 0x0000401BL
#define MCI_VCR_STATUS_CLOCK                    0x0000401CL
#define MCI_VCR_STATUS_ASSEMBLE_RECORD          0x0000401DL
#define MCI_VCR_STATUS_TIMECODE_PRESENT         0x0000401EL
#define MCI_VCR_STATUS_NUMBER_OF_VIDEO_TRACKS   0x0000401FL
#define MCI_VCR_STATUS_NUMBER_OF_AUDIO_TRACKS   0x00004020L
#define MCI_VCR_STATUS_CLOCK_ID                 0x00004021L
#define MCI_VCR_STATUS_PAUSE_TIMEOUT            0x00004022L
#define MCI_VCR_STATUS_PREROLL_DURATION         0x00004023L
#define MCI_VCR_STATUS_POSTROLL_DURATION        0x00004024L
#define MCI_VCR_STATUS_VIDEO                    0x00004025L
#define MCI_VCR_STATUS_AUDIO                    0x00004026L

#define MCI_VCR_STATUS_NUMBER                   0x00080000L

/* flags for dwFlags parameter of MCI_ESCAPE command message */
#define MCI_VCR_ESCAPE_STRING                   0x00000100L

/* flags for dwFlags parameter of MCI_LIST command message */
#define MCI_VCR_LIST_VIDEO_SOURCE               0x00010000L
#define MCI_VCR_LIST_AUDIO_SOURCE               0x00020000L
#define MCI_VCR_LIST_COUNT                      0x00040000L
#define MCI_VCR_LIST_NUMBER                     0x00080000L

/* flags for dwFlags parameter of MCI_MARK command message */
#define MCI_VCR_MARK_WRITE                      0x00010000L
#define MCI_VCR_MARK_ERASE                      0x00020000L

/* flags for dwFlags parameter for MCI_SETAUDIO command message */
#define MCI_VCR_SETAUDIO_RECORD                 0x00010000L
#define MCI_VCR_SETAUDIO_SOURCE                 0x00020000L
#define MCI_VCR_SETAUDIO_MONITOR                0x00040000L
#define MCI_VCR_SETAUDIO_TO                     0x00200000L
#define MCI_VCR_SETAUDIO_NUMBER                 0x00400000L

/* flags for dwFlags parameter for MCI_SETVIDEO command message */
#define MCI_VCR_SETVIDEO_RECORD                 0x00010000L
#define MCI_VCR_SETVIDEO_SOURCE                 0x00020000L
#define MCI_VCR_SETVIDEO_MONITOR                0x00040000L
#define MCI_VCR_SETVIDEO_TO                     0x00100000L
#define MCI_VCR_SETVIDEO_NUMBER                 0x00200000L

/* The following is the function digitalvideo drivers must use 
 * to signal when a frame marked by the SIGNAL command has been rendered:
 *
 *  SEND_VCRSIGNAL(dwFlags, dwCallback, hDriver, wDeviceID, dwUser, dwPos )
 *
 * The following is a description of the parameters:
 *
 *  dwFlags    - the dwFlags parameter passed when the signal was set
 *  dwCallback - the dwCallback value from the MCI_VCR_SIGNAL_PARMS struct
 *               used to set the signal
 *  hDriver    - the handle assigned to the driver by MMSYSTEM when the 
 *               device was opened
 *  wDeviceID  - the device ID
 *  dwUser     - the dwUserParm value from the MCI_VCR_SIGNAL_PARMS struct
 *               used to set the signal
 *  dwPos      - the position at which the signal was sent, in the current
 *               time format.
 *
 * The window indicated by the handle in the dwCallback field is notified 
 * by means of a Windows message with the following form:
 *
 * msg    = MM_MCISIGNAL
 * wParam = wDeviceID of the sending driver 
 * lParam = the uservalue specified or the position the signal was sent
 *          at; the latter if the MCI_VCR_SIGNAL_POSITION flag was set 
 *          in the dwFlags parameter when the signal was created.
 */

#define SEND_VCRSIGNAL(dwFlags, dwCallback, hDriver, wDeviceID, dwUser, dwPos ) \
  DriverCallback( (dwCallback), DCB_WINDOW, (HANDLE)(wDeviceID), MM_MCISIGNAL,\
  hDriver, ((dwFlags) & MCI_VCR_SIGNAL_POSITION) ? (dwPos):(dwUser),\
  ((dwFlags) & MCI_VCR_SIGNAL_POSITION) ? (dwUser):(dwPos))

/* Window message for signal notification */
#define MM_MCISIGNAL                            0x3CB

/* flags for dwFlags parameter of MCI_SIGNAL command message */
#define MCI_VCR_SIGNAL_AT                       0x00010000L
#define MCI_VCR_SIGNAL_EVERY                    0x00020000L
#define MCI_VCR_SIGNAL_USERVAL                  0x00040000L
#define MCI_VCR_SIGNAL_CANCEL                   0x00080000L
#define MCI_VCR_SIGNAL_POSITION                 0x00100000L

/* flags for dwFlags parameter of MCI_STEP command message */
#define MCI_VCR_STEP_FRAMES                     0x00010000L
#define MCI_VCR_STEP_REVERSE                    0x00020000L

/* flags for dwFlags parameter of MCI_FREEZE command message */
#define MCI_VCR_FREEZE_INPUT                    0x00010000L
#define MCI_VCR_FREEZE_OUTPUT                   0x00020000L
#define MCI_VCR_FREEZE_FIELD                    0x00040000L
#define MCI_VCR_FREEZE_FRAME                    0x00080000L

/* flags for dwFlags parameter of MCI_UNFREEZE command message */
#define MCI_VCR_UNFREEZE_INPUT                  0x00010000L
#define MCI_VCR_UNFREEZE_OUTPUT                 0x00020000L

/* string resource values for vcr media types */
#define MCI_VCR_MEDIA_8MM                       (MCI_VCR_OFFSET + 1)
#define MCI_VCR_MEDIA_HI8                       (MCI_VCR_OFFSET + 2)
#define MCI_VCR_MEDIA_VHS                       (MCI_VCR_OFFSET + 3)
#define MCI_VCR_MEDIA_SVHS                      (MCI_VCR_OFFSET + 4)
#define MCI_VCR_MEDIA_BETA                      (MCI_VCR_OFFSET + 5)
#define MCI_VCR_MEDIA_EDBETA                    (MCI_VCR_OFFSET + 6)
#define MCI_VCR_MEDIA_OTHER                     (MCI_VCR_OFFSET + 7)

/* string resource values for vcr play/record formats */
#define MCI_VCR_FORMAT_SP                       (MCI_VCR_OFFSET + 8)
#define MCI_VCR_FORMAT_LP                       (MCI_VCR_OFFSET + 9)
#define MCI_VCR_FORMAT_EP                       (MCI_VCR_OFFSET + 10)
#define MCI_VCR_FORMAT_OTHER                    (MCI_VCR_OFFSET + 11)

/* string resource values for timecode types */
#define MCI_VCR_TIME_TIMECODE                   (MCI_VCR_OFFSET + 12)
#define MCI_VCR_TIME_COUNTER                    (MCI_VCR_OFFSET + 13)
#define MCI_VCR_TIME_DETECT                     (MCI_VCR_OFFSET + 14)

/* string resource values for src types */
#define MCI_VCR_SRC_TYPE_TUNER                  (MCI_VCR_OFFSET + 15)
#define MCI_VCR_SRC_TYPE_LINE                   (MCI_VCR_OFFSET + 16)
#define MCI_VCR_SRC_TYPE_SVIDEO                 (MCI_VCR_OFFSET + 17)
#define MCI_VCR_SRC_TYPE_RGB                    (MCI_VCR_OFFSET + 18)
#define MCI_VCR_SRC_TYPE_AUX                    (MCI_VCR_OFFSET + 19)
#define MCI_VCR_SRC_TYPE_GENERIC                (MCI_VCR_OFFSET + 20)
#define MCI_VCR_SRC_TYPE_MUTE                   (MCI_VCR_OFFSET + 21)
#define MCI_VCR_SRC_TYPE_OUTPUT                 (MCI_VCR_OFFSET + 22)

/* string resource values for vcr counters */
#define MCI_VCR_INDEX_TIMECODE                  (MCI_VCR_OFFSET + 23)         
#define MCI_VCR_INDEX_COUNTER                   (MCI_VCR_OFFSET + 24)   
#define MCI_VCR_INDEX_DATE                      (MCI_VCR_OFFSET + 25)
#define MCI_VCR_INDEX_TIME                      (MCI_VCR_OFFSET + 26)

/* string resources for timecode type and counter resolution */
#define MCI_VCR_COUNTER_RES_SECONDS             (MCI_VCR_OFFSET + 27)            
#define MCI_VCR_COUNTER_RES_FRAMES              (MCI_VCR_OFFSET + 28)

#define MCI_VCR_TIMECODE_TYPE_SMPTE             (MCI_VCR_OFFSET + 29)
#define MCI_VCR_TIMECODE_TYPE_SMPTE_DROP        (MCI_VCR_OFFSET + 30)
#define MCI_VCR_TIMECODE_TYPE_OTHER             (MCI_VCR_OFFSET + 31)
#define MCI_VCR_TIMECODE_TYPE_NONE              (MCI_VCR_OFFSET + 32)

#define MCI_VCR_PLUS                            (MCI_VCR_OFFSET + 33)
#define MCI_VCR_MINUS                           (MCI_VCR_OFFSET + 34)
#define MCI_VCR_RESET                           (MCI_VCR_OFFSET + 35)

#ifndef RC_INVOKED

/* parameter block for MCI_SEEK command message */
typedef struct tagMCI_VCR_SEEK_PARMS {
    DWORD   dwCallback;
    DWORD   dwTo;
    DWORD   dwMark;
    DWORD   dwAt;
} MCI_VCR_SEEK_PARMS;
typedef MCI_VCR_SEEK_PARMS FAR *LPMCI_VCR_SEEK_PARMS;

/* parameter block for MCI_SET command message */
typedef struct tagMCI_VCR_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    DWORD   dwTimeMode;
    DWORD   dwRecordFormat;
    DWORD   dwCounterFormat;
    DWORD   dwIndex;
    DWORD   dwTracking;
    DWORD   dwSpeed;
    DWORD   dwLength;
    DWORD   dwCounter;
    DWORD   dwClock;
    DWORD   dwPauseTimeout;
    DWORD   dwPrerollDuration;
    DWORD   dwPostrollDuration;
} MCI_VCR_SET_PARMS;
typedef MCI_VCR_SET_PARMS FAR *LPMCI_VCR_SET_PARMS;

/* parameter block for MCI_VCR_SETTUNER command message */
typedef struct tagMCI_VCR_SETTUNER_PARMS {
    DWORD   dwCallback;
    DWORD   dwChannel;
    DWORD   dwNumber;
} MCI_VCR_SETTUNER_PARMS;
typedef MCI_VCR_SETTUNER_PARMS FAR *LPMCI_VCR_SETTUNER_PARMS;

/* parameter block for MCI_ESCAPE command message */
typedef struct tagMCI_VCR_ESCAPE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpstrCommand;
} MCI_VCR_ESCAPE_PARMS;
typedef MCI_VCR_ESCAPE_PARMS FAR *LPMCI_VCR_ESCAPE_PARMS;

/* parameter block for MCI_LIST command message */
typedef struct tagMCI_VCR_LIST_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwNumber;
} MCI_VCR_LIST_PARMS;
typedef MCI_VCR_LIST_PARMS FAR *LPMCI_VCR_LIST_PARMS;

/* parameter block for MCI_RECORD command message */
typedef struct tagMCI_VCR_RECORD_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwAt;
} MCI_VCR_RECORD_PARMS;
typedef MCI_VCR_RECORD_PARMS FAR *LPMCI_VCR_RECORD_PARMS;

/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_VCR_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwAt;
} MCI_VCR_PLAY_PARMS;
typedef MCI_VCR_PLAY_PARMS FAR *LPMCI_VCR_PLAY_PARMS;

/* parameter block for MCI_SETAUDIO command message */
typedef struct tagMCI_VCR_SETAUDIO_PARMS {
    DWORD   dwCallback;
    DWORD   dwTrack;
    DWORD   dwTo;
    DWORD   dwNumber;
} MCI_VCR_SETAUDIO_PARMS;
typedef MCI_VCR_SETAUDIO_PARMS FAR *LPMCI_VCR_SETAUDIO_PARMS;

/* parameter block for MCI_SIGNAL command message */
typedef struct tagMCI_VCR_SIGNAL_PARMS {
    DWORD   dwCallback;
    DWORD   dwPosition;
    DWORD   dwPeriod;
    DWORD   dwUserParm;
} MCI_VCR_SIGNAL_PARMS;
typedef MCI_VCR_SIGNAL_PARMS FAR * LPMCI_VCR_SIGNAL_PARMS;

/* parameter block for MCI_VCR_STATUS command message */
typedef struct tagMCI_VCR_STATUS_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
    DWORD   dwTrack;
    DWORD   dwNumber;
} MCI_VCR_STATUS_PARMS;
typedef MCI_VCR_STATUS_PARMS FAR * LPMCI_VCR_STATUS_PARMS;

/* parameter block for MCI_SETVIDEO command message */
typedef struct tagMCI_VCR_SETVIDEO_PARMS {
    DWORD   dwCallback;
    DWORD   dwTrack;
    DWORD   dwTo;
    DWORD   dwNumber;
} MCI_VCR_SETVIDEO_PARMS;
typedef MCI_VCR_SETVIDEO_PARMS FAR *LPMCI_VCR_SETVIDEO_PARMS;

/* parameter block for MCI_STEP command message */
typedef struct tagMCI_VCR_STEP_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_VCR_STEP_PARMS;
typedef MCI_VCR_STEP_PARMS FAR *LPMCI_VCR_STEP_PARMS;

/* parameter block for MCI_CUE command message */
typedef struct tagMCI_VCR_CUE_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_VCR_CUE_PARMS;
typedef MCI_VCR_CUE_PARMS FAR *LPMCI_VCR_CUE_PARMS;

#endif /* NOT RC_INVOKED */

/* VCR error codes */
#define MCIERR_VCR_CANNOT_OPEN_COMM         (MCIERR_CUSTOM_DRIVER_BASE + 1)
#define MCIERR_VCR_CANNOT_WRITE_COMM        (MCIERR_CUSTOM_DRIVER_BASE + 2)
#define MCIERR_VCR_READ_TIMEOUT             (MCIERR_CUSTOM_DRIVER_BASE + 3)
#define MCIERR_VCR_COMMAND_BUFFER_FULL      (MCIERR_CUSTOM_DRIVER_BASE + 4)
#define MCIERR_VCR_COMMAND_CANCELLED        (MCIERR_CUSTOM_DRIVER_BASE + 5)
#define MCIERR_VCR_POWER_OFF                (MCIERR_CUSTOM_DRIVER_BASE + 6)
#define MCIERR_VCR_COMMAND_FAILED           (MCIERR_CUSTOM_DRIVER_BASE + 7)
#define MCIERR_VCR_SEARCH                   (MCIERR_CUSTOM_DRIVER_BASE + 8)
#define MCIERR_VCR_CONDITION                (MCIERR_CUSTOM_DRIVER_BASE + 9)
#define MCIERR_VCR_CAMERA_MODE              (MCIERR_CUSTOM_DRIVER_BASE + 10)
#define MCIERR_VCR_VCR_MODE                 (MCIERR_CUSTOM_DRIVER_BASE + 11)
#define MCIERR_VCR_COUNTER_TYPE             (MCIERR_CUSTOM_DRIVER_BASE + 12)
#define MCIERR_VCR_TUNER                    (MCIERR_CUSTOM_DRIVER_BASE + 13)
#define MCIERR_VCR_EMERGENCY_STOP           (MCIERR_CUSTOM_DRIVER_BASE + 14)
#define MCIERR_VCR_MEDIA_UNMOUNTED          (MCIERR_CUSTOM_DRIVER_BASE + 15)
#define MCIERR_VCR_REGISTER                 (MCIERR_CUSTOM_DRIVER_BASE + 16)
#define MCIERR_VCR_TRACK_FAILURE            (MCIERR_CUSTOM_DRIVER_BASE + 17)
#define MCIERR_VCR_CUE_FAILED_FLAGS         (MCIERR_CUSTOM_DRIVER_BASE + 18)
#define MCIERR_VCR_ISWRITEPROTECTED         (MCIERR_CUSTOM_DRIVER_BASE + 19)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\VdmDbg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1985-1999, Microsoft Corporation

Module Name:

    vdmdbg.h

Abstract:

    Prodecure declarations, constant definitions, type definition and macros
    for the VDMDBG.DLL VDM Debugger interface.

--*/

#ifndef _VDMDBG_
#define _VDMDBG_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#include <pshpack4.h>

#define STATUS_VDM_EVENT    STATUS_SEGMENT_NOTIFICATION

#ifndef DBG_SEGLOAD
#define DBG_SEGLOAD     0
#define DBG_SEGMOVE     1
#define DBG_SEGFREE     2
#define DBG_MODLOAD     3
#define DBG_MODFREE     4
#define DBG_SINGLESTEP  5
#define DBG_BREAK       6
#define DBG_GPFAULT     7
#define DBG_DIVOVERFLOW 8
#define DBG_INSTRFAULT  9
#define DBG_TASKSTART   10
#define DBG_TASKSTOP    11
#define DBG_DLLSTART    12
#define DBG_DLLSTOP     13
#define DBG_ATTACH      14
#define DBG_TOOLHELP    15
#define DBG_STACKFAULT  16
#define DBG_WOWINIT     17
#define DBG_TEMPBP      18
#define DBG_MODMOVE     19
#define DBG_INIT        20
#define DBG_GPFAULT2    21
#endif

//
// These flags are set in the same WORD as the DBG_ event id's (above).
//
#define VDMEVENT_NEEDS_INTERACTIVE  0x8000
#define VDMEVENT_VERBOSE            0x4000
#define VDMEVENT_PE                 0x2000
#define VDMEVENT_ALLFLAGS           0xe000
//
// These flags are set in the second WORD of the exception event
// parameters.
//
#define VDMEVENT_V86                0x0001
#define VDMEVENT_PM16               0x0002

//
// The following flags control the contents of the CONTEXT structure.
//

#define VDMCONTEXT_i386    0x00010000    // this assumes that i386 and
#define VDMCONTEXT_i486    0x00010000    // i486 have identical context records

#define VDMCONTEXT_CONTROL         (VDMCONTEXT_i386 | 0x00000001L) // SS:SP, CS:IP, FLAGS, BP
#define VDMCONTEXT_INTEGER         (VDMCONTEXT_i386 | 0x00000002L) // AX, BX, CX, DX, SI, DI
#define VDMCONTEXT_SEGMENTS        (VDMCONTEXT_i386 | 0x00000004L) // DS, ES, FS, GS
#define VDMCONTEXT_FLOATING_POINT  (VDMCONTEXT_i386 | 0x00000008L) // 387 state
#define VDMCONTEXT_DEBUG_REGISTERS (VDMCONTEXT_i386 | 0x00000010L) // DB 0-3,6,7
#define VDMCONTEXT_EXTENDED_REGISTERS  (VDMCONTEXT_i386 | 0x00000020L) // cpu specific extensions

#define VDMCONTEXT_FULL (VDMCONTEXT_CONTROL | VDMCONTEXT_INTEGER |\
                      VDMCONTEXT_SEGMENTS)


#ifdef _X86_

// On x86 machines, just copy the definition of the CONTEXT and LDT_ENTRY
// structures.
typedef struct _CONTEXT VDMCONTEXT;
typedef struct _LDT_ENTRY VDMLDT_ENTRY;

#else // _X86_

//
//  Define the size of the 80387 save area, which is in the context frame.
//

#define SIZE_OF_80387_REGISTERS      80

typedef struct _FLOATING_SAVE_AREA {
    ULONG   ControlWord;
    ULONG   StatusWord;
    ULONG   TagWord;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;
    ULONG   DataSelector;
    UCHAR   RegisterArea[SIZE_OF_80387_REGISTERS];
    ULONG   Cr0NpxState;
} FLOATING_SAVE_AREA;

//
// Simulated context structure for the 16-bit environment
//

typedef struct _VDMCONTEXT {

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a threads context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //
    // CONTEXT_FULL on some systems (MIPS namely) does not contain the
    // CONTEXT_SEGMENTS definition.  VDMDBG assumes that CONTEXT_INTEGER also
    // includes CONTEXT_SEGMENTS to account for this.
    //

    ULONG ContextFlags;

    //
    // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
    // set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
    // included in CONTEXT_FULL.
    //

    ULONG   Dr0;
    ULONG   Dr1;
    ULONG   Dr2;
    ULONG   Dr3;
    ULONG   Dr6;
    ULONG   Dr7;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
    //

    FLOATING_SAVE_AREA FloatSave;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_SEGMENTS.
    //

    ULONG   SegGs;
    ULONG   SegFs;
    ULONG   SegEs;
    ULONG   SegDs;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_INTEGER.
    //

    ULONG   Edi;
    ULONG   Esi;
    ULONG   Ebx;
    ULONG   Edx;
    ULONG   Ecx;
    ULONG   Eax;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_CONTROL.
    //

    ULONG   Ebp;
    ULONG   Eip;
    ULONG   SegCs;              // MUST BE SANITIZED
    ULONG   EFlags;             // MUST BE SANITIZED
    ULONG   Esp;
    ULONG   SegSs;

} VDMCONTEXT;

//
//  LDT descriptor entry
//

typedef struct _VDMLDT_ENTRY {
    USHORT  LimitLow;
    USHORT  BaseLow;
    union {
        struct {
            UCHAR   BaseMid;
            UCHAR   Flags1;     // Declare as bytes to avoid alignment
            UCHAR   Flags2;     // Problems.
            UCHAR   BaseHi;
        } Bytes;
        struct {
            ULONG   BaseMid : 8;
            ULONG   Type : 5;
            ULONG   Dpl : 2;
            ULONG   Pres : 1;
            ULONG   LimitHi : 4;
            ULONG   Sys : 1;
            ULONG   Reserved_0 : 1;
            ULONG   Default_Big : 1;
            ULONG   Granularity : 1;
            ULONG   BaseHi : 8;
        } Bits;
    } HighWord;
} VDMLDT_ENTRY;

#endif // _X86_

typedef VDMCONTEXT *LPVDMCONTEXT;
typedef VDMLDT_ENTRY *LPVDMLDT_ENTRY;

#define VDMCONTEXT_TO_PROGRAM_COUNTER(Context) (PVOID)((Context)->Eip)

#define VDMCONTEXT_LENGTH  (sizeof(VDMCONTEXT))
#define VDMCONTEXT_ALIGN   (sizeof(ULONG))
#define VDMCONTEXT_ROUND   (VDMCONTEXT_ALIGN - 1)

#define V86FLAGS_CARRY      0x00001
#define V86FLAGS_PARITY     0x00004
#define V86FLAGS_AUXCARRY   0x00010
#define V86FLAGS_ZERO       0x00040
#define V86FLAGS_SIGN       0x00080
#define V86FLAGS_TRACE      0x00100
#define V86FLAGS_INTERRUPT  0x00200
#define V86FLAGS_DIRECTION  0x00400
#define V86FLAGS_OVERFLOW   0x00800
#define V86FLAGS_IOPL       0x03000
#define V86FLAGS_IOPL_BITS  0x12
#define V86FLAGS_RESUME     0x10000
#define V86FLAGS_V86        0x20000     // Used to detect RealMode v. ProtMode
#define V86FLAGS_ALIGNMENT  0x40000

#define MAX_MODULE_NAME  8 + 1
#define MAX_PATH16      255

typedef struct _SEGMENT_NOTE {
    WORD    Selector1;                      // Selector of operation
    WORD    Selector2;                      // Dest. Sel. for moving segments
    WORD    Segment;                        // Segment within Module
    CHAR    Module[MAX_MODULE_NAME+1];      // Module name
    CHAR    FileName[MAX_PATH16+1];         // PathName to executable image
    WORD    Type;                           // Code / Data, etc.
    DWORD   Length;                         // Length of image
} SEGMENT_NOTE;

typedef struct _IMAGE_NOTE {
    CHAR    Module[MAX_MODULE_NAME+1];      // Module
    CHAR    FileName[MAX_PATH16+1];         // Path to executable image
    WORD    hModule;                        // 16-bit hModule
    WORD    hTask;                          // 16-bit hTask
} IMAGE_NOTE;

typedef struct {
    DWORD   dwSize;
    char    szModule[MAX_MODULE_NAME+1];
    HANDLE  hModule;
    WORD    wcUsage;
    char    szExePath[MAX_PATH16+1];
    WORD    wNext;
} MODULEENTRY, *LPMODULEENTRY;


#define SN_CODE 0                           // Protect mode code segment
#define SN_DATA 1                           // Protect mode data segment
#define SN_V86  2                           // V86 mode segment

typedef struct _TEMP_BP_NOTE {
    WORD    Seg;                            // Dest. Segment or Selector
    DWORD   Offset;                         // Dest. Offset
    BOOL    bPM;                            // TRUE for PM, FALSE for V86
} TEMP_BP_NOTE;

typedef struct _VDM_SEGINFO {
    WORD    Selector;                       // Selector or RM segment
    WORD    SegNumber;                      // Logical segment number in executable
    DWORD   Length;                         // Length of segment
    WORD    Type;                           // Type (0=v86, 1=PM)
    CHAR    ModuleName[MAX_MODULE_NAME];    // Module
    CHAR    FileName[MAX_PATH16];           // Path to executable image
} VDM_SEGINFO;

/* GlobalFirst()/GlobalNext() flags */
#define GLOBAL_ALL      0
#define GLOBAL_LRU      1
#define GLOBAL_FREE     2

/* GLOBALENTRY.wType entries */
#define GT_UNKNOWN      0
#define GT_DGROUP       1
#define GT_DATA         2
#define GT_CODE         3
#define GT_TASK         4
#define GT_RESOURCE     5
#define GT_MODULE       6
#define GT_FREE         7
#define GT_INTERNAL     8
#define GT_SENTINEL     9
#define GT_BURGERMASTER 10

/* If GLOBALENTRY.wType==GT_RESOURCE, the following is GLOBALENTRY.wData: */
#define GD_USERDEFINED      0
#define GD_CURSORCOMPONENT  1
#define GD_BITMAP           2
#define GD_ICONCOMPONENT    3
#define GD_MENU             4
#define GD_DIALOG           5
#define GD_STRING           6
#define GD_FONTDIR          7
#define GD_FONT             8
#define GD_ACCELERATORS     9
#define GD_RCDATA           10
#define GD_ERRTABLE         11
#define GD_CURSOR           12
#define GD_ICON             14
#define GD_NAMETABLE        15
#define GD_MAX_RESOURCE     15

typedef struct {
    DWORD   dwSize;
    DWORD   dwAddress;
    DWORD   dwBlockSize;
    HANDLE  hBlock;
    WORD    wcLock;
    WORD    wcPageLock;
    WORD    wFlags;
    BOOL    wHeapPresent;
    HANDLE  hOwner;
    WORD    wType;
    WORD    wData;
    DWORD   dwNext;
    DWORD   dwNextAlt;
} GLOBALENTRY, *LPGLOBALENTRY;

typedef DWORD (CALLBACK* DEBUGEVENTPROC)( LPDEBUG_EVENT, LPVOID );

// Macros to access VDM_EVENT parameters
#define W1(x) ((USHORT)(x.ExceptionInformation[0]))
#define W2(x) ((USHORT)(x.ExceptionInformation[0] >> 16))
#define W3(x) ((USHORT)(x.ExceptionInformation[1]))
#define W4(x) ((USHORT)(x.ExceptionInformation[1] >> 16))
#define DW3(x) (x.ExceptionInformation[2])
#define DW4(x) (x.ExceptionInformation[3])

#include <poppack.h>


BOOL
WINAPI
VDMProcessException(
    LPDEBUG_EVENT   lpDebugEvent
    );

BOOL
WINAPI
VDMGetThreadSelectorEntry(
    HANDLE          hProcess,
    HANDLE          hThread,
    WORD            wSelector,
    LPVDMLDT_ENTRY  lpSelectorEntry
    );

ULONG
WINAPI
VDMGetPointer(
    HANDLE          hProcess,
    HANDLE          hThread,
    WORD            wSelector,
    DWORD           dwOffset,
    BOOL            fProtMode
    );

// VDMGetThreadContext, VDMSetThreadContext are obselete
// Use VDMGetContext, VDMSetContext
BOOL
WINAPI
VDMGetContext(
    HANDLE          hProcess,
    HANDLE          hThread,
    LPVDMCONTEXT    lpVDMContext
);

BOOL
WINAPI
VDMSetContext(
    HANDLE          hProcess,
    HANDLE          hThread,
    LPVDMCONTEXT    lpVDMContext
);

BOOL
WINAPI
VDMGetSelectorModule(
    HANDLE          hProcess,
    HANDLE          hThread,
    WORD            wSelector,
    PUINT           lpSegmentNumber,
    __in LPSTR      lpModuleName,
    UINT            nNameSize,
    __in LPSTR      lpModulePath,
    UINT            nPathSize
);

BOOL
WINAPI
VDMGetModuleSelector(
    HANDLE          hProcess,
    HANDLE          hThread,
    UINT            wSegmentNumber,
    __in LPSTR      lpModuleName,
    LPWORD          lpSelector
);

BOOL
WINAPI
VDMModuleFirst(
    HANDLE          hProcess,
    HANDLE          hThread,
    LPMODULEENTRY   lpModuleEntry,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
);

BOOL
WINAPI
VDMModuleNext(
    HANDLE          hProcess,
    HANDLE          hThread,
    LPMODULEENTRY   lpModuleEntry,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
);

BOOL
WINAPI
VDMGlobalFirst(
    HANDLE          hProcess,
    HANDLE          hThread,
    LPGLOBALENTRY   lpGlobalEntry,
    WORD            wFlags,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
);

BOOL
WINAPI
VDMGlobalNext(
    HANDLE          hProcess,
    HANDLE          hThread,
    LPGLOBALENTRY   lpGlobalEntry,
    WORD            wFlags,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
);

typedef BOOL (WINAPI *PROCESSENUMPROC)( DWORD dwProcessId, DWORD dwAttributes, LPARAM lpUserDefined );
typedef BOOL (WINAPI *TASKENUMPROC)( DWORD dwThreadId, WORD hMod16, WORD hTask16, LPARAM lpUserDefined );
typedef BOOL (WINAPI *TASKENUMPROCEX)( DWORD dwThreadId, WORD hMod16, WORD hTask16,
                                       PSZ pszModName, PSZ pszFileName, LPARAM lpUserDefined );

#define WOW_SYSTEM  (DWORD)0x0001

INT
WINAPI
VDMEnumProcessWOW(
    PROCESSENUMPROC fp,
    LPARAM          lparam
);

INT
WINAPI
VDMEnumTaskWOW(
    DWORD           dwProcessId,
    TASKENUMPROC    fp,
    LPARAM          lparam
);

//
// VDMEnumTaskWOWEx is the same as VDMEnumTaskWOW except
// the callback procedure gets two more parameters,
// the module name of the EXE and the full path to the
// EXE.
//

INT
WINAPI
VDMEnumTaskWOWEx(
    DWORD           dwProcessId,
    TASKENUMPROCEX  fp,
    LPARAM          lparam
);

//
// VDMTerminateTaskWOW rudely terminates a 16-bit WOW task
// similar to the way TerminateProcess kills a Win32
// process.
//

BOOL
WINAPI
VDMTerminateTaskWOW(
    DWORD           dwProcessId,
    WORD            htask
);

//
// VDMStartTaskInWOW launches a Win16 task in a pre-existing
// WOW VDM.  Note that the caller is responsible for ensuring
// the program is a 16-bit Windows program.  If it is a DOS
// or Win32 program, it will still be launched from within
// the target WOW VDM.
//
// The supplied command line and show command are passed
// unchanged to the 16-bit WinExec API in the target WOW VDM.
//
// Note this routine is ANSI-only.
//

BOOL
WINAPI
VDMStartTaskInWOW(
    DWORD           dwProcessId,
    __in LPSTR      lpCommandLine,
    WORD            wShow
);

//
// VDMKillWOW is not implemented.
//

BOOL
WINAPI
VDMKillWOW(
    VOID
);

//
// VDMDetectWOW is not implemented.
//

BOOL
WINAPI
VDMDetectWOW(
    VOID
);

BOOL
WINAPI
VDMBreakThread(
    HANDLE          hProcess,
    HANDLE          hThread
);

DWORD
WINAPI
VDMGetDbgFlags(
    HANDLE          hProcess
    );

BOOL
WINAPI
VDMSetDbgFlags(
    HANDLE          hProcess,
    DWORD           dwFlags
    );

#define VDMDBG_BREAK_DOSTASK      0x00000001
#define VDMDBG_BREAK_WOWTASK      0x00000002
#define VDMDBG_BREAK_LOADDLL      0x00000004
#define VDMDBG_BREAK_EXCEPTIONS   0x00000008
#define VDMDBG_BREAK_DEBUGGER     0x00000010
#define VDMDBG_TRACE_HISTORY      0x00000080
#define VDMDBG_BREAK_DIVIDEBYZERO 0x00000100

#define VDMDBG_INITIAL_FLAGS      VDMDBG_BREAK_DIVIDEBYZERO

//
// VDMIsModuleLoaded can be used to determine if the 16-bit
// executable referenced by the full path name parameter is
// loaded in ntvdm.
//
// Note that this function uses an internal table in vdmdbg.dll
// to determine a module's existence. One important usage of this
// function is to print a message when a particular module is
// loaded for the first time. To accomplish this, call this
// routine during a DBG_SEGLOAD notification BEFORE the entry
// point VDMProcessException has been called. If it returns FALSE,
// then the module has not yet been loaded.
//
BOOL
WINAPI
VDMIsModuleLoaded(
    __in LPSTR szPath
    );

BOOL
WINAPI
VDMGetSegmentInfo(
    WORD Selector,
    ULONG Offset,
    BOOL bProtectMode,
    VDM_SEGINFO *pSegInfo
    );

//
// VDMGetSymbol
//
// This routine reads the standard .SYM file format.
//
// szModule         - module name (max 9 chars)
// SegNumber        - logical segment number of segment (see VDM_SEGINFO)
// Offset           - offset in segment
// bProtectMode     - TRUE for PM, FALSE for V86 mode
// bNextSymbol      - FALSE to find nearest sym BEFORE offset, TRUE for AFTER
// szSymbolName     - receives symbol name (must point to 256 byte buffer)
// pDisplacement    - distance in bytes from nearest symbol
//

BOOL
WINAPI
VDMGetSymbol(
    __in LPSTR szModule,
    WORD SegNumber,
    DWORD Offset,
    BOOL bProtectMode,
    BOOL bNextSymbol,
    __out LPSTR szSymbolName,
    PDWORD pDisplacement
    );

BOOL
WINAPI
VDMGetAddrExpression(
    __in LPSTR  szModule,
    __in LPSTR  szSymbol,
    PWORD  Selector,
    PDWORD Offset,
    PWORD  Type
    );

#define VDMADDR_V86     2
#define VDMADDR_PM16    4
#define VDMADDR_PM32   16

//
// typedefs for main entry points
//

typedef BOOL  (WINAPI *VDMPROCESSEXCEPTIONPROC)(LPDEBUG_EVENT);
typedef BOOL  (WINAPI *VDMGETTHREADSELECTORENTRYPROC)(HANDLE,HANDLE,DWORD,LPVDMLDT_ENTRY);
typedef ULONG (WINAPI *VDMGETPOINTERPROC)(HANDLE,HANDLE,WORD,DWORD,BOOL);
typedef BOOL  (WINAPI *VDMGETCONTEXTPROC)(HANDLE,HANDLE,LPVDMCONTEXT);
typedef BOOL  (WINAPI *VDMSETCONTEXTPROC)(HANDLE,HANDLE,LPVDMCONTEXT);
typedef BOOL  (WINAPI *VDMKILLWOWPROC)(VOID);
typedef BOOL  (WINAPI *VDMDETECTWOWPROC)(VOID);
typedef BOOL  (WINAPI *VDMBREAKTHREADPROC)(HANDLE);
typedef BOOL  (WINAPI *VDMGETSELECTORMODULEPROC)(HANDLE,HANDLE,WORD,PUINT,LPSTR, UINT,LPSTR, UINT);
typedef BOOL  (WINAPI *VDMGETMODULESELECTORPROC)(HANDLE,HANDLE,UINT,LPSTR,LPWORD);
typedef BOOL  (WINAPI *VDMMODULEFIRSTPROC)(HANDLE,HANDLE,LPMODULEENTRY,DEBUGEVENTPROC,LPVOID);
typedef BOOL  (WINAPI *VDMMODULENEXTPROC)(HANDLE,HANDLE,LPMODULEENTRY,DEBUGEVENTPROC,LPVOID);
typedef BOOL  (WINAPI *VDMGLOBALFIRSTPROC)(HANDLE,HANDLE,LPGLOBALENTRY,WORD,DEBUGEVENTPROC,LPVOID);
typedef BOOL  (WINAPI *VDMGLOBALNEXTPROC)(HANDLE,HANDLE,LPGLOBALENTRY,WORD,DEBUGEVENTPROC,LPVOID);

typedef INT   (WINAPI *VDMENUMPROCESSWOWPROC)(PROCESSENUMPROC,LPARAM);
typedef INT   (WINAPI *VDMENUMTASKWOWPROC)(DWORD,TASKENUMPROC,LPARAM);
typedef INT   (WINAPI *VDMENUMTASKWOWEXPROC)(DWORD,TASKENUMPROCEX,LPARAM);
typedef BOOL  (WINAPI *VDMTERMINATETASKINWOWPROC)(DWORD,WORD);
typedef BOOL  (WINAPI *VDMSTARTTASKINWOWPROC)(DWORD,LPSTR,WORD);

typedef DWORD (WINAPI *VDMGETDBGFLAGSPROC)(HANDLE);
typedef BOOL  (WINAPI *VDMSETDBGFLAGSPROC)(HANDLE,DWORD);
typedef BOOL  (WINAPI *VDMISMODULELOADEDPROC)(LPSTR);
typedef BOOL  (WINAPI *VDMGETSEGMENTINFOPROC)(WORD,ULONG,BOOL,VDM_SEGINFO);
typedef BOOL  (WINAPI *VDMGETSYMBOLPROC)(LPSTR, WORD, DWORD, BOOL, BOOL, LPSTR, PDWORD);
typedef BOOL  (WINAPI *VDMGETADDREXPRESSIONPROC)(LPSTR, LPSTR, PWORD, PDWORD, PWORD);


#ifdef __cplusplus
}
#endif

#endif // _VDMDBG_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\vdslun.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for vdslun.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __vdslun_h__
#define __vdslun_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_vdslun_0000_0000 */
/* [local] */ 

typedef 
enum _VDS_STORAGE_IDENTIFIER_CODE_SET
    {	VDSStorageIdCodeSetReserved	= 0,
	VDSStorageIdCodeSetBinary	= 1,
	VDSStorageIdCodeSetAscii	= 2,
	VDSStorageIdCodeSetUtf8	= 3
    } 	VDS_STORAGE_IDENTIFIER_CODE_SET;

typedef 
enum _VDS_STORAGE_IDENTIFIER_TYPE
    {	VDSStorageIdTypeVendorSpecific	= 0,
	VDSStorageIdTypeVendorId	= 1,
	VDSStorageIdTypeEUI64	= 2,
	VDSStorageIdTypeFCPHName	= 3,
	VDSStorageIdTypePortRelative	= 4,
	VDSStorageIdTypeTargetPortGroup	= 5,
	VDSStorageIdTypeLogicalUnitGroup	= 6,
	VDSStorageIdTypeMD5LogicalUnitIdentifier	= 7,
	VDSStorageIdTypeScsiNameString	= 8
    } 	VDS_STORAGE_IDENTIFIER_TYPE;

typedef 
enum _VDS_STORAGE_BUS_TYPE
    {	VDSBusTypeUnknown	= 0,
	VDSBusTypeScsi	= 0x1,
	VDSBusTypeAtapi	= 0x2,
	VDSBusTypeAta	= 0x3,
	VDSBusType1394	= 0x4,
	VDSBusTypeSsa	= 0x5,
	VDSBusTypeFibre	= 0x6,
	VDSBusTypeUsb	= 0x7,
	VDSBusTypeRAID	= 0x8,
	VDSBusTypeiScsi	= 0x9,
	VDSBusTypeSas	= 0xa,
	VDSBusTypeSata	= 0xb,
	VDSBusTypeSd	= 0xc,
	VDSBusTypeMmc	= 0xd,
	VDSBusTypeMax	= 0xe,
	VDSBusTypeFileBackedVirtual	= 0xf,
	VDSBusTypeMaxReserved	= 0x7f
    } 	VDS_STORAGE_BUS_TYPE;

typedef struct _VDS_STORAGE_IDENTIFIER
    {
    VDS_STORAGE_IDENTIFIER_CODE_SET m_CodeSet;
    VDS_STORAGE_IDENTIFIER_TYPE m_Type;
    ULONG m_cbIdentifier;
    BYTE *m_rgbIdentifier;
    } 	VDS_STORAGE_IDENTIFIER;

typedef struct _VDS_STORAGE_DEVICE_ID_DESCRIPTOR
    {
    ULONG m_version;
    ULONG m_cIdentifiers;
    VDS_STORAGE_IDENTIFIER *m_rgIdentifiers;
    } 	VDS_STORAGE_DEVICE_ID_DESCRIPTOR;

typedef 
enum _VDS_INTERCONNECT_ADDRESS_TYPE
    {	VDS_IA_UNKNOWN	= 0,
	VDS_IA_FCFS	= 1,
	VDS_IA_FCPH	= 2,
	VDS_IA_FCPH3	= 3,
	VDS_IA_MAC	= 4,
	VDS_IA_SCSI	= 5
    } 	VDS_INTERCONNECT_ADDRESS_TYPE;

typedef struct _VDS_INTERCONNECT
    {
    VDS_INTERCONNECT_ADDRESS_TYPE m_addressType;
    ULONG m_cbPort;
    BYTE *m_pbPort;
    ULONG m_cbAddress;
    BYTE *m_pbAddress;
    } 	VDS_INTERCONNECT;

typedef struct _VDS_LUN_INFORMATION
    {
    ULONG m_version;
    BYTE m_DeviceType;
    BYTE m_DeviceTypeModifier;
    BOOL m_bCommandQueueing;
    VDS_STORAGE_BUS_TYPE m_BusType;
    char *m_szVendorId;
    char *m_szProductId;
    char *m_szProductRevision;
    char *m_szSerialNumber;
    GUID m_diskSignature;
    VDS_STORAGE_DEVICE_ID_DESCRIPTOR m_deviceIdDescriptor;
    ULONG m_cInterconnects;
    VDS_INTERCONNECT *m_rgInterconnects;
    } 	VDS_LUN_INFORMATION;

#define	VER_VDS_LUN_INFORMATION	( 1 )



extern RPC_IF_HANDLE __MIDL_itf_vdslun_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vdslun_0000_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\vds.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for vds.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __vds_h__
#define __vds_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IEnumVdsObject_FWD_DEFINED__
#define __IEnumVdsObject_FWD_DEFINED__
typedef interface IEnumVdsObject IEnumVdsObject;
#endif 	/* __IEnumVdsObject_FWD_DEFINED__ */


#ifndef __IVdsAsync_FWD_DEFINED__
#define __IVdsAsync_FWD_DEFINED__
typedef interface IVdsAsync IVdsAsync;
#endif 	/* __IVdsAsync_FWD_DEFINED__ */


#ifndef __IVdsAdviseSink_FWD_DEFINED__
#define __IVdsAdviseSink_FWD_DEFINED__
typedef interface IVdsAdviseSink IVdsAdviseSink;
#endif 	/* __IVdsAdviseSink_FWD_DEFINED__ */


#ifndef __IVdsProvider_FWD_DEFINED__
#define __IVdsProvider_FWD_DEFINED__
typedef interface IVdsProvider IVdsProvider;
#endif 	/* __IVdsProvider_FWD_DEFINED__ */


#ifndef __IVdsProviderSupport_FWD_DEFINED__
#define __IVdsProviderSupport_FWD_DEFINED__
typedef interface IVdsProviderSupport IVdsProviderSupport;
#endif 	/* __IVdsProviderSupport_FWD_DEFINED__ */


#ifndef __IVdsSwProvider_FWD_DEFINED__
#define __IVdsSwProvider_FWD_DEFINED__
typedef interface IVdsSwProvider IVdsSwProvider;
#endif 	/* __IVdsSwProvider_FWD_DEFINED__ */


#ifndef __IVdsPack_FWD_DEFINED__
#define __IVdsPack_FWD_DEFINED__
typedef interface IVdsPack IVdsPack;
#endif 	/* __IVdsPack_FWD_DEFINED__ */


#ifndef __IVdsPack2_FWD_DEFINED__
#define __IVdsPack2_FWD_DEFINED__
typedef interface IVdsPack2 IVdsPack2;
#endif 	/* __IVdsPack2_FWD_DEFINED__ */


#ifndef __IVdsDisk_FWD_DEFINED__
#define __IVdsDisk_FWD_DEFINED__
typedef interface IVdsDisk IVdsDisk;
#endif 	/* __IVdsDisk_FWD_DEFINED__ */


#ifndef __IVdsDisk2_FWD_DEFINED__
#define __IVdsDisk2_FWD_DEFINED__
typedef interface IVdsDisk2 IVdsDisk2;
#endif 	/* __IVdsDisk2_FWD_DEFINED__ */


#ifndef __IVdsDiskOnline_FWD_DEFINED__
#define __IVdsDiskOnline_FWD_DEFINED__
typedef interface IVdsDiskOnline IVdsDiskOnline;
#endif 	/* __IVdsDiskOnline_FWD_DEFINED__ */


#ifndef __IVdsAdvancedDisk_FWD_DEFINED__
#define __IVdsAdvancedDisk_FWD_DEFINED__
typedef interface IVdsAdvancedDisk IVdsAdvancedDisk;
#endif 	/* __IVdsAdvancedDisk_FWD_DEFINED__ */


#ifndef __IVdsAdvancedDisk2_FWD_DEFINED__
#define __IVdsAdvancedDisk2_FWD_DEFINED__
typedef interface IVdsAdvancedDisk2 IVdsAdvancedDisk2;
#endif 	/* __IVdsAdvancedDisk2_FWD_DEFINED__ */


#ifndef __IVdsCreatePartitionEx_FWD_DEFINED__
#define __IVdsCreatePartitionEx_FWD_DEFINED__
typedef interface IVdsCreatePartitionEx IVdsCreatePartitionEx;
#endif 	/* __IVdsCreatePartitionEx_FWD_DEFINED__ */


#ifndef __IVdsRemovable_FWD_DEFINED__
#define __IVdsRemovable_FWD_DEFINED__
typedef interface IVdsRemovable IVdsRemovable;
#endif 	/* __IVdsRemovable_FWD_DEFINED__ */


#ifndef __IVdsVolume_FWD_DEFINED__
#define __IVdsVolume_FWD_DEFINED__
typedef interface IVdsVolume IVdsVolume;
#endif 	/* __IVdsVolume_FWD_DEFINED__ */


#ifndef __IVdsVolume2_FWD_DEFINED__
#define __IVdsVolume2_FWD_DEFINED__
typedef interface IVdsVolume2 IVdsVolume2;
#endif 	/* __IVdsVolume2_FWD_DEFINED__ */


#ifndef __IVdsVolumeOnline_FWD_DEFINED__
#define __IVdsVolumeOnline_FWD_DEFINED__
typedef interface IVdsVolumeOnline IVdsVolumeOnline;
#endif 	/* __IVdsVolumeOnline_FWD_DEFINED__ */


#ifndef __IVdsVolumePlex_FWD_DEFINED__
#define __IVdsVolumePlex_FWD_DEFINED__
typedef interface IVdsVolumePlex IVdsVolumePlex;
#endif 	/* __IVdsVolumePlex_FWD_DEFINED__ */


#ifndef __IVdsDisk3_FWD_DEFINED__
#define __IVdsDisk3_FWD_DEFINED__
typedef interface IVdsDisk3 IVdsDisk3;
#endif 	/* __IVdsDisk3_FWD_DEFINED__ */


#ifndef __IVdsHwProvider_FWD_DEFINED__
#define __IVdsHwProvider_FWD_DEFINED__
typedef interface IVdsHwProvider IVdsHwProvider;
#endif 	/* __IVdsHwProvider_FWD_DEFINED__ */


#ifndef __IVdsHwProviderType_FWD_DEFINED__
#define __IVdsHwProviderType_FWD_DEFINED__
typedef interface IVdsHwProviderType IVdsHwProviderType;
#endif 	/* __IVdsHwProviderType_FWD_DEFINED__ */


#ifndef __IVdsHwProviderType2_FWD_DEFINED__
#define __IVdsHwProviderType2_FWD_DEFINED__
typedef interface IVdsHwProviderType2 IVdsHwProviderType2;
#endif 	/* __IVdsHwProviderType2_FWD_DEFINED__ */


#ifndef __IVdsHwProviderStoragePools_FWD_DEFINED__
#define __IVdsHwProviderStoragePools_FWD_DEFINED__
typedef interface IVdsHwProviderStoragePools IVdsHwProviderStoragePools;
#endif 	/* __IVdsHwProviderStoragePools_FWD_DEFINED__ */


#ifndef __IVdsSubSystem_FWD_DEFINED__
#define __IVdsSubSystem_FWD_DEFINED__
typedef interface IVdsSubSystem IVdsSubSystem;
#endif 	/* __IVdsSubSystem_FWD_DEFINED__ */


#ifndef __IVdsSubSystem2_FWD_DEFINED__
#define __IVdsSubSystem2_FWD_DEFINED__
typedef interface IVdsSubSystem2 IVdsSubSystem2;
#endif 	/* __IVdsSubSystem2_FWD_DEFINED__ */


#ifndef __IVdsSubSystemNaming_FWD_DEFINED__
#define __IVdsSubSystemNaming_FWD_DEFINED__
typedef interface IVdsSubSystemNaming IVdsSubSystemNaming;
#endif 	/* __IVdsSubSystemNaming_FWD_DEFINED__ */


#ifndef __IVdsSubSystemIscsi_FWD_DEFINED__
#define __IVdsSubSystemIscsi_FWD_DEFINED__
typedef interface IVdsSubSystemIscsi IVdsSubSystemIscsi;
#endif 	/* __IVdsSubSystemIscsi_FWD_DEFINED__ */


#ifndef __IVdsSubSystemInterconnect_FWD_DEFINED__
#define __IVdsSubSystemInterconnect_FWD_DEFINED__
typedef interface IVdsSubSystemInterconnect IVdsSubSystemInterconnect;
#endif 	/* __IVdsSubSystemInterconnect_FWD_DEFINED__ */


#ifndef __IVdsControllerPort_FWD_DEFINED__
#define __IVdsControllerPort_FWD_DEFINED__
typedef interface IVdsControllerPort IVdsControllerPort;
#endif 	/* __IVdsControllerPort_FWD_DEFINED__ */


#ifndef __IVdsController_FWD_DEFINED__
#define __IVdsController_FWD_DEFINED__
typedef interface IVdsController IVdsController;
#endif 	/* __IVdsController_FWD_DEFINED__ */


#ifndef __IVdsControllerControllerPort_FWD_DEFINED__
#define __IVdsControllerControllerPort_FWD_DEFINED__
typedef interface IVdsControllerControllerPort IVdsControllerControllerPort;
#endif 	/* __IVdsControllerControllerPort_FWD_DEFINED__ */


#ifndef __IVdsDrive_FWD_DEFINED__
#define __IVdsDrive_FWD_DEFINED__
typedef interface IVdsDrive IVdsDrive;
#endif 	/* __IVdsDrive_FWD_DEFINED__ */


#ifndef __IVdsDrive2_FWD_DEFINED__
#define __IVdsDrive2_FWD_DEFINED__
typedef interface IVdsDrive2 IVdsDrive2;
#endif 	/* __IVdsDrive2_FWD_DEFINED__ */


#ifndef __IVdsLun_FWD_DEFINED__
#define __IVdsLun_FWD_DEFINED__
typedef interface IVdsLun IVdsLun;
#endif 	/* __IVdsLun_FWD_DEFINED__ */


#ifndef __IVdsLun2_FWD_DEFINED__
#define __IVdsLun2_FWD_DEFINED__
typedef interface IVdsLun2 IVdsLun2;
#endif 	/* __IVdsLun2_FWD_DEFINED__ */


#ifndef __IVdsLunNaming_FWD_DEFINED__
#define __IVdsLunNaming_FWD_DEFINED__
typedef interface IVdsLunNaming IVdsLunNaming;
#endif 	/* __IVdsLunNaming_FWD_DEFINED__ */


#ifndef __IVdsLunNumber_FWD_DEFINED__
#define __IVdsLunNumber_FWD_DEFINED__
typedef interface IVdsLunNumber IVdsLunNumber;
#endif 	/* __IVdsLunNumber_FWD_DEFINED__ */


#ifndef __IVdsLunControllerPorts_FWD_DEFINED__
#define __IVdsLunControllerPorts_FWD_DEFINED__
typedef interface IVdsLunControllerPorts IVdsLunControllerPorts;
#endif 	/* __IVdsLunControllerPorts_FWD_DEFINED__ */


#ifndef __IVdsLunMpio_FWD_DEFINED__
#define __IVdsLunMpio_FWD_DEFINED__
typedef interface IVdsLunMpio IVdsLunMpio;
#endif 	/* __IVdsLunMpio_FWD_DEFINED__ */


#ifndef __IVdsLunIscsi_FWD_DEFINED__
#define __IVdsLunIscsi_FWD_DEFINED__
typedef interface IVdsLunIscsi IVdsLunIscsi;
#endif 	/* __IVdsLunIscsi_FWD_DEFINED__ */


#ifndef __IVdsLunPlex_FWD_DEFINED__
#define __IVdsLunPlex_FWD_DEFINED__
typedef interface IVdsLunPlex IVdsLunPlex;
#endif 	/* __IVdsLunPlex_FWD_DEFINED__ */


#ifndef __IVdsIscsiPortal_FWD_DEFINED__
#define __IVdsIscsiPortal_FWD_DEFINED__
typedef interface IVdsIscsiPortal IVdsIscsiPortal;
#endif 	/* __IVdsIscsiPortal_FWD_DEFINED__ */


#ifndef __IVdsIscsiTarget_FWD_DEFINED__
#define __IVdsIscsiTarget_FWD_DEFINED__
typedef interface IVdsIscsiTarget IVdsIscsiTarget;
#endif 	/* __IVdsIscsiTarget_FWD_DEFINED__ */


#ifndef __IVdsIscsiPortalGroup_FWD_DEFINED__
#define __IVdsIscsiPortalGroup_FWD_DEFINED__
typedef interface IVdsIscsiPortalGroup IVdsIscsiPortalGroup;
#endif 	/* __IVdsIscsiPortalGroup_FWD_DEFINED__ */


#ifndef __IVdsStoragePool_FWD_DEFINED__
#define __IVdsStoragePool_FWD_DEFINED__
typedef interface IVdsStoragePool IVdsStoragePool;
#endif 	/* __IVdsStoragePool_FWD_DEFINED__ */


#ifndef __IVdsMaintenance_FWD_DEFINED__
#define __IVdsMaintenance_FWD_DEFINED__
typedef interface IVdsMaintenance IVdsMaintenance;
#endif 	/* __IVdsMaintenance_FWD_DEFINED__ */


#ifndef __IVdsVdProvider_FWD_DEFINED__
#define __IVdsVdProvider_FWD_DEFINED__
typedef interface IVdsVdProvider IVdsVdProvider;
#endif 	/* __IVdsVdProvider_FWD_DEFINED__ */


#ifndef __IVdsVDisk_FWD_DEFINED__
#define __IVdsVDisk_FWD_DEFINED__
typedef interface IVdsVDisk IVdsVDisk;
#endif 	/* __IVdsVDisk_FWD_DEFINED__ */


#ifndef __IVdsOpenVDisk_FWD_DEFINED__
#define __IVdsOpenVDisk_FWD_DEFINED__
typedef interface IVdsOpenVDisk IVdsOpenVDisk;
#endif 	/* __IVdsOpenVDisk_FWD_DEFINED__ */


#ifndef __IVdsServiceLoader_FWD_DEFINED__
#define __IVdsServiceLoader_FWD_DEFINED__
typedef interface IVdsServiceLoader IVdsServiceLoader;
#endif 	/* __IVdsServiceLoader_FWD_DEFINED__ */


#ifndef __IVdsService_FWD_DEFINED__
#define __IVdsService_FWD_DEFINED__
typedef interface IVdsService IVdsService;
#endif 	/* __IVdsService_FWD_DEFINED__ */


#ifndef __IVdsServiceUninstallDisk_FWD_DEFINED__
#define __IVdsServiceUninstallDisk_FWD_DEFINED__
typedef interface IVdsServiceUninstallDisk IVdsServiceUninstallDisk;
#endif 	/* __IVdsServiceUninstallDisk_FWD_DEFINED__ */


#ifndef __IVdsServiceHba_FWD_DEFINED__
#define __IVdsServiceHba_FWD_DEFINED__
typedef interface IVdsServiceHba IVdsServiceHba;
#endif 	/* __IVdsServiceHba_FWD_DEFINED__ */


#ifndef __IVdsServiceIscsi_FWD_DEFINED__
#define __IVdsServiceIscsi_FWD_DEFINED__
typedef interface IVdsServiceIscsi IVdsServiceIscsi;
#endif 	/* __IVdsServiceIscsi_FWD_DEFINED__ */


#ifndef __IVdsServiceInitialization_FWD_DEFINED__
#define __IVdsServiceInitialization_FWD_DEFINED__
typedef interface IVdsServiceInitialization IVdsServiceInitialization;
#endif 	/* __IVdsServiceInitialization_FWD_DEFINED__ */


#ifndef __IVdsHbaPort_FWD_DEFINED__
#define __IVdsHbaPort_FWD_DEFINED__
typedef interface IVdsHbaPort IVdsHbaPort;
#endif 	/* __IVdsHbaPort_FWD_DEFINED__ */


#ifndef __IVdsIscsiInitiatorAdapter_FWD_DEFINED__
#define __IVdsIscsiInitiatorAdapter_FWD_DEFINED__
typedef interface IVdsIscsiInitiatorAdapter IVdsIscsiInitiatorAdapter;
#endif 	/* __IVdsIscsiInitiatorAdapter_FWD_DEFINED__ */


#ifndef __IVdsIscsiInitiatorPortal_FWD_DEFINED__
#define __IVdsIscsiInitiatorPortal_FWD_DEFINED__
typedef interface IVdsIscsiInitiatorPortal IVdsIscsiInitiatorPortal;
#endif 	/* __IVdsIscsiInitiatorPortal_FWD_DEFINED__ */


#ifndef __IVdsDiskPartitionMF_FWD_DEFINED__
#define __IVdsDiskPartitionMF_FWD_DEFINED__
typedef interface IVdsDiskPartitionMF IVdsDiskPartitionMF;
#endif 	/* __IVdsDiskPartitionMF_FWD_DEFINED__ */


#ifndef __IVdsVolumeMF_FWD_DEFINED__
#define __IVdsVolumeMF_FWD_DEFINED__
typedef interface IVdsVolumeMF IVdsVolumeMF;
#endif 	/* __IVdsVolumeMF_FWD_DEFINED__ */


#ifndef __IVdsVolumeMF2_FWD_DEFINED__
#define __IVdsVolumeMF2_FWD_DEFINED__
typedef interface IVdsVolumeMF2 IVdsVolumeMF2;
#endif 	/* __IVdsVolumeMF2_FWD_DEFINED__ */


#ifndef __IVdsVolumeShrink_FWD_DEFINED__
#define __IVdsVolumeShrink_FWD_DEFINED__
typedef interface IVdsVolumeShrink IVdsVolumeShrink;
#endif 	/* __IVdsVolumeShrink_FWD_DEFINED__ */


#ifndef __IVdsSubSystemImportTarget_FWD_DEFINED__
#define __IVdsSubSystemImportTarget_FWD_DEFINED__
typedef interface IVdsSubSystemImportTarget IVdsSubSystemImportTarget;
#endif 	/* __IVdsSubSystemImportTarget_FWD_DEFINED__ */


#ifndef __IVdsIscsiPortalLocal_FWD_DEFINED__
#define __IVdsIscsiPortalLocal_FWD_DEFINED__
typedef interface IVdsIscsiPortalLocal IVdsIscsiPortalLocal;
#endif 	/* __IVdsIscsiPortalLocal_FWD_DEFINED__ */


#ifndef __IVdsServiceSAN_FWD_DEFINED__
#define __IVdsServiceSAN_FWD_DEFINED__
typedef interface IVdsServiceSAN IVdsServiceSAN;
#endif 	/* __IVdsServiceSAN_FWD_DEFINED__ */


#ifndef __IVdsVolumeMF3_FWD_DEFINED__
#define __IVdsVolumeMF3_FWD_DEFINED__
typedef interface IVdsVolumeMF3 IVdsVolumeMF3;
#endif 	/* __IVdsVolumeMF3_FWD_DEFINED__ */


#ifndef __IVdsDiskPartitionMF2_FWD_DEFINED__
#define __IVdsDiskPartitionMF2_FWD_DEFINED__
typedef interface IVdsDiskPartitionMF2 IVdsDiskPartitionMF2;
#endif 	/* __IVdsDiskPartitionMF2_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "vdssys.h"
#include "vdserr.h"
#include "vdslun.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_vds_0000_0000 */
/* [local] */ 

//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) 2008 Microsoft Corporation.
//
//---------------------------------------------------------------





typedef GUID VDS_OBJECT_ID;

typedef 
enum _VDS_OBJECT_TYPE
    {	VDS_OT_UNKNOWN	= 0,
	VDS_OT_PROVIDER	= 1,
	VDS_OT_PACK	= 10,
	VDS_OT_VOLUME	= 11,
	VDS_OT_VOLUME_PLEX	= 12,
	VDS_OT_DISK	= 13,
	VDS_OT_SUB_SYSTEM	= 30,
	VDS_OT_CONTROLLER	= 31,
	VDS_OT_DRIVE	= 32,
	VDS_OT_LUN	= 33,
	VDS_OT_LUN_PLEX	= 34,
	VDS_OT_PORT	= 35,
	VDS_OT_PORTAL	= 36,
	VDS_OT_TARGET	= 37,
	VDS_OT_PORTAL_GROUP	= 38,
	VDS_OT_STORAGE_POOL	= 39,
	VDS_OT_HBAPORT	= 90,
	VDS_OT_INIT_ADAPTER	= 91,
	VDS_OT_INIT_PORTAL	= 92,
	VDS_OT_ASYNC	= 100,
	VDS_OT_ENUM	= 101,
	VDS_OT_VDISK	= 200,
	VDS_OT_OPEN_VDISK	= 201
    } 	VDS_OBJECT_TYPE;

typedef 
enum _VDS_PROVIDER_TYPE
    {	VDS_PT_UNKNOWN	= 0,
	VDS_PT_SOFTWARE	= 1,
	VDS_PT_HARDWARE	= 2,
	VDS_PT_VIRTUALDISK	= 3,
	VDS_PT_MAX	= 4
    } 	VDS_PROVIDER_TYPE;

typedef 
enum _VDS_PROVIDER_FLAG
    {	VDS_PF_DYNAMIC	= 0x1,
	VDS_PF_INTERNAL_HARDWARE_PROVIDER	= 0x2,
	VDS_PF_ONE_DISK_ONLY_PER_PACK	= 0x4,
	VDS_PF_ONE_PACK_ONLINE_ONLY	= 0x8,
	VDS_PF_VOLUME_SPACE_MUST_BE_CONTIGUOUS	= 0x10,
	VDS_PF_SUPPORT_DYNAMIC	= 0x80000000,
	VDS_PF_SUPPORT_FAULT_TOLERANT	= 0x40000000,
	VDS_PF_SUPPORT_DYNAMIC_1394	= 0x20000000,
	VDS_PF_SUPPORT_MIRROR	= 0x20,
	VDS_PF_SUPPORT_RAID5	= 0x40
    } 	VDS_PROVIDER_FLAG;

typedef 
enum _VDS_RECOVER_ACTION
    {	VDS_RA_UNKNOWN	= 0,
	VDS_RA_REFRESH	= 1,
	VDS_RA_RESTART	= 2
    } 	VDS_RECOVER_ACTION;

typedef 
enum _VDS_NOTIFICATION_TARGET_TYPE
    {	VDS_NTT_UNKNOWN	= 0,
	VDS_NTT_PACK	= VDS_OT_PACK,
	VDS_NTT_VOLUME	= VDS_OT_VOLUME,
	VDS_NTT_DISK	= VDS_OT_DISK,
	VDS_NTT_PARTITION	= 60,
	VDS_NTT_DRIVE_LETTER	= 61,
	VDS_NTT_FILE_SYSTEM	= 62,
	VDS_NTT_MOUNT_POINT	= 63,
	VDS_NTT_SUB_SYSTEM	= VDS_OT_SUB_SYSTEM,
	VDS_NTT_CONTROLLER	= VDS_OT_CONTROLLER,
	VDS_NTT_DRIVE	= VDS_OT_DRIVE,
	VDS_NTT_LUN	= VDS_OT_LUN,
	VDS_NTT_PORT	= VDS_OT_PORT,
	VDS_NTT_PORTAL	= VDS_OT_PORTAL,
	VDS_NTT_TARGET	= VDS_OT_TARGET,
	VDS_NTT_PORTAL_GROUP	= VDS_OT_PORTAL_GROUP,
	VDS_NTT_SERVICE	= 200
    } 	VDS_NOTIFICATION_TARGET_TYPE;

#define	VDS_NF_PACK_ARRIVE	( 1 )

#define	VDS_NF_PACK_DEPART	( 2 )

#define	VDS_NF_PACK_MODIFY	( 3 )

#define	VDS_NF_VOLUME_ARRIVE	( 4 )

#define	VDS_NF_VOLUME_DEPART	( 5 )

#define	VDS_NF_VOLUME_MODIFY	( 6 )

#define	VDS_NF_VOLUME_REBUILDING_PROGRESS	( 7 )

#define	VDS_NF_DISK_ARRIVE	( 8 )

#define	VDS_NF_DISK_DEPART	( 9 )

#define	VDS_NF_DISK_MODIFY	( 10 )

#define	VDS_NF_PARTITION_ARRIVE	( 11 )

#define	VDS_NF_PARTITION_DEPART	( 12 )

#define	VDS_NF_PARTITION_MODIFY	( 13 )

#define	VDS_NF_SUB_SYSTEM_ARRIVE	( 101 )

#define	VDS_NF_SUB_SYSTEM_DEPART	( 102 )

#define	VDS_NF_CONTROLLER_ARRIVE	( 103 )

#define	VDS_NF_CONTROLLER_DEPART	( 104 )

#define	VDS_NF_DRIVE_ARRIVE	( 105 )

#define	VDS_NF_DRIVE_DEPART	( 106 )

#define	VDS_NF_DRIVE_MODIFY	( 107 )

#define	VDS_NF_LUN_ARRIVE	( 108 )

#define	VDS_NF_LUN_DEPART	( 109 )

#define	VDS_NF_LUN_MODIFY	( 110 )

#define	VDS_NF_PORT_ARRIVE	( 121 )

#define	VDS_NF_PORT_DEPART	( 122 )

#define	VDS_NF_PORTAL_ARRIVE	( 123 )

#define	VDS_NF_PORTAL_DEPART	( 124 )

#define	VDS_NF_PORTAL_MODIFY	( 125 )

#define	VDS_NF_TARGET_ARRIVE	( 126 )

#define	VDS_NF_TARGET_DEPART	( 127 )

#define	VDS_NF_TARGET_MODIFY	( 128 )

#define	VDS_NF_PORTAL_GROUP_ARRIVE	( 129 )

#define	VDS_NF_PORTAL_GROUP_DEPART	( 130 )

#define	VDS_NF_PORTAL_GROUP_MODIFY	( 131 )

#define	VDS_NF_SUB_SYSTEM_MODIFY	( 151 )

#define	VDS_NF_DRIVE_LETTER_FREE	( 201 )

#define	VDS_NF_DRIVE_LETTER_ASSIGN	( 202 )

#define	VDS_NF_FILE_SYSTEM_MODIFY	( 203 )

#define	VDS_NF_FILE_SYSTEM_FORMAT_PROGRESS	( 204 )

#define	VDS_NF_MOUNT_POINTS_CHANGE	( 205 )

#define	VDS_NF_FILE_SYSTEM_SHRINKING_PROGRESS	( 206 )

#define	VDS_NF_SERVICE_OUT_OF_SYNC	( 301 )

#define	VDS_NF_CONTROLLER_MODIFY	( 350 )

#define	VDS_NF_CONTROLLER_REMOVED	( 351 )

#define	VDS_NF_PORT_MODIFY	( 352 )

#define	VDS_NF_PORT_REMOVED	( 353 )

#define	VDS_NF_DRIVE_REMOVED	( 354 )

typedef struct _VDS_PACK_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID packId;
    } 	VDS_PACK_NOTIFICATION;

typedef struct _VDS_DISK_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID diskId;
    } 	VDS_DISK_NOTIFICATION;

typedef struct _VDS_VOLUME_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID volumeId;
    VDS_OBJECT_ID plexId;
    ULONG ulPercentCompleted;
    } 	VDS_VOLUME_NOTIFICATION;

typedef struct _VDS_PARTITION_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID diskId;
    ULONGLONG ullOffset;
    } 	VDS_PARTITION_NOTIFICATION;

typedef struct _VDS_SERVICE_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_RECOVER_ACTION action;
    } 	VDS_SERVICE_NOTIFICATION;

typedef struct _VDS_DRIVE_LETTER_NOTIFICATION
    {
    ULONG ulEvent;
    WCHAR wcLetter;
    VDS_OBJECT_ID volumeId;
    } 	VDS_DRIVE_LETTER_NOTIFICATION;

typedef struct _VDS_FILE_SYSTEM_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID volumeId;
    DWORD dwPercentCompleted;
    } 	VDS_FILE_SYSTEM_NOTIFICATION;

typedef struct _VDS_MOUNT_POINT_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID volumeId;
    } 	VDS_MOUNT_POINT_NOTIFICATION;

typedef struct _VDS_SUB_SYSTEM_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID subSystemId;
    } 	VDS_SUB_SYSTEM_NOTIFICATION;

typedef struct _VDS_CONTROLLER_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID controllerId;
    } 	VDS_CONTROLLER_NOTIFICATION;

typedef struct _VDS_DRIVE_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID driveId;
    } 	VDS_DRIVE_NOTIFICATION;

typedef struct _VDS_LUN_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID LunId;
    } 	VDS_LUN_NOTIFICATION;

typedef struct _VDS_PORT_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID portId;
    } 	VDS_PORT_NOTIFICATION;

typedef struct _VDS_PORTAL_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID portalId;
    } 	VDS_PORTAL_NOTIFICATION;

typedef struct _VDS_TARGET_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID targetId;
    } 	VDS_TARGET_NOTIFICATION;

typedef struct _VDS_PORTAL_GROUP_NOTIFICATION
    {
    ULONG ulEvent;
    VDS_OBJECT_ID portalGroupId;
    } 	VDS_PORTAL_GROUP_NOTIFICATION;

typedef struct _VDS_NOTIFICATION
    {
    VDS_NOTIFICATION_TARGET_TYPE objectType;
    /* [switch_type] */ union 
        {
        VDS_PACK_NOTIFICATION Pack;
        VDS_DISK_NOTIFICATION Disk;
        VDS_VOLUME_NOTIFICATION Volume;
        VDS_PARTITION_NOTIFICATION Partition;
        VDS_DRIVE_LETTER_NOTIFICATION Letter;
        VDS_FILE_SYSTEM_NOTIFICATION FileSystem;
        VDS_MOUNT_POINT_NOTIFICATION MountPoint;
        VDS_SUB_SYSTEM_NOTIFICATION SubSystem;
        VDS_CONTROLLER_NOTIFICATION Controller;
        VDS_DRIVE_NOTIFICATION Drive;
        VDS_LUN_NOTIFICATION Lun;
        VDS_PORT_NOTIFICATION Port;
        VDS_PORTAL_NOTIFICATION Portal;
        VDS_TARGET_NOTIFICATION Target;
        VDS_PORTAL_GROUP_NOTIFICATION PortalGroup;
        VDS_SERVICE_NOTIFICATION Service;
         /* Empty union arm */ 
        } 	;
    } 	VDS_NOTIFICATION;

typedef 
enum _VDS_ASYNC_OUTPUT_TYPE
    {	VDS_ASYNCOUT_UNKNOWN	= 0,
	VDS_ASYNCOUT_CREATEVOLUME	= 1,
	VDS_ASYNCOUT_EXTENDVOLUME	= 2,
	VDS_ASYNCOUT_SHRINKVOLUME	= 3,
	VDS_ASYNCOUT_ADDVOLUMEPLEX	= 4,
	VDS_ASYNCOUT_BREAKVOLUMEPLEX	= 5,
	VDS_ASYNCOUT_REMOVEVOLUMEPLEX	= 6,
	VDS_ASYNCOUT_REPAIRVOLUMEPLEX	= 7,
	VDS_ASYNCOUT_RECOVERPACK	= 8,
	VDS_ASYNCOUT_REPLACEDISK	= 9,
	VDS_ASYNCOUT_CREATEPARTITION	= 10,
	VDS_ASYNCOUT_CLEAN	= 11,
	VDS_ASYNCOUT_CREATELUN	= 50,
	VDS_ASYNCOUT_ADDLUNPLEX	= 52,
	VDS_ASYNCOUT_REMOVELUNPLEX	= 53,
	VDS_ASYNCOUT_EXTENDLUN	= 54,
	VDS_ASYNCOUT_SHRINKLUN	= 55,
	VDS_ASYNCOUT_RECOVERLUN	= 56,
	VDS_ASYNCOUT_LOGINTOTARGET	= 60,
	VDS_ASYNCOUT_LOGOUTFROMTARGET	= 61,
	VDS_ASYNCOUT_CREATETARGET	= 62,
	VDS_ASYNCOUT_CREATEPORTALGROUP	= 63,
	VDS_ASYNCOUT_DELETETARGET	= 64,
	VDS_ASYNCOUT_ADDPORTAL	= 65,
	VDS_ASYNCOUT_REMOVEPORTAL	= 66,
	VDS_ASYNCOUT_DELETEPORTALGROUP	= 67,
	VDS_ASYNCOUT_FORMAT	= 101,
	VDS_ASYNCOUT_CREATE_VDISK	= 200,
	VDS_ASYNCOUT_ATTACH_VDISK	= 201,
	VDS_ASYNCOUT_COMPACT_VDISK	= 202,
	VDS_ASYNCOUT_MERGE_VDISK	= 203,
	VDS_ASYNCOUT_EXPAND_VDISK	= 204
    } 	VDS_ASYNC_OUTPUT_TYPE;

typedef struct _VDS_ASYNC_OUTPUT
    {
    VDS_ASYNC_OUTPUT_TYPE type;
    /* [switch_type] */ union 
        {
        struct _cp
            {
            ULONGLONG ullOffset;
            VDS_OBJECT_ID volumeId;
            } 	cp;
        struct _cv
            {
            IUnknown *pVolumeUnk;
            } 	cv;
        struct _bvp
            {
            IUnknown *pVolumeUnk;
            } 	bvp;
        struct _sv
            {
            ULONGLONG ullReclaimedBytes;
            } 	sv;
        struct _cl
            {
            IUnknown *pLunUnk;
            } 	cl;
        struct _ct
            {
            IUnknown *pTargetUnk;
            } 	ct;
        struct _cpg
            {
            IUnknown *pPortalGroupUnk;
            } 	cpg;
        struct _cvd
            {
            IUnknown *pVDiskUnk;
            } 	cvd;
         /* Empty union arm */ 
        } 	;
    } 	VDS_ASYNC_OUTPUT;

typedef USHORT VDS_ISCSI_PORTALGROUP_TAG;

typedef 
enum VDS_IPADDRESS_TYPE
    {	VDS_IPT_TEXT	= 0,
	VDS_IPT_IPV4	= 1,
	VDS_IPT_IPV6	= 2,
	VDS_IPT_EMPTY	= 3
    } 	VDS_IPADDRESS_TYPE;

typedef 
enum _VDS_HEALTH
    {	VDS_H_UNKNOWN	= 0,
	VDS_H_HEALTHY	= 1,
	VDS_H_REBUILDING	= 2,
	VDS_H_STALE	= 3,
	VDS_H_FAILING	= 4,
	VDS_H_FAILING_REDUNDANCY	= 5,
	VDS_H_FAILED_REDUNDANCY	= 6,
	VDS_H_FAILED_REDUNDANCY_FAILING	= 7,
	VDS_H_FAILED	= 8,
	VDS_H_REPLACED	= 9,
	VDS_H_PENDING_FAILURE	= 10,
	VDS_H_DEGRADED	= 11
    } 	VDS_HEALTH;

typedef 
enum _VDS_TRANSITION_STATE
    {	VDS_TS_UNKNOWN	= 0,
	VDS_TS_STABLE	= 1,
	VDS_TS_EXTENDING	= 2,
	VDS_TS_SHRINKING	= 3,
	VDS_TS_RECONFIGING	= 4,
	VDS_TS_RESTRIPING	= 5
    } 	VDS_TRANSITION_STATE;

typedef 
enum _VDS_FILE_SYSTEM_TYPE
    {	VDS_FST_UNKNOWN	= 0,
	VDS_FST_RAW	= ( VDS_FST_UNKNOWN + 1 ) ,
	VDS_FST_FAT	= ( VDS_FST_RAW + 1 ) ,
	VDS_FST_FAT32	= ( VDS_FST_FAT + 1 ) ,
	VDS_FST_NTFS	= ( VDS_FST_FAT32 + 1 ) ,
	VDS_FST_CDFS	= ( VDS_FST_NTFS + 1 ) ,
	VDS_FST_UDF	= ( VDS_FST_CDFS + 1 ) ,
	VDS_FST_EXFAT	= ( VDS_FST_UDF + 1 ) 
    } 	VDS_FILE_SYSTEM_TYPE;

typedef 
enum _VDS_HBAPORT_TYPE
    {	VDS_HPT_UNKNOWN	= 1,
	VDS_HPT_OTHER	= 2,
	VDS_HPT_NOTPRESENT	= 3,
	VDS_HPT_NPORT	= 5,
	VDS_HPT_NLPORT	= 6,
	VDS_HPT_FLPORT	= 7,
	VDS_HPT_FPORT	= 8,
	VDS_HPT_EPORT	= 9,
	VDS_HPT_GPORT	= 10,
	VDS_HPT_LPORT	= 20,
	VDS_HPT_PTP	= 21
    } 	VDS_HBAPORT_TYPE;

typedef 
enum _VDS_HBAPORT_STATUS
    {	VDS_HPS_UNKNOWN	= 1,
	VDS_HPS_ONLINE	= 2,
	VDS_HPS_OFFLINE	= 3,
	VDS_HPS_BYPASSED	= 4,
	VDS_HPS_DIAGNOSTICS	= 5,
	VDS_HPS_LINKDOWN	= 6,
	VDS_HPS_ERROR	= 7,
	VDS_HPS_LOOPBACK	= 8
    } 	VDS_HBAPORT_STATUS;

typedef 
enum _VDS_HBAPORT_SPEED_FLAG
    {	VDS_HSF_UNKNOWN	= 0,
	VDS_HSF_1GBIT	= 0x1,
	VDS_HSF_2GBIT	= 0x2,
	VDS_HSF_10GBIT	= 0x4,
	VDS_HSF_4GBIT	= 0x8,
	VDS_HSF_NOT_NEGOTIATED	= ( 1 << 15 ) 
    } 	VDS_HBAPORT_SPEED_FLAG;

typedef 
enum _VDS_PATH_STATUS
    {	VDS_MPS_UNKNOWN	= 0,
	VDS_MPS_ONLINE	= 1,
	VDS_MPS_FAILED	= 5,
	VDS_MPS_STANDBY	= 7
    } 	VDS_PATH_STATUS;

typedef 
enum _VDS_LOADBALANCE_POLICY_ENUM
    {	VDS_LBP_UNKNOWN	= 0,
	VDS_LBP_FAILOVER	= 1,
	VDS_LBP_ROUND_ROBIN	= 2,
	VDS_LBP_ROUND_ROBIN_WITH_SUBSET	= 3,
	VDS_LBP_DYN_LEAST_QUEUE_DEPTH	= 4,
	VDS_LBP_WEIGHTED_PATHS	= 5,
	VDS_LBP_LEAST_BLOCKS	= 6,
	VDS_LBP_VENDOR_SPECIFIC	= 7
    } 	VDS_LOADBALANCE_POLICY_ENUM;

typedef 
enum _VDS_PROVIDER_LBSUPPORT_FLAG
    {	VDS_LBF_FAILOVER	= 0x1,
	VDS_LBF_ROUND_ROBIN	= 0x2,
	VDS_LBF_ROUND_ROBIN_WITH_SUBSET	= 0x4,
	VDS_LBF_DYN_LEAST_QUEUE_DEPTH	= 0x8,
	VDS_LBF_WEIGHTED_PATHS	= 0x10,
	VDS_LBF_LEAST_BLOCKS	= 0x20,
	VDS_LBF_VENDOR_SPECIFIC	= 0x40
    } 	VDS_PROVIDER_LBSUPPORT_FLAG;

typedef 
enum _VDS_VERSION_SUPPORT_FLAG
    {	VDS_VSF_1_0	= 0x1,
	VDS_VSF_1_1	= 0x2,
	VDS_VSF_2_0	= 0x4,
	VDS_VSF_2_1	= 0x8,
	VDS_VSF_3_0	= 0x10
    } 	VDS_VERSION_SUPPORT_FLAG;

typedef 
enum _VDS_HWPROVIDER_TYPE
    {	VDS_HWT_UNKNOWN	= 0,
	VDS_HWT_PCI_RAID	= 1,
	VDS_HWT_FIBRE_CHANNEL	= 2,
	VDS_HWT_ISCSI	= 3,
	VDS_HWT_SAS	= 4,
	VDS_HWT_HYBRID	= 5
    } 	VDS_HWPROVIDER_TYPE;

typedef 
enum _VDS_ISCSI_LOGIN_TYPE
    {	VDS_ILT_MANUAL	= 0,
	VDS_ILT_PERSISTENT	= 1,
	VDS_ILT_BOOT	= 2
    } 	VDS_ISCSI_LOGIN_TYPE;

typedef 
enum _VDS_ISCSI_AUTH_TYPE
    {	VDS_IAT_NONE	= 0,
	VDS_IAT_CHAP	= 1,
	VDS_IAT_MUTUAL_CHAP	= 2
    } 	VDS_ISCSI_AUTH_TYPE;

typedef 
enum _VDS_ISCSI_IPSEC_FLAG
    {	VDS_IIF_VALID	= 0x1,
	VDS_IIF_IKE	= 0x2,
	VDS_IIF_MAIN_MODE	= 0x4,
	VDS_IIF_AGGRESSIVE_MODE	= 0x8,
	VDS_IIF_PFS_ENABLE	= 0x10,
	VDS_IIF_TRANSPORT_MODE_PREFERRED	= 0x20,
	VDS_IIF_TUNNEL_MODE_PREFERRED	= 0x40
    } 	VDS_ISCSI_IPSEC_FLAG;

typedef 
enum _VDS_ISCSI_LOGIN_FLAG
    {	VDS_ILF_REQUIRE_IPSEC	= 0x1,
	VDS_ILF_MULTIPATH_ENABLED	= 0x2
    } 	VDS_ISCSI_LOGIN_FLAG;

typedef struct _VDS_PATH_ID
    {
    ULONGLONG ullSourceId;
    ULONGLONG ullPathId;
    } 	VDS_PATH_ID;

typedef struct _VDS_WWN
    {
    UCHAR rguchWwn[ 8 ];
    } 	VDS_WWN;

typedef struct _VDS_IPADDRESS
    {
    VDS_IPADDRESS_TYPE type;
    ULONG ipv4Address;
    UCHAR ipv6Address[ 16 ];
    ULONG ulIpv6FlowInfo;
    ULONG ulIpv6ScopeId;
    WCHAR wszTextAddress[ 257 ];
    ULONG ulPort;
    } 	VDS_IPADDRESS;

typedef struct _VDS_ISCSI_IPSEC_KEY
    {
    UCHAR *pKey;
    ULONG ulKeySize;
    } 	VDS_ISCSI_IPSEC_KEY;

typedef struct _VDS_ISCSI_SHARED_SECRET
    {
    UCHAR *pSharedSecret;
    ULONG ulSharedSecretSize;
    } 	VDS_ISCSI_SHARED_SECRET;

typedef struct _VDS_HBAPORT_PROP
    {
    VDS_OBJECT_ID id;
    VDS_WWN wwnNode;
    VDS_WWN wwnPort;
    VDS_HBAPORT_TYPE type;
    VDS_HBAPORT_STATUS status;
    ULONG ulPortSpeed;
    ULONG ulSupportedPortSpeed;
    } 	VDS_HBAPORT_PROP;

typedef struct _VDS_ISCSI_INITIATOR_ADAPTER_PROP
    {
    VDS_OBJECT_ID id;
    LPWSTR pwszName;
    } 	VDS_ISCSI_INITIATOR_ADAPTER_PROP;

typedef struct _VDS_ISCSI_INITIATOR_PORTAL_PROP
    {
    VDS_OBJECT_ID id;
    VDS_IPADDRESS address;
    ULONG ulPortIndex;
    } 	VDS_ISCSI_INITIATOR_PORTAL_PROP;

typedef struct _VDS_PROVIDER_PROP
    {
    VDS_OBJECT_ID id;
    LPWSTR pwszName;
    GUID guidVersionId;
    LPWSTR pwszVersion;
    VDS_PROVIDER_TYPE type;
    ULONG ulFlags;
    ULONG ulStripeSizeFlags;
    SHORT sRebuildPriority;
    } 	VDS_PROVIDER_PROP;

typedef struct _VDS_PATH_INFO
    {
    VDS_PATH_ID pathId;
    VDS_HWPROVIDER_TYPE type;
    VDS_PATH_STATUS status;
    /* [switch_type] */ union 
        {
        VDS_OBJECT_ID controllerPortId;
        VDS_OBJECT_ID targetPortalId;
         /* Empty union arm */ 
        } 	;
    /* [switch_type] */ union 
        {
        VDS_OBJECT_ID hbaPortId;
        VDS_OBJECT_ID initiatorAdapterId;
         /* Empty union arm */ 
        } 	;
    /* [switch_type] */ union 
        {
        VDS_HBAPORT_PROP *pHbaPortProp;
        VDS_IPADDRESS *pInitiatorPortalIpAddr;
         /* Empty union arm */ 
        } 	;
    } 	VDS_PATH_INFO;

typedef struct _VDS_PATH_POLICY
    {
    VDS_PATH_ID pathId;
    BOOL bPrimaryPath;
    ULONG ulWeight;
    } 	VDS_PATH_POLICY;



extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0000_v0_0_s_ifspec;

#ifndef __IEnumVdsObject_INTERFACE_DEFINED__
#define __IEnumVdsObject_INTERFACE_DEFINED__

/* interface IEnumVdsObject */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumVdsObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("118610b7-8d94-4030-b5b8-500889788e4e")
    IEnumVdsObject : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pcFetched) IUnknown **ppObjectArray,
            /* [out] */ __RPC__out ULONG *pcFetched) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumVdsObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumVdsObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumVdsObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumVdsObject * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumVdsObject * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pcFetched) IUnknown **ppObjectArray,
            /* [out] */ __RPC__out ULONG *pcFetched);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumVdsObject * This,
            /* [in] */ ULONG celt);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumVdsObject * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumVdsObject * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        END_INTERFACE
    } IEnumVdsObjectVtbl;

    interface IEnumVdsObject
    {
        CONST_VTBL struct IEnumVdsObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumVdsObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumVdsObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumVdsObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumVdsObject_Next(This,celt,ppObjectArray,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppObjectArray,pcFetched) ) 

#define IEnumVdsObject_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumVdsObject_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumVdsObject_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumVdsObject_INTERFACE_DEFINED__ */


#ifndef __IVdsAsync_INTERFACE_DEFINED__
#define __IVdsAsync_INTERFACE_DEFINED__

/* interface IVdsAsync */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsAsync;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d5d23b6d-5a55-4492-9889-397a3c2d2dbc")
    IVdsAsync : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Wait( 
            /* [out] */ __RPC__out HRESULT *pHrResult,
            /* [out] */ __RPC__out VDS_ASYNC_OUTPUT *pAsyncOut) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryStatus( 
            /* [out] */ __RPC__out HRESULT *pHrResult,
            /* [out] */ __RPC__out ULONG *pulPercentCompleted) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsAsyncVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsAsync * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsAsync * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsAsync * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            __RPC__in IVdsAsync * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Wait )( 
            __RPC__in IVdsAsync * This,
            /* [out] */ __RPC__out HRESULT *pHrResult,
            /* [out] */ __RPC__out VDS_ASYNC_OUTPUT *pAsyncOut);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryStatus )( 
            __RPC__in IVdsAsync * This,
            /* [out] */ __RPC__out HRESULT *pHrResult,
            /* [out] */ __RPC__out ULONG *pulPercentCompleted);
        
        END_INTERFACE
    } IVdsAsyncVtbl;

    interface IVdsAsync
    {
        CONST_VTBL struct IVdsAsyncVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsAsync_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsAsync_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsAsync_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsAsync_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#define IVdsAsync_Wait(This,pHrResult,pAsyncOut)	\
    ( (This)->lpVtbl -> Wait(This,pHrResult,pAsyncOut) ) 

#define IVdsAsync_QueryStatus(This,pHrResult,pulPercentCompleted)	\
    ( (This)->lpVtbl -> QueryStatus(This,pHrResult,pulPercentCompleted) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsAsync_INTERFACE_DEFINED__ */


#ifndef __IVdsAdviseSink_INTERFACE_DEFINED__
#define __IVdsAdviseSink_INTERFACE_DEFINED__

/* interface IVdsAdviseSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsAdviseSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8326cd1d-cf59-4936-b786-5efc08798e25")
    IVdsAdviseSink : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnNotify( 
            /* [range][in] */ __RPC__in_range(1,100) LONG lNumberOfNotifications,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfNotifications) VDS_NOTIFICATION *pNotificationArray) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsAdviseSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsAdviseSink * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsAdviseSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsAdviseSink * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnNotify )( 
            __RPC__in IVdsAdviseSink * This,
            /* [range][in] */ __RPC__in_range(1,100) LONG lNumberOfNotifications,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfNotifications) VDS_NOTIFICATION *pNotificationArray);
        
        END_INTERFACE
    } IVdsAdviseSinkVtbl;

    interface IVdsAdviseSink
    {
        CONST_VTBL struct IVdsAdviseSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsAdviseSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsAdviseSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsAdviseSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsAdviseSink_OnNotify(This,lNumberOfNotifications,pNotificationArray)	\
    ( (This)->lpVtbl -> OnNotify(This,lNumberOfNotifications,pNotificationArray) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsAdviseSink_INTERFACE_DEFINED__ */


#ifndef __IVdsProvider_INTERFACE_DEFINED__
#define __IVdsProvider_INTERFACE_DEFINED__

/* interface IVdsProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("10c5e575-7984-4e81-a56b-431f5f92ae42")
    IVdsProvider : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_PROVIDER_PROP *pProviderProp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsProvider * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsProvider * This,
            /* [out] */ __RPC__out VDS_PROVIDER_PROP *pProviderProp);
        
        END_INTERFACE
    } IVdsProviderVtbl;

    interface IVdsProvider
    {
        CONST_VTBL struct IVdsProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsProvider_GetProperties(This,pProviderProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pProviderProp) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsProvider_INTERFACE_DEFINED__ */


#ifndef __IVdsProviderSupport_INTERFACE_DEFINED__
#define __IVdsProviderSupport_INTERFACE_DEFINED__

/* interface IVdsProviderSupport */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsProviderSupport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1732be13-e8f9-4a03-bfbc-5f616aa66ce1")
    IVdsProviderSupport : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVersionSupport( 
            /* [out] */ __RPC__out ULONG *ulVersionSupport) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsProviderSupportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsProviderSupport * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsProviderSupport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsProviderSupport * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetVersionSupport )( 
            __RPC__in IVdsProviderSupport * This,
            /* [out] */ __RPC__out ULONG *ulVersionSupport);
        
        END_INTERFACE
    } IVdsProviderSupportVtbl;

    interface IVdsProviderSupport
    {
        CONST_VTBL struct IVdsProviderSupportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsProviderSupport_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsProviderSupport_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsProviderSupport_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsProviderSupport_GetVersionSupport(This,ulVersionSupport)	\
    ( (This)->lpVtbl -> GetVersionSupport(This,ulVersionSupport) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsProviderSupport_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vds_0000_0005 */
/* [local] */ 
















typedef 
enum _VDS_PACK_STATUS
    {	VDS_PS_UNKNOWN	= 0,
	VDS_PS_ONLINE	= 1,
	VDS_PS_OFFLINE	= 4
    } 	VDS_PACK_STATUS;

typedef 
enum _VDS_PACK_FLAG
    {	VDS_PKF_FOREIGN	= 0x1,
	VDS_PKF_NOQUORUM	= 0x2,
	VDS_PKF_POLICY	= 0x4,
	VDS_PKF_CORRUPTED	= 0x8,
	VDS_PKF_ONLINE_ERROR	= 0x10
    } 	VDS_PACK_FLAG;

typedef 
enum _VDS_DISK_STATUS
    {	VDS_DS_UNKNOWN	= 0,
	VDS_DS_ONLINE	= 1,
	VDS_DS_NOT_READY	= 2,
	VDS_DS_NO_MEDIA	= 3,
	VDS_DS_FAILED	= 5,
	VDS_DS_MISSING	= 6,
	VDS_DS_OFFLINE	= 4
    } 	VDS_DISK_STATUS;

typedef 
enum _VDS_PARTITION_STYLE
    {	VDS_PST_UNKNOWN	= 0,
	VDS_PST_MBR	= 1,
	VDS_PST_GPT	= 2
    } 	VDS_PARTITION_STYLE;

typedef 
enum _VDS_DISK_FLAG
    {	VDS_DF_AUDIO_CD	= 0x1,
	VDS_DF_HOTSPARE	= 0x2,
	VDS_DF_RESERVE_CAPABLE	= 0x4,
	VDS_DF_MASKED	= 0x8,
	VDS_DF_STYLE_CONVERTIBLE	= 0x10,
	VDS_DF_CLUSTERED	= 0x20,
	VDS_DF_READ_ONLY	= 0x40,
	VDS_DF_SYSTEM_DISK	= 0x80,
	VDS_DF_BOOT_DISK	= 0x100,
	VDS_DF_PAGEFILE_DISK	= 0x200,
	VDS_DF_HIBERNATIONFILE_DISK	= 0x400,
	VDS_DF_CRASHDUMP_DISK	= 0x800,
	VDS_DF_HAS_ARC_PATH	= 0x1000,
	VDS_DF_DYNAMIC	= 0x2000,
	VDS_DF_BOOT_FROM_DISK	= 0x4000,
	VDS_DF_CURRENT_READ_ONLY	= 0x8000
    } 	VDS_DISK_FLAG;

typedef 
enum _VDS_PARTITION_FLAG
    {	VDS_PTF_SYSTEM	= 0x1
    } 	VDS_PARTITION_FLAG;

typedef 
enum _VDS_LUN_RESERVE_MODE
    {	VDS_LRM_NONE	= 0,
	VDS_LRM_EXCLUSIVE_RW	= 1,
	VDS_LRM_EXCLUSIVE_RO	= 2,
	VDS_LRM_SHARED_RO	= 3,
	VDS_LRM_SHARED_RW	= 4
    } 	VDS_LUN_RESERVE_MODE;

typedef 
enum _VDS_VOLUME_STATUS
    {	VDS_VS_UNKNOWN	= 0,
	VDS_VS_ONLINE	= 1,
	VDS_VS_NO_MEDIA	= 3,
	VDS_VS_FAILED	= 5,
	VDS_VS_OFFLINE	= 4
    } 	VDS_VOLUME_STATUS;

typedef 
enum _VDS_VOLUME_TYPE
    {	VDS_VT_UNKNOWN	= 0,
	VDS_VT_SIMPLE	= 10,
	VDS_VT_SPAN	= 11,
	VDS_VT_STRIPE	= 12,
	VDS_VT_MIRROR	= 13,
	VDS_VT_PARITY	= 14
    } 	VDS_VOLUME_TYPE;

typedef 
enum _VDS_VOLUME_FLAG
    {	VDS_VF_SYSTEM_VOLUME	= 0x1,
	VDS_VF_BOOT_VOLUME	= 0x2,
	VDS_VF_ACTIVE	= 0x4,
	VDS_VF_READONLY	= 0x8,
	VDS_VF_HIDDEN	= 0x10,
	VDS_VF_CAN_EXTEND	= 0x20,
	VDS_VF_CAN_SHRINK	= 0x40,
	VDS_VF_PAGEFILE	= 0x80,
	VDS_VF_HIBERNATION	= 0x100,
	VDS_VF_CRASHDUMP	= 0x200,
	VDS_VF_INSTALLABLE	= 0x400,
	VDS_VF_LBN_REMAP_ENABLED	= 0x800,
	VDS_VF_FORMATTING	= 0x1000,
	VDS_VF_NOT_FORMATTABLE	= 0x2000,
	VDS_VF_NTFS_NOT_SUPPORTED	= 0x4000,
	VDS_VF_FAT32_NOT_SUPPORTED	= 0x8000,
	VDS_VF_FAT_NOT_SUPPORTED	= 0x10000,
	VDS_VF_NO_DEFAULT_DRIVE_LETTER	= 0x20000,
	VDS_VF_PERMANENTLY_DISMOUNTED	= 0x40000,
	VDS_VF_PERMANENT_DISMOUNT_SUPPORTED	= 0x80000,
	VDS_VF_SHADOW_COPY	= 0x100000,
	VDS_VF_FVE_ENABLED	= 0x200000,
	VDS_VF_DIRTY	= 0x400000
    } 	VDS_VOLUME_FLAG;

typedef 
enum _VDS_VOLUME_PLEX_TYPE
    {	VDS_VPT_UNKNOWN	= 0,
	VDS_VPT_SIMPLE	= VDS_VT_SIMPLE,
	VDS_VPT_SPAN	= VDS_VT_SPAN,
	VDS_VPT_STRIPE	= VDS_VT_STRIPE,
	VDS_VPT_PARITY	= VDS_VT_PARITY
    } 	VDS_VOLUME_PLEX_TYPE;

typedef 
enum _VDS_VOLUME_PLEX_STATUS
    {	VDS_VPS_UNKNOWN	= 0,
	VDS_VPS_ONLINE	= 1,
	VDS_VPS_NO_MEDIA	= 3,
	VDS_VPS_FAILED	= 5
    } 	VDS_VOLUME_PLEX_STATUS;

typedef 
enum _VDS_DISK_EXTENT_TYPE
    {	VDS_DET_UNKNOWN	= 0,
	VDS_DET_FREE	= 1,
	VDS_DET_DATA	= 2,
	VDS_DET_OEM	= 3,
	VDS_DET_ESP	= 4,
	VDS_DET_MSR	= 5,
	VDS_DET_LDM	= 6,
	VDS_DET_CLUSTER	= 7,
	VDS_DET_UNUSABLE	= 0x7fff
    } 	VDS_DISK_EXTENT_TYPE;

typedef struct _VDS_PACK_PROP
    {
    VDS_OBJECT_ID id;
    LPWSTR pwszName;
    VDS_PACK_STATUS status;
    ULONG ulFlags;
    } 	VDS_PACK_PROP;

typedef struct _VDS_PACK_PROP *PVDS_PACK_PROP;

typedef struct _VDS_DISK_PROP
    {
    VDS_OBJECT_ID id;
    VDS_DISK_STATUS status;
    VDS_LUN_RESERVE_MODE ReserveMode;
    VDS_HEALTH health;
    DWORD dwDeviceType;
    DWORD dwMediaType;
    ULONGLONG ullSize;
    ULONG ulBytesPerSector;
    ULONG ulSectorsPerTrack;
    ULONG ulTracksPerCylinder;
    ULONG ulFlags;
    VDS_STORAGE_BUS_TYPE BusType;
    VDS_PARTITION_STYLE PartitionStyle;
    /* [switch_type] */ union 
        {
        DWORD dwSignature;
        GUID DiskGuid;
         /* Empty union arm */ 
        } 	;
    LPWSTR pwszDiskAddress;
    LPWSTR pwszName;
    LPWSTR pwszFriendlyName;
    LPWSTR pwszAdaptorName;
    LPWSTR pwszDevicePath;
    } 	VDS_DISK_PROP;

typedef struct _VDS_DISK_PROP *PVDS_DISK_PROP;

typedef 
enum _VDS_DISK_OFFLINE_REASON
    {	VDSDiskOfflineReasonNone	= 0,
	VDSDiskOfflineReasonPolicy	= 1,
	VDSDiskOfflineReasonRedundantPath	= 2,
	VDSDiskOfflineReasonSnapshot	= 3,
	VDSDiskOfflineReasonCollision	= 4
    } 	VDS_DISK_OFFLINE_REASON;

typedef struct _VDS_DISK_PROP2
    {
    VDS_OBJECT_ID id;
    VDS_DISK_STATUS status;
    VDS_DISK_OFFLINE_REASON OfflineReason;
    VDS_LUN_RESERVE_MODE ReserveMode;
    VDS_HEALTH health;
    DWORD dwDeviceType;
    DWORD dwMediaType;
    ULONGLONG ullSize;
    ULONG ulBytesPerSector;
    ULONG ulSectorsPerTrack;
    ULONG ulTracksPerCylinder;
    ULONG ulFlags;
    VDS_STORAGE_BUS_TYPE BusType;
    VDS_PARTITION_STYLE PartitionStyle;
    /* [switch_type] */ union 
        {
        DWORD dwSignature;
        GUID DiskGuid;
         /* Empty union arm */ 
        } 	;
    LPWSTR pwszDiskAddress;
    LPWSTR pwszName;
    LPWSTR pwszFriendlyName;
    LPWSTR pwszAdaptorName;
    LPWSTR pwszDevicePath;
    LPWSTR pwszLocationPath;
    } 	VDS_DISK_PROP2;

typedef struct _VDS_DISK_PROP2 *PVDS_DISK_PROP2;

typedef struct _VDS_VOLUME_PROP
    {
    VDS_OBJECT_ID id;
    VDS_VOLUME_TYPE type;
    VDS_VOLUME_STATUS status;
    VDS_HEALTH health;
    VDS_TRANSITION_STATE TransitionState;
    ULONGLONG ullSize;
    ULONG ulFlags;
    VDS_FILE_SYSTEM_TYPE RecommendedFileSystemType;
    LPWSTR pwszName;
    } 	VDS_VOLUME_PROP;

typedef struct _VDS_VOLUME_PROP *PVDS_VOLUME_PROP;

typedef struct _VDS_VOLUME_PROP2
    {
    VDS_OBJECT_ID id;
    VDS_VOLUME_TYPE type;
    VDS_VOLUME_STATUS status;
    VDS_HEALTH health;
    VDS_TRANSITION_STATE TransitionState;
    ULONGLONG ullSize;
    ULONG ulFlags;
    VDS_FILE_SYSTEM_TYPE RecommendedFileSystemType;
    ULONG cbUniqueId;
    LPWSTR pwszName;
    BYTE *pUniqueId;
    } 	VDS_VOLUME_PROP2;

typedef struct _VDS_VOLUME_PROP2 *PVDS_VOLUME_PROP2;

typedef struct _VDS_VOLUME_PLEX_PROP
    {
    VDS_OBJECT_ID id;
    VDS_VOLUME_PLEX_TYPE type;
    VDS_VOLUME_PLEX_STATUS status;
    VDS_HEALTH health;
    VDS_TRANSITION_STATE TransitionState;
    ULONGLONG ullSize;
    ULONG ulStripeSize;
    ULONG ulNumberOfMembers;
    } 	VDS_VOLUME_PLEX_PROP;

typedef struct _VDS_VOLUME_PLEX_PROP *PVDS_VOLUME_PLEX_PROP;

typedef struct _VDS_DISK_EXTENT
    {
    VDS_OBJECT_ID diskId;
    VDS_DISK_EXTENT_TYPE type;
    ULONGLONG ullOffset;
    ULONGLONG ullSize;
    VDS_OBJECT_ID volumeId;
    VDS_OBJECT_ID plexId;
    ULONG memberIdx;
    } 	VDS_DISK_EXTENT;

typedef struct _VDS_DISK_EXTENT *PVDS_DISK_EXTENT;

typedef struct _VDS_DISK_FREE_EXTENT
    {
    VDS_OBJECT_ID diskId;
    ULONGLONG ullOffset;
    ULONGLONG ullSize;
    } 	VDS_DISK_FREE_EXTENT;

typedef struct _VDS_DISK_FREE_EXTENT *PVDS_DISK_FREE_EXTENT;

typedef struct _VDS_INPUT_DISK
    {
    VDS_OBJECT_ID diskId;
    ULONGLONG ullSize;
    VDS_OBJECT_ID plexId;
    ULONG memberIdx;
    } 	VDS_INPUT_DISK;

#define GPT_PARTITION_NAME_LENGTH    36
typedef struct _VDS_PARTITION_INFO_GPT
    {
    GUID partitionType;
    GUID partitionId;
    ULONGLONG attributes;
    WCHAR name[ 36 ];
    } 	VDS_PARTITION_INFO_GPT;

typedef struct _VDS_PARTITION_INFO_MBR
    {
    BYTE partitionType;
    BOOLEAN bootIndicator;
    BOOLEAN recognizedPartition;
    DWORD hiddenSectors;
    } 	VDS_PARTITION_INFO_MBR;

typedef struct _VDS_PARTITION_PROP
    {
    VDS_PARTITION_STYLE PartitionStyle;
    ULONG ulFlags;
    ULONG ulPartitionNumber;
    ULONGLONG ullOffset;
    ULONGLONG ullSize;
    /* [switch_type] */ union 
        {
        VDS_PARTITION_INFO_MBR Mbr;
        VDS_PARTITION_INFO_GPT Gpt;
         /* Empty union arm */ 
        } 	;
    } 	VDS_PARTITION_PROP;

typedef 
enum tag_VDS_PARTITION_STYLE
    {	VDS_PARTITION_STYLE_MBR	= 0,
	VDS_PARTITION_STYLE_GPT	= ( VDS_PARTITION_STYLE_MBR + 1 ) ,
	VDS_PARTITION_STYLE_RAW	= ( VDS_PARTITION_STYLE_GPT + 1 ) 
    } 	__VDS_PARTITION_STYLE;

typedef struct _VDS_PARTITION_INFORMATION_EX
    {
    __VDS_PARTITION_STYLE dwPartitionStyle;
    ULONGLONG ullStartingOffset;
    ULONGLONG ullPartitionLength;
    DWORD dwPartitionNumber;
    BOOLEAN bRewritePartition;
    /* [switch_type] */ union 
        {
        VDS_PARTITION_INFO_MBR Mbr;
        VDS_PARTITION_INFO_GPT Gpt;
        } 	;
    } 	VDS_PARTITION_INFORMATION_EX;

typedef struct _CREATE_PARTITION_PARAMETERS
    {
    VDS_PARTITION_STYLE style;
    /* [switch_type] */ union 
        {
        struct 
            {
            BYTE partitionType;
            BOOLEAN bootIndicator;
            } 	MbrPartInfo;
        struct 
            {
            GUID partitionType;
            GUID partitionId;
            ULONGLONG attributes;
            WCHAR name[ 36 ];
            } 	GptPartInfo;
         /* Empty union arm */ 
        } 	;
    } 	CREATE_PARTITION_PARAMETERS;

typedef struct _CHANGE_ATTRIBUTES_PARAMETERS
    {
    VDS_PARTITION_STYLE style;
    /* [switch_type] */ union 
        {
        struct 
            {
            BOOLEAN bootIndicator;
            } 	MbrPartInfo;
        struct 
            {
            ULONGLONG attributes;
            } 	GptPartInfo;
         /* Empty union arm */ 
        } 	;
    } 	CHANGE_ATTRIBUTES_PARAMETERS;

typedef struct _CHANGE_PARTITION_TYPE_PARAMETERS
    {
    VDS_PARTITION_STYLE style;
    /* [switch_type] */ union 
        {
        struct 
            {
            BYTE partitionType;
            } 	MbrPartInfo;
        struct 
            {
            GUID partitionType;
            } 	GptPartInfo;
         /* Empty union arm */ 
        } 	;
    } 	CHANGE_PARTITION_TYPE_PARAMETERS;



extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0005_v0_0_s_ifspec;

#ifndef __IVdsSwProvider_INTERFACE_DEFINED__
#define __IVdsSwProvider_INTERFACE_DEFINED__

/* interface IVdsSwProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsSwProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9aa58360-ce33-4f92-b658-ed24b14425b8")
    IVdsSwProvider : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPacks( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePack( 
            /* [out] */ __RPC__deref_out_opt IVdsPack **ppPack) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsSwProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsSwProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsSwProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsSwProvider * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryPacks )( 
            __RPC__in IVdsSwProvider * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreatePack )( 
            __RPC__in IVdsSwProvider * This,
            /* [out] */ __RPC__deref_out_opt IVdsPack **ppPack);
        
        END_INTERFACE
    } IVdsSwProviderVtbl;

    interface IVdsSwProvider
    {
        CONST_VTBL struct IVdsSwProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsSwProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsSwProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsSwProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsSwProvider_QueryPacks(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryPacks(This,ppEnum) ) 

#define IVdsSwProvider_CreatePack(This,ppPack)	\
    ( (This)->lpVtbl -> CreatePack(This,ppPack) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsSwProvider_INTERFACE_DEFINED__ */


#ifndef __IVdsPack_INTERFACE_DEFINED__
#define __IVdsPack_INTERFACE_DEFINED__

/* interface IVdsPack */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsPack;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3b69d7f5-9d94-4648-91ca-79939ba263bf")
    IVdsPack : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_PACK_PROP *pPackProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProvider( 
            /* [out] */ __RPC__deref_out_opt IVdsProvider **ppProvider) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryVolumes( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDisks( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateVolume( 
            /* [in] */ VDS_VOLUME_TYPE type,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfDisks) VDS_INPUT_DISK *pInputDiskArray,
            /* [in] */ LONG lNumberOfDisks,
            /* [in] */ ULONG ulStripeSize,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddDisk( 
            /* [in] */ VDS_OBJECT_ID DiskId,
            /* [in] */ VDS_PARTITION_STYLE PartitionStyle,
            /* [in] */ BOOL bAsHotSpare) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MigrateDisks( 
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfDisks) VDS_OBJECT_ID *pDiskArray,
            /* [in] */ LONG lNumberOfDisks,
            /* [in] */ VDS_OBJECT_ID TargetPack,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bQueryOnly,
            /* [size_is][out] */ __RPC__out_ecount_full(lNumberOfDisks) HRESULT *pResults,
            /* [out] */ __RPC__out BOOL *pbRebootNeeded) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ReplaceDisk( 
            /* [in] */ VDS_OBJECT_ID OldDiskId,
            /* [in] */ VDS_OBJECT_ID NewDiskId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveMissingDisk( 
            /* [in] */ VDS_OBJECT_ID DiskId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Recover( 
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsPackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsPack * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsPack * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsPack * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsPack * This,
            /* [out] */ __RPC__out VDS_PACK_PROP *pPackProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProvider )( 
            __RPC__in IVdsPack * This,
            /* [out] */ __RPC__deref_out_opt IVdsProvider **ppProvider);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryVolumes )( 
            __RPC__in IVdsPack * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryDisks )( 
            __RPC__in IVdsPack * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateVolume )( 
            __RPC__in IVdsPack * This,
            /* [in] */ VDS_VOLUME_TYPE type,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfDisks) VDS_INPUT_DISK *pInputDiskArray,
            /* [in] */ LONG lNumberOfDisks,
            /* [in] */ ULONG ulStripeSize,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddDisk )( 
            __RPC__in IVdsPack * This,
            /* [in] */ VDS_OBJECT_ID DiskId,
            /* [in] */ VDS_PARTITION_STYLE PartitionStyle,
            /* [in] */ BOOL bAsHotSpare);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *MigrateDisks )( 
            __RPC__in IVdsPack * This,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfDisks) VDS_OBJECT_ID *pDiskArray,
            /* [in] */ LONG lNumberOfDisks,
            /* [in] */ VDS_OBJECT_ID TargetPack,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bQueryOnly,
            /* [size_is][out] */ __RPC__out_ecount_full(lNumberOfDisks) HRESULT *pResults,
            /* [out] */ __RPC__out BOOL *pbRebootNeeded);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ReplaceDisk )( 
            __RPC__in IVdsPack * This,
            /* [in] */ VDS_OBJECT_ID OldDiskId,
            /* [in] */ VDS_OBJECT_ID NewDiskId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveMissingDisk )( 
            __RPC__in IVdsPack * This,
            /* [in] */ VDS_OBJECT_ID DiskId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Recover )( 
            __RPC__in IVdsPack * This,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsPackVtbl;

    interface IVdsPack
    {
        CONST_VTBL struct IVdsPackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsPack_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsPack_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsPack_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsPack_GetProperties(This,pPackProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pPackProp) ) 

#define IVdsPack_GetProvider(This,ppProvider)	\
    ( (This)->lpVtbl -> GetProvider(This,ppProvider) ) 

#define IVdsPack_QueryVolumes(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryVolumes(This,ppEnum) ) 

#define IVdsPack_QueryDisks(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryDisks(This,ppEnum) ) 

#define IVdsPack_CreateVolume(This,type,pInputDiskArray,lNumberOfDisks,ulStripeSize,ppAsync)	\
    ( (This)->lpVtbl -> CreateVolume(This,type,pInputDiskArray,lNumberOfDisks,ulStripeSize,ppAsync) ) 

#define IVdsPack_AddDisk(This,DiskId,PartitionStyle,bAsHotSpare)	\
    ( (This)->lpVtbl -> AddDisk(This,DiskId,PartitionStyle,bAsHotSpare) ) 

#define IVdsPack_MigrateDisks(This,pDiskArray,lNumberOfDisks,TargetPack,bForce,bQueryOnly,pResults,pbRebootNeeded)	\
    ( (This)->lpVtbl -> MigrateDisks(This,pDiskArray,lNumberOfDisks,TargetPack,bForce,bQueryOnly,pResults,pbRebootNeeded) ) 

#define IVdsPack_ReplaceDisk(This,OldDiskId,NewDiskId,ppAsync)	\
    ( (This)->lpVtbl -> ReplaceDisk(This,OldDiskId,NewDiskId,ppAsync) ) 

#define IVdsPack_RemoveMissingDisk(This,DiskId)	\
    ( (This)->lpVtbl -> RemoveMissingDisk(This,DiskId) ) 

#define IVdsPack_Recover(This,ppAsync)	\
    ( (This)->lpVtbl -> Recover(This,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsPack_INTERFACE_DEFINED__ */


#ifndef __IVdsPack2_INTERFACE_DEFINED__
#define __IVdsPack2_INTERFACE_DEFINED__

/* interface IVdsPack2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsPack2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("13B50BFF-290A-47DD-8558-B7C58DB1A71A")
    IVdsPack2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateVolume2( 
            /* [in] */ VDS_VOLUME_TYPE type,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfDisks) VDS_INPUT_DISK *pInputDiskArray,
            /* [in] */ LONG lNumberOfDisks,
            /* [in] */ ULONG ulStripeSize,
            /* [in] */ ULONG ulAlign,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsPack2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsPack2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsPack2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsPack2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateVolume2 )( 
            __RPC__in IVdsPack2 * This,
            /* [in] */ VDS_VOLUME_TYPE type,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfDisks) VDS_INPUT_DISK *pInputDiskArray,
            /* [in] */ LONG lNumberOfDisks,
            /* [in] */ ULONG ulStripeSize,
            /* [in] */ ULONG ulAlign,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsPack2Vtbl;

    interface IVdsPack2
    {
        CONST_VTBL struct IVdsPack2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsPack2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsPack2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsPack2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsPack2_CreateVolume2(This,type,pInputDiskArray,lNumberOfDisks,ulStripeSize,ulAlign,ppAsync)	\
    ( (This)->lpVtbl -> CreateVolume2(This,type,pInputDiskArray,lNumberOfDisks,ulStripeSize,ulAlign,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsPack2_INTERFACE_DEFINED__ */


#ifndef __IVdsDisk_INTERFACE_DEFINED__
#define __IVdsDisk_INTERFACE_DEFINED__

/* interface IVdsDisk */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsDisk;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("07e5c822-f00c-47a1-8fce-b244da56fd06")
    IVdsDisk : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_DISK_PROP *pDiskProperties) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPack( 
            /* [out] */ __RPC__deref_out_opt IVdsPack **ppPack) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIdentificationData( 
            /* [out] */ __RPC__out VDS_LUN_INFORMATION *pLunInfo) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryExtents( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_DISK_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ConvertStyle( 
            /* [in] */ VDS_PARTITION_STYLE NewStyle) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ ULONG ulFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ClearFlags( 
            /* [in] */ ULONG ulFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsDiskVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsDisk * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsDisk * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsDisk * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsDisk * This,
            /* [out] */ __RPC__out VDS_DISK_PROP *pDiskProperties);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPack )( 
            __RPC__in IVdsDisk * This,
            /* [out] */ __RPC__deref_out_opt IVdsPack **ppPack);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetIdentificationData )( 
            __RPC__in IVdsDisk * This,
            /* [out] */ __RPC__out VDS_LUN_INFORMATION *pLunInfo);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryExtents )( 
            __RPC__in IVdsDisk * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_DISK_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ConvertStyle )( 
            __RPC__in IVdsDisk * This,
            /* [in] */ VDS_PARTITION_STYLE NewStyle);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            __RPC__in IVdsDisk * This,
            /* [in] */ ULONG ulFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ClearFlags )( 
            __RPC__in IVdsDisk * This,
            /* [in] */ ULONG ulFlags);
        
        END_INTERFACE
    } IVdsDiskVtbl;

    interface IVdsDisk
    {
        CONST_VTBL struct IVdsDiskVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsDisk_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsDisk_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsDisk_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsDisk_GetProperties(This,pDiskProperties)	\
    ( (This)->lpVtbl -> GetProperties(This,pDiskProperties) ) 

#define IVdsDisk_GetPack(This,ppPack)	\
    ( (This)->lpVtbl -> GetPack(This,ppPack) ) 

#define IVdsDisk_GetIdentificationData(This,pLunInfo)	\
    ( (This)->lpVtbl -> GetIdentificationData(This,pLunInfo) ) 

#define IVdsDisk_QueryExtents(This,ppExtentArray,plNumberOfExtents)	\
    ( (This)->lpVtbl -> QueryExtents(This,ppExtentArray,plNumberOfExtents) ) 

#define IVdsDisk_ConvertStyle(This,NewStyle)	\
    ( (This)->lpVtbl -> ConvertStyle(This,NewStyle) ) 

#define IVdsDisk_SetFlags(This,ulFlags)	\
    ( (This)->lpVtbl -> SetFlags(This,ulFlags) ) 

#define IVdsDisk_ClearFlags(This,ulFlags)	\
    ( (This)->lpVtbl -> ClearFlags(This,ulFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsDisk_INTERFACE_DEFINED__ */


#ifndef __IVdsDisk2_INTERFACE_DEFINED__
#define __IVdsDisk2_INTERFACE_DEFINED__

/* interface IVdsDisk2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsDisk2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("40F73C8B-687D-4a13-8D96-3D7F2E683936")
    IVdsDisk2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSANMode( 
            /* [in] */ BOOL bEnable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsDisk2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsDisk2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsDisk2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsDisk2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetSANMode )( 
            __RPC__in IVdsDisk2 * This,
            /* [in] */ BOOL bEnable);
        
        END_INTERFACE
    } IVdsDisk2Vtbl;

    interface IVdsDisk2
    {
        CONST_VTBL struct IVdsDisk2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsDisk2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsDisk2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsDisk2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsDisk2_SetSANMode(This,bEnable)	\
    ( (This)->lpVtbl -> SetSANMode(This,bEnable) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsDisk2_INTERFACE_DEFINED__ */


#ifndef __IVdsDiskOnline_INTERFACE_DEFINED__
#define __IVdsDiskOnline_INTERFACE_DEFINED__

/* interface IVdsDiskOnline */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsDiskOnline;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("90681B1D-6A7F-48e8-9061-31B7AA125322")
    IVdsDiskOnline : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Online( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Offline( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsDiskOnlineVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsDiskOnline * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsDiskOnline * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsDiskOnline * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Online )( 
            __RPC__in IVdsDiskOnline * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Offline )( 
            __RPC__in IVdsDiskOnline * This);
        
        END_INTERFACE
    } IVdsDiskOnlineVtbl;

    interface IVdsDiskOnline
    {
        CONST_VTBL struct IVdsDiskOnlineVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsDiskOnline_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsDiskOnline_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsDiskOnline_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsDiskOnline_Online(This)	\
    ( (This)->lpVtbl -> Online(This) ) 

#define IVdsDiskOnline_Offline(This)	\
    ( (This)->lpVtbl -> Offline(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsDiskOnline_INTERFACE_DEFINED__ */


#ifndef __IVdsAdvancedDisk_INTERFACE_DEFINED__
#define __IVdsAdvancedDisk_INTERFACE_DEFINED__

/* interface IVdsAdvancedDisk */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsAdvancedDisk;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6e6f6b40-977c-4069-bddd-ac710059f8c0")
    IVdsAdvancedDisk : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPartitionProperties( 
            /* [in] */ ULONGLONG ullOffset,
            /* [out] */ __RPC__out VDS_PARTITION_PROP *pPartitionProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPartitions( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfPartitions) VDS_PARTITION_PROP **ppPartitionPropArray,
            /* [out] */ __RPC__out LONG *plNumberOfPartitions) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePartition( 
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ ULONGLONG ullSize,
            /* [in] */ __RPC__in CREATE_PARTITION_PARAMETERS *para,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeletePartition( 
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bForceProtected) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ChangeAttributes( 
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ __RPC__in CHANGE_ATTRIBUTES_PARAMETERS *para) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AssignDriveLetter( 
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ WCHAR wcLetter) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteDriveLetter( 
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ WCHAR wcLetter) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDriveLetter( 
            /* [in] */ ULONGLONG ullOffset,
            /* [out] */ __RPC__out WCHAR *pwcLetter) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FormatPartition( 
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ VDS_FILE_SYSTEM_TYPE type,
            /* [string][in] */ __RPC__in_string LPWSTR pwszLabel,
            /* [in] */ DWORD dwUnitAllocationSize,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bQuickFormat,
            /* [in] */ BOOL bEnableCompression,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clean( 
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bForceOEM,
            /* [in] */ BOOL bFullClean,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsAdvancedDiskVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsAdvancedDisk * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsAdvancedDisk * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsAdvancedDisk * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPartitionProperties )( 
            __RPC__in IVdsAdvancedDisk * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [out] */ __RPC__out VDS_PARTITION_PROP *pPartitionProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryPartitions )( 
            __RPC__in IVdsAdvancedDisk * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfPartitions) VDS_PARTITION_PROP **ppPartitionPropArray,
            /* [out] */ __RPC__out LONG *plNumberOfPartitions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreatePartition )( 
            __RPC__in IVdsAdvancedDisk * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ ULONGLONG ullSize,
            /* [in] */ __RPC__in CREATE_PARTITION_PARAMETERS *para,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeletePartition )( 
            __RPC__in IVdsAdvancedDisk * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bForceProtected);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ChangeAttributes )( 
            __RPC__in IVdsAdvancedDisk * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ __RPC__in CHANGE_ATTRIBUTES_PARAMETERS *para);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AssignDriveLetter )( 
            __RPC__in IVdsAdvancedDisk * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ WCHAR wcLetter);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeleteDriveLetter )( 
            __RPC__in IVdsAdvancedDisk * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ WCHAR wcLetter);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDriveLetter )( 
            __RPC__in IVdsAdvancedDisk * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [out] */ __RPC__out WCHAR *pwcLetter);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FormatPartition )( 
            __RPC__in IVdsAdvancedDisk * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ VDS_FILE_SYSTEM_TYPE type,
            /* [string][in] */ __RPC__in_string LPWSTR pwszLabel,
            /* [in] */ DWORD dwUnitAllocationSize,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bQuickFormat,
            /* [in] */ BOOL bEnableCompression,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        HRESULT ( STDMETHODCALLTYPE *Clean )( 
            __RPC__in IVdsAdvancedDisk * This,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bForceOEM,
            /* [in] */ BOOL bFullClean,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsAdvancedDiskVtbl;

    interface IVdsAdvancedDisk
    {
        CONST_VTBL struct IVdsAdvancedDiskVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsAdvancedDisk_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsAdvancedDisk_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsAdvancedDisk_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsAdvancedDisk_GetPartitionProperties(This,ullOffset,pPartitionProp)	\
    ( (This)->lpVtbl -> GetPartitionProperties(This,ullOffset,pPartitionProp) ) 

#define IVdsAdvancedDisk_QueryPartitions(This,ppPartitionPropArray,plNumberOfPartitions)	\
    ( (This)->lpVtbl -> QueryPartitions(This,ppPartitionPropArray,plNumberOfPartitions) ) 

#define IVdsAdvancedDisk_CreatePartition(This,ullOffset,ullSize,para,ppAsync)	\
    ( (This)->lpVtbl -> CreatePartition(This,ullOffset,ullSize,para,ppAsync) ) 

#define IVdsAdvancedDisk_DeletePartition(This,ullOffset,bForce,bForceProtected)	\
    ( (This)->lpVtbl -> DeletePartition(This,ullOffset,bForce,bForceProtected) ) 

#define IVdsAdvancedDisk_ChangeAttributes(This,ullOffset,para)	\
    ( (This)->lpVtbl -> ChangeAttributes(This,ullOffset,para) ) 

#define IVdsAdvancedDisk_AssignDriveLetter(This,ullOffset,wcLetter)	\
    ( (This)->lpVtbl -> AssignDriveLetter(This,ullOffset,wcLetter) ) 

#define IVdsAdvancedDisk_DeleteDriveLetter(This,ullOffset,wcLetter)	\
    ( (This)->lpVtbl -> DeleteDriveLetter(This,ullOffset,wcLetter) ) 

#define IVdsAdvancedDisk_GetDriveLetter(This,ullOffset,pwcLetter)	\
    ( (This)->lpVtbl -> GetDriveLetter(This,ullOffset,pwcLetter) ) 

#define IVdsAdvancedDisk_FormatPartition(This,ullOffset,type,pwszLabel,dwUnitAllocationSize,bForce,bQuickFormat,bEnableCompression,ppAsync)	\
    ( (This)->lpVtbl -> FormatPartition(This,ullOffset,type,pwszLabel,dwUnitAllocationSize,bForce,bQuickFormat,bEnableCompression,ppAsync) ) 

#define IVdsAdvancedDisk_Clean(This,bForce,bForceOEM,bFullClean,ppAsync)	\
    ( (This)->lpVtbl -> Clean(This,bForce,bForceOEM,bFullClean,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsAdvancedDisk_INTERFACE_DEFINED__ */


#ifndef __IVdsAdvancedDisk2_INTERFACE_DEFINED__
#define __IVdsAdvancedDisk2_INTERFACE_DEFINED__

/* interface IVdsAdvancedDisk2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsAdvancedDisk2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9723f420-9355-42de-ab66-e31bb15beeac")
    IVdsAdvancedDisk2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ChangePartitionType( 
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ BOOL bForce,
            /* [in] */ __RPC__in CHANGE_PARTITION_TYPE_PARAMETERS *para) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsAdvancedDisk2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsAdvancedDisk2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsAdvancedDisk2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsAdvancedDisk2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ChangePartitionType )( 
            __RPC__in IVdsAdvancedDisk2 * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ BOOL bForce,
            /* [in] */ __RPC__in CHANGE_PARTITION_TYPE_PARAMETERS *para);
        
        END_INTERFACE
    } IVdsAdvancedDisk2Vtbl;

    interface IVdsAdvancedDisk2
    {
        CONST_VTBL struct IVdsAdvancedDisk2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsAdvancedDisk2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsAdvancedDisk2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsAdvancedDisk2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsAdvancedDisk2_ChangePartitionType(This,ullOffset,bForce,para)	\
    ( (This)->lpVtbl -> ChangePartitionType(This,ullOffset,bForce,para) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsAdvancedDisk2_INTERFACE_DEFINED__ */


#ifndef __IVdsCreatePartitionEx_INTERFACE_DEFINED__
#define __IVdsCreatePartitionEx_INTERFACE_DEFINED__

/* interface IVdsCreatePartitionEx */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsCreatePartitionEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9882f547-cfc3-420b-9750-00dfbec50662")
    IVdsCreatePartitionEx : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePartitionEx( 
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ ULONGLONG ullSize,
            /* [in] */ ULONG ulAlign,
            /* [in] */ __RPC__in CREATE_PARTITION_PARAMETERS *para,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsCreatePartitionExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsCreatePartitionEx * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsCreatePartitionEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsCreatePartitionEx * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreatePartitionEx )( 
            __RPC__in IVdsCreatePartitionEx * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [in] */ ULONGLONG ullSize,
            /* [in] */ ULONG ulAlign,
            /* [in] */ __RPC__in CREATE_PARTITION_PARAMETERS *para,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsCreatePartitionExVtbl;

    interface IVdsCreatePartitionEx
    {
        CONST_VTBL struct IVdsCreatePartitionExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsCreatePartitionEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsCreatePartitionEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsCreatePartitionEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsCreatePartitionEx_CreatePartitionEx(This,ullOffset,ullSize,ulAlign,para,ppAsync)	\
    ( (This)->lpVtbl -> CreatePartitionEx(This,ullOffset,ullSize,ulAlign,para,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsCreatePartitionEx_INTERFACE_DEFINED__ */


#ifndef __IVdsRemovable_INTERFACE_DEFINED__
#define __IVdsRemovable_INTERFACE_DEFINED__

/* interface IVdsRemovable */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsRemovable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0316560b-5db4-4ed9-bbb5-213436ddc0d9")
    IVdsRemovable : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryMedia( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Eject( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsRemovableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsRemovable * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsRemovable * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsRemovable * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryMedia )( 
            __RPC__in IVdsRemovable * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Eject )( 
            __RPC__in IVdsRemovable * This);
        
        END_INTERFACE
    } IVdsRemovableVtbl;

    interface IVdsRemovable
    {
        CONST_VTBL struct IVdsRemovableVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsRemovable_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsRemovable_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsRemovable_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsRemovable_QueryMedia(This)	\
    ( (This)->lpVtbl -> QueryMedia(This) ) 

#define IVdsRemovable_Eject(This)	\
    ( (This)->lpVtbl -> Eject(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsRemovable_INTERFACE_DEFINED__ */


#ifndef __IVdsVolume_INTERFACE_DEFINED__
#define __IVdsVolume_INTERFACE_DEFINED__

/* interface IVdsVolume */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsVolume;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("88306bb2-e71f-478c-86a2-79da200a0f11")
    IVdsVolume : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_VOLUME_PROP *pVolumeProperties) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPack( 
            /* [out] */ __RPC__deref_out_opt IVdsPack **ppPack) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPlexes( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Extend( 
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfDisks) VDS_INPUT_DISK *pInputDiskArray,
            /* [in] */ LONG lNumberOfDisks,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Shrink( 
            /* [in] */ ULONGLONG ullNumberOfBytesToRemove,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddPlex( 
            /* [in] */ VDS_OBJECT_ID VolumeId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BreakPlex( 
            /* [in] */ VDS_OBJECT_ID plexId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemovePlex( 
            /* [in] */ VDS_OBJECT_ID plexId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ BOOL bForce) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ ULONG ulFlags,
            /* [in] */ BOOL bRevertOnClose) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ClearFlags( 
            /* [in] */ ULONG ulFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsVolumeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsVolume * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsVolume * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsVolume * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsVolume * This,
            /* [out] */ __RPC__out VDS_VOLUME_PROP *pVolumeProperties);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPack )( 
            __RPC__in IVdsVolume * This,
            /* [out] */ __RPC__deref_out_opt IVdsPack **ppPack);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryPlexes )( 
            __RPC__in IVdsVolume * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Extend )( 
            __RPC__in IVdsVolume * This,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfDisks) VDS_INPUT_DISK *pInputDiskArray,
            /* [in] */ LONG lNumberOfDisks,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Shrink )( 
            __RPC__in IVdsVolume * This,
            /* [in] */ ULONGLONG ullNumberOfBytesToRemove,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddPlex )( 
            __RPC__in IVdsVolume * This,
            /* [in] */ VDS_OBJECT_ID VolumeId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *BreakPlex )( 
            __RPC__in IVdsVolume * This,
            /* [in] */ VDS_OBJECT_ID plexId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemovePlex )( 
            __RPC__in IVdsVolume * This,
            /* [in] */ VDS_OBJECT_ID plexId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            __RPC__in IVdsVolume * This,
            /* [in] */ BOOL bForce);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            __RPC__in IVdsVolume * This,
            /* [in] */ ULONG ulFlags,
            /* [in] */ BOOL bRevertOnClose);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ClearFlags )( 
            __RPC__in IVdsVolume * This,
            /* [in] */ ULONG ulFlags);
        
        END_INTERFACE
    } IVdsVolumeVtbl;

    interface IVdsVolume
    {
        CONST_VTBL struct IVdsVolumeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsVolume_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsVolume_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsVolume_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsVolume_GetProperties(This,pVolumeProperties)	\
    ( (This)->lpVtbl -> GetProperties(This,pVolumeProperties) ) 

#define IVdsVolume_GetPack(This,ppPack)	\
    ( (This)->lpVtbl -> GetPack(This,ppPack) ) 

#define IVdsVolume_QueryPlexes(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryPlexes(This,ppEnum) ) 

#define IVdsVolume_Extend(This,pInputDiskArray,lNumberOfDisks,ppAsync)	\
    ( (This)->lpVtbl -> Extend(This,pInputDiskArray,lNumberOfDisks,ppAsync) ) 

#define IVdsVolume_Shrink(This,ullNumberOfBytesToRemove,ppAsync)	\
    ( (This)->lpVtbl -> Shrink(This,ullNumberOfBytesToRemove,ppAsync) ) 

#define IVdsVolume_AddPlex(This,VolumeId,ppAsync)	\
    ( (This)->lpVtbl -> AddPlex(This,VolumeId,ppAsync) ) 

#define IVdsVolume_BreakPlex(This,plexId,ppAsync)	\
    ( (This)->lpVtbl -> BreakPlex(This,plexId,ppAsync) ) 

#define IVdsVolume_RemovePlex(This,plexId,ppAsync)	\
    ( (This)->lpVtbl -> RemovePlex(This,plexId,ppAsync) ) 

#define IVdsVolume_Delete(This,bForce)	\
    ( (This)->lpVtbl -> Delete(This,bForce) ) 

#define IVdsVolume_SetFlags(This,ulFlags,bRevertOnClose)	\
    ( (This)->lpVtbl -> SetFlags(This,ulFlags,bRevertOnClose) ) 

#define IVdsVolume_ClearFlags(This,ulFlags)	\
    ( (This)->lpVtbl -> ClearFlags(This,ulFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsVolume_INTERFACE_DEFINED__ */


#ifndef __IVdsVolume2_INTERFACE_DEFINED__
#define __IVdsVolume2_INTERFACE_DEFINED__

/* interface IVdsVolume2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsVolume2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("72AE6713-DCBB-4a03-B36B-371F6AC6B53D")
    IVdsVolume2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties2( 
            /* [out] */ __RPC__out VDS_VOLUME_PROP2 *pVolumeProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsVolume2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsVolume2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsVolume2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsVolume2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties2 )( 
            __RPC__in IVdsVolume2 * This,
            /* [out] */ __RPC__out VDS_VOLUME_PROP2 *pVolumeProperties);
        
        END_INTERFACE
    } IVdsVolume2Vtbl;

    interface IVdsVolume2
    {
        CONST_VTBL struct IVdsVolume2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsVolume2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsVolume2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsVolume2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsVolume2_GetProperties2(This,pVolumeProperties)	\
    ( (This)->lpVtbl -> GetProperties2(This,pVolumeProperties) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsVolume2_INTERFACE_DEFINED__ */


#ifndef __IVdsVolumeOnline_INTERFACE_DEFINED__
#define __IVdsVolumeOnline_INTERFACE_DEFINED__

/* interface IVdsVolumeOnline */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsVolumeOnline;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1BE2275A-B315-4f70-9E44-879B3A2A53F2")
    IVdsVolumeOnline : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Online( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsVolumeOnlineVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsVolumeOnline * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsVolumeOnline * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsVolumeOnline * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Online )( 
            __RPC__in IVdsVolumeOnline * This);
        
        END_INTERFACE
    } IVdsVolumeOnlineVtbl;

    interface IVdsVolumeOnline
    {
        CONST_VTBL struct IVdsVolumeOnlineVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsVolumeOnline_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsVolumeOnline_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsVolumeOnline_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsVolumeOnline_Online(This)	\
    ( (This)->lpVtbl -> Online(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsVolumeOnline_INTERFACE_DEFINED__ */


#ifndef __IVdsVolumePlex_INTERFACE_DEFINED__
#define __IVdsVolumePlex_INTERFACE_DEFINED__

/* interface IVdsVolumePlex */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsVolumePlex;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4daa0135-e1d1-40f1-aaa5-3cc1e53221c3")
    IVdsVolumePlex : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_VOLUME_PLEX_PROP *pPlexProperties) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVolume( 
            /* [out] */ __RPC__deref_out_opt IVdsVolume **ppVolume) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryExtents( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_DISK_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Repair( 
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfDisks) VDS_INPUT_DISK *pInputDiskArray,
            /* [in] */ LONG lNumberOfDisks,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsVolumePlexVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsVolumePlex * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsVolumePlex * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsVolumePlex * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsVolumePlex * This,
            /* [out] */ __RPC__out VDS_VOLUME_PLEX_PROP *pPlexProperties);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetVolume )( 
            __RPC__in IVdsVolumePlex * This,
            /* [out] */ __RPC__deref_out_opt IVdsVolume **ppVolume);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryExtents )( 
            __RPC__in IVdsVolumePlex * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_DISK_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Repair )( 
            __RPC__in IVdsVolumePlex * This,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfDisks) VDS_INPUT_DISK *pInputDiskArray,
            /* [in] */ LONG lNumberOfDisks,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsVolumePlexVtbl;

    interface IVdsVolumePlex
    {
        CONST_VTBL struct IVdsVolumePlexVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsVolumePlex_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsVolumePlex_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsVolumePlex_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsVolumePlex_GetProperties(This,pPlexProperties)	\
    ( (This)->lpVtbl -> GetProperties(This,pPlexProperties) ) 

#define IVdsVolumePlex_GetVolume(This,ppVolume)	\
    ( (This)->lpVtbl -> GetVolume(This,ppVolume) ) 

#define IVdsVolumePlex_QueryExtents(This,ppExtentArray,plNumberOfExtents)	\
    ( (This)->lpVtbl -> QueryExtents(This,ppExtentArray,plNumberOfExtents) ) 

#define IVdsVolumePlex_Repair(This,pInputDiskArray,lNumberOfDisks,ppAsync)	\
    ( (This)->lpVtbl -> Repair(This,pInputDiskArray,lNumberOfDisks,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsVolumePlex_INTERFACE_DEFINED__ */


#ifndef __IVdsDisk3_INTERFACE_DEFINED__
#define __IVdsDisk3_INTERFACE_DEFINED__

/* interface IVdsDisk3 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsDisk3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8F4B2F5D-EC15-4357-992F-473EF10975B9")
    IVdsDisk3 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties2( 
            /* [out] */ __RPC__out VDS_DISK_PROP2 *pDiskProperties) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryFreeExtents( 
            /* [in] */ ULONG ulAlign,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfFreeExtents) VDS_DISK_FREE_EXTENT **ppFreeExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfFreeExtents) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsDisk3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsDisk3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsDisk3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsDisk3 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties2 )( 
            __RPC__in IVdsDisk3 * This,
            /* [out] */ __RPC__out VDS_DISK_PROP2 *pDiskProperties);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryFreeExtents )( 
            __RPC__in IVdsDisk3 * This,
            /* [in] */ ULONG ulAlign,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfFreeExtents) VDS_DISK_FREE_EXTENT **ppFreeExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfFreeExtents);
        
        END_INTERFACE
    } IVdsDisk3Vtbl;

    interface IVdsDisk3
    {
        CONST_VTBL struct IVdsDisk3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsDisk3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsDisk3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsDisk3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsDisk3_GetProperties2(This,pDiskProperties)	\
    ( (This)->lpVtbl -> GetProperties2(This,pDiskProperties) ) 

#define IVdsDisk3_QueryFreeExtents(This,ulAlign,ppFreeExtentArray,plNumberOfFreeExtents)	\
    ( (This)->lpVtbl -> QueryFreeExtents(This,ulAlign,ppFreeExtentArray,plNumberOfFreeExtents) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsDisk3_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vds_0000_0020 */
/* [local] */ 



























typedef 
enum _VDS_SUB_SYSTEM_STATUS
    {	VDS_SSS_UNKNOWN	= 0,
	VDS_SSS_ONLINE	= 1,
	VDS_SSS_NOT_READY	= 2,
	VDS_SSS_OFFLINE	= 4,
	VDS_SSS_FAILED	= 5,
	VDS_SSS_PARTIALLY_MANAGED	= 9
    } 	VDS_SUB_SYSTEM_STATUS;

typedef 
enum _VDS_SUB_SYSTEM_FLAG
    {	VDS_SF_LUN_MASKING_CAPABLE	= 0x1,
	VDS_SF_LUN_PLEXING_CAPABLE	= 0x2,
	VDS_SF_LUN_REMAPPING_CAPABLE	= 0x4,
	VDS_SF_DRIVE_EXTENT_CAPABLE	= 0x8,
	VDS_SF_HARDWARE_CHECKSUM_CAPABLE	= 0x10,
	VDS_SF_RADIUS_CAPABLE	= 0x20,
	VDS_SF_READ_BACK_VERIFY_CAPABLE	= 0x40,
	VDS_SF_WRITE_THROUGH_CACHING_CAPABLE	= 0x80,
	VDS_SF_SUPPORTS_FAULT_TOLERANT_LUNS	= 0x200,
	VDS_SF_SUPPORTS_NON_FAULT_TOLERANT_LUNS	= 0x400,
	VDS_SF_SUPPORTS_SIMPLE_LUNS	= 0x800,
	VDS_SF_SUPPORTS_SPAN_LUNS	= 0x1000,
	VDS_SF_SUPPORTS_STRIPE_LUNS	= 0x2000,
	VDS_SF_SUPPORTS_MIRROR_LUNS	= 0x4000,
	VDS_SF_SUPPORTS_PARITY_LUNS	= 0x8000,
	VDS_SF_SUPPORTS_AUTH_CHAP	= 0x10000,
	VDS_SF_SUPPORTS_AUTH_MUTUAL_CHAP	= 0x20000,
	VDS_SF_SUPPORTS_SIMPLE_TARGET_CONFIG	= 0x40000,
	VDS_SF_SUPPORTS_LUN_NUMBER	= 0x80000,
	VDS_SF_SUPPORTS_MIRRORED_CACHE	= 0x100000,
	VDS_SF_READ_CACHING_CAPABLE	= 0x200000,
	VDS_SF_WRITE_CACHING_CAPABLE	= 0x400000,
	VDS_SF_MEDIA_SCAN_CAPABLE	= 0x800000,
	VDS_SF_CONSISTENCY_CHECK_CAPABLE	= 0x1000000
    } 	VDS_SUB_SYSTEM_FLAG;

typedef 
enum _VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG
    {	VDS_SF_SUPPORTS_RAID2_LUNS	= 0x1,
	VDS_SF_SUPPORTS_RAID3_LUNS	= 0x2,
	VDS_SF_SUPPORTS_RAID4_LUNS	= 0x4,
	VDS_SF_SUPPORTS_RAID5_LUNS	= 0x8,
	VDS_SF_SUPPORTS_RAID6_LUNS	= 0x10,
	VDS_SF_SUPPORTS_RAID01_LUNS	= 0x20,
	VDS_SF_SUPPORTS_RAID03_LUNS	= 0x40,
	VDS_SF_SUPPORTS_RAID05_LUNS	= 0x80,
	VDS_SF_SUPPORTS_RAID10_LUNS	= 0x100,
	VDS_SF_SUPPORTS_RAID15_LUNS	= 0x200,
	VDS_SF_SUPPORTS_RAID30_LUNS	= 0x400,
	VDS_SF_SUPPORTS_RAID50_LUNS	= 0x800,
	VDS_SF_SUPPORTS_RAID51_LUNS	= 0x1000,
	VDS_SF_SUPPORTS_RAID53_LUNS	= 0x2000,
	VDS_SF_SUPPORTS_RAID60_LUNS	= 0x4000,
	VDS_SF_SUPPORTS_RAID61_LUNS	= 0x8000
    } 	VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG;

typedef 
enum _VDS_INTERCONNECT_FLAG
    {	VDS_ITF_PCI_RAID	= 0x1,
	VDS_ITF_FIBRE_CHANNEL	= 0x2,
	VDS_ITF_ISCSI	= 0x4,
	VDS_ITF_SAS	= 0x8
    } 	VDS_INTERCONNECT_FLAG;

typedef 
enum _VDS_CONTROLLER_STATUS
    {	VDS_CS_UNKNOWN	= 0,
	VDS_CS_ONLINE	= 1,
	VDS_CS_NOT_READY	= 2,
	VDS_CS_OFFLINE	= 4,
	VDS_CS_FAILED	= 5,
	VDS_CS_REMOVED	= 8
    } 	VDS_CONTROLLER_STATUS;

typedef 
enum _VDS_PORT_STATUS
    {	VDS_PRS_UNKNOWN	= 0,
	VDS_PRS_ONLINE	= 1,
	VDS_PRS_NOT_READY	= 2,
	VDS_PRS_OFFLINE	= 4,
	VDS_PRS_FAILED	= 5,
	VDS_PRS_REMOVED	= 8
    } 	VDS_PORT_STATUS;

typedef 
enum _VDS_DRIVE_STATUS
    {	VDS_DRS_UNKNOWN	= 0,
	VDS_DRS_ONLINE	= 1,
	VDS_DRS_NOT_READY	= 2,
	VDS_DRS_OFFLINE	= 4,
	VDS_DRS_FAILED	= 5,
	VDS_DRS_REMOVED	= 8
    } 	VDS_DRIVE_STATUS;

typedef 
enum _VDS_DRIVE_FLAG
    {	VDS_DRF_HOTSPARE	= 0x1,
	VDS_DRF_ASSIGNED	= 0x2,
	VDS_DRF_UNASSIGNED	= 0x4,
	VDS_DRF_HOTSPARE_IN_USE	= 0x8,
	VDS_DRF_HOTSPARE_STANDBY	= 0x10
    } 	VDS_DRIVE_FLAG;

typedef 
enum _VDS_LUN_TYPE
    {	VDS_LT_UNKNOWN	= 0,
	VDS_LT_DEFAULT	= 1,
	VDS_LT_FAULT_TOLERANT	= 2,
	VDS_LT_NON_FAULT_TOLERANT	= 3,
	VDS_LT_SIMPLE	= 10,
	VDS_LT_SPAN	= 11,
	VDS_LT_STRIPE	= 12,
	VDS_LT_MIRROR	= 13,
	VDS_LT_PARITY	= 14,
	VDS_LT_RAID2	= 15,
	VDS_LT_RAID3	= 16,
	VDS_LT_RAID4	= 17,
	VDS_LT_RAID5	= 18,
	VDS_LT_RAID6	= 19,
	VDS_LT_RAID01	= 20,
	VDS_LT_RAID03	= 21,
	VDS_LT_RAID05	= 22,
	VDS_LT_RAID10	= 23,
	VDS_LT_RAID15	= 24,
	VDS_LT_RAID30	= 25,
	VDS_LT_RAID50	= 26,
	VDS_LT_RAID51	= 27,
	VDS_LT_RAID53	= 28,
	VDS_LT_RAID60	= 29,
	VDS_LT_RAID61	= 30
    } 	VDS_LUN_TYPE;

typedef 
enum _VDS_LUN_STATUS
    {	VDS_LS_UNKNOWN	= 0,
	VDS_LS_ONLINE	= 1,
	VDS_LS_NOT_READY	= 2,
	VDS_LS_OFFLINE	= 4,
	VDS_LS_FAILED	= 5
    } 	VDS_LUN_STATUS;

typedef 
enum _VDS_LUN_FLAG
    {	VDS_LF_LBN_REMAP_ENABLED	= 0x1,
	VDS_LF_READ_BACK_VERIFY_ENABLED	= 0x2,
	VDS_LF_WRITE_THROUGH_CACHING_ENABLED	= 0x4,
	VDS_LF_HARDWARE_CHECKSUM_ENABLED	= 0x8,
	VDS_LF_READ_CACHE_ENABLED	= 0x10,
	VDS_LF_WRITE_CACHE_ENABLED	= 0x20,
	VDS_LF_MEDIA_SCAN_ENABLED	= 0x40,
	VDS_LF_CONSISTENCY_CHECK_ENABLED	= 0x80,
	VDS_LF_SNAPSHOT	= 0x100
    } 	VDS_LUN_FLAG;

typedef 
enum _VDS_LUN_PLEX_TYPE
    {	VDS_LPT_UNKNOWN	= 0,
	VDS_LPT_SIMPLE	= VDS_LT_SIMPLE,
	VDS_LPT_SPAN	= VDS_LT_SPAN,
	VDS_LPT_STRIPE	= VDS_LT_STRIPE,
	VDS_LPT_PARITY	= VDS_LT_PARITY,
	VDS_LPT_RAID2	= VDS_LT_RAID2,
	VDS_LPT_RAID3	= VDS_LT_RAID3,
	VDS_LPT_RAID4	= VDS_LT_RAID4,
	VDS_LPT_RAID5	= VDS_LT_RAID5,
	VDS_LPT_RAID6	= VDS_LT_RAID6,
	VDS_LPT_RAID03	= VDS_LT_RAID03,
	VDS_LPT_RAID05	= VDS_LT_RAID05,
	VDS_LPT_RAID10	= VDS_LT_RAID10,
	VDS_LPT_RAID15	= VDS_LT_RAID15,
	VDS_LPT_RAID30	= VDS_LT_RAID30,
	VDS_LPT_RAID50	= VDS_LT_RAID50,
	VDS_LPT_RAID53	= VDS_LT_RAID53,
	VDS_LPT_RAID60	= VDS_LT_RAID60
    } 	VDS_LUN_PLEX_TYPE;

typedef 
enum _VDS_LUN_PLEX_STATUS
    {	VDS_LPS_UNKNOWN	= 0,
	VDS_LPS_ONLINE	= 1,
	VDS_LPS_NOT_READY	= 2,
	VDS_LPS_OFFLINE	= 4,
	VDS_LPS_FAILED	= 5
    } 	VDS_LUN_PLEX_STATUS;

typedef 
enum _VDS_LUN_PLEX_FLAG
    {	VDS_LPF_LBN_REMAP_ENABLED	= VDS_LF_LBN_REMAP_ENABLED
    } 	VDS_LUN_PLEX_FLAG;

typedef 
enum _VDS_ISCSI_PORTAL_STATUS
    {	VDS_IPS_UNKNOWN	= 0,
	VDS_IPS_ONLINE	= 1,
	VDS_IPS_NOT_READY	= 2,
	VDS_IPS_OFFLINE	= 4,
	VDS_IPS_FAILED	= 5
    } 	VDS_ISCSI_PORTAL_STATUS;

typedef 
enum _VDS_STORAGE_POOL_STATUS
    {	VDS_SPS_UNKNOWN	= 0,
	VDS_SPS_ONLINE	= 1,
	VDS_SPS_NOT_READY	= 2,
	VDS_SPS_OFFLINE	= 4
    } 	VDS_STORAGE_POOL_STATUS;

typedef 
enum _VDS_STORAGE_POOL_TYPE
    {	VDS_SPT_UNKNOWN	= 0,
	VDS_SPT_PRIMORDIAL	= 0x1,
	VDS_SPT_CONCRETE	= 0x2
    } 	VDS_STORAGE_POOL_TYPE;

typedef 
enum _VDS_MAINTENANCE_OPERATION
    {	BlinkLight	= 1,
	BeepAlarm	= 2,
	SpinDown	= 3,
	SpinUp	= 4,
	Ping	= 5
    } 	VDS_MAINTENANCE_OPERATION;

typedef struct _VDS_HINTS
    {
    ULONGLONG ullHintMask;
    ULONGLONG ullExpectedMaximumSize;
    ULONG ulOptimalReadSize;
    ULONG ulOptimalReadAlignment;
    ULONG ulOptimalWriteSize;
    ULONG ulOptimalWriteAlignment;
    ULONG ulMaximumDriveCount;
    ULONG ulStripeSize;
    BOOL bFastCrashRecoveryRequired;
    BOOL bMostlyReads;
    BOOL bOptimizeForSequentialReads;
    BOOL bOptimizeForSequentialWrites;
    BOOL bRemapEnabled;
    BOOL bReadBackVerifyEnabled;
    BOOL bWriteThroughCachingEnabled;
    BOOL bHardwareChecksumEnabled;
    BOOL bIsYankable;
    SHORT sRebuildPriority;
    } 	VDS_HINTS;

typedef struct _VDS_HINTS *PVDS_HINTS;

#define	VDS_HINT_FASTCRASHRECOVERYREQUIRED	( 0x1L )

#define	VDS_HINT_MOSTLYREADS	( 0x2L )

#define	VDS_HINT_OPTIMIZEFORSEQUENTIALREADS	( 0x4L )

#define	VDS_HINT_OPTIMIZEFORSEQUENTIALWRITES	( 0x8L )

#define	VDS_HINT_READBACKVERIFYENABLED	( 0x10L )

#define	VDS_HINT_REMAPENABLED	( 0x20L )

#define	VDS_HINT_WRITETHROUGHCACHINGENABLED	( 0x40L )

#define	VDS_HINT_HARDWARECHECKSUMENABLED	( 0x80L )

#define	VDS_HINT_ISYANKABLE	( 0x100L )

typedef struct _VDS_HINTS2
    {
    ULONGLONG ullHintMask;
    ULONGLONG ullExpectedMaximumSize;
    ULONG ulOptimalReadSize;
    ULONG ulOptimalReadAlignment;
    ULONG ulOptimalWriteSize;
    ULONG ulOptimalWriteAlignment;
    ULONG ulMaximumDriveCount;
    ULONG ulStripeSize;
    ULONG ulReserved1;
    ULONG ulReserved2;
    ULONG ulReserved3;
    BOOL bFastCrashRecoveryRequired;
    BOOL bMostlyReads;
    BOOL bOptimizeForSequentialReads;
    BOOL bOptimizeForSequentialWrites;
    BOOL bRemapEnabled;
    BOOL bReadBackVerifyEnabled;
    BOOL bWriteThroughCachingEnabled;
    BOOL bHardwareChecksumEnabled;
    BOOL bIsYankable;
    BOOL bAllocateHotSpare;
    BOOL bUseMirroredCache;
    BOOL bReadCachingEnabled;
    BOOL bWriteCachingEnabled;
    BOOL bMediaScanEnabled;
    BOOL bConsistencyCheckEnabled;
    VDS_STORAGE_BUS_TYPE BusType;
    BOOL bReserved1;
    BOOL bReserved2;
    BOOL bReserved3;
    SHORT sRebuildPriority;
    } 	VDS_HINTS2;

typedef struct _VDS_HINTS2 *PVDS_HINTS2;

#define	VDS_HINT_ALLOCATEHOTSPARE	( 0x200L )

#define	VDS_HINT_BUSTYPE	( 0x400L )

#define	VDS_HINT_USEMIRROREDCACHE	( 0x800L )

#define	VDS_HINT_READCACHINGENABLED	( 0x1000L )

#define	VDS_HINT_WRITECACHINGENABLED	( 0x2000L )

#define	VDS_HINT_MEDIASCANENABLED	( 0x4000L )

#define	VDS_HINT_CONSISTENCYCHECKENABLED	( 0x8000L )

typedef struct _VDS_SUB_SYSTEM_PROP
    {
    VDS_OBJECT_ID id;
    LPWSTR pwszFriendlyName;
    LPWSTR pwszIdentification;
    ULONG ulFlags;
    ULONG ulStripeSizeFlags;
    VDS_SUB_SYSTEM_STATUS status;
    VDS_HEALTH health;
    SHORT sNumberOfInternalBuses;
    SHORT sMaxNumberOfSlotsEachBus;
    SHORT sMaxNumberOfControllers;
    SHORT sRebuildPriority;
    } 	VDS_SUB_SYSTEM_PROP;

typedef struct _VDS_SUB_SYSTEM_PROP2
    {
    VDS_OBJECT_ID id;
    LPWSTR pwszFriendlyName;
    LPWSTR pwszIdentification;
    ULONG ulFlags;
    ULONG ulStripeSizeFlags;
    ULONG ulSupportedRaidTypeFlags;
    VDS_SUB_SYSTEM_STATUS status;
    VDS_HEALTH health;
    SHORT sNumberOfInternalBuses;
    SHORT sMaxNumberOfSlotsEachBus;
    SHORT sMaxNumberOfControllers;
    SHORT sRebuildPriority;
    ULONG ulNumberOfEnclosures;
    } 	VDS_SUB_SYSTEM_PROP2;

typedef struct _VDS_CONTROLLER_PROP
    {
    VDS_OBJECT_ID id;
    LPWSTR pwszFriendlyName;
    LPWSTR pwszIdentification;
    VDS_CONTROLLER_STATUS status;
    VDS_HEALTH health;
    SHORT sNumberOfPorts;
    } 	VDS_CONTROLLER_PROP;

typedef struct _VDS_DRIVE_PROP
    {
    VDS_OBJECT_ID id;
    ULONGLONG ullSize;
    LPWSTR pwszFriendlyName;
    LPWSTR pwszIdentification;
    ULONG ulFlags;
    VDS_DRIVE_STATUS status;
    VDS_HEALTH health;
    SHORT sInternalBusNumber;
    SHORT sSlotNumber;
    } 	VDS_DRIVE_PROP;

typedef struct _VDS_DRIVE_PROP2
    {
    VDS_OBJECT_ID id;
    ULONGLONG ullSize;
    LPWSTR pwszFriendlyName;
    LPWSTR pwszIdentification;
    ULONG ulFlags;
    VDS_DRIVE_STATUS status;
    VDS_HEALTH health;
    SHORT sInternalBusNumber;
    SHORT sSlotNumber;
    ULONG ulEnclosureNumber;
    VDS_STORAGE_BUS_TYPE busType;
    ULONG ulSpindleSpeed;
    } 	VDS_DRIVE_PROP2;

typedef struct _VDS_DRIVE_EXTENT
    {
    VDS_OBJECT_ID id;
    VDS_OBJECT_ID LunId;
    ULONGLONG ullSize;
    BOOL bUsed;
    } 	VDS_DRIVE_EXTENT;

#define VDS_REBUILD_PRIORITY_MIN        0
#define VDS_REBUILD_PRIORITY_MAX        16
typedef struct _VDS_LUN_PROP
    {
    VDS_OBJECT_ID id;
    ULONGLONG ullSize;
    LPWSTR pwszFriendlyName;
    LPWSTR pwszIdentification;
    LPWSTR pwszUnmaskingList;
    ULONG ulFlags;
    VDS_LUN_TYPE type;
    VDS_LUN_STATUS status;
    VDS_HEALTH health;
    VDS_TRANSITION_STATE TransitionState;
    SHORT sRebuildPriority;
    } 	VDS_LUN_PROP;

typedef struct _VDS_LUN_PROP *PVDS_LUN_PROP;

typedef struct _VDS_LUN_PLEX_PROP
    {
    VDS_OBJECT_ID id;
    ULONGLONG ullSize;
    VDS_LUN_PLEX_TYPE type;
    VDS_LUN_PLEX_STATUS status;
    VDS_HEALTH health;
    VDS_TRANSITION_STATE TransitionState;
    ULONG ulFlags;
    ULONG ulStripeSize;
    SHORT sRebuildPriority;
    } 	VDS_LUN_PLEX_PROP;

typedef struct _VDS_PORT_PROP
    {
    VDS_OBJECT_ID id;
    LPWSTR pwszFriendlyName;
    LPWSTR pwszIdentification;
    VDS_PORT_STATUS status;
    } 	VDS_PORT_PROP;

typedef struct _VDS_ISCSI_PORTAL_PROP
    {
    VDS_OBJECT_ID id;
    VDS_IPADDRESS address;
    VDS_ISCSI_PORTAL_STATUS status;
    } 	VDS_ISCSI_PORTAL_PROP;

typedef struct _VDS_ISCSI_TARGET_PROP
    {
    VDS_OBJECT_ID id;
    LPWSTR pwszIscsiName;
    LPWSTR pwszFriendlyName;
    BOOL bChapEnabled;
    } 	VDS_ISCSI_TARGET_PROP;

typedef struct _VDS_ISCSI_PORTALGROUP_PROP
    {
    VDS_OBJECT_ID id;
    VDS_ISCSI_PORTALGROUP_TAG tag;
    } 	VDS_ISCSI_PORTALGROUP_PROP;

typedef 
enum _VDS_RAID_TYPE
    {	VDS_RT_UNKNOWN	= 0,
	VDS_RT_RAID0	= 10,
	VDS_RT_RAID1	= 11,
	VDS_RT_RAID2	= 12,
	VDS_RT_RAID3	= 13,
	VDS_RT_RAID4	= 14,
	VDS_RT_RAID5	= 15,
	VDS_RT_RAID6	= 16,
	VDS_RT_RAID01	= 17,
	VDS_RT_RAID03	= 18,
	VDS_RT_RAID05	= 19,
	VDS_RT_RAID10	= 20,
	VDS_RT_RAID15	= 21,
	VDS_RT_RAID30	= 22,
	VDS_RT_RAID50	= 23,
	VDS_RT_RAID51	= 24,
	VDS_RT_RAID53	= 25,
	VDS_RT_RAID60	= 26,
	VDS_RT_RAID61	= 27
    } 	VDS_RAID_TYPE;

typedef struct _VDS_POOL_CUSTOM_ATTRIBUTES
    {
    LPWSTR pwszName;
    LPWSTR pwszValue;
    } 	VDS_POOL_CUSTOM_ATTRIBUTES;

typedef struct _VDS_POOL_CUSTOM_ATTRIBUTES *PVDS_POOL_CUSTOM_ATTRIBUTES;

typedef struct _VDS_POOL_ATTRIBUTES
    {
    ULONGLONG ullAttributeMask;
    VDS_RAID_TYPE raidType;
    VDS_STORAGE_BUS_TYPE busType;
    LPWSTR pwszIntendedUsage;
    BOOL bSpinDown;
    BOOL bIsThinProvisioned;
    ULONGLONG ullProvisionedSpace;
    BOOL bNoSinglePointOfFailure;
    ULONG ulDataRedundancyMax;
    ULONG ulDataRedundancyMin;
    ULONG ulDataRedundancyDefault;
    ULONG ulPackageRedundancyMax;
    ULONG ulPackageRedundancyMin;
    ULONG ulPackageRedundancyDefault;
    ULONG ulStripeSize;
    ULONG ulStripeSizeMax;
    ULONG ulStripeSizeMin;
    ULONG ulDefaultStripeSize;
    ULONG ulNumberOfColumns;
    ULONG ulNumberOfColumnsMax;
    ULONG ulNumberOfColumnsMin;
    ULONG ulDefaultNumberofColumns;
    ULONG ulDataAvailabilityHint;
    ULONG ulAccessRandomnessHint;
    ULONG ulAccessDirectionHint;
    ULONG ulAccessSizeHint;
    ULONG ulAccessLatencyHint;
    ULONG ulAccessBandwidthWeightHint;
    ULONG ulStorageCostHint;
    ULONG ulStorageEfficiencyHint;
    ULONG ulNumOfCustomAttributes;
    VDS_POOL_CUSTOM_ATTRIBUTES *pPoolCustomAttributes;
    BOOL bReserved1;
    BOOL bReserved2;
    ULONG ulReserved1;
    ULONG ulReserved2;
    ULONGLONG ullReserved1;
    ULONGLONG ullReserved2;
    } 	VDS_POOL_ATTRIBUTES;

typedef struct _VDS_POOL_ATTRIBUTES *PVDS_POOL_ATTRIBUTES;

#define	VDS_POOL_ATTRIB_RAIDTYPE	( 0x1L )

#define	VDS_POOL_ATTRIB_BUSTYPE	( 0x2L )

#define	VDS_POOL_ATTRIB_ALLOW_SPINDOWN	( 0x4L )

#define	VDS_POOL_ATTRIB_THIN_PROVISION	( 0x8L )

#define	VDS_POOL_ATTRIB_NO_SINGLE_POF	( 0x10L )

#define	VDS_POOL_ATTRIB_DATA_RDNCY_MAX	( 0x20L )

#define	VDS_POOL_ATTRIB_DATA_RDNCY_MIN	( 0x40L )

#define	VDS_POOL_ATTRIB_DATA_RDNCY_DEF	( 0x80L )

#define	VDS_POOL_ATTRIB_PKG_RDNCY_MAX	( 0x100L )

#define	VDS_POOL_ATTRIB_PKG_RDNCY_MIN	( 0x200L )

#define	VDS_POOL_ATTRIB_PKG_RDNCY_DEF	( 0x400L )

#define	VDS_POOL_ATTRIB_STRIPE_SIZE	( 0x800L )

#define	VDS_POOL_ATTRIB_STRIPE_SIZE_MAX	( 0x1000L )

#define	VDS_POOL_ATTRIB_STRIPE_SIZE_MIN	( 0x2000L )

#define	VDS_POOL_ATTRIB_STRIPE_SIZE_DEF	( 0x4000L )

#define	VDS_POOL_ATTRIB_NUM_CLMNS	( 0x8000L )

#define	VDS_POOL_ATTRIB_NUM_CLMNS_MAX	( 0x10000L )

#define	VDS_POOL_ATTRIB_NUM_CLMNS_MIN	( 0x20000L )

#define	VDS_POOL_ATTRIB_NUM_CLMNS_DEF	( 0x40000L )

#define	VDS_POOL_ATTRIB_DATA_AVL_HINT	( 0x80000L )

#define	VDS_POOL_ATTRIB_ACCS_RNDM_HINT	( 0x100000L )

#define	VDS_POOL_ATTRIB_ACCS_DIR_HINT	( 0x200000L )

#define	VDS_POOL_ATTRIB_ACCS_SIZE_HINT	( 0x400000L )

#define	VDS_POOL_ATTRIB_ACCS_LTNCY_HINT	( 0x800000L )

#define	VDS_POOL_ATTRIB_ACCS_BDW_WT_HINT	( 0x1000000L )

#define	VDS_POOL_ATTRIB_STOR_COST_HINT	( 0x2000000L )

#define	VDS_POOL_ATTRIB_STOR_EFFCY_HINT	( 0x4000000L )

#define	VDS_POOL_ATTRIB_CUSTOM_ATTRIB	( 0x8000000L )

typedef struct _VDS_STORAGE_POOL_PROP
    {
    VDS_OBJECT_ID id;
    VDS_STORAGE_POOL_STATUS status;
    VDS_HEALTH health;
    VDS_STORAGE_POOL_TYPE type;
    LPWSTR pwszName;
    LPWSTR pwszDescription;
    ULONGLONG ullTotalConsumedSpace;
    ULONGLONG ullTotalManagedSpace;
    ULONGLONG ullRemainingFreeSpace;
    } 	VDS_STORAGE_POOL_PROP;

typedef struct _VDS_STORAGE_POOL_PROP *PVDS_STORAGE_POOL_PROP;

typedef struct _VDS_STORAGE_POOL_DRIVE_EXTENT
    {
    VDS_OBJECT_ID id;
    ULONGLONG ullSize;
    BOOL bUsed;
    } 	VDS_STORAGE_POOL_DRIVE_EXTENT;



extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0020_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0020_v0_0_s_ifspec;

#ifndef __IVdsHwProvider_INTERFACE_DEFINED__
#define __IVdsHwProvider_INTERFACE_DEFINED__

/* interface IVdsHwProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsHwProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d99bdaae-b13a-4178-9fdb-e27f16b4603e")
    IVdsHwProvider : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QuerySubSystems( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reenumerate( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsHwProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsHwProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsHwProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsHwProvider * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QuerySubSystems )( 
            __RPC__in IVdsHwProvider * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reenumerate )( 
            __RPC__in IVdsHwProvider * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            __RPC__in IVdsHwProvider * This);
        
        END_INTERFACE
    } IVdsHwProviderVtbl;

    interface IVdsHwProvider
    {
        CONST_VTBL struct IVdsHwProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsHwProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsHwProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsHwProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsHwProvider_QuerySubSystems(This,ppEnum)	\
    ( (This)->lpVtbl -> QuerySubSystems(This,ppEnum) ) 

#define IVdsHwProvider_Reenumerate(This)	\
    ( (This)->lpVtbl -> Reenumerate(This) ) 

#define IVdsHwProvider_Refresh(This)	\
    ( (This)->lpVtbl -> Refresh(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsHwProvider_INTERFACE_DEFINED__ */


#ifndef __IVdsHwProviderType_INTERFACE_DEFINED__
#define __IVdsHwProviderType_INTERFACE_DEFINED__

/* interface IVdsHwProviderType */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsHwProviderType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3e0f5166-542d-4fc6-947a-012174240b7e")
    IVdsHwProviderType : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProviderType( 
            /* [out] */ __RPC__out VDS_HWPROVIDER_TYPE *pType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsHwProviderTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsHwProviderType * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsHwProviderType * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsHwProviderType * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProviderType )( 
            __RPC__in IVdsHwProviderType * This,
            /* [out] */ __RPC__out VDS_HWPROVIDER_TYPE *pType);
        
        END_INTERFACE
    } IVdsHwProviderTypeVtbl;

    interface IVdsHwProviderType
    {
        CONST_VTBL struct IVdsHwProviderTypeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsHwProviderType_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsHwProviderType_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsHwProviderType_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsHwProviderType_GetProviderType(This,pType)	\
    ( (This)->lpVtbl -> GetProviderType(This,pType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsHwProviderType_INTERFACE_DEFINED__ */


#ifndef __IVdsHwProviderType2_INTERFACE_DEFINED__
#define __IVdsHwProviderType2_INTERFACE_DEFINED__

/* interface IVdsHwProviderType2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsHwProviderType2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8190236f-c4d0-4e81-8011-d69512fcc984")
    IVdsHwProviderType2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProviderType2( 
            /* [out] */ __RPC__out VDS_HWPROVIDER_TYPE *pType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsHwProviderType2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsHwProviderType2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsHwProviderType2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsHwProviderType2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProviderType2 )( 
            __RPC__in IVdsHwProviderType2 * This,
            /* [out] */ __RPC__out VDS_HWPROVIDER_TYPE *pType);
        
        END_INTERFACE
    } IVdsHwProviderType2Vtbl;

    interface IVdsHwProviderType2
    {
        CONST_VTBL struct IVdsHwProviderType2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsHwProviderType2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsHwProviderType2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsHwProviderType2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsHwProviderType2_GetProviderType2(This,pType)	\
    ( (This)->lpVtbl -> GetProviderType2(This,pType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsHwProviderType2_INTERFACE_DEFINED__ */


#ifndef __IVdsHwProviderStoragePools_INTERFACE_DEFINED__
#define __IVdsHwProviderStoragePools_INTERFACE_DEFINED__

/* interface IVdsHwProviderStoragePools */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsHwProviderStoragePools;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d5b5937a-f188-4c79-b86c-11c920ad11b8")
    IVdsHwProviderStoragePools : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryStoragePools( 
            /* [in] */ ULONG ulFlags,
            /* [in] */ ULONGLONG ullRemainingFreeSpace,
            /* [unique][in] */ __RPC__in_opt VDS_POOL_ATTRIBUTES *pPoolAttributes,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateLunInStoragePool( 
            /* [in] */ VDS_LUN_TYPE type,
            /* [in] */ ULONGLONG ullSizeInBytes,
            /* [in] */ VDS_OBJECT_ID StoragePoolId,
            /* [string][in] */ __RPC__in_string LPWSTR pwszUnmaskingList,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS2 *pHints2,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryMaxLunCreateSizeInStoragePool( 
            /* [in] */ VDS_LUN_TYPE type,
            /* [in] */ VDS_OBJECT_ID StoragePoolId,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS2 *pHints2,
            /* [out] */ __RPC__out ULONGLONG *pullMaxLunSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsHwProviderStoragePoolsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsHwProviderStoragePools * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsHwProviderStoragePools * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsHwProviderStoragePools * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryStoragePools )( 
            __RPC__in IVdsHwProviderStoragePools * This,
            /* [in] */ ULONG ulFlags,
            /* [in] */ ULONGLONG ullRemainingFreeSpace,
            /* [unique][in] */ __RPC__in_opt VDS_POOL_ATTRIBUTES *pPoolAttributes,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateLunInStoragePool )( 
            __RPC__in IVdsHwProviderStoragePools * This,
            /* [in] */ VDS_LUN_TYPE type,
            /* [in] */ ULONGLONG ullSizeInBytes,
            /* [in] */ VDS_OBJECT_ID StoragePoolId,
            /* [string][in] */ __RPC__in_string LPWSTR pwszUnmaskingList,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS2 *pHints2,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryMaxLunCreateSizeInStoragePool )( 
            __RPC__in IVdsHwProviderStoragePools * This,
            /* [in] */ VDS_LUN_TYPE type,
            /* [in] */ VDS_OBJECT_ID StoragePoolId,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS2 *pHints2,
            /* [out] */ __RPC__out ULONGLONG *pullMaxLunSize);
        
        END_INTERFACE
    } IVdsHwProviderStoragePoolsVtbl;

    interface IVdsHwProviderStoragePools
    {
        CONST_VTBL struct IVdsHwProviderStoragePoolsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsHwProviderStoragePools_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsHwProviderStoragePools_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsHwProviderStoragePools_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsHwProviderStoragePools_QueryStoragePools(This,ulFlags,ullRemainingFreeSpace,pPoolAttributes,ppEnum)	\
    ( (This)->lpVtbl -> QueryStoragePools(This,ulFlags,ullRemainingFreeSpace,pPoolAttributes,ppEnum) ) 

#define IVdsHwProviderStoragePools_CreateLunInStoragePool(This,type,ullSizeInBytes,StoragePoolId,pwszUnmaskingList,pHints2,ppAsync)	\
    ( (This)->lpVtbl -> CreateLunInStoragePool(This,type,ullSizeInBytes,StoragePoolId,pwszUnmaskingList,pHints2,ppAsync) ) 

#define IVdsHwProviderStoragePools_QueryMaxLunCreateSizeInStoragePool(This,type,StoragePoolId,pHints2,pullMaxLunSize)	\
    ( (This)->lpVtbl -> QueryMaxLunCreateSizeInStoragePool(This,type,StoragePoolId,pHints2,pullMaxLunSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsHwProviderStoragePools_INTERFACE_DEFINED__ */


#ifndef __IVdsSubSystem_INTERFACE_DEFINED__
#define __IVdsSubSystem_INTERFACE_DEFINED__

/* interface IVdsSubSystem */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsSubSystem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6fcee2d3-6d90-4f91-80e2-a5c7caaca9d8")
    IVdsSubSystem : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_SUB_SYSTEM_PROP *pSubSystemProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProvider( 
            /* [out] */ __RPC__deref_out_opt IVdsProvider **ppProvider) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryControllers( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryLuns( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDrives( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDrive( 
            /* [in] */ SHORT sBusNumber,
            /* [in] */ SHORT sSlotNumber,
            /* [out] */ __RPC__deref_out_opt IVdsDrive **ppDrive) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reenumerate( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetControllerStatus( 
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfOnlineControllers) VDS_OBJECT_ID *pOnlineControllerIdArray,
            /* [in] */ LONG lNumberOfOnlineControllers,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfOfflineControllers) VDS_OBJECT_ID *pOfflineControllerIdArray,
            /* [in] */ LONG lNumberOfOfflineControllers) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateLun( 
            /* [in] */ VDS_LUN_TYPE type,
            /* [in] */ ULONGLONG ullSizeInBytes,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [string][in] */ __RPC__in_string LPWSTR pwszUnmaskingList,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS *pHints,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ReplaceDrive( 
            /* [in] */ VDS_OBJECT_ID DriveToBeReplaced,
            /* [in] */ VDS_OBJECT_ID ReplacementDrive) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ VDS_SUB_SYSTEM_STATUS status) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryMaxLunCreateSize( 
            /* [in] */ VDS_LUN_TYPE type,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS *pHints,
            /* [out] */ __RPC__out ULONGLONG *pullMaxLunSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsSubSystemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsSubSystem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsSubSystem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsSubSystem * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsSubSystem * This,
            /* [out] */ __RPC__out VDS_SUB_SYSTEM_PROP *pSubSystemProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProvider )( 
            __RPC__in IVdsSubSystem * This,
            /* [out] */ __RPC__deref_out_opt IVdsProvider **ppProvider);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryControllers )( 
            __RPC__in IVdsSubSystem * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryLuns )( 
            __RPC__in IVdsSubSystem * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryDrives )( 
            __RPC__in IVdsSubSystem * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDrive )( 
            __RPC__in IVdsSubSystem * This,
            /* [in] */ SHORT sBusNumber,
            /* [in] */ SHORT sSlotNumber,
            /* [out] */ __RPC__deref_out_opt IVdsDrive **ppDrive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reenumerate )( 
            __RPC__in IVdsSubSystem * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetControllerStatus )( 
            __RPC__in IVdsSubSystem * This,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfOnlineControllers) VDS_OBJECT_ID *pOnlineControllerIdArray,
            /* [in] */ LONG lNumberOfOnlineControllers,
            /* [size_is][in] */ __RPC__in_ecount_full(lNumberOfOfflineControllers) VDS_OBJECT_ID *pOfflineControllerIdArray,
            /* [in] */ LONG lNumberOfOfflineControllers);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateLun )( 
            __RPC__in IVdsSubSystem * This,
            /* [in] */ VDS_LUN_TYPE type,
            /* [in] */ ULONGLONG ullSizeInBytes,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [string][in] */ __RPC__in_string LPWSTR pwszUnmaskingList,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS *pHints,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ReplaceDrive )( 
            __RPC__in IVdsSubSystem * This,
            /* [in] */ VDS_OBJECT_ID DriveToBeReplaced,
            /* [in] */ VDS_OBJECT_ID ReplacementDrive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            __RPC__in IVdsSubSystem * This,
            /* [in] */ VDS_SUB_SYSTEM_STATUS status);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryMaxLunCreateSize )( 
            __RPC__in IVdsSubSystem * This,
            /* [in] */ VDS_LUN_TYPE type,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS *pHints,
            /* [out] */ __RPC__out ULONGLONG *pullMaxLunSize);
        
        END_INTERFACE
    } IVdsSubSystemVtbl;

    interface IVdsSubSystem
    {
        CONST_VTBL struct IVdsSubSystemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsSubSystem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsSubSystem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsSubSystem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsSubSystem_GetProperties(This,pSubSystemProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pSubSystemProp) ) 

#define IVdsSubSystem_GetProvider(This,ppProvider)	\
    ( (This)->lpVtbl -> GetProvider(This,ppProvider) ) 

#define IVdsSubSystem_QueryControllers(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryControllers(This,ppEnum) ) 

#define IVdsSubSystem_QueryLuns(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryLuns(This,ppEnum) ) 

#define IVdsSubSystem_QueryDrives(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryDrives(This,ppEnum) ) 

#define IVdsSubSystem_GetDrive(This,sBusNumber,sSlotNumber,ppDrive)	\
    ( (This)->lpVtbl -> GetDrive(This,sBusNumber,sSlotNumber,ppDrive) ) 

#define IVdsSubSystem_Reenumerate(This)	\
    ( (This)->lpVtbl -> Reenumerate(This) ) 

#define IVdsSubSystem_SetControllerStatus(This,pOnlineControllerIdArray,lNumberOfOnlineControllers,pOfflineControllerIdArray,lNumberOfOfflineControllers)	\
    ( (This)->lpVtbl -> SetControllerStatus(This,pOnlineControllerIdArray,lNumberOfOnlineControllers,pOfflineControllerIdArray,lNumberOfOfflineControllers) ) 

#define IVdsSubSystem_CreateLun(This,type,ullSizeInBytes,pDriveIdArray,lNumberOfDrives,pwszUnmaskingList,pHints,ppAsync)	\
    ( (This)->lpVtbl -> CreateLun(This,type,ullSizeInBytes,pDriveIdArray,lNumberOfDrives,pwszUnmaskingList,pHints,ppAsync) ) 

#define IVdsSubSystem_ReplaceDrive(This,DriveToBeReplaced,ReplacementDrive)	\
    ( (This)->lpVtbl -> ReplaceDrive(This,DriveToBeReplaced,ReplacementDrive) ) 

#define IVdsSubSystem_SetStatus(This,status)	\
    ( (This)->lpVtbl -> SetStatus(This,status) ) 

#define IVdsSubSystem_QueryMaxLunCreateSize(This,type,pDriveIdArray,lNumberOfDrives,pHints,pullMaxLunSize)	\
    ( (This)->lpVtbl -> QueryMaxLunCreateSize(This,type,pDriveIdArray,lNumberOfDrives,pHints,pullMaxLunSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsSubSystem_INTERFACE_DEFINED__ */


#ifndef __IVdsSubSystem2_INTERFACE_DEFINED__
#define __IVdsSubSystem2_INTERFACE_DEFINED__

/* interface IVdsSubSystem2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsSubSystem2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("be666735-7800-4a77-9d9c-40f85b87e292")
    IVdsSubSystem2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties2( 
            /* [out] */ __RPC__out VDS_SUB_SYSTEM_PROP2 *pSubSystemProp2) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDrive2( 
            /* [in] */ SHORT sBusNumber,
            /* [in] */ SHORT sSlotNumber,
            /* [in] */ ULONG ulEnclosureNumber,
            /* [out] */ __RPC__deref_out_opt IVdsDrive **ppDrive) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateLun2( 
            /* [in] */ VDS_LUN_TYPE type,
            /* [in] */ ULONGLONG ullSizeInBytes,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [string][in] */ __RPC__in_string LPWSTR pwszUnmaskingList,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS2 *pHints2,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryMaxLunCreateSize2( 
            /* [in] */ VDS_LUN_TYPE type,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS2 *pHints2,
            /* [out] */ __RPC__out ULONGLONG *pullMaxLunSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsSubSystem2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsSubSystem2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsSubSystem2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsSubSystem2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties2 )( 
            __RPC__in IVdsSubSystem2 * This,
            /* [out] */ __RPC__out VDS_SUB_SYSTEM_PROP2 *pSubSystemProp2);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDrive2 )( 
            __RPC__in IVdsSubSystem2 * This,
            /* [in] */ SHORT sBusNumber,
            /* [in] */ SHORT sSlotNumber,
            /* [in] */ ULONG ulEnclosureNumber,
            /* [out] */ __RPC__deref_out_opt IVdsDrive **ppDrive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateLun2 )( 
            __RPC__in IVdsSubSystem2 * This,
            /* [in] */ VDS_LUN_TYPE type,
            /* [in] */ ULONGLONG ullSizeInBytes,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [string][in] */ __RPC__in_string LPWSTR pwszUnmaskingList,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS2 *pHints2,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryMaxLunCreateSize2 )( 
            __RPC__in IVdsSubSystem2 * This,
            /* [in] */ VDS_LUN_TYPE type,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [unique][in] */ __RPC__in_opt VDS_HINTS2 *pHints2,
            /* [out] */ __RPC__out ULONGLONG *pullMaxLunSize);
        
        END_INTERFACE
    } IVdsSubSystem2Vtbl;

    interface IVdsSubSystem2
    {
        CONST_VTBL struct IVdsSubSystem2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsSubSystem2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsSubSystem2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsSubSystem2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsSubSystem2_GetProperties2(This,pSubSystemProp2)	\
    ( (This)->lpVtbl -> GetProperties2(This,pSubSystemProp2) ) 

#define IVdsSubSystem2_GetDrive2(This,sBusNumber,sSlotNumber,ulEnclosureNumber,ppDrive)	\
    ( (This)->lpVtbl -> GetDrive2(This,sBusNumber,sSlotNumber,ulEnclosureNumber,ppDrive) ) 

#define IVdsSubSystem2_CreateLun2(This,type,ullSizeInBytes,pDriveIdArray,lNumberOfDrives,pwszUnmaskingList,pHints2,ppAsync)	\
    ( (This)->lpVtbl -> CreateLun2(This,type,ullSizeInBytes,pDriveIdArray,lNumberOfDrives,pwszUnmaskingList,pHints2,ppAsync) ) 

#define IVdsSubSystem2_QueryMaxLunCreateSize2(This,type,pDriveIdArray,lNumberOfDrives,pHints2,pullMaxLunSize)	\
    ( (This)->lpVtbl -> QueryMaxLunCreateSize2(This,type,pDriveIdArray,lNumberOfDrives,pHints2,pullMaxLunSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsSubSystem2_INTERFACE_DEFINED__ */


#ifndef __IVdsSubSystemNaming_INTERFACE_DEFINED__
#define __IVdsSubSystemNaming_INTERFACE_DEFINED__

/* interface IVdsSubSystemNaming */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsSubSystemNaming;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0d70faa3-9cd4-4900-aa20-6981b6aafc75")
    IVdsSubSystemNaming : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFriendlyName( 
            /* [string][in] */ __RPC__in_string LPWSTR pwszFriendlyName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsSubSystemNamingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsSubSystemNaming * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsSubSystemNaming * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsSubSystemNaming * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFriendlyName )( 
            __RPC__in IVdsSubSystemNaming * This,
            /* [string][in] */ __RPC__in_string LPWSTR pwszFriendlyName);
        
        END_INTERFACE
    } IVdsSubSystemNamingVtbl;

    interface IVdsSubSystemNaming
    {
        CONST_VTBL struct IVdsSubSystemNamingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsSubSystemNaming_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsSubSystemNaming_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsSubSystemNaming_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsSubSystemNaming_SetFriendlyName(This,pwszFriendlyName)	\
    ( (This)->lpVtbl -> SetFriendlyName(This,pwszFriendlyName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsSubSystemNaming_INTERFACE_DEFINED__ */


#ifndef __IVdsSubSystemIscsi_INTERFACE_DEFINED__
#define __IVdsSubSystemIscsi_INTERFACE_DEFINED__

/* interface IVdsSubSystemIscsi */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsSubSystemIscsi;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0027346f-40d0-4b45-8cec-5906dc0380c8")
    IVdsSubSystemIscsi : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryTargets( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPortals( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateTarget( 
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszIscsiName,
            /* [string][in] */ __RPC__in_string LPWSTR pwszFriendlyName,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetIpsecGroupPresharedKey( 
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsSubSystemIscsiVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsSubSystemIscsi * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsSubSystemIscsi * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsSubSystemIscsi * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryTargets )( 
            __RPC__in IVdsSubSystemIscsi * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryPortals )( 
            __RPC__in IVdsSubSystemIscsi * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateTarget )( 
            __RPC__in IVdsSubSystemIscsi * This,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszIscsiName,
            /* [string][in] */ __RPC__in_string LPWSTR pwszFriendlyName,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetIpsecGroupPresharedKey )( 
            __RPC__in IVdsSubSystemIscsi * This,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey);
        
        END_INTERFACE
    } IVdsSubSystemIscsiVtbl;

    interface IVdsSubSystemIscsi
    {
        CONST_VTBL struct IVdsSubSystemIscsiVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsSubSystemIscsi_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsSubSystemIscsi_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsSubSystemIscsi_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsSubSystemIscsi_QueryTargets(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryTargets(This,ppEnum) ) 

#define IVdsSubSystemIscsi_QueryPortals(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryPortals(This,ppEnum) ) 

#define IVdsSubSystemIscsi_CreateTarget(This,pwszIscsiName,pwszFriendlyName,ppAsync)	\
    ( (This)->lpVtbl -> CreateTarget(This,pwszIscsiName,pwszFriendlyName,ppAsync) ) 

#define IVdsSubSystemIscsi_SetIpsecGroupPresharedKey(This,pIpsecKey)	\
    ( (This)->lpVtbl -> SetIpsecGroupPresharedKey(This,pIpsecKey) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsSubSystemIscsi_INTERFACE_DEFINED__ */


#ifndef __IVdsSubSystemInterconnect_INTERFACE_DEFINED__
#define __IVdsSubSystemInterconnect_INTERFACE_DEFINED__

/* interface IVdsSubSystemInterconnect */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsSubSystemInterconnect;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9e6fa560-c141-477b-83ba-0b6c38f7febf")
    IVdsSubSystemInterconnect : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSupportedInterconnects( 
            /* [out] */ __RPC__out ULONG *pulSupportedInterconnectsFlag) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsSubSystemInterconnectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsSubSystemInterconnect * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsSubSystemInterconnect * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsSubSystemInterconnect * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedInterconnects )( 
            __RPC__in IVdsSubSystemInterconnect * This,
            /* [out] */ __RPC__out ULONG *pulSupportedInterconnectsFlag);
        
        END_INTERFACE
    } IVdsSubSystemInterconnectVtbl;

    interface IVdsSubSystemInterconnect
    {
        CONST_VTBL struct IVdsSubSystemInterconnectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsSubSystemInterconnect_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsSubSystemInterconnect_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsSubSystemInterconnect_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsSubSystemInterconnect_GetSupportedInterconnects(This,pulSupportedInterconnectsFlag)	\
    ( (This)->lpVtbl -> GetSupportedInterconnects(This,pulSupportedInterconnectsFlag) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsSubSystemInterconnect_INTERFACE_DEFINED__ */


#ifndef __IVdsControllerPort_INTERFACE_DEFINED__
#define __IVdsControllerPort_INTERFACE_DEFINED__

/* interface IVdsControllerPort */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsControllerPort;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("18691d0d-4e7f-43e8-92e4-cf44beeed11c")
    IVdsControllerPort : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_PORT_PROP *pPortProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetController( 
            /* [out] */ __RPC__deref_out_opt IVdsController **ppController) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAssociatedLuns( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ VDS_PORT_STATUS status) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsControllerPortVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsControllerPort * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsControllerPort * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsControllerPort * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsControllerPort * This,
            /* [out] */ __RPC__out VDS_PORT_PROP *pPortProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetController )( 
            __RPC__in IVdsControllerPort * This,
            /* [out] */ __RPC__deref_out_opt IVdsController **ppController);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAssociatedLuns )( 
            __RPC__in IVdsControllerPort * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IVdsControllerPort * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            __RPC__in IVdsControllerPort * This,
            /* [in] */ VDS_PORT_STATUS status);
        
        END_INTERFACE
    } IVdsControllerPortVtbl;

    interface IVdsControllerPort
    {
        CONST_VTBL struct IVdsControllerPortVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsControllerPort_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsControllerPort_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsControllerPort_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsControllerPort_GetProperties(This,pPortProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pPortProp) ) 

#define IVdsControllerPort_GetController(This,ppController)	\
    ( (This)->lpVtbl -> GetController(This,ppController) ) 

#define IVdsControllerPort_QueryAssociatedLuns(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryAssociatedLuns(This,ppEnum) ) 

#define IVdsControllerPort_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IVdsControllerPort_SetStatus(This,status)	\
    ( (This)->lpVtbl -> SetStatus(This,status) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsControllerPort_INTERFACE_DEFINED__ */


#ifndef __IVdsController_INTERFACE_DEFINED__
#define __IVdsController_INTERFACE_DEFINED__

/* interface IVdsController */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsController;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cb53d96e-dffb-474a-a078-790d1e2bc082")
    IVdsController : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_CONTROLLER_PROP *pControllerProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSubSystem( 
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPortProperties( 
            /* [in] */ SHORT sPortNumber,
            /* [out] */ __RPC__out VDS_PORT_PROP *pPortProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FlushCache( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InvalidateCache( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAssociatedLuns( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ VDS_CONTROLLER_STATUS status) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsControllerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsController * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsController * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsController * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsController * This,
            /* [out] */ __RPC__out VDS_CONTROLLER_PROP *pControllerProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSubSystem )( 
            __RPC__in IVdsController * This,
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPortProperties )( 
            __RPC__in IVdsController * This,
            /* [in] */ SHORT sPortNumber,
            /* [out] */ __RPC__out VDS_PORT_PROP *pPortProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FlushCache )( 
            __RPC__in IVdsController * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *InvalidateCache )( 
            __RPC__in IVdsController * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IVdsController * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAssociatedLuns )( 
            __RPC__in IVdsController * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            __RPC__in IVdsController * This,
            /* [in] */ VDS_CONTROLLER_STATUS status);
        
        END_INTERFACE
    } IVdsControllerVtbl;

    interface IVdsController
    {
        CONST_VTBL struct IVdsControllerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsController_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsController_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsController_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsController_GetProperties(This,pControllerProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pControllerProp) ) 

#define IVdsController_GetSubSystem(This,ppSubSystem)	\
    ( (This)->lpVtbl -> GetSubSystem(This,ppSubSystem) ) 

#define IVdsController_GetPortProperties(This,sPortNumber,pPortProp)	\
    ( (This)->lpVtbl -> GetPortProperties(This,sPortNumber,pPortProp) ) 

#define IVdsController_FlushCache(This)	\
    ( (This)->lpVtbl -> FlushCache(This) ) 

#define IVdsController_InvalidateCache(This)	\
    ( (This)->lpVtbl -> InvalidateCache(This) ) 

#define IVdsController_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IVdsController_QueryAssociatedLuns(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryAssociatedLuns(This,ppEnum) ) 

#define IVdsController_SetStatus(This,status)	\
    ( (This)->lpVtbl -> SetStatus(This,status) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsController_INTERFACE_DEFINED__ */


#ifndef __IVdsControllerControllerPort_INTERFACE_DEFINED__
#define __IVdsControllerControllerPort_INTERFACE_DEFINED__

/* interface IVdsControllerControllerPort */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsControllerControllerPort;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ca5d735f-6bae-42c0-b30e-f2666045ce71")
    IVdsControllerControllerPort : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryControllerPorts( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsControllerControllerPortVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsControllerControllerPort * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsControllerControllerPort * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsControllerControllerPort * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryControllerPorts )( 
            __RPC__in IVdsControllerControllerPort * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        END_INTERFACE
    } IVdsControllerControllerPortVtbl;

    interface IVdsControllerControllerPort
    {
        CONST_VTBL struct IVdsControllerControllerPortVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsControllerControllerPort_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsControllerControllerPort_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsControllerControllerPort_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsControllerControllerPort_QueryControllerPorts(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryControllerPorts(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsControllerControllerPort_INTERFACE_DEFINED__ */


#ifndef __IVdsDrive_INTERFACE_DEFINED__
#define __IVdsDrive_INTERFACE_DEFINED__

/* interface IVdsDrive */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsDrive;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ff24efa4-aade-4b6b-898b-eaa6a20887c7")
    IVdsDrive : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_DRIVE_PROP *pDriveProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSubSystem( 
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryExtents( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_DRIVE_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ ULONG ulFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ClearFlags( 
            /* [in] */ ULONG ulFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ VDS_DRIVE_STATUS status) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsDriveVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsDrive * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsDrive * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsDrive * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsDrive * This,
            /* [out] */ __RPC__out VDS_DRIVE_PROP *pDriveProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSubSystem )( 
            __RPC__in IVdsDrive * This,
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryExtents )( 
            __RPC__in IVdsDrive * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_DRIVE_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            __RPC__in IVdsDrive * This,
            /* [in] */ ULONG ulFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ClearFlags )( 
            __RPC__in IVdsDrive * This,
            /* [in] */ ULONG ulFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            __RPC__in IVdsDrive * This,
            /* [in] */ VDS_DRIVE_STATUS status);
        
        END_INTERFACE
    } IVdsDriveVtbl;

    interface IVdsDrive
    {
        CONST_VTBL struct IVdsDriveVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsDrive_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsDrive_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsDrive_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsDrive_GetProperties(This,pDriveProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pDriveProp) ) 

#define IVdsDrive_GetSubSystem(This,ppSubSystem)	\
    ( (This)->lpVtbl -> GetSubSystem(This,ppSubSystem) ) 

#define IVdsDrive_QueryExtents(This,ppExtentArray,plNumberOfExtents)	\
    ( (This)->lpVtbl -> QueryExtents(This,ppExtentArray,plNumberOfExtents) ) 

#define IVdsDrive_SetFlags(This,ulFlags)	\
    ( (This)->lpVtbl -> SetFlags(This,ulFlags) ) 

#define IVdsDrive_ClearFlags(This,ulFlags)	\
    ( (This)->lpVtbl -> ClearFlags(This,ulFlags) ) 

#define IVdsDrive_SetStatus(This,status)	\
    ( (This)->lpVtbl -> SetStatus(This,status) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsDrive_INTERFACE_DEFINED__ */


#ifndef __IVdsDrive2_INTERFACE_DEFINED__
#define __IVdsDrive2_INTERFACE_DEFINED__

/* interface IVdsDrive2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsDrive2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("60b5a730-addf-4436-8ca7-5769e2d1ffa4")
    IVdsDrive2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties2( 
            /* [out] */ __RPC__out VDS_DRIVE_PROP2 *pDriveProp2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsDrive2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsDrive2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsDrive2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsDrive2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties2 )( 
            __RPC__in IVdsDrive2 * This,
            /* [out] */ __RPC__out VDS_DRIVE_PROP2 *pDriveProp2);
        
        END_INTERFACE
    } IVdsDrive2Vtbl;

    interface IVdsDrive2
    {
        CONST_VTBL struct IVdsDrive2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsDrive2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsDrive2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsDrive2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsDrive2_GetProperties2(This,pDriveProp2)	\
    ( (This)->lpVtbl -> GetProperties2(This,pDriveProp2) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsDrive2_INTERFACE_DEFINED__ */


#ifndef __IVdsLun_INTERFACE_DEFINED__
#define __IVdsLun_INTERFACE_DEFINED__

/* interface IVdsLun */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsLun;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3540a9c7-e60f-4111-a840-8bba6c2c83d8")
    IVdsLun : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_LUN_PROP *pLunProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSubSystem( 
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIdentificationData( 
            /* [out] */ __RPC__out VDS_LUN_INFORMATION *pLunInfo) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryActiveControllers( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Extend( 
            /* [in] */ ULONGLONG ullNumberOfBytesToAdd,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Shrink( 
            /* [in] */ ULONGLONG ullNumberOfBytesToRemove,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPlexes( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddPlex( 
            /* [in] */ VDS_OBJECT_ID lunId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemovePlex( 
            /* [in] */ VDS_OBJECT_ID plexId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Recover( 
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetMask( 
            /* [string][in] */ __RPC__in_string LPWSTR pwszUnmaskingList) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AssociateControllers( 
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfActiveControllers) VDS_OBJECT_ID *pActiveControllerIdArray,
            /* [in] */ LONG lNumberOfActiveControllers,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfInactiveControllers) VDS_OBJECT_ID *pInactiveControllerIdArray,
            /* [in] */ LONG lNumberOfInactiveControllers) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryHints( 
            /* [out] */ __RPC__out VDS_HINTS *pHints) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ApplyHints( 
            /* [in] */ __RPC__in VDS_HINTS *pHints) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ VDS_LUN_STATUS status) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryMaxLunExtendSize( 
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [out] */ __RPC__out ULONGLONG *pullMaxBytesToBeAdded) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsLunVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsLun * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsLun * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsLun * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsLun * This,
            /* [out] */ __RPC__out VDS_LUN_PROP *pLunProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSubSystem )( 
            __RPC__in IVdsLun * This,
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetIdentificationData )( 
            __RPC__in IVdsLun * This,
            /* [out] */ __RPC__out VDS_LUN_INFORMATION *pLunInfo);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryActiveControllers )( 
            __RPC__in IVdsLun * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Extend )( 
            __RPC__in IVdsLun * This,
            /* [in] */ ULONGLONG ullNumberOfBytesToAdd,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Shrink )( 
            __RPC__in IVdsLun * This,
            /* [in] */ ULONGLONG ullNumberOfBytesToRemove,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryPlexes )( 
            __RPC__in IVdsLun * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddPlex )( 
            __RPC__in IVdsLun * This,
            /* [in] */ VDS_OBJECT_ID lunId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemovePlex )( 
            __RPC__in IVdsLun * This,
            /* [in] */ VDS_OBJECT_ID plexId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Recover )( 
            __RPC__in IVdsLun * This,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetMask )( 
            __RPC__in IVdsLun * This,
            /* [string][in] */ __RPC__in_string LPWSTR pwszUnmaskingList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            __RPC__in IVdsLun * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AssociateControllers )( 
            __RPC__in IVdsLun * This,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfActiveControllers) VDS_OBJECT_ID *pActiveControllerIdArray,
            /* [in] */ LONG lNumberOfActiveControllers,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfInactiveControllers) VDS_OBJECT_ID *pInactiveControllerIdArray,
            /* [in] */ LONG lNumberOfInactiveControllers);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryHints )( 
            __RPC__in IVdsLun * This,
            /* [out] */ __RPC__out VDS_HINTS *pHints);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ApplyHints )( 
            __RPC__in IVdsLun * This,
            /* [in] */ __RPC__in VDS_HINTS *pHints);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            __RPC__in IVdsLun * This,
            /* [in] */ VDS_LUN_STATUS status);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryMaxLunExtendSize )( 
            __RPC__in IVdsLun * This,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(lNumberOfDrives) VDS_OBJECT_ID *pDriveIdArray,
            /* [in] */ LONG lNumberOfDrives,
            /* [out] */ __RPC__out ULONGLONG *pullMaxBytesToBeAdded);
        
        END_INTERFACE
    } IVdsLunVtbl;

    interface IVdsLun
    {
        CONST_VTBL struct IVdsLunVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsLun_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsLun_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsLun_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsLun_GetProperties(This,pLunProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pLunProp) ) 

#define IVdsLun_GetSubSystem(This,ppSubSystem)	\
    ( (This)->lpVtbl -> GetSubSystem(This,ppSubSystem) ) 

#define IVdsLun_GetIdentificationData(This,pLunInfo)	\
    ( (This)->lpVtbl -> GetIdentificationData(This,pLunInfo) ) 

#define IVdsLun_QueryActiveControllers(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryActiveControllers(This,ppEnum) ) 

#define IVdsLun_Extend(This,ullNumberOfBytesToAdd,pDriveIdArray,lNumberOfDrives,ppAsync)	\
    ( (This)->lpVtbl -> Extend(This,ullNumberOfBytesToAdd,pDriveIdArray,lNumberOfDrives,ppAsync) ) 

#define IVdsLun_Shrink(This,ullNumberOfBytesToRemove,ppAsync)	\
    ( (This)->lpVtbl -> Shrink(This,ullNumberOfBytesToRemove,ppAsync) ) 

#define IVdsLun_QueryPlexes(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryPlexes(This,ppEnum) ) 

#define IVdsLun_AddPlex(This,lunId,ppAsync)	\
    ( (This)->lpVtbl -> AddPlex(This,lunId,ppAsync) ) 

#define IVdsLun_RemovePlex(This,plexId,ppAsync)	\
    ( (This)->lpVtbl -> RemovePlex(This,plexId,ppAsync) ) 

#define IVdsLun_Recover(This,ppAsync)	\
    ( (This)->lpVtbl -> Recover(This,ppAsync) ) 

#define IVdsLun_SetMask(This,pwszUnmaskingList)	\
    ( (This)->lpVtbl -> SetMask(This,pwszUnmaskingList) ) 

#define IVdsLun_Delete(This)	\
    ( (This)->lpVtbl -> Delete(This) ) 

#define IVdsLun_AssociateControllers(This,pActiveControllerIdArray,lNumberOfActiveControllers,pInactiveControllerIdArray,lNumberOfInactiveControllers)	\
    ( (This)->lpVtbl -> AssociateControllers(This,pActiveControllerIdArray,lNumberOfActiveControllers,pInactiveControllerIdArray,lNumberOfInactiveControllers) ) 

#define IVdsLun_QueryHints(This,pHints)	\
    ( (This)->lpVtbl -> QueryHints(This,pHints) ) 

#define IVdsLun_ApplyHints(This,pHints)	\
    ( (This)->lpVtbl -> ApplyHints(This,pHints) ) 

#define IVdsLun_SetStatus(This,status)	\
    ( (This)->lpVtbl -> SetStatus(This,status) ) 

#define IVdsLun_QueryMaxLunExtendSize(This,pDriveIdArray,lNumberOfDrives,pullMaxBytesToBeAdded)	\
    ( (This)->lpVtbl -> QueryMaxLunExtendSize(This,pDriveIdArray,lNumberOfDrives,pullMaxBytesToBeAdded) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsLun_INTERFACE_DEFINED__ */


#ifndef __IVdsLun2_INTERFACE_DEFINED__
#define __IVdsLun2_INTERFACE_DEFINED__

/* interface IVdsLun2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsLun2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e5b3a735-9efb-499a-8071-4394d9ee6fcb")
    IVdsLun2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryHints2( 
            /* [out] */ __RPC__out VDS_HINTS2 *pHints2) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ApplyHints2( 
            /* [in] */ __RPC__in VDS_HINTS2 *pHints2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsLun2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsLun2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsLun2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsLun2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryHints2 )( 
            __RPC__in IVdsLun2 * This,
            /* [out] */ __RPC__out VDS_HINTS2 *pHints2);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ApplyHints2 )( 
            __RPC__in IVdsLun2 * This,
            /* [in] */ __RPC__in VDS_HINTS2 *pHints2);
        
        END_INTERFACE
    } IVdsLun2Vtbl;

    interface IVdsLun2
    {
        CONST_VTBL struct IVdsLun2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsLun2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsLun2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsLun2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsLun2_QueryHints2(This,pHints2)	\
    ( (This)->lpVtbl -> QueryHints2(This,pHints2) ) 

#define IVdsLun2_ApplyHints2(This,pHints2)	\
    ( (This)->lpVtbl -> ApplyHints2(This,pHints2) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsLun2_INTERFACE_DEFINED__ */


#ifndef __IVdsLunNaming_INTERFACE_DEFINED__
#define __IVdsLunNaming_INTERFACE_DEFINED__

/* interface IVdsLunNaming */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsLunNaming;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("907504cb-6b4e-4d88-a34d-17ba661fbb06")
    IVdsLunNaming : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFriendlyName( 
            /* [string][in] */ __RPC__in_string LPWSTR pwszFriendlyName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsLunNamingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsLunNaming * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsLunNaming * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsLunNaming * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFriendlyName )( 
            __RPC__in IVdsLunNaming * This,
            /* [string][in] */ __RPC__in_string LPWSTR pwszFriendlyName);
        
        END_INTERFACE
    } IVdsLunNamingVtbl;

    interface IVdsLunNaming
    {
        CONST_VTBL struct IVdsLunNamingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsLunNaming_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsLunNaming_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsLunNaming_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsLunNaming_SetFriendlyName(This,pwszFriendlyName)	\
    ( (This)->lpVtbl -> SetFriendlyName(This,pwszFriendlyName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsLunNaming_INTERFACE_DEFINED__ */


#ifndef __IVdsLunNumber_INTERFACE_DEFINED__
#define __IVdsLunNumber_INTERFACE_DEFINED__

/* interface IVdsLunNumber */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsLunNumber;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d3f95e46-54b3-41f9-b678-0f1871443a08")
    IVdsLunNumber : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLunNumber( 
            /* [out] */ __RPC__out ULONG *pulLunNumber) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsLunNumberVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsLunNumber * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsLunNumber * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsLunNumber * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLunNumber )( 
            __RPC__in IVdsLunNumber * This,
            /* [out] */ __RPC__out ULONG *pulLunNumber);
        
        END_INTERFACE
    } IVdsLunNumberVtbl;

    interface IVdsLunNumber
    {
        CONST_VTBL struct IVdsLunNumberVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsLunNumber_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsLunNumber_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsLunNumber_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsLunNumber_GetLunNumber(This,pulLunNumber)	\
    ( (This)->lpVtbl -> GetLunNumber(This,pulLunNumber) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsLunNumber_INTERFACE_DEFINED__ */


#ifndef __IVdsLunControllerPorts_INTERFACE_DEFINED__
#define __IVdsLunControllerPorts_INTERFACE_DEFINED__

/* interface IVdsLunControllerPorts */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsLunControllerPorts;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("451fe266-da6d-406a-bb60-82e534f85aeb")
    IVdsLunControllerPorts : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AssociateControllerPorts( 
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfActiveControllerPorts) VDS_OBJECT_ID *pActiveControllerPortIdArray,
            /* [in] */ LONG lNumberOfActiveControllerPorts,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfInactiveControllerPorts) VDS_OBJECT_ID *pInactiveControllerPortIdArray,
            /* [in] */ LONG lNumberOfInactiveControllerPorts) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryActiveControllerPorts( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsLunControllerPortsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsLunControllerPorts * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsLunControllerPorts * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsLunControllerPorts * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AssociateControllerPorts )( 
            __RPC__in IVdsLunControllerPorts * This,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfActiveControllerPorts) VDS_OBJECT_ID *pActiveControllerPortIdArray,
            /* [in] */ LONG lNumberOfActiveControllerPorts,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfInactiveControllerPorts) VDS_OBJECT_ID *pInactiveControllerPortIdArray,
            /* [in] */ LONG lNumberOfInactiveControllerPorts);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryActiveControllerPorts )( 
            __RPC__in IVdsLunControllerPorts * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        END_INTERFACE
    } IVdsLunControllerPortsVtbl;

    interface IVdsLunControllerPorts
    {
        CONST_VTBL struct IVdsLunControllerPortsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsLunControllerPorts_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsLunControllerPorts_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsLunControllerPorts_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsLunControllerPorts_AssociateControllerPorts(This,pActiveControllerPortIdArray,lNumberOfActiveControllerPorts,pInactiveControllerPortIdArray,lNumberOfInactiveControllerPorts)	\
    ( (This)->lpVtbl -> AssociateControllerPorts(This,pActiveControllerPortIdArray,lNumberOfActiveControllerPorts,pInactiveControllerPortIdArray,lNumberOfInactiveControllerPorts) ) 

#define IVdsLunControllerPorts_QueryActiveControllerPorts(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryActiveControllerPorts(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsLunControllerPorts_INTERFACE_DEFINED__ */


#ifndef __IVdsLunMpio_INTERFACE_DEFINED__
#define __IVdsLunMpio_INTERFACE_DEFINED__

/* interface IVdsLunMpio */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsLunMpio;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7c5fbae3-333a-48a1-a982-33c15788cde3")
    IVdsLunMpio : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPathInfo( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfPaths) VDS_PATH_INFO **ppPaths,
            /* [out] */ __RPC__out LONG *plNumberOfPaths) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetLoadBalancePolicy( 
            /* [out] */ __RPC__out VDS_LOADBALANCE_POLICY_ENUM *pPolicy,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfPaths) VDS_PATH_POLICY **ppPaths,
            /* [out] */ __RPC__out LONG *plNumberOfPaths) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetLoadBalancePolicy( 
            /* [in] */ VDS_LOADBALANCE_POLICY_ENUM policy,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfPaths) VDS_PATH_POLICY *pPaths,
            /* [in] */ LONG lNumberOfPaths) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSupportedLbPolicies( 
            /* [out] */ __RPC__out ULONG *pulLbFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsLunMpioVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsLunMpio * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsLunMpio * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsLunMpio * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPathInfo )( 
            __RPC__in IVdsLunMpio * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfPaths) VDS_PATH_INFO **ppPaths,
            /* [out] */ __RPC__out LONG *plNumberOfPaths);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetLoadBalancePolicy )( 
            __RPC__in IVdsLunMpio * This,
            /* [out] */ __RPC__out VDS_LOADBALANCE_POLICY_ENUM *pPolicy,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfPaths) VDS_PATH_POLICY **ppPaths,
            /* [out] */ __RPC__out LONG *plNumberOfPaths);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetLoadBalancePolicy )( 
            __RPC__in IVdsLunMpio * This,
            /* [in] */ VDS_LOADBALANCE_POLICY_ENUM policy,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfPaths) VDS_PATH_POLICY *pPaths,
            /* [in] */ LONG lNumberOfPaths);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSupportedLbPolicies )( 
            __RPC__in IVdsLunMpio * This,
            /* [out] */ __RPC__out ULONG *pulLbFlags);
        
        END_INTERFACE
    } IVdsLunMpioVtbl;

    interface IVdsLunMpio
    {
        CONST_VTBL struct IVdsLunMpioVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsLunMpio_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsLunMpio_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsLunMpio_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsLunMpio_GetPathInfo(This,ppPaths,plNumberOfPaths)	\
    ( (This)->lpVtbl -> GetPathInfo(This,ppPaths,plNumberOfPaths) ) 

#define IVdsLunMpio_GetLoadBalancePolicy(This,pPolicy,ppPaths,plNumberOfPaths)	\
    ( (This)->lpVtbl -> GetLoadBalancePolicy(This,pPolicy,ppPaths,plNumberOfPaths) ) 

#define IVdsLunMpio_SetLoadBalancePolicy(This,policy,pPaths,lNumberOfPaths)	\
    ( (This)->lpVtbl -> SetLoadBalancePolicy(This,policy,pPaths,lNumberOfPaths) ) 

#define IVdsLunMpio_GetSupportedLbPolicies(This,pulLbFlags)	\
    ( (This)->lpVtbl -> GetSupportedLbPolicies(This,pulLbFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsLunMpio_INTERFACE_DEFINED__ */


#ifndef __IVdsLunIscsi_INTERFACE_DEFINED__
#define __IVdsLunIscsi_INTERFACE_DEFINED__

/* interface IVdsLunIscsi */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsLunIscsi;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0d7c1e64-b59b-45ae-b86a-2c2cc6a42067")
    IVdsLunIscsi : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AssociateTargets( 
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfTargets) VDS_OBJECT_ID *pTargetIdArray,
            /* [in] */ LONG lNumberOfTargets) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAssociatedTargets( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsLunIscsiVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsLunIscsi * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsLunIscsi * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsLunIscsi * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AssociateTargets )( 
            __RPC__in IVdsLunIscsi * This,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(lNumberOfTargets) VDS_OBJECT_ID *pTargetIdArray,
            /* [in] */ LONG lNumberOfTargets);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAssociatedTargets )( 
            __RPC__in IVdsLunIscsi * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        END_INTERFACE
    } IVdsLunIscsiVtbl;

    interface IVdsLunIscsi
    {
        CONST_VTBL struct IVdsLunIscsiVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsLunIscsi_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsLunIscsi_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsLunIscsi_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsLunIscsi_AssociateTargets(This,pTargetIdArray,lNumberOfTargets)	\
    ( (This)->lpVtbl -> AssociateTargets(This,pTargetIdArray,lNumberOfTargets) ) 

#define IVdsLunIscsi_QueryAssociatedTargets(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryAssociatedTargets(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsLunIscsi_INTERFACE_DEFINED__ */


#ifndef __IVdsLunPlex_INTERFACE_DEFINED__
#define __IVdsLunPlex_INTERFACE_DEFINED__

/* interface IVdsLunPlex */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsLunPlex;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0ee1a790-5d2e-4abb-8c99-c481e8be2138")
    IVdsLunPlex : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_LUN_PLEX_PROP *pPlexProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetLun( 
            /* [out] */ __RPC__deref_out_opt IVdsLun **ppLun) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryExtents( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_DRIVE_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryHints( 
            /* [out] */ __RPC__out VDS_HINTS *pHints) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ApplyHints( 
            /* [in] */ __RPC__in VDS_HINTS *pHints) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsLunPlexVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsLunPlex * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsLunPlex * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsLunPlex * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsLunPlex * This,
            /* [out] */ __RPC__out VDS_LUN_PLEX_PROP *pPlexProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetLun )( 
            __RPC__in IVdsLunPlex * This,
            /* [out] */ __RPC__deref_out_opt IVdsLun **ppLun);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryExtents )( 
            __RPC__in IVdsLunPlex * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_DRIVE_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryHints )( 
            __RPC__in IVdsLunPlex * This,
            /* [out] */ __RPC__out VDS_HINTS *pHints);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ApplyHints )( 
            __RPC__in IVdsLunPlex * This,
            /* [in] */ __RPC__in VDS_HINTS *pHints);
        
        END_INTERFACE
    } IVdsLunPlexVtbl;

    interface IVdsLunPlex
    {
        CONST_VTBL struct IVdsLunPlexVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsLunPlex_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsLunPlex_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsLunPlex_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsLunPlex_GetProperties(This,pPlexProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pPlexProp) ) 

#define IVdsLunPlex_GetLun(This,ppLun)	\
    ( (This)->lpVtbl -> GetLun(This,ppLun) ) 

#define IVdsLunPlex_QueryExtents(This,ppExtentArray,plNumberOfExtents)	\
    ( (This)->lpVtbl -> QueryExtents(This,ppExtentArray,plNumberOfExtents) ) 

#define IVdsLunPlex_QueryHints(This,pHints)	\
    ( (This)->lpVtbl -> QueryHints(This,pHints) ) 

#define IVdsLunPlex_ApplyHints(This,pHints)	\
    ( (This)->lpVtbl -> ApplyHints(This,pHints) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsLunPlex_INTERFACE_DEFINED__ */


#ifndef __IVdsIscsiPortal_INTERFACE_DEFINED__
#define __IVdsIscsiPortal_INTERFACE_DEFINED__

/* interface IVdsIscsiPortal */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsIscsiPortal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7fa1499d-ec85-4a8a-a47b-ff69201fcd34")
    IVdsIscsiPortal : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_ISCSI_PORTAL_PROP *pPortalProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSubSystem( 
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAssociatedPortalGroups( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ VDS_ISCSI_PORTAL_STATUS status) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetIpsecTunnelAddress( 
            /* [in] */ __RPC__in VDS_IPADDRESS *pTunnelAddress,
            /* [in] */ __RPC__in VDS_IPADDRESS *pDestinationAddress) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIpsecSecurity( 
            /* [in] */ __RPC__in VDS_IPADDRESS *pInitiatorPortalAddress,
            /* [out] */ __RPC__out ULONGLONG *pullSecurityFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetIpsecSecurity( 
            /* [in] */ __RPC__in VDS_IPADDRESS *pInitiatorPortalAddress,
            /* [in] */ ULONGLONG ullSecurityFlags,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsIscsiPortalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsIscsiPortal * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsIscsiPortal * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsIscsiPortal * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsIscsiPortal * This,
            /* [out] */ __RPC__out VDS_ISCSI_PORTAL_PROP *pPortalProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSubSystem )( 
            __RPC__in IVdsIscsiPortal * This,
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAssociatedPortalGroups )( 
            __RPC__in IVdsIscsiPortal * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            __RPC__in IVdsIscsiPortal * This,
            /* [in] */ VDS_ISCSI_PORTAL_STATUS status);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetIpsecTunnelAddress )( 
            __RPC__in IVdsIscsiPortal * This,
            /* [in] */ __RPC__in VDS_IPADDRESS *pTunnelAddress,
            /* [in] */ __RPC__in VDS_IPADDRESS *pDestinationAddress);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetIpsecSecurity )( 
            __RPC__in IVdsIscsiPortal * This,
            /* [in] */ __RPC__in VDS_IPADDRESS *pInitiatorPortalAddress,
            /* [out] */ __RPC__out ULONGLONG *pullSecurityFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetIpsecSecurity )( 
            __RPC__in IVdsIscsiPortal * This,
            /* [in] */ __RPC__in VDS_IPADDRESS *pInitiatorPortalAddress,
            /* [in] */ ULONGLONG ullSecurityFlags,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey);
        
        END_INTERFACE
    } IVdsIscsiPortalVtbl;

    interface IVdsIscsiPortal
    {
        CONST_VTBL struct IVdsIscsiPortalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsIscsiPortal_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsIscsiPortal_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsIscsiPortal_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsIscsiPortal_GetProperties(This,pPortalProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pPortalProp) ) 

#define IVdsIscsiPortal_GetSubSystem(This,ppSubSystem)	\
    ( (This)->lpVtbl -> GetSubSystem(This,ppSubSystem) ) 

#define IVdsIscsiPortal_QueryAssociatedPortalGroups(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryAssociatedPortalGroups(This,ppEnum) ) 

#define IVdsIscsiPortal_SetStatus(This,status)	\
    ( (This)->lpVtbl -> SetStatus(This,status) ) 

#define IVdsIscsiPortal_SetIpsecTunnelAddress(This,pTunnelAddress,pDestinationAddress)	\
    ( (This)->lpVtbl -> SetIpsecTunnelAddress(This,pTunnelAddress,pDestinationAddress) ) 

#define IVdsIscsiPortal_GetIpsecSecurity(This,pInitiatorPortalAddress,pullSecurityFlags)	\
    ( (This)->lpVtbl -> GetIpsecSecurity(This,pInitiatorPortalAddress,pullSecurityFlags) ) 

#define IVdsIscsiPortal_SetIpsecSecurity(This,pInitiatorPortalAddress,ullSecurityFlags,pIpsecKey)	\
    ( (This)->lpVtbl -> SetIpsecSecurity(This,pInitiatorPortalAddress,ullSecurityFlags,pIpsecKey) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsIscsiPortal_INTERFACE_DEFINED__ */


#ifndef __IVdsIscsiTarget_INTERFACE_DEFINED__
#define __IVdsIscsiTarget_INTERFACE_DEFINED__

/* interface IVdsIscsiTarget */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsIscsiTarget;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa8f5055-83e5-4bcc-aa73-19851a36a849")
    IVdsIscsiTarget : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_ISCSI_TARGET_PROP *pTargetProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSubSystem( 
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPortalGroups( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAssociatedLuns( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePortalGroup( 
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetFriendlyName( 
            /* [string][in] */ __RPC__in_string LPWSTR pwszFriendlyName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSharedSecret( 
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_SHARED_SECRET *pTargetSharedSecret,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszInitiatorName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RememberInitiatorSharedSecret( 
            /* [string][in] */ __RPC__in_string LPWSTR pwszInitiatorName,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_SHARED_SECRET *pInitiatorSharedSecret) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetConnectedInitiators( 
            /* [size_is][size_is][string][out] */ __RPC__deref_out_ecount_full_opt_string(*plNumberOfInitiators) LPWSTR **pppwszInitiatorList,
            /* [out] */ __RPC__out LONG *plNumberOfInitiators) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsIscsiTargetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsIscsiTarget * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsIscsiTarget * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [out] */ __RPC__out VDS_ISCSI_TARGET_PROP *pTargetProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSubSystem )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [out] */ __RPC__deref_out_opt IVdsSubSystem **ppSubSystem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryPortalGroups )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAssociatedLuns )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreatePortalGroup )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetFriendlyName )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [string][in] */ __RPC__in_string LPWSTR pwszFriendlyName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetSharedSecret )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_SHARED_SECRET *pTargetSharedSecret,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszInitiatorName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RememberInitiatorSharedSecret )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [string][in] */ __RPC__in_string LPWSTR pwszInitiatorName,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_SHARED_SECRET *pInitiatorSharedSecret);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetConnectedInitiators )( 
            __RPC__in IVdsIscsiTarget * This,
            /* [size_is][size_is][string][out] */ __RPC__deref_out_ecount_full_opt_string(*plNumberOfInitiators) LPWSTR **pppwszInitiatorList,
            /* [out] */ __RPC__out LONG *plNumberOfInitiators);
        
        END_INTERFACE
    } IVdsIscsiTargetVtbl;

    interface IVdsIscsiTarget
    {
        CONST_VTBL struct IVdsIscsiTargetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsIscsiTarget_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsIscsiTarget_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsIscsiTarget_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsIscsiTarget_GetProperties(This,pTargetProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pTargetProp) ) 

#define IVdsIscsiTarget_GetSubSystem(This,ppSubSystem)	\
    ( (This)->lpVtbl -> GetSubSystem(This,ppSubSystem) ) 

#define IVdsIscsiTarget_QueryPortalGroups(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryPortalGroups(This,ppEnum) ) 

#define IVdsIscsiTarget_QueryAssociatedLuns(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryAssociatedLuns(This,ppEnum) ) 

#define IVdsIscsiTarget_CreatePortalGroup(This,ppAsync)	\
    ( (This)->lpVtbl -> CreatePortalGroup(This,ppAsync) ) 

#define IVdsIscsiTarget_Delete(This,ppAsync)	\
    ( (This)->lpVtbl -> Delete(This,ppAsync) ) 

#define IVdsIscsiTarget_SetFriendlyName(This,pwszFriendlyName)	\
    ( (This)->lpVtbl -> SetFriendlyName(This,pwszFriendlyName) ) 

#define IVdsIscsiTarget_SetSharedSecret(This,pTargetSharedSecret,pwszInitiatorName)	\
    ( (This)->lpVtbl -> SetSharedSecret(This,pTargetSharedSecret,pwszInitiatorName) ) 

#define IVdsIscsiTarget_RememberInitiatorSharedSecret(This,pwszInitiatorName,pInitiatorSharedSecret)	\
    ( (This)->lpVtbl -> RememberInitiatorSharedSecret(This,pwszInitiatorName,pInitiatorSharedSecret) ) 

#define IVdsIscsiTarget_GetConnectedInitiators(This,pppwszInitiatorList,plNumberOfInitiators)	\
    ( (This)->lpVtbl -> GetConnectedInitiators(This,pppwszInitiatorList,plNumberOfInitiators) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsIscsiTarget_INTERFACE_DEFINED__ */


#ifndef __IVdsIscsiPortalGroup_INTERFACE_DEFINED__
#define __IVdsIscsiPortalGroup_INTERFACE_DEFINED__

/* interface IVdsIscsiPortalGroup */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsIscsiPortalGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fef5f89d-a3dd-4b36-bf28-e7dde045c593")
    IVdsIscsiPortalGroup : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_ISCSI_PORTALGROUP_PROP *pPortalGroupProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTarget( 
            /* [out] */ __RPC__deref_out_opt IVdsIscsiTarget **ppTarget) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAssociatedPortals( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddPortal( 
            /* [in] */ VDS_OBJECT_ID portalId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemovePortal( 
            /* [in] */ VDS_OBJECT_ID portalId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsIscsiPortalGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsIscsiPortalGroup * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsIscsiPortalGroup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsIscsiPortalGroup * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsIscsiPortalGroup * This,
            /* [out] */ __RPC__out VDS_ISCSI_PORTALGROUP_PROP *pPortalGroupProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTarget )( 
            __RPC__in IVdsIscsiPortalGroup * This,
            /* [out] */ __RPC__deref_out_opt IVdsIscsiTarget **ppTarget);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAssociatedPortals )( 
            __RPC__in IVdsIscsiPortalGroup * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddPortal )( 
            __RPC__in IVdsIscsiPortalGroup * This,
            /* [in] */ VDS_OBJECT_ID portalId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemovePortal )( 
            __RPC__in IVdsIscsiPortalGroup * This,
            /* [in] */ VDS_OBJECT_ID portalId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            __RPC__in IVdsIscsiPortalGroup * This,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsIscsiPortalGroupVtbl;

    interface IVdsIscsiPortalGroup
    {
        CONST_VTBL struct IVdsIscsiPortalGroupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsIscsiPortalGroup_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsIscsiPortalGroup_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsIscsiPortalGroup_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsIscsiPortalGroup_GetProperties(This,pPortalGroupProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pPortalGroupProp) ) 

#define IVdsIscsiPortalGroup_GetTarget(This,ppTarget)	\
    ( (This)->lpVtbl -> GetTarget(This,ppTarget) ) 

#define IVdsIscsiPortalGroup_QueryAssociatedPortals(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryAssociatedPortals(This,ppEnum) ) 

#define IVdsIscsiPortalGroup_AddPortal(This,portalId,ppAsync)	\
    ( (This)->lpVtbl -> AddPortal(This,portalId,ppAsync) ) 

#define IVdsIscsiPortalGroup_RemovePortal(This,portalId,ppAsync)	\
    ( (This)->lpVtbl -> RemovePortal(This,portalId,ppAsync) ) 

#define IVdsIscsiPortalGroup_Delete(This,ppAsync)	\
    ( (This)->lpVtbl -> Delete(This,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsIscsiPortalGroup_INTERFACE_DEFINED__ */


#ifndef __IVdsStoragePool_INTERFACE_DEFINED__
#define __IVdsStoragePool_INTERFACE_DEFINED__

/* interface IVdsStoragePool */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsStoragePool;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("932ca8cf-0eb3-4ba8-9620-22665d7f8450")
    IVdsStoragePool : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProvider( 
            /* [out] */ __RPC__deref_out_opt IVdsProvider **ppProvider) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_STORAGE_POOL_PROP *pStoragePoolProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAttributes( 
            /* [out] */ __RPC__out VDS_POOL_ATTRIBUTES *pStoragePoolAttributes) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDriveExtents( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_STORAGE_POOL_DRIVE_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAllocatedLuns( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAllocatedStoragePools( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsStoragePoolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsStoragePool * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsStoragePool * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsStoragePool * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProvider )( 
            __RPC__in IVdsStoragePool * This,
            /* [out] */ __RPC__deref_out_opt IVdsProvider **ppProvider);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsStoragePool * This,
            /* [out] */ __RPC__out VDS_STORAGE_POOL_PROP *pStoragePoolProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAttributes )( 
            __RPC__in IVdsStoragePool * This,
            /* [out] */ __RPC__out VDS_POOL_ATTRIBUTES *pStoragePoolAttributes);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryDriveExtents )( 
            __RPC__in IVdsStoragePool * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfExtents) VDS_STORAGE_POOL_DRIVE_EXTENT **ppExtentArray,
            /* [out] */ __RPC__out LONG *plNumberOfExtents);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAllocatedLuns )( 
            __RPC__in IVdsStoragePool * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAllocatedStoragePools )( 
            __RPC__in IVdsStoragePool * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        END_INTERFACE
    } IVdsStoragePoolVtbl;

    interface IVdsStoragePool
    {
        CONST_VTBL struct IVdsStoragePoolVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsStoragePool_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsStoragePool_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsStoragePool_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsStoragePool_GetProvider(This,ppProvider)	\
    ( (This)->lpVtbl -> GetProvider(This,ppProvider) ) 

#define IVdsStoragePool_GetProperties(This,pStoragePoolProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pStoragePoolProp) ) 

#define IVdsStoragePool_GetAttributes(This,pStoragePoolAttributes)	\
    ( (This)->lpVtbl -> GetAttributes(This,pStoragePoolAttributes) ) 

#define IVdsStoragePool_QueryDriveExtents(This,ppExtentArray,plNumberOfExtents)	\
    ( (This)->lpVtbl -> QueryDriveExtents(This,ppExtentArray,plNumberOfExtents) ) 

#define IVdsStoragePool_QueryAllocatedLuns(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryAllocatedLuns(This,ppEnum) ) 

#define IVdsStoragePool_QueryAllocatedStoragePools(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryAllocatedStoragePools(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsStoragePool_INTERFACE_DEFINED__ */


#ifndef __IVdsMaintenance_INTERFACE_DEFINED__
#define __IVdsMaintenance_INTERFACE_DEFINED__

/* interface IVdsMaintenance */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsMaintenance;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("daebeef3-8523-47ed-a2b9-05cecce2a1ae")
    IVdsMaintenance : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE StartMaintenance( 
            /* [in] */ VDS_MAINTENANCE_OPERATION operation) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE StopMaintenance( 
            /* [in] */ VDS_MAINTENANCE_OPERATION operation) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PulseMaintenance( 
            /* [in] */ VDS_MAINTENANCE_OPERATION operation,
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsMaintenanceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsMaintenance * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsMaintenance * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsMaintenance * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *StartMaintenance )( 
            __RPC__in IVdsMaintenance * This,
            /* [in] */ VDS_MAINTENANCE_OPERATION operation);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *StopMaintenance )( 
            __RPC__in IVdsMaintenance * This,
            /* [in] */ VDS_MAINTENANCE_OPERATION operation);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *PulseMaintenance )( 
            __RPC__in IVdsMaintenance * This,
            /* [in] */ VDS_MAINTENANCE_OPERATION operation,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IVdsMaintenanceVtbl;

    interface IVdsMaintenance
    {
        CONST_VTBL struct IVdsMaintenanceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsMaintenance_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsMaintenance_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsMaintenance_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsMaintenance_StartMaintenance(This,operation)	\
    ( (This)->lpVtbl -> StartMaintenance(This,operation) ) 

#define IVdsMaintenance_StopMaintenance(This,operation)	\
    ( (This)->lpVtbl -> StopMaintenance(This,operation) ) 

#define IVdsMaintenance_PulseMaintenance(This,operation,ulCount)	\
    ( (This)->lpVtbl -> PulseMaintenance(This,operation,ulCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsMaintenance_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vds_0000_0047 */
/* [local] */ 

#if (WINVER >= _WIN32_WINNT_WIN7)



typedef struct _VDS_CREATE_VDISK_PARAMETERS
    {
    GUID UniqueId;
    ULONGLONG MaximumSize;
    ULONG BlockSizeInBytes;
    ULONG SectorSizeInBytes;
    LPWSTR pParentPath;
    LPWSTR pSourcePath;
    } 	VDS_CREATE_VDISK_PARAMETERS;

typedef struct _VDS_CREATE_VDISK_PARAMETERS *PVDS_CREATE_VDISK_PARAMETERS;



extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0047_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0047_v0_0_s_ifspec;

#ifndef __IVdsVdProvider_INTERFACE_DEFINED__
#define __IVdsVdProvider_INTERFACE_DEFINED__

/* interface IVdsVdProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsVdProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b481498c-8354-45f9-84a0-0bdd2832a91f")
    IVdsVdProvider : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryVDisks( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateVDisk( 
            /* [in] */ __RPC__in PVIRTUAL_STORAGE_TYPE VirtualDeviceType,
            /* [string][in] */ __RPC__in_string LPWSTR pPath,
            /* [unique][string][in] */ __RPC__in_opt_string LPWSTR pStringSecurityDescriptor,
            /* [in] */ CREATE_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONG ProviderSpecificFlags,
            /* [in] */ ULONG Reserved,
            /* [in] */ __RPC__in PVDS_CREATE_VDISK_PARAMETERS pCreateDiskParameters,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddVDisk( 
            /* [in] */ __RPC__in PVIRTUAL_STORAGE_TYPE VirtualDeviceType,
            /* [string][in] */ __RPC__in_string LPWSTR pPath,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt IVdsVDisk **ppVDisk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDiskFromVDisk( 
            /* [in] */ __RPC__in_opt IVdsVDisk *pVDisk,
            /* [out] */ __RPC__deref_out_opt IVdsDisk **ppDisk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVDiskFromDisk( 
            /* [in] */ __RPC__in_opt IVdsDisk *pDisk,
            /* [out] */ __RPC__deref_out_opt IVdsVDisk **ppVDisk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsVdProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsVdProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsVdProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsVdProvider * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryVDisks )( 
            __RPC__in IVdsVdProvider * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateVDisk )( 
            __RPC__in IVdsVdProvider * This,
            /* [in] */ __RPC__in PVIRTUAL_STORAGE_TYPE VirtualDeviceType,
            /* [string][in] */ __RPC__in_string LPWSTR pPath,
            /* [unique][string][in] */ __RPC__in_opt_string LPWSTR pStringSecurityDescriptor,
            /* [in] */ CREATE_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONG ProviderSpecificFlags,
            /* [in] */ ULONG Reserved,
            /* [in] */ __RPC__in PVDS_CREATE_VDISK_PARAMETERS pCreateDiskParameters,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddVDisk )( 
            __RPC__in IVdsVdProvider * This,
            /* [in] */ __RPC__in PVIRTUAL_STORAGE_TYPE VirtualDeviceType,
            /* [string][in] */ __RPC__in_string LPWSTR pPath,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt IVdsVDisk **ppVDisk);
        
        HRESULT ( STDMETHODCALLTYPE *GetDiskFromVDisk )( 
            __RPC__in IVdsVdProvider * This,
            /* [in] */ __RPC__in_opt IVdsVDisk *pVDisk,
            /* [out] */ __RPC__deref_out_opt IVdsDisk **ppDisk);
        
        HRESULT ( STDMETHODCALLTYPE *GetVDiskFromDisk )( 
            __RPC__in IVdsVdProvider * This,
            /* [in] */ __RPC__in_opt IVdsDisk *pDisk,
            /* [out] */ __RPC__deref_out_opt IVdsVDisk **ppVDisk);
        
        END_INTERFACE
    } IVdsVdProviderVtbl;

    interface IVdsVdProvider
    {
        CONST_VTBL struct IVdsVdProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsVdProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsVdProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsVdProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsVdProvider_QueryVDisks(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryVDisks(This,ppEnum) ) 

#define IVdsVdProvider_CreateVDisk(This,VirtualDeviceType,pPath,pStringSecurityDescriptor,Flags,ProviderSpecificFlags,Reserved,pCreateDiskParameters,ppAsync)	\
    ( (This)->lpVtbl -> CreateVDisk(This,VirtualDeviceType,pPath,pStringSecurityDescriptor,Flags,ProviderSpecificFlags,Reserved,pCreateDiskParameters,ppAsync) ) 

#define IVdsVdProvider_AddVDisk(This,VirtualDeviceType,pPath,ppVDisk)	\
    ( (This)->lpVtbl -> AddVDisk(This,VirtualDeviceType,pPath,ppVDisk) ) 

#define IVdsVdProvider_GetDiskFromVDisk(This,pVDisk,ppDisk)	\
    ( (This)->lpVtbl -> GetDiskFromVDisk(This,pVDisk,ppDisk) ) 

#define IVdsVdProvider_GetVDiskFromDisk(This,pDisk,ppVDisk)	\
    ( (This)->lpVtbl -> GetVDiskFromDisk(This,pDisk,ppVDisk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsVdProvider_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vds_0000_0048 */
/* [local] */ 

typedef 
enum _VDS_VDISK_STATE
    {	VDS_VST_UNKNOWN	= 0,
	VDS_VST_ADDED	= ( VDS_VST_UNKNOWN + 1 ) ,
	VDS_VST_OPEN	= ( VDS_VST_ADDED + 1 ) ,
	VDS_VST_ATTACH_PENDING	= ( VDS_VST_OPEN + 1 ) ,
	VDS_VST_ATTACHED_NOT_OPEN	= ( VDS_VST_ATTACH_PENDING + 1 ) ,
	VDS_VST_ATTACHED	= ( VDS_VST_ATTACHED_NOT_OPEN + 1 ) ,
	VDS_VST_DETACH_PENDING	= ( VDS_VST_ATTACHED + 1 ) ,
	VDS_VST_COMPACTING	= ( VDS_VST_DETACH_PENDING + 1 ) ,
	VDS_VST_MERGING	= ( VDS_VST_COMPACTING + 1 ) ,
	VDS_VST_EXPANDING	= ( VDS_VST_MERGING + 1 ) ,
	VDS_VST_DELETED	= ( VDS_VST_EXPANDING + 1 ) ,
	VDS_VST_MAX	= ( VDS_VST_DELETED + 1 ) 
    } 	VDS_VDISK_STATE;

typedef struct _VDS_VDISK_PROPERTIES
    {
    VDS_OBJECT_ID Id;
    VDS_VDISK_STATE State;
    VIRTUAL_STORAGE_TYPE VirtualDeviceType;
    ULONGLONG VirtualSize;
    ULONGLONG PhysicalSize;
    LPWSTR pPath;
    LPWSTR pDeviceName;
    DEPENDENT_DISK_FLAG DiskFlag;
    BOOL bIsChild;
    LPWSTR pParentPath;
    } 	VDS_VDISK_PROPERTIES;

typedef struct _VDS_VDISK_PROPERTIES *PVDS_VDISK_PROPERTIES;



extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0048_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0048_v0_0_s_ifspec;

#ifndef __IVdsVDisk_INTERFACE_DEFINED__
#define __IVdsVDisk_INTERFACE_DEFINED__

/* interface IVdsVDisk */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsVDisk;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1e062b84-e5e6-4b4b-8a25-67b81e8f13e8")
    IVdsVDisk : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ VIRTUAL_DISK_ACCESS_MASK AccessMask,
            /* [in] */ OPEN_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONG ReadWriteDepth,
            /* [out] */ __RPC__deref_out_opt IVdsOpenVDisk **ppOpenVDisk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out PVDS_VDISK_PROPERTIES pDiskProperties) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHostVolume( 
            /* [out] */ __RPC__deref_out_opt IVdsVolume **ppVolume) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceName( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppDeviceName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsVDiskVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsVDisk * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsVDisk * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsVDisk * This);
        
        HRESULT ( STDMETHODCALLTYPE *Open )( 
            __RPC__in IVdsVDisk * This,
            /* [in] */ VIRTUAL_DISK_ACCESS_MASK AccessMask,
            /* [in] */ OPEN_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONG ReadWriteDepth,
            /* [out] */ __RPC__deref_out_opt IVdsOpenVDisk **ppOpenVDisk);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsVDisk * This,
            /* [out] */ __RPC__out PVDS_VDISK_PROPERTIES pDiskProperties);
        
        HRESULT ( STDMETHODCALLTYPE *GetHostVolume )( 
            __RPC__in IVdsVDisk * This,
            /* [out] */ __RPC__deref_out_opt IVdsVolume **ppVolume);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeviceName )( 
            __RPC__in IVdsVDisk * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppDeviceName);
        
        END_INTERFACE
    } IVdsVDiskVtbl;

    interface IVdsVDisk
    {
        CONST_VTBL struct IVdsVDiskVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsVDisk_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsVDisk_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsVDisk_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsVDisk_Open(This,AccessMask,Flags,ReadWriteDepth,ppOpenVDisk)	\
    ( (This)->lpVtbl -> Open(This,AccessMask,Flags,ReadWriteDepth,ppOpenVDisk) ) 

#define IVdsVDisk_GetProperties(This,pDiskProperties)	\
    ( (This)->lpVtbl -> GetProperties(This,pDiskProperties) ) 

#define IVdsVDisk_GetHostVolume(This,ppVolume)	\
    ( (This)->lpVtbl -> GetHostVolume(This,ppVolume) ) 

#define IVdsVDisk_GetDeviceName(This,ppDeviceName)	\
    ( (This)->lpVtbl -> GetDeviceName(This,ppDeviceName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsVDisk_INTERFACE_DEFINED__ */


#ifndef __IVdsOpenVDisk_INTERFACE_DEFINED__
#define __IVdsOpenVDisk_INTERFACE_DEFINED__

/* interface IVdsOpenVDisk */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsOpenVDisk;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("75c8f324-f715-4fe3-a28e-f9011b61a4a1")
    IVdsOpenVDisk : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Attach( 
            /* [unique][in] */ __RPC__in_opt LPWSTR pStringSecurityDescriptor,
            /* [in] */ ATTACH_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONG ProviderSpecificFlags,
            /* [in] */ ULONG TimeoutInMs,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Detach( 
            /* [in] */ DETACH_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONG ProviderSpecificFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DetachAndDelete( 
            /* [in] */ DETACH_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONG ProviderSpecificFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Compact( 
            /* [in] */ COMPACT_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONG Reserved,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Merge( 
            /* [in] */ MERGE_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONG MergeDepth,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Expand( 
            /* [in] */ EXPAND_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONGLONG NewSize,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsOpenVDiskVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsOpenVDisk * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsOpenVDisk * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsOpenVDisk * This);
        
        HRESULT ( STDMETHODCALLTYPE *Attach )( 
            __RPC__in IVdsOpenVDisk * This,
            /* [unique][in] */ __RPC__in_opt LPWSTR pStringSecurityDescriptor,
            /* [in] */ ATTACH_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONG ProviderSpecificFlags,
            /* [in] */ ULONG TimeoutInMs,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        HRESULT ( STDMETHODCALLTYPE *Detach )( 
            __RPC__in IVdsOpenVDisk * This,
            /* [in] */ DETACH_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONG ProviderSpecificFlags);
        
        HRESULT ( STDMETHODCALLTYPE *DetachAndDelete )( 
            __RPC__in IVdsOpenVDisk * This,
            /* [in] */ DETACH_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONG ProviderSpecificFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Compact )( 
            __RPC__in IVdsOpenVDisk * This,
            /* [in] */ COMPACT_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONG Reserved,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        HRESULT ( STDMETHODCALLTYPE *Merge )( 
            __RPC__in IVdsOpenVDisk * This,
            /* [in] */ MERGE_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONG MergeDepth,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        HRESULT ( STDMETHODCALLTYPE *Expand )( 
            __RPC__in IVdsOpenVDisk * This,
            /* [in] */ EXPAND_VIRTUAL_DISK_FLAG Flags,
            /* [in] */ ULONGLONG NewSize,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsOpenVDiskVtbl;

    interface IVdsOpenVDisk
    {
        CONST_VTBL struct IVdsOpenVDiskVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsOpenVDisk_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsOpenVDisk_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsOpenVDisk_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsOpenVDisk_Attach(This,pStringSecurityDescriptor,Flags,ProviderSpecificFlags,TimeoutInMs,ppAsync)	\
    ( (This)->lpVtbl -> Attach(This,pStringSecurityDescriptor,Flags,ProviderSpecificFlags,TimeoutInMs,ppAsync) ) 

#define IVdsOpenVDisk_Detach(This,Flags,ProviderSpecificFlags)	\
    ( (This)->lpVtbl -> Detach(This,Flags,ProviderSpecificFlags) ) 

#define IVdsOpenVDisk_DetachAndDelete(This,Flags,ProviderSpecificFlags)	\
    ( (This)->lpVtbl -> DetachAndDelete(This,Flags,ProviderSpecificFlags) ) 

#define IVdsOpenVDisk_Compact(This,Flags,Reserved,ppAsync)	\
    ( (This)->lpVtbl -> Compact(This,Flags,Reserved,ppAsync) ) 

#define IVdsOpenVDisk_Merge(This,Flags,MergeDepth,ppAsync)	\
    ( (This)->lpVtbl -> Merge(This,Flags,MergeDepth,ppAsync) ) 

#define IVdsOpenVDisk_Expand(This,Flags,NewSize,ppAsync)	\
    ( (This)->lpVtbl -> Expand(This,Flags,NewSize,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsOpenVDisk_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vds_0000_0050 */
/* [local] */ 

#define	VDS_ATTACH_VIRTUAL_DISK_FLAG_USE_FILE_ACL	( 0x1 )

#endif // _WIN32_WINNT_WIN7


















// {9C38ED61-D565-4728-AEEE-C80952F0ECDE}
DEFINE_GUID(CLSID_VdsLoader, 
 0X9C38ED61,0xD565,0x4728,0xAE,0xEE,0xC8,0x09,0x52,0xF0,0xEC,0xDE);

// {7D1933CB-86F6-4A98-8628-01BE94C9A575}
DEFINE_GUID(CLSID_VdsService, 
 0x7D1933CB,0x86F6,0x4A98,0x86,0x28,0x01,0xBE,0x94,0xC9,0xA5,0x75);

#define	MAX_FS_NAME_SIZE	( 8 )

#define	MAX_FS_FORMAT_SUPPORT_NAME_SIZE	( 32 )

#define	MAX_FS_ALLOWED_CLUSTER_SIZES_SIZE	( 32 )

typedef 
enum _VDS_SERVICE_FLAG
    {	VDS_SVF_SUPPORT_DYNAMIC	= 0x1,
	VDS_SVF_SUPPORT_FAULT_TOLERANT	= 0x2,
	VDS_SVF_SUPPORT_GPT	= 0x4,
	VDS_SVF_SUPPORT_DYNAMIC_1394	= 0x8,
	VDS_SVF_CLUSTER_SERVICE_CONFIGURED	= 0x10,
	VDS_SVF_AUTO_MOUNT_OFF	= 0x20,
	VDS_SVF_OS_UNINSTALL_VALID	= 0x40,
	VDS_SVF_EFI	= 0x80,
	VDS_SVF_SUPPORT_MIRROR	= 0x100L,
	VDS_SVF_SUPPORT_RAID5	= 0x200L
    } 	VDS_SERVICE_FLAG;

typedef struct _VDS_SERVICE_PROP
    {
    LPWSTR pwszVersion;
    ULONG ulFlags;
    } 	VDS_SERVICE_PROP;

typedef 
enum _VDS_SAN_POLICY
    {	VDS_SP_UNKNOWN	= 0,
	VDS_SP_ONLINE	= 0x1,
	VDS_SP_OFFLINE_SHARED	= 0x2,
	VDS_SP_OFFLINE	= 0x3
    } 	VDS_SAN_POLICY;

typedef struct VDS_REPARSE_POINT_PROP
    {
    VDS_OBJECT_ID SourceVolumeId;
    LPWSTR pwszPath;
    } 	VDS_REPARSE_POINT_PROP;

typedef struct VDS_REPARSE_POINT_PROP *PVDS_REPARSE_POINT_PROP;

typedef 
enum _VDS_DRIVE_LETTER_FLAG
    {	VDS_DLF_NON_PERSISTENT	= 0x1
    } 	VDS_DRIVE_LETTER_FLAG;

typedef struct _VDS_DRIVE_LETTER_PROP
    {
    WCHAR wcLetter;
    VDS_OBJECT_ID volumeId;
    ULONG ulFlags;
    BOOL bUsed;
    } 	VDS_DRIVE_LETTER_PROP;

typedef struct _VDS_DRIVE_LETTER_PROP *PVDS_DRIVE_LETTER_PROP;

typedef 
enum _VDS_FILE_SYSTEM_FLAG
    {	VDS_FSF_SUPPORT_FORMAT	= 0x1,
	VDS_FSF_SUPPORT_QUICK_FORMAT	= 0x2,
	VDS_FSF_SUPPORT_COMPRESS	= 0x4,
	VDS_FSF_SUPPORT_SPECIFY_LABEL	= 0x8,
	VDS_FSF_SUPPORT_MOUNT_POINT	= 0x10,
	VDS_FSF_SUPPORT_REMOVABLE_MEDIA	= 0x20,
	VDS_FSF_SUPPORT_EXTEND	= 0x40,
	VDS_FSF_ALLOCATION_UNIT_512	= 0x10000,
	VDS_FSF_ALLOCATION_UNIT_1K	= 0x20000,
	VDS_FSF_ALLOCATION_UNIT_2K	= 0x40000,
	VDS_FSF_ALLOCATION_UNIT_4K	= 0x80000,
	VDS_FSF_ALLOCATION_UNIT_8K	= 0x100000,
	VDS_FSF_ALLOCATION_UNIT_16K	= 0x200000,
	VDS_FSF_ALLOCATION_UNIT_32K	= 0x400000,
	VDS_FSF_ALLOCATION_UNIT_64K	= 0x800000,
	VDS_FSF_ALLOCATION_UNIT_128K	= 0x1000000,
	VDS_FSF_ALLOCATION_UNIT_256K	= 0x2000000
    } 	VDS_FILE_SYSTEM_FLAG;

typedef struct _VDS_FILE_SYSTEM_TYPE_PROP
    {
    VDS_FILE_SYSTEM_TYPE type;
    WCHAR wszName[ 8 ];
    ULONG ulFlags;
    ULONG ulCompressionFlags;
    ULONG ulMaxLableLength;
    LPWSTR pwszIllegalLabelCharSet;
    } 	VDS_FILE_SYSTEM_TYPE_PROP;

typedef struct _VDS_FILE_SYSTEM_TYPE_PROP *PVDS_FILE_SYSTEM_TYPE_PROP;

typedef 
enum _VDS_FILE_SYSTEM_FORMAT_SUPPORT_FLAG
    {	VDS_FSS_DEFAULT	= 0x1,
	VDS_FSS_PREVIOUS_REVISION	= 0x2,
	VDS_FSS_RECOMMENDED	= 0x4
    } 	VDS_FILE_SYSTEM_FORMAT_SUPPORT_FLAG;

typedef struct _VDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP
    {
    ULONG ulFlags;
    USHORT usRevision;
    ULONG ulDefaultUnitAllocationSize;
    ULONG rgulAllowedUnitAllocationSizes[ 32 ];
    WCHAR wszName[ 32 ];
    } 	VDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP;

typedef struct _VDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP *PVDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP;

typedef 
enum _VDS_FILE_SYSTEM_PROP_FLAG
    {	VDS_FPF_COMPRESSED	= 0x1
    } 	VDS_FILE_SYSTEM_PROP_FLAG;

typedef 
enum _VDS_FORMAT_OPTION_FLAGS
    {	VDS_FSOF_NONE	= 0,
	VDS_FSOF_FORCE	= 0x1,
	VDS_FSOF_QUICK	= 0x2,
	VDS_FSOF_COMPRESSION	= 0x4,
	VDS_FSOF_DUPLICATE_METADATA	= 0x8
    } 	VDS_FORMAT_OPTION_FLAGS;

typedef struct _VDS_FILE_SYSTEM_PROP
    {
    VDS_FILE_SYSTEM_TYPE type;
    VDS_OBJECT_ID volumeId;
    ULONG ulFlags;
    ULONGLONG ullTotalAllocationUnits;
    ULONGLONG ullAvailableAllocationUnits;
    ULONG ulAllocationUnitSize;
    LPWSTR pwszLabel;
    } 	VDS_FILE_SYSTEM_PROP;

typedef struct _VDS_FILE_SYSTEM_PROP *PVDS_FILE_SYSTEM_PROP;

typedef 
enum _VDS_QUERY_PROVIDER_FLAG
    {	VDS_QUERY_SOFTWARE_PROVIDERS	= 0x1,
	VDS_QUERY_HARDWARE_PROVIDERS	= 0x2,
	VDS_QUERY_VIRTUALDISK_PROVIDERS	= 0x4
    } 	VDS_QUERY_PROVIDER_FLAG;



extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0050_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vds_0000_0050_v0_0_s_ifspec;

#ifndef __IVdsServiceLoader_INTERFACE_DEFINED__
#define __IVdsServiceLoader_INTERFACE_DEFINED__

/* interface IVdsServiceLoader */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsServiceLoader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e0393303-90d4-4a97-ab71-e9b671ee2729")
    IVdsServiceLoader : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE LoadService( 
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszMachineName,
            /* [out] */ __RPC__deref_out_opt IVdsService **ppService) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsServiceLoaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsServiceLoader * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsServiceLoader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsServiceLoader * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *LoadService )( 
            __RPC__in IVdsServiceLoader * This,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszMachineName,
            /* [out] */ __RPC__deref_out_opt IVdsService **ppService);
        
        END_INTERFACE
    } IVdsServiceLoaderVtbl;

    interface IVdsServiceLoader
    {
        CONST_VTBL struct IVdsServiceLoaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsServiceLoader_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsServiceLoader_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsServiceLoader_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsServiceLoader_LoadService(This,pwszMachineName,ppService)	\
    ( (This)->lpVtbl -> LoadService(This,pwszMachineName,ppService) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsServiceLoader_INTERFACE_DEFINED__ */


#ifndef __IVdsService_INTERFACE_DEFINED__
#define __IVdsService_INTERFACE_DEFINED__

/* interface IVdsService */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0818a8ef-9ba9-40d8-a6f9-e22833cc771e")
    IVdsService : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsServiceReady( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE WaitForServiceReady( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_SERVICE_PROP *pServiceProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryProviders( 
            /* [in] */ DWORD masks,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryMaskedDisks( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryUnallocatedDisks( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ VDS_OBJECT_ID ObjectId,
            /* [in] */ VDS_OBJECT_TYPE type,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppObjectUnk) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDriveLetters( 
            /* [in] */ WCHAR wcFirstLetter,
            /* [in] */ DWORD count,
            /* [size_is][out] */ __RPC__out_ecount_full(count) VDS_DRIVE_LETTER_PROP *pDriveLetterPropArray) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryFileSystemTypes( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfFileSystems) VDS_FILE_SYSTEM_TYPE_PROP **ppFileSystemTypeProps,
            /* [out] */ __RPC__out LONG *plNumberOfFileSystems) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reenumerate( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CleanupObsoleteMountPoints( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ __RPC__in_opt IVdsAdviseSink *pSink,
            /* [out] */ __RPC__out DWORD *pdwCookie) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reboot( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ ULONG ulFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ClearFlags( 
            /* [in] */ ULONG ulFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsService * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsService * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *IsServiceReady )( 
            __RPC__in IVdsService * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *WaitForServiceReady )( 
            __RPC__in IVdsService * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsService * This,
            /* [out] */ __RPC__out VDS_SERVICE_PROP *pServiceProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryProviders )( 
            __RPC__in IVdsService * This,
            /* [in] */ DWORD masks,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryMaskedDisks )( 
            __RPC__in IVdsService * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryUnallocatedDisks )( 
            __RPC__in IVdsService * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            __RPC__in IVdsService * This,
            /* [in] */ VDS_OBJECT_ID ObjectId,
            /* [in] */ VDS_OBJECT_TYPE type,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppObjectUnk);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryDriveLetters )( 
            __RPC__in IVdsService * This,
            /* [in] */ WCHAR wcFirstLetter,
            /* [in] */ DWORD count,
            /* [size_is][out] */ __RPC__out_ecount_full(count) VDS_DRIVE_LETTER_PROP *pDriveLetterPropArray);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryFileSystemTypes )( 
            __RPC__in IVdsService * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfFileSystems) VDS_FILE_SYSTEM_TYPE_PROP **ppFileSystemTypeProps,
            /* [out] */ __RPC__out LONG *plNumberOfFileSystems);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reenumerate )( 
            __RPC__in IVdsService * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            __RPC__in IVdsService * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CleanupObsoleteMountPoints )( 
            __RPC__in IVdsService * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Advise )( 
            __RPC__in IVdsService * This,
            /* [in] */ __RPC__in_opt IVdsAdviseSink *pSink,
            /* [out] */ __RPC__out DWORD *pdwCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            __RPC__in IVdsService * This,
            /* [in] */ DWORD dwCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reboot )( 
            __RPC__in IVdsService * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            __RPC__in IVdsService * This,
            /* [in] */ ULONG ulFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ClearFlags )( 
            __RPC__in IVdsService * This,
            /* [in] */ ULONG ulFlags);
        
        END_INTERFACE
    } IVdsServiceVtbl;

    interface IVdsService
    {
        CONST_VTBL struct IVdsServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsService_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsService_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsService_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsService_IsServiceReady(This)	\
    ( (This)->lpVtbl -> IsServiceReady(This) ) 

#define IVdsService_WaitForServiceReady(This)	\
    ( (This)->lpVtbl -> WaitForServiceReady(This) ) 

#define IVdsService_GetProperties(This,pServiceProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pServiceProp) ) 

#define IVdsService_QueryProviders(This,masks,ppEnum)	\
    ( (This)->lpVtbl -> QueryProviders(This,masks,ppEnum) ) 

#define IVdsService_QueryMaskedDisks(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryMaskedDisks(This,ppEnum) ) 

#define IVdsService_QueryUnallocatedDisks(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryUnallocatedDisks(This,ppEnum) ) 

#define IVdsService_GetObject(This,ObjectId,type,ppObjectUnk)	\
    ( (This)->lpVtbl -> GetObject(This,ObjectId,type,ppObjectUnk) ) 

#define IVdsService_QueryDriveLetters(This,wcFirstLetter,count,pDriveLetterPropArray)	\
    ( (This)->lpVtbl -> QueryDriveLetters(This,wcFirstLetter,count,pDriveLetterPropArray) ) 

#define IVdsService_QueryFileSystemTypes(This,ppFileSystemTypeProps,plNumberOfFileSystems)	\
    ( (This)->lpVtbl -> QueryFileSystemTypes(This,ppFileSystemTypeProps,plNumberOfFileSystems) ) 

#define IVdsService_Reenumerate(This)	\
    ( (This)->lpVtbl -> Reenumerate(This) ) 

#define IVdsService_Refresh(This)	\
    ( (This)->lpVtbl -> Refresh(This) ) 

#define IVdsService_CleanupObsoleteMountPoints(This)	\
    ( (This)->lpVtbl -> CleanupObsoleteMountPoints(This) ) 

#define IVdsService_Advise(This,pSink,pdwCookie)	\
    ( (This)->lpVtbl -> Advise(This,pSink,pdwCookie) ) 

#define IVdsService_Unadvise(This,dwCookie)	\
    ( (This)->lpVtbl -> Unadvise(This,dwCookie) ) 

#define IVdsService_Reboot(This)	\
    ( (This)->lpVtbl -> Reboot(This) ) 

#define IVdsService_SetFlags(This,ulFlags)	\
    ( (This)->lpVtbl -> SetFlags(This,ulFlags) ) 

#define IVdsService_ClearFlags(This,ulFlags)	\
    ( (This)->lpVtbl -> ClearFlags(This,ulFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsService_INTERFACE_DEFINED__ */


#ifndef __IVdsServiceUninstallDisk_INTERFACE_DEFINED__
#define __IVdsServiceUninstallDisk_INTERFACE_DEFINED__

/* interface IVdsServiceUninstallDisk */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsServiceUninstallDisk;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B6B22DA8-F903-4be7-B492-C09D875AC9DA")
    IVdsServiceUninstallDisk : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDiskIdFromLunInfo( 
            /* [in] */ __RPC__in VDS_LUN_INFORMATION *pLunInfo,
            /* [out] */ __RPC__out VDS_OBJECT_ID *pDiskId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UninstallDisks( 
            /* [size_is][in] */ __RPC__in_ecount_full(ulCount) VDS_OBJECT_ID *pDiskIdArray,
            /* [in] */ ULONG ulCount,
            /* [in] */ BOOLEAN bForce,
            /* [out] */ __RPC__out BOOLEAN *pbReboot,
            /* [size_is][out] */ __RPC__out_ecount_full(ulCount) HRESULT *pResults) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsServiceUninstallDiskVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsServiceUninstallDisk * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsServiceUninstallDisk * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsServiceUninstallDisk * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDiskIdFromLunInfo )( 
            __RPC__in IVdsServiceUninstallDisk * This,
            /* [in] */ __RPC__in VDS_LUN_INFORMATION *pLunInfo,
            /* [out] */ __RPC__out VDS_OBJECT_ID *pDiskId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *UninstallDisks )( 
            __RPC__in IVdsServiceUninstallDisk * This,
            /* [size_is][in] */ __RPC__in_ecount_full(ulCount) VDS_OBJECT_ID *pDiskIdArray,
            /* [in] */ ULONG ulCount,
            /* [in] */ BOOLEAN bForce,
            /* [out] */ __RPC__out BOOLEAN *pbReboot,
            /* [size_is][out] */ __RPC__out_ecount_full(ulCount) HRESULT *pResults);
        
        END_INTERFACE
    } IVdsServiceUninstallDiskVtbl;

    interface IVdsServiceUninstallDisk
    {
        CONST_VTBL struct IVdsServiceUninstallDiskVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsServiceUninstallDisk_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsServiceUninstallDisk_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsServiceUninstallDisk_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsServiceUninstallDisk_GetDiskIdFromLunInfo(This,pLunInfo,pDiskId)	\
    ( (This)->lpVtbl -> GetDiskIdFromLunInfo(This,pLunInfo,pDiskId) ) 

#define IVdsServiceUninstallDisk_UninstallDisks(This,pDiskIdArray,ulCount,bForce,pbReboot,pResults)	\
    ( (This)->lpVtbl -> UninstallDisks(This,pDiskIdArray,ulCount,bForce,pbReboot,pResults) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsServiceUninstallDisk_INTERFACE_DEFINED__ */


#ifndef __IVdsServiceHba_INTERFACE_DEFINED__
#define __IVdsServiceHba_INTERFACE_DEFINED__

/* interface IVdsServiceHba */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsServiceHba;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0ac13689-3134-47c6-a17c-4669216801be")
    IVdsServiceHba : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryHbaPorts( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsServiceHbaVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsServiceHba * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsServiceHba * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsServiceHba * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryHbaPorts )( 
            __RPC__in IVdsServiceHba * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        END_INTERFACE
    } IVdsServiceHbaVtbl;

    interface IVdsServiceHba
    {
        CONST_VTBL struct IVdsServiceHbaVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsServiceHba_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsServiceHba_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsServiceHba_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsServiceHba_QueryHbaPorts(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryHbaPorts(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsServiceHba_INTERFACE_DEFINED__ */


#ifndef __IVdsServiceIscsi_INTERFACE_DEFINED__
#define __IVdsServiceIscsi_INTERFACE_DEFINED__

/* interface IVdsServiceIscsi */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsServiceIscsi;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("14fbe036-3ed7-4e10-90e9-a5ff991aff01")
    IVdsServiceIscsi : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInitiatorName( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszIscsiName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryInitiatorAdapters( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetIpsecGroupPresharedKey( 
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetAllIpsecTunnelAddresses( 
            /* [in] */ __RPC__in VDS_IPADDRESS *pTunnelAddress,
            /* [in] */ __RPC__in VDS_IPADDRESS *pDestinationAddress) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetAllIpsecSecurity( 
            /* [in] */ VDS_OBJECT_ID targetPortalId,
            /* [in] */ ULONGLONG ullSecurityFlags,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetInitiatorSharedSecret( 
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_SHARED_SECRET *pInitiatorSharedSecret,
            /* [in] */ VDS_OBJECT_ID targetId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RememberTargetSharedSecret( 
            /* [in] */ VDS_OBJECT_ID targetId,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_SHARED_SECRET *pTargetSharedSecret) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsServiceIscsiVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsServiceIscsi * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsServiceIscsi * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsServiceIscsi * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetInitiatorName )( 
            __RPC__in IVdsServiceIscsi * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszIscsiName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryInitiatorAdapters )( 
            __RPC__in IVdsServiceIscsi * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetIpsecGroupPresharedKey )( 
            __RPC__in IVdsServiceIscsi * This,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetAllIpsecTunnelAddresses )( 
            __RPC__in IVdsServiceIscsi * This,
            /* [in] */ __RPC__in VDS_IPADDRESS *pTunnelAddress,
            /* [in] */ __RPC__in VDS_IPADDRESS *pDestinationAddress);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetAllIpsecSecurity )( 
            __RPC__in IVdsServiceIscsi * This,
            /* [in] */ VDS_OBJECT_ID targetPortalId,
            /* [in] */ ULONGLONG ullSecurityFlags,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetInitiatorSharedSecret )( 
            __RPC__in IVdsServiceIscsi * This,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_SHARED_SECRET *pInitiatorSharedSecret,
            /* [in] */ VDS_OBJECT_ID targetId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RememberTargetSharedSecret )( 
            __RPC__in IVdsServiceIscsi * This,
            /* [in] */ VDS_OBJECT_ID targetId,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_SHARED_SECRET *pTargetSharedSecret);
        
        END_INTERFACE
    } IVdsServiceIscsiVtbl;

    interface IVdsServiceIscsi
    {
        CONST_VTBL struct IVdsServiceIscsiVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsServiceIscsi_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsServiceIscsi_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsServiceIscsi_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsServiceIscsi_GetInitiatorName(This,ppwszIscsiName)	\
    ( (This)->lpVtbl -> GetInitiatorName(This,ppwszIscsiName) ) 

#define IVdsServiceIscsi_QueryInitiatorAdapters(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryInitiatorAdapters(This,ppEnum) ) 

#define IVdsServiceIscsi_SetIpsecGroupPresharedKey(This,pIpsecKey)	\
    ( (This)->lpVtbl -> SetIpsecGroupPresharedKey(This,pIpsecKey) ) 

#define IVdsServiceIscsi_SetAllIpsecTunnelAddresses(This,pTunnelAddress,pDestinationAddress)	\
    ( (This)->lpVtbl -> SetAllIpsecTunnelAddresses(This,pTunnelAddress,pDestinationAddress) ) 

#define IVdsServiceIscsi_SetAllIpsecSecurity(This,targetPortalId,ullSecurityFlags,pIpsecKey)	\
    ( (This)->lpVtbl -> SetAllIpsecSecurity(This,targetPortalId,ullSecurityFlags,pIpsecKey) ) 

#define IVdsServiceIscsi_SetInitiatorSharedSecret(This,pInitiatorSharedSecret,targetId)	\
    ( (This)->lpVtbl -> SetInitiatorSharedSecret(This,pInitiatorSharedSecret,targetId) ) 

#define IVdsServiceIscsi_RememberTargetSharedSecret(This,targetId,pTargetSharedSecret)	\
    ( (This)->lpVtbl -> RememberTargetSharedSecret(This,targetId,pTargetSharedSecret) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsServiceIscsi_INTERFACE_DEFINED__ */


#ifndef __IVdsServiceInitialization_INTERFACE_DEFINED__
#define __IVdsServiceInitialization_INTERFACE_DEFINED__

/* interface IVdsServiceInitialization */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsServiceInitialization;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4afc3636-db01-4052-80c3-03bbcb8d3c69")
    IVdsServiceInitialization : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszMachineName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsServiceInitializationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsServiceInitialization * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsServiceInitialization * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsServiceInitialization * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in IVdsServiceInitialization * This,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszMachineName);
        
        END_INTERFACE
    } IVdsServiceInitializationVtbl;

    interface IVdsServiceInitialization
    {
        CONST_VTBL struct IVdsServiceInitializationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsServiceInitialization_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsServiceInitialization_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsServiceInitialization_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsServiceInitialization_Initialize(This,pwszMachineName)	\
    ( (This)->lpVtbl -> Initialize(This,pwszMachineName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsServiceInitialization_INTERFACE_DEFINED__ */


#ifndef __IVdsHbaPort_INTERFACE_DEFINED__
#define __IVdsHbaPort_INTERFACE_DEFINED__

/* interface IVdsHbaPort */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsHbaPort;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2abd757f-2851-4997-9a13-47d2a885d6ca")
    IVdsHbaPort : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_HBAPORT_PROP *pHbaPortProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetAllPathStatuses( 
            /* [in] */ VDS_PATH_STATUS status) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsHbaPortVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsHbaPort * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsHbaPort * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsHbaPort * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsHbaPort * This,
            /* [out] */ __RPC__out VDS_HBAPORT_PROP *pHbaPortProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetAllPathStatuses )( 
            __RPC__in IVdsHbaPort * This,
            /* [in] */ VDS_PATH_STATUS status);
        
        END_INTERFACE
    } IVdsHbaPortVtbl;

    interface IVdsHbaPort
    {
        CONST_VTBL struct IVdsHbaPortVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsHbaPort_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsHbaPort_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsHbaPort_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsHbaPort_GetProperties(This,pHbaPortProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pHbaPortProp) ) 

#define IVdsHbaPort_SetAllPathStatuses(This,status)	\
    ( (This)->lpVtbl -> SetAllPathStatuses(This,status) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsHbaPort_INTERFACE_DEFINED__ */


#ifndef __IVdsIscsiInitiatorAdapter_INTERFACE_DEFINED__
#define __IVdsIscsiInitiatorAdapter_INTERFACE_DEFINED__

/* interface IVdsIscsiInitiatorAdapter */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsIscsiInitiatorAdapter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b07fedd4-1682-4440-9189-a39b55194dc5")
    IVdsIscsiInitiatorAdapter : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_ISCSI_INITIATOR_ADAPTER_PROP *pInitiatorAdapterProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryInitiatorPortals( 
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE LoginToTarget( 
            /* [in] */ VDS_ISCSI_LOGIN_TYPE loginType,
            /* [in] */ VDS_OBJECT_ID targetId,
            /* [in] */ VDS_OBJECT_ID targetPortalId,
            /* [in] */ VDS_OBJECT_ID initiatorPortalId,
            /* [in] */ ULONG ulLoginFlags,
            /* [in] */ BOOL bHeaderDigest,
            /* [in] */ BOOL bDataDigest,
            /* [in] */ VDS_ISCSI_AUTH_TYPE authType,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE LogoutFromTarget( 
            /* [in] */ VDS_OBJECT_ID targetId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsIscsiInitiatorAdapterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsIscsiInitiatorAdapter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsIscsiInitiatorAdapter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsIscsiInitiatorAdapter * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsIscsiInitiatorAdapter * This,
            /* [out] */ __RPC__out VDS_ISCSI_INITIATOR_ADAPTER_PROP *pInitiatorAdapterProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryInitiatorPortals )( 
            __RPC__in IVdsIscsiInitiatorAdapter * This,
            /* [out] */ __RPC__deref_out_opt IEnumVdsObject **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *LoginToTarget )( 
            __RPC__in IVdsIscsiInitiatorAdapter * This,
            /* [in] */ VDS_ISCSI_LOGIN_TYPE loginType,
            /* [in] */ VDS_OBJECT_ID targetId,
            /* [in] */ VDS_OBJECT_ID targetPortalId,
            /* [in] */ VDS_OBJECT_ID initiatorPortalId,
            /* [in] */ ULONG ulLoginFlags,
            /* [in] */ BOOL bHeaderDigest,
            /* [in] */ BOOL bDataDigest,
            /* [in] */ VDS_ISCSI_AUTH_TYPE authType,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *LogoutFromTarget )( 
            __RPC__in IVdsIscsiInitiatorAdapter * This,
            /* [in] */ VDS_OBJECT_ID targetId,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsIscsiInitiatorAdapterVtbl;

    interface IVdsIscsiInitiatorAdapter
    {
        CONST_VTBL struct IVdsIscsiInitiatorAdapterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsIscsiInitiatorAdapter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsIscsiInitiatorAdapter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsIscsiInitiatorAdapter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsIscsiInitiatorAdapter_GetProperties(This,pInitiatorAdapterProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pInitiatorAdapterProp) ) 

#define IVdsIscsiInitiatorAdapter_QueryInitiatorPortals(This,ppEnum)	\
    ( (This)->lpVtbl -> QueryInitiatorPortals(This,ppEnum) ) 

#define IVdsIscsiInitiatorAdapter_LoginToTarget(This,loginType,targetId,targetPortalId,initiatorPortalId,ulLoginFlags,bHeaderDigest,bDataDigest,authType,ppAsync)	\
    ( (This)->lpVtbl -> LoginToTarget(This,loginType,targetId,targetPortalId,initiatorPortalId,ulLoginFlags,bHeaderDigest,bDataDigest,authType,ppAsync) ) 

#define IVdsIscsiInitiatorAdapter_LogoutFromTarget(This,targetId,ppAsync)	\
    ( (This)->lpVtbl -> LogoutFromTarget(This,targetId,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsIscsiInitiatorAdapter_INTERFACE_DEFINED__ */


#ifndef __IVdsIscsiInitiatorPortal_INTERFACE_DEFINED__
#define __IVdsIscsiInitiatorPortal_INTERFACE_DEFINED__

/* interface IVdsIscsiInitiatorPortal */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsIscsiInitiatorPortal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("38a0a9ab-7cc8-4693-ac07-1f28bd03c3da")
    IVdsIscsiInitiatorPortal : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [out] */ __RPC__out VDS_ISCSI_INITIATOR_PORTAL_PROP *pInitiatorPortalProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetInitiatorAdapter( 
            /* [out] */ __RPC__deref_out_opt IVdsIscsiInitiatorAdapter **ppInitiatorAdapter) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetIpsecTunnelAddress( 
            /* [in] */ __RPC__in VDS_IPADDRESS *pTunnelAddress,
            /* [in] */ __RPC__in VDS_IPADDRESS *pDestinationAddress) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIpsecSecurity( 
            /* [in] */ VDS_OBJECT_ID targetPortalId,
            /* [out] */ __RPC__out ULONGLONG *pullSecurityFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetIpsecSecurity( 
            /* [in] */ VDS_OBJECT_ID targetPortalId,
            /* [in] */ ULONGLONG ullSecurityFlags,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsIscsiInitiatorPortalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsIscsiInitiatorPortal * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsIscsiInitiatorPortal * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsIscsiInitiatorPortal * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            __RPC__in IVdsIscsiInitiatorPortal * This,
            /* [out] */ __RPC__out VDS_ISCSI_INITIATOR_PORTAL_PROP *pInitiatorPortalProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetInitiatorAdapter )( 
            __RPC__in IVdsIscsiInitiatorPortal * This,
            /* [out] */ __RPC__deref_out_opt IVdsIscsiInitiatorAdapter **ppInitiatorAdapter);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetIpsecTunnelAddress )( 
            __RPC__in IVdsIscsiInitiatorPortal * This,
            /* [in] */ __RPC__in VDS_IPADDRESS *pTunnelAddress,
            /* [in] */ __RPC__in VDS_IPADDRESS *pDestinationAddress);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetIpsecSecurity )( 
            __RPC__in IVdsIscsiInitiatorPortal * This,
            /* [in] */ VDS_OBJECT_ID targetPortalId,
            /* [out] */ __RPC__out ULONGLONG *pullSecurityFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetIpsecSecurity )( 
            __RPC__in IVdsIscsiInitiatorPortal * This,
            /* [in] */ VDS_OBJECT_ID targetPortalId,
            /* [in] */ ULONGLONG ullSecurityFlags,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey);
        
        END_INTERFACE
    } IVdsIscsiInitiatorPortalVtbl;

    interface IVdsIscsiInitiatorPortal
    {
        CONST_VTBL struct IVdsIscsiInitiatorPortalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsIscsiInitiatorPortal_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsIscsiInitiatorPortal_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsIscsiInitiatorPortal_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsIscsiInitiatorPortal_GetProperties(This,pInitiatorPortalProp)	\
    ( (This)->lpVtbl -> GetProperties(This,pInitiatorPortalProp) ) 

#define IVdsIscsiInitiatorPortal_GetInitiatorAdapter(This,ppInitiatorAdapter)	\
    ( (This)->lpVtbl -> GetInitiatorAdapter(This,ppInitiatorAdapter) ) 

#define IVdsIscsiInitiatorPortal_SetIpsecTunnelAddress(This,pTunnelAddress,pDestinationAddress)	\
    ( (This)->lpVtbl -> SetIpsecTunnelAddress(This,pTunnelAddress,pDestinationAddress) ) 

#define IVdsIscsiInitiatorPortal_GetIpsecSecurity(This,targetPortalId,pullSecurityFlags)	\
    ( (This)->lpVtbl -> GetIpsecSecurity(This,targetPortalId,pullSecurityFlags) ) 

#define IVdsIscsiInitiatorPortal_SetIpsecSecurity(This,targetPortalId,ullSecurityFlags,pIpsecKey)	\
    ( (This)->lpVtbl -> SetIpsecSecurity(This,targetPortalId,ullSecurityFlags,pIpsecKey) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsIscsiInitiatorPortal_INTERFACE_DEFINED__ */


#ifndef __IVdsDiskPartitionMF_INTERFACE_DEFINED__
#define __IVdsDiskPartitionMF_INTERFACE_DEFINED__

/* interface IVdsDiskPartitionMF */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsDiskPartitionMF;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("538684e0-ba3d-4bc0-aca9-164aff85c2a9")
    IVdsDiskPartitionMF : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPartitionFileSystemProperties( 
            /* [in] */ ULONGLONG ullOffset,
            /* [out] */ __RPC__out VDS_FILE_SYSTEM_PROP *pFileSystemProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPartitionFileSystemTypeName( 
            /* [in] */ ULONGLONG ullOffset,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszFileSystemTypeName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPartitionFileSystemFormatSupport( 
            /* [in] */ ULONGLONG ullOffset,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfFileSystems) VDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP **ppFileSystemSupportProps,
            /* [out] */ __RPC__out LONG *plNumberOfFileSystems) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FormatPartitionEx( 
            /* [in] */ ULONGLONG ullOffset,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszFileSystemTypeName,
            /* [in] */ USHORT usFileSystemRevision,
            /* [in] */ ULONG ulDesiredUnitAllocationSize,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszLabel,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bQuickFormat,
            /* [in] */ BOOL bEnableCompression,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsDiskPartitionMFVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsDiskPartitionMF * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsDiskPartitionMF * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsDiskPartitionMF * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPartitionFileSystemProperties )( 
            __RPC__in IVdsDiskPartitionMF * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [out] */ __RPC__out VDS_FILE_SYSTEM_PROP *pFileSystemProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPartitionFileSystemTypeName )( 
            __RPC__in IVdsDiskPartitionMF * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszFileSystemTypeName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryPartitionFileSystemFormatSupport )( 
            __RPC__in IVdsDiskPartitionMF * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfFileSystems) VDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP **ppFileSystemSupportProps,
            /* [out] */ __RPC__out LONG *plNumberOfFileSystems);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FormatPartitionEx )( 
            __RPC__in IVdsDiskPartitionMF * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszFileSystemTypeName,
            /* [in] */ USHORT usFileSystemRevision,
            /* [in] */ ULONG ulDesiredUnitAllocationSize,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszLabel,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bQuickFormat,
            /* [in] */ BOOL bEnableCompression,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsDiskPartitionMFVtbl;

    interface IVdsDiskPartitionMF
    {
        CONST_VTBL struct IVdsDiskPartitionMFVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsDiskPartitionMF_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsDiskPartitionMF_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsDiskPartitionMF_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsDiskPartitionMF_GetPartitionFileSystemProperties(This,ullOffset,pFileSystemProp)	\
    ( (This)->lpVtbl -> GetPartitionFileSystemProperties(This,ullOffset,pFileSystemProp) ) 

#define IVdsDiskPartitionMF_GetPartitionFileSystemTypeName(This,ullOffset,ppwszFileSystemTypeName)	\
    ( (This)->lpVtbl -> GetPartitionFileSystemTypeName(This,ullOffset,ppwszFileSystemTypeName) ) 

#define IVdsDiskPartitionMF_QueryPartitionFileSystemFormatSupport(This,ullOffset,ppFileSystemSupportProps,plNumberOfFileSystems)	\
    ( (This)->lpVtbl -> QueryPartitionFileSystemFormatSupport(This,ullOffset,ppFileSystemSupportProps,plNumberOfFileSystems) ) 

#define IVdsDiskPartitionMF_FormatPartitionEx(This,ullOffset,pwszFileSystemTypeName,usFileSystemRevision,ulDesiredUnitAllocationSize,pwszLabel,bForce,bQuickFormat,bEnableCompression,ppAsync)	\
    ( (This)->lpVtbl -> FormatPartitionEx(This,ullOffset,pwszFileSystemTypeName,usFileSystemRevision,ulDesiredUnitAllocationSize,pwszLabel,bForce,bQuickFormat,bEnableCompression,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsDiskPartitionMF_INTERFACE_DEFINED__ */


#ifndef __IVdsVolumeMF_INTERFACE_DEFINED__
#define __IVdsVolumeMF_INTERFACE_DEFINED__

/* interface IVdsVolumeMF */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsVolumeMF;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ee2d5ded-6236-4169-931d-b9778ce03dc6")
    IVdsVolumeMF : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetFileSystemProperties( 
            /* [out] */ __RPC__out VDS_FILE_SYSTEM_PROP *pFileSystemProp) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Format( 
            /* [in] */ VDS_FILE_SYSTEM_TYPE type,
            /* [string][in] */ __RPC__in_string LPWSTR pwszLabel,
            /* [in] */ DWORD dwUnitAllocationSize,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bQuickFormat,
            /* [in] */ BOOL bEnableCompression,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddAccessPath( 
            /* [string][max_is][in] */ __RPC__in_ecount_full_string(( ( 260 - 1 )  + 1 ) ) LPWSTR pwszPath) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryAccessPaths( 
            /* [size_is][size_is][string][out] */ __RPC__deref_out_ecount_full_opt_string(*plNumberOfAccessPaths) LPWSTR **pwszPathArray,
            /* [out] */ __RPC__out LONG *plNumberOfAccessPaths) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryReparsePoints( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfReparsePointProps) VDS_REPARSE_POINT_PROP **ppReparsePointProps,
            /* [out] */ __RPC__out LONG *plNumberOfReparsePointProps) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteAccessPath( 
            /* [string][max_is][in] */ __RPC__in_ecount_full_string(( ( 260 - 1 )  + 1 ) ) LPWSTR pwszPath,
            /* [in] */ BOOL bForce) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Mount( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Dismount( 
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bPermanent) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetFileSystemFlags( 
            /* [in] */ ULONG ulFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ClearFileSystemFlags( 
            /* [in] */ ULONG ulFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsVolumeMFVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsVolumeMF * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsVolumeMF * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsVolumeMF * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetFileSystemProperties )( 
            __RPC__in IVdsVolumeMF * This,
            /* [out] */ __RPC__out VDS_FILE_SYSTEM_PROP *pFileSystemProp);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Format )( 
            __RPC__in IVdsVolumeMF * This,
            /* [in] */ VDS_FILE_SYSTEM_TYPE type,
            /* [string][in] */ __RPC__in_string LPWSTR pwszLabel,
            /* [in] */ DWORD dwUnitAllocationSize,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bQuickFormat,
            /* [in] */ BOOL bEnableCompression,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddAccessPath )( 
            __RPC__in IVdsVolumeMF * This,
            /* [string][max_is][in] */ __RPC__in_ecount_full_string(( ( 260 - 1 )  + 1 ) ) LPWSTR pwszPath);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryAccessPaths )( 
            __RPC__in IVdsVolumeMF * This,
            /* [size_is][size_is][string][out] */ __RPC__deref_out_ecount_full_opt_string(*plNumberOfAccessPaths) LPWSTR **pwszPathArray,
            /* [out] */ __RPC__out LONG *plNumberOfAccessPaths);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryReparsePoints )( 
            __RPC__in IVdsVolumeMF * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfReparsePointProps) VDS_REPARSE_POINT_PROP **ppReparsePointProps,
            /* [out] */ __RPC__out LONG *plNumberOfReparsePointProps);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeleteAccessPath )( 
            __RPC__in IVdsVolumeMF * This,
            /* [string][max_is][in] */ __RPC__in_ecount_full_string(( ( 260 - 1 )  + 1 ) ) LPWSTR pwszPath,
            /* [in] */ BOOL bForce);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Mount )( 
            __RPC__in IVdsVolumeMF * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Dismount )( 
            __RPC__in IVdsVolumeMF * This,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bPermanent);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetFileSystemFlags )( 
            __RPC__in IVdsVolumeMF * This,
            /* [in] */ ULONG ulFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ClearFileSystemFlags )( 
            __RPC__in IVdsVolumeMF * This,
            /* [in] */ ULONG ulFlags);
        
        END_INTERFACE
    } IVdsVolumeMFVtbl;

    interface IVdsVolumeMF
    {
        CONST_VTBL struct IVdsVolumeMFVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsVolumeMF_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsVolumeMF_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsVolumeMF_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsVolumeMF_GetFileSystemProperties(This,pFileSystemProp)	\
    ( (This)->lpVtbl -> GetFileSystemProperties(This,pFileSystemProp) ) 

#define IVdsVolumeMF_Format(This,type,pwszLabel,dwUnitAllocationSize,bForce,bQuickFormat,bEnableCompression,ppAsync)	\
    ( (This)->lpVtbl -> Format(This,type,pwszLabel,dwUnitAllocationSize,bForce,bQuickFormat,bEnableCompression,ppAsync) ) 

#define IVdsVolumeMF_AddAccessPath(This,pwszPath)	\
    ( (This)->lpVtbl -> AddAccessPath(This,pwszPath) ) 

#define IVdsVolumeMF_QueryAccessPaths(This,pwszPathArray,plNumberOfAccessPaths)	\
    ( (This)->lpVtbl -> QueryAccessPaths(This,pwszPathArray,plNumberOfAccessPaths) ) 

#define IVdsVolumeMF_QueryReparsePoints(This,ppReparsePointProps,plNumberOfReparsePointProps)	\
    ( (This)->lpVtbl -> QueryReparsePoints(This,ppReparsePointProps,plNumberOfReparsePointProps) ) 

#define IVdsVolumeMF_DeleteAccessPath(This,pwszPath,bForce)	\
    ( (This)->lpVtbl -> DeleteAccessPath(This,pwszPath,bForce) ) 

#define IVdsVolumeMF_Mount(This)	\
    ( (This)->lpVtbl -> Mount(This) ) 

#define IVdsVolumeMF_Dismount(This,bForce,bPermanent)	\
    ( (This)->lpVtbl -> Dismount(This,bForce,bPermanent) ) 

#define IVdsVolumeMF_SetFileSystemFlags(This,ulFlags)	\
    ( (This)->lpVtbl -> SetFileSystemFlags(This,ulFlags) ) 

#define IVdsVolumeMF_ClearFileSystemFlags(This,ulFlags)	\
    ( (This)->lpVtbl -> ClearFileSystemFlags(This,ulFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsVolumeMF_INTERFACE_DEFINED__ */


#ifndef __IVdsVolumeMF2_INTERFACE_DEFINED__
#define __IVdsVolumeMF2_INTERFACE_DEFINED__

/* interface IVdsVolumeMF2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsVolumeMF2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4dbcee9a-6343-4651-b85f-5e75d74d983c")
    IVdsVolumeMF2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetFileSystemTypeName( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszFileSystemTypeName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryFileSystemFormatSupport( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfFileSystems) VDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP **ppFileSystemSupportProps,
            /* [out] */ __RPC__out LONG *plNumberOfFileSystems) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FormatEx( 
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszFileSystemTypeName,
            /* [in] */ USHORT usFileSystemRevision,
            /* [in] */ ULONG ulDesiredUnitAllocationSize,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszLabel,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bQuickFormat,
            /* [in] */ BOOL bEnableCompression,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsVolumeMF2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsVolumeMF2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsVolumeMF2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsVolumeMF2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetFileSystemTypeName )( 
            __RPC__in IVdsVolumeMF2 * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszFileSystemTypeName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryFileSystemFormatSupport )( 
            __RPC__in IVdsVolumeMF2 * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*plNumberOfFileSystems) VDS_FILE_SYSTEM_FORMAT_SUPPORT_PROP **ppFileSystemSupportProps,
            /* [out] */ __RPC__out LONG *plNumberOfFileSystems);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FormatEx )( 
            __RPC__in IVdsVolumeMF2 * This,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszFileSystemTypeName,
            /* [in] */ USHORT usFileSystemRevision,
            /* [in] */ ULONG ulDesiredUnitAllocationSize,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszLabel,
            /* [in] */ BOOL bForce,
            /* [in] */ BOOL bQuickFormat,
            /* [in] */ BOOL bEnableCompression,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsVolumeMF2Vtbl;

    interface IVdsVolumeMF2
    {
        CONST_VTBL struct IVdsVolumeMF2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsVolumeMF2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsVolumeMF2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsVolumeMF2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsVolumeMF2_GetFileSystemTypeName(This,ppwszFileSystemTypeName)	\
    ( (This)->lpVtbl -> GetFileSystemTypeName(This,ppwszFileSystemTypeName) ) 

#define IVdsVolumeMF2_QueryFileSystemFormatSupport(This,ppFileSystemSupportProps,plNumberOfFileSystems)	\
    ( (This)->lpVtbl -> QueryFileSystemFormatSupport(This,ppFileSystemSupportProps,plNumberOfFileSystems) ) 

#define IVdsVolumeMF2_FormatEx(This,pwszFileSystemTypeName,usFileSystemRevision,ulDesiredUnitAllocationSize,pwszLabel,bForce,bQuickFormat,bEnableCompression,ppAsync)	\
    ( (This)->lpVtbl -> FormatEx(This,pwszFileSystemTypeName,usFileSystemRevision,ulDesiredUnitAllocationSize,pwszLabel,bForce,bQuickFormat,bEnableCompression,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsVolumeMF2_INTERFACE_DEFINED__ */


#ifndef __IVdsVolumeShrink_INTERFACE_DEFINED__
#define __IVdsVolumeShrink_INTERFACE_DEFINED__

/* interface IVdsVolumeShrink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsVolumeShrink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d68168c9-82a2-4f85-b6e9-74707c49a58f")
    IVdsVolumeShrink : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryMaxReclaimableBytes( 
            /* [out] */ __RPC__out ULONGLONG *pullMaxNumberOfReclaimableBytes) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Shrink( 
            /* [in] */ ULONGLONG ullDesiredNumberOfReclaimableBytes,
            /* [in] */ ULONGLONG ullMinNumberOfReclaimableBytes,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsVolumeShrinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsVolumeShrink * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsVolumeShrink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsVolumeShrink * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryMaxReclaimableBytes )( 
            __RPC__in IVdsVolumeShrink * This,
            /* [out] */ __RPC__out ULONGLONG *pullMaxNumberOfReclaimableBytes);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Shrink )( 
            __RPC__in IVdsVolumeShrink * This,
            /* [in] */ ULONGLONG ullDesiredNumberOfReclaimableBytes,
            /* [in] */ ULONGLONG ullMinNumberOfReclaimableBytes,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsVolumeShrinkVtbl;

    interface IVdsVolumeShrink
    {
        CONST_VTBL struct IVdsVolumeShrinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsVolumeShrink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsVolumeShrink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsVolumeShrink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsVolumeShrink_QueryMaxReclaimableBytes(This,pullMaxNumberOfReclaimableBytes)	\
    ( (This)->lpVtbl -> QueryMaxReclaimableBytes(This,pullMaxNumberOfReclaimableBytes) ) 

#define IVdsVolumeShrink_Shrink(This,ullDesiredNumberOfReclaimableBytes,ullMinNumberOfReclaimableBytes,ppAsync)	\
    ( (This)->lpVtbl -> Shrink(This,ullDesiredNumberOfReclaimableBytes,ullMinNumberOfReclaimableBytes,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsVolumeShrink_INTERFACE_DEFINED__ */


#ifndef __IVdsSubSystemImportTarget_INTERFACE_DEFINED__
#define __IVdsSubSystemImportTarget_INTERFACE_DEFINED__

/* interface IVdsSubSystemImportTarget */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsSubSystemImportTarget;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("83bfb87f-43fb-4903-baa6-127f01029eec")
    IVdsSubSystemImportTarget : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetImportTarget( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszIscsiName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetImportTarget( 
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszIscsiName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsSubSystemImportTargetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsSubSystemImportTarget * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsSubSystemImportTarget * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsSubSystemImportTarget * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetImportTarget )( 
            __RPC__in IVdsSubSystemImportTarget * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszIscsiName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetImportTarget )( 
            __RPC__in IVdsSubSystemImportTarget * This,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszIscsiName);
        
        END_INTERFACE
    } IVdsSubSystemImportTargetVtbl;

    interface IVdsSubSystemImportTarget
    {
        CONST_VTBL struct IVdsSubSystemImportTargetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsSubSystemImportTarget_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsSubSystemImportTarget_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsSubSystemImportTarget_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsSubSystemImportTarget_GetImportTarget(This,ppwszIscsiName)	\
    ( (This)->lpVtbl -> GetImportTarget(This,ppwszIscsiName) ) 

#define IVdsSubSystemImportTarget_SetImportTarget(This,pwszIscsiName)	\
    ( (This)->lpVtbl -> SetImportTarget(This,pwszIscsiName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsSubSystemImportTarget_INTERFACE_DEFINED__ */


#ifndef __IVdsIscsiPortalLocal_INTERFACE_DEFINED__
#define __IVdsIscsiPortalLocal_INTERFACE_DEFINED__

/* interface IVdsIscsiPortalLocal */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsIscsiPortalLocal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ad837c28-52c1-421d-bf04-fae7da665396")
    IVdsIscsiPortalLocal : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetIpsecSecurityLocal( 
            /* [in] */ ULONGLONG ullSecurityFlags,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsIscsiPortalLocalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsIscsiPortalLocal * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsIscsiPortalLocal * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsIscsiPortalLocal * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetIpsecSecurityLocal )( 
            __RPC__in IVdsIscsiPortalLocal * This,
            /* [in] */ ULONGLONG ullSecurityFlags,
            /* [unique][in] */ __RPC__in_opt VDS_ISCSI_IPSEC_KEY *pIpsecKey);
        
        END_INTERFACE
    } IVdsIscsiPortalLocalVtbl;

    interface IVdsIscsiPortalLocal
    {
        CONST_VTBL struct IVdsIscsiPortalLocalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsIscsiPortalLocal_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsIscsiPortalLocal_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsIscsiPortalLocal_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsIscsiPortalLocal_SetIpsecSecurityLocal(This,ullSecurityFlags,pIpsecKey)	\
    ( (This)->lpVtbl -> SetIpsecSecurityLocal(This,ullSecurityFlags,pIpsecKey) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsIscsiPortalLocal_INTERFACE_DEFINED__ */


#ifndef __IVdsServiceSAN_INTERFACE_DEFINED__
#define __IVdsServiceSAN_INTERFACE_DEFINED__

/* interface IVdsServiceSAN */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsServiceSAN;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FC5D23E8-A88B-41a5-8DE0-2D2F73C5A630")
    IVdsServiceSAN : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSANPolicy( 
            /* [out] */ __RPC__out VDS_SAN_POLICY *pSanPolicy) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetSANPolicy( 
            /* [in] */ VDS_SAN_POLICY SanPolicy) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsServiceSANVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsServiceSAN * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsServiceSAN * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsServiceSAN * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSANPolicy )( 
            __RPC__in IVdsServiceSAN * This,
            /* [out] */ __RPC__out VDS_SAN_POLICY *pSanPolicy);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetSANPolicy )( 
            __RPC__in IVdsServiceSAN * This,
            /* [in] */ VDS_SAN_POLICY SanPolicy);
        
        END_INTERFACE
    } IVdsServiceSANVtbl;

    interface IVdsServiceSAN
    {
        CONST_VTBL struct IVdsServiceSANVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsServiceSAN_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsServiceSAN_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsServiceSAN_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsServiceSAN_GetSANPolicy(This,pSanPolicy)	\
    ( (This)->lpVtbl -> GetSANPolicy(This,pSanPolicy) ) 

#define IVdsServiceSAN_SetSANPolicy(This,SanPolicy)	\
    ( (This)->lpVtbl -> SetSANPolicy(This,SanPolicy) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsServiceSAN_INTERFACE_DEFINED__ */


#ifndef __IVdsVolumeMF3_INTERFACE_DEFINED__
#define __IVdsVolumeMF3_INTERFACE_DEFINED__

/* interface IVdsVolumeMF3 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsVolumeMF3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6788FAF9-214E-4b85-BA59-266953616E09")
    IVdsVolumeMF3 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryVolumeGuidPathnames( 
            /* [size_is][size_is][string][out] */ __RPC__deref_out_ecount_full_opt_string(*pulNumberOfPaths) LPWSTR **pwszPathArray,
            /* [out] */ __RPC__out ULONG *pulNumberOfPaths) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FormatEx2( 
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszFileSystemTypeName,
            /* [in] */ USHORT usFileSystemRevision,
            /* [in] */ ULONG ulDesiredUnitAllocationSize,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszLabel,
            /* [in] */ DWORD Options,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OfflineVolume( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsVolumeMF3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsVolumeMF3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsVolumeMF3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsVolumeMF3 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryVolumeGuidPathnames )( 
            __RPC__in IVdsVolumeMF3 * This,
            /* [size_is][size_is][string][out] */ __RPC__deref_out_ecount_full_opt_string(*pulNumberOfPaths) LPWSTR **pwszPathArray,
            /* [out] */ __RPC__out ULONG *pulNumberOfPaths);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FormatEx2 )( 
            __RPC__in IVdsVolumeMF3 * This,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszFileSystemTypeName,
            /* [in] */ USHORT usFileSystemRevision,
            /* [in] */ ULONG ulDesiredUnitAllocationSize,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszLabel,
            /* [in] */ DWORD Options,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OfflineVolume )( 
            __RPC__in IVdsVolumeMF3 * This);
        
        END_INTERFACE
    } IVdsVolumeMF3Vtbl;

    interface IVdsVolumeMF3
    {
        CONST_VTBL struct IVdsVolumeMF3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsVolumeMF3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsVolumeMF3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsVolumeMF3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsVolumeMF3_QueryVolumeGuidPathnames(This,pwszPathArray,pulNumberOfPaths)	\
    ( (This)->lpVtbl -> QueryVolumeGuidPathnames(This,pwszPathArray,pulNumberOfPaths) ) 

#define IVdsVolumeMF3_FormatEx2(This,pwszFileSystemTypeName,usFileSystemRevision,ulDesiredUnitAllocationSize,pwszLabel,Options,ppAsync)	\
    ( (This)->lpVtbl -> FormatEx2(This,pwszFileSystemTypeName,usFileSystemRevision,ulDesiredUnitAllocationSize,pwszLabel,Options,ppAsync) ) 

#define IVdsVolumeMF3_OfflineVolume(This)	\
    ( (This)->lpVtbl -> OfflineVolume(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsVolumeMF3_INTERFACE_DEFINED__ */


#ifndef __IVdsDiskPartitionMF2_INTERFACE_DEFINED__
#define __IVdsDiskPartitionMF2_INTERFACE_DEFINED__

/* interface IVdsDiskPartitionMF2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVdsDiskPartitionMF2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9CBE50CA-F2D2-4bf4-ACE1-96896B729625")
    IVdsDiskPartitionMF2 : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FormatPartitionEx2( 
            /* [in] */ ULONGLONG ullOffset,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszFileSystemTypeName,
            /* [in] */ USHORT usFileSystemRevision,
            /* [in] */ ULONG ulDesiredUnitAllocationSize,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszLabel,
            /* [in] */ DWORD Options,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVdsDiskPartitionMF2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IVdsDiskPartitionMF2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IVdsDiskPartitionMF2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IVdsDiskPartitionMF2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *FormatPartitionEx2 )( 
            __RPC__in IVdsDiskPartitionMF2 * This,
            /* [in] */ ULONGLONG ullOffset,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszFileSystemTypeName,
            /* [in] */ USHORT usFileSystemRevision,
            /* [in] */ ULONG ulDesiredUnitAllocationSize,
            /* [string][unique][in] */ __RPC__in_opt_string LPWSTR pwszLabel,
            /* [in] */ DWORD Options,
            /* [out] */ __RPC__deref_out_opt IVdsAsync **ppAsync);
        
        END_INTERFACE
    } IVdsDiskPartitionMF2Vtbl;

    interface IVdsDiskPartitionMF2
    {
        CONST_VTBL struct IVdsDiskPartitionMF2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVdsDiskPartitionMF2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVdsDiskPartitionMF2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVdsDiskPartitionMF2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVdsDiskPartitionMF2_FormatPartitionEx2(This,ullOffset,pwszFileSystemTypeName,usFileSystemRevision,ulDesiredUnitAllocationSize,pwszLabel,Options,ppAsync)	\
    ( (This)->lpVtbl -> FormatPartitionEx2(This,ullOffset,pwszFileSystemTypeName,usFileSystemRevision,ulDesiredUnitAllocationSize,pwszLabel,Options,ppAsync) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVdsDiskPartitionMF2_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\vdssys.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for vdssys.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __vdssys_h__
#define __vdssys_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "wtypes.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_vdssys_0000_0000 */
/* [local] */ 

#if (WINVER >= _WIN32_WINNT_WIN7)
#if defined(VDS_MIDL_PASS)
typedef LPWSTR PWSTR;

typedef LPCWSTR PCWSTR;

typedef DWORD ACCESS_MASK;

#pragma warning(push)
#pragma warning(disable:4001) 
#pragma once
#pragma warning(pop)
typedef PVOID PSECURITY_DESCRIPTOR;

typedef PVOID LPOVERLAPPED;

typedef ULONG *PULONG;

typedef HANDLE *PHANDLE;

#pragma once
#pragma once
#pragma once
#pragma once
#pragma warning(push)
#pragma warning(disable : 4200)
#pragma warning(disable : 4201)
typedef struct _VIRTUAL_STORAGE_TYPE
    {
    ULONG DeviceId;
    GUID VendorId;
    } 	VIRTUAL_STORAGE_TYPE;

typedef struct _VIRTUAL_STORAGE_TYPE *PVIRTUAL_STORAGE_TYPE;

typedef 
enum _CREATE_VIRTUAL_DISK_VERSION
    {	CREATE_VIRTUAL_DISK_VERSION_UNSPECIFIED	= 0,
	CREATE_VIRTUAL_DISK_VERSION_1	= 1
    } 	CREATE_VIRTUAL_DISK_VERSION;

typedef struct _CREATE_VIRTUAL_DISK_PARAMETERS
    {
    CREATE_VIRTUAL_DISK_VERSION Version;
    union 
        {
        struct 
            {
            GUID UniqueId;
            ULONGLONG MaximumSize;
            ULONG BlockSizeInBytes;
            ULONG SectorSizeInBytes;
            PCWSTR ParentPath;
            PCWSTR SourcePath;
            } 	Version1;
        } 	;
    } 	CREATE_VIRTUAL_DISK_PARAMETERS;

typedef struct _CREATE_VIRTUAL_DISK_PARAMETERS *PCREATE_VIRTUAL_DISK_PARAMETERS;

typedef 
enum _CREATE_VIRTUAL_DISK_FLAG
    {	CREATE_VIRTUAL_DISK_FLAG_NONE	= 0,
	CREATE_VIRTUAL_DISK_FLAG_FULL_PHYSICAL_ALLOCATION	= 0x1
    } 	CREATE_VIRTUAL_DISK_FLAG;

typedef 
enum _OPEN_VIRTUAL_DISK_VERSION
    {	OPEN_VIRTUAL_DISK_VERSION_UNSPECIFIED	= 0,
	OPEN_VIRTUAL_DISK_VERSION_1	= 1
    } 	OPEN_VIRTUAL_DISK_VERSION;

typedef struct _OPEN_VIRTUAL_DISK_PARAMETERS
    {
    OPEN_VIRTUAL_DISK_VERSION Version;
    union 
        {
        struct 
            {
            ULONG RWDepth;
            } 	Version1;
        } 	;
    } 	OPEN_VIRTUAL_DISK_PARAMETERS;

typedef struct _OPEN_VIRTUAL_DISK_PARAMETERS *POPEN_VIRTUAL_DISK_PARAMETERS;

typedef /* [v1_enum] */ 
enum _VIRTUAL_DISK_ACCESS_MASK
    {	VIRTUAL_DISK_ACCESS_ATTACH_RO	= 0x10000,
	VIRTUAL_DISK_ACCESS_ATTACH_RW	= 0x20000,
	VIRTUAL_DISK_ACCESS_DETACH	= 0x40000,
	VIRTUAL_DISK_ACCESS_GET_INFO	= 0x80000,
	VIRTUAL_DISK_ACCESS_CREATE	= 0x100000,
	VIRTUAL_DISK_ACCESS_METAOPS	= 0x200000,
	VIRTUAL_DISK_ACCESS_READ	= 0xd0000,
	VIRTUAL_DISK_ACCESS_ALL	= 0x3f0000,
	VIRTUAL_DISK_ACCESS_WRITABLE	= 0x320000
    } 	VIRTUAL_DISK_ACCESS_MASK;

typedef 
enum _OPEN_VIRTUAL_DISK_FLAG
    {	OPEN_VIRTUAL_DISK_FLAG_NONE	= 0,
	OPEN_VIRTUAL_DISK_FLAG_NO_PARENTS	= 0x1,
	OPEN_VIRTUAL_DISK_FLAG_BLANK_FILE	= 0x2,
	OPEN_VIRTUAL_DISK_FLAG_BOOT_DRIVE	= 0x4
    } 	OPEN_VIRTUAL_DISK_FLAG;

DWORD __stdcall OpenVirtualDisk( 
    PVIRTUAL_STORAGE_TYPE VirtualStorageType,
    PCWSTR Path,
    VIRTUAL_DISK_ACCESS_MASK VirtualDiskAccessMask,
    OPEN_VIRTUAL_DISK_FLAG Flags,
    POPEN_VIRTUAL_DISK_PARAMETERS Parameters,
    PHANDLE Handle);

DWORD __stdcall CreateVirtualDisk( 
    PVIRTUAL_STORAGE_TYPE VirtualStorageType,
    PCWSTR Path,
    VIRTUAL_DISK_ACCESS_MASK VirtualDiskAccessMask,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    CREATE_VIRTUAL_DISK_FLAG Flags,
    ULONG ProviderSpecificFlags,
    PCREATE_VIRTUAL_DISK_PARAMETERS Parameters,
    LPOVERLAPPED Overlapped,
    PHANDLE Handle);

typedef 
enum _ATTACH_VIRTUAL_DISK_VERSION
    {	ATTACH_VIRTUAL_DISK_VERSION_UNSPECIFIED	= 0,
	ATTACH_VIRTUAL_DISK_VERSION_1	= 1
    } 	ATTACH_VIRTUAL_DISK_VERSION;

typedef struct _ATTACH_VIRTUAL_DISK_PARAMETERS
    {
    ATTACH_VIRTUAL_DISK_VERSION Version;
    union 
        {
        struct 
            {
            ULONG Reserved;
            } 	Version1;
        } 	;
    } 	ATTACH_VIRTUAL_DISK_PARAMETERS;

typedef struct _ATTACH_VIRTUAL_DISK_PARAMETERS *PATTACH_VIRTUAL_DISK_PARAMETERS;

typedef 
enum _ATTACH_VIRTUAL_DISK_FLAG
    {	ATTACH_VIRTUAL_DISK_FLAG_NONE	= 0,
	ATTACH_VIRTUAL_DISK_FLAG_READ_ONLY	= 0x1,
	ATTACH_VIRTUAL_DISK_FLAG_NO_DRIVE_LETTER	= 0x2,
	ATTACH_VIRTUAL_DISK_FLAG_PERMANENT_LIFETIME	= 0x4,
	ATTACH_VIRTUAL_DISK_FLAG_NO_LOCAL_HOST	= 0x8
    } 	ATTACH_VIRTUAL_DISK_FLAG;

DWORD __stdcall AttachVirtualDisk( 
    HANDLE VirtualDiskHandle,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    ATTACH_VIRTUAL_DISK_FLAG Flags,
    ULONG ProviderSpecificFlags,
    PATTACH_VIRTUAL_DISK_PARAMETERS Parameters,
    LPOVERLAPPED Overlapped);

typedef 
enum _DETACH_VIRTUAL_DISK_FLAG
    {	DETACH_VIRTUAL_DISK_FLAG_NONE	= 0
    } 	DETACH_VIRTUAL_DISK_FLAG;

DWORD __stdcall DetachVirtualDisk( 
    HANDLE VirtualDiskHandle,
    DETACH_VIRTUAL_DISK_FLAG Flags,
    ULONG ProviderSpecificFlags);

DWORD __stdcall GetVirtualDiskPhysicalPath( 
    HANDLE VirtualDiskHandle,
    PULONG DiskPathSizeInBytes,
    PWSTR DiskPath);

typedef 
enum _DEPENDENT_DISK_FLAG
    {	DEPENDENT_DISK_FLAG_NONE	= 0,
	DEPENDENT_DISK_FLAG_MULT_BACKING_FILES	= 0x1,
	DEPENDENT_DISK_FLAG_FULLY_ALLOCATED	= 0x2,
	DEPENDENT_DISK_FLAG_READ_ONLY	= 0x4,
	DEPENDENT_DISK_FLAG_REMOTE	= 0x8,
	DEPENDENT_DISK_FLAG_SYSTEM_VOLUME	= 0x10,
	DEPENDENT_DISK_FLAG_SYSTEM_VOLUME_PARENT	= 0x20,
	DEPENDENT_DISK_FLAG_REMOVABLE	= 0x40,
	DEPENDENT_DISK_FLAG_NO_DRIVE_LETTER	= 0x80,
	DEPENDENT_DISK_FLAG_PARENT	= 0x100,
	DEPENDENT_DISK_FLAG_NO_HOST_DISK	= 0x200,
	DEPENDENT_DISK_FLAG_PERMANENT_LIFETIME	= 0x400
    } 	DEPENDENT_DISK_FLAG;

typedef 
enum _STORAGE_DEPENDENCY_INFO_VERSION
    {	STORAGE_DEPENDENCY_INFO_VERSION_UNSPECIFIED	= 0,
	STORAGE_DEPENDENCY_INFO_VERSION_1	= 1,
	STORAGE_DEPENDENCY_INFO_VERSION_2	= 2
    } 	STORAGE_DEPENDENCY_INFO_VERSION;

typedef struct _STORAGE_DEPENDENCY_INFO_TYPE_1
    {
    DEPENDENT_DISK_FLAG DependencyTypeFlags;
    ULONG ProviderSpecificFlags;
    VIRTUAL_STORAGE_TYPE VirtualStorageType;
    } 	STORAGE_DEPENDENCY_INFO_TYPE_1;

typedef struct _STORAGE_DEPENDENCY_INFO_TYPE_1 *PSTORAGE_DEPENDENCY_INFO_TYPE_1;

typedef struct _STORAGE_DEPENDENCY_INFO_TYPE_2
    {
    DEPENDENT_DISK_FLAG DependencyTypeFlags;
    ULONG ProviderSpecificFlags;
    VIRTUAL_STORAGE_TYPE VirtualStorageType;
    ULONG AncestorLevel;
    PWSTR DependencyDeviceName;
    PWSTR HostVolumeName;
    PWSTR DependentVolumeName;
    PWSTR DependentVolumeRelativePath;
    } 	STORAGE_DEPENDENCY_INFO_TYPE_2;

typedef struct _STORAGE_DEPENDENCY_INFO_TYPE_2 *PSTORAGE_DEPENDENCY_INFO_TYPE_2;

typedef struct _STORAGE_DEPENDENCY_INFO
    {
    STORAGE_DEPENDENCY_INFO_VERSION Version;
    ULONG NumberEntries;
    union 
        {
        STORAGE_DEPENDENCY_INFO_TYPE_1 Version1Entries[ 1 ];
        STORAGE_DEPENDENCY_INFO_TYPE_2 Version2Entries[ 1 ];
        } 	;
    } 	STORAGE_DEPENDENCY_INFO;

typedef struct _STORAGE_DEPENDENCY_INFO *PSTORAGE_DEPENDENCY_INFO;

typedef 
enum _GET_STORAGE_DEPENDENCY_FLAG
    {	GET_STORAGE_DEPENDENCY_FLAG_NONE	= 0,
	GET_STORAGE_DEPENDENCY_FLAG_HOST_VOLUMES	= 0x1,
	GET_STORAGE_DEPENDENCY_FLAG_DISK_HANDLE	= 0x2
    } 	GET_STORAGE_DEPENDENCY_FLAG;

DWORD __stdcall GetStorageDependencyInformation( 
    HANDLE ObjectHandle,
    GET_STORAGE_DEPENDENCY_FLAG Flags,
    ULONG StorageDependencyInfoSize,
    PSTORAGE_DEPENDENCY_INFO StorageDependencyInfo,
    PULONG SizeUsed);

typedef 
enum _GET_VIRTUAL_DISK_INFO_VERSION
    {	GET_VIRTUAL_DISK_INFO_UNSPECIFIED	= 0,
	GET_VIRTUAL_DISK_INFO_SIZE	= 1,
	GET_VIRTUAL_DISK_INFO_IDENTIFIER	= 2,
	GET_VIRTUAL_DISK_INFO_PARENT_LOCATION	= 3,
	GET_VIRTUAL_DISK_INFO_PARENT_IDENTIFIER	= 4,
	GET_VIRTUAL_DISK_INFO_PARENT_TIMESTAMP	= 5,
	GET_VIRTUAL_DISK_INFO_VIRTUAL_STORAGE_TYPE	= 6,
	GET_VIRTUAL_DISK_INFO_PROVIDER_SUBTYPE	= 7
    } 	GET_VIRTUAL_DISK_INFO_VERSION;

typedef struct _GET_VIRTUAL_DISK_INFO
    {
    GET_VIRTUAL_DISK_INFO_VERSION Version;
    union 
        {
        struct 
            {
            ULONGLONG VirtualSize;
            ULONGLONG PhysicalSize;
            ULONG BlockSize;
            ULONG SectorSize;
            } 	Size;
        GUID Identifier;
        struct 
            {
            BOOL ParentResolved;
            WCHAR ParentLocationBuffer[ 1 ];
            } 	ParentLocation;
        GUID ParentIdentifier;
        ULONG ParentTimestamp;
        VIRTUAL_STORAGE_TYPE VirtualStorageType;
        ULONG ProviderSubtype;
        } 	;
    } 	GET_VIRTUAL_DISK_INFO;

typedef struct _GET_VIRTUAL_DISK_INFO *PGET_VIRTUAL_DISK_INFO;

DWORD __stdcall GetVirtualDiskInformation( 
    HANDLE VirtualDiskHandle,
    PULONG VirtualDiskInfoSize,
    PGET_VIRTUAL_DISK_INFO VirtualDiskInfo,
    PULONG SizeUsed);

typedef 
enum _SET_VIRTUAL_DISK_INFO_VERSION
    {	SET_VIRTUAL_DISK_INFO_UNSPECIFIED	= 0,
	SET_VIRTUAL_DISK_INFO_PARENT_PATH	= 1,
	SET_VIRTUAL_DISK_INFO_IDENTIFIER	= 2
    } 	SET_VIRTUAL_DISK_INFO_VERSION;

typedef struct _SET_VIRTUAL_DISK_INFO
    {
    SET_VIRTUAL_DISK_INFO_VERSION Version;
    union 
        {
        PCWSTR ParentFilePath;
        GUID UniqueIdentifier;
        } 	;
    } 	SET_VIRTUAL_DISK_INFO;

typedef struct _SET_VIRTUAL_DISK_INFO *PSET_VIRTUAL_DISK_INFO;

DWORD __stdcall SetVirtualDiskInformation( 
    HANDLE VirtualDiskHandle,
    PSET_VIRTUAL_DISK_INFO VirtualDiskInfo);

typedef struct _VIRTUAL_DISK_PROGRESS
    {
    DWORD OperationStatus;
    ULONGLONG CurrentValue;
    ULONGLONG CompletionValue;
    } 	VIRTUAL_DISK_PROGRESS;

typedef struct _VIRTUAL_DISK_PROGRESS *PVIRTUAL_DISK_PROGRESS;

DWORD __stdcall GetVirtualDiskOperationProgress( 
    HANDLE VirtualDiskHandle,
    LPOVERLAPPED Overlapped,
    PVIRTUAL_DISK_PROGRESS Progress);

typedef 
enum _COMPACT_VIRTUAL_DISK_VERSION
    {	COMPACT_VIRTUAL_DISK_VERSION_UNSPECIFIED	= 0,
	COMPACT_VIRTUAL_DISK_VERSION_1	= 1
    } 	COMPACT_VIRTUAL_DISK_VERSION;

typedef struct _COMPACT_VIRTUAL_DISK_PARAMETERS
    {
    COMPACT_VIRTUAL_DISK_VERSION Version;
    union 
        {
        struct 
            {
            ULONG Reserved;
            } 	Version1;
        } 	;
    } 	COMPACT_VIRTUAL_DISK_PARAMETERS;

typedef struct _COMPACT_VIRTUAL_DISK_PARAMETERS *PCOMPACT_VIRTUAL_DISK_PARAMETERS;

typedef 
enum _COMPACT_VIRTUAL_DISK_FLAG
    {	COMPACT_VIRTUAL_DISK_FLAG_NONE	= 0
    } 	COMPACT_VIRTUAL_DISK_FLAG;

DWORD __stdcall CompactVirtualDisk( 
    HANDLE VirtualDiskHandle,
    COMPACT_VIRTUAL_DISK_FLAG Flags,
    PCOMPACT_VIRTUAL_DISK_PARAMETERS Parameters,
    LPOVERLAPPED Overlapped);

typedef 
enum _MERGE_VIRTUAL_DISK_VERSION
    {	MERGE_VIRTUAL_DISK_VERSION_UNSPECIFIED	= 0,
	MERGE_VIRTUAL_DISK_VERSION_1	= 1
    } 	MERGE_VIRTUAL_DISK_VERSION;

typedef struct _MERGE_VIRTUAL_DISK_PARAMETERS
    {
    MERGE_VIRTUAL_DISK_VERSION Version;
    union 
        {
        struct 
            {
            ULONG MergeDepth;
            } 	Version1;
        } 	;
    } 	MERGE_VIRTUAL_DISK_PARAMETERS;

typedef struct _MERGE_VIRTUAL_DISK_PARAMETERS *PMERGE_VIRTUAL_DISK_PARAMETERS;

typedef 
enum _MERGE_VIRTUAL_DISK_FLAG
    {	MERGE_VIRTUAL_DISK_FLAG_NONE	= 0
    } 	MERGE_VIRTUAL_DISK_FLAG;

DWORD __stdcall MergeVirtualDisk( 
    HANDLE VirtualDiskHandle,
    MERGE_VIRTUAL_DISK_FLAG Flags,
    PMERGE_VIRTUAL_DISK_PARAMETERS Parameters,
    LPOVERLAPPED Overlapped);

typedef 
enum _EXPAND_VIRTUAL_DISK_VERSION
    {	EXPAND_VIRTUAL_DISK_VERSION_UNSPECIFIED	= 0,
	EXPAND_VIRTUAL_DISK_VERSION_1	= 1
    } 	EXPAND_VIRTUAL_DISK_VERSION;

typedef struct _EXPAND_VIRTUAL_DISK_PARAMETERS
    {
    EXPAND_VIRTUAL_DISK_VERSION Version;
    union 
        {
        struct 
            {
            ULONGLONG NewSize;
            } 	Version1;
        } 	;
    } 	EXPAND_VIRTUAL_DISK_PARAMETERS;

typedef struct _EXPAND_VIRTUAL_DISK_PARAMETERS *PEXPAND_VIRTUAL_DISK_PARAMETERS;

typedef 
enum _EXPAND_VIRTUAL_DISK_FLAG
    {	EXPAND_VIRTUAL_DISK_FLAG_NONE	= 0
    } 	EXPAND_VIRTUAL_DISK_FLAG;

DWORD __stdcall ExpandVirtualDisk( 
    HANDLE VirtualDiskHandle,
    EXPAND_VIRTUAL_DISK_FLAG Flags,
    PEXPAND_VIRTUAL_DISK_PARAMETERS Parameters,
    LPOVERLAPPED Overlapped);

typedef 
enum _SURFACE_VIRTUAL_DISK_FLAG
    {	SURFACE_VIRTUAL_DISK_FLAG_NONE	= 0,
	SURFACE_VIRTUAL_DISK_FLAG_READ_ONLY	= 0x1,
	SURFACE_VIRTUAL_DISK_FLAG_NO_DRIVE_LETTER	= 0x2,
	SURFACE_VIRTUAL_DISK_FLAG_PERMANENT_LIFETIME	= 0x4,
	SURFACE_VIRTUAL_DISK_FLAG_NO_LOCAL_HOST	= 0x8
    } 	SURFACE_VIRTUAL_DISK_FLAG;

typedef 
enum _UNSURFACE_VIRTUAL_DISK_FLAG
    {	UNSURFACE_VIRTUAL_DISK_FLAG_NONE	= 0
    } 	UNSURFACE_VIRTUAL_DISK_FLAG;

#pragma warning(pop)
#else //defined(VDS_MIDL_PASS)
#include "virtdisk.h"
#endif //defined(VDS_MIDL_PASS)
#endif // _WIN32_WINNT_WIN7


extern RPC_IF_HANDLE __MIDL_itf_vdssys_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vdssys_0000_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\vdserr.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    vdserr.h

Abstract:

    Constant definitions for the Virtual Disk Service error messages.

    Error code values:
    Added in Windows Server 2003:          0x2400-0x24FF
    Added in Windows Vista:                0x2500-0x26FF
    Added in VDS 1.1:                      0x2700-0x27FF
    Added in Windows Server 2008:          0x2800-0x28FF
    Added in Win7:                         0x2900-0x29FF

    NOTE:
    If porting over an error code which was added to Server 2003 SP make sure
    the error code's value is in the designated range for Windows Server 2003.
    If the value is not in the designated range make sure it does not conflict
    with any of the already defined errors and if it does change the value
    to the next available Vista value.

Author:

    Kevin Seng   [KSeng]    04/01/05

Revision History:

--*/
#pragma once
// HRESULT codes
//////////////////////////////////////////////////////////////////////////////
//
// Codes added in Windows Server 2003:           0x2400-0x24FF
//
//////////////////////////////////////////////////////////////////////////////
//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: VDS_E_NOT_SUPPORTED
//
// MessageText:
//
// The operation is not supported by the object.
//
#define VDS_E_NOT_SUPPORTED              ((HRESULT)0x80042400L)

//
// MessageId: VDS_E_INITIALIZED_FAILED
//
// MessageText:
//
// The service failed to initialize.
//
#define VDS_E_INITIALIZED_FAILED         ((HRESULT)0x80042401L)

//
// MessageId: VDS_E_INITIALIZE_NOT_CALLED
//
// MessageText:
//
// The initialization method was not called.
//
#define VDS_E_INITIALIZE_NOT_CALLED      ((HRESULT)0x80042402L)

//
// MessageId: VDS_E_ALREADY_REGISTERED
//
// MessageText:
//
// The provider is already registered.
//
#define VDS_E_ALREADY_REGISTERED         ((HRESULT)0x80042403L)

//
// MessageId: VDS_E_ANOTHER_CALL_IN_PROGRESS
//
// MessageText:
//
// A concurrent second call is made on an object before the first is completed.
//
#define VDS_E_ANOTHER_CALL_IN_PROGRESS   ((HRESULT)0x80042404L)

//
// MessageId: VDS_E_OBJECT_NOT_FOUND
//
// MessageText:
//
// The object is not found.
//
#define VDS_E_OBJECT_NOT_FOUND           ((HRESULT)0x80042405L)

//
// MessageId: VDS_E_INVALID_SPACE
//
// MessageText:
//
// The specified space is not free or not valid.
//
#define VDS_E_INVALID_SPACE              ((HRESULT)0x80042406L)

//
// MessageId: VDS_E_PARTITION_LIMIT_REACHED
//
// MessageText:
//
// The number of partitions has reached the limit on a disk.
//
#define VDS_E_PARTITION_LIMIT_REACHED    ((HRESULT)0x80042407L)

//
// MessageId: VDS_E_PARTITION_NOT_EMPTY
//
// MessageText:
//
// The extended partition is not empty.
//
#define VDS_E_PARTITION_NOT_EMPTY        ((HRESULT)0x80042408L)

//
// MessageId: VDS_E_OPERATION_PENDING
//
// MessageText:
//
// The operation has not been completed yet.
//
#define VDS_E_OPERATION_PENDING          ((HRESULT)0x80042409L)

//
// MessageId: VDS_E_OPERATION_DENIED
//
// MessageText:
//
// This operation is not allowed on the current boot, system or pagefile 
// volume. It is also not allowed on any volume on a basic MBR disk that contains 
// the boot, system or pagefile volume. 
//
#define VDS_E_OPERATION_DENIED           ((HRESULT)0x8004240AL)

//
// MessageId: VDS_E_OBJECT_DELETED
//
// MessageText:
//
// The object has been deleted.
//
#define VDS_E_OBJECT_DELETED             ((HRESULT)0x8004240BL)

//
// MessageId: VDS_E_CANCEL_TOO_LATE
//
// MessageText:
//
// The operation cannot be cancelled.
//
#define VDS_E_CANCEL_TOO_LATE            ((HRESULT)0x8004240CL)

//
// MessageId: VDS_E_OPERATION_CANCELED
//
// MessageText:
//
// The operation has been cancelled.
//
#define VDS_E_OPERATION_CANCELED         ((HRESULT)0x8004240DL)

//
// MessageId: VDS_E_CANNOT_EXTEND
//
// MessageText:
//
// The volume cannot be extended because the file system does not support it.
//
#define VDS_E_CANNOT_EXTEND              ((HRESULT)0x8004240EL)

//
// MessageId: VDS_E_NOT_ENOUGH_SPACE
//
// MessageText:
//
// There is not enough usable space for this operation.
//
#define VDS_E_NOT_ENOUGH_SPACE           ((HRESULT)0x8004240FL)

//
// MessageId: VDS_E_NOT_ENOUGH_DRIVE
//
// MessageText:
//
// Not enough drives are specified to complete this operation.
//
#define VDS_E_NOT_ENOUGH_DRIVE           ((HRESULT)0x80042410L)

//
// MessageId: VDS_E_BAD_COOKIE
//
// MessageText:
//
// The cookie is not found.
//
#define VDS_E_BAD_COOKIE                 ((HRESULT)0x80042411L)

//
// MessageId: VDS_E_NO_MEDIA
//
// MessageText:
//
// There is no media in the device.
//
#define VDS_E_NO_MEDIA                   ((HRESULT)0x80042412L)

//
// MessageId: VDS_E_DEVICE_IN_USE
//
// MessageText:
//
// The device is in use.
//
#define VDS_E_DEVICE_IN_USE              ((HRESULT)0x80042413L)

//
// MessageId: VDS_E_DISK_NOT_EMPTY
//
// MessageText:
//
// The disk is not empty.
//
#define VDS_E_DISK_NOT_EMPTY             ((HRESULT)0x80042414L)

//
// MessageId: VDS_E_INVALID_OPERATION
//
// MessageText:
//
// Invalid operation.
//
#define VDS_E_INVALID_OPERATION          ((HRESULT)0x80042415L)

//
// MessageId: VDS_E_PATH_NOT_FOUND
//
// MessageText:
//
// The path is not found.
//
#define VDS_E_PATH_NOT_FOUND             ((HRESULT)0x80042416L)

//
// MessageId: VDS_E_DISK_NOT_INITIALIZED
//
// MessageText:
//
// The disk is not initialized.
//
#define VDS_E_DISK_NOT_INITIALIZED       ((HRESULT)0x80042417L)

//
// MessageId: VDS_E_NOT_AN_UNALLOCATED_DISK
//
// MessageText:
//
// The disk is not unallocated.
//
#define VDS_E_NOT_AN_UNALLOCATED_DISK    ((HRESULT)0x80042418L)

//
// MessageId: VDS_E_UNRECOVERABLE_ERROR
//
// MessageText:
//
// An unrecoverable error occurred. The service must shut down.
//
#define VDS_E_UNRECOVERABLE_ERROR        ((HRESULT)0x80042419L)

//
// MessageId: VDS_S_DISK_PARTIALLY_CLEANED
//
// MessageText:
//
// The disk is not fully cleaned due to I/O error.
//
#define VDS_S_DISK_PARTIALLY_CLEANED     ((HRESULT)0x0004241AL)

//
// MessageId: VDS_E_DMADMIN_SERVICE_CONNECTION_FAILED
//
// MessageText:
//
// The provider failed to connect to the Logical Disk Management 
// Administrative service.
//
#define VDS_E_DMADMIN_SERVICE_CONNECTION_FAILED ((HRESULT)0x8004241BL)

//
// MessageId: VDS_E_PROVIDER_INITIALIZATION_FAILED
//
// MessageText:
//
// The provider failed to initialize.
//
#define VDS_E_PROVIDER_INITIALIZATION_FAILED ((HRESULT)0x8004241CL)

//
// MessageId: VDS_E_OBJECT_EXISTS
//
// MessageText:
//
// The object already exists.
//
#define VDS_E_OBJECT_EXISTS              ((HRESULT)0x8004241DL)

//
// MessageId: VDS_E_NO_DISKS_FOUND
//
// MessageText:
//
// No disks were found on the target machine.
//
#define VDS_E_NO_DISKS_FOUND             ((HRESULT)0x8004241EL)

//
// MessageId: VDS_E_PROVIDER_CACHE_CORRUPT
//
// MessageText:
//
// The provider's cache has become corrupt.
//
#define VDS_E_PROVIDER_CACHE_CORRUPT     ((HRESULT)0x8004241FL)

//
// MessageId: VDS_E_DMADMIN_METHOD_CALL_FAILED
//
// MessageText:
//
// A method call to the Logical Disk Management Administrative service failed.
//
#define VDS_E_DMADMIN_METHOD_CALL_FAILED ((HRESULT)0x80042420L)

//
// MessageId: VDS_S_PROVIDER_ERROR_LOADING_CACHE
//
// MessageText:
//
// The provider encountered errors while loading the cache. 
// See the NT Event Log for more information.
//
#define VDS_S_PROVIDER_ERROR_LOADING_CACHE ((HRESULT)0x00042421L)

//
// MessageId: VDS_E_PROVIDER_VOL_DEVICE_NAME_NOT_FOUND
//
// MessageText:
//
// The device form of the volume pathname could not be retrieved.
//
#define VDS_E_PROVIDER_VOL_DEVICE_NAME_NOT_FOUND ((HRESULT)0x80042422L)

//
// MessageId: VDS_E_PROVIDER_VOL_OPEN
//
// MessageText:
//
// Failed to open the volume device.
//
#define VDS_E_PROVIDER_VOL_OPEN          ((HRESULT)0x80042423L)

//
// MessageId: VDS_E_DMADMIN_CORRUPT_NOTIFICATION
//
// MessageText:
//
// A corrupt notification was sent from the Logical Disk Manager 
// Administrative service.
//
#define VDS_E_DMADMIN_CORRUPT_NOTIFICATION ((HRESULT)0x80042424L)

//
// MessageId: VDS_E_INCOMPATIBLE_FILE_SYSTEM
//
// MessageText:
//
// The file system is incompatible.
//
#define VDS_E_INCOMPATIBLE_FILE_SYSTEM   ((HRESULT)0x80042425L)

//
// MessageId: VDS_E_INCOMPATIBLE_MEDIA
//
// MessageText:
//
// The media is incompatible.
//
#define VDS_E_INCOMPATIBLE_MEDIA         ((HRESULT)0x80042426L)

//
// MessageId: VDS_E_ACCESS_DENIED
//
// MessageText:
//
// Access is denied.
//
#define VDS_E_ACCESS_DENIED              ((HRESULT)0x80042427L)

//
// MessageId: VDS_E_MEDIA_WRITE_PROTECTED
//
// MessageText:
//
// The media is write protected.
//
#define VDS_E_MEDIA_WRITE_PROTECTED      ((HRESULT)0x80042428L)

//
// MessageId: VDS_E_BAD_LABEL
//
// MessageText:
//
// The label is illegal.
//
#define VDS_E_BAD_LABEL                  ((HRESULT)0x80042429L)

//
// MessageId: VDS_E_CANT_QUICK_FORMAT
//
// MessageText:
//
// Can not quick format the volume.
//
#define VDS_E_CANT_QUICK_FORMAT          ((HRESULT)0x8004242AL)

//
// MessageId: VDS_E_IO_ERROR
//
// MessageText:
//
// IO error occured during format.
//
#define VDS_E_IO_ERROR                   ((HRESULT)0x8004242BL)

//
// MessageId: VDS_E_VOLUME_TOO_SMALL
//
// MessageText:
//
// The volume size is too small.
//
#define VDS_E_VOLUME_TOO_SMALL           ((HRESULT)0x8004242CL)

//
// MessageId: VDS_E_VOLUME_TOO_BIG
//
// MessageText:
//
// The volume size is too big.
//
#define VDS_E_VOLUME_TOO_BIG             ((HRESULT)0x8004242DL)

//
// MessageId: VDS_E_CLUSTER_SIZE_TOO_SMALL
//
// MessageText:
//
// The cluster size is too small.
//
#define VDS_E_CLUSTER_SIZE_TOO_SMALL     ((HRESULT)0x8004242EL)

//
// MessageId: VDS_E_CLUSTER_SIZE_TOO_BIG
//
// MessageText:
//
// The cluster size is too big.
//
#define VDS_E_CLUSTER_SIZE_TOO_BIG       ((HRESULT)0x8004242FL)

//
// MessageId: VDS_E_CLUSTER_COUNT_BEYOND_32BITS
//
// MessageText:
//
// The number of clusters is too big for 32 bit integer.
//
#define VDS_E_CLUSTER_COUNT_BEYOND_32BITS ((HRESULT)0x80042430L)

//
// MessageId: VDS_E_OBJECT_STATUS_FAILED
//
// MessageText:
//
// The object is in failed status.
//
#define VDS_E_OBJECT_STATUS_FAILED       ((HRESULT)0x80042431L)

//
// MessageId: VDS_E_VOLUME_INCOMPLETE
//
// MessageText:
//
// All extents for the volume could not be found.
//
#define VDS_E_VOLUME_INCOMPLETE          ((HRESULT)0x80042432L)

//
// MessageId: VDS_E_EXTENT_SIZE_LESS_THAN_MIN
//
// MessageText:
//
// The size of the extent is less than the minimum.
//
#define VDS_E_EXTENT_SIZE_LESS_THAN_MIN  ((HRESULT)0x80042433L)

//
// MessageId: VDS_S_UPDATE_BOOTFILE_FAILED
//
// MessageText:
//
// Failed to update the boot configuration data.
//
#define VDS_S_UPDATE_BOOTFILE_FAILED     ((HRESULT)0x00042434L)

//
// MessageId: VDS_S_BOOT_PARTITION_NUMBER_CHANGE
//
// MessageText:
//
// The boot partition's partition number will change as a result of the operation.
//
#define VDS_S_BOOT_PARTITION_NUMBER_CHANGE ((HRESULT)0x00042436L)

//
// MessageId: VDS_E_BOOT_PARTITION_NUMBER_CHANGE
//
// MessageText:
//
// The boot partition's partition number will change as a result of the 
// migration operation.
//
#define VDS_E_BOOT_PARTITION_NUMBER_CHANGE ((HRESULT)0x80042436L)

//
// MessageId: VDS_E_NO_FREE_SPACE
//
// MessageText:
//
// The selected disk does not have enough free space to complete the operation.
//
#define VDS_E_NO_FREE_SPACE              ((HRESULT)0x80042437L)

//
// MessageId: VDS_E_ACTIVE_PARTITION
//
// MessageText:
//
// An active partition was detected on the selected disk, and it is not the active partition used to boot the currently running OS.
//
#define VDS_E_ACTIVE_PARTITION           ((HRESULT)0x80042438L)

//
// MessageId: VDS_E_PARTITION_OF_UNKNOWN_TYPE
//
// MessageText:
//
// Cannot read partition information.
//
#define VDS_E_PARTITION_OF_UNKNOWN_TYPE  ((HRESULT)0x80042439L)

//
// MessageId: VDS_E_LEGACY_VOLUME_FORMAT
//
// MessageText:
//
// A partition with an unknown type was detected on the selected disk.
//
#define VDS_E_LEGACY_VOLUME_FORMAT       ((HRESULT)0x8004243AL)

//
// MessageId: VDS_E_NON_CONTIGUOUS_DATA_PARTITIONS
//
// MessageText:
//
// The selected GPT formatted disk contains a partition which is not of type 
// 'PARTITION_BASIC_DATA_GUID', and is both preceeded and followed by a partition 
// of type 'PARTITION_BASIC_DATA_GUID'.
//
#define VDS_E_NON_CONTIGUOUS_DATA_PARTITIONS ((HRESULT)0x8004243BL)

//
// MessageId: VDS_E_MIGRATE_OPEN_VOLUME
//
// MessageText:
//
// A volume on the selected disk could not be opened.
//
#define VDS_E_MIGRATE_OPEN_VOLUME        ((HRESULT)0x8004243CL)

//
// MessageId: VDS_E_VOLUME_NOT_ONLINE
//
// MessageText:
//
// The volume is not online.
//
#define VDS_E_VOLUME_NOT_ONLINE          ((HRESULT)0x8004243DL)

//
// MessageId: VDS_E_VOLUME_NOT_HEALTHY
//
// MessageText:
//
// The volume is not healthy.
//
#define VDS_E_VOLUME_NOT_HEALTHY         ((HRESULT)0x8004243EL)

//
// MessageId: VDS_E_VOLUME_SPANS_DISKS
//
// MessageText:
//
// The volume spans multiple disks.
//
#define VDS_E_VOLUME_SPANS_DISKS         ((HRESULT)0x8004243FL)

//
// MessageId: VDS_E_REQUIRES_CONTIGUOUS_DISK_SPACE
//
// MessageText:
//
// The volume requires contiguous disk extents.
//
#define VDS_E_REQUIRES_CONTIGUOUS_DISK_SPACE ((HRESULT)0x80042440L)

//
// MessageId: VDS_E_BAD_PROVIDER_DATA
//
// MessageText:
//
// A provider returned bad data.
//
#define VDS_E_BAD_PROVIDER_DATA          ((HRESULT)0x80042441L)

//
// MessageId: VDS_E_PROVIDER_FAILURE
//
// MessageText:
//
// A provider failed to complete an operation.
//
#define VDS_E_PROVIDER_FAILURE           ((HRESULT)0x80042442L)

//
// MessageId: VDS_S_VOLUME_COMPRESS_FAILED
//
// MessageText:
//
// Failed to compress the volume.
//
#define VDS_S_VOLUME_COMPRESS_FAILED     ((HRESULT)0x00042443L)

//
// MessageId: VDS_E_PACK_OFFLINE
//
// MessageText:
//
// The pack is not online.
//
#define VDS_E_PACK_OFFLINE               ((HRESULT)0x80042444L)

//
// MessageId: VDS_E_VOLUME_NOT_A_MIRROR
//
// MessageText:
//
// The volume is not a mirror.
//
#define VDS_E_VOLUME_NOT_A_MIRROR        ((HRESULT)0x80042445L)

//
// MessageId: VDS_E_NO_EXTENTS_FOR_VOLUME
//
// MessageText:
//
// No extents were found for the volume.
//
#define VDS_E_NO_EXTENTS_FOR_VOLUME      ((HRESULT)0x80042446L)

//
// MessageId: VDS_E_DISK_NOT_LOADED_TO_CACHE
//
// MessageText:
//
// The disk failed to load to the cache.
//
#define VDS_E_DISK_NOT_LOADED_TO_CACHE   ((HRESULT)0x80042447L)

//
// MessageId: VDS_E_INTERNAL_ERROR
//
// MessageText:
//
// Check the event log for errors.
//
#define VDS_E_INTERNAL_ERROR             ((HRESULT)0x80042448L)

//
// MessageId: VDS_S_ACCESS_PATH_NOT_DELETED
//
// MessageText:
//
// The access paths on the volume may not be deleted.
//
#define VDS_S_ACCESS_PATH_NOT_DELETED    ((HRESULT)0x00044244L)

//
// MessageId: VDS_E_PROVIDER_TYPE_NOT_SUPPORTED
//
// MessageText:
//
// The method call is not supported for the specified provider type.
//
#define VDS_E_PROVIDER_TYPE_NOT_SUPPORTED ((HRESULT)0x8004244AL)

//
// MessageId: VDS_E_DISK_NOT_ONLINE
//
// MessageText:
//
// This disk is already offline. 
//
#define VDS_E_DISK_NOT_ONLINE            ((HRESULT)0x8004244BL)

//
// MessageId: VDS_E_DISK_IN_USE_BY_VOLUME
//
// MessageText:
//
// The disk is already in use by the volume.
//
#define VDS_E_DISK_IN_USE_BY_VOLUME      ((HRESULT)0x8004244CL)

//
// MessageId: VDS_S_IN_PROGRESS
//
// MessageText:
//
// The asynchronous operation is in progress.
//
#define VDS_S_IN_PROGRESS                ((HRESULT)0x0004244DL)

//
// MessageId: VDS_E_ASYNC_OBJECT_FAILURE
//
// MessageText:
//
// Failure initializing the asynchronous object.
//
#define VDS_E_ASYNC_OBJECT_FAILURE       ((HRESULT)0x8004244EL)

//
// MessageId: VDS_E_VOLUME_NOT_MOUNTED
//
// MessageText:
//
// A file system is not mounted on the volume.
//
#define VDS_E_VOLUME_NOT_MOUNTED         ((HRESULT)0x8004244FL)

//
// MessageId: VDS_E_PACK_NOT_FOUND
//
// MessageText:
//
// The pack was not found.
//
#define VDS_E_PACK_NOT_FOUND             ((HRESULT)0x80042450L)

//
// MessageId: VDS_E_IMPORT_SET_INCOMPLETE
//
// MessageText:
//
// Import failed. Attempt to import a subset of the disks in the foreign pack.
//
#define VDS_E_IMPORT_SET_INCOMPLETE      ((HRESULT)0x80042451L)

//
// MessageId: VDS_E_DISK_NOT_IMPORTED
//
// MessageText:
//
// A disk in the import's source pack was not imported.
//
#define VDS_E_DISK_NOT_IMPORTED          ((HRESULT)0x80042452L)

//
// MessageId: VDS_E_OBJECT_OUT_OF_SYNC
//
// MessageText:
//
// The system's information about the object may not be up to date.
//
#define VDS_E_OBJECT_OUT_OF_SYNC         ((HRESULT)0x80042453L)

//
// MessageId: VDS_E_MISSING_DISK
//
// MessageText:
//
// The disk is missing.
//
#define VDS_E_MISSING_DISK               ((HRESULT)0x80042454L)

//
// MessageId: VDS_E_DISK_PNP_REG_CORRUPT
//
// MessageText:
//
// The provider's list of Pnp registered disks has become corrupt.
//
#define VDS_E_DISK_PNP_REG_CORRUPT       ((HRESULT)0x80042455L)

//
// MessageId: VDS_E_LBN_REMAP_ENABLED_FLAG
//
// MessageText:
//
// The provider does not support the LBN REMAP ENABLED volume flag.
//
#define VDS_E_LBN_REMAP_ENABLED_FLAG     ((HRESULT)0x80042456L)

//
// MessageId: VDS_E_NO_DRIVELETTER_FLAG
//
// MessageText:
//
// The provider does not support the NO DRIVELETTER volume flag.
//
#define VDS_E_NO_DRIVELETTER_FLAG        ((HRESULT)0x80042457L)

//
// MessageId: VDS_E_REVERT_ON_CLOSE
//
// MessageText:
//
// REVERT ON CLOSE may only be used with GPT flags HIDDEN, READ ONLY, 
// NO DRIVE LETTER or SHADOW COPY.
//
#define VDS_E_REVERT_ON_CLOSE            ((HRESULT)0x80042458L)

//
// MessageId: VDS_E_REVERT_ON_CLOSE_SET
//
// MessageText:
//
// The REVERT ON CLOSE volume flag is already set for this volume.
//
#define VDS_E_REVERT_ON_CLOSE_SET        ((HRESULT)0x80042459L)

//
// MessageId: VDS_E_IA64_BOOT_MIRRORED_TO_MBR
//
// MessageText:
//
// Not used! You have mirrored your boot volume on a GPT disk, to an MBR disk. 
// You will not be able to boot your machine from the secondary plex.
//
#define VDS_E_IA64_BOOT_MIRRORED_TO_MBR  ((HRESULT)0x8004245AL)

//
// MessageId: VDS_S_IA64_BOOT_MIRRORED_TO_MBR
//
// MessageText:
//
// You have mirrored your boot volume on a GPT disk, to an MBR disk. 
// You will not be able to boot your machine from the secondary plex.
//
#define VDS_S_IA64_BOOT_MIRRORED_TO_MBR  ((HRESULT)0x0004245AL)

//
// MessageId: VDS_S_UNABLE_TO_GET_GPT_ATTRIBUTES
//
// MessageText:
//
// Unable to retrieve the GPT attributes for this volume, (hidden, read only 
// and no drive letter).
//
#define VDS_S_UNABLE_TO_GET_GPT_ATTRIBUTES ((HRESULT)0x0004245BL)

//
// MessageId: VDS_E_VOLUME_TEMPORARILY_DISMOUNTED
//
// MessageText:
//
// The volume is temporarily dismounted.
//
#define VDS_E_VOLUME_TEMPORARILY_DISMOUNTED ((HRESULT)0x8004245CL)

//
// MessageId: VDS_E_VOLUME_PERMANENTLY_DISMOUNTED
//
// MessageText:
//
// The volume is permanently dismounted.
//
#define VDS_E_VOLUME_PERMANENTLY_DISMOUNTED ((HRESULT)0x8004245DL)

//
// MessageId: VDS_E_VOLUME_HAS_PATH
//
// MessageText:
//
// The volume still has access path to it.
//
#define VDS_E_VOLUME_HAS_PATH            ((HRESULT)0x8004245EL)

//
// MessageId: VDS_E_TIMEOUT
//
// MessageText:
//
// The operation timed out.
//
#define VDS_E_TIMEOUT                    ((HRESULT)0x8004245FL)

//
// MessageId: VDS_E_REPAIR_VOLUMESTATE
//
// MessageText:
//
// To repair a volume, both the volume and plex must be online, and must not be 
// healthy or rebuilding.
//
#define VDS_E_REPAIR_VOLUMESTATE         ((HRESULT)0x80042460L)

//
// MessageId: VDS_E_LDM_TIMEOUT
//
// MessageText:
//
// The operation timed out in the Logical Disk Manager Administrative service. 
// Retry the operation.
//
#define VDS_E_LDM_TIMEOUT                ((HRESULT)0x80042461L)

//
// MessageId: VDS_E_REVERT_ON_CLOSE_MISMATCH
//
// MessageText:
//
// When clearing volume flags that have been set using revert on close, 
// the same combination of HIDDEN, READ ONLY, NO DRIVE LETTER or SHADOW COPY 
// flags must be passed to both the SetFlags and ClearFlags calls.
//
#define VDS_E_REVERT_ON_CLOSE_MISMATCH   ((HRESULT)0x80042462L)

//
// MessageId: VDS_E_RETRY
//
// MessageText:
//
// The operation failed. Retry the operation.
//
#define VDS_E_RETRY                      ((HRESULT)0x80042463L)

//
// MessageId: VDS_E_ONLINE_PACK_EXISTS
//
// MessageText:
//
// Create pack operation failed. An online pack already exists.
//
#define VDS_E_ONLINE_PACK_EXISTS         ((HRESULT)0x80042464L)

//
// MessageId: VDS_S_EXTEND_FILE_SYSTEM_FAILED
//
// MessageText:
//
// The volume was extended successfully but the file system failed to extend.
//
#define VDS_S_EXTEND_FILE_SYSTEM_FAILED  ((HRESULT)0x00042465L)

//
// MessageId: VDS_E_EXTEND_FILE_SYSTEM_FAILED
//
// MessageText:
//
// The file system failed to extend.
//
#define VDS_E_EXTEND_FILE_SYSTEM_FAILED  ((HRESULT)0x80042466L)

//
// MessageId: VDS_S_MBR_BOOT_MIRRORED_TO_GPT
//
// MessageText:
//
// You have mirrored your boot volume on an MBR disk, to a GPT disk. 
// You will not be able to boot your machine from the secondary plex.
//
#define VDS_S_MBR_BOOT_MIRRORED_TO_GPT   ((HRESULT)0x00042467L)

//
// MessageId: VDS_E_MAX_USABLE_MBR
//
// MessageText:
//
// Only the first 2TB are usable on large MBR disks. 
// Cannot create partitions beyond the 2TB mark, nor convert 
// the disk to dynamic.
//
#define VDS_E_MAX_USABLE_MBR             ((HRESULT)0x80042468L)

//
// MessageId: VDS_S_GPT_BOOT_MIRRORED_TO_MBR
//
// MessageText:
//
// You have mirrored your boot volume on a GPT disk, to an MBR disk. 
// You will not be able to boot your machine from the secondary plex.
//
#define VDS_S_GPT_BOOT_MIRRORED_TO_MBR   ((HRESULT)0x80042469L)

//////////////////////////////////////////////////////////////////////////////
//
// Codes added in Windows Vista:                 0x2500-0x26FF
//
//////////////////////////////////////////////////////////////////////////////
//
// MessageId: VDS_E_NO_SOFTWARE_PROVIDERS_LOADED
//
// MessageText:
//
// There are no software provders loaded.
//
#define VDS_E_NO_SOFTWARE_PROVIDERS_LOADED ((HRESULT)0x80042500L)

//
// MessageId: VDS_E_DISK_NOT_MISSING
//
// MessageText:
//
// The disk is not missing.
//
#define VDS_E_DISK_NOT_MISSING           ((HRESULT)0x80042501L)

//
// MessageId: VDS_E_NO_VOLUME_LAYOUT
//
// MessageText:
//
// Failed to retrieve the volume's layout. Operations on the volume will fail.
//
#define VDS_E_NO_VOLUME_LAYOUT           ((HRESULT)0x80042502L)

//
// MessageId: VDS_E_CORRUPT_VOLUME_INFO
//
// MessageText:
//
// The volume's driver information is corrupt. Operations on the volume will fail.
//
#define VDS_E_CORRUPT_VOLUME_INFO        ((HRESULT)0x80042503L)

//
// MessageId: VDS_E_INVALID_ENUMERATOR
//
// MessageText:
//
// The enumerator is corrupted.
//
#define VDS_E_INVALID_ENUMERATOR         ((HRESULT)0x80042504L)

//
// MessageId: VDS_E_DRIVER_INTERNAL_ERROR
//
// MessageText:
//
// Internal error in the volume management driver.
//
#define VDS_E_DRIVER_INTERNAL_ERROR      ((HRESULT)0x80042505L)

//
// MessageId: VDS_E_VOLUME_INVALID_NAME
//
// MessageText:
//
// The volume name is invalid.
//
#define VDS_E_VOLUME_INVALID_NAME        ((HRESULT)0x80042507L)

//
// MessageId: VDS_S_DISK_IS_MISSING
//
// MessageText:
//
// The disk is missing, not all information could be returned.
//
#define VDS_S_DISK_IS_MISSING            ((HRESULT)0x00042508L)

//
// MessageId: VDS_E_CORRUPT_PARTITION_INFO
//
// MessageText:
//
// The disk's partition information is corrupted.
//
#define VDS_E_CORRUPT_PARTITION_INFO     ((HRESULT)0x80042509L)

//
// MessageId: VDS_S_NONCONFORMANT_PARTITION_INFO
//
// MessageText:
//
// The disk's partition information is does not conform to that expected 
// on a dynamic disk.
//
#define VDS_S_NONCONFORMANT_PARTITION_INFO ((HRESULT)0x0004250AL)

//
// MessageId: VDS_E_CORRUPT_EXTENT_INFO
//
// MessageText:
//
// The disk's extent information is corrupted.
//
#define VDS_E_CORRUPT_EXTENT_INFO        ((HRESULT)0x8004250BL)

//
// MessageId: VDS_E_DUP_EMPTY_PACK_GUID
//
// MessageText:
//
// An empty pack already exists. Release the existing empty pack before 
// creating another empty pack.
//
#define VDS_E_DUP_EMPTY_PACK_GUID        ((HRESULT)0x8004250CL)

//
// MessageId: VDS_E_DRIVER_NO_PACK_NAME
//
// MessageText:
//
// The volume management driver did not return a pack name. 
// Internal driver error.
//
#define VDS_E_DRIVER_NO_PACK_NAME        ((HRESULT)0x8004250DL)

//
// MessageId: VDS_S_SYSTEM_PARTITION
//
// MessageText:
//
// Warning, there was a failure while checking for the system partition.
//
#define VDS_S_SYSTEM_PARTITION           ((HRESULT)0x0004250EL)

//
// MessageId: VDS_E_BAD_PNP_MESSAGE
//
// MessageText:
//
// The PNP service sent a corrupted notification to the provider.
//
#define VDS_E_BAD_PNP_MESSAGE            ((HRESULT)0x8004250FL)

//
// MessageId: VDS_E_NO_PNP_DISK_ARRIVE
//
// MessageText:
//
// No disk arrival notification was received.
//
#define VDS_E_NO_PNP_DISK_ARRIVE         ((HRESULT)0x80042510L)

//
// MessageId: VDS_E_NO_PNP_VOLUME_ARRIVE
//
// MessageText:
//
// No volume arrival notification was received.
//
#define VDS_E_NO_PNP_VOLUME_ARRIVE       ((HRESULT)0x80042511L)

//
// MessageId: VDS_E_NO_PNP_DISK_REMOVE
//
// MessageText:
//
// No disk removal notification was received.
//
#define VDS_E_NO_PNP_DISK_REMOVE         ((HRESULT)0x80042512L)

//
// MessageId: VDS_E_NO_PNP_VOLUME_REMOVE
//
// MessageText:
//
// No volume removal notification was received.
//
#define VDS_E_NO_PNP_VOLUME_REMOVE       ((HRESULT)0x80042513L)

//
// MessageId: VDS_E_PROVIDER_EXITING
//
// MessageText:
//
// The provider is exiting.
//
#define VDS_E_PROVIDER_EXITING           ((HRESULT)0x80042514L)

//
// MessageId: VDS_E_EXTENT_EXCEEDS_DISK_FREE_SPACE
//
// MessageText:
//
// The specified disk extent size exceeds the size of free disk space.
//
#define VDS_E_EXTENT_EXCEEDS_DISK_FREE_SPACE ((HRESULT)0x80042515L)

//
// MessageId: VDS_E_MEMBER_SIZE_INVALID
//
// MessageText:
//
// The size of the plex member is invalid.
//
#define VDS_E_MEMBER_SIZE_INVALID        ((HRESULT)0x80042516L)

//
// MessageId: VDS_S_NO_NOTIFICATION
//
// MessageText:
//
// No volume arrival notification was received. 
// Refresh the Disk Management display.
//
#define VDS_S_NO_NOTIFICATION            ((HRESULT)0x00042517L)

//
// MessageId: VDS_S_DEFAULT_PLEX_MEMBER_IDS
//
// MessageText:
//
// Defaults have been used for the member ids or plex ids.
//
#define VDS_S_DEFAULT_PLEX_MEMBER_IDS    ((HRESULT)0x00042518L)

//
// MessageId: VDS_E_INVALID_DISK
//
// MessageText:
//
// This operation is not allowed on an invalid disk. The disk may be 
// invalid because it is corrupted or failing, or it may be invalid 
// because it is OFFLINE.
//
#define VDS_E_INVALID_DISK               ((HRESULT)0x80042519L)

//
// MessageId: VDS_E_INVALID_PACK
//
// MessageText:
//
// This operation is not allowed on the invalid disk pack.
//
#define VDS_E_INVALID_PACK               ((HRESULT)0x8004251AL)

//
// MessageId: VDS_E_VOLUME_ON_DISK
//
// MessageText:
//
// This operation is not allowed on disks with volumes.
//
#define VDS_E_VOLUME_ON_DISK             ((HRESULT)0x8004251BL)

//
// MessageId: VDS_E_DRIVER_INVALID_PARAM
//
// MessageText:
//
// The driver returned an invalid parameter error.
//
#define VDS_E_DRIVER_INVALID_PARAM       ((HRESULT)0x8004251CL)

//
// MessageId: VDS_E_TARGET_PACK_NOT_EMPTY
//
// MessageText:
//
// The target pack is not empty.
//
#define VDS_E_TARGET_PACK_NOT_EMPTY      ((HRESULT)0x8004251DL)

//
// MessageId: VDS_E_CANNOT_SHRINK
//
// MessageText:
//
// The volume cannot be shrunk because the file system does not support it.
//
#define VDS_E_CANNOT_SHRINK              ((HRESULT)0x8004251EL)

//
// MessageId: VDS_E_MULTIPLE_PACKS
//
// MessageText:
//
// Specified disks are not all from the same pack.
//
#define VDS_E_MULTIPLE_PACKS             ((HRESULT)0x8004251FL)

//
// MessageId: VDS_E_PACK_ONLINE
//
// MessageText:
//
// This operation is not allowed on online packs. The pack must be offline.
//
#define VDS_E_PACK_ONLINE                ((HRESULT)0x80042520L)

//
// MessageId: VDS_E_INVALID_PLEX_COUNT
//
// MessageText:
//
// The plex count for the volume must be non-zero.
//
#define VDS_E_INVALID_PLEX_COUNT         ((HRESULT)0x80042521L)

//
// MessageId: VDS_E_INVALID_MEMBER_COUNT
//
// MessageText:
//
// The member count for the volume must be non-zero.
//
#define VDS_E_INVALID_MEMBER_COUNT       ((HRESULT)0x80042522L)

//
// MessageId: VDS_E_INVALID_PLEX_ORDER
//
// MessageText:
//
// The plex indexes must be monotonically increasing and begin with zero.
//
#define VDS_E_INVALID_PLEX_ORDER         ((HRESULT)0x80042523L)

//
// MessageId: VDS_E_INVALID_MEMBER_ORDER
//
// MessageText:
//
// The member indexes must be monotonically increasing and begin with zero.
//
#define VDS_E_INVALID_MEMBER_ORDER       ((HRESULT)0x80042524L)

//
// MessageId: VDS_E_INVALID_STRIPE_SIZE
//
// MessageText:
//
// The stripe size must be a multiple of 2, between 512 bytes and 1 MB, 
// for stripe and raid5 volumes. The stripe size must be zero for other 
// volume types.
//
#define VDS_E_INVALID_STRIPE_SIZE        ((HRESULT)0x80042525L)

//
// MessageId: VDS_E_INVALID_DISK_COUNT
//
// MessageText:
//
// The number of disks specified is invalid for this operation.
//
#define VDS_E_INVALID_DISK_COUNT         ((HRESULT)0x80042526L)

//
// MessageId: VDS_E_INVALID_EXTENT_COUNT
//
// MessageText:
//
// An invalid number of extents was specified for at least one disk.
