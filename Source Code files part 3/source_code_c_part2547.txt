ms
    } // asm
    piSource += iAlignedBlocksOfFour * 4 * cChannel;
    piFIROut += iAlignedBlocksOfFour * 4;

    // Remember that piSource was made to point to 32-byte boundary, even if actual input sources
    // don't live on that boundary (eg, ABAB with first "A" on 32-byte boundary, our inputs are the "B"'s)
    // If we were reading the odd ones, we need to add one here
    if (iNumUnalignedStartALL & 1)
        piSource += 1;

    // Finish off the unaligned samples
    NTapFIR_Unaligned_MMX(rgiCoefNum, piSource, iNumUnalignedEnd, rgiSrc,
        piFIROut, cChannel, 5);
} // FiveTapNUMERATOR_MMX_STEREO



void EightTapNUMERATOR_MMX_STEREO
                       (const I16 *rgiCoefNum,
                        const I16 *piSource,
                        I16* rgiSrc, I32 *piSrcCurr,
                        const Int iSourceLength,
                        I32 *piFIROutAligned, const I32 c_iAlignMultiple,
                        I16 *piMMXCoefs, const I32 iSizeOfMMXCoefs)
{
    const int cChannel = 2;

    Int iSrcCurr = *piSrcCurr;
    I32    *piFIROut = piFIROutAligned;
    I32     iShiftLeft;

    int     iNumUnalignedStart;             // Number of unaligned samples at start of block
    int     iNumUnalignedStartALL;          // Unaligned samples at start including other channel's
    int     iNumUnalignedEnd;               // Number of unaligned samples at end of block
    int     iAlignedBlocksOfFour;           // Number of aligned blocks of 4 samples

    // Determine number of aligned, unaligned samples
    assert(((c_iAlignMultiple - 1) & c_iAlignMultiple) == 0); // Pure power of 2
    iNumUnalignedStartALL = ((((U32) piSource + c_iAlignMultiple - 1) & ~(c_iAlignMultiple - 1)) -
        (U32) piSource) / sizeof(*piSource);
    iNumUnalignedStart = (iNumUnalignedStartALL + 1) / cChannel;
    iAlignedBlocksOfFour = (iSourceLength - iNumUnalignedStart) / 4; // DIV 4
    iNumUnalignedEnd = (iSourceLength - iNumUnalignedStart) & (4-1); // MOD 4

    // FIRST, calculate unaligned start samples
    NTapFIR_Unaligned_MMX(rgiCoefNum, piSource, iNumUnalignedStart, rgiSrc,
        piFIROut, cChannel, 8);
    piSource += iNumUnalignedStartALL;
    assert(0 == (((U32)piSource) & (c_iAlignMultiple -1)));
    piFIROut += iNumUnalignedStart;

    // Set up staggered MMX coefficient arrays, then go MMX for aligned inputs
    // Align staggered MMX coefficient array on 32-byte boundary

    // Perf tests indicate that initializing MMX coefs EVERY TIME is slightly
    // faster than init once and much faster than hard-coded tables or
    // pre-initialized. Strange but true. Mem alignment is definitely a factor.

    InitMMXFilterCoefs(piMMXCoefs, iSizeOfMMXCoefs, rgiCoefNum, 8);
    if (iNumUnalignedStartALL & 1)
    {
        // ODD # samples from piSource to align point,
        // we use sizeof(I16) offset from align
        iShiftLeft = 0; // Desired input will get read into slots 1,3
    }
    else
    {
        // EVEN # samples from piSource to align point,
        // we use 0 offset from align
        iShiftLeft = 16; // Desired input will get read into slots 0,2
    }

    assert(0 == ((U32)piFIROut & 1)); // Verify we're on a DWORD boundary
    assert(0 == *piSrcCurr); // MMX history matches input order, it's NOT a doubled history

#define iShiftLeftASM   eax
#define piFIROutput     ebx
#define iLoopCtr        ecx
#define piSrcHistory    edx
#define piSrc           esi
#define piMMXCoefsASM   edi

#define SIZEOF_I16      2
#define SIZEOF_I32      4

    _asm
    {
        mov         iShiftLeftASM, iShiftLeft
        mov         iLoopCtr, iAlignedBlocksOfFour  // Load the index ctr
        mov         piSrcHistory, rgiSrc
        mov         piSrc, piSource
        movq        mm7, [piSrcHistory]                 // Oldest 4 samples (history): unaligned, but only done once
        movq        mm6, [piSrcHistory + 4*SIZEOF_I16]  // Second-oldest 4 samples (history): unaligned, but only done once
        mov         piFIROutput, piFIROut
        mov         piMMXCoefsASM, piMMXCoefs

MMXLOOP:
        // We used to pre-load input. DON'T DO THIS, last iteration can read past valid memory
        // Load in the input
        movq        mm4, [piSrc + 0*SIZEOF_I16]
        movq        mm3, [piSrc + 4*SIZEOF_I16]

        // Throw away the samples we don't want to construct next input vector
        pxor        mm1, mm1                    // Zero it
        movd        mm1, iShiftLeftASM
        movq        mm5, mm4
        pslld       mm5, mm1                    // Shift left by 16 or 0
        psrad       mm5, 16                     // Shift right is always 16
        pslld       mm3, mm1                    // Shift left by 16 or 0
        psrad       mm3, 16                     // Shift right is always 16
        packssdw    mm5, mm3                    // Combine the results to get 4 inputs

        // ---INTERATION 0---
        movq        mm2, mm7                            // Copy oldest history
        movq        mm1, mm6                            // Copy second-oldest history
        pmaddwd     mm2, [piMMXCoefsASM + SIZEOF_I16*0] // MADD oldest history w/ 1-offset coefs
        movq        mm0, mm5                            // Copy current input vector
        pmaddwd     mm1, [piMMXCoefsASM + SIZEOF_I16*4] // MADD second-oldest history
        pmaddwd     mm0, [piMMXCoefsASM + SIZEOF_I16*8] // MADD current input vector
        paddd       mm2, mm1                            // Sum mm1 + mm2 results
        paddd       mm0, mm2                            // Sum (mm1 + mm2) + mm0 results
        movq        mm1, mm0                            // Now sum horizontally: HI32(mm0) + LO32(mm0)
        psrlq       mm0, 32
        paddd       mm0, mm1

        movd        [piFIROutput + SIZEOF_I32*0], mm0   // Output results


        // ---INTERATION 1---
        movq        mm2, mm7                            // Copy oldest history
        movq        mm1, mm6                            // Copy second-oldest history
        pmaddwd     mm2, [piMMXCoefsASM + SIZEOF_I16*12]// MADD oldest history w/ 2-offset coefs
        movq        mm0, mm5                            // Copy current input vector
        pmaddwd     mm1, [piMMXCoefsASM + SIZEOF_I16*16]// MADD second-oldest history
        pmaddwd     mm0, [piMMXCoefsASM + SIZEOF_I16*20]// MADD current input vector
        paddd       mm2, mm1                            // Sum mm1 + mm2 results
        paddd       mm0, mm2                            // Sum (mm1 + mm2) + mm0 results
        movq        mm1, mm0                            // Now sum horizontally: HI32(mm0) + LO32(mm0)
        psrlq       mm0, 32
        paddd       mm0, mm1

        movd        [piFIROutput + SIZEOF_I32*1], mm0   // Output results


        // ---INTERATION 2---
        movq        mm2, mm7                            // Copy oldest history
        movq        mm1, mm6                            // Copy second-oldest history
        pmaddwd     mm2, [piMMXCoefsASM + SIZEOF_I16*24]// MADD oldest history w/ 3-offset coefs
        movq        mm0, mm5                            // Copy current input vector
        pmaddwd     mm1, [piMMXCoefsASM + SIZEOF_I16*28]// MADD second-oldest history
        pmaddwd     mm0, [piMMXCoefsASM + SIZEOF_I16*32]// MADD current input vector
        paddd       mm2, mm1                            // Sum mm1 + mm2 results
        paddd       mm0, mm2                            // Sum (mm1 + mm2) + mm0 results
        movq        mm1, mm0                            // Now sum horizontally: HI32(mm0) + LO32(mm0)
        psrlq       mm0, 32
        paddd       mm0, mm1

        movd        [piFIROutput + SIZEOF_I32*2], mm0   // Output results


        // ---INTERATION 3---
        movq        mm1, mm6                            // Copy second-oldest history
        movq        mm0, mm5                            // Copy current input vector
        pmaddwd     mm1, [piMMXCoefsASM + SIZEOF_I16*36]// MADD second-oldest history w/ 4-offset coefs
        pmaddwd     mm0, [piMMXCoefsASM + SIZEOF_I16*40]// MADD current input vector
        paddd       mm0, mm1                            // Sum mm1 + mm0 results
        movq        mm1, mm0                            // Now sum horizontally: HI32(mm0) + LO32(mm0)
        psrlq       mm0, 32
        paddd       mm0, mm1

        movd        [piFIROutput + SIZEOF_I32*3], mm0   // Output results


        // Load next input, decrement ctrs, advance ptrs and loop around
        add         piSrc, 8*SIZEOF_I16
        add         piFIROutput, 4*SIZEOF_I32
        dec         iLoopCtr
        movq        mm7, mm6                    // Second-oldest history is now oldest
        movq        mm6, mm5                    // Current input vector is now 2nd oldest

        jnz         MMXLOOP

        // End of loop
        movq        [piSrcHistory], mm7                 // Oldest 4 samples (history): unaligned, but only done once
        movq        [piSrcHistory + 4*SIZEOF_I16], mm6  // Second-oldest 4 samples (history): unaligned, but only done once
        emms
    } // asm
    piSource += iAlignedBlocksOfFour * 4 * cChannel;
    piFIROut += iAlignedBlocksOfFour * 4;

    // Remember that piSource was made to point to 32-byte boundary, even if actual input sources
    // don't live on that boundary (eg, ABAB with first "A" on 32-byte boundary, our inputs are the "B"'s)
    // If we were reading the odd ones, we need to add one here
    if (iNumUnalignedStartALL & 1)
        piSource += 1;

    // Finish off the unaligned samples
    NTapFIR_Unaligned_MMX(rgiCoefNum, piSource, iNumUnalignedEnd, rgiSrc,
        piFIROut, cChannel, 8);
} // EightTapNUMERATOR_MMX_STEREO




//***************************************************************************
// FLOP DENOMINATORS
//***************************************************************************
void INLINE
FourTapDENOMINATOR_FLOP
                      (const Float *rgfltCoefDen,
                       const int position, const Float fltInvNumScale,
                       float *rgfltDst, I32 *piDstCurr,
                       const Int iSliceIncr, Float *pfltPower,
                       const Int iSourceLength, const I32 *piFIROutAligned)
{
    const Int c_minus1Mod3[] = {2, 0, 1};
    const int c_iSliceMask = iSliceIncr - 1;
    const int c_iASMLoopsPerSlice = iSliceIncr / 2;

    Int iDstCurr = *piDstCurr;
    Float fltSumSquared = 0;

    I32 iOuterLoops;

    // C setup for FLOP denominator
    assert(0 == iSliceIncr % 4); // ASM FLOP loop can only handle multiples of 4
    assert(0 == iSourceLength % iSliceIncr); // Won't do partial computations at the moment
    assert(iSourceLength >= iSliceIncr);
    iOuterLoops = iSourceLength / iSliceIncr;

#undef  ORDER
#define ORDER   3

#define iDstCurrPREV    eax
#define piFIROutput     ebx
#define iSliceLoopCtr   ecx
#define pfltPowerASM    ecx
#define pfltDstHistory  edx
#define iOuterLoopsASM  edx
#define iDstCurrASM     esi
#define iPositionASM    edi
#define pfltCoefDen     edi

// Need to do this because stupid assembler translates [edx+(esi+x)*4]
// to [edx+esi*4+x]. So this macro does the expansion manually.
#define HISTORYIDX(reg,offset)  ((reg)*SIZEOF_FLT + (offset)*SIZEOF_FLT)

#define SIZEOF_FLT      4

    // For ease of commenting, let
    //    A = fltInvNumScale * piFIROutAligned[j]
    //    B = rgfltCoefDen[1] * rgfltDst[iDstCurr + 0] = B1-1 * B1-2
    //    C = rgfltCoefDen[2] * rgfltDst[iDstCurr + 1] = C1-1 * C1-2
    //    D = rgfltCoefDen[3] * rgfltDst[iDstCurr + 2] = D1-1 * D1-2

    _asm
    {
        //-------------------------------------------------------------------
        // SETUP
        //-------------------------------------------------------------------
        mov     piFIROutput, piFIROutAligned
        mov     iSliceLoopCtr, c_iASMLoopsPerSlice
        mov     pfltDstHistory, rgfltDst
        mov     iDstCurrASM, iDstCurr
        mov     pfltCoefDen, rgfltCoefDen

        // NOTE: All NOP's have been omitted in the code below.

        //-------------------------------------------------------------------
        // PROLOG: Get us into steady-state so we can loop
        //-------------------------------------------------------------------

        // Clock 0: stack empty
        fild    dword ptr [piFIROutput]                         // Load A1-1

        // Clock 1: A1-1
        fld     fltInvNumScale                                  // Load A1-2

        // Clock 2: A1-2, A1-1
        fld     dword ptr [pfltCoefDen + 2*SIZEOF_FLT]          // Load C1-1
        
        // Clock 3: C1-1, A1-2, A1-1
        fld     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 1)] // Load C1-2
        fxch    st(2)

        // Clock 4: A1-2, C1-1, C1-2, A1-1
        fmulp   st(3), st(0)                                    // Compute A1
        fld     dword ptr [pfltCoefDen + 3*SIZEOF_FLT]          // Load D1-1

        // Clock 5: D1-1, C1-1, C1-2, A1
        fld     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 2)] // Load D1-2
        mov     iDstCurrASM, dword ptr [c_minus1Mod3 + iDstCurrASM*SIZEOF_I32] // Load next history slot

        // Clock 6: D1-2, D1-1, C1-1, C1-2, A1
        fild    dword ptr [piFIROutput + 1*SIZEOF_FLT]          // Load A2-1
        fxch    st(3)
        fmulp   st(4), st(0)                                    // Compute C1

        // Clock 7: D1-2, D1-1, A2-1, C1, A1
        fld     fltInvNumScale                                  // Load A2-2
        fxch    st(1)

        // Clock 8: D1-2, A2-2, D1-1, A2-1, C1, A1
        fmulp   st(2), st(0)                                    // Compute D1
        fld     dword ptr [pfltCoefDen + 1*SIZEOF_FLT]          // Load B1-1
        fxch    st(1)                                           // StackOrder: A2 in st(1) by clock 22

        // Clock 9: A2-2, B1-1, D1, A2-1, C1, A1
        fld     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 1)] // Load B1-2 (we loaded new iDstCurrASM so use 1 instead of 0)
        fxch    st(4)

        // Clock 10: A2-1, A2-2, B1-1, D1, B1-2, C1, A1
        fmulp   st(1), st(0)                                    // Compute A2
        fld     dword ptr [pfltCoefDen + 2*SIZEOF_FLT]          // Load C2-1
        fxch    st(5)

        // Clock 11: C1, A2, B1-1, D1, B1-2, C2-1, A1
        fsubp   st(6), st(0)                                    // Compute A1-C1
        fld     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 1)] // Load C2-2
        fxch    st(2)

        // Clock 12: B1-1, A2, C2-2, D1, B1-2, C2-1, A1-C1
        fmulp   st(4), st(0)                                    // Compute B1
        fld     dword ptr [pfltCoefDen + 3*SIZEOF_FLT]          // Load D2-1
        mov     iDstCurrPREV, iDstCurrASM                       // Save this for later reference

        // Clock 13: D2-1, A2, C2-2, D1, B1, C2-1, A1-C1
        fxch    st(1)                                           // StackOrder: A2 in st(1) by clock 22
        fld     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 2)] // Load D2-2
        fxch    st(4)

        // Clock 14: D1, A2, D2-1, C2-2, D2-2, B1, C2-1, A1-C1
        fsubp   st(7), st(0)                                    // Compute A1-C1-D1
        fld     fltSumSquared                                   // Load prevPwr

        // Clock 15: prevPwr, A2, D2-1, C2-2, D2-2, B1, C2-1, A1-C1-D1
        fxch    st(3)
        mov     iDstCurrASM, dword ptr [c_minus1Mod3 + iDstCurrASM*SIZEOF_I32] // Load next history slot

        // Clock 16: C2-2, A2, D2-1, prevPwr, D2-2, B1, C2-1, A1-C1-D1
        fmulp   st(6), st(0)                                    // Compute C2
        fldz                                                    // Load PWR0 = 0
        fxch    st(5)

        // Clock 17: B1, A2, D2-1, prevPwr, D2-2, PWR0, C2, A1-C1-D1
        fsubp   st(7), st(0)                                    // Compute A1-C1-D1-B1 = O1
        fld     dword ptr [pfltCoefDen + 1*SIZEOF_FLT]          // Load B2-1
        fxch    st(2)

        //-------------------------------------------------------------------
        // STEADY-STATE: Loop like the wind
        //-------------------------------------------------------------------

        // The FLOP stacks of clocks 41 and 18 MUST MATCH in order to to loop around
        // Comments marked as "StackOrder" indicate that a particular choice was made
        // in order to satisfy this requirement (or in order to avoid fxch's)

FLOPLOOP:
        // Clock 18: D2-1, A2, B2-1, prevPwr, D2-2, PWR0, C2, O1
        fmulp   st(4), st(0)                                    // Compute D2


        // Clock 19: A2, B2-1, prevPwr, D2, PWR0, C2, O1
        fild    dword ptr [piFIROutput + 2*SIZEOF_FLT]          // Load A3-1
        fxch    st(3)
        faddp   st(5), st(0)                                    // Compute prevPwr+PWR0=newPwr0

        // Clock 20: A2, B2-1, A3-1, D2, newPwr0, C2, O1
        fld     fltInvNumScale                                  // Load A3-2
        fxch    st(7)
        
        // Clock 21: O1, A2, B2-1, A3-1, D2, newPwr0, C2, A3-2
        fst     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrPREV, 0)] // Store O1 in proper slot
        fmul    st(2), st(0)                                    // Compute B2

        // Clock 22: O1, A2, B2, A3-1, D2, newPwr0, C2, A3-2
        fst     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrPREV, ORDER)] // Store O1 in proper slot
        fxch    st(1)
        fsubrp  st(6), st(0)                                    // Compute A2-C2

        // Clock 23: O1, B2, A3-1, D2, newPwr0, A2-C2, A3-2
        fmul    st(0), st(0)                                    // Compute PWR1
        fld     dword ptr [pfltCoefDen + 2*SIZEOF_FLT]          // Load C3-1
        fxch    st(5)

        // Clock 24: newPwr0, PWR1, B2, A3-1, D2, C3-1, A2-C2, A3-2
        fstp    fltSumSquared                                   // Store newPwr0
        fld     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 1)] // Load C3-2
        fxch    st(3)

        // Clock 25: A3-1, PWR1, B2, C3-2, D2, C3-1, A2-C2, A3-2
        fmulp   st(7), st(0)                                    // Compute A3
        fld     dword ptr [pfltCoefDen + 3*SIZEOF_FLT]          // Load D3-1
        fxch    st(4)

        // Clock 26: D2, PWR1, B2, C3-2, D3-1, C3-1, A2-C2, A3
        fsubp   st(6), st(0)                                    // Compute A2-C2-D2
        fld     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 2)] // Load D3-2
        fxch    st(3)

        // Clock 27: C3-2, PWR1, B2, D3-2, D3-1, C3-1, A2-C2-D2, A3
        fmulp   st(5), st(0)                                    // Compute C3
        fld     fltSumSquared                                   // Load prevPwr
        mov     iDstCurrPREV, iDstCurrASM                       // Save this for later reference

        // Clock 28: prevPwr, PWR1, B2, D3-2, D3-1, C3, A2-C2-D2, A3
        mov     iDstCurrASM, dword ptr [c_minus1Mod3 + iDstCurrASM*SIZEOF_I32] // Load next history slot
        fxch    st(3)

        // Clock 29: D3-2, PWR1, B2, prevPwr, D3-1, C3, A2-C2-D2, A3
        fmulp   st(4), st(0)                                    // Compute D3
        fld     dword ptr [pfltCoefDen + 1*SIZEOF_FLT]          // Load B3-1
        fxch    st(6)                                           // StackOrder: O2 in st(1) by clock 32

        // Clock 30: A2-C2-D2, PWR1, B2, prevPwr, D3, C3, B3-1, A3
        fsubrp  st(2), st(0)                                    // Compute A2-C2-D2-B2 = O2
        fxch    st(1)                                           // StackOrder: O2 in st(1) by clock 32

        // Clock 31: O2, PWR1, prevPwr, D3, C3, B3-1, A3
        fild    dword ptr [piFIROutput + 3*SIZEOF_FLT]          // Load A4-1
        fxch    st(2)
        faddp   st(3), st(0)                                    // Compute newPwr1

        // Clock 32: O2, A4-1, newPwr1, D3, C3, B3-1, A3
        fld     fltInvNumScale                                  // Load A4-2
        fxch    st(5)
        fsubp   st(7), st(0)                                    // Compute A3-C3

        // Clock 33: O2, A4-1, newPwr1, D3, A4-2, B3-1, A3-C3
        fst     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrPREV, 0)] // Store O1 in proper slot
        fmul    st(5), st(0)                                    // Compute B3
        add     piFIROutput, 2*SIZEOF_FLT                       // Increment piFIROutput

        // Clock 34: O2, A4-1, newPwr1, D3, A4-2, B3, A3-C3
        fst     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrPREV, ORDER)] // Store O1 in proper slot
        fld     dword ptr [pfltCoefDen + 2*SIZEOF_FLT]          // Load C4-1
        fxch    st(3)

        // Clock 35: newPwr1, O2, A4-1, C4-1, D3, A4-2, B3, A3-C3
        fstp    fltSumSquared                                   // Store newPwr1
        fmul    st(0), st(0)                                    // Compute PWR2
        fld     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 1)] // Load C4-2

        // Clock 36: C4-2, PWR2, A4-1, C4-1, D3, A4-2, B3, A3-C3
        fxch    st(4)
        fsubp   st(7), st(0)                                    // Compute A3-C3-D3
        fld     dword ptr [pfltCoefDen + 3*SIZEOF_FLT]          // Load D4-1

        // Clock 37: D4-1, PWR2, A4-1, C4-1, C4-2, A4-2, B3, A3-C3-D3
        fxch    st(5)                                           // StackOrder: A4 in st(1)
        fmulp   st(2), st(0)                                    // Compute A4
        fld     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 2)] // Load D4-2

        // Clock 38: D4-2, PWR2, A4, C4-1, C4-2, D4-1, B3, A3-C3-D3
        // Push the usual fxch out of this slot to slot 39, so we can do dec iSliceLoopCtr will in advance
        dec     iSliceLoopCtr                                   // Decrement loop counter: 2 outputs completed/iteration
        mov     iDstCurrPREV, iDstCurrASM                       // Save this for later reference
        mov     iDstCurrASM, dword ptr [c_minus1Mod3 + iDstCurrASM*SIZEOF_I32] // Load next history slot

        // Clock 39: C4-2, PWR2, A4, C4-1, D4-2, D4-1, B3, A3-C3-D3
        fxch    st(4)                                           // StackOrder: D4-2 in st(4)
        fmulp   st(3), st(0)                                    // Compute C4
        fld     fltSumSquared                                   // Load prevPwr

        // Clock 40: B3, PWR2, A4, C4, D4-2, D4-1, prevPwr, A3-C3-D3
        fxch    st(6)
        fsubp   st(7), st(0)                                    // Compute A3-C3-D3-B3 = O3
        fld     dword ptr [pfltCoefDen + 1*SIZEOF_FLT]          // Load B4-1

        // Clock 41-1: B4-1, PWR2, A4, C4, D4-2, D4-1, prevPwr, O3
        fxch    st(2)
        // Clock 41-2: A4, PWR2, B4-1, C4, D4-2, D4-1, prevPwr, O3
        fxch    st(1)
        // Clock 41-3: PWR2, A4, B4-1, C4, D4-2, D4-1, prevPwr, O3
        fxch    st(3)

        // Clock 42-1: C4, A4, B4-1, PWR2, D4-2, D4-1, prevPwr, O3
        fxch    st(6)
        // Clock 42-2: prevPwr, A4, B4-1, PWR2, D4-2, D4-1, C4, O3
        fxch    st(5)
        // Clock 42-3:   D4-1, A4, B4-1, PWR2,    D4-2, prevPwr, C4, O3
        // vs. Clock 18: D2-1, A2, B2-1, prevPwr, D2-2, PWR0,    C2, O1
        // The FLOP stacks of clocks 41 and 18 MUST MATCH in order to to loop around
        // Note PWR2/prevPwr will be added, so they can exchange slots with each other

        //-------------------------------------------------------------------
        // END OF LOOP: Do some housekeeping, don't worry about pipeline scheduling
        //-------------------------------------------------------------------

        // Clock EOL-1 (use different numbering scheme for end-of-loop)
        jnz     FLOPLOOP

        // If we've reached this point, we've outputed iSliceIncr number of samples
        // prevPwr + PWR2 is the value we wish to write to pfltPower[position]
        // After doing this, be sure to set PWR2 = 0 and prevPwr = 0 on FLOP stack
        // Calculate power, write it out, and clear the running sum (fltSumSquared)
        mov     iOuterLoopsASM, iOuterLoops              // Check for outer loop termination

        // Clock EOL-2:
        dec     iOuterLoopsASM
        mov     iOuterLoops, iOuterLoopsASM              // Write iOuterLoops back to local var
        jz      EPILOG                                   // Done with loops, go to epilog

        // Clock EOL-3
        mov     iPositionASM, position
        fxch    st(3)                                    // Load PWR2 to st(0)
        faddp   st(5), st(0)                             // Add prevPwr + PWR2 to get newPwr2

        // Clock EOL-4
        mov     pfltPowerASM, pfltPower
        fldz
        fxch    st(5)                                    // Replace prevPwr with 0

        // Clock EOL-5
        fstp    dword ptr [pfltPowerASM + iPositionASM*SIZEOF_FLT] // Store newPwr2 in pfltPower[position]
        fldz                                             // Replace PWR2 with 0
        lea     pfltPowerASM, [pfltPowerASM + 3*SIZEOF_FLT] // Increment pfltPower

        // Clock EOL-6
        mov     pfltPower, pfltPowerASM                  // Write pfltPower back to local var
        mov     pfltCoefDen, rgfltCoefDen                // Restore inner loop var
        cmp     iOuterLoopsASM, 1                        // Check if this is the last time around

        // Clock EOL-7
        mov     fltSumSquared, 0                         // Clear the running sum
        mov     iOuterLoopsASM, -1                       // Prep for CMOV
        mov     iSliceLoopCtr, 0                         // Zero this without disturbing flags

        // Clock EOL-8
        fxch    st(3)                                    // Restore original FLOP stack order
        cmove   iSliceLoopCtr, iOuterLoopsASM            // If last time, do 1 less iteration

        // Clock EOL-9
        add     iSliceLoopCtr, c_iASMLoopsPerSlice
        mov     pfltDstHistory, rgfltDst                 // Restore inner loop var
        jmp     FLOPLOOP

        //-------------------------------------------------------------------
        // EPILOG: Finish off the last operation, ignore pipeline crap
        //-------------------------------------------------------------------

EPILOG:

        // Clock X
        mov     pfltDstHistory, rgfltDst                 // Restore inner loop var

        // Clock E-1: D4-1, A4, B4-1, PWR2, D4-2, prevPwr, C4, O3
        fmulp   st(4), st(0)                                    // Compute D4
        fxch    st(2)

        // Clock E-2: PWR2, B4-1, A4, D4, prevPwr, C4, O3
        faddp   st(4), st(0)                                    // Compute newPwr2
        fxch    st(5)

        // Clock E-3: O3, A4, D4, newPwr2, C4, B4-1
        fst     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrPREV, 0)] // Store O3 in proper slot
        fmul    st(5), st(0)                                    // Compute B4

        // Clock E-4: O3, A4, D4, newPwr2, C4, B4
        fst     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrPREV, ORDER)] // Store O3 in proper slot
        fxch    st(1)
        fsubrp  st(4), st(0)                                    // Compute A4-C4

        // Clock E-5: O3, D4, newPwr2, A4-C4, B4
        fmul    st(0), st(0)                                    // Compute PWR3
        fxch    st(1)

        // Clock E-6: D4, PWR3, newPwr2, A4-C4, B4
        fsubp   st(3), st(0)                                    // Compute A4-C4-D4
        fxch    st(3)

        // Clock E-7: B4, newPwr2, A4-C4-D4, PWR3
        fsubp   st(2), st(0)                                    // Compute A4-C4-D4-B4 = O4

        // Clock E-8: newPwr2, O4, PWR3
        faddp   st(2), st(0)                                    // Compute newPwr2+PWR3=newPwr3

        // Clock E-9: O4, newPwr3
        fst     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 0)] // Store O4 in proper slot

        // Clock E-10: O4, newPwr3
        fst     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, ORDER)] // Store O4 in proper slot
        fmul    st(0), st(0)                                    // Compute PWR4

        // Clock E-11: PWR4, newPwr3
        faddp   st(1), st(0)                                    // Compute newPwr3+PWR4=newPwr4

        // Clock E-12: newPwr4
        mov     iPositionASM, position
        mov     pfltPowerASM, pfltPower
        fst     dword ptr [pfltPowerASM + iPositionASM*SIZEOF_FLT] // Store newPwr4 to pfltPower[position]
        fstp    fltSumSquared                                   // Store newPwr4

        //-------------------------------------------------------------------
        // SHUT DOWN
        //-------------------------------------------------------------------

        // Save current dst
        mov     iDstCurr, iDstCurrASM

    } // asm

#undef ORDER

    *piDstCurr = iDstCurr;
} // FourTapDENOMINATOR_FLOP



void INLINE
FiveTapDENOMINATOR_FLOP
                      (const Float *rgfltCoefDen,
                       const int position, const Float fltInvNumScale,
                       float *rgfltDst, I32 *piDstCurr,
                       const Int iSliceIncr, Float *pfltPower,
                       const Int iSourceLength, const I32 *piFIROutAligned)
{
    int j;
    Float fltSumSquared = 0;

    // Translate
    const I32 *output = piFIROutAligned;

    FIVE_TAP_IIR_FLOAT_DENOMINATOR_VARIABLES
    FIVE_TAP_IIR_FLOAT_DENOMINATOR(fltInvNumScale, position)
}



void INLINE
SevenTapDENOMINATOR_FLOP
                       (const Float *rgfltCoefDen, const int position,
                        const Float fltInvNumScale,
                        float *rgfltDst, I32 *piDstCurr,
                        const Int iSliceIncr, Float *pfltPower,
                        const Int iSourceLength, const I32 *piFIROutAligned)
{
    const Int c_minus1Mod6[] = {5, 0, 1, 2, 3, 4};
    const int c_iSliceMask = iSliceIncr - 1;
    const int c_iASMLoopsPerSlice = iSliceIncr / 2;

    Int iDstCurr = *piDstCurr;
    Float fltSumSquared = 0;
    I32 iOuterLoops;

    // C setup for FLOP denominator
    assert(0 == iSliceIncr % 4); // ASM FLOP loop can only handle multiples of 4
    assert(0 == iSourceLength % iSliceIncr); // Won't do partial computations at the moment
    assert(iSourceLength >= iSliceIncr);
    iOuterLoops = iSourceLength / iSliceIncr;

#undef  ORDER
#define ORDER   6

#undef iPositionASM

#define cMinus1Mod6     eax
#define iPositionASM    eax
#define piFIROutput     ebx
#define iSliceLoopCtr   ecx
#define pfltPowerASM    ecx
#define pfltDstHistory  edx
#define iOuterLoopsASM  edx
#define iDstCurrASM     esi
#define pfltCoefDen     edi

// Need to do this because stupid assembler translates [edx+(esi+x)*4]
// to [edx+esi*4+x]. So this macro does the expansion manually.
#define HISTORYIDX(reg,offset)  ((reg)*SIZEOF_FLT + (offset)*SIZEOF_FLT)

#define SIZEOF_FLT      4

    // For ease of commenting, let
    //    A = fltInvNumScale * piFIROutAligned[j]
    //    B = rgfltCoefDen[1] * rgfltDst[iDstCurr + 0] = B1-1 * B1-2
    //    C = rgfltCoefDen[2] * rgfltDst[iDstCurr + 1] = C1-1 * C1-2
    //    D = rgfltCoefDen[3] * rgfltDst[iDstCurr + 2] = D1-1 * D1-2
    //    E = rgfltCoefDen[4] * rgfltDst[iDstCurr + 3] = E1-1 * E1-2
    //    F = rgfltCoefDen[5] * rgfltDst[iDstCurr + 4] = F1-1 * F1-2
    //    G = rgfltCoefDen[6] * rgfltDst[iDstCurr + 5] = G1-1 * G1-2
    _asm
    {
        //-------------------------------------------------------------------
        // SETUP
        //-------------------------------------------------------------------
        lea     cMinus1Mod6, c_minus1Mod6
        mov     piFIROutput, piFIROutAligned
        mov     iSliceLoopCtr, c_iASMLoopsPerSlice
        mov     pfltDstHistory, rgfltDst
        mov     iDstCurrASM, iDstCurr
        mov     pfltCoefDen, rgfltCoefDen

        //-------------------------------------------------------------------
        // PROLOG: Get us into steady-state so we can loop
        //-------------------------------------------------------------------

        // Initially I chose to do fxch in the D0 (decoder 0) slot. Later I realized
        // that fst(p) is a 2 micro-op instruction, and so I moved fxch to the D1/D2
        // slot of the previous clock so fst(p) could be placed in D0 slot to avoid
        // decode penalties (4-1-1 decode pattern). I only did this for the looping portion,
        // and left the prolog and epilog alone. Hence the change of style at clock 18.

        // Clock 0: stack empty
        fild    dword ptr [piFIROutput]                         // Load A1-1
        //nop
        //nop

        // Clock 1: A1-1
        fld     fltInvNumScale                                  // Load A1-2
        //nop
        //nop

        // Clock 2: A1-2, A1-1
        fld     dword ptr [pfltCoefDen + 2*SIZEOF_FLT]          // Load C1-1
        //nop
        //nop

        // Clock 3: C1-1, A1-2, A1-1
        fld     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 1)] // Load C1-2
        //nop
        //nop

        // Clock 4: C1-2, C1-1, A1-2, A1-1
        fxch    st(2)
        fmulp   st(3), st(0)                                    // Compute A1
        fld     dword ptr [pfltCoefDen + 3*SIZEOF_FLT]          // Load D1-1

        // Clock 5: D1-1, C1-1, C1-2, A1
        fld     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 2)] // Load D1-2
        //nop
        //nop

        // Clock 6: D1-2, D1-1, C1-1, C1-2, A1
        fxch    st(2)
        fmulp   st(3), st(0)                                    // Compute C1
        fld     dword ptr [pfltCoefDen + 4*SIZEOF_FLT]          // Load E1-1

        // Clock 7: E1-1, D1-1, D1-2, C1, A1
        fld     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 3)] // Load E1-2
        //nop
        //nop

        // Clock 8: E1-2, E1-1, D1-1, D1-2, C1, A1
        fxch    st(2)
        fmulp   st(3), st(0)                                    // Compute D1
        fld     dword ptr [pfltCoefDen + 1*SIZEOF_FLT]          // Load B1-1

        // Clock 9: B1-1, E1-1, E1-2, D1, C1, A1
        fld     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 0)] // Load B1-2
        //nop
        //nop

        // Clock 10: B1-2, B1-1, E1-1, E1-2, D1, C1, A1
        fxch    st(2)
        fmulp   st(3), st(0)                                    // Compute E1
        //nop

        // Clock 11: B1-1, B1-2, E1, D1, C1, A1
        fxch    st(4)
        fsubp   st(5), st(0)                                    // Compute A1-C1
        fldz                                                    // Load PWR0 (=0)

        // Clock 12: PWR0(=0), B1-2, E1, D1, B1-1, A1-C1
        fxch    st(1)
        fmulp   st(4), st(0)                                    // Compute B1
        fld     dword ptr [pfltCoefDen + 5*SIZEOF_FLT]          // Load F1-1

        // Clock 13: F1-1, PWR0, E1, D1, B1, A1-C1
        fld     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 4)] // Load F1-2
        //nop
        //nop

        // Clock 14: F1-2, F1-1, PWR0, E1, D1, B1, A1-C1
        fld     dword ptr [pfltCoefDen + 6*SIZEOF_FLT]          // Load G1-1
        add     piFIROutput, SIZEOF_I32                         // Increment piFIROutput
        //nop

        // Clock 15: G1-1, F1-2, F1-1, PWR0, E1, D1, B1, A1-C1
        fxch    st(5)
        fsubp   st(7), st(0)                                    // Compute A1-C1-D1
        fld     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 5)] // Load G1-2

        // Clock 16: G1-2, F1-2, F1-1, PWR0, E1, G1-1, B1, A1-C1-D1
        fxch    st(1)
        fmulp   st(2), st(0)                                    // Compute F1
        fld     fltSumSquared                                   // Load prevPwr

        // Clock 17: prevPwr, G1-2, F1, PWR0, E1, G1-1, B1, A1-C1-D1
        mov     iDstCurrASM, dword ptr [cMinus1Mod6 + iDstCurrASM*SIZEOF_I32] // Load next history slot
        fxch    st(4)                                           // Move fxch from D0 to D1/D2 slot
        //nop

        //-------------------------------------------------------------------
        // STEADY-STATE: Loop like the wind
        //-------------------------------------------------------------------

        // The FLOP stacks of clocks 53 and 18 MUST MATCH in order to to loop around
        // Comments marked as "StackOrder" indicate that a particular choice was made
        // in order to satisfy this requirement

FLOPLOOP:
        // Clock 18: E1, G1-2, F1, PWR0, prevPwr, G1-1, B1, A1-C1-D1
        faddp   st(6), st(0)                                    // Compute E1+B1
        fild    dword ptr [piFIROutput]                         // Load A2-1
        fxch    st(1)

        // Clock 19: G1-2, A2-1, F1, PWR0, prevPwr, G1-1, E1+B1, A1-C1-D1
        fmulp   st(5), st(0)                                    // Compute G1
        fld     fltInvNumScale                                  // Load A2-2
        fxch    st(3)

        // Clock 20: PWR0, A2-1, F1, A2-2, prevPwr, G1, E1+B1, A1-C1-D1
        faddp   st(4), st(0)                                    // Compute newPwr0 = PWR0+prevPwr
        fld     dword ptr [pfltCoefDen + 2*SIZEOF_FLT]          // Load C2-1
        fxch    st(6)

        // Clock 21: E1+B1, A2-1, F1, A2-2, newPwr0, G1, C2-1, A1-C1-D1
        fsubp   st(7), st(0)                                    // Compute A1-C1-D1-(E1+B1)
        fld     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 1)] // Load C2-2
        fxch    st(1)

        // Clock 22: A2-1, C2-2, F1, A2-2, newPwr0, G1, C2-1, A1-C1-D1-(E1+B1)
        fmulp   st(3), st(0)                                    // Compute A2
        fld     dword ptr [pfltCoefDen + 3*SIZEOF_FLT]          // Load D2-1
        fxch    st(4)

        // Clock 23: newPwr0, C2-2, F1, A2, D2-1, G1, C2-1, A1-C1-D1-(E1+B1)
        fstp    fltSumSquared                                   // Store newPwr0
        fld     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 2)] // Load D2-2
        fxch    st(1)

        // Clock 24: C2-2, D2-2, F1, A2, D2-1, G1, C2-1, A1-C1-D1-(E1+B1)
        fmulp   st(6), st(0)                                    // Compute C2
        fld     dword ptr [pfltCoefDen + 4*SIZEOF_FLT]          // Load E2-1
        fxch    st(2)

        // Clock 25: F1, D2-2, E2-1, A2, D2-1, G1, C2, A1-C1-D1-(E1+B1)
        faddp   st(5), st(0)                                    // Compute F1+G1
        fld     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 3)] // Load E2-2
        fxch    st(1)

        // Clock 26: D2-2, E2-2, E2-1, A2, D2-1, F1+G1, C2, A1-C1-D1-(E1+B1)
        fmulp   st(4), st(0)                                    // Compute D2
        fld     dword ptr [pfltCoefDen + 5*SIZEOF_FLT]          // Load F2-1
        //nop

        // Clock 27: F2-1, E2-2, E2-1, A2, D2, F1+G1, C2, A1-C1-D1-(E1+B1)
        add     piFIROutput, SIZEOF_I32                         // Increment piFIROutput
        fxch    st(1)
        //nop

        // Clock 28: E2-2, F2-1, E2-1, A2, D2, F1+G1, C2, A1-C1-D1-(E1+B1)
        fmulp   st(2), st(0)                                    // Compute E2
        fld     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 4)] // Load F2-2
        fxch    st(5)

        // Clock 29: F1+G1, F2-1, E2, A2, D2, F2-2, C2, A1-C1-D1-(E1+B1)
        fsubp   st(7), st(0)                                    // Compute O1 = A1-C1-D1-(E1+B1)-(F1+G1)
        fld     dword ptr [pfltCoefDen + 1*SIZEOF_FLT]          // Load B2-1
        fxch    st(3)                                           // StackOrder: B3 in st(6)

        // Clock 30: A2, F2-1, E2, B2-1, D2, F2-2, C2, O1
        fsubrp  st(6), st(0)                                    // Compute A2-C2
        fld     dword ptr [pfltCoefDen + 6*SIZEOF_FLT]          // Load G2-1
        fxch    st(1)

        // Clock 31: F2-1, G2-1, E2, B2-1, D2, F2-2, A2-C2, O1
        fmulp   st(5), st(0)                                    // Compute F2
        fld     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 5)] // Load G2-2
        fxch    st(7)

        // Clock 32: O1, G2-1, E2, B2-1, D2, F2, A2-C2, G2-2
        fst     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 0)] // Store O1 in proper slot
        //nop
        //nop

        // Clock 33: O1, G2-1, E2, B2-1, D2, F2, A2-C2, G2-2
        fst     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, ORDER)] // Store O1 in proper slot (aliased)
        fmul    st(3), st(0)                                    // Compute B2
        fxch    st(2)                                           // StackOrder: E3 in st(0)

        // Clock 34: E2, G2-1, O1, B2, D2, F2, A2-C2, G2-2
        faddp   st(4), st(0)                                    // Compute D2+E2
        fild    dword ptr [piFIROutput]                         // Load A3-1
        fxch    st(2)

        // Clock 35: O1, G2-1, A3-1, B2, D2+E2, F2, A2-C2, G2-2
        fmul    st(0), st(0)                                    // Compute PWR1=O1^2
        mov     iDstCurrASM, dword ptr [cMinus1Mod6 + iDstCurrASM*SIZEOF_I32] // Load next history slot
        fxch    st(5)                                           // StackOrder: B3 in st(6)

        // Clock 36: F2, G2-1, A3-1, B2, D2+E2, PWR1, A2-C2, G2-2
        fsubp   st(6), st(0)                                    // Compute A2-C2-F2
        fld     fltInvNumScale                                  // Load A3-2
        fxch    st(7)                                           // StackOrder: A3-C3-D3 in st(7)

        // Clock 37: G2-2, G2-1, A3-1, B2, D2+E2, PWR1, A2-C2-F2, A3-2
        fmulp   st(1), st(0)                                    // Compute G2
        fld     fltSumSquared                                   // Load prevPwr
        fxch    st(4)                                           // StackOrder: E3 in st(0) via prevPwr in st(4)

        // Clock 38: D2+E2, G2, A3-1, B2, prevPwr, PWR1, A2-C2-F2, A3-2
        faddp   st(3), st(0)                                    // Compute D2+E2+B2
        fld     dword ptr [pfltCoefDen + 2*SIZEOF_FLT]          // Load C3-1
        fxch    st(2)                                           // StackOrder: A3-C3-D3 in st(7)

        // Clock 39: A3-1, G2, C3-1, D2+E2+B2, prevPwr, PWR1, A2-C2-F2, A3-2
        fmulp   st(7), st(0)                                    // Compute A3
        fld     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 1)] // Load C3-2
        fxch    st(5)                                           // StackOrder: E3 in st(0) via prevPwr in st(4)

        // Clock 40: PWR1, G2, C3-1, D2+E2+B2, prevPwr, C3-2, A2-C2-F2, A3
        faddp   st(4), st(0)                                    // Compute newPwr1 = PWR1+prevPwr
        fld     dword ptr [pfltCoefDen + 3*SIZEOF_FLT]          // Load D3-1
        fxch    st(3)                                           // StackOrder: B3 in st(6)

        // Clock 41: D2+E2+B2, G2, C3-1, D3-1, newPwr1, C3-2, A2-C2-F2, A3
        fsubp   st(6), st(0)                                    // Compute A2-C2-F2-(D2+E2+B2)
        fld     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 2)] // Load D3-2
        fxch    st(5)                                           // StackOrder: F3 in st(2)

        // Clock 42: C3-2, G2, C3-1, D3-1, newPwr1, D3-2, A2-C2-F2-(D2+E2+B2), A3
        fmulp   st(2), st(0)                                    // Compute C3
        fld     dword ptr [pfltCoefDen + 4*SIZEOF_FLT]          // Load E3-1
        fxch    st(4)

        // Clock 43: newPwr1, G2, C3, D3-1, E3-1, D3-2, A2-C2-F2-(D2+E2+B2), A3
        fstp    fltSumSquared                                   // Store newPwr1
        fld     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 3)] // Load E3-2
        fxch    st(5)                                           // StackOrder: PWR2 in st(3)

        // Clock 44: D3-2, G2, C3, D3-1, E3-1, E3-2, A2-C2-F2-(D2+E2+B2), A3
        fmulp   st(3), st(0)                                    // Compute D3
        fld     dword ptr [pfltCoefDen + 1*SIZEOF_FLT]          // Load B3-1
        fxch    st(6)                                           // StackOrder: B3 in st(6)

        // Clock 45: A2-C2-F2-(D2+E2+B2), G2, C3, D3, E3-1, E3-2, B3-1, A3
        fsubrp  st(1), st(0)                                    // Compute O2 = A2-C2-F2-(D2+E2+B2)-G2
        fld     dword ptr [pfltCoefDen + 5*SIZEOF_FLT]          // Load F3-1
        fxch    st(5)                                           // StackOrder: E3 in st(0) via prevPwr in st(4)

        // Clock 46: E3-2, O2, C3, D3, E3-1, F3-1, B3-1, A3
        fmulp   st(4), st(0)                                    // Compute E3
        fld     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 4)] // Load F3-2
        fxch    st(2)                                           // StackOrder: A3-C3-D3 in st(7)

        // Clock 47: C3, O2, F3-2, D3, E3, F3-1, B3-1, A3
        fsubp   st(7), st(0)                                    // Compute A3-C3
        fld     dword ptr [pfltCoefDen + 6*SIZEOF_FLT]          // Load G3-1
        fxch    st(1)

        // Clock 48: O2, G3-1, F3-2, D3, E3, F3-1, B3-1, A3-C3
        fst     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 0)] // Store O2 in proper slot
        fmul    st(6), st(0)                                    // Compute B3
        //nop

        // Clock 49: O2, G3-1, F3-2, D3, E3, F3-1, B3, A3-C3
        fst     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, ORDER)] // Store O2 in proper slot (aliased)
        add     piFIROutput, SIZEOF_I32                         // Increment piFIROutput
        //nop

        // Clock 50: O2, G3-1, F3-2, D3, E3, F3-1, B3, A3-C3
        fmul    st(0), st(0)                                    // Compute PWR2 = O2^2
        fxch    st(3)                                           // StackOrder: PWR2 in st(3), A3-C3-D3 in st(7)
        dec     iSliceLoopCtr                                   // Decrement loop counter: 2 outputs completed/iteration (3rd output started)

        // Clock 51: D3, G3-1, F3-2, PWR2, E3, F3-1, B3, A3-C3
        fsubp   st(7), st(0)                                    // Compute A3-C3-D3
        fld     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 5)] // Load G3-2
        fxch    st(5)                                           // StackOrder: F3 in st(2)

        // Clock 52: F3-1, G3-1, F3-2, PWR2, E3, G3-2, B3, A3-C3-D3
        fmulp   st(2), st(0)                                    // Compute F3
        fld     fltSumSquared                                   // Load prevPwr
        fxch    st(4)                                           // StackOrder: E3 in st(0)

        // Clock 53:     E3, G3-1, F3, PWR2, prevPwr, G3-2, B3, A3-C3-D3
        // vs. Clock 18: E1, G1-2, F1, PWR0, prevPwr, G1-1, B1, A1-C1-D1
        // The FLOP stacks of clocks 53 and 18 MUST MATCH in order to to loop around
        // NB: the reversal of G3-1, G3-2 vs. G1-2, G1-1 have no ill effect (whew!)

        //-------------------------------------------------------------------
        // END OF LOOP: Do some housekeeping, don't worry about pipeline scheduling
        //-------------------------------------------------------------------

        // Clock EOL-1 (use different numbering scheme for end-of-loop)
        mov     iDstCurrASM, dword ptr [cMinus1Mod6 + iDstCurrASM*SIZEOF_I32] // Load next history slot
        jnz     FLOPLOOP

        // If we've reached this point, we've outputed iSliceIncr number of samples
        // prevPwr + PWR2 is the value we wish to write to pfltPower[position]
        // After doing this, be sure to set PWR2 = 0 and prevPwr = 0 on FLOP stack
        // Calculate power, write it out, and clear the running sum (fltSumSquared)
        mov     iOuterLoopsASM, iOuterLoops              // Check for outer loop termination

        // Clock EOL-2:
        dec     iOuterLoopsASM
        mov     iOuterLoops, iOuterLoopsASM              // Write iOuterLoops back to local var
        jz      EPILOG                                   // Done with loops, go to epilog

        // Clock EOL-3
        mov     iPositionASM, position
        fxch    st(4)                                    // Load prevPwr to st(0)
        faddp   st(3), st(0)                             // Add prevPwr + PWR2 to get newPwr2

        // Clock EOL-4
        mov     pfltPowerASM, pfltPower
        fldz
        fxch    st(3)                                    // Replace PWR2 with 0        

        // Clock EOL-5
        fstp    dword ptr [pfltPowerASM + iPositionASM*SIZEOF_FLT] // Store newPwr2 in pfltPower[position]
        fldz                                             // Replace prevPwr with 0
        lea     pfltPowerASM, [pfltPowerASM + 3*SIZEOF_FLT] // Increment pfltPower

        // Clock EOL-6
        mov     pfltPower, pfltPowerASM                  // Write pfltPower back to local var
        lea     cMinus1Mod6, c_minus1Mod6                // Restore inner loop var
        cmp     iOuterLoopsASM, 1                        // Check if this is the last time around

        // Clock EOL-7
        mov     fltSumSquared, 0                         // Clear the running sum
        mov     iOuterLoopsASM, -1                       // Prep for CMOV
        mov     iSliceLoopCtr, 0                         // Zero this without disturbing flags

        // Clock EOL-8
        fxch    st(4)                                    // Restore original FLOP stack order
        cmove   iSliceLoopCtr, iOuterLoopsASM            // If last time, do 1 less iteration
        //nop

        // Clock EOL-9
        add     iSliceLoopCtr, c_iASMLoopsPerSlice
        mov     pfltDstHistory, rgfltDst                 // Restore inner loop var
        jmp     FLOPLOOP

        //-------------------------------------------------------------------
        // EPILOG: Finish off the last operation
        //-------------------------------------------------------------------

EPILOG:
        // Clock X
        mov     pfltDstHistory, rgfltDst                 // Restore inner loop var
        //nop
        //nop

        // Clock 53: E3, G3-1, F3, PWR2, prevPwr, G3-2, B3, A3-C3-D3
        faddp   st(6), st(0)                                    // Compute E3+B3
        fild    dword ptr [piFIROutput]                         // Load A4-1
        //nop

        // Clock 54: A4-1, G3-2, F3, PWR2, prevPwr, G3-1, E3+B3, A3-C3-D3
        fxch    st(1)
        fmulp   st(5), st(0)                                    // Compute G3
        fld     fltInvNumScale                                  // Load A4-2

        // Clock 55: A4-2, A4-1, F3, PWR2, prevPwr, G3, E3+B3, A3-C3-D3
        fxch    st(3)
        faddp   st(4), st(0)                                    // Compute newPwr2 = PWR2+prevPwr
        fld     dword ptr [pfltCoefDen + 2*SIZEOF_FLT]          // Load C4-1

        // Clock 56: C4-1, A4-1, F3, A4-2, newPwr2, G3, E3+B3, A3-C3-D3
        fxch    st(6)
        fsubp   st(7), st(0)                                    // Compute A3-C3-D3-(E3+B3)
        fld     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 1)] // Load C4-2

        // Clock 57: C4-2, A4-1, F3, A4-2, newPwr2, G3, C4-1, A3-C3-D3-(E3+B3)
        fxch    st(1)
        fmulp   st(3), st(0)                                    // Compute A4
        fld     dword ptr [pfltCoefDen + 3*SIZEOF_FLT]          // Load D4-1

        // Clock 58: D4-1, C4-2, F3, A4, newPwr2, G3, C4-1, A3-C3-D3-(E3+B3)
        fxch    st(4)

        // This will take another clock cycle. It's not worth it to fix this.
        fstp    fltSumSquared                                   // Store newPwr2
        fld     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 2)] // Load D4-2

        // Clock 59: D4-2, C4-2, F3, A4, D4-1, G3, C4-1, A3-C3-D3-(E3+B3)
        fxch    st(1)
        fmulp   st(6), st(0)                                    // Compute C4
        fld     dword ptr [pfltCoefDen + 4*SIZEOF_FLT]          // Load E4-1

        // Clock 60: E4-1, D4-2, F3, A4, D4-1, G3, C4, A3-C3-D3-(E3+B3)
        fxch    st(2)
        faddp   st(5), st(0)                                    // Compute F3+G3
        fld     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 3)] // Load E4-2

        // Clock 61: E4-2, D4-2, E4-1, A4, D4-1, F3+G3, C4, A3-C3-D3-(E3+B3)
        fxch    st(1)
        fmulp   st(4), st(0)                                    // Compute D4
        fld     dword ptr [pfltCoefDen + 5*SIZEOF_FLT]          // Load F4-1

        // Clock 62: F4-1, E4-2, E4-1, A4, D4, F3+G3, C4, A3-C3-D3-(E3+B3)
        //nop
        //nop
        //nop

        // Clock 63: F4-1, E4-2, E4-1, A4, D4, F3+G3, C4, A3-C3-D3-(E3+B3)
        fxch    st(1)
        fmulp   st(2), st(0)                                    // Compute E4
        fld     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 4)] // Load F4-2

        // Clock 64: F4-2, F4-1, E4, A4, D4, F3+G3, C4, A3-C3-D3-(E3+B3)
        fxch    st(5)
        fsubp   st(7), st(0)                                    // Compute O3 = A3-C3-D3-(E3+B3)-(F3+G3)
        fld     dword ptr [pfltCoefDen + 1*SIZEOF_FLT]          // Load B4-1

        // Clock 65: B4-1, F4-1, E4, A4, D4, F4-2, C4, O3
        fxch    st(6)
        fsubp   st(3), st(0)                                    // Compute A4-C4
        fld     dword ptr [pfltCoefDen + 6*SIZEOF_FLT]          // Load G4-1

        // Clock 66: G4-1, F4-1, E4, A4-C4, D4, F4-2, B4-1, O3
        fxch    st(1)
        fmulp   st(5), st(0)                                    // Compute F4
        fld     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 5)] // Load G4-2

        // Clock 67: G4-2, G4-1, E4, A4-C4, D4, F4, B4-1, O3
        fxch    st(7)

        // This will take another clock cycle. It's not worth it to fix this.
        fst     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 0)] // Store O3 in proper slot
        //nop

        // Clock 68: O3, G4-1, E4, A4-C4, D4, F4, B4-1, G4-2
        fmul    st(6), st(0)                                    // Compute B4

        // This will take another clock cycle. It's not worth it to fix this.
        fst     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, ORDER)] // Store O3 in proper slot (aliased)
        
        // At this point, ignore pipelining and dump the remaining instructions
        fmul    st(0), st(0)                                    // Compute PWR3

        // Stack: PWR3, G4-1, E4, A4-C4, D4, F4, B4, G4-2
        fxch    st(2)
        faddp   st(4), st(0)                                    // Compute D4+E4

        // Stack: G4-1, PWR3, A4-C4, D4+E4, F4, B4, G4-2
        fxch    st(4)
        fsubp   st(2), st(0)                                    // Compute A4-C4-F4

        // Stack: PWR3, A4-C4-F4, D4+E4, G4-1, B4, G4-2
        fld     fltSumSquared                                   // Load prevPwr

        // Stack: prevPwr, PWR3, A4-C4-F4, D4+E4, G4-1, B4, G4-2
        fxch    st(4)
        fmulp   st(6), st(0)                                    // Compute G4

        // Stack: PWR3, A4-C4-F4, D4+E4, prevPwr, B4, G4
        fxch    st(4)
        faddp   st(2), st(0)                                    // Compute D4+E4+B4

        // Stack: A4-C4-F4, D4+E4+B4, prevPwr, PWR3, G4
        fxch    st(2)
        faddp   st(3), st(0)                                    // Compute newPwr3 = PWR3+prevPwr

        // Stack: D4+E4+B4, A4-C4-F4, newPwr3, G4
        fsubp   st(1), st(0)                                    // Compute A4-C4-F4-(D4+E4+B4)

        // Stack: A4-C4-F4-(D4+E4+B4), newPwr3, G4
        fxch    st(1)
        fstp    fltSumSquared                                   // Store newPwr3

        // Stack: A4-C4-F4-(D4+E4+B4), G4
        fsubrp  st(1), st(0)                                    // Compute O4 = A4-C4-F4-(D4+E4+B4)-G4
        mov     iDstCurrASM, dword ptr [cMinus1Mod6 + iDstCurrASM*SIZEOF_I32] // Load next history slot

        // Stack: O4
        fst     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, 0)]; // Store O4 in proper slot
        fst     dword ptr [pfltDstHistory + HISTORYIDX(iDstCurrASM, ORDER)]; // Store O4 in proper slot (aliased)
        fmul    st(0), st(0)                                    // Compute PWR4 = O4^2

        // Stack: PWR4
        fld     fltSumSquared                                   // Load prevPwr

        // Stack: prevPwr, PWR4
        faddp   st(1), st(0)                                    // Compute newPwr4 = PWR4+prevPwr

        // Stack: newPwr4
        mov     iPositionASM, position
        mov     pfltPowerASM, pfltPower
        fst     dword ptr [pfltPowerASM + iPositionASM*SIZEOF_FLT] // Store newPwr4 to pfltPower[position]
        fstp    fltSumSquared                                   // Store newPwr4

        //-------------------------------------------------------------------
        // SHUT DOWN
        //-------------------------------------------------------------------

        // Save current dst
        mov     iDstCurr, iDstCurrASM
    }

#undef ORDER

    *piDstCurr = iDstCurr;
} // SevenTapDENOMINATOR_FLOP




//***************************************************************************
// FILTER WRAPPER FUNCTIONS
// These functions provide aligned memory for the MMX filters to operate with.
//***************************************************************************

Void INLINE FourFiveFourSTEREO(const Int cCoefLow, const Int cCoefMed, const Int cCoefHi,
                               FLOATORU32* pfltPower, const I16 *piSource,
                               const Int iSourceLength, const Int iSliceWidth,
                               const Int iSliceIncr,
                               const I16 cChannel, I16 *piTransientSrcLow,
                               Int *piTransientSrcLowCurr, FLOATORI32 *pfltTransientDstLow,
                               Int *piTransientDstLowCurr,
                               I16 *piTransientSrcMed,Int *piTransientSrcMedCurr,
                               FLOATORI32 *pfltTransientDstMed, Int *piTransientDstMedCurr,
                               I16 *piTransientSrcHi, Int *piTransientSrcHiCurr,
                               FLOATORI32 *pfltTransientDstHi, Int *piTransientDstHiCurr,
                               const I16 *rgiCoefNumLow, const Float fltInvScaleNumLow,
                               const Float *rgfltCoefDenLow,
                               const I16 *rgiCoefNumMed, const Float fltInvScaleNumMed,
                               const Float *rgfltCoefDenMed,
                               const I16 *rgiCoefNumHi, const Float fltInvScaleNumHi,
                               const Float *rgfltCoefDenHi)
{
    // Get us some local 32-byte aligned arrays
    const int c_iAlignMultiple = 32; // Used to compute mask: must be pure pwr of 2 like 16 or 32
    I32     rgiFIROut[4096+16]; // +16 == +(32/sizeof(I16)), for 32-byte alignment
    I16     rgiMMXCoefs[32+16]; // +16 == +(32/sizeof(I16)), for 32-byte alignment

    I32    *piFIROutAligned = (I32 *)(((U32)rgiFIROut + c_iAlignMultiple - 1) &
        ~(c_iAlignMultiple - 1));
    I16    *piMMXCoefs = (I16 *)(((U32)rgiMMXCoefs + c_iAlignMultiple - 1) &
        ~(c_iAlignMultiple - 1));
    const I32 iSizeOfMMXCoefs = (U32)rgiMMXCoefs + sizeof(rgiMMXCoefs) -
        (U32)piMMXCoefs;

#ifdef MMXVERIFY_ENABLE
#define MMXVERIFY(a)    (a)
#else   // MMXVERIFY
#define MMXVERIFY(a)
#endif  // MMXVERIFY

    // LOW Filter
    FourTapNUMERATOR_MMX_STEREO(rgiCoefNumLow, piSource, piTransientSrcLow,
        piTransientSrcLowCurr, iSourceLength, piFIROutAligned,
        c_iAlignMultiple, piMMXCoefs, iSizeOfMMXCoefs);
    MMXVERIFY(FourTapNUMERATOR_MMX_VERIFY(rgiCoefNumLow, piSource,
        piTransientSrcLow + 6, (I32 *)(piTransientSrcLow + 4),
        cChannel, iSourceLength, piFIROutAligned,
        c_iAlignMultiple, piMMXCoefs, iSizeOfMMXCoefs));
    FourTapDENOMINATOR_FLOP(rgfltCoefDenLow, 0, fltInvScaleNumLow, pfltTransientDstLow,
        piTransientDstLowCurr, iSliceIncr, pfltPower, iSourceLength, piFIROutAligned);
    MMXVERIFY(FourTapDENOMINATOR_FLOP_VERIFY(rgfltCoefDenLow, 0, fltInvScaleNumLow,
        pfltTransientDstLow + 9, (I32 *)(pfltTransientDstLow + 8),
        iSliceIncr, pfltPower,
        iSourceLength, piFIROutAligned));


    // MED Filter
    FiveTapNUMERATOR_MMX_STEREO(rgiCoefNumMed, piSource, piTransientSrcMed,
        piTransientSrcMedCurr, iSourceLength, piFIROutAligned,
        c_iAlignMultiple, piMMXCoefs, iSizeOfMMXCoefs);
    MMXVERIFY(FiveTapNUMERATOR_MMX_VERIFY(rgiCoefNumMed, piSource,
        piTransientSrcMed + 10, (I32 *)(piTransientSrcMed + 8),
        cChannel, iSourceLength, piFIROutAligned,
        c_iAlignMultiple, piMMXCoefs, iSizeOfMMXCoefs));
    FiveTapDENOMINATOR_FLOP(rgfltCoefDenMed, 1, fltInvScaleNumMed, pfltTransientDstMed,
        piTransientDstMedCurr, iSliceIncr, pfltPower, iSourceLength, piFIROutAligned);
    MMXVERIFY(FiveTapDENOMINATOR_FLOP_VERIFY(rgfltCoefDenMed, 1, fltInvScaleNumMed,
        pfltTransientDstMed + 15, (I32 *)(pfltTransientDstMed + 14),
        iSliceIncr, pfltPower, iSourceLength,
        piFIROutAligned));


    // HIGH Filter
    FourTapNUMERATOR_MMX_STEREO(rgiCoefNumHi, piSource, piTransientSrcHi,
        piTransientSrcHiCurr, iSourceLength, piFIROutAligned,
        c_iAlignMultiple, piMMXCoefs, iSizeOfMMXCoefs);
    MMXVERIFY(FourTapNUMERATOR_MMX_VERIFY(rgiCoefNumHi, piSource,
        piTransientSrcHi + 6, (I32 *)(piTransientSrcHi + 4),
        cChannel, iSourceLength, piFIROutAligned,
        c_iAlignMultiple, piMMXCoefs, iSizeOfMMXCoefs));
    FourTapDENOMINATOR_FLOP(rgfltCoefDenHi, 2, fltInvScaleNumHi, pfltTransientDstHi,
        piTransientDstHiCurr, iSliceIncr, pfltPower, iSourceLength, piFIROutAligned);
    MMXVERIFY(FourTapDENOMINATOR_FLOP_VERIFY(rgfltCoefDenHi, 2, fltInvScaleNumHi,
        pfltTransientDstHi + 9, (I32 *)(pfltTransientDstHi + 8),
        iSliceIncr, pfltPower, iSourceLength, piFIROutAligned));
} // FourFiveFourSTEREO



#ifdef MMXMONO
Void INLINE FourFiveFourMONO(const Int cCoefLow, const Int cCoefMed, const Int cCoefHi,
                             FLOATORU32* pfltPower, const I16 *piSource,
                             const Int iSourceLength, const Int iSliceWidth,
                             const Int iSliceIncr,
                             const I16 cChannel, I16 *piTransientSrcLow,
                             Int *piTransientSrcLowCurr, FLOATORI32 *pfltTransientDstLow,
                             Int *piTransientDstLowCurr,
                             I16 *piTransientSrcMed,Int *piTransientSrcMedCurr,
                             FLOATORI32 *pfltTransientDstMed, Int *piTransientDstMedCurr,
                             I16 *piTransientSrcHi, Int *piTransientSrcHiCurr,
                             FLOATORI32 *pfltTransientDstHi, Int *piTransientDstHiCurr,
                             const I16 *rgiCoefNumLow, const Float fltInvScaleNumLow,
                             const Float *rgfltCoefDenLow,
                             const I16 *rgiCoefNumMed, const Float fltInvScaleNumMed,
                             const Float *rgfltCoefDenMed,
                             const I16 *rgiCoefNumHi, const Float fltInvScaleNumHi,
                             const Float *rgfltCoefDenHi)
{
    // Get us some local 32-byte aligned arrays
    const int c_iAlignMultiple = 32; // Used to compute mask: must be pure pwr of 2 like 16 or 32
    I32     rgiFIROut[4096+16]; // +16 == +(32/sizeof(I16)), for 32-byte alignment
    I16     rgiMMXCoefs[32+16]; // +16 == +(32/sizeof(I16)), for 32-byte alignment

    I32    *piFIROutAligned = (I32 *)(((U32)rgiFIROut + c_iAlignMultiple - 1) &
        ~(c_iAlignMultiple - 1));
    I16    *piMMXCoefs = (I16 *)(((U32)rgiMMXCoefs + c_iAlignMultiple - 1) &
        ~(c_iAlignMultiple - 1));
    const I32 iSizeOfMMXCoefs = (U32)rgiMMXCoefs + sizeof(rgiMMXCoefs) -
        (U32)piMMXCoefs;

#ifdef MMXVERIFY_ENABLE
#define MMXVERIFY(a)    (a)
    static I16 rgiSrcLowVERIFY[8] = {0};
    static Float rgfltDstLowVERIFY[8] = {0};
    static I32 iSrcLowCurrVERIFY = 0;
    static I32 iDstLowCurrVERIFY = 0;

    static I16 rgiSrcMedVERIFY[10] = {0};
    static Float rgfltDstMedVERIFY[10] = {0};
    static I32 iSrcMedCurrVERIFY = 0;
    static I32 iDstMedCurrVERIFY = 0;

    static I16 rgiSrcHiVERIFY[8] = {0};
    static Float rgfltDstHiVERIFY[8] = {0};
    static I32 iSrcHiCurrVERIFY = 0;
    static I32 iDstHiCurrVERIFY = 0;
#else   // MMXVERIFY
#define MMXVERIFY(a)
#endif  // MMXVERIFY

    // LOW Filter
    FourTapNUMERATOR_MMX_MONO(rgiCoefNumLow, piSource, piTransientSrcLow,
        piTransientSrcLowCurr, iSourceLength, piFIROutAligned,
        c_iAlignMultiple, piMMXCoefs, iSizeOfMMXCoefs);
    MMXVERIFY(FourTapNUMERATOR_MMX_VERIFY(rgiCoefNumLow, piSource,
        rgiSrcLowVERIFY, &iSrcLowCurrVERIFY, cChannel, iSourceLength, piFIROutAligned,
        c_iAlignMultiple, piMMXCoefs, iSizeOfMMXCoefs));
    FourTapDENOMINATOR_FLOP(rgfltCoefDenLow, 0, fltInvScaleNumLow, pfltTransientDstLow,
        piTransientDstLowCurr, iSliceIncr, pfltPower, iSourceLength, piFIROutAligned);
    MMXVERIFY(FourTapDENOMINATOR_FLOP_VERIFY(rgfltCoefDenLow, 0, fltInvScaleNumLow,
        rgfltDstLowVERIFY, &iDstLowCurrVERIFY, iSliceIncr, pfltPower,
        iSourceLength, piFIROutAligned));


    // MED Filter
    FiveTapNUMERATOR_MMX_MONO(rgiCoefNumMed, piSource, piTransientSrcMed,
        piTransientSrcMedCurr, iSourceLength, piFIROutAligned,
        c_iAlignMultiple, piMMXCoefs, iSizeOfMMXCoefs);
    MMXVERIFY(FiveTapNUMERATOR_MMX_VERIFY(rgiCoefNumMed, piSource,
        rgiSrcMedVERIFY, &iSrcMedCurrVERIFY, cChannel, iSourceLength, piFIROutAligned,
        c_iAlignMultiple, piMMXCoefs, iSizeOfMMXCoefs));
    FiveTapDENOMINATOR_FLOP(rgfltCoefDenMed, 1, fltInvScaleNumMed, pfltTransientDstMed,
        piTransientDstMedCurr, iSliceIncr, pfltPower, iSourceLength, piFIROutAligned);
    MMXVERIFY(FiveTapDENOMINATOR_FLOP_VERIFY(rgfltCoefDenMed, 1, fltInvScaleNumMed,
        rgfltDstMedVERIFY, &iDstMedCurrVERIFY, iSliceIncr, pfltPower, iSourceLength,
        piFIROutAligned));


    // HIGH Filter
    FourTapNUMERATOR_MMX_MONO(rgiCoefNumHi, piSource, piTransientSrcHi,
        piTransientSrcHiCurr, iSourceLength, piFIROutAligned,
        c_iAlignMultiple, piMMXCoefs, iSizeOfMMXCoefs);
    MMXVERIFY(FourTapNUMERATOR_MMX_VERIFY(rgiCoefNumHi, piSource,
        rgiSrcHiVERIFY, &iSrcHiCurrVERIFY, cChannel, iSourceLength, piFIROutAligned,
        c_iAlignMultiple, piMMXCoefs, iSizeOfMMXCoefs));
    FourTapDENOMINATOR_FLOP(rgfltCoefDenHi, 2, fltInvScaleNumHi, pfltTransientDstHi,
        piTransientDstHiCurr, iSliceIncr, pfltPower, iSourceLength, piFIROutAligned);
    MMXVERIFY(FourTapDENOMINATOR_FLOP_VERIFY(rgfltCoefDenHi, 2, fltInvScaleNumHi,
        rgfltDstHiVERIFY, &iDstHiCurrVERIFY, iSliceIncr, pfltPower, iSourceLength,
        piFIROutAligned));
} // FourFiveFourMONO
#endif  // MMXMONO



//***************************************************************************
// MONO ENCODE FILTER WRAPPERS
// These functions basically provide coefficients, and not much else.
// As noted above, MMX mono is no faster than C code, so these are likely to
// die sometime soon.
//***************************************************************************

#ifdef MMXMONO
Void g_GetLowMedHiPower_48MONO_MMX(GET_LOW_MED_HI_ARGS)
{
    FOURTAP_FILTER_COEFS(Low, Num, 4.1942460e-003F, -4.1410504e-003F,
        -4.1410504e-003F, 4.1942460e-003F, 3931353.900655440967641966055168);
    const Float rgfltCoefDenLow [] = {1.0000000e+000F,-2.9414462e+000F,
        2.8870889e+000F,-9.4553636e-001F};

    FIVETAP_FILTER_COEFS(Med, Num, 1.2855937e-001F, -7.3982581e-002F,
        -1.0910086e-001F, -7.3982581e-002F, 1.2855937e-001F,
        127460.01996558293471170036792558);
    const Float rgfltCoefDenMed [] = {1.0000000e+000F,-2.8771186e+000F,
        3.2317212e+000F,-1.7996087e+000F,4.4667200e-001F};

    FOURTAP_FILTER_COEFS(Hi, Num, 4.1398413e-001F, -1.1541642e+000F,
        1.1541642e+000F, -4.1398413e-001F, 20896.620165554909424925763335516);
    const Float rgfltCoefDenHi  [] = {1.0000000e+000F,-1.2260380e+000F,
        8.4042799e-001F,-6.9830589e-002F};
    
    FourFiveFourMONO(cCoefLow, cCoefMed, cCoefHi, pfltPower, piSource,
        iSourceLength, iSliceWidth, iSliceIncr, cChannel, piTransientSrcLow,
        piTransientSrcLowCurr, pfltTransientDstLow, piTransientDstLowCurr,
        piTransientSrcMed, piTransientSrcMedCurr, pfltTransientDstMed,
        piTransientDstMedCurr, piTransientSrcHi, piTransientSrcHiCurr,
        pfltTransientDstHi, piTransientDstHiCurr,
        rgiCoefNumLow, fltInvScaleNumLow, rgfltCoefDenLow,
        rgiCoefNumMed, fltInvScaleNumMed, rgfltCoefDenMed,
        rgiCoefNumHi, fltInvScaleNumHi, rgfltCoefDenHi);    
} // g_GetLowMedHiPower_48MONO_MMX

Void g_GetLowMedHiPower_44MONO_MMX(GET_LOW_MED_HI_ARGS)
{
    FOURTAP_FILTER_COEFS(Low, Num, 4.5562337e-003F, -4.4878074e-003F, -4.4878074e-003F,
        4.5562337e-003F, 3623269.6924894840137334842660726);
    const Float rgfltCoefDenLow [] = {1.0F, -2.936026F, 2.877028F, -0.94086515F};

    // Really a seven-tap but make 8-tap for MMX (#taps must be multiple of 4)
    EIGHTTAP_FILTER_COEFS(Med, Num, 7.2210559e-002F, -1.5162153e-001F, 8.6766934e-002F,
        -1.5332479e-016F, -8.6766934e-002F, 1.5162153e-001F, -7.2210559e-002F, 0.0F,
        105499.36592923926502391456937428);
    const Float rgfltCoefDenMed [] = {1.0F, -4.5286285F, 8.9140898F, -9.9460928F,
        6.6909911F, -2.5544758F, 4.2425609e-001F};

    FOURTAP_FILTER_COEFS(Hi, Num, 3.8254407e-001F, -1.0501596F, 1.0501596F,
        -3.8254407e-001F, 22872.140765340019501728920781339);
    const Float rgfltCoefDenHi  [] = {1.0F,-1.0657992F,7.6597665e-001F,-3.3631573e-002F};

    // Get us some local 32-byte aligned arrays
    const int c_iAlignMultiple = 32; // Used to compute mask: must be pure pwr of 2 like 16 or 32
    I32     rgiFIROut[4096+16]; // +16 == +(32/sizeof(I16)), for 32-byte alignment
    I16     rgiMMXCoefs[44+16]; // +16 == +(32/sizeof(I16)), for 32-byte alignment

    I32    *piFIROutAligned = (I32 *)(((U32)rgiFIROut + c_iAlignMultiple - 1) &
        ~(c_iAlignMultiple - 1));
    I16    *piMMXCoefs = (I16 *)(((U32)rgiMMXCoefs + c_iAlignMultiple - 1) &
        ~(c_iAlignMultiple - 1));
    const I32 iSizeOfMMXCoefs = (U32)rgiMMXCoefs + sizeof(rgiMMXCoefs) -
        (U32)piMMXCoefs;

#ifdef MMXVERIFY_ENABLE
#define MMXVERIFY(a)    (a)
    static I16 rgiSrcLowVERIFY[8] = {0};
    static Float rgfltDstLowVERIFY[8] = {0};
    static I32 iSrcLowCurrVERIFY = 0;
    static I32 iDstLowCurrVERIFY = 0;

    static I16 rgiSrcMedVERIFY[16] = {0};
    static Float rgfltDstMedVERIFY[16] = {0};
    static I32 iSrcMedCurrVERIFY = 0;
    static I32 iDstMedCurrVERIFY = 0;

    static I16 rgiSrcHiVERIFY[8] = {0};
    static Float rgfltDstHiVERIFY[8] = {0};
    static I32 iSrcHiCurrVERIFY = 0;
    static I32 iDstHiCurrVERIFY = 0;

    static s_iCallNum = 0;
    s_iCallNum += 1;
#else   // MMXVERIFY
#define MMXVERIFY(a)
#endif  // MMXVERIFY

    // LOW Filter
    FourTapNUMERATOR_MMX_MONO(rgiCoefNumLow, piSource, piTransientSrcLow,
        piTransientSrcLowCurr, iSourceLength, piFIROutAligned,
        c_iAlignMultiple, piMMXCoefs, iSizeOfMMXCoefs);
    MMXVERIFY(FourTapNUMERATOR_MMX_VERIFY(rgiCoefNumLow, piSource,
        rgiSrcLowVERIFY, &iSrcLowCurrVERIFY, cChannel, iSourceLength, piFIROutAligned,
        c_iAlignMultiple, piMMXCoefs, iSizeOfMMXCoefs));
    FourTapDENOMINATOR_FLOP(rgfltCoefDenLow, 0, fltInvScaleNumLow, pfltTransientDstLow,
        piTransientDstLowCurr, iSliceIncr, pfltPower, iSourceLength, piFIROutAligned);
    MMXVERIFY(FourTapDENOMINATOR_FLOP_VERIFY(rgfltCoefDenLow, 0, fltInvScaleNumLow,
        rgfltDstLowVERIFY, &iDstLowCurrVERIFY, iSliceIncr, pfltPower,
        iSourceLength, piFIROutAligned));


    // MED Filter
    EightTapNUMERATOR_MMX_MONO(rgiCoefNumMed, piSource, piTransientSrcMed,
        piTransientSrcMedCurr, iSourceLength, piFIROutAligned,
        c_iAlignMultiple, piMMXCoefs, iSizeOfMMXCoefs);
    MMXVERIFY(EightTapNUMERATOR_MMX_VERIFY(rgiCoefNumMed, piSource,
        rgiSrcMedVERIFY, &iSrcMedCurrVERIFY, cChannel, iSourceLength, piFIROutAligned,
        c_iAlignMultiple, piMMXCoefs, iSizeOfMMXCoefs));
    SevenTapDENOMINATOR_FLOP(rgfltCoefDenMed, 1, fltInvScaleNumMed, pfltTransientDstMed,
        piTransientDstMedCurr, iSliceIncr, pfltPower, iSourceLength, piFIROutAligned);
    MMXVERIFY(SevenTapDENOMINATOR_FLOP_VERIFY(rgfltCoefDenMed, 1, fltInvScaleNumMed,
        rgfltDstMedVERIFY, &iDstMedCurrVERIFY, iSliceIncr, pfltPower, iSourceLength,
        piFIROutAligned));


    // HIGH Filter
    FourTapNUMERATOR_MMX_MONO(rgiCoefNumHi, piSource, piTransientSrcHi,
        piTransientSrcHiCurr, iSourceLength, piFIROutAligned,
        c_iAlignMultiple, piMMXCoefs, iSizeOfMMXCoefs);
    MMXVERIFY(FourTapNUMERATOR_MMX_VERIFY(rgiCoefNumHi, piSource,
        rgiSrcHiVERIFY, &iSrcHiCurrVERIFY, cChannel, iSourceLength, piFIROutAligned,
        c_iAlignMultiple, piMMXCoefs, iSizeOfMMXCoefs));
    FourTapDENOMINATOR_FLOP(rgfltCoefDenHi, 2, fltInvScaleNumHi, pfltTransientDstHi,
        piTransientDstHiCurr, iSliceIncr, pfltPower, iSourceLength, piFIROutAligned);
    MMXVERIFY(FourTapDENOMINATOR_FLOP_VERIFY(rgfltCoefDenHi, 2, fltInvScaleNumHi,
        rgfltDstHiVERIFY, &iDstHiCurrVERIFY, iSliceIncr, pfltPower, iSourceLength,
        piFIROutAligned));
} // g_GetLowMedHiPower_44MONO_MMX


Void g_GetLowMedHiPower_32MONO_MMX(GET_LOW_MED_HI_ARGS)
{
    FOURTAP_FILTER_COEFS(Low, Num, 6.2256543e-003F, -6.0485736e-003F,
        -6.0485736e-003F, 6.2256543e-003F, 2669740.2298729726810758170905857);
    const Float rgfltCoefDenLow [] = {1.0000000e+000F, -2.9102951e+000F,
        2.8300775e+000F, -9.1942820e-001F};

    FIVETAP_FILTER_COEFS(Med, Num, 2.2369834e-001F, -5.1857903e-002F,
        -3.4345617e-001F, -5.1857903e-002F, 2.2369834e-001F,
        73262.12425502029826987051544664);
    const Float rgfltCoefDenMed [] = {1.0000000e+000F, -2.2512264e+000F,
        1.9390413e+000F, -1.0269138e+000F, 3.4620074e-001F};

    FOURTAP_FILTER_COEFS(Hi, Num, 2.6059998e-001F, -6.4498064e-001F,
        6.4498064e-001F, -2.6059998e-001F, 36185.624218922943313427573293876);
    const Float rgfltCoefDenHi  [] = {1.0000000e+000F, -3.1030711e-001F,
        6.0270790e-001F, 1.0185376e-001F};

    FourFiveFourMONO(cCoefLow, cCoefMed, cCoefHi, pfltPower, piSource,
        iSourceLength, iSliceWidth, iSliceIncr, cChannel, piTransientSrcLow,
        piTransientSrcLowCurr, pfltTransientDstLow, piTransientDstLowCurr,
        piTransientSrcMed, piTransientSrcMedCurr, pfltTransientDstMed,
        piTransientDstMedCurr, piTransientSrcHi, piTransientSrcHiCurr,
        pfltTransientDstHi, piTransientDstHiCurr,
        rgiCoefNumLow, fltInvScaleNumLow, rgfltCoefDenLow,
        rgiCoefNumMed, fltInvScaleNumMed, rgfltCoefDenMed,
        rgiCoefNumHi, fltInvScaleNumHi, rgfltCoefDenHi);
} // g_GetLowMedHiPower_32MONO_MMX


Void g_GetLowMedHiPower_22MONO_MMX(GET_LOW_MED_HI_ARGS)
{
    FOURTAP_FILTER_COEFS(Low, Num, 8.9270704e-003F, -8.3957364e-003F,
        -8.3957364e-003F, 8.9270704e-003F, 1891668.0416512672033032543056801);
    const Float rgfltCoefDenLow [] = {1.0000000e+000F, -2.8661956e+000F,
        2.7524893e+000F, -8.8523103e-001F};

    FIVETAP_FILTER_COEFS(Med, Num, 3.7825275e-001F, -2.7009893e-002F,
        -7.0166945e-001F, -2.7009893e-002F, 3.7825275e-001F,
        43339.656242870633479044984783711);
    const Float rgfltCoefDenMed [] = {1.0000000e+000F, -1.4097054e+000F,
        3.9462869e-001F, -2.9769521e-001F, 3.3857173e-001F};

    FOURTAP_FILTER_COEFS(Hi, Num, 1.2646487e-001F, -2.1157565e-001F,
        2.1157565e-001F, -1.2646487e-001F, 96938.083089149356231018092590096);
    const Float rgfltCoefDenHi  [] = {1.0000000e+000F, 9.2724155e-001F,
        8.8804049e-001F, 2.8471791e-001F};

    FourFiveFourMONO(cCoefLow, cCoefMed, cCoefHi, pfltPower, piSource,
        iSourceLength, iSliceWidth, iSliceIncr, cChannel, piTransientSrcLow,
        piTransientSrcLowCurr, pfltTransientDstLow, piTransientDstLowCurr,
        piTransientSrcMed, piTransientSrcMedCurr, pfltTransientDstMed,
        piTransientDstMedCurr, piTransientSrcHi, piTransientSrcHiCurr,
        pfltTransientDstHi, piTransientDstHiCurr,
        rgiCoefNumLow, fltInvScaleNumLow, rgfltCoefDenLow,
        rgiCoefNumMed, fltInvScaleNumMed, rgfltCoefDenMed,
        rgiCoefNumHi, fltInvScaleNumHi, rgfltCoefDenHi);
} // g_GetLowMedHiPower_22MONO_MMX


Void g_GetLowMedHiPower_16MONO_MMX(GET_LOW_MED_HI_ARGS)
{
    FOURTAP_FILTER_COEFS(Low, Num, 1.2164886e-002F, -1.0804778e-002F,
        -1.0804778e-002F, 1.2164886e-002F, 1426620.7818825410218450995255553);
    const Float rgfltCoefDenLow [] = {1.0000000e+000F, -2.8096674e+000F,
        2.6577447e+000F, -8.4535714e-001F};

    FIVETAP_FILTER_COEFS(Med, Num, 6.0241859e-001F, -5.6092363e-003F,
        -1.1912111e+000F, -5.6092363e-003F, 6.0241859e-001F,
        27225.067583280221753351021750463);
    const Float rgfltCoefDenMed [] = {1.0000000e+000F,-4.3220212e-001F,-1.0839609e+000F,7.7620433e-002F,5.1464140e-001F};

    FOURTAP_FILTER_COEFS(Hi, Num, 3.9054597e-002F, 3.3076983e-003F,
        -3.3076983e-003F, -3.9054597e-002F, 773541.65498344124752840283771319);
    const Float rgfltCoefDenHi  [] = {1.0000000e+000F, 2.2733598e+000F,
        1.9348375e+000F, 5.8998385e-001F};

    FourFiveFourMONO(cCoefLow, cCoefMed, cCoefHi, pfltPower, piSource,
        iSourceLength, iSliceWidth, iSliceIncr, cChannel, piTransientSrcLow,
        piTransientSrcLowCurr, pfltTransientDstLow, piTransientDstLowCurr,
        piTransientSrcMed, piTransientSrcMedCurr, pfltTransientDstMed,
        piTransientDstMedCurr, piTransientSrcHi, piTransientSrcHiCurr,
        pfltTransientDstHi, piTransientDstHiCurr,
        rgiCoefNumLow, fltInvScaleNumLow, rgfltCoefDenLow,
        rgiCoefNumMed, fltInvScaleNumMed, rgfltCoefDenMed,
        rgiCoefNumHi, fltInvScaleNumHi, rgfltCoefDenHi);
} // g_GetLowMedHiPower_16MONO_MMX

#endif  // MMXMONO



//***************************************************************************
// STEREO ENCODE FILTER WRAPPERS
// These functions basically provide coefficients, and not much else.
//***************************************************************************

Void g_GetLowMedHiPower_48_MMX(GET_LOW_MED_HI_ARGS)
{
    FOURTAP_FILTER_COEFS(Low, Num, 4.1942460e-003F, -4.1410504e-003F,
        -4.1410504e-003F, 4.1942460e-003F, 3931353.900655440967641966055168);
    const Float rgfltCoefDenLow [] = {1.0000000e+000F,-2.9414462e+000F,
        2.8870889e+000F,-9.4553636e-001F};

    FIVETAP_FILTER_COEFS(Med, Num, 1.2855937e-001F, -7.3982581e-002F,
        -1.0910086e-001F, -7.3982581e-002F, 1.2855937e-001F,
        127460.01996558293471170036792558);
    const Float rgfltCoefDenMed [] = {1.0000000e+000F,-2.8771186e+000F,
        3.2317212e+000F,-1.7996087e+000F,4.4667200e-001F};

    FOURTAP_FILTER_COEFS(Hi, Num, 4.1398413e-001F, -1.1541642e+000F,
        1.1541642e+000F, -4.1398413e-001F, 20896.620165554909424925763335516);
    const Float rgfltCoefDenHi  [] = {1.0000000e+000F,-1.2260380e+000F,
        8.4042799e-001F,-6.9830589e-002F};

    FourFiveFourSTEREO(cCoefLow, cCoefMed, cCoefHi, pfltPower, piSource,
        iSourceLength, iSliceWidth, iSliceIncr, cChannel, piTransientSrcLow,
        piTransientSrcLowCurr, pfltTransientDstLow, piTransientDstLowCurr,
        piTransientSrcMed, piTransientSrcMedCurr, pfltTransientDstMed,
        piTransientDstMedCurr, piTransientSrcHi, piTransientSrcHiCurr,
        pfltTransientDstHi, piTransientDstHiCurr,
        rgiCoefNumLow, fltInvScaleNumLow, rgfltCoefDenLow,
        rgiCoefNumMed, fltInvScaleNumMed, rgfltCoefDenMed,
        rgiCoefNumHi, fltInvScaleNumHi, rgfltCoefDenHi);
} // g_GetLowMedHiPower_48_MMX


Void g_GetLowMedHiPower_44_MMX(GET_LOW_MED_HI_ARGS)
{
    FOURTAP_FILTER_COEFS(Low, Num, 4.5562337e-003F, -4.4878074e-003F, -4.4878074e-003F,
        4.5562337e-003F, 3623269.6924894840137334842660726);
    const Float rgfltCoefDenLow [] = {1.0F, -2.936026F, 2.877028F, -0.94086515F};

    // Really a seven-tap but make 8-tap for MMX (#taps must be multiple of 4)
    EIGHTTAP_FILTER_COEFS(Med, Num, 7.2210559e-002F, -1.5162153e-001F, 8.6766934e-002F,
        -1.5332479e-016F, -8.6766934e-002F, 1.5162153e-001F, -7.2210559e-002F, 0.0F,
        105499.36592923926502391456937428);
    const Float rgfltCoefDenMed [] = {1.0F, -4.5286285F, 8.9140898F, -9.9460928F,
        6.6909911F, -2.5544758F, 4.2425609e-001F};

    FOURTAP_FILTER_COEFS(Hi, Num, 3.8254407e-001F, -1.0501596F, 1.0501596F,
        -3.8254407e-001F, 22872.140765340019501728920781339);
    const Float rgfltCoefDenHi  [] = {1.0F,-1.0657992F,7.6597665e-001F,-3.3631573e-002F};

    // Get us some local 32-byte aligned arrays
    const int c_iAlignMultiple = 32; // Used to compute mask: must be pure pwr of 2 like 16 or 32
    I32     rgiFIROut[4096+16]; // +16 == +(32/sizeof(I16)), for 32-byte alignment
    I16     rgiMMXCoefs[44+16]; // +16 == +(32/sizeof(I16)), for 32-byte alignment

    I32    *piFIROutAligned = (I32 *)(((U32)rgiFIROut + c_iAlignMultiple - 1) &
        ~(c_iAlignMultiple - 1));
    I16    *piMMXCoefs = (I16 *)(((U32)rgiMMXCoefs + c_iAlignMultiple - 1) &
        ~(c_iAlignMultiple - 1));
    const I32 iSizeOfMMXCoefs = (U32)rgiMMXCoefs + sizeof(rgiMMXCoefs) -
        (U32)piMMXCoefs;

#ifdef MMXVERIFY_ENABLE
#define MMXVERIFY(a)    (a)
#else   // MMXVERIFY
#define MMXVERIFY(a)
#endif  // MMXVERIFY

    // LOW Filter
    FourTapNUMERATOR_MMX_STEREO(rgiCoefNumLow, piSource, piTransientSrcLow,
        piTransientSrcLowCurr, iSourceLength, piFIROutAligned,
        c_iAlignMultiple, piMMXCoefs, iSizeOfMMXCoefs);
    MMXVERIFY(FourTapNUMERATOR_MMX_VERIFY(rgiCoefNumLow, piSource,
        piTransientSrcLow + 6, (I32 *)(piTransientSrcLow + 4),
        cChannel, iSourceLength, piFIROutAligned,
        c_iAlignMultiple, piMMXCoefs, iSizeOfMMXCoefs));
    FourTapDENOMINATOR_FLOP(rgfltCoefDenLow, 0, fltInvScaleNumLow, pfltTransientDstLow,
        piTransientDstLowCurr, iSliceIncr, pfltPower, iSourceLength, piFIROutAligned);
    MMXVERIFY(FourTapDENOMINATOR_FLOP_VERIFY(rgfltCoefDenLow, 0, fltInvScaleNumLow,
        pfltTransientDstLow + 9, (I32 *)(pfltTransientDstLow + 8),
        iSliceIncr, pfltPower,
        iSourceLength, piFIROutAligned));


    // MED Filter
    EightTapNUMERATOR_MMX_STEREO(rgiCoefNumMed, piSource, piTransientSrcMed,
        piTransientSrcMedCurr, iSourceLength, piFIROutAligned,
        c_iAlignMultiple, piMMXCoefs, iSizeOfMMXCoefs);
    MMXVERIFY(EightTapNUMERATOR_MMX_VERIFY(rgiCoefNumMed, piSource,
        piTransientSrcMed + 10, (I32 *)(piTransientSrcMed + 8),
        cChannel, iSourceLength, piFIROutAligned,
        c_iAlignMultiple, piMMXCoefs, iSizeOfMMXCoefs));
    SevenTapDENOMINATOR_FLOP(rgfltCoefDenMed, 1, fltInvScaleNumMed, pfltTransientDstMed,
        piTransientDstMedCurr, iSliceIncr, pfltPower, iSourceLength, piFIROutAligned);
    MMXVERIFY(SevenTapDENOMINATOR_FLOP_VERIFY(rgfltCoefDenMed, 1, fltInvScaleNumMed,
        pfltTransientDstMed + 15, (I32 *)(pfltTransientDstMed + 14),
        iSliceIncr, pfltPower, iSourceLength,
        piFIROutAligned));


    // HIGH Filter
    FourTapNUMERATOR_MMX_STEREO(rgiCoefNumHi, piSource, piTransientSrcHi,
        piTransientSrcHiCurr, iSourceLength, piFIROutAligned,
        c_iAlignMultiple, piMMXCoefs, iSizeOfMMXCoefs);
    MMXVERIFY(FourTapNUMERATOR_MMX_VERIFY(rgiCoefNumHi, piSource,
        piTransientSrcHi + 6, (I32 *)(piTransientSrcHi + 4),
        cChannel, iSourceLength, piFIROutAligned,
        c_iAlignMultiple, piMMXCoefs, iSizeOfMMXCoefs));
    FourTapDENOMINATOR_FLOP(rgfltCoefDenHi, 2, fltInvScaleNumHi, pfltTransientDstHi,
        piTransientDstHiCurr, iSliceIncr, pfltPower, iSourceLength, piFIROutAligned);
    MMXVERIFY(FourTapDENOMINATOR_FLOP_VERIFY(rgfltCoefDenHi, 2, fltInvScaleNumHi,
        pfltTransientDstHi + 9, (I32 *)(pfltTransientDstHi + 8),
        iSliceIncr, pfltPower, iSourceLength, piFIROutAligned));
}



Void g_GetLowMedHiPower_32_MMX(GET_LOW_MED_HI_ARGS)
{
    FOURTAP_FILTER_COEFS(Low, Num, 6.2256543e-003F, -6.0485736e-003F,
        -6.0485736e-003F, 6.2256543e-003F, 2669740.2298729726810758170905857);
    const Float rgfltCoefDenLow [] = {1.0000000e+000F, -2.9102951e+000F,
        2.8300775e+000F, -9.1942820e-001F};

    FIVETAP_FILTER_COEFS(Med, Num, 2.2369834e-001F, -5.1857903e-002F,
        -3.4345617e-001F, -5.1857903e-002F, 2.2369834e-001F,
        73262.12425502029826987051544664);
    const Float rgfltCoefDenMed [] = {1.0000000e+000F, -2.2512264e+000F,
        1.9390413e+000F, -1.0269138e+000F, 3.4620074e-001F};

    FOURTAP_FILTER_COEFS(Hi, Num, 2.6059998e-001F, -6.4498064e-001F,
        6.4498064e-001F, -2.6059998e-001F, 36185.624218922943313427573293876);
    const Float rgfltCoefDenHi  [] = {1.0000000e+000F, -3.1030711e-001F,
        6.0270790e-001F, 1.0185376e-001F};

    FourFiveFourSTEREO(cCoefLow, cCoefMed, cCoefHi, pfltPower, piSource,
        iSourceLength, iSliceWidth, iSliceIncr, cChannel, piTransientSrcLow,
        piTransientSrcLowCurr, pfltTransientDstLow, piTransientDstLowCurr,
        piTransientSrcMed, piTransientSrcMedCurr, pfltTransientDstMed,
        piTransientDstMedCurr, piTransientSrcHi, piTransientSrcHiCurr,
        pfltTransientDstHi, piTransientDstHiCurr,
        rgiCoefNumLow, fltInvScaleNumLow, rgfltCoefDenLow,
        rgiCoefNumMed, fltInvScaleNumMed, rgfltCoefDenMed,
        rgiCoefNumHi, fltInvScaleNumHi, rgfltCoefDenHi);
} // g_GetLowMedHiPower_32_MMX



Void g_GetLowMedHiPower_22_MMX(GET_LOW_MED_HI_ARGS)
{
    FOURTAP_FILTER_COEFS(Low, Num, 8.9270704e-003F, -8.3957364e-003F,
        -8.3957364e-003F, 8.9270704e-003F, 1891668.0416512672033032543056801);
    const Float rgfltCoefDenLow [] = {1.0000000e+000F, -2.8661956e+000F,
        2.7524893e+000F, -8.8523103e-001F};

    FIVETAP_FILTER_COEFS(Med, Num, 3.7825275e-001F, -2.7009893e-002F,
        -7.0166945e-001F, -2.7009893e-002F, 3.7825275e-001F,
        43339.656242870633479044984783711);
    const Float rgfltCoefDenMed [] = {1.0000000e+000F, -1.4097054e+000F,
        3.9462869e-001F, -2.9769521e-001F, 3.3857173e-001F};

    FOURTAP_FILTER_COEFS(Hi, Num, 1.2646487e-001F, -2.1157565e-001F,
        2.1157565e-001F, -1.2646487e-001F, 96938.083089149356231018092590096);
    const Float rgfltCoefDenHi  [] = {1.0000000e+000F, 9.2724155e-001F,
        8.8804049e-001F, 2.8471791e-001F};

    FourFiveFourSTEREO(cCoefLow, cCoefMed, cCoefHi, pfltPower, piSource,
        iSourceLength, iSliceWidth, iSliceIncr, cChannel, piTransientSrcLow,
        piTransientSrcLowCurr, pfltTransientDstLow, piTransientDstLowCurr,
        piTransientSrcMed, piTransientSrcMedCurr, pfltTransientDstMed,
        piTransientDstMedCurr, piTransientSrcHi, piTransientSrcHiCurr,
        pfltTransientDstHi, piTransientDstHiCurr,
        rgiCoefNumLow, fltInvScaleNumLow, rgfltCoefDenLow,
        rgiCoefNumMed, fltInvScaleNumMed, rgfltCoefDenMed,
        rgiCoefNumHi, fltInvScaleNumHi, rgfltCoefDenHi);
} // g_GetLowMedHiPower_22_MMX


Void g_GetLowMedHiPower_16_MMX(GET_LOW_MED_HI_ARGS)
{
    FOURTAP_FILTER_COEFS(Low, Num, 1.2164886e-002F, -1.0804778e-002F,
        -1.0804778e-002F, 1.2164886e-002F, 1426620.7818825410218450995255553);
    const Float rgfltCoefDenLow [] = {1.0000000e+000F, -2.8096674e+000F,
        2.6577447e+000F, -8.4535714e-001F};

    FIVETAP_FILTER_COEFS(Med, Num, 6.0241859e-001F, -5.6092363e-003F,
        -1.1912111e+000F, -5.6092363e-003F, 6.0241859e-001F,
        27225.067583280221753351021750463);
    const Float rgfltCoefDenMed [] = {1.0000000e+000F,-4.3220212e-001F,-1.0839609e+000F,7.7620433e-002F,5.1464140e-001F};

    FOURTAP_FILTER_COEFS(Hi, Num, 3.9054597e-002F, 3.3076983e-003F,
        -3.3076983e-003F, -3.9054597e-002F, 773541.65498344124752840283771319);
    const Float rgfltCoefDenHi  [] = {1.0000000e+000F, 2.2733598e+000F,
        1.9348375e+000F, 5.8998385e-001F};

    FourFiveFourSTEREO(cCoefLow, cCoefMed, cCoefHi, pfltPower, piSource,
        iSourceLength, iSliceWidth, iSliceIncr, cChannel, piTransientSrcLow,
        piTransientSrcLowCurr, pfltTransientDstLow, piTransientDstLowCurr,
        piTransientSrcMed, piTransientSrcMedCurr, pfltTransientDstMed,
        piTransientDstMedCurr, piTransientSrcHi, piTransientSrcHiCurr,
        pfltTransientDstHi, piTransientDstHiCurr,
        rgiCoefNumLow, fltInvScaleNumLow, rgfltCoefDenLow,
        rgiCoefNumMed, fltInvScaleNumMed, rgfltCoefDenMed,
        rgiCoefNumHi, fltInvScaleNumHi, rgfltCoefDenHi);
} // g_GetLowMedHiPower_16_MMX




//***************************************************************************
//***************************************************************************
#if defined (PEAQ_MASK)
Void prvComputeNoisePattern_SIMD(const CAudioObjectEncoder* pauenc,
                                 const Float* rgfltCoefOrig,
                                 const Float* rgfltCoefRecon,
                                 const Int iLenCoef,
                                 Float* rgfltNoisePattern,
                                 const Bool* rgfNoisyBark)
{
    CAudioObject* pau = pauenc->pau; 
    Int cFrameSampleHalf = pau->m_cFrameSampleHalf;
    Int cSamplingRate    = pau->m_iSamplingRate;
    Int cValidBarkBand   = pau->m_rgcValidBarkBand[0];   // For max subframe size

    const Int*   rgiBarkIndex       = pau->m_rgiBarkIndexOrig; // For max subframe size
    const Float* rgfltOuterEarXform = pauenc->m_rgfltOuterEarXform;

    Int     iBand=0;
    Float   fltScale = 1.0F / iLenCoef / cFrameSampleHalf / 0.625F / 0.625F; //wchen: this assumes !NO_LEVELING
    Int     iDownFactor = LOG2 (cFrameSampleHalf) - LOG2 (iLenCoef);
    
    const Float c_fltPowStep  = 1.0592537251772888788092803732781F;
    Float fltPower    = 1.1885022274370184377301224648922F;
    Float fltPowConst = (Float) pow(10.0, 0.3 - (cValidBarkBand-1)*0.025);

    const Bool* pfNoisyBark = rgfNoisyBark;

    Bool    fPrint = 0; //pau->m_iFrameNumber == 2;

    assert (iDownFactor >= 0); 
    memset(rgfltNoisePattern, 0, NUM_BARK_BAND * sizeof(rgfltNoisePattern[0]));

    if (iDownFactor > 0)
    {
        const I16 c_iDownFactorDivisor = (1 << iDownFactor);
        const I16 c_iDFBlockMASK = ~(c_iDownFactorDivisor - 1);

        Int iCoefFull = 0;      // Full-frame coef idx for output
        Int iCoefIn = 0;        // Small subframe coef idx for input
        Int iGoldenBark = 0;    // Current golden bark band we're working on

        // pfltXform is must be incremented specially and so is not indexed
        // with the others.
        const Float* pfltXform = pauenc->m_rgpfltXfromComboHead [iDownFactor - 1];
        Float  fltError;

        I16 iNextBand, iNextBandR;

        iNextBand = (I16) rgiBarkIndex[iGoldenBark + 1];
        iNextBandR = (iNextBand & c_iDFBlockMASK);
        fltError = rgfltCoefOrig[iCoefIn] - rgfltCoefRecon[iCoefIn];
        fltError *= fltError;
        
        while (iCoefFull < cFrameSampleHalf)
        {
            if (rgfNoisyBark[iGoldenBark])
            {
                // Advance iCoefIn but be careful: advancement of iCoefIn must
                // match non-noisy loop behaviour below

                // Pre-loop fractional case: iWidth = 1 to c_iDownFactorDivisor for 0th
                // iteration. Don't worry about it, it's all covered in next calculation.
                
                // Simulate loop. Don't increment iCoefIn for the post-fractional part
                // (remainder of downsample factor). We need to consider when iCoefFull
                // is not a multiple of c_iDownFactorDivisor, so we ROUND UP.
                assert(iCoefFull <= iNextBandR);
                iCoefIn += ((iNextBandR - iCoefFull + c_iDownFactorDivisor - 1) >> iDownFactor);
            }
            else
            {
                Int iWidth;

	            iWidth = (c_iDownFactorDivisor - iCoefFull + (iCoefFull & c_iDFBlockMASK));
	            while (iCoefFull < iNextBandR)
	            {
                    fltError = rgfltCoefOrig[iCoefIn] - rgfltCoefRecon[iCoefIn];
                    fltError *= fltError;
                    rgfltNoisePattern[iGoldenBark] += fltError * *pfltXform;
                    pfltXform++;
	                iCoefFull += iWidth;
                    iWidth = c_iDownFactorDivisor;
                    iCoefIn += 1;
	            }
                //take care of the fractional part
                rgfltNoisePattern[iGoldenBark] += fltError * *pfltXform;
                rgfltNoisePattern[iGoldenBark] *= fltScale;
                pfltXform++;
            }

            // The following pointers are advanced the same way for everyone for each
            // iteration of the loop.  iCoefIn also needs to be incremented, but in a
            // specifc way and is therefore done above.
            iCoefFull = iNextBand;
            iNextBand = (I16) rgiBarkIndex[iGoldenBark + 2]; // Avoid iGoldenBark dependency
            iGoldenBark += 1;
            iNextBandR = (iNextBand & c_iDFBlockMASK);
        }
    }
    else
    {
        Int     iCoef=0;
        Float *pfltNoisePattern = rgfltNoisePattern;

        assert(0 == iDownFactor); // We assume (iDownFactor < 0) is not possible
        iBand = cValidBarkBand; // Count down to zero


#define rTemp               eax
#define rpfltNoisePattern   eax
#define riRemainingCoefs    eax
#define rpiBarkIndex        ebx
#define riCountZero         ecx
#define rpfltOuterEar       edx
#define rpfltCoefOrig       esi
#define rpfltCoefRecon      edi

#define SIZEOF_I32      4
#define SIZEOF_FLOAT    4

        _asm
        {

            // Initialize outer loop registers and vars
            mov     rpiBarkIndex, rgiBarkIndex
            add     rpiBarkIndex, SIZEOF_I32
            
            // Initialize inner loop registers and vars
            mov     rpfltOuterEar, rgfltOuterEarXform
            mov     rpfltCoefOrig, rgfltCoefOrig
            mov     rpfltCoefRecon, rgfltCoefRecon
            mov     rTemp, dword ptr [fltScale]
            push    rTemp

nextBark:
            dec     dword ptr [iBand]                   // Check if it's time to exit outer loop
            jl      exitLoop
            mov     rTemp, dword ptr [rpiBarkIndex]     // Find next bark band boundary
            add     rpiBarkIndex, SIZEOF_I32
            mov     riCountZero, rTemp
            sub     riCountZero, dword ptr [iCoef]      // Calculate width of bark band
            mov     dword ptr [iCoef], rTemp            // Save new iCoef value

            // Is this band noisy? If so, go to next band
            mov     rTemp, dword ptr [pfNoisyBark]
            add     rTemp, SIZEOF_I32
            mov     dword ptr [pfNoisyBark], rTemp
            mov     rTemp, dword ptr [rTemp - SIZEOF_I32]
            test    rTemp, rTemp
            je      computeNoisePower

            // Advance inner loop pointers
            imul    riCountZero, SIZEOF_FLOAT
            add     rpfltCoefOrig, riCountZero
            add     rpfltCoefRecon, riCountZero
            add     rpfltOuterEar, riCountZero

            jmp     nextBark


computeNoisePower:
            // This band is not noisy. Compute noise pattern.
            xorps   xmm7_xmm7                           // Zero the accumulator
            sar     riCountZero, 2                      // Each SIMD register holds 4 coefs

            // Compute error power with outer ear transform
            // Calculate number of iterations we need from the Software Pipelined
            // loop, then calculate number of iterations needed to finish
            mov     riRemainingCoefs, riCountZero
            sub     riCountZero, 3                      // 2 SIMD coefs finish in epilog
            sar     riCountZero, 2                      // Divide by 4

            jle     computeRemainder

            // If we reach this point, we're going to do software pipelined loop
            // Compute how many iterations will remain when we exit
            neg     riRemainingCoefs    // LEA only does positive displacements
            lea     riRemainingCoefs, [riRemainingCoefs + 4*riCountZero + 3]
            neg     riRemainingCoefs

            // Software Pipelined Loop: as described on p. 5-25 of Intel's
            // Optimization Reference Manual, this loop achieves high throughput
            // by overlapping the execution of several iterations.

            // **************************************************************
            // PROLOG (Software Pipelined Loop)
            // **************************************************************

            // Some clocks are skipped because there's no instructions there. This
            // is because the decoder can sometimes decode faster than the execution
            // units can execute.

            // Clock 0
            movaps  xmm0_esiBASE                    // Load rgfltCoefOrig = O1
            add     rpfltCoefOrig, 4*SIZEOF_FLOAT   // Advance ptrs

            // Clock 2
            movaps  xmm1_ediBASE                    // Load rgfltCoefRecon = R1
            add     rpfltCoefRecon, 4*SIZEOF_FLOAT  // Advance ptrs

            // Clock 4
            movaps  xmm2_edxBASE                    // Load rgfltOuterEarXform = E1
            add     rpfltOuterEar, 4*SIZEOF_FLOAT   // Advance ptrs

            // Clock 5
            subps   xmm0_xmm1                       // D1 = O1 - R1

            // Clock 6
            movaps  xmm3_esiBASE                    // Load rgfltCoefOrig = O2
            add     rpfltCoefOrig, 4*SIZEOF_FLOAT   // Advance ptrs

            // Clock 8
            movaps  xmm4_ediBASE                    // Load rgfltCoefRecon = R2
            add     rpfltCoefRecon, 4*SIZEOF_FLOAT  // Advance ptrs

            // Clock 9
            mulps   xmm0_xmm2                       // T1 = D1 * E1

            // Clock 10
            movaps  xmm5_edxBASE                    // Load rgfltOuterEarXform = E2
            add     rpfltOuterEar, 4*SIZEOF_FLOAT   // Advance ptrs

            // Clock 11
            subps   xmm3_xmm4                       // D2 = O2 - R2
            
            // Clock 12
            movaps  xmm6_esiBASE                    // Load rgfltCoefOrig = O3
            add     rpfltCoefOrig, 4*SIZEOF_FLOAT   // Advance ptrs

            // **************************************************************
            // STEADY STATE (Software Pipelined Loop)
            // **************************************************************

softPipeLOOP:
            // Clock 14
            movaps  xmm1_ediBASE                    // Load rgfltCoefRecon = R3
            add     rpfltCoefRecon, 4*SIZEOF_FLOAT  // Advance ptrs

            // Clock 15
            mulps   xmm0_xmm0                       // A1 = T1^2

            // Clock 16
            movaps  xmm2_edxBASE                    // Load rgfltOuterEarXform = E3
            add     rpfltOuterEar, 4*SIZEOF_FLOAT   // Advance ptrs

            // Clock 17
            mulps   xmm3_xmm5                       // T2 = D2 * E2

            // Clock 18
            subps   xmm6_xmm1                       // D3 = O3 - R3

            // Clock 19
            movaps  xmm4_esiBASE                    // Load rgfltCoefOrig = O4
            add     rpfltCoefOrig, 4*SIZEOF_FLOAT   // Advance ptrs

            // Clock 20
            addps   xmm7_xmm0                       // Accumulate noise power, A += A1

            // Clock 21
            movaps  xmm5_ediBASE                    // Load rgfltCoefRecon = R4
            add     rpfltCoefRecon, 4*SIZEOF_FLOAT  // Advance ptrs

            // Clock 22
            mulps   xmm3_xmm3                       // A2 = T2^2

            // Clock 23
            movaps  xmm1_edxBASE                    // Load rgfltOuterEarXform = E4
            add     rpfltOuterEar, 4*SIZEOF_FLOAT   // Advance ptrs

            // Clock 24
            mulps   xmm6_xmm2                       // T3 = D3 * E3

            // Clock 25
            subps   xmm4_xmm5                       // D4 = O4 - R4

            // Clock 26
            movaps  xmm0_esiBASE                    // Load rgfltCoefOrig = O5
            add     rpfltCoefOrig, 4*SIZEOF_FLOAT   // Advance ptrs

            // Clock 27
            addps   xmm7_xmm3                       // Accumulate noise power, A += A2

            // Clock 28
            movaps  xmm5_ediBASE                    // Load rgfltCoefRecon = R5
            add     rpfltCoefRecon, 4*SIZEOF_FLOAT  // Advance ptrs

            // Clock 29
            mulps   xmm6_xmm6                       // A3 = T3^2

            // Clock 30
            movaps  xmm2_edxBASE                    // Load rgfltOuterEarXform = E5
            add     rpfltOuterEar, 4*SIZEOF_FLOAT   // Advance ptrs

            // Clock 31
            mulps   xmm4_xmm1                       // T4 = D4 * E4

            // Clock 32
            subps   xmm0_xmm5                       // D5 = O5 - R5

            // Clock 33
            movaps  xmm3_esiBASE                    // Load rgfltCoefOrig = O6
            add     rpfltCoefOrig, 4*SIZEOF_FLOAT   // Advance ptrs

            // Clock 34
            addps   xmm7_xmm6                       // Accumulate noise power, A += A3

            // Clock 35
            movaps  xmm1_ediBASE                    // Load rgfltCoefRecon = R6
            add     rpfltCoefRecon, 4*SIZEOF_FLOAT  // Advance ptrs

            // Clock 36
            mulps   xmm4_xmm4                       // A4 = T4^2

            // Clock 37
            movaps  xmm5_edxBASE                    // Load rgfltOuterEarXform = E6
            add     rpfltOuterEar, 4*SIZEOF_FLOAT

            // Clock 38
            mulps   xmm0_xmm2                       // T5 = D5 * E5

            // Clock 39
            subps   xmm3_xmm1                       // D6 = O6 - R6

            // Clock 40
            movaps  xmm6_esiBASE                    // Load rgfltCoefOrig = O7
            add     rpfltCoefOrig, 4*SIZEOF_FLOAT   // Advance ptrs
            dec     riCountZero                     // Decrement loop counter

            // Clock 41
            addps   xmm7_xmm4                       // Accumulate noise power, A += A4

            // End of steady-state: keep looping until done
            jg      softPipeLOOP

            // **************************************************************
            // EPILOG (Software Pipelined Loop)
            // **************************************************************

            // Clock 42
            movaps  xmm2_ediBASE                    // Load rgfltCoefRecon = R7
            add     rpfltCoefRecon, 4*SIZEOF_FLOAT  // Advance ptrs

            // Clock 43
            mulps   xmm0_xmm0                       // A5 = T5^2

            // Clock 44
            movaps  xmm1_edxBASE                    // Load rgfltOuterEarXform = E7
            add     rpfltOuterEar, 4*SIZEOF_FLOAT   // Advance ptrs

            // Clock 45
            mulps   xmm3_xmm5                       // T6 = D6 * E6

            // Clock 46
            subps   xmm6_xmm2                       // D7 = O7 - R7

            // Clock 48
            addps   xmm7_xmm0                       // Accumulate noise power, A += A5

            // Clock 50
            mulps   xmm3_xmm3                       // A6 = T6^2

            // Clock 52
            mulps   xmm6_xmm1                       // T7 = D7 * E7

            // Clock 55
            addps   xmm7_xmm3                       // Accumulate noise power, A += A6

            // Clock 57
            mulps   xmm6_xmm6                       // A7 = T7^2

            // Clock 62
            addps   xmm7_xmm6                       // Accumulate noise power, A += A7


computeRemainder:
            // Finish the job, one SIMD register at a time
            mov     riCountZero, riRemainingCoefs
            test    riCountZero, riCountZero
            jle     horizontalSum                   // Sometimes the remainder is zero

remainderLOOP:
            movaps  xmm0_esiBASE                    // Load rgfltCoefOrig
            add     rpfltCoefOrig, 4*SIZEOF_FLOAT   // Advance ptrs
            movaps  xmm1_ediBASE                    // Load rgfltCoefRecon
            add     rpfltCoefRecon, 4*SIZEOF_FLOAT  // Advance ptrs
            movaps  xmm2_edxBASE                    // Load rgfltOuterEar
            add     rpfltOuterEar, 4*SIZEOF_FLOAT   // Advance ptrs

            subps   xmm0_xmm1                       // D = O - R
            dec     riCountZero
            mulps   xmm0_xmm2                       // T = D * E
            mulps   xmm0_xmm0                       // A = T^2
            addps   xmm7_xmm0                       // Accumulate noise power, Accum += A

            jg     remainderLOOP

horizontalSum:
            // OK, now do the horizontal summation to get the power sum
            // for this bark band
            movhlps xmm3_xmm7
            mov     rpfltNoisePattern, dword ptr [pfltNoisePattern]
            addps   xmm3_xmm7
            movssFROMMEM xmm4_espBASE               // Load fltScale to xmm4
            movaps  xmm7_xmm3
            shufps(xmm3_xmm3, 0xB1)                 // ABCD -> BADC
            addss   xmm3_xmm7                       // A+B+C+D in lowest cell
            mulss   xmm3_xmm4                       // Multiply by fltScale
            movssTOMEM eaxBASE_xmm3                 // Store result

            add     rpfltNoisePattern, SIZEOF_FLOAT
            mov     pfltNoisePattern, rpfltNoisePattern

            jmp     nextBark

exitLoop:
            pop     rTemp                           // Clean up fltScale
        }
    }

#if !defined NO_BARK_BW
    assert (cValidBarkBand >= 3);
    rgfltNoisePattern[0] *= fltPowConst;
    rgfltNoisePattern[1] *= fltPowConst;
    rgfltNoisePattern[2] *= fltPowConst;
    fltPowConst = (Float) pow(10.0, (1 - cValidBarkBand)*0.025);
    for (iBand = 3; iBand < cValidBarkBand; iBand++) {
        rgfltNoisePattern[iBand] *= fltPower * fltPowConst;
        fltPower *= c_fltPowStep;
    }
#endif

#if 0
    // Absorb the scale based on bark bandwidth (since while computing NMR, we are simply dividing with excitation
    for (iBand = 0; iBand < 3; iBand++) {
#if !defined NO_BARK_BW
        rgfltNoisePattern[iBand] *= (Float) pow(10.0, 0.3)/(Float) pow(10.0, (cValidBarkBand-1)*0.025);
#endif
    }
    for (iBand = 3; iBand < cValidBarkBand; iBand++) {
#if !defined NO_BARK_BW
        rgfltNoisePattern[iBand] *= (Float) pow(10.0, iBand * 0.025)/(Float) pow(10.0, (cValidBarkBand-1)*0.025);
#endif
    }
#endif

} // prvComputeNoisePattern_SIMD

#endif  // PEAQ_MASK

#endif  // ENCODER

#endif // defined(WMA_TARGET_X86)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\wmaudio_parse.c ===
/*
 * Windows Media Audio (WMA) Decoder API (parsering)
 *
 * Copyright (c) Microsoft Corporation 1999.  All Rights Reserved.
 */

#pragma code_seg("WMADEC")
#pragma data_seg("WMADEC_RW")
#pragma const_seg("WMADEC_RD")

#if defined _WIN32
#include <windows.h>
#define _BOOL_DEFINED
#endif

#include <stdio.h>
#include "malloc.h"

#include "msaudio.h"
#include "wmaudio.h"
#include "wmaudio_type.h"
#include "loadstuff.h"
#define INITGUID
#include "wmaguids.h"
#include "wmamath.h"
#include "..\..\..\dsound\dsndver.h"

#ifndef WMAAPI_NO_DRM
#include "drmpd.h"
#endif /* WMAAPI_NO_DRM */


#ifndef MIN
#define MIN(x, y)  ((x) < (y) ? (x) : (y))
#endif /* MIN */


//
//  Routines for byte-swapping the members of various structs
//

#ifdef BIG_ENDIAN

void ByteSwapWaveFormatEx( WAVEFORMATEX& dst );
void ByteSwapAsfXAcmAudioErrorMaskingData( AsfXAcmAudioErrorMaskingData& dst );

#endif

//unsigned char g_Buffer[1024];
#define MAX_BUFSIZE 128

void SWAPWORD(tWMA_U8 * pSrc)
{
    tWMA_U8 Temp;
    Temp  = *pSrc;
    *pSrc = *(pSrc+1);
    *(pSrc+1)= Temp;
}

void SWAPDWORD(tWMA_U8 * pSrc)
{
    tWMA_U8 Temp;
    Temp      = *pSrc;
    *pSrc     = *(pSrc+3);
    *(pSrc+3) = Temp;
    Temp      = *(pSrc+1);
    *(pSrc+1) = *(pSrc+2);
    *(pSrc+2) = Temp;
}

void SwapWstr(tWMA_U16 *src, tWMA_U32 n)
{
    tWMA_U32 j;
    tWMA_U8 *p = (tWMA_U8 *)src;
    for (j = 0; j < n; j++) {
        SWAPWORD(p);
        p += 2;
    }
}

/****************************************************************************/
/*
tWMA_U32 WMAFileGetData (
    tHWMAFileState *state,
    tWMA_U32 offset,
    tWMA_U32 num_bytes,
    unsigned char **ppData)
{
    tWMA_U32 dwActual;
    unsigned char *pDst, *pSrc;
    if (num_bytes > 1024) 
    {
        WMADebugMessage("** WMAFileGetLicenseData: Requested too much (%lu).\n",
                num_bytes);
    }
    dwActual = 0;
    pDst = g_Buffer;
    while (MAX_BUFSIZE < num_bytes) {
        dwActual  += WMAFileCBGetData (state, offset, MAX_BUFSIZE,&pSrc);
        num_bytes -= MAX_BUFSIZE;
        memcpy(pDst,pSrc,MAX_BUFSIZE);
        pDst      += MAX_BUFSIZE;
        offset    += MAX_BUFSIZE;
    }
    dwActual += WMAFileCBGetData (state, offset, num_bytes,&pSrc);
    memcpy(pDst,pSrc,num_bytes);
    *ppData = g_Buffer;
    return dwActual;
}
*/
/****************************************************************************/
static DWORD HnsQWORDtoMsDWORD (QWORD qw)
{
    DWORD msLo, msHi;

    msLo = qw.dwLo/10000;
    msHi = (DWORD)ftoi((float)qw.dwHi*429496.7296f);

    return msLo + msHi;
}


/****************************************************************************/
DWORD WMA_GetBuffer (

    tWMAFileStateInternal *pInt,
    DWORD cbOffset,
    DWORD cbTotal,
    BYTE *pBuffer)
{
    DWORD cbReturn = 0;
    BYTE *pData;
    DWORD cbActual;
    DWORD cbWanted;

    if(pBuffer == NULL)
    {
        return 0;
    }

    while(cbTotal > 0)
    {
        cbWanted = MIN(WMA_MAX_DATA_REQUESTED, cbTotal);
        cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                    pInt->hdr_parse.pCallbackContext,
                                    cbOffset, cbWanted, &pData);
        if(cbActual != cbWanted)
        {
            return 0;
        }

        memcpy(pBuffer, pData, (size_t)cbActual);

        pBuffer += cbActual;
        cbOffset += cbActual;
        cbTotal -= cbActual;
        cbReturn += cbActual;
    }

    return cbReturn;        
}


/****************************************************************************/
WMAERR
WMA_LoadObjectHeader(tWMAFileHdrStateInternal *pInt,
                     GUID *pObjectId,
                     QWORD *pqwSize)
{
    BYTE *pData;
    DWORD cbWanted;
    DWORD cbActual;

    if(pInt == NULL)
    {
        return WMAERR_INVALIDARG;
    }

    cbWanted = MIN_OBJECT_SIZE;
    cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                pInt->pCallbackContext,
                                pInt->currPacketOffset, cbWanted, &pData);
    if(cbActual != cbWanted)
    {
        return WMAERR_BUFFERTOOSMALL;
    }
    pInt->currPacketOffset += cbActual;

    LoadGUID(*pObjectId, pData);
    LoadQWORD(*pqwSize, pData);

    return WMAERR_OK;
}


/****************************************************************************/
WMAERR
WMA_LoadHeaderObject(tWMAFileHdrStateInternal *pInt,
                     int isFull)
{
    GUID objectId;
    QWORD qwSize;
    DWORD cHeaders;
    BYTE align;
    BYTE arch;

    BYTE *pData;
    DWORD cbWanted;
    DWORD cbActual;

    if(pInt == NULL)
    {
        return WMAERR_INVALIDARG;
    }

#ifndef WMAAPI_NO_DRM
#ifdef GLOBAL_SECRET

    if(isFull)
    {
        SetSecret_4of7(((tWMAFileStateInternal *)pInt)->pDRM_state);
    }
#endif // GLOBAL_SECRET

#endif /* WMAAPI_NO_DRM */

    cbWanted = MIN_OBJECT_SIZE + sizeof(DWORD) + 2*sizeof(BYTE);
    cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                pInt->pCallbackContext,
                                pInt->currPacketOffset, cbWanted, &pData);
    if(cbActual != cbWanted)
    {
        return WMAERR_BUFFERTOOSMALL;
    }
    pInt->currPacketOffset += cbActual;

    LoadGUID(objectId, pData);
    LoadQWORD(qwSize, pData);
    LoadDWORD(cHeaders, pData);
    LoadBYTE(align, pData);
    LoadBYTE(arch, pData);

    if(!WMA_IsEqualGUID(&CLSID_CAsfHeaderObjectV0, &objectId)
       || align != 1
       || arch != 2)
    {
        return WMAERR_INVALIDHEADER;
    }

    /* use all */
    pInt->cbHeader = qwSize.dwLo;
    
    return WMAERR_OK;
}


/****************************************************************************/
WMAERR
WMA_LoadPropertiesObject(tWMAFileHdrStateInternal *pInt,
                         DWORD cbSize,
                         int isFull)
{
    GUID mmsId;
    QWORD qwTotalSize;
    QWORD qwCreateTime;
    QWORD qwPackets;
    QWORD qwPlayDuration;
    QWORD qwSendDuration;
    QWORD qwPreroll;
    DWORD dwFlags;
    DWORD dwMinPacketSize;
    DWORD dwMaxPacketSize;
    DWORD dwMaxBitrate;

    BYTE *pData;
    DWORD cbWanted;
    DWORD cbActual;

    if(pInt == NULL)
    {
        return WMAERR_INVALIDARG;
    }
    cbSize -= MIN_OBJECT_SIZE;

#ifndef WMAAPI_NO_DRM
#ifdef GLOBAL_SECRET

    if(isFull)
    {
        SetSecret_5of7(((tWMAFileStateInternal *)pInt)->pDRM_state);
    }
#endif // GLOBAL_SECRET

#endif /* WMAAPI_NO_DRM */

    cbWanted = sizeof(GUID) + 6*sizeof(QWORD) + 4*sizeof(DWORD);
    if(cbWanted > cbSize)
    {
        return WMAERR_BUFFERTOOSMALL;
    }
    cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                pInt->pCallbackContext,
                                pInt->currPacketOffset, cbWanted, &pData);
    if(cbActual != cbWanted)
    {
        return WMAERR_BUFFERTOOSMALL;
    }

    LoadGUID(mmsId, pData);
    LoadQWORD(qwTotalSize, pData);
    LoadQWORD(qwCreateTime, pData);
    LoadQWORD(qwPackets, pData);
    LoadQWORD(qwPlayDuration, pData);
    LoadQWORD(qwSendDuration, pData);
    LoadQWORD(qwPreroll, pData);
    LoadDWORD(dwFlags, pData);
    LoadDWORD(dwMinPacketSize, pData);
    LoadDWORD(dwMaxPacketSize, pData);
    LoadDWORD(dwMaxBitrate, pData);

    if(dwMinPacketSize != dwMaxPacketSize
       || (qwPackets.dwLo == 0 && qwPackets.dwHi == 0))
    {
        return WMAERR_FAIL;
    }

    pInt->cbPacketSize = dwMaxPacketSize;
    pInt->cPackets     = qwPackets.dwLo;
    pInt->msDuration   = HnsQWORDtoMsDWORD(qwSendDuration);
    pInt->msPreroll    = qwPreroll.dwLo;
    
    /* use all */
    pInt->currPacketOffset += cbSize;

    return WMAERR_OK;
}


/****************************************************************************/
WMAERR
WMA_LoadAudioObject(tWMAFileHdrStateInternal *pInt,
                    DWORD cbSize,
                    int isFull)
{
    GUID streamType;
    GUID ecStrategy;
    QWORD qwOffset;
    DWORD cbTypeSpecific;
    DWORD cbErrConcealment;
    WORD wStreamNum;
    DWORD dwJunk;
    DWORD nBlocksPerObject;
    AsfXAcmAudioErrorMaskingData *pScramblingData;
    // WAVEFORMATEX *pFmt;

    BYTE *pData;
    DWORD cbWanted;
    DWORD cbActual;

	    WORD  tw;
	    DWORD tdw;
	    const BYTE *tp;

    
    DWORD cbObjectOffset = 0;



    if(pInt == NULL)
    {
        return WMAERR_INVALIDARG;
    }

    cbSize -= MIN_OBJECT_SIZE;

#ifndef WMAAPI_NO_DRM
#ifdef GLOBAL_SECRET

    if (isFull)
    {
        SetSecret_3of7(((tWMAFileStateInternal *)pInt)->pDRM_state);
    }
#endif // GLOBAL_SECRET

#endif /* WMAAPI_NO_DRM */

    cbWanted = 2*sizeof(GUID) + sizeof(QWORD) + 3*sizeof(DWORD) + sizeof(WORD);
    if(cbObjectOffset + cbWanted > cbSize)
    {
        return WMAERR_BUFFERTOOSMALL;
    }
    cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                pInt->pCallbackContext,
                                pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);
    if(cbActual != cbWanted)
    {
        return WMAERR_BUFFERTOOSMALL;
    }
    cbObjectOffset += cbActual;

    LoadGUID(streamType, pData);
    LoadGUID(ecStrategy, pData);
    LoadQWORD(qwOffset, pData);
    LoadDWORD(cbTypeSpecific, pData);
    LoadDWORD(cbErrConcealment, pData);
    LoadWORD(wStreamNum, pData);
    LoadDWORD(dwJunk, pData);

    wStreamNum &= 0x7F;

    if( !WMA_IsEqualGUID( &CLSID_AsfXStreamTypeAcmAudio, &streamType ) )
    {
#ifndef WMAAPI_NO_DRM_STREAM
        /* Remember the DRM Aux Data stream number */
        if( WMA_IsEqualGUID( &CLSID_AsfXStreamTypeDRMAuxData, &streamType ) )
        {
            pInt->bDRMAuxStreamNum = (BYTE) wStreamNum;
        }
#endif  /* WMAAPI_NO_DRM_STREAM */

        /* Skip over the rest */
        pInt->currPacketOffset += cbSize;
        return WMAERR_OK;
    }

    /* Type specific */
    pInt->wAudioStreamId = wStreamNum; //Amit

    if(cbTypeSpecific > 0)
    {
        cbWanted = cbTypeSpecific;
        if(cbObjectOffset + cbWanted > cbSize)
        {
            return WMAERR_BUFFERTOOSMALL;
        }
        cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                    pInt->pCallbackContext,
                                    pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);
        if(cbActual != cbWanted)
        {
            return WMAERR_BUFFERTOOSMALL;
        }
        cbObjectOffset += cbActual;

        tp = pData;
        LoadWORD (tw ,tp);

        switch(tw)
        {
        case WAVE_FORMAT_WMAUDIO2:

            if(cbTypeSpecific < 28 /*sizeof(WMAUDIO2WAVEFORMAT)*/)
            {
                return WMAERR_FAIL;
            }

            pInt->nVersion         = 2;
		    tp = pData +  4; LoadDWORD(tdw,tp); 
            pInt->nSamplesPerSec   = tdw;
            tp = pData +  8; LoadDWORD(tdw,tp);
            pInt->nAvgBytesPerSec  = tdw;
            tp = pData + 12; LoadWORD (tw ,tp);
            pInt->nBlockAlign      = tw;
            tp = pData +  2; LoadWORD (tw ,tp);
            pInt->nChannels        = tw;
	        tp = pData + 22; LoadWORD (tw ,tp);
	        tp = pData + 18; LoadDWORD(tdw,tp);
            pInt->nSamplesPerBlock = tdw;
            pInt->nEncodeOpt       = tw;

            break;
        case WAVE_FORMAT_MSAUDIO1:
            if(cbTypeSpecific < 22 /*sizeof(MSAUDIO1WAVEFORMAT)*/)
            {
                return WMAERR_FAIL;
            }

            pInt->nVersion         = 1;
		    tp = pData +  4; LoadDWORD(tdw,tp); 
            pInt->nSamplesPerSec   = tdw;
            tp = pData +  8; LoadDWORD(tdw,tp);
            pInt->nAvgBytesPerSec  = tdw;
            tp = pData + 12; LoadWORD (tw ,tp);
            pInt->nBlockAlign      = tw;
            tp = pData +  2; LoadWORD (tw ,tp);
            pInt->nChannels        = tw;
	        tp = pData + 20; LoadWORD (tw,tp);
            pInt->nEncodeOpt       = tw;
	        tp = pData + 18; LoadWORD (tw,tp);
            pInt->nSamplesPerBlock = tw;

            break;
        default:
            // unknown...
            return WMAERR_FAIL;
        }
    }

    /* Error concealment - this can get as big as 400!!! */

    if(cbErrConcealment > 0)
    {
        if(WMA_IsEqualGUID(&CLSID_AsfXSignatureAudioErrorMaskingStrategy, &ecStrategy))
        {
            cbWanted = sizeof(AsfXSignatureAudioErrorMaskingData);
        }
        else if(WMA_IsEqualGUID(&CLSID_AsfXAcmAudioErrorMaskingStrategy, &ecStrategy))
        {
//            cbWanted = sizeof(AsfXAcmAudioErrorMaskingData);
            cbWanted = 8;
        }
        else
        {
            return WMAERR_FAIL;
        }

        if(cbObjectOffset + cbWanted > cbSize)
        {
            return WMAERR_BUFFERTOOSMALL;
        }
        cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                    pInt->pCallbackContext,
                                    pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);
        if(cbActual != cbWanted)
        {
            return WMAERR_BUFFERTOOSMALL;
        }
        cbObjectOffset += cbErrConcealment; // Skip over the rest - cbActual;

        if(WMA_IsEqualGUID(&CLSID_AsfXSignatureAudioErrorMaskingStrategy, &ecStrategy))
        {
            pInt->cbAudioSize = ((AsfXSignatureAudioErrorMaskingData *)pData)->maxObjectSize;
            
#ifdef BIG_ENDIAN
			// byte-swap the object size
			SWAP_DWORD(pInt->cbAudioSize);
#endif

        }
        else if(WMA_IsEqualGUID(&CLSID_AsfXAcmAudioErrorMaskingStrategy, &ecStrategy))
        {
            pScramblingData = (AsfXAcmAudioErrorMaskingData *)pData;
            
#ifdef BIG_ENDIAN
			// byte-swap the struct
			ByteSwapAsfXAcmAudioErrorMaskingData( *pScramblingData );
#endif


//            pInt->cbAudioSize = (DWORD)(pScramblingData->virtualPacketLen*pScramblingData->span);
            pInt->cbAudioSize = (DWORD)(((WORD)(pData+1)) * ((WORD)(*pData)));

			if (pScramblingData->span >1)
				return WMAERR_FAIL;
            
#ifdef BIG_ENDIAN
			// byte-swap the object size
			SWAP_DWORD(pInt->cbAudioSize);
#endif
        }
        else
        {
            return WMAERR_FAIL;
        }
    }

    nBlocksPerObject = pInt->cbAudioSize/pInt->nBlockAlign;
    pInt->cbAudioSize = nBlocksPerObject*pInt->nSamplesPerBlock*pInt->nChannels*2;

#ifndef WMAAPI_NO_DRM_STREAM
    /* Remember which stream contains the audio payloads */
    pInt->bAudioStreamNum = (BYTE) wStreamNum;
#endif  /* WMAAPI_NO_DRM_STREAM */
    
    /* use all */
    pInt->currPacketOffset += cbSize;

    return WMAERR_OK;
}


/****************************************************************************/
WMAERR
WMA_LoadEncryptionObject(tWMAFileHdrStateInternal *pInt,
                         DWORD cbSize)
{
    DWORD cbBlock;

    BYTE *pData;
    DWORD cbWanted;
    DWORD cbActual;

    DWORD cbObjectOffset = 0;

    if(pInt == NULL)
    {
        return WMAERR_INVALIDARG;
    }

    cbSize -= MIN_OBJECT_SIZE;

    pInt->cbSecretData = 0;

    /* SecretData */

    cbWanted = sizeof(DWORD);
    if(cbObjectOffset + cbWanted > cbSize)
    {
        return WMAERR_BUFFERTOOSMALL;
    }
    cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                pInt->pCallbackContext,
                                pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);
    if(cbActual != cbWanted)
    {
        return WMAERR_BUFFERTOOSMALL;
    }
    cbObjectOffset += cbActual;

    LoadDWORD(pInt->cbSecretData, pData);

    if(pInt->cbSecretData)
    {
        cbWanted = pInt->cbSecretData;
        if(cbObjectOffset + cbWanted > cbSize)
        {
            return WMAERR_BUFFERTOOSMALL;
        }
        cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                    pInt->pCallbackContext,
                                    pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);
        if(cbActual != cbWanted)
        {
            return WMAERR_BUFFERTOOSMALL;
        }
        cbObjectOffset += cbActual;

        memcpy(pInt->pbSecretData, pData, (size_t)cbActual);
    }

    /* Type string */

    cbWanted = sizeof(DWORD);
    if(cbObjectOffset + cbWanted > cbSize)
    {
        return WMAERR_BUFFERTOOSMALL;
    }
    cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                pInt->pCallbackContext,
                                pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);
    if(cbActual != cbWanted)
    {
        return WMAERR_BUFFERTOOSMALL;
    }
    cbObjectOffset += cbActual;

    LoadDWORD(cbBlock, pData);

    if(cbBlock)
    {
        cbWanted = cbBlock;
        if(cbObjectOffset + cbWanted > cbSize)
        {
            return WMAERR_BUFFERTOOSMALL;
        }
        cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                    pInt->pCallbackContext,
                                    pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);
        if(cbActual != cbWanted)
        {
            return WMAERR_BUFFERTOOSMALL;
        }
        cbObjectOffset += cbActual;

        memcpy(pInt->pbType, pData, (size_t)cbActual);
    }

    /* Key ID */

    cbWanted = sizeof(DWORD);
    if(cbObjectOffset + cbWanted > cbSize)
    {
        return WMAERR_BUFFERTOOSMALL;
    }
    cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                pInt->pCallbackContext,
                                pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);
    if(cbActual != cbWanted)
    {
        return WMAERR_BUFFERTOOSMALL;
    }
    cbObjectOffset += cbActual;

    LoadDWORD(cbBlock, pData);

    if(cbBlock)
    {
        cbWanted = cbBlock;
        if(cbObjectOffset + cbWanted > cbSize)
        {
            return WMAERR_BUFFERTOOSMALL;
        }
        cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                    pInt->pCallbackContext,
                                    pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);
        if(cbActual != cbWanted)
        {
            return WMAERR_BUFFERTOOSMALL;
        }
        cbObjectOffset += cbActual;

        memcpy(pInt->pbKeyID, pData, (size_t)cbActual);
    }

    /* License URL */

    cbWanted = sizeof(DWORD);
    if(cbObjectOffset + cbWanted > cbSize)
    {
        return WMAERR_BUFFERTOOSMALL;
    }
    cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                pInt->pCallbackContext,
                                pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);
    if(cbActual != cbWanted)
    {
        return WMAERR_BUFFERTOOSMALL;
    }
    cbObjectOffset += cbActual;

    LoadDWORD(cbBlock, pData);

    if(cbBlock)
    {
        cbWanted = cbBlock;
        if(cbObjectOffset + cbWanted > cbSize)
        {
            return WMAERR_BUFFERTOOSMALL;
        }
		while (cbWanted>0) {
			cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                        pInt->pCallbackContext,
										pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);
			cbObjectOffset += cbActual;
			cbWanted -= cbActual;
		}

        /* ignore */
    }

    /* use all */
    pInt->currPacketOffset += cbSize;

    return WMAERR_OK;
}


/****************************************************************************/
WMAERR
WMA_LoadContentDescriptionObject(tWMAFileHdrStateInternal *pInt,
                                 DWORD cbSize)
{
    BYTE *pData;
    DWORD cbWanted;
    DWORD cbActual;

    DWORD cbObjectOffset = 0;

    if(pInt == NULL)
    {
        return WMAERR_INVALIDARG;
    }

    cbSize -= MIN_OBJECT_SIZE;

    cbWanted = 5*sizeof(WORD);
    if(cbObjectOffset + cbWanted > cbSize)
    {
        return WMAERR_BUFFERTOOSMALL;
    }
    cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                pInt->pCallbackContext,
                                pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);
    if(cbActual != cbWanted)
    {
        return WMAERR_BUFFERTOOSMALL;
    }
    cbObjectOffset += cbActual;

    LoadWORD(pInt->cbCDTitle, pData);
    LoadWORD(pInt->cbCDAuthor, pData);
    LoadWORD(pInt->cbCDCopyright, pData);
    LoadWORD(pInt->cbCDDescription, pData);
    LoadWORD(pInt->cbCDRating, pData);

    pInt->cbCDOffset = pInt->currPacketOffset + cbObjectOffset;

    /* use all */
    pInt->currPacketOffset += cbSize;

    return WMAERR_OK;
}

/****************************************************************************/
WMAERR
WMA_LoadExtendedContentDescObject(tWMAFileHdrStateInternal *pInt,
                                 DWORD cbSize)
{
    BYTE *pData;
    DWORD cbWanted;
    DWORD cbActual;
    DWORD cbBuffer;
    WORD i;
    tWMAExtendedContentDesc *pECDesc = NULL;
    tWMA_U16 cDescriptors;
    DWORD cbOffset=0;
    DWORD cbWanted1 =0;
//    unsigned char g_Buffer[1024];
//    #define MAX_BUFSIZE 128


    DWORD cbObjectOffset = 0;

    if(pInt == NULL)
    {
        return WMAERR_INVALIDARG;
    }

    cbSize -= MIN_OBJECT_SIZE;

/////////////////////////S//////////////////////
    cbBuffer = cbSize;

/*    cbWanted = cbSize;
    cbBuffer = cbSize;

    cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);
    if(cbActual != cbWanted)
    {
        return WMAERR_BUFFERTOOSMALL;
    }
    cbObjectOffset += cbActual;
*/
///////////////////////////////////////E//////////
    if(pInt->m_pECDesc != NULL) 
        goto SKIP;

    pInt->m_pECDesc = (tWMAExtendedContentDesc *)malloc(sizeof(tWMAExtendedContentDesc));
    if( pInt->m_pECDesc == NULL) {
        return( WMAERR_OUTOFMEMORY );
    }
    pECDesc = pInt->m_pECDesc;
////////////////////////////S//////////////
    cbWanted = sizeof(tWMA_U16);

    cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                pInt->pCallbackContext,
                                pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);
    if(cbActual != cbWanted)
    {
        return WMAERR_BUFFERTOOSMALL;
    }
    cbObjectOffset += cbActual;
    cbBuffer -= cbActual;
////////////////////////////E/////////////
    LoadWORD(cDescriptors, pData);
//    cbBuffer -= sizeof(tWMA_U16);

    pECDesc->cDescriptors = cDescriptors;
    pECDesc->pDescriptors = (ECD_DESCRIPTOR *)malloc(cDescriptors * sizeof(ECD_DESCRIPTOR));
   if(pECDesc->pDescriptors == NULL)
       return( WMAERR_OUTOFMEMORY );

   for(i = 0; i < cDescriptors; i++) {
  
///////////////////////////////////////////S/////////////////////////////
        cbWanted = sizeof(tWMA_U16);

        cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                    pInt->pCallbackContext,
                                    pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);
        if(cbActual != cbWanted)
        {
            return WMAERR_BUFFERTOOSMALL;
        }
        cbObjectOffset += cbActual;
///////////////////////////////////////////E///////////////////////////       
       LoadWORD(pECDesc->pDescriptors[i].cbName, pData);
       cbBuffer -= sizeof(tWMA_U16);
        if(cbBuffer < pECDesc->pDescriptors[i].cbName + sizeof(tWMA_U16) * 2)
            return( WMAERR_BUFFERTOOSMALL );
        pECDesc->pDescriptors[i].pwszName = NULL;
        pECDesc->pDescriptors[i].pwszName = (tWMA_U16 *)malloc(pECDesc->pDescriptors[i].cbName);
        if (pECDesc->pDescriptors[i].pwszName == NULL)
            return( WMAERR_OUTOFMEMORY );
        else
        {

    ///////////////////////////////////////////S/////////////////////////////
            cbWanted = pECDesc->pDescriptors[i].cbName + sizeof(tWMA_U16) * 2;
            
            if(cbWanted > MAX_BUFSIZE)
            {
                cbOffset=0;
                do
                {
                    cbWanted1 =  cbWanted > MAX_BUFSIZE ? MAX_BUFSIZE : cbWanted;
                    cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                                pInt->pCallbackContext,
                                                pInt->currPacketOffset + cbObjectOffset, cbWanted1, &pData);
                    if(cbActual != cbWanted1)
                    {
                        return WMAERR_BUFFERTOOSMALL;
                    }
                    cbObjectOffset += cbActual;
                    cbWanted -=cbActual;
            ///////////////////////////////////////////E///////////////////////////       

                    memcpy(pECDesc->pDescriptors[i].pwszName+cbOffset, pData, cbActual);
                    cbOffset +=cbActual;
                }while(cbWanted >0);
            }
            else
            {
                cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                            pInt->pCallbackContext,
                                            pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);
                if(cbActual != cbWanted)
                {
                    return WMAERR_BUFFERTOOSMALL;
                }
                cbObjectOffset += cbActual;
        ///////////////////////////////////////////E///////////////////////////       

                memcpy(pECDesc->pDescriptors[i].pwszName, pData, pECDesc->pDescriptors[i].cbName);
            }
        }
#ifndef LITTLE_ENDIAN
        SwapWstr((tWMA_U16 *)pECDesc->pDescriptors[i].pwszName, (tWMA_U32)(pECDesc->pDescriptors[i].cbName / sizeof(tWMA_U16)));
#endif
        pData += pECDesc->pDescriptors[i].cbName;
        cbBuffer -= pECDesc->pDescriptors[i].cbName;
        LoadWORD(pECDesc->pDescriptors[i].data_type, pData);
        cbBuffer -= sizeof(tWMA_U16);
        LoadWORD(pECDesc->pDescriptors[i].cbValue, pData);
        cbBuffer -= sizeof(tWMA_U16);
        if(cbBuffer < (DWORD)pECDesc->pDescriptors[i].cbValue)
            return( WMAERR_BUFFERTOOSMALL );
        pECDesc->pDescriptors[i].uValue.pbBinary = NULL;
        pECDesc->pDescriptors[i].uValue.pbBinary = (tWMA_U8 *)malloc (pECDesc->pDescriptors[i].cbValue);
        if (pECDesc->pDescriptors[i].uValue.pbBinary == NULL)
            return( WMAERR_OUTOFMEMORY );
        else
        {
    ///////////////////////////////////////////S/////////////////////////////
            cbWanted = pECDesc->pDescriptors[i].cbValue;

            if(cbWanted > MAX_BUFSIZE)
            {
                cbOffset=0;
                do
                {
                    cbWanted1 =  cbWanted > MAX_BUFSIZE ? MAX_BUFSIZE : cbWanted;
                    cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                                pInt->pCallbackContext,
                                                pInt->currPacketOffset + cbObjectOffset, cbWanted1, &pData);
                    if(cbActual != cbWanted1)
                    {
                        return WMAERR_BUFFERTOOSMALL;
                    }
                    cbObjectOffset += cbActual;
                    cbWanted -=cbActual;
            ///////////////////////////////////////////E///////////////////////////       
                    memcpy(pECDesc->pDescriptors[i].uValue.pbBinary+cbOffset, pData, cbActual);
                    cbOffset +=cbActual;
                }while(cbWanted >0);
            }
            else
            {
                cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                            pInt->pCallbackContext,
                                            pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);
                if(cbActual != cbWanted)
                {
                    return WMAERR_BUFFERTOOSMALL;
                }
                cbObjectOffset += cbActual;
        ///////////////////////////////////////////E///////////////////////////       

                memcpy(pECDesc->pDescriptors[i].uValue.pbBinary, pData, pECDesc->pDescriptors[i].cbValue);

            }
    }
#ifndef LITTLE_ENDIAN
        if((pECDesc->pDescriptors[i].data_type == ECD_DWORD) ||
        (pECDesc->pDescriptors[i].data_type == ECD_BOOL))
            SWAPDWORD((tWMA_U8 *)pECDesc->pDescriptors[i].uValue.pbBinary);
        else if(pECDesc->pDescriptors[i].data_type == ECD_STRING)
            SwapWstr((tWMA_U16 *)pECDesc->pDescriptors[i].uValue.pwszString, (tWMA_U32)(pECDesc->pDescriptors[i].cbValue / sizeof(tWMA_U16));
        else if(pECDesc->pDescriptors[i].data_type == ECD_WORD)
            SWAPWORD((tWMA_U8 *)pECDesc->pDescriptors[i].uValue.pbBinary);
#endif
        pData += pECDesc->pDescriptors[i].cbValue;
        cbBuffer -= pECDesc->pDescriptors[i].cbValue;
    }

SKIP:
    /* use all */
    pInt->currPacketOffset += cbSize;

    return( WMAERR_OK );
}

/****************************************************************************/
WMAERR
WMA_LoadLicenseStoreObject(tWMAFileHdrStateInternal *pInt,
                                 DWORD cbSize)
{
    BYTE *pData;
    DWORD cbWanted;
    DWORD cbDone;
    DWORD cbActual;

    DWORD m_dwFlag;

    DWORD cbObjectOffset = 0;

    if(pInt == NULL)
    {
        return WMAERR_INVALIDARG;
    }

    cbSize -= MIN_OBJECT_SIZE;

    cbWanted = 8;
    if(cbObjectOffset + cbWanted > cbSize)
    {
        return WMAERR_BUFFERTOOSMALL;
    }
    cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                pInt->pCallbackContext,
                                pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);
    if(cbActual != cbWanted)
    {
        return WMAERR_BUFFERTOOSMALL;
    }
    cbObjectOffset += cbActual;

    LoadDWORD(m_dwFlag, pData);
    LoadDWORD(pInt->m_dwLicenseLen, pData);

    cbWanted = pInt->m_dwLicenseLen;
    if(cbObjectOffset + cbWanted > cbSize)
    {
        return WMAERR_NOTDONE;
    }
    pInt->m_pLicData = malloc(cbWanted);

    cbDone = 0;
    while (cbWanted) {
        cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                    pInt->pCallbackContext,
                                    pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);
        memcpy(pInt->m_pLicData + cbDone, pData, cbActual);
        cbObjectOffset += cbActual;
        cbWanted -= cbActual;
        cbDone   += cbActual;
        if(cbActual == 0)
        {
            return WMAERR_FAIL;
        }
    }

//    pInt->cbCDOffset = pInt->currPacketOffset + cbObjectOffset;

    /* use all */
    pInt->currPacketOffset += cbSize;

    return WMAERR_OK;
}


/****************************************************************************/
WMAERR  WMA_LoadMarkerObject(tWMAFileHdrStateInternal *pInt, DWORD cbSize, int iIndex)
{
    BYTE *pData;
    DWORD cbWanted;
    DWORD cbActual;

    DWORD cbObjectOffset = 0;

    GUID    m_gMarkerStrategy;
    WORD    m_wAlignment;
    WORD    m_wNameLen;
    WORD    tw;
    unsigned int i, j;


    if(pInt == NULL)
    {
        return WMAERR_INVALIDARG;
    }


    cbSize -= MIN_OBJECT_SIZE;

    cbWanted = 24;
    if(cbObjectOffset + cbWanted > cbSize)
    {
        return WMAERR_BUFFERTOOSMALL;
    }
    cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                pInt->pCallbackContext,
                                pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);
    if(cbActual != cbWanted)
    {
        return WMAERR_BUFFERTOOSMALL;
    }
    cbObjectOffset += cbActual;

    LoadGUID (m_gMarkerStrategy, pData);
    LoadDWORD(pInt->m_dwMarkerNum, pData);
    LoadWORD (m_wAlignment, pData);
    LoadWORD (m_wNameLen, pData);

    //pInt->m_pMarkers = (MarkerEntry *) malloc(sizeof(MarkerEntry)*pInt->m_dwMarkerNum);
	
//NQF+
	if( pInt->m_dwMarkerNum == 0)
	{
        /* use all */
        pInt->currPacketOffset += cbSize;
    	return WMAERR_OK;

    } else if ( iIndex < 0 ) {  //for query number of Markers
        
        /* use all */
        pInt->currPacketOffset += cbSize;
        return WMAERR_OK;

    } else if ( iIndex >= (int) pInt -> m_dwMarkerNum) {
        /* use all */
        pInt->currPacketOffset += cbSize;
        return WMAERR_BUFFERTOOSMALL;  //NQF_temp 
    }
//NQF-

    for (j = 0; j <= (unsigned int) iIndex; j++) {
        cbWanted = 18;
        if(cbObjectOffset + cbWanted > cbSize)
        {
            return WMAERR_BUFFERTOOSMALL;
        }
        cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                    pInt->pCallbackContext,
                                    pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);
        if(cbActual != cbWanted)
        {
            return WMAERR_BUFFERTOOSMALL;
        }
        cbObjectOffset += cbActual;

        LoadQWORD(pInt->m_pMarker->m_qOffset, pData);
        LoadQWORD(pInt->m_pMarker->m_qtime, pData);
        LoadWORD (pInt->m_pMarker->m_wEntryLen, pData);

        cbWanted = pInt->m_pMarker->m_wEntryLen;
        if(cbObjectOffset + cbWanted > cbSize)
        {
            return WMAERR_BUFFERTOOSMALL;
        }
        cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                    pInt->pCallbackContext,
                                    pInt->currPacketOffset + cbObjectOffset, cbWanted, &pData);
        if(cbActual != cbWanted)
        {
            return WMAERR_BUFFERTOOSMALL;
        }
        cbObjectOffset += cbActual;

        LoadDWORD(pInt->m_pMarker->m_dwSendTime, pData);
        LoadDWORD(pInt->m_pMarker->m_dwFlags, pData);
        LoadDWORD(pInt->m_pMarker->m_dwDescLen, pData);

        //pInt->m_pMarkers[j].m_pwDescName = (WORD *)malloc(sizeof(WORD)*pInt->m_pMarkers[j].m_dwDescLen);

        for (i=0;i<pInt->m_pMarker->m_dwDescLen && i < DESC_NAME_MAX_LENGTH; i++) {
            LoadWORD(tw, pData);
            pInt->m_pMarker->m_pwDescName[i] = tw;
        }
    }

    /* use all */
    pInt->currPacketOffset += cbSize;

    return WMAERR_OK;
}

/****************************************************************************/
WMAERR WMA_GetMarkerObject(tWMAFileHdrStateInternal *pInt, int iIndex)
{
    WMAERR wmarc;
    GUID objId;
    QWORD qwSize;

    if(pInt == NULL)
    {
        return WMAERR_INVALIDARG;
    }

    /* initialize the some state */

    pInt->currPacketOffset = 0;

    pInt->cbCDOffset      = 0;
    pInt->cbCDTitle       = 0;
    pInt->cbCDAuthor      = 0;
    pInt->cbCDCopyright   = 0;
    pInt->cbCDDescription = 0;
    pInt->cbCDRating      = 0;


    /* ASF Header Object */

    wmarc = WMA_LoadHeaderObject(pInt, 0);
    if(wmarc != WMAERR_OK)
    {
        return wmarc;
    }
    pInt->cbFirstPacketOffset = pInt->cbHeader += DATA_OBJECT_SIZE;

    /* Scan Header Objects */

    while(pInt->currPacketOffset < pInt->cbFirstPacketOffset)
    {
        wmarc = WMA_LoadObjectHeader(pInt, &objId, &qwSize);
        if(wmarc != WMAERR_OK)
        {
            return wmarc;
        }

        if(WMA_IsEqualGUID(&CLSID_CAsfMarkerObjectV0, &objId))
        {
            wmarc = WMA_LoadMarkerObject(pInt, qwSize.dwLo, iIndex);
            if(wmarc != WMAERR_OK)
            {
                return wmarc;            
            }
            break;  
        }
        else
        {
            /* skip over this object */
            pInt->currPacketOffset += qwSize.dwLo - MIN_OBJECT_SIZE;
        }
    }

    return WMAERR_OK;
}


/****************************************************************************/
WMAERR
WMA_ParseAsfHeader(tWMAFileHdrStateInternal *pInt,
                   int isFull)
{
    WMAERR wmarc;
    GUID objId;
    QWORD qwSize;

    if(pInt == NULL)
    {
        return WMAERR_INVALIDARG;
    }

    /* initialize the some state */

    pInt->currPacketOffset = 0;

    pInt->cbCDOffset      = 0;
    pInt->cbCDTitle       = 0;
    pInt->cbCDAuthor      = 0;
    pInt->cbCDCopyright   = 0;
    pInt->cbCDDescription = 0;
    pInt->cbCDRating      = 0;

#ifndef WMAAPI_NO_DRM
#ifdef GLOBAL_SECRET

    if(isFull)
    {
        SetSecret_7of7(((tWMAFileStateInternal *)pInt)->pDRM_state);
    }

#endif // GLOBAL_SECRET

#endif /* WMAAPI_NO_DRM */

    /* ASF Header Object */

    wmarc = WMA_LoadHeaderObject(pInt, isFull);
    if(wmarc != WMAERR_OK)
    {
        return wmarc;
    }
    pInt->cbFirstPacketOffset = pInt->cbHeader += DATA_OBJECT_SIZE;

    /* Scan Header Objects */

    while(pInt->currPacketOffset < pInt->cbFirstPacketOffset)
    {
        wmarc = WMA_LoadObjectHeader(pInt, &objId, &qwSize);
        if(wmarc != WMAERR_OK)
        {
            return wmarc;
        }

        if(WMA_IsEqualGUID(&CLSID_CAsfPropertiesObjectV2, &objId))
        {
            wmarc = WMA_LoadPropertiesObject(pInt, qwSize.dwLo,
                                             isFull);
            if(wmarc != WMAERR_OK)
            {
                return wmarc;
            }
        }
        else if( WMA_IsEqualGUID( &CLSID_CAsfStreamPropertiesObjectV1, &objId )
                 || WMA_IsEqualGUID( &CLSID_CAsfStreamPropertiesObjectV2, &objId ) )
        {
            wmarc = WMA_LoadAudioObject(pInt, qwSize.dwLo,
                                        isFull);
            if(wmarc != WMAERR_OK)
            {
                return wmarc;
            }
        }
        else if(WMA_IsEqualGUID(&CLSID_CAsfContentEncryptionObject, &objId))
        {
            wmarc = WMA_LoadEncryptionObject(pInt, qwSize.dwLo);
            if(wmarc != WMAERR_OK)
            {
                return wmarc;
            }
        }
        else if(WMA_IsEqualGUID(&CLSID_CAsfContentDescriptionObjectV0, &objId))
        {
            wmarc = WMA_LoadContentDescriptionObject(pInt, qwSize.dwLo);
            if(wmarc != WMAERR_OK)
            {
                return wmarc;
            }
        }
        else if(WMA_IsEqualGUID(&CLSID_CAsfExtendedContentDescObject, &objId))
        {
            if(isFull) { // only in this case, we parse extended content desc
                wmarc = WMA_LoadExtendedContentDescObject(pInt, qwSize.dwLo);
                if(wmarc != WMAERR_OK) {
                    return wmarc;
                }
            }
            else
			{
				pInt->currPacketOffset += qwSize.dwLo - MIN_OBJECT_SIZE;
				wmarc = WMAERR_OK;
			}
        }
        //else if( 0 && WMA_IsEqualGUID(&CLSID_CAsfMarkerObjectV0, &objId))
        //{
        //   wmarc = WMA_LoadMarkerObject(pInt, qwSize.dwLo);
        //    if(wmarc != WMAERR_OK)
        //    {
        //        return wmarc;
        //    }
        //}
        else if(WMA_IsEqualGUID(&CLSID_CAsfLicenseStoreObject, &objId))
        {
            wmarc = WMA_LoadLicenseStoreObject(pInt, qwSize.dwLo);
            if(wmarc != WMAERR_OK)
            {
                return wmarc;
            }
        }
        else
        {
            /* skip over this object */
            pInt->currPacketOffset += qwSize.dwLo - MIN_OBJECT_SIZE;
        }
    }

    return WMAERR_OK;
}


/****************************************************************************/
static DWORD
GetASFVarField(BYTE bType,
               const BYTE *p,
               DWORD *pcbOffset)
{
    DWORD dwVar = 0;

    switch(bType)
    {
    case 0x01:
        dwVar = (DWORD)(*p);
        *pcbOffset += 1;
        break;
    case 0x02:
        {
            WORD w;
            GetUnalignedWord(p, w);
            dwVar = w;
            *pcbOffset += 2;
            break;
        }
    case 0x03:
        GetUnalignedDword(p, dwVar);
        *pcbOffset += 4;
        break;
    }

    return dwVar;
}




/****************************************************************************/
WMAERR
WMA_ParsePacketHeader(tWMAFileStateInternal *pInt)
{
    BYTE b;
    PACKET_PARSE_INFO_EX *pParseInfoEx;

    BYTE *pData;
    DWORD cbWanted;
    DWORD cbActual;
    DWORD cbLocalOffset=0;

    if(pInt == NULL)
    {
        return WMAERR_INVALIDARG;
    }

    pParseInfoEx = &pInt->ppex;

//    cbWanted = 24;              /* at most */
    
    cbWanted = 1;              /* at least */
    cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                pInt->pCallbackContext,
                                pInt->hdr_parse.currPacketOffset,
                                cbWanted, &pData);


    if(cbActual != cbWanted)
    {
        return WMAERR_BUFFERTOOSMALL;
    }

    /* ParsePacket begins */

    pParseInfoEx->fParityPacket = FALSE;
    pParseInfoEx->cbParseOffset = 0;

//////////////////////////////////////////////////
//    b = pData[pParseInfoEx->cbParseOffset];

    b = pData[cbLocalOffset];
///////////////////////////////////////////////////
    
    pParseInfoEx->fEccPresent = (BOOL)( (b&0x80) == 0x80 );
    pParseInfoEx->bECLen = 0;

    if(pParseInfoEx->fEccPresent)
    {
        if(b&0x10)
        {
            pParseInfoEx->fParityPacket = TRUE;
            return WMAERR_OK;
        }

        if(b&0x60)
        {
            return WMAERR_FAIL;
        }

        pParseInfoEx->bECLen = (b&0x0f);
        if(pParseInfoEx->bECLen != 2)
        {
            return WMAERR_FAIL;
        }

        pParseInfoEx->cbParseOffset = (DWORD)(1 + pParseInfoEx->bECLen);
//////////////////////////////////////////////////////////////////////////////
        cbWanted = 1;              /* at least */
        cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                    pInt->pCallbackContext,
                                    pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,
                                    cbWanted, &pData);

//        b = pData[pParseInfoEx->cbParseOffset];
          b = pData[cbLocalOffset];

//////////////////////////////////////////////////////////////////////////////
    }

    pParseInfoEx->cbPacketLenTypeOffset = pParseInfoEx->cbParseOffset;

    pParseInfoEx->bPacketLenType = (b&0x60)>>5;
    if(pParseInfoEx->bPacketLenType != 0
       && pParseInfoEx->bPacketLenType != 2)
    {
        return WMAERR_FAIL;
    }

    pParseInfoEx->bPadLenType = (b&0x18)>>3;
    if(pParseInfoEx->bPadLenType == 3)
    {
        return WMAERR_FAIL;
    }

    pParseInfoEx->bSequenceLenType = (b&0x06)>>1;

    pParseInfoEx->fMultiPayloads = (BOOL)(b&0x01);

    pParseInfoEx->cbParseOffset++;

//////////////////////////////////////////////////////////////////////////////
        cbWanted = 1;              /* at least */
        cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                    pInt->pCallbackContext,
                                    pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,
                                    cbWanted, &pData);

//        b = pData[pParseInfoEx->cbParseOffset];
          b = pData[cbLocalOffset];

//////////////////////////////////////////////////////////////////////////////

    pParseInfoEx->bOffsetBytes = 4;
    pParseInfoEx->bOffsetLenType = 3;

    if(b != 0x5d)
    {
        if((b&0xc0) != 0x40)
        {
            return WMAERR_FAIL;
        }

        if((b&0x30) != 0x10)
        {
            return WMAERR_FAIL;
        }

        pParseInfoEx->bOffsetLenType = (b&0x0c)>>2;
        if(pParseInfoEx->bOffsetLenType == 0)
        {
            return WMAERR_FAIL;
        }
        else if(pParseInfoEx->bOffsetLenType < 3)
        {
            pParseInfoEx->bOffsetBytes = pParseInfoEx->bOffsetLenType;
        }

        if((b&0x03) != 0x01)
        {
            return WMAERR_FAIL;
        }
    }

    pParseInfoEx->cbParseOffset++;

//////////////////////////////////////////////////////////////////////////////
    pParseInfoEx->cbPacketLenOffset = pParseInfoEx->cbParseOffset; 
    switch(pParseInfoEx->bPacketLenType)
    {
    case 0x01:
        {
            cbWanted =1;
            cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                        pInt->pCallbackContext,
                                        pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,
                                        cbWanted, &pData);
            pParseInfoEx->cbExplicitPacketLength =  (DWORD)(*pData);
            pParseInfoEx->cbParseOffset++;
            break;
        }
    case 0x02:
        {
            WORD w;
            cbWanted =2;
            cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                        pInt->pCallbackContext,
                                        pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,
                                        cbWanted, &pData);
            GetUnalignedWord(pData, w);
            pParseInfoEx->cbExplicitPacketLength =  (DWORD)(w);
            pParseInfoEx->cbParseOffset+=2;
        
            break;

        }
    case 0x03:
        {
            DWORD dw;
            cbWanted =4;
            cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                        pInt->pCallbackContext,
                                        pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,
                                        cbWanted, &pData);
            GetUnalignedDword(pData, dw);
            pParseInfoEx->cbExplicitPacketLength =  dw;
            pParseInfoEx->cbParseOffset+=4;
            break;
        }
    default:
        cbWanted =0;
    }

/*    pParseInfoEx->cbPacketLenOffset = pParseInfoEx->cbParseOffset;
    pParseInfoEx->cbExplicitPacketLength = GetASFVarField(pParseInfoEx->bPacketLenType,
                                                          &pData[pParseInfoEx->cbParseOffset],
                                                          &pParseInfoEx->cbParseOffset);
*/

//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
    pParseInfoEx->cbSequenceOffset = pParseInfoEx->cbParseOffset;
    switch(pParseInfoEx->bSequenceLenType)
    {
    case 0x01:
        {
            cbWanted =1;
            cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                        pInt->pCallbackContext,
                                        pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,
                                        cbWanted, &pData);
            pParseInfoEx->dwSequenceNum =  (DWORD)(*pData);
            pParseInfoEx->cbParseOffset++;
            break;
        }
    case 0x02:
        {
            WORD w;
            cbWanted =2;
            cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                        pInt->pCallbackContext,
                                        pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,
                                        cbWanted, &pData);
            GetUnalignedWord(pData, w);
            pParseInfoEx->dwSequenceNum =  (DWORD)(w);
            pParseInfoEx->cbParseOffset+=2;
        
            break;

        }
    case 0x03:
        {
            DWORD dw;
            cbWanted =4;
            cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                        pInt->pCallbackContext,
                                        pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,
                                        cbWanted, &pData);
            GetUnalignedDword(pData, dw);
            pParseInfoEx->dwSequenceNum =  dw;
            pParseInfoEx->cbParseOffset+=4;
            break;
        }
    default:
        cbWanted =0;
    }

    /*    pParseInfoEx->cbSequenceOffset = pParseInfoEx->cbParseOffset;
    pParseInfoEx->dwSequenceNum = GetASFVarField(pParseInfoEx->bSequenceLenType,
                                                 &pData[pParseInfoEx->cbParseOffset],
                                                 &pParseInfoEx->cbParseOffset);
*/
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////    
    pParseInfoEx->cbPadLenOffset = pParseInfoEx->cbParseOffset;
    switch(pParseInfoEx->bPadLenType)
    {
    case 0x01:
        {
            cbWanted =1;
            cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                        pInt->pCallbackContext,
                                        pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,
                                        cbWanted, &pData);
            pParseInfoEx->cbPadding =  (DWORD)(*pData);
            pParseInfoEx->cbParseOffset++;
            break;
        }
    case 0x02:
        {
            WORD w;
            cbWanted =2;
            cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                        pInt->pCallbackContext,
                                        pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,
                                        cbWanted, &pData);
            GetUnalignedWord(pData, w);
            pParseInfoEx->cbPadding =  (DWORD)(w);
            pParseInfoEx->cbParseOffset+=2;
        
            break;

        }
    case 0x03:
        {
            DWORD dw;
            cbWanted =4;
            cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                        pInt->pCallbackContext,
                                        pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,
                                        cbWanted, &pData);
            GetUnalignedDword(pData, dw);
            pParseInfoEx->cbPadding =  dw;
            pParseInfoEx->cbParseOffset+=4;
            break;
        }
    default:
        cbWanted =0;
    }

    
    
    
    /*    pParseInfoEx->cbPadLenOffset = pParseInfoEx->cbParseOffset;
    pParseInfoEx->cbPadding = GetASFVarField(pParseInfoEx->bPadLenType,
                                             &pData[pParseInfoEx->cbParseOffset],
                                             &pParseInfoEx->cbParseOffset);
*/

/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
// Now read 6 bytes
    
    cbWanted =6;
    cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                pInt->pCallbackContext,
                                 pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,
                                 cbWanted, &pData);
    if(cbActual != cbWanted)
    {
        return WMAERR_BUFFERTOOSMALL;
    }
////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////
    GetUnalignedDword(&pData[cbLocalOffset], pParseInfoEx->dwSCR);
//    GetUnalignedDword(&pData[pParseInfoEx->cbParseOffset], pParseInfoEx->dwSCR);

/////////////////////////////////////////////////////////////////////////////////
    
    pParseInfoEx->cbParseOffset += 4;


//////////////////////////////////////////////////////////////////////////////////
    GetUnalignedWord(&pData[cbLocalOffset+4], pParseInfoEx->wDuration);
    
//    GetUnalignedWord(&pData[pParseInfoEx->cbParseOffset], pParseInfoEx->wDuration);

////////////////////////////////////////////////////////////////////////////////////
    
    pParseInfoEx->cbParseOffset += 2;


    /* ParsePacketEx begins */

    pParseInfoEx->cbPayLenTypeOffset = 0;
    pParseInfoEx->bPayLenType = 0;
    pParseInfoEx->bPayBytes = 0;
    pParseInfoEx->cPayloads = 1;

    if(pParseInfoEx->fMultiPayloads)
    {
//////////////////////////////////////////////////////
        cbWanted =1;
        cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                    pInt->pCallbackContext,
                                     pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,
                                     cbWanted, &pData);
        if(cbActual != cbWanted)
        {
            return WMAERR_BUFFERTOOSMALL;
        }

//        b = pData[pParseInfoEx->cbParseOffset];
        b = pData[cbLocalOffset];
//////////////////////////////////////////////////////
        pParseInfoEx->cbPayLenTypeOffset = pParseInfoEx->cbParseOffset;

        pParseInfoEx->bPayLenType = (b&0xc0)>>6;
        if(pParseInfoEx->bPayLenType != 2
           && pParseInfoEx->bPayLenType != 1)
        {
            return WMAERR_FAIL;
        }

        pParseInfoEx->bPayBytes = pParseInfoEx->bPayLenType;

        pParseInfoEx->cPayloads = (DWORD)(b&0x3f);
        if(pParseInfoEx->cPayloads == 0)
        {
            return WMAERR_FAIL;
        }

        pParseInfoEx->cbParseOffset++;
    }

    return WMAERR_OK;
}


/****************************************************************************/
WMAERR
WMA_ParsePayloadHeader(tWMAFileStateInternal *pInt)
{
    DWORD cbDummy;
    DWORD cbParseOffset;
    DWORD cbRepDataOffset;
    DWORD dwPayloadSize;
    PACKET_PARSE_INFO_EX *pParseInfoEx;
    PAYLOAD_MAP_ENTRY_EX *pPayload;
    DWORD cbLocalOffset=0;

    BYTE *pData;
    DWORD cbWanted;
    DWORD cbActual;
//	BYTE bFrameRate = 0;
	WORD wTotalDataBytes=0;

    if(pInt == NULL)
    {
        return WMAERR_INVALIDARG;
    }

    pParseInfoEx = &pInt->ppex;
    pPayload = &pInt->payload;

//    cbWanted = 24;              /* at most */

    cbWanted = 2;              /* at least */
    cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                pInt->pCallbackContext,
                                pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset,
                                cbWanted, &pData);
    if(cbActual != cbWanted)
    {
        return WMAERR_BUFFERTOOSMALL;
    }

    cbParseOffset = 0;

    /* Loop in ParsePacketAndPayloads */

    pPayload->cbPacketOffset = (WORD)pParseInfoEx->cbParseOffset;
//    pPayload->bStreamId = pData[cbParseOffset];
    pPayload->bStreamId = (pData[cbParseOffset])&0x03; // Amit to get correct Streamid 
    pPayload->bObjectId = pData[cbParseOffset + 1];

    cbDummy = 0;
//////////////////////////////////////////////////////////////////////////////////////
/*    pPayload->cbObjectOffset = GetASFVarField(pParseInfoEx->bOffsetLenType,
                                              &pData[cbParseOffset + 2],
                                              &cbDummy);

  */  switch(pParseInfoEx->bOffsetLenType)
    {
    case 0x01:
        {
            cbWanted =1;
            cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                        pInt->pCallbackContext,
                                        pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset +2,
                                        cbWanted, &pData);
            pPayload->cbObjectOffset =  (DWORD)(*pData);
            break;
        }
    case 0x02:
        {
            WORD w;
            cbWanted =2;
            cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                        pInt->pCallbackContext,
                                        pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset+2,
                                        cbWanted, &pData);
            GetUnalignedWord(pData, w);
            pPayload->cbObjectOffset =  (DWORD)(w);
        
            break;

        }
    case 0x03:
        {
            DWORD dw;
            cbWanted =4;
            cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                        pInt->pCallbackContext,
                                        pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset +2,
                                        cbWanted, &pData);
            GetUnalignedDword(pData, dw);
            pPayload->cbObjectOffset =  dw;
            break;
        }
    default:
        cbWanted =0;
    }

//////////////////////////////////////////////////////////////////////////////////////

    cbRepDataOffset = cbParseOffset + 2 + pParseInfoEx->bOffsetBytes;

///////////////////////////////////////////////////////////////////////////////////////

    cbWanted =1;
    cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                pInt->pCallbackContext,
                                pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset + cbRepDataOffset,
                                cbWanted, &pData);

//    pPayload->cbRepData = pData[cbRepDataOffset];
    pPayload->cbRepData = pData[cbLocalOffset];

///////////////////////////////////////////////////////////////////////////////////////
    pPayload->msObjectPres = 0xffffffff;

    if(pPayload->cbRepData == 1)
    {
        pPayload->msObjectPres = pPayload->cbObjectOffset;
        pPayload->cbObjectOffset = 0;
        pPayload->cbObjectSize = 0;
        pPayload->bIsCompressedPayload =1;
///////////////////////////////////////////////////////////////////////////////////////

        cbWanted =3;
        cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                    pInt->pCallbackContext,
                                pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset + cbRepDataOffset +1,
                                cbWanted, &pData);

/********************Amit to take care of compressed payload**************************/
//       if(pData[cbRepDataOffset +1] >0)
       if(pData[cbLocalOffset] >0)
//			bFrameRate = 1000/pData[cbRepDataOffset +1];
		

///////////////////////////////////////////////////////////////////////////////////////
		if( pParseInfoEx->fMultiPayloads)
		{
			//GetUnalignedWord( &pData[ cbRepDataOffset + 2 ],wTotalDataBytes ); // changed by amit
            GetUnalignedWord( &pData[ cbLocalOffset + 1 ],wTotalDataBytes );
		}
		else
		{
			wTotalDataBytes = 0; //pData[ cbRepDataOffset + 2 ];
		}
/********************End of Amit to take care of compressed payload**************************/
    }
    else if(pPayload->cbRepData >= 8)
    {
///////////////////////////////////////////////////////////////////////////////////////

        cbWanted =8;
        cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                    pInt->pCallbackContext,
                                pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset + cbRepDataOffset +1,
                                cbWanted, &pData);
        GetUnalignedDword(&pData[cbLocalOffset],
                          pPayload->cbObjectSize);
        GetUnalignedDword(&pData[cbLocalOffset+ 4],
                          pPayload->msObjectPres);

        
/*        GetUnalignedDword(&pData[cbRepDataOffset + 1],
                          pPayload->cbObjectSize);
        GetUnalignedDword(&pData[cbRepDataOffset + 1 + 4],
                          pPayload->msObjectPres);
*/
//////////////////////////////////////////////////////////////////////////////////////////        
        pPayload->bIsCompressedPayload =0;
    }

    pPayload->cbTotalSize = 1 + 1 + pParseInfoEx->bOffsetBytes + 1 + pPayload->cbRepData;

    if(pParseInfoEx->fMultiPayloads)
    {
        cbDummy = 0;

//////////////////////////////////////////////////////////////////////////////////////
      /*  dwPayloadSize = GetASFVarField(pParseInfoEx->bPayLenType,
                                       &pData[cbParseOffset + pPayload->cbTotalSize],
                                       &cbDummy);
*/
        switch(pParseInfoEx->bPayLenType)
        {
        case 0x01:
            {
                cbWanted =1;
                cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                            pInt->pCallbackContext,
                                            pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset +pPayload->cbTotalSize,
                                            cbWanted, &pData);
                dwPayloadSize =  (DWORD)(*pData);
                break;
            }
        case 0x02:
            {
                WORD w;
                cbWanted =2;
                cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                            pInt->pCallbackContext,
                                            pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset+pPayload->cbTotalSize,
                                            cbWanted, &pData);
                GetUnalignedWord(pData, w);
                dwPayloadSize =  (DWORD)(w);
        
                break;

            }
        case 0x03:
            {
                DWORD dw;
                cbWanted =4;
                cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                            pInt->pCallbackContext,
                                            pInt->hdr_parse.currPacketOffset + pParseInfoEx->cbParseOffset + pPayload->cbTotalSize,
                                            cbWanted, &pData);
                GetUnalignedDword(pData, dw);
                dwPayloadSize =  dw;
                break;
            }
        default:
            cbWanted =0;
        }

//////////////////////////////////////////////////////////////////////////////////////

    
    }
    else if(pParseInfoEx->cbExplicitPacketLength > 0)
    {
        dwPayloadSize = pParseInfoEx->cbExplicitPacketLength
                      - pParseInfoEx->cbParseOffset
                      - pPayload->cbTotalSize
                      - pParseInfoEx->cbPadding;
    }
    else
    {
        dwPayloadSize = pInt->hdr_parse.cbPacketSize
                      - pParseInfoEx->cbParseOffset
                      - pPayload->cbTotalSize
                      - pParseInfoEx->cbPadding;
    }
    if (0 == wTotalDataBytes)
        wTotalDataBytes = (WORD) dwPayloadSize;

    pPayload->cbPayloadSize = (WORD)dwPayloadSize;

    pPayload->cbTotalSize += pParseInfoEx->bPayBytes
                          + (WORD)pPayload->cbPayloadSize;

 	pPayload->wTotalDataBytes = wTotalDataBytes; // Amit

/*    if( 1 == pPayload->cbRepData )
    {
        pPayload->cbPayloadSize--;
    }
*/
    pParseInfoEx->cbParseOffset += pPayload->cbTotalSize;

    if(pParseInfoEx->cbParseOffset > pInt->hdr_parse.cbPacketSize
       || (pParseInfoEx->cbParseOffset == pInt->hdr_parse.cbPacketSize
           && pInt->iPayload < pParseInfoEx->cPayloads - 1))
    {
        return WMAERR_CORRUPTDATA;
    }

    return WMAERR_OK;
}

//
//  Routines for byte-swapping the members of various structs
//

#ifdef BIG_ENDIAN

void ByteSwapWaveFormatEx( WAVEFORMATEX& dst )
{
	// swap the struct elements
	SWAP_WORD( dst.wFormatTag );
	SWAP_WORD( dst.nChannels );
	SWAP_DWORD( dst.nSamplesPerSec );
	SWAP_DWORD( dst.nAvgBytesPerSec );
	SWAP_WORD( dst.nBlockAlign );
	SWAP_WORD( dst.wBitsPerSample );
	SWAP_WORD( dst.cbSize );
}

void ByteSwapAsfXAcmAudioErrorMaskingData( AsfXAcmAudioErrorMaskingData& dst )
{
	// swap the struct elements
	SWAP_WORD( dst.virtualPacketLen );
	SWAP_WORD( dst.virtualChunkLen );
	SWAP_WORD( dst.silenceLen );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\x86\nspalloc.h ===
/*M*
//
//               INTEL CORPORATION PROPRIETARY INFORMATION
//  This software is supplied under the terms of a license agreement or
//  nondisclosure agreement with Intel Corporation and may not be copied
//  or disclosed except in accordance with the terms of that agreement.
//        Copyright (c) 1995 Intel Corporation. All Rights Reserved.
//
//      $Workfile: nspalloc.h $
//      $Revision: 3 $
//      $Modtime: 9/11/99 4:22p $
//
//  Purpose: NSP 32 bytes aligned allocator/deallocator
//
*M*/

#if !defined(_NSPALLOC_H) || defined (_OWN_BLDPCS)
#define _NSPALLOC_H

#ifdef __cplusplus
extern "C" {
#endif

NSPAPI(void*,  nspMalloc, (int length))
NSPAPI(float*, nspsMalloc,(int length))
NSPAPI(double*,nspdMalloc,(int length))
NSPAPI(SCplx*, nspcMalloc,(int length))
NSPAPI(DCplx*, nspzMalloc,(int length))
NSPAPI(short*, nspwMalloc,(int length))
NSPAPI(WCplx*, nspvMalloc,(int length))
NSPAPI(long*,  nspiMalloc,(int length))
NSPAPI(ICplx*, nspjMalloc,(int length))

NSPAPI(void,   nspFree,   (void* ptr ))
#ifdef __cplusplus
 }
#endif
#endif                                  /* _NSPALLOC_H                     */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\x86\nsp.h ===
/*M*
//
//               INTEL CORPORATION PROPRIETARY INFORMATION
//  This software is supplied under the terms of a license agreement or
//  nondisclosure agreement with Intel Corporation and may not be copied
//  or disclosed except in accordance with the terms of that agreement.
//        Copyright (c) 1995 Intel Corporation. All Rights Reserved.
//
//      $Workfile: nsp.h $
//      $Revision: 4 $
//      $Modtime: 9/11/99 4:16p $
//
//  Purpose: NSP Common Header file
*M*/

#if !defined (_NSP_H)
#if defined (__BORLANDC__)
#include "nsppatch.h"
#endif

#define _NSP_H

#include "nspwarn.h"

/* ======================================================================== */



/* ---------------------------- Definitions ------------------------------- */

#if !defined (_OWN_BLDPCS)

#define  NSP_EPS   (1.0E-12)
#define  NSP_PI    (3.14159265358979324)     /* Standard C not support M_PI */
#define  NSP_2PI   (6.28318530717958648)
#define  NSP_PI_2  (1.57079632679489662)
#define  NSP_PI_4  (0.785398163397448310)

#define  NSP_DegToRad(deg)  ((deg)/180.0 * NSP_PI)

#define  NSPsDegToRad(deg)  ((float) ((deg)/180.0 * NSP_PI))
#define  NSPdDegToRad(deg)  ((double)((deg)/180.0 * NSP_PI))

#define  MAX(a,b)  (((a) > (b)) ? (a) : (b))
#define  MIN(a,b)  (((a) < (b)) ? (a) : (b))

#if !defined (FALSE)
#define  FALSE  0
#define  TRUE   1
#endif


/* --------------------------- Common Types ------------------------------- */

  typedef int    NSPStatus;


  typedef struct _SCplx {
    float        re;
    float        im;
  } SCplx;

  typedef struct _DCplx {
    double        re;
    double        im;
  } DCplx;

  typedef struct _WCplx {
    short         re;
    short         im;
  } WCplx;

  typedef struct _ICplx {
    int         re;
    int         im;
  } ICplx;

static const SCplx  SCplxZero = {0,0};
static const DCplx  DCplxZero = {(double)0.0,(double)0.0};
static const WCplx  WCplxZero = {(short) 0,  (short) 0};
static const ICplx  ICplxZero = {(int)0,(int)0};

static const SCplx SCplxOneZero = {1,0};
static const DCplx DCplxOneZero = {(double)1.0,(double)0.0};
static const WCplx WCplxOneOne  = {(short) 1,  (short) 1};
static const ICplx ICplxOneOne  = {(int)1,(int)1};
static const SCplx SCplxOneOne  = {(float) 1.0,(float) 1.0};
static const DCplx DCplxOneOne  = {(double)1.0,(double)1.0};


/* ======================================================================== */

#endif                                                            /* _NSP_H */
#endif                                                            /* PCS    */

#ifdef __cplusplus
extern "C" {
#endif

#if defined( _WIN32 ) && !defined( __GNUC__ )
#define __STDCALL __stdcall
#define __CDECL __cdecl
#define __INT64 __int64
#else
#define __STDCALL
#define __CDECL
#define __INT64 long long 
#endif


#if !defined (NSPAPI)
# if !defined(NSP_W32DLL)
#  define NSPAPI(type,name,arg) extern    type __STDCALL name arg;
# elif defined (__BORLANDC__)
#  define NSPAPI(type,name,arg) extern  type _import __STDCALL name arg;
# else
#   if defined (_WIN32)
#      define NSPAPI(type,name,arg) extern  __declspec(dllimport) type __STDCALL name arg;
#   elif defined (linux)
#      define NSPAPI(type,name,arg) extern type name arg;
#   endif
# endif
#endif

/* ---------------------- NSP Library Control Symbols -----------------------

nsp_UsesVector:     vector/scalar Zero,Set,Copy,Add,Sub,Mpy,Div,Conj
                    b<,Inv>Tresh<1,2>,bAbs<1,2>,bAdd<2,3>,bExp<1,2>,bLn<1,2>,
                    bMpy<2,3>, bSqr<1,2>, bSqrt<1,2>, Max, Maxext, Min, Minext
                    Mean, StDev
                    Dotprod, Dotprodext,
                    bConj<,Extend><1,2>, bConjFlip2
                    b<Mu,A>LawToLin, bLinTo<Mu,A>Law
                    AutoCorr<Biased,Unbiased>, CrossCorr,
                    Norm, Normext, Normalize, bDiv<1,2,3>
                    <Up,Down>Sample,bArctan<1,2>

nsp_UsesConversion: bImag, bReal, bCplxTo2Real, b2RealToCplx,
                    b<,r>Mag, b<,rPhase>,
                    bFloatTo<Int,Fix,S31Fix,S15Fix,S7Fix,S1516Fix>,
                    b<Int,Fix,S31Fix,S15Fix,S7Fix,S1516Fix>ToFloat,
                    b<,r>CartToPolar, b<,r>PolarToCart

nsp_UsesConvolution:Conv
                    Conv2D
                    Filter2D

nsp_UsesDct:        Dct

nsp_UsesTransform:  Dft
                    Fft<,Nip>, <Real,Ccs>Fftl<,Nip>, MpyRC<Perm,Pack><2,3>
                    <Real,Ccs><,2>Fft<,Nip>
                    Goertz

nsp_UsesFir:        struct FirState,FirInit<,Mr>,FirFree,Fir<Get,Set><Taps,Dlyl>
                    struct Fir<Taps|Dly>State, 
                    FirlInit<,Mr,Dlyl>, Firl, Firl<Get,Set><Taps,Dlyl>,
                    

nsp_UsesFirGen:     nspdFirLowpass, nspdFirHighpass, nspdFirBandpass 
                    nspdFirBandstop 
                        

nsp_UsesIir:        struct Iir<Tap,Dly>State, IirlInit<,Bq,Dlyl>, Iirl
                    struct Iir<Tap,Dly>State, IirInit<,Bq>, Iir, IirFree

nsp_UsesLms:        struct Lms<Tap,Dly>State, LmslInit<,Mr,Dlyl>,
                    Lmsl<Get,Set><Step,Leak>, Lmsl<,Na>

nsp_UsesMedian      MedianFilter1,MedianFilter2

nsp_UsesMisc:       BitRevTbl,BitRev,
                    TwdTbl

nsp_UsesSampleGen:  struct ToneState, ToneInit, Tone
                    struct TrnglState, TrnglInit, Trngl
                    bRandUni, RandUni, RandUniInit
                    bRandGauss, RandGauss, RandGausInit

nsp_UsesWin:        Win<Bartlett,Hann,Hamming,Blackman<,Std,Opt>,Kaiser>

nsp_UsesWavelet:    WtInit, WtInitLen, WtSetState, WtGetState,
                    WtDecompose, WtReconstruct */


/* ---------------------------- NSP Library Parts ------------------------- */

#if defined (nsp_UsesAll) || defined (nsp_UsesConvolution)
# include  "nspconv.h"
# include  "nspcnv2d.h"
# include  "nspfir2.h"
#endif

#if defined (nsp_UsesAll) || defined (nsp_UsesConversion)
# include  "nspcvrt.h"
#endif

#if defined (nsp_UsesAll) || defined (nsp_UsesDct)
# include "nspdct.h"
#endif

#if defined (nsp_UsesAll) || defined (nsp_UsesFir)
# include  "nspfirl.h"
# include  "nspfirh.h"
#endif

#if defined (nsp_UsesAll) || defined (nsp_UsesFirGen)
# include  "nspfirg.h"
#endif

#if defined (nsp_UsesAll) || defined (nsp_UsesIir)
# include  "nspiirl.h"
# include  "nspiirh.h"
#endif

#if defined (nsp_UsesAll) || defined (nsp_UsesLms)
# include  "nsplmsl.h"
# include  "nsplmsh.h"
#endif

#if defined (nsp_UsesAll) || defined (nsp_UsesMedian)
# include  "nspmed.h"
#endif

#if defined (nsp_UsesAll) || defined (nsp_UsesMisc)
# include  "nspmisc.h"
#endif

#if defined (nsp_UsesAll) || defined (nsp_UsesSampleGen)
# include  "nsprand.h"
# include  "nsptone.h"
# include  "nsptrngl.h"
#endif

#if defined (nsp_UsesAll) || defined (nsp_UsesTransform)
# include  "nspfft.h"
# include  "nspgrtzl.h"
# include  "nspgrtzw.h"
#endif

#if defined (nsp_UsesAll) || defined (nsp_UsesVector)
# include  "nsparith.h"
# include  "nspcorr.h"
# include  "nsplaw.h"
# include  "nsplnexp.h"
# include  "nspsampl.h"
# include  "nspfirh.h"
# include  "nspfirl.h"
# include  "nspfirg.h"
# include  "nsprsmpl.h"
# include  "nspvec.h"
# include  "nspdotp.h"
# include  "nspnorm.h"
# include  "nsplogic.h"
# include  "nspdiv.h"
# include  "nspatan.h"
#endif

#if defined (nsp_UsesAll) || defined (nsp_UsesWin)
# include  "nspwin.h"
#endif

#if defined (nsp_UsesAll) || defined (nsp_UsesWavelet)
# include  "nspwlt.h"
#endif

#include "nsperror.h"
#include "nspalloc.h"

/* ------------------------------------------------------------------------ */

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\x86\nsperror.h ===
/*M*
//
//               INTEL CORPORATION PROPRIETARY INFORMATION
//  This software is supplied under the terms of a license agreement or
//  nondisclosure agreement with Intel Corporation and may not be copied
//  or disclosed except in accordance with the terms of that agreement.
//        Copyright (c) 1995 Intel Corporation. All Rights Reserved.
//
//      $Workfile: nsperror.h $
//      $Revision: 3 $
//      $Modtime: Dec 16 1996 18:31:22 $
//
//  Purpose: NSP Error Handling Module
*M*/
#ifdef __cplusplus
extern "C" {
#endif

#if !defined (_NSPERROR_H) || defined (_OWN_BLDPCS)
    #define _NSPERROR_H

/* ------------------------------------------------------------------------*/

    #if !defined (_OWN_BLDPCS)

    typedef struct _NSPLibVersion
        {
        int    major;                   /* e.g. 3                          */
        int    minor;                   /* e.g. 00                         */
        int    build;                   /* e.g. 11                         */
        const char * Name;                    /* e.g. "nspp6l.lib","nspm5.dll"   */
        const char * Version;                 /* e.g. "v4.00"                    */
        const char * InternalVersion;         /* e.g. "[3.00.11, 07/12/96]"      */
        const char * BuildDate;               /* e.g. "Jun 1 96"                 */
        const char * CallConv;                /* e.g. "DLL",..                   */
        } NSPLibVersion;

/*--- NSPErrStatus,NSPErrMode Values Definition ---------------------------*/

/* common status code definitions */

        #define NSP_StsOk             0         /* everything is ok                */
        #define NSP_StsBackTrace     -1         /* pseudo error for back trace     */
        #define NSP_StsError         -2         /* unknown /unspecified error      */
        #define NSP_StsInternal      -3         /* internal error (bad state)      */
        #define NSP_StsNoMem         -4         /* out of memory                   */
        #define NSP_StsBadArg        -5         /* function arg/param is bad       */
        #define NSP_StsBadFunc       -6         /* unsupported function            */
        #define NSP_StsNoConv        -7         /* iter. didn't converge           */
        #define NSP_StsAutoTrace     -8         /* Tracing through nsptrace.h      */
        #define NSP_StsDivideByZero  -9
        #define NSP_StsNullPtr       -10
        #define NSP_StsBadSizeValue  -11
        #define NSP_StsBadPtr        -12
        #define NSP_StsBadStruct     -13
        #define NSP_StsBadLen        -14         /* bad vector length              */          

        #define NSP_ErrModeLeaf     0           /* Print error and exit program    */
        #define NSP_ErrModeParent   1           /* Print error and continue        */
        #define NSP_ErrModeSilent   2           /* Don't print and continue        */

/* custom status code definitions */
    /* nspsmpl */
        #define NSP_StsBadFact       -50        /* Negative FactorRange            */
    /* nspfirg */
        #define NSP_StsBadFreq       -51        /* bad frequency value             */
        #define NSP_StsBadRel        -52        /* bad relation between frequency  */ 



    typedef int (__STDCALL *NSPErrorCallBack)  (NSPStatus status,
                                                const char *funcname, const char *context,
                                                const char *file, int   line);

/* ------------------------------------------------------------------------*/
/* Flags for scaleMode parameter of nsp?Func(...,scaleMode,scaleFactor)    */

        #define NSP_NO_SCALE        0x0000      /* ignore factor                   */
        #define NSP_FIXED_SCALE     0x0002      /* fixed factor value              */
        #define NSP_AUTO_SCALE      0x0004      /* detect factor value             */

        #define NSP_OVERFLOW        0x0000      /* wrapround                       */
        #define NSP_SATURATE        0x0001      /* saturate                        */

/*--- Macros --------------------------------------------------------------*/

        #define NSP_ERROR(status,func,context)\
nspError((status),(func),(context),__FILE__,__LINE__)

        #define NSP_ERRCHK(func,context)\
   ((nspGetErrStatus() >= 0) ? NSP_StsOk \
: NSP_ERROR(NSP_StsBackTrace,(func),(context)))

        #define NSP_ASSERT(expr,func,context)\
   ((expr) ? NSP_StsOk \
: NSP_ERROR(NSP_StsInternal,(func),(context)))

        #define NSP_RSTERR() (nspSetErrStatus(NSP_StsOk))


    #endif
/*--- Get Library Version -------------------------------------------------*/
/* Returns pointer to NSP lib info structure                               */

    NSPAPI(const NSPLibVersion *,nspGetLibVersion,(void))

/*--- Get/Set ErrStatus ---------------------------------------------------*/

    NSPAPI(NSPStatus, nspGetErrStatus,(void))
    NSPAPI(void,      nspSetErrStatus,(NSPStatus status))

/*--- NspStdErrMode Declaration -------------------------------------------*/

    NSPAPI(int,  nspGetErrMode,(void))
    NSPAPI(void, nspSetErrMode,(int mode))

/*--- nspError,nspErrorStr Declaration ------------------------------------*/

    NSPAPI(NSPStatus,   nspError,(NSPStatus status, const char *func,
                                  const char *context, const char *file,int line))

    NSPAPI(const char*, nspErrorStr,(NSPStatus status))

/*--- nspRedirectError Declaration ----------------------------------------*/

    NSPAPI(NSPStatus, nspNulDevReport,(NSPStatus   status, const char *funcname,
                                       const char *context,const char *file,
                                       int   line))

    NSPAPI(NSPStatus, nspStdErrReport,(NSPStatus   status, const char *funcname,
                                       const char *context,const char *file,
                                       int   line))

    #if defined _WIN32   /* _WIN32 */
    NSPAPI(NSPStatus, nspGuiBoxReport,(NSPStatus   status, const char *funcname,
                                       const char *context,const char *file,
                                       int   line))
    #endif               /* _WIN32 */

    NSPAPI(NSPErrorCallBack, nspRedirectError,(NSPErrorCallBack nspErrorFunc))

#endif                                  /* _NSPERROR_H                     */
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\x86\nspfft.h ===
/*M*
//
//               INTEL CORPORATION PROPRIETARY INFORMATION
//  This software is supplied under the terms of a license agreement or
//  nondisclosure agreement with Intel Corporation and may not be copied
//  or disclosed except in accordance with the terms of that agreement.
//        Copyright (c) 1996 Intel Corporation. All Rights Reserved.
//
//      $Workfile: nspfft.h $
//      $Revision: 3 $
//      $Modtime: Dec 16 1996 17:47:06  $
//
//  Purpose: NSP Fourier Transforms 
*M*/
#ifdef __cplusplus
extern "C" {
#endif
#if !defined (_NSPFFT_H) || defined (_OWN_BLDPCS)

    #define _NSPFFT_H

/* ======================================================================== */

    #if !defined (_OWN_BLDPCS)

        #define  NSP_Forw              1
        #define  NSP_Inv               2
        #define  NSP_Init              4
        #define  NSP_Free              8
        #define  NSP_NoScale          16
        #define  NSP_NoBitRev         32
        #define  NSP_InBitRev         64
        #define  NSP_OutBitRev       128
        #define  NSP_OutRCPack       256
        #define  NSP_OutRCPerm       512
        #define  NSP_InRCPack       1024
        #define  NSP_InRCPerm       4096
        #define  NSP_DoIntCore      8192
        #define  NSP_DoFloatCore   16384
        #define  NSP_DoFastMMX     32768

    #endif

/* ------------------------------------------------------------------------ */
/*                                                                          */
/*                                  Dft                                     */
/*                                                                          */
/* Compute the forward  or inverse discrete Fourier transform  (DFT)        */
/* of a complex signal.                                                     */
/*                                                                          */
/* ------------------------------------------------------------------------ */

    NSPAPI(void,nspvDft,(const WCplx *inSamps,  WCplx  *outSamps,
                         int    length,   int     flags,
                         int    scaleMode,int    *scaleFactor))
    NSPAPI(void,nspcDft,(const SCplx *inSamps,  SCplx *outSamps,
                         int    length,   int    flags))
    NSPAPI(void,nspzDft,(const DCplx *inSamps,  DCplx *outSamps,
                         int    length,   int    flags))

/* ------------------------------------------------------------------------ */
/*                                                                          */
/*                                  Fft                                     */
/*                                                                          */
/* Compute  the forward  or inverse   fast Fourier  transform (FFT)         */
/* of a complex signal.                                                     */
/*                                                                          */
/* ------------------------------------------------------------------------ */

    NSPAPI(void,nspvFft,(WCplx  *samps, int order, int flags,
                         int     scaleMode,        int *scaleFactor))

    NSPAPI(void,nspcFft,(SCplx  *samps, int order, int flags))
    NSPAPI(void,nspzFft,(DCplx  *samps, int order, int flags))


    NSPAPI(void,nspvFftNip,(const WCplx *inSamps,  WCplx  *outSamps,
                            int    order,    int     flags,
                            int    scaleMode,int   *scaleFactor))

    NSPAPI(void,nspcFftNip,(const SCplx *inSamps,  SCplx  *outSamps,
                            int    order,    int     flags))

    NSPAPI(void,nspzFftNip,(const DCplx *inSamps,  DCplx  *outSamps,
                            int    order,    int     flags))


    NSPAPI(void,nspvrFft,(short  *reSamps, short  *imSamps, int order, int flags,
                          int    scaleMode,int    *scaleFactor))

    NSPAPI(void,nspcrFft,(float  *reSamps, float  *imSamps, int order, int flags))

    NSPAPI(void,nspzrFft,(double *reSamps, double *imSamps, int order, int flags))


    NSPAPI(void,nspvrFftNip,(const short *reInSamps,  const short *imInSamps,
                             short *reOutSamps,       short *imOutSamps,
                             int    order,            int    flags,
                             int    scaleMode,        int   *scaleFactor))

    NSPAPI(void,nspcrFftNip,(const float  *reInSamps, const float  *imInSamps,
                             float  *reOutSamps,      float  *imOutSamps,
                             int     order,           int     flags))

    NSPAPI(void,nspzrFftNip,(const double *reInSamps, const double *imInSamps,
                             double *reOutSamps,      double *imOutSamps,
                             int     order,           int     flags))

/* ------------------------------------------------------------------------ */
/*                                                                          */
/*                         RealFftl, RealFftlNip                            */
/*                                                                          */
/* Compute the  forward or inverse FFT  of a real signal  using RCPack or   */
/* RCPerm format.                                                           */
/*                                                                          */
/* ------------------------------------------------------------------------ */

    NSPAPI(void,nspwRealFftl,(short  *samps, int order, int  flags,
                              int     scaleMode,        int *scaleFactor))

    NSPAPI(void,nspsRealFftl,(float  *samps, int order, int  flags))

    NSPAPI(void,nspdRealFftl,(double *samps, int order, int  flags))


    NSPAPI(void,nspwRealFftlNip,(const short  *inSamps,  short  *outSamps,
                                 int     order,    int     flags,
                                 int     scaleMode,int    *scaleFactor))

    NSPAPI(void,nspsRealFftlNip,(const float  *inSamps,  float  *outSamps,
                                 int     order,    int     flags))

    NSPAPI(void,nspdRealFftlNip,(const double *inSamps,  double *outSamps,
                                 int     order,    int     flags))

/* ------------------------------------------------------------------------ */
/*                                                                          */
/*                            CcsFftl, CcsFftlNip                           */
/*                                                                          */
/* Compute the  forward or inverse  FFT of a  complex conjugate-symmetric   */
/* (CCS) signal using RCPack or RCPerm format.                              */
/*                                                                          */
/* ------------------------------------------------------------------------ */

    NSPAPI(void,nspwCcsFftl,(short  *samps,    int  order, int flags,
                             int     scaleMode,int *scaleFactor))

    NSPAPI(void,nspsCcsFftl,(float  *samps,    int  order, int flags))

    NSPAPI(void,nspdCcsFftl,(double *samps,    int  order, int flags))


    NSPAPI(void,nspwCcsFftlNip,(const short *inSamps,  short  *outSamps,
                                int    order,    int     flags,
                                int    scaleMode,int    *scaleFactor))

    NSPAPI(void,nspsCcsFftlNip,(const float  *inSamps, float  *outSamps,
                                int     order,   int     flags))

    NSPAPI(void,nspdCcsFftlNip,(const double *inSamps, double *outSamps,
                                int     order,   int     flags))

/* ------------------------------------------------------------------------ */
/*                                                                          */
/*                       MpyRCPack2, MpyRCPack3                             */
/*                                                                          */
/* Multiply two vectors stored in RCPack format.                            */
/*                                                                          */
/* ------------------------------------------------------------------------ */

    NSPAPI(void,nspwMpyRCPack2,(const short *src,  short  *dst, int order,
                                int    scaleMode,         int *scaleFactor))

    NSPAPI(void,nspsMpyRCPack2,(const float  *src, float  *dst, int order))

    NSPAPI(void,nspdMpyRCPack2,(const double *src, double *dst, int order))


    NSPAPI(void,nspwMpyRCPack3,(const short  *srcA,const short  *srcB,short  *dst,
                                int     order,
                                int     scaleMode, int    *scaleFactor))

    NSPAPI(void,nspsMpyRCPack3,(const float  *srcA,const float  *srcB,float  *dst,
                                int     order))

    NSPAPI(void,nspdMpyRCPack3,(const double *srcA,const double *srcB,double *dst,
                                int     order))

/* ------------------------------------------------------------------------ */
/*                                                                          */
/*                        MpyRCPerm2, MpyRCPerm3                            */
/*                                                                          */
/* Multiply two vectors stored in RCPerm format.                            */
/*                                                                          */
/* ------------------------------------------------------------------------ */

    NSPAPI(void,nspwMpyRCPerm2,(const short  *src, short  *dst, int order,
                                int     scaleMode,        int *scaleFactor))

    NSPAPI(void,nspsMpyRCPerm2,(const float  *src, float  *dst, int order))

    NSPAPI(void,nspdMpyRCPerm2,(const double *src, double *dst, int order))


    NSPAPI(void,nspwMpyRCPerm3,(const short  *srcA,const short  *srcB,short  *dst,
                                int     order,
                                int     scaleMode, int    *scaleFactor))

    NSPAPI(void,nspsMpyRCPerm3,(const float  *srcA,const float  *srcB,float  *dst,
                                int     order))

    NSPAPI(void,nspdMpyRCPerm3,(const double *srcA,const double *srcB,double *dst,
                                int     order))
/* ------------------------------------------------------------------------ */
/*                                                                          */
/*                        RealFft,  RealFftNip                              */
/*                                                                          */
/* Compute the forward or inverse FFT of a real signal.                     */
/*                                                                          */
/* ------------------------------------------------------------------------ */

    NSPAPI(void,nspwRealFft,(short  *samps, int order,  int  flags,
                             int     scaleMode,         int *scaleFactor))

    NSPAPI(void,nspsRealFft,(float  *samps, int order,  int  flags))
    NSPAPI(void,nspdRealFft,(double *samps, int order,  int  flags))


    NSPAPI(void,nspwRealFftNip,(const short  *inSamps,  WCplx *outSamps,
                                int     order,    int    flags,
                                int     scaleMode,int   *scaleFactor))

    NSPAPI(void,nspsRealFftNip,(const float  *inSamps,  SCplx *outSamps,
                                int     order,    int    flags))

    NSPAPI(void,nspdRealFftNip,(const double *inSamps,  DCplx *outSamps,
                                int     order,    int    flags))

/* ------------------------------------------------------------------------ */
/*                                                                          */
/*                            CcsFft, CcsFftNip                             */
/*                                                                          */
/* Compute the  forward or inverse  FFT of a  complex conjugate-symmetric   */
/* (CCS) signal.                                                            */
/*                                                                          */
/* ------------------------------------------------------------------------ */

    NSPAPI(void,nspwCcsFft,(short  *samps, int order, int flags,
                            int     scaleMode,        int *scaleFactor))

    NSPAPI(void,nspsCcsFft,(float  *samps, int order, int flags))
    NSPAPI(void,nspdCcsFft,(double *samps, int order, int flags))


    NSPAPI(void,nspwCcsFftNip,(const WCplx *inSamps,  short *outSamps,
                               int    order,    int    flags,
                               int    scaleMode,int   *scaleFactor))

    NSPAPI(void,nspsCcsFftNip,(const SCplx *inSamps, float  *outSamps,
                               int    order,   int     flags))

    NSPAPI(void,nspdCcsFftNip,(const DCplx *inSamps, double *outSamps,
                               int    order,   int     flags))

/* ------------------------------------------------------------------------ */
/*                                                                          */
/*                    nsp?Real2Fft, nsp?Real2FftNip                         */
/*                                                                          */
/* Compute the forward or inverse FFT of two real signals.                  */
/*                                                                          */
/* ------------------------------------------------------------------------ */

    NSPAPI(void,nspwReal2Fft,(short *xSamps, short *ySamps, int order, int flags,
                              int scaleMode, int *scaleFactor))

    NSPAPI(void,nspsReal2Fft,(float *xSamps, float *ySamps, int order, int flags))

    NSPAPI(void,nspdReal2Fft,(double *xSamps, double *ySamps, int order, int flags))


    NSPAPI(void,nspwReal2FftNip,(const short *xInSamps, WCplx  *xOutSamps,
                                 const short *yInSamps, WCplx  *yOutSamps,
                                 int order, int flags,
                                 int scaleMode, int *scaleFactor))

    NSPAPI(void,nspsReal2FftNip,(const float *xInSamps, SCplx  *xOutSamps,
                                 const float *yInSamps, SCplx  *yOutSamps,
                                 int order, int flags))

    NSPAPI(void,nspdReal2FftNip,(const double *xInSamps, DCplx *xOutSamps,
                                 const double *yInSamps, DCplx *yOutSamps,
                                 int order, int flags))

/* ------------------------------------------------------------------------ */
/*                                                                          */
/*                    nsp?Ccs2Fft, nsp?Ccs2FftNip                           */
/*                                                                          */
/* Compute the forward or reverse  FFT of two complex conjugate-symmetric   */
/* (CCS) signals.                                                           */
/*                                                                          */
/* ------------------------------------------------------------------------ */

    NSPAPI(void,nspwCcs2Fft,(short  *xSamps, short  *ySamps, int order,int flags,
                             int     scaleMode, int *scaleFactor))

    NSPAPI(void,nspsCcs2Fft,(float  *xSamps, float  *ySamps, int order,int flags))

    NSPAPI(void,nspdCcs2Fft,(double *xSamps, double *ySamps, int order,int flags))


    NSPAPI(void,nspwCcs2FftNip,(const WCplx *xInSamps, short  *xOutSamps,
                                const WCplx *yInSamps, short  *yOutSamps,
                                int order, int flags,
                                int scaleMode, int *scaleFactor))

    NSPAPI(void,nspsCcs2FftNip,(const SCplx *xInSamps, float  *xOutSamps,
                                const SCplx *yInSamps, float  *yOutSamps,
                                int order, int flags))

    NSPAPI(void,nspdCcs2FftNip,(const DCplx *xInSamps, double *xOutSamps,
                                const DCplx *yInSamps, double *yOutSamps,
                                int order, int flags))

/* ======================================================================== */

#endif                                                         /* _NSPFFT_H */
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\x86\nspwarn.h ===
/*M*
//
//               INTEL CORPORATION PROPRIETARY INFORMATION
//  This software is supplied under the terms of a license agreement or
//  nondisclosure agreement with Intel Corporation and may not be copied
//  or disclosed except in accordance with the terms of that agreement.
//        Copyright (c) 1994 Intel Corporation. All Rights Reserved.
//
//      $Workfile: nspwarn.h $
//      $Revision: 3 $
//      $Modtime: 3/05/97 19:06 $
//
//   Purpose:
//
*M*/

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __NSPWARN_H__
#define __NSPWARN_H__

#if !defined (_OWN_BLDPCS)


#if _MSC_VER >= 1000

/* nonstandard extension used : nameless struct/union          */
#pragma warning(disable : 4201)
/* nonstandard extension used : bit field types other than int */
#pragma warning(disable : 4214)
/* unreferenced inline function has been removed               */
#pragma warning(disable : 4514)
/* named type definition in parentheses                        */
#pragma warning(disable : 4115)

#endif /* _MSC_VER >= 1000 */
#endif /* (_OWN_BLDPCS)    */


#endif /* __NSPWARN_H__    */

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\x86\userdll.h ===
/*M*
//
//               INTEL CORPORATION PROPRIETARY INFORMATION
//  This software is supplied under the terms of a license agreement or
//  nondisclosure agreement with Intel Corporation and may not be copied
//  or disclosed except in accordance with the terms of that agreement.
//        Copyright (c) 1999 Intel Corporation. All Rights Reserved.
//
//  Purpose: Declarations of the required functions
//   
*M*/


/***********************************************************/
/* Only copy the function prototype of all the             */
/* functions you want from the release include files       */
/***********************************************************/
#ifdef __USERLIST__
    NSPAPI(void,nspcFft,     (SCplx  *samps, int order, int flags))
    NSPAPI(void,nspsCcsFft,  (float  *samps, int order, int flags))
#endif /* __USERLIST__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmaxmo\wmaxmop.h ===
//
// Debug flags

#if DBG
#define MYCHECK(x) {RIP_ON_NOT_TRUE("WMA XMO", x);}
#else
#define MYCHECK(msg) {}
#endif

#if DBG

#define DEBUG_LEVEL_ERROR 0
#define DEBUG_LEVEL_WARNING 1
#define DEBUG_LEVEL_INFO 2
#define DEBUG_LEVEL_SPAM 5

extern ULONG g_WmaXmoDebugLevel;
#define DBG_SPAM(_exp_) {if (g_WmaXmoDebugLevel >= DEBUG_LEVEL_SPAM) DbgPrint _exp_;}
#define DBG_INFO(_exp) {if (g_WmaXmoDebugLevel >= DEBUG_LEVEL_INFO) DbgPrint _exp;}
#define DBG_ERROR(_exp) {if (g_WmaXmoDebugLevel >= DEBUG_LEVEL_ERROR) DbgPrint _exp;}
#define DBG_WARN(_exp) {if (g_WmaXmoDebugLevel >= DEBUG_LEVEL_WARNING) DbgPrint _exp;}

#else

#define DBG_SPAM(_exp_)
#define DBG_INFO(_exp_)
#define DBG_ERROR(_exp_)
#define DBG_WARN(_exp_)

#endif

#define ENTER_CS(pCS) {\
    EnterCriticalSection(pCS);\
}

#define LEAVE_CS(pCS) {\
    LeaveCriticalSection(pCS);\
}


// BUGBUG
// Trial-and-error has shown that WMA has a limit on the number
// of samples it is willing to consider decoding at once.
// If you ask for (say) a million samples, you'll get 0 samples.
//
// Worse, asking for 2049 samples at a time appears to cause heap
// corruption.
//
// Asking for 2048 samples works fine. It is lame because that's
// the frame size, so every other request returns 0 samples.
// That's twice the overhead as if we asked for 2049 samples,
// but it avoids corrupting the heap.

const DWORD WMA_MAX_SRC_PACKET_SIZE = 128;
const DWORD MAX_SAMPLES_PER_REQUEST = 2048;
const DWORD WMA_SRC_BUFFER_SIZE = max(4096*2,WMAMO_HEADER_SIZE);

const DWORD WMA_MAX_CONTEXTS = 10;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\x86\opcodes.h ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1998 - 1998

Module Name:

	opcodes.h
         
Abstract:

    Header for unsupported assembly instructions.

Author:

	Marc Holder (marchold@microsoft.com) 16-July-1998

Revision History:

*************************************************************************/

// MSVC Now understands conditional move opcodes
//Conditional move opcode macros
#define cmoves  cmoves
#define cmovz   cmovz
#define cmove   cmove
#define cmovne  cmovne
#define cmovnz  cmovnz
#define cmovge  cmovge
#define cmovg   cmovg

//Registers encoding opcode macros
#define edx_edi edx,edi
#define edx_eax edx,eax
#define ebx_eax ebx,eax
#define edi_eax edi,eax
#define esi_eax esi,eax
#define eax_edi eax,edi
#define eax_edx eax,edx



#ifndef _USE_INTEL_COMPILER

//Katmai new instructions opcodes
#define pavgb       _asm _emit 0x0F _asm _emit 0xE0  //packed byte avarage, takes 2 mmx registers  
#define psadbw      _asm _emit 0x0F _asm _emit 0xF6  //packed byte to word sun absolute diffrences, takes 2 mmx registers
#define pshufw      _asm _emit 0x0F _asm _emit 0x70  //pshufw takes 2 mmx registers and 1 byte which must be emited  
#define pmulhuw     _asm _emit 0x0F _asm _emit 0xE4  //pmulhuw packed unsigned multiply keep high words takes 2 mmx registers
#define pinsrw      _asm _emit 0x0F _asm _emit 0xC4
#define pmovmskb    _asm _emit 0x0F _asm _emit 0xD7  
#define pminub      _asm _emit 0x0F _asm _emit 0xDA
#define pmaxub      _asm _emit 0x0F _asm _emit 0xDE
#define pminsw      _asm _emit 0x0F _asm _emit 0xEA

//Katmai SIMD FP instruction opcodes
#define movaps  _asm _emit 0x0F _asm _emit 0x28  //128 bit aligned move
#define movups  _asm _emit 0x0F _asm _emit 0x10  //128 bit unaligned move
#define shufps(reg,funct) _asm emit 0x0F _asm _emit 0xC6 reg _asm _emit funct
#define unpcklps _asm _emit 0x0F _asm _emit 0x14
#define unpckhps _asm _emit 0x0F _asm _emit 0x15
#define mulps _asm _emit 0x0F _asm _emit 0x59
#define cvtps2pi _asm _emit 0x0F _asm _emit 0x2D 
#define xorps _asm _emit 0x0F _asm _emit 0x57
#define subps _asm _emit 0x0F _asm _emit 0x5C
#define addps _asm _emit 0x0F _asm _emit 0x58
#define addss _asm _emit 0xF3 _asm _emit 0x0F _asm _emit 0x58
#define mulss _asm _emit 0xF3 _asm _emit 0x0F _asm _emit 0x59
#define movssFROMMEM _asm _emit 0xF3 _asm _emit 0x0F _asm _emit 0x10
#define movssTOMEM _asm _emit 0xF3 _asm _emit 0x0F _asm _emit 0x11
#define movhlps _asm _emit 0x0F _asm _emit 0x12
#define movlhps _asm _emit 0x0F _asm _emit 0x16

#define xmm3_ebx _asm _emit 0x1B
#define xmm4_ecx _asm _emit 0x21
#define xmm2_edx _asm _emit 0x12 

#define xmm0_esiBASE    _asm _emit 0x06     // xmm0, [esi]
#define xmm1_esiBASE    _asm _emit 0x0E     // xmm1, [esi]
#define xmm2_esiBASE    _asm _emit 0x16     // xmm2, [esi]
#define xmm3_esiBASE    _asm _emit 0x1E     // xmm3, [esi]
#define xmm4_esiBASE    _asm _emit 0x26     // xmm4, [esi]
#define xmm5_esiBASE    _asm _emit 0x2E     // xmm5, [esi]
#define xmm6_esiBASE    _asm _emit 0x36     // xmm6, [esi]
#define xmm7_esiBASE    _asm _emit 0x3E     // xmm6, [esi]

#define xmm0_ediBASE    _asm _emit 0x07     // xmm0, [edi]
#define xmm1_ediBASE    _asm _emit 0x0F     // xmm1, [edi]
#define xmm2_ediBASE    _asm _emit 0x17     // xmm2, [edi]
#define xmm3_ediBASE    _asm _emit 0x1F     // xmm3, [edi]
#define xmm4_ediBASE    _asm _emit 0x27     // xmm4, [edi]
#define xmm5_ediBASE    _asm _emit 0x2F     // xmm5, [edi]
#define xmm6_ediBASE    _asm _emit 0x37     // xmm6, [edi]

#define xmm0_edxBASE    _asm _emit 0x02     // xmm0, [edx]
#define xmm1_edxBASE    _asm _emit 0x0A     // xmm1, [edx]
#define xmm2_edxBASE    _asm _emit 0x12     // xmm2, [edx]
#define xmm3_edxBASE    _asm _emit 0x1A     // xmm3, [edx]
#define xmm4_edxBASE    _asm _emit 0x22     // xmm4, [edx]
#define xmm5_edxBASE    _asm _emit 0x2A     // xmm5, [edx]
#define xmm6_edxBASE    _asm _emit 0x32     // xmm6, [edx]


#define xmm3_espBASE    _asm _emit 0x1c _asm _emit 0x24 // xmm3, [esp]
#define xmm4_espBASE    _asm _emit 0x24 _asm _emit 0x24 // xmm4, [esp]
#define eaxBASE_xmm3    _asm _emit 0x18     // [eax], xmm3


//defines opcodes for mm?,[esi+offset],imm to use with pinsrw
#define mm0_esi(offset,imm) _asm _emit 0x46 _asm _emit offset _asm _emit imm
#define mm1_esi(offset,imm) _asm _emit 0x4E _asm _emit offset _asm _emit imm
#define mm2_esi(offset,imm) _asm _emit 0x56 _asm _emit offset _asm _emit imm

//For mmx,[edi]
#define mm0_edi _asm _emit 0x07
#define mm1_edi _asm _emit 0x0F
#define mm2_edi _asm _emit 0x17
#define mm3_edi _asm _emit 0x1F
#define mm4_edi _asm _emit 0x27
#define mm6_edi _asm _emit 0x37 
#define mm7_edi _asm _emit 0x3F

//For mmx,[esi+edx+offset]
#define mm1_esi_edx_(offset) _asm emit 0x4C _asm _emit 0x16 _asm _emit offset 
#define mm7_esi_edx_(offset) _asm emit 0x7C _asm _emit 0x16 _asm _emit offset 

//For mmx,[esi+offset]
#define mm1_esi_(offset)    _asm _emit 0x4E _asm _emit offset

//For mmx,[edi+offset]
#define mm5_edi_(offset)    _asm _emit 0x6F _asm _emit offset
#define mm6_edi_(offset)    _asm _emit 0x77 _asm _emit offset
#define mm7_edi_(offset)    _asm _emit 0x7F _asm _emit offset

//for cmov
#define eax_ebx             _asm _emit 0xC3
#define ecx_ebx             _asm _emit 0xCB
#define edx_ebx             _asm _emit 0xD3

//for eax,mm4
#define eax_mm4             _asm _emit 0xC4
#define eax_mm7             _asm _emit 0xC7

//MMX redister encoding opcode macros
#define mm0_mm0 _asm _emit 0xC0
#define mm0_mm1 _asm _emit 0xC1
#define mm0_mm2 _asm _emit 0xC2
#define mm0_mm3 _asm _emit 0xC3
#define mm0_mm4 _asm _emit 0xC4
#define mm0_mm5 _asm _emit 0xC5
#define mm0_mm6 _asm _emit 0xC6
#define mm0_mm7 _asm _emit 0xC7
#define mm1_mm1 _asm _emit 0xC9
#define mm1_mm2 _asm _emit 0xCA
#define mm1_mm3 _asm _emit 0xCB
#define mm1_mm4 _asm _emit 0xCC
#define mm1_mm5 _asm _emit 0xCD
#define mm1_mm6 _asm _emit 0xCE
#define mm1_mm7 _asm _emit 0xCF
#define mm2_mm0 _asm _emit 0xD0
#define mm2_mm1 _asm _emit 0xD1
#define mm2_mm2 _asm _emit 0xD2
#define mm2_mm3 _asm _emit 0xD3
#define mm2_mm4 _asm _emit 0xD4
#define mm2_mm5 _asm _emit 0xD5
#define mm2_mm6 _asm _emit 0xD6
#define mm2_mm7 _asm _emit 0xD7
#define mm3_mm0 _asm _emit 0xD8
#define mm3_mm1 _asm _emit 0xD9
#define mm3_mm2 _asm _emit 0xDA
#define mm3_mm3 _asm _emit 0xDB
#define mm3_mm4 _asm _emit 0xDC
#define mm3_mm7 _asm _emit 0xDF
#define mm4_mm0 _asm _emit 0xE0
#define mm4_mm1 _asm _emit 0xE1
#define mm4_mm2 _asm _emit 0xE2
#define mm4_mm4 _asm _emit 0xE4
#define mm4_mm5 _asm _emit 0xE5
#define mm4_mm6 _asm _emit 0xE6
#define mm4_mm7 _asm _emit 0xE7
#define mm5_mm0 _asm _emit 0xE8
#define mm5_mm1 _asm _emit 0xE9
#define mm5_mm2 _asm _emit 0xEA
#define mm5_mm3 _asm _emit 0xEB
#define mm5_mm4 _asm _emit 0xEC
#define mm5_mm5 _asm _emit 0xED
#define mm5_mm6 _asm _emit 0xEE
#define mm5_mm7 _asm _emit 0xEF
#define mm6_mm0 _asm _emit 0xF0
#define mm6_mm1 _asm _emit 0xF1
#define mm6_mm2 _asm _emit 0xF2
#define mm6_mm3 _asm _emit 0xF3
#define mm6_mm4 _asm _emit 0xF4
#define mm6_mm5 _asm _emit 0xF5
#define mm6_mm6 _asm _emit 0xF6
#define mm6_mm7 _asm _emit 0xF7
#define mm7_mm0 _asm _emit 0xF8
#define mm7_mm1 _asm _emit 0xF9
#define mm7_mm2 _asm _emit 0xFA
#define mm7_mm3 _asm _emit 0xFB
#define mm7_mm4 _asm _emit 0xFC
#define mm7_mm5 _asm _emit 0xFD
#define mm7_mm6 _asm _emit 0xFE
#define mm7_mm7 _asm _emit 0xFF

//SIMD_FP registers
#define xmm0_xmm0 _asm _emit 0xC0
#define xmm0_xmm1 _asm _emit 0xC1
#define xmm0_xmm2 _asm _emit 0xC2
#define xmm0_xmm3 _asm _emit 0xC3
#define xmm0_xmm4 _asm _emit 0xC4
#define xmm0_xmm5 _asm _emit 0xC5
#define xmm0_xmm6 _asm _emit 0xC6
#define xmm0_xmm7 _asm _emit 0xC7
#define xmm1_xmm0 _asm _emit 0xC8
#define xmm1_xmm1 _asm _emit 0xC9
#define xmm1_xmm2 _asm _emit 0xCA
#define xmm1_xmm3 _asm _emit 0xCB
#define xmm1_xmm4 _asm _emit 0xCC
#define xmm1_xmm5 _asm _emit 0xCD
#define xmm1_xmm6 _asm _emit 0xCE
#define xmm1_xmm7 _asm _emit 0xCF
#define xmm2_xmm0 _asm _emit 0xD0
#define xmm2_xmm1 _asm _emit 0xD1
#define xmm2_xmm2 _asm _emit 0xD2
#define xmm2_xmm3 _asm _emit 0xD3
#define xmm2_xmm4 _asm _emit 0xD4
#define xmm2_xmm5 _asm _emit 0xD5
#define xmm2_xmm6 _asm _emit 0xD6
#define xmm2_xmm7 _asm _emit 0xD7
#define xmm3_xmm0 _asm _emit 0xD8
#define xmm3_xmm1 _asm _emit 0xD9
#define xmm3_xmm2 _asm _emit 0xDA
#define xmm3_xmm3 _asm _emit 0xDB
#define xmm3_xmm4 _asm _emit 0xDC
#define xmm3_xmm5 _asm _emit 0xDD
#define xmm3_xmm7 _asm _emit 0xDF
#define xmm4_xmm0 _asm _emit 0xE0
#define xmm4_xmm1 _asm _emit 0xE1
#define xmm4_xmm2 _asm _emit 0xE2
#define xmm4_xmm3 _asm _emit 0xE3
#define xmm4_xmm4 _asm _emit 0xE4
#define xmm4_xmm5 _asm _emit 0xE5
#define xmm4_xmm6 _asm _emit 0xE6
#define xmm4_xmm7 _asm _emit 0xE7
#define xmm5_xmm0 _asm _emit 0xE8
#define xmm5_xmm1 _asm _emit 0xE9
#define xmm5_xmm2 _asm _emit 0xEA
#define xmm5_xmm3 _asm _emit 0xEB
#define xmm5_xmm4 _asm _emit 0xEC
#define xmm5_xmm5 _asm _emit 0xED
#define xmm5_xmm6 _asm _emit 0xEE
#define xmm5_xmm7 _asm _emit 0xEF
#define xmm6_xmm0 _asm _emit 0xF0
#define xmm6_xmm1 _asm _emit 0xF1
#define xmm6_xmm2 _asm _emit 0xF2
#define xmm6_xmm3 _asm _emit 0xF3
#define xmm6_xmm4 _asm _emit 0xF4
#define xmm6_xmm5 _asm _emit 0xF5
#define xmm6_xmm6 _asm _emit 0xF6
#define xmm6_xmm7 _asm _emit 0xF7
#define xmm7_xmm0 _asm _emit 0xF8
#define xmm7_xmm1 _asm _emit 0xF9
#define xmm7_xmm2 _asm _emit 0xFA
#define xmm7_xmm3 _asm _emit 0xFB
#define xmm7_xmm4 _asm _emit 0xFC
#define xmm7_xmm5 _asm _emit 0xFD
#define xmm7_xmm6 _asm _emit 0xFE
#define xmm7_xmm7 _asm _emit 0xFF

#define mm0_xmm4 _asm _emit 0xC4
#define mm1_xmm0 _asm _emit 0xC8
#define mm1_xmm2 _asm _emit 0xCA
#define mm2_xmm4 _asm _emit 0xD4
#define mm3_xmm0 _asm _emit 0xD8
#define mm3_xmm2 _asm _emit 0xDA

#define emit _asm _emit

#define CPU_ID _asm _emit 0x0f _asm _emit 0xa2
#define RDTSC  _asm _emit 0x0f _asm _emit 0x31



#else   // _USE_INTEL_COMPILER

//Katmai new instructions opcodes
#define pavgb  pavgb
#define psadbw psadbw
#define pshufw pshufw
#define shufps shufps

//MMX redister encoding opcode macros
#define mm0_mm0 mm0,mm0
#define mm0_mm1 mm0,mm1
#define mm0_mm7 mm0,mm7
#define mm0_mm3 mm0,mm3
#define mm1_mm1 mm1,mm1
#define mm1_mm2 mm1,mm2
#define mm1_mm7 mm1,mm7
#define mm2_mm2 mm2,mm2
#define mm2_mm3 mm2,mm3
#define mm2_mm7 mm2,mm7
#define mm3_mm2 mm3,mm2
#define mm3_mm4 mm3,mm4
#define mm3_mm7 mm3,mm7
#define mm4_mm2 mm4,mm2
#define mm4_mm5 mm4,mm5
#define mm4_mm7 mm4,mm7
#define mm5_mm6 mm5,mm6
#define mm5_mm7 mm5,mm7
#define mm6_mm7 mm6,mm7
#define mm7_mm0 mm7,mm0
#define mm7_mm1 mm7,mm1

//Katmai SIMD FP instruction opcodes
#define movaps movaps
#define movups movups
#define shufps(reg,funct) shufps reg,funct
#define unpcklps unpcklps
#define mulps mulps
#define cvtps2pi cvtps2pi
#define unpckhps unpckhps
#define xorps xorps
#define subps subps
#define addps addps
#define addss addss
#define mulss mulss
#define movssFROMMEM    movss
#define movssTOMEM      movss
#define movhlps         movhlps

#define xmm3_ebx xmm3,[ebx]
#define xmm4_ecx xmm4,[ecx]
#define xmm2_edx xmm2,[edx]

#define xmm0_esiBASE    xmm0, [esi]
#define xmm1_esiBASE    xmm1, [esi]
#define xmm2_esiBASE    xmm2, [esi]
#define xmm3_esiBASE    xmm3, [esi]
#define xmm4_esiBASE    xmm4, [esi]
#define xmm5_esiBASE    xmm5, [esi]
#define xmm6_esiBASE    xmm6, [esi]
#define xmm7_esiBASE    xmm7, [esi]

#define xmm0_ediBASE    xmm0, [edi]
#define xmm1_ediBASE    xmm1, [edi]
#define xmm2_ediBASE    xmm2, [edi]
#define xmm3_ediBASE    xmm3, [edi]
#define xmm4_ediBASE    xmm4, [edi]
#define xmm5_ediBASE    xmm5, [edi]
#define xmm6_ediBASE    xmm6, [edi]

#define xmm0_edxBASE    xmm0, [edx]
#define xmm1_edxBASE    xmm1, [edx]
#define xmm2_edxBASE    xmm2, [edx]
#define xmm3_edxBASE    xmm3, [edx]
#define xmm4_edxBASE    xmm4, [edx]
#define xmm5_edxBASE    xmm5, [edx]
#define xmm6_edxBASE    xmm6, [edx]


#define xmm3_espBASE    xmm3, [esp]
#define xmm4_espBASE    xmm4, [esp]
#define eaxBASE_xmm3    [eax], xmm3

#define xmm0_xmm0 xmm0,xmm0
#define xmm0_xmm1 xmm0,xmm1
#define xmm1_xmm1 xmm1,xmm1
#define xmm0_xmm3 xmm0,xmm3
#define xmm1_xmm2 xmm1,xmm2
#define xmm2_xmm2 xmm2,xmm2
#define xmm1_xmm4 xmm1,xmm4
#define xmm3_xmm0 xmm3,xmm0
#define xmm4_xmm4 xmm4,xmm4

#define xmm1_xmm0 xmm1,xmm0
#define xmm3_xmm5 xmm3,xmm5

#define mm0_xmm4 mm0,xmm4
#define mm1_xmm0 mm1,xmm0
#define mm1_xmm2 mm1,xmm2
#define mm2_xmm4 mm2,xmm4
#define mm3_xmm0 mm3,xmm0
#define mm3_xmm2 mm3,xmm2

#define emit ,

#define CPU_ID cpuid

#endif  // _USE_INTEL_COMPILER
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmaxmo\wmaxmo.cpp ===
/***************************************************************************
*
*  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
*
*  File:       wmaxmo.c
*  Content:    WMA XMO en/decode API.
*  History:
*   Date       By        Reason
*   ====       ==        ======
*  10/03/00    jpalevic  Created.
*  01/12/2001  georgioc  overhaul to make it more user friendly and conform to xmo spec
****************************************************************************/

#pragma code_seg("WMADECXMO")
#pragma data_seg("WMADECXMO_RW")
#pragma const_seg("WMADECXMO_RD")

#pragma comment(linker, "/merge:WMADECXMO_RW=WMADECXMO")
#pragma comment(linker, "/merge:WMADECXMO_RD=WMADECXMO")
#pragma comment(linker, "/section:WMADECXMO,ERW")

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntos.h>

#ifdef __cplusplus
}
#endif // __cplusplus

#include <xtl.h>
#include "..\..\dsound\dsndver.h"
#include <xdbg.h>
#include "wmaxmo.h"
#include "wmaxmop.h"
#include "wma_dec_win32_x86.h"

#if DBG

    ULONG g_WmaXmoDebugLevel = DEBUG_LEVEL_WARNING;

#endif



//
// this is the intermediate XMO instantiation function
//

HRESULT 
WmaCreateInMemoryDecoderEx(
    LPFNWMAXMODATACALLBACK  pCallback,
    PVOID                   pCallbackContext,
    DWORD                   dwYieldRate,
    LPWAVEFORMATEX          pwfxCompressed,
    XWmaFileMediaObject     **ppMediaObject)
{

    HRESULT hr = S_OK;

    hr = WmaCreateInMemoryDecoder(
        pCallback,
        pCallbackContext,
        dwYieldRate,
        pwfxCompressed,
        (XMediaObject **)ppMediaObject);

    return hr;

}

HRESULT 
WmaCreateInMemoryDecoder(
    LPFNWMAXMODATACALLBACK  pCallback,
    PVOID                   pCallbackContext,
    DWORD                   dwYieldRate,
    LPWAVEFORMATEX          pwfxCompressed,
    XMediaObject            **ppMediaObject)
{


    HRESULT                 hr;
    MYCHECK(ppMediaObject);
    
    CWMAXMediaObject* pXMO;
        
    if (dwYieldRate == 0) {

        //
        // never yield
        //

        dwYieldRate = 1000;

    }

    //
    // pcallbackBack
    //

    if (pCallback == NULL) {

        MYCHECK(pCallback != NULL);
        *ppMediaObject = NULL;
        return E_FAIL;

    }

    pXMO = new CWMAXMediaObject();
    if (pXMO == NULL) {
        return E_OUTOFMEMORY;
    }    

    //
    // initialize wma xmo
    //

    hr = pXMO->InitializeIntermediate(
        pCallback,
        pCallbackContext,
        dwYieldRate,
        pwfxCompressed);


    if (SUCCEEDED(hr)) {

        *ppMediaObject = (XMediaObject *) pXMO;

    } else {

        *ppMediaObject = NULL;
        pXMO->Release();

    }

    return hr;

}

HRESULT
WmaCreateDecoderEx(
    LPCSTR                  pszFileName, 
    HANDLE                  hFile,
    BOOL                    fAsyncMode,
    DWORD                   dwLookaheadBufferSize,
    DWORD                   dwMaxPackets,
    DWORD                   dwYieldRate,
    LPWAVEFORMATEX          pwfxCompressed,
    XWmaFileMediaObject        **ppMediaObject)
{
    HRESULT hr = S_OK;

    hr = WmaCreateDecoder(
        pszFileName, 
        hFile,
        fAsyncMode,
        dwLookaheadBufferSize,
        dwMaxPackets,
        dwYieldRate,
        pwfxCompressed,
        (XFileMediaObject **)ppMediaObject);

    return hr;

}


HRESULT
WmaCreateDecoder(
    LPCSTR                  pszFileName, 
    HANDLE                  hFile,
    BOOL                    fAsyncMode,
    DWORD                   dwLookaheadBufferSize,
    DWORD                   dwMaxPackets,
    DWORD                   dwYieldRate,
    LPWAVEFORMATEX          pwfxCompressed,
    XFileMediaObject        **ppMediaObject)
{
    HRESULT                 hr;
    MYCHECK(ppMediaObject);
    
    CWMAXMediaObject* pXMO;
        
    if (dwYieldRate == 0) {

        //
        // never yield
        //

        dwYieldRate = 1000;

    }

    pXMO = new CWMAXMediaObject();
    if (pXMO == NULL) {
        return E_OUTOFMEMORY;
    }    

    //
    // initialize wma xmo
    //

    hr = pXMO->Initialize(pszFileName,
                          hFile,
                          fAsyncMode,
                          dwLookaheadBufferSize,
                          dwMaxPackets,
                          dwYieldRate,
                          pwfxCompressed);
    
    if (SUCCEEDED(hr)) {

        *ppMediaObject = pXMO;

    } else {

        *ppMediaObject = NULL;
        pXMO->Release();

    }

    return hr;
}


CWMAXMediaObject::CWMAXMediaObject()
{
    ZeroMemory(&m_state, sizeof (m_state));
    ZeroMemory(&m_hdr, sizeof (m_hdr));
    m_dwYieldRate = 1000;
    m_pSrcBuffer = NULL;
    m_dwMaxContexts = 0;
    m_pContextPool = NULL;
    m_bDecodeMore = TRUE;
    m_bAsyncMode = FALSE;
    m_bExternalHandle = FALSE;
    m_cRef = 0;
    m_dwPendingPackets = 0;
    m_dwSrcBufferOffset = 0;
    m_dwCurrentWmaFileOffset = 0;
    m_pCallback = NULL;
    m_pCallbackContext = NULL;
    m_hThread = NULL;
    m_hDeleteThreadEvent = NULL;
    m_hFile = INVALID_HANDLE_VALUE;
    m_dwThreadId = 0;

    memset(&m_overlapped,0,sizeof(OVERLAPPED));
    InitializeCriticalSection(&m_CS);

}

CWMAXMediaObject::~CWMAXMediaObject()
{

    Reset();

    //
    // set the delete event
    //

    if (m_hDeleteThreadEvent) {

        SetEvent(m_hDeleteThreadEvent);

    }

    //
    // wait on thread exiting..
    //

    if (m_hThread) {
        WaitForSingleObject(m_hThread,INFINITE);
    }

    ASSERT(m_dwThreadId == 0);


    if ( m_state ) {
        WMAFileDecodeClose(&m_state);
    }

    if (m_pSrcBuffer) {
        delete [] m_pSrcBuffer;
    }

    if (m_pContextPool) {
        delete [] m_pContextPool;
    }


    if ((m_hFile != INVALID_HANDLE_VALUE) && (m_bExternalHandle == FALSE)) {
        CloseHandle(m_hFile);
    }

    if (m_hDeleteThreadEvent) {

        CloseHandle(m_hDeleteThreadEvent);

    }

    if (m_overlapped.hEvent) {
        CloseHandle(m_overlapped.hEvent);
    }
}


VOID CWMAXMediaObject::Reset()
{

    //
    // wait until out pending list is  empty
    //

    while (TRUE) {

        if (IsListEmpty(&m_PendingList)) {

            break;

        }

        Sleep(5);

    }

}


HRESULT CWMAXMediaObject::InitializeIntermediate(
    LPFNWMAXMODATACALLBACK     pCallback,
    PVOID                      pCallbackContext,
    DWORD                      dwYieldRate,
    LPWAVEFORMATEX             pwfxCompressed
    )
{
    HRESULT hr;
    m_bAsyncMode = FALSE;

    m_dwYieldRate = dwYieldRate;
    m_dwLookaheadSize = 0;

    m_pCallback = pCallback;
    m_pCallbackContext = pCallbackContext;

    InitializeListHead(&m_AvailableList);
    InitializeListHead(&m_PendingList);

    AddRef();

    hr = Flush();
    
    if (FAILED(hr)) {
        return hr;
    }

    if (pwfxCompressed) {
        GetFormat(pwfxCompressed);
    }

    return hr;

}


HRESULT CWMAXMediaObject::Initialize(
    LPCSTR pszFileName, 
    HANDLE hFile,
    BOOL fAsyncMode,
    DWORD dwLookaheadSize,
    DWORD dwMaxPackets,
    DWORD dwYieldRate,
    LPWAVEFORMATEX pwfxCompressed
    )
{
    HRESULT hr;
    PWMAXMO_ASYNC_CONTEXT pContext;

    AddRef();

    m_dwYieldRate = dwYieldRate;

    //
    // create a file media object to read the raw wma data from
    //

    if (hFile == NULL) {

        MYCHECK(pszFileName);
        m_bExternalHandle = FALSE;

        m_hFile = CreateFile(pszFileName,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             (fAsyncMode ? (FILE_FLAG_OVERLAPPED) : 0),
                             NULL);

    } else {

        m_bExternalHandle = TRUE;
        m_hFile = hFile;

        NTSTATUS status;
        IO_STATUS_BLOCK IoStatusBlock;
        DWORD dwMode;

        status = NtQueryInformationFile(
                hFile,
                &IoStatusBlock,
                &dwMode,
                sizeof(dwMode),
                FileModeInformation
                );

        MYCHECK(!(dwMode &  FILE_NO_INTERMEDIATE_BUFFERING) && "File Handle passed was opened async. Not supported.");

    }


    if (m_hFile == INVALID_HANDLE_VALUE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
    }

    //
    // allocate packet buffer.assume 16 bit resolution for all wma files
    //

    m_dwLookaheadSize = max(WMA_SRC_BUFFER_SIZE,dwLookaheadSize)*2;
    
    m_pSrcBuffer = new BYTE[m_dwLookaheadSize];

    if (m_pSrcBuffer == NULL) {
        return E_OUTOFMEMORY;
    }

    m_bAsyncMode = fAsyncMode;
    m_dwMaxContexts = max(2,dwMaxPackets);

    //
    // init state
    //

    InitializeListHead(&m_AvailableList);
    InitializeListHead(&m_PendingList);

    //
    // we are initialized ok. Now create a thread that will gives us
    // some context to run and check if packets have been submitted
    //

    if (fAsyncMode == TRUE) {

        //
        // alloc a buffer for contexts
        //
    
        m_pContextPool = (PUCHAR) new WMAXMO_ASYNC_CONTEXT[m_dwMaxContexts];
    
        if (m_pContextPool == NULL) {
            return E_OUTOFMEMORY;
        }
    
        //
        // insert contexts in list..
        //
    
        for (ULONG i=0;i<m_dwMaxContexts;i++) {
    
            pContext = (PWMAXMO_ASYNC_CONTEXT) (m_pContextPool + sizeof(WMAXMO_ASYNC_CONTEXT)*i);
            InitializeListHead(&pContext->ListEntry);
            InsertHeadList(&m_AvailableList,
                           &pContext->ListEntry);
    
        }

        m_hThread = CreateThread(NULL,
                                 8192,
                                 WmaXmoThreadProc,
                                 this,
                                 0,
                                 &m_dwThreadId);

        if (m_hThread == NULL) {
            return E_OUTOFMEMORY;
        }

        //
        // create event that will signal thread to terminate
        //

        m_hDeleteThreadEvent = CreateEvent(NULL,FALSE,FALSE,NULL);

        if (m_hDeleteThreadEvent == NULL) {
            return E_OUTOFMEMORY;
        }

        m_overlapped.hEvent = CreateEvent(NULL,FALSE,FALSE,NULL);;

        if (m_overlapped.hEvent == NULL) {
            return E_OUTOFMEMORY;
        }

    }

    hr = Flush();
    
    if (FAILED(hr)) {
        return hr;
    }

    if (pwfxCompressed) {
        GetFormat(pwfxCompressed);
    }
    
    return hr;

}

HRESULT STDMETHODCALLTYPE CWMAXMediaObject::Flush()
{
    tWMAFileStatus rc;
    HRESULT hr;
    DWORD dwBytesRead;
    BOOL bResult;

    DBG_INFO(("WmaXmo (%x): Flush Called\n",this));

    Reset();

    ENTER_CS(&m_CS);

    m_dwSrcBufferOffset = 0;
    m_dwCurrentWmaFileOffset = 0;

    DBG_INFO(("WmaXmo (%x): Flush: SrcBufferOffset = 0x%x, WmaFileOffset 0x%x\n",
             this,
             m_dwSrcBufferOffset,
             m_dwCurrentWmaFileOffset));

    //
    // for the in-memory wma, we dont read any data from file
    //

    if (m_pCallback == NULL) {

        //
        // prime the src buffer with file data (wma header etc)
        //
    
        SetFilePointer(m_hFile, 0, NULL, FILE_BEGIN);

        m_overlapped.Offset = 0;
        m_overlapped.OffsetHigh = 0;

        bResult = ReadFile(m_hFile,
                     m_pSrcBuffer,
                     m_dwLookaheadSize,
                     &dwBytesRead,
                     (m_bAsyncMode ? &m_overlapped : 0)) ;

        if (!bResult && !m_bAsyncMode) {

            LEAVE_CS(&m_CS);
            return HRESULT_FROM_WIN32(GetLastError());

        }
     
        if (m_bAsyncMode) {
    
            bResult = GetOverlappedResult(m_hFile,&m_overlapped,&dwBytesRead,TRUE);
            if (!bResult) {
    
                LEAVE_CS(&m_CS);
                return HRESULT_FROM_WIN32(GetLastError());
    
            }
    
        }

    }

        
    rc = WMAFileDecodeCreate(&m_state, this);

    if (rc != cWMA_NoErr) {

        DBG_WARN(("WmaXmo (%x): Flush: WMA decoder failed creation. Most likely due to out-of-memory.\n",this));

        LEAVE_CS(&m_CS);
        return E_FAIL;

    }

    rc = WMAFileDecodeInit( m_state);
    
    DBG_INFO(("m_state = 0x%08x\n", m_state));
    
    if (rc != cWMA_NoErr) {

        DBG_WARN(("WmaXmo (%x): Flush: WMA decoder failed init. Most likely due to out-of-memory.\n",this));

        LEAVE_CS(&m_CS);
        return E_FAIL;

    }

    rc = WMAFileDecodeInfo( m_state, &m_hdr);
    
    if (rc != cWMA_NoErr) {

        DBG_WARN(("WmaXmo (%x): Flush: WMA decoder failed init 2. Most likely due to out-of-memory.\n",this));

        LEAVE_CS(&m_CS);
        return E_FAIL;

    }

    if (m_hdr.has_DRM) {
        
        DBG_ERROR(( "DRM FILES NOT SUPPORTED!\n")); // Cannot open DRM licensed files.

        LEAVE_CS(&m_CS);
        return E_FAIL;

    }

    m_bDecodeMore = TRUE;

    LEAVE_CS(&m_CS);
    return S_OK;
}

DWORD WINAPI WmaXmoThreadProc(
    LPVOID pParameter
    )
{
    CWMAXMediaObject *pThis = (CWMAXMediaObject *) pParameter;
    pThis->ThreadProc();

    return 0;
}

VOID CWMAXMediaObject::ThreadProc()
{
    HRESULT hr = S_OK;

    while (m_cRef > 0) {

        //
        // this function should have been called in response to an event being signalled
        //
    
        if (WaitForSingleObject(m_hDeleteThreadEvent,0) == WAIT_OBJECT_0) {

            //
            // thread needs to be deleted, bail...
            //

            DBG_INFO(("ThreadProc: Leaving thread\n"));
            goto exit;

        }

        ENTER_CS(&m_CS);

        if (!IsListEmpty(&m_PendingList)) {
    
            PWMAXMO_ASYNC_CONTEXT pCtx;

            pCtx = (PWMAXMO_ASYNC_CONTEXT) m_PendingList.Flink;
            hr =  ReadWmaDataFromFile((PUCHAR)m_pSrcBuffer,
                                      m_dwLookaheadSize,
                                      pCtx);

            LEAVE_CS(&m_CS);

            if (hr == E_ABORT) {

                goto exit;

            }

        } else {

            LEAVE_CS(&m_CS);

        }

        

    }

exit:

    m_dwThreadId = 0;
    ExitThread(0);

}


HRESULT STDMETHODCALLTYPE CWMAXMediaObject::Process( 
    LPCXMEDIAPACKET pSrc,
    LPCXMEDIAPACKET pDst
    )
{
    HRESULT hr = S_OK;
    
    MYCHECK(m_state);

    if ((m_bAsyncMode == FALSE) && (m_hFile == INVALID_HANDLE_VALUE)) {

        ASSERT(m_pCallback);
        ASSERT(m_pCallbackContext);

        //
        // we are in intermediate XMO mode. Dont read from file
        // since the wma codec will call the caller for data
        //

        return Decode(pDst);

    } else {

        MYCHECK(pSrc == NULL);

    }

    if (m_bAsyncMode) {

        PWMAXMO_ASYNC_CONTEXT   pContext;

        ENTER_CS(&m_CS);

        //
        // retrieve a context packet
        //

        if (IsListEmpty(&m_AvailableList)) {

            LEAVE_CS(&m_CS);
            ASSERT(FALSE && " Run out of available packets. Caller called Process too many times in a row");
            return E_OUTOFMEMORY;

        }

        pContext = (PWMAXMO_ASYNC_CONTEXT) RemoveTailList(&m_AvailableList);

        m_dwPendingPackets++;

        DBG_SPAM(("Process: Dequeued available context %x, pendingCount %x\n",
                 pContext, m_dwPendingPackets));


        pContext->pThis = this;

        //
        // save relevant variables into our context since media packets are off the stack
        //

        memcpy(&pContext->Xmp, pDst, sizeof(XMEDIAPACKET));

        if (!IsListEmpty(&m_PendingList)) {

            //
            // queue this packet since one is already being processed..
            //

            InsertTailList(&m_PendingList,
                           &pContext->ListEntry);


            DBG_SPAM(("Process: queuing pending context %x, pendingCount %x\n",
                     pContext, m_dwPendingPackets));


            LEAVE_CS(&m_CS);

            if (pDst->pdwStatus) {
                *pDst->pdwStatus = XMEDIAPACKET_STATUS_PENDING;
            }

            //
            // return pending.
            //

            return S_OK;

        }

        //
        // insert in pending list
        //

        InsertTailList(&m_PendingList,
                       &pContext->ListEntry);

        LEAVE_CS(&m_CS);


        return hr;

    } else {

        hr = ReadWmaDataFromFile((PUCHAR)m_pSrcBuffer,
                                 m_dwLookaheadSize,
                                 NULL);
     
        if (FAILED(hr)) {
     
            ASSERT(!FAILED(hr));
            return hr;
     
        }

        return Decode(pDst);
    }

}

HRESULT 
CWMAXMediaObject::Decode( 
    LPCXMEDIAPACKET pDst
    )
{
    PVOID pDstBuffer;
    HRESULT hr;
    DWORD count = 0;
    DWORD dwXmpStatus = XMEDIAPACKET_STATUS_SUCCESS;

    ASSERT((pDst->dwMaxSize % (2*m_hdr.num_channels)) == 0);
    DWORD num_bytes_requested = pDst->dwMaxSize;
    DWORD num_samples_requested = (num_bytes_requested) / (sizeof(short)* m_hdr.num_channels);
    DWORD num_samples_decoded = 0;
    
    pDstBuffer = pDst->pvBuffer;

    {
        while ( num_samples_decoded < num_samples_requested ) {


            if ( m_bDecodeMore ) {

                m_bDecodeMore = false;
                count++;

                //
                // yield execution so we dont hog the CPU
                //

                if (count%m_dwYieldRate == 0) {

                    DBG_SPAM(("Yielding execution\n"));
                    SwitchToThread();

                }

                tWMAFileStatus rc = WMAFileDecodeData(m_state);

                if (rc != cWMA_NoErr) {

                    if (rc == cWMA_NoMoreFrames)
                    {
                        DBG_ERROR(("  done playing!\n"));
                    }
                    else
                    {
                        DBG_ERROR(("  stopping due to error! (%d)\n", rc));
                        dwXmpStatus = XMEDIAPACKET_STATUS_FAILURE;
                    }
                    break; // End of WMA file, or some error.
                }


            }

            short* pSamples = ((short*) pDstBuffer) + num_samples_decoded * m_hdr.num_channels;
            DWORD numSamples = num_samples_requested - num_samples_decoded;
            
            if ( numSamples > MAX_SAMPLES_PER_REQUEST) {
                numSamples = MAX_SAMPLES_PER_REQUEST;
            }

            DBG_SPAM(("WMAFileGetPCM (this %x)(0x%08x, %d)\n", this, pSamples, numSamples));
            DWORD samples_decoded_this_round = WMAFileGetPCM( m_state,
                pSamples,
                NULL, numSamples);

            DBG_INFO((" ...got %d samples.\n", samples_decoded_this_round));

            if ( samples_decoded_this_round < numSamples ){
                m_bDecodeMore = true;
            }

            num_samples_decoded += samples_decoded_this_round;
        }

    }
    
    DBG_SPAM(("Process: Completing context, pdwStatus %x\n",
             pDst->pdwStatus));

    if (pDst->pdwCompletedSize ) {
        *pDst->pdwCompletedSize = num_samples_decoded * m_hdr.num_channels * sizeof(short);

        if (pDst->dwMaxSize > *pDst->pdwCompletedSize) {
    
            DBG_ERROR(("Wmaxmo (%x): Process: Completing packet %x with %x bytes, asked for %x\n",
                        this,
                        pDst,
                        *pDst->pdwCompletedSize,
                        pDst->dwMaxSize));
    
    
        }

    }
    
    if (pDst->hCompletionEvent) {
        SetEvent(pDst->hCompletionEvent);
    }

    if (pDst->pdwStatus) {
        *pDst->pdwStatus = dwXmpStatus;
    }
    
    return S_OK;
}

// Callback from WMA codec code.

extern "C" tWMA_U32 WMAFileCBGetData(tHWMAFileState state,
   PVOID Context,
   tWMA_U32 offset,
   tWMA_U32 num_bytes,
   unsigned char **ppData);

tWMA_U32 WMAFileCBGetData(tHWMAFileState state,
   PVOID pContext,
   tWMA_U32 offset,
   tWMA_U32 num_bytes,
   unsigned char **ppData)
{
   CWMAXMediaObject* pMO = (CWMAXMediaObject*) pContext;
   MYCHECK(pMO);

   return pMO->GetData(offset, num_bytes, (void**) ppData);
}

tWMA_U32 CWMAXMediaObject::GetData(DWORD offset,
   DWORD num_bytes,
   void** ppData
   )
{
   XMEDIAPACKET xmp;
   HRESULT                 hr      = DS_OK;
   DWORD                   dwRead;

   //
   // if the XMO is instanttiated as a in-memory decoder
   // dialup the caller supplied callback
   //

   if (m_pCallback) {

       ASSERT(m_dwLookaheadSize == 0);
       return (*m_pCallback)(m_pCallbackContext,
                             offset,
                             num_bytes,
                             ppData);

   }

   ENTER_CS(&m_CS);

   ULONG max_bytes = m_dwSrcBufferOffset+m_dwLookaheadSize - offset;

   DBG_SPAM((" CBGetData(%x) offset: 0x%08x-0x%08x size: %d\n", this, offset, offset + num_bytes - 1, num_bytes));
   MYCHECK(ppData);
   
   if (((m_dwSrcBufferOffset+m_dwLookaheadSize) <= offset) ||
       (num_bytes > max_bytes)){

       DBG_WARN(("Wma decoder requested data at an offset further than dwLookaheadSize.Offset %x, current %x ",offset,m_dwSrcBufferOffset));
       return 0;

   }

   *ppData = m_pSrcBuffer + offset - m_dwSrcBufferOffset;

#if DBG
   if (offset < m_dwCurrentWmaFileOffset) {

       DBG_WARN(("WMAXMO(%x): GetData: Wma ask for Offset %x, last offset %x\n",
                this,
                offset,
                m_dwCurrentWmaFileOffset));


   }
#endif

   m_dwCurrentWmaFileOffset = offset;

   LEAVE_CS(&m_CS);

   return num_bytes;
}

HRESULT CWMAXMediaObject::ReadWmaDataFromFile(
    PVOID pvBuffer,
    DWORD dwSize,
    PWMAXMO_ASYNC_CONTEXT   pContext
    )
{
    NTSTATUS                status = STATUS_SUCCESS;
    HRESULT hr = S_OK;
    ULONG Offset;
    BOOL bResult;
    DWORD dwBytesRead;

    Offset = m_dwSrcBufferOffset;

    if ((m_dwCurrentWmaFileOffset-m_dwSrcBufferOffset) < m_dwLookaheadSize/2) {

        //
        // no need to do any file i/o
        //

        DBG_INFO(("ReadFile: no file I/o done\n"));

    } else {

        m_dwSrcBufferOffset = m_dwCurrentWmaFileOffset;        
        if (Offset) {
            ASSERT(m_dwSrcBufferOffset);
        }

    }

    if (Offset == m_dwSrcBufferOffset) {

        //
        // if offset did not change dont bother reading
        //


    } else {

        DBG_INFO((" CBGetData Reading ahead, offset %x, wma offset %x\n",
                  m_dwSrcBufferOffset,
                  m_dwCurrentWmaFileOffset));
    
        SetFilePointer(m_hFile, m_dwSrcBufferOffset, NULL, FILE_BEGIN);

        DBG_SPAM(("ReadFile(%x): calling readfile with context %x, pendingCount %x, listempty %d\n",
                 this, pContext, m_dwPendingPackets, IsListEmpty(&m_PendingList) ));
    
        m_overlapped.Offset = m_dwSrcBufferOffset;

        bResult = ReadFile(m_hFile,
                     pvBuffer,
                     dwSize,
                     &dwBytesRead,
                     (pContext ? &m_overlapped : NULL));

        if (!pContext && !bResult) {

            hr = HRESULT_FROM_WIN32(GetLastError());

            DBG_ERROR(("Wmaxmo::readfile: Read failed with %x\n",
                      hr));
                      
            return hr;

        }
     
    }

    if (pContext) {

        //
        // wait for overlapped operation
        //

        bResult = GetOverlappedResult(m_hFile,&m_overlapped,&dwBytesRead,TRUE);
        if (!bResult) {

            return HRESULT_FROM_WIN32(GetLastError());

        }

        //
        // decode wma data
        //
    
        hr = Decode(&pContext->Xmp);
    
        //
        // remove from pending list
        //
    
        RemoveEntryList(&pContext->ListEntry);
    
        //
        // return to available list
        //
    
        InsertHeadList(&m_AvailableList,
                       &pContext->ListEntry);
    
        m_dwPendingPackets--;
    
        DBG_SPAM(("WmaXMO::ReadFile(%x): completing context %x, pendingCount %x, listempty %d\n",
                 this, pContext, m_dwPendingPackets, IsListEmpty(&m_PendingList) ));
    
    
    }

    return HRESULT_FROM_NT(status);

}

HRESULT STDMETHODCALLTYPE CWMAXMediaObject::GetInfo( LPXMEDIAINFO pInfo )
{

    ASSERT(pInfo);

    pInfo->dwMaxLookahead = 0;
    pInfo->dwFlags = XMO_STREAMF_FIXED_SAMPLE_SIZE | 
        XMO_STREAMF_FIXED_PACKET_ALIGNMENT;

    //
    // we are decoder: GetOutput gives the minimum buffer we need to decode a 
    // block of wma data.
    //
    
    // No real minimum, the codec has its own internal buffer. But it likes to
    // decode in MAX_SAMPLES_PER_REQUEST sample chunks

    pInfo->dwOutputSize = m_hdr.num_channels * sizeof(short) * MAX_SAMPLES_PER_REQUEST; 
    return S_OK;
}
                                                   
HRESULT STDMETHODCALLTYPE CWMAXMediaObject::Discontinuity(void){
   return S_OK;
}

HRESULT STDMETHODCALLTYPE CWMAXMediaObject::GetStatus( 
    LPDWORD pdwStatus
    )
{

    if (pdwStatus) {

        *pdwStatus = XMO_STATUSF_ACCEPT_OUTPUT_DATA;

        if (m_bAsyncMode) {
    
            //
            // if we have no available contexts to queue packets,
            // tell caller to not submit anymore...
            //

            ENTER_CS(&m_CS);
            if (IsListEmpty(&m_AvailableList)) {
    
                *pdwStatus = 0;

            }
            LEAVE_CS(&m_CS);

        }

    }

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CWMAXMediaObject::GetFileContentDescription(WMAXMOFileContDesc* pContentDesc)
{
   HRESULT hr = S_OK;
   tWMA_U32 WmaErr = cWMA_NoErr;

   WmaErr = WMAFileContentDesc(m_state, (tWMAFileContDesc *) pContentDesc);
   if (WmaErr != cWMA_NoErr) {

       DBG_ERROR(("WMAFileContentDesc failed with 0x%x\n",WmaErr));
       return E_FAIL;
   }

   return hr;
}

HRESULT STDMETHODCALLTYPE CWMAXMediaObject::GetFormat(WAVEFORMATEX* pWave)
{
   pWave->wFormatTag = WAVE_FORMAT_PCM;
   pWave->nSamplesPerSec = WMASampleRateToHz(m_hdr.sample_rate);
   pWave->nChannels = m_hdr.num_channels;
   pWave->wBitsPerSample = 16;
   pWave->nBlockAlign = ((pWave->wBitsPerSample + 7) / 8) * pWave->nChannels;
   pWave->nAvgBytesPerSec = pWave->nBlockAlign * pWave->nSamplesPerSec;
   pWave->cbSize = 0;
   
   return S_OK;
}

HRESULT CWMAXMediaObject::Seek(LONG lOffset, DWORD dwOrigin, LPDWORD pdwAbsolute)
{
    HRESULT                 hr          = DS_OK;
    NTSTATUS                status;

    ASSERT(m_pCallback == NULL);

    ASSERT((lOffset == 0) && (dwOrigin == FILE_CURRENT) && "WmaXmo only supports querying current position");
    
    if(pdwAbsolute)
    {
        *pdwAbsolute = m_dwCurrentWmaFileOffset;
    }

    return hr;
}

HRESULT CWMAXMediaObject::GetLength(LPDWORD pdwLength)
{
    HRESULT                 hr  = DS_OK;
    
    //
    // you can not query file pointer if we are in-memory decoder
    //


    ASSERT(m_pCallback == NULL);

    if((*pdwLength = GetFileSize(m_hFile, NULL)) == -1)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}

__inline DWORD CWMAXMediaObject::WMASampleRateToHz(tWMAFileSampleRate sampleRate)
{

   UINT nSampleRate;
   switch (sampleRate)
   {
   case cWMA_SR_08kHz:
       nSampleRate = 8000;
       break;
       
   case cWMA_SR_11_025kHz:
       nSampleRate = 11025;
       break;
       
   case cWMA_SR_16kHz:
       nSampleRate = 16000;
       break;
       
   case cWMA_SR_22_05kHz:
       nSampleRate = 22050;
       break;
       
   case cWMA_SR_32kHz:
       nSampleRate = 32000;
       break;
       
   case cWMA_SR_44_1kHz:
       nSampleRate = 44100;
       break;
       
   case cWMA_SR_48kHz:
       nSampleRate = 48000;
       break;
       
   default:
       DBG_ERROR(("Unknown sample rate: %d\n", m_hdr.sample_rate));

       MYCHECK(0);
       nSampleRate = 0;
       break;
   }
   return nSampleRate;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\autoprofile.c ===
#include "bldsetup.h"

#pragma warning( disable : 4103 )
#include "AutoProfile.h"

#ifdef PROFILE

#include <stdio.h>
//#include <assert.h>
#include <tchar.h>

//****************************************************************************************
//
// The Zen and the Art of Profiling 
//   by Sil after much befuddlement
//
// Profile as few things as possible to get your result.  
//
// Each profile start-stop pair costs 3.770 microsocnds on a 500MHz Pentium.
// So profiling a per-coefficent function like getNextRunLevelHighRate costs 
// 2.3 seconds of execution time for a process which otherwise only takes 1.6 seconds
//
// Unless you correct for the start-stop overhead, changing the profile configurtation
// will effect the overall results.  A spreadsheet could take this current output and
// do such a correction - given you measure the start-stop overhead of your test machines.
//
// The start-stop overhead gets distributed to the parent and the child functions.
//
// Some runs are significantly off - if the results don't make sense, repeat them.
//
// But similiar runs are pretty similar.  I have not quantified the variance.
//
//****************************************************************************************
   
ProfileFunctionDeffinitionType Profiler_functionDefintions[MAX_FUNCTIONS_TO_PROFILE] = {0,_T(""),

MSAC_DECODE_PROFILE					,_T("Decode"),
DECODE_PROFILE                      ,_T("..audecDecode"),
WMA_FILE_DECODE_DATA_PROFILE        ,_T("..WMAFileDecodeData"),
DECODE_PACKET_PROFILE               ,_T("....DecodePacket"),
DECODE_FRAME_PROFILE                ,_T("......DecodeFrame"),
AUDEC_DECODE_DATA_PROFILE           ,_T("......audecDecodeData"),
SAVE_HISTORY_MONO_PROFILE			,_T("........Save History Mono"),
DECODE_SUB_FRAME_PROFILE            ,_T("........DecodeSubFrame"),
DECODE_SUB_FRAME_HIGH_RATE_PROFILE  ,_T("........DecodeSubFrameHighRate"),
DECODE_FRAME_HEADER_PROFILE         ,_T("..........DecodeFrameHeader"),
UPDATE_SUB_FRAME_CONFIG_PROFILE     ,_T("............UpdateSubFrameConfig"),
ADAPT_TO_SUB_FRAME_CONFIG_PROFILE   ,_T("............AdaptToSubFrameConfig"),
SET_DET_TABLE_PROFILE               ,_T("............SetDetTable"),
FRAME_HEADER_NOISE_SUB_PROFILE		,_T("............DecodeFrameHeaderNoiseSub"),
FRAME_HEADER_LPC_PROFILE			,_T("............DecodeFrameHeaderLpc"),
LPC_TO_SPECTRUM_PROFILE  			,_T("..............prvLpcToSpectrum"),
FFT32_PROFILE                       ,_T("................prvFFT32"),
GET_BAND_WEIGHTS_PROFILE			,_T("............GetBandWeightXxxRate"),
INVERSE_QUAN_HIGH_RATE_PROFILE      ,_T("..........InverseQuantizeHighRate"),
DECODE_COEFFICENTS_HIGH_RATE_PROFILE,_T("..........ReconCoefficentsHighRate"),

DECODE_COEFFICENT_STEREO_PROFILE    ,_T("..........DecodeCoefficientStereo"),
DECODE_COEFFICENT_MONO_PROFILE      ,_T("............prvDecodeCoefficientMono"),
DECODE_RUN_LEVEL_PROFILE            ,_T("..............prvDecodeRunLevel"),
HUFF_DEC_GET_PROFILE                ,_T("................HuffDecGet"),
INVERSE_QUAN_HIGH_SDTOLR_PROFILE	,_T("..........InverseQuantizeHighRateSDtoLR"),
INVERSE_QUAN_LOW_RATE_PROFILE		,_T("..........prvInverseQuantizeLowRate"),
INVERSE_QUAN_MID_RATE_PROFILE		,_T("..........prvInverseQuantizeMidRate"),
DCTIV_PROFILE                       ,_T("..........DctIV"),
FFT_PROFILE                         ,_T("............FFT"),

WMA_FILE_GET_PCM_PROFILE            ,_T("..WMAFileGetPCM"),
AU_GET_PCM_PROFILE                  ,_T("....auGetPCM"),
INVERSE_TRANSFORM_AND_RECON_PROFILE ,_T("........InverseTransformAndRecon"),
INVERSE_TRANSFORM_MONO_PROFILE		,_T("..........InverseTransformMono"),
RECON_MONO_PROFILE          		,_T("..........ReconMono"),
CONVERT_SD_TO_LR_PROFILE            ,_T("Convert s/d to l/r"),
INVERSE_OUANTIZE_SPECTRUM_PROFILE	,_T("Quantize Spectrum"),
0,_T("")
}; 

int     Profiler_functionCountCalls[MAX_FUNCTIONS_TO_PROFILE];
__int64 Profiler_functionTimings[MAX_FUNCTIONS_TO_PROFILE];
__int64 Profiler_functionPlusChildTimings[MAX_FUNCTIONS_TO_PROFILE];
__int64 Profiler_totalTime;
__int64 profileStartTime;
HANDLE hProfile;
FunctionProfile *Profiler_lastFunctionProfiler;

void Profiler_init(TCHAR* wcsProfilerName )
{
	Profiler_initEX(wcsProfilerName, 0 );
}

void Profiler_initEX(TCHAR* szProfilerName, int fAppend )
{
    LONGLONG startTime;
#if defined(_UNICODE) || defined(UNICODE)
	WCHAR* wcsProfilerName = szProfilerName;
#else
    WCHAR wcsProfilerName[200];
    mbstowcs( wcsProfilerName, szProfilerName, strlen(szProfilerName)+1 );
#endif

    hProfile = CreateFileW(wcsProfilerName, 
						   GENERIC_WRITE, FILE_SHARE_WRITE, NULL, 
						   fAppend ? OPEN_ALWAYS : CREATE_ALWAYS, 
						   FILE_ATTRIBUTE_NORMAL, NULL);

	if ( fAppend && hProfile != NULL )
		SetFilePointer( hProfile, 0L, NULL, FILE_END ); 

	memset( Profiler_functionCountCalls, 0, sizeof(int)*MAX_FUNCTIONS_TO_PROFILE );
	memset( Profiler_functionTimings, 0, sizeof(__int64)*MAX_FUNCTIONS_TO_PROFILE );
	memset( Profiler_functionPlusChildTimings, 0, sizeof(__int64)*MAX_FUNCTIONS_TO_PROFILE );

    Profiler_lastFunctionProfiler = NULL;
    Profiler_totalTime = 0;
    Profiler_getTimer(&startTime);
    profileStartTime = startTime;
}

void Profiler_print(TCHAR* szMsg)
{
    DWORD dwBytesWritten;		
    if (hProfile)
    {
        WriteFile(hProfile, (void*) szMsg, sizeof(TCHAR) * _tcslen(szMsg), &dwBytesWritten, NULL);
    }		
}

void Profiler_close(void)
{
	Profiler_closeEX(0,0,NULL);
}

void Profiler_closeEX(unsigned int Duration, DWORD TotalTime, TCHAR* szMsg)
{
    LONGLONG stopTime;
    int i = 1;
    TCHAR buff[120];
	float fltTotalTime;
    Profiler_getTimer(&stopTime);
    Profiler_totalTime = stopTime-profileStartTime;
	fltTotalTime = (float)Profiler_totalTime;
	if (szMsg != NULL)
		Profiler_print(szMsg);
    _stprintf(buff,_T("Total Time %10.0f\r\n\r\n"),fltTotalTime);
    Profiler_print(buff);
	if ( Duration != 0 && TotalTime != 0 )
	{	// change duration to media play duration converted to profiling time units
		fltTotalTime = Duration * (fltTotalTime/TotalTime);
		_stprintf(buff,_T("Play Time  %10.0f ms == %10.0f profile time units.\r\n\r\n"),(float)Duration, fltTotalTime);
		Profiler_print(buff);
	}
    _stprintf(buff,_T("  Function   Function  Function  Function\r\n"));
    Profiler_print(buff);
    _stprintf(buff,_T("   + child       only  + child   only\r\n"));
    Profiler_print(buff);
    _stprintf(buff,_T("      time       time  ratio     ratio     Count  Function Name\r\n\r\n"));
    Profiler_print(buff);
    do {
        int j = Profiler_functionDefintions[i].id;
        if (Profiler_functionPlusChildTimings[j] > 0) {
            
            _stprintf(buff,_T("%10.0f %10.0f  %7.5f   %7.5f %7d  %s,\r\n"),
				(float)(Profiler_functionPlusChildTimings[j]),
				(float)(Profiler_functionTimings[j]),
				((float)Profiler_functionPlusChildTimings[j]/fltTotalTime),
				((float)Profiler_functionTimings[j]/fltTotalTime),
				Profiler_functionCountCalls[j],
				Profiler_functionDefintions[i].name);
            Profiler_print(buff);
        }
    } while (++i < MAX_FUNCTIONS_TO_PROFILE);

	CloseHandle(hProfile);
}
#endif	// PROFILE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\bldsetup.h ===
/*++

Copyright (c) 2001  Microsoft Corporation. All rights reserved.

Module Name:

    bldsetup.h

Abstract:

    Compiler and linker customizations

--*/

#ifdef _XBOX
#ifndef _BLDSETUP_H
#define _BLDSETUP_H

//
// Put code and data into named sections so that
// games could potentially unload them when they're not needed anymore
//
#pragma code_seg("WMVDEC")
#pragma data_seg("WMVDECRW")
#pragma const_seg("WMVDECRD")

//
// Remap some internal function names. This is a temporary fix to
// resolve link-time conflicts between WMA and WMV decoders.
// Post-launch, we should change dsound to pick up the new WMA decoder code.
// Then we can remove the WMA decoder files here and just use what's in dsound.
//

#define WMARawDecClose          WMV_WMARawDecClose
#define WMARawDecReset          WMV_WMARawDecReset
#define WMARawDecStatus         WMV_WMARawDecStatus
#define WMARawDecGetPCM         WMV_WMARawDecGetPCM
#define SWAPWORD                WMV_SWAPWORD
#define SWAPDWORD               WMV_SWAPDWORD
#define SwapWstr                WMV_SwapWstr
#define auInitPcInfoDEC         WMV_auInitPcInfoDEC
#define prvOutputBufferSize     WMV_prvOutputBufferSize
#define prvFinalLoad            WMV_prvFinalLoad
#define g_cBitGet               WMV_g_cBitGet
#define getMask                 WMV_getMask
#define WMA_set_fNoMoreData     WMV_WMA_set_fNoMoreData
#define WMA_get_nHdrBits        WMV_WMA_get_nHdrBits

#define ibstrmBitsLeft          WMV_ibstrmBitsLeft
#define ibstrmSetGetMoreData    WMV_ibstrmSetGetMoreData
#define ibstrmSetUserData       WMV_ibstrmSetUserData
#define ibstrmSetOwner          WMV_ibstrmSetOwner
#define ibstrmGetPacketHeader   WMV_ibstrmGetPacketHeader
#define ibstrmSetPacketHeader   WMV_ibstrmSetPacketHeader
#define ibstrmFlush             WMV_ibstrmFlush
#define ibstrmInit              WMV_ibstrmInit
#define ibstrmReset             WMV_ibstrmReset
#define ibstrmGetMoreData       WMV_ibstrmGetMoreData
#define ibstrmResetPacket       WMV_ibstrmResetPacket
#define ibstrmPeekBitsNonStop   WMV_ibstrmPeekBitsNonStop
#define ibstrmPeekBits          WMV_ibstrmPeekBits
#define ibstrmLookForBits       WMV_ibstrmLookForBits
#define ibstrmFlushBits         WMV_ibstrmFlushBits
#define ibstrmGetBits           WMV_ibstrmGetBits
#define ibstrmAttach            WMV_ibstrmAttach

#define RandStateClear          WMV_RandStateClear
#define LOG2                    WMV_LOG2
#define ROUNDF                  WMV_ROUNDF
#define MyOutputDbgStr          WMV_MyOutputDbgStr
#define ffltAvgSquareWeights    WMV_ffltAvgSquareWeights
#define ffltSqrtRatio           WMV_ffltSqrtRatio
#define fltPerfTimerDecodeTime  WMV_fltPerfTimerDecodeTime
#define quickRand               WMV_quickRand
#define huffDecGet              WMV_huffDecGet
#define InverseQuadRootOfSumSquares WMV_InverseQuadRootOfSumSquares
#define InverseQuadRootI        WMV_InverseQuadRootI

#define TraceInfoHelper         WMV_TraceInfoHelper
#define PerfTimerNew            WMV_PerfTimerNew
#define PerfTimerStart          WMV_PerfTimerStart
#define PerfTimerStop           WMV_PerfTimerStop
#define PerfTimerStopElapsed    WMV_PerfTimerStopElapsed
#define PerfTimerReport         WMV_PerfTimerReport
#define PerfTimerFree           WMV_PerfTimerFree

#define g_rgiHuffDecTblMsk      WMV_g_rgiHuffDecTblMsk
#define g_rgiHuffDecTblNoisePower WMV_g_rgiHuffDecTblNoisePower
#define g_rgiHuffDecTbl16smOb   WMV_g_rgiHuffDecTbl16smOb
#define g_rgiHuffDecTbl44smOb   WMV_g_rgiHuffDecTbl44smOb
#define g_rgiHuffDecTbl16ssOb   WMV_g_rgiHuffDecTbl16ssOb
#define g_rgiHuffDecTbl44ssOb   WMV_g_rgiHuffDecTbl44ssOb
#define g_rgiHuffDecTbl44smQb   WMV_g_rgiHuffDecTbl44smQb
#define g_rgiHuffDecTbl44ssQb   WMV_g_rgiHuffDecTbl44ssQb
#define g_rgiBarkFreq           WMV_g_rgiBarkFreq
#define g_rgfiPwrToRMS          WMV_g_rgfiPwrToRMS
#define g_rgfltLsfReconLevel    WMV_g_rgfltLsfReconLevel
#define g_SinTableForReconstruction WMV_g_SinTableForReconstruction
#define rgSinCosTables          WMV_rgSinCosTables
#define rgiMaskMinusPower10     WMV_rgiMaskMinusPower10
#define rgiMaskPlusPower10      WMV_rgiMaskPlusPower10
#define rgDBPower10             WMV_rgDBPower10
#define rgfltDBPowerExponentScale WMV_rgfltDBPowerExponentScale

#define g_sct64                 WMV_g_sct64
#define g_sct128                WMV_g_sct128
#define g_sct256                WMV_g_sct256
#define g_sct512                WMV_g_sct512
#define g_sct1024               WMV_g_sct1024
#define g_sct2048               WMV_g_sct2048
#define gRun16smOb              WMV_gRun16smOb
#define gRun16ssOb              WMV_gRun16ssOb
#define gRun44smOb              WMV_gRun44smOb
#define gRun44ssOb              WMV_gRun44ssOb
#define gRun44smQb              WMV_gRun44smQb
#define gRun44ssQb              WMV_gRun44ssQb
#define gLevel16smOb            WMV_gLevel16smOb
#define gLevel16ssOb            WMV_gLevel16ssOb
#define gLevel44smOb            WMV_gLevel44smOb
#define gLevel44ssOb            WMV_gLevel44ssOb
#define gLevel44smQb            WMV_gLevel44smQb
#define gLevel44ssQb            WMV_gLevel44ssQb

#ifndef WMV_MEMORY_DEBUGGING

#define wmvalloc    malloc
#define wmvfree     free
#define wmvrealloc  realloc

#else // WMV_MEMORY_DEBUGGING

#include <malloc.h>

#ifdef __cplusplus
extern "C" {
#endif

void  WmvDebugMemInit();
void* WmvDebugAlloc(char* filename, int linenum, size_t size);
void  WmvDebugFree(void* ptr);
void* WmvDebugRealloc(char* filename, int linenum, void* ptr, size_t size);

#define wmvalloc(size) WmvDebugAlloc(__FILE__, __LINE__, size)
#define wmvfree WmvDebugFree
#define wmvrealloc(ptr, size) WmvDebugRealloc(__FILE__, __LINE__, ptr, size)

#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
static __forceinline void* __cdecl operator new(size_t size) { return wmvalloc(size); }
static __forceinline void __cdecl operator delete(void* ptr) { wmvfree(ptr); }

static __forceinline void* __cdecl operator new[](size_t size) { return wmvalloc(size); }
static __forceinline void __cdecl operator delete(void* ptr ) { wmvfree(ptr); }
#endif

#endif // WMV_MEMORY_DEBUGGING

#endif // !_BLDSETUP_H
#endif // XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\config.c ===
#include "bldsetup.h"

//V7PLUS/Scrunch/wmaudio/integer/config/config.c#1 - add change 18676 (text)
#include "msaudio.h"
#include "config.h"

//
// Structures we use to store the samplingrate/bitrate mapping
//
#pragma pack(1)                 // byte-pack the structure
typedef struct WMARateEntry_tag
{
    U32 nBitrate;             // bit rate
    U8  nFramesLookAhead;     // no. of look ahead frames
    
    U8  fAllowSuperFrame;
    U8  nFramesPerPacket;
    U8  nMaxSubFrameDiv;
    
    WeightMode wtMode; //from msaudio.h, typedef enum {LPC_MODE=0,BARK_MODE} WeightMode;
    
} WMARateEntry;
#pragma pack()

typedef struct WMARateList_tag
{
    U32 nSamplingRate;
    U32 nChannels;
    U32 nEntries;
    const WMARateEntry *pRates;
} WMARateList;


#define SIZEOF_ARRAY(ar) (sizeof(ar)/sizeof((ar)[0]))

//
// Data for the samplingrate/bitrate mapping
//
// ---------------------------------------------------------------------------
// For Windows Media Audio V2

// mono
static const WMARateEntry gWma2RateList8000m[] = {
#if !defined (V7_CONFIG) // use buffer, rather than frame cbr
    { 8000, 32, 1, 10, 2, LPC_MODE }, // no-sub
    { 6000, 32, 1, 10, 2, LPC_MODE }, // sub
    { 5000, 32, 1, 10, 2, LPC_MODE }, // sub
#else
    { 8000, 0, 0, 1, 1, LPC_MODE }, // no-sub
    { 6000, 0, 0, 1, 1, LPC_MODE }, // sub
    { 5000, 0, 0, 1, 1, LPC_MODE }, // sub
#endif // !defined (V7_CONFIG) 
    {  128, 0, 0, 1, 1, LPC_MODE }  /* special silence mode: can't go any lower because nBlockAlign has to be >= 1 */
};

static const WMARateEntry gWma2RateList11025m[] = {
#if !defined (V7_CONFIG) // use buffer, rather than frame cbr
    { 10000, 32, 1, 10, 2, LPC_MODE },// sub
    {  8000, 32, 1, 10, 2, LPC_MODE } // sub
#else
    { 10000, 0, 0, 1, 1, LPC_MODE },// sub
    {  8000, 0, 0, 1, 1, LPC_MODE } // sub
#endif  // !defined (V7_CONFIG)
};

static const WMARateEntry gWma2RateList16000m[] = { // 448ms per packet, or 2.23 packets per second.
#if !defined (V7_CONFIG) // increase # packets per buffer
    { 16000, 32, 1, 10, 4, LPC_MODE },// In encoder, we produce max 2 subframes in this config.
    { 12000, 32, 1, 10, 2, LPC_MODE },// In encoder, we produce max 2 subframes in this config.
    { 10000, 32, 1, 10, 2, LPC_MODE },// In encoder, we produce max 2 subframes in this config.
#else
    { 16000, 32, 1, 14, 4, LPC_MODE },// sub
    { 12000, 32, 1, 14, 2, LPC_MODE },// sub
    { 10000, 32, 1, 14, 2, LPC_MODE },// sub
#endif
};

static const WMARateEntry gWma2RateList22050m[] = { // 325ms per packet, or 3.08 packets per second.
#if !defined (V7_CONFIG) // increase # packets per buffer
    { 20000, 32, 1, 8, 8, BARK_MODE },// sub
    { 16000, 32, 1, 8, 4,  BARK_MODE },// sub
#else
    { 20000, 32, 1, 14, 8, LPC_MODE },// sub
    { 16000, 32, 1, 14, 4, LPC_MODE },// sub
#endif
};

static const WMARateEntry gWma2RateList32000m[] = {
#if !defined (V7_CONFIG) // increase # packets per buffer
    { 20000, 32, 1, 8, 8, BARK_MODE } // sub // 640ms per packet, or 1.5625 packets per second. 
#else
    { 20000, 32, 1, 10, 8, LPC_MODE } // sub // 640ms per packet, or 1.5625 packets per second. 
#endif
};

static const WMARateEntry gWma2RateList44100m[] = { // 371.5ms per packet, or 2.69 packets per second
    { 48000, 32, 1, 8, 16, BARK_MODE },// no-sub
    { 32000, 32, 1, 8, 16, BARK_MODE },// no-sub
};

// stereo
static const WMARateEntry gWma2RateList8000s[]  = {
#if !defined (V7_CONFIG) // use buffer, rather than frame cbr
    { 12000, 32, 1, 10, 2, LPC_MODE }   // sub
#else
    { 12000, 0, 0, 1, 1, LPC_MODE }   // sub
#endif  // !defined (V7_CONFIG) 
};


static const WMARateEntry gWma2RateList16000s[] = { // 640ms per packet, or 1.5625 packets per second.
#if !defined (V7_CONFIG) // increase # packets per buffer
    { 20000, 32, 1, 10, 8, LPC_MODE }, // In encoder, we produce max 2 subframes in this config.
    { 16000, 32, 1, 10, 4, LPC_MODE }  // In encoder, we produce max 2 subframes in this config.
#else
    { 20000, 32, 1, 14, 8, LPC_MODE }, // sub
    { 16000, 32, 1, 14, 4, LPC_MODE }  // sub
#endif
};

static const WMARateEntry gWma2RateList22050s[] = { 
    { 32000, 32, 1, 8, 8, BARK_MODE }, // sub // 371.5ms per packet, or 2.69 packets per second. 
#if !defined (V7_CONFIG)  // increase # packets per buffer
    { 22000, 32, 1, 8, 4, BARK_MODE },// sub // 650ms per packet, or 1.538 packets per second. 
    { 20000, 32, 1, 8, 4, BARK_MODE } // sub // 650ms per packet, or 1.538 packets per second. 
#else
    { 22000, 32, 1, 14, 4, LPC_MODE },// sub // 650ms per packet, or 1.538 packets per second. 
    { 20000, 32, 1, 14, 4, LPC_MODE } // sub // 650ms per packet, or 1.538 packets per second. 
#endif
};

static const WMARateEntry gWma2RateList32000s[] = { // 384ms per packet, or 2.60 packets per second.
#if !defined (V7_CONFIG)
    { 48000, 32, 1, 6, 16, BARK_MODE}, // no-sub: addl subframes found useful 10/6/00
#else
    { 48000, 32, 1, 6, 8, BARK_MODE}, // sub 
#endif // !defined (V7_CONFIG)
    { 40000, 32, 1, 6, 8, BARK_MODE }, // sub
    { 32000, 32, 1, 6, 8, BARK_MODE }  // sub
};

static const WMARateEntry gWma2RateList44100s[] = { // 371.5ms per packet, or 2.69 packets per second
    { 192000, 32, 1, 8, 16, BARK_MODE }, // no-sub
    { 160000, 32, 1, 8, 16, BARK_MODE }, // no-sub
    { 128000, 32, 1, 8, 16, BARK_MODE }, // no-sub
    {  96000, 32, 1, 8, 16, BARK_MODE }, // no-sub
    {  80000, 32, 1, 8, 16, BARK_MODE }, // no-sub
    {  64000, 32, 1, 8, 16, BARK_MODE }, // no-sub
    {  48000, 64, 1, 8, 16, BARK_MODE }, // addl buffer to have maximum freedom
    {  32000, 64, 1, 8,  8, BARK_MODE },  // addl buffer to have maximum freedom
};

static const WMARateEntry gWma2RateList48000s[] = { // 341ms per packet, or 2.93 packets per second
    { 192000, 32, 1, 8, 16, BARK_MODE }, // no-sub
    { 160000, 32, 1, 8, 16, BARK_MODE }, // no-sub
    { 128000, 32, 1, 8, 16, BARK_MODE }  // no-sub
};

static const WMARateList gWma2RateList[] = {
    {    8000, 1, SIZEOF_ARRAY(gWma2RateList8000m),  &gWma2RateList8000m[0] }
    , {  8000, 2, SIZEOF_ARRAY(gWma2RateList8000s),  &gWma2RateList8000s[0] }
    , { 11025, 1, SIZEOF_ARRAY(gWma2RateList11025m), &gWma2RateList11025m[0] }
    , { 11025, 2, 0/*SIZEOF_ARRAY(gWma2RateList11025s)*/, NULL/*&gWma2RateList11025s[0]*/ }
    , { 16000, 1, SIZEOF_ARRAY(gWma2RateList16000m), &gWma2RateList16000m[0] }
    , { 16000, 2, SIZEOF_ARRAY(gWma2RateList16000s), &gWma2RateList16000s[0] }
    , { 22050, 1, SIZEOF_ARRAY(gWma2RateList22050m), &gWma2RateList22050m[0] }
    , { 22050, 2, SIZEOF_ARRAY(gWma2RateList22050s), &gWma2RateList22050s[0] }
    , { 32000, 1, SIZEOF_ARRAY(gWma2RateList32000m), &gWma2RateList32000m[0] }
    , { 32000, 2, SIZEOF_ARRAY(gWma2RateList32000s), &gWma2RateList32000s[0] }
    , { 44100, 1, SIZEOF_ARRAY(gWma2RateList44100m), &gWma2RateList44100m[0] }
    , { 44100, 2, SIZEOF_ARRAY(gWma2RateList44100s), &gWma2RateList44100s[0] }
    , { 48000, 1, 0/*SIZEOF_ARRAY(gMwa2RateList48000m)*/, NULL/*&gWma2RateList48000m[0]*/ }
    , { 48000, 2, SIZEOF_ARRAY(gWma2RateList48000s), &gWma2RateList48000s[0] }
};

////////////////////////////////////////////////////////////////////////
// Helper for finding the right PCM list in the above table
////////////////////////////////////////////////////////////////////////
const WMARateList *
findRateListByPCMParams(U32 nSamplingRate,
                        U32 nChannels)
{
   const WMARateList* pRateList = gWma2RateList;
   U32 nRateLists = SIZEOF_ARRAY(gWma2RateList);
   U32 i;

   for(i = 0; i < nRateLists; i++) {
      if(pRateList[i].nSamplingRate == nSamplingRate &&
         pRateList[i].nChannels == nChannels)
           return pRateList[i].pRates ? &pRateList[i] : NULL;
   }
   return NULL;
}


////////////////////////////////////////////////////////////////////////
// Logic to compupte recommended encoder settings
////////////////////////////////////////////////////////////////////////
static U16 prvEncOptionsBitMask (WeightMode wtMode,
                                 Bool bUseSuperFrame,
                                 Bool bUseSubFrame,
                                 U32 nMaxSubFrameDiv,
                                 Bool bLowBitRate) {
    U16 wEncodeOptions;
    
    if (wtMode == BARK_MODE) 
        wEncodeOptions = 1;
    else                  
    {
        //per discussion with serges, mingcl. we are ok to use 20 now.
#if !defined (V7_CONFIG)
        wEncodeOptions = 0x20;
#else
        wEncodeOptions = 0x00;
#endif
    }
    
    // for V2 and above?
    if(bUseSuperFrame)      // bit 1: fAllowSuperFrame
        wEncodeOptions |= 0x2;
    
    if(bUseSubFrame) {
        
        // bit 2: fAllowSubFrame, only valide when fAllowsuperFrame==TRUE
        wEncodeOptions |= 0x4;
        
        // bit 3-4: cSubFrames in a Frame, only valid when fAllowSubFrame==TRUE
        //   for >= 32 kbps / channel : 00 = 8, 01 = 16, 10 = 32, 11 = 64
        //                              (always default to 16 for now)
        //   for <  32 kbps / channel : 00 = 2, 01 = 4 , 10 = 8, 11 = 16
        //                              (not used for now since fAllowSubFrame
        //                               should always be false for this case)
        if (!bLowBitRate) {
            assert(nMaxSubFrameDiv >= 8 && nMaxSubFrameDiv <= 64);
            wEncodeOptions |= (LOG2(nMaxSubFrameDiv) - 3) << 3;
        }
        else {
            assert(nMaxSubFrameDiv >= 2 && nMaxSubFrameDiv <= 16);
            wEncodeOptions |= (LOG2(nMaxSubFrameDiv) - 1) << 3;
        }
    }
    
    return wEncodeOptions;
}

U16 prvEncodeOptions(U32 nSamplesPerSec,
                     U32 nChannels,
                     const WMARateEntry* pEntry) {
    return prvEncOptionsBitMask(pEntry->wtMode,
        pEntry->fAllowSuperFrame,
        pEntry->fAllowSuperFrame,
        pEntry->nMaxSubFrameDiv,
        pEntry->nBitrate / nChannels < 32000);
}

/////////////////////////
//                     //
//   Frame size math   //
//                     //
/////////////////////////

// returns a * b / c, rounding up
U32 MyMulDiv(U32 a, U32 b, U32 c) {
    // first cancel out some 2's to reduce the risk of overflows
    do {
        U32 tmpA = a & 1;
        U32 tmpB = b & 1;
        U32 tmpC = c & 1;
        if (tmpC) // c is no longer even - done
            break;
        if (!tmpA) // a is still even
            a >>= 1;
        else if (!tmpB) // b is still even
            b >>= 1;
        else // neither a nor b is even - done
            break;
        c >>= 1;
    } while (1);
    
    return (a * b + c - 1) / c;
}

//
// Define a common way of rounding things in various computations.
//

// returns the approximate average number of compressed bits for n samples
U32 SamplesToBits(U32 cSamples, U32 ulSamplingRate, U32 ulBitrate) {
   return MyMulDiv(ulBitrate, cSamples, ulSamplingRate);
}
U32 BitsToBytes(U32 cBits) {
    return (cBits + 7) / 8;
}

U32 prvSamplesPerPacket(U32 ulSamplingRate,
                        U32 ulChannels,
                        U32 ulBitrate,
                        U32 ulFramesPerPacket) {
   return ulFramesPerPacket * msaudioGetSamplePerFrame(ulSamplingRate, ulBitrate, ulChannels, 2);
}

//
// Picks a packet size that will give us approximately the desired bitrate
//
U32 prvBytesPerPacket(U32 ulSamplingRate,
                      U32 ulChannels,
                      U32 ulBitrate,
                      U32 ulFramesPerPacket) {
    U32 cSamplesPerPacket, cbPacket;
    if (ulBitrate == 128) return 1; // silence mode
    cSamplesPerPacket = prvSamplesPerPacket(ulSamplingRate, ulChannels, ulBitrate, ulFramesPerPacket);
    cbPacket = BitsToBytes(SamplesToBits(cSamplesPerPacket,
                                         ulSamplingRate,
                                         ulBitrate));
    
    // 32_44_2: bring nAvgBytesPerSec below 4000 to prevent ARM decoder crash
    if (ulSamplingRate == 44100 && ulChannels == 2 && ulBitrate == 32000) {
      // predict nAvgBytesPerSec by simulating the prvActualBitrate() logic
      while (BitsToBytes(MyMulDiv(8 * cbPacket,
                                  ulSamplingRate,
                                  cSamplesPerPacket)) >= 4000) {
        cbPacket--;
      }
    }
    return cbPacket;
}

//
// Returns the average bitrate according to the formula
//
//                 bits per packet  *  sampling rate
//    bitrate = -------------------------------------
//                       samples per packet
//
// The value returned by this function is accurate to within 1 bit per second
//
U32 prvActualBitrate(U32 ulSamplingRate,
                     U32 ulChannels,
                     U32 ulBitrate,
                     U32 ulFramesPerPacket) {
    return MyMulDiv(8 * prvBytesPerPacket(ulSamplingRate, ulChannels, ulBitrate, ulFramesPerPacket),
                    ulSamplingRate,
                    prvSamplesPerPacket(ulSamplingRate, ulChannels, ulBitrate, ulFramesPerPacket));
}

U32 prvBytesPerSec(U32 ulSamplingRate,
                   U32 ulChannels,
                   U32 ulBitrate,
                   U32 ulFramesPerPacket) {
   return BitsToBytes(prvActualBitrate(ulSamplingRate, ulChannels, ulBitrate, ulFramesPerPacket));
}

U32 prvPseudoSuperframeSamples(U32 ulSamplingRate,
                               U32 ulChannels,
                               U32 ulBitrate,
                               U32 ulFramesPerPacket,
                               U32 nBufLengthSamples) {
    
    // round down to the nearest multiple of whole packets
    U32 cSamplesPerPacket = prvSamplesPerPacket(ulSamplingRate, ulChannels, ulBitrate, ulFramesPerPacket);
    return nBufLengthSamples / cSamplesPerPacket * cSamplesPerPacket;
}

U32 prvPseudoSuperframeSize(U32 ulSamplingRate,
                            U32 ulChannels,
                            U32 ulBitrate,
                            U32 ulFramesPerPacket,
                            U32 nBufLengthSamples)
{
    // now convert from samples to compressed bytes
    return BitsToBytes(SamplesToBits(prvPseudoSuperframeSamples(ulSamplingRate, ulChannels, ulBitrate, ulFramesPerPacket, nBufLengthSamples),
                                     ulSamplingRate,
                                     prvActualBitrate(ulSamplingRate, ulChannels, ulBitrate, ulFramesPerPacket)));
}
/////////////////////////////
//                         //
//   End frame size math   //
//                         //
/////////////////////////////


//
// Proper ASF A/V interleaving requires at least a certain number
// of packets per second (about 3 for bitrates below 32kbps and
// about 5 for 32kbps and higher).  Our preferred packet sizes
// in the table above do not meet these requirements for sampling
// rates >= 16kHz.  However, we want to keep it that way for
// audio-only scenarios.
//
// The solution we use is to enumerate two separate format entries
// for any format whose default nFramesPerPacket does not meet the
// ASF AV interleave requirements.  One format (enumerated first)
// has the normal (preferred for audio-only) packet size.  The
// other, enumerated later, has a smaller packet size, suitable
// for ASF AV Interleave.
//
// These functions abstract the logic of choosing which formats
// need two entries,
//
U32 prvFramesPerPacketForASFAVInterleave(U32 ulSamplingRate, U32 ulChannels, const WMARateEntry* pEntry) {
    U32 ulRequiredPacketsPerSec = (pEntry->nBitrate >= 32000) ? 5 : 3;
    U32 ulSamplesPerFrame = msaudioGetSamplePerFrame(ulSamplingRate, pEntry->nBitrate, ulChannels, 2);
    if (ulSamplingRate / (pEntry->nFramesPerPacket * ulSamplesPerFrame) >= ulRequiredPacketsPerSec)
        return pEntry->nFramesPerPacket; // no need to have a special mode
    else // compute the special value
        return ulSamplingRate / (ulRequiredPacketsPerSec * ulSamplesPerFrame);
}

// If the default frames-per-packet from this entry does not work for
// AV interleave then we will have a second version of this format that does.
Bool prvIsSpecialForASFAVInterleave(U32 ulSamplingRate, U32 ulChannels, const WMARateEntry* pEntry) {
    if (pEntry->nFramesPerPacket !=
        prvFramesPerPacketForASFAVInterleave(ulSamplingRate,
                                          ulChannels,
                                          pEntry)) {
        return WMAB_TRUE;
    }
    else
        return WMAB_FALSE;
}


// Calls various functions and stuffs the results into a single struct
void prvInitializeFormat(WMAFormatInfo* pFormat,
                         U32 ulSamplingRate,
                         U32 ulChannels,
                         const WMARateEntry* pEntry,
                         Bool fSpecialASFAVInterleave) {
    U32 ulBitrate = pEntry->nBitrate;
    U32 nSamplesPerFrame = msaudioGetSamplePerFrame(ulSamplingRate, ulBitrate, ulChannels, 2);
    U32 nFramesPerPacket;
    if (fSpecialASFAVInterleave)
        nFramesPerPacket = prvFramesPerPacketForASFAVInterleave(ulSamplingRate, ulChannels, pEntry);
    else
        nFramesPerPacket = pEntry->nFramesPerPacket;

    // base WAVEFORMATEX
    pFormat->nSamplesPerSec  = ulSamplingRate;
    pFormat->nChannels       = ulChannels;
    pFormat->nAvgBytesPerSec = prvBytesPerSec(ulSamplingRate, ulChannels, ulBitrate, nFramesPerPacket);
    pFormat->nBlockAlign     = prvBytesPerPacket(ulSamplingRate, ulChannels, ulBitrate, nFramesPerPacket);
    
    pFormat->nLookaheadSamples    = pEntry->nFramesLookAhead * nSamplesPerFrame;

    // extended WAVEFORMATEX   
    pFormat->nSamplesPerBlock  = prvSamplesPerPacket(ulSamplingRate, ulChannels, ulBitrate, nFramesPerPacket);
    pFormat->dwSuperBlockAlign = prvPseudoSuperframeSize(ulSamplingRate, ulChannels, ulBitrate, nFramesPerPacket, pFormat->nLookaheadSamples);
    pFormat->wEncodeOptions    = prvEncodeOptions(ulSamplingRate, ulChannels, pEntry);

    // miscellaneous
    pFormat->nFramesPerPacket     = nFramesPerPacket;
    pFormat->nSamplesPerFrame     = nSamplesPerFrame;
    pFormat->nMaxSamplesPerPacket = MaxSamplesPerPacket(2, ulSamplingRate, ulChannels, ulBitrate);
    pFormat->nSuperFrameSamples   = prvPseudoSuperframeSamples(ulSamplingRate, ulChannels, ulBitrate, nFramesPerPacket, pFormat->nLookaheadSamples);
    pFormat->ulOfficialBitrate    = ulBitrate;
}

//
// "Special" formats are the versions modified adapted for ASF AV interleave.
// "Normal" formats are the ones listed in the table.
//
U32 prvNormalFormatCount() {
    static U32 cRet;
    static int fAlreadyComputed = 0;
    
    if (!fAlreadyComputed) {
        const WMARateList* pList = gWma2RateList;
        U32 cList = SIZEOF_ARRAY(gWma2RateList), nList;
        cRet = 0;
        for (nList = 0; nList < cList; nList++)
            cRet += pList[nList].nEntries;
        fAlreadyComputed = 1;
    }
    return cRet;
}
U32 prvSpecialFormatCount() {
    static U32 cRet;
    static int fAlreadyComputed = 0;
    
    if (!fAlreadyComputed) {
        const WMARateList* pList = gWma2RateList;
        U32 cList = SIZEOF_ARRAY(gWma2RateList), nList;
        cRet = 0;
        for (nList = 0; nList < cList; nList++) {
            U32 nEntry;
            for (nEntry = 0; nEntry < pList[nList].nEntries; nEntry++) {
                if (prvIsSpecialForASFAVInterleave(pList[nList].nSamplingRate,
                                                   pList[nList].nChannels,
                                                   &(pList[nList].pRates[nEntry]))) {
                    cRet++;
                }
            }
        }
        fAlreadyComputed = 1;
    }
    return cRet;
}
////////////////////////////////////////////////////////////////////////
//
// public entry points for enumerating and checking supported formats
//
////////////////////////////////////////////////////////////////////////

Bool GetPCMParamsByIndex(U32 ulIndex, U32* pulSamplingRate, U32* pulChannels) 
{
    const WMARateList* pList = gWma2RateList;
    U32 cList = SIZEOF_ARRAY(gWma2RateList);
    U32 cEntry = 0, cValid = 0;

   while (cEntry < cList) {
      if (pList[cEntry].nEntries) {
         if (cValid == ulIndex) {
            *pulSamplingRate = pList[cEntry].nSamplingRate;
            *pulChannels = pList[cEntry].nChannels;
            return WMAB_TRUE;
         }
         cValid++;
      }
      cEntry++;
   }
   return WMAB_FALSE;
}

Bool CheckPCMParams(U32 ulSamplingRate, U32 ulChannels) {
   if (findRateListByPCMParams(ulSamplingRate, ulChannels))
      return WMAB_TRUE;
   else
      return WMAB_FALSE;
}


U32 TotalFormatCount(Bool fIncludeASFAVInterleaveSpecial) {
    if (fIncludeASFAVInterleaveSpecial)
        return prvNormalFormatCount() + prvSpecialFormatCount();
    else
        return prvNormalFormatCount();
}

Bool GetFormatByIndex(U32 ulIndex, Bool fIncludeASFAVInterleaveSpecial, WMAFormatInfo *pFormat) {
    const WMARateList* pRateList = gWma2RateList;
    U32 nRateLists = SIZEOF_ARRAY(gWma2RateList);
    U32 iList;
    const WMARateEntry* pEntry = NULL;
    
   //
   // This translates an external index (where there are two positions for
   // every special format) into an internal one (where any every format
   // has just one position.  Also assigns the "special" flag based on the
   // external index.
   //
   // The way this mapping works is somewhat arbitrary.  We could have also
   // placse the peferred and special versions of each special format next
   // to each other.  I chose to put all the special versions at the end,
   // so that if a caller does not require the special version they may
   // never even get to the special section in the enumeration process.
   //
   Bool fSpecialASFAVInterleave = WMAB_FALSE;
   if (ulIndex >= prvNormalFormatCount() + prvSpecialFormatCount())
       return WMAB_FALSE;

   if (ulIndex >= prvNormalFormatCount()) {
       if (!fIncludeASFAVInterleaveSpecial)
           return WMAB_FALSE;
       fSpecialASFAVInterleave = WMAB_TRUE;
       ulIndex -= prvNormalFormatCount();
   }
   
   //
   // Now find the nth entry in our tables
   //
   for(iList = 0; iList < nRateLists; iList++) {
       if (fSpecialASFAVInterleave) {
           // go into the rate list and count the special entries
           U32 iRate;
           for (iRate = 0; iRate < pRateList[iList].nEntries; iRate++) {
               if (prvIsSpecialForASFAVInterleave(pRateList[iList].nSamplingRate,
                                                  pRateList[iList].nChannels,
                                                  &(pRateList[iList].pRates[iRate]))) {
                   if (ulIndex == 0) { // this is it
                       pRateList = &(pRateList[iList]);
                       pEntry = &(pRateList->pRates[iRate]);
                       goto found;
                   }
                   ulIndex--;
               }
           }
       }
       else { // skip whole lists based on their format count
           if(ulIndex < pRateList[iList].nEntries) {
               pRateList = &(pRateList[iList]);
               pEntry = &(pRateList->pRates[ulIndex]);
               goto found;
           }
           ulIndex -= pRateList[iList].nEntries;
       }
   }

found:
   if (!pEntry) {
       assert(!"bug in GetFormatByIndex or GetFormatCount");
       return WMAB_FALSE;
   }

   prvInitializeFormat(pFormat, pRateList->nSamplingRate, pRateList->nChannels, pEntry, fSpecialASFAVInterleave);
   return WMAB_TRUE;
}

Bool GetFormatByPCMParamsAndIndex(U32 ulIndex, U32 ulSamplingRate, U32 ulChannels, Bool fIncludeASFAVInterleaveSpecial, WMAFormatInfo* pFormat) {
   const WMARateList* pRateList = findRateListByPCMParams(ulSamplingRate, ulChannels);
   U32 nEntry, nSpecial;
   
   if (!pRateList)
      return WMAB_FALSE;
   
   if (ulIndex < pRateList->nEntries) { // normal
       prvInitializeFormat(pFormat, ulSamplingRate, ulChannels, &(pRateList->pRates[ulIndex]), WMAB_FALSE);
       return WMAB_TRUE;
   }

   if (!fIncludeASFAVInterleaveSpecial)
       return WMAB_FALSE;

   // ASFAVInterleave special - if it exists
   ulIndex -= pRateList->nEntries;
   // Find the nth special entry
   for (nEntry = 0, nSpecial = 0; nEntry < pRateList->nEntries; nEntry++) {
       if (prvIsSpecialForASFAVInterleave(ulSamplingRate, ulChannels, &(pRateList->pRates[ulIndex]))) {
           if (nSpecial == ulIndex) { // found the beast !
               prvInitializeFormat(pFormat, ulSamplingRate, ulChannels, &(pRateList->pRates[ulIndex]), WMAB_TRUE);
               return WMAB_TRUE;
           }
           nSpecial++;
       }
   }
   // not found
   return WMAB_FALSE;
}

const WMARateEntry* NearestRateEntry(U32 ulSamplingRate, U32 ulChannels, U32 ulBitrateWanted) {
   const WMARateList* pRateList = findRateListByPCMParams(ulSamplingRate, ulChannels);
   
   // Find the nearest bitrate entry.  Bitrates are always enumerated in descending order.
   U32 iBitrateIndex = 0;
   U32 uiMinDiff = 0xFFFFFFFF;
   I32 iBestMatch = -1;
   
   if (!pRateList)
      return WMAB_FALSE;
   
   for (iBitrateIndex = 0; iBitrateIndex < pRateList->nEntries; iBitrateIndex++) {
       U32 ulBitrate = pRateList->pRates[iBitrateIndex].nBitrate;
       U32 uiDiffTmp = abs ((I32)ulBitrateWanted - (I32)ulBitrate);
       if (uiDiffTmp == 0) {
           iBestMatch = iBitrateIndex;
           break;
       }
       if (uiMinDiff > uiDiffTmp) {
           uiMinDiff = uiDiffTmp;
           iBestMatch = iBitrateIndex;
       }
   }
   if (iBestMatch == -1) // nothing even close
       return NULL;
   return &(pRateList->pRates[iBestMatch]);
}
   
Bool GetFormatByPCMParamsAndBitrate(U32 ulSamplingRate, 
                                    U32 ulChannels, 
                                    U32 ulBitrateWanted, Bool fASFAVInterleave, WMAFormatInfo* pFormat) {
   const WMARateEntry* pEntry = NearestRateEntry(ulSamplingRate, ulChannels, ulBitrateWanted);
   if (!pEntry) return WMAB_FALSE;
   prvInitializeFormat(pFormat, ulSamplingRate, ulChannels, pEntry, fASFAVInterleave);
   return WMAB_TRUE;
}



//***************************************************************************
// Function: GetTranscodeDstFormatByIndex
//
// Purpose:
//   Enumerate the destination formats which are valid for the given
//   source format.
//
// Arguments:
//   WMAFormatInfo *pSrcFormat [in] - the source format whose destinations
//     we'd like to enumerate.
//   U32 ulDstIndex [in] - an index (0 is first) provided by the caller.
//     If the caller has not found what he wants he keeps advancing the
//     index until we give him what he wants or we return WMAB_FALSE,
//     indicating that there is no valid destination format for the given
//     index.
//   WMAFormatInfo *pDstFormat [out] - we return a valid destination format
//     for pSrcFormat here.
//
// Returns:
//   WMAB_TRUE if there exists a valid destination format for the given
//   pSrcFormat and ulDstIndex. WMAB_FALSE otherwise.
//***************************************************************************
Bool GetTranscodeDstFormatByIndex(const WMAFormatInfo* pSrcFormat,
                                  const U32 ulDstIndex,
                                  WMAFormatInfo* pDstFormat)
{
   const WMARateList* pSrcRateList =
       findRateListByPCMParams(pSrcFormat->nSamplesPerSec, pSrcFormat->nChannels);
   const I32 iSrcBitrate = pSrcFormat->nAvgBytesPerSec * 8;

   I32  iBestMatch;
   U32  iBitrateIndex;
   U32  uiMinDiff;
   Bool fDstFound;
   I32  iDstCount;

   // For now we have only tested 44kHz. As we test and add more, this function
   // will return more supported formats.
   if ((pSrcFormat->nSamplesPerSec != 44100) || (pSrcFormat->wEncodeOptions != 0x0F))
       return WMAB_FALSE;

   // Current rules for transcoder:
   // Source and dest must be same sample rate, number of channels and cSubband
   // Source and dest must be both bark band weighting mode, superframe mode.

   // Find position of source format in rate list
   uiMinDiff = 0xFFFFFFFF;
   iBestMatch = -1;
   for (iBitrateIndex = 0; iBitrateIndex < pSrcRateList->nEntries; iBitrateIndex++)
   {
       const U32 ulBitrate = pSrcRateList->pRates[iBitrateIndex].nBitrate;
       const U32 uiDiffTmp = abs (iSrcBitrate - (I32)ulBitrate);

       if (uiDiffTmp == 0)
       {
           iBestMatch = iBitrateIndex;
           break;
       }
       if (uiMinDiff > uiDiffTmp)
       {
           uiMinDiff = uiDiffTmp;
           iBestMatch = iBitrateIndex;
       }
   }

   if (-1 == iBestMatch)
       return WMAB_FALSE; // Couldn't find the source in our list

   // Now count the candidate output formats
   fDstFound = WMAB_FALSE;
   iBitrateIndex = iBestMatch + 1;  // Transcoder doesn't do same-to-same. Start with next one.
   iDstCount = ulDstIndex;
   while (iBitrateIndex < pSrcRateList->nEntries)
   {
       WMAFormatInfo rDstCandidate;

       prvInitializeFormat(&rDstCandidate, pSrcFormat->nSamplesPerSec,
           pSrcFormat->nChannels, &(pSrcRateList->pRates[iBitrateIndex]), WMAB_FALSE);
       if (0 == (rDstCandidate.wEncodeOptions & ENCOPT_BARK) ||
           0 == (rDstCandidate.wEncodeOptions & ENCOPT_SUPERFRAME))
       {
           // We've reached the end of the line, terminate the search
           break;
       }

       if (iDstCount <= 0)
       {
           // Found it!
           if (NULL != pDstFormat)
               *pDstFormat = rDstCandidate;

           fDstFound = WMAB_TRUE;
           break;
       }

       iDstCount -= 1;
       iBitrateIndex += 1;
   }

   return fDstFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\blkdec_wmv.cpp ===
/************************************************************************

Copyright (c) 1996  Microsoft Corporation

Module Name:

	blkdec.cpp

Abstract:

	block decoding functions.

Author:

	Wei-ge Chen (wchen@microsoft.com) 4-Sept-1996
	Bruce Lin (blin@microsoft.com) 02-Nov-1996

Revision History:

*************************************************************************/

#include "bldsetup.h"

#include "xplatform.h"
#include "wmvdec_api.h"

#include <stdlib.h>
#include <math.h>
#include "limits.h"
#include "typedef.hpp"
#include "wmvdec_member.h"
#include "wmvdec_function.h"
#include "codehead.h"
#include "strmdec_wmv.hpp"
#include "idctdec_wmv2.h"

#ifdef __MFC_
#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW				
#endif // __MFC_
//#define MAXCODEWORDLNGIntraDCy 7
//#define MAXCODEWORDLNGIntraDCc 8

tWMVDecodeStatus decodeIntraBlockAcPred (
    tWMVDecInternalMember *pWMVDec,
	CDCTTableInfo_Dec* IntraDCTTableInfo_Dec, 
	CWMVMBMode*        pmbmd,
    U8_WMV   *ppxliTextureQMB,        //place to set the pixels
    I32_WMV             iOffsetToNextRowForDCT,
	I32_WMV             ib, 
    I16_WMV*            piQuanCoefACPred, 
    I16_WMV*            pRef, 
    Bool_WMV            bPredPattern
)
{

    tWMVDecodeStatus tWMVStatus;

	//Bool_WMV bPredPattern;
	U8_WMV* piZigzagInv; 
    assert(MB_SQUARE_SIZE - 4 <= UINT_MAX);
    memset (pWMVDec->m_rgiCoefReconPlus1, 0, (size_t)(MB_SQUARE_SIZE - 4));
	//piQuanCoefACPred [0] = m_rgiCoefRecon[0] + pRef [0];
	//m_rgiCoefRecon[0] = (piQuanCoefACPred [0] << 3);

    if ((pmbmd->m_rgbDCTCoefPredPattern & 1)){
		if (bPredPattern != pWMVDec->m_bRotatedIdct){
            I32_WMV i;
			for (i = 1; i < 8; i++) {
				piQuanCoefACPred [i + BLOCK_SIZE] = 0;
				piQuanCoefACPred [i] = pRef [i] ;
			}
            //piZigzagInv = g_pHorizontalZigzagInv; Old Symmetric matrix, 
    		if (pWMVDec->m_bRotatedIdct) //bPredPattern == 0, m_bRotatedIdct == 1 
    			piZigzagInv = (U8_WMV*) pWMVDec->m_pVerticalZigzagInvRotated;
            else //bPredPattern == 1, m_bRotatedIdct == 0 
    			piZigzagInv = (U8_WMV*) pWMVDec->m_pHorizontalZigzagInv;
		}
		else{
            I32_WMV i;
			for (i = 1; i < 8; i++) {
				piQuanCoefACPred [i + BLOCK_SIZE] = pRef [i + BLOCK_SIZE];
				piQuanCoefACPred [i] = 0;
			}
            // piZigzagInv = g_pVerticalZigzagInv; Old Symmetric matrix, 
    		if (pWMVDec->m_bRotatedIdct) //bPredPattern == 1 , m_bRotatedIdct == 1
    			piZigzagInv = (U8_WMV*) pWMVDec->m_pHorizontalZigzagInvRotated;
            else //bPredPattern == 0, m_bRotatedIdct == 0
    			piZigzagInv = (U8_WMV*) pWMVDec->m_pVerticalZigzagInv;
		}
	}
	else{
        I32_WMV i;
		for (i = 1; i < 8; i++) {
			piQuanCoefACPred [i + BLOCK_SIZE] = 0;
			piQuanCoefACPred [i] = 0;
		}
		if (pWMVDec->m_bRotatedIdct)
            piZigzagInv = pWMVDec->m_pZigzagInvRotated_I;
        else
            piZigzagInv = pWMVDec->m_pZigzagInv_I;
	}

    // reverse ib because of the internal representation of m_rgbCodedBlockPattern
    if (pWMVDec->m_cvCodecVersion != MP4S)
        tWMVStatus = DecodeInverseIntraBlockQuantizeAcPred (
            pWMVDec,
			IntraDCTTableInfo_Dec,
			(pmbmd->m_rgbCodedBlockPattern & (1<<(5-ib))), 
			piQuanCoefACPred, 
			piZigzagInv
        );//get the quantized block	
    else
    	tWMVStatus = DecodeInverseIntraBlockQuantizeAcPred_MPEG4 (
            pWMVDec,
			IntraDCTTableInfo_Dec,
			(pmbmd->m_rgbCodedBlockPattern & (1<<(5-ib))), 
			piQuanCoefACPred, 
			piZigzagInv
            );//get the quantized block	

    
    if (WMV_Succeeded != tWMVStatus) {
		return tWMVStatus;
	}
    FUNCTION_PROFILE_DECL_START(fpIDCT,IDCT_PROFILE);
	(*pWMVDec->m_pIntraIDCT_Dec) (ppxliTextureQMB, iOffsetToNextRowForDCT, pWMVDec->m_rgiCoefRecon);
    FUNCTION_PROFILE_STOP(&fpIDCT);
    return WMV_Succeeded;
}



//Use 0-5 in decoder but Y_BLOCK1-V_BLOCK in encoder. the mess needs to be fixed.
I16_WMV* decodeDiffDCTCoef(tWMVDecInternalMember *pWMVDec, I16_WMV** piQuanCoefACPredTable, Bool_WMV bLeftMB, Bool_WMV bTopMB, Bool_WMV bLeftTopMB, Bool_WMV& bPredPattern)
{
//	I16_WMV* pDct = piQuanCoefACPred;
	//PixelI* pCoefRecon = m_rgiCoefRecon;
	I16_WMV *pDctLeft, *pDctTop, *pDctLeftTop;

    pDctLeft = piQuanCoefACPredTable[bLeftMB];
    pDctTop = piQuanCoefACPredTable[2+bTopMB];
    pDctLeftTop = piQuanCoefACPredTable[4+bLeftTopMB];

    if (abs (*pDctLeftTop - *pDctTop) < abs (*pDctLeftTop - *pDctLeft) + pWMVDec->m_iDCPredCorrect){
        bPredPattern = 0;
        return pDctLeft;
    }
    else {
        bPredPattern = 1;
        return pDctTop;
    }
}
Void_WMV decodeBitsOfESCCode (tWMVDecInternalMember *pWMVDec)
{

    if (pWMVDec->m_iStepSize >= 8){
        I32_WMV iBitsCnt = 0, iBit = 0;
        while (iBitsCnt < 6 && !iBit){
            iBit = BS_getBit ( pWMVDec->m_pbitstrmIn);
            iBitsCnt++;
        }
        if (iBit)
            pWMVDec->m_iNUMBITS_ESC_LEVEL = iBitsCnt + 1; // from 2-7
        else
            pWMVDec->m_iNUMBITS_ESC_LEVEL = 8; // from 2-7
    }
    else{
        pWMVDec->m_iNUMBITS_ESC_LEVEL = BS_getBits ( pWMVDec->m_pbitstrmIn, 3);  // 1-7, 0 is ESC
        if (!pWMVDec->m_iNUMBITS_ESC_LEVEL){
            pWMVDec->m_iNUMBITS_ESC_LEVEL = 8 + BS_getBit ( pWMVDec->m_pbitstrmIn);  // ESC + 0 == 8  ESC + 1 == 9
        }
    }

    pWMVDec->m_iNUMBITS_ESC_RUN = 3 + BS_getBits ( pWMVDec->m_pbitstrmIn, 2);


}



#define WMV_ESC_Decoding()                                                          \
	if (pWMVDec->m_bFirstEscCodeInFrame){                                                    \
        decodeBitsOfESCCode (pWMVDec);                                                     \
        pWMVDec->m_bFirstEscCodeInFrame = FALSE_WMV;                                             \
	}                                                                               \
	uiRun = BS_getBits ( pWMVDec->m_pbitstrmIn, pWMVDec->m_iNUMBITS_ESC_RUN);			                    \
	if (BS_getBit ( pWMVDec->m_pbitstrmIn)) /* escape decoding */                              \
		iLevel = -1 * BS_getBits ( pWMVDec->m_pbitstrmIn, pWMVDec->m_iNUMBITS_ESC_LEVEL);                 \
	else                                                                            \
		iLevel = BS_getBits ( pWMVDec->m_pbitstrmIn, pWMVDec->m_iNUMBITS_ESC_LEVEL);                      


// Sridhar:  This function isn't called (unles MMX stream) so don't bother for now
tWMVDecodeStatus DecodeInverseInterBlockQuantizeEscCode(tWMVDecInternalMember *pWMVDec, CDCTTableInfo_Dec* InterDCTTableInfo_Dec, U8_WMV *pZigzagInv, I32_WMV iXformMode)
{
	FUNCTION_PROFILE_DECL_START(fpDecode,DECINVIBQUANTESCCODE_PROFILE );
	
	Huffman_WMV* hufDCTACDec = InterDCTTableInfo_Dec->hufDCTACDec;
	I8_WMV* rgLevelAtIndx = InterDCTTableInfo_Dec->pcLevelAtIndx;
	U8_WMV* rgRunAtIndx = InterDCTTableInfo_Dec->puiRunAtIndx;
//  Change iStartIndxOfLastRun to iStartIndxOfLastRunMinus1 and <= to <
//	iStartIndxOfLastRun = InterDCTTableInfo_Dec->iStartIndxOfLastRunMinus1;
	U8_WMV* rgIfNotLastNumOfLevelAtRun = InterDCTTableInfo_Dec->puiNotLastNumOfLevelAtRun;
	U8_WMV* rgIfLastNumOfLevelAtRun = InterDCTTableInfo_Dec->puiLastNumOfLevelAtRun; 
	U8_WMV* rgIfNotLastNumOfRunAtLevel = InterDCTTableInfo_Dec->puiNotLastNumOfRunAtLevel;
	U8_WMV* rgIfLastNumOfRunAtLevel = InterDCTTableInfo_Dec->puiLastNumOfRunAtLevel;
	U32_WMV iStartIndxOfLastRun = InterDCTTableInfo_Dec->iStartIndxOfLastRunMinus1 + 1;
	I32_WMV  iTCOEF_ESCAPE = InterDCTTableInfo_Dec->iTcoef_ESCAPE;

    Bool_WMV bIsLastRun = FALSE_WMV;
    U32_WMV uiRun; // = 0;
    I32_WMV  iLevel; // = 0;
    U32_WMV uiCoefCounter = 0;
    U8_WMV   lIndex;
    I32_WMV iDoubleStepSize = pWMVDec->m_iDoubleStepSize;
    I32_WMV iStepMinusStepIsEven = pWMVDec->m_iStepMinusStepIsEven;
	register I32_WMV iDCTHorzFlags = 0;

    memset (pWMVDec->m_rgiCoefRecon, 0, (size_t) MB_SQUARE_SIZE);
    do {
        register I32_WMV iIndex;
		lIndex = (U8_WMV) Huffman_WMV_get (hufDCTACDec, pWMVDec->m_pbitstrmIn);
		//lIndex = m_pbitstrmIn->getMaxBits(MAXCODEWORDLNGDCT,gDecodeCodeTableDCT);//m_iMaxCodeLngth, m_rgCodeSymSize);
		if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
            FUNCTION_PROFILE_STOP(&fpDecode);
			return WMV_CorruptedBits;
		}
        //lIndex = m_pentrdecDCT->decodeSymbol();
        // if Huffman
        if (lIndex != iTCOEF_ESCAPE)	{
			if (lIndex >= iStartIndxOfLastRun)
				bIsLastRun = TRUE_WMV;
            uiRun = rgRunAtIndx[lIndex];
            iLevel = (BS_getBit ( pWMVDec->m_pbitstrmIn)) ? - rgLevelAtIndx[lIndex] :
                rgLevelAtIndx[lIndex];
            if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
                FUNCTION_PROFILE_STOP(&fpDecode);
                return WMV_CorruptedBits;
            }
        } 
		else {
			if (BS_getBit ( pWMVDec->m_pbitstrmIn)){
                if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
                    FUNCTION_PROFILE_STOP(&fpDecode);
                    return WMV_CorruptedBits;
                }
				// ESC + '1' + VLC
                lIndex = (U8_WMV) Huffman_WMV_get (hufDCTACDec, pWMVDec->m_pbitstrmIn);
        		//lIndex = (U8_WMV) hufDCTACDec->get (pWMVDec->m_pbitstrmIn);
				//lIndex = m_pbitstrmIn->getMaxBits(MAXCODEWORDLNGDCT,gDecodeCodeTableDCT);//m_iMaxCodeLngth, m_rgCodeSymSize);
                if (BS_invalid ( pWMVDec->m_pbitstrmIn) || lIndex == iTCOEF_ESCAPE) { // ESC + 1 + ESC :  bits corrupted
                    FUNCTION_PROFILE_STOP(&fpDecode);
			        return WMV_CorruptedBits;
		        }
				uiRun = rgRunAtIndx[lIndex];
				iLevel = rgLevelAtIndx[lIndex];
				if (lIndex >= iStartIndxOfLastRun){
					bIsLastRun = TRUE_WMV;
					iLevel += (I8_WMV) rgIfLastNumOfLevelAtRun[uiRun];
				}
				else
					iLevel += (I8_WMV) rgIfNotLastNumOfLevelAtRun[uiRun];
				if (BS_getBit ( pWMVDec->m_pbitstrmIn)) 
					iLevel = -iLevel;
                if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
                    FUNCTION_PROFILE_STOP(&fpDecode);
                    return WMV_CorruptedBits;
                }
			}
			else if (BS_getBit ( pWMVDec->m_pbitstrmIn)){
                if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
                    FUNCTION_PROFILE_STOP(&fpDecode);
                    return WMV_CorruptedBits;
                }
				// ESC + '10' + VLC
                lIndex = (U8_WMV) Huffman_WMV_get (hufDCTACDec, pWMVDec->m_pbitstrmIn);
        		//lIndex = (U8_WMV) hufDCTACDec->get (pWMVDec->m_pbitstrmIn);
				//lIndex = m_pbitstrmIn->getMaxBits(MAXCODEWORDLNGDCT,gDecodeCodeTableDCT);//m_iMaxCodeLngth, m_rgCodeSymSize);
                if (BS_invalid ( pWMVDec->m_pbitstrmIn) || lIndex == iTCOEF_ESCAPE) { // ESC + 1 + ESC :  bits corrupted
                    FUNCTION_PROFILE_STOP(&fpDecode);
			        return WMV_CorruptedBits;
		        }
				uiRun = rgRunAtIndx[lIndex];
				iLevel = rgLevelAtIndx[lIndex];
				if (lIndex >= iStartIndxOfLastRun){
					bIsLastRun = TRUE_WMV;
					uiRun += (rgIfLastNumOfRunAtLevel[iLevel] + pWMVDec->m_iEscRunDiffV2V3);
				}
				else
					uiRun += (rgIfNotLastNumOfRunAtLevel[iLevel] + pWMVDec->m_iEscRunDiffV2V3);
				if (BS_getBit ( pWMVDec->m_pbitstrmIn)) 
					iLevel = -iLevel;
                if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
                    FUNCTION_PROFILE_STOP(&fpDecode);
                    return WMV_CorruptedBits;
                }
			}
			else{
				// ESC + '00' + FLC
				bIsLastRun = (Bool_WMV) BS_getBit ( pWMVDec->m_pbitstrmIn); // escape decoding
                if (pWMVDec->m_cvCodecVersion >= WMV1){
                    WMV_ESC_Decoding();
                }
                else{
					uiRun = BS_getBits ( pWMVDec->m_pbitstrmIn, NUMBITS_ESC_RUN);			
        			iLevel = (I8_WMV)BS_getBits ( pWMVDec->m_pbitstrmIn, NUMBITS_ESC_LEVEL);
				}
		        if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
                    FUNCTION_PROFILE_STOP(&fpDecode);
			        return WMV_CorruptedBits;
		        }
			}
        }
        uiCoefCounter += uiRun;

		if (uiCoefCounter >= BLOCK_SQUARE_SIZE) {
            FUNCTION_PROFILE_STOP(&fpDecode);
			return WMV_CorruptedBits;
        }
        
        iIndex = pWMVDec->m_pZigzagInv [uiCoefCounter];

        // If this coefficient is not in the first column then set the flag which indicates
        // what row it is in. This flag field will be used by the IDCT to see if it can
        // shortcut the IDCT of the row if all coefficients are zero.
		if (iIndex & 0x7)
			iDCTHorzFlags |= (1<<((iIndex & 0x38)>>3));

        if (iLevel == 1)
			pWMVDec->m_rgiCoefRecon [pZigzagInv [uiCoefCounter]] = pWMVDec->m_i2DoublePlusStepSize;
		else if (iLevel == -1)
			pWMVDec->m_rgiCoefRecon [pZigzagInv [uiCoefCounter]] = pWMVDec->m_i2DoublePlusStepSizeNeg;
		else if (iLevel > 0)
//			I32_WMV iCoefRecon = m_iStepSize * ((iLevel << 1) + 1) - m_bStepSizeIsEven;
			pWMVDec->m_rgiCoefRecon [pZigzagInv [uiCoefCounter]] = iDoubleStepSize * iLevel + iStepMinusStepIsEven;
		else
//			I32_WMV iCoefRecon = m_bStepSizeIsEven - m_iStepSize * (1 - (iLevel << 1));
			pWMVDec->m_rgiCoefRecon [pZigzagInv [uiCoefCounter]] = iDoubleStepSize * iLevel - iStepMinusStepIsEven;

        uiCoefCounter++;
    } while (!bIsLastRun);
    // Save the DCT row flags. This will be passed to the IDCT routine
    pWMVDec->m_iDCTHorzFlags = iDCTHorzFlags;

    FUNCTION_PROFILE_STOP(&fpDecode);
    return WMV_Succeeded;
}


Void_WMV decodeIntraDCAcPredMSV (tWMVDecInternalMember *pWMVDec, tWMVDecodeStatus* pError, Huffman_WMV* hufDCTDCDec, I32_WMV iTCOEF_ESCAPE)
{
    U8_WMV lSzDiffIntraDC;
	lSzDiffIntraDC = (U8_WMV) Huffman_WMV_get (hufDCTDCDec, pWMVDec->m_pbitstrmIn);
    if (BS_invalid ( pWMVDec->m_pbitstrmIn)){
        *pError = WMV_CorruptedBits;
    }
    if (lSzDiffIntraDC != iTCOEF_ESCAPE)	{
        if (lSzDiffIntraDC != 0)
            pWMVDec->m_rgiCoefRecon [0] = (BS_getBit ( pWMVDec->m_pbitstrmIn)) ? -lSzDiffIntraDC : lSzDiffIntraDC;
        else
            pWMVDec->m_rgiCoefRecon [0] = 0;
        if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
            *pError = WMV_CorruptedBits;
        }
    }
	else {
		lSzDiffIntraDC = (U8_WMV) BS_getBits ( pWMVDec->m_pbitstrmIn, NUMBITS_ESC_LEVEL);
        pWMVDec->m_rgiCoefRecon [0] = (BS_getBit ( pWMVDec->m_pbitstrmIn)) ? -lSzDiffIntraDC : lSzDiffIntraDC;
    }
	*pError = WMV_Succeeded;
}

tWMVDecodeStatus DecodeInverseIntraBlockQuantizeAcPred (
    tWMVDecInternalMember *pWMVDec,
	CDCTTableInfo_Dec* IntraDCTTableInfo_Dec, 
	Bool_WMV CBP,
	I16_WMV* pDct, 
	U8_WMV* piZigzagInv 	
)
{
#   if !defined(_SH4_)
    FUNCTION_PROFILE_DECL_START(fpDecode,DECINVIBQUANTESCCODE_PROFILE );
#	endif
	
	Huffman_WMV* hufDCTACDec = IntraDCTTableInfo_Dec->hufDCTACDec;
	I8_WMV* rgLevelAtIndx = IntraDCTTableInfo_Dec->pcLevelAtIndx;
	U8_WMV* rgRunAtIndx = IntraDCTTableInfo_Dec->puiRunAtIndx;
//  Change iStartIndxOfLastRun to iStartIndxOfLastRunMinus1 and <= to <
//	iStartIndxOfLastRun = IntraDCTTableInfo_Dec->iStartIndxOfLastRunMinus1;
	U8_WMV* rgIfNotLastNumOfLevelAtRunIntra = IntraDCTTableInfo_Dec->puiNotLastNumOfLevelAtRun;
	U8_WMV* rgIfLastNumOfLevelAtRunIntra = IntraDCTTableInfo_Dec->puiLastNumOfLevelAtRun; 
	U8_WMV* rgIfNotLastNumOfRunAtLevelIntra = IntraDCTTableInfo_Dec->puiNotLastNumOfRunAtLevel;
	U8_WMV* rgIfLastNumOfRunAtLevelIntra = IntraDCTTableInfo_Dec->puiLastNumOfRunAtLevel;
	U32_WMV iStartIndxOfLastRun = IntraDCTTableInfo_Dec->iStartIndxOfLastRunMinus1 + 1;
	I32_WMV iTCOEF_ESCAPE = IntraDCTTableInfo_Dec->iTcoef_ESCAPE;


    Bool_WMV bIsLastRun = FALSE_WMV;
    U32_WMV uiRun; // = 0;
    I32_WMV iLevel; // = 0;
    U32_WMV uiCoefCounter = 1;
    U8_WMV   lIndex;
    I32_WMV iDoubleStepSize = pWMVDec->m_iDoubleStepSize;

#ifndef _NEW_INTRA_QUANT_RECON_
    I32_WMV iStepMinusStepIsEven = pWMVDec->m_iStepMinusStepIsEven;
#else
	I32_WMV iStepMinusStepIsEven = pWMVDec->m_iStepSize - 1;
#endif
    I32_WMV i;

	if (CBP) {
		do {
            lIndex = (U8_WMV) Huffman_WMV_get (hufDCTACDec, pWMVDec->m_pbitstrmIn);
            //lIndex = (U8_WMV) hufDCTACDec->get (pWMVDec->m_pbitstrmIn);
			//lIndex = m_pbitstrmIn->getMaxBits (iMAXCODEWORDLNGDCT,decodeCodeTableDCT);
            assert(lIndex <= iTCOEF_ESCAPE);
			if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {

#   if !defined(_SH4_)
				FUNCTION_PROFILE_STOP(&fpDecode);
#	endif

				               
				return WMV_CorruptedBits;
			}
			if (lIndex != iTCOEF_ESCAPE)	{
				bIsLastRun = (lIndex >= iStartIndxOfLastRun);
				uiRun = rgRunAtIndx[lIndex];
				iLevel = (BS_getBit ( pWMVDec->m_pbitstrmIn)) ? - rgLevelAtIndx[lIndex] :
					rgLevelAtIndx[lIndex];
				if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {

#   if !defined(_SH4_)
				FUNCTION_PROFILE_STOP(&fpDecode);
#	endif
					
					return WMV_CorruptedBits;
				}
			}
			else {
				if (BS_getBit ( pWMVDec->m_pbitstrmIn)){
                    if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {


#   if !defined(_SH4_)
				FUNCTION_PROFILE_STOP(&fpDecode);
#	endif

						return WMV_CorruptedBits;
                    }
					// ESC + '1' + VLC
                    lIndex = (U8_WMV) Huffman_WMV_get (hufDCTACDec, pWMVDec->m_pbitstrmIn);
					//lIndex = (U8_WMV) hufDCTACDec->get (pWMVDec->m_pbitstrmIn);
					//lIndex = pWMVDec->m_pbitstrmIn->getMaxBits (iMAXCODEWORDLNGDCT, decodeCodeTableDCT);//pWMVDec->m_iMaxCodeLngth, pWMVDec->m_rgCodeSymSize);
                    if (BS_invalid ( pWMVDec->m_pbitstrmIn) || lIndex == iTCOEF_ESCAPE) { // ESC + 1 + ESC :  bits corrupted
#   if !defined(_SH4_)
				FUNCTION_PROFILE_STOP(&fpDecode);
#	endif
			            return WMV_CorruptedBits;
		            }
					uiRun = rgRunAtIndx [lIndex];
					iLevel = rgLevelAtIndx[lIndex];
					if (lIndex >= iStartIndxOfLastRun){
						bIsLastRun = TRUE_WMV;
						iLevel += (I8_WMV) rgIfLastNumOfLevelAtRunIntra[uiRun];
					}
					else
						iLevel += (I8_WMV) rgIfNotLastNumOfLevelAtRunIntra[uiRun];
					if (BS_getBit ( pWMVDec->m_pbitstrmIn)) 
						iLevel = -iLevel;
                    if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
#   if !defined(_SH4_)
				FUNCTION_PROFILE_STOP(&fpDecode);
#	endif
                        return WMV_CorruptedBits;
                    }
				}
				else if (BS_getBit ( pWMVDec->m_pbitstrmIn)){
                    if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
#   if !defined(_SH4_)
				FUNCTION_PROFILE_STOP(&fpDecode);
#	endif
                        return WMV_CorruptedBits;
                    }
					// ESC + '01' + VLC
                    lIndex = (U8_WMV) Huffman_WMV_get (hufDCTACDec, pWMVDec->m_pbitstrmIn);
					//lIndex = (U8_WMV) hufDCTACDec->get (pWMVDec->m_pbitstrmIn);
					//lIndex = pWMVDec->m_pbitstrmIn->getMaxBits (iMAXCODEWORDLNGDCT, decodeCodeTableDCT);//pWMVDec->m_iMaxCodeLngth, pWMVDec->m_rgCodeSymSize);
                    if (BS_invalid ( pWMVDec->m_pbitstrmIn) || lIndex == iTCOEF_ESCAPE) { // ESC + 1 + ESC :  bits corrupted
#   if !defined(_SH4_)
				FUNCTION_PROFILE_STOP(&fpDecode);
#	endif
			            return WMV_CorruptedBits;
		            }
					uiRun = rgRunAtIndx [lIndex];
					iLevel = rgLevelAtIndx[lIndex];
					if (lIndex >= iStartIndxOfLastRun){
						bIsLastRun = TRUE_WMV;
						uiRun += (rgIfLastNumOfRunAtLevelIntra[iLevel] + pWMVDec->m_iEscRunDiffV2V3);
					}
					else
						uiRun += (rgIfNotLastNumOfRunAtLevelIntra[iLevel] + pWMVDec->m_iEscRunDiffV2V3);
					if (BS_getBit ( pWMVDec->m_pbitstrmIn)) 
						iLevel = -iLevel;
                    if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
#   if !defined(_SH4_)
				FUNCTION_PROFILE_STOP(&fpDecode);
#	endif
                        return WMV_CorruptedBits;
                    }
				}
				else{
					// ESC + '00' + FLC
					bIsLastRun = (Bool_WMV) BS_getBit ( pWMVDec->m_pbitstrmIn); // escape decoding
                    if (pWMVDec->m_cvCodecVersion >= WMV1){
                        WMV_ESC_Decoding();
                    }
                    else{
					    uiRun = BS_getBits ( pWMVDec->m_pbitstrmIn, NUMBITS_ESC_RUN);			
        			    iLevel = (I8_WMV)BS_getBits ( pWMVDec->m_pbitstrmIn, NUMBITS_ESC_LEVEL);
					}
		            if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
#   if !defined(_SH4_)
				FUNCTION_PROFILE_STOP(&fpDecode);
#	endif
			            return WMV_CorruptedBits;
		            }
				}
			}
            assert(uiRun<= 63);
			uiCoefCounter += uiRun;

			if (uiCoefCounter >= BLOCK_SQUARE_SIZE) {
#   if !defined(_SH4_)
				FUNCTION_PROFILE_STOP(&fpDecode);
#	endif
				return WMV_CorruptedBits;
			}
			// Use 8x8 for each blcok to aVoid_WMV IFs. 
			if ((piZigzagInv[uiCoefCounter] & 0xfffffff8) == 0)  // cnt >= 0(1) && <=7
				pDct[piZigzagInv[uiCoefCounter]] = iLevel + pDct[piZigzagInv[uiCoefCounter]];
			else if ((piZigzagInv[uiCoefCounter] & 0x00000007) == 0) // cnt mod 8 == 0
				pDct[BLOCK_SIZE + (piZigzagInv[uiCoefCounter] >> 3)] = iLevel + pDct[BLOCK_SIZE + (piZigzagInv [uiCoefCounter] >> 3)];
			else {
				if (iLevel > 0)
//					pWMVDec->m_rgiCoefRecon[piZigzagInv[uiCoefCounter]] = (PixelI32) ((pWMVDec->m_iStepSize * (iLevel * 2 + 1)) - pWMVDec->m_bStepSizeIsEven);
					pWMVDec->m_rgiCoefRecon[piZigzagInv[uiCoefCounter]] = iDoubleStepSize * iLevel + iStepMinusStepIsEven;
				else // iLevel < 0 (note: iLevel != 0)
//					pWMVDec->m_rgiCoefRecon[piZigzagInv[uiCoefCounter]] = (PixelI32) ((pWMVDec->m_iStepSize * (iLevel * 2 - 1)) + pWMVDec->m_bStepSizeIsEven);
					pWMVDec->m_rgiCoefRecon[piZigzagInv[uiCoefCounter]] = iDoubleStepSize * iLevel - iStepMinusStepIsEven;
			}
			uiCoefCounter++;
		} while (!bIsLastRun);
	}

	for (i = 1; i < 8; i++){
		I32_WMV iLevel1 = pDct [i];
		if (iLevel1 == 0)
			pWMVDec->m_rgiCoefRecon [i] = 0;
        else if (iLevel1 > 0)
//            pWMVDec->m_rgiCoefRecon [i] = (PixelI32) ((pWMVDec->m_iStepSize * (iLevel1 * 2 + 1)) - pWMVDec->m_bStepSizeIsEven);
            pWMVDec->m_rgiCoefRecon [i] = iDoubleStepSize * iLevel1 + iStepMinusStepIsEven;
		else
//            pWMVDec->m_rgiCoefRecon [i] = (PixelI32) ((pWMVDec->m_iStepSize * (iLevel1 * 2 - 1)) + pWMVDec->m_bStepSizeIsEven);
            pWMVDec->m_rgiCoefRecon [i] = iDoubleStepSize * iLevel1 - iStepMinusStepIsEven;
		
        iLevel1 = pDct [i + BLOCK_SIZE];
		if (iLevel1 == 0)
			pWMVDec->m_rgiCoefRecon [i << 3] = 0;
        else if (iLevel1 > 0)
//            pWMVDec->m_rgiCoefRecon [i << 3] = (PixelI32) ((pWMVDec->m_iStepSize * (iLevel1 * 2 + 1)) - pWMVDec->m_bStepSizeIsEven);
            pWMVDec->m_rgiCoefRecon [i << 3] = iDoubleStepSize * iLevel1 + iStepMinusStepIsEven;
		else
//            pWMVDec->m_rgiCoefRecon [i << 3] = (PixelI32) ((pWMVDec->m_iStepSize * (iLevel1 * 2 - 1)) + pWMVDec->m_bStepSizeIsEven);
            pWMVDec->m_rgiCoefRecon [i << 3] = iDoubleStepSize * iLevel1 - iStepMinusStepIsEven;
	}
#   if !defined(_SH4_)
				FUNCTION_PROFILE_STOP(&fpDecode);
#	endif
    return WMV_Succeeded;
}

//Use 0-5 in decoder but Y_BLOCK1-V_BLOCK in encoder. the mess needs to be fixed.
I16_WMV* decodeDiffDCTCoef_WMV(tWMVDecInternalMember *pWMVDec, U8_WMV* ppxliTextureQMB, I16_WMV** piQuanCoefACPredTable, Bool_WMV bLeftMB, Bool_WMV bTopMB, Bool_WMV bLeftTopMB, Bool_WMV bLeftMBAndInter, Bool_WMV bTopMBAndInter, Bool_WMV bLeftTopMBAndInter, Bool_WMV& bPredPattern, I32_WMV iWidthPrev, I32_WMV iStepSize)
{
	I16_WMV *pDctLeft, *pDctTop;
    //I16_WMV iDctLeftTop;
    I16_WMV *pAvgDct;

    if (!bPredPattern){
        if (bLeftMBAndInter){
            pAvgDct = piQuanCoefACPredTable[1];
            if (1)//!pAvgDct[0])
                pAvgDct[0] = (I16_WMV) (*pWMVDec->m_pBlkAvgX8_MMX) (ppxliTextureQMB - BLOCK_SIZE, iWidthPrev, iStepSize);
            pWMVDec->m_pAvgQuanDctCoefDecLeft[0] = pAvgDct[0];
            pDctLeft = pWMVDec->m_pAvgQuanDctCoefDecLeft;
        }
        else{
            pDctLeft = piQuanCoefACPredTable[bLeftMB];
        }
        //bPredPattern = 0;
        return pDctLeft;
    }
    else{
        if (bTopMBAndInter){
            pAvgDct = piQuanCoefACPredTable[3];
            if (1)//!pAvgDct[0])
                pAvgDct[0] = (I16_WMV) (*pWMVDec->m_pBlkAvgX8_MMX) (ppxliTextureQMB - (iWidthPrev << 3) , iWidthPrev, iStepSize);
            pWMVDec->m_pAvgQuanDctCoefDecTop[0] = pAvgDct[0];
            pDctTop = pWMVDec->m_pAvgQuanDctCoefDecTop;
        }
        else{
            pDctTop = piQuanCoefACPredTable[2+bTopMB];
        }
        //bPredPattern = 1;
        return pDctTop;
    }
}

I16_WMV* decodeDiffDCTCoef_WMV_Y23(I16_WMV** piQuanCoefACPredTable, Bool_WMV bLeftMB, Bool_WMV bTopMB, Bool_WMV bLeftTopMB, Bool_WMV& bPredPattern)
{
	I16_WMV *pDctLeft, *pDctTop;//, *pDctLeftTop;

    pDctLeft = piQuanCoefACPredTable[bLeftMB];
    pDctTop = piQuanCoefACPredTable[2+bTopMB];
    //pDctLeftTop = piQuanCoefACPredTable[4+bLeftTopMB];

    if (!bPredPattern)
        return pDctLeft;
    else
        return pDctTop;

}

#ifndef _EMB_WMV2_
// MB routines from Vopdec.cpp
tWMVDecodeStatus DecodePMB (
    tWMVDecInternalMember *pWMVDec,
    CWMVMBMode*            pmbmd, 
//    const Bool_WMV* rgCBP, 
    U8_WMV* ppxlcCurrQYMB,
    U8_WMV* ppxlcCurrQUMB,
    U8_WMV* ppxlcCurrQVMB,
    CoordI xRefY, CoordI yRefY,
    CoordI xRefUV, CoordI yRefUV
)
{
	FUNCTION_PROFILE_DECL_START(fpDecode,DECODEPMB_PROFILE);

    const Bool_WMV rgCBP = pmbmd->m_rgbCodedBlockPattern;
    Bool_WMV bTop, bBottom, bLeft, bRight;

    I32_WMV iXformType = pWMVDec->m_iFrameXformMode;

    tWMVDecodeStatus tWMVStatus;
    // Y
    Buffer __huge* ppxliErrorQMB = pWMVDec->m_rgiCoefReconBuf;;
    U8_WMV* ppxlcRefY = pWMVDec->m_ppxliRef0Y + ((yRefY >> 1) + EXPANDY_REFVOP) * pWMVDec->m_iWidthPrevY + (xRefY >> 1) + EXPANDY_REFVOP;
    Bool_WMV bXEvenY = !(xRefY & 1), bYEvenY = !(yRefY & 1);

    // UV
    Bool_WMV bXEvenUV = !(xRefUV & 1), bYEvenUV = !(yRefUV & 1);
    I32_WMV iPxLoc = ((yRefUV >> 1) + EXPANDUV_REFVOP) * pWMVDec->m_iWidthPrevUV + (xRefUV >> 1) + EXPANDUV_REFVOP;
    const U8_WMV* ppxlcRefU = pWMVDec->m_ppxliRef0U + iPxLoc;
    const U8_WMV* ppxlcRefV = pWMVDec->m_ppxliRef0V + iPxLoc;

    if (pWMVDec->m_bMBXformSwitching)
        iXformType = pmbmd->m_iMBXformMode;

    //CDCTTableInfo_Dec* pInterDCTTableInfo_Dec = pWMVDec->m_pInterDCTTableInfo_Dec;
    CDCTTableInfo_Dec* pInterDCTTableInfo_Dec;
    if (pWMVDec->m_bDCTTable_MB){
        pInterDCTTableInfo_Dec = pWMVDec->m_pInterDCTTableInfo_Dec_Set[pmbmd->m_iDCTTable_MB_Index];
	    //m_pIntraDCTTableInfo_Dec = m_pIntraDCTTableInfo_Dec_Set[pmbmd->m_iDCTTable_MB_Index];
    }
    else{
        pInterDCTTableInfo_Dec = pWMVDec->m_pInterDCTTableInfo_Dec;
    }

    // Y-blocks first (4 blocks)
    if (rgCBP & 32) {
        if (pmbmd->m_bBlkXformSwitchOn)
        {
            if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 0)
                iXformType = XFORMMODE_8x8;
            else if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 0)
                iXformType = XFORMMODE_8x4;
            else
                iXformType = XFORMMODE_4x8;
        }

        if (iXformType == XFORMMODE_8x8)
        {
            ppxliErrorQMB = pWMVDec->m_rgiCoefReconBuf;
            tWMVStatus = (*pWMVDec->m_pDecodeInverseInterBlockQuantize)(pWMVDec, pInterDCTTableInfo_Dec, pWMVDec->m_pZigzagScanOrder, XFORMMODE_8x8); //get the quantized block      
            if (WMV_Succeeded != tWMVStatus) {
                FUNCTION_PROFILE_STOP(&fpDecode);
                return tWMVStatus;
            }
            (*pWMVDec->m_pInterIDCT_Dec) (ppxliErrorQMB, ppxliErrorQMB, BLOCK_SIZE, pWMVDec->m_iDCTHorzFlags);
        }
        bTop = TRUE_WMV;
        bBottom = TRUE_WMV;
        if (iXformType == XFORMMODE_8x4)
        {
            ppxliErrorQMB = pWMVDec->m_ppxliErrorQ;
            memset(ppxliErrorQMB, 0, 256);  // _XFORMSWITCHING_TODO either implement faster way to clear error buffer (MMX) or eliminate need to clear by implementing 8x4 and 4x8 AddError functions 
            if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 0)
                bTop = FALSE_WMV;
            else if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 1)
                bBottom = FALSE_WMV;
            if (bTop)
            {
                tWMVStatus = (*pWMVDec->m_pDecodeInverseInterBlockQuantize)(pWMVDec, pInterDCTTableInfo_Dec, pWMVDec->m_p8x4ZigzagScanOrder, XFORMMODE_8x4); //get the quantized block      
                if (WMV_Succeeded != tWMVStatus) {
                    FUNCTION_PROFILE_STOP(&fpDecode);
                    return tWMVStatus;
                }
                (*pWMVDec->m_pInter8x4IDCT_Dec) (ppxliErrorQMB, BLOCK_SIZE, pWMVDec->m_rgiCoefReconBuf, 0);
            }
            if (bBottom)
            {
                tWMVStatus = (*pWMVDec->m_pDecodeInverseInterBlockQuantize)(pWMVDec, pInterDCTTableInfo_Dec, pWMVDec->m_p8x4ZigzagScanOrder, XFORMMODE_8x4); //get the quantized block      
                if (WMV_Succeeded != tWMVStatus) {
                    FUNCTION_PROFILE_STOP(&fpDecode);
                    return tWMVStatus;
                }
                (*pWMVDec->m_pInter8x4IDCT_Dec) (ppxliErrorQMB, BLOCK_SIZE, pWMVDec->m_rgiCoefReconBuf, 1);
            }
        }

        bLeft = TRUE_WMV;
        bRight = TRUE_WMV;
        if (iXformType == XFORMMODE_4x8)
        {
            ppxliErrorQMB = pWMVDec->m_ppxliErrorQ;
            memset(ppxliErrorQMB, 0, 256);
            if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 0)
                bLeft = FALSE_WMV;
            else if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 1)
                bRight = FALSE_WMV;
            if (bLeft)
            {
                tWMVStatus = (*pWMVDec->m_pDecodeInverseInterBlockQuantize)(pWMVDec, pInterDCTTableInfo_Dec, pWMVDec->m_p4x8ZigzagScanOrder, XFORMMODE_4x8); //get the quantized block      
                if (WMV_Succeeded != tWMVStatus) {
                    FUNCTION_PROFILE_STOP(&fpDecode);
                    return tWMVStatus;
                }                
                (*pWMVDec->m_pInter4x8IDCT_Dec) (ppxliErrorQMB, BLOCK_SIZE, pWMVDec->m_rgiCoefReconBuf, 0);
            }
            if (bRight)
            {
                tWMVStatus = (*pWMVDec->m_pDecodeInverseInterBlockQuantize)(pWMVDec, pInterDCTTableInfo_Dec, pWMVDec->m_p4x8ZigzagScanOrder, XFORMMODE_4x8); //get the quantized block      
                if (WMV_Succeeded != tWMVStatus) {
                    FUNCTION_PROFILE_STOP(&fpDecode);
                    return tWMVStatus;
                }
                (*pWMVDec->m_pInter4x8IDCT_Dec) (ppxliErrorQMB, BLOCK_SIZE, pWMVDec->m_rgiCoefReconBuf, 1);
            } 
        }
	    (*pWMVDec->m_pMotionCompAndAddError) (pWMVDec, ppxlcCurrQYMB, ppxliErrorQMB, ppxlcRefY, pWMVDec->m_iWidthPrevY, bXEvenY, bYEvenY, pWMVDec->m_iMixedPelMV);
    } 
    else {
	    (*pWMVDec->m_pMotionComp) (pWMVDec, ppxlcCurrQYMB, ppxlcRefY, pWMVDec->m_iWidthPrevY, bXEvenY, bYEvenY, pWMVDec->m_iMixedPelMV);
    }
    ppxlcCurrQYMB += BLOCK_SIZE;
    ppxlcRefY += BLOCK_SIZE;
    
    if (rgCBP & 16) {
        if (pmbmd->m_bBlkXformSwitchOn)
        {
            if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 0)
                iXformType = XFORMMODE_8x8;
            else if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 0)
                iXformType = XFORMMODE_8x4;
            else
                iXformType = XFORMMODE_4x8;
        }

        if (iXformType == XFORMMODE_8x8)
        {
            ppxliErrorQMB = pWMVDec->m_rgiCoefReconBuf;
            tWMVStatus = (*pWMVDec->m_pDecodeInverseInterBlockQuantize)(pWMVDec, pInterDCTTableInfo_Dec, pWMVDec->m_pZigzagScanOrder, XFORMMODE_8x8); //get the quantized block       
            if (WMV_Succeeded != tWMVStatus) {
                FUNCTION_PROFILE_STOP(&fpDecode);
                return tWMVStatus;
            }
            (*pWMVDec->m_pInterIDCT_Dec) (ppxliErrorQMB, ppxliErrorQMB, BLOCK_SIZE, pWMVDec->m_iDCTHorzFlags);
        }

        bTop = TRUE_WMV;
        bBottom = TRUE_WMV;
        if (iXformType == XFORMMODE_8x4)
        {
            ppxliErrorQMB = pWMVDec->m_ppxliErrorQ;
            memset(ppxliErrorQMB, 0, 256);
            if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 0)
                bTop = FALSE_WMV;
            else if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 1)
                bBottom = FALSE_WMV;
            if (bTop)
            {
                tWMVStatus = (*pWMVDec->m_pDecodeInverseInterBlockQuantize)(pWMVDec, pInterDCTTableInfo_Dec, pWMVDec->m_p8x4ZigzagScanOrder, XFORMMODE_8x4); //get the quantized block      
                if (WMV_Succeeded != tWMVStatus) {
                    FUNCTION_PROFILE_STOP(&fpDecode);
                    return tWMVStatus;
                }
                (*pWMVDec->m_pInter8x4IDCT_Dec) (ppxliErrorQMB, BLOCK_SIZE, pWMVDec->m_rgiCoefReconBuf, 0);
            }
            if (bBottom)
            {
                tWMVStatus = (*pWMVDec->m_pDecodeInverseInterBlockQuantize)(pWMVDec, pInterDCTTableInfo_Dec, pWMVDec->m_p8x4ZigzagScanOrder, XFORMMODE_8x4); //get the quantized block      
                if (WMV_Succeeded != tWMVStatus) {
                    FUNCTION_PROFILE_STOP(&fpDecode);
                    return tWMVStatus;
                }
                (*pWMVDec->m_pInter8x4IDCT_Dec) (ppxliErrorQMB, BLOCK_SIZE, pWMVDec->m_rgiCoefReconBuf, 1);
            }
        }

        bLeft = TRUE_WMV;
        bRight = TRUE_WMV;
        if (iXformType == XFORMMODE_4x8)
        {
            ppxliErrorQMB = pWMVDec->m_ppxliErrorQ;
            memset(ppxliErrorQMB, 0, 256);
            if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 0)
                bLeft = FALSE_WMV;
            else if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 1)
                bRight = FALSE_WMV;
            if (bLeft)
            {
                tWMVStatus = (*pWMVDec->m_pDecodeInverseInterBlockQuantize)(pWMVDec, pInterDCTTableInfo_Dec, pWMVDec->m_p4x8ZigzagScanOrder, XFORMMODE_4x8); //get the quantized block      
                if (WMV_Succeeded != tWMVStatus) {
                    FUNCTION_PROFILE_STOP(&fpDecode);
                    return tWMVStatus;
                }
                (*pWMVDec->m_pInter4x8IDCT_Dec) (ppxliErrorQMB, BLOCK_SIZE, pWMVDec->m_rgiCoefReconBuf, 0);
            }
            if (bRight)
            {
                tWMVStatus = (*pWMVDec->m_pDecodeInverseInterBlockQuantize)(pWMVDec, pInterDCTTableInfo_Dec, pWMVDec->m_p4x8ZigzagScanOrder, XFORMMODE_4x8); //get the quantized block      
                if (WMV_Succeeded != tWMVStatus) {
                    FUNCTION_PROFILE_STOP(&fpDecode);
                    return tWMVStatus;
                }
                (*pWMVDec->m_pInter4x8IDCT_Dec) (ppxliErrorQMB, BLOCK_SIZE, pWMVDec->m_rgiCoefReconBuf, 1);
            } 
        }

		(*pWMVDec->m_pMotionCompAndAddError) (pWMVDec, ppxlcCurrQYMB, ppxliErrorQMB, ppxlcRefY, pWMVDec->m_iWidthPrevY, bXEvenY, bYEvenY, pWMVDec->m_iMixedPelMV);
    }
    else { 
		(*pWMVDec->m_pMotionComp) (pWMVDec, ppxlcCurrQYMB, ppxlcRefY, pWMVDec->m_iWidthPrevY,  bXEvenY, bYEvenY, pWMVDec->m_iMixedPelMV);
    }
    ppxlcCurrQYMB += pWMVDec->m_iWidthPrevYxBlkMinusBlk;
    ppxlcRefY += pWMVDec->m_iWidthPrevYxBlkMinusBlk;

    if (rgCBP & 8) {
        if (pmbmd->m_bBlkXformSwitchOn)
        {
            if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 0)
                iXformType = XFORMMODE_8x8;
            else if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 0)
                iXformType = XFORMMODE_8x4;
            else
                iXformType = XFORMMODE_4x8;
        }

        if (iXformType == XFORMMODE_8x8)
        {
            ppxliErrorQMB = pWMVDec->m_rgiCoefReconBuf;
            tWMVStatus = (*pWMVDec->m_pDecodeInverseInterBlockQuantize)(pWMVDec, pInterDCTTableInfo_Dec, pWMVDec->m_pZigzagScanOrder, XFORMMODE_8x8); //get the quantized block       
            if (WMV_Succeeded != tWMVStatus) {
                FUNCTION_PROFILE_STOP(&fpDecode);
                return tWMVStatus;
            }
            (*pWMVDec->m_pInterIDCT_Dec) (ppxliErrorQMB, ppxliErrorQMB, BLOCK_SIZE, pWMVDec->m_iDCTHorzFlags);
        }

        bTop = TRUE_WMV;
        bBottom = TRUE_WMV;
        if (iXformType == XFORMMODE_8x4)
        {
            ppxliErrorQMB = pWMVDec->m_ppxliErrorQ;
            memset(ppxliErrorQMB, 0, 256);
            if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 0)
                bTop = FALSE_WMV;
            else if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 1)
                bBottom = FALSE_WMV;
            if (bTop)
            {
                tWMVStatus = (*pWMVDec->m_pDecodeInverseInterBlockQuantize)(pWMVDec, pInterDCTTableInfo_Dec, pWMVDec->m_p8x4ZigzagScanOrder, XFORMMODE_8x4); //get the quantized block      
                if (WMV_Succeeded != tWMVStatus) {
                    FUNCTION_PROFILE_STOP(&fpDecode);
                    return tWMVStatus;
                }
                (*pWMVDec->m_pInter8x4IDCT_Dec) (ppxliErrorQMB, BLOCK_SIZE, pWMVDec->m_rgiCoefReconBuf, 0);
            }
            if (bBottom)
            {
                tWMVStatus = (*pWMVDec->m_pDecodeInverseInterBlockQuantize)(pWMVDec, pInterDCTTableInfo_Dec, pWMVDec->m_p8x4ZigzagScanOrder, XFORMMODE_8x4); //get the quantized block      
                if (WMV_Succeeded != tWMVStatus) {
                    FUNCTION_PROFILE_STOP(&fpDecode);
                    return tWMVStatus;
                }
                (*pWMVDec->m_pInter8x4IDCT_Dec) (ppxliErrorQMB, BLOCK_SIZE, pWMVDec->m_rgiCoefReconBuf, 1);
            }
        }

        bLeft = TRUE_WMV;
        bRight = TRUE_WMV;
        if (iXformType == XFORMMODE_4x8)
        {
            ppxliErrorQMB = pWMVDec->m_ppxliErrorQ;
            memset(ppxliErrorQMB, 0, 256);
            if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 0)
                bLeft = FALSE_WMV;
            else if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 1)
                bRight = FALSE_WMV;
            if (bLeft)
            {
                tWMVStatus = (*pWMVDec->m_pDecodeInverseInterBlockQuantize)(pWMVDec, pInterDCTTableInfo_Dec, pWMVDec->m_p4x8ZigzagScanOrder, XFORMMODE_4x8); //get the quantized block      
                if (WMV_Succeeded != tWMVStatus) {
                    FUNCTION_PROFILE_STOP(&fpDecode);
                    return tWMVStatus;
                }
                (*pWMVDec->m_pInter4x8IDCT_Dec) (ppxliErrorQMB, BLOCK_SIZE, pWMVDec->m_rgiCoefReconBuf, 0);
            }
            if (bRight)
            {
                tWMVStatus = (*pWMVDec->m_pDecodeInverseInterBlockQuantize)(pWMVDec, pInterDCTTableInfo_Dec, pWMVDec->m_p4x8ZigzagScanOrder, XFORMMODE_4x8); //get the quantized block     
                if (WMV_Succeeded != tWMVStatus) {
                    FUNCTION_PROFILE_STOP(&fpDecode);
                    return tWMVStatus;
                }                
                (*pWMVDec->m_pInter4x8IDCT_Dec) (ppxliErrorQMB, BLOCK_SIZE, pWMVDec->m_rgiCoefReconBuf, 1);
            } 
        }
		(*pWMVDec->m_pMotionCompAndAddError) (pWMVDec, ppxlcCurrQYMB, ppxliErrorQMB, ppxlcRefY, pWMVDec->m_iWidthPrevY, bXEvenY, bYEvenY, pWMVDec->m_iMixedPelMV);
    }
    else {
	    (*pWMVDec->m_pMotionComp) (pWMVDec, ppxlcCurrQYMB, ppxlcRefY, pWMVDec->m_iWidthPrevY, bXEvenY, bYEvenY, pWMVDec->m_iMixedPelMV);
    }
    ppxlcCurrQYMB += BLOCK_SIZE;
    ppxlcRefY += BLOCK_SIZE;

    if (rgCBP & 4) {
        if (pmbmd->m_bBlkXformSwitchOn)
        {
            if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 0)
                iXformType = XFORMMODE_8x8;
            else if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 0)
                iXformType = XFORMMODE_8x4;
            else
                iXformType = XFORMMODE_4x8;
        }

        if (iXformType == XFORMMODE_8x8)
        {
            ppxliErrorQMB = pWMVDec->m_rgiCoefReconBuf;
            tWMVStatus = (*pWMVDec->m_pDecodeInverseInterBlockQuantize)(pWMVDec, pInterDCTTableInfo_Dec, pWMVDec->m_pZigzagScanOrder, XFORMMODE_8x8); //get the quantized block       
            if (WMV_Succeeded != tWMVStatus) {
                FUNCTION_PROFILE_STOP(&fpDecode);
                return tWMVStatus;
            }
            (*pWMVDec->m_pInterIDCT_Dec) (ppxliErrorQMB, ppxliErrorQMB, BLOCK_SIZE, pWMVDec->m_iDCTHorzFlags);
        }

        bTop = TRUE_WMV;
        bBottom = TRUE_WMV;
        if (iXformType == XFORMMODE_8x4)
        {
            ppxliErrorQMB = pWMVDec->m_ppxliErrorQ;
            memset(ppxliErrorQMB, 0, 256);
            if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 0)
                bTop = FALSE_WMV;
            else if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 1)
                bBottom = FALSE_WMV;
            if (bTop)
            {
                tWMVStatus = (*pWMVDec->m_pDecodeInverseInterBlockQuantize)(pWMVDec, pInterDCTTableInfo_Dec, pWMVDec->m_p8x4ZigzagScanOrder, XFORMMODE_8x4); //get the quantized block      
                if (WMV_Succeeded != tWMVStatus) {
                    FUNCTION_PROFILE_STOP(&fpDecode);
                    return tWMVStatus;
                }
                (*pWMVDec->m_pInter8x4IDCT_Dec) (ppxliErrorQMB, BLOCK_SIZE, pWMVDec->m_rgiCoefReconBuf, 0);
            }
            if (bBottom)
            {
                tWMVStatus = (*pWMVDec->m_pDecodeInverseInterBlockQuantize)(pWMVDec, pInterDCTTableInfo_Dec, pWMVDec->m_p8x4ZigzagScanOrder, XFORMMODE_8x4); //get the quantized block      
                if (WMV_Succeeded != tWMVStatus) {
                    FUNCTION_PROFILE_STOP(&fpDecode);
                    return tWMVStatus;
                }
                (*pWMVDec->m_pInter8x4IDCT_Dec) (ppxliErrorQMB, BLOCK_SIZE, pWMVDec->m_rgiCoefReconBuf, 1);
            }
        }

        bLeft = TRUE_WMV;
        bRight = TRUE_WMV;
        if (iXformType == XFORMMODE_4x8)
        {
            ppxliErrorQMB = pWMVDec->m_ppxliErrorQ;
            memset(ppxliErrorQMB, 0, 256);
            if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 0)
                bLeft = FALSE_WMV;
            else if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 1)
                bRight = FALSE_WMV;
            if (bLeft)
            {
                tWMVStatus = (*pWMVDec->m_pDecodeInverseInterBlockQuantize)(pWMVDec, pInterDCTTableInfo_Dec, pWMVDec->m_p4x8ZigzagScanOrder, XFORMMODE_4x8); //get the quantized block      
                if (WMV_Succeeded != tWMVStatus) {
                    FUNCTION_PROFILE_STOP(&fpDecode);
                    return tWMVStatus;
                }
                (*pWMVDec->m_pInter4x8IDCT_Dec) (ppxliErrorQMB, BLOCK_SIZE, pWMVDec->m_rgiCoefReconBuf, 0);
            }
            if (bRight)
            {
                tWMVStatus = (*pWMVDec->m_pDecodeInverseInterBlockQuantize)(pWMVDec, pInterDCTTableInfo_Dec, pWMVDec->m_p4x8ZigzagScanOrder, XFORMMODE_4x8); //get the quantized block      
                if (WMV_Succeeded != tWMVStatus) {
                    FUNCTION_PROFILE_STOP(&fpDecode);
                    return tWMVStatus;
                }
                (*pWMVDec->m_pInter4x8IDCT_Dec) (ppxliErrorQMB, BLOCK_SIZE, pWMVDec->m_rgiCoefReconBuf, 1);
            } 
        }
	    (*pWMVDec->m_pMotionCompAndAddError) (pWMVDec, ppxlcCurrQYMB, ppxliErrorQMB, ppxlcRefY, pWMVDec->m_iWidthPrevY, bXEvenY, bYEvenY, pWMVDec->m_iMixedPelMV);
    }
    else {
		(*pWMVDec->m_pMotionComp) (pWMVDec, ppxlcCurrQYMB, ppxlcRefY, pWMVDec->m_iWidthPrevY, bXEvenY, bYEvenY, pWMVDec->m_iMixedPelMV);
    }

    // UV

    // U-block
    if (rgCBP & 2) {
        if (pmbmd->m_bBlkXformSwitchOn)
        {
            if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 0)
                iXformType = XFORMMODE_8x8;
            else if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 0)
                iXformType = XFORMMODE_8x4;
            else
                iXformType = XFORMMODE_4x8;
        }

        if (iXformType == XFORMMODE_8x8)
        {
            ppxliErrorQMB = pWMVDec->m_rgiCoefReconBuf;
            tWMVStatus = (*pWMVDec->m_pDecodeInverseInterBlockQuantize)(pWMVDec, pInterDCTTableInfo_Dec, pWMVDec->m_pZigzagScanOrder, XFORMMODE_8x8); //get the quantized block  
            if (WMV_Succeeded != tWMVStatus) {
                FUNCTION_PROFILE_STOP(&fpDecode);
                return tWMVStatus;
            }        
            (*pWMVDec->m_pInterIDCT_Dec) (ppxliErrorQMB, ppxliErrorQMB, BLOCK_SIZE, pWMVDec->m_iDCTHorzFlags);
        }

        bTop = TRUE_WMV;
        bBottom = TRUE_WMV;
        if (iXformType == XFORMMODE_8x4)
        {
            ppxliErrorQMB = pWMVDec->m_ppxliErrorQ;
            memset(ppxliErrorQMB, 0, 256);
            if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 0)
                bTop = FALSE_WMV;
            else if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 1)
                bBottom = FALSE_WMV;
            if (bTop)
            {
                tWMVStatus = (*pWMVDec->m_pDecodeInverseInterBlockQuantize)(pWMVDec, pInterDCTTableInfo_Dec, pWMVDec->m_p8x4ZigzagScanOrder, XFORMMODE_8x4); //get the quantized block      
                if (WMV_Succeeded != tWMVStatus) {
                    FUNCTION_PROFILE_STOP(&fpDecode);
                    return tWMVStatus;
                }
                (*pWMVDec->m_pInter8x4IDCT_Dec) (ppxliErrorQMB, BLOCK_SIZE, pWMVDec->m_rgiCoefReconBuf, 0);
            }
            if (bBottom)
            {
                tWMVStatus = (*pWMVDec->m_pDecodeInverseInterBlockQuantize)(pWMVDec, pInterDCTTableInfo_Dec, pWMVDec->m_p8x4ZigzagScanOrder, XFORMMODE_8x4); //get the quantized block      
                if (WMV_Succeeded != tWMVStatus) {
                    FUNCTION_PROFILE_STOP(&fpDecode);
                    return tWMVStatus;
                }
                (*pWMVDec->m_pInter8x4IDCT_Dec) (ppxliErrorQMB, BLOCK_SIZE, pWMVDec->m_rgiCoefReconBuf, 1);
            }
        }

        bLeft = TRUE_WMV;
        bRight = TRUE_WMV;
        if (iXformType == XFORMMODE_4x8)
        {
            ppxliErrorQMB = pWMVDec->m_ppxliErrorQ;
            memset(ppxliErrorQMB, 0, 256);
            if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 0)
                bLeft = FALSE_WMV;
            else if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 1)
                bRight = FALSE_WMV;
            if (bLeft)
            {
                tWMVStatus = (*pWMVDec->m_pDecodeInverseInterBlockQuantize)(pWMVDec, pInterDCTTableInfo_Dec, pWMVDec->m_p4x8ZigzagScanOrder, XFORMMODE_4x8); //get the quantized block      
                if (WMV_Succeeded != tWMVStatus) {
                    FUNCTION_PROFILE_STOP(&fpDecode);
                    return tWMVStatus;
                }
                (*pWMVDec->m_pInter4x8IDCT_Dec) (ppxliErrorQMB, BLOCK_SIZE, pWMVDec->m_rgiCoefReconBuf, 0);
            }
            if (bRight)
            {
                tWMVStatus = (*pWMVDec->m_pDecodeInverseInterBlockQuantize)(pWMVDec, pInterDCTTableInfo_Dec, pWMVDec->m_p4x8ZigzagScanOrder, XFORMMODE_4x8); //get the quantized block      
                if (WMV_Succeeded != tWMVStatus) {
                    FUNCTION_PROFILE_STOP(&fpDecode);
                    return tWMVStatus;
                }
                (*pWMVDec->m_pInter4x8IDCT_Dec) (ppxliErrorQMB, BLOCK_SIZE, pWMVDec->m_rgiCoefReconBuf, 1);
            } 
        }


        (*pWMVDec->m_pMotionCompAndAddErrorUV) (
            pWMVDec, ppxlcCurrQUMB, ppxliErrorQMB, ppxlcRefU, 
            pWMVDec->m_iWidthPrevUV, bXEvenUV, bYEvenUV, pWMVDec->m_iMixedPelMV);
    } 
    else 
        (*pWMVDec->m_pMotionCompUV) (pWMVDec, ppxlcCurrQUMB, ppxlcRefU, pWMVDec->m_iWidthPrevUV,  bXEvenUV, bYEvenUV, pWMVDec->m_iMixedPelMV);

    // V-block
    if (rgCBP & 1) {
        if (pmbmd->m_bBlkXformSwitchOn)
        {
            if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 0)
                iXformType = XFORMMODE_8x8;
            else if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 0)
                iXformType = XFORMMODE_8x4;
            else
                iXformType = XFORMMODE_4x8;
        }

        if (iXformType == XFORMMODE_8x8)
        {
            ppxliErrorQMB = pWMVDec->m_rgiCoefReconBuf;
            tWMVStatus = (*pWMVDec->m_pDecodeInverseInterBlockQuantize)(pWMVDec, pInterDCTTableInfo_Dec, pWMVDec->m_pZigzagScanOrder, XFORMMODE_8x8); //get the quantized block  
            if (WMV_Succeeded != tWMVStatus) {
                FUNCTION_PROFILE_STOP(&fpDecode);
                return tWMVStatus;
            }

            (*pWMVDec->m_pInterIDCT_Dec) (ppxliErrorQMB, ppxliErrorQMB, BLOCK_SIZE, pWMVDec->m_iDCTHorzFlags);
        }

        bTop = TRUE_WMV;
        bBottom = TRUE_WMV;
        if (iXformType == XFORMMODE_8x4)
        {
            ppxliErrorQMB = pWMVDec->m_ppxliErrorQ;
            memset(ppxliErrorQMB, 0, 256);
            if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 0)
                bTop = FALSE_WMV;
            else if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 1)
                bBottom = FALSE_WMV;
            if (bTop)
            {
                tWMVStatus = (*pWMVDec->m_pDecodeInverseInterBlockQuantize)(pWMVDec, pInterDCTTableInfo_Dec, pWMVDec->m_p8x4ZigzagScanOrder, XFORMMODE_8x4); //get the quantized block      
                if (WMV_Succeeded != tWMVStatus) {
                    FUNCTION_PROFILE_STOP(&fpDecode);
                    return tWMVStatus;
                }
                (*pWMVDec->m_pInter8x4IDCT_Dec) (ppxliErrorQMB, BLOCK_SIZE, pWMVDec->m_rgiCoefReconBuf, 0);
            }
            if (bBottom)
            {
                tWMVStatus = (*pWMVDec->m_pDecodeInverseInterBlockQuantize)(pWMVDec, pInterDCTTableInfo_Dec, pWMVDec->m_p8x4ZigzagScanOrder, XFORMMODE_8x4); //get the quantized block      
                if (WMV_Succeeded != tWMVStatus) {
                    FUNCTION_PROFILE_STOP(&fpDecode);
                    return tWMVStatus;
                }
                (*pWMVDec->m_pInter8x4IDCT_Dec) (ppxliErrorQMB, BLOCK_SIZE, pWMVDec->m_rgiCoefReconBuf, 1);
            }
        }

        bLeft = TRUE_WMV;
        bRight = TRUE_WMV;
        if (iXformType == XFORMMODE_4x8)
        {
            ppxliErrorQMB = pWMVDec->m_ppxliErrorQ;
            memset(ppxliErrorQMB, 0, 256);
            if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 0)
                bLeft = FALSE_WMV;
            else if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 1)
                bRight = FALSE_WMV;
            if (bLeft)
            {
                tWMVStatus = (*pWMVDec->m_pDecodeInverseInterBlockQuantize)(pWMVDec, pInterDCTTableInfo_Dec, pWMVDec->m_p4x8ZigzagScanOrder, XFORMMODE_4x8); //get the quantized block      
                if (WMV_Succeeded != tWMVStatus) {
                    FUNCTION_PROFILE_STOP(&fpDecode);
                    return tWMVStatus;
                }
                (*pWMVDec->m_pInter4x8IDCT_Dec) (ppxliErrorQMB, BLOCK_SIZE, pWMVDec->m_rgiCoefReconBuf, 0);
            }
            if (bRight)
            {
                tWMVStatus = (*pWMVDec->m_pDecodeInverseInterBlockQuantize)(pWMVDec, pInterDCTTableInfo_Dec, pWMVDec->m_p4x8ZigzagScanOrder, XFORMMODE_4x8); //get the quantized block      
                if (WMV_Succeeded != tWMVStatus) {
                    FUNCTION_PROFILE_STOP(&fpDecode);
                    return tWMVStatus;
                }
                (*pWMVDec->m_pInter4x8IDCT_Dec) (ppxliErrorQMB, BLOCK_SIZE, pWMVDec->m_rgiCoefReconBuf, 1);
            } 
        }
       (*pWMVDec->m_pMotionCompAndAddErrorUV) (
            pWMVDec, ppxlcCurrQVMB, ppxliErrorQMB, ppxlcRefV, 
            pWMVDec->m_iWidthPrevUV, bXEvenUV, bYEvenUV, pWMVDec->m_iMixedPelMV);
    }
    else 
        (*pWMVDec->m_pMotionCompUV) (pWMVDec, ppxlcCurrQVMB, ppxlcRefV, pWMVDec->m_iWidthPrevUV, bXEvenUV, bYEvenUV, pWMVDec->m_iMixedPelMV);
            
    FUNCTION_PROFILE_STOP(&fpDecode);
    return WMV_Succeeded;
}
#endif //_EMB_WMV2_

#define INTRADCYTCOEF_ESCAPE_MSV 119							// see table.13/H.263
#define INTRADCUVTCOEF_ESCAPE_MSV 119							// see table.13/H.263
tWMVDecodeStatus DecodeIMBAcPred (
    tWMVDecInternalMember *pWMVDec,
    CWMVMBMode*            pmbmd, 
    U8_WMV*      ppxliTextureQMBY,
    U8_WMV*      ppxliTextureQMBU, 
    U8_WMV*      ppxliTextureQMBV, 
    I16_WMV*                piQuanCoefACPred, 
    I16_WMV**                piQuanCoefACPredTable, 
    Bool_WMV                bLeftMB, 
    Bool_WMV                bTopMB, 
    Bool_WMV                bLeftTopMB)
{
    tWMVDecodeStatus tWMVStatus;

    // Y-blocks first (4 blocks)
    U8_WMV * ppxliCodedBlkY = ppxliTextureQMBY;
    Bool_WMV bPredPattern;
    I16_WMV* pRef; 
    Bool_WMV bMBPattern[4] = {bLeftTopMB, bTopMB, bLeftMB, bLeftTopMB};
    U32_WMV ib;

    CDCTTableInfo_Dec* pInterDCTTableInfo_Dec;
    CDCTTableInfo_Dec* pIntraDCTTableInfo_Dec;
    if (pWMVDec->m_bDCTTable_MB){
        pInterDCTTableInfo_Dec = pWMVDec->m_pInterDCTTableInfo_Dec_Set[pmbmd->m_iDCTTable_MB_Index];
	    pIntraDCTTableInfo_Dec = pWMVDec->m_pIntraDCTTableInfo_Dec_Set[pmbmd->m_iDCTTable_MB_Index];
    }
    else{
        pInterDCTTableInfo_Dec = pWMVDec->m_pInterDCTTableInfo_Dec;
        pIntraDCTTableInfo_Dec = pWMVDec->m_pIntraDCTTableInfo_Dec;
    }

    for (ib = 0; ib < 4; ib++) {
        decodeIntraDCAcPredMSV (pWMVDec, &tWMVStatus, pWMVDec->m_pHufDCTDCyDec, INTRADCYTCOEF_ESCAPE_MSV);

        if (WMV_Succeeded != tWMVStatus) {
            return tWMVStatus;
        }

        pRef = decodeDiffDCTCoef(pWMVDec, piQuanCoefACPredTable, bLeftMB, bTopMB, bMBPattern[ib], bPredPattern);
        piQuanCoefACPred [0] = pWMVDec->m_rgiCoefRecon[0] + pRef [0];
        //pWMVDec->m_rgiCoefRecon[0] = (piQuanCoefACPred [0] << 3);
        pWMVDec->m_rgiCoefRecon[0] = (piQuanCoefACPred [0] * pWMVDec->m_iDCStepSize);

        tWMVStatus = decodeIntraBlockAcPred (
            pWMVDec, 
			pIntraDCTTableInfo_Dec,
            pmbmd, 
            ppxliCodedBlkY, 
            pWMVDec->m_iWidthPrevY,
            ib,
            piQuanCoefACPred,
            pRef,
            bPredPattern
            );
        if (WMV_Succeeded != tWMVStatus) {
            return tWMVStatus;
        }
        ppxliCodedBlkY += (ib != 1) ? BLOCK_SIZE : pWMVDec->m_iWidthPrevYxBlkMinusBlk;
        piQuanCoefACPred += BLOCK_SIZE_TIMES2;
        piQuanCoefACPredTable += 6;
    }

    // U-blocks
//#ifdef __MSV

    decodeIntraDCAcPredMSV (pWMVDec, &tWMVStatus, pWMVDec->m_pHufDCTDCcDec, INTRADCUVTCOEF_ESCAPE_MSV);
    
    if (WMV_Succeeded != tWMVStatus) {
        return tWMVStatus;
    }

    pRef = decodeDiffDCTCoef(pWMVDec, piQuanCoefACPredTable, bLeftMB, bTopMB, bLeftTopMB,bPredPattern);
    piQuanCoefACPred [0] = pWMVDec->m_rgiCoefRecon[0] + pRef [0];
//    pWMVDec->m_rgiCoefRecon[0] = (piQuanCoefACPred [0] << 3);
    pWMVDec->m_rgiCoefRecon[0] = (piQuanCoefACPred [0] * pWMVDec->m_iDCStepSizeC);

//#ifdef __MSV
    tWMVStatus = decodeIntraBlockAcPred (
        pWMVDec, 
		pInterDCTTableInfo_Dec,
        pmbmd,
        ppxliTextureQMBU,
        pWMVDec->m_iWidthPrevUV,
        4,
        piQuanCoefACPred,
        pRef,
        bPredPattern
        );

    if (WMV_Succeeded != tWMVStatus) {
        return tWMVStatus;
    }
    piQuanCoefACPred += BLOCK_SIZE_TIMES2;
    piQuanCoefACPredTable += 6;

    // V-blocks
//#ifdef __MSV

    decodeIntraDCAcPredMSV (pWMVDec, &tWMVStatus, pWMVDec->m_pHufDCTDCcDec, INTRADCUVTCOEF_ESCAPE_MSV);
    if (WMV_Succeeded != tWMVStatus) {
        return tWMVStatus;
    }

    pRef = decodeDiffDCTCoef(pWMVDec, piQuanCoefACPredTable, bLeftMB, bTopMB, bLeftTopMB,bPredPattern);
    piQuanCoefACPred [0] = pWMVDec->m_rgiCoefRecon[0] + pRef [0];
//    pWMVDec->m_rgiCoefRecon[0] = (piQuanCoefACPred [0] << 3);
    pWMVDec->m_rgiCoefRecon[0] = (piQuanCoefACPred [0] * pWMVDec->m_iDCStepSizeC);

//#ifdef __MSV
    tWMVStatus = decodeIntraBlockAcPred (
        pWMVDec, 
		pInterDCTTableInfo_Dec,
        pmbmd,
        ppxliTextureQMBV,
        pWMVDec->m_iWidthPrevUV,
        5,
        piQuanCoefACPred,
        pRef,
        bPredPattern
        );

    if (WMV_Succeeded != tWMVStatus) {
        return tWMVStatus;
    }

    return WMV_Succeeded;
}


tWMVDecodeStatus DecodeIMBAcPred_PFrame (
    tWMVDecInternalMember *pWMVDec,
    CWMVMBMode*            pmbmd, 
    U8_WMV*      ppxliTextureQMBY,
    U8_WMV*      ppxliTextureQMBU, 
    U8_WMV*      ppxliTextureQMBV, 
    I16_WMV*                piQuanCoefACPred, 
    I16_WMV**               piQuanCoefACPredTable, 
    Bool_WMV                bLeftMB, 
    Bool_WMV                bTopMB, 
    Bool_WMV                bLeftTopMB)
{
    Bool_WMV bLeftMBAndIntra, bLeftMBAndInter;
    Bool_WMV bTopMBAndIntra, bTopMBAndInter;
    Bool_WMV bLeftTopMBAndIntra, bLeftTopMBAndInter;
    Bool_WMV bMBPattern[4];
    CDCTTableInfo_Dec* pInterDCTTableInfo_Dec;
    CDCTTableInfo_Dec* pIntraDCTTableInfo_Dec;

    // Y
    tWMVDecodeStatus tWMVStatus;
    U8_WMV * ppxliCodedBlkY = ppxliTextureQMBY;
    Bool_WMV bPredPattern;
    I16_WMV* pRef; 
    U32_WMV ib;

	if (bLeftMB){
		if ((pmbmd - 1)->m_dctMd == INTRA){
			bLeftMBAndIntra = TRUE_WMV;
			bLeftMBAndInter = FALSE_WMV;
		}
		else{
			bLeftMBAndIntra = FALSE_WMV;
			bLeftMBAndInter = TRUE_WMV;
		}
	}
	else{
		bLeftMBAndInter = bLeftMBAndIntra = FALSE_WMV;
	}

	if (bTopMB){
		if ((pmbmd - pWMVDec->m_uintNumMBX)->m_dctMd == INTRA){
			bTopMBAndIntra = TRUE_WMV;
			bTopMBAndInter = FALSE_WMV;
		}
		else{
			bTopMBAndIntra = FALSE_WMV;
			bTopMBAndInter = TRUE_WMV;
		}
	}
	else{
        bTopMBAndInter = bTopMBAndIntra = FALSE_WMV;
	}

	if (bLeftTopMB){
		if ((pmbmd - pWMVDec->m_uintNumMBX - 1)->m_dctMd == INTRA){
			bLeftTopMBAndIntra = TRUE_WMV;
			bLeftTopMBAndInter = FALSE_WMV;
		}
		else{
			bLeftTopMBAndIntra = FALSE_WMV;
			bLeftTopMBAndInter = TRUE_WMV;
		}
	}
	else{
        bLeftTopMBAndInter = bLeftTopMBAndIntra = FALSE_WMV;
	}
	// bMBPattern is not used anymore.

    bMBPattern[0] = bLeftTopMBAndIntra;
    bMBPattern[1] = bTopMBAndIntra;
    bMBPattern[2] = bLeftMBAndIntra;
    bMBPattern[3] = bLeftTopMBAndIntra;


    if (pWMVDec->m_bDCTTable_MB){
        pInterDCTTableInfo_Dec = pWMVDec->m_pInterDCTTableInfo_Dec_Set[pmbmd->m_iDCTTable_MB_Index];
	    pIntraDCTTableInfo_Dec = pWMVDec->m_pIntraDCTTableInfo_Dec_Set[pmbmd->m_iDCTTable_MB_Index];
    }
    else{
        pInterDCTTableInfo_Dec = pWMVDec->m_pInterDCTTableInfo_Dec;
        pIntraDCTTableInfo_Dec = pWMVDec->m_pIntraDCTTableInfo_Dec;
    }


    // Y-blocks first (4 blocks)


    // Y0 block first 
    decodeIntraDCAcPredMSV (pWMVDec, &tWMVStatus, pWMVDec->m_pHufDCTDCyDec, INTRADCYTCOEF_ESCAPE_MSV);
    if (WMV_Succeeded != tWMVStatus) {
        return tWMVStatus;
    }
    ib = 0;

    bPredPattern = (pmbmd->m_rgbDCTCoefPredPattern & 2) >> 1;
    pRef = decodeDiffDCTCoef_WMV(pWMVDec, ppxliTextureQMBY, piQuanCoefACPredTable, bLeftMB, bTopMB, bLeftTopMB, bLeftMBAndInter, bTopMBAndInter, bLeftTopMBAndInter, bPredPattern, pWMVDec->m_iWidthPrevY, pWMVDec->m_iDCStepSize);
    piQuanCoefACPred [0] = pWMVDec->m_rgiCoefRecon[0] + pRef [0];
    pWMVDec->m_rgiCoefRecon[0] = (piQuanCoefACPred [0] * pWMVDec->m_iDCStepSize);
    tWMVStatus = decodeIntraBlockAcPred (
        pWMVDec, 
		pIntraDCTTableInfo_Dec,
        pmbmd, 
        ppxliCodedBlkY, 
        pWMVDec->m_iWidthPrevY,
        ib,
        piQuanCoefACPred,
        pRef,
        bPredPattern
        );
    if (WMV_Succeeded != tWMVStatus) {
        return tWMVStatus;
    }
    ppxliCodedBlkY += (ib != 1) ? BLOCK_SIZE : pWMVDec->m_iWidthPrevYxBlkMinusBlk;
    piQuanCoefACPred += BLOCK_SIZE_TIMES2;
    piQuanCoefACPredTable += 6;

    for (ib = 1; ib < 3; ib++) {
        decodeIntraDCAcPredMSV (pWMVDec, &tWMVStatus, pWMVDec->m_pHufDCTDCyDec, INTRADCYTCOEF_ESCAPE_MSV);
        if (WMV_Succeeded != tWMVStatus) {
            return tWMVStatus;
        }
        // Y_BLOCK1 = 1; Y_BLOCK2 = 2; Y_BLOCK3 = 3;

        bPredPattern = (pmbmd->m_rgbDCTCoefPredPattern & (1<<(ib+1))) >> (ib+1);

        //pRef = decodeDiffDCTCoef(piQuanCoefACPredTable, bLeftMBAndIntra, bTopMBAndIntra, bMBPattern[ib], bPredPattern);
        pRef = decodeDiffDCTCoef_WMV_Y23(piQuanCoefACPredTable, bLeftMBAndIntra, bTopMBAndIntra, bMBPattern[ib], bPredPattern);
        piQuanCoefACPred [0] = pWMVDec->m_rgiCoefRecon[0] + pRef [0];
        pWMVDec->m_rgiCoefRecon[0] = (piQuanCoefACPred [0] * pWMVDec->m_iDCStepSize);
        tWMVStatus = decodeIntraBlockAcPred (
            pWMVDec, 
			pIntraDCTTableInfo_Dec,
            pmbmd, 
            ppxliCodedBlkY, 
            pWMVDec->m_iWidthPrevY,
            ib,
            piQuanCoefACPred,
            pRef,
            bPredPattern
            );
        if (WMV_Succeeded != tWMVStatus) {
            return tWMVStatus;
        }
        ppxliCodedBlkY += (ib != 1) ? BLOCK_SIZE : pWMVDec->m_iWidthPrevYxBlkMinusBlk;
        piQuanCoefACPred += BLOCK_SIZE_TIMES2;
        piQuanCoefACPredTable += 6;
    }

    // Y4
    ib = 3;
    decodeIntraDCAcPredMSV (pWMVDec, &tWMVStatus, pWMVDec->m_pHufDCTDCyDec, INTRADCYTCOEF_ESCAPE_MSV);
    if (WMV_Succeeded != tWMVStatus) {
        return tWMVStatus;
    }

    pRef = decodeDiffDCTCoef(pWMVDec, piQuanCoefACPredTable, bLeftMBAndIntra, bTopMBAndIntra, bMBPattern[ib], bPredPattern);
    piQuanCoefACPred [0] = pWMVDec->m_rgiCoefRecon[0] + pRef [0];
    pWMVDec->m_rgiCoefRecon[0] = (piQuanCoefACPred [0] * pWMVDec->m_iDCStepSize);
    tWMVStatus = decodeIntraBlockAcPred (
        pWMVDec, 
		pIntraDCTTableInfo_Dec,
        pmbmd, 
        ppxliCodedBlkY, 
        pWMVDec->m_iWidthPrevY,
        ib,
        piQuanCoefACPred,
        pRef,
        bPredPattern
        );
    if (WMV_Succeeded != tWMVStatus) {
        return tWMVStatus;
    }
    ppxliCodedBlkY += (ib != 1) ? BLOCK_SIZE : pWMVDec->m_iWidthPrevYxBlkMinusBlk;
    piQuanCoefACPred += BLOCK_SIZE_TIMES2;
    piQuanCoefACPredTable += 6;

    // U-blocks
//#ifdef __MSV
    decodeIntraDCAcPredMSV (pWMVDec, &tWMVStatus, pWMVDec->m_pHufDCTDCcDec, INTRADCUVTCOEF_ESCAPE_MSV);
    if (WMV_Succeeded != tWMVStatus) {
        return tWMVStatus;
    }

    bPredPattern = (pmbmd->m_rgbDCTCoefPredPattern & (1<<5))>>5;
    pRef = decodeDiffDCTCoef_WMV(pWMVDec, ppxliTextureQMBU, piQuanCoefACPredTable, bLeftMB, bTopMB, bLeftTopMB, bLeftMBAndInter, bTopMBAndInter, bLeftTopMBAndInter, bPredPattern, pWMVDec->m_iWidthPrevUV, pWMVDec->m_iDCStepSizeC);
    piQuanCoefACPred [0] = pWMVDec->m_rgiCoefRecon[0] + pRef [0];
    pWMVDec->m_rgiCoefRecon[0] = (piQuanCoefACPred [0] * pWMVDec->m_iDCStepSizeC);

//#ifdef __MSV
    tWMVStatus = decodeIntraBlockAcPred (
        pWMVDec, 
		pInterDCTTableInfo_Dec,
        pmbmd,
        ppxliTextureQMBU,
        pWMVDec->m_iWidthPrevUV,
        4,
        piQuanCoefACPred,
        pRef,
        bPredPattern
        );

    if (WMV_Succeeded != tWMVStatus) {
        return tWMVStatus;
    }
    piQuanCoefACPred += BLOCK_SIZE_TIMES2;
    piQuanCoefACPredTable += 6;

    // V-blocks
//#ifdef __MSV
    decodeIntraDCAcPredMSV (pWMVDec, &tWMVStatus, pWMVDec->m_pHufDCTDCcDec, INTRADCUVTCOEF_ESCAPE_MSV);
    if (WMV_Succeeded != tWMVStatus) {
        return tWMVStatus;
    }

    bPredPattern = (pmbmd->m_rgbDCTCoefPredPattern & (1<<6)) >> 6;
    pRef = decodeDiffDCTCoef_WMV(pWMVDec, ppxliTextureQMBV, piQuanCoefACPredTable, bLeftMB, bTopMB, bLeftTopMB, bLeftMBAndInter, bTopMBAndInter, bLeftTopMBAndInter, bPredPattern, pWMVDec->m_iWidthPrevUV, pWMVDec->m_iDCStepSizeC);
    piQuanCoefACPred [0] = pWMVDec->m_rgiCoefRecon[0] + pRef [0];
    pWMVDec->m_rgiCoefRecon[0] = (piQuanCoefACPred [0] * pWMVDec->m_iDCStepSizeC);

    tWMVStatus = decodeIntraBlockAcPred (
        pWMVDec, 
		pInterDCTTableInfo_Dec,
        pmbmd,
        ppxliTextureQMBV,
        pWMVDec->m_iWidthPrevUV,
        5,
        piQuanCoefACPred,
        pRef,
        bPredPattern
        );

    if (WMV_Succeeded != tWMVStatus) {
        return tWMVStatus;
    }

    return WMV_Succeeded;
}


#ifndef _EMB_WMV2_
// _MIXEDPEL_

#define TWOPOINT(output, a, b)                  \
    output = rgiClapTab[(((I32_WMV)a + (I32_WMV)b + 1) >> 1)];

#define FOURPOINT(output, a, b, c, d)           \
    output = rgiClapTab[(I32_WMV)((9 * ((I32_WMV)b + (I32_WMV)c) - ((I32_WMV)a + (I32_WMV)d) + 8) >> 4)];

Void_WMV MotionCompMixed (
                        tWMVDecInternalMember *pWMVDec,
                        U8_WMV*              ppxlcPredMB,
                        const U8_WMV*        ppxlcRefMB,
                        I32_WMV                  iWidthPrev,
                        Bool_WMV                 bInterpolateX,
                        Bool_WMV                 bInterpolateY,
                        I32_WMV                  iMixedPelMV
                        )
{    
	FUNCTION_PROFILE_DECL_START(fpDecode,MOTIONCOMPMIXED_PROFILE);

    const U8_WMV* rgiClapTab = pWMVDec->m_rgiClapTabDec; 

    U8_WMV* ppxlcPred = ppxlcPredMB;

    U8_WMV tempBlock[11 * 8 + 15];
    U8_WMV *alignedBlock = (U8_WMV*) (((int)tempBlock + 15) & ~15);
    
    if (bInterpolateY) {
        if (bInterpolateX) {  //!bXSubPxl && !bYSubPxl
            assert(iMixedPelMV == 0);
            I32_WMV iy;
            for (iy = 0; iy < 8; iy++) {
				memcpy(ppxlcPredMB,ppxlcRefMB,8);                
                ppxlcRefMB += iWidthPrev;
                ppxlcPredMB += iWidthPrev;
            }
        }
        else {  //bXSubPxl && !bYSubPxl            
            U8_WMV* pRef = (U8_WMV*) (ppxlcRefMB + 1);
            
            if (iMixedPelMV == 0) {
                I32_WMV iy; 
                for (iy = 0; iy < 8; iy++) {
                    I32_WMV ix;
                    for (ix = 0; ix < 8; ix++) {
                        FOURPOINT(ppxlcPred[ix], pRef[ix-2], pRef[ix-1], pRef[ix], pRef[ix+1]);
                    }
                    ppxlcPred += iWidthPrev;
                    pRef += iWidthPrev;
                } 
            } else {
                // Handles the case in underline
                // I Q H Q I Q H Q I
                //     ___     ___
                I32_WMV iy;
                for (iy = 0; iy < 8; iy++) {
                    I32_WMV ix;
                    for (ix = 0; ix < 8; ix++) {
                        FOURPOINT(ppxlcPred[ix], pRef[ix-2], pRef[ix-1], pRef[ix], pRef[ix+1]);
                        TWOPOINT(ppxlcPred[ix], ppxlcPred[ix], pRef[ix]);
                    }

                    ppxlcPred  += iWidthPrev;
                    pRef += iWidthPrev;
                }
            }
        }
    }
    else {
        if (bInterpolateX) {  //!bXSubPxl&& bYSubPxl
            U8_WMV* pRef = (U8_WMV*) (ppxlcRefMB + iWidthPrev);           
            const U8_WMV* pLine4 = pRef + iWidthPrev;
            const U8_WMV* pLine3 = pRef;
            const U8_WMV* pLine2 = pLine3 - iWidthPrev;
            const U8_WMV* pLine1 = pLine2 - iWidthPrev;        
            
            if (iMixedPelMV == 0) {   
                I32_WMV iy;
                for (iy = 0; iy < 8; iy++) {
                    I32_WMV ix; 
                    for (ix = 0; ix < 8; ix++) {
                        FOURPOINT(ppxlcPred[ix], pLine1[ix], pLine2[ix], pLine3[ix], pLine4[ix]);
                    }
                    
                    ppxlcPred += iWidthPrev;
                    pLine1 += iWidthPrev;
                    pLine2 += iWidthPrev;
                    pLine3 += iWidthPrev;
                    pLine4 += iWidthPrev;
                }

            } else {
                //      H Q H' 
                //      I                        
                const U8_WMV* pLine = pLine1;
                U8_WMV* pBlock = alignedBlock;
                I32_WMV iy;
                for (iy = 0; iy < 11; iy++) {
                    I32_WMV ix;
                    for (ix = 0; ix < 8; ix++) {
                        FOURPOINT(pBlock[ix], pLine[ix - 1], pLine[ix], pLine[ix + 1], pLine[ix + 2]);
                    }

                    pLine += iWidthPrev;
                    pBlock += 8;
                }
            
                pBlock = alignedBlock;
                for (iy = 0; iy < 8; iy++) {
                    I32_WMV ix;
                    for (ix = 0; ix < 8; ix++) {
                        I32_WMV iDiagResult, iVertResult;
                        FOURPOINT(iDiagResult, pBlock[ix], pBlock[ix + 8], pBlock[ix + 16], pBlock[ix + 24]);                        
                        FOURPOINT(iVertResult, pLine1[ix], pLine2[ix], pLine3[ix], pLine4[ix]);
                        TWOPOINT(ppxlcPred[ix], iDiagResult, iVertResult);
                    }

                    ppxlcPred += iWidthPrev;
                    pBlock += 8;
                    pLine1 += iWidthPrev;
                    pLine2 += iWidthPrev;
                    pLine3 += iWidthPrev;
                    pLine4 += iWidthPrev; 
                }     

            }
        }
        else { // bXSubPxl && bYSubPxl
            U8_WMV* pRef = (U8_WMV*) (ppxlcRefMB + iWidthPrev + 1);             
            const U8_WMV* pLine4 = pRef + iWidthPrev;
            const U8_WMV* pLine3 = pRef;
            const U8_WMV* pLine2 = pLine3 - iWidthPrev;
            const U8_WMV* pLine1 = pLine2 - iWidthPrev;                
            if (iMixedPelMV == 0) {

                const U8_WMV* pLine = pLine1;
                U8_WMV* pBlock = alignedBlock;
                I32_WMV iy;
                for (iy = 0; iy < 11; iy++) {
                    I32_WMV ix;
                    for (ix = 0; ix < 8; ix++) {
                        FOURPOINT(pBlock[ix], pLine[ix - 2], pLine[ix - 1], pLine[ix], pLine[ix + 1]);
                    }
                    pLine += iWidthPrev;
                    pBlock += 8;
                }
            
                pBlock = alignedBlock;
                for (iy = 0; iy < 8; iy++) {
                    I32_WMV ix;
                    for (ix = 0; ix < 8; ix++) {
                        FOURPOINT(ppxlcPred[ix], pBlock[ix], pBlock[ix + 8], pBlock[ix + 16], pBlock[ix + 24]);
                     }
                    ppxlcPred += iWidthPrev;
                    pBlock += 8;
                }   
            } else {
                // H Q H
                //     I

                const U8_WMV* pLine = pLine1;
                U8_WMV* pBlock = alignedBlock;
                I32_WMV iy;
                for (iy = 0; iy < 11; iy++) {
                    I32_WMV ix;
                    for (ix = 0; ix < 8; ix++) {
                        FOURPOINT(pBlock[ix], pLine[ix - 2], pLine[ix - 1], pLine[ix], pLine[ix + 1]);
                    }
                    pLine += iWidthPrev;
                    pBlock += 8;
                }
            
                pBlock = alignedBlock;
                for (iy = 0; iy < 8; iy++) {
                    I32_WMV ix;
                    for (ix = 0; ix < 8; ix++) {
                        I32_WMV iDiagResult, iVertResult;
                        FOURPOINT(iDiagResult, pBlock[ix], pBlock[ix + 8], pBlock[ix + 16], pBlock[ix + 24]);
                        FOURPOINT(iVertResult, pLine1[ix], pLine2[ix], pLine3[ix], pLine4[ix]);
                        TWOPOINT(ppxlcPred[ix], iDiagResult, iVertResult);
                     }
                    ppxlcPred += iWidthPrev;
                    pBlock += 8;
                    pLine1 += iWidthPrev;
                    pLine2 += iWidthPrev;
                    pLine3 += iWidthPrev;
                    pLine4 += iWidthPrev; 
                }  

            }
        }
    }
    FUNCTION_PROFILE_STOP(&fpDecode);
}

Void_WMV MotionCompMixedAndAddError (
                                   tWMVDecInternalMember *pWMVDec,
                                   U8_WMV* ppxlcCurrQMB, 
                                   const Buffer __huge* ppxliErrorBuf, 
                                   const U8_WMV* ppxlcRef, 
                                   I32_WMV iWidthFrm, Bool_WMV bXEven, Bool_WMV bYEven, 
                                   I32_WMV iMixedPelMV
                                   )
{
	FUNCTION_PROFILE_DECL_START(fpDecode,MOTIONCOMPMIXEDADDERROR_PROFILE);

    const U8_WMV* rgiClapTab = pWMVDec->m_rgiClapTabDec; 

    U8_WMV tempBlock[11 * 8 + 15];
    U8_WMV *alignedBlock = (U8_WMV*) (((int)tempBlock + 15) & ~15);

    const PixelI32 *ppxliErrorQMB = ppxliErrorBuf->i32;
    if (bYEven) {
        if (bXEven) {  //!bXSubPxl && !bYSubPxl
            if (iMixedPelMV == 0) {
                I32_WMV iy;
                for (iy = 0; iy < BLOCK_SIZE; iy++) {
                    I32_WMV ix;
                    for (ix = 0; ix < BLOCK_SIZE; ix++) {
                        ppxlcCurrQMB [ix] = rgiClapTab [ppxliErrorQMB [ix] + ppxlcRef [ix]];
                    }
                    ppxlcRef += iWidthFrm;
                    ppxlcCurrQMB += iWidthFrm;
                    ppxliErrorQMB += BLOCK_SIZE;
                }

            } else {
                // Handles the case in underline
                // I Q H Q I Q H Q I
                //         ___           				
                I32_WMV iy;
                for (iy = 0; iy < BLOCK_SIZE; iy++) {
                    I32_WMV ix;
                    for (ix = 0; ix < BLOCK_SIZE; ix++) {
                        I32_WMV iResult;
                        FOURPOINT(iResult, ppxlcRef[ix - 1], ppxlcRef[ix], ppxlcRef[ix + 1], ppxlcRef[ix + 2]);
                        TWOPOINT(iResult, iResult, ppxlcRef[ix]);
                        ppxlcCurrQMB[ix] = rgiClapTab [ppxliErrorQMB [ix] + iResult];
                    }
                    ppxlcCurrQMB += iWidthFrm;
                    ppxliErrorQMB += BLOCK_SIZE;
                    ppxlcRef += iWidthFrm;
                }    

            }
        }
        else {  //bXSubPxl && !bYSubPxl
            if (iMixedPelMV == 0) {
                I32_WMV iy;
                for (iy = 0; iy < BLOCK_SIZE; iy++) {   
                    I32_WMV ix;
                    for (ix = 0; ix < BLOCK_SIZE; ix++) {
                        I32_WMV iResult;
                        FOURPOINT(iResult, ppxlcRef[ix - 1], ppxlcRef[ix], ppxlcRef[ix + 1], ppxlcRef[ix + 2]);
                        ppxlcCurrQMB [ix] = rgiClapTab [ppxliErrorQMB [ix] + iResult];
                    }
                    ppxlcRef += iWidthFrm;
                    ppxlcCurrQMB += iWidthFrm;
                    ppxliErrorQMB += BLOCK_SIZE;
                }

            } else {
                // Handles the case in underline
                // I Q H Q I Q H Q I
                //     ___     ___               
                I32_WMV iy;
                for (iy = 0; iy < BLOCK_SIZE; iy++) {
                    I32_WMV ix;
                    for (ix = 0; ix < BLOCK_SIZE; ix++) {
                        I32_WMV iResult;
                        FOURPOINT(iResult, ppxlcRef[ix - 1], ppxlcRef[ix], ppxlcRef[ix + 1], ppxlcRef[ix + 2]);
                        TWOPOINT(iResult, iResult, ppxlcRef[ix + 1]);
                        ppxlcCurrQMB[ix] = rgiClapTab [ppxliErrorQMB [ix] + 
                            iResult];	
                    }
                    ppxlcCurrQMB += iWidthFrm;
                    ppxliErrorQMB += BLOCK_SIZE;
                    ppxlcRef += iWidthFrm;
                }   

            }
        }
    }
    else {
        if (bXEven) {  //!bXSubPxl&& bYSubPxl
            if (iMixedPelMV == 0) {

                const U8_WMV* pLine1 = ppxlcRef - iWidthFrm;
                const U8_WMV* pLine2 = ppxlcRef;
                const U8_WMV* pLine3 = pLine2 + iWidthFrm;
                const U8_WMV* pLine4 = pLine3 + iWidthFrm;   
                I32_WMV iy;
                for (iy = 0; iy < BLOCK_SIZE; iy++) {  
                    I32_WMV ix;
                    for (ix = 0; ix < BLOCK_SIZE; ix++) {   
                        I32_WMV iResult;
                        FOURPOINT(iResult, pLine1[ix], pLine2[ix], pLine3[ix], pLine4[ix]);
                        ppxlcCurrQMB [ix] = rgiClapTab [ppxliErrorQMB [ix] + iResult];
                    }
                    pLine1 += iWidthFrm;
                    pLine2 += iWidthFrm;
                    pLine3 += iWidthFrm;
                    pLine4 += iWidthFrm;
                    ppxlcCurrQMB += iWidthFrm;
                    ppxliErrorQMB += BLOCK_SIZE;
                }

            } else {
                //      H Q H' 
                //      I          

                U8_WMV* pRef = (U8_WMV*) (ppxlcRef + iWidthFrm);                   
                const U8_WMV* pLine4 = pRef + iWidthFrm; 
                const U8_WMV* pLine3 = pRef;
                const U8_WMV* pLine2 = pLine3 - iWidthFrm;
                const U8_WMV* pLine1 = pLine2 - iWidthFrm;
                const U8_WMV* pLine = pLine1;
                U8_WMV* pBlock = alignedBlock;
                I32_WMV iy;
                for (iy = 0; iy < 11; iy++) {
                    I32_WMV ix;
                    for (ix = 0; ix < 8; ix++) {
                        FOURPOINT(pBlock[ix], pLine[ix - 1], pLine[ix], pLine[ix + 1], pLine[ix + 2]);
                    }
                    pLine += iWidthFrm;
                    pBlock += 8;
                }
                pBlock = alignedBlock;
                
                for (iy = 0; iy < BLOCK_SIZE; iy++) {
                    I32_WMV ix;
                    for (ix = 0; ix < BLOCK_SIZE; ix++) {
                        I32_WMV iResult, iDiagResult, iVertResult;
                        FOURPOINT(iDiagResult, pBlock[ix], pBlock[ix + 8], pBlock[ix + 16], pBlock[ix + 24]);
                        FOURPOINT(iVertResult, pLine1[ix], pLine2[ix], pLine3[ix], pLine4[ix]);
                        TWOPOINT(iResult, iDiagResult, iVertResult);
                        ppxlcCurrQMB[ix] = rgiClapTab [ppxliErrorQMB [ix] + iResult];
                    }
                    pBlock += 8;
                    ppxlcCurrQMB += iWidthFrm;
                    ppxliErrorQMB += BLOCK_SIZE;
                    pLine1 += iWidthFrm;
                    pLine2 += iWidthFrm;
                    pLine3 += iWidthFrm;
                    pLine4 += iWidthFrm;
                }   

            }
        }
        else { // bXSubPxl && bYSubPxl
            if (iMixedPelMV == 0) {

                U8_WMV* pRef = (U8_WMV*) ppxlcRef; 
                const U8_WMV* pLine1 = pRef - iWidthFrm;
                const U8_WMV* pLine = pLine1;
                U8_WMV* pBlock = alignedBlock;
                I32_WMV iy;
                for (iy = 0; iy < 11; iy++) {
                    I32_WMV ix;
                    for (ix = 0; ix < 8; ix++) {
                        FOURPOINT(pBlock[ix], pLine[ix - 1], pLine[ix], pLine[ix + 1], pLine[ix + 2]);
                    }
                    pLine += iWidthFrm;
                    pBlock += 8;
                }
                pBlock = alignedBlock;
                for (iy = 0; iy < BLOCK_SIZE; iy++) {
                    I32_WMV ix;
                    for (ix = 0; ix < BLOCK_SIZE; ix++) {
                        I32_WMV iResult;
                        FOURPOINT(iResult, pBlock[ix], pBlock[ix + 8], pBlock[ix + 16], pBlock[ix + 24]);
                        ppxlcCurrQMB[ix] = rgiClapTab [ppxliErrorQMB [ix] + iResult];
                    }
                    pBlock += 8;
                    ppxlcCurrQMB += iWidthFrm;
                    ppxliErrorQMB += BLOCK_SIZE;
                }      

            } else {
                // H Q H
                //     I
                //alignedBlock

                U8_WMV* pRef = (U8_WMV*) (ppxlcRef + iWidthFrm + 1); 
                const U8_WMV* pLine4 = pRef + iWidthFrm;
                const U8_WMV* pLine3 = pRef;
                const U8_WMV* pLine2 = pLine3 - iWidthFrm;
                const U8_WMV* pLine1 = pLine2 - iWidthFrm;

                const U8_WMV* pLine = pLine1;
                U8_WMV* pBlock = alignedBlock;
                I32_WMV iy;
                for (iy = 0; iy < 11; iy++) {
                    I32_WMV ix;
                    for (ix = 0; ix < 8; ix++) {
                        FOURPOINT(pBlock[ix], pLine[ix- 2], pLine[ix - 1], pLine[ix], pLine[ix + 1]);
                    }
                    pLine += iWidthFrm;
                    pBlock += 8;
                }
                pBlock = alignedBlock;
                for (iy = 0; iy < BLOCK_SIZE; iy++) {
                    I32_WMV ix;
                    for (ix = 0; ix < BLOCK_SIZE; ix++) {
                        I32_WMV iResult, iDiagResult, iVertResult;
                        FOURPOINT(iDiagResult, pBlock[ix], pBlock[ix + 8], pBlock[ix + 16], pBlock[ix + 24]);
                        FOURPOINT(iVertResult, pLine1[ix], pLine2[ix], pLine3[ix], pLine4[ix]);
                        TWOPOINT(iResult, iDiagResult, iVertResult);
                        ppxlcCurrQMB[ix] = rgiClapTab [ppxliErrorQMB [ix] + iResult];

                    }
                    pBlock += 8;
                    ppxliErrorQMB += BLOCK_SIZE;
                    ppxlcCurrQMB += iWidthFrm;
                    pLine4 += iWidthFrm;
                    pLine3 += iWidthFrm;
                    pLine2 += iWidthFrm;
                    pLine1 += iWidthFrm;
                }      

            }
        }
    }
    FUNCTION_PROFILE_STOP(&fpDecode);
}
#endif //_EMB_WMV2_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\deblock.cpp ===
#include "bldsetup.h"

#include "xplatform.h"

#ifdef _SUPPORT_POST_FILTERS_
#include "limits.h"
#include "stdio.h"
#include "stdlib.h"
#include "typedef.hpp"
#include "wmvdec_member.h"
#include "wmvdec_function.h"
#include "postfilter_wmv.hpp"
#include <math.h>
#include "tables_wmv.h"

Void_WMV DeblockIFrame (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* ppxliY,
    U8_WMV* ppxliU,
    U8_WMV* ppxliV,
    U32_WMV iMBStartY, U32_WMV iMBEndY
    )
{ 
    assert (pWMVDec->m_bDeblockOn);
    U8_WMV* ppxliPostY = ppxliY; //pWMVDec->m_ppxliPostQY + pWMVDec->m_iWidthPrevYXExpPlusExp;
    U8_WMV* ppxliPostU = ppxliU; //pWMVDec->m_ppxliPostQU + pWMVDec->m_iWidthPrevUVXExpPlusExp;
    U8_WMV* ppxliPostV = ppxliV; //pWMVDec->m_ppxliPostQV + pWMVDec->m_iWidthPrevUVXExpPlusExp;
    U32_WMV imbY;
    for (imbY = iMBStartY; imbY < iMBEndY; imbY++) {
        U8_WMV* ppxliCodedPostY = ppxliPostY;
        U8_WMV* ppxliCodedPostU = ppxliPostU;
        U8_WMV* ppxliCodedPostV = ppxliPostV;
        U32_WMV imbX;
        for (imbX = 0; imbX < pWMVDec->m_uintNumMBX; imbX++) {
            
                g_pDeblockMB(
                    pWMVDec,
                    ppxliCodedPostY, 
                    ppxliCodedPostU, 
                    ppxliCodedPostV, 
                    imbX,                       // left
                    FALSE,                      // right half-edge
                    imbY,                       // top
                    FALSE,                      // bottom half-edge
                    TRUE_WMV,                       // middle
                    pWMVDec->m_iStepSize,
                    pWMVDec->m_iWidthPrevY,
                    pWMVDec->m_iWidthPrevUV);

            ppxliCodedPostY += MB_SIZE;
            ppxliCodedPostU += BLOCK_SIZE;
            ppxliCodedPostV += BLOCK_SIZE;
        }
        ppxliPostY += pWMVDec->m_iMBSizeXWidthPrevY;
        ppxliPostU += pWMVDec->m_iBlkSizeXWidthPrevUV;
        ppxliPostV += pWMVDec->m_iBlkSizeXWidthPrevUV;
    }

    if (pWMVDec->m_bDeringOn == FALSE)
        return;

    ppxliPostY = ppxliY; //pWMVDec->m_ppxliPostQY + pWMVDec->m_iWidthPrevYXExpPlusExp;
    ppxliPostU = ppxliU; //pWMVDec->m_ppxliPostQU + pWMVDec->m_iWidthPrevUVXExpPlusExp;
    ppxliPostV = ppxliV; //pWMVDec->m_ppxliPostQV + pWMVDec->m_iWidthPrevUVXExpPlusExp;

    for (imbY = iMBStartY; imbY < iMBEndY; imbY++) {
        U8_WMV* ppxliCodedPostY = ppxliPostY;
        U8_WMV* ppxliCodedPostU = ppxliPostU;
        U8_WMV* ppxliCodedPostV = ppxliPostV;
        U32_WMV imbX;
        for (imbX = 0; imbX < pWMVDec->m_uintNumMBX; imbX++) {
            
                if (!((imbX == 0)            ||
                     (imbX == pWMVDec->m_uintNumMBX-1)||
                     (imbY == 0)             ||
                     (imbY == pWMVDec->m_uintNumMBY-1))) 
                     g_pDeringMB(ppxliCodedPostY, ppxliCodedPostU, ppxliCodedPostV,pWMVDec->m_iStepSize,pWMVDec->m_iWidthPrevY,pWMVDec->m_iWidthPrevUV);
      
            ppxliCodedPostY += MB_SIZE;
            ppxliCodedPostU += BLOCK_SIZE;
            ppxliCodedPostV += BLOCK_SIZE;
        }
        ppxliPostY += pWMVDec->m_iMBSizeXWidthPrevY;
        ppxliPostU += pWMVDec->m_iBlkSizeXWidthPrevUV;
        ppxliPostV += pWMVDec->m_iBlkSizeXWidthPrevUV;
    }
}


Void_WMV DeblockPFrame (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* ppxliY,
    U8_WMV* ppxliU,
    U8_WMV* ppxliV,
    U32_WMV iMBStartY, U32_WMV iMBEndY
    )
{   
    assert (pWMVDec->m_bDeblockOn);
    U8_WMV* ppxliPostY = ppxliY; //pWMVDec->m_ppxliPostQY + pWMVDec->m_iWidthPrevYXExpPlusExp;
    U8_WMV* ppxliPostU = ppxliU; //pWMVDec->m_ppxliPostQU + pWMVDec->m_iWidthPrevUVXExpPlusExp;
    U8_WMV* ppxliPostV = ppxliV; //pWMVDec->m_ppxliPostQV + pWMVDec->m_iWidthPrevUVXExpPlusExp;
    const CWMVMBMode* pmbmd = pWMVDec->m_rgmbmd + iMBStartY * pWMVDec->m_uintNumMBX;
    U32_WMV imbY;
	for (imbY = iMBStartY; imbY < iMBEndY; imbY++) {
        U8_WMV* ppxliCodedPostY = ppxliPostY;
        U8_WMV* ppxliCodedPostU = ppxliPostU;
        U8_WMV* ppxliCodedPostV = ppxliPostV;
        U32_WMV imbX;
        for (imbX = 0; imbX < pWMVDec->m_uintNumMBX; imbX++, pmbmd++) {
#ifndef _XBOX
            if (pmbmd->m_bSkip == FALSE) {
#else
            if (1) { // 
#endif
                Bool_WMV bdoBottomHalfEdge = FALSE, bdoRightHalfEdge = FALSE_WMV;
                if (imbX != (pWMVDec->m_uintNumMBX - 1)) {
                    bdoRightHalfEdge = (pmbmd + 1)->m_bSkip;
                }
                if (imbY != (pWMVDec->m_uintNumMBY - 1)) {
                    bdoBottomHalfEdge = (pmbmd + pWMVDec->m_uintNumMBX)->m_bSkip;
                }
                g_pDeblockMB(
                    pWMVDec,
                    ppxliCodedPostY, 
                    ppxliCodedPostU, 
                    ppxliCodedPostV, 
                    imbX,                           // left
                    bdoRightHalfEdge,               // right half-edge
                    imbY,                           // top
                    bdoBottomHalfEdge,              // bottom half-edge
                    TRUE_WMV,                           // middle
                    pWMVDec->m_iStepSize,
                    pWMVDec->m_iWidthPrevY,
                    pWMVDec->m_iWidthPrevUV);
            }
            ppxliCodedPostY += MB_SIZE;
            ppxliCodedPostU += BLOCK_SIZE;
            ppxliCodedPostV += BLOCK_SIZE;
        }
        ppxliPostY += pWMVDec->m_iMBSizeXWidthPrevY; 
        ppxliPostU += pWMVDec->m_iBlkSizeXWidthPrevUV;
        ppxliPostV += pWMVDec->m_iBlkSizeXWidthPrevUV;
    }

    if (pWMVDec->m_bDeringOn == FALSE)
        return;

    ppxliPostY = ppxliY; //pWMVDec->m_ppxliPostQY + pWMVDec->m_iWidthPrevYXExpPlusExp;
    ppxliPostU = ppxliU; //pWMVDec->m_ppxliPostQU + pWMVDec->m_iWidthPrevUVXExpPlusExp;
    ppxliPostV = ppxliV; //pWMVDec->m_ppxliPostQV + pWMVDec->m_iWidthPrevUVXExpPlusExp;
    pmbmd = pWMVDec->m_rgmbmd + iMBStartY * pWMVDec->m_uintNumMBX;
    for (imbY = iMBStartY; imbY < iMBEndY; imbY++) {
        U8_WMV* ppxliCodedPostY = ppxliPostY;
        U8_WMV* ppxliCodedPostU = ppxliPostU;
        U8_WMV* ppxliCodedPostV = ppxliPostV;
        U32_WMV imbX;
        for (imbX = 0; imbX < pWMVDec->m_uintNumMBX; imbX++, pmbmd++) {
#ifndef _XBOX
            if (pmbmd->m_bSkip == FALSE) {
#else
            if (1) {
#endif
           
                if (!((imbX == 0)            ||
                     (imbX == pWMVDec->m_uintNumMBX-1)||
                     (imbY == 0)             ||
                     (imbY == pWMVDec->m_uintNumMBY-1))) 
                     g_pDeringMB(ppxliCodedPostY, ppxliCodedPostU, ppxliCodedPostV,pWMVDec->m_iStepSize,pWMVDec->m_iWidthPrevY,pWMVDec->m_iWidthPrevUV);
  
            }
            ppxliCodedPostY += MB_SIZE;
            ppxliCodedPostU += BLOCK_SIZE;
            ppxliCodedPostV += BLOCK_SIZE;
        }
        ppxliPostY += pWMVDec->m_iMBSizeXWidthPrevY; 
        ppxliPostU += pWMVDec->m_iBlkSizeXWidthPrevUV;
        ppxliPostV += pWMVDec->m_iBlkSizeXWidthPrevUV;
    }
}


Void_WMV AssignDeblokRoutines (tWMVDecInternalMember *pWMVDec)
{
    if (pWMVDec->m_iPostProcessMode < 0 || pWMVDec->m_iPostProcessMode >= 5) 
        return;

    if (pWMVDec->m_iPostProcessMode == 4) {
        pWMVDec->m_pDecodeI = WMVideoDecDecodeIDeblock;
        pWMVDec->m_pDecodeP = WMVideoDecDecodePDeblock;
        pWMVDec->m_bDeblockOn = TRUE_WMV;
        pWMVDec->m_bDeringOn = TRUE_WMV;
        g_InitPostFilter (FALSE);
    }
    else if (pWMVDec->m_iPostProcessMode == 3) {
        pWMVDec->m_pDecodeI = WMVideoDecDecodeIDeblock;
        pWMVDec->m_pDecodeP = WMVideoDecDecodePDeblock;
        pWMVDec->m_bDeblockOn = TRUE_WMV;
        pWMVDec->m_bDeringOn = TRUE_WMV;
        g_InitPostFilter (TRUE_WMV);
    }
    else if (pWMVDec->m_iPostProcessMode == 2) {
        pWMVDec->m_pDecodeI = WMVideoDecDecodeIDeblock;
        pWMVDec->m_pDecodeP = WMVideoDecDecodePDeblock;
        pWMVDec->m_bDeblockOn = TRUE_WMV;
        pWMVDec->m_bDeringOn = FALSE_WMV;
        g_InitPostFilter (FALSE);
    }
    else if (pWMVDec->m_iPostProcessMode == 1) {
        pWMVDec->m_pDecodeI = WMVideoDecDecodeIDeblock;
        pWMVDec->m_pDecodeP = WMVideoDecDecodePDeblock;
        pWMVDec->m_bDeblockOn = TRUE_WMV;
        pWMVDec->m_bDeringOn = FALSE_WMV;
        g_InitPostFilter (TRUE_WMV);
    }
    else {
        pWMVDec->m_pDecodeI = WMVideoDecDecodeI;
        pWMVDec->m_pDecodeP = WMVideoDecDecodeP;
        pWMVDec->m_bDeblockOn = FALSE_WMV;
        pWMVDec->m_bDeringOn = FALSE_WMV;
    }
}

#endif // _SUPPORT_POST_FILTERS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\decolorconv_wmv.cpp ===
#include "bldsetup.h"

#include "xplatform.h"
#include "wmvdec_api.h"
#include "wmvdec_member.h"
#include "wmvdec_function.h"
#include "constants_wmv.h"
#include "math.h"
#include "memory.h"

#ifdef IPP_COLORCONV
#include "..\arm\ippdefs.h"
#include "..\arm\ippIp.h"
#endif //IPP_COLORCONV

#if defined(_ARM_) || defined(__arm)
#   define PAGE_ARM_MINICACHE 0x800
#else
#   define PAGE_ARM_MINICACHE 0
#endif

// XBox surface requires 64-bit scanline alignment
#ifdef _XBOX
#define BITMAP_WIDTH_WMV(width, bitCount) \
    (I32_WMV)((I32_WMV)(((((I32_WMV)width) * ((I32_WMV)bitCount)) + 511L) & (I32_WMV)~511L) / 8L)
#else
#define BITMAP_WIDTH_WMV(width, bitCount) \
    (I32_WMV)((I32_WMV)(((((I32_WMV)width) * ((I32_WMV)bitCount)) + 31L) & (I32_WMV)~31L) / 8L)
#endif


#if defined (UNDER_CE) || defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB8) || defined (OUTPUT_RGB16) || defined (OUTPUT_RGB24) || defined (OUTPUT_RGB32)
#ifdef __cplusplus
extern "C" {
#endif
I32_WMV g_iVtoR_WMV [256];
I32_WMV g_iVtoG_WMV [256];
I32_WMV g_iUtoG_WMV [256];
I32_WMV g_iUtoB_WMV [256];
I32_WMV g_iYscale_WMV [256];
#ifdef __cplusplus
}
#endif
#endif // defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB8) || defined (OUTPUT_RGB16) || defined (OUTPUT_RGB24) || defined (OUTPUT_RGB32)

#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB8)
U8_WMV g_rgDitherMap_WMV [4] [4] [3] [256];

#define OFFSET 10          // First ten colours are used by Windows

const I32_WMV g_magic4x4 [4] [4] = {  
        0,  45,   9,  41,
        35,  16,  25,  19,
        38,   6,  48,   3,
        22,  29,  13,  32 
};

Void_WMV g_InitDstDitherMap_WMV ()
{
    I32_WMV x, y, z, t, ndiv51, nmod51;

    // Calculate the RED, GREEN and BLUE table entries

    for (x = 0; x < 4; x++) {
        for (y = 0; y < 4; y++) {
            for (z = 0; z < 256; z++) {
                t = g_magic4x4 [x] [y];
                ndiv51 = (z & 0xF8) / 51; nmod51 = (z & 0xF8) % 51;
                g_rgDitherMap_WMV [y] [x] [0] [z] = (ndiv51 + (nmod51 > t));  // r
                g_rgDitherMap_WMV [y] [x] [2] [z] = 36 * (ndiv51 + (nmod51 > t)) + OFFSET; // b
                ndiv51 = (z & 0xFC) / 51; nmod51 = (z & 0xFC) % 51;
                g_rgDitherMap_WMV [y] [x] [1] [z] = 6 * (ndiv51 + (nmod51 > t)); // g
            }
        }
    }
}
#endif // defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB8)
 
#if defined(OUTPUT_ALL_FORMATS) || defined(OUTPUT_RGB12) || defined(OUTPUT_GRAY4)
const U32_WMV g_uiDithering444 [24] = {3359615270, 2933630948, 21414038, 1043013166, 2298472485, 1461799693, 1991657213, 28333636,
                                       949904317, 1286920827, 3729350426, 598052109, 1617798366, 3149964184, 2962788697, 1000534078, 
                                       357460706, 2831545023, 2553801342, 866463537, 1486665357, 2042543698, 2379626617, 774808343};
const U8_WMV g_uiClapTab4BitDec [64] = {0, 0, 0, 0, 0, 0, 0, 0, 
                                        0, 0, 0, 0, 0, 0, 0, 0, 
                                        0, 0, 0, 0, 0, 0, 0, 0, 
                                        0, 0, 0, 0, 0, 0, 0, 0, 
                                        0, 2, 4, 6, 8, 10, 12, 14, 
                                        16, 18, 20, 22, 24, 26, 28, 30, 
                                        30, 30, 30, 30, 30, 30, 30, 30, 
                                        30, 30, 30, 30, 30, 30, 30, 30};
Void_WMV g_EndDstTables_WMV(tWMVDecInternalMember *pWMVDec)
{
#ifdef _6BIT_COLORCONV_OPT_
    wmvfree(pWMVDec->p_yuv2rgb_6bit_table);
    wmvfree(pWMVDec->m_rgiClapTab6BitDec - 256);
#endif
    VirtualFree(pWMVDec->m_rgiClapTab4BitDec - 32, 0, MEM_RELEASE);
    VirtualFree(pWMVDec->m_rgiDithering, 0, MEM_RELEASE);
}
#endif

tWMVDecodeStatus g_InitDstTables_WMV (tWMVDecInternalMember *pWMVDec)
{

    I32_WMV i;

#ifdef _6BIT_COLORCONV_OPT_
    pWMVDec->p_yuv2rgb_6bit_table = (YUV2RGB_6BIT_TABLE * ) wmvalloc (sizeof(YUV2RGB_6BIT_TABLE));
    if(pWMVDec->p_yuv2rgb_6bit_table == NULL)
        return WMV_BadMemory;
    I32_WMV iClapTabCenter = 256; // for clapping table
    pWMVDec->m_rgiClapTab6BitDec = (U8_WMV *) wmvalloc(512) ;
    if(pWMVDec->m_rgiClapTab6BitDec == NULL)
        return WMV_BadMemory;
    pWMVDec->m_rgiClapTab6BitDec += 256;
    for (i = -iClapTabCenter; i < iClapTabCenter; i++)
            pWMVDec->m_rgiClapTab6BitDec [i] = (U8_WMV) ((i < 0) ? 0 : (i > 63) ? 63 : i);
#endif

#if defined(OUTPUT_ALL_FORMATS) || defined(OUTPUT_RGB12) || defined(OUTPUT_GRAY4)
    pWMVDec->m_rgiClapTab4BitDec = (U8_WMV *) VirtualAlloc (0, 64, MEM_COMMIT, PAGE_READWRITE|PAGE_ARM_MINICACHE);
    if(pWMVDec->m_rgiClapTab4BitDec == NULL)
        return WMV_BadMemory;
    memcpy (pWMVDec->m_rgiClapTab4BitDec, g_uiClapTab4BitDec, 64);
    I32_WMV iClapTabCenter4 = 32;
    pWMVDec->m_rgiClapTab4BitDec += iClapTabCenter4;
    pWMVDec->m_rgiDithering = (U32_WMV *) VirtualAlloc (0, 96, MEM_COMMIT, PAGE_READWRITE|PAGE_ARM_MINICACHE);
    if(pWMVDec->m_rgiDithering == NULL)
        return WMV_BadMemory;
    memcpy (pWMVDec->m_rgiDithering, g_uiDithering444, 96);
    pWMVDec->m_iDitheringIndex = 3;
#endif

    for (i = 0; i < 256; i++) {
#if defined(OUTPUT_ALL_FORMATS) || defined(OUTPUT_RGB8) || defined(OUTPUT_RGB16) || defined(OUTPUT_RGB24) || defined(OUTPUT_RGB32)
        I32_WMV shift_value=16;
        g_iVtoR_WMV [i] = ((I32_WMV) 104597L * (I32_WMV) (i - 128)) >> shift_value;
        g_iVtoG_WMV [i] = ((I32_WMV) 53279L * (I32_WMV) (i - 128)) >> shift_value;
        g_iUtoG_WMV [i] = ((I32_WMV) 25675L * (I32_WMV) (i - 128)) >> shift_value;
        g_iUtoB_WMV [i] = ((I32_WMV) 132201L * (I32_WMV) (i - 128)) >> shift_value;
        g_iYscale_WMV [i] = ((I32_WMV) 76309L * (I32_WMV) (i - 16)) >> shift_value;
#endif

#ifdef _6BIT_COLORCONV_OPT_
        shift_value=18;
        pWMVDec->p_yuv2rgb_6bit_table->g_iVtoR [i] = ((I32_WMV) 104597L * (I32_WMV) (i - 128)) >> shift_value;
        pWMVDec->p_yuv2rgb_6bit_table->g_iVtoG [i] = ((I32_WMV) 53279L * (I32_WMV) (i - 128)) >> shift_value;
        pWMVDec->p_yuv2rgb_6bit_table->g_iUtoG [i] = ((I32_WMV) 25675L * (I32_WMV) (i - 128)) >> shift_value;
        pWMVDec->p_yuv2rgb_6bit_table->g_iUtoB [i] = ((I32_WMV) 132201L * (I32_WMV) (i - 128)) >> shift_value;
        pWMVDec->p_yuv2rgb_6bit_table->g_iYscale [i] = ((I32_WMV) 76309L * (I32_WMV) (i - 16)) >> shift_value;

#endif

#ifdef _MAC
		I32_WMV a, b;
		a = g_iYscale_WMV [i] - 23;
		YTable32 [i] = ((a&0x1FE) << 16) | ((a&0x1FE) << 8) | (a&0x1FF);
	 	
		a = (g_iUtoB_WMV [i] > 255)? 255 : ((g_iUtoB_WMV [i] < -213)? -213 : g_iUtoB_WMV [i]);
        b = (0-g_iUtoG_WMV[i]);
		UTable32 [i] = ((b&0x1FE) << 8) | (a&0x1FF);

		a = (0-g_iVtoG_WMV [i]);
        b = (g_iVtoR [i]);
		VTable32 [i] = ((b&0x1FE) << 16) | ((a&0x1FE) << 8);
#endif
    };

    return WMV_Succeeded;
}


tWMVDecodeStatus WMVideoDecInitBMPInfo (tWMVDecInternalMember *pWMVDec)
{
    // setting the funtion pointers, etc.
    if (pWMVDec->m_uiFOURCCOutput == FOURCC_BI_RGB_WMV) {
        pWMVDec->m_bYUVDstBMP = FALSE_WMV;
        // 16-bit FOURCC_BI_RGB_WMV is, by definition, RGB 5-5-5
#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB16)
        if (pWMVDec->m_uiBitsPerPixelOutput == 16) {
            // See WMVideoDecUpdateDstMB16 for an explanation of the following variables
            pWMVDec->m_uiRedscale = 10 - (8 - 5);
            pWMVDec->m_uiGreenscale = 5 - (8 - 5);
            pWMVDec->m_uiRedmask = 0x7c00;
            pWMVDec->m_uiGreenmask = 0x3e0;
            pWMVDec->m_pWMVideoDecUpdateDstMB = WMVideoDecUpdateDstMBRGB16;
            pWMVDec->m_pWMVideoDecUpdateDstPartialMB = WMVideoDecUpdateDstPartialMBRGB16;
            pWMVDec->m_pWMVideoDecUpdateDstBlk = WMVideoDecUpdateDstBlkRGB16;
        } else 
#endif // defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB16)

#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB24)
        if (pWMVDec->m_uiBitsPerPixelOutput == 24) {
            pWMVDec->m_pWMVideoDecUpdateDstMB = WMVideoDecUpdateDstMBRGB24;
            pWMVDec->m_pWMVideoDecUpdateDstPartialMB = WMVideoDecUpdateDstPartialMBRGB24;
            pWMVDec->m_pWMVideoDecUpdateDstBlk = WMVideoDecUpdateDstBlkRGB24;

        } else
#endif // defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB24)

#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB32)
        if (pWMVDec->m_uiBitsPerPixelOutput == 32) {
            pWMVDec->m_pWMVideoDecUpdateDstMB = WMVideoDecUpdateDstMBRGB32;
            pWMVDec->m_pWMVideoDecUpdateDstBlk = WMVideoDecUpdateDstBlkRGB32;
            pWMVDec->m_pWMVideoDecUpdateDstPartialMB = WMVideoDecUpdateDstPartialMBRGB32;

        } else
#endif // defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB32)

#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB8)
        // palettized
        if (pWMVDec->m_uiBitsPerPixelOutput == 8) {
            pWMVDec->m_pWMVideoDecUpdateDstMB = WMVideoDecUpdateDstMBRGB8;
            pWMVDec->m_pWMVideoDecUpdateDstPartialMB = WMVideoDecUpdateDstPartialMBRGB8;
            pWMVDec->m_pWMVideoDecUpdateDstBlk = WMVideoDecUpdateDstBlkRGB8;
        } else
#endif // defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB8)
       
            return WMV_UnSupportedOutputPixelFormat;
    }
    else if (pWMVDec->m_uiFOURCCOutput == FOURCC_BI_BITFIELDS_WMV) { // must be 16 or 32-bit
        pWMVDec->m_bYUVDstBMP = FALSE_WMV;
#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB16) || defined (OUTPUT_RGB12) || defined (OUTPUT_GRAY4) 
        if (pWMVDec->m_uiBitsPerPixelOutput == 15) { // 5-5-5
            // We only support the Windows 95 "standard" bitmap types which
            // are RGB 5-5-5 and RGB 5-6-5.  Windows NT allows for any
            // combination of bitmasks just so long as they don't overlap.
            // We don't play that game here (unless ordered to do so)

            pWMVDec->m_uiRedscale = 10-(8-5);
            pWMVDec->m_uiGreenscale = 5-(8-5);
            pWMVDec->m_uiRedmask = 0x7c00;
            pWMVDec->m_uiGreenmask = 0x3e0;
#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB16)
            pWMVDec->m_pWMVideoDecUpdateDstMB = WMVideoDecUpdateDstMBRGB16;
            pWMVDec->m_pWMVideoDecUpdateDstBlk = WMVideoDecUpdateDstBlkRGB16;
            pWMVDec->m_pWMVideoDecUpdateDstPartialMB = WMVideoDecUpdateDstPartialMBRGB16;
#endif
        }
        else if (pWMVDec->m_uiBitsPerPixelOutput == 16) { // 5-6-5
                // See WMVideoDecUpdateDstMB16 for an explanation of the following variables
            pWMVDec->m_uiRedscale = 11 - (8 - 5);
            pWMVDec->m_uiGreenscale = 5 - (8 - 6);
            pWMVDec->m_uiRedmask = 0xf800;
            pWMVDec->m_uiGreenmask = 0x7e0;
#if defined (OUTPUT_ALL_FORMATS)
            pWMVDec->m_pWMVideoDecUpdateDstMB = WMVideoDecUpdateDstMBRGB16;
            pWMVDec->m_pWMVideoDecUpdateDstBlk = WMVideoDecUpdateDstBlkRGB16;
            pWMVDec->m_pWMVideoDecUpdateDstPartialMB = WMVideoDecUpdateDstPartialMBRGB16;
#endif  //OUTPUT_RGB16
#if defined (OUTPUT_GRAY4)
            pWMVDec->m_pWMVideoDecUpdateDstMB = WMVideoDecUpdateDstMBGRAY4;
            pWMVDec->m_pWMVideoDecUpdateDstPartialMB = WMVideoDecUpdateDstPartialMBGRAY4;
            pWMVDec->m_pWMVideoDecUpdateDstBlk = WMVideoDecUpdateDstBlkGRAY4;
#endif  //OUTPUT_GRAY4
#if defined (OUTPUT_RGB16)
            pWMVDec->m_pWMVideoDecUpdateDstMB = WMVideoDecUpdateDstMBRGB16;
            pWMVDec->m_pWMVideoDecUpdateDstBlk = WMVideoDecUpdateDstBlkRGB16;
            pWMVDec->m_pWMVideoDecUpdateDstPartialMB = WMVideoDecUpdateDstPartialMBRGB16;
#endif  //OUTPUT_RGB16
#if defined (OUTPUT_RGB12)
            pWMVDec->m_pWMVideoDecUpdateDstMB = WMVideoDecUpdateDstMBRGB12;
            pWMVDec->m_pWMVideoDecUpdateDstBlk = WMVideoDecUpdateDstBlkRGB12;
            pWMVDec->m_pWMVideoDecUpdateDstPartialMB = WMVideoDecUpdateDstPartialMBRGB12;
#endif  //OUTPUT_RGB12

        } else
#endif // defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB16)

#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB32)
        if (pWMVDec->m_uiBitsPerPixelOutput == 32) {
            pWMVDec->m_pWMVideoDecUpdateDstMB = WMVideoDecUpdateDstMBRGB32;
            pWMVDec->m_pWMVideoDecUpdateDstBlk = WMVideoDecUpdateDstBlkRGB32;
            pWMVDec->m_pWMVideoDecUpdateDstPartialMB = WMVideoDecUpdateDstPartialMBRGB32;
        } else
#endif // defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB32)
            return WMV_UnSupportedOutputPixelFormat;
    } else
#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_UYVY)
    if (pWMVDec->m_uiFOURCCOutput == FOURCC_UYVY_WMV) {
        pWMVDec->m_bYUVDstBMP = TRUE_WMV;
        pWMVDec->m_pWMVideoDecUpdateDstMB = WMVideoDecUpdateDstMBUYVY;
        pWMVDec->m_pWMVideoDecUpdateDstPartialMB = WMVideoDecUpdateDstPartialMBUYVY;
        pWMVDec->m_pWMVideoDecUpdateDstBlk = WMVideoDecUpdateDstBlkUYVY;
    } else
#endif // defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_UYVY)

#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_YVYU)
    if (pWMVDec->m_uiFOURCCOutput == FOURCC_YVYU_WMV) {
        pWMVDec->m_bYUVDstBMP = TRUE_WMV;
        pWMVDec->m_pWMVideoDecUpdateDstMB = WMVideoDecUpdateDstMBYVYU;
        pWMVDec->m_pWMVideoDecUpdateDstPartialMB = WMVideoDecUpdateDstPartialMBYVYU;
        pWMVDec->m_pWMVideoDecUpdateDstBlk = WMVideoDecUpdateDstBlkYVYU;
    } else
#endif // defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_YVYU)

#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_YUY2)
    if (pWMVDec->m_uiFOURCCOutput == FOURCC_YUY2_WMV) {
        pWMVDec->m_bYUVDstBMP = TRUE_WMV;
        pWMVDec->m_pWMVideoDecUpdateDstMB = WMVideoDecUpdateDstMBYUY2;
        pWMVDec->m_pWMVideoDecUpdateDstPartialMB = WMVideoDecUpdateDstPartialMBYUY2;
        pWMVDec->m_pWMVideoDecUpdateDstBlk = WMVideoDecUpdateDstBlkYUY2;
    } else
#endif // defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_YUY2)
        return WMV_UnSupportedOutputPixelFormat;

    // set the BMP parameters
    pWMVDec->m_iWidthBMP = BITMAP_WIDTH_WMV (pWMVDec->m_iWidthSource, pWMVDec->m_uiBitsPerPixelOutput);
#ifdef _XBOX
        pWMVDec->m_iBMPPointerStart = 0;
#else
    if (pWMVDec->m_bYUVDstBMP == FALSE_WMV && pWMVDec->m_iHeightSource > 0) {
        pWMVDec->m_iWidthBMP = -pWMVDec->m_iWidthBMP;
        pWMVDec->m_iBMPPointerStart = (pWMVDec->m_iHeightSource - 1) * ((pWMVDec->m_iWidthSource * pWMVDec->m_uiBitsPerPixelOutput / 8 + 3) & ~3);
    }
    else 
        pWMVDec->m_iBMPPointerStart = 0;
#endif

    pWMVDec->m_iBMPMBIncrement = MB_SIZE * pWMVDec->m_uiBitsPerPixelOutput / 8;
    pWMVDec->m_iBMPBlkIncrement = BLOCK_SIZE * pWMVDec->m_uiBitsPerPixelOutput / 8;
    pWMVDec->m_iBMPMBHeightIncrement = pWMVDec->m_iWidthBMP * MB_SIZE;; 
    pWMVDec->m_iBMPBlkHeightIncrement = pWMVDec->m_iWidthBMP * BLOCK_SIZE;;


    return WMV_Succeeded;
}

tWMVDecodeStatus WMVideoDecColorConvert (tWMVDecInternalMember *pWMVDec, U8_WMV* pucDecodedOutput)
{
    tWMVDecodeStatus tWMVStatus = WMV_Succeeded;
    U32_WMV uiX, uiY;
    U32_WMV uiNumMBX = pWMVDec->m_uiNumMBX;
    U32_WMV uiNumMBY = pWMVDec->m_uiNumMBY;
    FUNCTION_PROFILE_DECL_START(fp,COLORCONVERTANDRENDER_PROFILE);

    U8_WMV* pucCurrY;
    U8_WMV* pucCurrU;
    U8_WMV* pucCurrV;
    if (pWMVDec->m_iPostProcessMode <= 0 || (pWMVDec->m_tFrmType == IVOP && pWMVDec->m_bXintra8)) {
        pucCurrY = pWMVDec->m_ppxliCurrQPlusExpY;
        pucCurrU = pWMVDec->m_ppxliCurrQPlusExpU;
        pucCurrV = pWMVDec->m_ppxliCurrQPlusExpV;
    }
    else {
        pucCurrY = pWMVDec->m_ppxliPostQPlusExpY;
        pucCurrU = pWMVDec->m_ppxliPostQPlusExpU;
        pucCurrV = pWMVDec->m_ppxliPostQPlusExpV;    
    }

    U8_WMV* pBmpPtr = pucDecodedOutput + pWMVDec->m_iBMPPointerStart;
//Bool_WMV* pbSkipMB = pWMVDec->m_pbSkipMB;
//Bool_WMV* pbSkipMB;
    for (uiY = 0; uiY < uiNumMBY; uiY++) {
        U8_WMV* pucCurrYMB = pucCurrY;
        U8_WMV* pucCurrUMB = pucCurrU;
        U8_WMV* pucCurrVMB = pucCurrV;
        U8_WMV* pBmpPtrMB = pBmpPtr;
        for (uiX = 0; uiX < uiNumMBX; uiX++) {
            if (1){//*pbSkipMB == FALSE_WMV)
                if (uiX != uiNumMBX - 1 && uiY != uiNumMBY - 1) {
                    pWMVDec->m_pWMVideoDecUpdateDstMB (
                        pWMVDec,
                        pBmpPtrMB, 
                        pucCurrYMB, pucCurrUMB, pucCurrVMB,
                        pWMVDec->m_iWidthInternal, pWMVDec->m_iWidthInternalUV, 
                        pWMVDec->m_iWidthBMP);
                }
                else {
                    I32_WMV iValidWidth = 
                        (uiX != (uiNumMBX - 1)) ? MB_SIZE :
                        (MB_SIZE - (pWMVDec -> m_iWidthY - pWMVDec -> m_iFrmWidthSrc));

                    I32_WMV iValidHeight = 
                        (uiY != (uiNumMBY - 1)) ? MB_SIZE :
                        (MB_SIZE - (abs(pWMVDec -> m_iHeightY) - abs(pWMVDec -> m_iFrmHeightSrc)));

                    pWMVDec->m_pWMVideoDecUpdateDstPartialMB (
                        pWMVDec,
                        pBmpPtrMB, 
                        pucCurrYMB, pucCurrUMB, pucCurrVMB,
                        pWMVDec->m_iWidthInternal, pWMVDec->m_iWidthInternalUV, 
                        iValidWidth, iValidHeight);
                }
            }
            // pbSkipMB++;
            pucCurrYMB += MB_SIZE;
            pucCurrUMB += BLOCK_SIZE;
            pucCurrVMB += BLOCK_SIZE;
            pBmpPtrMB += pWMVDec->m_iBMPMBIncrement;
        }
        pucCurrY += pWMVDec->m_iWidthInternalTimesMB;
        pucCurrU += pWMVDec->m_iWidthInternalUVTimesBlk;
        pucCurrV += pWMVDec->m_iWidthInternalUVTimesBlk;
        pBmpPtr += pWMVDec->m_iBMPMBHeightIncrement;
    }

    FUNCTION_PROFILE_STOP(&fp);
    return WMV_Succeeded;
}

#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB8)

#define wDITH24(xy,r,g,b) \
    (rgDitherMap [xy       + r] + \
     rgDitherMap [xy + 256 + g] + \
     rgDitherMap [xy + 512 + b]  )

Void_WMV WMVideoDecUpdateDstPartialMBRGB8 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iRgbWidth, I32_WMV iRgbHeight
) {
//
// Temporary macroblock-sized buffer
//
    U8_WMV  mb[MB_SIZE * MB_SIZE];
    U8_WMV *pBitsMb;
    I32_WMV i;
//
// Now color-space convert the macroblock into the buffer.
//
    WMVideoDecUpdateDstMBRGB8 (
        pWMVDec,
        (U8_WMV *)mb,
        pucCurrY,
        pucCurrU,
        pucCurrV,
        iWidthY,
        iWidthUV,
        MB_SIZE);
//
// And, copy the valid pixels from the buffer into the bitmap.
//
    pBitsMb = mb;
    for (i = 0; i < iRgbHeight; ++i) {
        memcpy (pBits, pBitsMb, iRgbWidth);

        pBitsMb += MB_SIZE;
        pBits += pWMVDec->m_iWidthBMP;
    }
}

Void_WMV WMVideoDecUpdateDstMBRGB8 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
) {
    U8_WMV rVal, gVal, bVal;
    U32_WMV iy;
    I32_WMV iYScale;

    const U8_WMV* rgiClapTab = pWMVDec->m_rgiClapTabDec; 

    U8_WMV * rgDitherMap = (U8_WMV *)(&(pWMVDec->m_rgDitherMap[0][0][0][0]));

    for (iy = 0; iy < BLOCK_SIZE; iy++) {
        I32_WMV iyAnd3 = (iy * 2) & 3;
        I32_WMV     xy = 3072*iyAnd3;
        
        I32_WMV iVtoR0 = g_iVtoR_WMV [pucCurrV [0]];
        I32_WMV iUtoG0PlusVtoG0 = g_iUtoG_WMV [pucCurrU [0]] + g_iVtoG_WMV [pucCurrV [0]];
        I32_WMV iUtoB0 = g_iUtoB_WMV [pucCurrU [0]];

        I32_WMV iVtoR1 = g_iVtoR_WMV [pucCurrV [1]];
        I32_WMV iUtoG1PlusVtoG1 = g_iUtoG_WMV[pucCurrU [1]] + g_iVtoG_WMV[pucCurrV [1]];
        I32_WMV iUtoB1 = g_iUtoB_WMV [pucCurrU [1]];

        I32_WMV iVtoR2 = g_iVtoR_WMV [pucCurrV [2]];
        I32_WMV iUtoG2PlusVtoG2 = g_iUtoG_WMV [pucCurrU [2]] + g_iVtoG_WMV [pucCurrV [2]];
        I32_WMV iUtoB2 = g_iUtoB_WMV [pucCurrU [2]];

        I32_WMV iVtoR3 = g_iVtoR_WMV [pucCurrV [3]];
        I32_WMV iUtoG3PlusVtoG3 = g_iUtoG_WMV [pucCurrU [3]] + g_iVtoG_WMV [pucCurrV [3]];
        I32_WMV iUtoB3 = g_iUtoB_WMV [pucCurrU [3]];

        I32_WMV iVtoR4 = g_iVtoR_WMV [pucCurrV[4]];
        I32_WMV iUtoG4PlusVtoG4 = g_iUtoG_WMV [pucCurrU [4]] + g_iVtoG_WMV[pucCurrV [4]];
        I32_WMV iUtoB4 = g_iUtoB_WMV[pucCurrU [4]];

        I32_WMV iVtoR5 = g_iVtoR_WMV [pucCurrV [5]];
        I32_WMV iUtoG5PlusVtoG5 = g_iUtoG_WMV [pucCurrU [5]] + g_iVtoG_WMV [pucCurrV [5]];
        I32_WMV iUtoB5 = g_iUtoB_WMV[pucCurrU [5]];

        I32_WMV iVtoR6 = g_iVtoR_WMV [pucCurrV [6]];
        I32_WMV iUtoG6PlusVtoG6 = g_iUtoG_WMV [pucCurrU [6]] + g_iVtoG_WMV [pucCurrV [6]];
        I32_WMV iUtoB6 = g_iUtoB_WMV [pucCurrU [6]];

        I32_WMV iVtoR7 = g_iVtoR_WMV [pucCurrV [7]];
        I32_WMV iUtoG7PlusVtoG7 = g_iUtoG_WMV [pucCurrU [7]] + g_iVtoG_WMV [pucCurrV [7]];
        I32_WMV iUtoB7 = g_iUtoB_WMV [pucCurrU [7]];

        iYScale = g_iYscale_WMV [pucCurrY [0]];
        rVal = rgiClapTab [(iYScale + iVtoR0)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG0PlusVtoG0)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB0)]; // b
        pBits [0] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [4]];
        rVal = rgiClapTab [(iYScale + iVtoR2)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG2PlusVtoG2)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB2)]; // b
        pBits [4] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [8]];
        rVal = rgiClapTab [(iYScale + iVtoR4)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG4PlusVtoG4)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB4)]; // b
        pBits [8] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [12]];
        rVal = rgiClapTab [(iYScale + iVtoR6)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG6PlusVtoG6)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB6)]; // b
        pBits [12] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [1]];
        rVal = rgiClapTab [(iYScale + iVtoR0)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG0PlusVtoG0)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB0)]; // b
        xy += 768;
        pBits [1] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [5]];
        rVal = rgiClapTab [(iYScale + iVtoR2)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG2PlusVtoG2)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB2)]; // b
        pBits [5] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [9]];
        rVal = rgiClapTab [(iYScale + iVtoR4)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG4PlusVtoG4)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB4)]; // b
        pBits [9] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [13]];
        rVal = rgiClapTab [(iYScale + iVtoR6)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG6PlusVtoG6)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB6)]; // b
        pBits [13] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [2]];
        rVal = rgiClapTab [(iYScale + iVtoR1)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG1PlusVtoG1)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB1)]; // b
        xy += 768;
        pBits [2] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [6]];
        rVal = rgiClapTab [(iYScale + iVtoR3)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG3PlusVtoG3)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB3)]; // b
        pBits [6] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [10]];
        rVal = rgiClapTab [(iYScale + iVtoR5)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG5PlusVtoG5)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB5)]; // b
        pBits [10] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [14]];
        rVal = rgiClapTab [(iYScale + iVtoR7)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG7PlusVtoG7)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB7)]; // b
        pBits [14] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [3]];
        rVal = rgiClapTab [(iYScale + iVtoR1)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG1PlusVtoG1)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB1)]; // b
        xy += 768;
        pBits [3] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [7]];
        rVal = rgiClapTab [(iYScale + iVtoR3)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG3PlusVtoG3)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB3)]; // b
        pBits [7] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [11]];
        rVal = rgiClapTab [(iYScale + iVtoR5)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG5PlusVtoG5)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB5)]; // b
        pBits [11] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [15]];
        rVal = rgiClapTab [(iYScale + iVtoR7)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG7PlusVtoG7)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB7)]; // b
        pBits [15] = wDITH24 (xy, rVal, gVal, bVal);
		pucCurrY += iWidthY;
		pucCurrU += iWidthUV;
		pucCurrV += iWidthUV;

        pBits += iBitmapWidth;

        iyAnd3 = (iy * 2 + 1) & 3;
        xy = 3072*iyAnd3;
        
        iYScale = g_iYscale_WMV [pucCurrY [0]];
        rVal = rgiClapTab [(iYScale + iVtoR0)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG0PlusVtoG0)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB0)]; // b
        pBits [0] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [4]];
        rVal = rgiClapTab [(iYScale + iVtoR2)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG2PlusVtoG2)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB2)]; // b
        pBits [4] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [8]];
        rVal = rgiClapTab [(iYScale + iVtoR4)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG4PlusVtoG4)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB4)]; // b
        pBits [8] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [12]];
        rVal = rgiClapTab [(iYScale + iVtoR6)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG6PlusVtoG6)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB6)]; // b
        pBits [12] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [1]];
        rVal = rgiClapTab [(iYScale + iVtoR0)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG0PlusVtoG0)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB0)]; // b
        xy += 768;
        pBits [1] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [5]];
        rVal = rgiClapTab [(iYScale + iVtoR2)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG2PlusVtoG2)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB2)]; // b
        pBits [5] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [9]];
        rVal = rgiClapTab [(iYScale + iVtoR4)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG4PlusVtoG4)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB4)]; // b
        pBits [9] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [13]];
        rVal = rgiClapTab [(iYScale + iVtoR6)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG6PlusVtoG6)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB6)]; // b
        pBits [13] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [2]];
        rVal = rgiClapTab [(iYScale + iVtoR1)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG1PlusVtoG1)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB1)]; // b
        xy += 768;
        pBits [2] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [6]];
        rVal = rgiClapTab [(iYScale + iVtoR3)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG3PlusVtoG3)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB3)]; // b
        pBits [6] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [10]];
        rVal = rgiClapTab [(iYScale + iVtoR5)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG5PlusVtoG5)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB5)]; // b
        pBits [10] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [14]];
        rVal = rgiClapTab [(iYScale + iVtoR7)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG7PlusVtoG7)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB7)]; // b
        pBits [14] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [3]];
        rVal = rgiClapTab [(iYScale + iVtoR1)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG1PlusVtoG1)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB1)]; // b
        xy += 768;
        pBits [3] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [7]];
        rVal = rgiClapTab [(iYScale + iVtoR3)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG3PlusVtoG3)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB3)]; // b
        pBits [7] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [11]];
        rVal = rgiClapTab [(iYScale + iVtoR5)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG5PlusVtoG5)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB5)]; // b
        pBits [11] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [15]];
        rVal = rgiClapTab [(iYScale + iVtoR7)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG7PlusVtoG7)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB7)]; // b
        pBits [15] = wDITH24 (xy, rVal, gVal, bVal);

        pucCurrY += iWidthY;

        pBits += iBitmapWidth;
    }
}

Void_WMV WMVideoDecUpdateDstBlkRGB8 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
) {
    U8_WMV rVal, gVal, bVal;
    U32_WMV iy;
    I32_WMV iYScale;

    const U8_WMV* rgiClapTab = pWMVDec->m_rgiClapTabDec; 

    U8_WMV * rgDitherMap = (U8_WMV *)(&(pWMVDec->m_rgDitherMap[0][0][0][0]));

    for (iy = 0; iy < SUB_BLOCK_SIZE; iy++) {
        I32_WMV iyAnd3 = (iy * 2) & 3;
        I32_WMV xy = 3072 * iyAnd3;
        
        I32_WMV iVtoR0 = g_iVtoR_WMV [pucCurrV [0]];
        I32_WMV iUtoG0PlusVtoG0 = g_iUtoG_WMV [pucCurrU [0]] + g_iVtoG_WMV [pucCurrV [0]];
        I32_WMV iUtoB0 = g_iUtoB_WMV [pucCurrU [0]];

        I32_WMV iVtoR1 = g_iVtoR_WMV [pucCurrV [1]];
        I32_WMV iUtoG1PlusVtoG1 = g_iUtoG_WMV[pucCurrU [1]] + g_iVtoG_WMV[pucCurrV [1]];
        I32_WMV iUtoB1 = g_iUtoB_WMV [pucCurrU [1]];

        I32_WMV iVtoR2 = g_iVtoR_WMV [pucCurrV [2]];
        I32_WMV iUtoG2PlusVtoG2 = g_iUtoG_WMV [pucCurrU [2]] + g_iVtoG_WMV [pucCurrV [2]];
        I32_WMV iUtoB2 = g_iUtoB_WMV [pucCurrU [2]];

        I32_WMV iVtoR3 = g_iVtoR_WMV [pucCurrV [3]];
        I32_WMV iUtoG3PlusVtoG3 = g_iUtoG_WMV [pucCurrU [3]] + g_iVtoG_WMV [pucCurrV [3]];
        I32_WMV iUtoB3 = g_iUtoB_WMV [pucCurrU [3]];

        iYScale = g_iYscale_WMV [pucCurrY [0]];
        rVal = rgiClapTab [(iYScale + iVtoR0)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG0PlusVtoG0)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB0)]; // b
        pBits [0] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [4]];
        rVal = rgiClapTab [(iYScale + iVtoR2)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG2PlusVtoG2)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB2)]; // b
        pBits [4] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [1]];
        rVal = rgiClapTab [(iYScale + iVtoR0)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG0PlusVtoG0)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB0)]; // b
        xy += 768;
        pBits [1] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [5]];
        rVal = rgiClapTab [(iYScale + iVtoR2)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG2PlusVtoG2)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB2)]; // b
        pBits [5] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [2]];
        rVal = rgiClapTab [(iYScale + iVtoR1)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG1PlusVtoG1)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB1)]; // b
        xy += 768;
        pBits [2] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [6]];
        rVal = rgiClapTab [(iYScale + iVtoR3)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG3PlusVtoG3)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB3)]; // b
        pBits [6] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [3]];
        rVal = rgiClapTab [(iYScale + iVtoR1)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG1PlusVtoG1)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB1)]; // b
        xy += 768;
        pBits [3] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [7]];
        rVal = rgiClapTab [(iYScale + iVtoR3)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG3PlusVtoG3)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB3)]; // b
        pBits [7] = wDITH24 (xy, rVal, gVal, bVal);

		pucCurrY += iWidthY;
		pucCurrU += iWidthUV;
		pucCurrV += iWidthUV;

        pBits += iBitmapWidth;

        iyAnd3 = (iy * 2 + 1) & 3;
        xy = 3072*iyAnd3;
        
        iYScale = g_iYscale_WMV [pucCurrY [0]];
        rVal = rgiClapTab [(iYScale + iVtoR0)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG0PlusVtoG0)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB0)]; // b
        pBits [0] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [4]];
        rVal = rgiClapTab [(iYScale + iVtoR2)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG2PlusVtoG2)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB2)]; // b
        pBits [4] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [1]];
        rVal = rgiClapTab [(iYScale + iVtoR0)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG0PlusVtoG0)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB0)]; // b
        xy += 768;
        pBits [1] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [5]];
        rVal = rgiClapTab [(iYScale + iVtoR2)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG2PlusVtoG2)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB2)]; // b
        pBits [5] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [2]];
        rVal = rgiClapTab [(iYScale + iVtoR1)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG1PlusVtoG1)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB1)]; // b
        xy += 768;
        pBits [2] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [6]];
        rVal = rgiClapTab [(iYScale + iVtoR3)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG3PlusVtoG3)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB3)]; // b
        pBits [6] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [3]];
        rVal = rgiClapTab [(iYScale + iVtoR1)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG1PlusVtoG1)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB1)]; // b
        xy += 768;
        pBits [3] = wDITH24 (xy, rVal, gVal, bVal);

        iYScale = g_iYscale_WMV [pucCurrY [7]];
        rVal = rgiClapTab [(iYScale + iVtoR3)]; // r
        gVal = rgiClapTab [(iYScale - iUtoG3PlusVtoG3)]; // g
        bVal = rgiClapTab [(iYScale + iUtoB3)]; // b
        pBits [7] = wDITH24 (xy, rVal, gVal, bVal);

        pucCurrY += iWidthY;

        pBits += iBitmapWidth;
    }
}
#endif // defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB8)

#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB16)

#define UpdateDstRGB15(i, iVtoR0, iUtoG0PlusVtoG0, iUtoB0) \
    iYScale = g_iYscale_WMV[pucCurrY[2*i+1]];             \
    rVal = rgiClapTab [(iYScale + iVtoR0)];             \
    gVal = rgiClapTab [(iYScale - iUtoG0PlusVtoG0)];    \
    bVal = rgiClapTab [(iYScale + iUtoB0)];             \
    rVal <<= 16; gVal <<= 16; bVal <<= 16;              \
    iYScale = g_iYscale_WMV[pucCurrY[2*i]];               \
    rVal += rgiClapTab [(iYScale + iVtoR0)];            \
    gVal += rgiClapTab [(iYScale - iUtoG0PlusVtoG0)];   \
    bVal += rgiClapTab [(iYScale + iUtoB0)];            \
    pdwBits[i] = ((rVal << 7) & 0x7c007c00) |           \
        ((gVal << 2) &  0x3e003e0) |                    \
        ((bVal >> 3) &   0x1f001f) ;

#define UpdateDstRGB16(i, iVtoR0, iUtoG0PlusVtoG0, iUtoB0) \
    iYScale = g_iYscale_WMV[pucCurrY[2*i+1]];             \
    rVal = rgiClapTab [(iYScale + iVtoR0)];             \
    gVal = rgiClapTab [(iYScale - iUtoG0PlusVtoG0)];    \
    bVal = rgiClapTab [(iYScale + iUtoB0)];             \
    rVal <<= 16; gVal <<= 16; bVal <<= 16;              \
    iYScale = g_iYscale_WMV[pucCurrY[2*i]];               \
    rVal += rgiClapTab [(iYScale + iVtoR0)];            \
    gVal += rgiClapTab [(iYScale - iUtoG0PlusVtoG0)];   \
    bVal += rgiClapTab [(iYScale + iUtoB0)];            \
    pdwBits[i] = ((rVal << 8) & 0xf800f800) |           \
        ((gVal << 3) &  0x7e007e0) |                    \
        ((bVal >> 3) &   0x1f001f) ;

Void_WMV WMVideoDecUpdateDstPartialMBRGB16 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iRgbWidth, I32_WMV iRgbHeight
) {
//
// Temporary macroblock-sized buffer
//
    U8_WMV  mb[MB_SIZE * 2 * MB_SIZE];
    U8_WMV *pBitsMb;
    I32_WMV i;
//
// Now color-space convert the macroblock into the buffer.
//
    WMVideoDecUpdateDstMBRGB16 (
        pWMVDec,
        (U8_WMV *)mb,
        pucCurrY,
        pucCurrU,
        pucCurrV,
        iWidthY,
        iWidthUV,
        MB_SIZE * 2);
//
// And, copy the valid pixels from the buffer into the bitmap.
//
    pBitsMb = mb;
    for (i = 0; i < iRgbHeight; ++i) {
        memcpy(pBits, pBitsMb, iRgbWidth * 2);

        pBitsMb += MB_SIZE * 2;
        pBits += pWMVDec->m_iWidthBMP;
    }
}

#if !defined( OPT_DECOLORCONV_ARM) 
#ifndef IPP_COLORCONV
#ifndef _6BIT_COLORCONV_OPT_
Void_WMV WMVideoDecUpdateDstMBRGB16 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
) {
    I32_WMV                   rVal, gVal, bVal;
    U32_WMV           *pdwBits = (U32_WMV*) pBits;
    U32_WMV                  iy;
    I32_WMV                   iYScale;

    const U8_WMV* rgiClapTab = pWMVDec->m_rgiClapTabDec; 
//
// We need to do the following (not including the basic YUV to
// RGB 8-8-8 conversion):
//
// First, scale from RGB 8-8-8 to RGB 5-5-5 or RGB 5-6-5.  The 8-5
// below is the difference in the number of bits between the
// formats.
//
// pWMVDec->m_uiGreenscale is either 8-6 or 8-5 depending on 5-6-5 or 5-5-5
// respectively. pWMVDec->m_uiGreenmask is either 0x7e0 or 0x3e0.
//
// rVal = (rVal >> 8-5) & 0x1f;
// gVal = (gVal >> pWMVDec->m_uiGreenscale) & pWMVDec->m_uiGreenmask;
// bVal = (bVal >> 8-5) & 0x1f;
//
// Then we need to shift the r and g into their proper positions
// (b is shifted zero)
//
// m_redshift is either 10 or 11 depending on 5-5-5 or 5-6-5,
// respectively.
//
// rval <<= m_redshift;
// gval <<= 5;
//
// And finally, write the pixel
//
// *(WORD *)pBits = rVal | gVal | bVal;
//
// We can reduce this by combining the shifts and scales into a
// single shift.
//
// pWMVDec->m_uiRedscale = RGBT_555 ? 10-(8-5) : 11-(8-5)
// pWMVDec->m_uiGreenscale = RGBT_555 ? 5-(8-5) : 5-(8-6);
// bluescale = 0-(8-5); // actually must be right shifted.by 3
//
// Since after the shifts, we have non-significant bits overlapping
// the fields, we have to mask them off.
//
// pWMVDec->m_uiRedmask = RGBT_555 ? 0x7c00 : 0xf800;
// pWMVDec->m_uiGreenmask = RGBT_555 ? 0x3e0 : 0x7e0;
// bluemask = 0x1f;
//
// So we end up with
//
// *(WORD *)pBits = ((rVal << pWMVDec->m_uiRedscale) & pWMVDec->m_uiRedmask) |
//     ((gVal << pWMVDec->m_uiGreenscale) & pWMVDec->m_uiGreenmask) |
//     ((bVal >> bluescale) & bluemask);
//
// Calculation of all of the scale and mask values is moved to the
// init function.  bluescale and bluemask are constant 3 and 0x1f.
//
    if (pWMVDec->m_uiRedscale == 7) {
        for (iy = 0; iy < BLOCK_SIZE; iy++) {
            I32_WMV iVtoR0, iUtoG0PlusVtoG0, iUtoB0;
            I32_WMV iVtoR1, iUtoG1PlusVtoG1, iUtoB1;
            I32_WMV iVtoR2, iUtoG2PlusVtoG2, iUtoB2;
            I32_WMV iVtoR3, iUtoG3PlusVtoG3, iUtoB3;
            I32_WMV iVtoR4, iUtoG4PlusVtoG4, iUtoB4;
            I32_WMV iVtoR5, iUtoG5PlusVtoG5, iUtoB5;
            I32_WMV iVtoR6, iUtoG6PlusVtoG6, iUtoB6;
            I32_WMV iVtoR7, iUtoG7PlusVtoG7, iUtoB7;

            iVtoR0 = g_iVtoR_WMV[pucCurrV[0]];
            iUtoG0PlusVtoG0 = g_iUtoG_WMV [pucCurrU[0]] + g_iVtoG_WMV [pucCurrV[0]];
            iUtoB0 = g_iUtoB_WMV[pucCurrU[0]];            
            UpdateDstRGB15 (0, iVtoR0, iUtoG0PlusVtoG0, iUtoB0)           

            iVtoR1 = g_iVtoR_WMV[pucCurrV[1]];
            iUtoG1PlusVtoG1 = g_iUtoG_WMV [pucCurrU[1]] + g_iVtoG_WMV [pucCurrV[1]];
            iUtoB1 = g_iUtoB_WMV[pucCurrU[1]];
            UpdateDstRGB15 (1,iVtoR1,iUtoG1PlusVtoG1,iUtoB1)           

            iVtoR2 = g_iVtoR_WMV[pucCurrV[2]];
            iUtoG2PlusVtoG2 = g_iUtoG_WMV[pucCurrU[2]] + g_iVtoG_WMV[pucCurrV[2]];
            iUtoB2 = g_iUtoB_WMV[pucCurrU[2]];
            UpdateDstRGB15 (2,iVtoR2,iUtoG2PlusVtoG2,iUtoB2)           

            iVtoR3 = g_iVtoR_WMV[pucCurrV[3]];
            iUtoG3PlusVtoG3 = g_iUtoG_WMV[pucCurrU[3]] + g_iVtoG_WMV[pucCurrV[3]];
            iUtoB3 = g_iUtoB_WMV[pucCurrU[3]];
            UpdateDstRGB15 (3,iVtoR3,iUtoG3PlusVtoG3,iUtoB3)           

            iVtoR4 = g_iVtoR_WMV[pucCurrV[4]];
            iUtoG4PlusVtoG4 = g_iUtoG_WMV[pucCurrU[4]] + g_iVtoG_WMV[pucCurrV[4]];
            iUtoB4 = g_iUtoB_WMV[pucCurrU[4]];
            UpdateDstRGB15 (4,iVtoR4,iUtoG4PlusVtoG4,iUtoB4)           

            iVtoR5 = g_iVtoR_WMV[pucCurrV[5]];
            iUtoG5PlusVtoG5 = g_iUtoG_WMV[pucCurrU[5]] + g_iVtoG_WMV[pucCurrV[5]];
            iUtoB5 = g_iUtoB_WMV[pucCurrU[5]];
            UpdateDstRGB15 (5,iVtoR5,iUtoG5PlusVtoG5,iUtoB5)           

            iVtoR6 = g_iVtoR_WMV[pucCurrV[6]];
            iUtoG6PlusVtoG6 = g_iUtoG_WMV[pucCurrU[6]] + g_iVtoG_WMV[pucCurrV[6]];
            iUtoB6 = g_iUtoB_WMV[pucCurrU[6]];
            UpdateDstRGB15 (6,iVtoR6,iUtoG6PlusVtoG6,iUtoB6)           

            iVtoR7 = g_iVtoR_WMV[pucCurrV[7]];
            iUtoG7PlusVtoG7 = g_iUtoG_WMV[pucCurrU[7]] + g_iVtoG_WMV[pucCurrV[7]];
            iUtoB7 = g_iUtoB_WMV[pucCurrU[7]];
            UpdateDstRGB15 (7,iVtoR7,iUtoG7PlusVtoG7,iUtoB7)           

            pucCurrY += iWidthY;
            pucCurrU += iWidthUV;
            pucCurrV += iWidthUV;

            pBits += iBitmapWidth;

            pdwBits = (U32_WMV *)pBits;

            UpdateDstRGB15 (0,iVtoR0,iUtoG0PlusVtoG0,iUtoB0)           
            UpdateDstRGB15 (1,iVtoR1,iUtoG1PlusVtoG1,iUtoB1)           
            UpdateDstRGB15 (2,iVtoR2,iUtoG2PlusVtoG2,iUtoB2)           
            UpdateDstRGB15 (3,iVtoR3,iUtoG3PlusVtoG3,iUtoB3)           
            UpdateDstRGB15 (4,iVtoR4,iUtoG4PlusVtoG4,iUtoB4)           
            UpdateDstRGB15 (5,iVtoR5,iUtoG5PlusVtoG5,iUtoB5)           
            UpdateDstRGB15 (6,iVtoR6,iUtoG6PlusVtoG6,iUtoB6)           
            UpdateDstRGB15 (7,iVtoR7,iUtoG7PlusVtoG7,iUtoB7)           

            pucCurrY += iWidthY;

            pBits += iBitmapWidth;
            pdwBits = (U32_WMV *)pBits;
        }

    }
    else {
        for (iy = 0; iy < BLOCK_SIZE; iy++) {
            I32_WMV iVtoR0, iUtoG0PlusVtoG0, iUtoB0;
            I32_WMV iVtoR1, iUtoG1PlusVtoG1, iUtoB1;
            I32_WMV iVtoR2, iUtoG2PlusVtoG2, iUtoB2;
            I32_WMV iVtoR3, iUtoG3PlusVtoG3, iUtoB3;
            I32_WMV iVtoR4, iUtoG4PlusVtoG4, iUtoB4;
            I32_WMV iVtoR5, iUtoG5PlusVtoG5, iUtoB5;
            I32_WMV iVtoR6, iUtoG6PlusVtoG6, iUtoB6;
            I32_WMV iVtoR7, iUtoG7PlusVtoG7, iUtoB7;

            iVtoR0 = g_iVtoR_WMV[pucCurrV[0]];
            iUtoG0PlusVtoG0 = g_iUtoG_WMV [pucCurrU[0]] + g_iVtoG_WMV [pucCurrV[0]];
            iUtoB0 = g_iUtoB_WMV[pucCurrU[0]];
            UpdateDstRGB16 (0,iVtoR0,iUtoG0PlusVtoG0,iUtoB0)           

            iVtoR1 = g_iVtoR_WMV[pucCurrV[1]];
            iUtoG1PlusVtoG1 = g_iUtoG_WMV [pucCurrU[1]] + g_iVtoG_WMV [pucCurrV[1]];
            iUtoB1 = g_iUtoB_WMV[pucCurrU[1]];            
            UpdateDstRGB16 (1,iVtoR1,iUtoG1PlusVtoG1,iUtoB1)           
                
            iVtoR2 = g_iVtoR_WMV[pucCurrV[2]];
            iUtoG2PlusVtoG2 = g_iUtoG_WMV[pucCurrU[2]] + g_iVtoG_WMV[pucCurrV[2]];
            iUtoB2 = g_iUtoB_WMV[pucCurrU[2]];
            UpdateDstRGB16 (2,iVtoR2,iUtoG2PlusVtoG2,iUtoB2)           

            iVtoR3 = g_iVtoR_WMV[pucCurrV[3]];
            iUtoG3PlusVtoG3 = g_iUtoG_WMV[pucCurrU[3]] + g_iVtoG_WMV[pucCurrV[3]];
            iUtoB3 = g_iUtoB_WMV[pucCurrU[3]];
            UpdateDstRGB16 (3,iVtoR3,iUtoG3PlusVtoG3,iUtoB3)           

            iVtoR4 = g_iVtoR_WMV[pucCurrV[4]];
            iUtoG4PlusVtoG4 = g_iUtoG_WMV[pucCurrU[4]] + g_iVtoG_WMV[pucCurrV[4]];
            iUtoB4 = g_iUtoB_WMV[pucCurrU[4]];
            UpdateDstRGB16 (4,iVtoR4,iUtoG4PlusVtoG4,iUtoB4)           

            iVtoR5 = g_iVtoR_WMV[pucCurrV[5]];
            iUtoG5PlusVtoG5 = g_iUtoG_WMV[pucCurrU[5]] + g_iVtoG_WMV[pucCurrV[5]];
            iUtoB5 = g_iUtoB_WMV[pucCurrU[5]];
            UpdateDstRGB16 (5,iVtoR5,iUtoG5PlusVtoG5,iUtoB5)           

            iVtoR6 = g_iVtoR_WMV[pucCurrV[6]];
            iUtoG6PlusVtoG6 = g_iUtoG_WMV[pucCurrU[6]] + g_iVtoG_WMV[pucCurrV[6]];
            iUtoB6 = g_iUtoB_WMV[pucCurrU[6]];
            UpdateDstRGB16 (6,iVtoR6,iUtoG6PlusVtoG6,iUtoB6)           
                    
            iVtoR7 = g_iVtoR_WMV[pucCurrV[7]];
            iUtoG7PlusVtoG7 = g_iUtoG_WMV[pucCurrU[7]] + g_iVtoG_WMV[pucCurrV[7]];
            iUtoB7 = g_iUtoB_WMV[pucCurrU[7]];
            UpdateDstRGB16 (7,iVtoR7,iUtoG7PlusVtoG7,iUtoB7)           

            pucCurrY += iWidthY;
            pucCurrU += iWidthUV;
            pucCurrV += iWidthUV;

            pBits += iBitmapWidth;
            pdwBits = (U32_WMV *)pBits;

            UpdateDstRGB16 (0,iVtoR0,iUtoG0PlusVtoG0,iUtoB0)           
            UpdateDstRGB16 (1,iVtoR1,iUtoG1PlusVtoG1,iUtoB1)           
            UpdateDstRGB16 (2,iVtoR2,iUtoG2PlusVtoG2,iUtoB2)           
            UpdateDstRGB16 (3,iVtoR3,iUtoG3PlusVtoG3,iUtoB3)           
            UpdateDstRGB16 (4,iVtoR4,iUtoG4PlusVtoG4,iUtoB4)           
            UpdateDstRGB16 (5,iVtoR5,iUtoG5PlusVtoG5,iUtoB5)           
            UpdateDstRGB16 (6,iVtoR6,iUtoG6PlusVtoG6,iUtoB6)           
            UpdateDstRGB16 (7,iVtoR7,iUtoG7PlusVtoG7,iUtoB7)           
                
            pucCurrY += iWidthY;

            pBits += iBitmapWidth;
            pdwBits = (U32_WMV*) pBits;
        }
    }
}
#endif

Void_WMV WMVideoDecUpdateDstBlkRGB16 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
) {
    I32_WMV                   rVal, gVal, bVal;
    U32_WMV          *pdwBits = (U32_WMV*) pBits;
    U32_WMV                  iy;
    I32_WMV                   iYScale;

    const U8_WMV* rgiClapTab = pWMVDec->m_rgiClapTabDec; 
    if (pWMVDec->m_uiRedscale == 7) {
        for (iy = 0; iy < SUB_BLOCK_SIZE; iy++) {
            I32_WMV iVtoR0, iUtoG0PlusVtoG0, iUtoB0;
            I32_WMV iVtoR1, iUtoG1PlusVtoG1, iUtoB1;
            I32_WMV iVtoR2, iUtoG2PlusVtoG2, iUtoB2;
            I32_WMV iVtoR3, iUtoG3PlusVtoG3, iUtoB3;

            iVtoR0 = g_iVtoR_WMV[pucCurrV[0]];
            iUtoG0PlusVtoG0 = g_iUtoG_WMV [pucCurrU[0]] + g_iVtoG_WMV [pucCurrV[0]];
            iUtoB0 = g_iUtoB_WMV[pucCurrU[0]];
            UpdateDstRGB15 (0,iVtoR0,iUtoG0PlusVtoG0,iUtoB0)           

            iVtoR1 = g_iVtoR_WMV[pucCurrV[1]];
            iUtoG1PlusVtoG1 = g_iUtoG_WMV [pucCurrU[1]] + g_iVtoG_WMV [pucCurrV[1]];
            iUtoB1 = g_iUtoB_WMV[pucCurrU[1]];
            UpdateDstRGB15 (1,iVtoR1,iUtoG1PlusVtoG1,iUtoB1)           

            iVtoR2 = g_iVtoR_WMV[pucCurrV[2]];
            iUtoG2PlusVtoG2 = g_iUtoG_WMV[pucCurrU[2]] + g_iVtoG_WMV[pucCurrV[2]];
            iUtoB2 = g_iUtoB_WMV[pucCurrU[2]];
            UpdateDstRGB15 (2,iVtoR2,iUtoG2PlusVtoG2,iUtoB2)           

            iVtoR3 = g_iVtoR_WMV[pucCurrV[3]];
            iUtoG3PlusVtoG3 = g_iUtoG_WMV[pucCurrU[3]] + g_iVtoG_WMV[pucCurrV[3]];
            iUtoB3 = g_iUtoB_WMV[pucCurrU[3]];
            UpdateDstRGB15 (3,iVtoR3,iUtoG3PlusVtoG3,iUtoB3)           

            pucCurrY += iWidthY;
            pucCurrU += iWidthUV;
            pucCurrV += iWidthUV;

            pBits += iBitmapWidth;

            pdwBits = (U32_WMV*) pBits;

            UpdateDstRGB15 (0,iVtoR0,iUtoG0PlusVtoG0,iUtoB0)           
            UpdateDstRGB15 (1,iVtoR1,iUtoG1PlusVtoG1,iUtoB1)           
            UpdateDstRGB15 (2,iVtoR2,iUtoG2PlusVtoG2,iUtoB2)           
            UpdateDstRGB15 (3,iVtoR3,iUtoG3PlusVtoG3,iUtoB3)           

            pucCurrY += iWidthY;

            pBits += iBitmapWidth;
            pdwBits = (U32_WMV*) pBits;
        }

    }
    else {
        for (iy = 0; iy < SUB_BLOCK_SIZE; iy++) {
            I32_WMV iVtoR0, iUtoG0PlusVtoG0, iUtoB0;
            I32_WMV iVtoR1, iUtoG1PlusVtoG1, iUtoB1;
            I32_WMV iVtoR2, iUtoG2PlusVtoG2, iUtoB2;
            I32_WMV iVtoR3, iUtoG3PlusVtoG3, iUtoB3;

            iVtoR0 = g_iVtoR_WMV[pucCurrV[0]];
            iUtoG0PlusVtoG0 = g_iUtoG_WMV [pucCurrU[0]] + g_iVtoG_WMV [pucCurrV[0]];
            iUtoB0 = g_iUtoB_WMV[pucCurrU[0]];
            UpdateDstRGB16 (0,iVtoR0,iUtoG0PlusVtoG0,iUtoB0)           

            iVtoR1 = g_iVtoR_WMV[pucCurrV[1]];
            iUtoG1PlusVtoG1 = g_iUtoG_WMV [pucCurrU[1]] + g_iVtoG_WMV [pucCurrV[1]];
            iUtoB1 = g_iUtoB_WMV[pucCurrU[1]];
            UpdateDstRGB16 (1,iVtoR1,iUtoG1PlusVtoG1,iUtoB1)           
                
            iVtoR2 = g_iVtoR_WMV[pucCurrV[2]];
            iUtoG2PlusVtoG2 = g_iUtoG_WMV[pucCurrU[2]] + g_iVtoG_WMV[pucCurrV[2]];
            iUtoB2 = g_iUtoB_WMV[pucCurrU[2]];
            UpdateDstRGB16 (2,iVtoR2,iUtoG2PlusVtoG2,iUtoB2)           

            iVtoR3 = g_iVtoR_WMV[pucCurrV[3]];
            iUtoG3PlusVtoG3 = g_iUtoG_WMV[pucCurrU[3]] + g_iVtoG_WMV[pucCurrV[3]];
            iUtoB3 = g_iUtoB_WMV[pucCurrU[3]];
            UpdateDstRGB16 (3,iVtoR3,iUtoG3PlusVtoG3,iUtoB3)           

            pucCurrY += iWidthY;
            pucCurrU += iWidthUV;
            pucCurrV += iWidthUV;

            pBits += iBitmapWidth;
            pdwBits = (U32_WMV*) pBits;

            UpdateDstRGB16 (0,iVtoR0,iUtoG0PlusVtoG0,iUtoB0)           
            UpdateDstRGB16 (1,iVtoR1,iUtoG1PlusVtoG1,iUtoB1)           
            UpdateDstRGB16 (2,iVtoR2,iUtoG2PlusVtoG2,iUtoB2)           
            UpdateDstRGB16 (3,iVtoR3,iUtoG3PlusVtoG3,iUtoB3)           
                
            pucCurrY += iWidthY;

            pBits += iBitmapWidth;
            pdwBits = (U32_WMV*) pBits;
        }
    }
}
#else // IPP_COLORCONV

Void_WMV WMVideoDecUpdateDstMBRGB16 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* ppxliCurrQYMB,
    const U8_WMV* ppxliCurrQUMB,
    const U8_WMV* ppxliCurrQVMB,
    I32_WMV iWidthY,
    I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
)
{
  
	const Ipp8u* const pSrc[3] = { (Ipp8u*) ppxliCurrQYMB,
								   (Ipp8u*) ppxliCurrQUMB,
								   (Ipp8u*) ppxliCurrQVMB};

	int srcStep[3];
	srcStep[0] = iWidthY;
	srcStep[1] = iWidthUV;
	srcStep[2] = iWidthUV;

	Ipp16u* pDst;
	pDst = (Ipp16u*) pBits;

	int dstStep = iBitmapWidth;

	IppiSize roiSize;
	roiSize.height = 16;
	roiSize.width  = 16;

	//ippiYUV420ToRGB565_8u16u_P3C3R(pSrc, srcStep, pDst, dstStep, roiSize);
    ippiYUV420ToBGR565_8u16u_P3C3R(pSrc, srcStep, pDst, dstStep, roiSize);
};

Void_WMV WMVideoDecUpdateDstBlkRGB16 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* ppxliCurrQYMB,
    const U8_WMV* ppxliCurrQUMB,
    const U8_WMV* ppxliCurrQVMB,
    I32_WMV iWidthY,
    I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
)
{
  
	const Ipp8u* const pSrc[3] = { (Ipp8u*) ppxliCurrQYMB,
								   (Ipp8u*) ppxliCurrQUMB,
								   (Ipp8u*) ppxliCurrQVMB};

	int srcStep[3];
	srcStep[0] = iWidthY;
	srcStep[1] = iWidthUV;
	srcStep[2] = iWidthUV;

	Ipp16u* pDst;
	pDst = (Ipp16u*) pBits;

	int dstStep = iBitmapWidth;

	IppiSize roiSize;
	roiSize.height = 8;
	roiSize.width  = 8;

	//ippiYUV420ToRGB565_8u16u_P3C3R(pSrc, srcStep, pDst, dstStep, roiSize);
    ippiYUV420ToBGR565_8u16u_P3C3R(pSrc, srcStep, pDst, dstStep, roiSize);
};
#endif // IPP_COLORCONV
#endif //OPT_DECOLORCONV_ARM
#endif // defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB16)

#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_GRAY4)
#define UpdateGray4(iUV, iY0, iY1) \
    iYtoRGB = rgiClapTab [(pucCurrY[iY1] + (uiDither >> 28)) >> 4];\
    uiDither <<= 1;\
    rVal = rgiClapTab [(pucCurrY[iY0] + (uiDither >> 28)) >> 4];\
    uiDither <<= 1;\
    iYtoRGB = rVal + (iYtoRGB << 16);\
    ((U32_WMV*)pBits) [iUV] = (iYtoRGB << 11) | (iYtoRGB << 6) | iYtoRGB;\
    iYtoRGB = rgiClapTab [((pucCurrY + iWidthY) [iY1] + (uiDither >> 28)) >> 4];\
    uiDither <<= 1;\
    rVal = rgiClapTab [((pucCurrY + iWidthY) [iY0] + (uiDither >> 28)) >> 4];\
    uiDither <<= 1;\
    iYtoRGB = rVal + (iYtoRGB << 16);\
    ((U32_WMV*)(pBits + iBitmapWidth)) [iUV] = (iYtoRGB << 11) | (iYtoRGB << 6) | iYtoRGB;

Void_WMV WMVideoDecUpdateDstPartialMBGRAY4 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV, 
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iRgbWidth, I32_WMV iRgbHeight
)
{
//
// Temporary macroblock-sized buffer
//
    U8_WMV  mb[MB_SIZE * 2 * MB_SIZE];
    U8_WMV *pBitsMb;
    I32_WMV i;
//
// Now color-space convert the macroblock into the buffer.
//
    WMVideoDecUpdateDstMBGRAY4 (
        pWMVDec,
        (U8_WMV *)mb,
        pucCurrY,
        pucCurrU,
        pucCurrV,
        iWidthY,
        iWidthUV,
        MB_SIZE * 2);
//
// And, copy the valid pixels from the buffer into the bitmap.
//
    pBitsMb = mb;
    for (i = 0; i < iRgbHeight; ++i) {
        memcpy(pBits, pBitsMb, iRgbWidth * 2);

        pBitsMb += MB_SIZE * 2;
        pBits += pWMVDec->m_iWidthBMP;
    }
}

Void_WMV WMVideoDecUpdateDstMBGRAY4 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
)
{
    U32_WMV uiDither;
    I32_WMV rVal, iYtoRGB;
    const U8_WMV* rgiClapTab = pWMVDec->m_rgiClapTab4BitDec;
    pWMVDec->m_iDitheringIndex -= 1;
    pWMVDec->m_iDitheringIndex = (pWMVDec->m_iDitheringIndex < 0)? 2 : pWMVDec->m_iDitheringIndex;
    const U32_WMV* piDithering = pWMVDec->m_rgiDithering + (pWMVDec->m_iDitheringIndex << 3);
    for (U32_WMV iy = 0; iy < BLOCK_SIZE; iy++) {
        uiDither = piDithering [iy];
        UpdateGray4(0, 0, 1);
        UpdateGray4(1, 2, 3);
        UpdateGray4(2, 4, 5);
        UpdateGray4(3, 6, 7);
        UpdateGray4(4, 8, 9);
        UpdateGray4(5, 10, 11);
        UpdateGray4(6, 12, 13);
        UpdateGray4(7, 14, 15);
        pucCurrY += (iWidthY << 1);
        pBits += (iBitmapWidth << 1);
    }
}

Void_WMV WMVideoDecUpdateDstBlkGRAY4 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
)
{
    U32_WMV uiDither;
    I32_WMV rVal, iYtoRGB;
    const U8_WMV* rgiClapTab = pWMVDec->m_rgiClapTab4BitDec;
    pWMVDec->m_iDitheringIndex -= 1;
    pWMVDec->m_iDitheringIndex = (pWMVDec->m_iDitheringIndex < 0)? 2 : pWMVDec->m_iDitheringIndex;
    const U32_WMV* piDithering = pWMVDec->m_rgiDithering + (pWMVDec->m_iDitheringIndex << 3);
    for (U32_WMV iy = 0; iy < SUB_BLOCK_SIZE; iy++) {
        uiDither = piDithering [iy];
        UpdateGray4(0, 0, 1);
        UpdateGray4(1, 2, 3);
        UpdateGray4(2, 4, 5);
        UpdateGray4(3, 6, 7);
        pucCurrY += (iWidthY << 1);
        pBits += (iBitmapWidth << 1);
    }
}
#endif //OUTPUT_GRAY4

#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB12)
#define UpdateRGB12(iUV, iY0, iY1) \
    gVal = pucCurrU[iUV] - 128;\
    iUVtoG = 100 * gVal;\
    rVal = pucCurrV[iUV] - 128;\
    iVtoR = 408 * rVal;\
    iUtoB = gVal << 9;\
    iUVtoG += 208 * rVal;\
    iYtoRGB = pucCurrY[iY1] + (uiDither >> 28);\
    uiDither <<= 1;\
    rVal = rgiClapTab [(((iYtoRGB << 8) + iVtoR)) >> 12];\
    gVal = rgiClapTab [(((iYtoRGB << 8) - iUVtoG)) >> 12];\
    bVal = rgiClapTab [(((iYtoRGB << 8) + iUtoB)) >> 12];\
    iYtoRGB = pucCurrY[iY0] + (uiDither >> 28);\
    uiDither <<= 1;\
    rVal = rgiClapTab [(((iYtoRGB << 8) + iVtoR)) >> 12] + (rVal << 16);\
    gVal = rgiClapTab [(((iYtoRGB << 8) - iUVtoG)) >> 12] + (gVal << 16);\
    bVal = rgiClapTab [(((iYtoRGB << 8) + iUtoB)) >> 12] + (bVal << 16);\
    ((U32_WMV*)pBits) [iUV] = (rVal << 11) | (gVal << 6) | bVal;\
    iYtoRGB = (pucCurrY + iWidthY) [iY1] + (uiDither >> 28);\
    uiDither <<= 1;\
    rVal = rgiClapTab [(((iYtoRGB << 8) + iVtoR)) >> 12];\
    gVal = rgiClapTab [(((iYtoRGB << 8) - iUVtoG)) >> 12];\
    bVal = rgiClapTab [(((iYtoRGB << 8) + iUtoB)) >> 12];\
    iYtoRGB = (pucCurrY + iWidthY) [iY0] + (uiDither >> 28);\
    uiDither <<= 1;\
    rVal = rgiClapTab [(((iYtoRGB << 8) + iVtoR)) >> 12] + (rVal << 16);\
    gVal = rgiClapTab [(((iYtoRGB << 8) - iUVtoG)) >> 12] + (gVal << 16);\
    bVal = rgiClapTab [(((iYtoRGB << 8) + iUtoB)) >> 12] + (bVal << 16);\
    ((U32_WMV*)(pBits + iBitmapWidth)) [iUV] = (rVal << 11) | (gVal << 6) | bVal;

Void_WMV WMVideoDecUpdateDstPartialMBRGB12 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iRgbWidth, I32_WMV iRgbHeight
)
{
//
// Temporary macroblock-sized buffer
//
    U8_WMV  mb[MB_SIZE * 2 * MB_SIZE];
    U8_WMV *pBitsMb;
    I32_WMV i;
//
// Now color-space convert the macroblock into the buffer.
//
    WMVideoDecUpdateDstMBRGB12 (
        pWMVDec,
        (U8_WMV *)mb,
        pucCurrY,
        pucCurrU,
        pucCurrV,
        iWidthY,
        iWidthUV,
        MB_SIZE * 2);
//
// And, copy the valid pixels from the buffer into the bitmap.
//
    pBitsMb = mb;
    for (i = 0; i < iRgbHeight; ++i) {
        memcpy(pBits, pBitsMb, iRgbWidth * 2);

        pBitsMb += MB_SIZE * 2;
        pBits += pWMVDec->m_iWidthBMP;
    }
}

#if !defined( OPT_DECOLORCONV_ARM)
Void_WMV WMVideoDecUpdateDstMBRGB12 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
)
{
    U32_WMV uiDither;
    I32_WMV rVal, gVal, bVal;
    I32_WMV iYtoRGB, iVtoR, iUVtoG, iUtoB;
    const U8_WMV* rgiClapTab = pWMVDec->m_rgiClapTab4BitDec;
    pWMVDec->m_iDitheringIndex -= 1;
    pWMVDec->m_iDitheringIndex = (pWMVDec->m_iDitheringIndex < 0)? 2 : pWMVDec->m_iDitheringIndex;
    const U32_WMV* piDithering = pWMVDec->m_rgiDithering + (pWMVDec->m_iDitheringIndex << 3);
    for (U32_WMV iy = 0; iy < BLOCK_SIZE; iy++) {
        uiDither = piDithering [iy];
        UpdateRGB12(0, 0, 1);
        UpdateRGB12(1, 2, 3);
        UpdateRGB12(2, 4, 5);
        UpdateRGB12(3, 6, 7);
        UpdateRGB12(4, 8, 9);
        UpdateRGB12(5, 10, 11);
        UpdateRGB12(6, 12, 13);
        UpdateRGB12(7, 14, 15);
        pucCurrY += (iWidthY << 1);
        pucCurrU += iWidthUV;
        pucCurrV += iWidthUV;
        pBits += (iBitmapWidth << 1);
    }
}

Void_WMV WMVideoDecUpdateDstBlkRGB12 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
)
{
    U32_WMV uiDither;
    I32_WMV rVal, gVal, bVal;
    I32_WMV iYtoRGB, iVtoR, iUVtoG, iUtoB;
    const U8_WMV* rgiClapTab = pWMVDec->m_rgiClapTab4BitDec;
    pWMVDec->m_iDitheringIndex -= 1;
    pWMVDec->m_iDitheringIndex = (pWMVDec->m_iDitheringIndex < 0)? 2 : pWMVDec->m_iDitheringIndex;
    const U32_WMV* piDithering = pWMVDec->m_rgiDithering + (pWMVDec->m_iDitheringIndex << 3);
    for (U32_WMV iy = 0; iy < SUB_BLOCK_SIZE; iy++) {
        uiDither = piDithering [iy];
        UpdateRGB12(0, 0, 1);
        UpdateRGB12(1, 2, 3);
        UpdateRGB12(2, 4, 5);
        UpdateRGB12(3, 6, 7);
        pucCurrY += (iWidthY << 1);
        pucCurrU += iWidthUV;
        pucCurrV += iWidthUV;
        pBits += (iBitmapWidth << 1);
    }
}
#endif //#if !defined( OPT_DECOLORCONV_ARM)
#endif //OUTPUT_RGB12

#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB24)

Void_WMV WMVideoDecUpdateDstPartialMBRGB24 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iRgbWidth, I32_WMV iRgbHeight
) {
//
// Temporary macroblock-sized buffer
//
    U8_WMV mb[MB_SIZE * 3 * MB_SIZE];
    U8_WMV *pBitsMb;
    I32_WMV i;
//
// Now color-space convert the macroblock into the buffer.
//
    WMVideoDecUpdateDstMBRGB24(
        pWMVDec,
        (U8_WMV *)mb,
        pucCurrY,
        pucCurrU,
        pucCurrV,
        iWidthY,
        iWidthUV,
        MB_SIZE * 3);
//
// And, copy the valid pixels from the buffer into the bitmap.
//
    pBitsMb = mb;
    for (i = 0; i < iRgbHeight; ++i) {
        memcpy(pBits, pBitsMb, iRgbWidth * 3);

        pBitsMb += MB_SIZE * 3;
        pBits += pWMVDec->m_iWidthBMP;
    }
}

#ifndef OPT_DECOLORCONV_SH4
Void_WMV WMVideoDecUpdateDstMBRGB24 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
) {
    const U8_WMV* rgiClapTab = pWMVDec->m_rgiClapTabDec; 

    U32_WMV iy;
    
    for (iy = 0; iy < BLOCK_SIZE; iy++) {
        I32_WMV iVtoR0, iUtoG0PlusVtoG0, iUtoB0;
        I32_WMV iVtoR1, iUtoG1PlusVtoG1, iUtoB1;
        I32_WMV iVtoR2, iUtoG2PlusVtoG2, iUtoB2;
        I32_WMV iVtoR3, iUtoG3PlusVtoG3, iUtoB3;
        I32_WMV iVtoR4, iUtoG4PlusVtoG4, iUtoB4;
        I32_WMV iVtoR5, iUtoG5PlusVtoG5, iUtoB5;
        I32_WMV iVtoR6, iUtoG6PlusVtoG6, iUtoB6;
        I32_WMV iVtoR7, iUtoG7PlusVtoG7, iUtoB7;
        I32_WMV iYScale;

        iVtoR0 = g_iVtoR_WMV [pucCurrV [0]];
        iUtoG0PlusVtoG0 = g_iUtoG_WMV [pucCurrU [0]] + g_iVtoG_WMV [pucCurrV [0]];
        iUtoB0 = g_iUtoB_WMV [pucCurrU [0]];

        iYScale = g_iYscale_WMV [pucCurrY [0]];
        pBits [2] = rgiClapTab [(iYScale + iVtoR0)]; // r
        pBits [1] = rgiClapTab [(iYScale - iUtoG0PlusVtoG0)]; // g
        pBits [0] = rgiClapTab [(iYScale + iUtoB0)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[1]];
        pBits [5] = rgiClapTab [(iYScale + iVtoR0)]; // r
        pBits [4] = rgiClapTab [(iYScale - iUtoG0PlusVtoG0)]; // g
        pBits [3] = rgiClapTab [(iYScale + iUtoB0)]; // b

        iVtoR1 = g_iVtoR_WMV [pucCurrV [1]];
        iUtoG1PlusVtoG1 = g_iUtoG_WMV[pucCurrU [1]] + g_iVtoG_WMV[pucCurrV [1]];
        iUtoB1 = g_iUtoB_WMV [pucCurrU [1]];

        iYScale = g_iYscale_WMV[pucCurrY [2]];
        pBits [8] = rgiClapTab [(iYScale + iVtoR1)]; // r
        pBits [7] = rgiClapTab [(iYScale - iUtoG1PlusVtoG1)]; // g
        pBits [6] = rgiClapTab [(iYScale + iUtoB1)]; // b

        iYScale = g_iYscale_WMV [pucCurrY [3]];
        pBits [11] = rgiClapTab [(iYScale + iVtoR1)]; // r
        pBits [10] = rgiClapTab [(iYScale - iUtoG1PlusVtoG1)]; // g
        pBits [9]  = rgiClapTab [(iYScale + iUtoB1)]; // b

        iVtoR2 = g_iVtoR_WMV [pucCurrV [2]];
        iUtoG2PlusVtoG2 = g_iUtoG_WMV [pucCurrU [2]] + g_iVtoG_WMV [pucCurrV [2]];
        iUtoB2 = g_iUtoB_WMV [pucCurrU [2]];

        iYScale = g_iYscale_WMV [pucCurrY [4]];
        pBits [14] = rgiClapTab [(iYScale + iVtoR2)]; // r
        pBits [13] = rgiClapTab [(iYScale - iUtoG2PlusVtoG2)]; // g
        pBits [12] = rgiClapTab [(iYScale + iUtoB2)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[5]];
        pBits [17] = rgiClapTab [(iYScale + iVtoR2)]; // r
        pBits [16] = rgiClapTab [(iYScale - iUtoG2PlusVtoG2)]; // g
        pBits [15] = rgiClapTab [(iYScale + iUtoB2)]; // b

        iVtoR3 = g_iVtoR_WMV [pucCurrV [3]];
        iUtoG3PlusVtoG3 = g_iUtoG_WMV [pucCurrU [3]] + g_iVtoG_WMV [pucCurrV [3]];
        iUtoB3 = g_iUtoB_WMV [pucCurrU [3]];
        
        iYScale = g_iYscale_WMV [pucCurrY [6]];
        pBits [20] = rgiClapTab [(iYScale + iVtoR3)]; // r
        pBits [19] = rgiClapTab [(iYScale - iUtoG3PlusVtoG3)]; // g
        pBits [18] = rgiClapTab [(iYScale + iUtoB3)]; // b
        
        iYScale = g_iYscale_WMV[pucCurrY[7]];
        pBits [23] = rgiClapTab [(iYScale + iVtoR3)]; // r
        pBits [22] = rgiClapTab [(iYScale - iUtoG3PlusVtoG3)]; // g
        pBits [21] = rgiClapTab [(iYScale + iUtoB3)]; // b
        
        iVtoR4 = g_iVtoR_WMV[pucCurrV[4]];
        iUtoG4PlusVtoG4 = g_iUtoG_WMV[pucCurrU[4]] + g_iVtoG_WMV[pucCurrV[4]];
        iUtoB4 = g_iUtoB_WMV[pucCurrU[4]];
        
        iYScale = g_iYscale_WMV[pucCurrY[8]];
        pBits [26] = rgiClapTab [(iYScale + iVtoR4)]; // r
        pBits [25] = rgiClapTab [(iYScale - iUtoG4PlusVtoG4)]; // g
        pBits [24] = rgiClapTab [(iYScale + iUtoB4)]; // b
        
        iYScale = g_iYscale_WMV[pucCurrY[9]];
        pBits [29] = rgiClapTab [(iYScale + iVtoR4)]; // r
        pBits [28] = rgiClapTab [(iYScale - iUtoG4PlusVtoG4)]; // g
        pBits [27] = rgiClapTab [(iYScale + iUtoB4)]; // b

        iVtoR5 = g_iVtoR_WMV[pucCurrV[5]];
        iUtoG5PlusVtoG5 = g_iUtoG_WMV[pucCurrU[5]] + g_iVtoG_WMV[pucCurrV[5]];
        iUtoB5 = g_iUtoB_WMV[pucCurrU[5]];

        iYScale = g_iYscale_WMV[pucCurrY[10]];
        pBits [32] = rgiClapTab [(iYScale + iVtoR5)]; // r
        pBits [31] = rgiClapTab [(iYScale - iUtoG5PlusVtoG5)]; // g
        pBits [30] = rgiClapTab [(iYScale + iUtoB5)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[11]];
        pBits [35] = rgiClapTab [(iYScale + iVtoR5)]; // r
        pBits [34] = rgiClapTab [(iYScale - iUtoG5PlusVtoG5)]; // g
        pBits [33] = rgiClapTab [(iYScale + iUtoB5)]; // b

        iVtoR6 = g_iVtoR_WMV[pucCurrV[6]];
        iUtoG6PlusVtoG6 = g_iUtoG_WMV[pucCurrU[6]] + g_iVtoG_WMV[pucCurrV[6]];
        iUtoB6 = g_iUtoB_WMV[pucCurrU[6]];

        iYScale = g_iYscale_WMV[pucCurrY[12]];
        pBits [38] = rgiClapTab [(iYScale + iVtoR6)]; // r
        pBits [37] = rgiClapTab [(iYScale - iUtoG6PlusVtoG6)]; // g
        pBits [36] = rgiClapTab [(iYScale + iUtoB6)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[13]];
        pBits [41] = rgiClapTab [(iYScale + iVtoR6)]; // r
        pBits [40] = rgiClapTab [(iYScale - iUtoG6PlusVtoG6)]; // g
        pBits [39] = rgiClapTab [(iYScale + iUtoB6)]; // b

        iVtoR7 = g_iVtoR_WMV[pucCurrV[7]];
        iUtoG7PlusVtoG7 = g_iUtoG_WMV[pucCurrU[7]] + g_iVtoG_WMV[pucCurrV[7]];
        iUtoB7 = g_iUtoB_WMV[pucCurrU[7]];

        iYScale = g_iYscale_WMV[pucCurrY[14]];
        pBits [44] = rgiClapTab [(iYScale + iVtoR7)]; // r
        pBits [43] = rgiClapTab [(iYScale - iUtoG7PlusVtoG7)]; // g
        pBits [42] = rgiClapTab [(iYScale + iUtoB7)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[15]];
        pBits [47] = rgiClapTab [(iYScale + iVtoR7)]; // r
        pBits [46] = rgiClapTab [(iYScale - iUtoG7PlusVtoG7)]; // g
        pBits [45] = rgiClapTab [(iYScale + iUtoB7)]; // b

        pucCurrY += iWidthY;
        pucCurrU += iWidthUV;
        pucCurrV += iWidthUV;

        pBits += iBitmapWidth;

        iYScale = g_iYscale_WMV[pucCurrY[0]];
        pBits [2] = rgiClapTab [(iYScale + iVtoR0)]; // r
        pBits [1] = rgiClapTab [(iYScale - iUtoG0PlusVtoG0)]; // g
        pBits [0] = rgiClapTab [(iYScale + iUtoB0)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[1]];
        pBits [5] = rgiClapTab [(iYScale + iVtoR0)]; // r
        pBits [4] = rgiClapTab [(iYScale - iUtoG0PlusVtoG0)]; // g
        pBits [3] = rgiClapTab [(iYScale + iUtoB0)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[2]];
        pBits [8] = rgiClapTab [(iYScale + iVtoR1)]; // r
        pBits [7] = rgiClapTab [(iYScale - iUtoG1PlusVtoG1)]; // g
        pBits [6] = rgiClapTab [(iYScale + iUtoB1)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[3]];
        pBits [11] = rgiClapTab [(iYScale + iVtoR1)]; // r
        pBits [10] = rgiClapTab [(iYScale - iUtoG1PlusVtoG1)]; // g
        pBits [9]  = rgiClapTab [(iYScale + iUtoB1)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[4]];
        pBits [14] = rgiClapTab [(iYScale + iVtoR2)]; // r
        pBits [13] = rgiClapTab [(iYScale - iUtoG2PlusVtoG2)]; // g
        pBits [12] = rgiClapTab [(iYScale + iUtoB2)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[5]];
        pBits [17] = rgiClapTab [(iYScale + iVtoR2)]; // r
        pBits [16] = rgiClapTab [(iYScale - iUtoG2PlusVtoG2)]; // g
        pBits [15] = rgiClapTab [(iYScale + iUtoB2)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[6]];
        pBits [20] = rgiClapTab [(iYScale + iVtoR3)]; // r
        pBits [19] = rgiClapTab [(iYScale - iUtoG3PlusVtoG3)]; // g
        pBits [18] = rgiClapTab [(iYScale + iUtoB3)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[7]];
        pBits [23] = rgiClapTab [(iYScale + iVtoR3)]; // r
        pBits [22] = rgiClapTab [(iYScale - iUtoG3PlusVtoG3)]; // g
        pBits [21] = rgiClapTab [(iYScale + iUtoB3)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[8]];
        pBits [26] = rgiClapTab [(iYScale + iVtoR4)]; // r
        pBits [25] = rgiClapTab [(iYScale - iUtoG4PlusVtoG4)]; // g
        pBits [24] = rgiClapTab [(iYScale + iUtoB4)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[9]];
        pBits [29] = rgiClapTab [(iYScale + iVtoR4)]; // r
        pBits [28] = rgiClapTab [(iYScale - iUtoG4PlusVtoG4)]; // g
        pBits [27] = rgiClapTab [(iYScale + iUtoB4)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[10]];
        pBits [32] = rgiClapTab [(iYScale + iVtoR5)]; // r
        pBits [31] = rgiClapTab [(iYScale - iUtoG5PlusVtoG5)]; // g
        pBits [30] = rgiClapTab [(iYScale + iUtoB5)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[11]];
        pBits [35] = rgiClapTab [(iYScale + iVtoR5)]; // r
        pBits [34] = rgiClapTab [(iYScale - iUtoG5PlusVtoG5)]; // g
        pBits [33] = rgiClapTab [(iYScale + iUtoB5)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[12]];
        pBits [38] = rgiClapTab [(iYScale + iVtoR6)]; // r
        pBits [37] = rgiClapTab [(iYScale - iUtoG6PlusVtoG6)]; // g
        pBits [36] = rgiClapTab [(iYScale + iUtoB6)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[13]];
        pBits [41] = rgiClapTab [(iYScale + iVtoR6)]; // r
        pBits [40] = rgiClapTab [(iYScale - iUtoG6PlusVtoG6)]; // g
        pBits [39] = rgiClapTab [(iYScale + iUtoB6)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[14]];
        pBits [44] = rgiClapTab [(iYScale + iVtoR7)]; // r
        pBits [43] = rgiClapTab [(iYScale - iUtoG7PlusVtoG7)]; // g
        pBits [42] = rgiClapTab [(iYScale + iUtoB7)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[15]];
        pBits [47] = rgiClapTab [(iYScale + iVtoR7)]; // r
        pBits [46] = rgiClapTab [(iYScale - iUtoG7PlusVtoG7)]; // g
        pBits [45] = rgiClapTab [(iYScale + iUtoB7)]; // b

        pucCurrY += iWidthY;
        pBits += iBitmapWidth;
    }
}

Void_WMV WMVideoDecUpdateDstBlkRGB24 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV *pBits,
    const U8_WMV *pucCurrY, const U8_WMV *pucCurrU, const U8_WMV *pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
) {
    const U8_WMV* rgiClapTab = pWMVDec->m_rgiClapTabDec; 

    U32_WMV iy;
    
    for (iy = 0; iy < SUB_BLOCK_SIZE; iy++) {
        I32_WMV iVtoR0, iUtoG0PlusVtoG0, iUtoB0;
        I32_WMV iVtoR1, iUtoG1PlusVtoG1, iUtoB1;
        I32_WMV iVtoR2, iUtoG2PlusVtoG2, iUtoB2;
        I32_WMV iVtoR3, iUtoG3PlusVtoG3, iUtoB3;
        I32_WMV iYScale;

        iVtoR0 = g_iVtoR_WMV [pucCurrV [0]];
        iUtoG0PlusVtoG0 = g_iUtoG_WMV [pucCurrU [0]] + g_iVtoG_WMV [pucCurrV [0]];
        iUtoB0 = g_iUtoB_WMV [pucCurrU [0]];

        iYScale = g_iYscale_WMV [pucCurrY [0]];
        pBits [2] = rgiClapTab [(iYScale + iVtoR0)]; // r
        pBits [1] = rgiClapTab [(iYScale - iUtoG0PlusVtoG0)]; // g
        pBits [0] = rgiClapTab [(iYScale + iUtoB0)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[1]];
        pBits [5] = rgiClapTab [(iYScale + iVtoR0)]; // r
        pBits [4] = rgiClapTab [(iYScale - iUtoG0PlusVtoG0)]; // g
        pBits [3] = rgiClapTab [(iYScale + iUtoB0)]; // b

        iVtoR1 = g_iVtoR_WMV [pucCurrV [1]];
        iUtoG1PlusVtoG1 = g_iUtoG_WMV[pucCurrU [1]] + g_iVtoG_WMV[pucCurrV [1]];
        iUtoB1 = g_iUtoB_WMV [pucCurrU [1]];

        iYScale = g_iYscale_WMV[pucCurrY [2]];
        pBits [8] = rgiClapTab [(iYScale + iVtoR1)]; // r
        pBits [7] = rgiClapTab [(iYScale - iUtoG1PlusVtoG1)]; // g
        pBits [6] = rgiClapTab [(iYScale + iUtoB1)]; // b

        iYScale = g_iYscale_WMV [pucCurrY [3]];
        pBits [11] = rgiClapTab [(iYScale + iVtoR1)]; // r
        pBits [10] = rgiClapTab [(iYScale - iUtoG1PlusVtoG1)]; // g
        pBits [9]  = rgiClapTab [(iYScale + iUtoB1)]; // b

        iVtoR2 = g_iVtoR_WMV [pucCurrV [2]];
        iUtoG2PlusVtoG2 = g_iUtoG_WMV [pucCurrU [2]] + g_iVtoG_WMV [pucCurrV [2]];
        iUtoB2 = g_iUtoB_WMV [pucCurrU [2]];

        iYScale = g_iYscale_WMV [pucCurrY [4]];
        pBits [14] = rgiClapTab [(iYScale + iVtoR2)]; // r
        pBits [13] = rgiClapTab [(iYScale - iUtoG2PlusVtoG2)]; // g
        pBits [12] = rgiClapTab [(iYScale + iUtoB2)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[5]];
        pBits [17] = rgiClapTab [(iYScale + iVtoR2)]; // r
        pBits [16] = rgiClapTab [(iYScale - iUtoG2PlusVtoG2)]; // g
        pBits [15] = rgiClapTab [(iYScale + iUtoB2)]; // b

        iVtoR3 = g_iVtoR_WMV [pucCurrV [3]];
        iUtoG3PlusVtoG3 = g_iUtoG_WMV [pucCurrU [3]] + g_iVtoG_WMV [pucCurrV [3]];
        iUtoB3 = g_iUtoB_WMV [pucCurrU [3]];
        
        iYScale = g_iYscale_WMV [pucCurrY [6]];
        pBits [20] = rgiClapTab [(iYScale + iVtoR3)]; // r
        pBits [19] = rgiClapTab [(iYScale - iUtoG3PlusVtoG3)]; // g
        pBits [18] = rgiClapTab [(iYScale + iUtoB3)]; // b
        
        iYScale = g_iYscale_WMV[pucCurrY [7]];
        pBits [23] = rgiClapTab [(iYScale + iVtoR3)]; // r
        pBits [22] = rgiClapTab [(iYScale - iUtoG3PlusVtoG3)]; // g
        pBits [21] = rgiClapTab [(iYScale + iUtoB3)]; // b
        
        pucCurrY += iWidthY;
        pucCurrU += iWidthUV;
        pucCurrV += iWidthUV;

        pBits += iBitmapWidth;

        iYScale = g_iYscale_WMV[pucCurrY[0]];
        pBits [2] = rgiClapTab [(iYScale + iVtoR0)]; // r
        pBits [1] = rgiClapTab [(iYScale - iUtoG0PlusVtoG0)]; // g
        pBits [0] = rgiClapTab [(iYScale + iUtoB0)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[1]];
        pBits [5] = rgiClapTab [(iYScale + iVtoR0)]; // r
        pBits [4] = rgiClapTab [(iYScale - iUtoG0PlusVtoG0)]; // g
        pBits [3] = rgiClapTab [(iYScale + iUtoB0)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[2]];
        pBits [8] = rgiClapTab [(iYScale + iVtoR1)]; // r
        pBits [7] = rgiClapTab [(iYScale - iUtoG1PlusVtoG1)]; // g
        pBits [6] = rgiClapTab [(iYScale + iUtoB1)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[3]];
        pBits [11] = rgiClapTab [(iYScale + iVtoR1)]; // r
        pBits [10] = rgiClapTab [(iYScale - iUtoG1PlusVtoG1)]; // g
        pBits [9]  = rgiClapTab [(iYScale + iUtoB1)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[4]];
        pBits [14] = rgiClapTab [(iYScale + iVtoR2)]; // r
        pBits [13] = rgiClapTab [(iYScale - iUtoG2PlusVtoG2)]; // g
        pBits [12] = rgiClapTab [(iYScale + iUtoB2)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[5]];
        pBits [17] = rgiClapTab [(iYScale + iVtoR2)]; // r
        pBits [16] = rgiClapTab [(iYScale - iUtoG2PlusVtoG2)]; // g
        pBits [15] = rgiClapTab [(iYScale + iUtoB2)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[6]];
        pBits [20] = rgiClapTab [(iYScale + iVtoR3)]; // r
        pBits [19] = rgiClapTab [(iYScale - iUtoG3PlusVtoG3)]; // g
        pBits [18] = rgiClapTab [(iYScale + iUtoB3)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[7]];
        pBits [23] = rgiClapTab [(iYScale + iVtoR3)]; // r
        pBits [22] = rgiClapTab [(iYScale - iUtoG3PlusVtoG3)]; // g
        pBits [21] = rgiClapTab [(iYScale + iUtoB3)]; // b

        pucCurrY += iWidthY;
        pBits += iBitmapWidth;
    }
}
#endif	//define(OPT_DECOLORCONV_SH4)

#endif // defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB24)

#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB32)

Void_WMV WMVideoDecUpdateDstPartialMBRGB32 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iRgbWidth, I32_WMV iRgbHeight
) {
//
// Temporary macroblock-sized buffer
//
    U8_WMV  mb [MB_SIZE * 4 * MB_SIZE];
    U8_WMV *pBitsMb;
    I32_WMV i;
//
// Now color-space convert the macroblock into the buffer.
//
    WMVideoDecUpdateDstMBRGB32(
        pWMVDec,
        (U8_WMV *)mb,
        pucCurrY,
        pucCurrU,
        pucCurrV,
        iWidthY,
        iWidthUV,
        MB_SIZE * 4);
//
// And, copy the valid pixels from the buffer into the bitmap.
//
    pBitsMb = mb;
    for (i = 0; i < iRgbHeight; ++i) {
        memcpy(pBits, pBitsMb, iRgbWidth * 4);

        pBitsMb += MB_SIZE * 4;
        pBits += pWMVDec->m_iWidthBMP;
    }
}

Void_WMV WMVideoDecUpdateDstMBRGB32 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
) {
    const U8_WMV* rgiClapTab = pWMVDec->m_rgiClapTabDec; 

    U32_WMV iy;
    for (iy = 0; iy < BLOCK_SIZE; iy++) {
        I32_WMV iVtoR0, iUtoG0PlusVtoG0, iUtoB0;
        I32_WMV iVtoR1, iUtoG1PlusVtoG1, iUtoB1;
        I32_WMV iVtoR2, iUtoG2PlusVtoG2, iUtoB2;
        I32_WMV iVtoR3, iUtoG3PlusVtoG3, iUtoB3;
        I32_WMV iVtoR4, iUtoG4PlusVtoG4, iUtoB4;
        I32_WMV iVtoR5, iUtoG5PlusVtoG5, iUtoB5;
        I32_WMV iVtoR6, iUtoG6PlusVtoG6, iUtoB6;
        I32_WMV iVtoR7, iUtoG7PlusVtoG7, iUtoB7;
        I32_WMV iYScale;

        iVtoR0 = g_iVtoR_WMV [pucCurrV[0]];
        iUtoG0PlusVtoG0 = g_iUtoG_WMV [pucCurrU[0]] + g_iVtoG_WMV [pucCurrV[0]];
        iUtoB0 = g_iUtoB_WMV [pucCurrU[0]];
        iYScale = g_iYscale_WMV[pucCurrY[0]];
        pBits [2] = rgiClapTab [(iYScale + iVtoR0)]; // r
        pBits [1] = rgiClapTab [(iYScale - iUtoG0PlusVtoG0)]; // g
        pBits [0] = rgiClapTab [(iYScale + iUtoB0)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[1]];
        pBits [6] = rgiClapTab [(iYScale + iVtoR0)]; // r
        pBits [5] = rgiClapTab [(iYScale - iUtoG0PlusVtoG0)]; // g
        pBits [4] = rgiClapTab [(iYScale + iUtoB0)]; // b

        iVtoR1 = g_iVtoR_WMV[pucCurrV[1]];
        iUtoG1PlusVtoG1 = g_iUtoG_WMV[pucCurrU[1]] + g_iVtoG_WMV[pucCurrV[1]];
        iUtoB1 = g_iUtoB_WMV[pucCurrU[1]];
        iYScale = g_iYscale_WMV[pucCurrY[2]];
        pBits [10] = rgiClapTab [(iYScale + iVtoR1)]; // r
        pBits [9] = rgiClapTab [(iYScale - iUtoG1PlusVtoG1)]; // g
        pBits [8] = rgiClapTab [(iYScale + iUtoB1)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[3]];
        pBits [14] = rgiClapTab [(iYScale + iVtoR1)]; // r
        pBits [13] = rgiClapTab [(iYScale - iUtoG1PlusVtoG1)]; // g
        pBits [12] = rgiClapTab [(iYScale + iUtoB1)]; // b

        iVtoR2 = g_iVtoR_WMV[pucCurrV[2]];
        iUtoG2PlusVtoG2 = g_iUtoG_WMV[pucCurrU[2]] + g_iVtoG_WMV[pucCurrV[2]];
        iUtoB2 = g_iUtoB_WMV[pucCurrU[2]];
        iYScale = g_iYscale_WMV[pucCurrY[4]];
        pBits [18] = rgiClapTab [(iYScale + iVtoR2)]; // r
        pBits [17] = rgiClapTab [(iYScale - iUtoG2PlusVtoG2)]; // g
        pBits [16] = rgiClapTab [(iYScale + iUtoB2)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[5]];
        pBits [22] = rgiClapTab [(iYScale + iVtoR2)]; // r
        pBits [21] = rgiClapTab [(iYScale - iUtoG2PlusVtoG2)]; // g
        pBits [20] = rgiClapTab [(iYScale + iUtoB2)]; // b

        iVtoR3 = g_iVtoR_WMV[pucCurrV[3]];
        iUtoG3PlusVtoG3 = g_iUtoG_WMV[pucCurrU[3]] + g_iVtoG_WMV[pucCurrV[3]];
        iUtoB3 = g_iUtoB_WMV[pucCurrU[3]];
        iYScale = g_iYscale_WMV[pucCurrY[6]];
        pBits [26] = rgiClapTab [(iYScale + iVtoR3)]; // r
        pBits [25] = rgiClapTab [(iYScale - iUtoG3PlusVtoG3)]; // g
        pBits [24] = rgiClapTab [(iYScale + iUtoB3)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[7]];
        pBits [30] = rgiClapTab [(iYScale + iVtoR3)]; // r
        pBits [29] = rgiClapTab [(iYScale - iUtoG3PlusVtoG3)]; // g
        pBits [28] = rgiClapTab [(iYScale + iUtoB3)]; // b

        iVtoR4 = g_iVtoR_WMV[pucCurrV[4]];
        iUtoG4PlusVtoG4 = g_iUtoG_WMV[pucCurrU[4]] + g_iVtoG_WMV[pucCurrV[4]];
        iUtoB4 = g_iUtoB_WMV[pucCurrU[4]];
        iYScale = g_iYscale_WMV[pucCurrY[8]];
        pBits [34] = rgiClapTab [(iYScale + iVtoR4)]; // r
        pBits [33] = rgiClapTab [(iYScale - iUtoG4PlusVtoG4)]; // g
        pBits [32] = rgiClapTab [(iYScale + iUtoB4)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[9]];
        pBits [38] = rgiClapTab [(iYScale + iVtoR4)]; // r
        pBits [37] = rgiClapTab [(iYScale - iUtoG4PlusVtoG4)]; // g
        pBits [36] = rgiClapTab [(iYScale + iUtoB4)]; // b

        iVtoR5 = g_iVtoR_WMV[pucCurrV[5]];
        iUtoG5PlusVtoG5 = g_iUtoG_WMV[pucCurrU[5]] + g_iVtoG_WMV[pucCurrV[5]];
        iUtoB5 = g_iUtoB_WMV[pucCurrU[5]];
        iYScale = g_iYscale_WMV[pucCurrY[10]];
        pBits [42] = rgiClapTab [(iYScale + iVtoR5)]; // r
        pBits [41] = rgiClapTab [(iYScale - iUtoG5PlusVtoG5)]; // g
        pBits [40] = rgiClapTab [(iYScale + iUtoB5)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[11]];
        pBits [46] = rgiClapTab [(iYScale + iVtoR5)]; // r
        pBits [45] = rgiClapTab [(iYScale - iUtoG5PlusVtoG5)]; // g
        pBits [44] = rgiClapTab [(iYScale + iUtoB5)]; // b

        iVtoR6 = g_iVtoR_WMV[pucCurrV[6]];
        iUtoG6PlusVtoG6 = g_iUtoG_WMV[pucCurrU[6]] + g_iVtoG_WMV[pucCurrV[6]];
        iUtoB6 = g_iUtoB_WMV[pucCurrU[6]];
        iYScale = g_iYscale_WMV[pucCurrY[12]];
        pBits [50] = rgiClapTab [(iYScale + iVtoR6)]; // r
        pBits [49] = rgiClapTab [(iYScale - iUtoG6PlusVtoG6)]; // g
        pBits [48] = rgiClapTab [(iYScale + iUtoB6)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[13]];
        pBits [54] = rgiClapTab [(iYScale + iVtoR6)]; // r
        pBits [53] = rgiClapTab [(iYScale - iUtoG6PlusVtoG6)]; // g
        pBits [52] = rgiClapTab [(iYScale + iUtoB6)]; // b

        iVtoR7 = g_iVtoR_WMV[pucCurrV[7]];
        iUtoG7PlusVtoG7 = g_iUtoG_WMV[pucCurrU[7]] + g_iVtoG_WMV[pucCurrV[7]];
        iUtoB7 = g_iUtoB_WMV[pucCurrU[7]];
        iYScale = g_iYscale_WMV[pucCurrY[14]];
        pBits [58] = rgiClapTab [(iYScale + iVtoR7)]; // r
        pBits [57] = rgiClapTab [(iYScale - iUtoG7PlusVtoG7)]; // g
        pBits [56] = rgiClapTab [(iYScale + iUtoB7)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[15]];
        pBits [62] = rgiClapTab [(iYScale + iVtoR7)]; // r
        pBits [61] = rgiClapTab [(iYScale - iUtoG7PlusVtoG7)]; // g
        pBits [60] = rgiClapTab [(iYScale + iUtoB7)]; // b

        pucCurrY += iWidthY;
        pucCurrU += iWidthUV;
        pucCurrV += iWidthUV;

        pBits += iBitmapWidth;

        iYScale = g_iYscale_WMV[pucCurrY[0]];
        pBits [2] = rgiClapTab [(iYScale + iVtoR0)]; // r
        pBits [1] = rgiClapTab [(iYScale - iUtoG0PlusVtoG0)]; // g
        pBits [0] = rgiClapTab [(iYScale + iUtoB0)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[1]];
        pBits [6] = rgiClapTab [(iYScale + iVtoR0)]; // r
        pBits [5] = rgiClapTab [(iYScale - iUtoG0PlusVtoG0)]; // g
        pBits [4] = rgiClapTab [(iYScale + iUtoB0)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[2]];
        pBits [10] = rgiClapTab [(iYScale + iVtoR1)]; // r
        pBits [9] = rgiClapTab [(iYScale - iUtoG1PlusVtoG1)]; // g
        pBits [8] = rgiClapTab [(iYScale + iUtoB1)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[3]];
        pBits [14] = rgiClapTab [(iYScale + iVtoR1)]; // r
        pBits [13] = rgiClapTab [(iYScale - iUtoG1PlusVtoG1)]; // g
        pBits [12] = rgiClapTab [(iYScale + iUtoB1)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[4]];
        pBits [18] = rgiClapTab [(iYScale + iVtoR2)]; // r
        pBits [17] = rgiClapTab [(iYScale - iUtoG2PlusVtoG2)]; // g
        pBits [16] = rgiClapTab [(iYScale + iUtoB2)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[5]];
        pBits [22] = rgiClapTab [(iYScale + iVtoR2)]; // r
        pBits [21] = rgiClapTab [(iYScale - iUtoG2PlusVtoG2)]; // g
        pBits [20] = rgiClapTab [(iYScale + iUtoB2)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[6]];
        pBits [26] = rgiClapTab [(iYScale + iVtoR3)]; // r
        pBits [25] = rgiClapTab [(iYScale - iUtoG3PlusVtoG3)]; // g
        pBits [24] = rgiClapTab [(iYScale + iUtoB3)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[7]];
        pBits [30] = rgiClapTab [(iYScale + iVtoR3)]; // r
        pBits [29] = rgiClapTab [(iYScale - iUtoG3PlusVtoG3)]; // g
        pBits [28] = rgiClapTab [(iYScale + iUtoB3)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[8]];
        pBits [34] = rgiClapTab [(iYScale + iVtoR4)]; // r
        pBits [33] = rgiClapTab [(iYScale - iUtoG4PlusVtoG4)]; // g
        pBits [32] = rgiClapTab [(iYScale + iUtoB4)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[9]];
        pBits [38] = rgiClapTab [(iYScale + iVtoR4)]; // r
        pBits [37] = rgiClapTab [(iYScale - iUtoG4PlusVtoG4)]; // g
        pBits [36] = rgiClapTab [(iYScale + iUtoB4)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[10]];
        pBits [42] = rgiClapTab [(iYScale + iVtoR5)]; // r
        pBits [41] = rgiClapTab [(iYScale - iUtoG5PlusVtoG5)]; // g
        pBits [40] = rgiClapTab [(iYScale + iUtoB5)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[11]];
        pBits [46] = rgiClapTab [(iYScale + iVtoR5)]; // r
        pBits [45] = rgiClapTab [(iYScale - iUtoG5PlusVtoG5)]; // g
        pBits [44] = rgiClapTab [(iYScale + iUtoB5)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[12]];
        pBits [50] = rgiClapTab [(iYScale + iVtoR6)]; // r
        pBits [49] = rgiClapTab [(iYScale - iUtoG6PlusVtoG6)]; // g
        pBits [48] = rgiClapTab [(iYScale + iUtoB6)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[13]];
        pBits [54] = rgiClapTab [(iYScale + iVtoR6)]; // r
        pBits [53] = rgiClapTab [(iYScale - iUtoG6PlusVtoG6)]; // g
        pBits [52] = rgiClapTab [(iYScale + iUtoB6)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[14]];
        pBits [58] = rgiClapTab [(iYScale + iVtoR7)]; // r
        pBits [57] = rgiClapTab [(iYScale - iUtoG7PlusVtoG7)]; // g
        pBits [56] = rgiClapTab [(iYScale + iUtoB7)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[15]];
        pBits [62] = rgiClapTab [(iYScale + iVtoR7)]; // r
        pBits [61] = rgiClapTab [(iYScale - iUtoG7PlusVtoG7)]; // g
        pBits [60] = rgiClapTab [(iYScale + iUtoB7)]; // b

        pucCurrY += iWidthY;

        pBits += iBitmapWidth;
    }
}
  
Void_WMV WMVideoDecUpdateDstBlkRGB32 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
) {
    const U8_WMV* rgiClapTab = pWMVDec->m_rgiClapTabDec; 

    U32_WMV iy;
    for (iy = 0; iy < SUB_BLOCK_SIZE; iy++) {
        I32_WMV iVtoR0, iUtoG0PlusVtoG0, iUtoB0;
        I32_WMV iVtoR1, iUtoG1PlusVtoG1, iUtoB1;
        I32_WMV iVtoR2, iUtoG2PlusVtoG2, iUtoB2;
        I32_WMV iVtoR3, iUtoG3PlusVtoG3, iUtoB3;
        I32_WMV iYScale;

        iVtoR0 = g_iVtoR_WMV [pucCurrV[0]];
        iUtoG0PlusVtoG0 = g_iUtoG_WMV [pucCurrU[0]] + g_iVtoG_WMV [pucCurrV[0]];
        iUtoB0 = g_iUtoB_WMV [pucCurrU[0]];
        iYScale = g_iYscale_WMV[pucCurrY[0]];
        pBits [2] = rgiClapTab [(iYScale + iVtoR0)]; // r
        pBits [1] = rgiClapTab [(iYScale - iUtoG0PlusVtoG0)]; // g
        pBits [0] = rgiClapTab [(iYScale + iUtoB0)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[1]];
        pBits [6] = rgiClapTab [(iYScale + iVtoR0)]; // r
        pBits [5] = rgiClapTab [(iYScale - iUtoG0PlusVtoG0)]; // g
        pBits [4] = rgiClapTab [(iYScale + iUtoB0)]; // b

        iVtoR1 = g_iVtoR_WMV[pucCurrV[1]];
        iUtoG1PlusVtoG1 = g_iUtoG_WMV[pucCurrU[1]] + g_iVtoG_WMV[pucCurrV[1]];
        iUtoB1 = g_iUtoB_WMV[pucCurrU[1]];
        iYScale = g_iYscale_WMV[pucCurrY[2]];
        pBits [10] = rgiClapTab [(iYScale + iVtoR1)]; // r
        pBits [9] = rgiClapTab [(iYScale - iUtoG1PlusVtoG1)]; // g
        pBits [8] = rgiClapTab [(iYScale + iUtoB1)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[3]];
        pBits [14] = rgiClapTab [(iYScale + iVtoR1)]; // r
        pBits [13] = rgiClapTab [(iYScale - iUtoG1PlusVtoG1)]; // g
        pBits [12] = rgiClapTab [(iYScale + iUtoB1)]; // b

        iVtoR2 = g_iVtoR_WMV[pucCurrV[2]];
        iUtoG2PlusVtoG2 = g_iUtoG_WMV[pucCurrU[2]] + g_iVtoG_WMV[pucCurrV[2]];
        iUtoB2 = g_iUtoB_WMV[pucCurrU[2]];
        iYScale = g_iYscale_WMV[pucCurrY[4]];
        pBits [18] = rgiClapTab [(iYScale + iVtoR2)]; // r
        pBits [17] = rgiClapTab [(iYScale - iUtoG2PlusVtoG2)]; // g
        pBits [16] = rgiClapTab [(iYScale + iUtoB2)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[5]];
        pBits [22] = rgiClapTab [(iYScale + iVtoR2)]; // r
        pBits [21] = rgiClapTab [(iYScale - iUtoG2PlusVtoG2)]; // g
        pBits [20] = rgiClapTab [(iYScale + iUtoB2)]; // b

        iVtoR3 = g_iVtoR_WMV[pucCurrV[3]];
        iUtoG3PlusVtoG3 = g_iUtoG_WMV[pucCurrU[3]] + g_iVtoG_WMV[pucCurrV[3]];
        iUtoB3 = g_iUtoB_WMV[pucCurrU[3]];
        iYScale = g_iYscale_WMV[pucCurrY[6]];
        pBits [26] = rgiClapTab [(iYScale + iVtoR3)]; // r
        pBits [25] = rgiClapTab [(iYScale - iUtoG3PlusVtoG3)]; // g
        pBits [24] = rgiClapTab [(iYScale + iUtoB3)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[7]];
        pBits [30] = rgiClapTab [(iYScale + iVtoR3)]; // r
        pBits [29] = rgiClapTab [(iYScale - iUtoG3PlusVtoG3)]; // g
        pBits [28] = rgiClapTab [(iYScale + iUtoB3)]; // b

        pucCurrY += iWidthY;
        pucCurrU += iWidthUV;
        pucCurrV += iWidthUV;

        pBits += iBitmapWidth;

        iYScale = g_iYscale_WMV[pucCurrY[0]];
        pBits [2] = rgiClapTab [(iYScale + iVtoR0)]; // r
        pBits [1] = rgiClapTab [(iYScale - iUtoG0PlusVtoG0)]; // g
        pBits [0] = rgiClapTab [(iYScale + iUtoB0)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[1]];
        pBits [6] = rgiClapTab [(iYScale + iVtoR0)]; // r
        pBits [5] = rgiClapTab [(iYScale - iUtoG0PlusVtoG0)]; // g
        pBits [4] = rgiClapTab [(iYScale + iUtoB0)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[2]];
        pBits [10] = rgiClapTab [(iYScale + iVtoR1)]; // r
        pBits [9] = rgiClapTab [(iYScale - iUtoG1PlusVtoG1)]; // g
        pBits [8] = rgiClapTab [(iYScale + iUtoB1)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[3]];
        pBits [14] = rgiClapTab [(iYScale + iVtoR1)]; // r
        pBits [13] = rgiClapTab [(iYScale - iUtoG1PlusVtoG1)]; // g
        pBits [12] = rgiClapTab [(iYScale + iUtoB1)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[4]];
        pBits [18] = rgiClapTab [(iYScale + iVtoR2)]; // r
        pBits [17] = rgiClapTab [(iYScale - iUtoG2PlusVtoG2)]; // g
        pBits [16] = rgiClapTab [(iYScale + iUtoB2)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[5]];
        pBits [22] = rgiClapTab [(iYScale + iVtoR2)]; // r
        pBits [21] = rgiClapTab [(iYScale - iUtoG2PlusVtoG2)]; // g
        pBits [20] = rgiClapTab [(iYScale + iUtoB2)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[6]];
        pBits [26] = rgiClapTab [(iYScale + iVtoR3)]; // r
        pBits [25] = rgiClapTab [(iYScale - iUtoG3PlusVtoG3)]; // g
        pBits [24] = rgiClapTab [(iYScale + iUtoB3)]; // b

        iYScale = g_iYscale_WMV[pucCurrY[7]];
        pBits [30] = rgiClapTab [(iYScale + iVtoR3)]; // r
        pBits [29] = rgiClapTab [(iYScale - iUtoG3PlusVtoG3)]; // g
        pBits [28] = rgiClapTab [(iYScale + iUtoB3)]; // b

        pucCurrY += iWidthY;

        pBits += iBitmapWidth;
    }
}

#endif // defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_RGB32)

#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_YUY2)

Void_WMV WMVideoDecUpdateDstPartialMBYUY2 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iRgbWidth, I32_WMV iRgbHeight
) {
//
// Temporary macroblock-sized buffer.  YUY2 is packed as follows:
//
// Y0 U0 Y1 V0    Y2 U2 Y3 V2    Y4 U4 Y5 V4
//
// Pixels 0,1     Pixels 2,3     Pixels 4,5
//
// Width must be a multiple of two.  Two pixels is four bytes, so effectively, 
// a pixel is two bytes.  If in some wierd situation we're given a bitmap
// into which we have to write an odd number of pixels, we'll just leave the
// last pixel undone.
//
    U8_WMV  mb[MB_SIZE * 2 * MB_SIZE + 8];
    U8_WMV *pBitsMb = mb;
    I32_WMV i;

    iRgbWidth &= ~1;
//
// Now color-space convert the macroblock into the buffer.
//
    pBitsMb = (U8_WMV*) (((ULONG_PTR) pBitsMb + 7) & ~7);
    WMVideoDecUpdateDstMBYUY2 (
        pWMVDec,
        pBitsMb,
        pucCurrY,
        pucCurrU,
        pucCurrV,
        iWidthY,
        iWidthUV,
        MB_SIZE * 2);

//
// And, copy the valid pixels from the buffer into the bitmap.
//
    for (i = 0; i < iRgbHeight; ++i) {
        memcpy(pBits, pBitsMb, iRgbWidth * 2);

        pBitsMb += MB_SIZE * 2;
        pBits += pWMVDec->m_iWidthBMP;
    }
}

Void_WMV WMVideoDecUpdateDstMBYUY2 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
) {
    #define MMX_YUY2_SHUFFLING
    #ifdef MMX_YUY2_SHUFFLING

    #define ASSERT_ALIGN8(x) assert(((ULONG_PTR) (x) & 7) == 0)
    ASSERT_ALIGN8(pBits);
    ASSERT_ALIGN8(pucCurrY);
    ASSERT_ALIGN8(pucCurrU);
    ASSERT_ALIGN8(pucCurrV);
    ASSERT_ALIGN8(iBitmapWidth);
    ASSERT_ALIGN8(iWidthY);
    ASSERT_ALIGN8(iWidthUV);

    __asm {
        mov         esi, pucCurrY
        mov         edi, pBits
        mov         ecx, pucCurrU
        mov         edx, pucCurrV
        mov         eax, BLOCK_SIZE

    L1: movq        mm2, [ecx]          ; 8 U values
        movq        mm3, [edx]          ; 8 V values
        pxor        mm4, mm4
        pxor        mm6, mm6
        pxor        mm0, mm0
        pxor        mm1, mm1
        punpcklbw   mm4, mm2
        punpckhbw   mm6, mm2
        movq        mm5, mm4
        movq        mm7, mm6
        punpckhwd   mm5, mm0            ; spread Us into 4 MMX registers
        punpckhwd   mm7, mm0            ;   ..u...u...u...u...u...u...u...u.
        punpcklwd   mm4, mm0
        punpcklwd   mm6, mm0

        pxor        mm2, mm2
        add         ecx, iWidthUV
        add         edx, iWidthUV

        punpcklbw   mm0, mm3            ; spread Vs and then OR them into Us 
        punpcklwd   mm1, mm0            ;   v.u.v.u.v.u.v.u.v.u.v.u.v.u.v.u.
        punpckhwd   mm2, mm0
        por         mm4, mm1
        por         mm5, mm2

        movq        mm0, [esi]          ; 16 Y values from the current line
        movq        mm1, [esi+8]

        pxor        mm2, mm2
        punpckhbw   mm2, mm3
        pxor        mm3, mm3
        punpcklwd   mm3, mm2
        por         mm6, mm3
        pxor        mm3, mm3
        punpckhwd   mm3, mm2
        por         mm7, mm3

        add         esi, iWidthY        ; spread Ys and output the final results
        pxor        mm2, mm2            ;   vyuyvyuyvyuyvyuyvyuyvyuyvyuyvyuy
        movq        mm3, mm0
        punpcklbw   mm0, mm2
        por         mm0, mm4
        movq        [edi], mm0          ; notice that we output 32 bytes (4 qwords)
        punpckhbw   mm3, mm2            ; without any intervening memory access
        por         mm3, mm5            ; to achieve maximum memory write perf
        movq        [edi+8], mm3
        movq        mm3, mm1
        punpcklbw   mm1, mm2
        por         mm1, mm6
        movq        [edi+16], mm1
        punpckhbw   mm3, mm2
        por         mm3, mm7
        movq        [edi+24], mm3

        movq        mm0, [esi]          ; 16 Y values from the next line
        movq        mm1, [esi+8]
        add         edi, iBitmapWidth
        pxor        mm2, mm2
        movq        mm3, mm0
        punpcklbw   mm0, mm2
        por         mm0, mm4
        movq        [edi], mm0
        punpckhbw   mm3, mm2
        por         mm3, mm5
        movq        [edi+8], mm3
        movq        mm3, mm1
        punpcklbw   mm1, mm2
        por         mm1, mm6
        movq        [edi+16], mm1
        punpckhbw   mm3, mm2
        por         mm3, mm7
        movq        [edi+24], mm3

        add         esi, iWidthY
        add         edi, iBitmapWidth
        dec         eax
        jnz         L1
        emms
    }

    #else // !MMX_YUY2_SHUFFLING

    I32_WMV i;
    for (i = 0; i < BLOCK_SIZE; i++) {        
        U8_WMV *pBitsNextLine = pBits + iBitmapWidth;
        const U8_WMV *ppxliCurrQYMBNextLine = pucCurrY + iWidthY;

        I32_WMV ipxliUV =                   (((I32_WMV)pucCurrU [0])<<8) | (((I32_WMV)pucCurrV [0])<<24);
        (*(I32_WMV *)pBits) =               (ipxliUV | ((I32_WMV)pucCurrY [0]) | (((I32_WMV)pucCurrY [1])<<16));
        (*(I32_WMV *)pBitsNextLine) =       (ipxliUV | ((I32_WMV)ppxliCurrQYMBNextLine [0]) | (((I32_WMV)ppxliCurrQYMBNextLine [1])<<16));

        ipxliUV =                       (((I32_WMV)pucCurrU [1])<<8) | (((I32_WMV)pucCurrV [1])<<24);
        (*(I32_WMV *)(pBits+4)) =           (ipxliUV | ((I32_WMV)pucCurrY [2]) | (((I32_WMV)pucCurrY [3])<<16));
        (*(I32_WMV *)(pBitsNextLine+4)) =   (ipxliUV | ((I32_WMV)ppxliCurrQYMBNextLine [2]) | (((I32_WMV)ppxliCurrQYMBNextLine [3])<<16));

        ipxliUV =                       (((I32_WMV)pucCurrU [2])<<8) | (((I32_WMV)pucCurrV [2])<<24);
        (*(I32_WMV *)(pBits+8)) =           (ipxliUV | ((I32_WMV)pucCurrY [4]) | (((I32_WMV)pucCurrY [5])<<16));
        (*(I32_WMV *)(pBitsNextLine+8)) =   (ipxliUV | ((I32_WMV)ppxliCurrQYMBNextLine [4]) | (((I32_WMV)ppxliCurrQYMBNextLine [5])<<16));

        ipxliUV =                       (((I32_WMV)pucCurrU [3])<<8) | (((I32_WMV)pucCurrV [3])<<24);
        (*(I32_WMV *)(pBits+12)) =          (ipxliUV | ((I32_WMV)pucCurrY [6]) | (((I32_WMV)pucCurrY [7])<<16));
        (*(I32_WMV *)(pBitsNextLine+12)) =  (ipxliUV | ((I32_WMV)ppxliCurrQYMBNextLine [6]) | (((I32_WMV)ppxliCurrQYMBNextLine [7])<<16));

        ipxliUV =                       (((I32_WMV)pucCurrU [4])<<8) | (((I32_WMV)pucCurrV [4])<<24);
        (*(I32_WMV *)(pBits+16)) =          (ipxliUV | ((I32_WMV)pucCurrY [8]) | (((I32_WMV)pucCurrY [9])<<16));
        (*(I32_WMV *)(pBitsNextLine+16)) =  (ipxliUV | ((I32_WMV)ppxliCurrQYMBNextLine [8]) | (((I32_WMV)ppxliCurrQYMBNextLine [9])<<16));
        
        ipxliUV =                       (((I32_WMV)pucCurrU [5])<<8) | (((I32_WMV)pucCurrV [5])<<24);
        (*(I32_WMV *)(pBits+20)) =          (ipxliUV | ((I32_WMV)pucCurrY [10]) | (((I32_WMV)pucCurrY [11])<<16));
        (*(I32_WMV *)(pBitsNextLine+20)) =  (ipxliUV | ((I32_WMV)ppxliCurrQYMBNextLine [10]) | (((I32_WMV)ppxliCurrQYMBNextLine [11])<<16));

        ipxliUV =                       (((I32_WMV)pucCurrU [6])<<8) | (((I32_WMV)pucCurrV [6])<<24);
        (*(I32_WMV *)(pBits+24)) =          (ipxliUV | ((I32_WMV)pucCurrY [12]) | (((I32_WMV)pucCurrY [13])<<16));
        (*(I32_WMV *)(pBitsNextLine+24)) =  (ipxliUV | ((I32_WMV)ppxliCurrQYMBNextLine [12]) | (((I32_WMV)ppxliCurrQYMBNextLine [13])<<16));

        ipxliUV =                       (((I32_WMV)pucCurrU [7])<<8) | (((I32_WMV)pucCurrV [7])<<24);
        (*(I32_WMV *)(pBits+28)) =          (ipxliUV | ((I32_WMV)pucCurrY [14]) | (((I32_WMV)pucCurrY [15])<<16));
        (*(I32_WMV *)(pBitsNextLine+28)) =  (ipxliUV | ((I32_WMV)ppxliCurrQYMBNextLine [14]) | (((I32_WMV)ppxliCurrQYMBNextLine [15])<<16));

        pBits = pBitsNextLine + iBitmapWidth;
        pucCurrY = ppxliCurrQYMBNextLine + iWidthY;
        pucCurrU += iWidthUV;
        pucCurrV += iWidthUV;
    }

    #endif // !MMX_YUY2_SHUFFLING
}

Void_WMV WMVideoDecUpdateDstBlkYUY2 (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
) {
    I32_WMV i;
    for (i = 0; i < SUB_BLOCK_SIZE; i++) {
        
        U8_WMV *pBitsNextLine = pBits + iBitmapWidth;
        const U8_WMV *ppxliCurrQYMBNextLine = pucCurrY + iWidthY;

        I32_WMV ipxliUV =                   (((I32_WMV)pucCurrU [0])<<8) | (((I32_WMV)pucCurrV [0])<<24);
        (*(I32_WMV *)pBits) =               (ipxliUV | ((I32_WMV)pucCurrY [0]) | (((I32_WMV)pucCurrY [1])<<16));
        (*(I32_WMV *)pBitsNextLine) =       (ipxliUV | ((I32_WMV)ppxliCurrQYMBNextLine [0]) | (((I32_WMV)ppxliCurrQYMBNextLine [1])<<16));

        ipxliUV =                       (((I32_WMV)pucCurrU [1])<<8) | (((I32_WMV)pucCurrV [1])<<24);
        (*(I32_WMV *)(pBits+4)) =           (ipxliUV | ((I32_WMV)pucCurrY [2]) | (((I32_WMV)pucCurrY [3])<<16));
        (*(I32_WMV *)(pBitsNextLine+4)) =   (ipxliUV | ((I32_WMV)ppxliCurrQYMBNextLine [2]) | (((I32_WMV)ppxliCurrQYMBNextLine [3])<<16));

        ipxliUV =                       (((I32_WMV)pucCurrU [2])<<8) | (((I32_WMV)pucCurrV [2])<<24);
        (*(I32_WMV *)(pBits+8)) =           (ipxliUV | ((I32_WMV)pucCurrY [4]) | (((I32_WMV)pucCurrY [5])<<16));
        (*(I32_WMV *)(pBitsNextLine+8)) =   (ipxliUV | ((I32_WMV)ppxliCurrQYMBNextLine [4]) | (((I32_WMV)ppxliCurrQYMBNextLine [5])<<16));

        ipxliUV =                       (((I32_WMV)pucCurrU [3])<<8) | (((I32_WMV)pucCurrV [3])<<24);
        (*(I32_WMV *)(pBits+12)) =          (ipxliUV | ((I32_WMV)pucCurrY [6]) | (((I32_WMV)pucCurrY [7])<<16));
        (*(I32_WMV *)(pBitsNextLine+12)) =  (ipxliUV | ((I32_WMV)ppxliCurrQYMBNextLine [6]) | (((I32_WMV)ppxliCurrQYMBNextLine [7])<<16));

        pBits = pBitsNextLine + iBitmapWidth;
        pucCurrY = ppxliCurrQYMBNextLine + iWidthY;
        pucCurrU += iWidthUV;
        pucCurrV += iWidthUV;
    }
}

#endif // defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_YUY2)

#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_UYVY)

Void_WMV WMVideoDecUpdateDstPartialMBUYVY (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iRgbWidth, I32_WMV iRgbHeight
) {
//
// Temporary macroblock-sized buffer.  UYVY is packed as follows:
//
// U0 Y0 V0 Y1    U2 Y2 V2 Y3    U4 Y4 V4 Y5
//
// Pixels 0,1     Pixels 2,3     Pixels 4,5
//
// Width must be a multiple of two.  Two pixels is four bytes, so effectively, 
// a pixel is two bytes.  If in some wierd situation we're given a bitmap
// into which we have to write an odd number of pixels, we'll just leave the
// last pixel undone.
//

    U8_WMV mb[MB_SIZE * 2 * MB_SIZE];
    U8_WMV *pBitsMb;
    I32_WMV i;

    iRgbWidth &= ~1;
//
// Now color-space convert the macroblock into the buffer.
//
    WMVideoDecUpdateDstMBUYVY(
        pWMVDec,
        (U8_WMV *)mb,
        pucCurrY,
        pucCurrU,
        pucCurrV,
        iWidthY,
        iWidthUV,
        MB_SIZE * 2);
//
// And, copy the valid pixels from the buffer into the bitmap.
//
    pBitsMb = mb;
    for (i = 0; i < iRgbHeight; ++i) {
        memcpy(pBits, pBitsMb, iRgbWidth * 2);

        pBitsMb += MB_SIZE * 2;
        pBits += pWMVDec->m_iWidthBMP;
    }
}

Void_WMV WMVideoDecUpdateDstMBUYVY (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
) {
    I32_WMV i;
    for (i = 0; i < BLOCK_SIZE; i++) {
        
        U8_WMV *pBitsNextLine = pBits + iBitmapWidth;
        const U8_WMV *ppxliCurrQYMBNextLine = pucCurrY + iWidthY;

        I32_WMV ipxliUV =                   ((I32_WMV)pucCurrU [0]) | (((I32_WMV)pucCurrV [0])<<16);
        (*(I32_WMV *)pBits) =               (ipxliUV | (((I32_WMV)pucCurrY [0])<<8) | (((I32_WMV)pucCurrY [1])<<24));
        (*(I32_WMV *)pBitsNextLine) =       (ipxliUV | (((I32_WMV)ppxliCurrQYMBNextLine [0])<<8) | (((I32_WMV)ppxliCurrQYMBNextLine [1])<<24));

        ipxliUV =                       ((I32_WMV)pucCurrU [1]) | (((I32_WMV)pucCurrV [1])<<16);
        (*(I32_WMV *)(pBits+4)) =           (ipxliUV | (((I32_WMV)pucCurrY [2])<<8) | (((I32_WMV)pucCurrY [3])<<24));
        (*(I32_WMV *)(pBitsNextLine+4)) =   (ipxliUV | (((I32_WMV)ppxliCurrQYMBNextLine [2])<<8) | (((I32_WMV)ppxliCurrQYMBNextLine [3])<<24));

        ipxliUV =                       ((I32_WMV)pucCurrU [2]) | (((I32_WMV)pucCurrV [2])<<16);
        (*(I32_WMV *)(pBits+8)) =           (ipxliUV | (((I32_WMV)pucCurrY [4])<<8) | (((I32_WMV)pucCurrY [5])<<24));
        (*(I32_WMV *)(pBitsNextLine+8)) =   (ipxliUV | (((I32_WMV)ppxliCurrQYMBNextLine [4])<<8) | (((I32_WMV)ppxliCurrQYMBNextLine [5])<<24));

        ipxliUV =                       ((I32_WMV)pucCurrU [3]) | (((I32_WMV)pucCurrV [3])<<16);
        (*(I32_WMV *)(pBits+12)) =          (ipxliUV | (((I32_WMV)pucCurrY [6])<<8) | (((I32_WMV)pucCurrY [7])<<24));
        (*(I32_WMV *)(pBitsNextLine+12)) =  (ipxliUV | (((I32_WMV)ppxliCurrQYMBNextLine [6])<<8) | (((I32_WMV)ppxliCurrQYMBNextLine [7])<<24));

        ipxliUV =                       ((I32_WMV)pucCurrU [4]) | (((I32_WMV)pucCurrV [4])<<16);
        (*(I32_WMV *)(pBits+16)) =          (ipxliUV | (((I32_WMV)pucCurrY [8])<<8) | (((I32_WMV)pucCurrY [9])<<24));
        (*(I32_WMV *)(pBitsNextLine+16)) =  (ipxliUV | (((I32_WMV)ppxliCurrQYMBNextLine [8])<<8) | (((I32_WMV)ppxliCurrQYMBNextLine [9])<<24));
        
        ipxliUV =                       ((I32_WMV)pucCurrU [5]) | (((I32_WMV)pucCurrV [5])<<16);
        (*(I32_WMV *)(pBits+20)) =          (ipxliUV | (((I32_WMV)pucCurrY [10])<<8) | (((I32_WMV)pucCurrY [11])<<24));
        (*(I32_WMV *)(pBitsNextLine+20)) =  (ipxliUV | (((I32_WMV)ppxliCurrQYMBNextLine [10])<<8) | (((I32_WMV)ppxliCurrQYMBNextLine [11])<<24));

        ipxliUV =                       ((I32_WMV)pucCurrU [6]) | (((I32_WMV)pucCurrV [6])<<16);
        (*(I32_WMV *)(pBits+24)) =          (ipxliUV | (((I32_WMV)pucCurrY [12])<<8) | (((I32_WMV)pucCurrY [13])<<24));
        (*(I32_WMV *)(pBitsNextLine+24)) =  (ipxliUV | (((I32_WMV)ppxliCurrQYMBNextLine [12])<<8) | (((I32_WMV)ppxliCurrQYMBNextLine [13])<<24));

        ipxliUV =                       ((I32_WMV)pucCurrU [7]) | (((I32_WMV)pucCurrV [7])<<16);
        (*(I32_WMV *)(pBits+28)) =          (ipxliUV | (((I32_WMV)pucCurrY [14])<<8) | (((I32_WMV)pucCurrY [15])<<24));
        (*(I32_WMV *)(pBitsNextLine+28)) =  (ipxliUV | (((I32_WMV)ppxliCurrQYMBNextLine [14])<<8) | (((I32_WMV)ppxliCurrQYMBNextLine [15])<<24));

        pBits = pBitsNextLine + iBitmapWidth;
        pucCurrY = ppxliCurrQYMBNextLine + iWidthY;
        pucCurrU += iWidthUV;
        pucCurrV += iWidthUV;
    }
}

Void_WMV WMVideoDecUpdateDstBlkUYVY (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
) {
    I32_WMV i;
    for (i = 0; i < SUB_BLOCK_SIZE; i++) {
        
        U8_WMV *pBitsNextLine = pBits + iBitmapWidth;
        const U8_WMV *ppxliCurrQYMBNextLine = pucCurrY + iWidthY;

        I32_WMV ipxliUV =                   ((I32_WMV)pucCurrU [0]) | (((I32_WMV)pucCurrV [0])<<16);
        (*(I32_WMV *)pBits) =               (ipxliUV | (((I32_WMV)pucCurrY [0])<<8) | (((I32_WMV)pucCurrY [1])<<24));
        (*(I32_WMV *)pBitsNextLine) =       (ipxliUV | (((I32_WMV)ppxliCurrQYMBNextLine [0])<<8) | (((I32_WMV)ppxliCurrQYMBNextLine [1])<<24));

        ipxliUV =                       ((I32_WMV)pucCurrU [1]) | (((I32_WMV)pucCurrV [1])<<16);
        (*(I32_WMV *)(pBits+4)) =           (ipxliUV | (((I32_WMV)pucCurrY [2])<<8) | (((I32_WMV)pucCurrY [3])<<24));
        (*(I32_WMV *)(pBitsNextLine+4)) =   (ipxliUV | (((I32_WMV)ppxliCurrQYMBNextLine [2])<<8) | (((I32_WMV)ppxliCurrQYMBNextLine [3])<<24));

        ipxliUV =                       ((I32_WMV)pucCurrU [2]) | (((I32_WMV)pucCurrV [2])<<16);
        (*(I32_WMV *)(pBits+8)) =           (ipxliUV | (((I32_WMV)pucCurrY [4])<<8) | (((I32_WMV)pucCurrY [5])<<24));
        (*(I32_WMV *)(pBitsNextLine+8)) =   (ipxliUV | (((I32_WMV)ppxliCurrQYMBNextLine [4])<<8) | (((I32_WMV)ppxliCurrQYMBNextLine [5])<<24));

        ipxliUV =                       ((I32_WMV)pucCurrU [3]) | (((I32_WMV)pucCurrV [3])<<16);
        (*(I32_WMV *)(pBits+12)) =          (ipxliUV | (((I32_WMV)pucCurrY [6])<<8) | (((I32_WMV)pucCurrY [7])<<24));
        (*(I32_WMV *)(pBitsNextLine+12)) =  (ipxliUV | (((I32_WMV)ppxliCurrQYMBNextLine [6])<<8) | (((I32_WMV)ppxliCurrQYMBNextLine [7])<<24));

        pBits = pBitsNextLine + iBitmapWidth;
        pucCurrY = ppxliCurrQYMBNextLine + iWidthY;
        pucCurrU += iWidthUV;
        pucCurrV += iWidthUV;
    }
}

#endif // defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_YUY2)


#if defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_YVYU)

Void_WMV WMVideoDecUpdateDstPartialMBYVYU (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iRgbWidth, I32_WMV iRgbHeight
) {
//
// Temporary macroblock-sized buffer.  YVYU is packed as follows:
//
// Y0 V0 Y1 U0    Y2 V2 Y3 U2    Y4 V4 Y5 U4 
//
// Pixels 0,1     Pixels 2,3     Pixels 4,5
//
// Width must be a multiple of two.  Two pixels is four bytes, so effectively, 
// a pixel is two bytes.  If in some wierd situation we're given a bitmap
// into which we have to write an odd number of pixels, we'll just leave the
// last pixel undone.
//
    U8_WMV  mb[MB_SIZE * 2 * MB_SIZE];
    U8_WMV *pBitsMb;
    I32_WMV i;

    iRgbWidth &= ~1;

//
// Now color-space convert the macroblock into the buffer.
//
    WMVideoDecUpdateDstMBYVYU(
        pWMVDec,
        (U8_WMV *)mb,
        pucCurrY,
        pucCurrU,
        pucCurrV,
        iWidthY,
        iWidthUV,
        MB_SIZE * 2);
//
// And, copy the valid pixels from the buffer into the bitmap.
//
    pBitsMb = mb;
    for (i = 0; i < iRgbHeight; ++i) {
        memcpy(pBits, pBitsMb, iRgbWidth * 2);

        pBitsMb += MB_SIZE * 2;
        pBits += pWMVDec->m_iWidthBMP;
    }
}

Void_WMV WMVideoDecUpdateDstMBYVYU (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
) {
    I32_WMV i;
    for (i = 0; i < BLOCK_SIZE; i++) {
        
        U8_WMV *pBitsNextLine = pBits + iBitmapWidth;
        const U8_WMV *ppxliCurrQYMBNextLine = pucCurrY + iWidthY;

        I32_WMV ipxliUV =                   ((I32_WMV)pucCurrU [0]<<24) | (((I32_WMV)pucCurrV [0])<<8);
        (*(I32_WMV *)pBits) =               (ipxliUV | ((I32_WMV)pucCurrY [0]) | (((I32_WMV)pucCurrY [1])<<16));
        (*(I32_WMV *)pBitsNextLine) =       (ipxliUV | ((I32_WMV)ppxliCurrQYMBNextLine [0]) | (((I32_WMV)ppxliCurrQYMBNextLine [1])<<16));

        ipxliUV =                       ((I32_WMV)pucCurrU [1]<<24) | (((I32_WMV)pucCurrV [1])<<8);
        (*(I32_WMV *)(pBits+4)) =           (ipxliUV | ((I32_WMV)pucCurrY [2]) | (((I32_WMV)pucCurrY [3])<<16));
        (*(I32_WMV *)(pBitsNextLine+4)) =   (ipxliUV | ((I32_WMV)ppxliCurrQYMBNextLine [2]) | (((I32_WMV)ppxliCurrQYMBNextLine [3])<<16));

        ipxliUV =                       ((I32_WMV)pucCurrU [2]<<24) | (((I32_WMV)pucCurrV [2])<<8);
        (*(I32_WMV *)(pBits+8)) =           (ipxliUV | ((I32_WMV)pucCurrY [4]) | (((I32_WMV)pucCurrY [5])<<16));
        (*(I32_WMV *)(pBitsNextLine+8)) =   (ipxliUV | ((I32_WMV)ppxliCurrQYMBNextLine [4]) | (((I32_WMV)ppxliCurrQYMBNextLine [5])<<16));

        ipxliUV =                       ((I32_WMV)pucCurrU [3]<<24) | (((I32_WMV)pucCurrV [3])<<8);
        (*(I32_WMV *)(pBits+12)) =          (ipxliUV | ((I32_WMV)pucCurrY [6]) | (((I32_WMV)pucCurrY [7])<<16));
        (*(I32_WMV *)(pBitsNextLine+12)) =  (ipxliUV | ((I32_WMV)ppxliCurrQYMBNextLine [6]) | (((I32_WMV)ppxliCurrQYMBNextLine [7])<<16));

        ipxliUV =                       ((I32_WMV)pucCurrU [4]<<24) | (((I32_WMV)pucCurrV [4])<<8);
        (*(I32_WMV *)(pBits+16)) =          (ipxliUV | ((I32_WMV)pucCurrY [8]) | (((I32_WMV)pucCurrY [9])<<16));
        (*(I32_WMV *)(pBitsNextLine+16)) =  (ipxliUV | ((I32_WMV)ppxliCurrQYMBNextLine [8]) | (((I32_WMV)ppxliCurrQYMBNextLine [9])<<16));
        
        ipxliUV =                       ((I32_WMV)pucCurrU [5]<<24) | (((I32_WMV)pucCurrV [5])<<8);
        (*(I32_WMV *)(pBits+20)) =          (ipxliUV | ((I32_WMV)pucCurrY [10]) | (((I32_WMV)pucCurrY [11])<<16));
        (*(I32_WMV *)(pBitsNextLine+20)) =  (ipxliUV | ((I32_WMV)ppxliCurrQYMBNextLine [10]) | (((I32_WMV)ppxliCurrQYMBNextLine [11])<<16));

        ipxliUV =                       ((I32_WMV)pucCurrU [6]<<24) | (((I32_WMV)pucCurrV [6])<<8);
        (*(I32_WMV *)(pBits+24)) =          (ipxliUV | ((I32_WMV)pucCurrY [12]) | (((I32_WMV)pucCurrY [13])<<16));
        (*(I32_WMV *)(pBitsNextLine+24)) =  (ipxliUV | ((I32_WMV)ppxliCurrQYMBNextLine [12]) | (((I32_WMV)ppxliCurrQYMBNextLine [13])<<16));

        ipxliUV =                       ((I32_WMV)pucCurrU [7]<<24) | (((I32_WMV)pucCurrV [7])<<8);
        (*(I32_WMV *)(pBits+28)) =          (ipxliUV | ((I32_WMV)pucCurrY [14]) | (((I32_WMV)pucCurrY [15])<<16));
        (*(I32_WMV *)(pBitsNextLine+28)) =  (ipxliUV | ((I32_WMV)ppxliCurrQYMBNextLine [14]) | (((I32_WMV)ppxliCurrQYMBNextLine [15])<<16));

        pBits = pBitsNextLine + iBitmapWidth;
        pucCurrY = ppxliCurrQYMBNextLine + iWidthY;
        pucCurrU += iWidthUV;
        pucCurrV += iWidthUV;
    }
}

Void_WMV WMVideoDecUpdateDstBlkYVYU (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* pBits,
    const U8_WMV* pucCurrY, const U8_WMV* pucCurrU, const U8_WMV* pucCurrV,
    I32_WMV iWidthY, I32_WMV iWidthUV,
    I32_WMV iBitmapWidth
) {
    I32_WMV i;
    for (i = 0; i < SUB_BLOCK_SIZE; i++) {
        
        U8_WMV *pBitsNextLine = pBits + iBitmapWidth;
        const U8_WMV *ppxliCurrQYMBNextLine = pucCurrY + iWidthY;

        I32_WMV ipxliUV =                   ((I32_WMV)pucCurrU [0]<<24) | (((I32_WMV)pucCurrV [0])<<8);
        (*(I32_WMV *)pBits) =               (ipxliUV | ((I32_WMV)pucCurrY [0]) | (((I32_WMV)pucCurrY [1])<<16));
        (*(I32_WMV *)pBitsNextLine) =       (ipxliUV | ((I32_WMV)ppxliCurrQYMBNextLine [0]) | (((I32_WMV)ppxliCurrQYMBNextLine [1])<<16));

        ipxliUV =                       ((I32_WMV)pucCurrU [1]<<24) | (((I32_WMV)pucCurrV [1])<<8);
        (*(I32_WMV *)(pBits+4)) =           (ipxliUV | ((I32_WMV)pucCurrY [2]) | (((I32_WMV)pucCurrY [3])<<16));
        (*(I32_WMV *)(pBitsNextLine+4)) =   (ipxliUV | ((I32_WMV)ppxliCurrQYMBNextLine [2]) | (((I32_WMV)ppxliCurrQYMBNextLine [3])<<16));

        ipxliUV =                       ((I32_WMV)pucCurrU [2]<<24) | (((I32_WMV)pucCurrV [2])<<8);
        (*(I32_WMV *)(pBits+8)) =           (ipxliUV | ((I32_WMV)pucCurrY [4]) | (((I32_WMV)pucCurrY [5])<<16));
        (*(I32_WMV *)(pBitsNextLine+8)) =   (ipxliUV | ((I32_WMV)ppxliCurrQYMBNextLine [4]) | (((I32_WMV)ppxliCurrQYMBNextLine [5])<<16));

        ipxliUV =                       ((I32_WMV)pucCurrU [3]<<24) | (((I32_WMV)pucCurrV [3])<<8);
        (*(I32_WMV *)(pBits+12)) =          (ipxliUV | ((I32_WMV)pucCurrY [6]) | (((I32_WMV)pucCurrY [7])<<16));
        (*(I32_WMV *)(pBitsNextLine+12)) =  (ipxliUV | ((I32_WMV)ppxliCurrQYMBNextLine [6]) | (((I32_WMV)ppxliCurrQYMBNextLine [7])<<16));

        pBits = pBitsNextLine + iBitmapWidth;
        pucCurrY = ppxliCurrQYMBNextLine + iWidthY;
        pucCurrU += iWidthUV;
        pucCurrV += iWidthUV;
    }
}

#endif // defined (OUTPUT_ALL_FORMATS) || defined (OUTPUT_YVYU)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\dectable_mp4x.cpp ===
/*************************************************************************

Copyright (c) 1998  Microsoft Corporation

Module Name:

	dectable.cpp

Abstract:

	Decoder Huffmane tables 

Author:

	Bruce Lin (blin@microsoft.com) June-1998
	Ming-Chieh Lee (mingcl@microsoft.com) June-1998

Revision History:

*************************************************************************/
#include "bldsetup.h"

#include "xplatform.h"
#include "typedef.hpp"
#include "wmvdec_api.h"

#ifndef _WMVONLY_
U8_WMV gDecodeCodeTableCBPY[128] = {
  6, 16,  6, 17,  6,  6,  6,  9,  5,  8,  5,  8,  5,  4,  5,  4,  5,  2,  5,  2,  5,  1,  5,  1,  4,  0,
  4,  0,  4,  0,  4,  0,  4, 12,  4, 12,  4, 12,  4, 12,  4, 10,  4, 10,  4, 10,  4, 10,  4, 14,  4, 14,
  4, 14,  4, 14,  4,  5,  4,  5,  4,  5,  4,  5,  4, 13,  4, 13,  4, 13,  4, 13,  4,  3,  4,  3,  4,  3,
  4,  3,  4, 11,  4, 11,  4, 11,  4, 11,  4,  7,  4,  7,  4,  7,  4,  7,  2, 15,  2, 15,  2, 15,  2, 15,
  2, 15,  2, 15,  2, 15,  2, 15,  2, 15,  2, 15,  2, 15,  2, 15,  2, 15,  2, 15,  2, 15,  2, 15
};

U8_WMV gDecodeCodeTableMCBPCintra_New [16] = {
	3,  1,  3,  2,  2,  3,  2,  3,  1,  0,  1,  0,  1,  0,  1,  0
};


U8_WMV gDecodeCodeTableMCBPCinter_New [256] = {
  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,
  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,
  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  7,  6,  7,  5,  6,  7,  6,  7,  5,  3,  5,  3,  5,  3,
  5,  3,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  3,  2,  3,  2,  3,  2,  3,  2,
  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0
};

U8_WMV gDecodeCodeTableMCBPCintra[1024] = {
  0, 255,  9,  8,  0, 255,  0, 255,  0, 255,  0, 255,  0, 255,  0, 255,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,
  6,  5,  6,  5,  6,  5,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  7,  6,  7,
  6,  7,  6,  7,  6,  7,  6,  7,  6,  7,  6,  7,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  3,  1,
  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,
  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,
  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,
  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,
  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  1,  3,  2,  3,  2,
  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,
  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,
  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,
  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,
  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,  3,  3,  3,  3,  3,
  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0
};


U8_WMV gDecodeCodeTableMCBPCinter[1024] = {
  0, 255,  9, 20,  9, 19,  9, 18,  9, 17,  9,  7,  8, 14,  8, 14,  8, 13,  8, 13,  8, 11,  8, 11,  7, 15,
  7, 15,  7, 15,  7, 15,  7, 10,  7, 10,  7, 10,  7, 10,  7,  9,  7,  9,  7,  9,  7,  9,  7,  6,  7,  6,
  7,  6,  7,  6,  7,  5,  7,  5,  7,  5,  7,  5,  6, 16,  6, 16,  6, 16,  6, 16,  6, 16,  6, 16,  6, 16,
  6, 16,  6,  3,  6,  3,  6,  3,  6,  3,  6,  3,  6,  3,  6,  3,  6,  3,  5, 12,  5, 12,  5, 12,  5, 12,
  5, 12,  5, 12,  5, 12,  5, 12,  5, 12,  5, 12,  5, 12,  5, 12,  5, 12,  5, 12,  5, 12,  5, 12,  4,  2,
  4,  2,  4,  2,  4,  2,  4,  2,  4,  2,  4,  2,  4,  2,  4,  2,  4,  2,  4,  2,  4,  2,  4,  2,  4,  2,
  4,  2,  4,  2,  4,  2,  4,  2,  4,  2,  4,  2,  4,  2,  4,  2,  4,  2,  4,  2,  4,  2,  4,  2,  4,  2,
  4,  2,  4,  2,  4,  2,  4,  2,  4,  2,  4,  1,  4,  1,  4,  1,  4,  1,  4,  1,  4,  1,  4,  1,  4,  1,
  4,  1,  4,  1,  4,  1,  4,  1,  4,  1,  4,  1,  4,  1,  4,  1,  4,  1,  4,  1,  4,  1,  4,  1,  4,  1,
  4,  1,  4,  1,  4,  1,  4,  1,  4,  1,  4,  1,  4,  1,  4,  1,  4,  1,  4,  1,  4,  1,  3,  8,  3,  8,
  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,
  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,
  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,
  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,
  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  8,  3,  4,  3,  4,  3,  4,
  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,
  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,
  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,
  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,
  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,  1,  0,
  1,  0,  1,  0,  1,  0,  1,  0,  1,  0
};

U8_WMV gDecodeCodeTableIntraDCy[256] = {
  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,
  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,
  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  3,  0,
  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,
  3,  0,  3,  0,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,
  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,
  4,  5,  4,  5,  4,  5,  5,  6,  5,  6,  5,  6,  5,  6,  6,  7,  6,  7,  7,  8,  0, 255
};
U8_WMV gDecodeCodeTableIntraDCc[512] = {
  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,
  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,
  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,
  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,
  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  1,
  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,
  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,
  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,
  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,
  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  2,  2,  2,
  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,
  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
  3,  3,  3,  3,  3,  3,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,
  5,  5,  6,  6,  6,  6,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  0, 255
};

U8_WMV gDecodeCodeTableMV[16384] = {
  0, 255,  0, 255,  0, 255,  0, 255, 13, 64, 13,  0, 13, 63, 13,  1, 12, 62, 12, 62, 12,  2, 12,  2, 12, 61,
 12, 61, 12,  3, 12,  3, 12, 60, 12, 60, 12,  4, 12,  4, 12, 59, 12, 59, 12,  5, 12,  5, 12, 58, 12, 58,
 12,  6, 12,  6, 12, 57, 12, 57, 12,  7, 12,  7, 11, 56, 11, 56, 11, 56, 11, 56, 11,  8, 11,  8, 11,  8,
 11,  8, 11, 55, 11, 55, 11, 55, 11, 55, 11,  9, 11,  9, 11,  9, 11,  9, 11, 54, 11, 54, 11, 54, 11, 54,
 11, 10, 11, 10, 11, 10, 11, 10, 11, 53, 11, 53, 11, 53, 11, 53, 11, 11, 11, 11, 11, 11, 11, 11, 11, 52,
 11, 52, 11, 52, 11, 52, 11, 12, 11, 12, 11, 12, 11, 12, 11, 51, 11, 51, 11, 51, 11, 51, 11, 13, 11, 13,
 11, 13, 11, 13, 11, 50, 11, 50, 11, 50, 11, 50, 11, 14, 11, 14, 11, 14, 11, 14, 11, 49, 11, 49, 11, 49,
 11, 49, 11, 15, 11, 15, 11, 15, 11, 15, 11, 48, 11, 48, 11, 48, 11, 48, 11, 16, 11, 16, 11, 16, 11, 16,
 11, 47, 11, 47, 11, 47, 11, 47, 11, 17, 11, 17, 11, 17, 11, 17, 11, 46, 11, 46, 11, 46, 11, 46, 11, 18,
 11, 18, 11, 18, 11, 18, 11, 45, 11, 45, 11, 45, 11, 45, 11, 19, 11, 19, 11, 19, 11, 19, 11, 44, 11, 44,
 11, 44, 11, 44, 11, 20, 11, 20, 11, 20, 11, 20, 11, 43, 11, 43, 11, 43, 11, 43, 11, 21, 11, 21, 11, 21,
 11, 21, 10, 42, 10, 42, 10, 42, 10, 42, 10, 42, 10, 42, 10, 42, 10, 42, 10, 22, 10, 22, 10, 22, 10, 22,
 10, 22, 10, 22, 10, 22, 10, 22, 10, 41, 10, 41, 10, 41, 10, 41, 10, 41, 10, 41, 10, 41, 10, 41, 10, 23,
 10, 23, 10, 23, 10, 23, 10, 23, 10, 23, 10, 23, 10, 23, 10, 40, 10, 40, 10, 40, 10, 40, 10, 40, 10, 40,
 10, 40, 10, 40, 10, 24, 10, 24, 10, 24, 10, 24, 10, 24, 10, 24, 10, 24, 10, 24,  8, 39,  8, 39,  8, 39,
  8, 39,  8, 39,  8, 39,  8, 39,  8, 39,  8, 39,  8, 39,  8, 39,  8, 39,  8, 39,  8, 39,  8, 39,  8, 39,
  8, 39,  8, 39,  8, 39,  8, 39,  8, 39,  8, 39,  8, 39,  8, 39,  8, 39,  8, 39,  8, 39,  8, 39,  8, 39,
  8, 39,  8, 39,  8, 39,  8, 25,  8, 25,  8, 25,  8, 25,  8, 25,  8, 25,  8, 25,  8, 25,  8, 25,  8, 25,
  8, 25,  8, 25,  8, 25,  8, 25,  8, 25,  8, 25,  8, 25,  8, 25,  8, 25,  8, 25,  8, 25,  8, 25,  8, 25,
  8, 25,  8, 25,  8, 25,  8, 25,  8, 25,  8, 25,  8, 25,  8, 25,  8, 25,  8, 38,  8, 38,  8, 38,  8, 38,
  8, 38,  8, 38,  8, 38,  8, 38,  8, 38,  8, 38,  8, 38,  8, 38,  8, 38,  8, 38,  8, 38,  8, 38,  8, 38,
  8, 38,  8, 38,  8, 38,  8, 38,  8, 38,  8, 38,  8, 38,  8, 38,  8, 38,  8, 38,  8, 38,  8, 38,  8, 38,
  8, 38,  8, 38,  8, 26,  8, 26,  8, 26,  8, 26,  8, 26,  8, 26,  8, 26,  8, 26,  8, 26,  8, 26,  8, 26,
  8, 26,  8, 26,  8, 26,  8, 26,  8, 26,  8, 26,  8, 26,  8, 26,  8, 26,  8, 26,  8, 26,  8, 26,  8, 26,
  8, 26,  8, 26,  8, 26,  8, 26,  8, 26,  8, 26,  8, 26,  8, 26,  8, 37,  8, 37,  8, 37,  8, 37,  8, 37,
  8, 37,  8, 37,  8, 37,  8, 37,  8, 37,  8, 37,  8, 37,  8, 37,  8, 37,  8, 37,  8, 37,  8, 37,  8, 37,
  8, 37,  8, 37,  8, 37,  8, 37,  8, 37,  8, 37,  8, 37,  8, 37,  8, 37,  8, 37,  8, 37,  8, 37,  8, 37,
  8, 37,  8, 27,  8, 27,  8, 27,  8, 27,  8, 27,  8, 27,  8, 27,  8, 27,  8, 27,  8, 27,  8, 27,  8, 27,
  8, 27,  8, 27,  8, 27,  8, 27,  8, 27,  8, 27,  8, 27,  8, 27,  8, 27,  8, 27,  8, 27,  8, 27,  8, 27,
  8, 27,  8, 27,  8, 27,  8, 27,  8, 27,  8, 27,  8, 27,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,
  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,
  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,
  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,
  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,
  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 36,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,
  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,
  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,
  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,
  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,
  7, 28,  7, 28,  7, 28,  7, 28,  7, 28,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,
  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,
  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,
  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,
  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,
  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,
  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,
  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,
  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,
  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,
  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,
  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,
  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,
  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,
  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,
  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,
  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,
  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,
  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,
  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,  5, 35,
  5, 35,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,
  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,
  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,
  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,
  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,
  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,
  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,
  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,
  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,
  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,
  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,
  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,
  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,
  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,
  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,
  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,
  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,
  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,
  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,
  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  5, 29,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,  4, 34,
  4, 34,  4, 34,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,
  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  4, 30,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,  3, 33,
  3, 33,  3, 33,  3, 33,  3, 33,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,  3, 31,
  3, 31,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,  1, 32,
  1, 32,  1, 32
};

/// ----- MP4S Table

U8_WMV gDecodeCodeTableIntraDCMPEG4y[4096] = {
11, 255, 11, 12, 10, 11, 10, 11,  9, 10,  9, 10,  9, 10,  9, 10,  8,  9,  8,  9,  8,  9, 
 8,  9,  8,  9,  8,  9,  8,  9,  8,  9,  7,  8,  7,  8,  7,  8,  7,  8,  7,  8, 
 7,  8,  7,  8,  7,  8,  7,  8,  7,  8,  7,  8,  7,  8,  7,  8,  7,  8,  7,  8, 
 7,  8,  6,  7,  6,  7,  6,  7,  6,  7,  6,  7,  6,  7,  6,  7,  6,  7,  6,  7, 
 6,  7,  6,  7,  6,  7,  6,  7,  6,  7,  6,  7,  6,  7,  6,  7,  6,  7,  6,  7, 
 6,  7,  6,  7,  6,  7,  6,  7,  6,  7,  6,  7,  6,  7,  6,  7,  6,  7,  6,  7, 
 6,  7,  6,  7,  6,  7,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6, 
 5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6, 
 5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6, 
 5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6, 
 5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6, 
 5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6, 
 5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  5,  6,  4,  5,  4,  5,  4,  5, 
 4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5, 
 4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5, 
 4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5, 
 4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5, 
 4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5, 
 4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5, 
 4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5, 
 4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5, 
 4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5, 
 4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5, 
 4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5, 
 4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  4,  5, 
 4,  5,  4,  5,  4,  5,  4,  5,  4,  5,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4, 
 3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4, 
 3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4, 
 3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4, 
 3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4, 
 3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4, 
 3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4, 
 3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4, 
 3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4, 
 3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4, 
 3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4, 
 3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4, 
 3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4, 
 3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4, 
 3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4, 
 3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4, 
 3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4, 
 3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4, 
 3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4, 
 3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4, 
 3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4, 
 3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4, 
 3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4, 
 3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4, 
 3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4, 
 3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4,  3,  4, 
 3,  4,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  0,  3,  0,  3,  0, 
 3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0, 
 3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0, 
 3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0, 
 3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0, 
 3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0, 
 3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0, 
 3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0, 
 3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0, 
 3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0, 
 3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0, 
 3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0, 
 3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0, 
 3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0, 
 3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0, 
 3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0, 
 3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0, 
 3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0, 
 3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0, 
 3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0, 
 3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0, 
 3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0, 
 3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0, 
 3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0, 
 3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0, 
 3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0,  3,  0, 
 3,  0,  3,  0,  3,  0,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1
};
U8_WMV gDecodeCodeTableIntraDCMPEG4c[8192] = {
12, 255, 12, 12, 11, 11, 11, 11, 10, 10, 10, 10, 10, 10, 10, 10,  9,  9,  9,  9,  9,  9, 
 9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8, 
 8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8, 
 8,  8,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 
 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 
 7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 
 7,  7,  7,  7,  7,  7,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6, 
 6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6, 
 6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6, 
 6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6, 
 6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6, 
 6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6, 
 6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  5,  5,  5,  5,  5,  5, 
 5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5, 
 5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5, 
 5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5, 
 5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5, 
 5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5, 
 5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5, 
 5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5, 
 5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5, 
 5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5, 
 5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5, 
 5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5, 
 5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5, 
 5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4, 
 4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4, 
 4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4, 
 4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4, 
 4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4, 
 4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4, 
 4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4, 
 4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4, 
 4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4, 
 4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4, 
 4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4, 
 4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4, 
 4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4, 
 4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4, 
 4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4, 
 4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4, 
 4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4, 
 4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4, 
 4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4, 
 4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4, 
 4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4, 
 4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4, 
 4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4, 
 4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4, 
 4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4, 
 4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4, 
 4,  4,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 
 3,  3,  3,  3,  3,  3,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 
 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1,  2,  1, 
 2,  1,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0,  2,  0, 
 2,  0,  2,  0,  2,  0,  2,  0,  2,  0
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\dectables.c ===
#include "bldsetup.h"

#include "DecTables.h"
#include "huffDTbl.c"
#include "macros.h"  //for FastFloat && NF2BP1
                   
#define F2BP1 NF2BP1

#ifdef USE_SIN_COS_TABLES

/*
g_SinTableForReconstruction can be built with the following code. 

#ifdef BUILD_INTEGER
#   define SHUFFLE_BITS(x) ((((x)>>16)&0xFFFF) | (((x)<<15)&0xFFFF0000))
#else 
#   define SHUFFLE_BITS(x) x
#endif

    for (i = 0; i < 1024; i++) pau->m_piSinForRecon2048[i] = SHUFFLE_BITS( BP2_FROM_FLOAT( -(sin ((0.5+i) * PI / 2048 / 2))));
    for (     ; i < 2048; i++) pau->m_piSinForRecon2048[i] = SHUFFLE_BITS( BP2_FROM_FLOAT(  (sin ((0.5+i) * PI / 2048 / 2))));
    for (i = 0; i < 512 ; i++) pau->m_piSinForRecon1024[i] = SHUFFLE_BITS( BP2_FROM_FLOAT( -(sin ((0.5+i) * PI / 1024 / 2))));
    for (     ; i < 1024; i++) pau->m_piSinForRecon1024[i] = SHUFFLE_BITS( BP2_FROM_FLOAT(  (sin ((0.5+i) * PI / 1024 / 2))));
    for (i = 0; i < 256 ; i++) pau->m_piSinForRecon512 [i] = SHUFFLE_BITS( BP2_FROM_FLOAT( -(sin ((0.5+i) * PI / 512  / 2))));
    for (     ; i < 512 ; i++) pau->m_piSinForRecon512 [i] = SHUFFLE_BITS( BP2_FROM_FLOAT(  (sin ((0.5+i) * PI / 512  / 2))));
    for (i = 0; i < 128 ; i++) pau->m_piSinForRecon256 [i] = SHUFFLE_BITS( BP2_FROM_FLOAT( -(sin ((0.5+i) * PI / 256  / 2))));
    for (     ; i < 256 ; i++) pau->m_piSinForRecon256 [i] = SHUFFLE_BITS( BP2_FROM_FLOAT(  (sin ((0.5+i) * PI / 256  / 2))));
    for (i = 0; i < 64  ; i++) pau->m_piSinForRecon128 [i] = SHUFFLE_BITS( BP2_FROM_FLOAT( -(sin ((0.5+i) * PI / 128  / 2))));
    for (     ; i < 128 ; i++) pau->m_piSinForRecon128 [i] = SHUFFLE_BITS( BP2_FROM_FLOAT(  (sin ((0.5+i) * PI / 128  / 2))));
    for (i = 0; i < 32  ; i++) pau->m_piSinForRecon64  [i] = SHUFFLE_BITS( BP2_FROM_FLOAT( -(sin ((0.5+i) * PI / 64   / 2))));
    for (     ; i < 64  ; i++) pau->m_piSinForRecon64  [i] = SHUFFLE_BITS( BP2_FROM_FLOAT(  (sin ((0.5+i) * PI / 64   / 2))));
*/
     
#ifdef BUILD_INT_FLOAT  
//Note: These numbers are float numbers represented in there hex format. These numbers
//      should be aligned on a 32byte boundary when the compiler supports it. When this
//      is done the appropriate mouvps in auReconStereo_SIMDFP is changed to movaps.
const Int g_SinTableForReconstruction[(2048+1024+512+256+128+64)] = {
0xB9C90FDA,0xBA96CBE2,0xBAFB53C7,0xBB2FEDD1,0xBB6231B9,0xBB8A3ACB,0xBBA35CB5,0xBBBC7E99,
0xBBD5A075,0xBBEEC249,0xBC03F20A,0xBC1082EA,0xBC1D13C5,0xBC29A49A,0xBC363568,0xBC42C62F,
0xBC4F56EF,0xBC5BE7A6,0xBC687856,0xBC7508FC,0xBC80CCCC,0xBC871516,0xBC8D5D5A,0xBC93A599,
0xBC99EDD2,0xBCA03605,0xBCA67E32,0xBCACC658,0xBCB30E78,0xBCB95691,0xBCBF9EA3,0xBCC5E6AD,
0xBCCC2EB0,0xBCD276AB,0xBCD8BE9E,0xBCDF0688,0xBCE54E6A,0xBCEB9643,0xBCF1DE13,0xBCF825DA,
0xBCFE6D97,0xBD025AA5,0xBD057E7A,0xBD08A249,0xBD0BC613,0xBD0EE9D8,0xBD120D97,0xBD153151,
0xBD185505,0xBD1B78B3,0xBD1E9C5B,0xBD21BFFD,0xBD24E399,0xBD28072E,0xBD2B2ABD,0xBD2E4E45,
0xBD3171C6,0xBD349541,0xBD37B8B5,0xBD3ADC22,0xBD3DFF87,0xBD4122E5,0xBD44463C,0xBD47698B,
0xBD4A8CD2,0xBD4DB012,0xBD50D34A,0xBD53F679,0xBD5719A1,0xBD5A3CC0,0xBD5D5FD7,0xBD6082E5,
0xBD63A5EA,0xBD66C8E7,0xBD69EBDB,0xBD6D0EC6,0xBD7031A8,0xBD735480,0xBD76774F,0xBD799A15,
0xBD7CBCD1,0xBD7FDF83,0xBD818116,0xBD831265,0xBD84A3AF,0xBD8634F4,0xBD87C634,0xBD89576E,
0xBD8AE8A4,0xBD8C79D4,0xBD8E0AFE,0xBD8F9C23,0xBD912D43,0xBD92BE5D,0xBD944F71,0xBD95E07F,
0xBD977188,0xBD99028B,0xBD9A9388,0xBD9C247F,0xBD9DB570,0xBD9F465B,0xBDA0D740,0xBDA2681F,
0xBDA3F8F7,0xBDA589C9,0xBDA71A95,0xBDA8AB5A,0xBDAA3C19,0xBDABCCD1,0xBDAD5D83,0xBDAEEE2D,
0xBDB07ED2,0xBDB20F6F,0xBDB3A005,0xBDB53095,0xBDB6C11D,0xBDB8519F,0xBDB9E219,0xBDBB728C,
0xBDBD02F8,0xBDBE935D,0xBDC023BA,0xBDC1B410,0xBDC3445F,0xBDC4D4A6,0xBDC664E5,0xBDC7F51D,
0xBDC9854D,0xBDCB1575,0xBDCCA596,0xBDCE35AE,0xBDCFC5BF,0xBDD155C7,0xBDD2E5C8,0xBDD475C0,
0xBDD605B0,0xBDD79598,0xBDD92578,0xBDDAB54F,0xBDDC451E,0xBDDDD4E4,0xBDDF64A2,0xBDE0F457,
0xBDE28403,0xBDE413A7,0xBDE5A342,0xBDE732D4,0xBDE8C25D,0xBDEA51DE,0xBDEBE155,0xBDED70C3,
0xBDEF0028,0xBDF08F83,0xBDF21ED6,0xBDF3AE1F,0xBDF53D5F,0xBDF6CC95,0xBDF85BC2,0xBDF9EAE5,
0xBDFB79FE,0xBDFD090E,0xBDFE9814,0xBE001388,0xBE00DB01,0xBE01A276,0xBE0269E5,0xBE03314F,
0xBE03F8B4,0xBE04C014,0xBE05876F,0xBE064EC5,0xBE071616,0xBE07DD61,0xBE08A4A7,0xBE096BE8,
0xBE0A3324,0xBE0AFA5A,0xBE0BC18B,0xBE0C88B6,0xBE0D4FDC,0xBE0E16FD,0xBE0EDE18,0xBE0FA52E,
0xBE106C3E,0xBE113349,0xBE11FA4E,0xBE12C14D,0xBE138847,0xBE144F3B,0xBE151629,0xBE15DD11,
0xBE16A3F4,0xBE176AD1,0xBE1831A8,0xBE18F879,0xBE19BF45,0xBE1A860A,0xBE1B4CCA,0xBE1C1383,
0xBE1CDA36,0xBE1DA0E4,0xBE1E678B,0xBE1F2E2C,0xBE1FF4C8,0xBE20BB5C,0xBE2181EB,0xBE224874,
0xBE230EF6,0xBE23D572,0xBE249BE7,0xBE256257,0xBE2628C0,0xBE26EF22,0xBE27B57E,0xBE287BD4,
0xBE294223,0xBE2A086B,0xBE2ACEAE,0xBE2B94E9,0xBE2C5B1E,0xBE2D214C,0xBE2DE773,0xBE2EAD94,
0xBE2F73AE,0xBE3039C2,0xBE30FFCE,0xBE31C5D4,0xBE328BD3,0xBE3351CB,0xBE3417BC,0xBE34DDA6,
0xBE35A389,0xBE366965,0xBE372F3A,0xBE37F508,0xBE38BACF,0xBE39808F,0xBE3A4647,0xBE3B0BF9,
0xBE3BD1A3,0xBE3C9746,0xBE3D5CE2,0xBE3E2276,0xBE3EE804,0xBE3FAD89,0xBE407308,0xBE41387F,
0xBE41FDEE,0xBE42C356,0xBE4388B7,0xBE444E10,0xBE451361,0xBE45D8AB,0xBE469DED,0xBE476328,
0xBE48285A,0xBE48ED85,0xBE49B2A9,0xBE4A77C4,0xBE4B3CD8,0xBE4C01E4,0xBE4CC6E8,0xBE4D8BE4,
0xBE4E50D9,0xBE4F15C5,0xBE4FDAA9,0xBE509F86,0xBE51645A,0xBE522926,0xBE52EDEA,0xBE53B2A6,
0xBE54775A,0xBE553C06,0xBE5600A9,0xBE56C544,0xBE5789D7,0xBE584E62,0xBE5912E4,0xBE59D75E,
0xBE5A9BCF,0xBE5B6038,0xBE5C2499,0xBE5CE8F1,0xBE5DAD40,0xBE5E7187,0xBE5F35C6,0xBE5FF9FC,
0xBE60BE29,0xBE61824D,0xBE624669,0xBE630A7C,0xBE63CE87,0xBE649288,0xBE655681,0xBE661A71,
0xBE66DE58,0xBE67A236,0xBE68660B,0xBE6929D8,0xBE69ED9B,0xBE6AB155,0xBE6B7506,0xBE6C38AF,
0xBE6CFC4E,0xBE6DBFE3,0xBE6E8370,0xBE6F46F4,0xBE700A6E,0xBE70CDDF,0xBE719147,0xBE7254A5,
0xBE7317FA,0xBE73DB46,0xBE749E88,0xBE7561C1,0xBE7624F1,0xBE76E817,0xBE77AB33,0xBE786E46,
0xBE79314F,0xBE79F44F,0xBE7AB745,0xBE7B7A31,0xBE7C3D14,0xBE7CFFED,0xBE7DC2BC,0xBE7E8582,
0xBE7F483D,0xBE800578,0xBE8066CC,0xBE80C81B,0xBE812965,0xBE818AAA,0xBE81EBEA,0xBE824D25,
0xBE82AE5B,0xBE830F8C,0xBE8370B8,0xBE83D1DF,0xBE843300,0xBE84941D,0xBE84F535,0xBE855647,
0xBE85B755,0xBE86185D,0xBE867960,0xBE86DA5D,0xBE873B56,0xBE879C49,0xBE87FD38,0xBE885E21,
0xBE88BF04,0xBE891FE3,0xBE8980BC,0xBE89E190,0xBE8A425E,0xBE8AA327,0xBE8B03EB,0xBE8B64AA,
0xBE8BC563,0xBE8C2616,0xBE8C86C5,0xBE8CE76D,0xBE8D4811,0xBE8DA8AF,0xBE8E0947,0xBE8E69DB,
0xBE8ECA68,0xBE8F2AF0,0xBE8F8B73,0xBE8FEBF0,0xBE904C67,0xBE90ACD9,0xBE910D45,0xBE916DAC,
0xBE91CE0D,0xBE922E69,0xBE928EBF,0xBE92EF0F,0xBE934F59,0xBE93AF9E,0xBE940FDD,0xBE947017,
0xBE94D04B,0xBE953079,0xBE9590A1,0xBE95F0C3,0xBE9650E0,0xBE96B0F7,0xBE971108,0xBE977113,
0xBE97D119,0xBE983118,0xBE989112,0xBE98F106,0xBE9950F4,0xBE99B0DC,0xBE9A10BE,0xBE9A709A,
0xBE9AD070,0xBE9B3041,0xBE9B900B,0xBE9BEFCF,0xBE9C4F8D,0xBE9CAF46,0xBE9D0EF8,0xBE9D6EA4,
0xBE9DCE4A,0xBE9E2DEA,0xBE9E8D84,0xBE9EED18,0xBE9F4CA5,0xBE9FAC2D,0xBEA00BAE,0xBEA06B29,
0xBEA0CA9E,0xBEA12A0D,0xBEA18976,0xBEA1E8D8,0xBEA24834,0xBEA2A78A,0xBEA306DA,0xBEA36623,
0xBEA3C566,0xBEA424A3,0xBEA483D9,0xBEA4E309,0xBEA54233,0xBEA5A156,0xBEA60073,0xBEA65F89,
0xBEA6BE99,0xBEA71DA3,0xBEA77CA6,0xBEA7DBA3,0xBEA83A99,0xBEA89989,0xBEA8F872,0xBEA95755,
0xBEA9B631,0xBEAA1507,0xBEAA73D6,0xBEAAD29F,0xBEAB3161,0xBEAB901C,0xBEABEED1,0xBEAC4D7F,
0xBEACAC27,0xBEAD0AC7,0xBEAD6962,0xBEADC7F5,0xBEAE2682,0xBEAE8508,0xBEAEE387,0xBEAF4200,
0xBEAFA072,0xBEAFFEDD,0xBEB05D41,0xBEB0BB9F,0xBEB119F5,0xBEB17845,0xBEB1D68E,0xBEB234D0,
0xBEB2930C,0xBEB2F140,0xBEB34F6E,0xBEB3AD94,0xBEB40BB4,0xBEB469CD,0xBEB4C7DE,0xBEB525E9,
0xBEB583ED,0xBEB5E1EA,0xBEB63FE0,0xBEB69DCE,0xBEB6FBB6,0xBEB75997,0xBEB7B770,0xBEB81543,
0xBEB8730E,0xBEB8D0D3,0xBEB92E90,0xBEB98C46,0xBEB9E9F5,0xBEBA479D,0xBEBAA53D,0xBEBB02D6,
0xBEBB6069,0xBEBBBDF4,0xBEBC1B77,0xBEBC78F4,0xBEBCD669,0xBEBD33D7,0xBEBD913D,0xBEBDEE9D,
0xBEBE4BF5,0xBEBEA945,0xBEBF068F,0xBEBF63D0,0xBEBFC10B,0xBEC01E3E,0xBEC07B6A,0xBEC0D88E,
0xBEC135AB,0xBEC192C0,0xBEC1EFCE,0xBEC24CD5,0xBEC2A9D4,0xBEC306CB,0xBEC363BB,0xBEC3C0A4,
0xBEC41D85,0xBEC47A5E,0xBEC4D730,0xBEC533FA,0xBEC590BD,0xBEC5ED77,0xBEC64A2B,0xBEC6A6D6,
0xBEC7037B,0xBEC76017,0xBEC7BCAC,0xBEC81938,0xBEC875BE,0xBEC8D23B,0xBEC92EB1,0xBEC98B1F,
0xBEC9E785,0xBECA43E4,0xBECAA03A,0xBECAFC89,0xBECB58D0,0xBECBB50F,0xBECC1147,0xBECC6D76,
0xBECCC99E,0xBECD25BE,0xBECD81D5,0xBECDDDE5,0xBECE39ED,0xBECE95ED,0xBECEF1E5,0xBECF4DD5,
0xBECFA9BD,0xBED0059D,0xBED06175,0xBED0BD45,0xBED1190D,0xBED174CD,0xBED1D085,0xBED22C34,
0xBED287DC,0xBED2E37C,0xBED33F13,0xBED39AA2,0xBED3F629,0xBED451A8,0xBED4AD1F,0xBED5088D,
0xBED563F3,0xBED5BF52,0xBED61AA7,0xBED675F5,0xBED6D13A,0xBED72C77,0xBED787AC,0xBED7E2D8,
0xBED83DFC,0xBED89918,0xBED8F42C,0xBED94F37,0xBED9AA39,0xBEDA0533,0xBEDA6025,0xBEDABB0F,
0xBEDB15F0,0xBEDB70C8,0xBEDBCB98,0xBEDC2660,0xBEDC811F,0xBEDCDBD6,0xBEDD3684,0xBEDD912A,
0xBEDDEBC7,0xBEDE465B,0xBEDEA0E7,0xBEDEFB6A,0xBEDF55E5,0xBEDFB057,0xBEE00AC1,0xBEE06522,
0xBEE0BF7A,0xBEE119C9,0xBEE17410,0xBEE1CE4E,0xBEE22884,0xBEE282B1,0xBEE2DCD5,0xBEE336F0,
0xBEE39102,0xBEE3EB0C,0xBEE4450D,0xBEE49F05,0xBEE4F8F5,0xBEE552DB,0xBEE5ACB9,0xBEE6068E,
0xBEE6605A,0xBEE6BA1D,0xBEE713D7,0xBEE76D88,0xBEE7C731,0xBEE820D0,0xBEE87A66,0xBEE8D3F4,
0xBEE92D78,0xBEE986F4,0xBEE9E066,0xBEEA39D0,0xBEEA9330,0xBEEAEC88,0xBEEB45D6,0xBEEB9F1C,
0xBEEBF858,0xBEEC518B,0xBEECAAB5,0xBEED03D6,0xBEED5CEE,0xBEEDB5FC,0xBEEE0F02,0xBEEE67FE,
0xBEEEC0F1,0xBEEF19DB,0xBEEF72BC,0xBEEFCB93,0xBEF02461,0xBEF07D26,0xBEF0D5E2,0xBEF12E94,
0xBEF1873D,0xBEF1DFDD,0xBEF23873,0xBEF29100,0xBEF2E984,0xBEF341FE,0xBEF39A6F,0xBEF3F2D7,
0xBEF44B35,0xBEF4A38A,0xBEF4FBD5,0xBEF55417,0xBEF5AC50,0xBEF6047F,0xBEF65CA4,0xBEF6B4C0,
0xBEF70CD3,0xBEF764DC,0xBEF7BCDB,0xBEF814D1,0xBEF86CBD,0xBEF8C4A0,0xBEF91C79,0xBEF97449,
0xBEF9CC0E,0xBEFA23CB,0xBEFA7B7D,0xBEFAD326,0xBEFB2AC6,0xBEFB825B,0xBEFBD9E7,0xBEFC3169,
0xBEFC88E2,0xBEFCE051,0xBEFD37B6,0xBEFD8F11,0xBEFDE662,0xBEFE3DAA,0xBEFE94E8,0xBEFEEC1C,
0xBEFF4346,0xBEFF9A67,0xBEFFF17D,0xBF002445,0xBF004FC6,0xBF007B43,0xBF00A6BA,0xBF00D22D,
0xBF00FD9A,0xBF012903,0xBF015467,0xBF017FC5,0xBF01AB1F,0xBF01D674,0xBF0201C3,0xBF022D0E,
0xBF025853,0xBF028394,0xBF02AED0,0xBF02DA06,0xBF030537,0xBF033064,0xBF035B8B,0xBF0386AE,
0xBF03B1CB,0xBF03DCE3,0xBF0407F6,0xBF043304,0xBF045E0D,0xBF048911,0xBF04B40F,0xBF04DF09,
0xBF0509FD,0xBF0534EC,0xBF055FD7,0xBF058ABC,0xBF05B59C,0xBF05E076,0xBF060B4C,0xBF06361C,
0xBF0660E7,0xBF068BAD,0xBF06B66E,0xBF06E12A,0xBF070BE0,0xBF073692,0xBF07613E,0xBF078BE4,
0xBF07B686,0xBF07E122,0xBF080BB9,0xBF08364B,0xBF0860D8,0xBF088B5F,0xBF08B5E1,0xBF08E05E,
0xBF090AD6,0xBF093548,0xBF095FB5,0xBF098A1D,0xBF09B47F,0xBF09DEDC,0xBF0A0934,0xBF0A3386,
0xBF0A5DD3,0xBF0A881B,0xBF0AB25E,0xBF0ADC9B,0xBF0B06D2,0xBF0B3105,0xBF0B5B32,0xBF0B8559,
0xBF0BAF7C,0xBF0BD998,0xBF0C03B0,0xBF0C2DC2,0xBF0C57CF,0xBF0C81D6,0xBF0CABD8,0xBF0CD5D4,
0xBF0CFFCB,0xBF0D29BD,0xBF0D53A9,0xBF0D7D8F,0xBF0DA771,0xBF0DD14C,0xBF0DFB23,0xBF0E24F3,
0xBF0E4EBF,0xBF0E7885,0xBF0EA245,0xBF0ECC00,0xBF0EF5B5,0xBF0F1F65,0xBF0F490F,0xBF0F72B4,
0xBF0F9C53,0xBF0FC5ED,0xBF0FEF81,0xBF101910,0xBF104299,0xBF106C1C,0xBF10959A,0xBF10BF13,
0xBF10E885,0xBF1111F3,0xBF113B5A,0xBF1164BC,0xBF118E19,0xBF11B76F,0xBF11E0C1,0xBF120A0C,
0xBF123352,0xBF125C92,0xBF1285CD,0xBF12AF02,0xBF12D831,0xBF13015B,0xBF132A7F,0xBF13539D,
0xBF137CB6,0xBF13A5C9,0xBF13CED6,0xBF13F7DE,0xBF1420E0,0xBF1449DC,0xBF1472D2,0xBF149BC3,
0xBF14C4AE,0xBF14ED93,0xBF151673,0xBF153F4D,0xBF156821,0xBF1590EF,0xBF15B9B7,0xBF15E27A,
0xBF160B37,0xBF1633EE,0xBF165C9F,0xBF16854B,0xBF16ADF1,0xBF16D691,0xBF16FF2B,0xBF1727BF,
0xBF17504E,0xBF1778D6,0xBF17A159,0xBF17C9D6,0xBF17F24D,0xBF181ABE,0xBF18432A,0xBF186B8F,
0xBF1893EF,0xBF18BC49,0xBF18E49D,0xBF190CEB,0xBF193533,0xBF195D75,0xBF1985B1,0xBF19ADE7,
0xBF19D618,0xBF19FE42,0xBF1A2667,0xBF1A4E86,0xBF1A769E,0xBF1A9EB1,0xBF1AC6BE,0xBF1AEEC4,
0xBF1B16C5,0xBF1B3EC0,0xBF1B66B5,0xBF1B8EA4,0xBF1BB68D,0xBF1BDE6F,0xBF1C064C,0xBF1C2E23,
0xBF1C55F4,0xBF1C7DBF,0xBF1CA583,0xBF1CCD42,0xBF1CF4FB,0xBF1D1CAD,0xBF1D445A,0xBF1D6C00,
0xBF1D93A1,0xBF1DBB3B,0xBF1DE2CF,0xBF1E0A5D,0xBF1E31E6,0xBF1E5968,0xBF1E80E3,0xBF1EA859,
0xBF1ECFC9,0xBF1EF732,0xBF1F1E96,0xBF1F45F3,0xBF1F6D4A,0xBF1F949B,0xBF1FBBE6,0xBF1FE32B,
0xBF200A69,0xBF2031A1,0xBF2058D4,0xBF208000,0xBF20A725,0xBF20CE45,0xBF20F55E,0xBF211C71,
0xBF21437E,0xBF216A85,0xBF219186,0xBF21B880,0xBF21DF74,0xBF220662,0xBF222D4A,0xBF22542B,
0xBF227B06,0xBF22A1DB,0xBF22C8A9,0xBF22EF72,0xBF231633,0xBF233CEF,0xBF2363A5,0xBF238A54,
0xBF23B0FC,0xBF23D79F,0xBF23FE3B,0xBF2424D1,0xBF244B60,0xBF2471EA,0xBF24986D,0xBF24BEE9,
0xBF24E55F,0xBF250BCF,0xBF253238,0xBF25589B,0xBF257EF8,0xBF25A54E,0xBF25CB9E,0xBF25F1E8,
0xBF26182B,0xBF263E68,0xBF26649E,0xBF268ACE,0xBF26B0F7,0xBF26D71A,0xBF26FD37,0xBF27234D,
0xBF27495D,0xBF276F66,0xBF279569,0xBF27BB65,0xBF27E15B,0xBF28074B,0xBF282D34,0xBF285316,
0xBF2878F2,0xBF289EC8,0xBF28C497,0xBF28EA5F,0xBF291021,0xBF2935DD,0xBF295B91,0xBF298140,
0xBF29A6E8,0xBF29CC89,0xBF29F224,0xBF2A17B8,0xBF2A3D46,0xBF2A62CD,0xBF2A884D,0xBF2AADC7,
0xBF2AD33B,0xBF2AF8A7,0xBF2B1E0E,0xBF2B436D,0xBF2B68C6,0xBF2B8E19,0xBF2BB364,0xBF2BD8AA,
0xBF2BFDE8,0xBF2C2320,0xBF2C4851,0xBF2C6D7C,0xBF2C92A0,0xBF2CB7BD,0xBF2CDCD4,0xBF2D01E4,
0xBF2D26ED,0xBF2D4BF0,0xBF2D70EC,0xBF2D95E1,0xBF2DBAD0,0xBF2DDFB8,0xBF2E0499,0xBF2E2973,
0xBF2E4E47,0xBF2E7314,0xBF2E97DA,0xBF2EBC9A,0xBF2EE153,0xBF2F0605,0xBF2F2AB0,0xBF2F4F55,
0xBF2F73F3,0xBF2F988A,0xBF2FBD1A,0xBF2FE1A4,0xBF300626,0xBF302AA2,0xBF304F18,0xBF307386,
0xBF3097EE,0xBF30BC4E,0xBF30E0A8,0xBF3104FB,0xBF312948,0xBF314D8D,0xBF3171CC,0xBF319604,
0xBF31BA35,0xBF31DE5F,0xBF320282,0xBF32269E,0xBF324AB4,0xBF326EC3,0xBF3292CA,0xBF32B6CB,
0xBF32DAC5,0xBF32FEB8,0xBF3322A5,0xBF33468A,0xBF336A68,0xBF338E40,0xBF33B210,0xBF33D5DA,
0xBF33F99D,0xBF341D58,0xBF34410D,0xBF3464BB,0xBF348862,0xBF34AC02,0xBF34CF9B,0xBF34F32D,
0x3F3516B8,0x3F353A3C,0x3F355DB9,0x3F35812F,0x3F35A49E,0x3F35C806,0x3F35EB67,0x3F360EC1,
0x3F363214,0x3F365560,0x3F3678A5,0x3F369BE3,0x3F36BF1A,0x3F36E24A,0x3F370573,0x3F372894,
0x3F374BAF,0x3F376EC3,0x3F3791CF,0x3F37B4D5,0x3F37D7D3,0x3F37FACA,0x3F381DBB,0x3F3840A4,
0x3F386386,0x3F388661,0x3F38A934,0x3F38CC01,0x3F38EEC7,0x3F391185,0x3F39343C,0x3F3956EC,
0x3F397995,0x3F399C37,0x3F39BED2,0x3F39E165,0x3F3A03F2,0x3F3A2677,0x3F3A48F5,0x3F3A6B6C,
0x3F3A8DDB,0x3F3AB044,0x3F3AD2A5,0x3F3AF4FF,0x3F3B1752,0x3F3B399E,0x3F3B5BE2,0x3F3B7E1F,
0x3F3BA055,0x3F3BC284,0x3F3BE4AB,0x3F3C06CB,0x3F3C28E4,0x3F3C4AF6,0x3F3C6D01,0x3F3C8F04,
0x3F3CB100,0x3F3CD2F4,0x3F3CF4E2,0x3F3D16C8,0x3F3D38A7,0x3F3D5A7E,0x3F3D7C4E,0x3F3D9E17,
0x3F3DBFD9,0x3F3DE193,0x3F3E0346,0x3F3E24F2,0x3F3E4696,0x3F3E6833,0x3F3E89C9,0x3F3EAB57,
0x3F3ECCDE,0x3F3EEE5E,0x3F3F0FD6,0x3F3F3147,0x3F3F52B0,0x3F3F7412,0x3F3F956D,0x3F3FB6C0,
0x3F3FD80C,0x3F3FF951,0x3F401A8E,0x3F403BC4,0x3F405CF2,0x3F407E19,0x3F409F38,0x3F40C050,
0x3F40E161,0x3F41026A,0x3F41236C,0x3F414466,0x3F416559,0x3F418645,0x3F41A728,0x3F41C805,
0x3F41E8DA,0x3F4209A7,0x3F422A6E,0x3F424B2C,0x3F426BE3,0x3F428C93,0x3F42AD3B,0x3F42CDDB,
0x3F42EE74,0x3F430F06,0x3F432F90,0x3F435012,0x3F43708D,0x3F439101,0x3F43B16D,0x3F43D1D1,
0x3F43F22E,0x3F441283,0x3F4432D1,0x3F445317,0x3F447356,0x3F44938D,0x3F44B3BC,0x3F44D3E4,
0x3F44F404,0x3F45141D,0x3F45342E,0x3F455437,0x3F457439,0x3F459433,0x3F45B426,0x3F45D411,
0x3F45F3F4,0x3F4613D0,0x3F4633A4,0x3F465370,0x3F467335,0x3F4692F2,0x3F46B2A8,0x3F46D256,
0x3F46F1FC,0x3F47119A,0x3F473131,0x3F4750C0,0x3F477048,0x3F478FC7,0x3F47AF3F,0x3F47CEB0,
0x3F47EE18,0x3F480D79,0x3F482CD3,0x3F484C24,0x3F486B6E,0x3F488AB0,0x3F48A9EA,0x3F48C91D,
0x3F48E848,0x3F49076B,0x3F492686,0x3F49459A,0x3F4964A6,0x3F4983AA,0x3F49A2A6,0x3F49C19B,
0x3F49E088,0x3F49FF6D,0x3F4A1E4A,0x3F4A3D1F,0x3F4A5BED,0x3F4A7AB3,0x3F4A9971,0x3F4AB827,
0x3F4AD6D5,0x3F4AF57C,0x3F4B141B,0x3F4B32B2,0x3F4B5141,0x3F4B6FC8,0x3F4B8E47,0x3F4BACBF,
0x3F4BCB2F,0x3F4BE996,0x3F4C07F6,0x3F4C264E,0x3F4C449F,0x3F4C62E7,0x3F4C8128,0x3F4C9F60,
0x3F4CBD91,0x3F4CDBBA,0x3F4CF9DB,0x3F4D17F4,0x3F4D3605,0x3F4D540E,0x3F4D720F,0x3F4D9009,
0x3F4DADFA,0x3F4DCBE3,0x3F4DE9C5,0x3F4E079F,0x3F4E2570,0x3F4E433A,0x3F4E60FC,0x3F4E7EB6,
0x3F4E9C68,0x3F4EBA12,0x3F4ED7B3,0x3F4EF54D,0x3F4F12DF,0x3F4F3069,0x3F4F4DEB,0x3F4F6B65,
0x3F4F88D7,0x3F4FA642,0x3F4FC3A4,0x3F4FE0FE,0x3F4FFE50,0x3F501B9A,0x3F5038DB,0x3F505615,
0x3F507347,0x3F509071,0x3F50AD93,0x3F50CAAD,0x3F50E7BE,0x3F5104C8,0x3F5121CA,0x3F513EC3,
0x3F515BB5,0x3F51789E,0x3F51957F,0x3F51B259,0x3F51CF2A,0x3F51EBF3,0x3F5208B4,0x3F52256D,
0x3F52421E,0x3F525EC6,0x3F527B67,0x3F5297FF,0x3F52B490,0x3F52D118,0x3F52ED98,0x3F530A10,
0x3F532680,0x3F5342E7,0x3F535F47,0x3F537B9E,0x3F5397EE,0x3F53B435,0x3F53D074,0x3F53ECAA,
0x3F5408D9,0x3F5424FF,0x3F54411D,0x3F545D33,0x3F547941,0x3F549547,0x3F54B144,0x3F54CD3A,
0x3F54E927,0x3F55050C,0x3F5520E8,0x3F553CBD,0x3F555889,0x3F55744D,0x3F559009,0x3F55ABBC,
0x3F55C767,0x3F55E30A,0x3F55FEA5,0x3F561A38,0x3F5635C2,0x3F565144,0x3F566CBE,0x3F56882F,
0x3F56A399,0x3F56BEF9,0x3F56DA52,0x3F56F5A3,0x3F5710EB,0x3F572C2A,0x3F574762,0x3F576291,
0x3F577DB8,0x3F5798D7,0x3F57B3ED,0x3F57CEFB,0x3F57EA01,0x3F5804FE,0x3F581FF3,0x3F583AE0,
0x3F5855C4,0x3F5870A0,0x3F588B74,0x3F58A63F,0x3F58C102,0x3F58DBBC,0x3F58F66F,0x3F591118,
0x3F592BBA,0x3F594653,0x3F5960E4,0x3F597B6C,0x3F5995EC,0x3F59B064,0x3F59CAD3,0x3F59E53A,
0x3F59FF98,0x3F5A19EE,0x3F5A343C,0x3F5A4E81,0x3F5A68BE,0x3F5A82F2,0x3F5A9D1E,0x3F5AB741,
0x3F5AD15C,0x3F5AEB6F,0x3F5B0579,0x3F5B1F7B,0x3F5B3974,0x3F5B5365,0x3F5B6D4D,0x3F5B872D,
0x3F5BA105,0x3F5BBAD4,0x3F5BD49A,0x3F5BEE58,0x3F5C080E,0x3F5C21BB,0x3F5C3B60,0x3F5C54FC,
0x3F5C6E8F,0x3F5C881A,0x3F5CA19D,0x3F5CBB17,0x3F5CD489,0x3F5CEDF2,0x3F5D0752,0x3F5D20AA,
0x3F5D39FA,0x3F5D5341,0x3F5D6C7F,0x3F5D85B5,0x3F5D9EE3,0x3F5DB807,0x3F5DD124,0x3F5DEA37,
0x3F5E0343,0x3F5E1C45,0x3F5E353F,0x3F5E4E31,0x3F5E671A,0x3F5E7FFA,0x3F5E98D2,0x3F5EB1A1,
0x3F5ECA68,0x3F5EE326,0x3F5EFBDB,0x3F5F1488,0x3F5F2D2C,0x3F5F45C8,0x3F5F5E5B,0x3F5F76E5,
0x3F5F8F67,0x3F5FA7E0,0x3F5FC051,0x3F5FD8B8,0x3F5FF118,0x3F60096E,0x3F6021BC,0x3F603A02,
0x3F60523E,0x3F606A73,0x3F60829E,0x3F609AC1,0x3F60B2DB,0x3F60CAEC,0x3F60E2F5,0x3F60FAF5,
0x3F6112ED,0x3F612ADB,0x3F6142C1,0x3F615A9F,0x3F617274,0x3F618A40,0x3F61A203,0x3F61B9BE,
0x3F61D16F,0x3F61E919,0x3F6200B9,0x3F621851,0x3F622FE0,0x3F624766,0x3F625EE4,0x3F627659,
0x3F628DC5,0x3F62A528,0x3F62BC83,0x3F62D3D5,0x3F62EB1E,0x3F63025F,0x3F631996,0x3F6330C5,
0x3F6347EC,0x3F635F09,0x3F63761E,0x3F638D2A,0x3F63A42D,0x3F63BB27,0x3F63D219,0x3F63E901,
0x3F63FFE1,0x3F6416B9,0x3F642D87,0x3F64444D,0x3F645B0A,0x3F6471BE,0x3F648869,0x3F649F0B,
0x3F64B5A5,0x3F64CC35,0x3F64E2BD,0x3F64F93D,0x3F650FB3,0x3F652620,0x3F653C85,0x3F6552E1,
0x3F656934,0x3F657F7E,0x3F6595BF,0x3F65ABF7,0x3F65C227,0x3F65D84E,0x3F65EE6C,0x3F660480,
0x3F661A8D,0x3F663090,0x3F66468A,0x3F665C7C,0x3F667264,0x3F668844,0x3F669E1B,0x3F66B3E9,
0x3F66C9AE,0x3F66DF6A,0x3F66F51D,0x3F670AC7,0x3F672069,0x3F673601,0x3F674B91,0x3F676118,
0x3F677695,0x3F678C0A,0x3F67A176,0x3F67B6D9,0x3F67CC33,0x3F67E184,0x3F67F6CC,0x3F680C0C,
0x3F682142,0x3F68366F,0x3F684B94,0x3F6860AF,0x3F6875C2,0x3F688ACB,0x3F689FCC,0x3F68B4C3,
0x3F68C9B2,0x3F68DE97,0x3F68F374,0x3F690848,0x3F691D12,0x3F6931D4,0x3F69468D,0x3F695B3D,
0x3F696FE3,0x3F698481,0x3F699916,0x3F69ADA1,0x3F69C224,0x3F69D69E,0x3F69EB0E,0x3F69FF76,
0x3F6A13D5,0x3F6A282A,0x3F6A3C77,0x3F6A50BA,0x3F6A64F5,0x3F6A7926,0x3F6A8D4F,0x3F6AA16E,
0x3F6AB585,0x3F6AC992,0x3F6ADD96,0x3F6AF191,0x3F6B0584,0x3F6B196D,0x3F6B2D4D,0x3F6B4124,
0x3F6B54F1,0x3F6B68B6,0x3F6B7C72,0x3F6B9025,0x3F6BA3CE,0x3F6BB76F,0x3F6BCB06,0x3F6BDE94,
0x3F6BF21A,0x3F6C0596,0x3F6C1909,0x3F6C2C73,0x3F6C3FD3,0x3F6C532B,0x3F6C667A,0x3F6C79BF,
0x3F6C8CFC,0x3F6CA02F,0x3F6CB359,0x3F6CC67A,0x3F6CD992,0x3F6CECA0,0x3F6CFFA6,0x3F6D12A2,
0x3F6D2596,0x3F6D3880,0x3F6D4B61,0x3F6D5E39,0x3F6D7108,0x3F6D83CD,0x3F6D968A,0x3F6DA93D,
0x3F6DBBE7,0x3F6DCE88,0x3F6DE120,0x3F6DF3AE,0x3F6E0634,0x3F6E18B0,0x3F6E2B23,0x3F6E3D8D,
0x3F6E4FEE,0x3F6E6245,0x3F6E7493,0x3F6E86D8,0x3F6E9914,0x3F6EAB47,0x3F6EBD71,0x3F6ECF91,
0x3F6EE1A8,0x3F6EF3B6,0x3F6F05BB,0x3F6F17B6,0x3F6F29A8,0x3F6F3B92,0x3F6F4D71,0x3F6F5F48,
0x3F6F7115,0x3F6F82D9,0x3F6F9494,0x3F6FA646,0x3F6FB7EE,0x3F6FC98E,0x3F6FDB24,0x3F6FECB0,
0x3F6FFE34,0x3F700FAE,0x3F70211F,0x3F703286,0x3F7043E5,0x3F70553A,0x3F706686,0x3F7077C8,
0x3F708902,0x3F709A32,0x3F70AB59,0x3F70BC76,0x3F70CD8A,0x3F70DE95,0x3F70EF97,0x3F71008F,
0x3F71117F,0x3F712264,0x3F713341,0x3F714414,0x3F7154DE,0x3F71659F,0x3F717656,0x3F718704,
0x3F7197A8,0x3F71A844,0x3F71B8D6,0x3F71C95F,0x3F71D9DE,0x3F71EA54,0x3F71FAC1,0x3F720B24,
0x3F721B7E,0x3F722BCF,0x3F723C16,0x3F724C54,0x3F725C89,0x3F726CB5,0x3F727CD7,0x3F728CEF,
0x3F729CFF,0x3F72AD05,0x3F72BD01,0x3F72CCF5,0x3F72DCDE,0x3F72ECBF,0x3F72FC96,0x3F730C64,
0x3F731C28,0x3F732BE4,0x3F733B95,0x3F734B3E,0x3F735ADC,0x3F736A72,0x3F7379FE,0x3F738981,
0x3F7398FA,0x3F73A86A,0x3F73B7D1,0x3F73C72E,0x3F73D682,0x3F73E5CC,0x3F73F50D,0x3F740445,
0x3F741373,0x3F742298,0x3F7431B3,0x3F7440C5,0x3F744FCE,0x3F745ECD,0x3F746DC3,0x3F747CAF,
0x3F748B92,0x3F749A6B,0x3F74A93B,0x3F74B802,0x3F74C6BF,0x3F74D573,0x3F74E41D,0x3F74F2BE,
0x3F750155,0x3F750FE3,0x3F751E68,0x3F752CE3,0x3F753B54,0x3F7549BC,0x3F75581B,0x3F756670,
0x3F7574BC,0x3F7582FE,0x3F759137,0x3F759F66,0x3F75AD8C,0x3F75BBA9,0x3F75C9BC,0x3F75D7C5,
0x3F75E5C5,0x3F75F3BC,0x3F7601A9,0x3F760F8C,0x3F761D66,0x3F762B37,0x3F7638FE,0x3F7646BB,
0x3F76546F,0x3F76621A,0x3F766FBB,0x3F767D53,0x3F768AE1,0x3F769865,0x3F76A5E0,0x3F76B352,
0x3F76C0BA,0x3F76CE19,0x3F76DB6E,0x3F76E8B9,0x3F76F5FB,0x3F770334,0x3F771063,0x3F771D88,
0x3F772AA4,0x3F7737B6,0x3F7744BF,0x3F7751BE,0x3F775EB4,0x3F776BA0,0x3F777883,0x3F77855C,
0x3F77922C,0x3F779EF2,0x3F77ABAE,0x3F77B861,0x3F77C50B,0x3F77D1AB,0x3F77DE41,0x3F77EACE,
0x3F77F751,0x3F7803CA,0x3F78103A,0x3F781CA1,0x3F7828FE,0x3F783551,0x3F78419B,0x3F784DDB,
0x3F785A12,0x3F78663F,0x3F787263,0x3F787E7D,0x3F788A8D,0x3F789694,0x3F78A291,0x3F78AE84,
0x3F78BA6E,0x3F78C64F,0x3F78D226,0x3F78DDF3,0x3F78E9B7,0x3F78F571,0x3F790121,0x3F790CC8,
0x3F791865,0x3F7923F9,0x3F792F83,0x3F793B03,0x3F79467A,0x3F7951E7,0x3F795D4B,0x3F7968A5,
0x3F7973F5,0x3F797F3C,0x3F798A79,0x3F7995AD,0x3F79A0D7,0x3F79ABF7,0x3F79B70D,0x3F79C21A,
0x3F79CD1E,0x3F79D818,0x3F79E308,0x3F79EDEE,0x3F79F8CB,0x3F7A039E,0x3F7A0E68,0x3F7A1928,
0x3F7A23DE,0x3F7A2E8B,0x3F7A392E,0x3F7A43C7,0x3F7A4E57,0x3F7A58DD,0x3F7A6359,0x3F7A6DCC,
0x3F7A7835,0x3F7A8295,0x3F7A8CEA,0x3F7A9737,0x3F7AA179,0x3F7AABB2,0x3F7AB5E1,0x3F7AC006,
0x3F7ACA22,0x3F7AD434,0x3F7ADE3D,0x3F7AE83C,0x3F7AF231,0x3F7AFC1C,0x3F7B05FE,0x3F7B0FD6,
0x3F7B19A4,0x3F7B2369,0x3F7B2D24,0x3F7B36D6,0x3F7B407D,0x3F7B4A1B,0x3F7B53B0,0x3F7B5D3A,
0x3F7B66BB,0x3F7B7032,0x3F7B79A0,0x3F7B8304,0x3F7B8C5E,0x3F7B95AE,0x3F7B9EF5,0x3F7BA832,
0x3F7BB166,0x3F7BBA8F,0x3F7BC3AF,0x3F7BCCC5,0x3F7BD5D2,0x3F7BDED5,0x3F7BE7CE,0x3F7BF0BD,
0x3F7BF9A3,0x3F7C027F,0x3F7C0B51,0x3F7C141A,0x3F7C1CD9,0x3F7C258E,0x3F7C2E39,0x3F7C36DB,
0x3F7C3F73,0x3F7C4801,0x3F7C5085,0x3F7C5900,0x3F7C6171,0x3F7C69D8,0x3F7C7236,0x3F7C7A8A,
0x3F7C82D4,0x3F7C8B14,0x3F7C934B,0x3F7C9B78,0x3F7CA39B,0x3F7CABB4,0x3F7CB3C4,0x3F7CBBCA,
0x3F7CC3C6,0x3F7CCBB8,0x3F7CD3A1,0x3F7CDB80,0x3F7CE355,0x3F7CEB21,0x3F7CF2E2,0x3F7CFA9A,
0x3F7D0249,0x3F7D09ED,0x3F7D1188,0x3F7D1919,0x3F7D20A0,0x3F7D281D,0x3F7D2F91,0x3F7D36FB,
0x3F7D3E5B,0x3F7D45B1,0x3F7D4CFE,0x3F7D5441,0x3F7D5B7A,0x3F7D62A9,0x3F7D69CE,0x3F7D70EA,
0x3F7D77FC,0x3F7D7F04,0x3F7D8603,0x3F7D8CF8,0x3F7D93E2,0x3F7D9AC4,0x3F7DA19B,0x3F7DA868,
0x3F7DAF2C,0x3F7DB5E6,0x3F7DBC96,0x3F7DC33D,0x3F7DC9DA,0x3F7DD06C,0x3F7DD6F5,0x3F7DDD75,
0x3F7DE3EA,0x3F7DEA56,0x3F7DF0B8,0x3F7DF710,0x3F7DFD5E,0x3F7E03A3,0x3F7E09DE,0x3F7E100F,
0x3F7E1636,0x3F7E1C53,0x3F7E2267,0x3F7E2871,0x3F7E2E71,0x3F7E3467,0x3F7E3A53,0x3F7E4036,
0x3F7E460F,0x3F7E4BDE,0x3F7E51A3,0x3F7E575E,0x3F7E5D10,0x3F7E62B7,0x3F7E6855,0x3F7E6DEA,
0x3F7E7374,0x3F7E78F4,0x3F7E7E6B,0x3F7E83D8,0x3F7E893B,0x3F7E8E94,0x3F7E93E4,0x3F7E9929,
0x3F7E9E65,0x3F7EA397,0x3F7EA8C0,0x3F7EADDE,0x3F7EB2F2,0x3F7EB7FD,0x3F7EBCFE,0x3F7EC1F5,
0x3F7EC6E3,0x3F7ECBC6,0x3F7ED0A0,0x3F7ED56F,0x3F7EDA35,0x3F7EDEF2,0x3F7EE3A4,0x3F7EE84C,
0x3F7EECEB,0x3F7EF180,0x3F7EF60B,0x3F7EFA8C,0x3F7EFF04,0x3F7F0371,0x3F7F07D5,0x3F7F0C2F,
0x3F7F107F,0x3F7F14C5,0x3F7F1901,0x3F7F1D34,0x3F7F215C,0x3F7F257B,0x3F7F2990,0x3F7F2D9C,
0x3F7F319D,0x3F7F3594,0x3F7F3982,0x3F7F3D66,0x3F7F4140,0x3F7F4510,0x3F7F48D6,0x3F7F4C93,
0x3F7F5045,0x3F7F53EE,0x3F7F578D,0x3F7F5B22,0x3F7F5EAE,0x3F7F622F,0x3F7F65A7,0x3F7F6914,
0x3F7F6C78,0x3F7F6FD2,0x3F7F7322,0x3F7F7669,0x3F7F79A5,0x3F7F7CD8,0x3F7F8000,0x3F7F831F,
0x3F7F8634,0x3F7F8940,0x3F7F8C41,0x3F7F8F39,0x3F7F9226,0x3F7F950A,0x3F7F97E4,0x3F7F9AB4,
0x3F7F9D7A,0x3F7FA037,0x3F7FA2E9,0x3F7FA592,0x3F7FA831,0x3F7FAAC6,0x3F7FAD51,0x3F7FAFD2,
0x3F7FB24A,0x3F7FB4B7,0x3F7FB71B,0x3F7FB975,0x3F7FBBC5,0x3F7FBE0B,0x3F7FC047,0x3F7FC279,
0x3F7FC4A2,0x3F7FC6C1,0x3F7FC8D5,0x3F7FCAE0,0x3F7FCCE1,0x3F7FCED9,0x3F7FD0C6,0x3F7FD2A9,
0x3F7FD483,0x3F7FD653,0x3F7FD819,0x3F7FD9D5,0x3F7FDB87,0x3F7FDD2F,0x3F7FDECE,0x3F7FE062,
0x3F7FE1ED,0x3F7FE36E,0x3F7FE4E5,0x3F7FE652,0x3F7FE7B5,0x3F7FE90F,0x3F7FEA5E,0x3F7FEBA4,
0x3F7FECE0,0x3F7FEE12,0x3F7FEF3A,0x3F7FF058,0x3F7FF16C,0x3F7FF277,0x3F7FF377,0x3F7FF46E,
0x3F7FF55B,0x3F7FF63E,0x3F7FF717,0x3F7FF7E6,0x3F7FF8AC,0x3F7FF967,0x3F7FFA19,0x3F7FFAC1,
0x3F7FFB5E,0x3F7FFBF2,0x3F7FFC7D,0x3F7FFCFD,0x3F7FFD73,0x3F7FFDE0,0x3F7FFE43,0x3F7FFE9B,
0x3F7FFEEA,0x3F7FFF30,0x3F7FFF6B,0x3F7FFF9C,0x3F7FFFC4,0x3F7FFFE1,0x3F7FFFF5,0x3F7FFFFF,
0xBA490FD9,0xBB16CBDB,0xBB7B53A9,0xBBAFEDA8,0xBBE23160,0xBC0A3A7B,0xBC235C30,0xBC3C7DCC,
0xBC559F4C,0xBC6EC0AA,0xBC83F0F2,0xBC90817A,0xBC9D11EC,0xBCA9A246,0xBCB63286,0xBCC2C2A9,
0xBCCF52AF,0xBCDBE294,0xBCE87258,0xBCF501F8,0xBD00C8B9,0xBD071062,0xBD0D57F6,0xBD139F75,
0xBD19E6DD,0xBD202E2D,0xBD267564,0xBD2CBC82,0xBD330385,0xBD394A6C,0xBD3F9137,0xBD45D7E4,
0xBD4C1E73,0xBD5264E2,0xBD58AB31,0xBD5EF15F,0xBD65376A,0xBD6B7D51,0xBD71C315,0xBD7808B3,
0xBD7E4E2B,0xBD8249BE,0xBD856C52,0xBD888ED2,0xBD8BB13C,0xBD8ED391,0xBD91F5D0,0xBD9517F9,
0xBD983A0A,0xBD9B5C05,0xBD9E7DE7,0xBDA19FB0,0xBDA4C161,0xBDA7E2F8,0xBDAB0476,0xBDAE25D9,
0xBDB14721,0xBDB4684E,0xBDB7895F,0xBDBAAA54,0xBDBDCB2C,0xBDC0EBE6,0xBDC40C83,0xBDC72D02,
0xBDCA4D62,0xBDCD6DA3,0xBDD08DC4,0xBDD3ADC5,0xBDD6CDA5,0xBDD9ED64,0xBDDD0D02,0xBDE02C7D,
0xBDE34BD6,0xBDE66B0C,0xBDE98A1F,0xBDECA90D,0xBDEFC7D7,0xBDF2E67C,0xBDF604FB,0xBDF92354,
0xBDFC4187,0xBDFF5F94,0xBE013EBC,0xBE02CD9B,0xBE045C65,0xBE05EB1B,0xBE0779BC,0xBE090848,
0xBE0A96BF,0xBE0C2521,0xBE0DB36D,0xBE0F41A4,0xBE10CFC4,0xBE125DCE,0xBE13EBC1,0xBE15799E,
0xBE170763,0xBE189511,0xBE1A22A8,0xBE1BB027,0xBE1D3D8E,0xBE1ECADD,0xBE205813,0xBE21E530,
0xBE237235,0xBE24FF20,0xBE268BF2,0xBE2818AA,0xBE29A548,0xBE2B31CC,0xBE2CBE36,0xBE2E4A85,
0xBE2FD6B9,0xBE3162D2,0xBE32EECF,0xBE347AB2,0xBE360678,0xBE379222,0xBE391DB0,0xBE3AA921,
0xBE3C3476,0xBE3DBFAD,0xBE3F4AC7,0xBE40D5C4,0xBE4260A3,0xBE43EB64,0xBE457607,0xBE47008B,
0xBE488AF1,0xBE4A1538,0xBE4B9F5F,0xBE4D2967,0xBE4EB350,0xBE503D19,0xBE51C6C1,0xBE535049,
0xBE54D9B1,0xBE5662F8,0xBE57EC1D,0xBE597522,0xBE5AFE05,0xBE5C86C6,0xBE5E0F65,0xBE5F97E2,
0xBE61203C,0xBE62A874,0xBE643089,0xBE65B87A,0xBE674048,0xBE68C7F3,0xBE6A4F79,0xBE6BD6DC,
0xBE6D5E1A,0xBE6EE533,0xBE706C28,0xBE71F2F7,0xBE7379A1,0xBE750026,0xBE768685,0xBE780CBE,
0xBE7992D0,0xBE7B18BC,0xBE7C9E82,0xBE7E2420,0xBE7FA998,0xBE809774,0xBE815A08,0xBE821C88,
0xBE82DEF4,0xBE83A14C,0xBE84638F,0xBE8525BF,0xBE85E7D9,0xBE86A9DF,0xBE876BD0,0xBE882DAD,
0xBE88EF74,0xBE89B126,0xBE8A72C3,0xBE8B344B,0xBE8BF5BD,0xBE8CB71A,0xBE8D7861,0xBE8E3992,
0xBE8EFAAD,0xBE8FBBB2,0xBE907CA1,0xBE913D79,0xBE91FE3C,0xBE92BEE7,0xBE937F7D,0xBE943FFB,
0xBE950062,0xBE95C0B3,0xBE9680EC,0xBE97410E,0xBE980119,0xBE98C10D,0xBE9980E9,0xBE9A40AD,
0xBE9B0059,0xBE9BBFEE,0xBE9C7F6A,0xBE9D3ECF,0xBE9DFE1B,0xBE9EBD4F,0xBE9F7C6A,0xBEA03B6D,
0xBEA0FA57,0xBEA1B928,0xBEA277E0,0xBEA3367F,0xBEA3F505,0xBEA4B372,0xBEA571C5,0xBEA62FFF,
0xBEA6EE1F,0xBEA7AC25,0xBEA86A12,0xBEA927E5,0xBEA9E59D,0xBEAAA33B,0xBEAB60BF,0xBEAC1E29,
0xBEACDB78,0xBEAD98AC,0xBEAE55C6,0xBEAF12C5,0xBEAFCFA8,0xBEB08C71,0xBEB1491E,0xBEB205B0,
0xBEB2C227,0xBEB37E82,0xBEB43AC1,0xBEB4F6E5,0xBEB5B2EC,0xBEB66ED8,0xBEB72AA7,0xBEB7E65B,
0xBEB8A1F1,0xBEB95D6C,0xBEBA18CA,0xBEBAD40B,0xBEBB8F2F,0xBEBC4A36,0xBEBD0521,0xBEBDBFEE,
0xBEBE7A9E,0xBEBF3530,0xBEBFEFA5,0xBEC0A9FD,0xBEC16437,0xBEC21E53,0xBEC2D851,0xBEC39231,
0xBEC44BF2,0xBEC50596,0xBEC5BF1B,0xBEC67882,0xBEC731CA,0xBEC7EAF3,0xBEC8A3FD,0xBEC95CE9,
0xBECA15B5,0xBECACE63,0xBECB86F1,0xBECC3F60,0xBECCF7AF,0xBECDAFDE,0xBECE67EE,0xBECF1FDE,
0xBECFD7AE,0xBED08F5E,0xBED146EE,0xBED1FE5E,0xBED2B5AD,0xBED36CDB,0xBED423EA,0xBED4DAD7,
0xBED591A4,0xBED6484F,0xBED6FEDA,0xBED7B543,0xBED86B8B,0xBED921B2,0xBED9D7B7,0xBEDA8D9B,
0xBEDB435D,0xBEDBF8FD,0xBEDCAE7C,0xBEDD63D8,0xBEDE1912,0xBEDECE2A,0xBEDF831F,0xBEE037F2,
0xBEE0ECA3,0xBEE1A130,0xBEE2559B,0xBEE309E3,0xBEE3BE08,0xBEE4720A,0xBEE525E9,0xBEE5D9A4,
0xBEE68D3C,0xBEE740B1,0xBEE7F401,0xBEE8A72E,0xBEE95A37,0xBEEA0D1C,0xBEEABFDD,0xBEEB727A,
0xBEEC24F3,0xBEECD747,0xBEED8976,0xBEEE3B81,0xBEEEED67,0xBEEF9F28,0xBEF050C5,0xBEF1023C,
0xBEF1B38E,0xBEF264BB,0xBEF315C2,0xBEF3C6A4,0xBEF47761,0xBEF527F8,0xBEF5D868,0xBEF688B3,
0xBEF738D8,0xBEF7E8D7,0xBEF898B0,0xBEF94862,0xBEF9F7EE,0xBEFAA753,0xBEFB5692,0xBEFC05AA,
0xBEFCB49B,0xBEFD6365,0xBEFE1207,0xBEFEC083,0xBEFF6ED8,0xBF000E82,0xBF006585,0xBF00BC74,
0xBF01134F,0xBF016A17,0xBF01C0CA,0xBF021769,0xBF026DF4,0xBF02C46B,0xBF031ACE,0xBF03711D,
0xBF03C757,0xBF041D7E,0xBF04738F,0xBF04C98D,0xBF051F75,0xBF05754A,0xBF05CB0A,0xBF0620B5,
0xBF06764B,0xBF06CBCD,0xBF07213A,0xBF077692,0xBF07CBD5,0xBF082103,0xBF08761C,0xBF08CB20,
0xBF092010,0xBF0974E9,0xBF09C9AE,0xBF0A1E5E,0xBF0A72F8,0xBF0AC77D,0xBF0B1BEC,0xBF0B7046,
0xBF0BC48B,0xBF0C18BA,0xBF0C6CD3,0xBF0CC0D7,0xBF0D14C5,0xBF0D689D,0xBF0DBC5F,0xBF0E100C,
0xBF0E63A2,0xBF0EB723,0xBF0F0A8E,0xBF0F5DE2,0xBF0FB121,0xBF100449,0xBF10575B,0xBF10AA57,
0xBF10FD3D,0xBF11500C,0xBF11A2C5,0xBF11F567,0xBF1247F3,0xBF129A68,0xBF12ECC7,0xBF133F0F,
0xBF139140,0xBF13E35B,0xBF14355E,0xBF14874B,0xBF14D921,0xBF152AE0,0xBF157C88,0xBF15CE19,
0xBF161F93,0xBF1670F6,0xBF16C241,0xBF171376,0xBF176493,0xBF17B598,0xBF180687,0xBF18575D,
0xBF18A81D,0xBF18F8C4,0xBF194955,0xBF1999CD,0xBF19EA2E,0xBF1A3A77,0xBF1A8AA8,0xBF1ADAC2,
0xBF1B2AC3,0xBF1B7AAD,0xBF1BCA7F,0xBF1C1A38,0xBF1C69DA,0xBF1CB963,0xBF1D08D5,0xBF1D582E,
0xBF1DA76F,0xBF1DF697,0xBF1E45A7,0xBF1E949F,0xBF1EE37E,0xBF1F3245,0xBF1F80F3,0xBF1FCF89,
0xBF201E06,0xBF206C6A,0xBF20BAB6,0xBF2108E9,0xBF215703,0xBF21A504,0xBF21F2EC,0xBF2240BB,
0xBF228E71,0xBF22DC0E,0xBF232992,0xBF2376FD,0xBF23C44F,0xBF241187,0xBF245EA6,0xBF24ABAC,
0xBF24F898,0xBF25456B,0xBF259224,0xBF25DEC4,0xBF262B4A,0xBF2677B7,0xBF26C40A,0xBF271043,
0xBF275C62,0xBF27A868,0xBF27F454,0xBF284026,0xBF288BDE,0xBF28D77C,0xBF292300,0xBF296E69,
0xBF29B9B9,0xBF2A04EF,0xBF2A500A,0xBF2A9B0B,0xBF2AE5F2,0xBF2B30BE,0xBF2B7B70,0xBF2BC608,
0xBF2C1085,0xBF2C5AE7,0xBF2CA52F,0xBF2CEF5D,0xBF2D396F,0xBF2D8367,0xBF2DCD44,0xBF2E1707,
0xBF2E60AE,0xBF2EAA3B,0xBF2EF3AD,0xBF2F3D03,0xBF2F863F,0xBF2FCF60,0xBF301865,0xBF306150,
0xBF30AA1F,0xBF30F2D3,0xBF313B6B,0xBF3183E9,0xBF31CC4B,0xBF321491,0xBF325CBC,0xBF32A4CC,
0xBF32ECC0,0xBF333498,0xBF337C55,0xBF33C3F6,0xBF340B7B,0xBF3452E5,0xBF349A33,0xBF34E165,
0x3F35287B,0x3F356F75,0x3F35B653,0x3F35FD15,0x3F3643BB,0x3F368A45,0x3F36D0B3,0x3F371704,
0x3F375D3A,0x3F37A353,0x3F37E950,0x3F382F30,0x3F3874F4,0x3F38BA9C,0x3F390027,0x3F394595,
0x3F398AE7,0x3F39D01D,0x3F3A1535,0x3F3A5A31,0x3F3A9F10,0x3F3AE3D3,0x3F3B2879,0x3F3B6D01,
0x3F3BB16D,0x3F3BF5BC,0x3F3C39EE,0x3F3C7E03,0x3F3CC1FB,0x3F3D05D6,0x3F3D4993,0x3F3D8D34,
0x3F3DD0B7,0x3F3E141D,0x3F3E5766,0x3F3E9A91,0x3F3EDD9F,0x3F3F208F,0x3F3F6362,0x3F3FA617,
0x3F3FE8AF,0x3F402B2A,0x3F406D86,0x3F40AFC5,0x3F40F1E7,0x3F4133EA,0x3F4175D0,0x3F41B798,
0x3F41F942,0x3F423ACE,0x3F427C3C,0x3F42BD8C,0x3F42FEBE,0x3F433FD2,0x3F4380C8,0x3F43C1A0,
0x3F44025A,0x3F4442F5,0x3F448372,0x3F44C3D1,0x3F450411,0x3F454433,0x3F458437,0x3F45C41C,
0x3F4603E3,0x3F46438B,0x3F468315,0x3F46C280,0x3F4701CC,0x3F4740FA,0x3F478008,0x3F47BEF9,
0x3F47FDCA,0x3F483C7C,0x3F487B10,0x3F48B985,0x3F48F7DA,0x3F493611,0x3F497429,0x3F49B222,
0x3F49EFFB,0x3F4A2DB6,0x3F4A6B51,0x3F4AA8CD,0x3F4AE62A,0x3F4B2367,0x3F4B6085,0x3F4B9D84,
0x3F4BDA63,0x3F4C1723,0x3F4C53C4,0x3F4C9045,0x3F4CCCA6,0x3F4D08E8,0x3F4D450A,0x3F4D810D,
0x3F4DBCF0,0x3F4DF8B3,0x3F4E3456,0x3F4E6FDA,0x3F4EAB3E,0x3F4EE681,0x3F4F21A5,0x3F4F5CA9,
0x3F4F978D,0x3F4FD252,0x3F500CF6,0x3F504779,0x3F5081DD,0x3F50BC21,0x3F50F644,0x3F513047,
0x3F516A2A,0x3F51A3ED,0x3F51DD8F,0x3F521711,0x3F525073,0x3F5289B4,0x3F52C2D5,0x3F52FBD5,
0x3F5334B5,0x3F536D74,0x3F53A612,0x3F53DE90,0x3F5416ED,0x3F544F2A,0x3F548745,0x3F54BF40,
0x3F54F71A,0x3F552ED4,0x3F55666C,0x3F559DE3,0x3F55D53A,0x3F560C70,0x3F564384,0x3F567A78,
0x3F56B14A,0x3F56E7FB,0x3F571E8C,0x3F5754FB,0x3F578B48,0x3F57C175,0x3F57F780,0x3F582D6A,
0x3F586333,0x3F5898DA,0x3F58CE60,0x3F5903C5,0x3F593908,0x3F596E29,0x3F59A329,0x3F59D807,
0x3F5A0CC4,0x3F5A415F,0x3F5A75D9,0x3F5AAA31,0x3F5ADE67,0x3F5B127B,0x3F5B466E,0x3F5B7A3E,
0x3F5BADED,0x3F5BE17A,0x3F5C14E6,0x3F5C482F,0x3F5C7B56,0x3F5CAE5B,0x3F5CE13E,0x3F5D13FF,
0x3F5D469E,0x3F5D791B,0x3F5DAB76,0x3F5DDDAF,0x3F5E0FC5,0x3F5E41B9,0x3F5E738B,0x3F5EA53A,
0x3F5ED6C8,0x3F5F0833,0x3F5F397B,0x3F5F6AA1,0x3F5F9BA5,0x3F5FCC86,0x3F5FFD44,0x3F602DE0,
0x3F605E5A,0x3F608EB0,0x3F60BEE5,0x3F60EEF6,0x3F611EE5,0x3F614EB1,0x3F617E5B,0x3F61ADE1,
0x3F61DD45,0x3F620C86,0x3F623BA4,0x3F626AA0,0x3F629978,0x3F62C82D,0x3F62F6C0,0x3F63252F,
0x3F63537B,0x3F6381A5,0x3F63AFAB,0x3F63DD8E,0x3F640B4E,0x3F6438EB,0x3F646665,0x3F6493BB,
0x3F64C0EE,0x3F64EDFE,0x3F651AEB,0x3F6547B4,0x3F65745A,0x3F65A0DC,0x3F65CD3B,0x3F65F977,
0x3F66258F,0x3F665184,0x3F667D55,0x3F66A903,0x3F66D48D,0x3F66FFF3,0x3F672B36,0x3F675655,
0x3F678151,0x3F67AC29,0x3F67D6DD,0x3F68016D,0x3F682BDA,0x3F685623,0x3F688047,0x3F68AA49,
0x3F68D426,0x3F68FDDF,0x3F692774,0x3F6950E6,0x3F697A33,0x3F69A35D,0x3F69CC62,0x3F69F543,
0x3F6A1E01,0x3F6A469A,0x3F6A6F0F,0x3F6A9760,0x3F6ABF8C,0x3F6AE795,0x3F6B0F79,0x3F6B3739,
0x3F6B5ED5,0x3F6B864C,0x3F6BADA0,0x3F6BD4CE,0x3F6BFBD9,0x3F6C22BF,0x3F6C4980,0x3F6C701E,
0x3F6C9696,0x3F6CBCEA,0x3F6CE31A,0x3F6D0925,0x3F6D2F0C,0x3F6D54CE,0x3F6D7A6C,0x3F6D9FE4,
0x3F6DC539,0x3F6DEA68,0x3F6E0F73,0x3F6E3459,0x3F6E591A,0x3F6E7DB7,0x3F6EA22F,0x3F6EC682,
0x3F6EEAB0,0x3F6F0EBA,0x3F6F329E,0x3F6F565E,0x3F6F79F8,0x3F6F9D6E,0x3F6FC0BF,0x3F6FE3EB,
0x3F7006F2,0x3F7029D4,0x3F704C91,0x3F706F28,0x3F70919B,0x3F70B3E9,0x3F70D611,0x3F70F814,
0x3F7119F3,0x3F713BAC,0x3F715D3F,0x3F717EAE,0x3F719FF7,0x3F71C11B,0x3F71E21A,0x3F7202F4,
0x3F7223A8,0x3F724437,0x3F7264A0,0x3F7284E4,0x3F72A503,0x3F72C4FC,0x3F72E4D0,0x3F73047E,
0x3F732407,0x3F73436B,0x3F7362A8,0x3F7381C1,0x3F73A0B4,0x3F73BF81,0x3F73DE28,0x3F73FCAA,
0x3F741B07,0x3F74393E,0x3F74574F,0x3F74753A,0x3F749300,0x3F74B0A0,0x3F74CE1A,0x3F74EB6F,
0x3F75089D,0x3F7525A6,0x3F754289,0x3F755F47,0x3F757BDE,0x3F759850,0x3F75B49C,0x3F75D0C2,
0x3F75ECC2,0x3F76089C,0x3F762450,0x3F763FDE,0x3F765B46,0x3F767688,0x3F7691A4,0x3F76AC9A,
0x3F76C76B,0x3F76E215,0x3F76FC99,0x3F7716F6,0x3F77312E,0x3F774B40,0x3F77652B,0x3F777EF1,
0x3F779890,0x3F77B209,0x3F77CB5C,0x3F77E488,0x3F77FD8F,0x3F78166F,0x3F782F29,0x3F7847BC,
0x3F78602A,0x3F787871,0x3F789091,0x3F78A88C,0x3F78C060,0x3F78D80E,0x3F78EF95,0x3F7906F6,
0x3F791E30,0x3F793544,0x3F794C32,0x3F7962F9,0x3F79799A,0x3F799014,0x3F79A668,0x3F79BC95,
0x3F79D29C,0x3F79E87C,0x3F79FE36,0x3F7A13C9,0x3F7A2936,0x3F7A3E7C,0x3F7A539B,0x3F7A6894,
0x3F7A7D66,0x3F7A9212,0x3F7AA697,0x3F7ABAF5,0x3F7ACF2D,0x3F7AE33D,0x3F7AF728,0x3F7B0AEB,
0x3F7B1E88,0x3F7B31FE,0x3F7B454E,0x3F7B5876,0x3F7B6B78,0x3F7B7E53,0x3F7B9107,0x3F7BA395,
0x3F7BB5FC,0x3F7BC83B,0x3F7BDA55,0x3F7BEC47,0x3F7BFE12,0x3F7C0FB7,0x3F7C2134,0x3F7C328B,
0x3F7C43BB,0x3F7C54C4,0x3F7C65A6,0x3F7C7661,0x3F7C86F5,0x3F7C9762,0x3F7CA7A9,0x3F7CB7C8,
0x3F7CC7C0,0x3F7CD792,0x3F7CE73C,0x3F7CF6C0,0x3F7D061C,0x3F7D1551,0x3F7D2460,0x3F7D3347,
0x3F7D4207,0x3F7D50A0,0x3F7D5F13,0x3F7D6D5E,0x3F7D7B82,0x3F7D897E,0x3F7D9754,0x3F7DA503,
0x3F7DB28A,0x3F7DBFEB,0x3F7DCD24,0x3F7DDA36,0x3F7DE721,0x3F7DF3E5,0x3F7E0082,0x3F7E0CF7,
0x3F7E1946,0x3F7E256D,0x3F7E316D,0x3F7E3D46,0x3F7E48F7,0x3F7E5482,0x3F7E5FE5,0x3F7E6B21,
0x3F7E7635,0x3F7E8123,0x3F7E8BE9,0x3F7E9688,0x3F7EA100,0x3F7EAB50,0x3F7EB579,0x3F7EBF7B,
0x3F7EC955,0x3F7ED309,0x3F7EDC95,0x3F7EE5F9,0x3F7EEF37,0x3F7EF84D,0x3F7F013C,0x3F7F0A03,
0x3F7F12A3,0x3F7F1B1C,0x3F7F236D,0x3F7F2B97,0x3F7F339A,0x3F7F3B75,0x3F7F4329,0x3F7F4AB6,
0x3F7F521B,0x3F7F5959,0x3F7F606F,0x3F7F675F,0x3F7F6E26,0x3F7F74C7,0x3F7F7B40,0x3F7F8191,
0x3F7F87BB,0x3F7F8DBE,0x3F7F9399,0x3F7F994D,0x3F7F9EDA,0x3F7FA43F,0x3F7FA97D,0x3F7FAE93,
0x3F7FB382,0x3F7FB849,0x3F7FBCE9,0x3F7FC161,0x3F7FC5B2,0x3F7FC9DC,0x3F7FCDDE,0x3F7FD1B9,
0x3F7FD56C,0x3F7FD8F8,0x3F7FDC5C,0x3F7FDF99,0x3F7FE2AF,0x3F7FE59D,0x3F7FE863,0x3F7FEB02,
0x3F7FED7A,0x3F7FEFCA,0x3F7FF1F3,0x3F7FF3F4,0x3F7FF5CE,0x3F7FF780,0x3F7FF90B,0x3F7FFA6E,
0x3F7FFBAA,0x3F7FFCBE,0x3F7FFDAB,0x3F7FFE70,0x3F7FFF0E,0x3F7FFF85,0x3F7FFFD4,0x3F7FFFFB,
0xBAC90FD5,0xBB96CBC1,0xBBFB5330,0xBC2FED02,0xBC622FFF,0xBC8A3938,0xBCA35A1C,0xBCBC7A9B,
0xBCD59AA6,0xBCEEBA2C,0xBD03EC90,0xBD107BB8,0xBD1D0A88,0xBD2998F6,0xBD3626FC,0xBD42B491,
0xBD4F41AF,0xBD5BCE4C,0xBD685A62,0xBD74E5E9,0xBD80B86C,0xBD86FD94,0xBD8D426A,0xBD9386E7,
0xBD99CB0A,0xBDA00ECF,0xBDA65230,0xBDAC952B,0xBDB2D7BB,0xBDB919DD,0xBDBF5B8D,0xBDC59CC6,
0xBDCBDD86,0xBDD21DC8,0xBDD85D89,0xBDDE9CC4,0xBDE4DB76,0xBDEB199A,0xBDF1572E,0xBDF7942C,
0xBDFDD092,0xBE02062E,0xBE0523C2,0xBE084105,0xBE0B5DF3,0xBE0E7A8B,0xBE1196CC,0xBE14B2B2,
0xBE17CE3D,0xBE1AE96B,0xBE1E0438,0xBE211EA5,0xBE2438AD,0xBE275251,0xBE2A6B8D,0xBE2D8461,
0xBE309CC9,0xBE33B4C4,0xBE36CC50,0xBE39E36C,0xBE3CFA15,0xBE401049,0xBE432607,0xBE463B4D,
0xBE495018,0xBE4C6467,0xBE4F7838,0xBE528B89,0xBE559E58,0xBE58B0A4,0xBE5BC26A,0xBE5ED3A8,
0xBE61E45C,0xBE64F486,0xBE680422,0xBE6B132F,0xBE6E21AB,0xBE712F94,0xBE743CE8,0xBE7749A6,
0xBE7A55CB,0xBE7D6156,0xBE803622,0xBE81BB4A,0xBE834022,0xBE84C4AA,0xBE8648DF,0xBE87CCC1,
0xBE895050,0xBE8AD38A,0xBE8C566E,0xBE8DD8FC,0xBE8F5B32,0xBE90DD10,0xBE925E94,0xBE93DFBF,
0xBE95608D,0xBE96E100,0xBE986116,0xBE99E0CE,0xBE9B6027,0xBE9CDF20,0xBE9E5DB8,0xBE9FDBEE,
0xBEA159C2,0xBEA2D733,0xBEA4543F,0xBEA5D0E5,0xBEA74D25,0xBEA8C8FE,0xBEAA446F,0xBEABBF77,
0xBEAD3A15,0xBEAEB449,0xBEB02E10,0xBEB1A76B,0xBEB32058,0xBEB498D6,0xBEB610E6,0xBEB78884,
0xBEB8FFB2,0xBEBA766E,0xBEBBECB6,0xBEBD628B,0xBEBED7EB,0xBEC04CD5,0xBEC1C148,0xBEC33544,
0xBEC4A8C8,0xBEC61BD2,0xBEC78E62,0xBEC90077,0xBECA7210,0xBECBE32C,0xBECD53CA,0xBECEC3EA,
0xBED0338A,0xBED1A2AA,0xBED31148,0xBED47F64,0xBED5ECFD,0xBED75A13,0xBED8C6A3,0xBEDA32AD,
0xBEDB9E31,0xBEDD092E,0xBEDE73A2,0xBEDFDD8D,0xBEE146EE,0xBEE2AFC4,0xBEE4180E,0xBEE57FCB,
0xBEE6E6FB,0xBEE84D9C,0xBEE9B3AE,0xBEEB1930,0xBEEC7E21,0xBEEDE280,0xBEEF464C,0xBEF0A985,
0xBEF20C29,0xBEF36E38,0xBEF4CFB1,0xBEF63093,0xBEF790DC,0xBEF8F08E,0xBEFA4FA5,0xBEFBAE22,
0xBEFD0C04,0xBEFE694A,0xBEFFC5F3,0xBF0090FF,0xBF013EB5,0xBF01EC1C,0xBF029932,0xBF0345F8,
0xBF03F26D,0xBF049E91,0xBF054A62,0xBF05F5E2,0xBF06A10E,0xBF074BE8,0xBF07F66F,0xBF08A0A1,
0xBF094A7F,0xBF09F409,0xBF0A9D3D,0xBF0B461C,0xBF0BEEA5,0xBF0C96D7,0xBF0D3EB3,0xBF0DE638,
0xBF0E8D65,0xBF0F343B,0xBF0FDAB8,0xBF1080DC,0xBF1126A7,0xBF11CC19,0xBF127130,0xBF1315EE,
0xBF13BA50,0xBF145E58,0xBF150204,0xBF15A554,0xBF164847,0xBF16EADE,0xBF178D18,0xBF182EF5,
0xBF18D073,0xBF197194,0xBF1A1255,0xBF1AB2B8,0xBF1B52BB,0xBF1BF25F,0xBF1C91A2,0xBF1D3084,
0xBF1DCF06,0xBF1E6D26,0xBF1F0AE5,0xBF1FA841,0xBF20453B,0xBF20E1D2,0xBF217E06,0xBF2219D7,
0xBF22B543,0xBF23504B,0xBF23EAEE,0xBF24852C,0xBF251F04,0xBF25B877,0xBF265184,0xBF26EA2A,
0xBF278268,0xBF281A40,0xBF28B1B0,0xBF2948B8,0xBF29DF57,0xBF2A758E,0xBF2B0B5B,0xBF2BA0BF,
0xBF2C35B9,0xBF2CCA49,0xBF2D5E6F,0xBF2DF229,0xBF2E8578,0xBF2F185B,0xBF2FAAD3,0xBF303CDE,
0xBF30CE7C,0xBF315FAD,0xBF31F071,0xBF3280C7,0xBF3310AF,0xBF33A029,0xBF342F34,0xBF34BDCF,
0x3F354BFB,0x3F35D9B8,0x3F366704,0x3F36F3DF,0x3F37804A,0x3F380C43,0x3F3897CB,0x3F3922E1,
0x3F39AD85,0x3F3A37B7,0x3F3AC175,0x3F3B4AC1,0x3F3BD398,0x3F3C5BFC,0x3F3CE3EC,0x3F3D6B67,
0x3F3DF26E,0x3F3E78FF,0x3F3EFF1B,0x3F3F84C0,0x3F4009F0,0x3F408EA9,0x3F4112EC,0x3F4196B7,
0x3F421A0B,0x3F429CE8,0x3F431F4C,0x3F43A138,0x3F4422AB,0x3F44A3A5,0x3F452426,0x3F45A42D,
0x3F4623BB,0x3F46A2CE,0x3F472167,0x3F479F84,0x3F481D27,0x3F489A4E,0x3F4916FA,0x3F499329,
0x3F4A0EDC,0x3F4A8A13,0x3F4B04CC,0x3F4B7F09,0x3F4BF8C7,0x3F4C7208,0x3F4CEACB,0x3F4D6310,
0x3F4DDAD5,0x3F4E521C,0x3F4EC8E4,0x3F4F3F2B,0x3F4FB4F4,0x3F502A3B,0x3F509F03,0x3F51134A,
0x3F518710,0x3F51FA54,0x3F526D18,0x3F52DF59,0x3F535118,0x3F53C255,0x3F54330F,0x3F54A347,
0x3F5512FB,0x3F55822C,0x3F55F0D9,0x3F565F02,0x3F56CCA7,0x3F5739C7,0x3F57A663,0x3F581279,
0x3F587E0B,0x3F58E916,0x3F59539C,0x3F59BD9C,0x3F5A2716,0x3F5A9009,0x3F5AF875,0x3F5B605A,
0x3F5BC7B8,0x3F5C2E8E,0x3F5C94DD,0x3F5CFAA3,0x3F5D5FE1,0x3F5DC497,0x3F5E28C3,0x3F5E8C67,
0x3F5EEF81,0x3F5F5212,0x3F5FB419,0x3F601596,0x3F607689,0x3F60D6F2,0x3F6136D0,0x3F619622,
0x3F61F4EA,0x3F625326,0x3F62B0D7,0x3F630DFC,0x3F636A95,0x3F63C6A1,0x3F642221,0x3F647D14,
0x3F64D77B,0x3F653154,0x3F658AA0,0x3F65E35E,0x3F663B8E,0x3F669330,0x3F66EA45,0x3F6740CA,
0x3F6796C1,0x3F67EC29,0x3F684103,0x3F68954C,0x3F68E907,0x3F693C32,0x3F698ECC,0x3F69E0D7,
0x3F6A3252,0x3F6A833C,0x3F6AD395,0x3F6B235E,0x3F6B7295,0x3F6BC13B,0x3F6C0F50,0x3F6C5CD4,
0x3F6CA9C5,0x3F6CF624,0x3F6D41F2,0x3F6D8D2D,0x3F6DD7D5,0x3F6E21EB,0x3F6E6B6D,0x3F6EB45D,
0x3F6EFCBA,0x3F6F4483,0x3F6F8BB8,0x3F6FD25A,0x3F701867,0x3F705DE1,0x3F70A2C6,0x3F70E717,
0x3F712AD4,0x3F716DFB,0x3F71B08E,0x3F71F28C,0x3F7233F4,0x3F7274C7,0x3F72B504,0x3F72F4AC,
0x3F7333BE,0x3F737239,0x3F73B01F,0x3F73ED6E,0x3F742A27,0x3F746649,0x3F74A1D5,0x3F74DCC9,
0x3F751727,0x3F7550ED,0x3F758A1C,0x3F75C2B3,0x3F75FAB3,0x3F76321B,0x3F7668EC,0x3F769F24,
0x3F76D4C4,0x3F7709CC,0x3F773E3C,0x3F777213,0x3F77A551,0x3F77D7F7,0x3F780A04,0x3F783B77,
0x3F786C52,0x3F789C93,0x3F78CC3B,0x3F78FB4A,0x3F7929BF,0x3F79579A,0x3F7984DC,0x3F79B183,
0x3F79DD91,0x3F7A0904,0x3F7A33DD,0x3F7A5E1C,0x3F7A87C1,0x3F7AB0CB,0x3F7AD93A,0x3F7B010E,
0x3F7B2848,0x3F7B4EE7,0x3F7B74EA,0x3F7B9A53,0x3F7BBF20,0x3F7BE353,0x3F7C06E9,0x3F7C29E5,
0x3F7C4C44,0x3F7C6E08,0x3F7C8F31,0x3F7CAFBD,0x3F7CCFAE,0x3F7CEF03,0x3F7D0DBC,0x3F7D2BD8,
0x3F7D4959,0x3F7D663D,0x3F7D8285,0x3F7D9E30,0x3F7DB940,0x3F7DD3B2,0x3F7DED88,0x3F7E06C2,
0x3F7E1F5E,0x3F7E375E,0x3F7E4EC1,0x3F7E6588,0x3F7E7BB1,0x3F7E913D,0x3F7EA62D,0x3F7EBA7F,
0x3F7ECE34,0x3F7EE14C,0x3F7EF3C7,0x3F7F05A4,0x3F7F16E4,0x3F7F2787,0x3F7F378C,0x3F7F46F4,
0x3F7F55BF,0x3F7F63EC,0x3F7F717B,0x3F7F7E6D,0x3F7F8AC2,0x3F7F9678,0x3F7FA191,0x3F7FAC0D,
0x3F7FB5EA,0x3F7FBF2A,0x3F7FC7CC,0x3F7FCFD1,0x3F7FD737,0x3F7FDE00,0x3F7FE42B,0x3F7FE9B8,
0x3F7FEEA7,0x3F7FF2F8,0x3F7FF6AC,0x3F7FF9C1,0x3F7FFC39,0x3F7FFE13,0x3F7FFF4E,0x3F7FFFEC,
0xBB490FC6,0xBC16CB58,0xBC7B514B,0xBCAFEA69,0xBCE22A7A,0xBD0A342F,0xBD2351CB,0xBD3C6DD5,
0xBD55880E,0xBD6EA038,0xBD83DB0A,0xBD9064B4,0xBD9CECF9,0xBDA973BA,0xBDB5F8DA,0xBDC27C39,
0xBDCEFDB7,0xBDDB7D37,0xBDE7FA9A,0xBDF475C0,0xBE007745,0xBE06B26E,0xBE0CEC4A,0xBE1324CA,
0xBE195BE0,0xBE1F917B,0xBE25C58C,0xBE2BF804,0xBE3228D4,0xBE3857EC,0xBE3E853E,0xBE44B0B9,
0xBE4ADA4F,0xBE5101F1,0xBE57278F,0xBE5D4B1A,0xBE636C83,0xBE698BBA,0xBE6FA8B2,0xBE75C35A,
0xBE7BDBA4,0xBE80F8C0,0xBE840270,0xBE870ADA,0xBE8A11F7,0xBE8D17C0,0xBE901C2C,0xBE931F35,
0xBE9620D2,0xBE9920FE,0xBE9C1FAF,0xBE9F1CDF,0xBEA21887,0xBEA5129F,0xBEA80B1F,0xBEAB0201,
0xBEADF73C,0xBEB0EACB,0xBEB3DCA5,0xBEB6CCC3,0xBEB9BB1E,0xBEBCA7AF,0xBEBF926F,0xBEC27B55,
0xBEC5625C,0xBEC8477C,0xBECB2AAE,0xBECE0BEA,0xBED0EB2A,0xBED3C867,0xBED6A399,0xBED97CB9,
0xBEDC53C1,0xBEDF28A9,0xBEE1FB6A,0xBEE4CBFE,0xBEE79A5D,0xBEEA6681,0xBEED3063,0xBEEFF7FB,
0xBEF2BD43,0xBEF58035,0xBEF840C8,0xBEFAFEF7,0xBEFDBABB,0xBF003A06,0xBF019573,0xBF02EF9F,
0xBF044889,0xBF05A02C,0xBF06F686,0xBF084B92,0xBF099F4E,0xBF0AF1B7,0xBF0C42C9,0xBF0D9281,
0xBF0EE0DB,0xBF102DD5,0xBF11796B,0xBF12C39A,0xBF140C5F,0xBF1553B7,0xBF16999F,0xBF17DE12,
0xBF19210F,0xBF1A6293,0xBF1BA299,0xBF1CE11F,0xBF1E1E22,0xBF1F599F,0xBF209393,0xBF21CBFB,
0xBF2302D3,0xBF24381A,0xBF256BCB,0xBF269DE3,0xBF27CE61,0xBF28FD41,0xBF2A2A80,0xBF2B561B,
0xBF2C800F,0xBF2DA859,0xBF2ECEF7,0xBF2FF3E6,0xBF311722,0xBF3238AA,0xBF33587A,0xBF34768F,
0x3F3592E7,0x3F36AD7F,0x3F37C655,0x3F38DD65,0x3F39F2AC,0x3F3B0629,0x3F3C17D9,0x3F3D27B8,
0x3F3E35C5,0x3F3F41FC,0x3F404C5C,0x3F4154E1,0x3F425B89,0x3F436051,0x3F446337,0x3F456439,
0x3F466354,0x3F476085,0x3F485BCA,0x3F495521,0x3F4A4C87,0x3F4B41FA,0x3F4C3578,0x3F4D26FD,
0x3F4E1689,0x3F4F0417,0x3F4FEFA8,0x3F50D937,0x3F51C0C2,0x3F52A649,0x3F5389C7,0x3F546B3B,
0x3F554AA4,0x3F5627FE,0x3F570348,0x3F57DC7F,0x3F58B3A1,0x3F5988AD,0x3F5A5BA0,0x3F5B2C79,
0x3F5BFB34,0x3F5CC7D1,0x3F5D924D,0x3F5E5AA6,0x3F5F20DB,0x3F5FE4E9,0x3F60A6CF,0x3F61668A,
0x3F62241A,0x3F62DF7B,0x3F6398AC,0x3F644FAC,0x3F650479,0x3F65B710,0x3F666771,0x3F671599,
0x3F67C187,0x3F686B39,0x3F6912AE,0x3F69B7E4,0x3F6A5AD9,0x3F6AFB8C,0x3F6B99FB,0x3F6C3624,
0x3F6CD007,0x3F6D67A1,0x3F6DFCF2,0x3F6E8FF8,0x3F6F20B0,0x3F6FAF1B,0x3F703B37,0x3F70C501,
0x3F714C7A,0x3F71D19F,0x3F725470,0x3F72D4EB,0x3F73530E,0x3F73CED9,0x3F74484B,0x3F74BF62,
0x3F75341D,0x3F75A67B,0x3F76167A,0x3F76841B,0x3F76EF5B,0x3F77583A,0x3F77BEB7,0x3F7822D1,
0x3F788486,0x3F78E3D6,0x3F7940C0,0x3F799B43,0x3F79F35E,0x3F7A4910,0x3F7A9C59,0x3F7AED37,
0x3F7B3BAB,0x3F7B87B2,0x3F7BD14D,0x3F7C187A,0x3F7C5D3A,0x3F7C9F8A,0x3F7CDF6C,0x3F7D1CDD,
0x3F7D57DE,0x3F7D906E,0x3F7DC68C,0x3F7DFA38,0x3F7E2B72,0x3F7E5A38,0x3F7E868B,0x3F7EB069,
0x3F7ED7D4,0x3F7EFCC9,0x3F7F1F49,0x3F7F3F54,0x3F7F5CE9,0x3F7F7808,0x3F7F90B1,0x3F7FA6E3,
0x3F7FBA9E,0x3F7FCBE2,0x3F7FDAAF,0x3F7FE705,0x3F7FF0E3,0x3F7FF84A,0x3F7FFD39,0x3F7FFFB1,
0xBBC90F88,0xBC96C9B6,0xBCFB49BA,0xBD2FE007,0xBD621469,0xBD8A200A,0xBDA3308C,0xBDBC3AC3,
0xBDD53DB9,0xBDEE3876,0xBE039502,0xBE1008B7,0xBE1C76DE,0xBE28DEFC,0xBE354098,0xBE419B37,
0xBE4DEE60,0xBE5A3997,0xBE667C66,0xBE72B651,0xBE7EE6E1,0xBE8586CE,0xBE8B9507,0xBE919DDD,
0xBE97A117,0xBE9D9E78,0xBEA395C5,0xBEA986C4,0xBEAF713A,0xBEB554EC,0xBEBB31A0,0xBEC1071E,
0xBEC6D529,0xBECC9B8B,0xBED25A09,0xBED8106B,0xBEDDBE79,0xBEE363FA,0xBEE900B7,0xBEEE9479,
0xBEF41F07,0xBEF9A02D,0xBEFF17B2,0xBF0242B1,0xBF04F484,0xBF07A136,0xBF0A48AD,0xBF0CEAD0,
0xBF0F8784,0xBF121EB0,0xBF14B039,0xBF173C07,0xBF19C200,0xBF1C420C,0xBF1EBC12,0xBF212FF9,
0xBF239DA9,0xBF26050A,0xBF286605,0xBF2AC082,0xBF2D1469,0xBF2F61A5,0xBF31A81D,0xBF33E7BC,
0x3F36206C,0x3F385216,0x3F3A7CA4,0x3F3CA003,0x3F3EBC1B,0x3F40D0DA,0x3F42DE29,0x3F44E3F5,
0x3F46E22A,0x3F48D8B3,0x3F4AC77F,0x3F4CAE79,0x3F4E8D90,0x3F5064AF,0x3F5233C6,0x3F53FAC3,
0x3F55B993,0x3F577026,0x3F591E6A,0x3F5AC450,0x3F5C61C7,0x3F5DF6BE,0x3F5F8327,0x3F6106F2,
0x3F628210,0x3F63F473,0x3F655E0B,0x3F66BECC,0x3F6816A8,0x3F696591,0x3F6AAB7B,0x3F6BE858,
0x3F6D1C1D,0x3F6E46BE,0x3F6F6830,0x3F708066,0x3F718F57,0x3F7294F8,0x3F73913F,0x3F748422,
0x3F756D97,0x3F764D97,0x3F772417,0x3F77F110,0x3F78B47B,0x3F796E4E,0x3F7A1E84,0x3F7AC516,
0x3F7B61FC,0x3F7BF531,0x3F7C7EB0,0x3F7CFE73,0x3F7D7474,0x3F7DE0B1,0x3F7E4323,0x3F7E9BC9,
0x3F7EEA9D,0x3F7F2F9D,0x3F7F6AC7,0x3F7F9C18,0x3F7FC38F,0x3F7FE129,0x3F7FF4E6,0x3F7FFEC4,
0xBC490E90,0xBD16C32C,0xBD7B2B74,0xBDAFB680,0xBDE1BC2E,0xBE09CF86,0xBE22ABB6,0xBE3B6ECF,
0xBE541501,0xBE6C9A7F,0xBE827DC0,0xBE8E9A22,0xBE9AA086,0xBEA68F12,0xBEB263EF,0xBEBE1D4A,
0xBEC9B953,0xBED53641,0xBEE0924F,0xBEEBCBBB,0xBEF6E0CB,0xBF00E7E4,0xBF064B82,0xBF0B9A6B,
0xBF10D3CD,0xBF15F6D9,0xBF1B02C6,0xBF1FF6CB,0xBF24D225,0xBF299415,0xBF2E3BDE,0xBF32C8C9,
0x3F373A23,0x3F3B8F3B,0x3F3FC767,0x3F43E200,0x3F47DE65,0x3F4BBBF8,0x3F4F7A1F,0x3F531849,
0x3F5695E5,0x3F59F26A,0x3F5D2D53,0x3F604621,0x3F633C5A,0x3F660F88,0x3F68BF3C,0x3F6B4B0C,
0x3F6DB293,0x3F6FF573,0x3F721352,0x3F740BDD,0x3F75DEC6,0x3F778BC5,0x3F791298,0x3F7A7302,
0x3F7BACCD,0x3F7CBFC9,0x3F7DABCC,0x3F7E70B0,0x3F7F0E58,0x3F7F84AB,0x3F7FD397,0x3F7FFB11};
#endif //BUILD_INT_FLOAT

#ifdef BUILD_INTEGER
const Int g_SinTableForReconstruction[(2048+1024+512+256+128+64)] = {
0xDBC1FFF9,0x9342FFED,0x4AC4FFE0,0x246FFD4 ,0xB9C9FFC7,0x714DFFBA,0x28D3FFAE,0xE05AFFA1,
0x97E3FF95,0x4F6EFF88,0x6FBFF7C ,0xBE8BFF6F,0x761DFF62,0x2DB3FF56,0xE54CFF49,0x9CE8FF3D,
0x5489FF30,0xC2DFF24 ,0xC3D5FF17,0x7B82FF0A,0x3334FEFE,0xEAEAFEF1,0xA2A6FEE5,0x5A67FED8,
0x122EFECC,0xC9FBFEBF,0x81CEFEB3,0x39A8FEA6,0xF188FE99,0xA96FFE8D,0x615DFE80,0x1953FE74,
0xD150FE67,0x8955FE5B,0x4162FE4E,0xF978FE41,0xB196FE35,0x69BDFE28,0x21EDFE1C,0xDA26FE0F,
0x9269FE03,0x4AB6FDF6,0x30DFDEA ,0xBB6EFDDD,0x73D9FDD0,0x2C50FDC4,0xE4D1FDB7,0x9D5EFDAB,
0x55F6FD9E,0xE9AFD92 ,0xC74AFD85,0x8006FD79,0x38CFFD6C,0xF1A4FD5F,0xAA87FD53,0x6376FD46,
0x1C73FD3A,0xD57EFD2D,0x8E96FD21,0x47BDFD14,0xF2FD08  ,0xBA36FCFB,0x7389FCEE,0x2CEAFCE2,
0xE65BFCD5,0x9FDCFCC9,0x596DFCBC,0x130EFCB0,0xCCBFFCA3,0x8680FC97,0x4053FC8A,0xFA37FC7D,
0xB42BFC71,0x6E32FC64,0x284AFC58,0xE274FC4B,0x9CB1FC3F,0x5700FC32,0x1162FC26,0xCBD7FC19,
0x865FFC0D,0x40FAFC00,0xFBAAFBF3,0xB66DFBE7,0x7145FBDA,0x2C30FBCE,0xE731FBC1,0xA247FBB5,
0x5D71FBA8,0x18B2FB9C,0xD408FB8F,0x8F73FB83,0x4AF5FB76,0x68DFB6A ,0xC23CFB5D,0x7E02FB50,
0x39DFFB44,0xF5D3FB37,0xB1DFFB2B,0x6E03FB1E,0x2A3FFB12,0xE693FB05,0xA2FFFAF9,0x5F85FAEC,
0x1C23FAE0,0xD8DBFAD3,0x95ACFAC7,0x5297FABA,0xF9DFAAE ,0xCCBCFAA1,0x89F6FA95,0x474AFA88,
0x4BAFA7C ,0xC245FA6F,0x7FEBFA62,0x3DADFA56,0xFB8BFA49,0xB985FA3D,0x779BFA30,0x35CEFA24,
0xF41EFA17,0xB28CFA0B,0x7116F9FE,0x2FBEF9F2,0xEE84F9E5,0xAD69F9D9,0x6C6BF9CC,0x2B8CF9C0,
0xEACCF9B3,0xAA2BF9A7,0x69AAF99A,0x2948F98E,0xE906F981,0xA8E3F975,0x68E1F968,0x2900F95C,
0xE93FF94F,0xA9A0F943,0x6A21F936,0x2AC4F92A,0xEB89F91D,0xAC70F911,0x6D79F904,0x2EA4F8F8,
0xEFF3F8EB,0xB164F8DF,0x72F8F8D2,0x34AFF8C6,0xF68BF8B9,0xB88AF8AD,0x7AADF8A0,0x3CF5F894,
0xFF61F887,0xC1F3F87B,0x84A9F86F,0x4784F862,0xA86F856 ,0xCDADF849,0x90FAF83D,0x546DF830,
0x1807F824,0xDBC8F817,0x9FAFF80B,0x63BEF7FE,0x27F5F7F2,0xEC53F7E5,0xB0D9F7D9,0x7588F7CC,
0x3A5FF7C0,0xFF5EF7B3,0xC487F7A7,0x89D9F79B,0x4F54F78E,0x14F8F782,0xDAC7F775,0xA0C0F769,
0x66E3F75C,0x2D31F750,0xF3AAF743,0xBA4EF737,0x811DF72B,0x4818F71E,0xF3EF712 ,0xD691F705,
0x9E10F6F9,0x65BBF6EC,0x2D94F6E0,0xF599F6D3,0xBDCCF6C7,0x862CF6BB,0x4EB9F6AE,0x1775F6A2,
0xE05FF695,0xA978F689,0x72BFF67C,0x3C35F670,0x5DAF664 ,0xCFAFF657,0x99B3F64B,0x63E8F63E,
0x2E4CF632,0xF8E1F625,0xC3A6F619,0x8E9DF60D,0x59C4F600,0x251DF5F4,0xF0A7F5E7,0xBC63F5DB,
0x8851F5CF,0x5472F5C2,0x20C5F5B6,0xED4AF5A9,0xBA03F59D,0x86EFF591,0x540EF584,0x2162F578,
0xEEE9F56B,0xBCA4F55F,0x8A94F553,0x58B8F546,0x2712F53A,0xF5A0F52D,0xC464F521,0x935EF515,
0x628DF508,0x31F3F4FC,0x18FF4F0 ,0xD161F4E3,0xA16BF4D7,0x71ABF4CA,0x4223F4BE,0x12D2F4B2,
0xE3B9F4A5,0xB4D8F499,0x8630F48D,0x57C0F480,0x2988F474,0xFB8AF467,0xCDC5F45B,0xA039F44F,
0x72E7F442,0x45CFF436,0x18F1F42A,0xEC4DF41D,0xBFE4F411,0x93B6F405,0x67C3F3F8,0x3C0BF3EC,
0x108FF3E0,0xE54FF3D3,0xBA4BF3C7,0x8F83F3BB,0x64F8F3AE,0x3AAAF3A2,0x1098F396,0xE6C4F389,
0xBD2DF37D,0x93D4F371,0x6AB9F364,0x41DDF358,0x193EF34C,0xF0DFF33F,0xC8BEF333,0xA0DCF327,
0x793AF31A,0x51D8F30E,0x2AB5F302,0x3D2F2F6 ,0xDD30F2E9,0xB6CFF2DD,0x90AEF2D1,0x6ACEF2C4,
0x4530F2B8,0x1FD3F2AC,0xFAB8F29F,0xD5DEF293,0xB147F287,0x8CF3F27B,0x68E1F26E,0x4513F262,
0x2187F256,0xFE3FF249,0xDB3AF23D,0xB87AF231,0x95FDF225,0x73C5F218,0x51D2F20C,0x3023F200,
0xEB9F1F4 ,0xED95F1E7,0xCCB6F1DB,0xAC1DF1CF,0x8BCBF1C3,0x6BBEF1B6,0x4BF8F1AA,0x2C78F19E,
0xD40F192 ,0xEE4FF185,0xCFA5F179,0xB143F16D,0x9329F161,0x7557F154,0x57CDF148,0x3A8CF13C,
0x1D94F130,0xE5F124  ,0xE47FF117,0xC863F10B,0xAC90F0FF,0x9108F0F3,0x75CAF0E6,0x5AD6F0DA,
0x402EF0CE,0x25D0F0C2,0xBBDF0B6 ,0xF1F6F0A9,0xD87AF09D,0xBF4BF091,0xA667F085,0x8DD0F079,
0x7586F06C,0x5D88F060,0x45D8F054,0x2E74F048,0x175FF03C,0x97F030  ,0xEA1DF023,0xD3F2F017,
0xBE15F00B,0xA886EFFF,0x9347EFF3,0x7E57EFE6,0x69B6EFDA,0x5565EFCE,0x4164EFC2,0x2DB3EFB6,
0x1A53EFAA,0x743EF9E ,0xF484EF91,0xE216EF85,0xCFF9EF79,0xBE2EEF6D,0xACB4EF61,0x9B8DEF55,
0x8AB8EF49,0x7A35EF3C,0x6A05EF30,0x5A28EF24,0x4A9FEF18,0x3B68EF0C,0x2C86EF00,0x1DF7EEF4,
0xFBCEEE8 ,0x1D6EEDC ,0xF444EECF,0xE707EEC3,0xDA1FEEB7,0xCD8CEEAB,0xC14FEE9F,0xB568EE93,
0xA9D6EE87,0x9E9BEE7B,0x93B7EE6F,0x8929EE63,0x7EF2EE56,0x7512EE4A,0x6B89EE3E,0x6258EE32,
0x597FEE26,0x50FEEE1A,0x48D5EE0E,0x4105EE02,0x398EEDF6,0x326FEDEA,0x2BAAEDDE,0x253EEDD2,
0x1F2DEDC6,0x1974EDBA,0x1417EDAE,0xF13EDA2 ,0xA6AED96 ,0x61CED8A ,0x22AED7E ,0xFE92ED71,
0xFB56ED65,0xF876ED59,0xF5F2ED4D,0xF3CAED41,0xF1FFED35,0xF090ED29,0xEF7EED1D,0xEECAED11,
0xEE73ED05,0xEE79ECF9,0xEEDEECED,0xEFA0ECE1,0xF0C1ECD5,0xF241ECC9,0xF41FECBD,0xF65CECB1,
0xF8F9ECA5,0xFBF5EC99,0xFF51EC8D,0x30DEC82 ,0x729EC76 ,0xBA5EC6A ,0x1082EC5E,0x15C0EC52,
0x1B5FEC46,0x215FEC3A,0x27C1EC2E,0x2E85EC22,0x35ABEC16,0x3D33EC0A,0x451DEBFE,0x4D6AEBF2,
0x561BEBE6,0x5F2EEBDA,0x68A5EBCE,0x727FEBC2,0x7CBEEBB6,0x8760EBAB,0x9267EB9F,0x9DD2EB93,
0xA9A2EB87,0xB5D7EB7B,0xC272EB6F,0xCF72EB63,0xDCD7EB57,0xEAA3EB4B,0xF8D4EB3F,0x76CEB34,
0x166BEB28,0x25D1EB1C,0x359DEB10,0x45D1EB04,0x566DEAF8,0x6770EAEC,0x78DBEAE0,0x8AAFEAD5,
0x9CEBEAC9,0xAF90EABD,0xC29DEAB1,0xD614EAA5,0xE9F4EA99,0xFE3EEA8D,0x12F1EA82,0x280FEA76,
0x3D97EA6A,0x5389EA5E,0x69E6EA52,0x80AEEA47,0x97E1EA3B,0xAF80EA2F,0xC78AEA23,0xE001EA17,
0xF8E3EA0B,0x1232EA00,0x2BEDE9F4,0x4615E9E8,0x60AAE9DC,0x7BACE9D0,0x971CE9C5,0xB2FAE9B9,
0xCF45E9AD,0xEBFFE9A1,0x926E996 ,0x26BDE98A,0x44C2E97E,0x6337E972,0x821BE967,0xA16EE95B,
0xC131E94F,0xE164E943,0x207E938 ,0x231AE92C,0x449FE920,0x6694E914,0x88FAE909,0xABD1E8FD,
0xCF1AE8F1,0xF2D5E8E5,0x1702E8DA,0x3BA1E8CE,0x60B3E8C2,0x8637E8B7,0xAC2EE8AB,0xD298E89F,
0xF976E893,0x20C7E888,0x488CE87C,0x70C5E870,0x9972E865,0xC294E859,0xEC2BE84D,0x1636E842,
0x40B7E836,0x6BADE82A,0x9718E81F,0xC2FAE813,0xEF51E807,0x1C1FE7FC,0x4963E7F0,0x771EE7E4,
0xA550E7D9,0xD3F9E7CD,0x31AE7C2 ,0x32B2E7B6,0x62C2E7AA,0x934AE79F,0xC44AE793,0xF5C3E787,
0x27B5E77C,0x5A1FE770,0x8D03E765,0xC061E759,0xF437E74D,0x2888E742,0x5D53E736,0x9298E72B,
0xC858E71F,0xFE92E713,0x3548E708,0x6C79E6FC,0xA425E6F1,0xDC4CE6E5,0x14F0E6DA,0x4E10E6CE,
0x87ACE6C3,0xC1C5E6B7,0xFC5AE6AB,0x376CE6A0,0x72FCE694,0xAF09E689,0xEB93E67D,0x289CE672,
0x6623E666,0xA428E65B,0xE2ABE64F,0x21ADE644,0x612FE638,0xA12FE62D,0xE1AFE621,0x22AFE616,
0x642EE60A,0xA62EE5FF,0xE8ADE5F3,0x2BAEE5E8,0x6F2FE5DC,0xB331E5D1,0xF7B5E5C5,0x3CB9E5BA,
0x8240E5AF,0xC848E5A3,0xED2E598 ,0x55DFE58C,0x9D6EE581,0xE580E575,0x2E15E56A,0x772DE55E,
0xC0C9E553,0xAE8E548 ,0x558BE53C,0xA0B2E531,0xEC5DE525,0x388DE51A,0x8542E50F,0xD27BE503,
0x203AE4F8,0x6E7EE4EC,0xBD48E4E1,0xC97E4D6 ,0x5C6DE4CA,0xACC9E4BF,0xFDABE4B3,0x4F14E4A8,
0xA104E49D,0xF37BE491,0x467AE486,0x9A00E47B,0xEE0EE46F,0x42A4E464,0x97C2E459,0xED68E44D,
0x4397E442,0x9A50E437,0xF191E42B,0x495BE420,0xA1AFE415,0xFA8DE409,0x53F5E3FE,0xADE7E3F3,
0x864E3E8 ,0x636BE3DC,0xBEFDE3D1,0x1B1AE3C6,0x77C2E3BA,0xD4F6E3AF,0x32B6E3A4,0x9101E399,
0xEFD9E38D,0x4F3DE382,0xAF2DE377,0xFABE36C ,0x70B5E360,0xD24DE355,0x3472E34A,0x9725E33F,
0xFA66E333,0x5E35E328,0xC292E31D,0x277DE312,0x8CF8E307,0xF301E2FB,0x599AE2F0,0xC0C2E2E5,
0x287AE2DA,0x90C1E2CF,0xF999E2C3,0x6300E2B8,0xCCF9E2AD,0x3782E2A2,0xA29BE297,0xE46E28C,
0x7A83E280,0xE751E275,0x54B0E26A,0xC2A2E25F,0x3126E254,0xA03CE249,0xFE5E23E ,0x8021E233,
0xF0F0E227,0x6252E21C,0xD447E211,0x46D1E206,0xB9EEE1FB,0x2D9FE1F0,0xA1E5E1E5,0x16BFE1DA,
0x8C2EE1CF,0x232E1C4 ,0x78CCE1B8,0xEFFAE1AD,0x67BEE1A2,0xE019E197,0x5909E18C,0xD28FE181,
0x4CACE176,0xC760E16B,0x42AAE160,0xBE8CE155,0x3B05E14A,0xB815E13F,0x35BDE134,0xB3FEE129,
0x32D6E11E,0xB247E113,0x3250E108,0xB2F2E0FD,0x342EE0F2,0xB602E0E7,0x3870E0DC,0xBB78E0D1,
0x3F19E0C6,0xC355E0BB,0x482BE0B0,0xCD9BE0A5,0x53A6E09A,0xDA4CE08F,0x618DE084,0xE96AE079,
0x71E2E06E,0xFAF6E063,0x84A5E059,0xEF2E04E ,0x99DAE043,0x255FE038,0xB181E02D,0x3E40E022,
0xCB9CE017,0x5996E00C,0xE82DE001,0x7762DFF6,0x735DFEC ,0x97A7DFE1,0x28B7DFD6,0xBA66DFCB,
0x4CB4DFC0,0xDFA1DFB5,0x732DDFAA,0x759DFA0 ,0x9C24DF95,0x3190DF8A,0xC79BDF7F,0x5E47DF74,
0xF594DF69,0x8D81DF5F,0x2610DF54,0xBF40DF49,0x5911DF3E,0xF384DF33,0x8E98DF29,0x2A4FDF1E,
0xC6A8DF13,0x63A3DF08,0x141DEFE ,0x9F82DEF3,0x3E67DEE8,0xDDEEDEDD,0x7E19DED2,0x1EE7DEC8,
0xC05ADEBD,0x6271DEB2,0x52CDEA8 ,0xA88BDE9D,0x4C8FDE92,0xF139DE87,0x9687DE7D,0x3C7BDE72,
0xE314DE67,0x8A53DE5D,0x3239DE52,0xDAC4DE47,0x83F6DE3D,0x2DCEDE32,0xD84DDE27,0x8373DE1D,
0x2F41DE12,0xDBB6DE07,0x88D2DDFD,0x3696DDF2,0xE503DDE7,0x9417DDDD,0x43D4DDD2,0xF43ADDC7,
0xA549DDBD,0x5700DDB2,0x961DDA8 ,0xBC6CDD9D,0x7020DD92,0x247EDD88,0xD986DD7D,0x8F38DD73,
0x4595DD68,0xFC9CDD5D,0xB44FDD53,0x6CACDD48,0x25B5DD3E,0xDF6ADD33,0x99CADD29,0x54D6DD1E,
0x108EDD14,0xCCF3DD09,0x8A04DCFF,0x47C1DCF4,0x62CDCEA ,0xC544DCDF,0x8509DCD5,0x457CDCCA,
0x69CDCC0 ,0xC86BDCB5,0x8AE7DCAB,0x4E12DCA0,0x11ECDC96,0xD674DC8B,0x9BABDC81,0x6192DC76,
0x2827DC6C,0xEF6DDC61,0xB762DC57,0x8007DC4D,0x495CDC42,0x1362DC38,0xDE18DC2D,0xA97FDC23,
0x7597DC18,0x4260DC0E,0xFDADC04 ,0xDE06DBF9,0xACE4DBEF,0x7C74DBE4,0x4CB6DBDA,0x1DAADBD0,
0xEF51DBC5,0xC1ABDBBB,0x94B7DBB1,0x6877DBA6,0x3CEADB9C,0x1211DB92,0xE7EBDB87,0xBE7ADB7D,
0x95BDDB73,0x6DB4DB68,0x465FDB5E,0x1FC0DB54,0xF9D5DB49,0xD49FDB3F,0xB01FDB35,0x8C55DB2B,
0x6940DB20,0x46E1DB16,0x2538DB0C,0x446DB02 ,0xE40ADAF7,0xC485DAED,0xA5B7DAE3,0x87A0DAD9,
0x6A40DACE,0x4D98DAC4,0x31A7DABA,0x166FDAB0,0xFBEFDAA5,0xE227DA9B,0xC917DA91,0xB0C0DA87,
0x9923DA7D,0x823EDA73,0x6C12DA68,0x56A0DA5E,0x41E8DA54,0x2DEADA4A,0x1AA5DA40,0x81BDA36,
0xF64CDA2B,0xE537DA21,0xD4DDDA17,0xC53EDA0D,0xB65BDA03,0xA832D9F9,0x9AC6D9EF,0x8E15D9E5,
0x8221D9DB,0x76E8D9D0,0x6C6CD9C6,0x62ADD9BC,0x59AAD9B2,0x5165D9A8,0x49DDD99E,0x4312D994,
0x3D04D98A,0x37B5D980,0x3323D976,0x2F50D96C,0x2C3BD962,0x29E4D958,0x284DD94E,0x2774D944,
0x275AD93A,0x2800D930,0x2965D926,0x2B8AD91C,0x2E6FD912,0x3214D908,0x367AD8FE,0x3B9FD8F4,
0x4186D8EA,0x482DD8E0,0x4F95D8D6,0x57BFD8CC,0x60AAD8C2,0x6A57D8B8,0x74C5D8AE,0x7FF6D8A4,
0x8BE9D89B,0x989ED891,0xA616D887,0xB450D87D,0xC34ED873,0xD30FD869,0xE393D85F,0xF4DAD855,
0x6E6D84C ,0x19B5D842,0x2D48D838,0x41A0D82E,0x56BCD824,0x6C9DD81A,0x8343D811,0x9AAED807,
0xB2DED7FD,0xCBD3D7F3,0xE58ED7E9,0xFD7E0   ,0x1B56D7D6,0x3763D7CC,0x5437D7C2,0x71D1D7B8,
0x9032D7AF,0xAF5AD7A5,0xCF49D79B,0xEFFFD791,0x117DD788,0x33C3D77E,0x56D0D774,0x7AA5D76A,
0x9F43D761,0xC4A9D757,0xEAD8D74D,0x11D0D744,0x3991D73A,0x621BD730,0x8B6ED727,0xB58BD71D,
0xE071D713,0xC22D70A ,0x389DD700,0x65E2D6F6,0x93F1D6ED,0xC2CBD6E3,0xF270D6D9,0x22E0D6D0,
0x541CD6C6,0x8623D6BD,0xB8F5D6B3,0xEC93D6A9,0x20FED6A0,0x5634D696,0x8C37D68D,0xC306D683,
0xFAA2D679,0x330BD670,0x6C41D666,0xA644D65D,0xE115D653,0x1CB3D64A,0x5920D640,0x965AD637,
0xD462D62D,0x1339D624,0x52DFD61A,0x9353D611,0xD496D607,0x16A8D5FE,0x598AD5F4,0x9D3BD5EB,
0xE1BBD5E1,0x270CD5D8,0x6D2CD5CE,0xB41DD5C5,0xFBDED5BB,0x4470D5B2,0x8DD2D5A9,0xD806D59F,
0x230AD596,0x6EE0D58C,0xBB87D583,0x900D57A ,0x574BD570,0xA668D567,0xF657D55D,0x4718D554,
0x98ACD54B,0xEB13D541,0x3E4CD538,0x9259D52F,0xE739D525,0x3CEDD51C,0x9374D513,0xEACFD509,
0x42FED500,0x9C01D4F7,0xF5D8D4ED,0x5085D4E4,0xAC05D4DB,0x85BD4D2 ,0x6586D4C8,0xC386D4BF,
0x225BD4B6,0x8207D4AD,0xE287D4A3,0x43DED49A,0xA60BD491,0x90FD488 ,0x6CE9D47E,0xD199D475,
0x3721D46C,0x9D7FD463,0x4B5D45A ,0x6CC2D450,0xD5A6D447,0x3F63D43E,0xA9F7D435,0x1564D42C,
0x81A8D423,0xEEC5D419,0x5CBBD410,0xCB8AD407,0x3B31D3FE,0xABB2D3F5,0x1D0CD3EC,0x8F40D3E3,
0x24DD3DA ,0x7634D3D0,0xEAF5D3C7,0x6091D3BE,0xD707D3B5,0x4E57D3AC,0xC682D3A3,0x3F88D39A,
0xB969D391,0x3426D388,0xAFBDD37F,0x2C31D376,0xA980D36D,0x27ABD364,0xA6B2D35B,0x2696D352,
0xA756D349,0x28F3D340,0xAB6CD337,0x2EC3D32E,0xB2F7D325,0x3808D31C,0xBDF6D313,0x44C2D30A,
0xCC6DD301,0x54F5D2F8,0xDE5BD2EF,0x68A0D2E6,0xF3C3D2DD,0x7FC5D2D4,0xCA6D2CC ,0x9A66D2C3,
0xD6FA2D45,0x477B2D4E,0xB71D2D57,0x25DF2D60,0x93C12D69,0xC32D72  ,0x6CE52D7A,0xD8262D83,
0x42872D8C,0xAC072D95,0x14A62D9E,0x7C642DA6,0xE3412DAF,0x493C2DB8,0xAE552DC1,0x128D2DCA,
0x75E32DD2,0xD8562DDB,0x39E82DE4,0x9A962DED,0xFA632DF5,0x594C2DFE,0xB7532E07,0x14762E10,
0x70B62E18,0xCC122E21,0x268B2E2A,0x80202E33,0xD8D12E3B,0x309E2E44,0x87872E4D,0xDD8B2E55,
0x32AA2E5E,0x86E52E67,0xDA3A2E6F,0x2CAB2E78,0x7E362E80,0xCEDC2E89,0x1E9C2E92,0x6D762E9A,
0xBB6A2EA3,0x8782EAC ,0x54A02EB4,0x9FE12EBD,0xEA3C2EC5,0x33B02ECE,0x7C3C2ED6,0xC3E22EDF,
0xAA02EE8 ,0x50772EF0,0x95672EF9,0xD96E2F01,0x1C8D2F0A,0x5EC52F12,0xA0142F1B,0xE07A2F23,
0x1FF82F2C,0x5E8D2F34,0x9C3A2F3D,0xD8FD2F45,0x14D72F4E,0x4FC72F56,0x89CE2F5F,0xC2EB2F67,
0xFB1E2F6F,0x32672F78,0x68C62F80,0x9E3A2F89,0xD2C42F91,0x6632F9A ,0x39172FA2,0x6AE02FAA,
0x9BBD2FB3,0xCBB02FBB,0xFAB72FC3,0x28D22FCC,0x56012FD4,0x82442FDD,0xAD9B2FE5,0xD8062FED,
0x1842FF6 ,0x2A152FFE,0x51BA3006,0x7872300E,0x9E3C3017,0xC319301F,0xE7093027,0xA0B3030,
0x2C1F3038,0x4D453040,0x6D7E3048,0x8CC83051,0xAB233059,0xC8903061,0xE50E3069,0x9D3072,
0x1B3D307A,0x34EE3082,0x4DB0308A,0x65823092,0x7C64309A,0x925630A3,0xA75930AB,0xBB6B30B3,
0xCE8D30BB,0xE0BE30C3,0xF1FF30CB,0x24F30D4 ,0x11AE30DC,0x201C30E4,0x2D9930EC,0x3A2430F4,
0x45BD30FC,0x50653104,0x5A1B310C,0x62DF3114,0x6AB1311C,0x71903124,0x777D312C,0x7C773134,
0x807F313D,0x83933145,0x85B4314D,0x86E23155,0x871D315D,0x86643165,0x84B7316D,0x82163175,
0x7E81317C,0x79F83184,0x747B318C,0x6E093194,0x66A2319C,0x5E4731A4,0x54F631AC,0x4AB131B4,
0x3F7631BC,0x334631C4,0x262031CC,0x180431D4,0x8F331DC ,0xF8EB31E3,0xE7EE31EB,0xD5FA31F3,
0xC30F31FB,0xAF2E3203,0x9A56320B,0x84873213,0x6DC0321A,0x56033222,0x3D4E322A,0x23A23232,
0x8FE323A ,0xED623241,0xD0CE3249,0xB3423251,0x94BE3259,0x75413260,0x54CB3268,0x335D3270,
0x10F63278,0xED96327F,0xC93C3287,0xA3EA328F,0x7D9D3296,0x5658329E,0x2E1832A6,0x4DE32AE,
0xDAAB32B5,0xAF7D32BD,0x835432C5,0x563132CC,0x281432D4,0xF8FB32DB,0xC8E832E3,0x97D932EB,
0x65D032F2,0x32CA32FA,0xFECA3301,0xC9CD3309,0x93D53311,0x5CE03318,0x24F03320,0xEC033327,
0xB21A332F,0x77343336,0x3B51333E,0xFE723345,0xC095334D,0x81BC3355,0x41E5335C,0x1103364,
0xBF3E336B,0x7C6F3372,0x38A1337A,0xF3D53381,0xAE0B3389,0x67433390,0x1F7C3398,0xD6B7339F,
0x8CF333A7,0x423033AE,0xF66E33B5,0xA9AD33BD,0x5BED33C4,0xD2D33CC ,0xBD6D33D3,0x6CAE33DA,
0x1AEF33E2,0xC82F33E9,0x747033F0,0x1FB033F8,0xC9F033FF,0x732F3406,0x1B6E340E,0xC2AB3415,
0x68E8341C,0xE233424 ,0xB25D342B,0x55963432,0xF7CD3439,0x99033441,0x39363448,0xD867344F,
0x76973456,0x13C4345E,0xAFEE3465,0x4B16346C,0xE53C3473,0x7E5E347A,0x167E3482,0xAD9A3489,
0x43B33490,0xD8C93497,0x6CDB349E,0xFFEA34A5,0x91F534AD,0x22FB34B4,0xB2FE34BB,0x41FC34C2,
0xCFF734C9,0x5CEC34D0,0xE8DD34D7,0x73C934DE,0xFDB134E5,0x869334ED,0xE7034F4 ,0x954834FB,
0x1B1A3502,0x9FE73509,0x23AE3510,0xA66F3517,0x282A351E,0xA8DF3525,0x288E352C,0xA7363533,
0x24D8353A,0xA1733541,0x1D083548,0x9795354F,0x111C3556,0x899B355D,0x1133564 ,0x7783356A,
0xECEC3571,0x614D3578,0xD4A6357F,0x46F73586,0xB840358D,0x28803594,0x97B9359B,0x5E935A2,
0x731035A8,0xDF2E35AF,0x4A4335B6,0xB45035BD,0x1D5335C4,0x854D35CB,0xEC3D35D1,0x522435D8,
0xB70135DF,0x1AD435E6,0x7D9D35EC,0xDF5C35F3,0x401135FA,0x9FBB3601,0xFE5B3607,0x5BF1360E,
0xB87B3615,0x13FB361C,0x6E6F3622,0xC7D93629,0x20373630,0x778A3636,0xCDD1363D,0x230D3644,
0x773C364A,0xCA603651,0x1C783658,0x6D84365E,0xBD833665,0xC76366C ,0x5A5C3672,0xA7363679,
0xF303367F,0x3DC33686,0x8776368D,0xD01B3693,0x17B3369A,0x5E3E36A0,0xA3BB36A7,0xE82B36AD,
0x2B8D36B4,0x6DE136BA,0xAF2636C1,0xEF5E36C7,0x2E8736CE,0x6CA236D4,0xA9AE36DB,0xE5AB36E1,
0x209A36E8,0x5A7936EE,0x934A36F5,0xCB0B36FB,0x1BD3702 ,0x37603708,0x6BF3370E,0x9F763715,
0xD1E9371B,0x34D3722 ,0x33A03728,0x62E3372E,0x91163735,0xBE39373B,0xEA4B3741,0x154C3748,
0x3F3C374E,0x681C3754,0x8FEA375B,0xB6A83761,0xDC543767,0xEE376E  ,0x24773774,0x46EF377A,
0x68543780,0x88A83787,0xA7EA378D,0xC6193793,0xE3363799,0xFF41379F,0x1A3A37A6,0x342037AC,
0x4CF337B2,0x64B337B8,0x7B6037BE,0x90FA37C5,0xA58137CB,0xB8F537D1,0xCB5537D7,0xDCA137DD,
0xECDA37E3,0xFBFF37E9,0xA1137F0 ,0x170E37F6,0x22F737FC,0x2DCB3802,0x378C3808,0x4037380E,
0x47CE3814,0x4E51381A,0x53BE3820,0x58173826,0x5B5A382C,0x5D893832,0x5EA23838,0x5EA5383E,
0x5D933844,0x5B6B384A,0x582E3850,0x53DA3856,0x4E71385C,0x47F13862,0x405B3868,0x37AF386E,
0x2DEC3874,0x2313387A,0x17233880,0xA1C3886 ,0xFBFF388B,0xECCA3891,0xDC7E3897,0xCB1B389D,
0xB8A038A3,0xA50E38A9,0x906438AF,0x7AA338B4,0x63C938BA,0x4BD838C0,0x32CF38C6,0x18AD38CC,
0xFD7438D1,0xE12238D7,0xC3B738DD,0xA53438E3,0x859838E9,0x64E338EE,0x431538F4,0x202E38FA,
0xFC2E38FF,0xD7153905,0xB0E2390B,0x89963911,0x61303916,0x37B0391C,0xD173922 ,0xE1643927,
0xB496392D,0x86AF3933,0x57AD3938,0x2791393E,0xF65A3943,0xC4093949,0x909D394F,0x5C163954,
0x2674395A,0xEFB8395F,0xB7E03965,0x7EED396A,0x44DE3970,0x9B53976 ,0xCD6F397B,0x900E3981,
0x51913986,0x11F8398C,0xD1443991,0x8F733997,0x4C86399C,0x87C39A2 ,0xC35739A7,0x7D1439AC,
0x35B639B2,0xED3A39B7,0xA3A239BD,0x58EC39C2,0xD1A39C8 ,0xC02A39CD,0x721E39D2,0x22F339D8,
0xD2AC39DD,0x814739E3,0x2EC439E8,0xDB2339ED,0x866539F3,0x308939F8,0xD98E39FD,0x81753A03,
0x283E3A08,0xCDE93A0D,0x72753A12,0x15E33A18,0xB8323A1D,0x59623A22,0xF9733A27,0x98663A2D,
0x36393A32,0xD2ED3A37,0x6E823A3C,0x8F73A42 ,0xA24D3A47,0x3A833A4C,0xD19A3A51,0x67903A56,
0xFC673A5B,0x901E3A61,0x22B53A66,0xB42C3A6B,0x44823A70,0xD3B83A75,0x61CD3A7A,0xEEC23A7F,
0x7A963A84,0x54A3A8A ,0x8EDC3A8F,0x174E3A94,0x9E9E3A99,0x24CE3A9E,0xA9DC3AA3,0x2DC83AA8,
0xB0933AAD,0x323D3AB2,0xB2C53AB7,0x322B3ABC,0xB0703AC1,0x2D923AC6,0xA9923ACB,0x24713AD0,
0x9E2D3AD5,0x16C63ADA,0x8E3D3ADF,0x4923AE4 ,0x79C43AE8,0xEDD43AED,0x60C03AF2,0xD28A3AF7,
0x43313AFC,0xB2B43B01,0x21153B06,0x8E523B0B,0xFA6C3B0F,0x65623B14,0xCF353B19,0x37E43B1E,
0x9F6F3B23,0x5D73B28 ,0x6B1B3B2C,0xCF3A3B31,0x32363B36,0x940D3B3B,0xF4C03B3F,0x544F3B44,
0xB2B93B49,0xFFF3B4E ,0x6C1F3B52,0xC71C3B57,0x20F33B5C,0x79A53B60,0xD1333B65,0x279B3B6A,
0x7CDE3B6E,0xD0FC3B73,0x23F43B78,0x75C73B7C,0xC6753B81,0x15FC3B86,0x645E3B8A,0xB19A3B8F,
0xFDB13B93,0x48A13B98,0x926B3B9D,0xDB0F3BA1,0x228D3BA6,0x68E43BAA,0xAE153BAF,0xF21F3BB3,
0x35033BB8,0x76C03BBC,0xB7563BC1,0xF6C53BC5,0x350E3BCA,0x722F3BCE,0xAE293BD3,0xE8FC3BD7,
0x22A83BDC,0x5B2C3BE0,0x92893BE5,0xC8BE3BE9,0xFDCB3BED,0x31B13BF2,0x646F3BF6,0x96053BFB,
0xC6733BFF,0xF5B93C03,0x23D73C08,0x50CD3C0C,0x7C9A3C10,0xA73F3C15,0xD0BB3C19,0xF90F3C1D,
0x203A3C22,0x463C3C26,0x6B153C2A,0x8EC63C2F,0xB14E3C33,0xD2AC3C37,0xF2E13C3B,0x11ED3C40,
0x2FD03C44,0x4C8A3C48,0x68193C4C,0x82803C51,0x9BBC3C55,0xB3CF3C59,0xCAB83C5D,0xE0783C61,
0xF50D3C65,0x8783C6A ,0x1AB93C6E,0x2BD03C72,0x3BBC3C76,0x4A7F3C7A,0x58163C7E,0x64843C82,
0x6FC63C86,0x79DE3C8A,0x82CB3C8F,0x8A8D3C93,0x91253C97,0x96913C9B,0x9AD23C9F,0x9DE93CA3,
0x9FD43CA7,0xA0933CAB,0xA0273CAF,0x9E903CB3,0x9BCD3CB7,0x97DF3CBB,0x92C53CBF,0x8C7F3CC3,
0x850D3CC7,0x7C6F3CCA,0x72A63CCE,0x67B03CD2,0x5B8E3CD6,0x4E403CDA,0x3FC53CDE,0x301F3CE2,
0x1F4B3CE6,0xD4B3CEA ,0xFA1F3CED,0xE5C63CF1,0xD0403CF5,0xB98E3CF9,0xA1AE3CFD,0x88A13D01,
0x6E683D04,0x53013D08,0x366D3D0C,0x18AC3D10,0xF9BE3D13,0xD9A23D17,0xB8593D1B,0x95E23D1F,
0x723D3D22,0x4D6B3D26,0x276B3D2A,0x3D3D2E  ,0xD7E13D31,0xAE583D35,0x83A03D39,0x57BA3D3C,
0x2AA63D40,0xFC643D43,0xCCF33D47,0x9C543D4B,0x6A863D4E,0x378A3D52,0x3603D56 ,0xCE063D59,
0x977E3D5D,0x5FC73D60,0x26E13D64,0xECCC3D67,0xB1893D6B,0x75163D6E,0x37743D72,0xF8A23D75,
0xB8A23D79,0x77723D7C,0x35123D80,0xF1833D83,0xACC53D87,0x66D73D8A,0x1FB93D8E,0xD76B3D91,
0x8DEE3D95,0x43413D98,0xF7643D9B,0xAA563D9F,0x5C193DA2,0xCAB3DA6 ,0xBC0E3DA9,0x6A403DAC,
0x17413DB0,0xC3123DB3,0x6DB33DB6,0x17233DBA,0xBF633DBD,0x66723DC0,0xC503DC4 ,0xB0FD3DC7,
0x54793DCA,0xF6C53DCD,0x97E03DD1,0x37C93DD4,0xD6813DD7,0x74093DDA,0x105E3DDE,0xAB833DE1,
0x45763DE4,0xDE383DE7,0x75C93DEA,0xC273DEE ,0xA1553DF1,0x35503DF4,0xC81A3DF7,0x59B23DFA,
0xEA183DFD,0x794C3E00,0x74E3E04 ,0x941F3E07,0x1FBD3E0A,0xAA293E0D,0x33623E10,0xBB6A3E13,
0x423F3E16,0xC7E23E19,0x4C523E1C,0xCF903E1F,0x519B3E22,0xD2733E25,0x52193E28,0xD08C3E2B,
0x4DCD3E2E,0xC9DA3E31,0x44B53E34,0xBE5C3E37,0x36D13E3A,0xAE133E3D,0x24213E40,0x98FC3E43,
0xCA43E46 ,0x7F193E48,0xF05A3E4B,0x60683E4E,0xCF423E51,0x3CE93E54,0xA95C3E57,0x149C3E5A,
0x7EA83E5C,0xE7803E5F,0x4F243E62,0xB5943E65,0x1AD13E68,0x7EDA3E6A,0xE1AE3E6D,0x434F3E70,
0xA3BB3E73,0x2F33E76 ,0x60F73E78,0xBDC73E7B,0x19623E7E,0x73C93E80,0xCCFC3E83,0x24FA3E86,
0x7BC33E88,0xD1583E8B,0x25B83E8E,0x78E43E90,0xCADB3E93,0x1B9C3E96,0x6B2A3E98,0xB9823E9B,
0x6A53E9E ,0x52933EA0,0x9D4C3EA3,0xE6D13EA5,0x2F203EA8,0x76393EAA,0xBC1E3EAD,0xCD3EB0,
0x44473EB2,0x868B3EB5,0xC79A3EB7,0x7743EBA ,0x46183EBC,0x83863EBF,0xBFBF3EC1,0xFAC23EC3,
0x348F3EC6,0x6D263EC8,0xA4883ECB,0xDAB43ECD,0xFAA3ED0 ,0x436A3ED2,0x75F43ED4,0xA7473ED7,
0xD7653ED9,0x64D3EDC ,0x33FE3EDE,0x60793EE0,0x8BBE3EE3,0xB5CC3EE5,0xDEA53EE7,0x6463EEA,
0x2CB13EEC,0x51E63EEE,0x75E43EF0,0x98AC3EF3,0xBA3D3EF5,0xDA973EF7,0xF9BA3EF9,0x17A73EFC,
0x345D3EFE,0x4FDC3F00,0x6A243F02,0x83353F05,0x9B0F3F07,0xB1B33F09,0xC71F3F0B,0xDB543F0D,
0xEE513F0F,0x183F12  ,0x10A73F14,0x20003F16,0x2E203F18,0x3B0A3F1A,0x46BC3F1C,0x51363F1E,
0x5A793F20,0x62853F22,0x69593F24,0x6EF53F26,0x735A3F28,0x76873F2A,0x787C3F2C,0x793A3F2E,
0x78C03F30,0x770E3F32,0x74243F34,0x70023F36,0x6AA83F38,0x64163F3A,0x5C4D3F3C,0x534B3F3E,
0x49113F40,0x3D9F3F42,0x30F43F44,0x23123F46,0x13F73F48,0x3A43F4A ,0xF2193F4B,0xDF553F4D,
0xCB593F4F,0xB6243F51,0x9FB73F53,0x88123F55,0x6F343F56,0x551D3F58,0x39CE3F5A,0x1D463F5C,
0xFF863F5D,0xE08D3F5F,0xC05B3F61,0x9EF03F63,0x7C4D3F64,0x58703F66,0x335B3F68,0xD0D3F6A,
0xE5863F6B,0xBCC63F6D,0x92CD3F6F,0x679B3F70,0x3B303F72,0xD8B3F74 ,0xDEAE3F75,0xAE983F77,
0x7D483F78,0x4ABF3F7A,0x16FD3F7C,0xE2013F7D,0xABCC3F7F,0x745E3F80,0x3BB73F82,0x1D63F84,
0xC6BC3F85,0x8A683F87,0x4CDA3F88,0xE143F8A ,0xCE133F8B,0x8CD93F8D,0x4A653F8E,0x6B83F90,
0xC1D13F91,0x7BB13F92,0x34563F94,0xEBC23F95,0xA1F43F97,0x56ED3F98,0xAAB3F9A ,0xBD303F9B,
0x6E7B3F9C,0x1E8B3F9E,0xCD623F9F,0x7AFF3FA0,0x27623FA2,0xD28B3FA3,0x7C7A3FA4,0x252F3FA6,
0xCCA93FA7,0x72EA3FA8,0x17F03FAA,0xBBBC3FAB,0x5E4E3FAC,0xFFA63FAD,0x9FC43FAF,0x3EA73FB0,
0xDC503FB1,0x78BF3FB2,0x13F33FB4,0xADED3FB5,0x46AD3FB6,0xDE323FB7,0x747C3FB8,0x98D3FBA,
0x9D633FBB,0x2FFE3FBC,0xC15F3FBD,0x51853FBE,0xE0703FBF,0x6E223FC0,0xFA983FC1,0x85D43FC3,
0xFD53FC4 ,0x989B3FC5,0x20273FC6,0xA6783FC7,0x2B8F3FC8,0xAF6A3FC9,0x320B3FCA,0xB3713FCB,
0x339C3FCC,0xB28D3FCD,0x30423FCE,0xACBD3FCF,0x27FD3FD0,0xA2023FD1,0x1ACC3FD2,0x925B3FD3,
0x8AF3FD4 ,0x7DC83FD4,0xF1A63FD5,0x64493FD6,0xD5B13FD7,0x45DE3FD8,0xB4D03FD9,0x22863FDA,
0x8F023FDB,0xFA433FDB,0x64483FDC,0xCD133FDD,0x34A23FDE,0x9AF63FDF,0xE3FE0   ,0x63EC3FE0,
0xC68E3FE1,0x27F53FE2,0x88213FE3,0xE7123FE3,0x44C73FE4,0xA1413FE5,0xFC803FE5,0x56833FE6,
0xAF4B3FE7,0x6D83FE8 ,0x5D293FE8,0xB23F3FE9,0x61A3FEA ,0x58B93FEA,0xAA1C3FEB,0xFA453FEB,
0x49313FEC,0x96E33FED,0xE3593FED,0x2E933FEE,0x78923FEE,0xC1563FEF,0x8DE3FF0 ,0x4F2A3FF0,
0x943B3FF1,0xD8103FF1,0x1AAA3FF2,0x5C083FF2,0x9C2B3FF3,0xDB123FF3,0x18BE3FF4,0x552D3FF4,
0x90623FF5,0xCA5A3FF5,0x3173FF6 ,0x3A993FF6,0x70DF3FF6,0xA5E93FF7,0xD9B73FF7,0xC4A3FF8,
0x3DA13FF8,0x6DBC3FF8,0x9C9C3FF9,0xCA403FF9,0xF6A93FF9,0x21D53FFA,0x4BC63FFA,0x747B3FFA,
0x9BF53FFB,0xC2333FFB,0xE7343FFB,0xAFB3FFC ,0x2D853FFC,0x4ED43FFC,0x6EE73FFC,0x8DBE3FFD,
0xAB5A3FFD,0xC7B93FFD,0xE2DD3FFD,0xFCC53FFD,0x15713FFE,0x2CE23FFE,0x43173FFE,0x58103FFE,
0x6BCD3FFE,0x7E4E3FFE,0x8F933FFF,0x9F9D3FFF,0xAE6B3FFF,0xBBFD3FFF,0xC8533FFF,0xD36E3FFF,
0xDD4C3FFF,0xE5EF3FFF,0xED563FFF,0xF3813FFF,0xF8713FFF,0xFC243FFF,0xFE9C3FFF,0xFFD83FFF,
0xB781FFF3,0x2685FFDA,0x958BFFC1,0x496FFA8 ,0x73A8FF8E,0xE2C3FF75,0x51E8FF5C,0xC11AFF43,
0x305AFF2A,0x9FABFF11,0xF0EFEF8 ,0x7E86FEDE,0xEE14FEC5,0x5DBAFEAC,0xCD7BFE93,0x3D57FE7A,
0xAD51FE61,0x1D6CFE48,0x8DA8FE2F,0xFE08FE15,0x6E8EFDFC,0xDF3CFDE3,0x5013FDCA,0xC116FDB1,
0x3247FD98,0xA3A7FD7F,0x1538FD66,0x86FDFD4D,0xF8F7FD33,0x6B28FD1A,0xDD92FD01,0x5037FCE8,
0xC31AFCCF,0x363BFCB6,0xA99EFC9D,0x1D43FC84,0x912CFC6B,0x55DFC52 ,0x79D6FC38,0xEE9AFC1F,
0x63AAFC06,0xD909FBED,0x4EB8FBD4,0xC4B9FBBB,0x3B0FFBA2,0xB1BBFB89,0x28BEFB70,0xA01CFB57,
0x17D6FB3E,0x8FEEFB25,0x866FB0C ,0x813FFAF3,0xFA7CFAD9,0x741FFAC0,0xEE29FAA7,0x689DFA8E,
0xE37CFA75,0x5EC8FA5C,0xDA84FA43,0x56B1FA2A,0xD351FA11,0x5067F9F8,0xCDF3F9DF,0x4BF8F9C6,
0xCA78F9AD,0x4975F994,0xC8F0F97B,0x48EDF962,0xC96BF949,0x4A6FF930,0xCBF8F917,0x4E0AF8FE,
0xD0A7F8E5,0x53CFF8CC,0xD786F8B3,0x5BCDF89A,0xE0A5F881,0x6612F868,0xEC14F84F,0x72AFF836,
0xF9E3F81D,0x81B2F805,0xA1FF7EC ,0x932CF7D3,0x1CD9F7BA,0xA72AF7A1,0x3221F788,0xBDBEF76F,
0x4A05F756,0xD6F6F73D,0x6495F724,0xF2E2F70B,0x81E0F6F3,0x1191F6DA,0xA1F6F6C1,0x3312F6A8,
0xC4E6F68F,0x5774F676,0xEABFF65D,0x7EC8F644,0x1390F62C,0xA91BF613,0x3F6AF5FA,0xD67FF5E1,
0x6E5BF5C8,0x701F5B0 ,0xA073F597,0x3AB2F57E,0xD5C0F565,0x71A0F54C,0xE52F534 ,0xABDAF51B,
0x4A39F502,0xE971F4E9,0x8984F4D1,0x2A74F4B8,0xCC42F49F,0x6EF1F486,0x1282F46E,0xB6F7F455,
0x5C53F43C,0x297F424 ,0xA9C6F40B,0x51E0F3F2,0xFAE8F3D9,0xA4E0F3C1,0x4FC9F3A8,0xFBA6F38F,
0xA879F377,0x5643F35E,0x507F346 ,0xB4C5F32D,0x6581F314,0x173CF2FC,0xC9F7F2E3,0x7DB6F2CA,
0x3279F2B2,0xE843F299,0x9F15F281,0x56F2F268,0xFDAF250 ,0xC9D1F237,0x84D9F21F,0x40F2F206,
0xFE1FF1ED,0xBC61F1D5,0x7BBBF1BC,0x3C2FF1A4,0xFDBEF18B,0xC06BF173,0x8437F15B,0x4923F142,
0xF33F12A ,0xD668F111,0x9EC3F0F9,0x6847F0E0,0x32F5F0C8,0xFED0F0AF,0xCBD9F097,0x9A12F07F,
0x697DF066,0x3A1CF04E,0xBF1F036 ,0xDEFEF01D,0xB344F005,0x88C5EFED,0x5F84EFD4,0x3782EFBC,
0x10C1EFA4,0xEB43EF8B,0xC709EF73,0xA416EF5B,0x826CEF43,0x620CEF2A,0x42F9EF12,0x2534EEFA,
0x8BEEEE2 ,0xED9BEEC9,0xD3CBEEB1,0xBB51EE99,0xA42EEE81,0x8E65EE69,0x79F7EE50,0x66E6EE38,
0x5533EE20,0x44E2EE08,0x35F3EDF0,0x2869EDD8,0x1C45EDC0,0x118AEDA8,0x838ED90 ,0x52ED78,
0xF9DBED5F,0xF4D2ED47,0xF13CED2F,0xEF19ED17,0xEE6AECFF,0xEF33ECE7,0xF175ECCF,0xF532ECB7,
0xFA6BEC9F,0x123EC88 ,0x95BEC70 ,0x1315EC58,0x1E53EC40,0x2B17EC28,0x3962EC10,0x4937EBF8,
0x5A98EBE0,0x6D86EBC8,0x8202EBB1,0x9810EB99,0xAFB0EB81,0xC8E5EB69,0xE3B0EB51,0x14EB3A,
0x1E11EB22,0x3DAAEB0A,0x5EE1EAF2,0x81B8EADB,0xA630EAC3,0xCC4BEAAB,0xF40CEA93,0x1D73EA7C,
0x4882EA64,0x753DEA4C,0xA3A3EA35,0xD3B8EA1D,0x57DEA06 ,0x38F3E9EE,0x6E1EE9D6,0xA4FDE9BF,
0xDD94E9A7,0x17E4E990,0x53EFE978,0x91B6E961,0xD13CE949,0x1283E932,0x558BE91A,0x9A57E903,
0xE0EAE8EB,0x2943E8D4,0x7366E8BC,0xBF55E8A5,0xD10E88E ,0x5C9AE876,0xADF5E85F,0x122E848,
0x5623E830,0xACFAE819,0x5A9E802 ,0x6032E7EA,0xBC96E7D3,0x1AD7E7BC,0x7AF7E7A4,0xDCF8E78D,
0x40DBE776,0xA6A3E75F,0xE51E748 ,0x77E6E730,0xE366E719,0x50D1E702,0xC029E6EB,0x3170E6D4,
0xA4A9E6BD,0x19D3E6A6,0x90F3E68F,0xA08E678 ,0x8515E661,0x21CE64A ,0x811FE633,0x21FE61C,
0x851EE605,0xA1EE5EE ,0x9120E5D7,0x1A27E5C0,0xA534E5A9,0x3248E592,0xC167E57B,0x5291E564,
0xE5C8E54D,0x7B0EE536,0x1265E520,0xABCEE509,0x474BE4F2,0xE4DFE4DB,0x848AE4C5,0x264FE4AE,
0xCA2FE497,0x702CE480,0x1848E46A,0xC284E453,0x6EE2E43C,0x1D65E426,0xCE0DE40F,0x80DDE3F9,
0x35D6E3E2,0xECFAE3CB,0xA64BE3B5,0x61CAE39E,0x1F79E388,0xDF5BE371,0xA170E35B,0x65BAE344,
0x2C3BE32E,0xF4F6E317,0xBFEBE301,0x8D1CE2EB,0x5C8BE2D4,0x2E3AE2BE,0x22BE2A8 ,0xD85FE291,
0xB0D8E27B,0x8B97E265,0x689FE24E,0x47F1E238,0x298EE222,0xD7AE20C ,0xF3B4E1F5,0xDC40E1DF,
0xC71EE1C9,0xB450E1B3,0xA3D9E19D,0x95B9E187,0x89F3E171,0x8088E15B,0x797AE144,0x74CAE12E,
0x727BE118,0x728EE102,0x7505E0EC,0x79E1E0D6,0x8124E0C1,0x8ACFE0AB,0x96E6E095,0xA568E07F,
0xB658E069,0xC9B8E053,0xDF89E03D,0xF7CDE027,0x1285E012,0x2FB4DFFC,0x4F5ADFE6,0x717BDFD0,
0x9616DFBB,0xBD2FDFA5,0xE6C6DF8F,0x12DDDF7A,0x4177DF64,0x7294DF4E,0xA636DF39,0xDC5FDF23,
0x1511DF0E,0x504EDEF8,0x8E16DEE3,0xCE6CDECD,0x1151DEB8,0x56C7DEA2,0x9ECFDE8D,0xE96CDE77,
0x369FDE62,0x8669DE4D,0xD8CDDE37,0x2DCBDE22,0x8566DE0D,0xDF9FDDF7,0x3C78DDE2,0x9BF2DDCD,
0xFE0FDDB7,0x62D1DDA2,0xCA39DD8D,0x3449DD78,0xA103DD63,0x1068DD4E,0x827ADD39,0xF73ADD23,
0x6EABDD0E,0xE8CDDCF9,0x65A2DCE4,0xE52DDCCF,0x676EDCBA,0xEC67DCA5,0x741ADC90,0xFE89DC7B,
0x8BB4DC67,0x1B9EDC52,0xAE49DC3D,0x43B5DC28,0xDBE5DC13,0x76DADBFE,0x1496DBEA,0xB51ADBD5,
0x5867DBC0,0xFE81DBAB,0xA767DB97,0x531CDB82,0x1A2DB6E ,0xB2F9DB59,0x6723DB44,0x1E23DB30,
0xD7FADB1B,0x94A8DB07,0x5431DAF2,0x1694DADE,0xDBD5DAC9,0xA3F4DAB5,0x6EF4DAA0,0x3CD5DA8C,
0xD99DA78 ,0xE142DA63,0xB7D2DA4F,0x9149DA3B,0x6DAADA26,0x4CF6DA12,0x2F2FD9FE,0x1456D9EA,
0xFC6DD9D5,0xE775D9C1,0xD570D9AD,0xC65FD999,0xBA45D985,0xB122D971,0xAAF8D95D,0xA7C8D949,
0xA795D935,0xAA60D921,0xB02AD90D,0xB8F4D8F9,0xC4C1D8E5,0xD392D8D1,0xE568D8BD,0xFA46D8A9,
0x122BD896,0x2D1BD882,0x4B16D86E,0x6C1ED85A,0x9035D847,0xB75CD833,0xE194D81F,0xEE0D80C,
0x3F40D7F8,0x72B6D7E4,0xA944D7D1,0xE2EBD7BD,0x1FADD7AA,0x5F8BD796,0xA287D783,0xE8A2D76F,
0x31DDD75C,0x7E3BD748,0xCDBCD735,0x2063D722,0x7630D70E,0xCF26D6FB,0x2B45D6E8,0x8A8FD6D5,
0xED06D6C1,0x52ABD6AE,0xBB7FD69B,0x2785D688,0x96BDD675,0x929D662 ,0x7ECBD64E,0xF7A3D63B,
0x73B4D628,0xF2FFD615,0x7585D602,0xFB48D5EF,0x844AD5DD,0x108BD5CA,0xA00DD5B7,0x32D2D5A4,
0xC8DBD591,0x6229D57E,0xFEBFD56B,0x9E9DD559,0x41C5D546,0xE838D533,0x91F8D521,0x3F07D50E,
0xEF65D4FB,0xA314D4E9,0x5A16D4D6,0x146BD4C4,0xD216D4B1,0x9318D49F,0x5772D48C,0x1F26D47A,
0xEA35D467,0xB8A0D455,0x8A6AD443,0x5F92D430,0x381CD41E,0x1407D40C,0xF357D3F9,0xD60BD3E7,
0xBC25D3D5,0xA5A8D3C3,0x9293D3B1,0x82EAD39F,0x76ACD38C,0x6DDCD37A,0x687AD368,0x6689D356,
0x6809D344,0x6CFCD332,0x7563D320,0x8141D30F,0x9095D2FD,0xA362D2EB,0xB9A8D2D9,0xD36AD2C7,
0xF572D4A ,0xEE9A2D5B,0xCA5E2D6D,0xA2A22D7F,0x77632D90,0x48A12DA2,0x165A2DB4,0xE08D2DC5,
0xA7392DD7,0x6A5B2DE8,0x29F42DFA,0xE6012E0B,0x9E802E1D,0x53722E2E,0x4D42E40 ,0xB2A52E51,
0x5CE42E62,0x38F2E74 ,0xA6A62E85,0x46262E96,0xE20E2EA7,0x7A5D2EB8,0xF132ECA ,0xA02C2EDB,
0x2DA92EEC,0xB7872EFD,0x3DC62F0E,0xC0642F1F,0x3F602F30,0xBAB82F41,0x326C2F52,0xA6792F63,
0x16E02F74,0x839D2F85,0xECB02F95,0x52182FA6,0xB3D42FB7,0x11E22FC8,0x6C402FD8,0xC2EE2FE9,
0x15EA2FFA,0x6533300A,0xB0C8301B,0xF8A8302B,0x3CD0303C,0x7D40304C,0xB9F7305D,0xF2F3306D,
0x2834307E,0x59B7308E,0x877B309F,0xB18030AF,0xD7C430BF,0xFA4530CF,0x190330E0,0x33FC30F0,
0x4B303100,0x5E9C3110,0x6E3F3120,0x7A193130,0x82273141,0x866A3151,0x86DF3161,0x83853171,
0x7C5B3180,0x71603190,0x629331A0,0x4FF231B0,0x397D31C0,0x1F3131D0,0x10E31E0 ,0xDF1231EF,
0xB93D31FF,0x8F8D320F,0x6201321E,0x3097322E,0xFB4F323D,0xC227324D,0x851E325D,0x4433326C,
0xFF65327B,0xB6B2328B,0x6A1A329A,0x199A32AA,0xC53332B9,0x6CE232C8,0x10A732D8,0xB08032E7,
0x4C6C32F6,0xE46B3305,0x787A3314,0x8993324 ,0x94C63333,0x1D013342,0xA1483351,0x219A3360,
0x9DF6336F,0x165B337E,0x8AC7338D,0xFB3A339B,0x67B233AA,0xD02E33B9,0x34AD33C8,0x952D33D7,
0xF1AF33E5,0x4A3033F4,0x9EB03403,0xEF2D3411,0x3BA63420,0x841A342F,0xC888343D,0x8EF344C,
0x454E345A,0x7DA33468,0xB1ED3477,0xE22C3485,0xE5F3494 ,0x368334A2,0x5A9834B0,0x7A9E34BE,
0x969234CD,0xAE7434DB,0xC24334E9,0xD1FD34F7,0xDDA13505,0xE52F3513,0xE8A63521,0xE803352F,
0xE347353D,0xDA6F354B,0xCD7C3559,0xBC6C3567,0xA73D3575,0x8DEF3583,0x70813590,0x4EF2359E,
0x294035AC,0xFF6B35B9,0xD17135C7,0x9F5135D5,0x690B35E2,0x2E9E35F0,0xF00735FD,0xAD47360B,
0x665C3618,0x1B463626,0xCC023633,0x78903640,0x20F0364E,0xC520365B,0x651E3668,0xEB3676,
0x98843683,0x2BEA3690,0xBB1B369D,0x461536AA,0xCCD836B7,0x4F6436C4,0xCDB636D1,0x47CE36DE,
0xBDAB36EB,0x2F4C36F8,0x9CB03705,0x5D63712 ,0x6ABD371E,0xCB64372B,0x27CA3738,0x7FED3744,
0xD3CE3751,0x236B375E,0x6EC3376A,0xB5D53777,0xF8A03783,0x37243790,0x715E379C,0xA74F37A9,
0xD8F537B5,0x65037C2 ,0x2F5D37CE,0x541E37DA,0x748F37E6,0x90B237F3,0xA88437FF,0xBC04380B,
0xCB323817,0xD60D3823,0xDC94382F,0xDEC6383B,0xDCA23847,0xD6273853,0xCB54385F,0xBC28386B,
0xA8A33877,0x90C33883,0x7487388E,0x53EF389A,0x2EFA38A6,0x5A638B2 ,0xD7F438BD,0xA5E138C9,
0x6F6E38D4,0x349838E0,0xF56038EB,0xB1C538F7,0x69C53902,0x1D5F390E,0xCC933919,0x77613924,
0x1DC63930,0xBFC2393B,0x5D553946,0xF67D3951,0x8B39395D,0x1B8A3968,0xA76D3973,0x2EE2397E,
0xB1E83989,0x307F3994,0xAAA5399F,0x205939AA,0x919B39B5,0xFE6B39BF,0x66C639CA,0xCAAC39D5,
0x2A1D39E0,0x851739EB,0xDB9A39F5,0x2DA63A00,0x7B383A0A,0xC4503A15,0x8EE3A20 ,0x49113A2A,
0x84B73A35,0xBBE03A3F,0xEE8C3A49,0x1CB93A54,0x46673A5E,0x6B943A68,0x8C413A73,0xA86C3A7D,
0xC0143A87,0xD3393A91,0xE1DA3A9B,0xEBF63AA5,0xF18C3AAF,0xF29C3AB9,0xEF253AC3,0xE7263ACD,
0xDA9E3AD7,0xC98C3AE1,0xB3F03AEB,0x99CA3AF5,0x7B173AFE,0x57D83B08,0x300B3B12,0x3B13B1C,
0xD2C83B25,0x9D4F3B2F,0x63463B38,0x24AC3B42,0xE1803B4B,0x99C23B55,0x4D713B5E,0xFC8C3B67,
0xA7123B71,0x4D023B7A,0xEE5D3B83,0x8B213B8D,0x234E3B96,0xB6E23B9F,0x45DD3BA8,0xD03F3BB1,
0x56063BBA,0xD7333BC3,0x53C33BCC,0xCBB83BD5,0x3F0F3BDE,0xADC83BE7,0x17E33BF0,0x7D5F3BF8,
0xDE3B3C01,0x3A773C0A,0x92113C13,0xE50A3C1B,0x33603C24,0x7D133C2C,0xC2223C35,0x28D3C3E,
0x3E523C46,0x75723C4E,0xA7EB3C57,0xD5BD3C5F,0xFEE83C67,0x236A3C70,0x43433C78,0x5E723C80,
0x74F73C88,0x86D23C91,0x94003C99,0x9C833CA1,0xA0593CA9,0x9F813CB1,0x99FB3CB9,0x8FC73CC1,
0x80E43CC9,0x6D503CD0,0x550C3CD8,0x38173CE0,0x16713CE8,0xF0183CEF,0xC50C3CF7,0x954D3CFF,
0x60DA3D06,0x27B23D0E,0xE9D63D15,0xA7433D1D,0x5FFA3D24,0x13FA3D2C,0xC3423D33,0x6DD33D3A,
0x13AB3D42,0xB4C93D49,0x512E3D50,0xE8D93D57,0x7BC83D5E,0x9FD3D66 ,0x93753D6D,0x18313D74,
0x98303D7B,0x13713D82,0x89F43D89,0xFBB83D8F,0x68BD3D96,0xD1033D9D,0x34883DA4,0x934D3DAB,
0xED503DB1,0x42913DB8,0x93103DBF,0xDECC3DC5,0x25C53DCC,0x67FA3DD2,0xA56B3DD9,0xDE173DDF,
0x11FD3DE6,0x411E3DEC,0x6B783DF2,0x910C3DF9,0xB1D83DFF,0xCDDD3E05,0xE5193E0B,0xF78C3E11,
0x5373E18 ,0xE173E1E ,0x122D3E24,0x11793E2A,0xBFA3E30 ,0x1AF3E36 ,0xF2983E3B,0xDEB53E41,
0xC6053E47,0xA8873E4D,0x863C3E53,0x5F223E58,0x333A3E5E,0x2833E64 ,0xCCFC3E69,0x92A53E6F,
0x537E3E74,0xF863E7A ,0xC6BC3E7F,0x79213E84,0x26B43E8A,0xCF753E8F,0x73623E94,0x127C3E9A,
0xACC33E9F,0x42353EA4,0xD2D33EA9,0x5E9C3EAE,0xE5903EB3,0x67AE3EB8,0xE4F53EBD,0x5D673EC2,
0xD1013EC7,0x3FC53ECC,0xA9B03ED1,0xEC43ED6 ,0x6F003EDA,0xCA623EDF,0x20EC3EE4,0x729C3EE8,
0xBF733EED,0x76F3EF2 ,0x4A913EF6,0x88D83EFB,0xC2433EFF,0xF6D43F03,0x26883F08,0x51603F0C,
0x775C3F10,0x987A3F15,0xB4BC3F19,0xCC203F1D,0xDEA63F21,0xEC4E3F25,0xF5173F29,0xF9023F2D,
0xF80E3F31,0xF23A3F35,0xE7863F39,0xD7F33F3D,0xC37F3F41,0xAA2A3F45,0x8BF53F49,0x68DE3F4C,
0x40E63F50,0x140C3F54,0xE2503F57,0xABB13F5B,0x70303F5E,0x2FCD3F62,0xEA863F65,0xA05B3F69,
0x514D3F6C,0xFD5B3F6F,0xA4853F73,0x46CA3F76,0xE42B3F79,0x7CA63F7C,0x103D3F80,0x9EEE3F83,
0x28B93F86,0xAD9E3F89,0x2D9D3F8C,0xA8B63F8F,0x1EE83F92,0x90343F95,0xFC983F97,0x64153F9A,
0xC6AA3F9D,0x24583FA0,0x7D1E3FA2,0xD0FB3FA5,0x1FF13FA8,0x69FE3FAA,0xAF223FAD,0xEF5D3FAF,
0x2AAF3FB2,0x61173FB4,0x92963FB7,0xBF2C3FB9,0xE6D73FBB,0x9993FBE ,0x27703FC0,0x405D3FC2,
0x54603FC4,0x63773FC6,0x6DA43FC8,0x72E63FCA,0x733C3FCC,0x6EA73FCE,0x65273FD0,0x56BA3FD2,
0x43633FD4,0x2B1F3FD6,0xDEF3FD8 ,0xEBD23FD9,0xC4CA3FDB,0x98D53FDD,0x67F33FDE,0x32253FE0,
0xF7693FE1,0xB7C13FE3,0x732C3FE4,0x29A93FE6,0xDB393FE7,0x87DB3FE9,0x2F913FEA,0xD2583FEB,
0x70323FEC,0x91D3FEE ,0x9D1B3FEF,0x2C2B3FF0,0xB64D3FF1,0x3B813FF2,0xBBC63FF3,0x371D3FF4,
0xAD853FF5,0x1F003FF6,0x8B8B3FF7,0xF3283FF7,0x55D63FF8,0xB3963FF9,0xC663FFA ,0x60483FFA,
0xAF3B3FFB,0xF93F3FFB,0x3E543FFC,0x7E7A3FFC,0xB9B13FFD,0xEFF93FFD,0x21513FFE,0x4DBB3FFE,
0x75353FFE,0x97C03FFF,0xB55C3FFF,0xCE083FFF,0xE1C53FFF,0xF0933FFF,0xFA723FFF,0xFF613FFF,
0x6F03FFE6,0x4D10FFB4,0x2B34FF82,0x97FFF50 ,0xE800FF1D,0xC6C8FEEB,0xA5E4FEB9,0x8565FE87,
0x655AFE54,0x45D4FE22,0x26E0FDF0,0x88FFDBE ,0xEAF1FD8B,0xCE14FD59,0xB208FD27,0x96DDFCF5,
0x7CA3FCC2,0x6368FC90,0x4B3CFC5E,0x342FFC2C,0x1E50FBFA,0x9AEFBC8 ,0xF65AFB95,0xE462FB63,
0xD3D6FB31,0xC4C6FAFF,0xB741FACD,0xAB56FA9B,0xA114FA69,0x988CFA37,0x91CDFA05,0x8CE6F9D3,
0x89E7F9A1,0x88DEF96F,0x89DCF93D,0x8CF0F90B,0x9229F8D9,0x9997F8A7,0xA349F875,0xAF4EF843,
0xBDB7F811,0xCE91F7DF,0xE1EDF7AD,0xF7DBF77B,0x1068F74A,0x2BA5F718,0x49A2F6E6,0x6A6DF6B4,
0x8E15F683,0xB4ABF651,0xDE3EF61F,0xADCF5EE ,0x3A95F5BC,0x6D78F58A,0xA395F559,0xDCFCF527,
0x19BAF4F6,0x59E0F4C4,0x9D7DF493,0xE4A0F461,0x2F58F430,0x7DB5F3FE,0xCFC6F3CD,0x2599F39C,
0x7F3FF36A,0xDCC6F339,0x3E3EF308,0xA3B6F2D7,0xD3DF2A6 ,0x7AE2F274,0xECB4F243,0x62C3F212,
0xDD1DF1E1,0x5BD2F1B0,0xDEF1F17F,0x6689F14E,0xF2A9F11D,0x8360F0ED,0x18BDF0BC,0xB2CFF08B,
0x51A6F05A,0xF550F029,0x9DDDEFF9,0x4B5BEFC8,0xFDD9EF97,0xB567EF67,0x7213EF36,0x33ECEF06,
0xFB02EED5,0xC763EEA5,0x991EEE75,0x7042EE44,0x4CDEEE14,0x2F02EDE4,0x16BAEDB4,0x418ED84,
0xF729ED53,0xEFFCED23,0xEEA0ECF3,0xF324ECC3,0xFD97EC93,0xE07EC64 ,0x2484EC34,0x411CEC04,
0x63DDEBD4,0x8CD7EBA5,0xBC18EB75,0xF1AFEB45,0x2DAAEB16,0x7019EAE6,0xB909EAB7,0x88AEA88,
0x5EAAEA58,0xBB78EA29,0x1F02E9FA,0x8957E9CB,0xFA85E99B,0x729BE96C,0xF1A7E93D,0x77B9E90E,
0x4DDE8E0 ,0x9924E8B1,0x349BE882,0xD751E853,0x8154E825,0x32B2E7F6,0xEB7AE7C7,0xABBBE799,
0x7382E76A,0x42DEE73C,0x19DEE70E,0xF88FE6DF,0xDF00E6B1,0xCD3EE683,0xC35AE655,0xC15FE627,
0xC75EE5F9,0xD563E5CB,0xEB7DE59D,0x9BAE570 ,0x3029E542,0x5ED7E514,0x95D2E4E7,0xD529E4B9,
0x1CEAE48C,0x6D22E45E,0xC5DFE431,0x2730E404,0x9123E3D7,0x3C4E3AA ,0x7F24E37C,0x34EE350,
0x9051E323,0x263CE2F6,0xC51BE2C9,0x6CFCE29C,0x1DEEE270,0xD7FEE243,0x9B3AE217,0x67B0E1EA,
0x3D6CE1BE,0x1C7EE192,0x4F2E166 ,0xF6D6E139,0xF238E10D,0xF726E0E1,0x5ACE0B6 ,0x1DD9E08A,
0x3FBAE05E,0x6B5CE032,0xA0CEE007,0xE01BDFDB,0x2953DFB0,0x7C81DF84,0xD9B5DF59,0x40FADF2E,
0xB25EDF03,0x2DEFDED8,0xB3BADEAD,0x43CBDE82,0xDE31DE57,0x82F9DE2D,0x322FDE02,0xEBE1DDD7,
0xB01BDDAD,0x7EECDD82,0x5860DD58,0x3C84DD2E,0x2B65DD04,0x2511DCDA,0x2993DCB0,0x38FADC86,
0x5351DC5C,0x78A7DC32,0xA907DC09,0xE47EDBDF,0x2B1ADBB6,0x7CE8DB8C,0xD9F3DB63,0x4249DB3A,
0xB5F6DB11,0x3507DAE8,0xBF89DABF,0x5588DA96,0xF711DA6D,0xA430DA45,0x5CF3DA1C,0x2165D9F4,
0xF193D9CB,0xCD89D9A3,0xB554D97B,0xA901D953,0xA89BD92B,0xB42FD903,0xCBC9D8DB,0xEF76D8B3,
0x1F42D88C,0x5B38D864,0xA366D83D,0xF7D7D815,0x5898D7EE,0xC5B4D7C7,0x3F38D7A0,0xC530D779,
0x57A8D752,0xF6ABD72B,0xA246D705,0x5A84D6DE,0x1F72D6B8,0xF11CD691,0xCF8CD66B,0xBAD0D645,
0xB2F2D61F,0xB7FFD5F9,0xCA02D5D3,0xE907D5AD,0x1519D588,0x4E45D562,0x9495D53D,0xE816D517,
0x48D2D4F2,0xB6D6D4CD,0x322CD4A8,0xBAE1D483,0x50FFD45E,0xF492D439,0xA5A5D415,0x6444D3F0,
0x307AD3CC,0xA51D3A8 ,0xF1D6D383,0xE713D35F,0xEA14D33B,0xFAE3D317,0x198CD2F4,0x461AD2D0,
0x7F682D52,0x36F02D76,0xE0732D99,0x7BE52DBC,0x93B2DE0 ,0x886C2E03,0xF96B2E25,0x5C2F2E48,
0xB0AC2E6B,0xF6D82E8D,0x2EA92EB0,0x58132ED2,0x730C2EF4,0x7F892F16,0x7D812F38,0x6CE82F5A,
0x4DB32F7C,0x1FDA2F9E,0xE3512FBF,0x980D2FE1,0x3E053002,0xD52F3023,0x5D7F3044,0xD6ED3065,
0x416D3086,0x9CF630A7,0xE97D30C7,0x26F830E8,0x555F3108,0x74A53128,0x84C23149,0x85AC3169,
0x77583188,0x59BD31A8,0x2CD231C8,0xF08B31E7,0xA4E13207,0x49C83226,0xDF373245,0x65253264,
0xDB883283,0x425732A2,0x998832C1,0xE11132DF,0x18E932FE,0x4108331C,0x5962333A,0x61F03358,
0x5AA73376,0x43803394,0x1C6F33B2,0xE56D33CF,0x9E7033ED,0x476F340A,0xE0613427,0x693C3444,
0xE1F93461,0x4A8E347E,0xA2F3349B,0xEB1D34B7,0x230534D4,0x4AA234F0,0x61EB350C,0x68D73528,
0x5F5E3544,0x45783560,0x1B1A357C,0xE03E3597,0x94DA35B3,0x38E635CE,0xCC5A35E9,0x4F2D3604,
0xC156361F,0x22CF363A,0x738E3654,0xB38B366F,0xE2BE3689,0x11F36A4 ,0xEA536BE ,0xB4936D8,
0xF70336F1,0xD1CB370B,0x9B983725,0x5464373E,0xFC253757,0x92D53771,0x186B378A,0x8CE037A3,
0xF02C37BB,0x424737D4,0x832B37ED,0xB2CE3805,0xD12A381D,0xDE383835,0xD9EF384D,0xC4493865,
0x9D3E387D,0x64C73894,0x1ADC38AC,0xBF7738C3,0x528F38DA,0xD41F38F1,0x441F3908,0xA287391F,
0xEF513935,0x2A76394C,0x53EF3962,0x6BB53978,0x71C2398E,0x660D39A4,0x489139BA,0x194839D0,
0xD82939E5,0x852F39FB,0x20533A10,0xA98F3A25,0x20DB3A3A,0x86323A4F,0xD98E3A63,0x1AE73A78,
0x4A373A8C,0x67793AA0,0x72A53AB4,0x6BB63AC8,0x52A63ADC,0x276E3AF0,0xEA093B03,0x9A703B17,
0x389D3B2A,0xC48B3B3D,0x3E343B50,0xA5913B63,0xFA9D3B75,0x3D523B88,0x6DAB3B9A,0x8BA13BAD,
0x97303BBF,0x90513BD1,0x76FF3BE2,0x4B353BF4,0xCED3C06 ,0xBC223C17,0x58CE3C28,0xE2EC3C39,
0x5A773C4A,0xBF693C5B,0x11BE3C6C,0x51703C7C,0x7E7A3C8C,0x98D73C9D,0xA0833CAD,0x95773CBD,
0x77B03CCC,0x47283CDC,0x3DB3CEC ,0xADC33CFB,0x44DD3D0A,0xC9233D19,0x3A913D28,0x99223D37,
0xE4D13D45,0x1D9B3D54,0x437A3D62,0x566B3D70,0x56683D7E,0x436E3D8C,0x1D783D9A,0xE4833DA7,
0x98893DB5,0x39873DC2,0xC7783DCF,0x425A3DDC,0xAA273DE9,0xFEDB3DF5,0x40733E02,0x6EEC3E0E,
0x8A403E1B,0x926D3E27,0x876E3E33,0x69403E3E,0x37E03E4A,0xF3493E55,0x9B783E61,0x306A3E6C,
0xB21C3E77,0x20893E82,0x7BAF3E8C,0xC38A3E97,0xF8173EA1,0x19523EAC,0x27393EB6,0x21C93EC0,
0x8FE3ECA ,0xDCD53ED3,0x9D4C3EDD,0x4A5F3EE6,0xE40C3EEF,0x6A503EF8,0xDD273F01,0x3C903F0A,
0x88873F13,0xC10A3F1B,0xE6163F23,0xF7A93F2B,0xF5C03F33,0xE0583F3B,0xB7703F43,0x7B053F4A,
0x2B153F52,0xC79D3F59,0x509B3F60,0xC60D3F67,0x27F13F6E,0x76443F74,0xB1053F7B,0xD8323F81,
0xEBC83F87,0xEBC63F8D,0xD82B3F93,0xB0F33F99,0x761E3F9E,0x27AA3FA4,0xC5943FA9,0x4FDC3FAE,
0xC6803FB3,0x297E3FB8,0x78D63FBC,0xB4843FC1,0xDC893FC5,0xF0E23FC9,0xF18F3FCD,0xDE8E3FD1,
0xB7DE3FD5,0x7D7E3FD8,0x2F6D3FDC,0xCDA93FDF,0x58333FE2,0xCF083FE5,0x32283FE8,0x81923FEB,
0xBD453FED,0xE5413FEF,0xF9853FF1,0xFA0F3FF3,0xE6E03FF5,0xBFF73FF7,0x85543FF9,0x36F53FFA,
0xD4DB3FFB,0x5F053FFC,0xD5733FFD,0x38243FFE,0x87183FFF,0xC2503FFF,0xE9CA3FFF,0xFD873FFF,
0xDE07FFCD,0x9A54FF69,0x575AFF04,0x1597FEA0,0xD586FE3B,0x97A2FDD7,0x5C69FD72,0x2456FD0E,
0xEFE4FCA9,0xBF90FC45,0x93D6FBE1,0x6D31FB7C,0x4C1EFB18,0x3117FAB4,0x1C98FA50,0xF1EF9EC,
0x923F988 ,0xB23F924 ,0x1599F8C0,0x2900F85C,0x45D5F7F8,0x6C91F794,0x9DB0F731,0xD9ADF6CD,
0x2102F66A,0x742AF606,0xD3A0F5A3,0x3FDFF540,0xB95FF4DD,0x409DF47A,0xD611F417,0x7A36F3B4,
0x2D86F352,0xF079F2EF,0xC38BF28D,0xA733F22B,0x9BEBF1C9,0xA22DF167,0xBA70F105,0xE52FF0A3,
0x22E0F042,0x73FDEFE0,0xD8FDEF7F,0x5259EF1E,0xE088EEBD,0x8402EE5D,0x3D3EEDFC,0xCB3ED9C,
0xF2D9ED3B,0xF025ECDB,0x50EEC7C ,0x320BEC1C,0x7792EBBC,0xD618EB5D,0x4E12EAFE,0xDFF7EA9F,
0x8C3AEA41,0x5352E9E2,0x35B2E984,0x33CEE926,0x4E1CE8C8,0x850DE86B,0xD916E80D,0x4AABE7B0,
0xDA3DE753,0x883FE6F7,0x5524E69A,0x415EE63E,0x4D5EE5E2,0x7996E586,0xC677E52B,0x3471E4D0,
0xC3F6E475,0x7574E41A,0x495DE3C0,0x401EE366,0x5A29E30C,0x97EAE2B3,0xF9D2E259,0x804DE201,
0x2BCAE1A8,0xFCB5E14F,0xF37DE0F7,0x108DE0A0,0x5452E048,0xBF38DFF1,0x51AADF9A,0xC14DF44,
0xEEE0DEED,0xFA79DE97,0x2F48DE42,0x8DB7DDED,0x1630DD98,0xC91BDD43,0xA6E1DCEF,0xAFE9DC9B,
0xE49BDC47,0x455FDBF4,0xD29ADBA1,0x8CB4DB4F,0x7411DAFC,0x8918DAAB,0xCC2DDA59,0x3DB5DA08,
0xDE14D9B7,0xADAED967,0xACE5D917,0xDC1CD8C7,0x3BB7D878,0xCC16D829,0x8D9AD7DB,0x80A5D78D,
0xA597D73F,0xFCD0D6F1,0x86AFD6A5,0x4393D658,0x33DBD60C,0x57E3D5C0,0xB00BD575,0x3CAFD52A,
0xFE2AD4DF,0xF4DAD495,0x2119D44C,0x8342D403,0x1BB0D3BA,0xEABDD371,0xF0C1D329,0x2E16D2E2,
0x5CEC2D64,0xAFEE2DAB,0xCA992DF1,0xAC952E37,0x558D2E7C,0xC52B2EC1,0xFB1B2F05,0xF7072F49,
0xB89C2F8D,0x3F872FD0,0x8B753013,0x9C133055,0x71113096,0xA1D30D8 ,0x66E63118,0x871E3159,
0x6A743198,0x109A31D8,0x79423216,0xA41F3255,0x90E33293,0x3F4232D0,0xAEF0330D,0xDFA33349,
0xD1103385,0x82ED33C1,0xF4F033FB,0x26D23436,0x18493470,0xC91034A9,0x38DE34E2,0x676D351A,
0x54793552,0xFFBC3589,0x68F235C0,0x8FD835F7,0x7429362C,0x15A53662,0x74093696,0x8F1436CB,
0x668636FE,0xFA1F3731,0x49A03764,0x54CA3796,0x1B6037C8,0x9D2537F9,0xD9DB3829,0xD1483859,
0x83303889,0xEF5938B7,0x158938E6,0xF5863913,0x8F193941,0xE209396D,0xEE203999,0xB32739C5,
0x30E839F0,0x672E3A1A,0x55C63A44,0xFC7B3A6D,0x5B1A3A96,0x71723ABE,0x3F503AE6,0xC4833B0D,
0xDD3B34  ,0xF42C3B59,0x9E433B7F,0xFEF33BA3,0x160E3BC8,0xE36A3BEB,0x66D83C0E,0xA02F3C31,
0x8F433C53,0x33EB3C74,0x8DFF3C95,0x9D543CB5,0x61C43CD4,0xDB293CF3,0x95B3D12 ,0xEC353D2F,
0x83933D4D,0xCF503D69,0xCF4A3D85,0x835E3DA1,0xEB693DBB,0x74B3DD6 ,0xD6E43DEF,0x5A143E08,
0x90BC3E21,0x7ABD3E38,0x17FB3E50,0x68593E66,0x6BBB3E7C,0x22063E92,0x8B1F3EA7,0xA6EC3EBB,
0x75563ECE,0xF6423EE1,0x299B3EF4,0xF493F06, 0xA7373F17,0xF14F3F27,0xED7C3F37,0x9BAB3F47,
0xFBCA3F55,0xDC63F64 ,0xD18C3F71,0x470E3F7E,0x6E3A3F8A,0x47033F96,0xD1583FA1,0xD2D3FAC,
0xFA743FB5,0x99223FBF,0xE92B3FC7,0xEA843FCF,0x9D243FD7,0x1023FDE ,0x16143FE4,0xDC543FE9,
0x53BA3FEE,0x7C413FF2,0x55E33FF6,0xE09C3FF9,0x1C673FFC,0x9433FFE ,0xA72C3FFF,0xF6203FFF,
0xBC1EFF9B,0x364AFED2,0xB646FE09,0x3FF3FD40,0xD72FFC77,0x7FD9FBAE,0x3DD1FAE6,0x14F3FA1E,
0x91CF956 ,0x1E27F88E,0x57EEF7C6,0xBA4BF6FF,0x4914F638,0x81FF572 ,0xFB3FF4AB,0x2646F3E6,
0x8D03F321,0x3344F25C,0x1CD3F198,0x4D79F0D4,0xC8F9F011,0x9318EF4F,0xAF94EE8D,0x222AEDCC,
0xEE93ED0B,0x1883EC4C,0xA3ADEB8D,0x93C0EACF,0xEC64EA11,0xB141E955,0xE5F9E899,0x8E28E7DF,
0xAD69E725,0x4750E66C,0x5F6CE5B4,0xF94AE4FD,0x186FE448,0xC05BE393,0xF48CE2DF,0xB876E22D,
0xF8BE17C ,0xFD35E0CB,0x84DAE01D,0xA9DADF6F,0x6F8CDEC2,0xD945DE17,0xEA51DD6D,0xA5F6DCC5,
0xF75DC1E ,0x2A05DB78,0xF8D9DAD3,0x7F1CDA30,0xBFF3D98F,0xBE7AD8EF,0x7DC8D850,0xE9D7B4,
0x4AE5D718,0x5EBAD67E,0x3F61D5E6,0xEFC8D54F,0x72D6D4BA,0xCB6BD427,0xFC5DD395,0x87CD306,
0xD732D88 ,0x42B22E14,0x948D2E9F,0x562F28  ,0x836C2FAF,0x1B333034,0xC51A30B7,0x7E993138,
0x453231B8,0x166F3236,0xEFE432B1,0xCF2E332B,0xB1F533A3,0x95EA3419,0x78C7348C,0x585234FE,
0x3258356E,0x4B335DC ,0xCD463647,0x89FE36B1,0x38D23718,0xD7C4377D,0x64E037E0,0xDE3F3841,
0x420038A0,0x8E5138FD,0xC1693957,0xD98939AF,0xD4FE3A05,0xB2203A59,0x6F523AAA,0xB023AFA,
0x83A83B47,0xD7CA3B91,0x5F73BDA ,0xCC93C20 ,0xEAE73C63,0x9F033CA5,0x27DA3CE4,0x84353D21,
0xB2E83D5B,0xB2D33D93,0x82E13DC9,0x220B3DFC,0x8F533E2D,0xC9C83E5B,0xD0853E87,0xA2B03EB1,
0x3F7D3ED8,0xA6293EFD,0xD5FF3F1F,0xCE553F3F,0x8E8D3F5D,0x16173F78,0x646C3F90,0x79133FA6,
0x539F3FBA,0xF3AE3FCB,0x58EC3FDA,0x830F3FE7,0x71DA3FF0,0x251D3FF8,0x9CB33FFD,0xD8853FFF,
0x78B8FF36,0x79A9FDA4,0xA918FC13,0x25FFFA82,0xF47F8F2 ,0x83CCF763,0xA254F5D5,0x8989F449,
0x57F7F2BE,0x2C07F136,0x23F9EFB0,0x5DE0EE2C,0xF79FECAB,0xEDFEB2E ,0xC112E9B3,0x2B68E83C,
0x6ACEE6C8,0x9BEAE559,0xDB14E3ED,0x4452E286,0xF357E123,0x379DFC6 ,0x8FB3DE6D,0xB29CDD19,
0x8667DBCB,0x24DADA82,0xA74FD93F,0x26ADD802,0xBB65D6CB,0x7D6ED59A,0x8442D471,0xE6DAD34D,
0x44542DCE,0xE75E2EE3,0xECE22FF1,0x400F30F8,0xCCA331F7,0x7EF432EE,0x43EE33DE,0x91A34C6,
0xBC9D35A5,0x4D3E367C,0xAA66374B,0xC4263811,0x8B3438CF,0xF0F33983,0xE7733A2F,0x61733AD2,
0x52613B6C,0xAE613BFD,0x6A4A3C84,0x7BAA3D02,0xD8C83D77,0x78A33DE2,0x52F63E44,0x603A3E9C,
0x99A33EEB,0xF9243F2F,0x79713F6A,0x15FC3F9C,0xCAFC3FC3,0x95653FE1,0x72EF3FF4,0x62163FFE};
#endif //BUILD_INTEGER
#endif //USE_SIN_COS_TABLES

// create these preload tables with cossin project & cut & paste
// g_sct64 added by Raymond was one bit different than what cossin.exe produces so use cossin's for consistency

const SinCosTable g_sct64 = {
        BP1_FROM_FLOAT(0.012271538285720),       // 0x01921d1f sin( pi/(4*64) ) * nF2BP1 for DCT & inverseTransform
        BP1_FROM_FLOAT(0.999924701839145),       // 0x7ffd8859 cos( pi/(4*64) ) * nF2BP1 for DCT & inverseTransform
        BP1_FROM_FLOAT(0.036807222941359),       // 0x04b6195d sin( 3*pi/(4*64) ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.999322384588350),       // 0x7fe9cbbe cos( 3*pi/(4*64) ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.049067674327418),       // 0x0647d97c sin( pi/64 ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.998795456205172),       // 0x7fd8878c cos( pi/64 ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.098017140329561),       // 0x0c8bd35d sin( pi/(64/2) ) * nF2BP1 for FFT
        BP1_FROM_FLOAT(0.995184726672197),       // 0x7f62368e cos( pi/(64/2) ) * nF2BP1 for FFT
        BP1_FROM_FLOAT(0.024541228522912),       // 0x03242abe sin( pi/(2*64) ) * nF2BP1 for FFT & inverseTransform
        BP1_FROM_FLOAT(0.999698818696204),       // 0x7ff62181 cos( pi/(2*64) ) * nF2BP1 for FFT & inverseTransform
        BP1_FROM_FLOAT(0.098135348654836)        // 0x0c8fb2f8 2*sin( pi/64 ) * nF2BP1 for DCT
#   ifdef ENABLE_LPC
       ,BP2_FROM_FLOAT(0.195090322016128)        // sin( 4*pi/cSB ) * nF2BP2 for LPC
       ,BP2_FROM_FLOAT(0.980785280403230)        // sin( 4*pi/cSB ) * nF2BP2 for LPC
#   endif
                };
const SinCosTable g_sct128 = {
        BP1_FROM_FLOAT(0.006135884649154),       // 0x00c90f87 sin( pi/(4*128) ) * nF2BP1 for DCT & inverseTransform
        BP1_FROM_FLOAT(0.999981175282601),       // 0x7fff6215 cos( pi/(4*128) ) * nF2BP1 for DCT & inverseTransform
        BP1_FROM_FLOAT(0.018406729905805),       // 0x025b26d7 sin( 3*pi/(4*128) ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.999830581795823),       // 0x7ffa72d0 cos( 3*pi/(4*128) ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.024541228522912),       // 0x03242abe sin( pi/128 ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.999698818696204),       // 0x7ff62181 cos( pi/128 ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.049067674327418),       // 0x0647d97c sin( pi/(128/2) ) * nF2BP1 for FFT
        BP1_FROM_FLOAT(0.998795456205172),       // 0x7fd8878c cos( pi/(128/2) ) * nF2BP1 for FFT
        BP1_FROM_FLOAT(0.012271538285720),       // 0x01921d1f sin( pi/(2*128) ) * nF2BP1 for FFT & inverseTransform
        BP1_FROM_FLOAT(0.999924701839145),       // 0x7ffd8859 cos( pi/(2*128) ) * nF2BP1 for FFT & inverseTransform
        BP1_FROM_FLOAT(0.049082457045825)        // 0x0648557d 2*sin( pi/128 ) * nF2BP1 for DCT
#   ifdef ENABLE_LPC
       ,BP2_FROM_FLOAT(0.098017140329560)        // sin( 4*pi/cSB ) * nF2BP2 for LPC
       ,BP2_FROM_FLOAT(0.995184726672196)        // sin( 4*pi/cSB ) * nF2BP2 for LPC
#   endif
                };
const SinCosTable g_sct256 = {
        BP1_FROM_FLOAT(0.003067956762966),       // 0x006487e2 sin( pi/(4*256) ) * nF2BP1 for DCT & inverseTransform
        BP1_FROM_FLOAT(0.999995293809576),       // 0x7fffd884 cos( pi/(4*256) ) * nF2BP1 for DCT & inverseTransform
        BP1_FROM_FLOAT(0.009203754782060),       // 0x012d96b0 sin( 3*pi/(4*256) ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.999957644551964),       // 0x7ffe9cb1 cos( 3*pi/(4*256) ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.012271538285720),       // 0x01921d1f sin( pi/256 ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.999924701839145),       // 0x7ffd8859 cos( pi/256 ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.024541228522912),       // 0x03242abe sin( pi/(256/2) ) * nF2BP1 for FFT
        BP1_FROM_FLOAT(0.999698818696204),       // 0x7ff62181 cos( pi/(256/2) ) * nF2BP1 for FFT
        BP1_FROM_FLOAT(0.006135884649154),       // 0x00c90f87 sin( pi/(2*256) ) * nF2BP1 for FFT & inverseTransform
        BP1_FROM_FLOAT(0.999981175282601),       // 0x7fff6215 cos( pi/(2*256) ) * nF2BP1 for FFT & inverseTransform
        BP1_FROM_FLOAT(0.024543076571440)        // 0x03243a3f 2*sin( pi/256 ) * nF2BP1 for DCT
#   ifdef ENABLE_LPC
       ,BP2_FROM_FLOAT(0.049067674327418)        // sin( 4*pi/cSB ) * nF2BP2 for LPC
       ,BP2_FROM_FLOAT(0.998795456205172)        // sin( 4*pi/cSB ) * nF2BP2 for LPC
#   endif
                };
const SinCosTable g_sct512 = {
        BP1_FROM_FLOAT(0.001533980186285),       // 0x003243f5 sin( pi/(4*512) ) * nF2BP1 for DCT & inverseTransform
        BP1_FROM_FLOAT(0.999998823451702),       // 0x7ffff620 cos( pi/(4*512) ) * nF2BP1 for DCT & inverseTransform
        BP1_FROM_FLOAT(0.004601926120449),       // 0x0096cbc1 sin( 3*pi/(4*512) ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.999989411081928),       // 0x7fffa72b cos( 3*pi/(4*512) ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.006135884649154),       // 0x00c90f87 sin( pi/512 ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.999981175282601),       // 0x7fff6215 cos( pi/512 ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.012271538285720),       // 0x01921d1f sin( pi/(512/2) ) * nF2BP1 for FFT
        BP1_FROM_FLOAT(0.999924701839145),       // 0x7ffd8859 cos( pi/(512/2) ) * nF2BP1 for FFT
        BP1_FROM_FLOAT(0.003067956762966),       // 0x006487e2 sin( pi/(2*512) ) * nF2BP1 for FFT & inverseTransform
        BP1_FROM_FLOAT(0.999995293809576),       // 0x7fffd884 cos( pi/(2*512) ) * nF2BP1 for FFT & inverseTransform
        BP1_FROM_FLOAT(0.012271769298309)        // 0x01921f0f 2*sin( pi/512 ) * nF2BP1 for DCT
#   ifdef ENABLE_LPC
       ,BP2_FROM_FLOAT(0.024541228522912)        // sin( 4*pi/cSB ) * nF2BP2 for LPC
       ,BP2_FROM_FLOAT(0.999698818696204)        // sin( 4*pi/cSB ) * nF2BP2 for LPC
#   endif
                };
const SinCosTable g_sct1024 = {
        BP1_FROM_FLOAT(0.000766990318743),       // 0x001921fb sin( pi/(4*1024) ) * nF2BP1 for DCT & inverseTransform
        BP1_FROM_FLOAT(0.999999705862882),       // 0x7ffffd87 cos( pi/(4*1024) ) * nF2BP1 for DCT & inverseTransform
        BP1_FROM_FLOAT(0.002300969151426),       // 0x004b65ed sin( 3*pi/(4*1024) ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.999997352766978),       // 0x7fffe9ca cos( 3*pi/(4*1024) ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.003067956762966),       // 0x006487e2 sin( pi/1024 ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.999995293809576),       // 0x7fffd884 cos( pi/1024 ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.006135884649154),       // 0x00c90f87 sin( pi/(1024/2) ) * nF2BP1 for FFT
        BP1_FROM_FLOAT(0.999981175282601),       // 0x7fff6215 cos( pi/(1024/2) ) * nF2BP1 for FFT
        BP1_FROM_FLOAT(0.001533980186285),       // 0x003243f5 sin( pi/(2*1024) ) * nF2BP1 for FFT & inverseTransform
        BP1_FROM_FLOAT(0.999998823451702),       // 0x7ffff620 cos( pi/(2*1024) ) * nF2BP1 for FFT & inverseTransform
        BP1_FROM_FLOAT(0.006135913525932)        // 0x00c90fc5 2*sin( pi/1024 ) * nF2BP1 for DCT
#   ifdef ENABLE_LPC
       ,BP2_FROM_FLOAT(0.012271538285719)        // sin( 4*pi/cSB ) * nF2BP2 for LPC
       ,BP2_FROM_FLOAT(0.999924701839144)        // sin( 4*pi/cSB ) * nF2BP2 for LPC
#   endif
                };
const SinCosTable g_sct2048 = {
        BP1_FROM_FLOAT(0.000383495187571),       // 0x000c90fd sin( pi/(4*2048) ) * nF2BP1 for DCT & inverseTransform
        BP1_FROM_FLOAT(0.999999926465718),       // 0x7fffff61 cos( pi/(4*2048) ) * nF2BP1 for DCT & inverseTransform
        BP1_FROM_FLOAT(0.001150485337114),       // 0x0025b2f8 sin( 3*pi/(4*2048) ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.999999338191526),       // 0x7ffffa71 cos( 3*pi/(4*2048) ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.001533980186285),       // 0x003243f5 sin( pi/2048 ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.999998823451702),       // 0x7ffff620 cos( pi/2048 ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.003067956762966),       // 0x006487e2 sin( pi/(2048/2) ) * nF2BP1 for FFT
        BP1_FROM_FLOAT(0.999995293809576),       // 0x7fffd884 cos( pi/(2048/2) ) * nF2BP1 for FFT
        BP1_FROM_FLOAT(0.000766990318743),       // 0x001921fb sin( pi/(2*2048) ) * nF2BP1 for FFT & inverseTransform
        BP1_FROM_FLOAT(0.999999705862882),       // 0x7ffffd87 cos( pi/(2*2048) ) * nF2BP1 for FFT & inverseTransform
        BP1_FROM_FLOAT(0.003067960372570)        // 0x006487ea 2*sin( pi/2048 ) * nF2BP1 for DCT
#   ifdef ENABLE_LPC
       ,BP2_FROM_FLOAT(0.006135884649154)        // sin( 4*pi/cSB ) * nF2BP2 for LPC
       ,BP2_FROM_FLOAT(0.999981175282601)        // sin( 4*pi/cSB ) * nF2BP2 for LPC
#   endif
                };/***
const SinCosTable g_sct128  = {0x006487c4,0x3fffb10a,0x3fffb109,0xff9b780d,0x00013bd2,0x00c90e90,0xfcdc1341,0x3FEC43C6};
const SinCosTable g_sct256  = {0x003243f1,0x3fffec41,0x3fffec41,0xffcdbbe0,0x00004ef4,0x006487c4,0xfe6deaa0,0x3ffb10c0};
const SinCosTable g_sct512  = {0x001921fa,0x3ffffb0f,0x3ffffb0f,0xffe6ddd7,0x000013bd,0x003243f1,0xff36f170,0x3ffec42c};
const SinCosTable g_sct1024 = {0x000c90fd,0x3ffffec3,0x3ffffec3,0xfff36ed4,0x000004ef,0x001921fa,0xff9b783c,0x3fffb10a};
const SinCosTable g_sct2048 = {0x0006487e,0x3fffffb0,0x3fffffb0,0xfff9b753,0x0000013b,0x000c90fd,0xffcdbc0f,0x3fffec41};
*///


const SinCosTable * const rgSinCosTables[SINCOSTABLE_ENTRIES] = {&g_sct64,&g_sct128,&g_sct256,
    NULL, &g_sct512,NULL, NULL, NULL, &g_sct1024, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, &g_sct2048};

// HighRate and MidRate InverseQuantize require one
// to caluclate 10^( (MaskQ-MaxMaskQ)&2.4*0.5/20 ) = (10^(1/16)) ^ (MaskQ-MaxMaskQ) 
// equals rgMaskPower10[ MaxMaskQ-MaskQ ] * (1<<((MaxMaskQ-MaskQ)/4) / ((float)(1<<28))
// The values for this table are from WMAConcepts.xls!WeightedQuantization
const MaskPowerType rgiMaskMinusPower10[MASK_MINUS_POWER_TABLE_SIZE] = {
    MASK_POWER_FROM_FLOAT(1.000000000000),    // *(2^-0) for [0]
    MASK_POWER_FROM_FLOAT(0.865964323282),    // *(2^-0) for [1]
    MASK_POWER_FROM_FLOAT(0.749894209206),    // *(2^-0) for [2]
    MASK_POWER_FROM_FLOAT(0.649381630123),    // *(2^-0) for [3]
    MASK_POWER_FROM_FLOAT(1.124682649970),    // *(2^-1) for [4]
    MASK_POWER_FROM_FLOAT(0.973935049027),    // *(2^-1) for [5]
    MASK_POWER_FROM_FLOAT(0.843393005431),    // *(2^-1) for [6]
    MASK_POWER_FROM_FLOAT(0.730348251760),    // *(2^-1) for [7]
    MASK_POWER_FROM_FLOAT(1.264911063015),    // *(2^-2) for [8]
    MASK_POWER_FROM_FLOAT(1.095367852598),    // *(2^-2) for [9]
    MASK_POWER_FROM_FLOAT(0.948549479246),    // *(2^-2) for [10]
    MASK_POWER_FROM_FLOAT(0.821410007775),    // *(2^-2) for [11]
    MASK_POWER_FROM_FLOAT(1.422623526305),    // *(2^-3) for [12]
    MASK_POWER_FROM_FLOAT(1.231941219419),    // *(2^-3) for [13]
    MASK_POWER_FROM_FLOAT(1.066817142069),    // *(2^-3) for [14]
    MASK_POWER_FROM_FLOAT(0.923825584352),    // *(2^-3) for [15]
    MASK_POWER_FROM_FLOAT(1.599999997765),    // *(2^-4) for [16]
    MASK_POWER_FROM_FLOAT(1.385542914271),    // *(2^-4) for [17]
    MASK_POWER_FROM_FLOAT(1.199830733240),    // *(2^-4) for [18]
    MASK_POWER_FROM_FLOAT(1.039010610431),    // *(2^-4) for [19]
    MASK_POWER_FROM_FLOAT(1.799492239952),    // *(2^-5) for [20]
    MASK_POWER_FROM_FLOAT(1.558296076953),    // *(2^-5) for [21]
    MASK_POWER_FROM_FLOAT(1.349428810179),    // *(2^-5) for [22]
    MASK_POWER_FROM_FLOAT(1.168557204306),    // *(2^-5) for [23]
    MASK_POWER_FROM_FLOAT(2.023857701570),    // *(2^-6) for [24]
    MASK_POWER_FROM_FLOAT(1.752588562667),    // *(2^-6) for [25]
    MASK_POWER_FROM_FLOAT(1.517679169774),    // *(2^-6) for [26]
    MASK_POWER_FROM_FLOAT(1.314256016165),    // *(2^-6) for [27]
    MASK_POWER_FROM_FLOAT(2.276197642088),    // *(2^-7) for [28]
    MASK_POWER_FROM_FLOAT(1.971105951816),    // *(2^-7) for [29]
    MASK_POWER_FROM_FLOAT(1.706907432526),    // *(2^-7) for [30]
    MASK_POWER_FROM_FLOAT(1.478120937943),    // *(2^-7) for [31]
    MASK_POWER_FROM_FLOAT(2.559999998659),    // *(2^-8) for [32]
    MASK_POWER_FROM_FLOAT(2.216868665069),    // *(2^-8) for [33]
    MASK_POWER_FROM_FLOAT(1.919729173183),    // *(2^-8) for [34]
    MASK_POWER_FROM_FLOAT(1.662416975945),    // *(2^-8) for [35]
    MASK_POWER_FROM_FLOAT(2.879187583923),    // *(2^-9) for [36]
    MASK_POWER_FROM_FLOAT(2.493273727596),    // *(2^-9) for [37]
    MASK_POWER_FROM_FLOAT(2.159086097032),    // *(2^-9) for [38]
    MASK_POWER_FROM_FLOAT(1.869691528380)     // *(2^-9) for [39]
#if defined(SKIMP_ON_ROM)
	);
#else	// so !defined(SKIMP_ON_ROM)
	,
    MASK_POWER_FROM_FLOAT(3.238172322512),    // *(2^-10) for [40]
    MASK_POWER_FROM_FLOAT(2.804141703993),    // *(2^-10) for [41]
    MASK_POWER_FROM_FLOAT(2.428286671638),    // *(2^-10) for [42]
    MASK_POWER_FROM_FLOAT(2.102809626609),    // *(2^-10) for [43]
    MASK_POWER_FROM_FLOAT(3.641916230321),    // *(2^-11) for [44]
    MASK_POWER_FROM_FLOAT(3.153769522905),    // *(2^-11) for [45]
    MASK_POWER_FROM_FLOAT(2.731051892042),    // *(2^-11) for [46]
    MASK_POWER_FROM_FLOAT(2.364993501455),    // *(2^-11) for [47]
    MASK_POWER_FROM_FLOAT(4.095999997109),    // *(2^-12) for [48]
    MASK_POWER_FROM_FLOAT(3.546989865601),    // *(2^-12) for [49]
    MASK_POWER_FROM_FLOAT(3.071566678584),    // *(2^-12) for [50]
    MASK_POWER_FROM_FLOAT(2.659867160022),    // *(2^-12) for [51]
    MASK_POWER_FROM_FLOAT(4.606700133532),    // *(2^-13) for [52]
    MASK_POWER_FROM_FLOAT(3.989237964153),    // *(2^-13) for [53]
    MASK_POWER_FROM_FLOAT(3.454537753016),    // *(2^-13) for [54]
    MASK_POWER_FROM_FLOAT(2.991506449878),    // *(2^-13) for [55]
    MASK_POWER_FROM_FLOAT(5.181075718254),    // *(2^-14) for [56]
    MASK_POWER_FROM_FLOAT(4.486626725644),    // *(2^-14) for [57]
    MASK_POWER_FROM_FLOAT(3.885258678347),    // *(2^-14) for [58]
    MASK_POWER_FROM_FLOAT(3.364495400339),    // *(2^-14) for [59]
    MASK_POWER_FROM_FLOAT(5.827065970749),    // *(2^-15) for [60]
    MASK_POWER_FROM_FLOAT(5.046031240374),    // *(2^-15) for [61]
    MASK_POWER_FROM_FLOAT(4.369683027267),    // *(2^-15) for [62]
    MASK_POWER_FROM_FLOAT(3.783989604563),    // *(2^-15) for [63]
	MASK_POWER_FROM_FLOAT(6.553599998355),    // *(2^-16) for [64]
    MASK_POWER_FROM_FLOAT(5.675183787942),    // *(2^-16) for [65]
    MASK_POWER_FROM_FLOAT(4.914506688714),    // *(2^-16) for [66]
    MASK_POWER_FROM_FLOAT(4.255787458271),    // *(2^-16) for [67]
    MASK_POWER_FROM_FLOAT(7.370720215142),    // *(2^-17) for [68]
    MASK_POWER_FROM_FLOAT(6.382780745625),    // *(2^-17) for [69]
    MASK_POWER_FROM_FLOAT(5.527260407805),    // *(2^-17) for [70]
    MASK_POWER_FROM_FLOAT(4.786410320550)     // *(2^-17) for [71]
	};
#endif	// of both defined(SKIMP_ON_ROM) and !defined(SKIMP_ON_ROM)


const MaskPowerType rgiMaskPlusPower10[MASK_PLUS_POWER_TABLE_SIZE] = {
    MASK_POWER_FROM_FLOAT(1.154781982303),    // *(2^0) for [-1]
    MASK_POWER_FROM_FLOAT(1.333521429449),    // *(2^0) for [-2]
    MASK_POWER_FROM_FLOAT(1.539926525205),    // *(2^0) for [-3]
    MASK_POWER_FROM_FLOAT(0.889139704406),    // *(2^1) for [-4]
    MASK_POWER_FROM_FLOAT(1.026762511581),    // *(2^1) for [-5]
    MASK_POWER_FROM_FLOAT(1.185686852783),    // *(2^1) for [-6]
    MASK_POWER_FROM_FLOAT(1.369209814817),    // *(2^1) for [-7]
    MASK_POWER_FROM_FLOAT(0.790569413453),    // *(2^2) for [-8]
    MASK_POWER_FROM_FLOAT(0.912935316563),    // *(2^2) for [-9]
    MASK_POWER_FROM_FLOAT(1.054241254926),    // *(2^2) for [-10]
    MASK_POWER_FROM_FLOAT(1.217418812215),    // *(2^2) for [-11]
    MASK_POWER_FROM_FLOAT(0.702926654369),    // *(2^3) for [-12]
    MASK_POWER_FROM_FLOAT(0.811727035791),    // *(2^3) for [-13]
    MASK_POWER_FROM_FLOAT(0.937367759645),    // *(2^3) for [-14]
    MASK_POWER_FROM_FLOAT(1.082455404103),    // *(2^3) for [-15]
    MASK_POWER_FROM_FLOAT(0.625000000000),    // *(2^4) for [-16]
    MASK_POWER_FROM_FLOAT(0.721738737077),    // *(2^4) for [-17]
    MASK_POWER_FROM_FLOAT(0.833450894803),    // *(2^4) for [-18]
    MASK_POWER_FROM_FLOAT(0.962454076856),    // *(2^4) for [-19]
    MASK_POWER_FROM_FLOAT(0.555712312460),    // *(2^5) for [-20]
    MASK_POWER_FROM_FLOAT(0.641726568341),    // *(2^5) for [-21]
    MASK_POWER_FROM_FLOAT(0.741054281592),    // *(2^5) for [-22]
    MASK_POWER_FROM_FLOAT(0.855756133795),    // *(2^5) for [-23]
    MASK_POWER_FROM_FLOAT(0.494105882943),    // *(2^6) for [-24]
    MASK_POWER_FROM_FLOAT(0.570584572852),    // *(2^6) for [-25]
    MASK_POWER_FROM_FLOAT(0.658900786191),    // *(2^6) for [-26]
    MASK_POWER_FROM_FLOAT(0.760886754841),    // *(2^6) for [-27]
    MASK_POWER_FROM_FLOAT(0.439329158515),    // *(2^7) for [-28]
    MASK_POWER_FROM_FLOAT(0.507329396904),    // *(2^7) for [-29]
    MASK_POWER_FROM_FLOAT(0.585854850709),    // *(2^7) for [-30]
    MASK_POWER_FROM_FLOAT(0.676534626633),    // *(2^7) for [-31]
    MASK_POWER_FROM_FLOAT(0.390625000000),    // *(2^8) for [-32]
    MASK_POWER_FROM_FLOAT(0.451086711138),    // *(2^8) for [-33]
    MASK_POWER_FROM_FLOAT(0.520906805992),    // *(2^8) for [-34]
    MASK_POWER_FROM_FLOAT(0.601533796638),    // *(2^8) for [-35]
    MASK_POWER_FROM_FLOAT(0.347320195287),    // *(2^9) for [-36]
    MASK_POWER_FROM_FLOAT(0.401079103351),    // *(2^9) for [-37]
    MASK_POWER_FROM_FLOAT(0.463158924133),    // *(2^9) for [-38]
    MASK_POWER_FROM_FLOAT(0.534847583622),    // *(2^9) for [-39]
    MASK_POWER_FROM_FLOAT(0.308816175908),    // *(2^10) for [-40]
    MASK_POWER_FROM_FLOAT(0.356615357101),    // *(2^10) for [-41]
    MASK_POWER_FROM_FLOAT(0.411812990904),    // *(2^10) for [-42]
    MASK_POWER_FROM_FLOAT(0.475554220378),    // *(2^10) for [-43]
    MASK_POWER_FROM_FLOAT(0.274580724537),    // *(2^11) for [-44]
    MASK_POWER_FROM_FLOAT(0.317080873996),    // *(2^11) for [-45]
    MASK_POWER_FROM_FLOAT(0.366159278899),    // *(2^11) for [-46]
    MASK_POWER_FROM_FLOAT(0.422834139317),    // *(2^11) for [-47]
    MASK_POWER_FROM_FLOAT(0.244140625000),    // *(2^12) for [-48]
    MASK_POWER_FROM_FLOAT(0.281929194927),    // *(2^12) for [-49]
    MASK_POWER_FROM_FLOAT(0.325566753745)     // *(2^12) for [-50]  
#if !defined(SKIMP_ON_ROM)
    ,   // length before 7/17/2001 (e.g. v8) was 50
    MASK_POWER_FROM_FLOAT(0.375958621502),    // *(2^12) for [-51]
    MASK_POWER_FROM_FLOAT(0.217075120658),    // *(2^13) for [-52]
    MASK_POWER_FROM_FLOAT(0.250674441457),    // *(2^13) for [-53]
    MASK_POWER_FROM_FLOAT(0.289474327117),    // *(2^13) for [-54]
    MASK_POWER_FROM_FLOAT(0.334279738367),    // *(2^13) for [-55]
    MASK_POWER_FROM_FLOAT(0.193010110408),    // *(2^14) for [-56]
    MASK_POWER_FROM_FLOAT(0.222884599119),    // *(2^14) for [-57]
    MASK_POWER_FROM_FLOAT(0.257383119315),    // *(2^14) for [-58]
    MASK_POWER_FROM_FLOAT(0.297221388668),    // *(2^14) for [-59]
    MASK_POWER_FROM_FLOAT(0.171612951905),    // *(2^15) for [-60]
    MASK_POWER_FROM_FLOAT(0.198175545782),    // *(2^15) for [-61]
    MASK_POWER_FROM_FLOAT(0.228849548846)     // *(2^15) for [-62]
#endif // SKIMP_ON_ROM
};

// lookup table for calculating QuantStepSize to QuantSep
// = 10^( (idx-18)/20 ) * (1<<((idx/8)+4)) for idx = 18..145
// note the range 22 to 138 is as large as was observed in many configurations of Tough and All1
// So one could skimp on its size if you really needed to.
// The values for this tables can be found in WMAConcepts.xls!QuantStep
const DBPowerType rgDBPower10[DBPOWER_TABLE_SIZE] = {
    DBPOWER_FROM_FLOAT(0.124113783240),    // *(2^6) for [18]
    DBPOWER_FROM_FLOAT(0.139257956296),    // *(2^6) for [19]
    DBPOWER_FROM_FLOAT(0.156250000000),    // *(2^6) for [20]
    DBPOWER_FROM_FLOAT(0.175315380096),    // *(2^6) for [21]
    DBPOWER_FROM_FLOAT(0.196707092226),    // *(2^6) for [22]
    DBPOWER_FROM_FLOAT(0.220708988607),    // *(2^6) for [23]
    DBPOWER_FROM_FLOAT(0.123819779605),    // *(2^7) for [24]
    DBPOWER_FROM_FLOAT(0.138928078115),    // *(2^7) for [25]
    DBPOWER_FROM_FLOAT(0.155879866332),    // *(2^7) for [26]
    DBPOWER_FROM_FLOAT(0.174900088459),    // *(2^7) for [27]
    DBPOWER_FROM_FLOAT(0.196241125464),    // *(2^7) for [28]
    DBPOWER_FROM_FLOAT(0.220186166465),    // *(2^7) for [29]
    DBPOWER_FROM_FLOAT(0.247052941471),    // *(2^7) for [30]
    DBPOWER_FROM_FLOAT(0.277197957039),    // *(2^7) for [31]
    DBPOWER_FROM_FLOAT(0.155510611832),    // *(2^8) for [32]
    DBPOWER_FROM_FLOAT(0.174485776573),    // *(2^8) for [33]
    DBPOWER_FROM_FLOAT(0.195776261389),    // *(2^8) for [34]
    DBPOWER_FROM_FLOAT(0.219664577395),    // *(2^8) for [35]
    DBPOWER_FROM_FLOAT(0.246467709541),    // *(2^8) for [36]
    DBPOWER_FROM_FLOAT(0.276541318744),    // *(2^8) for [37]
    DBPOWER_FROM_FLOAT(0.310284465551),    // *(2^8) for [38]
    DBPOWER_FROM_FLOAT(0.348144896328),    // *(2^8) for [39]
    DBPOWER_FROM_FLOAT(0.195312500000),    // *(2^9) for [40]
    DBPOWER_FROM_FLOAT(0.219144228846),    // *(2^9) for [41]
    DBPOWER_FROM_FLOAT(0.245883867145),    // *(2^9) for [42]
    DBPOWER_FROM_FLOAT(0.275886237621),    // *(2^9) for [43]
    DBPOWER_FROM_FLOAT(0.309549450874),    // *(2^9) for [44]
    DBPOWER_FROM_FLOAT(0.347320195287),    // *(2^9) for [45]
    DBPOWER_FROM_FLOAT(0.389699667692),    // *(2^9) for [46]
    DBPOWER_FROM_FLOAT(0.437250219285),    // *(2^9) for [47]
    DBPOWER_FROM_FLOAT(0.245301406831),    // *(2^10) for [48]
    DBPOWER_FROM_FLOAT(0.275232706219),    // *(2^10) for [49]
    DBPOWER_FROM_FLOAT(0.308816175908),    // *(2^10) for [50]
    DBPOWER_FROM_FLOAT(0.346497450024),    // *(2^10) for [51]
    DBPOWER_FROM_FLOAT(0.388776533306),    // *(2^10) for [52]
    DBPOWER_FROM_FLOAT(0.436214443296),    // *(2^10) for [53]
    DBPOWER_FROM_FLOAT(0.489440657198),    // *(2^10) for [54]
    DBPOWER_FROM_FLOAT(0.549161449075),    // *(2^10) for [55]
    DBPOWER_FROM_FLOAT(0.308084640652),    // *(2^11) for [56]
    DBPOWER_FROM_FLOAT(0.345676649362),    // *(2^11) for [57]
    DBPOWER_FROM_FLOAT(0.387855581939),    // *(2^11) for [58]
    DBPOWER_FROM_FLOAT(0.435181118548),    // *(2^11) for [59]
    DBPOWER_FROM_FLOAT(0.488281250000),    // *(2^11) for [60]
    DBPOWER_FROM_FLOAT(0.547860570252),    // *(2^11) for [61]
    DBPOWER_FROM_FLOAT(0.614709671587),    // *(2^11) for [62]
    DBPOWER_FROM_FLOAT(0.689715597779),    // *(2^11) for [63]
    DBPOWER_FROM_FLOAT(0.386936813593),    // *(2^12) for [64]
    DBPOWER_FROM_FLOAT(0.434150245041),    // *(2^12) for [65]
    DBPOWER_FROM_FLOAT(0.487124588341),    // *(2^12) for [66]
    DBPOWER_FROM_FLOAT(0.546562775970),    // *(2^12) for [67]
    DBPOWER_FROM_FLOAT(0.613253522664),    // *(2^12) for [68]
    DBPOWER_FROM_FLOAT(0.688081767410),    // *(2^12) for [69]
    DBPOWER_FROM_FLOAT(0.772040441632),    // *(2^12) for [70]
    DBPOWER_FROM_FLOAT(0.866243623197),    // *(2^12) for [71]
    DBPOWER_FROM_FLOAT(0.485970664769),    // *(2^13) for [72]
    DBPOWER_FROM_FLOAT(0.545268055052),    // *(2^13) for [73]
    DBPOWER_FROM_FLOAT(0.611800819635),    // *(2^13) for [74]
    DBPOWER_FROM_FLOAT(0.686451811343),    // *(2^13) for [75]
    DBPOWER_FROM_FLOAT(0.770211599767),    // *(2^13) for [76]
    DBPOWER_FROM_FLOAT(0.864191628993),    // *(2^13) for [77]
    DBPOWER_FROM_FLOAT(0.969638954848),    // *(2^13) for [78]
    DBPOWER_FROM_FLOAT(1.087952803820),    // *(2^13) for [79]
    DBPOWER_FROM_FLOAT(0.610351562500),    // *(2^14) for [80]
    DBPOWER_FROM_FLOAT(0.684825714678),    // *(2^14) for [81]
    DBPOWER_FROM_FLOAT(0.768387090415),    // *(2^14) for [82]
    DBPOWER_FROM_FLOAT(0.862144496292),    // *(2^14) for [83]
    DBPOWER_FROM_FLOAT(0.967342033982),    // *(2^14) for [84]
    DBPOWER_FROM_FLOAT(1.085375614464),    // *(2^14) for [85]
    DBPOWER_FROM_FLOAT(1.217811468989),    // *(2^14) for [86]
    DBPOWER_FROM_FLOAT(1.366406943649),    // *(2^14) for [87]
    DBPOWER_FROM_FLOAT(0.766566902399),    // *(2^15) for [88]
    DBPOWER_FROM_FLOAT(0.860102210194),    // *(2^15) for [89]
    DBPOWER_FROM_FLOAT(0.965050552040),    // *(2^15) for [90]
    DBPOWER_FROM_FLOAT(1.082804530859),    // *(2^15) for [91]
    DBPOWER_FROM_FLOAT(1.214926667511),    // *(2^15) for [92]
    DBPOWER_FROM_FLOAT(1.363170139492),    // *(2^15) for [93]
    DBPOWER_FROM_FLOAT(1.529502052814),    // *(2^15) for [94]
    DBPOWER_FROM_FLOAT(1.716129530221),    // *(2^15) for [95]
    DBPOWER_FROM_FLOAT(0.962764501572),    // *(2^16) for [96]
    DBPOWER_FROM_FLOAT(1.080239538103),    // *(2^16) for [97]
    DBPOWER_FROM_FLOAT(1.212048694491),    // *(2^16) for [98]
    DBPOWER_FROM_FLOAT(1.359941005707),    // *(2^16) for [99]
    DBPOWER_FROM_FLOAT(1.525878906250),    // *(2^16) for [100]
    DBPOWER_FROM_FLOAT(1.712064288557),    // *(2^16) for [101]
    DBPOWER_FROM_FLOAT(1.920967727900),    // *(2^16) for [102]
    DBPOWER_FROM_FLOAT(2.155361242592),    // *(2^16) for [103]
    DBPOWER_FROM_FLOAT(1.209177542478),    // *(2^17) for [104]
    DBPOWER_FROM_FLOAT(1.356719519943),    // *(2^17) for [105]
    DBPOWER_FROM_FLOAT(1.522264339030),    // *(2^17) for [106]
    DBPOWER_FROM_FLOAT(1.708008680493),    // *(2^17) for [107]
    DBPOWER_FROM_FLOAT(1.916417259723),    // *(2^17) for [108]
    DBPOWER_FROM_FLOAT(2.150255531073),    // *(2^17) for [109]
    DBPOWER_FROM_FLOAT(2.412626385689),    // *(2^17) for [110]
    DBPOWER_FROM_FLOAT(2.707011330873),    // *(2^17) for [111]
    DBPOWER_FROM_FLOAT(1.518658332527),    // *(2^18) for [112]
    DBPOWER_FROM_FLOAT(1.703962676227),    // *(2^18) for [113]
    DBPOWER_FROM_FLOAT(1.911877568811),    // *(2^18) for [114]
    DBPOWER_FROM_FLOAT(2.145161911845),    // *(2^18) for [115]
    DBPOWER_FROM_FLOAT(2.406911253929),    // *(2^18) for [116]
    DBPOWER_FROM_FLOAT(2.700598847121),    // *(2^18) for [117]
    DBPOWER_FROM_FLOAT(3.030121743679),    // *(2^18) for [118]
    DBPOWER_FROM_FLOAT(3.399852514267),    // *(2^18) for [119]
    DBPOWER_FROM_FLOAT(1.907348632813),    // *(2^19) for [120]
    DBPOWER_FROM_FLOAT(2.140080362558),    // *(2^19) for [121]
    DBPOWER_FROM_FLOAT(2.401209659874),    // *(2^19) for [122]
    DBPOWER_FROM_FLOAT(2.694201551378),    // *(2^19) for [123]
    DBPOWER_FROM_FLOAT(3.022943861783),    // *(2^19) for [124]
    DBPOWER_FROM_FLOAT(3.391798797995),    // *(2^19) for [125]
    DBPOWER_FROM_FLOAT(3.805660847574),    // *(2^19) for [126]
    DBPOWER_FROM_FLOAT(4.270021699369),    // *(2^19) for [127]
    DBPOWER_FROM_FLOAT(2.395521573722),    // *(2^20) for [128]
    DBPOWER_FROM_FLOAT(2.687819413841),    // *(2^20) for [129]
    DBPOWER_FROM_FLOAT(3.015782985836),    // *(2^20) for [130]
    DBPOWER_FROM_FLOAT(3.383764162660),    // *(2^20) for [131]
    DBPOWER_FROM_FLOAT(3.796645835042),    // *(2^20) for [132]
    DBPOWER_FROM_FLOAT(4.259906690568),    // *(2^20) for [133]
    DBPOWER_FROM_FLOAT(4.779693923891),    // *(2^20) for [134]
    DBPOWER_FROM_FLOAT(5.362904787064),    // *(2^20) for [135]
    DBPOWER_FROM_FLOAT(3.008639067411),    // *(2^21) for [136]
    DBPOWER_FROM_FLOAT(3.375748559833),    // *(2^21) for [137]
    DBPOWER_FROM_FLOAT(3.787652179599),    // *(2^21) for [138]
    DBPOWER_FROM_FLOAT(4.249815642834),    // *(2^21) for [139]
    DBPOWER_FROM_FLOAT(4.768371582031),    // *(2^21) for [140]
    DBPOWER_FROM_FLOAT(5.350200910121),    // *(2^21) for [141]
    DBPOWER_FROM_FLOAT(6.003024157137),    // *(2^21) for [142]
    DBPOWER_FROM_FLOAT(6.735503885895),    // *(2^21) for [143]
    DBPOWER_FROM_FLOAT(3.778679829091),    // *(2^22) for [144]
    DBPOWER_FROM_FLOAT(4.239748500288)     // *(2^22) for [145]
};

#if defined(REFERENCE_RAND_16)
	// constants used by 16-bit quickRand
	const unsigned int g_uWMALCA[LCA_SET] = {1637,1033,1825,1621, 1657,1861,1229,1549, 2017,941,1409,1777, 1153};
	const unsigned int g_uWMALCC[LCC_SET] = {13849,13841,13859};
#endif

#ifdef BUILD_INT_FLOAT
// Lookup factor (float)pow(2,4+(iQSS>>3)) associated with the above table
// index with [iQSS>>3]
const Float rgfltDBPowerExponentScale[((DBPOWER_TABLE_OFFSET+DBPOWER_TABLE_SIZE)>>3)+1] = {
	   16.0f,     32.0f,     64.0f,    128.0f,     256.0f,     512.0f,  
	 1024.0f,   2048.0f,   4096.0f,   8192.0f,   16384.0f,   32768.0f,
	65536.0f, 131072.0f, 262144.0f, 524288.0f, 1048576.0f, 2097152.0f, 4194304.0f
 };
#endif

const U16 g_rgiBarkFreq	[] = 
                                    {  100,    200,    300,    400,    510, 
                                       630,    770,    920,   1080,   1270,
                                      1480,   1720,   2000,   2320,   2700,
                                      3150,   3700,   4400,   5300,   6400,
                                      7700,   9500,  12000,  15500,  24500 };

// pow (10, iCurrMaskQ*MASK_QUANT/20*m_fltFlatenFactor) * (1 << 10) for 10 fract bits
// MASK_QUANT = 2.5, m_fltFlatenFactor = 0.5
const U32 g_rgfiPwrToRMS[] =
{
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 4, 5, 6, 7,
    8, 9, 10, 12, 14, 16, 18, 21, 24, 28, 32, 37, 43, 50, 58, 66, 77, 89, 102, 118,
    137, 158, 182, 210, 243, 280, 324, 374, 432, 499, 576, 665, 768, 887, 1024,
    1182, 1366, 1577, 1821, 2103, 2428, 2804, 3238, 3739, 4318, 4987, 5758, 6650,
    7679, 8867, 10240, 11825, 13655, 15769, 18210, 21028, 24283, 28041, 32382, 37394,
    43182, 49865, 57584, 66497, 76789, 88675, 102400, 118250, 136553, 157688, 182096,
    210281, 242829, 280414, 323817, 373938, 431817, 498655, 575838, 664967, 767892,
    886747, 1024000, 1182497, 1365526, 1576885, 1820958, 2102810, 2428287, 2804142,
    3238172, 3739383, 4318172, 4986547, 5758375
};




const U16 gRun16smOb[] =	{
    0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19, 
   20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39, 
   40,    41,    42,    43,    44,    45,    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59, 
   60,    61,    62,    63,    64,    65,    66,    67,    68,    69,    70,    71,    72,    73,    74,    75,    76,    77,    78,    79, 
   80,    81,    82,    83,    84,    85,    86,    87,    88,    89,    90,    91,    92,    93,    94,    95,    96,    97,    98,    99, 
  100,   101,   102,   103,   104,   105,   106,   107,   108,   109,   110,   111,   112,     0,     1,     2,     3,     4,     5,     6, 
    7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26, 
   27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,    46, 
   47,    48,    49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59,    60,    61,    62,    63,    64,    65,    66, 
   67,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18, 
   19,    20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38, 
   39,    40,    41,    42,    43,    44,    45,    46,    47,    48,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9, 
   10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28,    29, 
   30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,     0,     1,     2,     3,     4,     5,     6,     7, 
    8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27, 
   28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,     0,     1,     2,     3,     4,     5,     6,     7, 
    8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27, 
   28,    29,    30,    31,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15, 
   16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,     0,     1,     2,     3,     4,     5,     6,     7,     8, 
    9,    10,    11,    12,    13,    14,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,     0,     1,     2,     3, 
    4,     0,     1,     2,     0,     1,     2,     0,     1,     2,     0,     1,     2,     0,     1,     0,     1,     0,     1,     0, 
    1,     0,     1,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0};

const U16 gLevel16smOb[] =	{
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4, 
    4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4, 
    4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     5,     5,     5,     5,     5,     5,     5,     5, 
    5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5, 
    5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     6,     6,     6,     6,     6,     6,     6,     6, 
    6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6, 
    6,     6,     6,     6,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7, 
    7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     8,     8,     8,     8,     8,     8,     8,     8,     8, 
    8,     8,     8,     8,     8,     8,     9,     9,     9,     9,     9,     9,     9,     9,     9,     9,    10,    10,    10,    10, 
   10,    11,    11,    11,    12,    12,    12,    13,    13,    13,    14,    14,    14,    15,    15,    16,    16,    17,    17,    18, 
   18,    19,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,    36, 
   37,    38,    39,    40,    41,    42,    43,    44,    45,    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,    56, 
   57,    58,    59,    60,    61,    62,    63,    64,    65,    66,    67,    68,    69,    70};


const U16 gRun16ssOb[] =	{
    0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19, 
   20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39, 
   40,    41,    42,    43,    44,    45,    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59, 
   60,    61,    62,    63,    64,    65,    66,    67,    68,    69,    70,    71,    72,    73,    74,    75,    76,    77,    78,    79, 
   80,    81,    82,    83,    84,    85,    86,    87,    88,    89,    90,    91,    92,    93,    94,    95,    96,    97,    98,    99, 
  100,   101,   102,   103,   104,   105,   106,   107,   108,   109,   110,   111,   112,   113,   114,   115,   116,   117,   118,   119, 
  120,   121,   122,   123,   124,   125,   126,   127,   128,   129,   130,   131,   132,   133,   134,   135,   136,   137,   138,   139, 
  140,   141,   142,   143,   144,   145,   146,   147,   148,   149,   150,   151,   152,   153,   154,   155,   156,   157,   158,   159, 
  160,   161,   162,   163,   164,   165,   166,   167,   168,   169,   170,   171,   172,   173,   174,   175,   176,   177,   178,   179, 
  180,   181,   182,   183,   184,   185,   186,   187,   188,   189,   190,   191,   192,   193,   194,   195,   196,   197,   198,   199, 
  200,   201,   202,   203,   204,   205,   206,   207,   208,   209,   210,   211,   212,   213,     0,     1,     2,     3,     4,     5, 
    6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25, 
   26,    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,    42,    43,    44,    45, 
   46,    47,    48,    49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59,    60,    61,    62,    63,    64,    65, 
   66,    67,    68,    69,    70,    71,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,    12,    13, 
   14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30,    31,    32,    33, 
   34,    35,    36,    37,    38,    39,    40,    41,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11, 
   12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30,    31, 
   32,    33,    34,    35,    36,    37,    38,    39,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11, 
   12,    13,    14,    15,    16,    17,     0,     1,     2,     3,     0,     1,     2,     3,     0,     1,     0,     1,     0,     1, 
    0,     1,     0,     1,     0,     0,     0,     1,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0};

const U16 gLevel16ssOb[] =	{
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4, 
    4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4, 
    4,     4,     4,     4,     4,     4,     4,     4,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5, 
    5,     5,     5,     5,     5,     5,     6,     6,     6,     6,     7,     7,     7,     7,     8,     8,     9,     9,    10,    10, 
   11,    11,    12,    12,    13,    14,    15,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27, 
   28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40};

#ifdef ENABLE_ALL_ENCOPT

const U16 gRun44smOb[] =	{
    0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19, 
   20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39, 
   40,    41,    42,    43,    44,    45,    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59, 
   60,    61,    62,    63,    64,    65,    66,    67,    68,    69,    70,    71,    72,    73,    74,    75,    76,    77,    78,    79, 
   80,    81,    82,    83,    84,    85,    86,    87,    88,    89,    90,    91,    92,    93,    94,    95,    96,    97,    98,    99, 
  100,   101,   102,   103,   104,   105,   106,   107,   108,   109,   110,   111,   112,   113,   114,   115,   116,   117,   118,   119, 
  120,   121,   122,   123,   124,   125,   126,   127,   128,   129,   130,   131,   132,   133,   134,   135,   136,   137,   138,   139, 
  140,   141,   142,   143,   144,   145,   146,   147,   148,   149,   150,   151,   152,   153,   154,   155,   156,   157,   158,   159, 
  160,   161,   162,   163,   164,   165,   166,   167,   168,   169,   170,   171,   172,   173,   174,   175,   176,   177,   178,   179, 
  180,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18, 
   19,    20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38, 
   39,    40,    41,    42,    43,    44,    45,    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,    56,    57,    58, 
   59,    60,    61,    62,    63,    64,    65,    66,    67,    68,    69,    70,    71,    72,    73,    74,    75,    76,    77,    78, 
   79,    80,    81,    82,    83,    84,    85,    86,    87,    88,    89,    90,    91,    92,    93,    94,    95,    96,    97,    98, 
   99,   100,   101,   102,   103,   104,   105,   106,   107,   108,   109,     0,     1,     2,     3,     4,     5,     6,     7,     8, 
    9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28, 
   29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,    46,    47,    48, 
   49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59,    60,    61,    62,    63,    64,    65,    66,    67,    68, 
   69,    70,    71,    72,    73,    74,    75,    76,    77,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10, 
   11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30, 
   31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,    46,    47,    48,    49,    50, 
   51,    52,    53,    54,    55,    56,    57,    58,    59,    60,    61,    62,     0,     1,     2,     3,     4,     5,     6,     7, 
    8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27, 
   28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,    46,    47, 
   48,    49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59,    60,     0,     1,     2,     3,     4,     5,     6, 
    7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26, 
   27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,    46, 
   47,    48,    49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59,    60,    61,     0,     1,     2,     3,     4, 
    5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24, 
   25,    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,    42,    43,    44, 
   45,    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59,     0,     1,     2,     3,     4, 
    5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24, 
   25,    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,    42,    43,    44, 
   45,    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59,    60,     0,     1,     2,     3, 
    4,     5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23, 
   24,    25,    26,    27,    28,    29,    30,    31,    32,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10, 
   11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30, 
   31,    32,    33,    34,    35,    36,    37,    38,    39,    40,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9, 
   10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28,    29, 
   30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,     0,     1,     2,     3,     4,     5,     6,     7,     8, 
    9,    10,    11,    12,    13,    14,    15,    16,    17,    18,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9, 
   10,    11,    12,    13,    14,    15,    16,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,    12, 
   13,    14,    15,    16,    17,    18,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,     0,     1, 
    2,     3,     4,     5,     6,     7,     8,     9,    10,     0,     1,     2,     3,     4,     5,     6,     7,     8,     0,     1, 
    2,     3,     4,     5,     6,     7,     8,     9,    10,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,     0, 
    1,     2,     3,     4,     5,     0,     1,     2,     3,     4,     5,     6,     7,     0,     1,     2,     3,     4,     5,     6, 
    0,     1,     2,     3,     4,     5,     0,     1,     2,     3,     0,     1,     2,     3,     4,     0,     1,     2,     3,     4, 
    0,     1,     2,     3,     0,     1,     2,     3,     0,     1,     2,     0,     1,     2,     3,     0,     1,     2,     0,     1, 
    2,     3,     4,     0,     1,     2,     0,     1,     2,     3,     0,     1,     2,     0,     1,     2,     0,     1,     2,     0, 
    1,     2,     0,     1,     2,     0,     1,     2,     0,     1,     0,     1,     0,     1,     2,     3,     0,     1,     0,     1, 
    2,     0,     1,     0,     1,     2,     0,     1,     2,     0,     1,     0,     1,     0,     1,     0,     1,     0,     1,     0, 
    1,     0,     1,     0,     1,     0,     1,     2,     0,     1,     0,     1,     0,     1,     0,     1,     0,     1,     0,     1, 
    0,     1,     0,     1,     0,     1,     0,     1,     0,     0,     1,     0,     0,     1,     0,     1,     0,     1,     0,     1, 
    0,     0,     1,     0,     0,     0,     0,     1,     0,     1,     0,     0,     1,     0,     0,     1,     0,     1,     0,     1, 
    0,     1,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0};

const U16 gLevel44smOb[] =	{
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4, 
    4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4, 
    4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4, 
    4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     5,     5,     5,     5,     5,     5,     5,     5, 
    5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5, 
    5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5, 
    5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     6,     6,     6,     6,     6,     6,     6, 
    6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6, 
    6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6, 
    6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     7,     7,     7,     7,     7, 
    7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7, 
    7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7, 
    7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     8,     8,     8,     8,     8, 
    8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8, 
    8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8, 
    8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     9,     9,     9,     9, 
    9,     9,     9,     9,     9,     9,     9,     9,     9,     9,     9,     9,     9,     9,     9,     9,     9,     9,     9,     9, 
    9,     9,     9,     9,     9,     9,     9,     9,     9,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10, 
   10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10, 
   10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    11,    11,    11,    11,    11,    11,    11,    11,    11,    11, 
   11,    11,    11,    11,    11,    11,    11,    11,    11,    11,    11,    11,    11,    11,    11,    11,    11,    11,    11,    11, 
   11,    11,    11,    11,    11,    11,    11,    11,    11,    11,    11,    12,    12,    12,    12,    12,    12,    12,    12,    12, 
   12,    12,    12,    12,    12,    12,    12,    12,    12,    12,    13,    13,    13,    13,    13,    13,    13,    13,    13,    13, 
   13,    13,    13,    13,    13,    13,    13,    14,    14,    14,    14,    14,    14,    14,    14,    14,    14,    14,    14,    14, 
   14,    14,    14,    14,    14,    14,    15,    15,    15,    15,    15,    15,    15,    15,    15,    15,    15,    15,    16,    16, 
   16,    16,    16,    16,    16,    16,    16,    16,    16,    17,    17,    17,    17,    17,    17,    17,    17,    17,    18,    18, 
   18,    18,    18,    18,    18,    18,    18,    18,    18,    19,    19,    19,    19,    19,    19,    19,    19,    19,    19,    20, 
   20,    20,    20,    20,    20,    21,    21,    21,    21,    21,    21,    21,    21,    22,    22,    22,    22,    22,    22,    22, 
   23,    23,    23,    23,    23,    23,    24,    24,    24,    24,    25,    25,    25,    25,    25,    26,    26,    26,    26,    26, 
   27,    27,    27,    27,    28,    28,    28,    28,    29,    29,    29,    30,    30,    30,    30,    31,    31,    31,    32,    32, 
   32,    32,    32,    33,    33,    33,    34,    34,    34,    34,    35,    35,    35,    36,    36,    36,    37,    37,    37,    38, 
   38,    38,    39,    39,    39,    40,    40,    40,    41,    41,    42,    42,    43,    43,    43,    43,    44,    44,    45,    45, 
   45,    46,    46,    47,    47,    47,    48,    48,    48,    49,    49,    50,    50,    51,    51,    52,    52,    53,    53,    54, 
   54,    55,    55,    56,    56,    57,    57,    57,    58,    58,    59,    59,    60,    60,    61,    61,    62,    62,    63,    63, 
   64,    64,    65,    65,    66,    66,    67,    67,    68,    69,    69,    70,    71,    71,    72,    72,    73,    73,    74,    74, 
   75,    76,    76,    77,    78,    79,    80,    80,    81,    81,    82,    83,    83,    84,    85,    85,    86,    86,    87,    87, 
   88,    88,    89,    90,    91,    92,    93,    94,    95,    96,    97,    98,    99,   100,   101,   102,   103,   104,   105,   106, 
  107,   108,   109,   110,   111,   112,   113,   114,   115,   116,   117,   118,   119,   120,   121,   122,   123,   124,   125,   126, 
  127,   128,   129,   130,   131,   132,   133,   134,   135,   136,   137,   138,   139,   140,   141,   142,   143,   144,   145,   146, 
  147,   148,   149,   150,   151,   152,   153,   154,   155,   156,   157,   158,   159,   160,   161,   162,   163,   164,   165,   166, 
  167,   168,   169,   170,   171,   172,   173,   174,   175,   176,   177,   178,   179,   180,   181,   182,   183,   184,   185,   186, 
  187,   188,   189,   190,   191,   192,   193,   194,   195,   196,   197,   198,   199,   200,   201,   202,   203,   204,   205,   206, 
  207,   208,   209,   210,   211,   212,   213,   214,   215,   216,   217,   218,   219,   220,   221,   222,   223,   224,   225,   226, 
  227,   228,   229,   230,   231,   232,   233,   234,   235,   236,   237,   238,   239,   240,   241,   242,   243,   244,   245,   246, 
  247,   248,   249,   250,   251,   252,   253,   254,   255,   256,   257,   258,   259,   260,   261,   262,   263,   264,   265,   266, 
  267,   268,   269,   270,   271,   272,   273,   274,   275,   276,   277,   278,   279,   280,   281,   282,   283,   284,   285,   286, 
  287,   288,   289,   290,   291,   292,   293,   294,   295,   296,   297,   298,   299,   300,   301,   302,   303,   304,   305,   306, 
  307,   308,   309,   310,   311,   312,   313,   314,   315,   316,   317,   318,   319,   320,   321,   322,   323,   324,   325,   326, 
  327,   328,   329,   330,   331,   332,   333,   334,   335,   336,   337,   338,   339};


const U16 gRun44ssOb[] =	{
    0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19, 
   20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39, 
   40,    41,    42,    43,    44,    45,    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59, 
   60,    61,    62,    63,    64,    65,    66,    67,    68,    69,    70,    71,    72,    73,    74,    75,    76,    77,    78,    79, 
   80,    81,    82,    83,    84,    85,    86,    87,    88,    89,    90,    91,    92,    93,    94,    95,    96,    97,    98,    99, 
  100,   101,   102,   103,   104,   105,   106,   107,   108,   109,   110,   111,   112,   113,   114,   115,   116,   117,   118,   119, 
  120,   121,   122,   123,   124,   125,   126,   127,   128,   129,   130,   131,   132,   133,   134,   135,   136,   137,   138,   139, 
  140,   141,   142,   143,   144,   145,   146,   147,   148,   149,   150,   151,   152,   153,   154,   155,   156,   157,   158,   159, 
  160,   161,   162,   163,   164,   165,   166,   167,   168,   169,   170,   171,   172,   173,   174,   175,   176,   177,   178,   179, 
  180,   181,   182,   183,   184,   185,   186,   187,   188,   189,   190,   191,   192,   193,   194,   195,   196,   197,   198,   199, 
  200,   201,   202,   203,   204,   205,   206,   207,   208,   209,   210,   211,   212,   213,   214,   215,   216,   217,   218,   219, 
  220,   221,   222,   223,   224,   225,   226,   227,   228,   229,   230,   231,   232,   233,   234,   235,   236,   237,   238,   239, 
  240,   241,   242,   243,   244,   245,   246,   247,   248,   249,   250,   251,   252,   253,   254,   255,   256,   257,   258,   259, 
  260,   261,   262,   263,   264,   265,   266,   267,   268,   269,   270,   271,   272,   273,   274,   275,   276,   277,   278,   279, 
  280,   281,   282,   283,   284,   285,   286,   287,   288,   289,   290,   291,   292,   293,   294,   295,   296,   297,   298,   299, 
  300,   301,   302,   303,   304,   305,   306,   307,   308,   309,   310,   311,   312,   313,   314,   315,   316,   317,   318,   319, 
  320,   321,   322,   323,   324,   325,   326,   327,   328,   329,   330,   331,   332,   333,   334,   335,   336,   337,   338,   339, 
  340,   341,   342,   343,   344,   345,   346,   347,   348,   349,   350,     0,     1,     2,     3,     4,     5,     6,     7,     8, 
    9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28, 
   29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,    46,    47,    48, 
   49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59,    60,    61,    62,    63,    64,    65,    66,    67,    68, 
   69,    70,    71,    72,    73,    74,    75,    76,    77,    78,    79,    80,    81,    82,    83,    84,    85,    86,    87,    88, 
   89,    90,    91,    92,    93,    94,    95,    96,    97,    98,    99,   100,   101,   102,   103,   104,   105,   106,   107,   108, 
  109,   110,   111,   112,   113,   114,   115,   116,   117,   118,   119,   120,   121,     0,     1,     2,     3,     4,     5,     6, 
    7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26, 
   27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,    46, 
   47,    48,    49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59,    60,    61,    62,    63,    64,    65,    66, 
   67,    68,    69,    70,    71,    72,    73,    74,    75,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10, 
   11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30, 
   31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,    46,    47,    48,    49,    50, 
   51,    52,    53,    54,    55,    56,    57,    58,    59,    60,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9, 
   10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28,    29, 
   30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,     0,     1,     2,     3,     4,     5,     6,     7,     8, 
    9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28, 
   29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,     0,     1,     2,     3,     4,     5,     6, 
    7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,     0,     1,     2, 
    3,     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22, 
   23,    24,    25,    26,    27,    28,    29,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,    12, 
   13,    14,    15,    16,    17,    18,    19,    20,    21,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10, 
   11,    12,    13,    14,    15,    16,    17,    18,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,     0, 
    1,     2,     3,     4,     5,     6,     7,     8,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,     0,     1, 
    2,     3,     4,     5,     6,     7,     0,     1,     2,     3,     4,     0,     1,     2,     3,     4,     0,     1,     2,     3, 
    0,     1,     2,     3,     4,     0,     1,     2,     3,     4,     0,     1,     2,     0,     1,     2,     0,     1,     2,     0, 
    1,     2,     0,     1,     2,     0,     1,     2,     0,     1,     2,     0,     1,     0,     1,     0,     1,     2,     0,     1, 
    0,     1,     0,     1,     0,     1,     2,     0,     1,     2,     0,     1,     0,     1,     0,     1,     0,     1,     2,     0, 
    1,     0,     1,     0,     1,     0,     1,     0,     1,     0,     1,     0,     1,     0,     1,     0,     1,     0,     1,     0, 
    1,     0,     1,     0,     1,     0,     1,     0,     1,     0,     1,     0,     0,     0,     1,     0,     1,     0,     0,     1, 
    0,     0,     1,     0,     1,     0,     1,     0,     1,     0,     1,     0,     1,     0,     0,     1,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     1,     0,     1,     0,     0,     1,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0};

const U16 gLevel44ssOb[] =	{
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4, 
    4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4, 
    4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4, 
    4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5, 
    5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5, 
    5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     6,     6,     6,     6,     6,     6,     6,     6,     6, 
    6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6, 
    6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     7,     7,     7,     7,     7,     7,     7, 
    7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     8,     8,     8, 
    8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8, 
    8,     8,     8,     8,     8,     8,     8,     9,     9,     9,     9,     9,     9,     9,     9,     9,     9,     9,     9,     9, 
    9,     9,     9,     9,     9,     9,     9,     9,     9,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10, 
   10,    10,    10,    10,    10,    10,    10,    10,    11,    11,    11,    11,    11,    11,    11,    11,    11,    11,    11,    12, 
   12,    12,    12,    12,    12,    12,    12,    12,    13,    13,    13,    13,    13,    13,    13,    13,    13,    13,    14,    14, 
   14,    14,    14,    14,    14,    14,    15,    15,    15,    15,    15,    16,    16,    16,    16,    16,    17,    17,    17,    17, 
   18,    18,    18,    18,    18,    19,    19,    19,    19,    19,    20,    20,    20,    21,    21,    21,    22,    22,    22,    23, 
   23,    23,    24,    24,    24,    25,    25,    25,    26,    26,    26,    27,    27,    28,    28,    29,    29,    29,    30,    30, 
   31,    31,    32,    32,    33,    33,    33,    34,    34,    34,    35,    35,    36,    36,    37,    37,    38,    38,    38,    39, 
   39,    40,    40,    41,    41,    42,    42,    43,    43,    44,    44,    45,    45,    46,    46,    47,    47,    48,    48,    49, 
   49,    50,    50,    51,    51,    52,    52,    53,    53,    54,    54,    55,    56,    57,    57,    58,    58,    59,    60,    60, 
   61,    62,    62,    63,    63,    64,    64,    65,    65,    66,    66,    67,    67,    68,    69,    69,    70,    71,    72,    73, 
   74,    75,    76,    77,    78,    79,    80,    80,    81,    81,    82,    83,    83,    84,    85,    86,    87,    88,    89,    90, 
   91,    92,    93,    94,    95,    96,    97,    98,    99,   100,   101,   102,   103,   104,   105,   106,   107,   108,   109,   110, 
  111,   112,   113,   114,   115,   116,   117,   118,   119,   120,   121,   122,   123,   124,   125,   126,   127,   128,   129,   130, 
  131,   132,   133,   134,   135,   136,   137,   138,   139,   140,   141,   142,   143,   144,   145,   146,   147,   148,   149,   150, 
  151,   152,   153,   154,   155,   156,   157,   158,   159,   160,   161,   162,   163,   164,   165,   166,   167,   168,   169,   170, 
  171,   172,   173,   174,   175,   176,   177,   178,   179};


const U16 gRun44smQb[] =	{
    0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19, 
   20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39, 
   40,    41,    42,    43,    44,    45,    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59, 
   60,    61,    62,    63,    64,    65,    66,    67,    68,    69,    70,    71,    72,    73,    74,    75,    76,    77,    78,    79, 
   80,    81,    82,    83,    84,    85,    86,    87,    88,    89,    90,    91,    92,    93,    94,    95,    96,    97,    98,    99, 
  100,   101,   102,   103,   104,   105,   106,   107,   108,   109,   110,   111,   112,   113,   114,   115,   116,   117,   118,   119, 
  120,   121,   122,   123,   124,   125,   126,   127,   128,   129,   130,   131,   132,   133,   134,   135,   136,   137,   138,   139, 
  140,   141,   142,   143,   144,   145,   146,   147,   148,   149,   150,   151,   152,   153,   154,   155,   156,   157,   158,   159, 
  160,   161,   162,   163,   164,   165,   166,   167,   168,   169,   170,   171,   172,   173,   174,   175,   176,   177,   178,   179, 
  180,   181,   182,   183,   184,   185,   186,   187,   188,   189,   190,   191,   192,   193,   194,   195,   196,   197,   198,   199, 
  200,   201,   202,   203,   204,   205,   206,   207,   208,   209,   210,   211,   212,   213,   214,   215,   216,   217,   218,   219, 
  220,   221,   222,   223,   224,   225,   226,   227,   228,   229,   230,   231,   232,   233,   234,   235,   236,   237,   238,   239, 
  240,   241,   242,   243,   244,   245,   246,   247,   248,   249,   250,   251,   252,   253,   254,   255,   256,   257,   258,   259, 
  260,   261,   262,   263,   264,   265,   266,   267,   268,   269,   270,   271,   272,   273,   274,   275,   276,   277,   278,   279, 
  280,   281,   282,   283,   284,   285,   286,   287,   288,   289,   290,   291,   292,   293,   294,   295,   296,   297,   298,   299, 
  300,   301,   302,   303,   304,   305,   306,   307,   308,   309,   310,   311,   312,   313,   314,   315,   316,     0,     1,     2, 
    3,     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22, 
   23,    24,    25,    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,    42, 
   43,    44,    45,    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59,    60,    61,    62, 
   63,    64,    65,    66,    67,    68,    69,    70,    71,    72,    73,    74,    75,    76,    77,    78,    79,    80,    81,    82, 
   83,    84,    85,    86,    87,    88,    89,    90,    91,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10, 
   11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30, 
   31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,    46,    47,    48,    49,    50, 
   51,    52,    53,    54,    55,    56,    57,    58,    59,    60,    61,     0,     1,     2,     3,     4,     5,     6,     7,     8, 
    9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28, 
   29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,    46,    47,    48, 
   49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59,     0,     1,     2,     3,     4,     5,     6,     7,     8, 
    9,    10,    11,    12,    13,    14,    15,    16,    17,    18,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9, 
   10,    11,    12,    13,    14,    15,    16,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,     0,     1,     2, 
    3,     4,     5,     6,     0,     1,     2,     3,     4,     5,     0,     1,     2,     3,     4,     0,     1,     2,     3,     4, 
    0,     1,     2,     0,     1,     2,     0,     1,     2,     0,     1,     0,     1,     0,     1,     0,     1,     0,     1,     0, 
    1,     0,     1,     0,     0,     1,     0,     1,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0};

const U16 gLevel44smQb[] =	{
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     4,     4,     4,     4,     4,     4,     4,     4,     4, 
    4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4, 
    4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4, 
    4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     5,     5,     5,     5,     5,     5,     5,     5,     5, 
    5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6, 
    6,     6,     6,     6,     6,     6,     6,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     8,     8,     8, 
    8,     8,     8,     8,     9,     9,     9,     9,     9,     9,    10,    10,    10,    10,    10,    11,    11,    11,    11,    11, 
   12,    12,    12,    13,    13,    13,    14,    14,    14,    15,    15,    16,    16,    17,    17,    18,    18,    19,    19,    20, 
   20,    21,    21,    22,    23,    23,    24,    24,    25,    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,    36, 
   37,    38,    39,    40,    41,    42,    43,    44,    45,    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,    56, 
   57,    58,    59,    60};


const U16 gRun44ssQb[] =	{
    0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19, 
   20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39, 
   40,    41,    42,    43,    44,    45,    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59, 
   60,    61,    62,    63,    64,    65,    66,    67,    68,    69,    70,    71,    72,    73,    74,    75,    76,    77,    78,    79, 
   80,    81,    82,    83,    84,    85,    86,    87,    88,    89,    90,    91,    92,    93,    94,    95,    96,    97,    98,    99, 
  100,   101,   102,   103,   104,   105,   106,   107,   108,   109,   110,   111,   112,   113,   114,   115,   116,   117,   118,   119, 
  120,   121,   122,   123,   124,   125,   126,   127,   128,   129,   130,   131,   132,   133,   134,   135,   136,   137,   138,   139, 
  140,   141,   142,   143,   144,   145,   146,   147,   148,   149,   150,   151,   152,   153,   154,   155,   156,   157,   158,   159, 
  160,   161,   162,   163,   164,   165,   166,   167,   168,   169,   170,   171,   172,   173,   174,   175,   176,   177,   178,   179, 
  180,   181,   182,   183,   184,   185,   186,   187,   188,   189,   190,   191,   192,   193,   194,   195,   196,   197,   198,   199, 
  200,   201,   202,   203,   204,   205,   206,   207,   208,   209,   210,   211,   212,   213,   214,   215,   216,   217,   218,   219, 
  220,   221,   222,   223,   224,   225,   226,   227,   228,   229,   230,   231,   232,   233,   234,   235,   236,   237,   238,   239, 
  240,   241,   242,   243,   244,   245,   246,   247,   248,   249,   250,   251,   252,   253,   254,   255,   256,   257,   258,   259, 
  260,   261,   262,   263,   264,   265,   266,   267,   268,   269,   270,   271,   272,   273,   274,   275,   276,   277,   278,   279, 
  280,   281,   282,   283,   284,   285,   286,   287,   288,   289,   290,   291,   292,   293,   294,   295,   296,   297,   298,   299, 
  300,   301,   302,   303,   304,   305,   306,   307,   308,   309,   310,     0,     1,     2,     3,     4,     5,     6,     7,     8, 
    9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28, 
   29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,    46,    47,    48, 
   49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59,    60,    61,    62,    63,    64,    65,    66,    67,    68, 
   69,    70,    71,    72,    73,    74,    75,    76,    77,    78,    79,    80,    81,    82,    83,    84,    85,    86,    87,    88, 
   89,    90,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17, 
   18,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37, 
   38,    39,    40,    41,    42,    43,    44,    45,    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,    56,    57, 
   58,    59,    60,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16, 
   17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,     0,     1,     2,     3,     4,     5,     6,     7,     8, 
    9,     0,     1,     2,     3,     4,     5,     0,     1,     2,     3,     4,     0,     1,     0,     1,     0,     1,     0,     1, 
    0,     1,     0,     1,     0,     1,     0,     1,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0};

const U16 gLevel44ssQb[] =	{
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4, 
    4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     5,     5,     5,     5,     5,     5,     5,     5,     5, 
    5,     6,     6,     6,     6,     6,     6,     7,     7,     7,     7,     7,     8,     8,     9,     9,    10,    10,    11,    11, 
   12,    12,    13,    13,    14,    14,    15,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27, 
   28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40};


const float g_rgfltLsfReconLevel [LPCORDER] [16] = {
	{1.7925000e-002F,2.2837500e-002F,2.6762500e-002F,3.0825000e-002F,3.5525000e-002F,4.1200000e-002F,4.8675000e-002F,5.9487500e-002F},
	{2.6375000e-002F,3.1550000e-002F,3.5725000e-002F,3.9712500e-002F,4.3675000e-002F,4.7900000e-002F,5.2462500e-002F,5.7362500e-002F,6.2937500e-002F,6.9262500e-002F,7.6012500e-002F,8.3237500e-002F,9.1412500e-002F,1.0113750e-001F,1.1402500e-001F,1.3408750e-001F},
	{5.0262500e-002F,5.8850000e-002F,6.5262500e-002F,7.1475000e-002F,7.7675000e-002F,8.3950000e-002F,9.0537500e-002F,9.7350000e-002F,1.0438750e-001F,1.1285000e-001F,1.2243750e-001F,1.3320000e-001F,1.4338750e-001F,1.5515000e-001F,1.6963750e-001F,1.8963750e-001F},
	{7.7175000e-002F,9.1537500e-002F,1.0248750e-001F,1.1067500e-001F,1.1803750e-001F,1.2523750e-001F,1.3260000e-001F,1.4015000e-001F,1.4827500e-001F,1.5753750e-001F,1.6775000e-001F,1.7816250e-001F,1.8936250e-001F,2.0170000e-001F,2.1537500e-001F,2.3567500e-001F},
	{1.2272500e-001F,1.3523750e-001F,1.4651250e-001F,1.5676250e-001F,1.6615000e-001F,1.7541250e-001F,1.8412500e-001F,1.9248750e-001F,2.0115000e-001F,2.0993750e-001F,2.1916250e-001F,2.2836250e-001F,2.3852500e-001F,2.4982500e-001F,2.6332500e-001F,2.7956250e-001F},
	{1.6676250e-001F,1.8085000e-001F,1.9245000e-001F,2.0325000e-001F,2.1220000e-001F,2.2041250e-001F,2.2858750e-001F,2.3632500e-001F,2.4426250e-001F,2.5243750e-001F,3.7345000e-001F,2.7005000e-001F,2.7978750e-001F,2.9110000e-001F,3.0258750e-001F,3.1576250e-001F},
	{2.2883750e-001F,2.4497500e-001F,2.5706250e-001F,2.6682500e-001F,2.7482500e-001F,2.8178750e-001F,2.8793750e-001F,2.9365000e-001F,2.9970000e-001F,3.0601250e-001F,3.1253750e-001F,3.2001250e-001F,3.2903750e-001F,3.3938750e-001F,3.5292500e-001F,3.7077500e-001F},
	{2.9346250e-001F,3.1012500e-001F,3.2288750e-001F,3.3436250e-001F,3.4593750e-001F,3.5932500e-001F,3.7570000e-001F,4.0031250e-001F,3.4283750e-001F,3.4897500e-001F,3.5576250e-001F,3.6305000e-001F,3.7082500e-001F,3.8123750e-001F,3.9447500e-001F,4.0711250e-001F},
	{2.8091250e-001F,2.9517500e-001F,3.0435000e-001F,3.1206250e-001F,3.1885000e-001F,3.2506250e-001F,3.3096250e-001F,3.3675000e-001F},
	{3.9257500e-001F,4.0575000e-001F,4.1585000e-001F,4.2440000e-001F,4.3235000e-001F,4.4057500e-001F,4.5018750e-001F,4.6370000e-001F}};

#if defined(BUILD_INTEGER)

// This table is cut and pasted from WMAConcepts.xls!InvQuadRoot2
// Since the binary point is fixed at 32, this table should only change if INVQUADROOT_FRACTION_TABLE_SIZE==256 changes.
// Numerical results seem the same as previous method which used a 4096 table without interpolation

const UInt g_InvQuadRootFraction[1+INVQUADROOT_FRACTION_TABLE_SIZE] = {
    0xFFFFFFFF,                            //  UBP0_FROM_FLOAT(1),    //0
    UBP0_FROM_FLOAT(0.999025814722967),    //1
    UBP0_FROM_FLOAT(0.998056356216173),    //2
    UBP0_FROM_FLOAT(0.997091583357276),    //3
    UBP0_FROM_FLOAT(0.996131455538709),    //4
    UBP0_FROM_FLOAT(0.995175932659284),    //5
    UBP0_FROM_FLOAT(0.994224975115967),    //6
    UBP0_FROM_FLOAT(0.993278543795814),    //7
    UBP0_FROM_FLOAT(0.992336600068073),    //8
    UBP0_FROM_FLOAT(0.991399105776439),    //9
    UBP0_FROM_FLOAT(0.990466023231461),    //10
    UBP0_FROM_FLOAT(0.989537315203104),    //11
    UBP0_FROM_FLOAT(0.988612944913449),    //12
    UBP0_FROM_FLOAT(0.987692876029542),    //13
    UBP0_FROM_FLOAT(0.98677707265638),    //14
    UBP0_FROM_FLOAT(0.985865499330035),    //15
    UBP0_FROM_FLOAT(0.984958121010905),    //16
    UBP0_FROM_FLOAT(0.984054903077102),    //17
    UBP0_FROM_FLOAT(0.983155811317963),    //18
    UBP0_FROM_FLOAT(0.982260811927689),    //19
    UBP0_FROM_FLOAT(0.981369871499097),    //20
    UBP0_FROM_FLOAT(0.980482957017497),    //21
    UBP0_FROM_FLOAT(0.979600035854689),    //22
    UBP0_FROM_FLOAT(0.978721075763059),    //23
    UBP0_FROM_FLOAT(0.977846044869802),    //24
    UBP0_FROM_FLOAT(0.976974911671241),    //25
    UBP0_FROM_FLOAT(0.976107645027259),    //26
    UBP0_FROM_FLOAT(0.97524421415583),    //27
    UBP0_FROM_FLOAT(0.974384588627654),    //28
    UBP0_FROM_FLOAT(0.973528738360891),    //29
    UBP0_FROM_FLOAT(0.972676633615989),    //30
    UBP0_FROM_FLOAT(0.97182824499061),    //31
    UBP0_FROM_FLOAT(0.970983543414647),    //32
    UBP0_FROM_FLOAT(0.970142500145332),    //33
    UBP0_FROM_FLOAT(0.969305086762432),    //34
    UBP0_FROM_FLOAT(0.968471275163532),    //35
    UBP0_FROM_FLOAT(0.967641037559406),    //36
    UBP0_FROM_FLOAT(0.966814346469464),    //37
    UBP0_FROM_FLOAT(0.965991174717289),    //38
    UBP0_FROM_FLOAT(0.965171495426243),    //39
    UBP0_FROM_FLOAT(0.964355282015168),    //40
    UBP0_FROM_FLOAT(0.96354250819414),    //41
    UBP0_FROM_FLOAT(0.96273314796032),    //42
    UBP0_FROM_FLOAT(0.961927175593862),    //43
    UBP0_FROM_FLOAT(0.961124565653902),    //44
    UBP0_FROM_FLOAT(0.960325292974613),    //45
    UBP0_FROM_FLOAT(0.95952933266133),    //46
    UBP0_FROM_FLOAT(0.958736660086742),    //47
    UBP0_FROM_FLOAT(0.957947250887149),    //48
    UBP0_FROM_FLOAT(0.957161080958785),    //49
    UBP0_FROM_FLOAT(0.956378126454201),    //50
    UBP0_FROM_FLOAT(0.955598363778716),    //51
    UBP0_FROM_FLOAT(0.954821769586923),    //52
    UBP0_FROM_FLOAT(0.954048320779256),    //53
    UBP0_FROM_FLOAT(0.953277994498616),    //54
    UBP0_FROM_FLOAT(0.952510768127053),    //55
    UBP0_FROM_FLOAT(0.951746619282504),    //56
    UBP0_FROM_FLOAT(0.95098552581559),    //57
    UBP0_FROM_FLOAT(0.950227465806457),    //58
    UBP0_FROM_FLOAT(0.949472417561678),    //59
    UBP0_FROM_FLOAT(0.948720359611208),    //60
    UBP0_FROM_FLOAT(0.947971270705378),    //61
    UBP0_FROM_FLOAT(0.947225129811953),    //62
    UBP0_FROM_FLOAT(0.946481916113228),    //63
    UBP0_FROM_FLOAT(0.945741609003176),    //64
    UBP0_FROM_FLOAT(0.945004188084643),    //65
    UBP0_FROM_FLOAT(0.944269633166589),    //66
    UBP0_FROM_FLOAT(0.943537924261368),    //67
    UBP0_FROM_FLOAT(0.942809041582063),    //68
    UBP0_FROM_FLOAT(0.942082965539854),    //69
    UBP0_FROM_FLOAT(0.941359676741435),    //70
    UBP0_FROM_FLOAT(0.940639155986465),    //71
    UBP0_FROM_FLOAT(0.939921384265074),    //72
    UBP0_FROM_FLOAT(0.939206342755389),    //73
    UBP0_FROM_FLOAT(0.93849401282112),    //74
    UBP0_FROM_FLOAT(0.937784376009166),    //75
    UBP0_FROM_FLOAT(0.937077414047272),    //76
    UBP0_FROM_FLOAT(0.936373108841719),    //77
    UBP0_FROM_FLOAT(0.935671442475046),    //78
    UBP0_FROM_FLOAT(0.934972397203813),    //79
    UBP0_FROM_FLOAT(0.9342759554564),    //80
    UBP0_FROM_FLOAT(0.933582099830834),    //81
    UBP0_FROM_FLOAT(0.932890813092654),    //82
    UBP0_FROM_FLOAT(0.932202078172812),    //83
    UBP0_FROM_FLOAT(0.931515878165598),    //84
    UBP0_FROM_FLOAT(0.930832196326605),    //85
    UBP0_FROM_FLOAT(0.930151016070724),    //86
    UBP0_FROM_FLOAT(0.929472320970163),    //87
    UBP0_FROM_FLOAT(0.928796094752507),    //88
    UBP0_FROM_FLOAT(0.928122321298796),    //89
    UBP0_FROM_FLOAT(0.927450984641643),    //90
    UBP0_FROM_FLOAT(0.926782068963373),    //91
    UBP0_FROM_FLOAT(0.926115558594194),    //92
    UBP0_FROM_FLOAT(0.925451438010392),    //93
    UBP0_FROM_FLOAT(0.924789691832558),    //94
    UBP0_FROM_FLOAT(0.924130304823837),    //95
    UBP0_FROM_FLOAT(0.923473261888205),    //96
    UBP0_FROM_FLOAT(0.922818548068774),    //97
    UBP0_FROM_FLOAT(0.922166148546114),    //98
    UBP0_FROM_FLOAT(0.921516048636615),    //99
    UBP0_FROM_FLOAT(0.920868233790855),    //100
    UBP0_FROM_FLOAT(0.920222689592004),    //101
    UBP0_FROM_FLOAT(0.91957940175425),    //102
    UBP0_FROM_FLOAT(0.918938356121245),    //103
    UBP0_FROM_FLOAT(0.918299538664573),    //104
    UBP0_FROM_FLOAT(0.917662935482247),    //105
    UBP0_FROM_FLOAT(0.917028532797218),    //106
    UBP0_FROM_FLOAT(0.916396316955915),    //107
    UBP0_FROM_FLOAT(0.915766274426796),    //108
    UBP0_FROM_FLOAT(0.915138391798935),    //109
    UBP0_FROM_FLOAT(0.914512655780611),    //110
    UBP0_FROM_FLOAT(0.91388905319793),    //111
    UBP0_FROM_FLOAT(0.913267570993463),    //112
    UBP0_FROM_FLOAT(0.912648196224901),    //113
    UBP0_FROM_FLOAT(0.912030916063736),    //114
    UBP0_FROM_FLOAT(0.911415717793952),    //115
    UBP0_FROM_FLOAT(0.910802588810737),    //116
    UBP0_FROM_FLOAT(0.91019151661922),    //117
    UBP0_FROM_FLOAT(0.909582488833218),    //118
    UBP0_FROM_FLOAT(0.908975493174),    //119
    UBP0_FROM_FLOAT(0.908370517469075),    //120
    UBP0_FROM_FLOAT(0.907767549650993),    //121
    UBP0_FROM_FLOAT(0.90716657775616),    //122
    UBP0_FROM_FLOAT(0.906567589923676),    //123
    UBP0_FROM_FLOAT(0.905970574394182),    //124
    UBP0_FROM_FLOAT(0.905375519508726),    //125
    UBP0_FROM_FLOAT(0.90478241370765),    //126
    UBP0_FROM_FLOAT(0.904191245529481),    //127
    UBP0_FROM_FLOAT(0.903602003609845),    //128
    UBP0_FROM_FLOAT(0.903014676680396),    //129
    UBP0_FROM_FLOAT(0.902429253567758),    //130
    UBP0_FROM_FLOAT(0.901845723192475),    //131
    UBP0_FROM_FLOAT(0.90126407456799),    //132
    UBP0_FROM_FLOAT(0.900684296799622),    //133
    UBP0_FROM_FLOAT(0.900106379083569),    //134
    UBP0_FROM_FLOAT(0.899530310705914),    //135
    UBP0_FROM_FLOAT(0.898956081041654),    //136
    UBP0_FROM_FLOAT(0.898383679553736),    //137
    UBP0_FROM_FLOAT(0.897813095792106),    //138
    UBP0_FROM_FLOAT(0.897244319392775),    //139
    UBP0_FROM_FLOAT(0.896677340076892),    //140
    UBP0_FROM_FLOAT(0.896112147649831),    //141
    UBP0_FROM_FLOAT(0.895548732000295),    //142
    UBP0_FROM_FLOAT(0.894987083099423),    //143
    UBP0_FROM_FLOAT(0.894427190999916),    //144
    UBP0_FROM_FLOAT(0.893869045835169),    //145
    UBP0_FROM_FLOAT(0.893312637818422),    //146
    UBP0_FROM_FLOAT(0.89275795724191),    //147
    UBP0_FROM_FLOAT(0.89220499447604),    //148
    UBP0_FROM_FLOAT(0.891653739968563),    //149
    UBP0_FROM_FLOAT(0.891104184243764),    //150
    UBP0_FROM_FLOAT(0.890556317901667),    //151
    UBP0_FROM_FLOAT(0.890010131617242),    //152
    UBP0_FROM_FLOAT(0.889465616139622),    //153
    UBP0_FROM_FLOAT(0.888922762291343),    //154
    UBP0_FROM_FLOAT(0.888381560967574),    //155
    UBP0_FROM_FLOAT(0.887842003135375),    //156
    UBP0_FROM_FLOAT(0.887304079832949),    //157
    UBP0_FROM_FLOAT(0.88676778216892),    //158
    UBP0_FROM_FLOAT(0.886233101321602),    //159
    UBP0_FROM_FLOAT(0.885700028538295),    //160
    UBP0_FROM_FLOAT(0.885168555134573),    //161
    UBP0_FROM_FLOAT(0.884638672493595),    //162
    UBP0_FROM_FLOAT(0.884110372065417),    //163
    UBP0_FROM_FLOAT(0.883583645366315),    //164
    UBP0_FROM_FLOAT(0.883058483978115),    //165
    UBP0_FROM_FLOAT(0.882534879547532),    //166
    UBP0_FROM_FLOAT(0.882012823785518),    //167
    UBP0_FROM_FLOAT(0.88149230846662),    //168
    UBP0_FROM_FLOAT(0.880973325428339),    //169
    UBP0_FROM_FLOAT(0.880455866570503),    //170
    UBP0_FROM_FLOAT(0.879939923854648),    //171
    UBP0_FROM_FLOAT(0.879425489303404),    //172
    UBP0_FROM_FLOAT(0.878912554999886),    //173
    UBP0_FROM_FLOAT(0.878401113087102),    //174
    UBP0_FROM_FLOAT(0.877891155767354),    //175
    UBP0_FROM_FLOAT(0.877382675301662),    //176
    UBP0_FROM_FLOAT(0.87687566400918),    //177
    UBP0_FROM_FLOAT(0.876370114266633),    //178
    UBP0_FROM_FLOAT(0.875866018507748),    //179
    UBP0_FROM_FLOAT(0.875363369222702),    //180
    UBP0_FROM_FLOAT(0.874862158957572),    //181
    UBP0_FROM_FLOAT(0.874362380313789),    //182
    UBP0_FROM_FLOAT(0.873864025947605),    //183
    UBP0_FROM_FLOAT(0.873367088569562),    //184
    UBP0_FROM_FLOAT(0.87287156094397),    //185
    UBP0_FROM_FLOAT(0.872377435888383),    //186
    UBP0_FROM_FLOAT(0.871884706273099),    //187
    UBP0_FROM_FLOAT(0.871393365020643),    //188
    UBP0_FROM_FLOAT(0.870903405105276),    //189
    UBP0_FROM_FLOAT(0.870414819552497),    //190
    UBP0_FROM_FLOAT(0.869927601438559),    //191
    UBP0_FROM_FLOAT(0.869441743889983),    //192
    UBP0_FROM_FLOAT(0.868957240083086),    //193
    UBP0_FROM_FLOAT(0.868474083243507),    //194
    UBP0_FROM_FLOAT(0.867992266645745),    //195
    UBP0_FROM_FLOAT(0.867511783612694),    //196
    UBP0_FROM_FLOAT(0.867032627515195),    //197
    UBP0_FROM_FLOAT(0.866554791771583),    //198
    UBP0_FROM_FLOAT(0.866078269847242),    //199
    UBP0_FROM_FLOAT(0.865603055254171),    //200
    UBP0_FROM_FLOAT(0.865129141550544),    //201
    UBP0_FROM_FLOAT(0.864656522340285),    //202
    UBP0_FROM_FLOAT(0.864185191272645),    //203
    UBP0_FROM_FLOAT(0.863715142041779),    //204
    UBP0_FROM_FLOAT(0.863246368386335),    //205
    UBP0_FROM_FLOAT(0.862778864089041),    //206
    UBP0_FROM_FLOAT(0.862312622976306),    //207
    UBP0_FROM_FLOAT(0.861847638917812),    //208
    UBP0_FROM_FLOAT(0.861383905826124),    //209
    UBP0_FROM_FLOAT(0.860921417656296),    //210
    UBP0_FROM_FLOAT(0.860460168405485),    //211
    UBP0_FROM_FLOAT(0.860000152112567),    //212
    UBP0_FROM_FLOAT(0.85954136285776),    //213
    UBP0_FROM_FLOAT(0.85908379476225),    //214
    UBP0_FROM_FLOAT(0.858627441987819),    //215
    UBP0_FROM_FLOAT(0.858172298736482),    //216
    UBP0_FROM_FLOAT(0.857718359250124),    //217
    UBP0_FROM_FLOAT(0.85726561781014),    //218
    UBP0_FROM_FLOAT(0.856814068737085),    //219
    UBP0_FROM_FLOAT(0.856363706390322),    //220
    UBP0_FROM_FLOAT(0.855914525167676),    //221
    UBP0_FROM_FLOAT(0.855466519505093),    //222
    UBP0_FROM_FLOAT(0.855019683876299),    //223
    UBP0_FROM_FLOAT(0.854574012792468),    //224
    UBP0_FROM_FLOAT(0.85412950080189),    //225
    UBP0_FROM_FLOAT(0.853686142489641),    //226
    UBP0_FROM_FLOAT(0.853243932477263),    //227
    UBP0_FROM_FLOAT(0.852802865422442),    //228
    UBP0_FROM_FLOAT(0.852362936018689),    //229
    UBP0_FROM_FLOAT(0.85192413899503),    //230
    UBP0_FROM_FLOAT(0.851486469115693),    //231
    UBP0_FROM_FLOAT(0.851049921179803),    //232
    UBP0_FROM_FLOAT(0.850614490021076),    //233
    UBP0_FROM_FLOAT(0.850180170507523),    //234
    UBP0_FROM_FLOAT(0.849746957541149),    //235
    UBP0_FROM_FLOAT(0.84931484605766),    //236
    UBP0_FROM_FLOAT(0.848883831026173),    //237
    UBP0_FROM_FLOAT(0.848453907448929),    //238
    UBP0_FROM_FLOAT(0.848025070361007),    //239
    UBP0_FROM_FLOAT(0.847597314830043),    //240
    UBP0_FROM_FLOAT(0.847170635955951),    //241
    UBP0_FROM_FLOAT(0.846745028870647),    //242
    UBP0_FROM_FLOAT(0.846320488737779),    //243
    UBP0_FROM_FLOAT(0.845897010752451),    //244
    UBP0_FROM_FLOAT(0.845474590140965),    //245
    UBP0_FROM_FLOAT(0.845053222160547),    //246
    UBP0_FROM_FLOAT(0.844632902099093),    //247
    UBP0_FROM_FLOAT(0.844213625274905),    //248
    UBP0_FROM_FLOAT(0.84379538703644),    //249
    UBP0_FROM_FLOAT(0.843378182762051),    //250
    UBP0_FROM_FLOAT(0.84296200785974),    //251
    UBP0_FROM_FLOAT(0.842546857766908),    //252
    UBP0_FROM_FLOAT(0.842132727950112),    //253
    UBP0_FROM_FLOAT(0.841719613904818),    //254
    UBP0_FROM_FLOAT(0.841307511155163),    //255
    UBP0_FROM_FLOAT(0.840896415253715),    //256
};

// 2^((18+16-idx)/4.0)
// ARM uses 18.  Our fractional bits require 18+16 == 34.  
// Anyone who works out the formula should write it down.
// The values in this table is cut and pasted from WmaudioConcepts.xls!InvQuadRoot2.  
// Chnages to any of the LPc fractional bits should require a change in this table.

const UInt g_InvQuadRootExponent[BITS_LP_SPEC_POWER+1] = {
    WEIGHT_FROM_FLOAT(0.00276213586400995),    //0
    WEIGHT_FROM_FLOAT(0.00328475162208482),    //1
    WEIGHT_FROM_FLOAT(0.00390625),    //2
    WEIGHT_FROM_FLOAT(0.00464534029297938),    //3
    WEIGHT_FROM_FLOAT(0.0055242717280199),    //4
    WEIGHT_FROM_FLOAT(0.00656950324416965),    //5
    WEIGHT_FROM_FLOAT(0.0078125),    //6
    WEIGHT_FROM_FLOAT(0.00929068058595876),    //7
    WEIGHT_FROM_FLOAT(0.0110485434560398),    //8
    WEIGHT_FROM_FLOAT(0.0131390064883393),    //9
    WEIGHT_FROM_FLOAT(0.015625),    //10
    WEIGHT_FROM_FLOAT(0.0185813611719175),    //11
    WEIGHT_FROM_FLOAT(0.0220970869120796),    //12
    WEIGHT_FROM_FLOAT(0.0262780129766786),    //13
    WEIGHT_FROM_FLOAT(0.03125),    //14
    WEIGHT_FROM_FLOAT(0.037162722343835),    //15
    WEIGHT_FROM_FLOAT(0.0441941738241592),    //16
    WEIGHT_FROM_FLOAT(0.0525560259533572),    //17
    WEIGHT_FROM_FLOAT(0.0625),    //18
    WEIGHT_FROM_FLOAT(0.0743254446876701),    //19
    WEIGHT_FROM_FLOAT(0.0883883476483184),    //20
    WEIGHT_FROM_FLOAT(0.105112051906714),    //21
    WEIGHT_FROM_FLOAT(0.125),    //22
    WEIGHT_FROM_FLOAT(0.14865088937534),    //23
    WEIGHT_FROM_FLOAT(0.176776695296637),    //24
    WEIGHT_FROM_FLOAT(0.210224103813429),    //25
    WEIGHT_FROM_FLOAT(0.25),    //26
    WEIGHT_FROM_FLOAT(0.29730177875068),    //27
    WEIGHT_FROM_FLOAT(0.353553390593274),    //28
    WEIGHT_FROM_FLOAT(0.420448207626857),    //29
    WEIGHT_FROM_FLOAT(0.5),    //30
    WEIGHT_FROM_FLOAT(0.594603557501361),    //31
    WEIGHT_FROM_FLOAT(0.707106781186547)     //32

#if BITS_LP_SPEC_POWER>32
    ,
    WEIGHT_FROM_FLOAT(0.840896415253715),    //33
    WEIGHT_FROM_FLOAT(1),    //34
    WEIGHT_FROM_FLOAT(1.18920711500272),    //35
    WEIGHT_FROM_FLOAT(1.4142135623731),    //36
    WEIGHT_FROM_FLOAT(1.68179283050743),    //37
    WEIGHT_FROM_FLOAT(2),    //38
    WEIGHT_FROM_FLOAT(2.37841423000544),    //39
    WEIGHT_FROM_FLOAT(2.82842712474619),    //40
    WEIGHT_FROM_FLOAT(3.36358566101486),    //41
    WEIGHT_FROM_FLOAT(4),    //42
    WEIGHT_FROM_FLOAT(4.75682846001088),    //43
    WEIGHT_FROM_FLOAT(5.65685424949238),    //44
    WEIGHT_FROM_FLOAT(6.72717132202972),    //45
    WEIGHT_FROM_FLOAT(8.0),    //46
    WEIGHT_FROM_FLOAT(9.51365692002177),    //47
    WEIGHT_FROM_FLOAT(11.3137084989848),    //48
    WEIGHT_FROM_FLOAT(13.4543426440594),    //49
    WEIGHT_FROM_FLOAT(16.0),    //50
    WEIGHT_FROM_FLOAT(19.0273138400435),    //51
    WEIGHT_FROM_FLOAT(22.6274169979695),    //52
    WEIGHT_FROM_FLOAT(26.9086852881189),    //53
    WEIGHT_FROM_FLOAT(32.0),    //54
    WEIGHT_FROM_FLOAT(38.0546276800871),    //55
    WEIGHT_FROM_FLOAT(45.254833995939),    //56
    WEIGHT_FROM_FLOAT(53.8173705762377),    //57
    WEIGHT_FROM_FLOAT(64.0),    //58
    WEIGHT_FROM_FLOAT(76.1092553601742),    //59
    WEIGHT_FROM_FLOAT(90.5096679918781),    //60
    WEIGHT_FROM_FLOAT(107.634741152475),    //61
    WEIGHT_FROM_FLOAT(128.0),    //62
    WEIGHT_FROM_FLOAT(152.218510720348),    //63
    WEIGHT_FROM_FLOAT(181.019335983756)    //64
#endif  //BITS_LP_SPEC_POWER>32
};  


const UInt g_InverseFraction[1+INVERSE_FRACTION_TABLE_SIZE] = {
    0xFFFFFFFF,   //UBP0_FROM_FLOAT(1),    //0
    UBP0_FROM_FLOAT(0.996108949416342),    //1
    UBP0_FROM_FLOAT(0.992248062015504),    //2
    UBP0_FROM_FLOAT(0.988416988416988),    //3
    UBP0_FROM_FLOAT(0.984615384615385),    //4
    UBP0_FROM_FLOAT(0.980842911877395),    //5
    UBP0_FROM_FLOAT(0.977099236641221),    //6
    UBP0_FROM_FLOAT(0.973384030418251),    //7
    UBP0_FROM_FLOAT(0.96969696969697),    //8
    UBP0_FROM_FLOAT(0.966037735849057),    //9
    UBP0_FROM_FLOAT(0.962406015037594),    //10
    UBP0_FROM_FLOAT(0.958801498127341),    //11
    UBP0_FROM_FLOAT(0.955223880597015),    //12
    UBP0_FROM_FLOAT(0.951672862453532),    //13
    UBP0_FROM_FLOAT(0.948148148148148),    //14
    UBP0_FROM_FLOAT(0.944649446494465),    //15
    UBP0_FROM_FLOAT(0.941176470588235),    //16
    UBP0_FROM_FLOAT(0.937728937728938),    //17
    UBP0_FROM_FLOAT(0.934306569343066),    //18
    UBP0_FROM_FLOAT(0.930909090909091),    //19
    UBP0_FROM_FLOAT(0.927536231884058),    //20
    UBP0_FROM_FLOAT(0.924187725631769),    //21
    UBP0_FROM_FLOAT(0.920863309352518),    //22
    UBP0_FROM_FLOAT(0.917562724014337),    //23
    UBP0_FROM_FLOAT(0.914285714285714),    //24
    UBP0_FROM_FLOAT(0.911032028469751),    //25
    UBP0_FROM_FLOAT(0.907801418439716),    //26
    UBP0_FROM_FLOAT(0.904593639575972),    //27
    UBP0_FROM_FLOAT(0.901408450704225),    //28
    UBP0_FROM_FLOAT(0.898245614035088),    //29
    UBP0_FROM_FLOAT(0.895104895104895),    //30
    UBP0_FROM_FLOAT(0.89198606271777),    //31
    UBP0_FROM_FLOAT(0.888888888888889),    //32
    UBP0_FROM_FLOAT(0.885813148788927),    //33
    UBP0_FROM_FLOAT(0.882758620689655),    //34
    UBP0_FROM_FLOAT(0.879725085910653),    //35
    UBP0_FROM_FLOAT(0.876712328767123),    //36
    UBP0_FROM_FLOAT(0.873720136518771),    //37
    UBP0_FROM_FLOAT(0.870748299319728),    //38
    UBP0_FROM_FLOAT(0.867796610169492),    //39
    UBP0_FROM_FLOAT(0.864864864864865),    //40
    UBP0_FROM_FLOAT(0.861952861952862),    //41
    UBP0_FROM_FLOAT(0.859060402684564),    //42
    UBP0_FROM_FLOAT(0.8561872909699),    //43
    UBP0_FROM_FLOAT(0.853333333333333),    //44
    UBP0_FROM_FLOAT(0.850498338870432),    //45
    UBP0_FROM_FLOAT(0.847682119205298),    //46
    UBP0_FROM_FLOAT(0.844884488448845),    //47
    UBP0_FROM_FLOAT(0.842105263157895),    //48
    UBP0_FROM_FLOAT(0.839344262295082),    //49
    UBP0_FROM_FLOAT(0.836601307189543),    //50
    UBP0_FROM_FLOAT(0.833876221498371),    //51
    UBP0_FROM_FLOAT(0.831168831168831),    //52
    UBP0_FROM_FLOAT(0.828478964401295),    //53
    UBP0_FROM_FLOAT(0.825806451612903),    //54
    UBP0_FROM_FLOAT(0.823151125401929),    //55
    UBP0_FROM_FLOAT(0.82051282051282),    //56
    UBP0_FROM_FLOAT(0.817891373801917),    //57
    UBP0_FROM_FLOAT(0.815286624203822),    //58
    UBP0_FROM_FLOAT(0.812698412698413),    //59
    UBP0_FROM_FLOAT(0.810126582278481),    //60
    UBP0_FROM_FLOAT(0.807570977917981),    //61
    UBP0_FROM_FLOAT(0.805031446540881),    //62
    UBP0_FROM_FLOAT(0.802507836990596),    //63
    UBP0_FROM_FLOAT(0.8),    //64
    UBP0_FROM_FLOAT(0.797507788161994),    //65
    UBP0_FROM_FLOAT(0.795031055900621),    //66
    UBP0_FROM_FLOAT(0.792569659442725),    //67
    UBP0_FROM_FLOAT(0.790123456790123),    //68
    UBP0_FROM_FLOAT(0.787692307692308),    //69
    UBP0_FROM_FLOAT(0.785276073619632),    //70
    UBP0_FROM_FLOAT(0.782874617737003),    //71
    UBP0_FROM_FLOAT(0.780487804878049),    //72
    UBP0_FROM_FLOAT(0.778115501519757),    //73
    UBP0_FROM_FLOAT(0.775757575757576),    //74
    UBP0_FROM_FLOAT(0.773413897280967),    //75
    UBP0_FROM_FLOAT(0.771084337349398),    //76
    UBP0_FROM_FLOAT(0.768768768768769),    //77
    UBP0_FROM_FLOAT(0.766467065868264),    //78
    UBP0_FROM_FLOAT(0.764179104477612),    //79
    UBP0_FROM_FLOAT(0.761904761904762),    //80
    UBP0_FROM_FLOAT(0.759643916913947),    //81
    UBP0_FROM_FLOAT(0.757396449704142),    //82
    UBP0_FROM_FLOAT(0.755162241887906),    //83
    UBP0_FROM_FLOAT(0.752941176470588),    //84
    UBP0_FROM_FLOAT(0.750733137829912),    //85
    UBP0_FROM_FLOAT(0.748538011695906),    //86
    UBP0_FROM_FLOAT(0.746355685131195),    //87
    UBP0_FROM_FLOAT(0.744186046511628),    //88
    UBP0_FROM_FLOAT(0.742028985507246),    //89
    UBP0_FROM_FLOAT(0.739884393063584),    //90
    UBP0_FROM_FLOAT(0.737752161383285),    //91
    UBP0_FROM_FLOAT(0.735632183908046),    //92
    UBP0_FROM_FLOAT(0.73352435530086),    //93
    UBP0_FROM_FLOAT(0.731428571428571),    //94
    UBP0_FROM_FLOAT(0.729344729344729),    //95
    UBP0_FROM_FLOAT(0.727272727272727),    //96
    UBP0_FROM_FLOAT(0.725212464589235),    //97
    UBP0_FROM_FLOAT(0.72316384180791),    //98
    UBP0_FROM_FLOAT(0.72112676056338),    //99
    UBP0_FROM_FLOAT(0.719101123595506),    //100
    UBP0_FROM_FLOAT(0.717086834733894),    //101
    UBP0_FROM_FLOAT(0.715083798882682),    //102
    UBP0_FROM_FLOAT(0.713091922005571),    //103
    UBP0_FROM_FLOAT(0.711111111111111),    //104
    UBP0_FROM_FLOAT(0.709141274238227),    //105
    UBP0_FROM_FLOAT(0.707182320441989),    //106
    UBP0_FROM_FLOAT(0.705234159779614),    //107
    UBP0_FROM_FLOAT(0.703296703296703),    //108
    UBP0_FROM_FLOAT(0.701369863013699),    //109
    UBP0_FROM_FLOAT(0.699453551912568),    //110
    UBP0_FROM_FLOAT(0.697547683923706),    //111
    UBP0_FROM_FLOAT(0.695652173913043),    //112
    UBP0_FROM_FLOAT(0.693766937669377),    //113
    UBP0_FROM_FLOAT(0.691891891891892),    //114
    UBP0_FROM_FLOAT(0.690026954177898),    //115
    UBP0_FROM_FLOAT(0.688172043010753),    //116
    UBP0_FROM_FLOAT(0.686327077747989),    //117
    UBP0_FROM_FLOAT(0.684491978609626),    //118
    UBP0_FROM_FLOAT(0.682666666666667),    //119
    UBP0_FROM_FLOAT(0.680851063829787),    //120
    UBP0_FROM_FLOAT(0.679045092838196),    //121
    UBP0_FROM_FLOAT(0.677248677248677),    //122
    UBP0_FROM_FLOAT(0.675461741424802),    //123
    UBP0_FROM_FLOAT(0.673684210526316),    //124
    UBP0_FROM_FLOAT(0.671916010498688),    //125
    UBP0_FROM_FLOAT(0.670157068062827),    //126
    UBP0_FROM_FLOAT(0.668407310704961),    //127
    UBP0_FROM_FLOAT(0.666666666666667),    //128
    UBP0_FROM_FLOAT(0.664935064935065),    //129
    UBP0_FROM_FLOAT(0.663212435233161),    //130
    UBP0_FROM_FLOAT(0.661498708010336),    //131
    UBP0_FROM_FLOAT(0.65979381443299),    //132
    UBP0_FROM_FLOAT(0.658097686375321),    //133
    UBP0_FROM_FLOAT(0.656410256410256),    //134
    UBP0_FROM_FLOAT(0.654731457800512),    //135
    UBP0_FROM_FLOAT(0.653061224489796),    //136
    UBP0_FROM_FLOAT(0.651399491094148),    //137
    UBP0_FROM_FLOAT(0.649746192893401),    //138
    UBP0_FROM_FLOAT(0.648101265822785),    //139
    UBP0_FROM_FLOAT(0.646464646464647),    //140
    UBP0_FROM_FLOAT(0.644836272040302),    //141
    UBP0_FROM_FLOAT(0.64321608040201),    //142
    UBP0_FROM_FLOAT(0.641604010025063),    //143
    UBP0_FROM_FLOAT(0.64),    //144
    UBP0_FROM_FLOAT(0.638403990024938),    //145
    UBP0_FROM_FLOAT(0.63681592039801),    //146
    UBP0_FROM_FLOAT(0.635235732009926),    //147
    UBP0_FROM_FLOAT(0.633663366336634),    //148
    UBP0_FROM_FLOAT(0.632098765432099),    //149
    UBP0_FROM_FLOAT(0.630541871921182),    //150
    UBP0_FROM_FLOAT(0.628992628992629),    //151
    UBP0_FROM_FLOAT(0.627450980392157),    //152
    UBP0_FROM_FLOAT(0.625916870415648),    //153
    UBP0_FROM_FLOAT(0.624390243902439),    //154
    UBP0_FROM_FLOAT(0.62287104622871),    //155
    UBP0_FROM_FLOAT(0.621359223300971),    //156
    UBP0_FROM_FLOAT(0.619854721549637),    //157
    UBP0_FROM_FLOAT(0.618357487922705),    //158
    UBP0_FROM_FLOAT(0.616867469879518),    //159
    UBP0_FROM_FLOAT(0.615384615384615),    //160
    UBP0_FROM_FLOAT(0.613908872901679),    //161
    UBP0_FROM_FLOAT(0.61244019138756),    //162
    UBP0_FROM_FLOAT(0.610978520286396),    //163
    UBP0_FROM_FLOAT(0.60952380952381),    //164
    UBP0_FROM_FLOAT(0.608076009501188),    //165
    UBP0_FROM_FLOAT(0.606635071090047),    //166
    UBP0_FROM_FLOAT(0.605200945626478),    //167
    UBP0_FROM_FLOAT(0.60377358490566),    //168
    UBP0_FROM_FLOAT(0.602352941176471),    //169
    UBP0_FROM_FLOAT(0.60093896713615),    //170
    UBP0_FROM_FLOAT(0.599531615925059),    //171
    UBP0_FROM_FLOAT(0.598130841121495),    //172
    UBP0_FROM_FLOAT(0.596736596736597),    //173
    UBP0_FROM_FLOAT(0.595348837209302),    //174
    UBP0_FROM_FLOAT(0.593967517401392),    //175
    UBP0_FROM_FLOAT(0.592592592592593),    //176
    UBP0_FROM_FLOAT(0.591224018475751),    //177
    UBP0_FROM_FLOAT(0.589861751152074),    //178
    UBP0_FROM_FLOAT(0.588505747126437),    //179
    UBP0_FROM_FLOAT(0.587155963302752),    //180
    UBP0_FROM_FLOAT(0.585812356979405),    //181
    UBP0_FROM_FLOAT(0.584474885844749),    //182
    UBP0_FROM_FLOAT(0.583143507972665),    //183
    UBP0_FROM_FLOAT(0.581818181818182),    //184
    UBP0_FROM_FLOAT(0.580498866213152),    //185
    UBP0_FROM_FLOAT(0.579185520361991),    //186
    UBP0_FROM_FLOAT(0.577878103837472),    //187
    UBP0_FROM_FLOAT(0.576576576576577),    //188
    UBP0_FROM_FLOAT(0.575280898876405),    //189
    UBP0_FROM_FLOAT(0.573991031390135),    //190
    UBP0_FROM_FLOAT(0.572706935123042),    //191
    UBP0_FROM_FLOAT(0.571428571428571),    //192
    UBP0_FROM_FLOAT(0.570155902004454),    //193
    UBP0_FROM_FLOAT(0.568888888888889),    //194
    UBP0_FROM_FLOAT(0.567627494456763),    //195
    UBP0_FROM_FLOAT(0.566371681415929),    //196
    UBP0_FROM_FLOAT(0.565121412803532),    //197
    UBP0_FROM_FLOAT(0.563876651982379),    //198
    UBP0_FROM_FLOAT(0.562637362637363),    //199
    UBP0_FROM_FLOAT(0.56140350877193),    //200
    UBP0_FROM_FLOAT(0.560175054704595),    //201
    UBP0_FROM_FLOAT(0.558951965065502),    //202
    UBP0_FROM_FLOAT(0.557734204793028),    //203
    UBP0_FROM_FLOAT(0.556521739130435),    //204
    UBP0_FROM_FLOAT(0.55531453362256),    //205
    UBP0_FROM_FLOAT(0.554112554112554),    //206
    UBP0_FROM_FLOAT(0.552915766738661),    //207
    UBP0_FROM_FLOAT(0.551724137931034),    //208
    UBP0_FROM_FLOAT(0.550537634408602),    //209
    UBP0_FROM_FLOAT(0.549356223175966),    //210
    UBP0_FROM_FLOAT(0.548179871520343),    //211
    UBP0_FROM_FLOAT(0.547008547008547),    //212
    UBP0_FROM_FLOAT(0.545842217484009),    //213
    UBP0_FROM_FLOAT(0.54468085106383),    //214
    UBP0_FROM_FLOAT(0.543524416135881),    //215
    UBP0_FROM_FLOAT(0.542372881355932),    //216
    UBP0_FROM_FLOAT(0.54122621564482),    //217
    UBP0_FROM_FLOAT(0.540084388185654),    //218
    UBP0_FROM_FLOAT(0.538947368421053),    //219
    UBP0_FROM_FLOAT(0.53781512605042),    //220
    UBP0_FROM_FLOAT(0.536687631027254),    //221
    UBP0_FROM_FLOAT(0.535564853556485),    //222
    UBP0_FROM_FLOAT(0.534446764091858),    //223
    UBP0_FROM_FLOAT(0.533333333333333),    //224
    UBP0_FROM_FLOAT(0.532224532224532),    //225
    UBP0_FROM_FLOAT(0.531120331950207),    //226
    UBP0_FROM_FLOAT(0.530020703933747),    //227
    UBP0_FROM_FLOAT(0.528925619834711),    //228
    UBP0_FROM_FLOAT(0.527835051546392),    //229
    UBP0_FROM_FLOAT(0.526748971193416),    //230
    UBP0_FROM_FLOAT(0.525667351129363),    //231
    UBP0_FROM_FLOAT(0.524590163934426),    //232
    UBP0_FROM_FLOAT(0.523517382413088),    //233
    UBP0_FROM_FLOAT(0.522448979591837),    //234
    UBP0_FROM_FLOAT(0.521384928716904),    //235
    UBP0_FROM_FLOAT(0.520325203252033),    //236
    UBP0_FROM_FLOAT(0.519269776876268),    //237
    UBP0_FROM_FLOAT(0.518218623481781),    //238
    UBP0_FROM_FLOAT(0.517171717171717),    //239
    UBP0_FROM_FLOAT(0.516129032258065),    //240
    UBP0_FROM_FLOAT(0.515090543259557),    //241
    UBP0_FROM_FLOAT(0.514056224899598),    //242
    UBP0_FROM_FLOAT(0.513026052104208),    //243
    UBP0_FROM_FLOAT(0.512),    //244
    UBP0_FROM_FLOAT(0.510978043912176),    //245
    UBP0_FROM_FLOAT(0.50996015936255),    //246
    UBP0_FROM_FLOAT(0.508946322067594),    //247
    UBP0_FROM_FLOAT(0.507936507936508),    //248
    UBP0_FROM_FLOAT(0.506930693069307),    //249
    UBP0_FROM_FLOAT(0.505928853754941),    //250
    UBP0_FROM_FLOAT(0.504930966469428),    //251
    UBP0_FROM_FLOAT(0.503937007874016),    //252
    UBP0_FROM_FLOAT(0.502946954813359),    //253
    UBP0_FROM_FLOAT(0.501960784313725),    //254
    UBP0_FROM_FLOAT(0.500978473581213),    //255
    UBP0_FROM_FLOAT(0.5)     //256
};


const UInt g_SqrtFraction[1+SQRT_FRACTION_TABLE_SIZE] = {
    BP2_FROM_FLOAT(1),    //0
    BP2_FROM_FLOAT(1.00195122136759),    //1
    BP2_FROM_FLOAT(1.00389865026306),    //2
    BP2_FROM_FLOAT(1.00584230871444),    //3
    BP2_FROM_FLOAT(1.00778221853732),    //4
    BP2_FROM_FLOAT(1.00971840133772),    //5
    BP2_FROM_FLOAT(1.01165087851492),    //6
    BP2_FROM_FLOAT(1.01357967126418),    //7
    BP2_FROM_FLOAT(1.0155048005795),    //8
    BP2_FROM_FLOAT(1.01742628725623),    //9
    BP2_FROM_FLOAT(1.01934415189376),    //10
    BP2_FROM_FLOAT(1.02125841489801),    //11
    BP2_FROM_FLOAT(1.02316909648406),    //12
    BP2_FROM_FLOAT(1.02507621667855),    //13
    BP2_FROM_FLOAT(1.02697979532219),    //14
    BP2_FROM_FLOAT(1.02887985207215),    //15
    BP2_FROM_FLOAT(1.03077640640442),    //16
    BP2_FROM_FLOAT(1.03266947761614),    //17
    BP2_FROM_FLOAT(1.03455908482793),    //18
    BP2_FROM_FLOAT(1.03644524698606),    //19
    BP2_FROM_FLOAT(1.03832798286476),    //20
    BP2_FROM_FLOAT(1.04020731106833),    //21
    BP2_FROM_FLOAT(1.04208325003332),    //22
    BP2_FROM_FLOAT(1.04395581803063),    //23
    BP2_FROM_FLOAT(1.04582503316759),    //24
    BP2_FROM_FLOAT(1.04769091339001),    //25
    BP2_FROM_FLOAT(1.04955347648417),    //26
    BP2_FROM_FLOAT(1.0514127400788),    //27
    BP2_FROM_FLOAT(1.05326872164704),    //28
    BP2_FROM_FLOAT(1.05512143850838),    //29
    BP2_FROM_FLOAT(1.05697090783049),    //30
    BP2_FROM_FLOAT(1.05881714663109),    //31
    BP2_FROM_FLOAT(1.06066017177982),    //32
    BP2_FROM_FLOAT(1.0625),    //33
    BP2_FROM_FLOAT(1.0643366478704),    //34
    BP2_FROM_FLOAT(1.066170131827),    //35
    BP2_FROM_FLOAT(1.06800046816469),    //36
    BP2_FROM_FLOAT(1.06982767303898),    //37
    BP2_FROM_FLOAT(1.07165176246764),    //38
    BP2_FROM_FLOAT(1.07347275233235),    //39
    BP2_FROM_FLOAT(1.07529065838033),    //40
    BP2_FROM_FLOAT(1.07710549622588),    //41
    BP2_FROM_FLOAT(1.078917281352),    //42
    BP2_FROM_FLOAT(1.08072602911191),    //43
    BP2_FROM_FLOAT(1.08253175473055),    //44
    BP2_FROM_FLOAT(1.08433447330609),    //45
    BP2_FROM_FLOAT(1.08613419981142),    //46
    BP2_FROM_FLOAT(1.08793094909558),    //47
    BP2_FROM_FLOAT(1.08972473588517),    //48
    BP2_FROM_FLOAT(1.09151557478581),    //49
    BP2_FROM_FLOAT(1.09330348028349),    //50
    BP2_FROM_FLOAT(1.09508846674595),    //51
    BP2_FROM_FLOAT(1.09687054842402),    //52
    BP2_FROM_FLOAT(1.09864973945293),    //53
    BP2_FROM_FLOAT(1.10042605385369),    //54
    BP2_FROM_FLOAT(1.10219950553427),    //55
    BP2_FROM_FLOAT(1.10397010829098),    //56
    BP2_FROM_FLOAT(1.10573787580963),    //57
    BP2_FROM_FLOAT(1.10750282166683),    //58
    BP2_FROM_FLOAT(1.10926495933118),    //59
    BP2_FROM_FLOAT(1.11102430216445),    //60
    BP2_FROM_FLOAT(1.1127808634228),    //61
    BP2_FROM_FLOAT(1.11453465625794),    //62
    BP2_FROM_FLOAT(1.11628569371823),    //63
    BP2_FROM_FLOAT(1.11803398874989),    //64
    BP2_FROM_FLOAT(1.11977955419806),    //65
    BP2_FROM_FLOAT(1.1215224028079),    //66
    BP2_FROM_FLOAT(1.12326254722571),    //67
    BP2_FROM_FLOAT(1.125),    //68
    BP2_FROM_FLOAT(1.1267347735825),    //69
    BP2_FROM_FLOAT(1.12846688032924),    //70
    BP2_FROM_FLOAT(1.13019633250157),    //71
    BP2_FROM_FLOAT(1.13192314226718),    //72
    BP2_FROM_FLOAT(1.13364732170107),    //73
    BP2_FROM_FLOAT(1.13536888278656),    //74
    BP2_FROM_FLOAT(1.13708783741627),    //75
    BP2_FROM_FLOAT(1.13880419739304),    //76
    BP2_FROM_FLOAT(1.14051797443092),    //77
    BP2_FROM_FLOAT(1.14222918015607),    //78
    BP2_FROM_FLOAT(1.1439378261077),    //79
    BP2_FROM_FLOAT(1.14564392373896),    //80
    BP2_FROM_FLOAT(1.14734748441786),    //81
    BP2_FROM_FLOAT(1.14904851942814),    //82
    BP2_FROM_FLOAT(1.15074703997012),    //83
    BP2_FROM_FLOAT(1.15244305716161),    //84
    BP2_FROM_FLOAT(1.15413658203871),    //85
    BP2_FROM_FLOAT(1.15582762555668),    //86
    BP2_FROM_FLOAT(1.15751619859076),    //87
    BP2_FROM_FLOAT(1.15920231193696),    //88
    BP2_FROM_FLOAT(1.16088597631292),    //89
    BP2_FROM_FLOAT(1.16256720235864),    //90
    BP2_FROM_FLOAT(1.16424600063732),    //91
    BP2_FROM_FLOAT(1.1659223816361),    //92
    BP2_FROM_FLOAT(1.16759635576684),    //93
    BP2_FROM_FLOAT(1.16926793336686),    //94
    BP2_FROM_FLOAT(1.1709371246997),    //95
    BP2_FROM_FLOAT(1.17260393995586),    //96
    BP2_FROM_FLOAT(1.1742683892535),    //97
    BP2_FROM_FLOAT(1.17593048263917),    //98
    BP2_FROM_FLOAT(1.17759023008855),    //99
    BP2_FROM_FLOAT(1.17924764150708),    //100
    BP2_FROM_FLOAT(1.1809027267307),    //101
    BP2_FROM_FLOAT(1.18255549552653),    //102
    BP2_FROM_FLOAT(1.18420595759353),    //103
    BP2_FROM_FLOAT(1.18585412256314),    //104
    BP2_FROM_FLOAT(1.1875),    //105
    BP2_FROM_FLOAT(1.18914359940253),    //106
    BP2_FROM_FLOAT(1.1907849302036),    //107
    BP2_FROM_FLOAT(1.19242400177118),    //108
    BP2_FROM_FLOAT(1.19406082340892),    //109
    BP2_FROM_FLOAT(1.19569540435681),    //110
    BP2_FROM_FLOAT(1.19732775379175),    //111
    BP2_FROM_FLOAT(1.19895788082818),    //112
    BP2_FROM_FLOAT(1.20058579451866),    //113
    BP2_FROM_FLOAT(1.20221150385446),    //114
    BP2_FROM_FLOAT(1.20383501776614),    //115
    BP2_FROM_FLOAT(1.20545634512412),    //116
    BP2_FROM_FLOAT(1.20707549473925),    //117
    BP2_FROM_FLOAT(1.20869247536336),    //118
    BP2_FROM_FLOAT(1.21030729568982),    //119
    BP2_FROM_FLOAT(1.21191996435408),    //120
    BP2_FROM_FLOAT(1.21353048993422),    //121
    BP2_FROM_FLOAT(1.21513888095147),    //122
    BP2_FROM_FLOAT(1.21674514587074),    //123
    BP2_FROM_FLOAT(1.21834929310112),    //124
    BP2_FROM_FLOAT(1.21995133099645),    //125
    BP2_FROM_FLOAT(1.22155126785575),    //126
    BP2_FROM_FLOAT(1.22314911192381),    //127
    BP2_FROM_FLOAT(1.22474487139159),    //128
    BP2_FROM_FLOAT(1.22633855439679),    //129
    BP2_FROM_FLOAT(1.22793016902428),    //130
    BP2_FROM_FLOAT(1.22951972330663),    //131
    BP2_FROM_FLOAT(1.23110722522451),    //132
    BP2_FROM_FLOAT(1.23269268270725),    //133
    BP2_FROM_FLOAT(1.23427610363322),    //134
    BP2_FROM_FLOAT(1.23585749583032),    //135
    BP2_FROM_FLOAT(1.23743686707646),    //136
    BP2_FROM_FLOAT(1.23901422509994),    //137
    BP2_FROM_FLOAT(1.24058957757995),    //138
    BP2_FROM_FLOAT(1.24216293214699),    //139
    BP2_FROM_FLOAT(1.24373429638327),    //140
    BP2_FROM_FLOAT(1.2453036778232),    //141
    BP2_FROM_FLOAT(1.24687108395375),    //142
    BP2_FROM_FLOAT(1.24843652221489),    //143
    BP2_FROM_FLOAT(1.25),    //144
    BP2_FROM_FLOAT(1.2515615246563),    //145
    BP2_FROM_FLOAT(1.25312110348521),    //146
    BP2_FROM_FLOAT(1.2546787437428),    //147
    BP2_FROM_FLOAT(1.25623445264011),    //148
    BP2_FROM_FLOAT(1.25778823734363),    //149
    BP2_FROM_FLOAT(1.25934010497562),    //150
    BP2_FROM_FLOAT(1.2608900626145),    //151
    BP2_FROM_FLOAT(1.26243811729526),    //152
    BP2_FROM_FLOAT(1.26398427600979),    //153
    BP2_FROM_FLOAT(1.26552854570729),    //154
    BP2_FROM_FLOAT(1.26707093329458),    //155
    BP2_FROM_FLOAT(1.26861144563653),    //156
    BP2_FROM_FLOAT(1.27015008955635),    //157
    BP2_FROM_FLOAT(1.27168687183599),    //158
    BP2_FROM_FLOAT(1.27322179921646),    //159
    BP2_FROM_FLOAT(1.2747548783982),    //160
    BP2_FROM_FLOAT(1.27628611604138),    //161
    BP2_FROM_FLOAT(1.2778155187663),    //162
    BP2_FROM_FLOAT(1.27934309315367),    //163
    BP2_FROM_FLOAT(1.28086884574495),    //164
    BP2_FROM_FLOAT(1.2823927830427),    //165
    BP2_FROM_FLOAT(1.28391491151088),    //166
    BP2_FROM_FLOAT(1.2854352375752),    //167
    BP2_FROM_FLOAT(1.28695376762338),    //168
    BP2_FROM_FLOAT(1.28847050800552),    //169
    BP2_FROM_FLOAT(1.28998546503439),    //170
    BP2_FROM_FLOAT(1.29149864498574),    //171
    BP2_FROM_FLOAT(1.29301005409858),    //172
    BP2_FROM_FLOAT(1.2945196985755),    //173
    BP2_FROM_FLOAT(1.29602758458298),    //174
    BP2_FROM_FLOAT(1.29753371825167),    //175
    BP2_FROM_FLOAT(1.29903810567666),    //176
    BP2_FROM_FLOAT(1.3005407529178),    //177
    BP2_FROM_FLOAT(1.30204166599998),    //178
    BP2_FROM_FLOAT(1.30354085091339),    //179
    BP2_FROM_FLOAT(1.30503831361382),    //180
    BP2_FROM_FLOAT(1.30653406002293),    //181
    BP2_FROM_FLOAT(1.30802809602852),    //182
    BP2_FROM_FLOAT(1.30952042748481),    //183
    BP2_FROM_FLOAT(1.31101106021269),    //184
    BP2_FROM_FLOAT(1.3125),    //185
    BP2_FROM_FLOAT(1.31398725260179),    //186
    BP2_FROM_FLOAT(1.31547282374057),    //187
    BP2_FROM_FLOAT(1.31695671910659),    //188
    BP2_FROM_FLOAT(1.31843894435806),    //189
    BP2_FROM_FLOAT(1.31991950512143),    //190
    BP2_FROM_FLOAT(1.32139840699162),    //191
    BP2_FROM_FLOAT(1.3228756555323),    //192
    BP2_FROM_FLOAT(1.32435125627607),    //193
    BP2_FROM_FLOAT(1.32582521472478),    //194
    BP2_FROM_FLOAT(1.32729753634971),    //195
    BP2_FROM_FLOAT(1.32876822659183),    //196
    BP2_FROM_FLOAT(1.33023729086205),    //197
    BP2_FROM_FLOAT(1.33170473454141),    //198
    BP2_FROM_FLOAT(1.33317056298135),    //199
    BP2_FROM_FLOAT(1.33463478150391),    //200
    BP2_FROM_FLOAT(1.336097395402),    //201
    BP2_FROM_FLOAT(1.33755840993954),    //202
    BP2_FROM_FLOAT(1.33901783035178),    //203
    BP2_FROM_FLOAT(1.34047566184545),    //204
    BP2_FROM_FLOAT(1.34193190959899),    //205
    BP2_FROM_FLOAT(1.34338657876279),    //206
    BP2_FROM_FLOAT(1.34483967445938),    //207
    BP2_FROM_FLOAT(1.34629120178363),    //208
    BP2_FROM_FLOAT(1.34774116580299),    //209
    BP2_FROM_FLOAT(1.34918957155768),    //210
    BP2_FROM_FLOAT(1.35063642406089),    //211
    BP2_FROM_FLOAT(1.352081728299),    //212
    BP2_FROM_FLOAT(1.35352548923173),    //213
    BP2_FROM_FLOAT(1.35496771179243),    //214
    BP2_FROM_FLOAT(1.35640840088817),    //215
    BP2_FROM_FLOAT(1.35784756140003),    //216
    BP2_FROM_FLOAT(1.35928519818322),    //217
    BP2_FROM_FLOAT(1.36072131606733),    //218
    BP2_FROM_FLOAT(1.36215591985646),    //219
    BP2_FROM_FLOAT(1.36358901432946),    //220
    BP2_FROM_FLOAT(1.3650206042401),    //221
    BP2_FROM_FLOAT(1.36645069431722),    //222
    BP2_FROM_FLOAT(1.36787928926496),    //223
    BP2_FROM_FLOAT(1.36930639376292),    //224
    BP2_FROM_FLOAT(1.37073201246633),    //225
    BP2_FROM_FLOAT(1.37215615000626),    //226
    BP2_FROM_FLOAT(1.37357881098974),    //227
    BP2_FROM_FLOAT(1.375),    //228
    BP2_FROM_FLOAT(1.37641972159658),    //229
    BP2_FROM_FLOAT(1.37783798031554),    //230
    BP2_FROM_FLOAT(1.37925478066962),    //231
    BP2_FROM_FLOAT(1.38067012714841),    //232
    BP2_FROM_FLOAT(1.3820840242185),    //233
    BP2_FROM_FLOAT(1.38349647632367),    //234
    BP2_FROM_FLOAT(1.38490748788502),    //235
    BP2_FROM_FLOAT(1.38631706330118),    //236
    BP2_FROM_FLOAT(1.38772520694841),    //237
    BP2_FROM_FLOAT(1.3891319231808),    //238
    BP2_FROM_FLOAT(1.39053721633044),    //239
    BP2_FROM_FLOAT(1.39194109070751),    //240
    BP2_FROM_FLOAT(1.3933435506005),    //241
    BP2_FROM_FLOAT(1.39474460027634),    //242
    BP2_FROM_FLOAT(1.39614424398054),    //243
    BP2_FROM_FLOAT(1.39754248593737),    //244
    BP2_FROM_FLOAT(1.39893933034996),    //245
    BP2_FROM_FLOAT(1.4003347814005),    //246
    BP2_FROM_FLOAT(1.40172884325036),    //247
    BP2_FROM_FLOAT(1.40312152004023),    //248
    BP2_FROM_FLOAT(1.40451281589026),    //249
    BP2_FROM_FLOAT(1.40590273490025),    //250
    BP2_FROM_FLOAT(1.40729128114971),    //251
    BP2_FROM_FLOAT(1.40867845869808),    //252
    BP2_FROM_FLOAT(1.41006427158481),    //253
    BP2_FROM_FLOAT(1.41144872382953),    //254
    BP2_FROM_FLOAT(1.41283181943216),    //255
    BP2_FROM_FLOAT(1.4142135623731)      //256
};

#endif

#endif //ENABLE_ALL_ENCOPT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\dectable.cpp ===
/*************************************************************************

Copyright (c) 1998  Microsoft Corporation

Module Name:

	dectable.cpp

Abstract:

	Decoder Huffmane tables 

Author:

	Bruce Lin (blin@microsoft.com) June-1998
	Ming-Chieh Lee (mingcl@microsoft.com) June-1998

Revision History:

*************************************************************************/
#include "bldsetup.h"

#include "xplatform.h"
#include "limits.h"
#include "typedef.hpp"
#include "wmvdec_member.h"

U8_WMV  sm_rgRunAtIndx_HghMt [168] = 
{
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    2,    2,    2,    2,    2,    2,
    2,    2,    3,    3,    3,    3,    3,    3,    3,    4,
    4,    4,    4,    4,    5,    5,    5,    5,    5,    6,
    6,    6,    6,    7,    7,    7,    7,    8,    8,    8,
    9,    9,    9,   10,   10,   10,   11,   11,   11,   12,
   12,   13,   13,   14,   14,   15,   15,   16,   16,   17,
   18,   19,   20,   21,   22,   23,   24,   25,   26,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    1,    1,
    1,    1,    1,    2,    2,    2,    2,    3,    3,    3,
    3,    4,    4,    4,    5,    5,    5,    6,    6,    6,
    7,    7,    8,    8,    9,    9,   10,   10,   11,   11,
   12,   12,   13,   13,   14,   14,   15,   16,   17,   18,
   19,   20,   21,   22,   23,   24,   25,   26,   27,   28,
   29,   30,   31,   32,   33,   34,   35,   36,  
};
I8_WMV  sm_rgLevelAtIndx_HghMt [168] = 
{
    1,    2,    3,    4,    5,    6,    7,    8,    9,   10,
   11,   12,   13,   14,   15,   16,   17,   18,   19,   20,
   21,   22,   23,    1,    2,    3,    4,    5,    6,    7,
    8,    9,   10,   11,    1,    2,    3,    4,    5,    6,
    7,    8,    1,    2,    3,    4,    5,    6,    7,    1,
    2,    3,    4,    5,    1,    2,    3,    4,    5,    1,
    2,    3,    4,    1,    2,    3,    4,    1,    2,    3,
    1,    2,    3,    1,    2,    3,    1,    2,    3,    1,
    2,    1,    2,    1,    2,    1,    2,    1,    2,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    2,    3,    4,    5,    6,    7,    8,    9,    1,    2,
    3,    4,    5,    1,    2,    3,    4,    1,    2,    3,
    4,    1,    2,    3,    1,    2,    3,    1,    2,    3,
    1,    2,    1,    2,    1,    2,    1,    2,    1,    2,
    1,    2,    1,    2,    1,    2,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,
};

U8_WMV  sm_rgRunAtIndxOfIntraY_HghMt [185] = 
{
   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   0,    0,    0,    0,    0,    0,    0,    0,    0,    1,
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    1,    2,    2,    2,    2,    2,    2,
   2,    2,    2,    2,    2,    2,    3,    3,    3,    3,
   3,    3,    3,    3,    3,    3,    3,    4,    4,    4,
   4,    4,    4,    5,    5,    5,    5,    5,    6,    6,
   6,    6,    7,    7,    7,    7,    8,    8,    8,    8,
   9,    9,    9,    9,   10,   10,   10,   11,   11,   11,
  12,   12,   12,   13,   13,   13,   14,   14,   14,   15,
  15,   15,   16,   16,   17,   17,   18,   19,   20,   21,
  22,   23,   24,   25,   26,   27,   28,   29,   30,    0,
   0,    0,    0,    0,    0,    1,    1,    1,    1,    1,
   2,    2,    2,    2,    3,    3,    3,    3,    4,    4,
   4,    5,    5,    6,    6,    7,    7,    8,    8,    9,
   9,   10,   10,   11,   11,   12,   12,   13,   13,   14,
  14,   15,   15,   16,   17,   18,   19,   20,   21,   22,
  23,   24,   25,   26,   27,   28,   29,   30,   31,   32,
  33,   34,   35,   36,   37, 
};
I8_WMV  sm_rgLevelAtIndxOfIntraY_HghMt [185] = 
{
   1,    2,    3,    4,    5,    6,    7,    8,    9,   10,
  11,   12,   13,   14,   15,   16,   17,   18,   19,    1,
   2,    3,    4,    5,    6,    7,    8,    9,   10,   11,
  12,   13,   14,   15,    1,    2,    3,    4,    5,    6,
   7,    8,    9,   10,   11,   12,    1,    2,    3,    4,
   5,    6,    7,    8,    9,   10,   11,    1,    2,    3,
   4,    5,    6,    1,    2,    3,    4,    5,    1,    2,
   3,    4,    1,    2,    3,    4,    1,    2,    3,    4,
   1,    2,    3,    4,    1,    2,    3,    1,    2,    3,
   1,    2,    3,    1,    2,    3,    1,    2,    3,    1,
   2,    3,    1,    2,    1,    2,    1,    1,    1,    1,
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
   2,    3,    4,    5,    6,    1,    2,    3,    4,    5,
   1,    2,    3,    4,    1,    2,    3,    4,    1,    2,
   3,    1,    2,    1,    2,    1,    2,    1,    2,    1,
   2,    1,    2,    1,    2,    1,    2,    1,    2,    1,
   2,    1,    2,    1,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    1,    1,  
};

//Talking
U8_WMV  sm_rgRunAtIndx_Talking [148] = 
{
   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   0,    0,    0,    0,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    2,    2,    2,    2,    2,    3,    3,
   3,    3,    4,    4,    4,    4,    5,    5,    5,    5,
   6,    6,    6,    7,    7,    7,    8,    8,    8,    9,
   9,    9,   10,   10,   10,   11,   11,   11,   12,   12,
  12,   13,   13,   14,   14,   15,   15,   16,   17,   18,
  19,   20,   21,   22,   23,   24,   25,   26,   27,   28,
  29,    0,    0,    0,    0,    0,    1,    1,    1,    1,
   2,    2,    2,    3,    3,    3,    4,    4,    5,    5,
   6,    6,    7,    7,    8,    8,    9,    9,   10,   10,
  11,   11,   12,   12,   13,   13,   14,   14,   15,   15,
  16,   17,   18,   19,   20,   21,   22,   23,   24,   25,
  26,   27,   28,   29,   30,   31,   32,   33,   34,   35,
  36,   37,   38,   39,   40,   41,   42,   43,   
};
I8_WMV  sm_rgLevelAtIndx_Talking [148] = 
{
   1,    2,    3,    4,    5,    6,    7,    8,    9,   10,
  11,   12,   13,   14,    1,    2,    3,    4,    5,    6,
   7,    8,    9,    1,    2,    3,    4,    5,    1,    2,
   3,    4,    1,    2,    3,    4,    1,    2,    3,    4,
   1,    2,    3,    1,    2,    3,    1,    2,    3,    1,
   2,    3,    1,    2,    3,    1,    2,    3,    1,    2,
   3,    1,    2,    1,    2,    1,    2,    1,    1,    1,
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
   1,    1,    2,    3,    4,    5,    1,    2,    3,    4,
   1,    2,    3,    1,    2,    3,    1,    2,    1,    2,
   1,    2,    1,    2,    1,    2,    1,    2,    1,    2,
   1,    2,    1,    2,    1,    2,    1,    2,    1,    2,
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
   1,    1,    1,    1,    1,    1,    1,    1,   
};

U8_WMV  sm_rgRunAtIndxOfIntraY_Talking [132] = 
{
   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   0,    0,    0,    0,    0,    0,    1,    1,    1,    1,
   1,    1,    1,    1,    1,    1,    1,    2,    2,    2,
   2,    2,    2,    2,    2,    3,    3,    3,    3,    3,
   3,    3,    4,    4,    4,    4,    4,    5,    5,    5,
   5,    6,    6,    6,    6,    7,    7,    7,    8,    8,
   8,    9,    9,    9,   10,   10,   10,   11,   11,   11,
  12,   12,   12,   13,   13,   13,   14,   14,   15,   15,
  16,   17,   18,   19,   20,    0,    0,    0,    0,    1,
   1,    1,    1,    2,    2,    2,    3,    3,    3,    4,
   4,    5,    5,    6,    6,    7,    7,    8,    8,    9,
   9,   10,   10,   11,   11,   12,   12,   13,   13,   14,
  15,   16,   17,   18,   19,   20,   21,   22,   23,   24,
  25,   26,   
};
I8_WMV  sm_rgLevelAtIndxOfIntraY_Talking [132] = 
{
   1,    2,    3,    4,    5,    6,    7,    8,    9,   10,
  11,   12,   13,   14,   15,   16,    1,    2,    3,    4,
   5,    6,    7,    8,    9,   10,   11,    1,    2,    3,
   4,    5,    6,    7,    8,    1,    2,    3,    4,    5,
   6,    7,    1,    2,    3,    4,    5,    1,    2,    3,
   4,    1,    2,    3,    4,    1,    2,    3,    1,    2,
   3,    1,    2,    3,    1,    2,    3,    1,    2,    3,
   1,    2,    3,    1,    2,    3,    1,    2,    1,    2,
   1,    1,    1,    1,    1,    1,    2,    3,    4,    1,
   2,    3,    4,    1,    2,    3,    1,    2,    3,    1,
   2,    1,    2,    1,    2,    1,    2,    1,    2,    1,
   2,    1,    2,    1,    2,    1,    2,    1,    2,    1,
   1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
   1,    1,  
};
//MPEG4
I8_WMV  sm_rgLevelAtIndx_MPEG4 [102] = 
{
	1,2,3,4,5,6,7,8,9,10,
	11,12,1,2,3,4,5,6,1,2,
	3,4,1,2,3,1,2,3,1,2,
	3,1,2,3,1,2,1,2,1,2,
	1,2,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,2,
	3,1,2,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,
	1,1	
};

U8_WMV sm_rgRunAtIndx_MPEG4 [102] = 
{
	0,0,0,0,0,0,0,0,0,0,
	0,0,1,1,1,1,1,1,2,2,
	2,2,3,3,3,4,4,4,5,5,
	5,6,6,6,7,7,8,8,9,9,
	10,10,11,12,13,14,15,16,17,18,
	19,20,21,22,23,24,25,26,0,0,
	0,1,1,2,3,4,5,6,7,8,
	9,10,11,12,13,14,15,16,17,18,
	19,20,21,22,23,24,25,26,27,28,
	29,30,31,32,33,34,35,36,37,38,
	39,40
};
I8_WMV  sm_rgLevelAtIndxOfIntraY_MPEG4 [102] = 
{
	1,2,3,4,5,6,7,8,9,10,
	11,12,13,14,15,16,17,18,19,20,
	21,22,23,24,25,26,27,1,2,3,
	4,5,6,7,8,9,10,1,2,3,
	4,5,1,2,3,4,1,2,3,1,
	2,3,1,2,3,1,2,3,1,2,
	1,2,1,1,1,1,1,1,2,3,
	4,5,6,7,8,1,2,3,1,2,
	1,2,1,2,1,2,1,2,1,1,
	1,1,1,1,1,1,1,1,1,1,
	1,1
};

U8_WMV sm_rgRunAtIndxOfIntraY_MPEG4 [102] =
{
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,1,1,1,
	1,1,1,1,1,1,1,2,2,2,
	2,2,3,3,3,3,4,4,4,5,
	5,5,6,6,6,7,7,7,8,8,
	9,9,10,11,12,13,14,0,0,0,
	0,0,0,0,0,1,1,1,2,2,
	3,3,4,4,5,5,6,6,7,8,
	9,10,11,12,13,14,15,16,17,18,
	19,20
};

U8_WMV  sm_uXMvFromIndex_HghMt[1099] =
{
   32,   31,   32,   31,   33,   32,   33,   33,   31,   34,   30,   32,   32,   34,   35,   32,   34,   33,   29,   30,
   30,   32,   31,   31,   33,   35,   35,   33,   31,   29,   29,   33,   34,   30,   31,   28,   36,   30,   34,   32,
   32,   37,   32,   32,   25,   27,   39,   32,   32,   32,   38,   35,   36,   32,   37,   61,   26,   32,   34,   35,
    3,   35,   27,   28,   29,   34,   28,   37,   31,   36,   32,   27,   31,   30,   29,   39,   33,   29,   33,   35,
   25,   25,   29,   33,   31,   31,   31,   33,   32,   30,   32,   32,   41,   39,   33,   36,   32,   28,   34,   36,
   38,   24,   60,   31,   23,   28,   32,   33,   59,   32,   40,   30,    5,   34,   32,   38,   32,   30,   43,    4,
   32,   32,   42,   31,   31,   32,   26,   38,   26,   22,   21,   37,   61,   63,   37,   31,   32,   33,    2,    1,
   23,   33,   41,   27,   35,   30,   38,   23,   33,    3,   28,   34,   34,   27,   41,   29,   39,   35,   36,   29,
   32,   27,   30,   32,   24,   61,   37,   26,   59,   25,   35,   27,   36,   37,   30,   31,   34,   40,    3,   28,
   34,   39,   32,   31,   32,   30,   24,   28,   35,   36,   26,   32,   31,   33,   29,   33,   39,   25,   30,   24,
   35,   59,   29,   34,   25,   30,   21,   35,   43,   40,   32,   29,    5,   28,   31,   62,   33,   33,   25,   31,
   21,   31,   43,   31,   34,   33,   20,   40,   39,   31,   31,   57,   38,   32,   42,   33,   32,   31,   32,   29,
   30,   44,    5,   31,   22,   34,   36,   17,   38,   58,   38,   35,   32,   60,   35,   24,   32,   38,   16,   45,
   42,   32,   31,   29,    4,   30,   17,   40,   46,   48,   63,   32,   42,   19,   41,   22,   28,   36,   45,   33,
   33,   32,   29,    7,   41,   42,   18,   33,   33,   32,   22,   37,    1,   26,   22,   23,   49,   28,   26,   27,
   32,   33,   27,   23,   28,   36,   15,    6,   34,   27,   31,   26,   23,    2,   33,   32,   34,   41,   28,   32,
   41,    0,   36,   38,   34,   31,   47,   32,   17,   31,   39,   33,   37,   51,   30,   47,   32,   50,   32,   19,
   63,   30,   25,   27,   33,   62,   24,   31,   27,   30,   37,   31,   45,   32,   39,   20,   46,   47,   35,   19,
   34,    1,   49,   21,   21,   14,   51,   26,   23,   31,   36,   35,   58,   29,   29,   21,   20,   42,   13,   28,
   12,   40,   31,   33,   39,   60,   32,   44,   33,   31,   28,   37,   29,   32,   30,   49,   43,   28,   39,   25,
   32,   48,    2,   15,   20,   25,   31,   28,   21,   24,   25,   15,   31,   17,   37,   43,   18,   32,   33,   24,
   33,   36,   13,   33,   31,   39,   11,   31,   33,   32,   39,   37,   32,   32,   29,   17,   44,   46,   36,   35,
   26,   37,   58,   32,   34,   38,    8,   38,   38,   22,   29,   25,   16,   35,   32,   35,   33,   43,   18,   46,
   38,   50,   33,   18,   53,   60,   13,   32,   36,   33,   51,   36,   43,   45,   27,   42,   29,   24,   30,   25,
   31,   52,   31,   35,   38,    9,   22,   34,    4,   17,   28,   55,   42,   25,   17,   20,   47,   34,   33,   16,
   40,   25,   16,   30,   53,   29,   10,   11,   14,   26,   33,    4,   35,   44,   26,   16,   31,   26,   34,   38,
   29,   31,   30,   24,   22,   61,   32,    9,   45,   34,   31,   19,    9,   31,   46,   31,   35,   54,   29,   57,
   30,   50,    3,   31,   63,   34,   47,   41,   51,   18,   31,   14,   37,   38,   31,   24,   32,   31,   50,   33,
   31,   54,   27,    9,   33,   23,   19,   32,   29,   29,   33,   28,   47,   49,   30,   47,   33,   27,   25,   54,
   44,   45,   50,   58,   51,   48,   33,   59,   33,   34,   57,   13,   26,   33,   13,   48,   30,   11,    7,   56,
   34,   55,   26,    0,   26,   35,    1,   51,   33,   53,   31,   45,   12,   29,   29,   51,   31,   48,    2,    6,
   34,   30,   28,   33,   60,   40,   27,   46,   31,    9,   35,   29,   31,   39,   55,   46,   19,   37,   62,   34,
   30,   16,   19,   49,   41,   41,   39,   37,   14,    5,   13,   35,   55,   30,   40,   40,   42,    8,   20,   25,
   45,   35,   33,   36,   54,   38,   27,   37,   62,   40,   15,   59,   49,   31,   29,   34,   34,   39,   24,   29,
   25,   29,   21,   29,   10,   61,   33,   49,   35,   34,    3,   38,   39,   29,    7,   41,    1,   35,    4,   23,
   15,   23,   11,   37,   28,   35,   30,   30,   24,    1,   43,   56,    8,   34,   42,   24,   45,   30,   20,   23,
    8,   38,   22,   33,   17,   52,   34,   22,   53,   43,   44,    1,   27,   31,   41,   43,   41,   30,   31,   36,
   30,    5,   55,   31,   33,   30,   40,   23,   15,   29,   34,   34,   59,   34,   30,   11,   13,   38,    5,    0,
   30,   42,    5,   30,   29,   34,   10,   44,   30,   63,   35,   12,    3,   26,   15,   17,   25,   34,   43,   39,
   34,   56,   29,   23,   30,   12,   30,   10,   35,    9,   24,   58,   10,   12,   54,   33,   37,   20,   41,   35,
   29,   18,   61,   30,   40,   24,   39,   53,   62,   26,   29,   33,   34,   53,   49,   21,   27,   11,   63,   20,
   26,   23,    7,   13,    6,   47,   29,   30,    9,   51,   22,   34,   21,   25,   33,   56,   57,   30,   38,   51,
   51,   38,   63,   28,   40,   35,   33,   18,   33,   33,   24,   58,   58,   34,   49,   29,   43,    4,    1,    4,
   42,   35,   35,   30,   17,    5,   56,   61,   25,   37,   36,   55,   28,   35,   29,   50,   48,   52,    2,   42,
   34,   40,   46,   46,   43,   35,   29,   48,   20,   29,   31,   41,    7,   30,   35,   19,   14,   21,    8,   39,
   39,   40,   46,   55,   34,    6,   30,   34,   37,   25,   37,   33,   22,   44,   52,   17,   35,   29,   36,   35,
   40,   37,   28,   30,   50,   14,   28,   55,    6,   23,   19,   14,   30,    3,   30,   28,   28,   61,   61,   47,
   45,   48,   40,   40,   34,   34,   25,   30,   29,   35,    4,   26,   53,   50,   26,   41,   27,   59,   27,   38,
   39,    3,   50,   43,   47,   23,   33,   55,   35,   21,   23,   35,   61,   33,   46,   52,   35,   34,   24,   30,
   43,   16,   37,   21,    2,   24,   45,   34,   30,   55,   55,    1,   29,   29,   26,   28,   25,   31,   36,   22,
   17,   30,   52,    2,   44,   44,   57,   26,   62,   41,   39,   57,   26,   46,   49,   11,   16,   19,    5,   59,
   38,   39,   58,   38,   25,   49,   50,   22,   28,   59,    9,   59,    7,   28,   55,   17,    4,   35,   50,   21,
   29,   44,   47,   18,   24,   19,   25,   42,   35,    3,   51,   35,   16,   35,   30,   63,   57,   39,   39,   25,
   35,   38,    9,   16,   36,   45,   31,   60,   14,   34,   42,   24,    0,   37,   18,   61,   57,   37,   28,   53,
   20,   46,   14,   47,   38,   38,   38,    9,   34,   39,   43,   17,   39,   59,    5,   27,    0,   12,   27,
};
U8_WMV  sm_uYMvFromIndex_HghMt [1099] = 
{
   32,   32,   31,   31,   32,   33,   31,   33,   33,   32,   32,   30,   34,   31,   32,   29,   33,   30,   32,   33,
   31,   35,   34,   30,   34,   31,   33,   29,   29,   31,   33,   35,   30,   30,   35,   32,   32,   34,   34,   28,
   25,   32,   36,   27,   32,   32,   32,   37,   39,    3,   32,   30,   31,   26,   31,   32,   32,   38,   29,   29,
   32,   34,   31,   31,   34,   35,   33,   33,   28,   33,    1,   33,   27,   29,   30,   31,   28,   29,   37,   35,
   31,   33,   35,   27,   36,   37,   25,   25,   61,   35,    4,    5,   32,   33,   36,   30,   23,   30,   28,   34,
   31,   32,   32,   39,   32,   34,   21,   39,   32,   59,   32,   28,   32,   36,   60,   33,   24,   36,   32,   32,
   41,    2,   32,   38,   26,   22,   33,   30,   31,   32,   32,   30,   31,   32,   29,    3,   40,   38,   32,   32,
   33,   26,   31,   34,   28,   38,   34,   31,    3,   31,   35,   38,   27,   35,   33,   28,   29,   27,   29,   27,
   43,   29,   37,   63,   31,   33,   34,   30,   31,   30,   37,   30,   35,   35,   26,   41,   37,   31,   33,   28,
   26,   30,   42,   24,    7,   27,   33,   29,   36,   28,   34,   57,   23,   41,   36,   23,   35,   34,   25,   30,
   25,   33,   25,   25,   29,   24,   33,   39,   33,   33,    0,   37,   31,   36,   21,   32,   61,   24,   35,   61,
   31,    5,   31,   59,   39,   21,   32,   30,   34,   22,   40,   32,   29,   16,   31,    5,   62,    2,   20,   39,
   39,   32,   33,    1,   31,   24,   36,   32,   36,   32,   28,   26,    6,   31,   38,   34,   58,   35,   32,   33,
   33,   17,   43,   26,   31,   40,   31,   34,   32,   32,   31,   19,   30,   32,   29,   33,   38,   38,   32,   59,
   40,   18,   38,   32,   35,   34,   32,   17,    1,   15,   30,   28,   31,   28,   34,   29,   32,   27,   35,   27,
   49,   22,   37,   34,   37,   26,   32,   32,   22,   28,   45,   29,   30,   31,   43,   46,   41,   30,   26,   13,
   34,   32,   27,   38,   42,   42,   33,   47,   33,   60,   27,   42,   25,   32,   22,   32,   48,   32,   45,   33,
   33,   41,   27,   25,   19,   31,   35,   19,   36,   42,   27,   17,   31,   44,   28,   33,   33,   31,   23,   31,
   40,   33,   31,   34,   30,   32,   33,   36,   35,   47,   37,   41,   31,   23,   41,   29,   30,   35,   32,   25,
   32,   28,   58,    2,   37,   33,   14,   33,   49,   20,   39,   36,   21,    9,   23,   33,   35,   24,   39,   37,
   11,   33,   30,   31,   31,   28,   51,   40,   35,   29,   25,   33,   46,   35,   37,   30,   30,    8,   63,   28,
   15,   40,   33,   45,   49,   25,   32,    4,   47,   51,   36,   39,   53,   10,   24,   29,   30,   31,   25,   40,
   38,   38,   33,   56,   23,   27,   32,   37,   26,   29,   43,   36,   33,   24,   55,   43,    9,   29,   34,   34,
   24,   33,   18,   33,   33,   30,   31,   50,   24,   60,   30,   39,   34,   30,   39,   28,   22,   38,    2,   26,
   63,   32,   57,   21,   39,   33,   28,   18,   30,   34,   22,   33,   29,   41,   30,   34,   35,   21,   13,   34,
   35,   39,   30,   46,   32,   42,   32,   31,   33,   26,   11,   33,   22,   31,   25,   31,   53,   27,   43,   25,
   40,   50,   21,   36,   38,   30,   12,   31,   34,   20,   15,   29,   32,   62,   30,   13,   17,   32,   19,   31,
   20,   31,   30,    7,    1,   17,   34,   37,   31,   31,   44,   34,   26,   40,   16,   37,   52,   48,   30,   20,
   18,   33,   38,   29,    7,   25,   30,   54,   45,   47,   46,   41,   29,   29,   16,   30,   14,   26,   38,   34,
   34,   29,   34,   30,   29,   30,   57,   30,    4,   46,   33,   29,   39,   44,   30,   31,   50,   33,   31,   32,
   19,   32,   40,   31,   37,   47,    1,   35,   16,   31,    0,   35,   33,    1,   17,   34,    9,   34,   33,   31,
   49,   43,   42,   51,   34,   29,   23,   29,   14,   30,   45,   49,   11,   24,   31,   28,   35,   41,   30,   44,
   18,   29,   34,   35,   36,   25,   26,   21,   31,   30,   34,   19,   34,   44,   36,   38,   25,   31,   28,   23,
   37,    3,   55,   41,   30,   22,   41,   24,   33,   26,   35,   35,   30,   55,   51,   47,   48,   38,   24,   15,
   21,   50,   25,   46,   30,   29,   10,   34,   42,   45,   29,   42,   22,    3,   33,   27,   34,    1,   34,   28,
   34,   36,   35,   23,   23,   13,   58,    3,   26,   63,   25,   31,   34,   61,   38,   39,   25,   61,   29,   37,
   30,   41,   26,   48,   28,   33,   50,   35,   30,   37,   29,   29,   40,    6,   39,   28,   28,   19,    8,   22,
   45,   34,   35,   10,   58,   17,   37,   39,   30,   18,   54,   14,   29,   16,   59,   30,   35,   23,   35,   30,
   47,   36,   29,   55,   20,   12,   31,   35,   14,   29,   18,   34,   34,   24,   29,   26,   22,    2,   27,   23,
    8,   30,   55,   38,   60,   31,    4,   34,   49,   34,   27,   34,   33,   30,   31,   54,   42,   35,   38,   46,
   44,   26,   27,    9,   39,   25,   21,   29,   28,   42,   13,    0,    5,   34,   37,   28,   24,   29,   63,   26,
   22,   27,   29,   25,   33,   25,   61,    0,   35,   25,   36,   15,   27,   40,   53,   33,    3,   10,   16,   37,
   38,   18,   30,   46,   27,    9,    6,   29,   62,    8,   42,   28,   29,    3,   25,   16,   26,   29,   35,   28,
   27,   51,   61,   48,   37,    9,   34,    7,   49,   45,   20,   29,   21,    5,    5,   29,   28,   34,   29,   24,
   10,   24,   35,   36,   38,   55,   11,   36,   38,   53,   54,   26,   30,   49,   20,   27,   30,   39,   33,   41,
   49,   22,   38,   38,    4,   30,    8,    9,    3,   24,   22,   50,   37,   36,   31,   27,    2,    9,   42,   63,
   25,   19,   44,    1,   28,   28,   48,   30,   34,   41,   41,   38,   12,   27,   15,    0,   16,   34,   35,   38,
   28,   29,   40,   42,   51,   52,   45,   54,   59,   59,   42,   44,   37,   26,   46,   24,   15,   39,   22,   46,
   19,   35,   38,   17,   37,   23,   52,   55,   50,   37,   26,   11,   37,   12,   24,   30,   16,   13,   22,   13,
   36,   35,   40,   41,   34,   41,   26,   53,   51,    5,   21,   30,    2,   63,   41,   20,    1,   56,   21,   24,
   25,    5,   28,   35,   26,   28,   30,   18,   29,   23,   40,   34,   20,   42,   39,   34,   28,   61,   38,   27,
   62,    9,   36,   17,    9,   49,   24,   25,   54,   34,   39,   37,    3,    1,   25,   38,   38,   44,   35,   36,
   12,   60,   36,   38,   40,   25,   43,   39,   53,   28,   39,   57,   46,   10,   52,   27,   35,   42,   45,   59,
   15,   60,   38,   24,   23,   39,   12,   29,   24,    0,   20,   16,   28,   43,   35,   28,    1,   49,    4,   21,
   42,   39,   29,    3,   44,   21,   53,   55,   11,    5,    3,   39,   53,   28,   25,   19,   34,   28,   21,
};

U8_WMV  sm_uXMvFromIndex_Talking [1099] = 
{
   32,   32,   31,   32,   33,   31,   33,   31,   33,   32,   34,   32,   30,   32,   31,   34,   35,   32,   34,   33,
   29,   33,   30,   30,   31,   31,   35,   29,   33,   35,   33,   34,   31,   29,   30,   34,   30,   36,   28,   32,
   34,   37,   30,   27,   32,   25,   39,   32,   34,   32,   35,   35,   35,   31,   35,   29,   32,   29,   30,   29,
   37,   27,   36,   38,   37,   33,   32,   31,   29,   31,   28,   36,   33,   30,   34,   33,   33,   28,   27,   25,
   31,   26,   39,   32,   32,   31,   33,   39,   31,   38,   28,   36,   21,   23,   43,   36,   34,   41,   30,   25,
   28,   31,   30,   34,   38,   35,   61,   34,   28,   30,   37,   37,   35,   27,   36,    3,   59,   38,   37,   32,
   31,   29,   26,   33,   37,   33,   27,   27,   35,   34,   34,   40,   42,   33,   32,   29,    4,    5,   28,   24,
   25,   35,   39,   38,   32,   23,   27,   32,   30,   35,   26,   34,   60,   36,   29,   22,   26,   41,    7,   30,
   38,   30,   36,   29,   30,   41,   26,   25,   32,   34,   24,   39,    1,   25,   39,   32,   28,   29,   32,   38,
   26,   36,   28,   63,   28,   39,   23,   21,   26,   35,   31,   35,   57,   31,   29,   29,   28,   30,   27,   35,
    2,   38,   40,   34,   37,   29,   38,   43,   26,   32,   33,   42,   24,   40,   28,   32,   32,   32,   36,   32,
   43,   25,   21,   31,   30,   31,   41,   29,   33,   37,   26,   37,   27,   59,   23,   33,   35,   31,   31,   37,
   38,   39,   32,   23,   32,   27,   37,   36,   31,   40,   25,   27,   38,   31,   36,   28,   31,   36,   25,   45,
    3,   34,   38,   39,   40,   38,   30,   32,   19,   24,   25,   26,   45,   20,   24,   33,   33,   31,   41,   34,
   39,   47,   40,   58,   59,   41,   33,    3,   17,   61,   42,   30,   26,   29,   36,   61,   33,   37,   62,   28,
   25,   38,   25,   38,   17,   23,   34,   33,   21,   33,   49,   27,   32,   23,   27,   22,   24,   22,   39,   43,
   27,   37,    6,   42,   47,   26,   30,   31,   41,   39,   33,   22,   45,   36,   32,   45,   19,   22,   30,    5,
    5,   17,   29,   22,   31,   31,   43,   37,   27,   32,   32,   32,   33,   34,   43,   35,   29,   26,   22,   32,
   19,   32,   25,   31,   41,   49,   28,   34,   28,   39,   34,   19,   37,   38,   29,   21,   36,   42,   24,   48,
   16,   28,   49,   22,   34,   31,   38,   39,   44,   11,   35,   30,   33,   33,   23,   28,   33,   46,   15,   13,
   24,   41,   24,   34,   34,   30,   26,   24,   14,   60,   21,   29,   39,   23,   35,   37,   63,   45,   33,   34,
   47,   41,   22,   42,   35,   35,   23,   32,   35,   43,   32,    7,   31,   41,   20,   31,   16,   13,   63,   25,
   30,   32,   35,   30,   30,   31,   42,   47,   39,   38,   40,   40,   51,   55,   56,   18,   21,   39,   39,   33,
   17,   41,   23,   24,   43,   25,   31,   20,   19,   45,    1,   34,   31,   22,   35,   15,   46,   46,   35,   31,
   28,   29,   29,   23,   41,   27,   14,   53,   53,   27,   24,   32,   57,   32,   17,   42,   37,   29,   33,    1,
   25,   32,   32,   63,   26,   40,   44,   36,   31,   39,   20,   20,   44,   23,   33,   34,   35,   33,   33,   28,
   41,   23,   41,   41,   29,   25,   26,   49,   29,   24,   37,   49,   50,   51,   51,   26,   39,   25,   26,   15,
   39,   18,   42,   17,    4,   31,   32,   32,   60,    1,   42,   32,    0,   12,   19,   35,   21,   41,   17,   26,
   20,   45,   46,   32,   37,   22,   47,   29,   31,   27,   29,   30,   21,   33,   35,   18,   25,   33,   50,   51,
   42,    2,   15,   51,   53,   33,   25,   29,   55,   37,   38,   33,   38,   59,   38,   33,   39,   13,   32,   40,
   61,   61,   32,    9,   44,    3,   31,   29,   25,   31,   27,   23,    9,   25,    9,   29,   20,   30,   30,   42,
   18,   28,   25,   28,   28,   21,   29,   43,   29,   43,   26,   44,   44,   21,   38,   21,   24,   45,   45,   35,
   39,   22,   35,   36,   34,   34,   45,   34,   29,   31,   46,   25,   46,   16,   17,   31,   20,   32,   47,   47,
   47,   32,   49,   49,   49,   31,    1,   27,   28,   39,   39,   21,   36,   23,   51,    2,   40,   51,   32,   53,
   24,   30,   24,   30,   21,   40,   57,   57,   31,   41,   58,   32,   12,    4,   32,   34,   59,   31,   32,   13,
    9,   35,   26,   35,   37,   61,   37,   63,   26,   29,   41,   38,   23,   20,   41,   26,   41,   42,   42,   42,
   26,   26,   26,   26,    1,   26,   37,   37,   37,   23,   34,   42,   27,   43,   34,   27,   31,   24,   33,   16,
    3,   31,   24,   33,   24,    4,   44,   44,   11,   44,   31,   13,   13,   44,   45,   13,   25,   22,   38,   26,
   38,   38,   39,   32,   30,   39,   30,   22,   32,   26,   30,   47,   47,   47,   19,   47,   30,   31,   35,    8,
   23,   47,   47,   27,   35,   47,   31,   48,   35,   19,   36,   49,   49,   33,   31,   39,   27,   39,   49,   49,
   50,   50,   50,   39,   31,   51,   51,   39,   28,   33,   33,   21,   40,   31,   52,   53,   40,   53,    9,   33,
   31,   53,   54,   54,   54,   55,   55,   34,   15,   56,   25,   56,   21,   21,   40,   40,   25,   40,   58,   36,
    5,   41,   41,   12,   60,   41,   41,   37,   22,   61,   18,   29,   29,   30,   61,   30,   61,   62,   62,   30,
   30,   63,   18,   13,   30,   23,   19,   20,   20,   41,   13,    2,    5,    5,    1,    5,   32,    6,   32,   35,
   20,   35,   27,   35,   35,   36,   36,   13,   36,   41,   41,   41,    3,   30,   42,   27,   20,   30,   27,   28,
   30,   21,   33,   33,   14,   24,   30,   42,   24,   33,   25,   42,   43,   14,   43,   43,   14,   43,    7,   36,
   37,   37,   37,   37,    7,   14,   25,   43,   43,   44,   15,   37,    7,    7,    3,    1,    8,   15,   15,    8,
   44,   44,   44,   45,   45,   45,   45,    8,    8,   45,   21,   45,   28,   28,   28,   21,   28,   28,   22,   37,
   46,   46,   37,    8,   29,   37,   29,   22,   46,   37,   22,   29,   47,   47,   38,   38,   16,   38,   38,   33,
   38,   22,   47,   47,   29,   25,   16,    0,   48,    1,   34,   48,   48,   34,   25,   26,   26,   49,   49,   26,
    1,   49,    4,   26,    4,   49,    1,    9,   49,   49,   49,   10,   49,   17,   38,   17,   17,   50,   38,   50,
   50,   22,   38,   51,   38,   38,   51,   39,   39,   18,   22,   39,   51,   22,   52,   52,   52,   39,   53,   53,
   10,   23,   18,   29,   10,   53,   29,   54,   11,   54,   11,   11,   55,    1,   18,   55,   55,   55,   55,   55,
   55,   29,   34,   18,   29,   56,   56,   34,   57,   34,   34,   29,   29,   57,   57,   35,   35,   35,   35,   35,
   39,   35,   59,   59,   18,   59,   39,   30,   18,   40,   60,   60,   61,   30,   18,   61,   61,   19,   19,
};
U8_WMV  sm_uYMvFromIndex_Talking [1099] = 
{
   32,   31,   32,   33,   32,   31,   31,   33,   33,   34,   32,   30,   32,   35,   34,   31,   32,   29,   33,   30,
   32,   34,   33,   31,   30,   35,   31,   31,   29,   33,   35,   30,   29,   33,   34,   34,   30,   32,   32,   36,
   29,   32,   35,   32,   28,   32,   32,   27,   35,   37,   34,   29,   30,   36,   35,   34,   25,   30,   29,   35,
   33,   31,   31,   32,   31,   28,   39,   28,   29,   37,   31,   33,   27,   36,   28,   36,   37,   33,   33,   31,
   27,   32,   31,   38,   26,   25,   25,   33,   39,   31,   34,   30,   32,   32,   32,   34,   36,   32,   28,   33,
   30,   38,   37,   27,   33,   28,   32,   37,   35,   38,   29,   34,   27,   29,   29,   32,   32,   34,   35,    3,
   26,   36,   31,   38,   30,   26,   35,   34,   37,   26,   25,   32,   32,   39,   23,   37,   32,   32,   29,   32,
   29,   36,   29,   30,   41,   31,   30,   21,   39,   25,   34,   38,   32,   35,   39,   32,   33,   33,   32,   27,
   29,   25,   28,   27,   26,   31,   30,   35,   24,   24,   31,   34,   32,   30,   35,   40,   28,   38,    5,   35,
   29,   36,   36,   32,   38,   30,   33,   31,   35,   26,   23,   38,   32,   41,   28,   25,   37,   40,   37,   39,
   32,   36,   33,   39,   25,   26,   28,   31,   28,   42,   23,   31,   33,   31,   39,    1,   59,   22,   27,    4,
   33,   34,   33,   24,   41,    3,   35,   41,   41,   28,   36,   36,   28,   33,   35,   21,   23,   21,   22,   37,
   27,   27,   43,   29,   60,   39,   27,   25,   59,   34,   27,   27,   26,   40,   37,   27,   61,   26,   39,   33,
   31,   22,   37,   25,   30,   25,   24,   61,   31,   34,   25,   38,   32,   32,   30,    3,   61,   43,   29,   23,
   28,   32,   28,   32,   31,   34,    5,   33,   32,   33,   33,   42,   37,   23,   38,   31,   40,   26,   32,   26,
   37,   38,   36,   24,   29,   30,   20,   22,   29,   24,   32,   41,    2,   34,   25,   33,   29,   31,   39,   35,
   36,   24,   32,   30,   33,   27,   44,   60,   30,   36,   19,   34,   31,   24,   16,   35,   32,   38,   21,   33,
   31,   31,   21,   35,    5,   17,   29,   38,   38,   18,   58,   19,   43,   41,   30,   41,   43,   39,   29,    7,
   29,   17,   28,   19,   28,   31,   25,   19,   40,   26,   21,   33,   39,   23,   40,   30,   39,   34,   35,   32,
   32,   24,   33,   30,   40,   47,   39,   37,   32,   33,   24,   23,   45,   47,   27,   23,   42,   32,   32,   33,
   36,   37,   37,   17,   18,   22,   40,   38,   32,   31,   35,   24,   17,   25,   17,   23,   33,   34,   51,   42,
   31,   36,   36,   29,   21,   22,   37,   44,   43,   25,   47,   33,   45,   27,   31,   58,   31,   32,   31,   38,
   43,   20,   47,   45,   54,    1,   26,   34,   38,   14,   22,   24,   33,   34,   32,   32,   37,   21,   23,   49,
   35,   23,   28,   39,   39,   23,   55,   33,   30,   30,   63,   16,   42,   28,   13,   33,   33,   35,   19,   46,
   43,   17,   19,   36,   39,   24,   31,   32,   33,   26,   28,   62,   33,   63,   33,   39,   19,   49,   17,   31,
   43,   13,   15,   29,   25,   35,   33,   23,   49,   41,   28,   29,   34,   38,    7,   61,   11,   50,   13,   41,
   19,   47,   25,   26,   15,   42,   41,   29,   45,   27,   17,   35,   32,   29,   32,   24,   13,   26,   26,   31,
   24,   33,   28,   30,   31,   11,   45,   46,   33,   33,   35,   57,   32,   32,   35,   45,   34,   11,   37,   42,
   39,   37,   31,   49,   21,   27,   29,   47,   53,   40,   51,   16,   26,    1,   40,   30,   41,   44,   34,   25,
   27,   31,   35,   35,   31,   15,   49,    1,   35,   40,    5,   58,   21,   29,   22,   59,   45,   31,    9,   26,
    9,   29,   11,   32,   30,    3,   13,   20,   18,   20,   11,    3,   29,   40,   31,   53,   30,   17,   20,   37,
   31,   42,   47,   47,   54,   38,    9,   34,   13,   37,   21,   25,   27,   43,   42,   45,   40,   25,   27,   46,
   22,   25,   53,   20,    2,   14,   39,   15,   22,   44,   34,   21,   38,   33,   27,   48,   34,   52,   35,   47,
   49,   54,    2,   13,   23,   52,   29,   45,   22,   49,   54,   21,   40,   42,   31,   30,   29,   34,    0,   25,
   23,   51,   24,   59,   28,   38,   29,   31,    2,   13,   31,    8,   31,   33,   12,   45,   41,    7,   14,   30,
   25,   18,   43,   20,   43,   35,   44,    1,   49,   42,   42,   18,   41,   38,   41,   44,   53,   11,   20,   25,
   45,   46,   47,   48,   39,   52,   46,   49,   63,   55,   44,   38,   13,   13,   57,   22,   51,   16,   12,   28,
   35,   57,   25,   20,   26,   28,   28,   29,   32,   31,   62,   34,   35,   35,   19,   49,   48,   39,   40,   18,
   43,   46,   11,    6,   48,   19,   49,   41,   10,   23,   58,   17,   21,   23,   34,   30,   60,    0,   44,   34,
   26,   37,   46,   43,   49,   59,    4,   34,   59,   37,   22,   25,   28,   46,    6,   40,   59,   42,   36,   61,
   28,   30,   31,   43,   10,   22,   23,   47,   20,   52,   55,   36,   25,   16,    1,   11,   27,   29,    5,   63,
   18,   41,   31,   34,   38,    1,    5,   13,   28,   31,   17,   38,   39,   41,   36,   37,   22,   39,   33,   43,
   43,   15,   17,   49,   30,   21,   22,   20,   10,   17,   25,   54,   57,    3,   34,    8,   36,   25,   31,   14,
   15,   19,   29,   25,   18,   39,   53,   22,   27,   20,   29,   33,   41,   42,   35,   62,   50,   29,   53,   50,
   35,   55,   42,   61,   63,    4,    7,   42,   21,   46,   47,   49,   27,   46,   17,   55,   41,   50,   63,    4,
   56,   18,    8,   10,   18,   51,   63,   36,   55,   18,    5,   55,    9,   29,   17,   21,   30,   27,    1,   59,
    7,   11,   12,   15,    5,   42,   24,   41,   43,    7,   27,   22,   25,   31,   30,   37,   22,   39,   53,   29,
   36,   37,   48,    0,    5,   13,   17,   31,   32,   26,   46,   28,   44,   45,   46,   53,   49,   51,    3,   41,
    3,   22,   42,   33,    5,   45,    7,   22,   40,   53,   24,   14,   25,   27,   10,   12,   34,   16,   17,   53,
   20,   26,   39,   45,   18,   45,   35,   33,   31,   49,    4,   39,   42,   11,   51,    5,   13,   26,   27,   17,
   52,   30,    0,   22,   12,   34,   62,   36,   38,   41,   47,   30,   63,   38,   41,   43,   59,   33,   45,   37,
   38,   40,   47,   24,   48,   49,   30,    1,   10,   22,   49,   15,   39,   59,   31,   32,   33,   18,   13,   15,
   31,   21,   27,   44,   42,   39,   46,   17,   26,   32,   30,   31,    0,   30,   34,    9,   12,   13,   25,   31,
   32,   55,   43,   35,   61,   33,   35,   46,   25,   47,   48,   62,   63,   38,   61,    1,    2,    5,    7,    9,
   46,   10,   34,   35,   36,   55,   51,    7,   40,   23,   34,   37,    5,   13,   42,   18,   25,   27,   28,
};

// HGHMT_DCTAC
tPackHuffmanCode_WMV sm_HufDCTACInterTable_HghMt[170] = 
{  // 169*2
   169,     0,
     0,     3,
     3,     4,
    11,     5,
    20,     6,
    63,     6,
    93,     7,
   162,     8,
   172,     9,
   366,     9,
   522,    10,
   738,    10,
  1074,    11,
  1481,    11,
  2087,    12,
  2900,    12,
  1254,    13,
  4191,    13,
  5930,    13,
  8370,    14,
 11598,    14,
 14832,    14,
 16757,    15,
 23198,    15,
     4,     4,
    30,     5,
    66,     7,
   182,     8,
   371,     9,
   917,    10,
  1838,    11,
  2964,    12,
  5796,    13,
  8371,    14,
 11845,    14,
     5,     5,
    64,     7,
    73,     9,
   655,    10,
  1483,    11,
  1162,    13,
  2525,    14,
 29666,    15,
    24,     5,
    37,     8,
   138,    10,
  1307,    11,
  3679,    12,
  2505,    14,
  5020,    15,
    41,     6,
    79,     9,
  1042,    11,
  1165,    13,
 11841,    14,
    56,     6,
   270,     9,
  1448,    11,
  4188,    13,
 14834,    14,
    88,     7,
   543,    10,
  3710,    12,
 14847,    14,
    35,     8,
   739,    10,
  1253,    13,
 11840,    14,
   161,     8,
  1470,    11,
  2504,    14,
   131,     8,
   314,    11,
  5921,    13,
    68,     9,
   630,    12,
 14838,    14,
   139,    10,
  1263,    13,
 23195,    15,
   520,    10,
  7422,    13,
   921,    10,
  7348,    13,
   926,    10,
 14835,    14,
  1451,    11,
 29667,    15,
  1847,    11,
 23199,    15,
  2093,    12,
  3689,    12,
  3688,    12,
  1075,    11,
  2939,    12,
 11768,    14,
 11862,    14,
 11863,    14,
 14839,    14,
 20901,    15,
     3,     3,
    42,     6,
   228,     8,
   654,    10,
  1845,    11,
  4184,    13,
  7418,    13,
 11769,    14,
 16756,    15,
     9,     4,
    84,     8,
   920,    10,
  1163,    13,
  5021,    15,
    13,     4,
   173,     9,
  2086,    12,
 11596,    14,
    17,     5,
   363,     9,
  2943,    12,
 20900,    15,
    25,     5,
   539,    10,
  5885,    13,
    29,     5,
   916,    10,
 10451,    14,
    43,     6,
  1468,    11,
 23194,    15,
    47,     6,
   583,    12,
    16,     7,
  2613,    12,
    62,     6,
  2938,    12,
    89,     7,
  4190,    13,
    38,     8,
  2511,    14,
    85,     8,
  7349,    13,
    87,     8,
  3675,    12,
   160,     8,
  5224,    13,
   368,     9,
   144,    10,
   462,     9,
   538,    10,
   536,    10,
   360,     9,
   542,    10,
   580,    12,
  1846,    11,
   312,    11,
  1305,    11,
  3678,    12,
  1836,    11,
  2901,    12,
  2524,    14,
  8379,    14,
  1164,    13,
  5923,    13,
 11844,    14,
  5797,    13,
  1304,    11,
 14846,    14,
   361,     9,	
};

tPackHuffmanCode_WMV sm_HufDCTACIntraTable_HghMt[187] = 
{  // 186 * 2
   186,     0,
     1,     2,
     5,     3,
    13,     4,
    18,     5,
    14,     6,
    21,     7,
    19,     8,
    63,     8,
    75,     9,
   287,     9,
   184,    10,
   995,    10,
   370,    11,
   589,    12,
   986,    12,
   733,    13,
  8021,    13,
  1465,    14,
 16046,    14,
     0,     4,
    16,     5,
     8,     7,
    32,     8,
    41,     9,
   500,     9,
   563,    10,
   480,    11,
   298,    12,
   989,    12,
  1290,    13,
  7977,    13,
  2626,    14,
  4722,    15,
  5943,    15,
     3,     5,
    17,     7,
   196,     8,
    75,    10,
   180,    11,
  2004,    11,
   837,    12,
   727,    13,
  1983,    13,
  2360,    14,
  3003,    14,
  2398,    15,
    19,     5,
   120,     7,
   105,     9,
   562,    10,
  1121,    11,
  1004,    12,
  1312,    13,
  7978,    13,
 15952,    14,
 15953,    14,
  5254,    15,
    12,     6,
    36,     9,
   148,    11,
  2240,    12,
  3849,    14,
  7920,    15,
    61,     6,
    83,     9,
   416,    11,
   726,    13,
  3848,    14,
    19,     7,
   124,     9,
  1985,    11,
  1196,    14,
    27,     7,
   160,    10,
   836,    12,
  3961,    14,
   121,     7,
   993,    10,
   724,    13,
  8966,    14,
    33,     8,
   572,    10,
  4014,    12,
  9182,    14,
    53,     8,
   373,    11,
  1971,    13,
   197,     8,
   372,    11,
  1925,    13,
    72,     9,
   419,    11,
  1182,    13,
    44,     9,
   250,    10,
  2006,    11,
   146,    10,
  1484,    13,
  7921,    15,
   163,    10,
  1005,    12,
  2366,    14,
   482,    11,
  4723,    15,
  1988,    11,
  5255,    15,
   657,    12,
   659,    12,
  3978,    12,
  1289,    13,
  1288,    13,
  1933,    13,
  1982,    13,
  1932,    13,
  1198,    14,
  3002,    14,
  8967,    14,
  2970,    14,
  5942,    15,
    14,     4,
    69,     7,
   499,     9,
  1146,    11,
  1500,    13,
  9183,    14,
    25,     5,
    40,     9,
   374,    11,
  1181,    13,
  9181,    14,
    48,     6,
   162,    10,
   751,    12,
  1464,    14,
    63,     6,
   165,    10,
   987,    12,
  2367,    14,
    68,     7,
  1995,    11,
  2399,    15,
    99,     7,
   963,    12,
    21,     8,
  2294,    12,
    23,     8,
  1176,    13,
    44,     8,
  1970,    13,
    47,     8,
  8020,    13,
   141,     8,
  1981,    13,
   142,     8,
  4482,    13,
   251,     8,
  1291,    13,
    45,     8,
  1984,    11,
   121,     9,
  8031,    13,
   122,     9,
  8022,    13,
   561,    10,
   996,    10,
   417,    11,
   323,    11,
   503,    11,
   367,    12,
   658,    12,
   743,    12,
   364,    12,
   365,    12,
   988,    12,
  3979,    12,
  1177,    13,
   984,    12,
  1934,    13,
   725,    13,
  8030,    13,
  7979,    13,
  1935,    13,
  1197,    14,
 16047,    14,
  9180,    14,
    74,     9,
};

tPackHuffmanCode_WMV  sm_HufDCTACInterTable_Talking[150] = 
{  // 149 * 2
	149,    0,
     4,     3,
    20,     5,
    23,     7,
   127,     8,
   340,     9,
   498,    10,
   191,    11,
   101,    12,
  2730,    12,
  1584,    13,
  5527,    13,
   951,    14,
 11042,    14,
  3046,    15,
    11,     4,
    55,     7,
    98,     9,
     7,    11,
   358,    12,
   206,    13,
  5520,    13,
  1526,    14,
  3047,    15,
     7,     5,
   109,     8,
     3,    11,
   799,    12,
  1522,    14,
     2,     6,
    97,     9,
    85,    12,
   479,    14,
    26,     6,
    30,    10,
  2761,    12,
 11043,    14,
    30,     6,
    31,    10,
  2755,    12,
 11051,    14,
     6,     7,
     4,    11,
   760,    13,
    25,     7,
     6,    11,
  1597,    13,
    87,     7,
   386,    11,
 10914,    14,
     4,     8,
   384,    11,
  1436,    14,
   125,     8,
   356,    12,
  1901,    15,
     2,     9,
   397,    11,
  5505,    13,
   173,     8,
    96,    12,
  3175,    14,
    28,     9,
   238,    13,
     3,     9,
   719,    13,
   217,     9,
  5504,    13,
     2,    11,
   387,    11,
    87,    12,
    97,    12,
    49,    11,
   102,    12,
  1585,    13,
  1586,    13,
   172,    13,
   797,    12,
   118,    12,
    58,    11,
   357,    12,
  3174,    14,
     3,     2,
    84,     7,
   683,    10,
    22,    13,
  1527,    14,
     5,     4,
   248,     9,
  2729,    12,
    95,    15,
     4,     4,
    28,    10,
  5456,    13,
     4,     5,
   119,    11,
  1900,    15,
    14,     5,
    10,    12,
    12,     5,
  1378,    11,
     4,     6,
   796,    12,
     6,     6,
   200,    13,
    13,     6,
   474,    13,
     7,     6,
   201,    13,
     1,     7,
    46,    14,
    20,     7,
  5526,    13,
    10,     7,
  2754,    12,
    22,     7,
   347,    14,
    21,     7,
   346,    14,
    15,     8,
    94,    15,
   126,     8,
   171,     8,
    45,     9,
   216,     9,
    11,     9,
    20,    10,
   691,    10,
   499,    10,
    58,    10,
     0,    10,
    88,    10,
    46,     9,
    94,    10,
  1379,    11,
   236,    12,
    84,    12,
  2753,    12,
  5462,    13,
   762,    13,
   385,    11,
  5463,    13,
  1437,    14,
 10915,    14,
 11050,    14,
   478,    14,
  1596,    13,
   207,    13,
  5524,    13,
    13,     9,
};

tPackHuffmanCode_WMV sm_HufDCTACIntraTable_Talking[134] = 
{  // 133 * 2
	133,   0,
    1,     2,
    6,     3,
   15,     4,
   22,     5,
   32,     6,
   24,     7,
    8,     8,
  154,     8,
   86,     9,
  318,     9,
  240,    10,
  933,    10,
  119,    11,
  495,    11,
  154,    12,
   93,    13,
    1,     4,
   17,     5,
    2,     7,
   11,     8,
   18,     9,
  470,     9,
  638,    10,
  401,    11,
  234,    12,
  988,    12,
  315,    13,
    4,     5,
   20,     7,
  158,     8,
    9,    10,
  428,    11,
  482,    11,
  970,    12,
   95,    13,
   23,     5,
   78,     7,
   94,     9,
  243,    10,
  429,    11,
  236,    12,
 1520,    13,
   14,     6,
  225,     8,
  932,    10,
  156,    12,
  317,    13,
   59,     6,
   28,     9,
   20,    11,
 2494,    12,
    6,     7,
  122,     9,
  400,    11,
  311,    13,
   27,     7,
    8,    10,
 1884,    11,
  113,     7,
  215,    10,
 2495,    12,
    7,     8,
  175,    10,
 1228,    11,
   52,     8,
  613,    10,
  159,    12,
  224,     8,
   22,    11,
  807,    12,
   21,     9,
  381,    11,
 3771,    12,
   20,     9,
  246,    10,
  484,    11,
  203,    10,
 2461,    12,
  202,    10,
  764,    12,
  383,    11,
 1229,    11,
  765,    12,
 1278,    11,
  314,    13,
   10,     4,
   66,     7,
  467,     9,
 1245,    11,
   18,     5,
  232,     8,
   76,    11,
  310,    13,
   57,     6,
  612,    10,
 3770,    12,
    0,     7,
  174,    10,
 2460,    12,
   31,     7,
 1246,    11,
   67,     7,
 1244,    11,
    3,     8,
  971,    12,
    6,     8,
 2462,    12,
   42,     8,
 1521,    13,
   15,     8,
 2558,    12,
   51,     8,
 2559,    12,
  152,     8,
 2463,    12,
  234,     8,
  316,    13,
   46,     8,
  402,    11,
  310,     9,
  106,     9,
   21,    11,
  943,    10,
  483,    11,
  116,    11,
  235,    12,
  761,    12,
   92,    13,
  237,    12,
  989,    12,
  806,    12,
   94,    13,
   22,     7,
};

//MPEG4
tPackHuffmanCode_WMV sm_HufDCTACInterTable_MPEG4 [104] = 
{ //207 = 103 * 2 + 1
 103,   0,
   2,   2,
  15,   4,
  21,   6,
  23,   7,
  31,   8,
  37,   9,
  36,   9,
  33,  10,
  32,  10,
   7,  11,
   6,  11,
  32,  11,
   6,   3,
  20,   6,
  30,   8,
  15,  10,
  33,  11,
  80,  12,
  14,   4,
  29,   8,
  14,  10,
  81,  12,
  13,   5,
  35,   9,
  13,  10,
  12,   5,
  34,   9,
  82,  12,
  11,   5,
  12,  10,
  83,  12,
  19,   6,
  11,  10,
  84,  12,
  18,   6,
  10,  10,
  17,   6,
   9,  10,
  16,   6,
   8,  10,
  22,   7,
  85,  12,
  21,   7,
  20,   7,
  28,   8,
  27,   8,
  33,   9,
  32,   9,
  31,   9,
  30,   9,
  29,   9,
  28,   9,
  27,   9,
  26,   9,
  34,  11,
  35,  11,
  86,  12,
  87,  12,
   7,   4,
  25,   9,
   5,  11,
  15,   6,
   4,  11,
  14,   6,
  13,   6,
  12,   6,
  19,   7,
  18,   7,
  17,   7,
  16,   7,
  26,   8,
  25,   8,
  24,   8,
  23,   8,
  22,   8,
  21,   8,
  20,   8,
  19,   8,
  24,   9,
  23,   9,
  22,   9,
  21,   9,
  20,   9,
  19,   9,
  18,   9,
  17,   9,
   7,  10,
   6,  10,
   5,  10,
   4,  10,
  36,  11,
  37,  11,
  38,  11,
  39,  11,
  88,  12,
  89,  12,
  90,  12,
  91,  12,
  92,  12,
  93,  12,
  94,  12,
  95,  12,
   3,   7,
}; 
tPackHuffmanCode_WMV sm_HufDCTACIntraTable_MPEG4 [104] = 
{ //207 = 103 * 2 + 1
 103,   0,
   2,   2,
   6,   3,
  15,   4,
  13,   5,
  12,   5,
  21,   6,
  19,   6,
  18,   6,
  23,   7,
  31,   8,
  30,   8,
  29,   8,
  37,   9,
  36,   9,
  35,   9,
  33,   9,
  33,  10,
  32,  10,
  15,  10,
  14,  10,
   7,  11,
   6,  11,
  32,  11,
  33,  11,
  80,  12,
  81,  12,
  82,  12,
  14,   4,
  20,   6,
  22,   7,
  28,   8,
  32,   9,
  31,   9,
  13,  10,
  34,  11,
  83,  12,
  85,  12,
  11,   5,
  21,   7,
  30,   9,
  12,  10,
  86,  12,
  17,   6,
  27,   8,
  29,   9,
  11,  10,
  16,   6,
  34,   9,
  10,  10,
  13,   6,
  28,   9,
   8,  10,
  18,   7,
  27,   9,
  84,  12,
  20,   7,
  26,   9,
  87,  12,
  25,   8,
   9,  10,
  24,   8,
  35,  11,
  23,   8,
  25,   9,
  24,   9,
   7,  10,
  88,  12,
   7,   4,
  12,   6,
  22,   8,
  23,   9,
   6,  10,
   5,  11,
   4,  11,
  89,  12,
  15,   6,
  22,   9,
   5,  10,
  14,   6,
   4,  10,
  17,   7,
  36,  11,
  16,   7,
  37,  11,
  19,   7,
  90,  12,
  21,   8,
  91,  12,
  20,   8,
  19,   8,
  26,   8,
  21,   9,
  20,   9,
  19,   9,
  18,   9,
  17,   9,
  38,  11,
  39,  11,
  92,  12,
  93,  12,
  94,  12,
  95,  12,
   3,   7,
};
tPackHuffmanCode_WMV sm_HufMVTable_HghMt[1101] = 
{
  1100,    0,
    0,     2, 
    7,     4, 
    9,     4, 
   15,     4, 
   10,     5, 
   17,     5, 
   26,     5, 
   28,     5, 
   17,     6, 
   49,     6, 
   37,     7, 
   45,     7, 
   47,     7, 
  111,     7, 
  117,     7, 
   65,     8, 
   76,     8, 
   78,     8, 
   92,     8, 
   96,     8, 
   98,     8, 
  102,     8, 
  104,     8, 
  105,     8, 
  107,     8, 
  166,     8, 
  193,     8, 
  203,     8, 
  204,     8, 
  206,     8, 
  218,     8, 
  232,     8, 
  238,     8, 
  135,     9, 
  144,     9, 
  158,     9, 
  159,     9, 
  186,     9, 
  202,     9, 
  216,     9, 
  219,     9, 
  223,     9, 
  260,     9, 
  265,     9, 
  268,     9, 
  323,     9, 
  325,     9, 
  330,     9, 
  342,     9, 
  348,     9, 
  435,     9, 
  467,     9, 
  474,     9, 
  259,    10, 
  265,    10, 
  267,    10, 
  290,    10, 
  295,    10, 
  308,    10, 
  353,    10, 
  356,    10, 
  374,    10, 
  388,    10, 
  397,    10, 
  398,    10, 
  399,    10, 
  400,    10, 
  403,    10, 
  406,    10, 
  413,    10, 
  414,    10, 
  415,    10, 
  425,    10, 
  434,    10, 
  436,    10, 
  442,    10, 
  443,    10, 
  444,    10, 
  513,    10, 
  514,    10, 
  517,    10, 
  519,    10, 
  525,    10, 
  528,    10, 
  529,    10, 
  533,    10, 
  539,    10, 
  543,    10, 
  641,    10, 
  645,    10, 
  656,    10, 
  668,    10, 
  669,    10, 
  674,    10, 
  679,    10, 
  680,    10, 
  682,    10, 
  688,    10, 
  689,    10, 
  692,    10, 
  700,    10, 
  703,    10, 
  800,    10, 
  806,    10, 
  807,    10, 
  809,    10, 
  810,    10, 
  822,    10, 
  864,    10, 
  866,    10, 
  867,    10, 
  882,    10, 
  946,    10, 
  956,    10, 
  957,    10, 
  515,    11, 
  517,    11, 
  538,    11, 
  585,    11, 
  586,    11, 
  588,    11, 
  711,    11, 
  714,    11, 
  718,    11, 
  751,    11, 
  781,    11, 
  802,    11, 
  805,    11, 
  824,    11, 
  883,    11, 
  890,    11, 
 1033,    11, 
 1045,    11, 
 1046,    11, 
 1048,    11, 
 1064,    11, 
 1069,    11, 
 1071,    11, 
 1076,    11, 
 1288,    11, 
 1289,    11, 
 1296,    11, 
 1297,    11, 
 1308,    11, 
 1310,    11, 
 1316,    11, 
 1345,    11, 
 1347,    11, 
 1350,    11, 
 1351,    11, 
 1357,    11, 
 1367,    11, 
 1375,    11, 
 1386,    11, 
 1388,    11, 
 1389,    11, 
 1391,    11, 
 1398,    11, 
 1399,    11, 
 1402,    11, 
 1403,    11, 
 1404,    11, 
 1405,    11, 
 1536,    11, 
 1537,    11, 
 1539,    11, 
 1556,    11, 
 1558,    11, 
 1559,    11, 
 1564,    11, 
 1567,    11, 
 1602,    11, 
 1608,    11, 
 1609,    11, 
 1610,    11, 
 1611,    11, 
 1623,    11, 
 1640,    11, 
 1641,    11, 
 1643,    11, 
 1646,    11, 
 1663,    11, 
 1730,    11, 
 1736,    11, 
 1739,    11, 
 1758,    11, 
 1759,    11, 
 1762,    11, 
 1763,    11, 
 1775,    11, 
 1864,    11, 
 1867,    11, 
 1902,    11, 
 1903,    11, 
 1916,    11, 
 1033,    12, 
 1059,    12, 
 1064,    12, 
 1065,    12, 
 1066,    12, 
 1067,    12, 
 1074,    12, 
 1075,    12, 
 1174,    12, 
 1178,    12, 
 1237,    12, 
 1243,    12, 
 1409,    12, 
 1410,    12, 
 1419,    12, 
 1420,    12, 
 1421,    12, 
 1432,    12, 
 1433,    12, 
 1434,    12, 
 1438,    12, 
 1501,    12, 
 1561,    12, 
 1586,    12, 
 1587,    12, 
 1608,    12, 
 1650,    12, 
 1697,    12, 
 1698,    12, 
 1699,    12, 
 1711,    12, 
 1762,    12, 
 1763,    12, 
 1764,    12, 
 2048,    12, 
 2049,    12, 
 2050,    12, 
 2051,    12, 
 2074,    12, 
 2075,    12, 
 2089,    12, 
 2095,    12, 
 2098,    12, 
 2110,    12, 
 2111,    12, 
 2130,    12, 
 2131,    12, 
 2136,    12, 
 2155,    12, 
 2167,    12, 
 2168,    12, 
 2169,    12, 
 2170,    12, 
 2171,    12, 
 2560,    12, 
 2561,    12, 
 2573,    12, 
 2574,    12, 
 2575,    12, 
 2596,    12, 
 2615,    12, 
 2618,    12, 
 2619,    12, 
 2622,    12, 
 2630,    12, 
 2631,    12, 
 2634,    12, 
 2635,    12, 
 2655,    12, 
 2681,    12, 
 2682,    12, 
 2683,    12, 
 2688,    12, 
 2689,    12, 
 2692,    12, 
 2693,    12, 
 2713,    12, 
 2725,    12, 
 2726,    12, 
 2744,    12, 
 2746,    12, 
 2747,    12, 
 2748,    12, 
 2749,    12, 
 2760,    12, 
 2766,    12, 
 2767,    12, 
 2775,    12, 
 2780,    12, 
 2795,    12, 
 3076,    12, 
 3109,    12, 
 3110,    12, 
 3111,    12, 
 3114,    12, 
 3115,    12, 
 3130,    12, 
 3131,    12, 
 3132,    12, 
 3133,    12, 
 3232,    12, 
 3245,    12, 
 3284,    12, 
 3285,    12, 
 3324,    12, 
 3325,    12, 
 3462,    12, 
 3474,    12, 
 3475,    12, 
 3476,    12, 
 3477,    12, 
 3504,    12, 
 3512,    12, 
 3513,    12, 
 3514,    12, 
 3515,    12, 
 3520,    12, 
 3522,    12, 
 3523,    12, 
 3546,    12, 
 3547,    12, 
 3548,    12, 
 3549,    12, 
 3730,    12, 
 3731,    12, 
 3732,    12, 
 3733,    12, 
 3783,    12, 
 3788,    12, 
 3790,    12, 
 3791,    12, 
 3800,    12, 
 3801,    12, 
 3802,    12, 
 3803,    12, 
 2056,    13, 
 2057,    13, 
 2058,    13, 
 2064,    13, 
 2065,    13, 
 2116,    13, 
 2117,    13, 
 2145,    13, 
 2146,    13, 
 2147,    13, 
 2156,    13, 
 2338,    13, 
 2339,    13, 
 2350,    13, 
 2351,    13, 
 2358,    13, 
 2359,    13, 
 2481,    13, 
 2482,    13, 
 2483,    13, 
 2484,    13, 
 2485,    13, 
 2488,    13, 
 2489,    13, 
 2490,    13, 
 2491,    13, 
 2492,    13, 
 2493,    13, 
 2494,    13, 
 2495,    13, 
 2816,    13, 
 2837,    13, 
 2860,    13, 
 2861,    13, 
 2862,    13, 
 2863,    13, 
 2870,    13, 
 3001,    13, 
 3112,    13, 
 3114,    13, 
 3115,    13, 
 3116,    13, 
 3117,    13, 
 3118,    13, 
 3119,    13, 
 3120,    13, 
 3121,    13, 
 3128,    13, 
 3168,    13, 
 3169,    13, 
 3170,    13, 
 3171,    13, 
 3213,    13, 
 3214,    13, 
 3215,    13, 
 3218,    13, 
 3262,    13, 
 3263,    13, 
 3302,    13, 
 3303,    13, 
 3392,    13, 
 3393,    13, 
 3415,    13, 
 3416,    13, 
 3417,    13, 
 3418,    13, 
 3419,    13, 
 3420,    13, 
 3421,    13, 
 3480,    13, 
 3481,    13, 
 3482,    13, 
 3483,    13, 
 3484,    13, 
 3485,    13, 
 3501,    13, 
 3502,    13, 
 3503,    13, 
 3520,    13, 
 3521,    13, 
 3522,    13, 
 3523,    13, 
 3530,    13, 
 3531,    13, 
 3564,    13, 
 3565,    13, 
 3566,    13, 
 3567,    13, 
 4120,    13, 
 4130,    13, 
 4131,    13, 
 4144,    13, 
 4145,    13, 
 4146,    13, 
 4147,    13, 
 4176,    13, 
 4177,    13, 
 4188,    13, 
 4212,    13, 
 4213,    13, 
 4214,    13, 
 4215,    13, 
 4216,    13, 
 4217,    13, 
 4218,    13, 
 4219,    13, 
 4274,    13, 
 4275,    13, 
 4280,    13, 
 4281,    13, 
 4282,    13, 
 4283,    13, 
 4308,    13, 
 4330,    13, 
 4331,    13, 
 4332,    13, 
 4333,    13, 
 5124,    13, 
 5125,    13, 
 5126,    13, 
 5127,    13, 
 5136,    13, 
 5137,    13, 
 5138,    13, 
 5139,    13, 
 5140,    13, 
 5141,    13, 
 5142,    13, 
 5143,    13, 
 5144,    13, 
 5145,    13, 
 5222,    13, 
 5223,    13, 
 5224,    13, 
 5225,    13, 
 5226,    13, 
 5227,    13, 
 5228,    13, 
 5229,    13, 
 5246,    13, 
 5247,    13, 
 5256,    13, 
 5257,    13, 
 5258,    13, 
 5259,    13, 
 5302,    13, 
 5303,    13, 
 5304,    13, 
 5305,    13, 
 5306,    13, 
 5307,    13, 
 5308,    13, 
 5309,    13, 
 5360,    13, 
 5361,    13, 
 5368,    13, 
 5369,    13, 
 5370,    13, 
 5371,    13, 
 5372,    13, 
 5373,    13, 
 5374,    13, 
 5375,    13, 
 5418,    13, 
 5419,    13, 
 5420,    13, 
 5421,    13, 
 5422,    13, 
 5423,    13, 
 5424,    13, 
 5425,    13, 
 5448,    13, 
 5449,    13, 
 5454,    13, 
 5455,    13, 
 5464,    13, 
 5465,    13, 
 5466,    13, 
 5467,    13, 
 5490,    13, 
 5530,    13, 
 5531,    13, 
 5548,    13, 
 5562,    13, 
 5563,    13, 
 5584,    13, 
 5585,    13, 
 5586,    13, 
 5587,    13, 
 5588,    13, 
 5589,    13, 
 6173,    13, 
 6174,    13, 
 6175,    13, 
 6208,    13, 
 6209,    13, 
 6210,    13, 
 6211,    13, 
 6212,    13, 
 6213,    13, 
 6214,    13, 
 6215,    13, 
 6216,    13, 
 6217,    13, 
 6241,    13, 
 6242,    13, 
 6243,    13, 
 6244,    13, 
 6245,    13, 
 6246,    13, 
 6247,    13, 
 6248,    13, 
 6249,    13, 
 6250,    13, 
 6251,    13, 
 6252,    13, 
 6253,    13, 
 6254,    13, 
 6427,    13, 
 6428,    13, 
 6429,    13, 
 6430,    13, 
 6431,    13, 
 6466,    13, 
 6467,    13, 
 6468,    13, 
 6469,    13, 
 6470,    13, 
 6471,    13, 
 6488,    13, 
 6489,    13, 
 6637,    13, 
 6638,    13, 
 6639,    13, 
 6640,    13, 
 6641,    13, 
 6642,    13, 
 6643,    13, 
 6644,    13, 
 6645,    13, 
 6646,    13, 
 6647,    13, 
 6926,    13, 
 6927,    13, 
 7010,    13, 
 7011,    13, 
 7012,    13, 
 7013,    13, 
 7014,    13, 
 7015,    13, 
 7016,    13, 
 7017,    13, 
 7018,    13, 
 7019,    13, 
 7020,    13, 
 7021,    13, 
 7022,    13, 
 7023,    13, 
 7042,    13, 
 7080,    13, 
 7081,    13, 
 7082,    13, 
 7083,    13, 
 7084,    13, 
 7085,    13, 
 7086,    13, 
 7087,    13, 
 7088,    13, 
 7089,    13, 
 7090,    13, 
 7091,    13, 
 7552,    13, 
 7553,    13, 
 7554,    13, 
 7555,    13, 
 7556,    13, 
 7557,    13, 
 7558,    13, 
 7559,    13, 
 7560,    13, 
 7561,    13, 
 7562,    13, 
 7563,    13, 
 7564,    13, 
 7565,    13, 
 4103,    14, 
 4104,    14, 
 4105,    14, 
 4106,    14, 
 4107,    14, 
 4108,    14, 
 4109,    14, 
 4110,    14, 
 4111,    14, 
 4118,    14, 
 4224,    14, 
 4225,    14, 
 4226,    14, 
 4227,    14, 
 4228,    14, 
 4229,    14, 
 4230,    14, 
 4231,    14, 
 4288,    14, 
 4666,    14, 
 4667,    14, 
 4668,    14, 
 4669,    14, 
 4670,    14, 
 4671,    14, 
 4672,    14, 
 4673,    14, 
 4674,    14, 
 4675,    14, 
 4944,    14, 
 4946,    14, 
 4947,    14, 
 4952,    14, 
 4953,    14, 
 4954,    14, 
 4955,    14, 
 4956,    14, 
 4957,    14, 
 4958,    14, 
 4959,    14, 
 4960,    14, 
 4961,    14, 
 5634,    14, 
 5635,    14, 
 5644,    14, 
 5645,    14, 
 5646,    14, 
 5647,    14, 
 5664,    14, 
 5665,    14, 
 5666,    14, 
 5667,    14, 
 5668,    14, 
 5669,    14, 
 5670,    14, 
 5671,    14, 
 5672,    14, 
 5673,    14, 
 5742,    14, 
 5743,    14, 
 5756,    14, 
 5757,    14, 
 5758,    14, 
 5759,    14, 
 6000,    14, 
 6001,    14, 
 6226,    14, 
 6227,    14, 
 6258,    14, 
 6259,    14, 
 6260,    14, 
 6261,    14, 
 6262,    14, 
 6263,    14, 
 6264,    14, 
 6265,    14, 
 6266,    14, 
 6267,    14, 
 6268,    14, 
 6269,    14, 
 6270,    14, 
 6271,    14, 
 6424,    14, 
 6425,    14, 
 6438,    14, 
 6439,    14, 
 6512,    14, 
 6513,    14, 
 6514,    14, 
 6515,    14, 
 6516,    14, 
 6517,    14, 
 6518,    14, 
 6519,    14, 
 6520,    14, 
 6521,    14, 
 6522,    14, 
 6523,    14, 
 6816,    14, 
 6817,    14, 
 6818,    14, 
 6819,    14, 
 6820,    14, 
 6821,    14, 
 6822,    14, 
 6823,    14, 
 6824,    14, 
 6825,    14, 
 6826,    14, 
 6827,    14, 
 6828,    14, 
 6829,    14, 
 6972,    14, 
 6973,    14, 
 6974,    14, 
 6975,    14, 
 6992,    14, 
 6993,    14, 
 6994,    14, 
 6995,    14, 
 6996,    14, 
 6997,    14, 
 6998,    14, 
 6999,    14, 
 7000,    14, 
 7001,    14, 
 8242,    14, 
 8243,    14, 
 8244,    14, 
 8245,    14, 
 8246,    14, 
 8247,    14, 
 8248,    14, 
 8249,    14, 
 8250,    14, 
 8251,    14, 
 8252,    14, 
 8253,    14, 
 8254,    14, 
 8255,    14, 
 8256,    14, 
 8257,    14, 
 8258,    14, 
 8259,    14, 
 8378,    14, 
 8379,    14, 
 8396,    14, 
 8397,    14, 
 8398,    14, 
 8399,    14, 
 8416,    14, 
 8417,    14, 
 8418,    14, 
 8419,    14, 
 8420,    14, 
 8421,    14, 
 8422,    14, 
 8423,    14, 
 8618,    14, 
 8619,    14, 
 8640,    14, 
 8641,    14, 
 8642,    14, 
 8643,    14, 
 8644,    14, 
 8645,    14, 
 8646,    14, 
 8647,    14, 
 8648,    14, 
 8649,    14, 
 8650,    14, 
 8651,    14, 
 8652,    14, 
 8653,    14, 
 8654,    14, 
 8655,    14, 
 8656,    14, 
 8657,    14, 
 8658,    14, 
 8659,    14, 
10388,    14, 
10389,    14, 
10390,    14, 
10391,    14, 
10392,    14, 
10393,    14, 
10394,    14, 
10395,    14, 
10396,    14, 
10397,    14, 
10398,    14, 
10399,    14, 
10432,    14, 
10433,    14, 
10434,    14, 
10435,    14, 
10436,    14, 
10437,    14, 
10438,    14, 
10439,    14, 
10440,    14, 
10441,    14, 
10442,    14, 
10443,    14, 
10544,    14, 
10545,    14, 
10546,    14, 
10547,    14, 
10548,    14, 
10549,    14, 
10550,    14, 
10551,    14, 
10552,    14, 
10553,    14, 
10554,    14, 
10555,    14, 
10556,    14, 
10557,    14, 
10558,    14, 
10559,    14, 
10592,    14, 
10593,    14, 
10594,    14, 
10595,    14, 
10596,    14, 
10597,    14, 
10598,    14, 
10599,    14, 
10600,    14, 
10601,    14, 
10602,    14, 
10603,    14, 
10816,    14, 
10817,    14, 
10818,    14, 
10819,    14, 
10820,    14, 
10821,    14, 
10822,    14, 
10823,    14, 
10824,    14, 
10825,    14, 
10826,    14, 
10827,    14, 
10828,    14, 
10829,    14, 
10830,    14, 
10831,    14, 
10832,    14, 
10833,    14, 
10834,    14, 
10835,    14, 
10982,    14, 
10983,    14, 
11044,    14, 
11045,    14, 
11046,    14, 
11047,    14, 
11048,    14, 
11049,    14, 
11050,    14, 
11051,    14, 
11052,    14, 
11053,    14, 
11054,    14, 
11055,    14, 
11056,    14, 
11057,    14, 
11058,    14, 
11059,    14, 
11098,    14, 
11099,    14, 
12308,    14, 
12309,    14, 
12310,    14, 
12311,    14, 
12320,    14, 
12321,    14, 
12322,    14, 
12323,    14, 
12324,    14, 
12325,    14, 
12326,    14, 
12327,    14, 
12328,    14, 
12329,    14, 
12330,    14, 
12331,    14, 
12332,    14, 
12333,    14, 
12334,    14, 
12335,    14, 
12336,    14, 
12337,    14, 
12338,    14, 
12339,    14, 
12340,    14, 
12341,    14, 
12342,    14, 
12343,    14, 
12344,    14, 
12345,    14, 
12480,    14, 
12481,    14, 
12510,    14, 
12511,    14, 
12824,    14, 
12825,    14, 
12826,    14, 
12827,    14, 
12828,    14, 
12829,    14, 
12830,    14, 
12831,    14, 
12832,    14, 
12833,    14, 
12834,    14, 
12835,    14, 
12836,    14, 
12837,    14, 
12838,    14, 
12839,    14, 
12840,    14, 
12841,    14, 
12842,    14, 
12843,    14, 
12844,    14, 
12845,    14, 
12846,    14, 
12847,    14, 
12848,    14, 
12849,    14, 
12850,    14, 
12851,    14, 
12852,    14, 
12853,    14, 
13176,    14, 
13177,    14, 
13178,    14, 
13179,    14, 
13180,    14, 
13181,    14, 
13182,    14, 
13183,    14, 
13248,    14, 
13249,    14, 
13250,    14, 
13251,    14, 
13252,    14, 
13253,    14, 
13254,    14, 
13255,    14, 
13256,    14, 
13257,    14, 
13258,    14, 
13259,    14, 
13260,    14, 
13261,    14, 
13262,    14, 
13263,    14, 
13264,    14, 
13265,    14, 
13266,    14, 
13267,    14, 
13268,    14, 
13269,    14, 
13270,    14, 
13271,    14, 
13272,    14, 
13273,    14, 
14086,    14, 
14087,    14, 
14128,    14, 
14129,    14, 
14130,    14, 
14131,    14, 
14132,    14, 
14133,    14, 
14134,    14, 
14135,    14, 
14136,    14, 
14137,    14, 
14138,    14, 
14139,    14, 
14140,    14, 
14141,    14, 
14142,    14, 
14143,    14, 
14144,    14, 
14145,    14, 
14146,    14, 
14147,    14, 
14148,    14, 
14149,    14, 
14150,    14, 
14151,    14, 
14152,    14, 
14153,    14, 
14154,    14, 
14155,    14, 
14156,    14, 
14157,    14, 
14158,    14, 
14159,    14, 
15156,    14, 
15157,    14, 
15158,    14, 
15159,    14, 
15336,    14, 
15337,    14, 
15338,    14, 
15339,    14, 
15340,    14, 
15341,    14, 
15342,    14, 
15343,    14, 
15344,    14, 
15345,    14, 
15346,    14, 
15347,    14, 
15348,    14, 
15349,    14, 
15350,    14, 
15351,    14, 
15352,    14, 
15353,    14, 
15354,    14, 
15355,    14, 
15356,    14, 
15357,    14, 
15358,    14, 
15359,    14, 
 8192,    15, 
 8193,    15, 
 8194,    15, 
 8195,    15, 
 8196,    15, 
 8197,    15, 
 8198,    15, 
 8199,    15, 
 8200,    15, 
 8201,    15, 
 8202,    15, 
 8203,    15, 
 8204,    15, 
 8205,    15, 
 8238,    15, 
 8239,    15, 
 8578,    15, 
 8579,    15, 
 8628,    15, 
 8629,    15, 
 8630,    15, 
 8631,    15, 
 8632,    15, 
 8633,    15, 
 8634,    15, 
 8635,    15, 
 8636,    15, 
 8637,    15, 
 8638,    15, 
 8639,    15, 
 9312,    15, 
 9313,    15, 
 9314,    15, 
 9315,    15, 
 9316,    15, 
 9317,    15, 
 9318,    15, 
 9319,    15, 
 9320,    15, 
 9321,    15, 
 9322,    15, 
 9323,    15, 
 9324,    15, 
 9325,    15, 
 9326,    15, 
 9327,    15, 
 9328,    15, 
 9329,    15, 
 9330,    15, 
 9331,    15, 
 9890,    15, 
 9891,    15, 
   11,     4, 
};

tPackHuffmanCode_WMV sm_HufMVTable_Talking [1101] = 
{
	1100,  0,
    1,     1, 
    3,     4, 
    5,     4, 
    7,     4, 
    3,     5, 
    8,     5, 
   12,     5, 
    1,     6, 
    2,     6, 
   27,     6, 
    6,     7, 
   11,     7, 
   21,     7, 
    2,     8, 
   14,     8, 
   15,     8, 
   20,     8, 
   32,     8, 
   34,     8, 
   37,     8, 
   39,     8, 
   41,     8, 
   45,     8, 
   75,     8, 
   77,     8, 
    3,     9, 
   34,     9, 
   35,     9, 
   37,     9, 
   39,     9, 
   66,     9, 
   72,     9, 
   73,     9, 
   80,     9, 
   92,     9, 
  145,     9, 
  159,     9, 
   14,    10, 
   67,    10, 
   76,    10, 
   84,    10, 
   86,    10, 
  140,    10, 
  152,    10, 
  154,    10, 
  155,    10, 
  177,    10, 
  178,    10, 
  288,    10, 
  289,    10, 
  294,    10, 
  307,    10, 
  313,    10, 
  417,    10, 
  420,    10, 
  421,    10, 
  422,    10, 
  423,    10, 
  430,    10, 
  431,    10, 
   11,    11, 
   25,    11, 
  133,    11, 
  144,    11, 
  155,    11, 
  170,    11, 
  175,    11, 
  268,    11, 
  270,    11, 
  284,    11, 
  286,    11, 
  307,    11, 
  324,    11, 
  352,    11, 
  372,    11, 
  373,    11, 
  375,    11, 
  376,    11, 
  585,    11, 
  587,    11, 
  594,    11, 
  609,    11, 
  613,    11, 
  624,    11, 
  850,    11, 
  851,    11, 
  853,    11, 
  857,    11, 
   16,    12, 
   17,    12, 
   19,    12, 
   52,    12, 
   53,    12, 
   54,    12, 
   55,    12, 
   61,    12, 
   62,    12, 
  265,    12, 
  294,    12, 
  342,    12, 
  538,    12, 
  542,    12, 
  570,    12, 
  574,    12, 
  654,    12, 
  655,    12, 
  719,    12, 
 1169,    12, 
 1172,    12, 
 1183,    12, 
 1184,    12, 
 1187,    12, 
 1190,    12, 
 1191,    12, 
 1197,    12, 
 1198,    12, 
 1216,    12, 
 1220,    12, 
 1222,    12, 
 1224,    12, 
 1225,    12, 
 1269,    12, 
 1270,    12, 
 1271,    12, 
 1664,    12, 
 1666,    12, 
 1667,    12, 
 1672,    12, 
 1673,    12, 
 1677,    12, 
 1678,    12, 
 1679,    12, 
 1698,    12, 
 1699,    12, 
 1705,    12, 
 1712,    12, 
 1713,    12, 
 1716,    12, 
 1717,    12, 
   36,    13, 
   96,    13, 
   99,    13, 
  120,    13, 
  121,    13, 
  529,    13, 
  580,    13, 
  581,    13, 
  583,    13, 
  584,    13, 
  585,    13, 
  586,    13, 
  587,    13, 
  619,    13, 
  687,    13, 
  696,    13, 
  699,    13, 
 1078,    13, 
 1142,    13, 
 1143,    13, 
 1150,    13, 
 1224,    13, 
 1225,    13, 
 1226,    13, 
 1300,    13, 
 1414,    13, 
 1415,    13, 
 1432,    13, 
 1437,    13, 
 1497,    13, 
 1498,    13, 
 2336,    13, 
 2337,    13, 
 2363,    13, 
 2364,    13, 
 2365,    13, 
 2370,    13, 
 2371,    13, 
 2372,    13, 
 2373,    13, 
 2393,    13, 
 2398,    13, 
 2399,    13, 
 2434,    13, 
 2435,    13, 
 2446,    13, 
 2447,    13, 
 2500,    13, 
 2535,    13, 
 2536,    13, 
 2537,    13, 
 3330,    13, 
 3351,    13, 
 3352,    13, 
 3353,    13, 
 3393,    13, 
 3394,    13, 
 3395,    13, 
 3408,    13, 
 3423,    13, 
 3437,    13, 
 3438,    13, 
 3439,    13, 
   82,    14, 
   83,    14, 
   84,    14, 
   85,    14, 
   86,    14, 
   87,    14, 
  194,    14, 
  195,    14, 
  196,    14, 
  197,    14, 
 1054,    14, 
 1055,    14, 
 1056,    14, 
 1057,    14, 
 1164,    14, 
 1165,    14, 
 1235,    14, 
 1236,    14, 
 1237,    14, 
 1372,    14, 
 1373,    14, 
 1394,    14, 
 1395,    14, 
 1396,    14, 
 1397,    14, 
 2270,    14, 
 2271,    14, 
 2302,    14, 
 2303,    14, 
 2454,    14, 
 2614,    14, 
 2615,    14, 
 2824,    14, 
 2825,    14, 
 2826,    14, 
 2827,    14, 
 2866,    14, 
 2867,    14, 
 2868,    14, 
 2869,    14, 
 2870,    14, 
 2871,    14, 
 2872,    14, 
 2873,    14, 
 2992,    14, 
 3063,    14, 
 3064,    14, 
 3065,    14, 
 3066,    14, 
 3067,    14, 
 3068,    14, 
 3069,    14, 
 3070,    14, 
 3071,    14, 
 4692,    14, 
 4693,    14, 
 4694,    14, 
 4695,    14, 
 4720,    14, 
 4721,    14, 
 4722,    14, 
 4723,    14, 
 4724,    14, 
 4725,    14, 
 4779,    14, 
 4780,    14, 
 4781,    14, 
 4782,    14, 
 4783,    14, 
 4784,    14, 
 4785,    14, 
 4885,    14, 
 4886,    14, 
 4887,    14, 
 5055,    14, 
 5056,    14, 
 5057,    14, 
 5058,    14, 
 5059,    14, 
 5060,    14, 
 5061,    14, 
 5062,    14, 
 5063,    14, 
 5064,    14, 
 5065,    14, 
 5066,    14, 
 5067,    14, 
 5068,    14, 
 5069,    14, 
 6662,    14, 
 6663,    14, 
 6696,    14, 
 6697,    14, 
 6698,    14, 
 6699,    14, 
 6700,    14, 
 6701,    14, 
 6784,    14, 
 6843,    14, 
 6844,    14, 
 6845,    14, 
 6872,    14, 
 6873,    14, 
  148,    15, 
  149,    15, 
  150,    15, 
  151,    15, 
  160,    15, 
  161,    15, 
  162,    15, 
  163,    15, 
 2097,    15, 
 2098,    15, 
 2099,    15, 
 2100,    15, 
 2101,    15, 
 2102,    15, 
 2103,    15, 
 2104,    15, 
 2105,    15, 
 2106,    15, 
 2107,    15, 
 2361,    15, 
 2362,    15, 
 2363,    15, 
 2364,    15, 
 2365,    15, 
 2366,    15, 
 2367,    15, 
 2464,    15, 
 2465,    15, 
 2466,    15, 
 2467,    15, 
 2468,    15, 
 2469,    15, 
 4524,    15, 
 4525,    15, 
 4526,    15, 
 4527,    15, 
 4528,    15, 
 4529,    15, 
 4530,    15, 
 4531,    15, 
 4532,    15, 
 4533,    15, 
 4534,    15, 
 4535,    15, 
 4536,    15, 
 4537,    15, 
 4538,    15, 
 4539,    15, 
 4911,    15, 
 5204,    15, 
 5205,    15, 
 5206,    15, 
 5207,    15, 
 5208,    15, 
 5209,    15, 
 5210,    15, 
 5211,    15, 
 5212,    15, 
 5213,    15, 
 5214,    15, 
 5215,    15, 
 5216,    15, 
 5217,    15, 
 5218,    15, 
 5219,    15, 
 5220,    15, 
 5221,    15, 
 5222,    15, 
 5223,    15, 
 5224,    15, 
 5225,    15, 
 5226,    15, 
 5227,    15, 
 6110,    15, 
 6111,    15, 
 6112,    15, 
 6113,    15, 
 6114,    15, 
 6115,    15, 
 6116,    15, 
 6117,    15, 
 6118,    15, 
 6119,    15, 
 6120,    15, 
 6121,    15, 
 6122,    15, 
 6123,    15, 
 6124,    15, 
 6125,    15, 
 9536,    15, 
 9537,    15, 
 9538,    15, 
 9539,    15, 
 9540,    15, 
 9541,    15, 
 9542,    15, 
 9543,    15, 
 9544,    15, 
 9545,    15, 
 9546,    15, 
 9547,    15, 
 9548,    15, 
 9549,    15, 
 9550,    15, 
 9551,    15, 
 9552,    15, 
 9553,    15, 
 9554,    15, 
 9555,    15, 
 9556,    15, 
 9557,    15, 
 9768,    15, 
10086,    15, 
10087,    15, 
10088,    15, 
10089,    15, 
10090,    15, 
10091,    15, 
10092,    15, 
10093,    15, 
10094,    15, 
10095,    15, 
10096,    15, 
10097,    15, 
10098,    15, 
10099,    15, 
10100,    15, 
10101,    15, 
10102,    15, 
10103,    15, 
10104,    15, 
10105,    15, 
10106,    15, 
10107,    15, 
10108,    15, 
10109,    15, 
13571,    15, 
13636,    15, 
13637,    15, 
13638,    15, 
13639,    15, 
13664,    15, 
13665,    15, 
13666,    15, 
13667,    15, 
13668,    15, 
13669,    15, 
13670,    15, 
13671,    15, 
13672,    15, 
13673,    15, 
13674,    15, 
13675,    15, 
13676,    15, 
13677,    15, 
13678,    15, 
13679,    15, 
13680,    15, 
13681,    15, 
13682,    15, 
13683,    15, 
13684,    15, 
13685,    15, 
 1008,    16, 
 4157,    16, 
 4158,    16, 
 4159,    16, 
 4160,    16, 
 4161,    16, 
 4162,    16, 
 4163,    16, 
 4164,    16, 
 4165,    16, 
 4166,    16, 
 4167,    16, 
 4168,    16, 
 4169,    16, 
 4170,    16, 
 4171,    16, 
 4172,    16, 
 4173,    16, 
 4174,    16, 
 4175,    16, 
 4176,    16, 
 4177,    16, 
 4178,    16, 
 4179,    16, 
 4180,    16, 
 4181,    16, 
 4182,    16, 
 4183,    16, 
 4184,    16, 
 4185,    16, 
 4186,    16, 
 4187,    16, 
 4188,    16, 
 4189,    16, 
 4190,    16, 
 4191,    16, 
 4192,    16, 
 4193,    16, 
 4720,    16, 
 4721,    16, 
 8632,    16, 
 8633,    16, 
 8634,    16, 
 8635,    16, 
 8636,    16, 
 8637,    16, 
 8638,    16, 
 8639,    16, 
 8688,    16, 
 8689,    16, 
 8690,    16, 
 8691,    16, 
 8692,    16, 
 8693,    16, 
 8694,    16, 
 8695,    16, 
 8696,    16, 
 8697,    16, 
 8698,    16, 
 8699,    16, 
 8700,    16, 
 8701,    16, 
 8702,    16, 
 8703,    16, 
 9024,    16, 
 9025,    16, 
 9026,    16, 
 9027,    16, 
 9028,    16, 
 9029,    16, 
 9030,    16, 
 9031,    16, 
 9032,    16, 
 9033,    16, 
 9034,    16, 
 9035,    16, 
 9036,    16, 
 9037,    16, 
 9038,    16, 
 9039,    16, 
 9040,    16, 
 9041,    16, 
 9042,    16, 
 9043,    16, 
 9044,    16, 
 9045,    16, 
 9046,    16, 
 9047,    16, 
 9820,    16, 
12168,    16, 
12169,    16, 
12170,    16, 
12171,    16, 
12172,    16, 
12173,    16, 
12174,    16, 
12175,    16, 
12176,    16, 
12177,    16, 
12178,    16, 
12179,    16, 
12180,    16, 
12181,    16, 
12182,    16, 
12183,    16, 
12184,    16, 
12185,    16, 
12186,    16, 
12187,    16, 
12188,    16, 
12189,    16, 
12190,    16, 
12191,    16, 
12192,    16, 
12193,    16, 
12194,    16, 
12195,    16, 
12196,    16, 
12197,    16, 
12198,    16, 
12199,    16, 
12200,    16, 
12201,    16, 
12202,    16, 
12203,    16, 
12204,    16, 
12205,    16, 
12206,    16, 
12207,    16, 
12208,    16, 
12209,    16, 
12210,    16, 
12211,    16, 
12212,    16, 
12213,    16, 
12214,    16, 
12215,    16, 
12216,    16, 
12217,    16, 
12218,    16, 
12219,    16, 
19538,    16, 
19539,    16, 
20008,    16, 
20009,    16, 
20010,    16, 
20011,    16, 
20012,    16, 
20013,    16, 
20014,    16, 
20015,    16, 
20016,    16, 
20017,    16, 
20018,    16, 
20019,    16, 
20020,    16, 
20021,    16, 
20022,    16, 
20023,    16, 
20024,    16, 
20025,    16, 
20026,    16, 
20027,    16, 
20028,    16, 
20029,    16, 
20030,    16, 
20031,    16, 
20096,    16, 
20097,    16, 
20098,    16, 
20099,    16, 
20100,    16, 
20101,    16, 
20102,    16, 
20103,    16, 
20104,    16, 
20105,    16, 
20106,    16, 
20107,    16, 
20108,    16, 
20109,    16, 
20110,    16, 
20111,    16, 
20112,    16, 
20113,    16, 
20114,    16, 
20115,    16, 
20116,    16, 
20117,    16, 
20118,    16, 
20119,    16, 
20120,    16, 
20121,    16, 
20122,    16, 
20123,    16, 
20124,    16, 
20125,    16, 
20126,    16, 
20127,    16, 
20128,    16, 
20129,    16, 
20130,    16, 
20131,    16, 
20132,    16, 
20133,    16, 
20134,    16, 
20135,    16, 
20136,    16, 
20137,    16, 
20138,    16, 
20139,    16, 
20140,    16, 
20141,    16, 
20142,    16, 
20143,    16, 
20144,    16, 
20145,    16, 
20146,    16, 
20147,    16, 
20148,    16, 
20149,    16, 
20150,    16, 
20151,    16, 
20152,    16, 
20153,    16, 
20154,    16, 
20155,    16, 
20156,    16, 
20157,    16, 
20158,    16, 
20159,    16, 
20160,    16, 
20161,    16, 
20162,    16, 
20163,    16, 
20164,    16, 
20165,    16, 
20166,    16, 
20167,    16, 
20168,    16, 
20169,    16, 
20170,    16, 
20171,    16, 
27140,    16, 
27141,    16, 
 2018,    17, 
 2019,    17, 
 2020,    17, 
 2021,    17, 
 2022,    17, 
 2023,    17, 
 2024,    17, 
 2025,    17, 
 2026,    17, 
 2027,    17, 
 2028,    17, 
 2029,    17, 
 2030,    17, 
 2031,    17, 
 2032,    17, 
 2033,    17, 
 2034,    17, 
 2035,    17, 
 2036,    17, 
 2037,    17, 
 2038,    17, 
 2039,    17, 
 2040,    17, 
 2041,    17, 
 2042,    17, 
 2043,    17, 
 2044,    17, 
 2045,    17, 
 2046,    17, 
 2047,    17, 
 8192,    17, 
 8193,    17, 
 8194,    17, 
 8195,    17, 
 8196,    17, 
 8197,    17, 
 8198,    17, 
 8199,    17, 
 8200,    17, 
 8201,    17, 
 8202,    17, 
 8203,    17, 
 8204,    17, 
 8205,    17, 
 8206,    17, 
 8207,    17, 
 8208,    17, 
 8209,    17, 
 8210,    17, 
 8211,    17, 
 8212,    17, 
 8213,    17, 
 8214,    17, 
 8215,    17, 
 8216,    17, 
 8217,    17, 
 8218,    17, 
 8219,    17, 
 8220,    17, 
 8221,    17, 
 8222,    17, 
 8223,    17, 
 8224,    17, 
 8225,    17, 
 8226,    17, 
 8227,    17, 
 8228,    17, 
 8229,    17, 
 8230,    17, 
 8231,    17, 
 8232,    17, 
 8233,    17, 
 8234,    17, 
 8235,    17, 
 8236,    17, 
 8237,    17, 
 8238,    17, 
 8239,    17, 
 8240,    17, 
 8241,    17, 
 8242,    17, 
 8243,    17, 
 8244,    17, 
 8245,    17, 
 8246,    17, 
 8247,    17, 
 8248,    17, 
 8249,    17, 
 8250,    17, 
 8251,    17, 
 8252,    17, 
 8253,    17, 
 8254,    17, 
 8255,    17, 
 8256,    17, 
 8257,    17, 
 8258,    17, 
 8259,    17, 
 8260,    17, 
 8261,    17, 
 8262,    17, 
 8263,    17, 
 8264,    17, 
 8265,    17, 
 8266,    17, 
 8267,    17, 
 8268,    17, 
 8269,    17, 
 8270,    17, 
 8271,    17, 
 8272,    17, 
 8273,    17, 
 8274,    17, 
 8275,    17, 
 8276,    17, 
 8277,    17, 
 8278,    17, 
 8279,    17, 
 8280,    17, 
 8281,    17, 
 8282,    17, 
 8283,    17, 
 8284,    17, 
 8285,    17, 
 8286,    17, 
 8287,    17, 
 8288,    17, 
 8289,    17, 
 8290,    17, 
 8291,    17, 
 8292,    17, 
 8293,    17, 
 8294,    17, 
 8295,    17, 
 8296,    17, 
 8297,    17, 
 8298,    17, 
 8299,    17, 
 8300,    17, 
 8301,    17, 
 8302,    17, 
 8303,    17, 
 8304,    17, 
 8305,    17, 
 8306,    17, 
 8307,    17, 
 8308,    17, 
 8309,    17, 
 8310,    17, 
 8311,    17, 
 8312,    17, 
 8313,    17, 
19642,    17, 
19643,    17, 
23944,    17, 
23945,    17, 
23946,    17, 
23947,    17, 
23948,    17, 
23949,    17, 
23950,    17, 
23951,    17, 
23984,    17, 
23985,    17, 
23986,    17, 
23987,    17, 
23988,    17, 
23989,    17, 
23990,    17, 
23991,    17, 
23992,    17, 
23993,    17, 
23994,    17, 
23995,    17, 
23996,    17, 
23997,    17, 
23998,    17, 
23999,    17, 
24128,    17, 
24129,    17, 
24130,    17, 
24131,    17, 
24132,    17, 
24133,    17, 
24134,    17, 
24135,    17, 
24136,    17, 
24137,    17, 
24138,    17, 
24139,    17, 
24140,    17, 
24141,    17, 
24142,    17, 
24143,    17, 
24144,    17, 
24145,    17, 
24146,    17, 
24147,    17, 
24148,    17, 
24149,    17, 
24150,    17, 
24151,    17, 
24152,    17, 
24153,    17, 
24154,    17, 
24155,    17, 
24156,    17, 
24157,    17, 
24158,    17, 
24159,    17, 
24160,    17, 
24161,    17, 
24162,    17, 
24163,    17, 
24164,    17, 
24165,    17, 
24166,    17, 
24167,    17, 
24168,    17, 
24169,    17, 
24170,    17, 
24171,    17, 
24172,    17, 
24173,    17, 
24174,    17, 
24175,    17, 
24176,    17, 
24177,    17, 
24178,    17, 
24179,    17, 
24180,    17, 
24181,    17, 
24182,    17, 
24183,    17, 
24184,    17, 
24185,    17, 
24186,    17, 
24187,    17, 
24188,    17, 
24189,    17, 
24190,    17, 
24191,    17, 
24192,    17, 
24193,    17, 
24194,    17, 
24195,    17, 
24196,    17, 
24197,    17, 
24198,    17, 
24199,    17, 
24200,    17, 
24201,    17, 
24202,    17, 
24203,    17, 
24204,    17, 
24205,    17, 
24206,    17, 
24207,    17, 
24208,    17, 
24209,    17, 
24210,    17, 
24211,    17, 
24212,    17, 
24213,    17, 
24214,    17, 
24215,    17, 
24216,    17, 
24217,    17, 
24218,    17, 
24219,    17, 
24220,    17, 
24221,    17, 
24222,    17, 
24223,    17, 
24224,    17, 
24225,    17, 
24226,    17, 
24227,    17, 
24228,    17, 
24229,    17, 
24230,    17, 
24231,    17, 
24232,    17, 
24233,    17, 
24234,    17, 
24235,    17, 
24236,    17, 
24237,    17, 
24238,    17, 
24239,    17, 
24240,    17, 
24241,    17, 
24242,    17, 
24243,    17, 
24244,    17, 
24245,    17, 
24246,    17, 
24247,    17, 
24248,    17, 
24249,    17, 
24250,    17, 
24251,    17, 
24252,    17, 
24253,    17, 
24254,    17, 
24255,    17, 
24256,    17, 
24257,    17, 
24258,    17, 
24259,    17, 
24260,    17, 
24261,    17, 
24262,    17, 
24263,    17, 
24264,    17, 
24265,    17, 
24266,    17, 
24267,    17, 
24268,    17, 
24269,    17, 
24270,    17, 
24271,    17, 
24272,    17, 
24273,    17, 
24274,    17, 
24275,    17, 
24276,    17, 
24277,    17, 
24278,    17, 
24279,    17, 
24280,    17, 
24281,    17, 
24282,    17, 
24283,    17, 
24284,    17, 
24285,    17, 
24286,    17, 
24287,    17, 
24288,    17, 
24289,    17, 
24290,    17, 
24291,    17, 
24292,    17, 
24293,    17, 
24294,    17, 
24295,    17, 
24296,    17, 
24297,    17, 
24298,    17, 
24299,    17, 
24300,    17, 
24301,    17, 
24302,    17, 
24303,    17, 
24304,    17, 
24305,    17, 
24306,    17, 
24307,    17, 
24308,    17, 
24309,    17, 
24310,    17, 
24311,    17, 
24312,    17, 
24313,    17, 
24314,    17, 
24315,    17, 
24316,    17, 
24317,    17, 
24318,    17, 
24319,    17, 
24320,    17, 
24321,    17, 
24322,    17, 
24323,    17, 
24324,    17, 
24325,    17, 
24326,    17, 
24327,    17, 
24328,    17, 
24329,    17, 
24330,    17, 
24331,    17, 
24332,    17, 
24333,    17, 
24334,    17, 
24335,    17, 
    0,     8, 
};

/// #ifdef __TALKING_HEADER
//#ifdef NEW_PCBPCY_TABLE
tPackHuffmanCode_WMV sm_HufPCBPCYTable_HighRate[129] = 
{   128,       0,
    167,      14, 
 111288,      18, 
 111246,      18, 
 222581,      19, 
  27820,      16, 
   2665,      18, 
  10548,      20, 
  21099,      21, 
  27809,      16, 
 111289,      18, 
  10669,      20, 
 168787,      24, 
  27815,      16, 
  27819,      16, 
 111291,      18, 
    667,      16, 
  55620,      17, 
   2666,      18, 
  84392,      23, 
 222495,      19, 
  27823,      16, 
   2636,      18, 
 222494,      19, 
   2632,      18, 
  10652,      20, 
  10655,      20, 
 168786,      24, 
  10668,      20, 
    662,      16, 
  55622,      17, 
   2664,      18, 
    664,      16, 
   1319,      17, 
  55629,      17, 
   5335,      19, 
 222580,      19, 
   2652,      18, 
 111257,      18, 
  10653,      20, 
  10654,      20, 
   1317,      17, 
   2662,      18, 
  42197,      22, 
   5275,      19, 
    661,      16, 
  27821,      16, 
   2633,      18, 
   1313,      17, 
  27818,      16, 
  55621,      17, 
 111256,      18, 
   1327,      17, 
  13908,      15, 
  27808,      16, 
   1330,      17, 
    657,      16, 
  13906,      15, 
   1312,      17, 
   2653,      18, 
    660,      16, 
    155,      11, 
   1762,      12, 
     40,      12, 
    432,      10, 
      1,       3, 
     16,       8, 
     47,       6, 
     76,      10, 
     13,       4, 
      0,      10, 
      6,       9, 
    308,      12, 
     12,       4, 
      7,      10, 
      7,       9, 
   1761,      12, 
     14,       5, 
    218,       9, 
     34,       9, 
    868,      11, 
     15,       4, 
      6,      10, 
     15,       9, 
    309,      12, 
     20,       5, 
    221,       9, 
      4,       9, 
     21,      11, 
     26,       6, 
    435,      10, 
      5,      10, 
   1763,      12, 
     12,       5, 
    185,       8, 
      4,       8, 
    219,       9, 
     14,       4, 
     11,      10, 
     35,       9, 
   1739,      12, 
      5,       6, 
    433,      10, 
      1,      10, 
   1760,      12, 
     17,       5, 
    223,       9, 
     14,       9, 
    883,      11, 
      3,       5, 
    184,       8, 
      6,       8, 
    373,       9, 
     21,       5, 
    372,       9, 
     39,       9, 
    882,      11, 
     16,       5, 
    187,       8, 
      5,       8, 
    222,       9, 
     15,       5, 
      1,       9, 
     18,       8, 
      4,      10, 
      2,       3, 
     22,       5, 
      9,       4, 
      1,       5, 

};

tPackHuffmanCode_WMV sm_HufPCBPCYTable_MidRate[129] =
{   128,       0,
    673,      10, 
  22336,      15, 
 106687,      18, 
  89369,      17, 
   5396,      13, 
  17950,      15, 
  86390,      17, 
  86391,      17, 
   4525,      13, 
  26670,      16, 
 426745,      20, 
 213373,      19, 
   6710,      14, 
  10797,      14, 
  53342,      17, 
  26660,      16, 
   5397,      13, 
  21596,      15, 
 143593,      18, 
  72442,      17, 
   5591,      13, 
  22343,      15, 
  36217,      16, 
  26661,      16, 
  11170,      14, 
  43194,      16, 
 144886,      18, 
  89368,      17, 
   4526,      13, 
  13423,      15, 
  35899,      16, 
  13422,      15, 
   3354,      13, 
  17951,      15, 
 426744,      20, 
  71797,      17, 
  11169,      14, 
  36193,      16, 
 144887,      18, 
 143592,      18, 
   5395,      13, 
  36219,      16, 
  72436,      17, 
  72437,      17, 
   4485,      13, 
  18111,      15, 
  36192,      16, 
  36220,      16, 
   5394,      13, 
  17948,      15, 
  44685,      16, 
  36216,      16, 
   3342,      13, 
  13331,      15, 
  18097,      15, 
  13334,      15, 
   2794,      12, 
  10796,      14, 
  22337,      15, 
  10799,      14, 
    344,       9, 
   2258,      12, 
   1356,      11, 
   1670,      12, 
      0,       2, 
    105,       8, 
    107,       8, 
   1676,      12, 
      7,       3, 
    350,       9, 
    675,      10, 
   2793,      12, 
      6,       3, 
    561,      10, 
    696,      10, 
   6664,      14, 
     16,       5, 
    425,      10, 
    834,      11, 
   2696,      12, 
      4,       4, 
    418,      10, 
    676,      10, 
   4484,      13, 
     18,       5, 
    562,      10, 
    690,      10, 
   1664,      12, 
     27,       6, 
   1130,      11, 
   1678,      12, 
   9049,      14, 
     22,       5, 
    351,       9, 
    672,      10, 
   1357,      11, 
      5,       4, 
    563,      10, 
    697,      10, 
   5590,      13, 
     34,       6, 
   1128,      11, 
   1667,      12, 
   6666,      14, 
     19,       5, 
    566,      10, 
    699,      10, 
   4486,      13, 
     23,       5, 
    427,      10, 
    679,      10, 
   2259,      12, 
     20,       5, 
    567,      10, 
   1120,      11, 
   3343,      13, 
     25,       6, 
    426,      10, 
    691,      10, 
   1665,      12, 
     24,       6, 
    424,      10, 
    677,      10, 
   1679,      12, 
      7,       4, 
     85,       7, 
     71,       7, 
    173,       8, 
};
tPackHuffmanCode_WMV sm_HufPCBPCYTable_LowRate[129] = 
{   128,       0,
    212,       8, 
   8645,      14, 
  61834,      16, 
  54716,      16, 
   2169,      12, 
  13645,      14, 
  69183,      17, 
  69460,      17, 
   2150,      12, 
  13678,      14, 
  69461,      17, 
  69182,      17, 
   4302,      13, 
  15492,      14, 
  54717,      16, 
  61835,      16, 
   2152,      12, 
  17292,      15, 
  34731,      16, 
  30987,      15, 
   3856,      12, 
  17213,      15, 
  27347,      15, 
  30986,      15, 
   6823,      13, 
  17364,      15, 
  34590,      16, 
  27359,      15, 
   3452,      12, 
  15508,      14, 
  17293,      15, 
  27346,      15, 
   1724,      11, 
   8681,      14, 
  27354,      15, 
  27289,      15, 
   4343,      13, 
  17289,      15, 
  27355,      15, 
  30916,      15, 
   3414,      12, 
  13815,      14, 
  17294,      15, 
  27288,      15, 
   3410,      12, 
  15509,      14, 
  17288,      15, 
  17212,      15, 
   3412,      12, 
   7755,      13, 
  15459,      14, 
  15491,      14, 
   2145,      12, 
   8683,      14, 
  13676,      14, 
  13814,      14, 
   2147,      12, 
   8607,      14, 
  13672,      14, 
  15490,      14, 
    430,       9, 
   4288,      13, 
   3857,      12, 
   6906,      13, 
      0,       1, 
    240,       8, 
    429,       9, 
   4289,      13, 
     10,       4, 
    965,      10, 
   1929,      11, 
   6837,      13, 
      9,       4, 
   1077,      11, 
   1939,      11, 
   7744,      13, 
     29,       5, 
    971,      10, 
   2168,      12, 
   6831,      13, 
     11,       4, 
    967,      10, 
   1937,      11, 
   6827,      13, 
     31,       5, 
   1078,      11, 
   1727,      11, 
   3865,      12, 
     61,       6, 
   3409,      12, 
   4292,      13, 
   8680,      14, 
     54,       6, 
   1079,      11, 
   1711,      11, 
   4293,      13, 
     12,       4, 
   1074,      11, 
   1940,      11, 
   7728,      13, 
     66,       7, 
   2160,      12, 
   3876,      12, 
   7747,      13, 
     32,       6, 
   1086,      11, 
   1941,      11, 
   6826,      13, 
     55,       6, 
   1708,      11, 
   1710,      11, 
   4342,      13, 
     52,       6, 
   1082,      11, 
   3408,      12, 
   6830,      13, 
     57,       6, 
   1087,      11, 
   1933,      11, 
   4306,      13, 
     56,       6, 
   1083,      11, 
   1725,      11, 
   4307,      13, 
     17,       5, 
    428,       9, 
    243,       8, 
   1081,      11, 
};
//#endif // NEW_PCBPCY_TABLE

tPackHuffmanCode_WMV sm_HufPCBPCYTable[129] = 
{   128,      0,
    64,       7, 
   5065,      13, 
   2557,      12, 
    508,      15, 
   2556,      12, 
   2691,      18, 
  77108,      17, 
  33724,      16, 
   2106,      12, 
   2040,      17, 
   1021,      16, 
   1023,      16, 
    121,      13, 
   2690,      18, 
  38557,      16, 
    676,      16, 
   2424,      12, 
   1347,      17, 
  16863,      15, 
   2041,      17, 
   4851,      13, 
 154219,      18, 
 155385,      18, 
   1018,      16, 
   8430,      14, 
 616875,      20, 
  38556,      16, 
 155384,      18, 
   4818,      13, 
   2693,      18, 
  38558,      16, 
  19400,      15, 
     61,      12, 
  77695,      17, 
    674,      16, 
  38559,      16, 
   9710,      14, 
1233749,      21, 
  77693,      17, 
  77694,      17, 
   2533,      12, 
   2689,      18, 
 308436,      19, 
  33725,      16, 
    120,      13, 
  38555,      16, 
   1022,      16, 
    677,      16, 
    126,      13, 
   2688,      18, 
    675,      16, 
   1019,      16, 
   4214,      13, 
   2692,      18, 
    339,      15, 
  19401,      15, 
     85,      13, 
1233748,      21, 
  19422,      15, 
   9701,      14, 
    603,      10, 
  19276,      15, 
   2411,      12, 
   2410,      12, 
      1,       2, 
      0,       7, 
     38,       6, 
    299,       9, 
      7,       3, 
    527,      10, 
      4,       9, 
     40,      12, 
      6,       3, 
    522,      10, 
    296,       9, 
     43,      12, 
     17,       5, 
     27,      11, 
    314,       9, 
   1279,      11, 
      3,       4, 
    631,      10, 
    262,       9, 
   2105,      12, 
     11,       4, 
    635,      10, 
    300,       9, 
   1215,      11, 
      9,       6, 
     53,      12, 
    638,      10, 
   5064,      13, 
      1,       6, 
   1194,      11, 
    520,      10, 
     41,      12, 
      1,       4, 
    596,      10, 
    302,       9, 
   2104,      12, 
     36,       6, 
   1267,      11, 
    630,      10, 
   4854,      13, 
      1,       5, 
    634,      10, 
    318,       9, 
     62,      12, 
      8,       6, 
   1043,      11, 
     12,      10, 
   1214,      11, 
     20,       5, 
   1042,      11, 
    595,      10, 
   2426,      12, 
     33,       6, 
   1195,      11, 
    523,      10, 
     52,      12, 
     21,       5, 
    632,      10, 
    594,      10, 
   2408,      12, 
      5,       5, 
     11,      10, 
    156,       8, 
     14,      10, 
};

tPackHuffmanCode_WMV sm_HufICBPCYTable[65] = 
{
    64,    0,
    1,     1, 
   23,     6, 
    9,     5, 
    5,     5, 
    6,     5, 
   71,     9, 
   32,     7, 
   16,     7, 
    2,     5, 
  124,     9, 
   58,     7, 
   29,     7, 
    2,     6, 
  236,     9, 
  119,     8, 
    0,     8, 
    3,     5, 
  183,     9, 
   44,     7, 
   19,     7, 
    1,     6, 
  360,    10, 
   70,     8, 
   63,     8, 
   30,     6, 
 1810,    13, 
  181,     9, 
   66,     8, 
   34,     7, 
  453,    11, 
  286,    10, 
  135,     9, 
    6,     4, 
    3,     9, 
   30,     7, 
   28,     6, 
   18,     7, 
  904,    12, 
   68,     9, 
  112,     9, 
   31,     6, 
  574,    11, 
   57,     8, 
  142,     9, 
    1,     7, 
  454,    11, 
  182,     9, 
   69,     9, 
   20,     6, 
  575,    11, 
  125,     9, 
   24,     9, 
    7,     7, 
  455,    11, 
  134,     9, 
   25,     9, 
   21,     6, 
  475,    10, 
    2,     9, 
   70,     9, 
   13,     8, 
 1811,    13, 
  474,    10, 
  361,    10, 
};

// Tables for Talking
tPackHuffmanCode_WMV sm_HufDCTDCyTable_Talking[121] = 
{
    120,    0,
     1,     1,
     1,     2,
     1,     4,
     1,     5,
     5,     5,
     7,     5,
     8,     6,
    12,     6,
     0,     7,
     2,     7,
    18,     7,
    26,     7,
     3,     8,
     7,     8,
    39,     8,
    55,     8,
     5,     9,
    76,     9,
   108,     9,
   109,     9,
     8,    10,
    25,    10,
   155,    10,
    27,    10,
   154,    10,
    19,    11,
    52,    11,
    53,    11,
    97,    12,
    72,    13,
   196,    13,
    74,    13,
   198,    13,
   199,    13,
   146,    14,
   395,    14,
   147,    14,
   387,    14,
   386,    14,
   150,    14,
   151,    14,
   384,    14,
   788,    15,
   789,    15,
  1541,    16,
  1540,    16,
  1542,    16,
  3086,    17,
197581,    23,
197577,    23,
197576,    23,
197578,    23,
197579,    23,
197580,    23,
197582,    23,
197583,    23,
197584,    23,
197585,    23,
197586,    23,
197587,    23,
197588,    23,
197589,    23,
197590,    23,
197591,    23,
197592,    23,
197593,    23,
197594,    23,
197595,    23,
197596,    23,
197597,    23,
197598,    23,
197599,    23,
197600,    23,
197601,    23,
197602,    23,
197603,    23,
197604,    23,
197605,    23,
197606,    23,
197607,    23,
197608,    23,
197609,    23,
197610,    23,
197611,    23,
197612,    23,
197613,    23,
197614,    23,
197615,    23,
197616,    23,
197617,    23,
197618,    23,
197619,    23,
197620,    23,
197621,    23,
197622,    23,
197623,    23,
197624,    23,
197625,    23,
197626,    23,
197627,    23,
197628,    23,
197629,    23,
197630,    23,
197631,    23,
395136,    24,
395137,    24,
395138,    24,
395139,    24,
395140,    24,
395141,    24,
395142,    24,
395143,    24,
395144,    24,
395145,    24,
395146,    24,
395147,    24,
395148,    24,
395149,    24,
395150,    24,
395151,    24,
};
tPackHuffmanCode_WMV sm_HufDCTDCcTable_Talking[121] = 
{
    120,    0,
     0,     2,
     1,     2,
     5,     3,
     9,     4,
    13,     4,
    17,     5,
    29,     5,
    31,     5,
    33,     6,
    49,     6,
    56,     6,
    51,     6,
    57,     6,
    61,     6,
    97,     7,
   121,     7,
   128,     8,
   200,     8,
   202,     8,
   240,     8,
   129,     8,
   192,     8,
   201,     8,
   263,     9,
   262,     9,
   406,     9,
   387,     9,
   483,     9,
   482,     9,
   522,    10,
   523,    10,
  1545,    11,
  1042,    11,
  1043,    11,
  1547,    11,
  1041,    11,
  1546,    11,
  1631,    11,
  1040,    11,
  1629,    11,
  1630,    11,
  3256,    12,
  3088,    12,
  3257,    12,
  6179,    13,
 12357,    14,
 24713,    15,
 49424,    16,
3163208,    22,
3163209,    22,
3163210,    22,
3163211,    22,
3163212,    22,
3163213,    22,
3163214,    22,
3163215,    22,
3163216,    22,
3163217,    22,
3163218,    22,
3163219,    22,
3163220,    22,
3163221,    22,
3163222,    22,
3163223,    22,
3163224,    22,
3163225,    22,
3163226,    22,
3163227,    22,
3163228,    22,
3163229,    22,
3163230,    22,
3163231,    22,
3163232,    22,
3163233,    22,
3163234,    22,
3163235,    22,
3163236,    22,
3163237,    22,
3163238,    22,
3163239,    22,
3163240,    22,
3163241,    22,
3163242,    22,
3163243,    22,
3163244,    22,
3163245,    22,
3163246,    22,
3163247,    22,
3163248,    22,
3163249,    22,
3163250,    22,
3163251,    22,
3163252,    22,
3163253,    22,
3163254,    22,
3163255,    22,
3163256,    22,
3163257,    22,
3163258,    22,
3163259,    22,
3163260,    22,
3163261,    22,
3163262,    22,
3163263,    22,
6326400,    23,
6326401,    23,
6326402,    23,
6326403,    23,
6326404,    23,
6326405,    23,
6326406,    23,
6326407,    23,
6326408,    23,
6326409,    23,
6326410,    23,
6326411,    23,
6326412,    23,
6326413,    23,
6326414,    23,
6326415,    23,
};

// Tables for HighMotion
tPackHuffmanCode_WMV sm_HufDCTDCyTable_HghMt[121] = 
{
    120,    0,
     2,     2,
     3,     2,
     3,     3,
     2,     4,
     5,     4,
     1,     5,
     3,     5,
     8,     5,
     0,     6,
     5,     6,
    13,     6,
    15,     6,
    19,     6,
     8,     7,
    24,     7,
    28,     7,
    36,     7,
     4,     8,
     6,     8,
    18,     8,
    50,     8,
    59,     8,
    74,     8,
    75,     8,
    11,     9,
    38,     9,
    39,     9,
   102,     9,
   116,     9,
   117,     9,
    20,    10,
    28,    10,
    31,    10,
    29,    10,
    43,    11,
    61,    11,
   413,    11,
   415,    11,
    84,    12,
   825,    12,
   824,    12,
   829,    12,
   171,    13,
   241,    13,
  1656,    13,
   242,    13,
   480,    14,
   481,    14,
   340,    14,
  3314,    14,
   972,    15,
   683,    15,
  6631,    15,
   974,    15,
  6630,    15,
  1364,    16,
  1951,    16,
  1365,    16,
  3901,    17,
  3895,    17,
  3900,    17,
  3893,    17,
  7789,    18,
  7784,    18,
 15576,    19,
 15571,    19,
 15577,    19,
 31140,    20,
996538,    25,
996532,    25,
996533,    25,
996534,    25,
996535,    25,
996536,    25,
996537,    25,
996539,    25,
996540,    25,
996541,    25,
996542,    25,
996543,    25,
1993024,    26,
1993025,    26,
1993026,    26,
1993027,    26,
1993028,    26,
1993029,    26,
1993030,    26,
1993031,    26,
1993032,    26,
1993033,    26,
1993034,    26,
1993035,    26,
1993036,    26,
1993037,    26,
1993038,    26,
1993039,    26,
1993040,    26,
1993041,    26,
1993042,    26,
1993043,    26,
1993044,    26,
1993045,    26,
1993046,    26,
1993047,    26,
1993048,    26,
1993049,    26,
1993050,    26,
1993051,    26,
1993052,    26,
1993053,    26,
1993054,    26,
1993055,    26,
1993056,    26,
1993057,    26,
1993058,    26,
1993059,    26,
1993060,    26,
1993061,    26,
1993062,    26,
1993063,    26,
};

tPackHuffmanCode_WMV sm_HufDCTDCcTable_HghMt[121] = 
{
    120,    0,
     0,     2,
     1,     2,
     4,     3,
     7,     3,
    11,     4,
    13,     4,
    21,     5,
    40,     6,
    48,     6,
    50,     6,
    82,     7,
    98,     7,
   102,     7,
   166,     8,
   198,     8,
   207,     8,
   335,     9,
   398,     9,
   412,     9,
   669,    10,
   826,    10,
  1336,    11,
  1596,    11,
  1598,    11,
  1599,    11,
  1654,    11,
  2675,    12,
  3194,    12,
  3311,    12,
  5349,    13,
  6621,    13,
 10696,    14,
 10697,    14,
 25565,    15,
 13240,    14,
 13241,    14,
 51126,    16,
 25560,    15,
 25567,    15,
 51123,    16,
 51124,    16,
 51125,    16,
 25566,    15,
 51127,    16,
 51128,    16,
 51129,    16,
102245,    17,
204488,    18,
13087304,    24,
13087305,    24,
13087306,    24,
13087307,    24,
13087308,    24,
13087309,    24,
13087310,    24,
13087311,    24,
13087312,    24,
13087313,    24,
13087314,    24,
13087315,    24,
13087316,    24,
13087317,    24,
13087318,    24,
13087319,    24,
13087320,    24,
13087321,    24,
13087322,    24,
13087323,    24,
13087324,    24,
13087325,    24,
13087326,    24,
13087327,    24,
13087328,    24,
13087329,    24,
13087330,    24,
13087331,    24,
13087332,    24,
13087333,    24,
13087334,    24,
13087335,    24,
13087336,    24,
13087337,    24,
13087338,    24,
13087339,    24,
13087340,    24,
13087341,    24,
13087342,    24,
13087343,    24,
13087344,    24,
13087345,    24,
13087346,    24,
13087347,    24,
13087348,    24,
13087349,    24,
13087350,    24,
13087351,    24,
13087352,    24,
13087353,    24,
13087354,    24,
13087355,    24,
13087356,    24,
13087357,    24,
13087358,    24,
13087359,    24,
26174592,    25,
26174593,    25,
26174594,    25,
26174595,    25,
26174596,    25,
26174597,    25,
26174598,    25,
26174599,    25,
26174600,    25,
26174601,    25,
26174602,    25,
26174603,    25,
26174604,    25,
26174605,    25,
26174606,    25,
26174607,    25,
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\equalizer.c ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    MsAudioDec.cpp

Abstract:

    Implementation of top level functions of CAudioObjectDecoder.

Author:

    Wei-ge Chen (wchen) 14-July-1998

Revision History:


*************************************************************************/
#ifdef ENABLE_EQUALIZER

#include "bldsetup.h"

#include "msaudiodec.h"
#include "macros.h"

WMARESULT audecSetEqualizer (CAudioObjectDecoder* paudec, Int iBand, Int iGainIndB)
{
    if (iBand >= 0 && iBand < MAX_NO_EQBAND && iGainIndB >= MIN_EQ && iGainIndB <= MAX_EQ)  {
        paudec->m_fNoEq = WMAB_FALSE;
        if (iGainIndB != 0) {   
            paudec->m_rgfltEqBandWeight [iBand] = (Float) pow (10, iGainIndB / 20.0);
        }
        else 
            paudec->m_rgfltEqBandWeight [iBand] = 1.0F;
        return WMA_OK;
    }
    else 
        return TraceResult(WMA_E_INVALIDARG);
}

WMARESULT audecResetEqualizer (CAudioObjectDecoder* paudec)
{
    Int i;
    paudec->m_fNoEq = WMAB_TRUE; 
    for (i = 0; i < MAX_NO_EQBAND; i++)
        paudec->m_rgfltEqBandWeight [i] = 1.0F;

    return WMA_OK;
}

WMARESULT prvEqualize (CAudioObjectDecoder* paudec, PerChannelInfo* ppcinfo)
{
    Int i = 0;
    Int iCoef;
    Float fltWeightC = 1.0F;
    Float fltWeightR = 0;
    Int   iWidthR = 0;

    Float fltBandDiffL;
    Float fltBandDiffR;
    Int iWidthOfTransition;

    if (paudec->m_fNoEq)
        return WMA_OK;

    // Calculate first equalizer weighting
    do
    {
        fltWeightR += paudec->m_rgfltEqBandWeight[i];
        i += 1;
    } while (i < paudec->m_cEqBand && paudec->m_rgwEqBandBoundary[i - 1] == paudec->m_rgwEqBandBoundary[i]);
    iWidthR = i;
    fltWeightR /= iWidthR; // Average all the EQ gains

    // Apply each equalizer band's weighting to the desired coefficients
    for (i = 0; i < paudec->m_cEqBand; ) {
        Float fltWeightL;
        Float fltWeight;
        Int   iWidthC;

        // Shift weightings and widths down from right to left
        fltWeightL = fltWeightC;
        fltWeightC = fltWeightR;
        iWidthC = iWidthR;
        assert(iWidthC > 0);

        // Calculate next band's weight and width (one or more EQ bands may live
        // in one coefficient bin if frame size is small)
        if (i + iWidthC >= paudec->m_cEqBand)
        {
            fltWeightR = 1.0F;
            iWidthR = 0;
        }
        else
        {
            Int j = i + iWidthC;
            fltWeightR = 0;
            do
            {
                fltWeightR += paudec->m_rgfltEqBandWeight[j];
                j += 1;
            } while (j < paudec->m_cEqBand && paudec->m_rgwEqBandBoundary[j - 1] == paudec->m_rgwEqBandBoundary[j]);
            iWidthR = j - (i + iWidthC);
            fltWeightR /= iWidthR; // Average all the EQ gains
        }


        // EQUALIZE
        fltBandDiffL = fltWeightC - fltWeightL;
        fltBandDiffR = fltWeightC - fltWeightR;
        iWidthOfTransition = min (5, (paudec->m_rgwEqBandBoundary [i + iWidthC] -
            paudec->m_rgwEqBandBoundary [i]) / 4);

        for (iCoef = paudec->m_rgwEqBandBoundary [i];
            iCoef < paudec->m_rgwEqBandBoundary [i + iWidthC]; iCoef++)
        {
            if (iCoef - paudec->m_rgwEqBandBoundary [i] < iWidthOfTransition)
            {
                fltWeight = fltWeightC - (iWidthOfTransition - 1 - (iCoef -
                    paudec->m_rgwEqBandBoundary [i])) * fltBandDiffL / iWidthOfTransition;
            }
            else if (paudec->m_rgwEqBandBoundary [i + iWidthC] - iCoef <= iWidthOfTransition)
            {
                fltWeight = fltWeightC - (iWidthOfTransition -
                    (paudec->m_rgwEqBandBoundary [i + iWidthC] - iCoef)) *
                    fltBandDiffR / iWidthOfTransition;
            }
            else
                fltWeight = fltWeightC;

            ppcinfo->m_rgfltCoefRecon [iCoef] *= fltWeight;
        }

        // Advance indices
        i += iWidthC;

    } // for

    return WMA_OK;
}

Void    prvComputeBandPower (CAudioObjectDecoder* paudec)
{
    Int i;
    Float fltPower = 0;
    Int   iWidthC;
    Int   j;
    Int   iCoef;
    Float fltPwrOffset;

    for (i = 0; i < paudec->m_cEqBand; )
    {
        fltPower = 0;

        // Figure out width of this EQ band (more than one EQ band
        // may map to a single coefficient if frame size is small)
        j = i + 1;
        while (j < paudec->m_cEqBand && paudec->m_rgwEqBandBoundary[j - 1] == paudec->m_rgwEqBandBoundary[j])
            j++;
        iWidthC = j - i;

        // Calculate power of all coefficients within this EQ band
        for (iCoef = paudec->m_rgwEqBandBoundary [i];
            iCoef < paudec->m_rgwEqBandBoundary [i + iWidthC]; iCoef++)
        {
            fltPower += paudec->pau->m_rgpcinfo[0].m_rgfltCoefRecon[iCoef] *
                        paudec->pau->m_rgpcinfo[0].m_rgfltCoefRecon[iCoef];

            if (paudec->pau->m_cChannel > 1)
            {
                assert (paudec->pau->m_cChannel == 2);
                fltPower += paudec->pau->m_rgpcinfo[1].m_rgfltCoefRecon[iCoef] *
                            paudec->pau->m_rgpcinfo[1].m_rgfltCoefRecon[iCoef];
            }
        } // for

        // Record the power in one or more EQ bands
        assert (fltPower >= 0);

        // Fwd transform used to scale coefficients by sqrt(2/paudec->pau->m_cSubband),
        // but now does not so we must explicitly scale
        fltPwrOffset = (Float) (10 * log10(2.0F / paudec->pau->m_cSubband));
        for (j = i; j < i + iWidthC; j++)
        {
            fltPower = fltPwrOffset + (Float)(10*log10(fltPower));
            paudec->m_rgbBandPower[j] = (I8) checkRange (fltPower, SCHAR_MIN, SCHAR_MAX);
        }

        // Advance indices
        i += iWidthC;

    } // for
} // computeBandPower

WMARESULT audecGetBandPower (CAudioObjectDecoder* paudec, I8* rgbBandPower)
{
    rgbBandPower [0] = paudec->m_cEqBand;
    memcpy (rgbBandPower + 1, paudec->m_rgbBandPower, sizeof (I8) * MAX_NO_EQBAND);
    return WMA_OK;
}

Void    audecStartComputeBandPower (CAudioObjectDecoder* paudec)
{
    paudec->m_fComputeBandPower = WMAB_TRUE;
}

Void    audecStopComputeBandPower (CAudioObjectDecoder* paudec)
{
    paudec->m_fComputeBandPower = WMAB_FALSE;
}

Void    prvAdaptEqToSubFrame(CAudioObjectDecoder* paudec)
{
    Int i;
    // Set up the equalizer, if it needs it
    if (WMAB_FALSE == paudec->m_fNoEq && paudec->m_iEqFrameSize != paudec->pau->m_cSubFrameSampleAdjusted)
    {
        const static U16 rgwEqBandFreq [MAX_NO_EQBAND + 1] = {0, 50, 100, 200, 400, 800,
            1600, 3200, 6400, 12800, 24100};   //make sure the last one is beyond the end

        const Float fltSamplingPeriod = 1.0F / paudec->pau->m_iSamplingRate;

        paudec->m_iEqFrameSize = paudec->pau->m_cSubFrameSampleAdjusted;
        paudec->m_rgwEqBandBoundary [0] = 0;
        for (i = 0; i < MAX_NO_EQBAND; i++) {
            paudec->m_rgwEqBandBoundary [i + 1] = (U16) (rgwEqBandFreq [i + 1] *
                paudec->pau->m_cSubFrameSampleAdjusted * fltSamplingPeriod + 0.5f); //open end

            // Note that is is possible for consecutive elements of
            // paudec->m_rgwEqBandBoundary to have the same value, especially
            // in the case of small frames!

            if (paudec->m_rgwEqBandBoundary [i + 1] > paudec->pau->m_cSubbandAdjusted)    {
                paudec->m_rgwEqBandBoundary [i + 1] = (U16) paudec->pau->m_cSubbandAdjusted;
                paudec->m_cEqBand = (I8)(i + 1);
                break;
            }
        } // for
    } // if
}
#endif //ENABLE_EQUALIZER
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\entropydec.c ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    EntropyDec.cpp

Abstract:

    Implementation of entropy decoding functions.

Author:

    Wei-ge Chen (wchen) 14-July-1998

Revision History:


*************************************************************************/

#include "bldsetup.h"

#include "msaudiodec.h"
#include "huffdec.h"
#include "AutoProfile.h"  

//*****************************************************************************************
//
// prvDecodeFrameHeader
//
//*****************************************************************************************

//#define DEBUG_DECODE_TRACE
#undef DEBUG_DECODE_TRACE
#if defined (DEBUG_DECODE_TRACE)
extern unsigned int g_ulOutputSamples;
#define DEBUG_TRACE_QUANT(a, b, c)                                              \
                printf("%d %d %d %u\n", a, b, c, g_ulOutputSamples);                                  \
                fflush (stdout);
#pragma COMPILER_MESSAGE(__FILE__ "(43) : Warning - m_iQuantStepSize Debug Code Enabled.")
#else
#define DEBUG_TRACE_QUANT(a, b, c)
#endif

#if defined (_DEBUG)
#define COUNT_BITS(a,b) a += b
#else
#define COUNT_BITS(a,b)
#endif

WMARESULT prvDecodeFrameHeader (CAudioObjectDecoder* paudec, Int* piBitCnt)
{      
    Bool fSkipAll;
    Bool* fUpdateMask;
    I16  *piChannel = &paudec->m_iChannel;
    Int iMaskQPrev;
    Int iSizePrev = 0, iSizeCurr = 0, iSizeNext = 0;
    PerChannelInfo* ppcinfo;
	CAudioObject* pau = paudec->pau;

    WMARESULT   wmaResult = WMA_OK;
    U32         iResult;

#ifdef PROFILE
    FunctionProfile fp;
    FunctionProfileStart(&fp,DECODE_FRAME_HEADER_PROFILE);
#endif

    switch (paudec->m_hdrdecsts)
    {
        case HDR_SIZE:
            if (pau->m_fAllowSubFrame) 
            {
                //peek enough bits for this "case" if not enough will be on hold
                Int cBitsNeed = LOG2 ((U32) LOG2 ((U32)pau->m_iMaxSubFrameDiv)) + 1;
                TRACEWMA_EXIT(wmaResult, ibstrmLookForBits (&paudec->m_ibstrm, 12));
                if (pau->m_fHeaderReset) 
                {
                    TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, cBitsNeed, &iResult));
                    COUNT_BITS(*piBitCnt, cBitsNeed);
                    iSizePrev = pau->m_cFrameSampleHalf / (1 << iResult);

                    //current
                    TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, cBitsNeed, &iResult));
                    COUNT_BITS(*piBitCnt, cBitsNeed);
                    iSizeCurr = pau->m_cFrameSampleHalf / (1 << iResult);

                    assert (iSizePrev != 0 && iSizeCurr != 0);
                    pau->m_fHeaderReset = WMAB_FALSE;
                    if (iSizePrev  < pau->m_cMinSubFrameSampleHalf || iSizePrev > pau->m_cFrameSampleHalf ||
                        iSizeCurr  < pau->m_cMinSubFrameSampleHalf || iSizeCurr > pau->m_cFrameSampleHalf)
                    {
                        assert (WMAB_FALSE);
                        return TraceResult(WMA_E_BROKEN_FRAME);
                    }
                }

                TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, cBitsNeed, &iResult));
                COUNT_BITS(*piBitCnt, cBitsNeed);
                iSizeNext = pau->m_cFrameSampleHalf / (1 << iResult);
                if (iSizeNext  < pau->m_cMinSubFrameSampleHalf || iSizeNext > pau->m_cFrameSampleHalf)
                {
                    assert (WMAB_FALSE);
                    return TraceResult(WMA_E_BROKEN_FRAME);
                }
            }
            ASSERTWMA_EXIT(wmaResult, prvUpdateSubFrameConfig(paudec, iSizeNext, iSizePrev, iSizeCurr));
            ASSERTWMA_EXIT(wmaResult, auAdaptToSubFrameConfig (pau));
            ASSERTWMA_EXIT(wmaResult, auAdaptToSubFrameConfigDEC (pau));

#ifdef ENABLE_EQUALIZER
            prvAdaptEqToSubFrame(paudec);
#endif    //ENABLE_EQUALIZER

            if (pau->m_cChannel == 1)    {
                TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, 1, &iResult));
                pau->m_rgpcinfo [0].m_iPower = iResult;

                COUNT_BITS(*piBitCnt, 1);
                fSkipAll = (pau->m_rgpcinfo [0].m_iPower == 0);
            }
	        else if (pau->m_cChannel == 2)	{
                TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, 1, &iResult));

                pau->m_stereoMode = (StereoMode) iResult;

                COUNT_BITS(*piBitCnt, 1);
                TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, 1, &iResult));
		        pau->m_rgpcinfo [0].m_iPower = iResult;

                COUNT_BITS(*piBitCnt, 1);
                TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, 1, &iResult));
		        pau->m_rgpcinfo [1].m_iPower = iResult;

                COUNT_BITS(*piBitCnt, 1);
                fSkipAll = (pau->m_rgpcinfo [0].m_iPower == 0) & (pau->m_rgpcinfo [1].m_iPower == 0);
                prvSetDetTable  (paudec,  pau->m_rgpcinfo + 1);
            }
            pau->m_iQuantStepSize = MIN_QUANT; // shift it back by the minimum for decode or in case of exit
            if (fSkipAll) {
#               if defined(ENABLE_ALL_ENCOPT) && defined(ENABLE_LPC)
                    // no bits will be read
                    if (pau->m_iWeightingMode == LPC_MODE) 
                        TRACEWMA_EXIT(wmaResult, prvDecodeFrameHeaderLpc(paudec, (Int *)piBitCnt));
#               endif  // defined(ENABLE_ALL_ENCOPT) && defined(ENABLE_LPC)
                paudec->m_hdrdecsts = HDR_DONE;
                goto exit;
            }
            paudec->m_hdrdecsts = HDR_QUANT;

        case HDR_QUANT:
            TRACEWMA_EXIT(wmaResult, ibstrmLookForBits (&paudec->m_ibstrm, 3 * NUM_BITS_QUANTIZER));
            while(1) {
                Int iStepSize;

                TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm,
                    NUM_BITS_QUANTIZER, &iResult));
                iStepSize = iResult;

                COUNT_BITS(*piBitCnt, NUM_BITS_QUANTIZER);
                assert(iStepSize <= MSA_MAX_QUANT_ESC);
                DEBUG_TRACE_QUANT(pau->m_iFrameNumber, pau->m_iCurrSubFrame, iStepSize);
                if(iStepSize != MSA_MAX_QUANT_ESC) {
                    // the last one...
                    pau->m_iQuantStepSize += iStepSize;
			        MONITOR_RANGE(gMR_iQuantStepSize,pau->m_iQuantStepSize);
                    break;
                }
                // escape code, so on to the next level...
                pau->m_iQuantStepSize += MSA_MAX_QUANT_ESC;
            }
            auUpdateMaxEsc(pau, pau->m_iQuantStepSize);
            *piChannel  = 0;
#ifdef ENABLE_ALL_ENCOPT
            paudec->m_iBand     = (I16) pau->m_iFirstNoiseBand;;
#endif // ENABLE_ALL_ENCOPT
            paudec->m_hdrdecsts = HDR_NOISE1;

        case HDR_NOISE1 :
        case HDR_NOISE2 :
#           ifdef ENABLE_ALL_ENCOPT
            if (pau->m_fNoiseSub == WMAB_TRUE)
            {
                TRACEWMA_EXIT(wmaResult, prvDecodeFrameHeaderNoiseSub(paudec, (Int *)piBitCnt));
            }
#           endif //ENABLE_ALL_ENCOPT
            paudec->m_hdrdecsts = HDR_MSKUPD;

        case HDR_MSKUPD :

            TRACEWMA_EXIT(wmaResult, ibstrmLookForBits (&paudec->m_ibstrm, 1));
            //Setup the pointer to the quantized coefficents. This must be done after 
            //prvDecodeFrameHeaderNoiseSub since it changes the value of m_cSubbandActual
            ppcinfo = pau->m_rgpcinfo;
            ppcinfo->m_rgiCoefQ       = ((I16*) (pau->m_rgiCoefReconOrig + DOUBLE(pau->m_fPad2XTransform,pau->m_cFrameSampleHalf)))  
                                      - DOUBLE(pau->m_fPad2XTransform,ppcinfo->m_cSubbandActual);
            memset (ppcinfo->m_rgiCoefQ, 0,  sizeof (I16) * DOUBLE(pau->m_fPad2XTransform,ppcinfo->m_cSubbandActual));
            if (pau->m_cChannel == 2)   {
                ppcinfo = pau->m_rgpcinfo + 1;
                ppcinfo->m_rgiCoefQ       = ((I16*) (pau->m_rgiCoefReconOrig + DOUBLE(pau->m_fPad2XTransform, 2 * pau->m_cFrameSampleHalf)))
                                          - DOUBLE(pau->m_fPad2XTransform,ppcinfo->m_cSubbandActual);
                memset (ppcinfo->m_rgiCoefQ, 0,  sizeof (I16) * DOUBLE(pau->m_fPad2XTransform,ppcinfo->m_cSubbandActual));
            }

            fUpdateMask = &(pau->m_subfrmconfigCurr.m_rgfMaskUpdate [pau->m_iCurrSubFrame]);
            *fUpdateMask = WMAB_TRUE;
            if (pau->m_fAllowSubFrame && pau->m_subfrmconfigCurr.m_cSubFrame > 1) {
                TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, 1, &iResult));
                *fUpdateMask = iResult;
                (*piBitCnt)++;
            }
            *piChannel = 0;
            paudec->m_iBand = 0;
            paudec->m_hdrdecsts = HDR_BARK;

        case HDR_BARK :
            fUpdateMask = &(pau->m_subfrmconfigCurr.m_rgfMaskUpdate [pau->m_iCurrSubFrame]);
            if (pau->m_iWeightingMode == BARK_MODE) 
            {
                for (; *piChannel < pau->m_cChannel; (*piChannel)++)
                {
                    PerChannelInfo *ppcinfo = pau->m_rgpcinfo + *piChannel;
                    if (ppcinfo->m_iPower != 0) 
                    {
                        Int* rgiMaskQ = ppcinfo->m_rgiMaskQ;
                        if (*fUpdateMask == WMAB_TRUE)    
                        {
                            if (pau->m_iVersion == 1) {
                                TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm,
                                    NBITS_FIRST_MASKQUANT, &iResult));
	                            rgiMaskQ [0] = iResult + MIN_MASKQ_IN_DB_V1;
                                *piBitCnt += NBITS_FIRST_MASKQUANT;
                                paudec->m_iBand++;
                            }

                            for (; paudec->m_iBand < pau->m_cValidBarkBand; paudec->m_iBand++)	
                            {
				                Int iDiff;                        
                                TRACEWMA_EXIT(wmaResult, huffDecGet (g_rgiHuffDecTblMsk,
                                    &paudec->m_ibstrm, &iResult, (unsigned long *)&iDiff, (unsigned long *)0));
                                COUNT_BITS(*piBitCnt, iResult);
                                TRACEWMA_EXIT(wmaResult, ibstrmFlushBits(&paudec->m_ibstrm, iResult));   //flush bits used by huffDecGet
                                iDiff -= MAX_MASKQUANT_DIFF;
                                assert (iDiff >= -MAX_MASKQUANT_DIFF);
                                iMaskQPrev = (paudec->m_iBand == 0) ? 
                                              FIRST_V2_MASKQUANT : rgiMaskQ [paudec->m_iBand - 1];
				                rgiMaskQ [paudec->m_iBand] = iDiff + iMaskQPrev;
						        MONITOR_RANGE(gMR_rgiMaskQ, rgiMaskQ[paudec->m_iBand]);
                            }
                            pau->m_iSubFrameSizeWithUpdate = pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame];
                            paudec->m_iBand = 0;
                        }

                        //for IntFloat this gets done inside ReconWeightFactor()
                        //Scan For Max Weight
                        if (*fUpdateMask)
                        {
					        Int iMax = rgiMaskQ[0];
                            I16 iBand;
                            for (iBand = 1; iBand < pau->m_cValidBarkBand; iBand++)
                            {
                                if (rgiMaskQ[iBand] > iMax)
							        iMax = rgiMaskQ[iBand];
                            }
					        ppcinfo->m_iMaxMaskQ = iMax;
                        }
                    }
                    else if (*fUpdateMask == WMAB_TRUE)    
                    {	//else artifically set to constants since nothing got sent; see comments in msaudioenc.c
				        //0 db = 1.0 for weightfactor
				        memset( ppcinfo->m_rgiMaskQ, 0, pau->m_cValidBarkBand*sizeof(Int) );
                        ppcinfo->m_iMaxMaskQ = 0;
			        }
                }
            }
#if defined(ENABLE_ALL_ENCOPT) && defined(ENABLE_LPC)
            else 
            {
                TRACEWMA_EXIT(wmaResult, prvDecodeFrameHeaderLpc(paudec, (Int *)piBitCnt));
		        if (pau->m_fNoiseSub == WMAB_TRUE)	
			        prvGetBandWeightLowRate (paudec);
            }
#else   // defined(ENABLE_ALL_ENCOPT) && defined(ENABLE_LPC)
            else {
                assert(WMAB_FALSE);
            }
#endif  // defined(ENABLE_ALL_ENCOPT) && defined(ENABLE_LPC)
    }

    paudec->m_hdrdecsts = HDR_DONE;

exit:

#ifdef PROFILE
    FunctionProfileStop(&fp);
#endif

    return wmaResult;
}


//*****************************************************************************************
//
// prvDecodeCoefficientMono
//
//*****************************************************************************************
WMARESULT prvDecodeCoefficientMono	(CAudioObjectDecoder* paudec, 
                                     PerChannelInfo* ppcinfo, 
                                     Int* piBitCnt)
{
    WMARESULT   wmaResult = WMA_OK;

#ifdef PROFILE
    FunctionProfile fp;
    FunctionProfileStart(&fp,DECODE_COEFFICENT_MONO_PROFILE);
#endif

    if (ppcinfo->m_iPower == 0)
        goto exit;

    TRACEWMA_EXIT(wmaResult, prvDecodeRunLevel(paudec, ppcinfo, 0, ppcinfo->m_cSubbandActual, piBitCnt));

exit:
#ifdef PROFILE
    FunctionProfileStop(&fp);
#endif
    return wmaResult;
}


//*****************************************************************************************
//
// prvDecodeCoefficientStereo
//
//*****************************************************************************************
WMARESULT prvDecodeCoefficientStereo (CAudioObjectDecoder* paudec, 
                                    PerChannelInfo* ppcinfo, Int* piBitCnt)
{
    WMARESULT   wmaResult = WMA_OK;
    CAudioObject* pau = paudec->pau;

#ifdef PROFILE
    //FunctionProfile fp;
    //FunctionProfileStart(&fp,DECODE_COEFFICENT_STEREO_PROFILE);
#endif
	for (; paudec->m_iChannel < pau->m_cChannel; paudec->m_iChannel++)	
    {
        TRACEWMA_EXIT(wmaResult, prvDecodeCoefficientMono(paudec, ppcinfo + paudec->m_iChannel, piBitCnt));

        if(pau->m_iVersion == 1) 
        {
            *piBitCnt += ibstrmBitsLeft (&paudec->m_ibstrm) % 8;
		    ibstrmFlush(&paudec->m_ibstrm);         //no need to support pause mode (always has fraction bytes)
        }
        paudec->pau->m_iCurrReconCoef = 0;
	}

exit:
#ifdef PROFILE
    //FunctionProfileStop(&fp);
#endif
	return wmaResult;
}


//*****************************************************************************************
//
// prvGetNextRunDEC
//
//*****************************************************************************************
extern Int g_cBitPut;
WMARESULT prvGetNextRunDEC(Void*			 pobjin, 
					 PerChannelInfo* ppcinfo,
                     Int*			 piBitCnt)
{
	U32 uSign  = 0;		//1 for positive 0 for nonpositive
    I32 iSign  = 0;
	U32 iEntry = 0;		//index to the Vlc table entry
    U32 iResult;
    U16 cBitsTotal;
    WMARESULT     wmaResult = WMA_OK;
    CAudioObjectDecoder* paudec  = (CAudioObjectDecoder*) pobjin;
    CAudioObject*		 pau = paudec->pau;
    CWMAInputBitStream*  pibstrm = &(paudec->m_ibstrm);

    switch (paudec->m_rlsts)
    {
    case VLC:
        TRACEWMA_EXIT(wmaResult, huffDecGet (ppcinfo->m_rgiHuffDecTbl, &paudec->m_ibstrm,
            &iResult, &iEntry, &uSign));
        COUNT_BITS(*piBitCnt, iResult);
        TRACEWMA_EXIT(wmaResult, ibstrmFlushBits(&paudec->m_ibstrm, iResult));   //flush bits used by huffDecGet
	    if (iEntry == 0)
            goto escape;
        if (iEntry == 1)
        {
			/*
		    // [1], end of coefs for this subFrame 
            *pcRunOfZeros = ppcinfo->m_cSubbandActual - iCoef - 1;
            *piCurrLevel = 0;
            wmaResult = WMA_OK;
			*/
            pau->m_iLevel = 0;
			pau->m_iHighCutOffCurr = -1; 
			pau->m_iNextBarkIndex = -1;                                                                    
			pau->m_cRunOfZeros = ppcinfo->m_cSubbandActual - pau->m_iCurrReconCoef - 1;
        }
        else 
        {
			assert (iEntry >= 2);
            COUNT_BITS(*piBitCnt, 1);
            TRACEWMA_EXIT(wmaResult, ibstrmFlushBits(&paudec->m_ibstrm, 1));   //flush the sign bit also
			pau->m_cRunOfZeros = ppcinfo->m_rgiRunEntry [iEntry - 2] & 0x7FFFFFFF;
			assert (pau->m_cRunOfZeros >= 0);
			pau->m_iLevel = ppcinfo->m_rgiLevelEntry [iEntry - 2];
			pau->m_iSign = (I32) (uSign >> 31) - 1;
        }
        break;

    case ESCAPE:
escape:
        paudec->m_rlsts = ESCAPE;
        cBitsTotal = (U16) (pau->m_iMaxEscSize + pau->m_cBitsSubbandMax + 1); //<=25=13+11+1
        assert (cBitsTotal <= 25);
        TRACEWMA_EXIT(wmaResult, ibstrmLookForBits (&paudec->m_ibstrm, cBitsTotal));

        TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, cBitsTotal, &iResult));
        COUNT_BITS(*piBitCnt, cBitsTotal);

        cBitsTotal = (U16)(paudec->pau->m_cBitsSubbandMax + 1);
		pau->m_iLevel = (I16) (iResult >> cBitsTotal);
        pau->m_iSign = (I32) (iResult & 0x00000001) - 1;
        //*piCurrLevel = (I16) ((*piCurrLevel ^ iSign) - iSign);

		pau->m_cRunOfZeros = (I16) (iResult & (0xFFFFFFFF >> (32 - cBitsTotal))) >> 1;
		pau->m_cRunOfZeros &= 0x7FFFFFFF;
        paudec->m_rlsts = VLC;
	}

exit:
    return wmaResult;
}

//*****************************************************************************************
//
// prvDecodeRunLevel
//
//*****************************************************************************************
//#define RL_PRINT_SRC
#if defined (RL_PRINT_SRC)
#define DBG_RUNLEVEL(a,b,c,e)     \
                    if(e) {\
	                    printf("%d %d %d\n", a, b, c);\
                        fflush (stdout);\
                    }
#else 
#define DBG_RUNLEVEL(a,b,c,e)
#endif //DBG_RUNLEVEL

WMARESULT prvDecodeRunLevel  (CAudioObjectDecoder* paudec, 
                            PerChannelInfo* ppcinfo,
						    Int iCoefFirst, 
						    Int iCoefLim, 
                            Int* piBitCnt)
{
    I16* rgiCoefQ       = ppcinfo->m_rgiCoefQ;
    const U16* rgiRunEntry    = ppcinfo->m_rgiRunEntry;    
    const U16* rgiLevelEntry  = ppcinfo->m_rgiLevelEntry;    
    CAudioObject* pau = paudec->pau;
	I16* piCoef = &pau->m_iCurrReconCoef;	
#ifdef DEBUG_DECODE_TRACE
    DEBUG_ONLY( Bool fPrint = (g_ulOutputSamples==0x4e00); )
#else
    DEBUG_ONLY( Bool fPrint = (pau->m_iFrameNumber  <= 10 && pau->m_iCurrSubFrame == 0); )
#endif
    WMARESULT   wmaResult = WMA_OK;

    // This function is too frequently called to be profiled
	//FUNCTION_PROFILE(fp);
    //FUNCTION_PROFILE_START(&fp,DECODE_RUN_LEVEL_PROFILE);
    while (*piCoef < iCoefLim) 
    {
        TRACEWMA_EXIT(wmaResult, prvGetNextRunDEC(paudec,ppcinfo,piBitCnt));
        pau->m_iLevel = (I16) ((pau->m_iLevel ^ pau->m_iSign) - pau->m_iSign);
        DBG_RUNLEVEL(g_cBitGet-21,pau->m_cRunOfZeros,pau->m_iLevel,fPrint);
        if ( (*piCoef+ pau->m_cRunOfZeros) >= iCoefLim)  {
            assert (WMAB_FALSE);
            wmaResult = TraceResult(WMA_E_BROKEN_FRAME);
            goto exit;
        }
//        memset (rgiCoefQ + *piCoef, 0, pau->m_cRunOfZeros * sizeof (I16));
    	*piCoef += (I16) pau->m_cRunOfZeros;
		rgiCoefQ [*piCoef] = pau->m_iLevel;
		MONITOR_RANGE(gMR_iCoefQ,rgiCoefQ [*piCoef]);
		MONITOR_COUNT_CONDITIONAL(pau->m_cRunOfZeros>0,gMC_0CoefQ,pau->m_cRunOfZeros);
		(*piCoef)++;
        paudec->m_rlsts = VLC;
	}
    
exit:
    //FUNCTION_PROFILE_STOP(&fp);
	return wmaResult;
}


//*****************************************************************************************
//
// prvSetDetTable
//
//*****************************************************************************************
Void prvSetDetTable  (CAudioObjectDecoder* paudec,  PerChannelInfo* ppcinfo)
{
    CAudioObject* pau = paudec->pau;
/*** less than 0.5%
#ifdef PROFILE
    //FunctionProfile fp;
    //FunctionProfileStart(&fp,SET_DET_TABLE_PROFILE);
#endif
*///
    if (pau->m_iEntropyMode == SIXTEENS_OB)   {
        if (pau->m_stereoMode == STEREO_SUMDIFF)  {
            ppcinfo->m_rgiHuffDecTbl = g_rgiHuffDecTbl16ssOb;
            ppcinfo->m_rgiRunEntry = gRun16ssOb;    
            ppcinfo->m_rgiLevelEntry = gLevel16ssOb;    
        }
        else {
            ppcinfo->m_rgiHuffDecTbl = g_rgiHuffDecTbl16smOb; 
            ppcinfo->m_rgiRunEntry = gRun16smOb;    
            ppcinfo->m_rgiLevelEntry = gLevel16smOb;    
        }
    }
#ifdef ENABLE_ALL_ENCOPT
    else if (pau->m_iEntropyMode == FOURTYFOURS_QB)   {
        if (pau->m_stereoMode == STEREO_SUMDIFF)  {
            ppcinfo->m_rgiHuffDecTbl = g_rgiHuffDecTbl44ssQb;
            ppcinfo->m_rgiRunEntry = gRun44ssQb;    
            ppcinfo->m_rgiLevelEntry = gLevel44ssQb;
        }
        else {
            ppcinfo->m_rgiHuffDecTbl = g_rgiHuffDecTbl44smQb; 
            ppcinfo->m_rgiRunEntry = gRun44smQb;    
            ppcinfo->m_rgiLevelEntry = gLevel44smQb;    
        }
    }
    else if (pau->m_iEntropyMode == FOURTYFOURS_OB)   {
        if (pau->m_stereoMode == STEREO_SUMDIFF)  {
            ppcinfo->m_rgiHuffDecTbl = g_rgiHuffDecTbl44ssOb;
            ppcinfo->m_rgiRunEntry = gRun44ssOb;
            ppcinfo->m_rgiLevelEntry = gLevel44ssOb;
        }
        else {
            ppcinfo->m_rgiHuffDecTbl = g_rgiHuffDecTbl44smOb;
            ppcinfo->m_rgiRunEntry = gRun44smOb;
            ppcinfo->m_rgiLevelEntry = gLevel44smOb;
        }
    }
#endif // ENABLE_ALL_ENCOPT
/***
#ifdef PROFILE
    //FunctionProfileStop(&fp);
#endif
*///
}


#if defined(ENABLE_ALL_ENCOPT) && defined(ENABLE_LPC)

// define to break at a particular frame
//#define LPC_WEIGHTS_BREAK_AT_FRAME 27
// define to display overview of weight factor calculations by subframe
//#define SHOW_OVERVIEW_WEIGHT_FACTOR_FIRST 0
//#define SHOW_OVERVIEW_WEIGHT_FACTOR_LAST  60
#if defined(_DEBUG) && ( defined(SHOW_OVERVIEW_WEIGHT_FACTOR_FIRST) || defined(LPC_WEIGHTS_BREAK_AT_FRAME) )
#	pragma COMPILER_MESSAGE(__FILE__ "(644) : Warning - LPC Weight Factor Debug Code Enabled.")
#endif
#if defined(_DEBUG) && defined(LPC_WEIGHTS_BREAK_AT_FRAME)
#   define DEBUG_BREAK_AT_FRAME_LPC_WEIGHTS                 \
    if ( pau->m_iFrameNumber==LPC_WEIGHTS_BREAK_AT_FRAME )  \
        { DEBUG_BREAK(); }
#else   // define(_DEBUG) && defined(SHOW_OVERVIEW_WEIGHT_FACTOR)
#   define DEBUG_BREAK_AT_FRAME_LPC_WEIGHTS
#endif  // define(_DEBUG) && defined(SHOW_OVERVIEW_WEIGHT_FACTOR)
#if defined(_DEBUG) && defined(SHOW_OVERVIEW_WEIGHT_FACTOR_FIRST)
#   if UNDER_CE
#       define SHOW_OWF(iChan,iCase)                                            \
            if (SHOW_OVERVIEW_WEIGHT_FACTOR_FIRST <= pau->m_iFrameNumber        \
                && pau->m_iFrameNumber <= SHOW_OVERVIEW_WEIGHT_FACTOR_LAST )    \
                MyOutputDbgStr(0,"%4d %2d %d %4d %d  %+16.6f %+16.6f %+16.6f %+16.6f\n", \
                    pau->m_iFrameNumber,pau->m_iCurrSubFrame, pau->m_cSubband,  \
                    iChan, iCase,                                               \
                    FLOAT_FROM_WEIGHT(ppcinfo->m_rguiWeightFactor[0]),          \
                    FLOAT_FROM_WEIGHT(ppcinfo->m_rguiWeightFactor[1]),          \
                    FLOAT_FROM_WEIGHT(ppcinfo->m_rguiWeightFactor[2]),          \
                    FLOAT_FROM_WEIGHT(ppcinfo->m_rguiWeightFactor[3]) )
#   else // UNDER_CE
#       define SHOW_OWF(iChan,iCase)                                            \
            if (SHOW_OVERVIEW_WEIGHT_FACTOR_FIRST <= pau->m_iFrameNumber        \
                && pau->m_iFrameNumber <= SHOW_OVERVIEW_WEIGHT_FACTOR_LAST )    \
                printf("%4d %2d %d %4d %d  %+16.6f %+16.6f %+16.6f %+16.6f\n",  \
                    pau->m_iFrameNumber,pau->m_iCurrSubFrame, pau->m_cSubband,  \
                    iChan, iCase,                                               \
                    FLOAT_FROM_WEIGHT(ppcinfo->m_rguiWeightFactor[0]),          \
                    FLOAT_FROM_WEIGHT(ppcinfo->m_rguiWeightFactor[1]),          \
                    FLOAT_FROM_WEIGHT(ppcinfo->m_rguiWeightFactor[2]),          \
                    FLOAT_FROM_WEIGHT(ppcinfo->m_rguiWeightFactor[3]) )
#   endif  // UNDER_CE
#else   // define(_DEBUG) && defined(SHOW_OVERVIEW_WEIGHT_FACTOR)
#   define SHOW_OWF(iChan,iCase)
#endif  // define(_DEBUG) && defined(SHOW_OVERVIEW_WEIGHT_FACTOR)

WMARESULT prvDecodeFrameHeaderLpc (CAudioObjectDecoder* paudec, Int* piBitCnt) 
{
    Bool fUpdateMask = paudec->pau->m_subfrmconfigCurr.m_rgfMaskUpdate [paudec->pau->m_iCurrSubFrame];
	CAudioObject* pau = paudec->pau;
    I16* piChannel = &paudec->m_iChannel;
    PerChannelInfo *ppcinfo;
    // U8 rgiLspFreqQ[LPCORDER];  ONHOLD will lose this, use WeightFactor instead
    I16* piFreq = &paudec->m_iBand;  // preserve this across ONHOLD
	Int cBitAlloc;
    WMARESULT   wmaResult = WMA_OK;
    LpType rgLpcCoef [LPCORDER];
    FUNCTION_PROFILE(fp);
    FUNCTION_PROFILE_START(&fp,FRAME_HEADER_LPC_PROFILE);

    DEBUG_BREAK_AT_FRAME_LPC_WEIGHTS;

    for (; *piChannel < pau->m_cChannel; (*piChannel)++)   
	{
		ppcinfo = pau->m_rgpcinfo + *piChannel;
		if (ppcinfo->m_iPower != 0 )   
		{
			if (fUpdateMask == WMAB_TRUE)
			{
                // these 10 bytes are saved in the WeightFactor array in case we go ONHOLD.  
                // WeightFactor will be set by rgiLspFreqQ
                U8* rgiLspFreqQ = (U8*)(INTEGER_OR_INT_FLOAT( ppcinfo->m_rguiWeightFactor, ppcinfo->m_rgfltWeightFactor ));
				for (; *piFreq < LPCORDER; (*piFreq)++)	
				{
					U32         iResult;
					cBitAlloc = (*piFreq == 0 || *piFreq == 8 || *piFreq == 9) ? 3 : 4;
                
					TRACEWMA_EXIT(wmaResult, ibstrmGetBits(&paudec->m_ibstrm,
						          cBitAlloc, &iResult));
					rgiLspFreqQ[*piFreq] = (U8) iResult;

					*piBitCnt += cBitAlloc;
					MONITOR_RANGE(gMR_rgiLspFreqQ, rgiLspFreqQ[*piFreq]);
				}
				auLsp2lpc(pau, rgiLspFreqQ, rgLpcCoef, LPCORDER);
				TRACEWMA_EXIT(wmaResult, prvLpcToSpectrum(pau,
					          rgLpcCoef, ppcinfo));
                SHOW_OWF(*piChannel,0);
			}
			else if (pau->m_iCurrSubFrame > 0) 
			{	
				auResampleWeightFactorLPC (pau, ppcinfo);
                SHOW_OWF(*piChannel,1);
			}
		}
		else if (fUpdateMask == WMAB_TRUE)
		{	//artifically set to constants since nothing got sent for this channel; see comments in msaudioenc.c
			WeightType* pwtWeightFactor = (WeightType*) ppcinfo->m_rguiWeightFactor;
            I16 iFreq;
			ppcinfo->m_wtMaxWeight = WEIGHT_FROM_FLOAT(1.0F);
			for (iFreq = (I16) pau->m_cSubband; iFreq > 0; iFreq-- )
				*pwtWeightFactor++ = WEIGHT_FROM_FLOAT(1.0F);
            SHOW_OWF(*piChannel,2);
		}
        else if (pau->m_iCurrSubFrame > 0) 
		{	// resample even if zero power, these weights might be used in a later subframe with non-zero power
            auResampleWeightFactorLPC (pau, ppcinfo);
            SHOW_OWF(*piChannel,3);
		}
        *piFreq = 0;
	}

exit:
    FUNCTION_PROFILE_STOP(&fp);
    return wmaResult;
}
#endif  // ENABLE_LPC

#if defined (_DEBUG)
#define COUNT_BITS(a,b) a += b
#else
#define COUNT_BITS(a,b)
#endif

#ifdef ENABLE_ALL_ENCOPT
WMARESULT prvDecodeFrameHeaderNoiseSub (CAudioObjectDecoder* paudec, Int* piBitCnt)
{
    U8*	rgbBandNotCoded;
    Int iStart, iEnd;
    Int iCode;
    U32 cBitUsed;
    I16* piChannel = &paudec->m_iChannel;
    I16* piBand = &paudec->m_iBand;
	CAudioObject* pau = paudec->pau;

    WMARESULT   wmaResult = WMA_OK;
    U32         iResult;
	FUNCTION_PROFILE(fp);
	FUNCTION_PROFILE_START(&fp,FRAME_HEADER_NOISE_SUB_PROFILE);

    switch (paudec->m_hdrdecsts)
    {
        case HDR_NOISE1:
            //noise band indicator
            for (; *piChannel < pau->m_cChannel; (*piChannel)++)   {
                PerChannelInfo* ppcinfo = pau->m_rgpcinfo + *piChannel;
                TRACEWMA_EXIT(wmaResult, ibstrmLookForBits (&paudec->m_ibstrm, 
                                pau->m_cValidBarkBand - pau->m_iFirstNoiseBand));                
                if (ppcinfo->m_iPower != 0) {
                    rgbBandNotCoded = ppcinfo->m_rgbBandNotCoded;
                    *rgbBandNotCoded = 0;
                    ppcinfo->m_cSubbandActual = pau->m_iFirstNoiseIndex - pau->m_cLowCutOff;
                    iStart = 0, iEnd = 0;
                    while (WMAB_TRUE) {
                        iStart = max (pau->m_iFirstNoiseIndex, pau->m_rgiBarkIndex [*piBand]);
                        if (iStart >= pau->m_cHighCutOff)
                            break;
                        iEnd   = min (pau->m_cHighCutOff, pau->m_rgiBarkIndex [*piBand + 1]);

                        TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, 1, &iResult));
				        rgbBandNotCoded [*piBand] = (U8) iResult;

                        (*piBitCnt)++;
				        if (rgbBandNotCoded [*piBand] != 0)
					        rgbBandNotCoded [0]++;
                        else 
                            ppcinfo->m_cSubbandActual += iEnd - iStart;
                        (*piBand)++;
			        }
			        if (*piBand < pau->m_cValidBarkBand )
				        rgbBandNotCoded [*piBand] = (U8) 0;		// protect from debug verify code looking one band past end  
                }
                else 
                    ppcinfo->m_cSubbandActual = 0;
                assert (ppcinfo->m_cSubbandActual >= 0 &&
                        ppcinfo->m_cSubbandActual <= pau->m_cHighCutOff - pau->m_cLowCutOff);
                *piBand = (I16) pau->m_iFirstNoiseBand;
            }
            paudec->m_hdrdecsts = HDR_NOISE2;
            *piChannel = 0;
            //I guess
            *piBand = 0;

        case HDR_NOISE2:
            //noise power
            for (; *piChannel < pau->m_cChannel; (*piChannel)++)   {
                PerChannelInfo* ppcinfo = pau->m_rgpcinfo + *piChannel;
                if (ppcinfo->m_iPower != 0) {
			        U8*	 rgbBandNotCoded = ppcinfo->m_rgbBandNotCoded;
			        Int* rgiNoisePower   = ppcinfo->m_rgiNoisePower;
			        if (rgbBandNotCoded [0] > 0)	{
                        if (*piBand == 0)
                        {
                            TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, 7, &iResult));
				            rgiNoisePower [0] = iResult - 19;
                            (*piBand)++;
                            *piBitCnt += 7;
                        }

				        for (; *piBand < rgbBandNotCoded [0]; (*piBand)++)	{
                            TRACEWMA_EXIT(wmaResult, huffDecGet (g_rgiHuffDecTblNoisePower,
                                          &paudec->m_ibstrm, &cBitUsed, (unsigned long *)&iCode, (unsigned long *)0));
                            TRACEWMA_EXIT(wmaResult, ibstrmFlushBits(&paudec->m_ibstrm, cBitUsed));     //flush bits used by huffDecGet
                            COUNT_BITS(*piBitCnt, cBitUsed);
					        rgiNoisePower [*piBand] = iCode - 18 + rgiNoisePower [*piBand - 1];

					        MONITOR_RANGE(gMR_rgiNoisePower,rgiNoisePower[*piBand]);
				        }
			        }
                }
                *piBand = 0;
            }
    }

exit:
	FUNCTION_PROFILE_STOP(&fp);
    return wmaResult;
}

//******************************************************************************************
//
//  Helper functions for prvGetBandWeightLowRate
//  These functions can be replaced by processor dependent optimized variants
//

#ifndef FFLT_AVG_SQUARE_WEIGHTS
#   if defined(BUILD_INTEGER)
#       if defined(U64SQUARE32SR)
#           define U64_SQUARE_I32(x) U64SQUARE32SR(x, 0)
#       else
#           define U64_SQUARE_I32(x) (((U64)(x)) * ((U64)(x))) 
#       endif
        INLINE FastFloat ffltAvgSquareWeights(WeightType* pwtWeightFactor, Int cN )
        {
            U64 u64Sum = 0;
            FastFloat fflt;
            Int i = cN;
	        for ( ; i > 0; i--, pwtWeightFactor++) {
                u64Sum += U64_SQUARE_I32(*pwtWeightFactor);
            }
            // convert to a fastfloat and then divide.  This avoids an int64 division which is
            // really slow on the sh 3 and quite slow on other risc/dsp machines
            // cN varies from 1 to 328 so this can lose 8.3 bits of precision.
            // but we are comparing to float implementation which has only 24 bits of mantissa.
            fflt = FASTFLOAT_FROM_U64( u64Sum, (WEIGHTFACTOR_FRACT_BITS<<1) );
            fflt.iFraction /= cN;
            Norm4FastFloatU( &fflt );
            return fflt;
        }
#   else
        INLINE Float ffltAvgSquareWeights(WeightType* pwtWeightFactor, Int cN )
        {
            Float fltSum = 0;
            Int i = cN;
	        for ( ; i > 0; i--, pwtWeightFactor++) {
                fltSum += *pwtWeightFactor * *pwtWeightFactor;
	        }
            return fltSum/cN;
        }
#   endif
#   define FFLT_AVG_SQUARE_WEIGHTS( pwtWeightFactor, cN ) ffltAvgSquareWeights( pwtWeightFactor, cN )
#endif


#ifndef FFLT_SQRT_RATIO
    INLINE FastFloat ffltSqrtRatio( FastFloat fflt1, FastFloat fflt2 )
    {
#       if defined(BUILD_INTEGER)
            U64 u64Ratio;
            FastFloat fflt;
            Int iMSF8;
            U32 uiMSF;
            U32 uiFrac1;
            Int iExp = 0;
            if ( fflt2.iFraction==0 ) {
                assert( fflt2.iFraction != 0 ); // divide by 0
                fflt.iFraction = 0x7FFFFFFF;
                fflt.iFracBits = 0;
                return fflt;
            }
            //// fflt1.iFraction*0.5F/(1<<(fflt1.iFracBits-1))
            //// fflt2.iFraction*0.5F/(1<<(fflt2.iFracBits-1))
            u64Ratio = (((U64)fflt1.iFraction)<<32)/fflt2.iFraction;
            uiMSF = (U32)(u64Ratio>>32);
            if ( uiMSF==0 ) {
                iExp = 32;
                uiMSF = (U32)u64Ratio;
            }
            assert( uiMSF != 0 ) ;
            // normalize the most significant fractional part
            while( (uiMSF & 0xF0000000)==0 ) {
                iExp += 4;
                uiMSF <<= 4;
            }
            while( (uiMSF & 0x80000000)==0 ) {
                iExp++;
                uiMSF <<= 1;
            }
            // discard the most significant one bit (it's presence is built into g_InvQuadRootFraction)
            iExp++;
            // get all 32 bits from source
#           if defined(PLATFORM_OPTIMIZE_MINIMIZE_BRANCHING)
                uiMSF = (U32)((u64Ratio<<iExp)>>32);
#           else
                uiMSF = (iExp>32) ? (U32)(u64Ratio<<(iExp-32)) : (U32)(u64Ratio>>(32-iExp));
#           endif
            // split into top SQRT_FRACTION_TABLE_LOG2_SIZE==8 bits for fractional lookup and bottom bits for interpolation
            iMSF8 = uiMSF>>(32-SQRT_FRACTION_TABLE_LOG2_SIZE);
            uiMSF <<= SQRT_FRACTION_TABLE_LOG2_SIZE;
            // lookup and interpolate
            uiFrac1  = g_SqrtFraction[iMSF8++];   // BP2
            uiFrac1 += MULT_HI_UDWORD( uiMSF,  g_SqrtFraction[iMSF8] - uiFrac1 );
            // adjust by sqrt(1/2) if expoenent is odd
            if ( (iExp+fflt1.iFracBits-fflt2.iFracBits) & 1 ) {
                // multiply by 1/sqrt(2) and adjust fracbits by 1/2
                uiFrac1 = MULT_HI_UDWORD( uiFrac1, UBP0_FROM_FLOAT(0.70710678118654752440084436210485) );
                fflt.iFracBits = ((fflt1.iFracBits-(fflt2.iFracBits+1))>>1)+(iExp-3);
            } else {
                fflt.iFracBits = ((fflt1.iFracBits-fflt2.iFracBits)>>1)+(iExp-3);
            }
            fflt.iFraction = uiFrac1>>1;    // make sure sign is positive
            //// fflt.iFraction*0.5F/(1<<(fflt.iFracBits-1))
			Norm4FastFloatU( &fflt );
#           if defined(_DEBUG) && 0
            {   // old way used float
			    Float flt = (Float)sqrt( FloatFromFastFloat(fflt1) / FloatFromFastFloat(fflt2) );
                if ( fabs( flt - FloatFromFastFloat(fflt) ) > 0.01 ) {
                    DEBUG_BREAK();
                }
            }
#           endif
            return fflt;
#       else
			return (Float)sqrt( fflt1 / fflt2 );
#       endif
    }
#   define FFLT_SQRT_RATIO(fflt1,fflt2) ffltSqrtRatio(fflt1,fflt2)
#endif


// display noise bands used only once
//#define SHOW_NOISE_BANDS
#if defined(_DEBUG) && defined(SHOW_NOISE_BANDS)
    I16 iShown[2049] = { 1, 0 };
#   define SHOW_NOISE_BANDS_ONCE                                    \
        if (iShown[0]==1)                                           \
            memset( iShown, 0, 2049*sizeof(I16) );                  \
        if ((iShown[iEnd-iStart] & paudec->pau->m_cSubband)==0)     \
        {                                                           \
            iShown[iEnd-iStart] |= paudec->pau->m_cSubband;         \
            printf("%4d  %2d  %4d  %4d  %4d  %16.12f\n",            \
                paudec->pau->m_cSubbandAdjusted, iBand,                     \
                iStart, iEnd, iEnd-iStart, 1.0f/(iEnd-iStart) );    \
        }
#else
#   define SHOW_NOISE_BANDS_ONCE
#endif


Void prvGetBandWeightLowRate (CAudioObjectDecoder* paudec)
{
    U8*	rgbBandNotCoded;
    Int iBand;
    Int iStart, iEnd;
    Int iChannel;
	U8 cNoiseBand;
#if 0
    Int i;
    Float fltWeightFactor;
    Float fltInvBandWithd;
#endif
    FUNCTION_PROFILE(fp);
    FUNCTION_PROFILE_START(&fp,GET_BAND_WEIGHTS_PROFILE);

    //calculating band weight
    for (iChannel = 0; iChannel < paudec->pau->m_cChannel; iChannel++)   {
        if (paudec->pau->m_rgpcinfo [iChannel].m_iPower != 0) {
		    FastFloat rgfltBandWeight[25];
			FastFloat* rgffltSqrtBWRatio = paudec->pau->m_rgpcinfo[iChannel].m_rgffltSqrtBWRatio;
            WeightType* rgxWeightFactor  = paudec->pau->m_rgpcinfo[iChannel].INTEGER_OR_INT_FLOAT(m_rguiWeightFactor,m_rgfltWeightFactor);
		    rgbBandNotCoded = paudec->pau->m_rgpcinfo[iChannel].m_rgbBandNotCoded;
		    cNoiseBand = 0;
            iStart = 0, iEnd = 0;
            iBand = paudec->pau->m_iFirstNoiseBand;            
            while (WMAB_TRUE)    {
                iStart = max (paudec->pau->m_iFirstNoiseIndex, paudec->pau->m_rgiBarkIndex [iBand]);
                if (iStart >= paudec->pau->m_cHighCutOff)
                    break;
                assert (iBand < paudec->pau->m_cValidBarkBand);
                iEnd   = min (paudec->pau->m_cHighCutOff, paudec->pau->m_rgiBarkIndex [iBand + 1]);
                assert (iEnd >= iStart);

			    if (rgbBandNotCoded [iBand] == 1)	{
                    // This may be slower than straight divide, but we must do this to
                    // remain consistent with prvGetNoiseLikeBandsMono
                    rgfltBandWeight [cNoiseBand] = FFLT_AVG_SQUARE_WEIGHTS( rgxWeightFactor+iStart, iEnd-iStart );
                    //// rgfltBandWeight[cNoiseBand].iFraction*1.0F/(1<<rgfltBandWeight[cNoiseBand].iFracBits)
					MONITOR_RANGE(gMR_rgfltBandWeight,FLOAT_FROM_FASTFLOAT(rgfltBandWeight[cNoiseBand]));
					MONITOR_COUNT(gMC_GBW_floats,1+(iEnd-iStart)*2 );
				    cNoiseBand++;
			    }
                SHOW_NOISE_BANDS_ONCE;
                iBand++;
		    }
		    assert (cNoiseBand < paudec->pau->m_cValidBarkBand);
		    assert (paudec->pau->m_iFirstNoiseBand > 0);
			for( iBand = 0; iBand < (cNoiseBand-1); iBand++ )
			{	
				// This calculation is not ideally suited to FastFloat, leave in float for time being
				// But note that limited range of the result probably means it can be done more quickly
                rgffltSqrtBWRatio[iBand] = FFLT_SQRT_RATIO( rgfltBandWeight[iBand], rgfltBandWeight[cNoiseBand-1] );
				//// float SqrtBWRatio = fflt.iFraction*1.0F/(1<<fflt.iFracBits)
				MONITOR_RANGE(gMR_rgffltSqrtBWRatio,FLOAT_FROM_FASTFLOAT(rgffltSqrtBWRatio[iBand]));
				MONITOR_COUNT(gMC_GBW_floats,14);		// count sqrt as 10.
			}
			if (cNoiseBand > 0)
			{	// last band has a ratio of 1.0
#if defined(BUILD_INTEGER)
				rgffltSqrtBWRatio[cNoiseBand-1].iFraction = 0x40000000;
				rgffltSqrtBWRatio[cNoiseBand-1].iFracBits = 30;
#else
				rgffltSqrtBWRatio[cNoiseBand-1] = 1.0F;
#endif
				MONITOR_RANGE(gMR_rgffltSqrtBWRatio,1.0F);
			}
		    rgbBandNotCoded [0] = cNoiseBand; //used as cNoiseBand
        }
    }
    FUNCTION_PROFILE_STOP(&fp);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\float.c ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    MsAudio.cpp

Abstract:

    Floating point implementation of public member functions for CAudioObject.

Author:

    Wei-ge Chen (wchen) 11-March-1998

Revision History:


*************************************************************************/

#include "bldsetup.h"

#if !defined(_WIN32_WCE) && !defined(HITACHI)
#include <time.h>
#endif  // _WIN32_WCE

#include <math.h>
#include <limits.h>
#include <stdio.h>
#include "msaudio.h"
#include "macros.h"
#include "AutoProfile.h"

#ifndef BUILD_INTEGER

/////////////////////////////////////////////////////////////////////////
//      Floating point versions of code that has already been integerized
//      this may eventionally be deleted
//////////////////////////////////////////////////////////////////////////

//floating version
WMARESULT prvAdaptTrigToSubframeConfig(CAudioObject *pau)
{
    WMARESULT wmaResult = WMA_OK;
    Int iSize2Use;
	Double dA;
#   if !defined(V4V5_COMPARE_MODE) && !defined(INTEGER_ENCODER)
    const SinCosTable*  pSinCosTable;
#endif

    //if the adjacent size is bigger; just keep your own shape
    //otherwise a transition window is needed.
    if (pau->m_iSizePrev >= pau->m_iSizeCurr) {
        //just forward copy curr
		iSize2Use = pau->m_iSizeCurr;
    }
    else  {
        //long start
		iSize2Use = pau->m_iSizePrev;
    }

#ifdef USE_SIN_COS_TABLES
    switch (iSize2Use){
        case 2048:
            pau->m_piSinForRecon = pau->m_piSinForRecon2048;
            break;
        case 1024:
            pau->m_piSinForRecon = pau->m_piSinForRecon1024;
            break;
        case 512 :
            pau->m_piSinForRecon = pau->m_piSinForRecon512;
            break;
        case 256 :
            pau->m_piSinForRecon = pau->m_piSinForRecon256;
            break;
        case 128 :
            pau->m_piSinForRecon = pau->m_piSinForRecon128;
            break;
        case 64  :
            pau->m_piSinForRecon = pau->m_piSinForRecon64;
            break;
        default: 
            assert(0);
            return (TraceResult (WMA_E_BROKEN_FRAME));
    }
#endif  //maby else out next section


#   if !defined(V4V5_COMPARE_MODE) && !defined(INTEGER_ENCODER)
        // Use lookup-tables if we can 
        // Saves 1% of play time of SH4 and a tiny bit on an 233MHz Pentium II
        if (iSize2Use >= 64 && iSize2Use <= 2048)
        {
            pSinCosTable = rgSinCosTables[iSize2Use>>7];
            // START: see below for detailed explaination
            pau->m_fltSinRampUpStart =   pSinCosTable->sin_PIby4cSB;    //(Int) (sin (0.5 * PI / iSizeCurr / 2) * 0x3FFFFFFF);
            pau->m_fltCosRampUpStart =   pSinCosTable->cos_PIby4cSB;    //(Int) (cos (0.5 * PI / iSizeCurr / 2) * 0x3FFFFFFF);
            // PRIOR: see below for detailed explaination
            pau->m_fltSinRampUpPrior =  -pSinCosTable->sin_PIby4cSB;
            pau->m_fltCosRampUpPrior =   pSinCosTable->cos_PIby4cSB;
            pau->m_fltSinRampUpStep  = 2*pSinCosTable->sin_PIby2cSB;   // STEP = 2 * sin (PI / 2 / iSizeCurr) * 0x3FFFFFFF;
#           ifdef _DEBUG
            {   // Include the next code-block to verify changes to the lookup-table
                dA = PI / (4*iSize2Use);
                assert(fabs(pau->m_fltSinRampUpStart - sin ( dA ) ) <= 0.0001);
                assert(fabs(pau->m_fltCosRampUpStart - cos ( dA ) ) <= 0.0001);
                assert(fabs(pau->m_fltSinRampUpPrior - sin( -dA ) ) <= 0.0001);
                assert(fabs(pau->m_fltCosRampUpPrior - cos( -dA ) ) <= 0.0001);
                assert(fabs(pau->m_fltSinRampUpStep  -  2 * sin( 2*dA ) ) <= 0.0001); 
            }
#           endif // _DEBUG
        }
        else
#   endif // !defined(V4V5_COMPARE_MODE) && !defined(INTEGER_ENCODER)    
        {
            // START:  sin ((0.5 + iSize2Use) * PI / (2*iSize2Use) )
	        //		 = sin ( PI/(4*iSize2Use) + PI/2 ) =  cos( PI/(4*iSize2Use) )
	        // AND:    cos ((0.5 + iSize2Use) * PI / (2*iSize2Use) )
	        //       = cos ( PI/(4*iSize2Use) + PI/2 ) = -sin( PI/(4*iSize2Use) )
	        dA = PI / (4*iSize2Use);
            pau->m_fltSinRampUpStart =  (V4V5COMPARE)(sin ( dA ));
            pau->m_fltCosRampUpStart =  (V4V5COMPARE)(cos ( dA ));
	        // PRIOR:  sin ((0.5 + iSize2Use) * PI / (2*iSize2Use) -PI/(2*iSize2Use) )
	        //       = sin ( PI/(4*iSize2Use) + PI/2 - PI/(2*iSize2Use) ) 
            //       = cos( -PI/(4*iSize2Use) ) = cos( PI/(4*iSize2Use) )
	        // AND:    cos ((0.5 + iSize2Use) * PI / (2*iSize2Use) -PI/(2*iSize2Use) )
	        //       = cos ( PI/(4*iSize2Use) + PI/2 - PI/(2*iSize2Use) ) 
            //       = -sin( -PI/(4*iSize2Use) ) = sin( PI/(4*iSize2Use) )
	        pau->m_fltSinRampUpPrior =  (V4V5COMPARE)(sin( -dA ));
	        pau->m_fltCosRampUpPrior =  (V4V5COMPARE)(cos( -dA ));

            // Rotate by PI/(2*iSize2Use)
	        pau->m_fltSinRampUpStep  =  (V4V5COMPARE)( 2 * sin( 2*dA ) );
        }


    if (pau->m_iSizeNext >= pau->m_iSizeCurr) {
		iSize2Use = pau->m_iSizeCurr;
    }
    else    {
        //just backward copy curr
		iSize2Use = pau->m_iSizeNext;
    }

#ifdef USE_SIN_COS_TABLES
    switch (iSize2Use){
        case 2048:
            pau->m_piSinForSaveHistory = pau->m_piSinForRecon2048+2048;
            break;
        case 1024:
            pau->m_piSinForSaveHistory = pau->m_piSinForRecon1024+1024;
            break;
        case 512 :
            pau->m_piSinForSaveHistory = pau->m_piSinForRecon512+512;
            break;
        case 256 :
            pau->m_piSinForSaveHistory = pau->m_piSinForRecon256+256;
            break;
        case 128 :
            pau->m_piSinForSaveHistory = pau->m_piSinForRecon128+128;
            break;
        case 64  :
            pau->m_piSinForSaveHistory = pau->m_piSinForRecon64+64;
            break;
        default: 
            assert (0);
            return (TraceResult (WMA_E_BROKEN_FRAME));
    }
#endif //USE_SIN_COS_TABLES

#   if !defined(V4V5_COMPARE_MODE) && !defined(INTEGER_ENCODER)
        // Use lookup-tables if we can
        if (iSize2Use >= 64 && iSize2Use <= 2048)
        {
            pSinCosTable = rgSinCosTables[iSize2Use>>7];
            // START: see below for detailed explaination
            pau->m_fltSinRampDownStart =   pSinCosTable->cos_PIby4cSB;  //(Int) sin ((0.5 + iSizeNext) * PI / iSizeNext / 2);
            pau->m_fltCosRampDownStart =  -pSinCosTable->sin_PIby4cSB;  //(Int) cos ((0.5 + iSizeNext) * PI / iSizeNext / 2);
            // PRIOR: see below for detailed explaination
            pau->m_fltSinRampDownPrior =   pSinCosTable->cos_PIby4cSB;
            pau->m_fltCosRampDownPrior =   pSinCosTable->sin_PIby4cSB;
            pau->m_fltSinRampDownStep  = 2*pSinCosTable->sin_PIby2cSB;     // STEP = 2 * sin (PI / 2 / iSizeCurr) * 0x3FFFFFFF;
#           ifdef _DEBUG
            {   // Include this code-block to verify changes to the lookup-table
	            dA = PI/(4* iSize2Use);
                assert(fabs(pau->m_fltSinRampDownStart - cos( dA )) <= 0.0001);
                assert(fabs(pau->m_fltCosRampDownStart + sin( dA )) <= 0.0001);       // + == - -
                assert(fabs(pau->m_fltSinRampDownPrior - cos( dA )) <= 0.0001);
                assert(fabs(pau->m_fltCosRampDownPrior - sin( dA )) <= 0.0001);
                assert(fabs(pau->m_fltSinRampDownStep  - 2 * sin( 2*dA )) <= 0.0001);
            }
#           endif // _DEBUG
        }
        else
#   endif // !defined(V4V5_COMPARE_MODE) && !defined(INTEGER_ENCODER)    
        { 
            // START:  sin ((0.5 + iSize2Use) * PI / (2*iSize2Use) )
	        //		 = sin ( PI/(4*iSize2Use) + PI/2 ) =  cos( PI/(4*iSize2Use) )
	        // AND:    cos ((0.5 + iSize2Use) * PI / (2*iSize2Use) )
	        //       = cos ( PI/(4*iSize2Use) + PI/2 ) = -sin( PI/(4*iSize2Use) )
	        dA = PI/(4* iSize2Use);
            pau->m_fltSinRampDownStart = (V4V5COMPARE)(cos( dA ));
            pau->m_fltCosRampDownStart = (V4V5COMPARE)(-sin( dA ));
	        // PRIOR:  sin ((0.5 + iSize2Use) * PI / (2*iSize2Use) -PI/(2*iSize2Use) )
	        //       = sin ( PI/(4*iSize2Use) + PI/2 - PI/(2*iSize2Use) ) 
            //       = cos( -PI/(4*iSize2Use) ) = cos( PI/(4*iSize2Use) )
	        // AND:    cos ((0.5 + iSize2Use) * PI / (2*iSize2Use) -PI/(2*iSize2Use) )
	        //       = cos ( PI/(4*iSize2Use) + PI/2 - PI/(2*iSize2Use) ) 
            //       = -sin( -PI/(4*iSize2Use) ) = sin( PI/(4*iSize2Use) )
	        pau->m_fltSinRampDownPrior =  (V4V5COMPARE)(cos( dA ));
	        pau->m_fltCosRampDownPrior =  (V4V5COMPARE)(sin( dA ));
	        // Rotate by PI/(2*iSize2Use)

	        pau->m_fltSinRampDownStep  =  (V4V5COMPARE)( 2 * sin( 2*dA ) );
        }

#ifdef INTEGER_ENCODER
    wmaResult = prvAdaptTrigToSubframeConfig_INT(pau);
#endif  // INTEGER_ENCODER
    return wmaResult;
}

#endif // !BUILD_INTEGER

/////////////////////////////////////////////////////////////////////////
//      Floating point versions of code that has already been integerized
//      this may eventually be deleted
//////////////////////////////////////////////////////////////////////////

// DEBUG_BREAK at a particular Frame in prvInverseQuantizeHighRate or prvInverseQuantizeLowRate 
//#define INVERSE_QUANTIZE_AT_FRAME 26
// PRINT CoefRecon for all Frames in range (define or undefine both at once)
//#define PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST 178
//#define PRINT_INVERSE_QUANTIZE_AT_FRAME_LAST  178
#if defined(_DEBUG) && ( defined(INVERSE_QUANTIZE_AT_FRAME) || defined(PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST)  )
#	pragma COMPILER_MESSAGE(__FILE__ "(235) : Warning - Float Inverse Quantize Debug Code Enabled.")
static int iInvQuantFrameCount = 0;
static int iInvQuantSubFrameCount = 0;
#endif
#if defined(_DEBUG) && defined(INVERSE_QUANTIZE_AT_FRAME)
#	define DEBUG_BREAK_AT_FRAME_INV_QUANT															\
		if ( pau->m_iCurrSubFrame == 0 && ppcinfo == pau->m_rgpcinfo )								\
		{	iInvQuantFrameCount++;	iInvQuantSubFrameCount = 0; }									\
		else if ( ppcinfo == pau->m_rgpcinfo ) iInvQuantSubFrameCount++;							\
		if ( iInvQuantFrameCount == INVERSE_QUANTIZE_AT_FRAME )										\
			DEBUG_BREAK();				
#elif defined(_DEBUG) && defined(PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST)
#	define DEBUG_BREAK_AT_FRAME_INV_QUANT															\
		if ( pau->m_iCurrSubFrame == 0 && ppcinfo == pau->m_rgpcinfo )								\
		{	iInvQuantFrameCount++;	iInvQuantSubFrameCount = 0; }									\
		else if ( ppcinfo == pau->m_rgpcinfo ) iInvQuantSubFrameCount++;
#else	// defined(_DEBUG) && defined(INVERSE_QUANTIZE_AT_FRAME)
#	define DEBUG_BREAK_AT_FRAME_INV_QUANT
#endif	// defined(_DEBUG) && defined(INVERSE_QUANTIZE_AT_FRAME)
#if defined(PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST)
#	define PRINT_INVERSE_QUANTIZE(iQ,fltW,fltN)																									\
		if ( PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST <= pau->m_iFrameNumber &&  pau->m_iFrameNumber <= PRINT_INVERSE_QUANTIZE_AT_FRAME_LAST )	\
			printf("IQ:%4d %2d %1d  %4d  %+16.6f  %+16.6f  %4d %+10.4g\n",																			\
				 pau->m_iFrameNumber, pau->m_iCurrSubFrame, ppcinfo-pau->m_rgpcinfo, iRecon, fltW,rgfltCoefRecon [iRecon], iQ, fltN );
#else
#	define PRINT_INVERSE_QUANTIZE(iQ,fltW,fltN)
#	endif

#ifndef BUILD_INTEGER
#ifdef ENABLE_ALL_ENCOPT

//*************************************************************************************************
// prvInverseQuantizeLowRate() calculates values in rgfltCoefRecon[] prior to DCT 
// Handles both MidRate (NoiseSub and Bark Spectrum) and LowRate (NoiseSub and LPC Spectrum)
//*************************************************************************************************
WMARESULT prvInverseQuantizeLowRate (CAudioObject* pau, PerChannelInfo* ppcinfo,
                                     Int* rgiWeightFactor)
{
    FUNCTION_PROFILE(fp);
    FUNCTION_PROFILE_START(&fp,INVERSE_QUAN_LOW_RATE_PROFILE);
    {
		//Double dblQuantStep = (double)pau->m_iQuantStep/(1<<pau->m_iQuantStepFractBits);
		QuantStepType qstQuantStep = qstCalcQuantStep( pau->m_iQuantStepSize );
		const Float* rgfltWeightFactor  = (Float*) rgiWeightFactor;
		Float fltInvMaxWeight = 1.0F / ppcinfo->m_wtMaxWeight;
        const I16* rgiCoefQ             = ppcinfo->m_rgiCoefQ;
        Float* rgfltCoefRecon           = ppcinfo->m_rgfltCoefRecon;
	    Int iBark = 0;
	    Int iCoefQ = 0;
	    Int iRecon = 0;
        const U8* rgbBandNotCoded       = ppcinfo->m_rgbBandNotCoded;
        const Int* rgiNoisePower		= ppcinfo->m_rgiNoisePower;
	    //	Float* rgfltNoise = pau->m_rgfltGaussRand + (rand () % (20480 / pau->m_cSubband)) * pau->m_cSubband; //swith to diff segments
	    U8 cNoiseBand;
	    Int iNoiseBand = 0;
		QuantStepType qstQuantStepDivMaxWeight = qstQuantStep * fltInvMaxWeight;
		Float fltNoiseFactor;
		Int iTarget;

		DEBUG_BREAK_AT_FRAME_INV_QUANT;
		MONITOR_RANGE(gMR_QuantStepXInvMaxWeight,qstQuantStep*fltInvMaxWeight);		// match monitor in integer version

		if (!pau->m_fNoiseSub) {
			// Unusual case, but 8kHz Mono 8kpbs gets here
			memset (rgfltCoefRecon, 0, pau->m_cLowCutOff * sizeof (Float));
			for (iRecon = pau->m_cLowCutOff; iRecon < pau->m_cHighCutOff; iRecon++, iCoefQ++)
    			rgfltCoefRecon [iRecon] = (Float)((Float) (rgiCoefQ [iCoefQ]) * rgfltWeightFactor [iRecon] * qstQuantStepDivMaxWeight );
			memset (rgfltCoefRecon + pau->m_cHighCutOff, 0, (pau->m_cSubband - pau->m_cHighCutOff) * sizeof (Float));
            FUNCTION_PROFILE_STOP(&fp);
			return WMA_OK;
		}

		cNoiseBand = rgbBandNotCoded[0];

		fltNoiseFactor = pau->m_fltDitherLevel / (Float) 0x20000000;
		iTarget = pau->m_cLowCutOff;
		while  (iRecon < iTarget) 	
		{	// This does not happen in V2 sounds, don't bother to optimize
		    Float fltNoise = fltNoiseFactor * ((Float) quickRand (&(pau->m_tRandState)));
		    rgfltCoefRecon [iRecon] = (Float) (fltNoise * rgfltWeightFactor [pau->m_cLowCutOff] * qstQuantStepDivMaxWeight );
			MONITOR_RANGE(gMR_CoefRecon,rgfltCoefRecon[iRecon]);
			MONITOR_COUNT_CONDITIONAL(fabs(rgfltCoefRecon[iRecon])<(1.0F/(1<<TRANSFORM_FRACT_BITS)),gMC_zeroCoefRecon,1);
			MONITOR_RANGE(gMR_WeightRatio,(rgfltWeightFactor[pau->m_cLowCutOff]*fltInvMaxWeight));
			PRINT_INVERSE_QUANTIZE(0,rgfltWeightFactor[pau->m_cLowCutOff],fltNoise);
		    iRecon++;
        }

		iTarget = pau->m_iFirstNoiseIndex;
	    while  (iRecon < iTarget) {
            Float fltNoise = ((Float) quickRand (&(pau->m_tRandState))) * fltNoiseFactor;
		    if (iRecon >= pau->m_rgiBarkIndex [iBark + 1]) 
				iBark++;
            assert(iBark < NUM_BARK_BAND);
		    rgfltCoefRecon [iRecon] = (Float) ((rgiCoefQ [iCoefQ] + fltNoise) * rgfltWeightFactor [iRecon] *
                qstQuantStepDivMaxWeight );			
			MONITOR_RANGE(gMR_CoefRecon,rgfltCoefRecon[iRecon]);
			MONITOR_COUNT_CONDITIONAL(fabs(rgfltCoefRecon[iRecon])<(1.0F/(1<<TRANSFORM_FRACT_BITS)),gMC_zeroCoefRecon,1);
			MONITOR_RANGE(gMR_WeightRatio,(rgfltWeightFactor[iRecon]*fltInvMaxWeight));
			MONITOR_RANGE(gMR_weightFactor,rgfltWeightFactor[iRecon]);
			MONITOR_RANGE(gMR_QuantStepXMaxWeightXWeightFactor,rgfltWeightFactor[iRecon]*qstQuantStepDivMaxWeight);
			PRINT_INVERSE_QUANTIZE(rgiCoefQ [iCoefQ],rgfltWeightFactor [iRecon],fltNoise);
		    iRecon++;
		    iCoefQ++;
        }  
		
        while  (iRecon < pau->m_cHighCutOff) {
		    if (iRecon >= pau->m_rgiBarkIndex [iBark + 1]) 
				iBark++;
            assert(iBark < NUM_BARK_BAND);
			iTarget = min(pau->m_rgiBarkIndex [iBark + 1],pau->m_cHighCutOff);

			if (rgbBandNotCoded [iBark] == WMAB_TRUE)
            {
                // Exact match with int-float decoder only when I store in two variables! Naveen
                Float fltNoisePower0 = (Float)qstCalcQuantStep(rgiNoisePower [iNoiseBand]);
                Float fltNoisePower1 = pau->aupfnCalcSqrtBWRatio(ppcinfo, iNoiseBand, cNoiseBand);
                Float fltNoisePower = fltNoisePower0 * fltNoisePower1;

                assert(iBark < NUM_BARK_BAND);
				fltNoisePower *= fltInvMaxWeight / (Float) 0x20000000;
			    while (iRecon < iTarget)
                {
				    rgfltCoefRecon [iRecon] = ((Float) quickRand (&(pau->m_tRandState))) * fltNoisePower 
											* rgfltWeightFactor [iRecon];
					MONITOR_RANGE(gMR_CoefRecon,rgfltCoefRecon[iRecon]);
					MONITOR_COUNT_CONDITIONAL(fabs(rgfltCoefRecon[iRecon])<(1.0F/(1<<TRANSFORM_FRACT_BITS)),gMC_zeroCoefRecon,1);
					MONITOR_RANGE(gMR_WeightRatio,(rgfltWeightFactor[iRecon]*fltInvMaxWeight));
					MONITOR_RANGE(gMR_weightFactor,rgfltWeightFactor[iRecon]);
					PRINT_INVERSE_QUANTIZE(0,rgfltWeightFactor [iRecon],rgfltCoefRecon [iRecon]/rgfltWeightFactor [iRecon]);
				    iRecon++;	
			    }
			    iNoiseBand++;
		    }
		    else 
			{
				if ( pau->m_cHighCutOff < iTarget )
					iTarget = pau->m_cHighCutOff;
			    while (iRecon < iTarget)
                {
					Float fltNoise = ((Float) quickRand (&(pau->m_tRandState))) * fltNoiseFactor;
					rgfltCoefRecon [iRecon] = (Float) ((rgiCoefQ [iCoefQ] + fltNoise) * rgfltWeightFactor [iRecon] *
						qstQuantStepDivMaxWeight );			
					MONITOR_RANGE(gMR_CoefRecon,rgfltCoefRecon[iRecon]);
					MONITOR_COUNT_CONDITIONAL(fabs(rgfltCoefRecon[iRecon])<(1.0F/(1<<TRANSFORM_FRACT_BITS)),gMC_zeroCoefRecon,1);
					MONITOR_RANGE(gMR_WeightRatio,(rgfltWeightFactor[iRecon]*fltInvMaxWeight));
					MONITOR_RANGE(gMR_QuantStepXMaxWeightXWeightFactor,rgfltWeightFactor[iRecon]*qstQuantStepDivMaxWeight);
					MONITOR_RANGE(gMR_weightFactor,rgfltWeightFactor[iRecon]);
					PRINT_INVERSE_QUANTIZE(rgiCoefQ [iCoefQ],rgfltWeightFactor [iRecon],fltNoise);
					iRecon++;
					iCoefQ++;
				}
		    }
	    }

		iTarget = pau->m_cSubband;
		fltNoiseFactor *= (Float)(rgfltWeightFactor [pau->m_cHighCutOff - 1] * qstQuantStepDivMaxWeight);
	    while  (iRecon < iTarget) 	{
		    rgfltCoefRecon [iRecon] = ((Float) quickRand (&(pau->m_tRandState))) * fltNoiseFactor;
			// MONITOR_RANGE(gMR_CoefRecon,rgfltCoefRecon[iRecon]);
			// if (fabs(rgfltCoefRecon[iRecon])<(1.0F/(1<<TRANSFORM_FRACT_BITS))) { MONITOR_COUNT(gMC_zeroCoefRecon,1); }
			MONITOR_RANGE(gMR_WeightRatio,(rgfltWeightFactor[pau->m_cHighCutOff-1]*fltInvMaxWeight));
			MONITOR_RANGE(gMR_QuantStepXMaxWeightXWeightFactor,rgfltWeightFactor[pau->m_cHighCutOff-1]*qstQuantStepDivMaxWeight);
			MONITOR_RANGE(gMR_weightFactor,rgfltWeightFactor[pau->m_cHighCutOff-1]);
			PRINT_INVERSE_QUANTIZE(0,rgfltWeightFactor [iRecon],rgfltCoefRecon [iRecon]/rgfltWeightFactor [pau->m_cHighCutOff - 1]);
		    iRecon++;
        }    
    }
    FUNCTION_PROFILE_STOP(&fp);
	return WMA_OK;
}
#endif // ENABLE_ALL_ENCOPT
#endif // !BUILD_INTEGER
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\fft.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       fft.c
//
//  The FFT used for the DctIV and DctIV
//
//--------------------------------------------------------------------------

#include "bldsetup.h"

#include <math.h>
//#include <assert_wma.h>
#include <stdio.h>
#include <limits.h>
#include "msaudio.h"
#include "macros.h"
#include "AutoProfile.h"

// Define to get Split Radix FFt algorithm - which is expected to be 30% faster than Radix 2
//#define SPLIT_RADIX_FFT

#if defined(WMA_TARGET_MIPS) && defined(BUILD_INTEGER)


// Now separately build each processor
//#    include "../mips/transform_mips.c"

#elif ( defined(WMA_TARGET_SH3) || defined(WMA_TARGET_SH4) ) && defined(BUILD_INTEGER)

// Now separately build each processor
//#    include "../sh3/transform_sh3.c"

#elif defined(WMA_TARGET_SH4) && defined(BUILD_INT_FLOAT)

// Now separately build each processor
//#    include "../sh4/transform_sh4.c"

#else

// Some Algorithm Counters to match to journal article operation counts
#if defined(_DEBUG) && 0

    static int cButterfly0 = 0;         // R2 butterfly with no multiplies
    static int cButterfly1 = 0;         // R4 butterfly with no multiplies
    static int cButterfly2 = 0;         // R2 or R4 butterfly with a complex multiply
    static int cTrig  = 0;              // number of sin/cos recursions
    static int cAdditions = 0;          // number of Data additions (float or I32)
    static int cMultiplications = 0;    // number of Data mutliplications (float or I32)
    static int cIndexing = 0;           // count array indexing/incrementing
    static int cLoops = 0;              // count loops
    static int cLoopIndexing = 0;       // count extra loop indexing operations
    static int cTrigAdditions = 0;      // Additions for trig recursions
    static int cTrigMultiplications = 0; // multiplications for trig recursions

#   define DEBUG_COUNT_BTFLY0(a,m,i) cButterfly0++; cAdditions += a; cMultiplications += m; cIndexing += i;
#   define DEBUG_COUNT_BTFLY1(a,m,i) cButterfly1++; cAdditions += a; cMultiplications += m; cIndexing += i;
#   define DEBUG_COUNT_BTFLY2(a,m,i) cButterfly2++; cAdditions += a; cMultiplications += m; cIndexing += i;
#   define DEBUG_COUNT_TRIG(a,m)     cTrig++;  cTrigAdditions += a;  cTrigMultiplications += m;
#   define DEBUG_COUNT_LOOP(i)       cLoops++; cLoopIndexing += i;

#else // _DEBUG

#   define DEBUG_COUNT_BTFLY0(a,m,i)
#   define DEBUG_COUNT_BTFLY1(a,m,i)
#   define DEBUG_COUNT_BTFLY2(a,m,i)
#   define DEBUG_COUNT_TRIG(a,m)
#   define DEBUG_COUNT_LOOP(i)

#endif // _DEBUG

static const double dPI = PI;       // 3.1415926535897932384626433832795;

// the following defines do most of the computational work of the FFT, so they should be done efficently
// note need ur and ui to be defined unless assembly routines which should not need them
// note pointers will be incremented as a side effect of these macros
// define these in assembly for any processor whose compiler needs further optimization

#if !defined(SPLIT_RADIX_FFT)


#define FFTBUTTERFLY0(pxk,pxi) \
/* Butterfly at angle == 0 */ \
    ur = *pxk - *pxi;               /* ur = px[k] - px[i];      */ \
    *pxk++ += *pxi;                 /* px[k]   += px[i];        */ \
    *pxi++ = ur;                    /* px[i]   = ur;            */ \
    ui = *pxk - *pxi;               /* ui = px[k+1] - px[i+1];  */ \
    *pxk++ += *pxi;                 /* px[k+1] += px[i+1];      */ \
    *pxi++ = ui;                    /* px[i+1] = ui;            */
// leave pxi and pxk incremented by 2
// The SH-3 compiler generates very good code for fftbutterfly0

#define FFTBUTTERFLY(pxk,pxi,CR,SI)     \
/* Butterfly at a non-zero angle */     \
    ur = *pxk - *pxi;           /* ur = px[k] - px[i];    */ \
    *pxk++ += *pxi++;           /* px[k]   += px[i];      */ \
    ui = *pxk - *pxi;           /* ui = px[k+1] - px[i+1];*/ \
    *pxk++ += *pxi--;           /* px[k+1] += px[i+1];    */ \
    *pxi++ = MULT_BP2(CR,ur) - MULT_BP2(SI,ui);  /* px[i]   = cr * ur - (si) * ui; */ \
    *pxi++ = MULT_BP2(CR,ui) + MULT_BP2(SI,ur);  /* px[i+1] = cr * ui + (si) * ur; */ \
// leave pxi and pxk incremented by 2

// *************************************************************************************
// Spilt radix inverse FFT which scales by 2/N in a step-wise fashion
// *************************************************************************************

#if defined(BUILD_INTEGER)

#define FFTBUTTERFLY0_N(pxk,pxi) \
/* Butterfly at angle == 0 with inputs divided by 2*/ \
    ur = (tk = *pxk>>1) - (ti = *pxi>>1);   /* ur = px[k] - px[i];      */ \
    *pxk++ = tk + ti;                       /* px[k]   += px[i];        */ \
    *pxi++ = ur;                            /* px[i]   = ur;            */ \
    ui = (tk = *pxk>>1) - (ti = *pxi>>1);   /* ui = px[k+1] - px[i+1];  */ \
    *pxk++ = tk + ti;                       /* px[k+1] += px[i+1];      */ \
    *pxi++ = ui;                    /* px[i+1] = ui;            */
// leave pxi and pxk incremented by 2
// The SH-3 compiler generates very good code for fftbutterfly0

#define FFTBUTTERFLY_N(pxk,pxi,CR,SI)       \
/* Butterfly at a non-zero angle with inputs divided by 2*/     \
    ur = (tk = *pxk>>1) - (ti = *pxi++>>1); /* ur = px[k] - px[i];    */ \
    *pxk++ = tk + ti;                       /* px[k]   += px[i];      */ \
    ui = (tk = *pxk>>1) - (ti = *pxi-->>1); /* ui = px[k+1] - px[i+1];*/ \
    *pxk++ = tk + ti;                       /* px[k+1] += px[i+1];    */ \
    *pxi++ = MULT_BP2(CR,ur) - MULT_BP2(SI,ui);  /* px[i]   = cr * ur - (si) * ui; */ \
    *pxi++ = MULT_BP2(CR,ui) + MULT_BP2(SI,ur);  /* px[i+1] = cr * ui + (si) * ur; */ \
// leave pxi and pxk incremented by 2

#else // must be BUILD_INT_FLOAT

#define FFTBUTTERFLY0_N(pxk,pxi) FFTBUTTERFLY0(pxk,pxi)

#define FFTBUTTERFLY_N(pxk,pxi,CR,SI) FFTBUTTERFLY(pxk,pxi,CR,SI)

#endif

#ifndef _M_IX86
// the following tables save floating point conversions and trig function calls
// compiler is unwilling to evaluate a constant expression of the form cos(PI/4) as a constant
static const BP1Type icosPIbynp[16] = { 
        BP1_FROM_FLOAT(-0.999999999999996),   // cos(dPI/1)
        BP1_FROM_FLOAT(-0.000000043711390),   // cos(dPI/2)
        BP1_FROM_FLOAT(0.707106765732237),    // cos(dPI/4)
        BP1_FROM_FLOAT(0.923879528329380),    // cos(dPI/8)
        BP1_FROM_FLOAT(0.980785279337272),    // cos(dPI/16)
        BP1_FROM_FLOAT(0.995184726404418),    // cos(dPI/32)
        BP1_FROM_FLOAT(0.998795456138147),    // cos(dPI/64)
        BP1_FROM_FLOAT(0.999698818679443),    // cos(dPI/128)
        BP1_FROM_FLOAT(0.999924701834954),    // cos(dPI/256)
        BP1_FROM_FLOAT(0.999981175281554),    // cos(dPI/512)
        BP1_FROM_FLOAT(0.999995293809314),    // cos(dPI/1024)
        BP1_FROM_FLOAT(0.999998823451636),    // cos(dPI/2048)
        BP1_FROM_FLOAT(0.999999705862866),    // cos(dPI/4096)
        BP1_FROM_FLOAT(0.999999926465714),    // cos(dPI/8192)
        BP1_FROM_FLOAT(0.999999981616428),    // cos(dPI/16384)
        BP1_FROM_FLOAT(0.999999995404107) };  // cos(dPI/32768)
static const BP1Type isinPIbynp[16] = { 
        BP1_FROM_FLOAT(0.000000087422780),    // sin(-dPI/1)
        BP1_FROM_FLOAT(-0.999999999999999),   // sin(-dPI/2)
        BP1_FROM_FLOAT(-0.707106796640858),   // sin(-dPI/4)
        BP1_FROM_FLOAT(-0.382683442461104),   // sin(-dPI/8)
        BP1_FROM_FLOAT(-0.195090327375064),   // sin(-dPI/16)
        BP1_FROM_FLOAT(-0.098017143048367),   // sin(-dPI/32)
        BP1_FROM_FLOAT(-0.049067675691754),   // sin(-dPI/64)
        BP1_FROM_FLOAT(-0.024541229205697),   // sin(-dPI/128)
        BP1_FROM_FLOAT(-0.012271538627189),   // sin(-dPI/256)
        BP1_FROM_FLOAT(-0.006135884819899),   // sin(-dPI/512)
        BP1_FROM_FLOAT(-0.003067956848339),   // sin(-dPI/1024)
        BP1_FROM_FLOAT(-0.001533980228972),   // sin(-dPI/2048)
        BP1_FROM_FLOAT(-0.000766990340086),   // sin(-dPI/4096)
        BP1_FROM_FLOAT(-0.000383495198243),   // sin(-dPI/8192)
        BP1_FROM_FLOAT(-0.000191747602647),   // sin(-dPI/16384)
        BP1_FROM_FLOAT(-0.000095873801764) }; // sin(-dPI/32768)
#endif // _M_IX86


// *************************************************************************************
//  Radix 2 FFT
//  when BUILD_INTEGER, does a scale by 2/N FFT
//  when BUILD_INT_FLOAT, does a regular FFT
// *************************************************************************************

        
void prvFFT4DCT(CoefType data[], Int nLog2np, FftDirection fftDirection)
{
    I32 np = (1<<nLog2np);
    CoefType *px = data;
    I32 i, j, k, l, m, n;
    CoefType *pxk, *pxi;
    CoefType ur, ui;
#if defined(BUILD_INTEGER)
    CoefType tk, ti;
#endif

    // defining the following COSSIN structure allows us to pass a pointer to a set of values in asm code
    // but WinCE/SH-3 compiler seems to do a particularly bad job of optimizing access to structure members!
    // struct COSSIN { I32 CR2,SI2,CR1,SI1,STEP,CR,SI;  } cs;
    BP2Type CR2,SI2,CR1,SI1,STEP,CR,SI;
    FUNCTION_PROFILE(fp);
    FUNCTION_PROFILE_START(&fp,FFT_PROFILE);

#ifdef _M_IX86
    // Pentium sin/cos are fast
    CR = BP2_FROM_FLOAT(cos(dPI/np));
    STEP = BP2_FROM_FLOAT(2*sin(-dPI/np));
#else // _M_IX86
    // other platforms' sin/cos unlikely to be that optimized, so do lookup
    {
        if ( nLog2np < 16 )
        {
            CR = BP2_FROM_BP1(icosPIbynp[nLog2np]);         // CR = (I32)(cos(PI/np) * NF2BP2)
#ifdef BUILD_INTEGER
            STEP = isinPIbynp[nLog2np];                     // STEP = (I32)(2*sin(-PI/np) * NF2BP2)
#else
            STEP = BP2_FROM_FLOAT(2*isinPIbynp[nLog2np]);   // STEP = (I32)(2*sin(-PI/np) * NF2BP2)
#endif
        }
        else
        {
            CR = BP2_FROM_FLOAT(cos(dPI/np));
            STEP = BP2_FROM_FLOAT(2*sin(-dPI/np));
        }
    }
#endif // _M_IX86
    
    if (fftDirection == FFT_INVERSE) STEP *= -1;
    
    SI = DIV2(STEP);                                    // SI = (I32)(sin(-PI/np) * NF2BP2)

    ///  comments with three /// show example indexing sequences for np=1024 and times the loop is executed [1x]

    n = 2 * np;                             /// n: 2048
    m = n;

    while (m > 4) {                         /// m: {2048, ... 16, 8} [9x]
        l = m >> 1;
        CR2 = BP2_FROM_FLOAT(1);                                // cos(0)
        SI2 = 0;                                                // sin(0)
        CR1 = BP2_FROM_FLOAT(1) - MULT_BP2(STEP,SI);    // cos(2*2*PI/m)
        SI = SI1 = MULT_BP2(STEP,CR);                   // sin(2*2*PI/m)
        CR = CR1;
        STEP = MUL2(SI1);

        // Trivial butterflies (angle = 0) 
        for (k = 0; k < n; k += m) {        /// k: {0} {0,1024} ... {0,8,16...2044} [512x]
            i = k + l;                      /// i: {1024} {1024,2048} ... {4,12,20...2040}
            pxk = &px[k];
            pxi = &px[i];
            // +1/-1 butterfly 
            FFTBUTTERFLY0_N(pxk,pxi);                   // update px[i], px[i+1] and px[k], px[k+1], leave pointers +2
             // +1/-1/W_k butterfly 
            FFTBUTTERFLY_N(pxk,pxi,CR1,SI1);    // update px[i+2], px[i+2+1] and px[k+2], px[k+2+1], leave pointers +2
            /* Butterfly at a non-zero angle */ 
            //  ur = *pxk - *pxi;           /* ur = px[k] - px[i];    */ \
            //  *pxk++ += *pxi++;           /* px[k]   += px[i];      */ \
            //  ui = *pxk - *pxi;           /* ui = px[k+1] - px[i+1];*/ \
            //  *pxk++ += *pxi--;           /* px[k+1] += px[i+1];    */ \
            //  *pxi++ = MULT_BP2(CR,ur) - MULT_BP2(SI,ui);  /* px[i]   = cr * ur - (si) * ui; */ \
            //  *pxi++ = MULT_BP2(CR,ui) + MULT_BP2(SI,ur);  /* px[i+1] = cr * ui + (si) * ur; */ \
            // leave pxi and pxk incremented by 2
            DEBUG_COUNT_BTFLY0(4,0,4);
            DEBUG_COUNT_BTFLY1(6,4,6);
        }
        // Nontrivial butterflies 
        for (j = 4; j < l; j += 4) {        /// j: {4,8...1020} {4,8,...510} ... {4} {} [~510x]

            // recurrsion to next sin and cosine values where Theta = 2*PI/m;
            // CR2 = cos(-j*Theta);  SI2 = sin(-j*Theta); CR1 = cos((-j-2)*Theta); SI1 = sin((-j-2)*Theta);
            // recursion: cos(a-2b) = cos(a) - 2*sin(b)*cos(a-b)
            // and:       sin(a-2b) = sin(a) + 2*sin(b)*sin(a-b)
            CR2 -= MULT_BP2(STEP,SI1);
            SI2 += MULT_BP2(STEP,CR1);
            CR1 -= MULT_BP2(STEP,SI2);
            SI1 += MULT_BP2(STEP,CR2);

            // do main butterflies
            for (k = j; k <= n; k += m) {   /// k: {{4}{8}...{1020}} {{4,1028}{8,1032}...{508,1020}} ... {{4,20...2044}} [2048x]
                pxk = &px[k];
                pxi = &px[k + l];
                // +1/-1/W_k butterfly 
                FFTBUTTERFLY_N(pxk,pxi,CR2,SI2);        // update px[i], px[i+1] and px[k], px[k+1], leave pointers at +2
                // +1/-1/W_k butterfly 
                FFTBUTTERFLY_N(pxk,pxi,CR1,SI1);        // update px[i+2], px[i+2+1] and px[k+2], px[k+2+1], leave pointers at +2
                /* Butterfly at a non-zero angle */     \
                //  ur = *pxk - *pxi;           /* ur = px[k] - px[i];    */ \
                //  *pxk++ += *pxi++;           /* px[k]   += px[i];      */ \
                //  ui = *pxk - *pxi;           /* ui = px[k+1] - px[i+1];*/ \
                //  *pxk++ += *pxi--;           /* px[k+1] += px[i+1];    */ \
                //  *pxi++ = MULT_BP2(CR,ur) - MULT_BP2(SI,ui);  /* px[i]   = cr * ur - (si) * ui; */ \
                //  *pxi++ = MULT_BP2(CR,ui) + MULT_BP2(SI,ur);  /* px[i+1] = cr * ui + (si) * ur; */ \
                // leave pxi and pxk incremented by 2
                DEBUG_COUNT_BTFLY1(6,4,6);
                DEBUG_COUNT_BTFLY1(6,4,6);
                DEBUG_COUNT_LOOP(2);
            }
            DEBUG_COUNT_TRIG(2,2);
            DEBUG_COUNT_TRIG(2,2);
            DEBUG_COUNT_LOOP(2);
        }
        m  = l;
        DEBUG_COUNT_TRIG(2,2);
        DEBUG_COUNT_LOOP(2);
    }
    if (m > 2) {
        // m normally exits the loop above == 4, so normally do this except when called with np = 1 or 2
        for (j = 0; j < n; j += 4) {        /// j: {0,4...2044}  [512x]
            pxi = (pxk = px+j) + 2;
            
            // +1/-1 butterfly 
            FFTBUTTERFLY0(pxk,pxi);
            DEBUG_COUNT_BTFLY0(4,0,4);
            DEBUG_COUNT_LOOP(2);
        }
    }
    if (n > 4) {
        I32 n2, n21;
        CoefType tmp;

        n2 = np / 2;                        /// n2: 512
        n21 = np + 1;                       /// n21: 1025
        j = 0;                              
        for (i = 0; i < np; i += 4) {       /// i,j: 0,0; 4,1024; 8,512; 12,1536; ... 2044,??? [255x]

            if (i < j) {
                // swap 4 pairs of values (2 complex pairs with 2 others)
                // px[i] <-> px[j]; px[i+1] <-> px[j+1]
                // px[i+1+n21] <-> px[j+1+n21];  px[i+1+n21+1] <-> px[j+1+n21+1]
                pxi = &px[i];
                pxk = &px[j];
                tmp = *pxi; 
                *pxi++ = *pxk;
                *pxk++ = tmp;
                tmp = *pxi;
                *pxi = *pxk;
                *pxk = tmp;
                pxi  += n21;
                pxk  += n21;
                tmp = *pxi;
                *pxi++ = *pxk;
                *pxk++ = tmp;
                tmp = *pxi;
                *pxi = *pxk;
                *pxk = tmp;
            }

            // swap 2 pairs of values (1 complex pair with another)
            // px[i+2] <-> px[j+np];  px[i+3] <-> px[j+np+1]
            pxi = &px[i+2];
            pxk = &px[j+np];
            tmp = *pxi; 
            *pxi++ = *pxk;
            *pxk++ = tmp;
            tmp = *pxi;
            *pxi = *pxk;
            *pxk = tmp;

            k = n2;                         
            while (k <= j) {                /// k: {1024} {1024,512} {1024} {1024,512,256} ...
                j -= k;
                k = k / 2;
            }
            j += k;                         /// j: {1024} {512} {1536} {256} ...
        }
    }
    if (fftDirection == FFT_INVERSE) // Normalization to match Intel library
        for (i = 0; i < 2 * np; i++) data[i] /= np;
    FUNCTION_PROFILE_STOP(&fp);
}

#else // so must be SPLIT_RADIX_FFT

//****************************************************************************************************************
//
// A Split Radix FFT for the DCT -
// See WMAConcepts.xls - Sheet SRFFT32 for how this works.
// See also Sorensen & Heldeman, IEEE Trans ASSP, Vol ASSP-34, #1, 2/86, pp152-156.
// And also G. M. Blair, Electronics & Comm Engr Journal, August 1995, pp169-177.
//
//****************************************************************************************************************

#define BP2Const6(a,b,c,d,e,f) BP2_FROM_FLOAT(a),BP2_FROM_FLOAT(b),BP2_FROM_FLOAT(c), \
                               BP2_FROM_FLOAT(d),BP2_FROM_FLOAT(e),BP2_FROM_FLOAT(f)

static const BP2Type rgcbp2SrFFTTrig[] = {
//        STEP1             STEP3       
//        2sin(2pi/2^k) Cos(2pi/2^k)  Sin(2pi/2^k)  2sin(6pi/2^k)  Cos(6pi/2^k)  Sin(6pi/2^k)
BP2Const6(1.41421356237,0.70710678119,0.70710678119,1.41421356237,-0.70710678119,0.70710678119),    // K=3
BP2Const6(0.76536686473,0.92387953251,0.38268343237,1.84775906502, 0.38268343237,0.92387953251),    // K=4
BP2Const6(0.39018064403,0.98078528040,0.19509032202,1.11114046604, 0.83146961230,0.55557023302),    // K=5
BP2Const6(0.19603428066,0.99518472667,0.09801714033,0.58056935451, 0.95694033573,0.29028467725),    // K=6
BP2Const6(0.09813534865,0.99879545621,0.04906767433,0.29346094891, 0.98917650996,0.14673047446),    // k=7
BP2Const6(0.04908245705,0.99969881870,0.02454122852,0.14712912720, 0.99729045668,0.07356456360),    // k=8
BP2Const6(0.02454307657,0.99992470184,0.01227153829,0.07361444588, 0.99932238459,0.03680722294),    // k=9
BP2Const6(0.01227176930,0.99998117528,0.00613588465,0.03681345981, 0.99983058180,0.01840672991),    // k=10
BP2Const6(0.00613591353,0.99999529381,0.00306795676,0.01840750956, 0.99995764455,0.00920375478),    // k=11
BP2Const6(0.00306796037,0.99999882345,0.00153398019,0.00920385224, 0.99998941108,0.00460192612),    // k=12
BP2Const6(0.00153398064,0.99999970586,0.00076699032,0.00460193830, 0.99999735277,0.00230096915),    // k=13
BP2Const6(0.00076699038,0.99999992647,0.00038349519,0.00230097067, 0.99999933819,0.00115048534),    // k=14
BP2Const6(0.00038349519,0.99999998162,0.00019174760,0.00115048553, 0.99999983455,0.00057524276),    // k=15
BP2Const6(0.00019174760,0.99999999540,0.00009587380,0.00057524279, 0.99999995864,0.00028762139),    // k=16
0,0,0,0,0,0 };


#if defined(_DEBUG) && 0
// some code to show looping 
FILE* fileFFTDump = NULL;
Int* pFFTIndex = NULL;
#define DUMP_FFT_OPEN(msg,np)                          \
    if (fileFFTDump == NULL )                          \
        fileFFTDump = fopen("DUMP_FFT.TXT","wt");      \
    if (fileFFTDump != NULL )                          \
        fprintf( fileFFTDump, msg, np );               \
    pFFTIndex = wmvrealloc(pFFTIndex,2*np*sizeof(Int));\
    memset( pFFTIndex,0,2*np*sizeof(Int));
#define DUMP_FFT_SET(i,v) pFFTIndex[i] = v;
#define DUMP_FFT_SHOW(msg,k,np)                         \
    {   int i;                                          \
        if (fileFFTDump != NULL ) {                     \
            fprintf( fileFFTDump, msg, k, np );         \
            for( i=0; i<2*np; i += 2 ) {                \
                fprintf( fileFFTDump, "%d,  %d,\n",     \
                    i, pFFTIndex[i] );                  \
            }                                           \
        }                                               \
        memset( pFFTIndex, 0, 2*np*sizeof(Int) );       \
    }
#else
#define DUMP_FFT_OPEN(msg,np)
#define DUMP_FFT_SET(i,v)
#define DUMP_FFT_SHOW(msg,k,np)
#endif

#ifdef BUILD_INTEGER
#   define INTDIV2(a) ((a)>>1)
#else
#   define INTDIV2(a) (a)
#endif

void prvFFT4DCT(CoefType data[], Int nLog2np, FftDirection fftDirection)
{
    Int np = (1<<nLog2np);
    Int np2 = np<<1;
    Int np2m7 = np2-7;
    CoefType *pxk, *pxi, *px0, *px1, *px2, *px3;
    CoefType *px = data;
    I32 i, j, k, iOffset, iStride, iStridem1;
    Int n2k, n2km1, n2km2, n2kp2, idx;
    CoefType tmp, ur0, ui0, ur1, ui1;
    BP2Type bp2Step1, bp2Cos1, bp2Sin1, bp2Step3, bp2Cos3, bp2Sin3;
    BP2Type bp2Cos1p, bp2Sin1p, bp2Cos3p, bp2Sin3p;
    BP2Type bp2Cos1T, bp2Sin1T, bp2Cos3T, bp2Sin3T;
    CoefType ur2, ui2, ur3, ui3, urp, uip, urm, uim;
    const BP2Type* pbp2Trig = rgcbp2SrFFTTrig;
    INTEGER_ONLY( Int n2kp1; )

    FUNCTION_PROFILE(fp);
    FUNCTION_PROFILE_START(&fp,FFT_PROFILE);
    DUMP_FFT_OPEN("//FFT np = %d\n", np );

    
    assert(fftDirection == FFT_FORWARD); // not implemented inverse yet.
    
    // bit reverse (same code as Radix 2)
    if (np > 2) {
        I32 n2, n21;

        n2 = np / 2;                        /// n2: 512
        n21 = np + 1;                       /// n21: 1025
        j = 0;                              
        for (i = 0; i < np; i += 4) {       /// i,j: 0,0; 4,1024; 8,512; 12,1536; ... 2044,??? [255x]

            if (i < j) {
                // swap 4 pairs of values (2 complex pairs with 2 others)
                // px[i] <-> px[j]; px[i+1] <-> px[j+1]
                // px[i+1+n21] <-> px[j+1+n21];  px[i+1+n21+1] <-> px[j+1+n21+1]
                pxi = &px[i];
                pxk = &px[j];
                tmp = *pxi; 
                *pxi++ = *pxk;
                *pxk++ = tmp;
                tmp = *pxi;
                *pxi = *pxk;
                *pxk = tmp;
                pxi  += n21;
                pxk  += n21;
                tmp = *pxi;
                *pxi++ = *pxk;
                *pxk++ = tmp;
                tmp = *pxi;
                *pxi = *pxk;
                *pxk = tmp;
            }

            // swap 2 pairs of values (1 complex pair with another)
            // px[i+2] <-> px[j+np];  px[i+3] <-> px[j+np+1]
            pxi = &px[i+2];
            pxk = &px[j+np];
            tmp = *pxi; 
            *pxi++ = *pxk;
            *pxk++ = tmp;
            tmp = *pxi;
            *pxi = *pxk;
            *pxk = tmp;

            k = n2;                         
            while (k <= j) {                /// k: {1024} {1024,512} {1024} {1024,512,256} ...
                j -= k;
                k = k / 2;
            }
            j += k;                         /// j: {1024} {512} {1536} {256} ...
        }
    }
 
    // Length 2 butterflies
    for( iOffset = 0, iStride = 8; 
            iOffset < np2; 
                iOffset = (iStride<<1) - 4, iStride <<= 2 )
    {
        iStridem1 = iStride-1;
        for( idx = iOffset, px1 = (px0 = px+iOffset) + 2;
                idx < np2; 
                    idx += iStride, px0 += iStridem1, px1 += iStridem1 )
        {
            ur0 = *px0;
            ur1 = *px1; 
            *px0++ = ur0 + ur1;
            *px1++ = ur0 - ur1;
            ui0 = *px0;
            ui1 = *px1; 
            *px0 = ui0 + ui1;
            *px1 = ui0 - ui1;
            DUMP_FFT_SET(idx,2);
            DUMP_FFT_SET(idx+2,1);
            DEBUG_COUNT_BTFLY0(4,0,4);
            DEBUG_COUNT_LOOP(2);
        }
        DEBUG_COUNT_LOOP(6);
    }
    DUMP_FFT_SHOW("k = %d.\n", 1, np );

    // Radix 4 like Butterflies - either with ot without multiplies
    n2k = 2;
    for( k=2; k<=nLog2np; k++ )
    {
        n2k <<= 1;
        n2km1 = n2k>>1;
        n2km2 = n2k>>2;
        n2kp2 = n2k<<2;
#ifdef BUILD_INTEGER
        n2kp1 = n2k<<1;
        // we must scale all the px's by 2 that will not be accessed in the remainder of this main loop
        for( iOffset = n2kp1, iStride = n2k<<3; 
                iOffset < np2; 
                    iOffset = (iStride<<1) - n2kp1, iStride <<= 2 )
        {
            for( idx = iOffset; idx < np2; idx += iStride )
            {
                for( i = 0, px0 = px+idx; i < n2kp1; i++ )
                    *px0++ >>= 1;
            }
        }
#endif 
        // Trivial Butterflies - j==0 - no multiplies since Cos==1 and Sin==0
        for( iOffset = 0, iStride = n2kp2; 
                iOffset < np2; 
                    iOffset = (iStride - n2k)<<1, iStride <<= 2 )
        {
            px3 = (px2 = (px1 = (px0 = px+iOffset) + n2km1) + n2km1) + n2km1;
            iStridem1 = iStride-1;
            for( idx = iOffset; 
                    idx < np2m7; 
                        idx += iStride, px0 += iStridem1, px1 += iStridem1, px2 += iStridem1, px3 += iStridem1 )
            {
                urp = (ur0=INTDIV2(*px2++)) + (ur1=INTDIV2(*px3++));
                urm = ur0 - ur1;
                uip = (ui0=INTDIV2(*px2--)) + (ui1=INTDIV2(*px3--));
                uim = ui0 - ui1;
                *px2++  = (ur0 = INTDIV2(*px0)) - urp;
                *px0++  = ur0 + urp;
                *px3++  = (ur1 = INTDIV2(*px1)) - uim;
                *px1++  = ur1 + uim;
                *px2    = (ui0 = INTDIV2(*px0)) - uip;
                *px0    = ui0 + uip;
                *px3    = (ui1 = INTDIV2(*px1)) + urm;
                *px1    = ui1 - urm;
                DUMP_FFT_SET(idx,3);
                DUMP_FFT_SET(idx+n2km1,1);
                DUMP_FFT_SET(idx+2*n2km1,1);
                DUMP_FFT_SET(idx+3*n2km1,1);
                DEBUG_COUNT_BTFLY1(12,0,12);
                DEBUG_COUNT_LOOP(2);
            }
            DEBUG_COUNT_LOOP(9);
        }
        // Now the non-trivial butterflies
        if ( n2km2 > 1 )
        {
            if ( *pbp2Trig != 0 )
            {   // normal case with k <= 16
                bp2Step1 = *pbp2Trig++;     // 2*sin(2*pi/2^k)
                bp2Cos1  = *pbp2Trig++;     // cos(2*pi/2^k) 
                bp2Sin1  = *pbp2Trig++;     // sin(2*pi/2^k)
                bp2Step3 = *pbp2Trig++;     // 2*sin(6*pi/2^k)
                bp2Cos3  = *pbp2Trig++;     // cos(6*pi/2^k) 
                bp2Sin3  = *pbp2Trig++;     // sin(6*pi/2^k)
            }
            else
            {   // k > 16 is not normal - but cleaniness before smallness
                bp2Step1 = BP2_FROM_FLOAT( 2*sin(2*PI/n2k) );
                bp2Cos1  = BP2_FROM_FLOAT( cos(2*PI/n2k) );
                bp2Sin1  = BP2_FROM_FLOAT( sin(2*PI/n2k) );
                bp2Step3 = BP2_FROM_FLOAT( 2*sin(6*PI/n2k) );
                bp2Cos3  = BP2_FROM_FLOAT( cos(6*PI/n2k)  );
                bp2Sin3  = BP2_FROM_FLOAT( sin(6*PI/n2k) );
            }
            bp2Cos1p = bp2Cos3p = BP2_FROM_FLOAT(1.0);
            bp2Sin1p = bp2Sin3p = BP2_FROM_FLOAT(0.0);
            for( j = 1; j<n2km2;  j++ )
            {
                //assert( fabs(FLOAT_FROM_BP2(bp2Sin1) - sin((2*PI*j)/n2k)) < 0.0001 );
                //assert( fabs(FLOAT_FROM_BP2(bp2Sin3) - sin((6*PI*j)/n2k)) < 0.0001 );
                for( iOffset = j<<1, iStride = n2kp2; 
                        iOffset < np2; 
                            iOffset = (iStride - n2k + j)<<1, iStride <<= 2 )
                {
                    px3 = (px2 = (px1 = (px0 = px+iOffset) + n2km1) + n2km1) + n2km1;
                    iStridem1 = iStride-1;
                    for( idx = iOffset; 
                            idx < np2m7; 
                        idx += iStride, px0 += iStridem1, px1 += iStridem1, px2 += iStridem1, px3 += iStridem1 )
                    {
#if !defined(WMA_TARGET_SH4)
                        // The pentium prefers this way, but still does not generate wonderful code
                        ur0 = INTDIV2(*px2++);  ui0 = INTDIV2(*px2--);
                        ur2 = MULT_BP2(bp2Cos1,ur0) + MULT_BP2(bp2Sin1,ui0);
                        ui2 = MULT_BP2(bp2Cos1,ui0) - MULT_BP2(bp2Sin1,ur0);
                        ur1 = INTDIV2(*px3++);  ui1 = INTDIV2(*px3--);
                        ur3 = MULT_BP2(bp2Cos3,ur1) + MULT_BP2(bp2Sin3,ui1);
                        ui3 = MULT_BP2(bp2Cos3,ui1) - MULT_BP2(bp2Sin3,ur1);
                        urp     = ur2 + ur3;
                        *px2++  = (ur0 = INTDIV2(*px0)) - urp;
                        *px0++  = ur0 + urp;
                        uim     = ui2 - ui3;
                        *px3++  = (ur1 = INTDIV2(*px1)) - uim;
                        *px1++  = ur1 + uim;
                        uip     = ui2 + ui3;
                        *px2    = (ui0 = INTDIV2(*px0)) - uip;
                        *px0    = ui0 + uip;
                        urm     = ur2 - ur3;
                        *px3    = (ui1 = INTDIV2(*px1)) + urm;
                        *px1    = ui1 - urm;
#else
                        // some platforms might prefer this expression
                        ur0 = INTDIV2(*px2++);  ui0 = INTDIV2(*px2--);
                        ur2 = MULT_BP2(bp2Cos1,ur0) + MULT_BP2(bp2Sin1,ui0);
                        ui2 = MULT_BP2(bp2Cos1,ui0) - MULT_BP2(bp2Sin1,ur0);
                        ur1 = INTDIV2(*px3++); ui1 = INTDIV2(*px3--);
                        ur3 = MULT_BP2(bp2Cos3,ur1) + MULT_BP2(bp2Sin3,ui1);
                        ui3 = MULT_BP2(bp2Cos3,ui1) - MULT_BP2(bp2Sin3,ur1);
                        urp = ur2 + ur3;
                        urm = ur2 - ur3;
                        uip = ui2 + ui3;
                        uim = ui2 - ui3;
                        *px2++  = (ur0 = INTDIV2(*px0)) - urp;
                        *px0++  = ur0 + urp;
                        *px3++  = (ur1 = INTDIV2(*px1)) - uim;
                        *px1++  = ur1 + uim;
                        *px2    = (ui0 = INTDIV2(*px0)) - uip;
                        *px0    = ui0 + uip;
                        *px3    = (ui1 = INTDIV2(*px1)) + urm;
                        *px1    = ui1 - urm;
#endif
                        DUMP_FFT_SET(idx,4);
                        DUMP_FFT_SET(idx+n2km1,1);
                        DUMP_FFT_SET(idx+2*n2km1,1);
                        DUMP_FFT_SET(idx+3*n2km1,1);
                        DEBUG_COUNT_BTFLY2(16,8,12);
                        DEBUG_COUNT_LOOP(2);
                    }
                    DEBUG_COUNT_LOOP(10);
                }
                if ( (j+1) < n2km2 )
                {   // Trig Recurrsion for both 2*pi/2^k and 6*pi/2^k
                    // sin(a+b) = sin(a-b) + 2*sin(b)*cos(a)
                    // cos(a+b) = cos(a-b) - 2*sin(b)*sin(a)
                    // Lay these out like this as ahint to optimizer to overlap operations
                    bp2Sin1T = bp2Sin1p + MULT_BP2(bp2Step1,bp2Cos1);
                    bp2Cos1T = bp2Cos1p - MULT_BP2(bp2Step1,bp2Sin1);
                    bp2Sin3T = bp2Sin3p + MULT_BP2(bp2Step3,bp2Cos3);
                    bp2Cos3T = bp2Cos3p - MULT_BP2(bp2Step3,bp2Sin3);
                    bp2Sin1p = bp2Sin1;  bp2Sin1 = bp2Sin1T;
                    bp2Cos1p = bp2Cos1;  bp2Cos1 = bp2Cos1T;
                    bp2Sin3p = bp2Sin3;  bp2Sin3 = bp2Sin3T;
                    bp2Cos3p = bp2Cos3;  bp2Cos3 = bp2Cos3T;
                    DEBUG_COUNT_TRIG(2,2);
                    DEBUG_COUNT_TRIG(2,2);
                }
                DEBUG_COUNT_LOOP(2);
            }
        }
        DEBUG_COUNT_LOOP(7);
        DUMP_FFT_SHOW("k = %d.\n", k, np );
    }
    FUNCTION_PROFILE_STOP(&fp);
}


#endif  // both !SPLIT_RADIX_FFT and SPLIT_RADIX_FFT


#if defined(_DEBUG)
//*****************************************************************************************
//
// auDctIV
// DCT type IV transform
//
//*****************************************************************************************
//
// define DCT_SIN_PRINT to print sin values as they are used
//#define DCT_SIN_PRINT -1
// define DCT_IN_PRINT to prinf DCT input coefs (positive value to do so for just one frame)
//#define DCT_IN_PRINT 10100
// define DCT_PRE_PRINT to print DCT coefs prior to calling FFT
//#define DCT_PRE_PRINT -1
// define DCT_POST_PRINT to print DCT coefs after calling FFT
//#define DCT_POST_PRINT -1
// define DCT_OUT_PRINT to print DCT output coefs
//#define DCT_OUT_PRINT 10100
// define this to be smaller than 2048 is you only want a sample
#define DCT_MOD_COEF_TO_PRINT 128
#   if defined(DCT_IN_PRINT) || defined(DCT_PRE_PRINT)  || defined(DCT_POST_PRINT) || defined(DCT_OUT_PRINT)
#       pragma COMPILER_MESSAGE(__FILE__ "(725) : Warning - DCT Debug Code Enabled.")
        int bPrintDctAtFrame = 0;       // used by main program to control the printing
        extern int g_ulOutputSamples;   // main must create and update
		void DebugDctPrintCoefs(CAudioObject* pau, int def, int id, float fac, CoefType* pfCoef)
        {   int dcti; float fmax = 0;                                                     
            if ( ((int)pau->m_iFrameNumber==def) || (def < 0) || (bPrintDctAtFrame&(1<<id)) )          
            {   /* MyOutputDbgStr(0, "DCT %4s %4d\n",id,n); matlab does not like */  
				static char* szID[]= { "DCT in  ", "DCT pre ", "DCT post", "DCT out ", "Wgt Fact", "WF down ", "WF up  ", "WF same" };
                for( dcti = 0; dcti < pau->m_cSubbandAdjusted; dcti++ ) {    
					float f = id<4 ? FLOAT_FROM_COEF(pfCoef[dcti])/((Float)fac) :
								     FLOAT_FROM_WEIGHT(pfCoef[dcti]);
                    if ( fmax < fabs(f) )       
                        fmax = (float)fabs(f);
                    if ( dcti < DCT_MOD_COEF_TO_PRINT || (dcti%DCT_MOD_COEF_TO_PRINT)==0 ) 
#						ifdef UNDER_CE
							MyOutputDbgStr(0, 
#						else
							printf(
#						endif
						"%4d.%1d   %4d  %+15.7f\n",          
                            pau->m_iFrameNumber, pau->m_iCurrSubFrame, dcti, f );
                }
#				ifdef UNDER_CE
					MyOutputDbgStr(0, szID[id]);
					MyOutputDbgStr(0, 
#				else
					printf(szID[id]);
					printf(
#				endif
					" %4d  %+15.7f  %7d\n", pau->m_cSubbandAdjusted, fmax, g_ulOutputSamples );
#				ifndef UNDER_CE
					fflush(stdout); 
#				endif
            }
        }
#       define DCT_PRINT(def,id,fac,pfCoef)  DebugDctPrintCoefs(pau,def,id,fac,pfCoef)
#   else
#       define DCT_PRINT(def,id,fac,pfCoef)
#   endif
#   if defined(DCT_IN_PRINT)
#       define DCT_DOPRINT_IN(fac,pfCoef) DCT_PRINT(DCT_IN_PRINT,0,fac,pfCoef)
#   else
#       define DCT_DOPRINT_IN(fac,pfCoef)
#   endif
#   if defined(DCT_PRE_PRINT)
#       define DCT_DOPRINT_PRE(fac,pfCoef) DCT_PRINT(DCT_PRE_PRINT,1,n,fac,pfCoef)
#   else
#       define DCT_DOPRINT_PRE(fac,pfCoef)
#   endif
#   if defined(DCT_POST_PRINT)
#       define DCT_DOPRINT_POST(fac,pfCoef) DCT_PRINT(DCT_POST_PRINT,2,n,fac,pfCoef)
#   else
#       define DCT_DOPRINT_POST(fac,pfCoef)
#   endif
#   if defined(DCT_OUT_PRINT)
#       define DCT_DOPRINT_OUT(fac,pfCoef) DCT_PRINT(DCT_OUT_PRINT,3,n,fac,pfCoef)
#   else
#       define DCT_DOPRINT_OUT(fac,pfCoef)
#   endif
#   if defined(DCT_SIN_PRINT)
#       pragma COMPILER_MESSAGE(__FILE__ "(774) : Warning - DCT Debug Code Enabled.")
#       define DEBUG_DCT_SIN(id,i,fac,sinv)                                     \
            if ( (pau->m_iFrameNumber==DCT_SIN_PRINT) || (DCT_SIN_PRINT < 0) )  \
            {   printf("%2d  %4d  %+15.8f\n", id, i, sinv/fac );                \
                fflush(stdout);                                                 \
            }
#   else
#       define DEBUG_DCT_SIN(id,i,fac,sinv)
#   endif
#else
#       define DCT_DOPRINT_IN(fac,pfCoef)
#       define DCT_DOPRINT_PRE(fac,pfCoef)
#       define DCT_DOPRINT_POST(fac,pfCoef)
#       define DCT_DOPRINT_OUT(fac,pfCoef)
#       define DEBUG_DCT_SIN(id,i,fac,sinv)
#endif

#ifdef INTEGER_ENCODER
#define INTEGER_ENCODER_ONLY(a) a
#else
#define INTEGER_ENCODER_ONLY(a)
#endif

WMARESULT auDctIV(CAudioObject* pau, CoefType* rgiCoef, Float fltAfterScaleFactor, U32 *piMagnitude)
{
    CoefType *piCoefTop, *piCoefBottom, *piCoefBottomOut;
    CoefType iTr, iTi, iBr, iBi;
    BP1Type CR, CI, UR, UI, STEP, CR1, CI1, CR2, CI2;
    Int iFFTSize, i, cSB, nLog2SB;
    BP1Type  iFac;
    const SinCosTable* pSinCosTable;
    double fac;
    const double dPI = PI;
    const double dPI3Q = 3*PI/4;                        // PI (-1/4 + 1)
    const double dPIby4 = PI/4;
#if defined(BUILD_INTEGER)
    const double d1p0   = 1.0 * NF2BP1;
    const double d2p0   = 2.0 * NF2BP1;
    const double d1Hp0  = 0.5 * NF2BP1;
    const double d1Qp0  = 0.25* NF2BP1;
    Int nFacExponent;
    U32 iMagnitude = 0;
#else  // must be BUILD_INT_FLOAT
    const double d1p0   = 1.0;
    const double d2p0   = 2.0;
    const double d1Hp0  = 0.5;
    const double d1Qp0  = 0.25;
#endif  // BUILD_INTEGER or BUILD_INT_FLOAT

#ifdef INTEGER_ENCODER
    Int iScaleFactor;
#endif

    FUNCTION_PROFILE(fp);
    FUNCTION_PROFILE_START(&fp,DCTIV_PROFILE);

    // m_cSubbandAdjusted below deals with the need to scale transform results to compensate the fact 
    // that we're inv transforming coefficients from a transform that was twice or half our size

    cSB = pau->m_cSubbandAdjusted;
    iFFTSize = cSB/2;
    nLog2SB = LOG2( cSB );

    piCoefTop          = rgiCoef;               
    piCoefBottom       = rgiCoef + cSB - 1;
    piCoefBottomOut    = rgiCoef + cSB - 1;     // separate pointer now obsolete but still used

#if defined(WMA_SHOW_FRAMES) && defined(_DEBUG)
    prvWmaShowFrames(pau, "DCT", " %4d 0x%08x 0x%08x", cSB, piCoefTop, piCoefBottom);
#endif

    // fltAfterScaleFactor:  V2: 2/cSB == 1/iFFTSize and V1: sqrt(2/cSB)
#if defined(BUILD_INTEGER)
    fac = fltAfterScaleFactor * cSB * d1Qp0;
    for( nFacExponent = 0; fabs(fac) > d1p0; nFacExponent++ )
        fac /= 2.0f;        // SH warning CBE4717 here is ignorable
#else   // must be BUILD_INT_FLOAT
    fac = fltAfterScaleFactor;
#endif

    // initialize sin/cos recursion
    // note this style of recurrsion is more accurate than Numerical Recipies 5.5.6
    if ( 64 <= cSB && cSB <= 2048 )
    {
        pSinCosTable = rgSinCosTables[cSB>>7];
#       if defined(BUILD_INTEGER)
            iFac = (I32)ROUNDD( fac );
#       else  // must be BUILD_INT_FLOAT
            iFac = (BP1Type)fac;
#       endif // BUILD_INTEGER or BUILD_INT_FLOAT
        // initial cosine/sine values
        CR =  MULT_BP1(iFac,pSinCosTable->cos_PIby4cSB);        // CR = (I32)(fac*cos(-PI/(4*m_cSubband)) * NF2BP1)
        CI = -MULT_BP1(iFac,pSinCosTable->sin_PIby4cSB);        // CI = (I32)(fac*sin(-PI/(4*m_cSubband)) * NF2BP1)
        // prior cosine/sine values to init Pre-FFT recurrsion trig( -PI/(4*M) - (-PI/M ) = trig( 3*PI/(4*M) )
        CR1 =  MULT_BP1(iFac,pSinCosTable->cos_3PIby4cSB);  // CR = (I32)(fac*cos(+3*PI/(4*m_cSubband)) * NF2BP1)
        CI1 =  MULT_BP1(iFac,pSinCosTable->sin_3PIby4cSB);  // CI = (I32)(fac*sin(+3*PI/(4*m_cSubband)) * NF2BP1)
        // rotation step for both recurrsions
        STEP = -pSinCosTable->two_sin_PIbycSB;              // STEP = 2*sin(-PI/m_cSubband) 
        // prior cosine/sine values to init Post-FFT recurrsion
        CR2 =  pSinCosTable->cos_PIbycSB;                   // CR = (I32)(cos( PI/m_cSubband) * NF2BP1)
        CI2 =  pSinCosTable->sin_PIbycSB;                   // CI = (I32)(sin( PI/m_cSubband) * NF2BP1)
    }
    else
    {   // not normally needed in decoder, here for generality
        double dA, dSB;

        dA = -dPIby4 / (dSB=cSB);
        CR = (BP1Type)( fac * cos( dA ) );
        CI = (BP1Type)( fac * sin( dA ) );
        dA = dPI3Q / dSB;
        CR1 = (BP1Type)( fac * cos( dA ) );
        CI1 = (BP1Type)( fac * sin( dA ) );
        dA = -dPI / dSB;
        STEP = (BP1Type)( d2p0 * sin( dA ) );
        CR2  = (BP1Type)( d1p0 * cos( dA ) );
        CI2  = -STEP/2;  
    }

    // Include the next code-block to verify changes to the lookup-table
#if 0
    {
#       if defined(BUILD_INTEGER)
            const BP1Type Theshold = 1;
#       else
            const BP1Type Theshold = BP1_FROM_FLOAT(0.001F*fac);
#       endif
        assert(BPX_ABS(CR - (BP1Type)( fac * cos(-dPIby4 / cSB) )) <= Theshold);
        assert(BPX_ABS(CI - (BP1Type)( fac * sin(-dPIby4 / cSB) )) <= Theshold);
        assert(BPX_ABS(CR1 - (BP1Type)( fac * cos(dPI3Q / cSB) )) <= Theshold);
        assert(BPX_ABS(CI1 - (BP1Type)( fac * sin(dPI3Q / cSB) )) <= Theshold);
        assert(BPX_ABS(STEP - (BP1Type)( d2p0 * sin(-dPI / cSB) )) <= Theshold);
        assert(BPX_ABS(CR2  - (BP1Type)( d1p0 * cos(-dPI / cSB) )) <= Theshold);
        assert(BPX_ABS(CI2  - DIV2((-(BP1Type)( d2p0 * sin(-dPI / cSB) )))) <= Theshold);
    }
#endif

    DCT_DOPRINT_IN(1.0,rgiCoef);

    for (i = iFFTSize/2; i > 0; i--) {
        iBi = piCoefBottom[0];
        piCoefBottomOut[0] = piCoefTop[1];

        iTr = piCoefTop[0];
        piCoefTop[0] = MULT_BP1(CR,iTr) - MULT_BP1(CI,iBi);
        piCoefTop[1] = MULT_BP1(CR,iBi) + MULT_BP1(CI,iTr);

        DEBUG_DCT_SIN(0,i,fac,CI);
        MONITOR_RANGE(gMR_DCTCoefIntoFFT,FLOAT_FROM_COEF(piCoefTop[0]));
        MONITOR_RANGE(gMR_DCTCoefIntoFFT,FLOAT_FROM_COEF(piCoefTop[1]));
        // rotate angle by -b = -pi/cSubband
        // recursion: cos(a-b) = cos(a+b) - 2*sin(b)*sin(a)
        // and:       sin(a-b) = sin(a+b) + 2*sin(b)*cos(a)
        UR = CR1 - MULT_BP1(STEP,CI);
        UI = CI1 + MULT_BP1(STEP,CR);
        CR1 = CR;  CR = UR;
        CI1 = CI;  CI = UI;

        piCoefTop += 2;
        piCoefBottom -= 2;
        piCoefBottomOut -= 2;
    }

    for (i = iFFTSize/2; i > 0; i--) {
        iTr = piCoefTop[0];
        iTi = piCoefTop[1];
        piCoefTop[0] = MULT_BP1(CR,iTr) - MULT_BP1(CI,iTi);
        piCoefTop[1] = MULT_BP1(CR,iTi) + MULT_BP1(CI,iTr);

        DEBUG_DCT_SIN(1,i,fac,CI);
        MONITOR_RANGE(gMR_DCTCoefIntoFFT,FLOAT_FROM_COEF(piCoefTop[0]));
        MONITOR_RANGE(gMR_DCTCoefIntoFFT,FLOAT_FROM_COEF(piCoefTop[1]));
        // rotate angle by b = -pi/cSubband
        UR = CR1 - MULT_BP1(STEP,CI);
        UI = CI1 + MULT_BP1(STEP,CR);
        CR1 = CR;  CR = UR;
        CI1 = CI;  CI = UI;

        piCoefTop += 2;
    }

    DCT_DOPRINT_PRE((fac/d1Hp0),rgiCoef);

    //Call the integer FFT explicitly
    pau->aupfnFFT(rgiCoef, nLog2SB - 1, FFT_FORWARD);

    DCT_DOPRINT_POST(1.0,rgiCoef);

#ifdef INTEGER_ENCODER
    // TODO:  put this in asm for SH4, SH3 and casio
    if (nFacExponent > 0)
    {   // This scaling needed for encoding only (we think hopefully)
        const int c_iMaxScaleUp = 15;

        iScaleFactor = nFacExponent;

        // Limit pre-scale to +c_iMaxScaleUp (to avoid overflow)
        if (iScaleFactor > c_iMaxScaleUp)
        {
            nFacExponent = (iScaleFactor - c_iMaxScaleUp);
            iScaleFactor = c_iMaxScaleUp;
        }
        else
            nFacExponent = 0;

#ifdef _DEBUG
        if (iScaleFactor > 0)
        {
            I32 iIntMax = INT_MAX >> iScaleFactor;  
            piCoefTop      = rgiCoef; 
            for( i = cSB; i > 0; i--, piCoefTop++ )
            {
                assert(-iIntMax <= (I32)(*piCoefTop)  && (I32)(*piCoefTop) <= iIntMax );
            }
        }
#endif
    }

#endif

    // post FFT demodulation 
    // using R[i], I[i] as real and imaginary parts of complex point i
    // and C(i), S(i) are cos(i*pi/cSubband) and sin(i*pi/cSubband), and N = cSubband/2
    // R[0] = C(0) R[0] - S(0) I[0]
    // I[0] = -S(-(N-1)) R[N-1] - C(-(N-1)) I[N-1]
    // R[1] = C(1) R[1] - S(-1) I[N-1]
    // I[1] = -S(-(N-2)) R[N-2] - C(-(N-2)) I[N-2]
    // ...
    // R[N-2] = C(-(N-2)) R[N-2] - S(-(N-2)) I[N-2]
    // I[N-2] = -S(-1) R[1] - C(-1) I[1]
    // R[N-1] = C(-(N-1)) R[N-1] - S(-(N-1)) I[N-1]
    // R[N-1] = -S(0) R[0] - C(0) I[0]
    // and where 90 - angle trig formulas reveal:
    // C(-(N-i)) == -S(-i) and S(-(N-i)) = -C(-i)

    piCoefTop      = rgiCoef;           //reuse this pointer; start from head;
    piCoefBottom   = rgiCoef + cSB - 2; //reuse this pointer; start from tail;
    CR = BP1_FROM_FLOAT(1);             //one
    CI = 0;                             //zero

    for (i = iFFTSize/2; i > 0; i--) {
        iTr = piCoefTop[0] INTEGER_ENCODER_ONLY( <<iScaleFactor );
        iTi = piCoefTop[1] INTEGER_ENCODER_ONLY( <<iScaleFactor );
        iBr = piCoefBottom[0] INTEGER_ENCODER_ONLY( <<iScaleFactor );
        iBi = piCoefBottom[1] INTEGER_ENCODER_ONLY( <<iScaleFactor );

        piCoefTop[0] =  MULT_BP1(CR,iTr) -  MULT_BP1(CI,iTi);
        piCoefBottom[1] =  MULT_BP1(-CI,iTr) - MULT_BP1(CR,iTi);
        INTEGER_ONLY( iMagnitude |= abs(piCoefTop[0]) );
        INTEGER_ONLY( iMagnitude |= abs(piCoefBottom[1]) );

        DEBUG_DCT_SIN(2,i,d1p0,CI);
        MONITOR_RANGE(gMR_DCTCoefOut,FLOAT_FROM_COEF(piCoefTop[0]));
        MONITOR_RANGE(gMR_DCTCoefOut,FLOAT_FROM_COEF(piCoefBottom[1]));
        // rotate angle by -b = -pi/cSubband
        // recursion: cos(a-b) = cos(a+b) - 2*sin(b)*sin(a)
        // and:       sin(a-b) = sin(a+b) + 2*sin(b)*cos(a)
        UR = CR2 - MULT_BP1(STEP,CI);
        UI = CI2 + MULT_BP1(STEP,CR);
        CR2 = CR;  CR = UR;
        CI2 = CI;  CI = UI;

        // note that cos(-(cSubband/2 - i)*pi/cSubband ) = -sin( -i*pi/cSubband )
        piCoefTop[1] = MULT_BP1(CR,iBr) + MULT_BP1(CI,iBi);
        piCoefBottom[0] = MULT_BP1(-CI,iBr) +  MULT_BP1(CR,iBi);
        
        INTEGER_ONLY( iMagnitude |= abs(piCoefTop[1]) );
        INTEGER_ONLY( iMagnitude |= abs(piCoefBottom[0]) );

        MONITOR_RANGE(gMR_DCTCoefOut,FLOAT_FROM_COEF(piCoefTop[1]));
        MONITOR_RANGE(gMR_DCTCoefOut,FLOAT_FROM_COEF(piCoefBottom[0]));

        piCoefTop += 2;
        piCoefBottom -= 2;
    }
#if defined(BUILD_INTEGER)
    if ( nFacExponent > 0 )
    {   // This scaling needed in v1 bit-streams
        piCoefTop      = rgiCoef; 
        iMagnitude <<= nFacExponent;
        for( i = cSB; i > 0; i-- )
        {
            *piCoefTop++ <<= nFacExponent;
        }
    }
#endif

    if (NULL != piMagnitude)
        *piMagnitude = INTEGER_OR_INT_FLOAT( iMagnitude, 0 );

    DCT_DOPRINT_OUT(1.0,rgiCoef);
#if defined(DCT_OUT_PRINT) && defined(_DEBUG)
    if ( pau->m_iFrameNumber==DCT_OUT_PRINT)
    { DEBUG_BREAK(); }
#endif
    FUNCTION_PROFILE_STOP(&fp);

    return WMA_OK;
}



#endif // WMA_TARGET_MIPS, WMA_TARGET_SH3, WMA_TARGET_SH4 and everything else


//#define PLATFORM_LPC_LITDFT

#if defined(PLATFORM_LPC_LITDFT) 

// A Split Radix FFT for the LPC -
// Size (which is 32) must match that required by LPC
// See WMAConcepts.xls - Sheet SRFFT32 for how this works.
// See also Sorensen & Heldeman, IEEE Trans ASSP, Vol ASSP-34, #1, 2/86, pp152-156.

#define NP 32
#define LOGNP 5
#define NP2 (2*NP)
#define SWAP(a,b) tmp=(a);(a)=(b);(b)=tmp

#define BP2_CONST4(a,b,c,d) BP2_FROM_FLOAT(a),BP2_FROM_FLOAT(b),BP2_FROM_FLOAT(c),BP2_FROM_FLOAT(d)

const BP2Type rgbp2SRFFT32[] = {
//     cos(2*PI*j/2^k) sin(2*PI*j/2^k) cos(6*PI*j/2^k) sin(6*PI*j/2^k)
BP2_CONST4(0.70710678119,0.70710678119,-0.70710678119,0.70710678119),   // k=3, j=1
BP2_CONST4(0.92387953251,0.38268343237,0.38268343237,0.92387953251),    // k=4, j=1
BP2_CONST4(0.70710678119,0.70710678119,-0.70710678119,0.70710678119),   // k=4, j=2
BP2_CONST4(0.38268343237,0.92387953251,-0.92387953251,-0.38268343237),  // k=4, j=3
BP2_CONST4(0.98078528040,0.19509032202,0.83146961230,0.55557023302),    // k=5, j=1
BP2_CONST4(0.92387953251,0.38268343237,0.38268343237,0.92387953251),    // k=5, j=2
BP2_CONST4(0.83146961230,0.55557023302,-0.19509032202,0.98078528040),   // k=5, j=3
BP2_CONST4(0.70710678119,0.70710678119,-0.70710678119,0.70710678119),   // k=5, j=4
BP2_CONST4(0.55557023302,0.83146961230,-0.98078528040,0.19509032202),   // k=5, j=5
BP2_CONST4(0.38268343237,0.92387953251,-0.92387953251,-0.38268343237),  // k=5, j=6
BP2_CONST4(0.19509032202,0.98078528040,-0.55557023302,-0.83146961230)   // k=5, j=7
};

static const I8 rgi8BitReverse32[2*12] = {
    2,32,  4,16,  6,48,  10,40, 12,24, 14,56, 
    18,36, 22,52, 26,44, 30,60, 38,50, 46,58 
};


void prvFFT32(CoefType data[])
{
    CoefType *px = data;
    I32 i, j, k, iOffset, iStride;
    Int n2k, n2km1, n2km2, n2kp2, idx0, idx1, idxR0, idxR1, idxR2, idxR3;
    CoefType tmp, ur0, ui0, ur1, ui1;
    BP2Type bp2Cos1, bp2Sin1, bp2Cos3, bp2Sin3;
    const BP2Type* pbp2Trig = rgbp2SRFFT32;
    CoefType ur2, ui2, ur3, ui3, urp, uip, urm, uim;

    //FUNCTION_PROFILE(fp);
    //FUNCTION_PROFILE_START(&fp,FFT32_PROFILE);

    // bit reverse
    for( i = 0; i < (2*12); i += 2 )
    {
        SWAP( px[rgi8BitReverse32[i]], px[rgi8BitReverse32[i+1]] );
        SWAP( px[rgi8BitReverse32[i]+1], px[rgi8BitReverse32[i+1]+1] );
    }

    // Length 2 butterflies
    for( iOffset = 0, iStride = 8; 
            iOffset < NP2; 
                iOffset = (iStride<<1) - 4, iStride <<= 2 )
    {
        for( idx0 = iOffset; idx0<NP2; idx0 += iStride-1 )
        {
            ur0 = px[idx0];
            ur1 = px[idx1 = idx0+2 ]; 
            px[idx0++] = ur0 + ur1;
            px[idx1++] = ur0 - ur1;
            ui0 = px[idx0];
            ui1 = px[idx1]; 
            px[idx0] = ui0 + ui1;
            px[idx1] = ui0 - ui1;
        }
    }

    // L Shaped Butterflies
    n2k = 2;
    for( k=2; k<=LOGNP; k++ )
    {
        n2k <<= 1;
        n2km1 = n2k>>1;
        n2km2 = n2k>>2;
        n2kp2 = n2k<<2;
        // Trivial Butterflies - j==0 - no multiplies since Cos==1 and Sin==0
        for( iOffset = 0, iStride = n2kp2; 
                iOffset < NP2; 
                    iOffset = (iStride - n2k)<<1, iStride <<= 2 )
        {
            for( idxR0 = iOffset; 
                    idxR0 < (NP2-7); 
                        idxR0 += iStride )
            {
                idxR1 = idxR0 + n2km1;
                idxR2 = idxR1 + n2km1;
                idxR3 = idxR2 + n2km1;
                urp = px[idxR2]   + px[idxR3];
                urm = px[idxR2]   - px[idxR3];
                uip = px[idxR2+1] + px[idxR3+1];
                uim = px[idxR2+1] - px[idxR3+1];
                px[idxR2]    = px[idxR0] - urp;
                px[idxR0]   += urp;
                px[idxR3]    = px[idxR1] - uim;
                px[idxR1]   += uim;
                px[idxR2+1]  = px[idxR0+1] - uip;
                px[idxR0+1] += uip;
                px[idxR3+1]  = px[idxR1+1] + urm;
                px[idxR1+1] -= urm;
            }
        }
        // Now the non-trivial butterflies
        for( j = 1; j<n2km2;  j++ )
        {
            bp2Cos1 = *pbp2Trig++;      // cos(2*pi*j/n2k)
            bp2Sin1 = *pbp2Trig++;      // sin(2*pi*j/n2k)
            bp2Cos3 = *pbp2Trig++;      // cos(3*2*pi*j/n2k)
            bp2Sin3 = *pbp2Trig++;      // sin(3*2*pi*j/n2k)
            assert( fabs(FLOAT_FROM_BP2(bp2Sin1) - sin((2*PI*j)/n2k)) < 0.0001 );
            for( iOffset = j<<1, iStride = n2kp2; 
                    iOffset < NP2; 
                        iOffset = (iStride - n2k + j)<<1, iStride <<= 2 )
            {
                for( idxR0 = iOffset; 
                        idxR0 < (NP2-7); 
                            idxR0 += iStride )
                {
                    idxR1 = idxR0 + n2km1;
                    idxR2 = idxR1 + n2km1;
                    idxR3 = idxR2 + n2km1;
                    ur2 = bp2Cos1*px[idxR2]   + bp2Sin1*px[idxR2+1];
                    ui2 = bp2Cos1*px[idxR2+1] - bp2Sin1*px[idxR2];
                    ur3 = bp2Cos3*px[idxR3]   + bp2Sin3*px[idxR3+1];
                    ui3 = bp2Cos3*px[idxR3+1] - bp2Sin3*px[idxR3];
                    urp = ur2 + ur3;
                    urm = ur2 - ur3;
                    uip = ui2 + ui3;
                    uim = ui2 - ui3;
                    px[idxR2]    = px[idxR0] - urp;
                    px[idxR0]   += urp;
                    px[idxR3]    = px[idxR1] - uim;
                    px[idxR1]   += uim;
                    px[idxR2+1]  = px[idxR0+1] - uip;
                    px[idxR0+1] += uip;
                    px[idxR3+1]  = px[idxR1+1] + urm;
                    px[idxR1+1] -= urm;
                }
            }
        }
    }
    //FUNCTION_PROFILE_STOP(&fp);
}


#undef SWAP

#endif  // defined(PLATFORM_LPC_LITDFT) || 1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\frmdec_x86.cpp ===
#include "bldsetup.h"

#include "xplatform.h"

#include "limits.h"
//#include "windows.h"
#include <stdio.h>
#include <math.h>
#include <stdlib.h>

#include "typedef.hpp"
#include "wmvdec_member.h"
#include "wmvdec_function.h"
#include "codehead.h"
#include "tables_wmv.h"
#include "strmdec_wmv.hpp"
#include "idctdec_wmv2.h"
#include "motioncomp_wmv.h"


#ifdef _WMV_TARGET_X86_
#include "opcodes.h"
// output is in mm0
// note: this macro is different from the one in motest.cpp, mm6 is not used.
#define ComputeEightBytesCubicMC(pLine1, pLine2, pLine3, pLine4) _asm { \
_asm        movq        mm0, [pLine2]               \
_asm        movq        mm2, [pLine3]               \
_asm        movq        mm1, mm0                    \
_asm        movq        mm3, mm2                    \
_asm        punpcklbw   mm0, mm7                    \
_asm        punpcklbw   mm2, mm7                    \
_asm        movq        mm4, [pLine1]               \
_asm        movq        mm5, mm4                    \
_asm        paddw       mm0, mm2                    \
_asm        punpckhbw   mm1, mm7                    \
_asm        movq        mm2, const_09_09_09_09      \
_asm        punpckhbw   mm3, mm7                    \
_asm        pmullw      mm0, mm2                    \
_asm        paddw       mm1, mm3                    \
_asm        pmullw      mm1, mm2                    \
_asm        punpcklbw   mm4, mm7                    \
_asm        punpckhbw   mm5, mm7                    \
_asm        movq        mm2, [pLine4]               \
_asm        movq        mm3, mm2                    \
_asm        punpcklbw   mm2, mm7                    \
_asm        punpckhbw   mm3, mm7                    \
_asm        paddw       mm2, mm4                    \
_asm        paddw       mm3, mm5                    \
_asm        movq        mm5, const_08_08_08_08      \
_asm        psubw       mm0, mm2                    \
_asm        psubw       mm1, mm3                    \
_asm        paddw       mm0, mm5                    \
_asm        paddw       mm1, mm5                    \
_asm        psraw       mm0, 4                      \
_asm        psraw       mm1, 4                      \
_asm        packuswb    mm0, mm1                    \
}

// assume prediction is in mm0, output is in mm1;
#define AddErrorAndClip(pError)       _asm {            \
_asm                    movq        mm1, [pError]       \
_asm                    movq        mm2, mm0            \
_asm                    punpcklbw   mm0, mm7            \
_asm                    paddw       mm1, mm0            \
_asm                    movq        mm3, [pError + 8]   \
_asm                    punpckhbw   mm2, mm7            \
_asm                    paddw       mm3, mm2            \
_asm                    packuswb    mm1, mm3            \
}

//avg mm0,mm1
#define ComputeBilinear()            _asm {             \
_asm            movq        mm2, x01                    \
_asm            movq        mm3, x7f                    \
_asm            movq        mm5,mm0                     \
_asm            por         mm5,mm1                     \
_asm            psrlw       mm0,1                       \
_asm            psrlw       mm1,1                       \
_asm            pand        mm5,mm2                     \
_asm            pand        mm0,mm3                     \
_asm            pand        mm1,mm3                     \
_asm            paddw       mm0,mm5                     \
_asm            paddw       mm0,mm1                     \
}

Void_WMV MotionCompMixed_MMX (
                        tWMVDecInternalMember *pWMVDec, 
                        PixelC*              ppxlcPredMB,
                        const PixelC*        ppxlcRefMB,
                        I32_WMV                  iWidthPrev,
                        Bool_WMV                 bInterpolateX,
                        Bool_WMV                 bInterpolateY,
                        I32_WMV                  iMixedPelMV
                        )
{    
    PixelC* ppxlcPred = ppxlcPredMB;
        
    static const __int64 const_09_09_09_09 = 0x0009000900090009;
    static const __int64 const_08_08_08_08 = 0x0008000800080008;
    static const __int64 x01 = 0x0101010101010101;
    static const __int64 x7f = 0x7f7f7f7f7f7f7f7f;

    PixelC tempBlock[11 * 8 + 15];
    PixelC *alignedBlock = (PixelC*) (((int)tempBlock + 15) & ~15);
    if (bInterpolateY) {
        if (bInterpolateX) {  //!bXSubPxl && !bYSubPxl
            I32_WMV iy;
            assert(iMixedPelMV == 0);            
            for (iy = 0; iy < 8; iy++) {
                *(U64 *)(ppxlcPredMB) = *(U64 *)(ppxlcRefMB);
                ppxlcRefMB += iWidthPrev;
                ppxlcPredMB += iWidthPrev;
            }
        }
        else {  //bXSubPxl && !bYSubPxl            
            PixelC* pRef = (PixelC*) (ppxlcRefMB + 1);
            if (iMixedPelMV == 0) {
                _asm {
                    mov         esi, pRef;
                    mov         edi, ppxlcPred;
                    mov         edx, iWidthPrev;
                    mov         ecx, 8;
                    pxor        mm7, mm7;

main1a:
                    ComputeEightBytesCubicMC(esi - 2, esi - 1, esi, esi + 1);
                    movq        [edi], mm0;
                    add         esi, edx;
                    add         edi, edx;
                    dec         ecx;
                    jnz         main1a;
                    emms;
                }
            } else {
                // Handles the case in underline
                // I Q H Q I Q H Q I
                //     ___     ___
                _asm {
                    mov         esi, pRef;
                    mov         edi, ppxlcPred;
                    mov         edx, iWidthPrev;
                    mov         ecx, 8;
                    pxor        mm7, mm7;
                    
main1b:
                    ComputeEightBytesCubicMC(esi - 2, esi - 1, esi, esi + 1);
                    movq        mm1, [esi];
                    ComputeBilinear();
                    //pavgb       mm0_mm1;
                    movq        [edi], mm0;

                    add         esi, edx;
                    add         edi, edx;
                    dec         ecx;
                    jnz         main1b;
                    emms;
                }
            }
        }
    }
    else {
        if (bInterpolateX) {  //!bXSubPxl&& bYSubPxl
            PixelC* pRef = (PixelC*) (ppxlcRefMB + iWidthPrev);
            const PixelC* pLine4 = pRef + iWidthPrev;
            const PixelC* pLine3 = pRef;
            const PixelC* pLine2 = pLine3 - iWidthPrev;
            const PixelC* pLine1 = pLine2 - iWidthPrev;                                

            if (iMixedPelMV == 0) {                             
                _asm {
                    mov         esi, pLine1;
                    mov         eax, pLine4;
                    mov         edi, ppxlcPred;
                    mov         edx, iWidthPrev;
                    mov         ecx, 8;
                    pxor        mm7, mm7;                   
main2a:
                    ComputeEightBytesCubicMC(esi, esi + edx, esi + 2*edx, eax);
                    movq        [edi], mm0;
                    add         esi, edx;
                    add         eax, edx;
                    add         edi, edx;
                    dec         ecx;
                    jnz         main2a;
                    emms;
                }                
            } else {
                //      H Q H' 
                //      I                     
                _asm {
                    mov         esi, pLine1;
                    mov         edi, alignedBlock;
                    mov         edx, iWidthPrev;
                    mov         ecx, 11;
                    pxor        mm7, mm7;

main2b:
                    ComputeEightBytesCubicMC(esi - 1, esi, esi + 1, esi + 2);
                    movq        [edi], mm0;
                    add         esi, edx;
                    add         edi, 8;
                    dec         ecx;
                    jnz         main2b;
 
                    mov         esi, alignedBlock;
                    mov         edi, ppxlcPred;
                    mov         ecx, 8;
                    mov         eax, pLine1;
                    mov         ebx, pLine4;
main2c:
                    ComputeEightBytesCubicMC(esi, esi + 8, esi + 16, esi + 24);
                    movq        mm6, mm0;
                    ComputeEightBytesCubicMC(eax, eax + edx, eax + 2*edx, ebx);
                    movq        mm1, mm6;
                    ComputeBilinear();
//                    pavgb       mm0_mm6;
                    movq        [edi], mm0;
                    add         esi, 8;
                    add         eax, edx;
                    add         ebx, edx;
                    add         edi, edx;
                    dec         ecx;
                    jnz         main2c;
                    emms;
                }        
            }
        }
        else { // bXSubPxl && bYSubPxl
            PixelC* pRef = (PixelC*) (ppxlcRefMB + iWidthPrev + 1);
            const PixelC* pLine4 = pRef + iWidthPrev;
            const PixelC* pLine3 = pRef;
            const PixelC* pLine2 = pLine3 - iWidthPrev;
            const PixelC* pLine1 = pLine2 - iWidthPrev;                
            if (iMixedPelMV == 0) {

                _asm {
                    mov         esi, pLine1;
                    mov         edi, alignedBlock;
                    mov         edx, iWidthPrev;
                    mov         ecx, 11;
                    pxor        mm7, mm7;
main3a:
                    ComputeEightBytesCubicMC(esi - 2, esi - 1, esi, esi + 1);
                    movq        [edi], mm0;
                    add         esi, edx;
                    add         edi, 8;
                    dec         ecx;
                    jnz         main3a;

                    mov         esi, alignedBlock;
                    mov         edi, ppxlcPred;
                    mov         ecx, 8;
                   
main3b:
                    ComputeEightBytesCubicMC(esi, esi + 8, esi + 16, esi + 24);
                    movq        [edi], mm0;
                    add         esi, 8;
                    add         edi, edx;
                    dec         ecx;
                    jnz         main3b;
                    emms;
                }   
            } else {
                // H Q H
                //     I
                _asm {
                    mov         esi, pLine1;
                    mov         edi, alignedBlock;
                    mov         edx, iWidthPrev;
                    mov         ecx, 11;
                    pxor        mm7, mm7;
main4a:
                    ComputeEightBytesCubicMC(esi - 2, esi - 1, esi, esi + 1);
                    movq        [edi], mm0;
                    add         esi, edx;
                    add         edi, 8;
                    dec         ecx;
                    jnz         main4a;

                    mov         esi, alignedBlock;
                    mov         edi, ppxlcPred;
                    mov         ecx, 8;
                    mov         eax, pLine1;
                    mov         ebx, pLine4;
main4b:
                    ComputeEightBytesCubicMC(esi, esi + 8, esi + 16, esi + 24);
                    movq        mm6, mm0;
                    ComputeEightBytesCubicMC(eax, eax + edx, eax + 2*edx, ebx);
                    movq        mm1, mm6;
                    ComputeBilinear();
/*                     pavgb       mm0_mm6;*/
                    movq        [edi], mm0;
                    add         esi, 8;
                    add         eax, edx;
                    add         ebx, edx;
                    add         edi, edx;
                    dec         ecx;
                    jnz         main4b;
                    emms;
                }        
            }
        }
    }
}

Void_WMV MotionCompMixedAndAddError_MMX (
                                   tWMVDecInternalMember *pWMVDec,
                                   PixelC __huge* ppxlcCurrQMB, 
                                   const Buffer __huge* ppxliErrorBuf, 
                                   const PixelC __huge* ppxlcRef, 
                                   I32_WMV iWidthFrm, Bool_WMV bXEven, Bool_WMV bYEven, 
                                   I32_WMV iMixedPelMV
                                   )
{

    PixelC tempBlock[11 * 8 + 15];
    PixelC *alignedBlock = (PixelC*) (((int)tempBlock + 15) & ~15);

    static const __int64 const_09_09_09_09 = 0x0009000900090009;
    static const __int64 const_08_08_08_08 = 0x0008000800080008;
    static const __int64 x01 = 0x0101010101010101;
    static const __int64 x7f = 0x7f7f7f7f7f7f7f7f;

    const I16_WMV __huge *ppxliErrorQMB = ppxliErrorBuf->i16;
    if (bYEven) {
        if (bXEven) {  //!bXSubPxl && !bYSubPxl
            if (iMixedPelMV == 0) {
                _asm {
                    mov         esi, ppxliErrorQMB;
                    mov         edx, ppxlcRef;
                    mov         edi, ppxlcCurrQMB;
                    mov         ecx, 8;
                    pxor        mm7, mm7;
                    mov         ebx, iWidthFrm;
main0:
                    movq        mm0, [edx];
                    AddErrorAndClip(esi);
                    movq        [edi], mm1;

                    add         esi, 16;
                    add         edx, ebx;
                    add         edi, ebx;
                    dec         ecx;
                    jnz         main0;
                    emms;
                }
            } else {
                // Handles the case in underline
                // I Q H Q I Q H Q I
                //         ___                               
                _asm {
                    mov         esi, ppxlcRef;
                    mov         edi, ppxlcCurrQMB;
                    mov         edx, ppxliErrorQMB;
                    mov         ecx, 8;
                    mov         ebx, iWidthFrm;
                    pxor        mm7, mm7;
main1:
                    ComputeEightBytesCubicMC(esi - 1, esi, esi + 1, esi + 2);
                    movq        mm1, [esi];
//                    pavgb       mm0_mm1;
                    ComputeBilinear();
                    AddErrorAndClip(edx);
                    movq        [edi], mm1;
                    
                    add         esi, ebx;
                    add         edi, ebx;
                    add         edx, 16;
                    dec         ecx;
                    jnz         main1;
                    emms;
                }
            }
        }
        else {  //bXSubPxl && !bYSubPxl
            if (iMixedPelMV == 0) {
                _asm {
                    mov         esi, ppxlcRef;
                    mov         edi, ppxlcCurrQMB;
                    mov         edx, ppxliErrorQMB;
                    mov         ecx, 8;
                    mov         ebx, iWidthFrm;
                    pxor        mm7, mm7;
main2:
                    ComputeEightBytesCubicMC(esi - 1, esi, esi + 1, esi + 2);
                    AddErrorAndClip(edx);
                    movq        [edi], mm1;
                    add         esi, ebx;
                    add         edi, ebx;
                    add         edx, 16;
                    dec         ecx;
                    jnz         main2;
                    emms;
                }
            } else {
                // Handles the case in underline
                // I Q H Q I Q H Q I
                //     ___     ___   
                _asm {
                    mov         esi, ppxlcRef;
                    mov         edi, ppxlcCurrQMB;
                    mov         edx, ppxliErrorQMB;
                    mov         ecx, 8;
                    mov         ebx, iWidthFrm;
                    pxor        mm7, mm7;
main3:
                    ComputeEightBytesCubicMC(esi - 1, esi, esi + 1, esi + 2);
                    movq        mm1, [esi + 1];
                    ComputeBilinear();
//                    pavgb       mm0_mm1;
                    AddErrorAndClip(edx);
                    movq        [edi], mm1;
                    
                    add         esi, ebx;
                    add         edi, ebx;
                    add         edx, 16;
                    dec         ecx;
                    jnz         main3;
                    emms;
                }                
            }
        }
    }
    else {
        if (bXEven) {  //!bXSubPxl&& bYSubPxl
            if (iMixedPelMV == 0) {
                const PixelC* pLine1 = ppxlcRef - iWidthFrm;
                const PixelC* pLine4 = ppxlcRef + 2 * iWidthFrm;   

                _asm {
                    mov         esi, pLine1;
                    mov         eax, pLine4;
                    mov         edi, ppxlcCurrQMB;
                    mov         ebx, ppxliErrorQMB;
                    mov         edx, iWidthFrm;
                    mov         ecx, 8;
                    pxor        mm7, mm7;                   
main4:
                    ComputeEightBytesCubicMC(esi, esi + edx, esi + 2*edx, eax);
                    AddErrorAndClip(ebx);
                    movq        [edi], mm1;
                    add         esi, edx;
                    add         eax, edx;
                    add         edi, edx;
                    add         ebx, 16;
                    dec         ecx;
                    jnz         main4;
                    emms;
                } 
            } else {
                //      H Q H' 
                //      I                              
                PixelC* pRef = (PixelC*) (ppxlcRef + iWidthFrm);                   
                const PixelC* pLine4 = pRef + iWidthFrm; 
                const PixelC* pLine1 = pRef - 2 * iWidthFrm;
                I32_WMV iLoop = 8;
                //      H Q H' 
                //      I                     
                _asm {
                    mov         esi, pLine1;
                    mov         edi, alignedBlock;
                    mov         edx, iWidthFrm;
                    mov         ecx, 11;
                    pxor        mm7, mm7;

main5a:
                    ComputeEightBytesCubicMC(esi - 1, esi, esi + 1, esi + 2);
                    movq        [edi], mm0;
                    add         esi, edx;
                    add         edi, 8;
                    dec         ecx;
                    jnz         main5a;
 
                    mov         esi, alignedBlock;
                    mov         edi, ppxlcCurrQMB; 
                    mov         ecx, ppxliErrorQMB;
                    mov         eax, pLine1;
                    mov         ebx, pLine4;
main5b:
                    ComputeEightBytesCubicMC(esi, esi + 8, esi + 16, esi + 24);
                    movq        mm6, mm0;
                    ComputeEightBytesCubicMC(eax, eax + edx, eax + 2*edx, ebx);
                    movq        mm1, mm6;
                    ComputeBilinear();
//                    pavgb       mm0_mm6;
                    AddErrorAndClip(ecx);
                    movq        [edi], mm1;
                    add         ecx, 16;
                    add         esi, 8;
                    add         eax, edx;
                    add         ebx, edx;
                    add         edi, edx;
                    dec         iLoop;
                    jnz         main5b;
                    emms;
                }         
            }
        }
        else { // bXSubPxl && bYSubPxl
            if (iMixedPelMV == 0) {
                const PixelC* pLine1 = ppxlcRef - iWidthFrm;
                _asm {
                    mov         esi, pLine1;
                    mov         edi, alignedBlock;
                    mov         edx, iWidthFrm;
                    mov         ecx, 11;
                    pxor        mm7, mm7;
main6a:
                    ComputeEightBytesCubicMC(esi - 1, esi, esi + 1, esi + 2);
                    movq        [edi], mm0;
                    add         esi, edx;
                    add         edi, 8;
                    dec         ecx;
                    jnz         main6a;

                    mov         esi, alignedBlock;
                    mov         edi, ppxlcCurrQMB;
                    mov         ebx, ppxliErrorQMB
                    mov         ecx, 8;
                   
main6b:
                    ComputeEightBytesCubicMC(esi, esi + 8, esi + 16, esi + 24);
                    AddErrorAndClip(ebx);
                    movq        [edi], mm1;
                    add         ebx, 16;
                    add         esi, 8;
                    add         edi, edx;
                    dec         ecx;
                    jnz         main6b;
                    emms;
                }                      
            } else {
                // H Q H
                //     I
                //alignedBlock
                PixelC* pRef = (PixelC*) (ppxlcRef + iWidthFrm + 1); 
                const PixelC* pLine4 = pRef + iWidthFrm;
                const PixelC* pLine1 = pRef - 2 * iWidthFrm;
                I32_WMV iLoop = 8;
                _asm {
                    mov         esi, pLine1;
                    mov         edi, alignedBlock;
                    mov         edx, iWidthFrm;
                    mov         ecx, 11;
                    pxor        mm7, mm7;
main7a:
                    ComputeEightBytesCubicMC(esi - 2, esi - 1, esi, esi + 1);
                    movq        [edi], mm0;
                    add         esi, edx;
                    add         edi, 8;
                    dec         ecx;
                    jnz         main7a;

                    mov         esi, alignedBlock;
                    mov         edi, ppxlcCurrQMB;
                    mov         ecx, ppxliErrorQMB;
                    mov         eax, pLine1;
                    mov         ebx, pLine4;
main7b:
                    ComputeEightBytesCubicMC(esi, esi + 8, esi + 16, esi + 24);
                    movq        mm6, mm0;
                    ComputeEightBytesCubicMC(eax, eax + edx, eax + 2*edx, ebx);
                    movq        mm1, mm6;
                    ComputeBilinear();
//                    pavgb       mm0_mm6;
                    AddErrorAndClip(ecx);
                    movq        [edi], mm1;
                    add         ecx, 16;
                    add         esi, 8;
                    add         eax, edx;
                    add         ebx, edx;
                    add         edi, edx;
                    dec         iLoop;
                    jnz         main7b;
                    emms;
                }                  
            }
        }
    }
}

Void_WMV MotionCompMixed_KNI (
                        tWMVDecInternalMember *pWMVDec,
                        PixelC*              ppxlcPredMB,
                        const PixelC*        ppxlcRefMB,
                        I32_WMV                  iWidthPrev,
                        Bool_WMV                 bInterpolateX,
                        Bool_WMV                 bInterpolateY,
                        I32_WMV                  iMixedPelMV
                        )
{    
    PixelC* ppxlcPred = ppxlcPredMB;
        
    static const __int64 const_09_09_09_09 = 0x0009000900090009;
    static const __int64 const_08_08_08_08 = 0x0008000800080008;

    PixelC tempBlock[11 * 8 + 15];
    PixelC *alignedBlock = (PixelC*) (((int)tempBlock + 15) & ~15);

    if (bInterpolateY) {
        if (bInterpolateX) {  //!bXSubPxl && !bYSubPxl
            I32_WMV iy;
            assert(iMixedPelMV == 0);            
            for (iy = 0; iy < 8; iy++) {
                *(U64 *)(ppxlcPredMB) = *(U64 *)(ppxlcRefMB);
                ppxlcRefMB += iWidthPrev;
                ppxlcPredMB += iWidthPrev;
            }
        }
        else {  //bXSubPxl && !bYSubPxl            
            PixelC* pRef = (PixelC*) (ppxlcRefMB + 1);
            if (iMixedPelMV == 0) {
                _asm {
                    mov         esi, pRef;
                    mov         edi, ppxlcPred;
                    mov         edx, iWidthPrev;
                    mov         ecx, 8;
                    pxor        mm7, mm7;

main1a:
                    ComputeEightBytesCubicMC(esi - 2, esi - 1, esi, esi + 1);
                    movq        [edi], mm0;
                    add         esi, edx;
                    add         edi, edx;
                    dec         ecx;
                    jnz         main1a;
                    emms;
                }
            } else {
                // Handles the case in underline
                // I Q H Q I Q H Q I
                //     ___     ___
                _asm {
                    mov         esi, pRef;
                    mov         edi, ppxlcPred;
                    mov         edx, iWidthPrev;
                    mov         ecx, 8;
                    pxor        mm7, mm7;
                    
main1b:
                    ComputeEightBytesCubicMC(esi - 2, esi - 1, esi, esi + 1);
                    movq        mm1, [esi];
                    pavgb       mm0_mm1;
                    movq        [edi], mm0;

                    add         esi, edx;
                    add         edi, edx;
                    dec         ecx;
                    jnz         main1b;
                    emms;
                }
            }
        }
    }
    else {
        if (bInterpolateX) {  //!bXSubPxl&& bYSubPxl
            PixelC* pRef = (PixelC*) (ppxlcRefMB + iWidthPrev);
            const PixelC* pLine4 = pRef + iWidthPrev;
            const PixelC* pLine3 = pRef;
            const PixelC* pLine2 = pLine3 - iWidthPrev;
            const PixelC* pLine1 = pLine2 - iWidthPrev;                                

            if (iMixedPelMV == 0) {                             
                _asm {
                    mov         esi, pLine1;
                    mov         eax, pLine4;
                    mov         edi, ppxlcPred;
                    mov         edx, iWidthPrev;
                    mov         ecx, 8;
                    pxor        mm7, mm7;                   
main2a:
                    ComputeEightBytesCubicMC(esi, esi + edx, esi + 2*edx, eax);
                    movq        [edi], mm0;
                    add         esi, edx;
                    add         eax, edx;
                    add         edi, edx;
                    dec         ecx;
                    jnz         main2a;
                    emms;
                }                
            } else {
                //      H Q H' 
                //      I                     
                _asm {
                    mov         esi, pLine1;
                    mov         edi, alignedBlock;
                    mov         edx, iWidthPrev;
                    mov         ecx, 11;
                    pxor        mm7, mm7;

main2b:
                    ComputeEightBytesCubicMC(esi - 1, esi, esi + 1, esi + 2);
                    movq        [edi], mm0;
                    add         esi, edx;
                    add         edi, 8;
                    dec         ecx;
                    jnz         main2b;
 
                    mov         esi, alignedBlock;
                    mov         edi, ppxlcPred;
                    mov         ecx, 8;
                    mov         eax, pLine1;
                    mov         ebx, pLine4;
main2c:
                    ComputeEightBytesCubicMC(esi, esi + 8, esi + 16, esi + 24);
                    movq        mm6, mm0;
                    ComputeEightBytesCubicMC(eax, eax + edx, eax + 2*edx, ebx);
                    pavgb       mm0_mm6;
                    movq        [edi], mm0;
                    add         esi, 8;
                    add         eax, edx;
                    add         ebx, edx;
                    add         edi, edx;
                    dec         ecx;
                    jnz         main2c;
                    emms;
                }        
            }
        }
        else { // bXSubPxl && bYSubPxl
            PixelC* pRef = (PixelC*) (ppxlcRefMB + iWidthPrev + 1);
            const PixelC* pLine4 = pRef + iWidthPrev;
            const PixelC* pLine3 = pRef;
            const PixelC* pLine2 = pLine3 - iWidthPrev;
            const PixelC* pLine1 = pLine2 - iWidthPrev;                
            if (iMixedPelMV == 0) {

                _asm {
                    mov         esi, pLine1;
                    mov         edi, alignedBlock;
                    mov         edx, iWidthPrev;
                    mov         ecx, 11;
                    pxor        mm7, mm7;
main3a:
                    ComputeEightBytesCubicMC(esi - 2, esi - 1, esi, esi + 1);
                    movq        [edi], mm0;
                    add         esi, edx;
                    add         edi, 8;
                    dec         ecx;
                    jnz         main3a;

                    mov         esi, alignedBlock;
                    mov         edi, ppxlcPred;
                    mov         ecx, 8;
                   
main3b:
                    ComputeEightBytesCubicMC(esi, esi + 8, esi + 16, esi + 24);
                    movq        [edi], mm0;
                    add         esi, 8;
                    add         edi, edx;
                    dec         ecx;
                    jnz         main3b;
                    emms;
                }   
            } else {
                // H Q H
                //     I
                _asm {
                    mov         esi, pLine1;
                    mov         edi, alignedBlock;
                    mov         edx, iWidthPrev;
                    mov         ecx, 11;
                    pxor        mm7, mm7;
main4a:
                    ComputeEightBytesCubicMC(esi - 2, esi - 1, esi, esi + 1);
                    movq        [edi], mm0;
                    add         esi, edx;
                    add         edi, 8;
                    dec         ecx;
                    jnz         main4a;

                    mov         esi, alignedBlock;
                    mov         edi, ppxlcPred;
                    mov         ecx, 8;
                    mov         eax, pLine1;
                    mov         ebx, pLine4;
main4b:
                    ComputeEightBytesCubicMC(esi, esi + 8, esi + 16, esi + 24);
                    movq        mm6, mm0;
                    ComputeEightBytesCubicMC(eax, eax + edx, eax + 2*edx, ebx);
                    pavgb       mm0_mm6;
                    movq        [edi], mm0;
                    add         esi, 8;
                    add         eax, edx;
                    add         ebx, edx;
                    add         edi, edx;
                    dec         ecx;
                    jnz         main4b;
                    emms;
                }        
            }
        }
    }
}

Void_WMV MotionCompMixedAndAddError_KNI (
                                   tWMVDecInternalMember *pWMVDec,
                                   PixelC __huge* ppxlcCurrQMB, 
                                   const Buffer __huge* ppxliErrorBuf, 
                                   const PixelC __huge* ppxlcRef, 
                                   I32_WMV iWidthFrm, Bool_WMV bXEven, Bool_WMV bYEven, 
                                   I32_WMV iMixedPelMV
                                   )
{
    PixelC tempBlock[11 * 8 + 15];
    PixelC *alignedBlock = (PixelC*) (((int)tempBlock + 15) & ~15);

    static const __int64 const_09_09_09_09 = 0x0009000900090009;
    static const __int64 const_08_08_08_08 = 0x0008000800080008;

    const I16_WMV __huge *ppxliErrorQMB = ppxliErrorBuf->i16;
    if (bYEven) {
        if (bXEven) {  //!bXSubPxl && !bYSubPxl
            if (iMixedPelMV == 0) {
                _asm {
                    mov         esi, ppxliErrorQMB;
                    mov         edx, ppxlcRef;
                    mov         edi, ppxlcCurrQMB;
                    mov         ecx, 8;
                    pxor        mm7, mm7;
                    mov         ebx, iWidthFrm;
main0:
                    movq        mm0, [edx];
                    AddErrorAndClip(esi);
                    movq        [edi], mm1;

                    add         esi, 16;
                    add         edx, ebx;
                    add         edi, ebx;
                    dec         ecx;
                    jnz         main0;
                    emms;
                }
            } else {
                // Handles the case in underline
                // I Q H Q I Q H Q I
                //         ___                               
                _asm {
                    mov         esi, ppxlcRef;
                    mov         edi, ppxlcCurrQMB;
                    mov         edx, ppxliErrorQMB;
                    mov         ecx, 8;
                    mov         ebx, iWidthFrm;
                    pxor        mm7, mm7;
main1:
                    ComputeEightBytesCubicMC(esi - 1, esi, esi + 1, esi + 2);
                    movq        mm1, [esi];
                    pavgb       mm0_mm1;
                    AddErrorAndClip(edx);
                    movq        [edi], mm1;
                    
                    add         esi, ebx;
                    add         edi, ebx;
                    add         edx, 16;
                    dec         ecx;
                    jnz         main1;
                    emms;
                }
            }
        }
        else {  //bXSubPxl && !bYSubPxl
            if (iMixedPelMV == 0) {
                _asm {
                    mov         esi, ppxlcRef;
                    mov         edi, ppxlcCurrQMB;
                    mov         edx, ppxliErrorQMB;
                    mov         ecx, 8;
                    mov         ebx, iWidthFrm;
                    pxor        mm7, mm7;
main2:
                    ComputeEightBytesCubicMC(esi - 1, esi, esi + 1, esi + 2);
                    AddErrorAndClip(edx);
                    movq        [edi], mm1;
                    add         esi, ebx;
                    add         edi, ebx;
                    add         edx, 16;
                    dec         ecx;
                    jnz         main2;
                    emms;
                }
            } else {
                // Handles the case in underline
                // I Q H Q I Q H Q I
                //     ___     ___   
                _asm {
                    mov         esi, ppxlcRef;
                    mov         edi, ppxlcCurrQMB;
                    mov         edx, ppxliErrorQMB;
                    mov         ecx, 8;
                    mov         ebx, iWidthFrm;
                    pxor        mm7, mm7;
main3:
                    ComputeEightBytesCubicMC(esi - 1, esi, esi + 1, esi + 2);
                    movq        mm1, [esi + 1];
                    pavgb       mm0_mm1;
                    AddErrorAndClip(edx);
                    movq        [edi], mm1;
                    
                    add         esi, ebx;
                    add         edi, ebx;
                    add         edx, 16;
                    dec         ecx;
                    jnz         main3;
                    emms;
                }                
            }
        }
    }
    else {
        if (bXEven) {  //!bXSubPxl&& bYSubPxl
            if (iMixedPelMV == 0) {
                const PixelC* pLine1 = ppxlcRef - iWidthFrm;
                const PixelC* pLine4 = ppxlcRef + 2 * iWidthFrm;   

                _asm {
                    mov         esi, pLine1;
                    mov         eax, pLine4;
                    mov         edi, ppxlcCurrQMB;
                    mov         ebx, ppxliErrorQMB;
                    mov         edx, iWidthFrm;
                    mov         ecx, 8;
                    pxor        mm7, mm7;                   
main4:
                    ComputeEightBytesCubicMC(esi, esi + edx, esi + 2*edx, eax);
                    AddErrorAndClip(ebx);
                    movq        [edi], mm1;
                    add         esi, edx;
                    add         eax, edx;
                    add         edi, edx;
                    add         ebx, 16;
                    dec         ecx;
                    jnz         main4;
                    emms;
                } 
            } else {
                //      H Q H' 
                //      I                              
                PixelC* pRef = (PixelC*) (ppxlcRef + iWidthFrm);                   
                const PixelC* pLine4 = pRef + iWidthFrm; 
                const PixelC* pLine1 = pRef - 2 * iWidthFrm;
                I32_WMV iLoop = 8;
                //      H Q H' 
                //      I                     
                _asm {
                    mov         esi, pLine1;
                    mov         edi, alignedBlock;
                    mov         edx, iWidthFrm;
                    mov         ecx, 11;
                    pxor        mm7, mm7;

main5a:
                    ComputeEightBytesCubicMC(esi - 1, esi, esi + 1, esi + 2);
                    movq        [edi], mm0;
                    add         esi, edx;
                    add         edi, 8;
                    dec         ecx;
                    jnz         main5a;
 
                    mov         esi, alignedBlock;
                    mov         edi, ppxlcCurrQMB; 
                    mov         ecx, ppxliErrorQMB;
                    mov         eax, pLine1;
                    mov         ebx, pLine4;
main5b:
                    ComputeEightBytesCubicMC(esi, esi + 8, esi + 16, esi + 24);
                    movq        mm6, mm0;
                    ComputeEightBytesCubicMC(eax, eax + edx, eax + 2*edx, ebx);
                    pavgb       mm0_mm6;
                    AddErrorAndClip(ecx);
                    movq        [edi], mm1;
                    add         ecx, 16;
                    add         esi, 8;
                    add         eax, edx;
                    add         ebx, edx;
                    add         edi, edx;
                    dec         iLoop;
                    jnz         main5b;
                    emms;
                }         
            }
        }
        else { // bXSubPxl && bYSubPxl
            if (iMixedPelMV == 0) {
                const PixelC* pLine1 = ppxlcRef - iWidthFrm;
                _asm {
                    mov         esi, pLine1;
                    mov         edi, alignedBlock;
                    mov         edx, iWidthFrm;
                    mov         ecx, 11;
                    pxor        mm7, mm7;
main6a:
                    ComputeEightBytesCubicMC(esi - 1, esi, esi + 1, esi + 2);
                    movq        [edi], mm0;
                    add         esi, edx;
                    add         edi, 8;
                    dec         ecx;
                    jnz         main6a;

                    mov         esi, alignedBlock;
                    mov         edi, ppxlcCurrQMB;
                    mov         ebx, ppxliErrorQMB
                    mov         ecx, 8;
                   
main6b:
                    ComputeEightBytesCubicMC(esi, esi + 8, esi + 16, esi + 24);
                    AddErrorAndClip(ebx);
                    movq        [edi], mm1;
                    add         ebx, 16;
                    add         esi, 8;
                    add         edi, edx;
                    dec         ecx;
                    jnz         main6b;
                    emms;
                }                      
            } else {
                // H Q H
                //     I
                //alignedBlock
                PixelC* pRef = (PixelC*) (ppxlcRef + iWidthFrm + 1); 
                const PixelC* pLine4 = pRef + iWidthFrm;
                const PixelC* pLine1 = pRef - 2 * iWidthFrm;
                I32_WMV iLoop = 8;
                _asm {
                    mov         esi, pLine1;
                    mov         edi, alignedBlock;
                    mov         edx, iWidthFrm;
                    mov         ecx, 11;
                    pxor        mm7, mm7;
main7a:
                    ComputeEightBytesCubicMC(esi - 2, esi - 1, esi, esi + 1);
                    movq        [edi], mm0;
                    add         esi, edx;
                    add         edi, 8;
                    dec         ecx;
                    jnz         main7a;

                    mov         esi, alignedBlock;
                    mov         edi, ppxlcCurrQMB;
                    mov         ecx, ppxliErrorQMB;
                    mov         eax, pLine1;
                    mov         ebx, pLine4;
main7b:
                    ComputeEightBytesCubicMC(esi, esi + 8, esi + 16, esi + 24);
                    movq        mm6, mm0;
                    ComputeEightBytesCubicMC(eax, eax + edx, eax + 2*edx, ebx);
                    pavgb       mm0_mm6;
                    AddErrorAndClip(ecx);
                    movq        [edi], mm1;
                    add         ecx, 16;
                    add         esi, 8;
                    add         eax, edx;
                    add         ebx, edx;
                    add         edi, edx;
                    dec         iLoop;
                    jnz         main7b;
                    emms;
                }                  
            }
        }
    }
}



#define WMV_ESC_Decoding()                                                          \
	if (pWMVDec->m_bFirstEscCodeInFrame){                                                    \
        decodeBitsOfESCCode (pWMVDec);                                                     \
        pWMVDec->m_bFirstEscCodeInFrame = FALSE_WMV;                                             \
	}                                                                               \
	uiRun = BS_getBits (pWMVDec->m_pbitstrmIn,pWMVDec->m_iNUMBITS_ESC_RUN);			                    \
	if (BS_getBit (pWMVDec->m_pbitstrmIn)) /* escape decoding */                              \
		iLevel = -1 * BS_getBits (pWMVDec->m_pbitstrmIn,pWMVDec->m_iNUMBITS_ESC_LEVEL);                 \
	else                                                                            \
		iLevel = BS_getBits (pWMVDec->m_pbitstrmIn,pWMVDec->m_iNUMBITS_ESC_LEVEL);                      

int dbg_cnt1;

//This is not really an MMX routine but works along side the MMX idct
tWMVDecodeStatus DecodeInverseInterBlockQuantizeEscCode_MMX(tWMVDecInternalMember *pWMVDec, CDCTTableInfo_Dec* InterDCTTableInfo_Dec, U8_WMV *pZigzagInv, I32_WMV iXformMode)
{
	Huffman_WMV* hufDCTACDec = InterDCTTableInfo_Dec->hufDCTACDec;
	I8_WMV* rgLevelAtIndx = InterDCTTableInfo_Dec->pcLevelAtIndx;
	U8_WMV* rgRunAtIndx = InterDCTTableInfo_Dec->puiRunAtIndx;
//  Change iStartIndxOfLastRun to iStartIndxOfLastRunMinus1 and <= to <
//	iStartIndxOfLastRun = InterDCTTableInfo_Dec->iStartIndxOfLastRunMinus1;
	U8_WMV* rgIfNotLastNumOfLevelAtRun = InterDCTTableInfo_Dec->puiNotLastNumOfLevelAtRun;
	U8_WMV* rgIfLastNumOfLevelAtRun = InterDCTTableInfo_Dec->puiLastNumOfLevelAtRun; 
	U8_WMV* rgIfNotLastNumOfRunAtLevel = InterDCTTableInfo_Dec->puiNotLastNumOfRunAtLevel;
	U8_WMV* rgIfLastNumOfRunAtLevel = InterDCTTableInfo_Dec->puiLastNumOfRunAtLevel;
//	U32_WMV iStartIndxOfLastRun = InterDCTTableInfo_Dec->iStartIndxOfLastRunMinus1 + 1;
	I32_WMV iStartIndxOfLastRun = InterDCTTableInfo_Dec->iStartIndxOfLastRunMinus1 + 1;
	I32_WMV  iTCOEF_ESCAPE = InterDCTTableInfo_Dec->iTcoef_ESCAPE;

    Bool_WMV bIsLastRun = FALSE_WMV;
    U32_WMV uiRun; // = 0;
    I32_WMV  iLevel; // = 0;
    U32_WMV uiCoefCounter = 0;
//    U8_WMV   lIndex;
    I32_WMV iDoubleStepSize = pWMVDec->m_iDoubleStepSize;
    I32_WMV iStepMinusStepIsEven = pWMVDec->m_iStepMinusStepIsEven;
    //Align on cache line
    I16_WMV *rgiCoefRecon = (I16_WMV*)pWMVDec->m_rgiCoefRecon;
	register I32_WMV iDCTHorzFlags = 0;

//    memset (rgiCoefRecon, 0, (size_t) (BLOCK_SQUARE_SIZE_2>>1));
	_asm {
		xor		edx,edx
		mov		edi,rgiCoefRecon
		mov		dword ptr [edi],edx
		mov		dword ptr [edi+0x4],edx
		mov		dword ptr [edi+0x8],edx
		mov		dword ptr [edi+0xc],edx
		mov		dword ptr [edi+0x10],edx
		mov		dword ptr [edi+0x14],edx
		mov		dword ptr [edi+0x18],edx
		mov		dword ptr [edi+0x1c],edx
		mov		dword ptr [edi+0x20],edx
		mov		dword ptr [edi+0x24],edx
		mov		dword ptr [edi+0x28],edx
		mov		dword ptr [edi+0x2c],edx
		mov		dword ptr [edi+0x30],edx
		mov		dword ptr [edi+0x34],edx
		mov		dword ptr [edi+0x38],edx
		mov		dword ptr [edi+0x3c],edx
		mov		dword ptr [edi+0x40],edx
		mov		dword ptr [edi+0x44],edx
		mov		dword ptr [edi+0x48],edx
		mov		dword ptr [edi+0x4c],edx
		mov		dword ptr [edi+0x50],edx
		mov		dword ptr [edi+0x54],edx
		mov		dword ptr [edi+0x58],edx
		mov		dword ptr [edi+0x5c],edx
		mov		dword ptr [edi+0x60],edx
		mov		dword ptr [edi+0x64],edx
		mov		dword ptr [edi+0x68],edx
		mov		dword ptr [edi+0x6c],edx
		mov		dword ptr [edi+0x70],edx
		mov		dword ptr [edi+0x74],edx
		mov		dword ptr [edi+0x78],edx
		mov		dword ptr [edi+0x7c],edx
	}

    do {

	    dbg_cnt1++;
		I32_WMV lIndex = Huffman_WMV_get (hufDCTACDec, pWMVDec->m_pbitstrmIn);
        register I32_WMV iIndex;

		//lIndex = pWMVDec->m_pbitstrmIn->getMaxBits(MAXCODEWORDLNGDCT,gDecodeCodeTableDCT);//pWMVDec->m_iMaxCodeLngth, pWMVDec->m_rgCodeSymSize);
		if (BS_invalid ( pWMVDec->m_pbitstrmIn )) {
			return WMV_CorruptedBits;
		}
        //lIndex = pWMVDec->m_pentrdecDCT->decodeSymbol();
        // if Huffman
        if (lIndex != iTCOEF_ESCAPE)	{
			if (lIndex >= iStartIndxOfLastRun)
				bIsLastRun = TRUE_WMV;
            uiRun = rgRunAtIndx[lIndex];
            iLevel = (BS_getBit ( pWMVDec->m_pbitstrmIn)) ? - rgLevelAtIndx[lIndex] :
                rgLevelAtIndx[lIndex];
            if (BS_invalid ( pWMVDec->m_pbitstrmIn )) {
                return WMV_CorruptedBits;
            }
        } 
		else {
			if (BS_getBit (pWMVDec->m_pbitstrmIn)){
                I32_WMV lIndex2;
                if (BS_invalid ( pWMVDec->m_pbitstrmIn )) {
                    return WMV_CorruptedBits;
                }
				// ESC + '1' + VLC
        		//lIndex2 = hufDCTACDec->get (pWMVDec->m_pbitstrmIn);
				lIndex2 = Huffman_WMV_get (hufDCTACDec, pWMVDec->m_pbitstrmIn);
				//lIndex = pWMVDec->m_pbitstrmIn->getMaxBits(MAXCODEWORDLNGDCT,gDecodeCodeTableDCT);//pWMVDec->m_iMaxCodeLngth, pWMVDec->m_rgCodeSymSize);
                if (BS_invalid ( pWMVDec->m_pbitstrmIn ) || lIndex2 == iTCOEF_ESCAPE) { // ESC + 1 + ESC :  bits corrupted
			        return WMV_CorruptedBits;
		        }
				uiRun = rgRunAtIndx[lIndex2];
				iLevel = rgLevelAtIndx[lIndex2];
				if (lIndex2 >= iStartIndxOfLastRun){
					bIsLastRun = TRUE_WMV;
					iLevel += (I8_WMV) rgIfLastNumOfLevelAtRun[uiRun];
				}
				else
					iLevel += (I8_WMV) rgIfNotLastNumOfLevelAtRun[uiRun];
				if (BS_getBit ( pWMVDec->m_pbitstrmIn)) 
					iLevel = -iLevel;
                if (BS_invalid ( pWMVDec->m_pbitstrmIn )) {
                    return WMV_CorruptedBits;
                }
			}
			else if (BS_getBit (pWMVDec->m_pbitstrmIn)){
                I32_WMV lIndex2;
                if (BS_invalid ( pWMVDec->m_pbitstrmIn )) {
                    return WMV_CorruptedBits;
                }
				// ESC + '10' + VLC
        		//lIndex2 = hufDCTACDec->get (pWMVDec->m_pbitstrmIn);
				lIndex2 = Huffman_WMV_get (hufDCTACDec, pWMVDec->m_pbitstrmIn);
				//lIndex = pWMVDec->m_pbitstrmIn->getMaxBits(MAXCODEWORDLNGDCT,gDecodeCodeTableDCT);//pWMVDec->m_iMaxCodeLngth, pWMVDec->m_rgCodeSymSize);
                if (BS_invalid ( pWMVDec->m_pbitstrmIn ) || lIndex2 == iTCOEF_ESCAPE) { // ESC + 1 + ESC :  bits corrupted
			        return WMV_CorruptedBits;
		        }
				uiRun = rgRunAtIndx[lIndex2];
				iLevel = rgLevelAtIndx[lIndex2];
				if (lIndex2 >= iStartIndxOfLastRun){
					bIsLastRun = TRUE_WMV;
					uiRun += (rgIfLastNumOfRunAtLevel[iLevel] + pWMVDec->m_iEscRunDiffV2V3);
				}
				else
					uiRun += (rgIfNotLastNumOfRunAtLevel[iLevel] + pWMVDec->m_iEscRunDiffV2V3);
				if (BS_getBit ( pWMVDec->m_pbitstrmIn)) 
					iLevel = -iLevel;
                if (BS_invalid ( pWMVDec->m_pbitstrmIn )) {
                    return WMV_CorruptedBits;
                }
			}
			else{
				// ESC + '00' + FLC
				bIsLastRun = (Bool_WMV) BS_getBit (pWMVDec->m_pbitstrmIn); // escape decoding
                if (pWMVDec->m_cvCodecVersion >= WMV1){  // == WMV1 || WMV2
                    WMV_ESC_Decoding();
                }
                else{
					uiRun = BS_getBits (pWMVDec->m_pbitstrmIn,NUMBITS_ESC_RUN);			
        			iLevel = (I8_WMV)BS_getBits(pWMVDec->m_pbitstrmIn, NUMBITS_ESC_LEVEL);
				}
		        if (BS_invalid ( pWMVDec->m_pbitstrmIn )) {
			        return WMV_CorruptedBits;
		        }
			}
        }
        uiCoefCounter += uiRun;

		if (uiCoefCounter >= BLOCK_SQUARE_SIZE) {
			return WMV_CorruptedBits;
        }

        
        iIndex = pWMVDec->m_pZigzagInv [uiCoefCounter];

        // If this coefficient is not in the first column then set the flag which indicates
        // what row it is in. This flag field will be used by the IDCT to see if it can
        // shortcut the IDCT of the row if all coefficients are zero.
		if (iIndex & 0x7)
			iDCTHorzFlags |= (1<<((iIndex & 0x38)>>3));

        if (iLevel == 1)
			rgiCoefRecon [pZigzagInv [uiCoefCounter]] = (I16_WMV) pWMVDec->m_i2DoublePlusStepSize;
		else if (iLevel == -1)
			rgiCoefRecon [pZigzagInv [uiCoefCounter]] = (I16_WMV) pWMVDec->m_i2DoublePlusStepSizeNeg;
		else if (iLevel > 0)
//			I32_WMV iCoefRecon = pWMVDec->m_iStepSize * ((iLevel << 1) + 1) - pWMVDec->m_bStepSizeIsEven;
			rgiCoefRecon [pZigzagInv [uiCoefCounter]] = iDoubleStepSize * iLevel + iStepMinusStepIsEven;
		else
//			I32_WMV iCoefRecon = pWMVDec->m_bStepSizeIsEven - pWMVDec->m_iStepSize * (1 - (iLevel << 1));
			rgiCoefRecon [pZigzagInv [uiCoefCounter]] = iDoubleStepSize * iLevel - iStepMinusStepIsEven;

        uiCoefCounter++;
    } while (!bIsLastRun);
    // Save the DCT row flags. This will be passed to the IDCT routine
    pWMVDec->m_iDCTHorzFlags = iDCTHorzFlags;

    return WMV_Succeeded;
}

I32_WMV BlkAvgX8_MMX(const PixelC* ppxlcCurrRecnMB, I32_WMV iWidthPrev, I32_WMV iStepSize)
{
    I32_WMV iSum = 0;
	__asm {
		mov             ebx, ppxlcCurrRecnMB;
        mov             eax, iWidthPrev
		mov             ecx, BLOCK_SIZE

		pxor            mm6, mm6 // keep summation
		pxor            mm7, mm7 // zero

	mainLoopS:
		movq            mm0, [ebx]
		movq            mm2, mm0
		punpcklbw       mm2, mm7
		paddusw         mm6, mm2
		
		punpckhbw       mm0, mm7
		paddusw         mm6, mm0

		add             ebx, eax
		dec             ecx
		jne             mainLoopS

        // sum the four WORD up in one mm6
		movq            mm0, mm6
		punpcklwd       mm0, mm7
		punpckhwd       mm6, mm7
		paddd           mm6, mm0

		movq            mm0, mm6
		punpckldq       mm0, mm7
		punpckhdq       mm6, mm7
		paddd           mm6, mm0

        movd            edi, mm6
        mov             iSum, edi

        emms 
    }
    return ((iSum + 4) >> 3) / iStepSize;  // iSum / 64 * 8
};

Void_WMV g_RepeatRef0Y_MMX (
	PixelC* ppxlcRef0Y,
	CoordI  iStart, 
    CoordI  iEnd,
	I32_WMV     iOldLeftOffet,
	Bool_WMV    fTop, 
    Bool_WMV    fBottom,
    I32_WMV     iWidthY,
    I32_WMV     iWidthYPlusExp,
    I32_WMV     iWidthPrevY
)
{
	const PixelC* ppxliOldLeft = ppxlcRef0Y + iOldLeftOffet;
	const PixelC* ppxliOldRight = ppxliOldLeft + iWidthY - 1;
	const PixelC* ppxliOldTopLn = ppxliOldLeft - EXPANDY_REFVOP;
	PixelC* ppxliNew = (PixelC*) ppxliOldTopLn;
    I32_WMV iResidue = iWidthPrevY - iWidthYPlusExp;
	
//	I32_WMV iWidthPrevY = m_iWidthPrevY, iWidthYPlusExp = m_iWidthYPlusExp;
	I32_WMV iter = iEnd - iStart;
	const I32_WMV iPnewInc = iter * iWidthPrevY;
	static const __int64	x00000000000000FF = 0x00000000000000FF;
    I32_WMV iWidthPrevYDiv8;
    
	__asm {
        mov			eax, dword ptr [ppxliNew]
        mov			ebx, dword ptr [ppxliOldLeft]
        mov			ecx, dword ptr [iter]
        mov			edx, dword ptr [ppxliOldRight]
        mov			edi, dword ptr [iWidthPrevY]
        mov			esi, dword ptr [iWidthYPlusExp]

        movq		mm7, x00000000000000FF

NEXT_ROW:
        // left
        movd		mm6, [ebx]
        pand		mm6, mm7

        movq		mm0, mm6
        psllq		mm6, 8
        por			mm6, mm0

        movq		mm0, mm6
        psllq		mm6, 16
        por			mm6, mm0

        movq		mm0, mm6
        psllq		mm6, 32
        por			mm6, mm0

        movq		[eax], mm6
        movq		[eax + 8], mm6
        movq		[eax + 16], mm6
        movq		[eax + 24], mm6

        add			eax, esi

        // right
        movd		mm6, [edx]
        pand		mm6, mm7

        movq		mm0, mm6
        psllq		mm6, 8
        por			mm6, mm0

        movq		mm0, mm6
        psllq		mm6, 16
        por			mm6, mm0

        movq		mm0, mm6
        psllq		mm6, 32
        por			mm6, mm0

        movq		[eax], mm6
        movq		[eax + 8], mm6
        movq		[eax + 16], mm6
        movq		[eax + 24], mm6

//        add			eax, EXPANDY_REFVOP
        add			eax, dword ptr [iResidue]
        add			ebx, edi
        add			edx, edi

        dec			ecx
        jne			NEXT_ROW

        emms
	}

	ppxliOldRight = ppxliOldLeft + iWidthY - 1;
	ppxliNew = (PixelC*) ppxliOldTopLn;
    I32_WMV iResidueMB = iWidthPrevY - iWidthYPlusExp - EXPANDY_REFVOP;
	
    if (iResidueMB != 0) {
	    CoordI y;
	    for (y = iStart; y < iEnd; y++) { // x-direction interpolation
		    ppxliNew += iWidthYPlusExp + EXPANDY_REFVOP;		
		    memset (ppxliNew, *ppxliOldRight, iResidueMB);
		    ppxliNew += iResidueMB;
		    ppxliOldRight += iWidthPrevY;
	    }
    } else
        ppxliNew += (iEnd - iStart) * (iWidthYPlusExp + EXPANDY_REFVOP);

//	ppxliNew += iPnewInc;
    
	iWidthPrevYDiv8 = iWidthPrevY >> 3;
	if (fTop) {
		PixelC* ppxliLeftTop = ppxlcRef0Y;
		__asm {
            mov			eax, dword ptr [ppxliLeftTop]	
            mov			edx, EXPANDY_REFVOP
NEXT_ROW2:
            mov			ecx, dword ptr [iWidthPrevYDiv8]
            mov			ebx, dword ptr [ppxliOldTopLn]
NEXT_FIELD2:
            movq		mm0, [ebx]
            movq		[eax], mm0

            add			eax, 8
            add			ebx, 8

            dec			ecx
            jne			NEXT_FIELD2

            dec			edx
            jne			NEXT_ROW2

            emms
		}
	}
	if (fBottom) {
        I32_WMV iHeightYPadded = (iEnd + 15) & ~15;
        I32_WMV iBotExtend = iHeightYPadded - iEnd + EXPANDY_REFVOP;
		const PixelC* ppxliOldBotLn = ppxliNew - iWidthPrevY;
		__asm {
            mov			eax, dword ptr [ppxliNew]	
            mov			edx, dword ptr [iBotExtend]
NEXT_ROW3:
            mov			ecx, dword ptr [iWidthPrevYDiv8]
            mov			ebx, dword ptr [ppxliOldBotLn]
NEXT_FIELD3:
            movq		mm0, [ebx]
            movq		[eax], mm0

            add			eax, 8
            add			ebx, 8

            dec			ecx
            jne			NEXT_FIELD3

            dec			edx
            jne			NEXT_ROW3

            emms
		}
	}
}

Void_WMV g_RepeatRef0UV_MMX (
	PixelC* ppxlcRef0U,
	PixelC* ppxlcRef0V,
	CoordI  iStart, 
    CoordI  iEnd,
	I32_WMV     iOldLeftOffet,
	Bool_WMV    fTop, 
    Bool_WMV    fBottom,
    I32_WMV     iWidthUV,
    I32_WMV     iWidthUVPlusExp,
    I32_WMV     iWidthPrevUV
)
{
	const PixelC* ppxliOldLeftU = ppxlcRef0U + iOldLeftOffet;
	const PixelC* ppxliOldLeftV = ppxlcRef0V + iOldLeftOffet;
	const PixelC* ppxliOldRightU = ppxliOldLeftU + iWidthUV - 1;
	const PixelC* ppxliOldRightV = ppxliOldLeftV + iWidthUV - 1;
	const PixelC* ppxliOldTopLnU = ppxliOldLeftU - EXPANDUV_REFVOP;
	const PixelC* ppxliOldTopLnV = ppxliOldLeftV - EXPANDUV_REFVOP;
	PixelC* ppxliNewU = (PixelC*) ppxliOldTopLnU;
	PixelC* ppxliNewV = (PixelC*) ppxliOldTopLnV;
    I32_WMV iResidue = iWidthPrevUV - iWidthUVPlusExp;
	CoordI y;
    I32_WMV iWidthPrevUVDiv8;
	for (y = iStart; y < iEnd; y++) { // x-direction interpolation
		memset (ppxliNewU, *ppxliOldLeftU, EXPANDUV_REFVOP);
		memset (ppxliNewV, *ppxliOldLeftV, EXPANDUV_REFVOP);
		ppxliNewU += iWidthUVPlusExp;		
		ppxliNewV += iWidthUVPlusExp;		
//		memset(ppxliNewU, *ppxliOldRightU, EXPANDUV_REFVOP);
//		memset(ppxliNewV, *ppxliOldRightV, EXPANDUV_REFVOP);
//		ppxliNewU += EXPANDUV_REFVOP;		
//		ppxliNewV += EXPANDUV_REFVOP;		
		memset(ppxliNewU, *ppxliOldRightU, iResidue);
		memset(ppxliNewV, *ppxliOldRightV, iResidue);
		ppxliNewU += iResidue;		
		ppxliNewV += iResidue;		
		ppxliOldLeftU += iWidthPrevUV;
		ppxliOldLeftV += iWidthPrevUV;
		ppxliOldRightU += iWidthPrevUV;
		ppxliOldRightV += iWidthPrevUV;
	}
	iWidthPrevUVDiv8 = iWidthPrevUV >> 3;
	if (fTop) {
		PixelC* ppxliLeftTopU = ppxlcRef0U;
		PixelC* ppxliLeftTopV = ppxlcRef0V;
		__asm {
            mov			eax, dword ptr [ppxliLeftTopU]	
            mov			edx, EXPANDUV_REFVOP
            mov			edi, dword ptr [ppxliLeftTopV]	
NEXT_ROW2:
            mov			ebx, dword ptr [ppxliOldTopLnU]
            mov			ecx, dword ptr [iWidthPrevUVDiv8]
            mov			esi, dword ptr [ppxliOldTopLnV]
NEXT_FIELD2:
            // U
            movq		mm0, [ebx]
            movq		[eax], mm0

            add			eax, 8
            add			ebx, 8

            // V
            movq		mm0, [esi]
            movq		[edi], mm0

            add			esi, 8
            add			edi, 8

            dec			ecx
            jne			NEXT_FIELD2

            dec			edx
            jne			NEXT_ROW2

            emms
		}
	}
	if (fBottom) {
		const PixelC* ppxliOldBotLnU = ppxliNewU - iWidthPrevUV;
		const PixelC* ppxliOldBotLnV = ppxliNewV - iWidthPrevUV;
        I32_WMV iHeightUVPadded = ((iEnd * 2 + 15) & ~15)/2;
        I32_WMV iBotExtend = iHeightUVPadded - iEnd + EXPANDUV_REFVOP; 

		__asm {
            mov			eax, dword ptr [ppxliNewU]	
//            mov			edx, EXPANDUV_REFVOP
            mov			edx, dword ptr [iBotExtend]
            mov			edi, dword ptr [ppxliNewV]	
NEXT_ROW3:
            mov			ecx, dword ptr [iWidthPrevUVDiv8]
            mov			ebx, dword ptr [ppxliOldBotLnU]
            mov			esi, dword ptr [ppxliOldBotLnV]
NEXT_FIELD3:
            // U
            movq		mm0, [ebx]
            movq		[eax], mm0

            add			eax, 8
            add			ebx, 8

            // V
            movq		mm0, [esi]
            movq		[edi], mm0

            add			esi, 8
            add			edi, 8

            dec			ecx
            jne			NEXT_FIELD3

            dec			edx
            jne			NEXT_ROW3

            emms
		}
	}
}
#endif // _WMV_TARGET_X86_ || _Embedded_x86
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\headdec.cpp ===
/*************************************************************************

Copyright (c) 1996  Microsoft Corporation

Module Name:

	vopmbEnc.cpp

Abstract:

	Encoder VOP composed of MB's

Author:

	Ming-Chieh Lee (mingcl@microsoft.com)
	Bruce Lin (blin@microsoft.com)
			
	20-March-1996

Revision History:

*************************************************************************/
#include "bldsetup.h"

#include "xplatform.h"
#include <stdio.h>
#include <math.h>
#include <stdlib.h>

#include "typedef.hpp"
#include "strmdec_wmv.hpp"
#include "wmvdec_member.h"
#include "wmvdec_function.h"

tWMVDecodeStatus decodeMBOverheadOfIVOP_MSV (tWMVDecInternalMember *pWMVDec, CWMVMBMode* pmbmd, I32_WMV imbX, I32_WMV imbY)
{
    CWMVMBMode* pmbmdTop = pmbmd - pWMVDec->m_uintNumMBX;
    CWMVMBMode* pmbmdLeftTop = pmbmdTop - 1;
    CWMVMBMode* pmbmdLeft = pmbmd - 1;
    I32_WMV iCBPCY;
    I32_WMV iPredCBPY1, iPredCBPY2, iPredCBPY3, iPredCBPY4; 
    
    if (imbY == 0) {
        pmbmdTop = pWMVDec->m_pmbmdZeroCBPCY;
        pmbmdLeftTop = pWMVDec->m_pmbmdZeroCBPCY;
    }
    if (imbX == 0) {
        pmbmdLeft = pWMVDec->m_pmbmdZeroCBPCY;
        pmbmdLeftTop = pWMVDec->m_pmbmdZeroCBPCY;
    }

    iCBPCY = Huffman_WMV_get (&pWMVDec->m_hufICBPCYDec, pWMVDec->m_pbitstrmIn);
	if (BS_invalid ( pWMVDec->m_pbitstrmIn )) {
		return WMV_CorruptedBits;
	}
	if (iCBPCY < 0 || iCBPCY > 63) {
		return WMV_CorruptedBits;
	}

    pmbmd->m_rgbDCTCoefPredPattern = (U8_WMV) BS_getBit (pWMVDec->m_pbitstrmIn);
    
	if (BS_invalid ( pWMVDec->m_pbitstrmIn )) {
		return WMV_CorruptedBits;
	}
	pmbmd->m_bSkip = FALSE_WMV;
	pmbmd->m_dctMd = INTRA;
    
    I32_WMV iLeftTopCBPY4, iTopCBPY3, iTopCBPY4, iLeftCBPY2, iLeftCBPY4;
    
    iLeftTopCBPY4 = (pmbmdLeftTop->m_rgbCodedBlockPattern & (1<<2)) >> 2;
    iTopCBPY3 = (pmbmdTop->m_rgbCodedBlockPattern & (1<<3)) >> 3;
    iTopCBPY4 = (pmbmdTop->m_rgbCodedBlockPattern & (1<<2)) >> 2;
    iLeftCBPY2 = (pmbmdLeft->m_rgbCodedBlockPattern & (1<<4)) >> 4;
    iLeftCBPY4 = (pmbmdLeft->m_rgbCodedBlockPattern & (1<<2)) >> 2;

    iPredCBPY1 = (iLeftTopCBPY4 == iTopCBPY3 ) ? iLeftCBPY2 : iTopCBPY3;
    iPredCBPY1 ^= ((iCBPCY >> 5) & 0x00000001);

    iPredCBPY2 = (iTopCBPY3 == iTopCBPY4)? iPredCBPY1 : iTopCBPY4;
    iPredCBPY2 ^= ((iCBPCY >> 4) & 0x00000001);

    iPredCBPY3 = (iLeftCBPY2 == iPredCBPY1) ? iLeftCBPY4 : iPredCBPY1;
    iPredCBPY3 ^= ((iCBPCY >> 3) & 0x00000001);

    iPredCBPY4 = (iPredCBPY1 == iPredCBPY2)? iPredCBPY3: iPredCBPY2;
    iPredCBPY4 ^= ((iCBPCY >> 2) & 0x00000001);

    pmbmd->m_rgbCodedBlockPattern = (iPredCBPY1<<5)  | (iPredCBPY2<<4) |
        (iPredCBPY3<<3) | (iPredCBPY4<<2) | (iCBPCY & 0x00000003);

    //
    iCBPCY = iPredCBPY1 | iPredCBPY2 | iPredCBPY3 | iPredCBPY4 | iCBPCY & 0x00000003;
    // 0 :  0
    // 1 : 10
    // 2 : 11
    pmbmd->m_iDCTTable_MB_Index = 0;
    if (pWMVDec->m_bDCTTable_MB && iCBPCY){
        I32_WMV iDCTMBTableIndex = BS_getBit (pWMVDec->m_pbitstrmIn);
        if (iDCTMBTableIndex)
            iDCTMBTableIndex += BS_getBit (pWMVDec->m_pbitstrmIn); 
        assert(iDCTMBTableIndex>=0 && iDCTMBTableIndex<=2);
        pmbmd->m_iDCTTable_MB_Index = iDCTMBTableIndex;
    }
    
    return WMV_Succeeded;
}

tWMVDecodeStatus decodeMBOverheadOfPVOP_MSV (tWMVDecInternalMember *pWMVDec, CWMVMBMode* pmbmd)
{
    I32_WMV iCBPCY = 0;
	if (pWMVDec->m_bCODFlagOn) {

        if (pWMVDec->m_bSKIPBIT_CODING_ == FALSE) {
            pmbmd->m_bSkip = BS_getBit (pWMVDec->m_pbitstrmIn);
            if (BS_invalid ( pWMVDec->m_pbitstrmIn )) {
                return WMV_CorruptedBits;
            }
        }
		if (pmbmd->m_bSkip) {
            pmbmd->m_rgbCodedBlockPattern = 0;
			pmbmd->m_dctMd = INTER;
			return WMV_Succeeded;
		}
	}
	else
		pmbmd->m_bSkip = FALSE_WMV; // might be reset later

    if (pWMVDec->m_bNEW_PCBPCY_TABLE) {
	    iCBPCY  = Huffman_WMV_get (pWMVDec->m_pHufNewPCBPCYDec, pWMVDec->m_pbitstrmIn);
    } else {
        iCBPCY  = Huffman_WMV_get (&pWMVDec->m_hufPCBPCYDec, pWMVDec->m_pbitstrmIn);
    }

    if (BS_invalid ( pWMVDec->m_pbitstrmIn )) {
		return WMV_CorruptedBits;
	}
	if (iCBPCY < 0 || iCBPCY > 127) {
		return WMV_CorruptedBits;
	}

    if (iCBPCY & 0x00000040){ // INTER MB iCBPCY == CBPCY + 64
        pmbmd->m_dctMd = INTER;
        iCBPCY ^= 0x00000040;
		pmbmd->m_bCBPAllZero = (iCBPCY == 0);
    //_HYBRID_MV_
    if (pWMVDec->m_bMBHybridMV)
        pmbmd->m_iMVPredDirection = (U8_WMV) BS_getBit (pWMVDec->m_pbitstrmIn);
    else
        pmbmd->m_iMVPredDirection = 2;

    }
    else{
        pmbmd->m_dctMd = INTRA;

        pmbmd->m_rgbDCTCoefPredPattern = (U8_WMV) BS_getBit (pWMVDec->m_pbitstrmIn);

        // YU = 00 :0 
        // YU = 01 :110
        // YU = 10 :10
        // YU = 11 :111
        if (pWMVDec->m_bDCPred_IMBInPFrame){
            I32_WMV ibYUV_IPred;
            ibYUV_IPred = BS_getBit (pWMVDec->m_pbitstrmIn);
            if (!ibYUV_IPred){
				// [V_BLOCK] = [U_BLOCK] = [Y_BLOCK1] = 0
                pmbmd->m_rgbDCTCoefPredPattern &= 0x9D;
            }
            else{
                ibYUV_IPred = BS_getBit (pWMVDec->m_pbitstrmIn);
                if (!ibYUV_IPred){
					// [Y_BLOCK1] = 1
					// [V_BLOCK] = [U_BLOCK] = 0
                    pmbmd->m_rgbDCTCoefPredPattern |= 0x02;
                    pmbmd->m_rgbDCTCoefPredPattern &= 0x9F;
                }
                else if (ibYUV_IPred = BS_getBit (pWMVDec->m_pbitstrmIn)){
					// [V_BLOCK] = [U_BLOCK] = [Y_BLOCK1] = 1
                    pmbmd->m_rgbDCTCoefPredPattern |= 0x62;

                }else{
					// [Y_BLOCK1] = 0
					// [V_BLOCK] = [U_BLOCK] = 1
                    pmbmd->m_rgbDCTCoefPredPattern &= 0xFD;
                    pmbmd->m_rgbDCTCoefPredPattern |= 0x60;
                }
            }

            pmbmd->m_rgbDCTCoefPredPattern &= 0xFB; // [Y_BLOCK2] = 0;
            pmbmd->m_rgbDCTCoefPredPattern |= 0x08; // [Y_BLOCK3] = 1;
        }
        


		if (BS_invalid ( pWMVDec->m_pbitstrmIn )) {
			return WMV_CorruptedBits;
		}
    }

    // 0 :  0
    // 1 : 10
    // 2 : 11
    pmbmd->m_iDCTTable_MB_Index = 0;
    if (pWMVDec->m_bDCTTable_MB && iCBPCY){
        I32_WMV iDCTMBTableIndex = BS_getBit (pWMVDec->m_pbitstrmIn);
        if (iDCTMBTableIndex)
            iDCTMBTableIndex += BS_getBit (pWMVDec->m_pbitstrmIn); 
        assert(iDCTMBTableIndex>=0 && iDCTMBTableIndex<=2);
        pmbmd->m_iDCTTable_MB_Index = iDCTMBTableIndex;
    }
    


    pmbmd->m_rgbCodedBlockPattern = (U8_WMV) iCBPCY; // iCBPC info is already in iCBPCY. 

    if (pWMVDec->m_bXformSwitch)
    {
        pmbmd->m_bBlkXformSwitchOn = FALSE_WMV;

        if (pWMVDec->m_bMBXformSwitching && !pmbmd->m_bCBPAllZero && pmbmd->m_dctMd == INTER)
        {
            if ( !(pmbmd->m_bBlkXformSwitchOn = BS_getBit (pWMVDec->m_pbitstrmIn)) )
            {
                // Block-based transform-switching must not be enabled for this MB so get the
                // transform-type that will be applied to all blocks in this MB
                if (BS_getBit (pWMVDec->m_pbitstrmIn) == 0)
                    pmbmd->m_iMBXformMode = XFORMMODE_8x8;
                else if (BS_getBit (pWMVDec->m_pbitstrmIn) == 0)
                    pmbmd->m_iMBXformMode = XFORMMODE_8x4;
                else
                    pmbmd->m_iMBXformMode = XFORMMODE_4x8;            
            }
        }
    }
    return WMV_Succeeded;
}

#define MVFLCSIZE 6
#define MV_ESCAPE 1099

inline I8_WMV medianof3 (I8_WMV a0, I8_WMV a1, I8_WMV a2)
{
	if (a0 > a1) {
		if (a1 > a2)
			return a1;
		else if (a0 > a2)
			return a2;
		else
			return a0;
	}
	else if (a0 > a2)
		return a0;
	else if (a1 > a2)
		return a2;
	else
		return a1;
}


Void_WMV find16x16MVpred (tWMVDecInternalMember *pWMVDec, CVector& vecPredHalfPel, const CVector* pmv, const CWMVMBMode* pmbmd, Bool_WMV bLeftBndry, Bool_WMV bRightBndry, Bool_WMV bTopBndry) 
{
	CVector vctCandMVHalfPel0, vctCandMVHalfPel1, vctCandMVHalfPel2;

	if (bLeftBndry)
		vctCandMVHalfPel0.x = vctCandMVHalfPel0.y = 0;
	else
		vctCandMVHalfPel0 = *(pmv - 1);

	if (bTopBndry) {
		vecPredHalfPel = vctCandMVHalfPel0;
		return;
	}
	else {
		vctCandMVHalfPel1 = *(pmv - pWMVDec->m_iOffsetToTopMB);
		if (bRightBndry)
			vctCandMVHalfPel2.x = vctCandMVHalfPel2.y = 0;
		else
			vctCandMVHalfPel2 = *(pmv - pWMVDec->m_iOffsetToTopMB + 1);
	}
	vecPredHalfPel.x = medianof3 (vctCandMVHalfPel0.x, vctCandMVHalfPel1.x, vctCandMVHalfPel2.x);
	vecPredHalfPel.y = medianof3 (vctCandMVHalfPel0.y, vctCandMVHalfPel1.y, vctCandMVHalfPel2.y);

    if (pmbmd->m_iMVPredDirection != 2) {
        vecPredHalfPel = (pmbmd->m_iMVPredDirection == 0)? vctCandMVHalfPel0 : vctCandMVHalfPel1;
    }
}


tWMVDecodeStatus decodeMVMSV (tWMVDecInternalMember *pWMVDec, CVector* pmv, const CWMVMBMode* pmbmd, Bool_WMV bLeftBndry, Bool_WMV bRightBndry, Bool_WMV bTopBndry, Huffman_WMV* pHufMVDec, U8_WMV* uXMvFromIndex, U8_WMV* uYMvFromIndex)
{
    CVector vctPred;
    I32_WMV lSymbolx, lSymboly, lJoinSymbol, iVLC;
	
    find16x16MVpred (pWMVDec, vctPred, pmv, pmbmd, bLeftBndry, bRightBndry, bTopBndry);
    lJoinSymbol = Huffman_WMV_get (pHufMVDec, pWMVDec->m_pbitstrmIn);
    if (BS_invalid ( pWMVDec->m_pbitstrmIn )) {
		return WMV_CorruptedBits;
	}

    if (lJoinSymbol != MV_ESCAPE){
        lSymbolx = uXMvFromIndex[lJoinSymbol];
        lSymboly = uYMvFromIndex[lJoinSymbol];
    }
    else{
        lSymbolx = BS_getBits (pWMVDec->m_pbitstrmIn, MVFLCSIZE);
        lSymboly = BS_getBits (pWMVDec->m_pbitstrmIn, MVFLCSIZE);
    }

	iVLC = lSymbolx - 32 + vctPred.x;
	if (iVLC > pWMVDec->m_iMVRightBound)
		pmv->x = iVLC - 64;
	else if (iVLC < pWMVDec->m_iMVLeftBound)
		pmv->x = iVLC + 64;
	else
		pmv->x = (I8_WMV) iVLC;

	iVLC = lSymboly - 32 + vctPred.y;
	if (iVLC > pWMVDec->m_iMVRightBound)
		pmv->y = iVLC - 64;
	else if (iVLC < pWMVDec->m_iMVLeftBound)
		pmv->y = iVLC + 64;
	else
		pmv->y = (I8_WMV) iVLC;

	pWMVDec->m_iMixedPelMV = 0;
	if (pWMVDec->m_iMvResolution == 1) {
		if ( ((pmv->x) & 1) != 0 || ((pmv->y) & 1) != 0) {
			pWMVDec->m_iMixedPelMV = BS_getBits (pWMVDec->m_pbitstrmIn, 1);
		} 
	}

	return WMV_Succeeded;
}


Bool_WMV decideHybridMVOn (tWMVDecInternalMember *pWMVDec, CoordI x, Bool_WMV bNot1stRowInSlice, const CVector* pmv)
{
    if (pWMVDec->m_bFrmHybridMVOn && x != 0 && bNot1stRowInSlice && !pWMVDec->m_iMvResolution) {
        CVector vctMvLeft = *(pmv - 1);
        CVector vctMvUp = *(pmv - pWMVDec->m_iOffsetToTopMB);
        I32_WMV iMaxDeltaMV = max(abs(vctMvLeft.x - vctMvUp.x), abs(vctMvLeft.y - vctMvUp.y));;
        return (iMaxDeltaMV >= VAR_FOR_HYBRID_MV);
    } else
        return FALSE_WMV;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\frmdec_wmv.cpp ===
#include "bldsetup.h"

#include "xplatform.h"
#include "wmvdec_api.h"
#include "wmvdec_member.h"
#include "wmvdec_function.h"
#include "constants_wmv.h"
#include "tables_wmv.h"
#include "strmdec_wmv.hpp"
#include "codehead.h"

// mingcl: don't delete these two.  These are for hacking the display of the video info in the player.
int g_iBitRate = 0;
int g_iFrameRate = 0;

Void_WMV WMVideoDecAssignMotionCompRoutines (tWMVDecInternalMember *pWMVDec)
{
    if (pWMVDec->m_iMvResolution == 1) {
        pWMVDec->m_pMotionComp = pWMVDec->m_pMotionCompMixed;
        pWMVDec->m_pMotionCompAndAddError = pWMVDec->m_pMotionCompMixedAndAddError;
    } else {
        if (pWMVDec->m_bRndCtrlOn){
            if (pWMVDec->m_iRndCtrl){
                pWMVDec->m_pMotionComp = pWMVDec->m_pMotionCompRndCtrlOn;
                pWMVDec->m_pMotionCompAndAddError = pWMVDec->m_pMotionCompAndAddErrorRndCtrlOn;
#ifdef _EMB_WMV2_
                pWMVDec->m_iMotionCompRndCtrl=VECTORIZE_MOTIONCOMP_RNDCTRL_ON;
#endif
            }
            else{
                pWMVDec->m_pMotionComp = pWMVDec->m_pMotionCompRndCtrlOff;
                pWMVDec->m_pMotionCompAndAddError = pWMVDec->m_pMotionCompAndAddErrorRndCtrlOff;
#ifdef _EMB_WMV2_
                
                pWMVDec->m_iMotionCompRndCtrl=VECTORIZE_MOTIONCOMP_RNDCTRL_OFF;
                
#endif
            }
#ifdef DYNAMIC_EDGEPAD
            pWMVDec->m_tEdgePad.m_iround_ctrl=pWMVDec->m_iMotionCompRndCtrl;
#endif
        }
    }

    if (pWMVDec->m_bRndCtrlOn){
        if (pWMVDec->m_iRndCtrl){
            pWMVDec->m_pMotionCompUV = pWMVDec->m_pMotionCompRndCtrlOn;
            pWMVDec->m_pMotionCompAndAddErrorUV = pWMVDec->m_pMotionCompAndAddErrorRndCtrlOn;
#ifdef _EMB_WMV2_
            
            pWMVDec->m_iMotionCompRndCtrl=VECTORIZE_MOTIONCOMP_RNDCTRL_ON;


            
#endif
        }
        else{
            pWMVDec->m_pMotionCompUV = pWMVDec->m_pMotionCompRndCtrlOff;
            pWMVDec->m_pMotionCompAndAddErrorUV = pWMVDec->m_pMotionCompAndAddErrorRndCtrlOff;
#ifdef _EMB_WMV2_
            
            pWMVDec->m_iMotionCompRndCtrl=VECTORIZE_MOTIONCOMP_RNDCTRL_OFF;
            
#endif
        }

#ifdef DYNAMIC_EDGEPAD
        pWMVDec->m_tEdgePad.m_iround_ctrl=pWMVDec->m_iMotionCompRndCtrl;
#endif
    }
}

Void_WMV WMVideoDecSwapCurrAndRef (tWMVDecInternalMember *pWMVDec)
{
    tYUV420Frame_WMV*  pTmp = pWMVDec->m_pfrmCurrQ;
    pWMVDec->m_pfrmCurrQ = pWMVDec->m_pfrmPrev;
    pWMVDec->m_pfrmPrev = pTmp;
    
    pWMVDec->m_ppxliRef0Y = pWMVDec->m_pfrmPrev->m_pucYPlane;
    pWMVDec->m_ppxliRef0U = pWMVDec->m_pfrmPrev->m_pucUPlane;
    pWMVDec->m_ppxliRef0V = pWMVDec->m_pfrmPrev->m_pucVPlane;
    pWMVDec->m_ppxliRef0YPlusExp = pWMVDec->m_ppxliRef0Y + pWMVDec->m_iWidthPrevYXExpPlusExp;

    pWMVDec->m_ppxliCurrQPlusExpY = (U8_WMV*) pWMVDec->m_pfrmCurrQ->m_pucYPlane + pWMVDec->m_iWidthPrevYXExpPlusExp;
    pWMVDec->m_ppxliCurrQPlusExpU = (U8_WMV*) pWMVDec->m_pfrmCurrQ->m_pucUPlane + pWMVDec->m_iWidthPrevUVXExpPlusExp;
    pWMVDec->m_ppxliCurrQPlusExpV = (U8_WMV*) pWMVDec->m_pfrmCurrQ->m_pucVPlane + pWMVDec->m_iWidthPrevUVXExpPlusExp;
}

#if DBG
extern DWORD g_TotalBits;

extern "C"
ULONG
_cdecl
DbgPrint(
    PCH Format,
    ...
    );

DWORD g_IFrameCount;

#endif

tWMVDecodeStatus WMVideoDecDecodeI (tWMVDecInternalMember *pWMVDec)
{
    FUNCTION_PROFILE_DECL_START(fp,DECODEI_PROFILE);
    tWMVDecodeStatus tWMVStatus;

    U8_WMV* ppxliCurrQY = pWMVDec->m_ppxliCurrQPlusExpY;
    U8_WMV* ppxliCurrQU = pWMVDec->m_ppxliCurrQPlusExpU;
    U8_WMV* ppxliCurrQV = pWMVDec->m_ppxliCurrQPlusExpV;

    CWMVMBMode* pmbmd = pWMVDec->m_rgmbmd;
    I16_WMV* piQuanCoefACPred = pWMVDec->m_rgiQuanCoefACPred;
    I16_WMV** piQuanCoefACPredTable= pWMVDec->m_rgiQuanCoefACPredTable;
    U32_WMV uiNumMBFromSliceBdry = pWMVDec->m_uintNumMBX + 1;
    U32_WMV imbY;
    
#if DBG
    g_IFrameCount++;
#endif DBG

    if (pWMVDec->m_cvCodecVersion == MP43 || pWMVDec->m_cvCodecVersion >= WMV1) {
        pWMVDec->m_pInterDCTTableInfo_Dec = pWMVDec->m_pInterDCTTableInfo_Dec_Set[pWMVDec->m_iDCTACInterTableIndx];
	    pWMVDec->m_pIntraDCTTableInfo_Dec = pWMVDec->m_pIntraDCTTableInfo_Dec_Set[pWMVDec->m_iDCTACIntraTableIndx];
        pWMVDec->m_pHufDCTDCyDec = pWMVDec->m_pHufDCTDCDec_Set[pWMVDec->m_iIntraDCTDCTable<<1];
        pWMVDec->m_pHufDCTDCcDec = pWMVDec->m_pHufDCTDCDec_Set[(pWMVDec->m_iIntraDCTDCTable<<1) + 1];
    }
    else{
        pWMVDec->m_pInterDCTTableInfo_Dec = pWMVDec->m_pInterDCTTableInfo_Dec_Set[2];
	    pWMVDec->m_pIntraDCTTableInfo_Dec = pWMVDec->m_pIntraDCTTableInfo_Dec_Set[2];
    }

    UpdateDCStepSize(pWMVDec, pWMVDec->m_iStepSize);

    HUFFMANGET_DBG_HEADER(":WMVideoDecDecodeI",1);

    for (imbY = 0; imbY < pWMVDec->m_uintNumMBY; imbY++) {
        U8_WMV* ppxliCodedY = ppxliCurrQY;
        U8_WMV* ppxliCodedU = ppxliCurrQU;
        U8_WMV* ppxliCodedV = ppxliCurrQV;
        Bool_WMV bNot1stRowInSlice;
        U32_WMV imbX;

        if (!(imbY & 0x01)){ 
            piQuanCoefACPred = pWMVDec->m_rgiQuanCoefACPred;
            piQuanCoefACPredTable= pWMVDec->m_rgiQuanCoefACPredTable;
        }
        if (pWMVDec->m_cvCodecVersion >= WMV1 || pWMVDec->m_cvCodecVersion == MP4S) // THREE or STANDARD
            bNot1stRowInSlice = (imbY != 0);
        else 
            bNot1stRowInSlice = (imbY % pWMVDec->m_uintNumMBYSlice != 0);

#ifdef _MPG4_
        pWMVDec->m_rgiDCRef [0] = pWMVDec->m_rgiDCRef [1] = pWMVDec->m_rgiDCRef [2] = 128;
#endif
        for (imbX = 0; imbX < pWMVDec->m_uintNumMBX; imbX++) {

#if DBG
            g_TotalBits = 0;
#endif DBG

#if DBG && 0

if (g_IFrameCount == 4 && imbX < 8 && imbY == 18)
{
    _asm int 3;
}

#endif DBG

            if(pWMVDec->m_cvCodecVersion == MP4S) {
                if(checkResyncMarker(pWMVDec)) {
                    decodeVideoPacketHeader(pWMVDec, pWMVDec->m_iStepSize);
                    uiNumMBFromSliceBdry = 0;
                }
            }

            uiNumMBFromSliceBdry++;
            tWMVStatus = (*pWMVDec->m_pDecodeMBOverheadOfIVOP) (pWMVDec, pmbmd, imbX, imbY);
            if (WMV_Succeeded != tWMVStatus) {
                FUNCTION_PROFILE_STOP(&fp);
                return tWMVStatus;
            }

            {
                Bool_WMV bLeft = (imbX != 0) && (uiNumMBFromSliceBdry > 1);
                Bool_WMV bTop = bNot1stRowInSlice && (uiNumMBFromSliceBdry > pWMVDec->m_uintNumMBX);
                Bool_WMV bLeftTop = (imbX != 0) && bNot1stRowInSlice && (uiNumMBFromSliceBdry > (pWMVDec->m_uintNumMBX+1));
                tWMVStatus = (*pWMVDec->m_pDecodeIMBAcPred) (
                    pWMVDec,
                    pmbmd,
                    ppxliCodedY,
                    ppxliCodedU,
                    ppxliCodedV, 
                    piQuanCoefACPred, 
                    piQuanCoefACPredTable, 
                    bLeft,
                    bTop,
                    bLeftTop);
            }
//              (imbX != 0), 
//              bNot1stRowInSlice,
//              (imbX != 0 && bNot1stRowInSlice));

#if DBG && 0

if (g_IFrameCount == 4 && imbX < 8 && imbY == 18)
{
    BYTE *pBlock;
    DWORD block;
    DWORD YPitch = pWMVDec->m_iWidthPrevY;
    DWORD UVPitch = pWMVDec->m_iWidthPrevUV;

    DWORD i, j;

    for (block = 0; block < 4; block++)
    {
        pBlock = ppxliCodedY + BLOCK_SIZE * (block & 1) + BLOCK_SIZE * YPitch * (block >> 1);

        DbgPrint("----- Y block # %d for Macroblock %d-%d\n\n", block, imbX, imbY);

        for (j = 0; j < BLOCK_SIZE; j++)
        {
            for (i = 0; i < BLOCK_SIZE; i++)
            {
                DbgPrint("%02X ", *(pBlock + i + j * YPitch));
            }

            DbgPrint("\n");
        }

        DbgPrint("\n");
    }

    DbgPrint("----- U block for Macroblock %d-%d\n\n", imbX, imbY);

    for (j = 0; j < BLOCK_SIZE; j++)
    {
        for (i = 0; i < BLOCK_SIZE; i++)
        {
            DbgPrint("%02X ", *(ppxliCodedU + i + j * UVPitch));
        }

        DbgPrint("\n");
    }

    DbgPrint("\n");

    DbgPrint("----- V block for Macroblock %d-%d\n\n", imbX, imbY);

    for (j = 0; j < BLOCK_SIZE; j++)
    {
        for (i = 0; i < BLOCK_SIZE; i++)
        {
            DbgPrint("%02X ", *(ppxliCodedV + i + j * UVPitch));
        }

        DbgPrint("\n");
    }

    DbgPrint("\n");
}

#endif DBG


            if (WMV_Succeeded != tWMVStatus) {
                FUNCTION_PROFILE_STOP(&fp);
                return tWMVStatus;
            }
            ppxliCodedY += MB_SIZE;
            ppxliCodedU += BLOCK_SIZE;
            ppxliCodedV += BLOCK_SIZE;
            pmbmd++;
            piQuanCoefACPred += BLOCK_SIZE_TIMES2_TIMES6;
            piQuanCoefACPredTable += 36;
        }

        ppxliCurrQY += pWMVDec->m_iMBSizeXWidthPrevY; // point to the starting location of the first MB of each row
        ppxliCurrQU += pWMVDec->m_iBlkSizeXWidthPrevUV; // point to the starting location of the first MB of each row
        ppxliCurrQV += pWMVDec->m_iBlkSizeXWidthPrevUV; // point to the starting location of the first MB of each row
    }
    
    // Loop filter is mandatory
    if (pWMVDec->m_bLoopFilter)
#ifdef _MultiThread_Decode_ 
        DecodeMultiThreads (LOOPFILTER);
#else

#       ifndef COMBINE_LOOPFILTER_RENDERING
        DeblockSLFrame (pWMVDec, pWMVDec->m_ppxliCurrQPlusExpY, 
                         		    pWMVDec->m_ppxliCurrQPlusExpU,
                          		    pWMVDec->m_ppxliCurrQPlusExpV, 
                          		    FALSE, 0, 1, pWMVDec->m_uintNumMBX, 1, pWMVDec->m_uintNumMBY);
#       endif //COMBINE_LOOPFILTER_RENDERING
#endif

    // render
    if (!pWMVDec->m_bLoopFilter)
        memset (pWMVDec->m_rgchSkipPrevFrame, 0, (size_t) pWMVDec->m_uintNumMB);

    FUNCTION_PROFILE_STOP(&fp);
    return WMV_Succeeded;
}

//***************************************************************************************************
tWMVDecodeStatus WMVideoDecDecodeP (tWMVDecInternalMember *pWMVDec)
{
    FUNCTION_PROFILE(fpDecP[2]);
    tWMVDecodeStatus tWMVStatus;

    U8_WMV* ppxliCurrQY = pWMVDec->m_ppxliCurrQPlusExpY;
    U8_WMV* ppxliCurrQU = pWMVDec->m_ppxliCurrQPlusExpU;
    U8_WMV* ppxliCurrQV = pWMVDec->m_ppxliCurrQPlusExpV;

    U8_WMV* ppxliRefY = pWMVDec->m_ppxliRef0YPlusExp; //pWMVDec->m_ppxliRef0Y + pWMVDec->m_iWidthPrevYXExpPlusExp;
    U8_WMV* ppxliRefU = pWMVDec->m_ppxliRef0U + pWMVDec->m_iWidthPrevUVXExpPlusExp;
    U8_WMV* ppxliRefV = pWMVDec->m_ppxliRef0V + pWMVDec->m_iWidthPrevUVXExpPlusExp;

    U8_WMV* rgchSkipPrevFrame = pWMVDec->m_rgchSkipPrevFrame;

    CWMVMBMode* pmbmd = pWMVDec->m_rgmbmd;

    CVector* pmv = pWMVDec->m_rgmv;

    FUNCTION_PROFILE_START(&fpDecP[1],DECODEP_PROFILE);
    pWMVDec->m_iOffsetToTopMB = pWMVDec->m_uintNumMBX;
    CoordI x, y; // mvXUV, mvYUV; // mvXUV and mvYUV are zoomed UV MV
    U32_WMV imbx, imbY;
    I16_WMV* piQuanCoefACPred = pWMVDec->m_rgiQuanCoefACPred;
    I16_WMV** piQuanCoefACPredTable = pWMVDec->m_rgiQuanCoefACPredTable;
    U32_WMV uiNumMBFromSliceBdry = pWMVDec->m_uintNumMBX + 1;

    if (pWMVDec->m_cvCodecVersion == MP43 || pWMVDec->m_cvCodecVersion >= WMV1) {
        pWMVDec->m_pInterDCTTableInfo_Dec = pWMVDec->m_pInterDCTTableInfo_Dec_Set[pWMVDec->m_iDCTACInterTableIndx];

	    pWMVDec->m_pIntraDCTTableInfo_Dec = pWMVDec->m_pIntraDCTTableInfo_Dec_Set[pWMVDec->m_iDCTACInterTableIndx];
        pWMVDec->m_pHufDCTDCyDec = pWMVDec->m_pHufDCTDCDec_Set[pWMVDec->m_iIntraDCTDCTable<<1];
        pWMVDec->m_pHufDCTDCcDec = pWMVDec->m_pHufDCTDCDec_Set[(pWMVDec->m_iIntraDCTDCTable<<1) + 1];


	    pWMVDec->m_pHufMVDec = pWMVDec->m_pHufMVDec_Set[pWMVDec->m_iMVTable];
	    pWMVDec->m_puXMvFromIndex = pWMVDec->m_puMvFromIndex_Set[pWMVDec->m_iMVTable<<1];
	    pWMVDec->m_puYMvFromIndex = pWMVDec->m_puMvFromIndex_Set[(pWMVDec->m_iMVTable<<1) + 1];
        HUFFMANGET_DBG_HEADER(":WMVideoDecDecodeP",5);

    }
    else{
        pWMVDec->m_pInterDCTTableInfo_Dec = pWMVDec->m_pInterDCTTableInfo_Dec_Set[2];

	    pWMVDec->m_pIntraDCTTableInfo_Dec = pWMVDec->m_pIntraDCTTableInfo_Dec_Set[2];
    }

    // update all stepsize
    UpdateDCStepSize(pWMVDec, pWMVDec->m_iStepSize);
    pWMVDec->m_i2DoublePlusStepSize = pWMVDec->m_iDoubleStepSize + pWMVDec->m_iStepMinusStepIsEven;
    pWMVDec->m_i2DoublePlusStepSizeNeg = -1 * pWMVDec->m_i2DoublePlusStepSize;


#ifdef _EMB_WMV2_
    InitEMB_DecodePShortcut(pWMVDec);
#endif

#ifdef DYNAMIC_EDGEPAD
    edgePadSetup(pWMVDec, &pWMVDec->m_tEdgePad);
#endif

    for (imbY = 0, y = 0; imbY < pWMVDec->m_uintNumMBY; imbY++, y += MB_SIZE) {
        U8_WMV* ppxliCurrQYMB = ppxliCurrQY;
        U8_WMV* ppxliCurrQUMB = ppxliCurrQU;
        U8_WMV* ppxliCurrQVMB = ppxliCurrQV;
        U8_WMV* ppxliRefYMB = ppxliRefY;
        U8_WMV* ppxliRefUMB = ppxliRefU;
        U8_WMV* ppxliRefVMB = ppxliRefV;
        Bool_WMV bNot1stRowInPict = (imbY != 0);
        Bool_WMV bNot1stRowInSlice = (imbY % pWMVDec->m_uintNumMBYSlice != 0);

        pWMVDec->m_iOffsetToTopMB = -pWMVDec->m_iOffsetToTopMB;
        if (!(imbY & 0x01)){ 
            piQuanCoefACPred = pWMVDec->m_rgiQuanCoefACPred;
            piQuanCoefACPredTable= pWMVDec->m_rgiQuanCoefACPredTable;
            pmv = pWMVDec->m_rgmv;
        }

        if (pWMVDec->m_cvCodecVersion == MP4S && imbY) 
            bNot1stRowInSlice = TRUE_WMV;

#ifdef _MPG4_
        pWMVDec->m_rgiDCRef [0] = pWMVDec->m_rgiDCRef [1] = pWMVDec->m_rgiDCRef [2] = 128;
#endif
        for (x = 0, imbx = 0; imbx < pWMVDec->m_uintNumMBX; imbx++, x += MB_SIZE) {
            if (pWMVDec->m_cvCodecVersion == MP4S) {
                if (checkResyncMarker(pWMVDec)) {
                    decodeVideoPacketHeader(pWMVDec, pWMVDec->m_iStepSize);
                    uiNumMBFromSliceBdry = 0;
                }
            }
            uiNumMBFromSliceBdry ++;
//#ifdef _HYBRID_MV_
            pWMVDec->m_bMBHybridMV = decideHybridMVOn (pWMVDec, x, bNot1stRowInSlice, pmv);
//#endif
            tWMVStatus = (*pWMVDec->m_pDecodeMBOverheadOfPVOP) (pWMVDec, pmbmd);
            if (WMV_Succeeded != tWMVStatus) {
                FUNCTION_PROFILE_STOP(&fpDecP[1]);
                return tWMVStatus;
            }

            if (pmbmd->m_bSkip) {
SKIP_MB:
                pmv->x = pmv->y = 0;

                if (pWMVDec->m_bLoopFilter || *rgchSkipPrevFrame == 0) { // MB in the previous frame is not skipped
                    FUNCTION_PROFILE_START(&fpDecP[0],DECODEMBSKIP_PROFILE);
                    (*pWMVDec->m_pMotionCompZero) (
                        ppxliCurrQYMB, ppxliCurrQUMB, ppxliCurrQVMB,
                        ppxliRefYMB, ppxliRefUMB, ppxliRefVMB,
						pWMVDec->m_iWidthPrevY, pWMVDec->m_iWidthPrevUV);
                    FUNCTION_PROFILE_STOP(&fpDecP[0]);
                }
                *rgchSkipPrevFrame = 1;
                goto NEXT_MB;
            }
            // no skip
            *rgchSkipPrevFrame = 0;
            if (pmbmd->m_dctMd == INTER) {
                FUNCTION_PROFILE_START(&fpDecP[0],DECODEMBMOTION_PROFILE);

                if (pWMVDec->m_cvCodecVersion >= WMV1 || pWMVDec->m_cvCodecVersion == MP43) 
                    //result = decodeMV (pmv, imbx == 0, imbx == pWMVDec->m_uiRightestMB, !bNot1stRowInSlice);
                    tWMVStatus = decodeMVMSV (pWMVDec, pmv, pmbmd, imbx == 0, imbx == pWMVDec->m_uiRightestMB, !bNot1stRowInSlice, pWMVDec->m_pHufMVDec, pWMVDec->m_puXMvFromIndex, pWMVDec->m_puYMvFromIndex);
                else if (pWMVDec->m_cvCodecVersion == MP42 || pWMVDec->m_cvCodecVersion == MPG4)
                    tWMVStatus = decodeMV (pWMVDec, pmv, pmbmd, imbx == 0, imbx == pWMVDec->m_uiRightestMB, !bNot1stRowInSlice);
                else if (pWMVDec->m_cvCodecVersion == MP4S)
                    tWMVStatus = decodeMV (pWMVDec, pmv, pmbmd, imbx == 0 || uiNumMBFromSliceBdry==1 , imbx == pWMVDec->m_uiRightestMB, (!bNot1stRowInSlice) || uiNumMBFromSliceBdry < (pWMVDec->m_uintNumMBX + 1));
                if (WMV_Succeeded != tWMVStatus) {
                    FUNCTION_PROFILE_STOP(&fpDecP[0]);
                    FUNCTION_PROFILE_STOP(&fpDecP[1]);
                    return tWMVStatus;
                }
                pmbmd->m_bZeroMV = (pmv->x == 0 && pmv->y == 0);
                // no COD, so skip is decided by MV and CBP
                if (pmbmd->m_bCBPAllZero && pmbmd->m_bZeroMV) {
                    pmbmd->m_bSkip = TRUE_WMV;
                    FUNCTION_PROFILE_STOP(&fpDecP[0]);
                    goto SKIP_MB;
                }
                I32_WMV iMV_X = x * 2 + pmv->x;
                I32_WMV iMV_Y = y * 2 + pmv->y;
                I32_WMV iMV_X_UV = x + gmvUVtable4 [pmv->x];
                I32_WMV iMV_Y_UV = y + gmvUVtable4 [pmv->y];


                tWMVStatus = (*pWMVDec->m_pDecodePMB) (
                    pWMVDec, 
                    pmbmd,
                    ppxliCurrQYMB, 
                    ppxliCurrQUMB,
                    ppxliCurrQVMB, 
                    iMV_X, // Y MV 
                    iMV_Y,
                    iMV_X_UV, 
                    iMV_Y_UV);
                FUNCTION_PROFILE_STOP(&fpDecP[0]);
                if (WMV_Succeeded != tWMVStatus) {
                    FUNCTION_PROFILE_STOP(&fpDecP[1]);
                    return tWMVStatus;
                }
            }
            else {
                Bool_WMV bLeft, bTop, bLeftTop; 
                FUNCTION_PROFILE_START(&fpDecP[0],DECODEIMBINPFRAME_PROFILE);
                pmv->x = pmv->y = 0;                
                if (pWMVDec->m_cvCodecVersion >= WMV1){ 
                    bLeft = (imbx != 0);
                    bTop = bNot1stRowInPict;
                    bLeftTop = (imbx !=0 ) && bNot1stRowInPict;
                    if (pWMVDec->m_bDCPred_IMBInPFrame)
                        tWMVStatus = DecodeIMBAcPred_PFrame (
                            pWMVDec, 
                            pmbmd,
                            ppxliCurrQYMB,
                            ppxliCurrQUMB,
                            ppxliCurrQVMB,
                            piQuanCoefACPred, 
                            piQuanCoefACPredTable, 
                            bLeft,
                            bTop,
                            bLeftTop);
                    else
                        tWMVStatus = DecodeIMBAcPred (
                            pWMVDec, 
                            pmbmd,
                            ppxliCurrQYMB,
                            ppxliCurrQUMB,
                            ppxliCurrQVMB,
                            piQuanCoefACPred, 
                            piQuanCoefACPredTable, 
                            bLeft && ((pmbmd - 1)->m_dctMd == INTRA),
                            bTop && ((pmbmd - pWMVDec->m_uintNumMBX)->m_dctMd == INTRA),
                            bLeftTop && ((pmbmd - pWMVDec->m_uintNumMBX - 1)->m_dctMd == INTRA)
                            );
                }
                else{
                    bLeft = (imbx != 0) && ((pmbmd - 1)->m_dctMd == INTRA) &&
                        (uiNumMBFromSliceBdry > 1);
                    bTop = bNot1stRowInSlice && ((pmbmd - pWMVDec->m_uintNumMBX)->m_dctMd == INTRA)  &&
                        (uiNumMBFromSliceBdry > pWMVDec->m_uintNumMBX);
                    bLeftTop = (imbx!=0 ) && bNot1stRowInSlice && ((pmbmd - pWMVDec->m_uintNumMBX - 1)->m_dctMd == INTRA)  &&
                        (uiNumMBFromSliceBdry > (pWMVDec->m_uintNumMBX+1));
                    tWMVStatus = DecodeIMBAcPred_MP4X (
                        pWMVDec, 
                        pmbmd,
                        ppxliCurrQYMB,
                        ppxliCurrQUMB,
                        ppxliCurrQVMB,
                        piQuanCoefACPred, 
                        piQuanCoefACPredTable, 
                        bLeft,
                        bTop,
                        bLeftTop);
                }

                FUNCTION_PROFILE_STOP(&fpDecP[0]);
                if (WMV_Succeeded != tWMVStatus) {
                    FUNCTION_PROFILE_STOP(&fpDecP[1]);
                    return tWMVStatus;
                }
            }
NEXT_MB:
            if (pmbmd->m_dctMd == INTER) {
                piQuanCoefACPred[0] = piQuanCoefACPred[BLOCK_SIZE_TIMES2_TIMES4] =piQuanCoefACPred[BLOCK_SIZE_TIMES2_TIMES5] = 0;
            }
            rgchSkipPrevFrame++;
            pmbmd++;
            pmv++;
            ppxliCurrQYMB += MB_SIZE;
            ppxliCurrQUMB += BLOCK_SIZE;
            ppxliCurrQVMB += BLOCK_SIZE;
            ppxliRefYMB += MB_SIZE;
            ppxliRefUMB += BLOCK_SIZE;
            ppxliRefVMB += BLOCK_SIZE;
            piQuanCoefACPred += BLOCK_SIZE_TIMES2_TIMES6;
            piQuanCoefACPredTable += 36;
        }



        ppxliCurrQY += pWMVDec->m_iMBSizeXWidthPrevY; // point to the starting location of the first MB of each row
        ppxliCurrQU += pWMVDec->m_iBlkSizeXWidthPrevUV; // point to the starting location of the first MB of each row
        ppxliCurrQV += pWMVDec->m_iBlkSizeXWidthPrevUV; // point to the starting location of the first MB of each row
        ppxliRefY += pWMVDec->m_iMBSizeXWidthPrevY; // point to the starting location of the first MB of each row
        ppxliRefU += pWMVDec->m_iBlkSizeXWidthPrevUV; // point to the starting location of the first MB of each row
        ppxliRefV += pWMVDec->m_iBlkSizeXWidthPrevUV; // point to the starting location of the first MB of each row
    }

#ifndef COMBINE_LOOPFILTER_RENDERING
    if (pWMVDec->m_bLoopFilter)
#ifdef _MultiThread_Decode_ 
        DecodeMultiThreads (LOOPFILTER);
#else

        DeblockSLFrame (pWMVDec, pWMVDec->m_ppxliCurrQPlusExpY, 
                     		        pWMVDec->m_ppxliCurrQPlusExpU,
                      		        pWMVDec->m_ppxliCurrQPlusExpV, 
                      		        FALSE, 0, 1, pWMVDec->m_uintNumMBX, 1, pWMVDec->m_uintNumMBY);
#endif
#endif
    FUNCTION_PROFILE_STOP(&fpDecP[1]);
    return WMV_Succeeded;
}

#ifdef _SUPPORT_POST_FILTERS_
tWMVDecodeStatus WMVideoDecDecodeIDeblock (tWMVDecInternalMember *pWMVDec)
{
    FUNCTION_PROFILE_DECL_START(fp,DECODEI_PROFILE);
    tWMVDecodeStatus tWMVStatus;

    U8_WMV* ppxliCurrQY = pWMVDec->m_ppxliCurrQPlusExpY;
    U8_WMV* ppxliCurrQU = pWMVDec->m_ppxliCurrQPlusExpU;
    U8_WMV* ppxliCurrQV = pWMVDec->m_ppxliCurrQPlusExpV;
    U8_WMV* ppxliPostQY = pWMVDec->m_ppxliPostQPlusExpY;
    U8_WMV* ppxliPostQU = pWMVDec->m_ppxliPostQPlusExpU;
    U8_WMV* ppxliPostQV = pWMVDec->m_ppxliPostQPlusExpV;

    CWMVMBMode* pmbmd = pWMVDec->m_rgmbmd;
    I16_WMV* piQuanCoefACPred = pWMVDec->m_rgiQuanCoefACPred;
    I16_WMV** piQuanCoefACPredTable= pWMVDec->m_rgiQuanCoefACPredTable;
    U32_WMV uiNumMBFromSliceBdry = pWMVDec->m_uintNumMBX + 1;
    U32_WMV imbY;
    
    if (pWMVDec->m_cvCodecVersion == MP43 || pWMVDec->m_cvCodecVersion >= WMV1) {
        pWMVDec->m_pInterDCTTableInfo_Dec = pWMVDec->m_pInterDCTTableInfo_Dec_Set[pWMVDec->m_iDCTACInterTableIndx];
	    pWMVDec->m_pIntraDCTTableInfo_Dec = pWMVDec->m_pIntraDCTTableInfo_Dec_Set[pWMVDec->m_iDCTACIntraTableIndx];
        pWMVDec->m_pHufDCTDCyDec = pWMVDec->m_pHufDCTDCDec_Set[pWMVDec->m_iIntraDCTDCTable<<1];
        pWMVDec->m_pHufDCTDCcDec = pWMVDec->m_pHufDCTDCDec_Set[(pWMVDec->m_iIntraDCTDCTable<<1) + 1];
    }
    else{
        pWMVDec->m_pInterDCTTableInfo_Dec = pWMVDec->m_pInterDCTTableInfo_Dec_Set[2];
	    pWMVDec->m_pIntraDCTTableInfo_Dec = pWMVDec->m_pIntraDCTTableInfo_Dec_Set[2];
    }

    UpdateDCStepSize(pWMVDec, pWMVDec->m_iStepSize);

    HUFFMANGET_DBG_HEADER(":WMVideoDecDecodeI",1);

    for (imbY = 0; imbY < pWMVDec->m_uintNumMBY; imbY++) {
        U8_WMV* ppxliCodedY = ppxliCurrQY;
        U8_WMV* ppxliCodedU = ppxliCurrQU;
        U8_WMV* ppxliCodedV = ppxliCurrQV;
        Bool_WMV bNot1stRowInSlice;
        U32_WMV imbX;

        if (!(imbY & 0x01)){ 
            piQuanCoefACPred = pWMVDec->m_rgiQuanCoefACPred;
            piQuanCoefACPredTable= pWMVDec->m_rgiQuanCoefACPredTable;
        }
        if (pWMVDec->m_cvCodecVersion >= WMV1 || pWMVDec->m_cvCodecVersion == MP4S) // THREE or STANDARD
            bNot1stRowInSlice = (imbY != 0);
        else 
            bNot1stRowInSlice = (imbY % pWMVDec->m_uintNumMBYSlice != 0);

#ifdef _MPG4_
        pWMVDec->m_rgiDCRef [0] = pWMVDec->m_rgiDCRef [1] = pWMVDec->m_rgiDCRef [2] = 128;
#endif
        for (imbX = 0; imbX < pWMVDec->m_uintNumMBX; imbX++) {
            if(pWMVDec->m_cvCodecVersion == MP4S) {
                if(checkResyncMarker(pWMVDec)) {
                    decodeVideoPacketHeader(pWMVDec, pWMVDec->m_iStepSize);
                    uiNumMBFromSliceBdry = 0;
                }
            }

            uiNumMBFromSliceBdry++;
            tWMVStatus = (*pWMVDec->m_pDecodeMBOverheadOfIVOP) (pWMVDec, pmbmd, imbX, imbY);
            if (WMV_Succeeded != tWMVStatus) {
                FUNCTION_PROFILE_STOP(&fp);
                return tWMVStatus;
            }

            {
                Bool_WMV bLeft = (imbX != 0) && (uiNumMBFromSliceBdry > 1);
                Bool_WMV bTop = bNot1stRowInSlice && (uiNumMBFromSliceBdry > pWMVDec->m_uintNumMBX);
                Bfool_WMV bLeftTop = (imbX != 0) && bNot1stRowInSlice && (uiNumMBFromSliceBdry > (pWMVDec->m_uintNumMBX+1));
                tWMVStatus = (*pWMVDec->m_pDecodeIMBAcPred) (
                    pWMVDec,
                    pmbmd,
                    ppxliCodedY,
                    ppxliCodedU,
                    ppxliCodedV, 
                    piQuanCoefACPred, 
                    piQuanCoefACPredTable, 
                    bLeft,
                    bTop,
                    bLeftTop);
            }
//              (imbX != 0), 
//              bNot1stRowInSlice,
//              (imbX != 0 && bNot1stRowInSlice));

            if (WMV_Succeeded != tWMVStatus) {
                FUNCTION_PROFILE_STOP(&fp);
                return tWMVStatus;
            }
            ppxliCodedY += MB_SIZE;
            ppxliCodedU += BLOCK_SIZE;
            ppxliCodedV += BLOCK_SIZE;
            pmbmd++;
            piQuanCoefACPred += BLOCK_SIZE_TIMES2_TIMES6;
            piQuanCoefACPredTable += 36;
        }

        ppxliCurrQY += pWMVDec->m_iMBSizeXWidthPrevY; // point to the starting location of the first MB of each row
        ppxliCurrQU += pWMVDec->m_iBlkSizeXWidthPrevUV; // point to the starting location of the first MB of each row
        ppxliCurrQV += pWMVDec->m_iBlkSizeXWidthPrevUV; // point to the starting location of the first MB of each row
    }
    
    // Loop filter is mandatory
    if (pWMVDec->m_bLoopFilter)
#ifdef _MultiThread_Decode_ 
        DecodeMultiThreads (LOOPFILTER);
#else
        DeblockSLFrame (pWMVDec, pWMVDec->m_ppxliCurrQPlusExpY, 
                         		    pWMVDec->m_ppxliCurrQPlusExpU,
                          		    pWMVDec->m_ppxliCurrQPlusExpV, 
                          		    FALSE, 0, 1, pWMVDec->m_uintNumMBX, 1, pWMVDec->m_uintNumMBY);
#endif

    // Post-processing
    ppxliCurrQY = pWMVDec->m_ppxliCurrQPlusExpY;
    ppxliCurrQU = pWMVDec->m_ppxliCurrQPlusExpU;
    ppxliCurrQV = pWMVDec->m_ppxliCurrQPlusExpV; 
    ppxliPostQY = pWMVDec->m_ppxliPostQPlusExpY;
    ppxliPostQU = pWMVDec->m_ppxliPostQPlusExpU;
    ppxliPostQV = pWMVDec->m_ppxliPostQPlusExpV;
	for (I32_WMV i = 0; i < pWMVDec->m_iHeightUV; i++) {
        memcpy(ppxliPostQU, ppxliCurrQU, pWMVDec->m_iWidthPrevUV * sizeof(PixelC));
        ppxliPostQU += pWMVDec->m_iWidthPrevUV;
        ppxliCurrQU += pWMVDec->m_iWidthPrevUV;
        memcpy(ppxliPostQV, ppxliCurrQV, pWMVDec->m_iWidthPrevUV * sizeof(PixelC));
        ppxliPostQV += pWMVDec->m_iWidthPrevUV;
        ppxliCurrQV += pWMVDec->m_iWidthPrevUV;
        memcpy(ppxliPostQY, ppxliCurrQY, pWMVDec->m_iWidthPrevY * sizeof(PixelC));
        ppxliPostQY += pWMVDec->m_iWidthPrevY;
        ppxliCurrQY += pWMVDec->m_iWidthPrevY;
        memcpy(ppxliPostQY, ppxliCurrQY, pWMVDec->m_iWidthPrevY * sizeof(PixelC));
        ppxliPostQY += pWMVDec->m_iWidthPrevY;
        ppxliCurrQY += pWMVDec->m_iWidthPrevY;
    }
    DeblockIFrame (pWMVDec, 
                    pWMVDec->m_ppxliPostQPlusExpY,
                    pWMVDec->m_ppxliPostQPlusExpU,
                    pWMVDec->m_ppxliPostQPlusExpV,
                    0, pWMVDec->m_uintNumMBY);

    // render
    if (!pWMVDec->m_bLoopFilter)
        memset (pWMVDec->m_rgchSkipPrevFrame, 0, (size_t) pWMVDec->m_uintNumMB);

    FUNCTION_PROFILE_STOP(&fp);
    return WMV_Succeeded;
}

tWMVDecodeStatus WMVideoDecDecodePDeblock (tWMVDecInternalMember *pWMVDec)
{
    FUNCTION_PROFILE(fpDecP[2]);
    tWMVDecodeStatus tWMVStatus;

    U8_WMV* ppxliCurrQY = pWMVDec->m_ppxliCurrQPlusExpY;
    U8_WMV* ppxliCurrQU = pWMVDec->m_ppxliCurrQPlusExpU;
    U8_WMV* ppxliCurrQV = pWMVDec->m_ppxliCurrQPlusExpV;

    U8_WMV* ppxliRefY = pWMVDec->m_ppxliRef0YPlusExp; //pWMVDec->m_ppxliRef0Y + pWMVDec->m_iWidthPrevYXExpPlusExp;
    U8_WMV* ppxliRefU = pWMVDec->m_ppxliRef0U + pWMVDec->m_iWidthPrevUVXExpPlusExp;
    U8_WMV* ppxliRefV = pWMVDec->m_ppxliRef0V + pWMVDec->m_iWidthPrevUVXExpPlusExp;
    
    U8_WMV* ppxliPostQY = pWMVDec->m_ppxliPostQPlusExpY;
    U8_WMV* ppxliPostQU = pWMVDec->m_ppxliPostQPlusExpU;
    U8_WMV* ppxliPostQV = pWMVDec->m_ppxliPostQPlusExpV;

    U8_WMV* rgchSkipPrevFrame = pWMVDec->m_rgchSkipPrevFrame;

    CWMVMBMode* pmbmd = pWMVDec->m_rgmbmd;

    CVector* pmv = pWMVDec->m_rgmv;

    FUNCTION_PROFILE_START(&fpDecP[1],DECODEP_PROFILE);
    pWMVDec->m_iOffsetToTopMB = pWMVDec->m_uintNumMBX;
    CoordI x, y; // mvXUV, mvYUV; // mvXUV and mvYUV are zoomed UV MV
    U32_WMV imbx, imbY;
    I16_WMV* piQuanCoefACPred = pWMVDec->m_rgiQuanCoefACPred;
    I16_WMV** piQuanCoefACPredTable = pWMVDec->m_rgiQuanCoefACPredTable;
    U32_WMV uiNumMBFromSliceBdry = pWMVDec->m_uintNumMBX + 1;

    if (pWMVDec->m_cvCodecVersion == MP43 || pWMVDec->m_cvCodecVersion >= WMV1) {
        pWMVDec->m_pInterDCTTableInfo_Dec = pWMVDec->m_pInterDCTTableInfo_Dec_Set[pWMVDec->m_iDCTACInterTableIndx];

	    pWMVDec->m_pIntraDCTTableInfo_Dec = pWMVDec->m_pIntraDCTTableInfo_Dec_Set[pWMVDec->m_iDCTACInterTableIndx];
        pWMVDec->m_pHufDCTDCyDec = pWMVDec->m_pHufDCTDCDec_Set[pWMVDec->m_iIntraDCTDCTable<<1];
        pWMVDec->m_pHufDCTDCcDec = pWMVDec->m_pHufDCTDCDec_Set[(pWMVDec->m_iIntraDCTDCTable<<1) + 1];


	    pWMVDec->m_pHufMVDec = pWMVDec->m_pHufMVDec_Set[pWMVDec->m_iMVTable];
	    pWMVDec->m_puXMvFromIndex = pWMVDec->m_puMvFromIndex_Set[pWMVDec->m_iMVTable<<1];
	    pWMVDec->m_puYMvFromIndex = pWMVDec->m_puMvFromIndex_Set[(pWMVDec->m_iMVTable<<1) + 1];
        HUFFMANGET_DBG_HEADER(":WMVideoDecDecodeP",5);

    }
    else{
        pWMVDec->m_pInterDCTTableInfo_Dec = pWMVDec->m_pInterDCTTableInfo_Dec_Set[2];

	    pWMVDec->m_pIntraDCTTableInfo_Dec = pWMVDec->m_pIntraDCTTableInfo_Dec_Set[2];
    }

    // update all stepsize
    UpdateDCStepSize(pWMVDec, pWMVDec->m_iStepSize);
    pWMVDec->m_i2DoublePlusStepSize = pWMVDec->m_iDoubleStepSize + pWMVDec->m_iStepMinusStepIsEven;
    pWMVDec->m_i2DoublePlusStepSizeNeg = -1 * pWMVDec->m_i2DoublePlusStepSize;


#ifdef _EMB_WMV2_
    InitEMB_DecodePShortcut(pWMVDec);
#endif

#ifdef DYNAMIC_EDGEPAD
    edgePadSetup(pWMVDec, &pWMVDec->m_tEdgePad);
#endif

    for (imbY = 0, y = 0; imbY < pWMVDec->m_uintNumMBY; imbY++, y += MB_SIZE) {
        U8_WMV* ppxliCurrQYMB = ppxliCurrQY;
        U8_WMV* ppxliCurrQUMB = ppxliCurrQU;
        U8_WMV* ppxliCurrQVMB = ppxliCurrQV;
        U8_WMV* ppxliRefYMB = ppxliRefY;
        U8_WMV* ppxliRefUMB = ppxliRefU;
        U8_WMV* ppxliRefVMB = ppxliRefV;
        Bool_WMV bNot1stRowInPict = (imbY != 0);
        Bool_WMV bNot1stRowInSlice = (imbY % pWMVDec->m_uintNumMBYSlice != 0);

        pWMVDec->m_iOffsetToTopMB = -pWMVDec->m_iOffsetToTopMB;
        if (!(imbY & 0x01)){ 
            piQuanCoefACPred = pWMVDec->m_rgiQuanCoefACPred;
            piQuanCoefACPredTable= pWMVDec->m_rgiQuanCoefACPredTable;
            pmv = pWMVDec->m_rgmv;
        }

        if (pWMVDec->m_cvCodecVersion == MP4S && imbY) 
            bNot1stRowInSlice = TRUE_WMV;

#ifdef _MPG4_
        pWMVDec->m_rgiDCRef [0] = pWMVDec->m_rgiDCRef [1] = pWMVDec->m_rgiDCRef [2] = 128;
#endif
        for (x = 0, imbx = 0; imbx < pWMVDec->m_uintNumMBX; imbx++, x += MB_SIZE) {
            if (pWMVDec->m_cvCodecVersion == MP4S) {
                if (checkResyncMarker(pWMVDec)) {
                    decodeVideoPacketHeader(pWMVDec, pWMVDec->m_iStepSize);
                    uiNumMBFromSliceBdry = 0;
                }
            }
            uiNumMBFromSliceBdry ++;
//#ifdef _HYBRID_MV_
            pWMVDec->m_bMBHybridMV = decideHybridMVOn (pWMVDec, x, bNot1stRowInSlice, pmv);
//#endif
            tWMVStatus = (*pWMVDec->m_pDecodeMBOverheadOfPVOP) (pWMVDec, pmbmd);
            if (WMV_Succeeded != tWMVStatus) {
                FUNCTION_PROFILE_STOP(&fpDecP[1]);
                return tWMVStatus;
            }

            if (pmbmd->m_bSkip) {
SKIP_MB:
                pmv->x = pmv->y = 0;

                if (pWMVDec->m_bLoopFilter || *rgchSkipPrevFrame == 0) { // MB in the previous frame is not skipped
                    FUNCTION_PROFILE_START(&fpDecP[0],DECODEMBSKIP_PROFILE);
                    (*pWMVDec->m_pMotionCompZero) (
                        ppxliCurrQYMB, ppxliCurrQUMB, ppxliCurrQVMB,
                        ppxliRefYMB, ppxliRefUMB, ppxliRefVMB,
						pWMVDec->m_iWidthPrevY, pWMVDec->m_iWidthPrevUV);
                    FUNCTION_PROFILE_STOP(&fpDecP[0]);
                }
                *rgchSkipPrevFrame = 1;
                goto NEXT_MB;
            }
            // no skip
            *rgchSkipPrevFrame = 0;
            if (pmbmd->m_dctMd == INTER) {
                FUNCTION_PROFILE_START(&fpDecP[0],DECODEMBMOTION_PROFILE);

                if (pWMVDec->m_cvCodecVersion >= WMV1 || pWMVDec->m_cvCodecVersion == MP43) 
                    //result = decodeMV (pmv, imbx == 0, imbx == pWMVDec->m_uiRightestMB, !bNot1stRowInSlice);
                    tWMVStatus = decodeMVMSV (pWMVDec, pmv, pmbmd, imbx == 0, imbx == pWMVDec->m_uiRightestMB, !bNot1stRowInSlice, pWMVDec->m_pHufMVDec, pWMVDec->m_puXMvFromIndex, pWMVDec->m_puYMvFromIndex);
                else if (pWMVDec->m_cvCodecVersion == MP42 || pWMVDec->m_cvCodecVersion == MPG4)
                    tWMVStatus = decodeMV (pWMVDec, pmv, pmbmd, imbx == 0, imbx == pWMVDec->m_uiRightestMB, !bNot1stRowInSlice);
                else if (pWMVDec->m_cvCodecVersion == MP4S)
                    tWMVStatus = decodeMV (pWMVDec, pmv, pmbmd, imbx == 0 || uiNumMBFromSliceBdry==1 , imbx == pWMVDec->m_uiRightestMB, (!bNot1stRowInSlice) || uiNumMBFromSliceBdry < (pWMVDec->m_uintNumMBX + 1));
                if (WMV_Succeeded != tWMVStatus) {
                    FUNCTION_PROFILE_STOP(&fpDecP[0]);
                    FUNCTION_PROFILE_STOP(&fpDecP[1]);
                    return tWMVStatus;
                }
                pmbmd->m_bZeroMV = (pmv->x == 0 && pmv->y == 0);
                // no COD, so skip is decided by MV and CBP
                if (pmbmd->m_bCBPAllZero && pmbmd->m_bZeroMV) {
                    pmbmd->m_bSkip = TRUE_WMV;
                    FUNCTION_PROFILE_STOP(&fpDecP[0]);
                    goto SKIP_MB;
                }
                I32_WMV iMV_X = x * 2 + pmv->x;
                I32_WMV iMV_Y = y * 2 + pmv->y;
                I32_WMV iMV_X_UV = x + gmvUVtable4 [pmv->x];
                I32_WMV iMV_Y_UV = y + gmvUVtable4 [pmv->y];


                tWMVStatus = (*pWMVDec->m_pDecodePMB) (
                    pWMVDec, 
                    pmbmd,
                    ppxliCurrQYMB, 
                    ppxliCurrQUMB,
                    ppxliCurrQVMB, 
                    iMV_X, // Y MV 
                    iMV_Y,
                    iMV_X_UV, 
                    iMV_Y_UV);
                FUNCTION_PROFILE_STOP(&fpDecP[0]);
                if (WMV_Succeeded != tWMVStatus) {
                    FUNCTION_PROFILE_STOP(&fpDecP[1]);
                    return tWMVStatus;
                }
            }
            else {
                Bool_WMV bLeft, bTop, bLeftTop; 
                FUNCTION_PROFILE_START(&fpDecP[0],DECODEIMBINPFRAME_PROFILE);
                pmv->x = pmv->y = 0;                
                if (pWMVDec->m_cvCodecVersion >= WMV1){ 
                    bLeft = (imbx != 0);
                    bTop = bNot1stRowInPict;
                    bLeftTop = (imbx !=0 ) && bNot1stRowInPict;
                    if (pWMVDec->m_bDCPred_IMBInPFrame)
                        tWMVStatus = DecodeIMBAcPred_PFrame (
                            pWMVDec, 
                            pmbmd,
                            ppxliCurrQYMB,
                            ppxliCurrQUMB,
                            ppxliCurrQVMB,
                            piQuanCoefACPred, 
                            piQuanCoefACPredTable, 
                            bLeft,
                            bTop,
                            bLeftTop);
                    else
                        tWMVStatus = DecodeIMBAcPred (
                            pWMVDec, 
                            pmbmd,
                            ppxliCurrQYMB,
                            ppxliCurrQUMB,
                            ppxliCurrQVMB,
                            piQuanCoefACPred, 
                            piQuanCoefACPredTable, 
                            bLeft && ((pmbmd - 1)->m_dctMd == INTRA),
                            bTop && ((pmbmd - pWMVDec->m_uintNumMBX)->m_dctMd == INTRA),
                            bLeftTop && ((pmbmd - pWMVDec->m_uintNumMBX - 1)->m_dctMd == INTRA)
                            );
                }
                else{
                    bLeft = (imbx != 0) && ((pmbmd - 1)->m_dctMd == INTRA) &&
                        (uiNumMBFromSliceBdry > 1);
                    bTop = bNot1stRowInSlice && ((pmbmd - pWMVDec->m_uintNumMBX)->m_dctMd == INTRA)  &&
                        (uiNumMBFromSliceBdry > pWMVDec->m_uintNumMBX);
                    bLeftTop = (imbx!=0 ) && bNot1stRowInSlice && ((pmbmd - pWMVDec->m_uintNumMBX - 1)->m_dctMd == INTRA)  &&
                        (uiNumMBFromSliceBdry > (pWMVDec->m_uintNumMBX+1));
                    tWMVStatus = DecodeIMBAcPred_MP4X (
                        pWMVDec, 
                        pmbmd,
                        ppxliCurrQYMB,
                        ppxliCurrQUMB,
                        ppxliCurrQVMB,
                        piQuanCoefACPred, 
                        piQuanCoefACPredTable, 
                        bLeft,
                        bTop,
                        bLeftTop);
                }

                FUNCTION_PROFILE_STOP(&fpDecP[0]);
                if (WMV_Succeeded != tWMVStatus) {
                    FUNCTION_PROFILE_STOP(&fpDecP[1]);
                    return tWMVStatus;
                }
            }
NEXT_MB:
            if (pmbmd->m_dctMd == INTER) {
                piQuanCoefACPred[0] = piQuanCoefACPred[BLOCK_SIZE_TIMES2_TIMES4] =piQuanCoefACPred[BLOCK_SIZE_TIMES2_TIMES5] = 0;
            }
            rgchSkipPrevFrame++;
            pmbmd++;
            pmv++;
            ppxliCurrQYMB += MB_SIZE;
            ppxliCurrQUMB += BLOCK_SIZE;
            ppxliCurrQVMB += BLOCK_SIZE;
            ppxliRefYMB += MB_SIZE;
            ppxliRefUMB += BLOCK_SIZE;
            ppxliRefVMB += BLOCK_SIZE;
            piQuanCoefACPred += BLOCK_SIZE_TIMES2_TIMES6;
            piQuanCoefACPredTable += 36;
        }
        ppxliCurrQY += pWMVDec->m_iMBSizeXWidthPrevY; // point to the starting location of the first MB of each row
        ppxliCurrQU += pWMVDec->m_iBlkSizeXWidthPrevUV; // point to the starting location of the first MB of each row
        ppxliCurrQV += pWMVDec->m_iBlkSizeXWidthPrevUV; // point to the starting location of the first MB of each row
        ppxliRefY += pWMVDec->m_iMBSizeXWidthPrevY; // point to the starting location of the first MB of each row
        ppxliRefU += pWMVDec->m_iBlkSizeXWidthPrevUV; // point to the starting location of the first MB of each row
        ppxliRefV += pWMVDec->m_iBlkSizeXWidthPrevUV; // point to the starting location of the first MB of each row
    }

#ifndef COMBINE_LOOPFILTER_RENDERING
    if (pWMVDec->m_bLoopFilter)
#ifdef _MultiThread_Decode_ 
        DecodeMultiThreads (LOOPFILTER);
#else

        DeblockSLFrame (pWMVDec, pWMVDec->m_ppxliCurrQPlusExpY, 
                     		        pWMVDec->m_ppxliCurrQPlusExpU,
                      		        pWMVDec->m_ppxliCurrQPlusExpV, 
                      		        FALSE, 0, 1, pWMVDec->m_uintNumMBX, 1, pWMVDec->m_uintNumMBY);
#endif
#endif

    //Post-procesing
    ppxliCurrQY = pWMVDec->m_ppxliCurrQPlusExpY;
    ppxliCurrQU = pWMVDec->m_ppxliCurrQPlusExpU;
    ppxliCurrQV = pWMVDec->m_ppxliCurrQPlusExpV; 
    ppxliPostQY = pWMVDec->m_ppxliPostQPlusExpY;
    ppxliPostQU = pWMVDec->m_ppxliPostQPlusExpU;
    ppxliPostQV = pWMVDec->m_ppxliPostQPlusExpV;
	for (I32_WMV i = 0; i < pWMVDec->m_iHeightUV; i++) {
        memcpy(ppxliPostQU, ppxliCurrQU, pWMVDec->m_iWidthPrevUV * sizeof(PixelC));
        ppxliPostQU += pWMVDec->m_iWidthPrevUV;
        ppxliCurrQU += pWMVDec->m_iWidthPrevUV;
        memcpy(ppxliPostQV, ppxliCurrQV, pWMVDec->m_iWidthPrevUV * sizeof(PixelC));
        ppxliPostQV += pWMVDec->m_iWidthPrevUV;
        ppxliCurrQV += pWMVDec->m_iWidthPrevUV;
        memcpy(ppxliPostQY, ppxliCurrQY, pWMVDec->m_iWidthPrevY * sizeof(PixelC));
        ppxliPostQY += pWMVDec->m_iWidthPrevY;
        ppxliCurrQY += pWMVDec->m_iWidthPrevY;
        memcpy(ppxliPostQY, ppxliCurrQY, pWMVDec->m_iWidthPrevY * sizeof(PixelC));
        ppxliPostQY += pWMVDec->m_iWidthPrevY;
        ppxliCurrQY += pWMVDec->m_iWidthPrevY;
    }
    DeblockPFrame (pWMVDec, 
                pWMVDec->m_ppxliPostQPlusExpY,
                pWMVDec->m_ppxliPostQPlusExpU,
                pWMVDec->m_ppxliPostQPlusExpV,
                0, pWMVDec->m_uintNumMBY);

    FUNCTION_PROFILE_STOP(&fpDecP[1]);
    return WMV_Succeeded;
}
#endif //_SUPPORT_POST_FILTERS_

// 
Void_WMV UpdateDCStepSize(tWMVDecInternalMember *pWMVDec, I32_WMV iStepSize) 
{
    pWMVDec->m_iStepSize = iStepSize;
    pWMVDec->m_bStepSizeIsEven = ((pWMVDec->m_iStepSize % 2) == 0);
    pWMVDec->m_iStepMinusStepIsEven = pWMVDec->m_iStepSize - pWMVDec->m_bStepSizeIsEven;
    pWMVDec->m_iDoubleStepSize = pWMVDec->m_iStepSize << 1;
    pWMVDec->m_iDCStepSize = pWMVDec->m_iDCStepSizeC = 8;

    if (pWMVDec->m_cvCodecVersion >= MP43 || pWMVDec->m_cvCodecVersion == MP4S) {
        if (pWMVDec->m_iStepSize <= 4)   {
            pWMVDec->m_iDCStepSize = 8;
            pWMVDec->m_iDCStepSizeC = 8;
        }
        else if (pWMVDec->m_cvCodecVersion >= WMV1){
            pWMVDec->m_iDCStepSize = pWMVDec->m_iDCStepSizeC = pWMVDec->m_iStepSize / 2 + 6;
        }
        else if (pWMVDec->m_iStepSize <= 8)  {
            pWMVDec->m_iDCStepSize = 2 * pWMVDec->m_iStepSize;
            pWMVDec->m_iDCStepSizeC = (pWMVDec->m_iStepSize + 13) / 2;
        }
        else if (pWMVDec->m_iStepSize <= 24) {
            pWMVDec->m_iDCStepSize = pWMVDec->m_iStepSize + 8;
            pWMVDec->m_iDCStepSizeC = (pWMVDec->m_iStepSize + 13) / 2;
        }
        else {
            pWMVDec->m_iDCStepSize = 2 * pWMVDec->m_iStepSize - 16;
            pWMVDec->m_iDCStepSizeC = pWMVDec->m_iStepSize - 6;
        }
        if (pWMVDec->m_cvCodecVersion >= MP43) {
            pWMVDec->m_pAvgQuanDctCoefDec [0] = pWMVDec->m_pAvgQuanDctCoefDec [8] = (1024 + (pWMVDec->m_iDCStepSize >> 1)) / pWMVDec->m_iDCStepSize;
            pWMVDec->m_pAvgQuanDctCoefDecC[0] = pWMVDec->m_pAvgQuanDctCoefDecC[8] = (1024 + (pWMVDec->m_iDCStepSizeC >> 1)) / pWMVDec->m_iDCStepSizeC;
        }
    }
}


tWMVDecodeStatus WMVideoDecDecodeClipInfo (tWMVDecInternalMember *pWMVDec)
{
    if (pWMVDec->m_cvCodecVersion == WMV2) {
        if (pWMVDec->m_bXintra8Switch)
            pWMVDec->m_bXintra8 = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
    } else { // WMV1
        I32_WMV iFrameRate = BS_getBits  ( pWMVDec->m_pbitstrmIn, 5);
        if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
            pWMVDec->m_iFrameRate = 30;
            pWMVDec->m_iBitRate = 500; // to be conservative for the deblocking/deringing choice
            pWMVDec->m_bRndCtrlOn = FALSE;
            return WMV_Succeeded;
        }
        if (pWMVDec->m_iFrameRate == 0) // if the info is available from system (app), use it.
            pWMVDec->m_iFrameRate = iFrameRate;
        pWMVDec->m_iBitRate = BS_getBits (pWMVDec->m_pbitstrmIn, 11);
g_iBitRate = pWMVDec->m_iBitRate;
g_iFrameRate = pWMVDec->m_iFrameRate;
        if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
            pWMVDec->m_iFrameRate = 30;
            pWMVDec->m_iBitRate = 500; // to be conservative for the deblocking/deringing choice
            pWMVDec->m_bRndCtrlOn = FALSE;
            return WMV_Succeeded;
        }
    	if (pWMVDec->m_cvCodecVersion != MP42) 
            pWMVDec->m_bRndCtrlOn = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
    }
    return WMV_Succeeded;
}

tWMVDecodeStatus setSliceCode (tWMVDecInternalMember *pWMVDec, I32_WMV iSliceCode)
{
    // setSliceCode 
    if (!pWMVDec->m_fPrepared) {
        if (pWMVDec->m_cvCodecVersion == WMV2) {
			setRefreshPeriod(pWMVDec);
            pWMVDec->m_uintNumMBYSlice = pWMVDec->m_uintNumMBY / iSliceCode;
        }
        else if (pWMVDec->m_cvCodecVersion != MP4S) {
			if (pWMVDec->m_cvCodecVersion == WMV1) 
                setRefreshPeriod(pWMVDec);
            if (iSliceCode <= 22)
                return WMV_Failed;
            else {
                pWMVDec->m_uintNumMBYSlice = pWMVDec->m_uintNumMBY / (iSliceCode - 22);
            }
        }
        else // MP4S  Needs to be fixed
            pWMVDec->m_uintNumMBYSlice = pWMVDec->m_uintNumMBY;

        pWMVDec->m_bMainProfileOn = (!pWMVDec->m_bDeblockOn && pWMVDec->m_bMBAligned);
        pWMVDec->m_fPrepared = TRUE_WMV;
        return WMV_Succeeded;
    }
    else
        return WMV_Succeeded;
}

tWMVDecodeStatus decodeVOLHead (tWMVDecInternalMember *pWMVDec)
{
    assert (pWMVDec->m_cvCodecVersion == WMV2);
    pWMVDec->m_iFrameRate = BS_getBits  ( pWMVDec->m_pbitstrmIn, 5);
g_iFrameRate = pWMVDec->m_iFrameRate;
    pWMVDec->m_iBitRate = BS_getBits  ( pWMVDec->m_pbitstrmIn, 11);
g_iBitRate = pWMVDec->m_iBitRate;
    pWMVDec->m_bRndCtrlOn = TRUE_WMV;
    pWMVDec->m_bMixedPel = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
    pWMVDec->m_bLoopFilter = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
    pWMVDec->m_bXformSwitch = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
    pWMVDec->m_bXintra8Switch = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);

//#ifdef _HYBRID_MV_
    pWMVDec->m_bFrmHybridMVOn = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
//#else
//    pWMVDec->m_bFrmHybridMVOn = FALSE;
//#endif
    // DCTTABLE S/W at MB level for WMV2.
    pWMVDec->m_bDCTTable_MB_ENABLED = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
    pWMVDec->m_iSliceCode = BS_getBits  ( pWMVDec->m_pbitstrmIn, NUMBITS_SLICE_SIZE_WMV2);

    //pWMVDec->m_pbitstrmIn->flushMPEG4 ();
    return WMV_Succeeded;
}

Void_WMV DecodeSkipBit(tWMVDecInternalMember *pWMVDec)
{
	CWMVMBMode* pmbmd = pWMVDec->m_rgmbmd;
	U32_WMV imbY, imbX;

    switch(pWMVDec->m_SkipBitCodingMode) {
	case Normal:
		for (imbY = 0; imbY < pWMVDec->m_uintNumMBY; imbY++) {
			for (imbX = 0; imbX < pWMVDec->m_uintNumMBX; imbX++) {
				pmbmd [imbX].m_bSkip = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
				//pmbmd++;
			}
            pmbmd += pWMVDec->m_uintNumMBX;
		}
		break;
	case RowPredict:
		for (imbY = 0; imbY < pWMVDec->m_uintNumMBY; imbY++) {
			if (BS_getBits  ( pWMVDec->m_pbitstrmIn, 1)) { 
				// skip row
				for (imbX = 0; imbX < pWMVDec->m_uintNumMBX; imbX++) {
					pmbmd->m_bSkip = 1;
					pmbmd++;
				}
			} else { 
				for (imbX = 0; imbX < pWMVDec->m_uintNumMBX; imbX++) {
					pmbmd->m_bSkip = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
					pmbmd++;
				}
			}
		}
		break;
	case ColPredict:
        {
		    CWMVMBMode* pmbmdcol = pWMVDec->m_rgmbmd;
		    for (imbX = 0; imbX < pWMVDec->m_uintNumMBX; imbX++) {
			    pmbmd = pmbmdcol;
			    if (BS_getBits  ( pWMVDec->m_pbitstrmIn, 1)) { // skip column
				    for (imbY = 0; imbY < pWMVDec->m_uintNumMBY; imbY++) {
					    pmbmd->m_bSkip = 1;
					    pmbmd += pWMVDec->m_uintNumMBX;
				    }
			    } else {
				    for (imbY = 0; imbY < pWMVDec->m_uintNumMBY; imbY++) {
					    pmbmd->m_bSkip = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
					    pmbmd += pWMVDec->m_uintNumMBX;
				    }
			    }
			    pmbmdcol++;
		    }
        }
		break;
	}
}

tWMVDecodeStatus WMVideoDecDecodeFrameHead (tWMVDecInternalMember *pWMVDec)
{
    if (pWMVDec->m_cvCodecVersion != MP4S) {
        I32_WMV iNumBitsFrameType;
#ifdef _MPG4_
        if (pWMVDec->m_cvCodecVersion == MPG4) {
            U32_WMV uiVopStartCode = BS_getBits  ( pWMVDec->m_pbitstrmIn, NUMBITS_START_CODE_PREFIX+NUMBITS_VOP_START_CODE);
            uiVopStartCode = uiVopStartCode << NUMBITS_START_CODE_PREFIX;
            U32_WMV start = START_CODE_PREFIX << NUMBITS_START_CODE_PREFIX;
            BS_getBits  ( pWMVDec->m_pbitstrmIn, NUMBITS_VOP_TIME);
        }
#endif
        iNumBitsFrameType = (pWMVDec->m_cvCodecVersion == WMV2) ? NUMBITS_VOP_PRED_TYPE_WMV2 :  NUMBITS_VOP_PRED_TYPE;
        pWMVDec->m_tFrmType = (tFrameType_WMV) BS_getBits  ( pWMVDec->m_pbitstrmIn, iNumBitsFrameType);
        if (pWMVDec->m_tFrmType != IVOP && pWMVDec->m_tFrmType != PVOP)
            return WMV_CorruptedBits;

        if (pWMVDec->m_cvCodecVersion == WMV2 && pWMVDec->m_tFrmType == IVOP) {
            I32_WMV iBufferFullPercent = BS_getBits  ( pWMVDec->m_pbitstrmIn, 7);
            if (BS_invalid ( pWMVDec->m_pbitstrmIn))
	            return WMV_CorruptedBits;
        }

        pWMVDec->m_iStepSize = BS_getBits  ( pWMVDec->m_pbitstrmIn, NUMBITS_VOP_QUANTIZER);
        //pWMVDec->m_iStepSize = pWMVDec->m_iStepSize = stepDecoded;
        if (BS_invalid ( pWMVDec->m_pbitstrmIn) || pWMVDec->m_iStepSize <= 0 || pWMVDec->m_iStepSize > 31) {
	        return WMV_CorruptedBits;
        }


        if (pWMVDec->m_tFrmType == IVOP) {
            tWMVDecodeStatus tWMVStatus;
            if (pWMVDec->m_cvCodecVersion != WMV2)        
                pWMVDec->m_iSliceCode = BS_getBits  ( pWMVDec->m_pbitstrmIn, NUMBITS_SLICE_SIZE);
            tWMVStatus = setSliceCode (pWMVDec, pWMVDec->m_iSliceCode);
            //I32_WMV iSliceCode = BS_getBits  ( pWMVDec->m_pbitstrmIn, NUMBITS_SLICE_SIZE);
            if (tWMVStatus != WMV_Succeeded) {
			    return tWMVStatus;
		    }
            if (pWMVDec->m_cvCodecVersion >= WMV1){
                tWMVStatus = WMVideoDecDecodeClipInfo (pWMVDec);
                if(BS_invalid ( pWMVDec->m_pbitstrmIn) || tWMVStatus != WMV_Succeeded) {
                    return tWMVStatus;
                }
                if (pWMVDec->m_cvCodecVersion == WMV2) {
                    pWMVDec->m_bDCPred_IMBInPFrame = FALSE;
                } else {    // WMV1
                    pWMVDec->m_bDCTTable_MB_ENABLED = (pWMVDec->m_iBitRate > MIN_BITRATE_MB_TABLE);
                    pWMVDec->m_bDCPred_IMBInPFrame = (pWMVDec->m_iBitRate <= MAX_BITRATE_DCPred_IMBInPFrame && (pWMVDec->m_iFrmWidthSrc * pWMVDec->m_iFrmHeightSrc < 320 * 240));
                }
            }
            if (!pWMVDec->m_bXintra8 && pWMVDec->m_cvCodecVersion >= MP43) {
                //pWMVDec->m_cvCodecVersion == MP43 || pWMVDec->m_cvCodecVersion == WMV1(2)
                // If pWMVDec->m_bDCTTable_MB_ENABLED is on
                if (pWMVDec->m_bDCTTable_MB_ENABLED){
                    pWMVDec->m_bDCTTable_MB = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
                }
                if (!pWMVDec->m_bDCTTable_MB){
		            // DCT Table swtiching, I and P index are coded separately.
		            // Can be jointly coded using the following table. 
		            // IP Index : Code
		            // 00		: 00, 
		            // 11		: 01, 
		            // 01		: 100,
		            // 10		: 101,
		            // 02		: 1100,
		            // 12		: 1101,
		            // 20		: 1110, 
		            // 21		: 11110
		            // 22		: 11111
                    pWMVDec->m_iDCTACInterTableIndx = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
		            if (pWMVDec->m_iDCTACInterTableIndx){
			            pWMVDec->m_iDCTACInterTableIndx += BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
		            }
                    pWMVDec->m_iDCTACIntraTableIndx = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
		            if (pWMVDec->m_iDCTACIntraTableIndx){
			            pWMVDec->m_iDCTACIntraTableIndx += BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
		            }
                }
		        pWMVDec->m_iIntraDCTDCTable = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
            }
        
            pWMVDec->m_iRndCtrl = 1;
        }
        else {
            //if (pWMVDec->m_cvCodecVersion == WMV2)
            decodeVOPHead_WMV2(pWMVDec);
            //else
            //    pWMVDec->m_bCODFlagOn = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);

            if (pWMVDec->m_cvCodecVersion >= MP43) {
		        // MP43 || WMV1 (2) 
                if (pWMVDec->m_bDCTTable_MB_ENABLED){
                    pWMVDec->m_bDCTTable_MB = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
                }
                if (!pWMVDec->m_bDCTTable_MB){
                    pWMVDec->m_iDCTACInterTableIndx = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
		            if (pWMVDec->m_iDCTACInterTableIndx){
			            pWMVDec->m_iDCTACInterTableIndx += BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
		            }
                }
		        pWMVDec->m_iIntraDCTDCTable = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
		        pWMVDec->m_iMVTable = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
            }

            pWMVDec->m_iRndCtrl ^= 0x01;
        }
        if (BS_invalid ( pWMVDec->m_pbitstrmIn)) {
            return WMV_CorruptedBits;
        }
        return WMV_Succeeded;
    }// MP4S
    else{
        U32_WMV start, uiVopStartCode, iModuloInc, uiMarker;
        Time tCurrSec, tVopIncr;
        I32_WMV	iIntraDcSwitchThr;

        start = BS_getBits  ( pWMVDec->m_pbitstrmIn, NUMBITS_START_CODE_PREFIX);
        if (start != START_CODE_PREFIX) {
            return WMV_CorruptedBits;
        }

        uiVopStartCode = BS_getBits  (pWMVDec->m_pbitstrmIn , NUMBITS_VOP_START_CODE);
        if (uiVopStartCode != VOP_START_CODE) {
            return WMV_CorruptedBits;
        }
        pWMVDec->m_tFrmType = (tFrameType_WMV) BS_getBits  ( pWMVDec->m_pbitstrmIn, NUMBITS_VOP_PRED_TYPE);
        // Time reference and VOP_pred_type
        iModuloInc = 0;
        while (BS_getBits  ( pWMVDec->m_pbitstrmIn, 1) != 0)
            iModuloInc++;
        tCurrSec = iModuloInc + pWMVDec->m_tModuloBaseDecd;
        uiMarker = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
//        assert(uiMarker == 1);

        tVopIncr = BS_getBits  ( pWMVDec->m_pbitstrmIn, pWMVDec->m_iNumBitsTimeIncr);
        uiMarker = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1); // marker bit
//        assert(uiMarker == 1);

        pWMVDec->m_tOldModuloBaseDecd = pWMVDec->m_tModuloBaseDecd;
        pWMVDec->m_tOldModuloBaseDisp = pWMVDec->m_tModuloBaseDisp;
        //(pWMVDec->m_tFrmType != BVOP)
        pWMVDec->m_tModuloBaseDisp = pWMVDec->m_tModuloBaseDecd;      //update most recently displayed time base
        pWMVDec->m_tModuloBaseDecd = tCurrSec;

        pWMVDec->m_t = tCurrSec * pWMVDec->m_iClockRate + tVopIncr;

//  if ((pWMVDec->m_coded = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1)) == 0)         //vop_coded == false
        if (BS_getBits  ( pWMVDec->m_pbitstrmIn, 1) == 0)     {       //vop_coded == false
            Bool_WMV bInterlace = FALSE; //wchen: temporary solution
            return WMV_CorruptedBits;
        }


        if (pWMVDec->m_tFrmType == PVOP)
            pWMVDec->m_iRndCtrl = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1); //"VOP_Rounding_Type"
        else
            pWMVDec->m_iRndCtrl = 0;

        iIntraDcSwitchThr = BS_getBits  ( pWMVDec->m_pbitstrmIn, 3);

// INTERLACE
//        bInterlace = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
//        I32_WMV UIQUANTPRECISION = 5;
        if (pWMVDec->m_tFrmType == IVOP)    {
            pWMVDec->m_iStepSize = BS_getBits  ( pWMVDec->m_pbitstrmIn, 5);    //also assign intStep to be safe
            pWMVDec->uiFCode = 1;
        }
        else if (pWMVDec->m_tFrmType == PVOP) {
            pWMVDec->m_iStepSize = BS_getBits  ( pWMVDec->m_pbitstrmIn, 5);
            pWMVDec->uiFCode = BS_getBits  ( pWMVDec->m_pbitstrmIn, NUMBITS_VOP_FCODE);
            pWMVDec->iScaleFactor = 1 << (pWMVDec->uiFCode - 1);
            pWMVDec->iRange = 16 << pWMVDec->uiFCode;
        }
        return WMV_Succeeded;
    }
}
Void_WMV decodeVOPHead_WMV2 (tWMVDecInternalMember *pWMVDec)
{
    if (!pWMVDec->m_bSKIPBIT_CODING_){
#ifdef _MPG4_
        if (pWMVDec->m_cvCodecVersion != MPG4)
#endif
        pWMVDec->m_bCODFlagOn = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
    }
    else{
		I32_WMV iSkipBitCode = BS_getBits  ( pWMVDec->m_pbitstrmIn, 2);
		pWMVDec->m_bCODFlagOn = 1;
		if (iSkipBitCode == 0) {
			pWMVDec->m_bCODFlagOn = 0;
		} else {
			if (iSkipBitCode == 1) {
				pWMVDec->m_SkipBitCodingMode = Normal;
			} else if (iSkipBitCode == 2) {
				pWMVDec->m_SkipBitCodingMode = RowPredict;
			} else {
				pWMVDec->m_SkipBitCodingMode = ColPredict;
			}
			DecodeSkipBit(pWMVDec);
		}
    }

    // NEW_PCBPCY_TABLE
    if (pWMVDec->m_bNEW_PCBPCY_TABLE){
		if (pWMVDec->m_iStepSize <= 10) {
			if (!BS_getBits  ( pWMVDec->m_pbitstrmIn, 1)) { //0 High
				pWMVDec->m_pHufNewPCBPCYDec = &pWMVDec->m_hufPCBPCYDec_HighRate;
			} else if (!BS_getBits  ( pWMVDec->m_pbitstrmIn, 1)) { //10 Low
				pWMVDec->m_pHufNewPCBPCYDec = &pWMVDec->m_hufPCBPCYDec_LowRate;
			} else { //11 Mid
				pWMVDec->m_pHufNewPCBPCYDec = &pWMVDec->m_hufPCBPCYDec_MidRate;
			}
		} else if (pWMVDec->m_iStepSize <= 20) {
			if (!BS_getBits  ( pWMVDec->m_pbitstrmIn, 1)) { //0 Mid
				pWMVDec->m_pHufNewPCBPCYDec = &pWMVDec->m_hufPCBPCYDec_MidRate;
			} else if (!BS_getBits  ( pWMVDec->m_pbitstrmIn, 1)) { //10 High
				pWMVDec->m_pHufNewPCBPCYDec = &pWMVDec->m_hufPCBPCYDec_HighRate;
			} else { //11 Low
				pWMVDec->m_pHufNewPCBPCYDec = &pWMVDec->m_hufPCBPCYDec_LowRate;
			}
		} else {
			if (!BS_getBits  ( pWMVDec->m_pbitstrmIn, 1)) { //0 Low
				pWMVDec->m_pHufNewPCBPCYDec = &pWMVDec->m_hufPCBPCYDec_LowRate;
			} else if (!BS_getBits  ( pWMVDec->m_pbitstrmIn, 1)) { //10 Mid
				pWMVDec->m_pHufNewPCBPCYDec = &pWMVDec->m_hufPCBPCYDec_MidRate;
			} else { //11 High
				pWMVDec->m_pHufNewPCBPCYDec = &pWMVDec->m_hufPCBPCYDec_HighRate;
			}
		}
    }

    //_MIXEDPEL_
    if (pWMVDec->m_bMixedPel)
        pWMVDec->m_iMvResolution = BS_getBits  ( pWMVDec->m_pbitstrmIn, 1);
    
    
    if (pWMVDec->m_bXformSwitch) {
        if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 1)
        {
            pWMVDec->m_bMBXformSwitching = FALSE;
            if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 0)
                pWMVDec->m_iFrameXformMode = XFORMMODE_8x8;
            else if (BS_getBit ( pWMVDec->m_pbitstrmIn) == 0)
                pWMVDec->m_iFrameXformMode = XFORMMODE_8x4;
            else
                pWMVDec->m_iFrameXformMode = XFORMMODE_4x8;
        }
        else
            pWMVDec->m_bMBXformSwitching = TRUE_WMV;
    }

}

Void_WMV setRefreshPeriod(tWMVDecInternalMember *pWMVDec) 
{
#ifdef _SUPPORT_POST_FILTERS_
	I32_WMV iWidthTimesHeight  = pWMVDec->m_iWidthY * pWMVDec->m_iHeightY;
    if (pWMVDec->m_iBitRate > 300 || iWidthTimesHeight > 320 * 240)
        pWMVDec->m_bRefreshDisplay_AllMB_Enable = FALSE;
    else if (iWidthTimesHeight > 240 * 176){
#ifdef  _WMV_TARGET_X86_
        if (g_bSupportMMX_WMV)
            //pWMVDec->m_bRefreshDisplay_AllMB_Enable = FALSE;
            pWMVDec->m_iRefreshDisplay_AllMB_Period = 2;
        else
#endif //  _WMV_TARGET_X86_
            pWMVDec->m_iRefreshDisplay_AllMB_Period = 4;
            //pWMVDec->m_iRefreshDisplay_AllMB_Period = 3;
    }
    else {
        pWMVDec->m_iRefreshDisplay_AllMB_Period = 1;
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\huffdec_wmv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       huffman.cpp
//
//--------------------------------------------------------------------------
#include "bldsetup.h"

#include "xplatform.h"
#include "wmvdec_api.h"
#include "wmvdec_member.h"
#include "wmvdec_function.h"
#include "stdio.h"
#include "huffman_wmv.hpp"
#include "strmdec_wmv.hpp"
#ifndef CHECK_ALLOC
#define CHECK_ALLOC(ptr) if ((ptr)==NULL_WMV) { vr=vrOutOfMemory; goto lerror; }
#endif
#define MAX_DEC_TABLES 1000

typedef struct {
  U32_WMV code;
  U32_WMV length;
  U32_WMV table;
} InitEncInfo;


Void_WMV Huffman_WMV_construct(Huffman_WMV * pThis)
{
  pThis->m_tableInfo     = NULL_WMV;
  pThis->m_initInfo      = NULL_WMV;
  pThis->m_encInfo       = NULL_WMV;
  pThis->m_decInfo       = NULL_WMV;

  pThis->m_alphabetSize  = 0;
  pThis->m_maxCodeLength = 0;
  pThis->m_allocDecEntries=0;
  pThis->m_allocTables=0;
}

Void_WMV Huffman_WMV_destruct(Huffman_WMV * pThis)
{
  if ( pThis->m_tableInfo != NULL_WMV ) {
      DEBUG_HEAP_SUB( g_iHeapLastClass, pThis->m_allocTables * sizeof(TableInfo) );
  }
  delete [] pThis->m_tableInfo;
//  delete [] m_initInfo; // deleted elsewhere
//  delete [] m_encInfo;
  if ( pThis->m_decInfo != NULL ) {
      DEBUG_HEAP_SUB( g_iHeapLastClass, pThis->m_allocDecEntries * sizeof(HuffDecInfo) );
  }
  delete [] pThis->m_decInfo;
}

VResult Huffman_WMV_findTables(Huffman_WMV * pThis, I32_WMV &totalTableNum, I32_WMV *maxBits, I32_WMV iMAX_STAGES);
VResult Huffman_WMV_allocTables(Huffman_WMV * pThis, I32_WMV numTables);
void Huffman_WMV_fillEntry(Huffman_WMV * pThis, I32_WMV cwd, I32_WMV length, I32_WMV tableNum,
                        I32_WMV index, HuffDecInfo *currDecTable);

extern "C"
ULONG
_cdecl
DbgPrint(
    PCH Format,
    ...
    );

VResult Huffman_WMV_init (Huffman_WMV * pThis, U32_WMV uiUserData, tPackHuffmanCode_WMV huffArray[], I32_WMV *maxBits, I32_WMV iMAX_STAGES)
{
    VResult vr;
    I32_WMV i, j, numTables;

    pThis->m_uiUserData = uiUserData;

//  assert(sizeof(I32_WMV) == sizeof(int32)); // GetMask is only 32 bits wide
    pThis->m_maxCodeLength = 0;
    pThis->m_alphabetSize = huffArray[0].code;
    huffArray = huffArray++;

    pThis->m_encInfo = huffArray;
    pThis->m_maxCodeLength = 0;
    for (j=0; j<pThis->m_alphabetSize; j++) {
      //assert(*huffArray != -1);
      if ((U32_WMV) pThis->m_encInfo[j].length > (U32_WMV)pThis->m_maxCodeLength)
          pThis->m_maxCodeLength = pThis->m_encInfo[j].length;
  }
  // Generate decoder table if necessary
  //vr = initDecTable(maxBits);

#ifndef _CASIO_VIDEO_
#ifdef SMALL_HUFFMAN
  assert(pThis->m_alphabetSize <= (1<<12)); // so we can use 12 bits for symbol field
#else
  assert(pThis->m_alphabetSize <= (1<<16));
#endif
#endif

  pThis->m_initInfo = new TableInitInfo[MAX_DEC_TABLES];
  CHECK_ALLOC(pThis->m_initInfo);
  DEBUG_HEAP_ADD( g_iHeapLastClass, MAX_DEC_TABLES * sizeof(TableInitInfo));

  // Find the # of decoder tables we will need
  vr = Huffman_WMV_findTables(pThis,numTables, maxBits, iMAX_STAGES);
//printf("%d\n",numTables);
  if (vr.failed()) goto lerror;

  // Allocate tables
  vr = Huffman_WMV_allocTables(pThis,numTables);
  if (vr.failed()) goto lerror;

  // Now we are done with table info and can delete it
  delete [] pThis->m_initInfo;
  pThis->m_initInfo=NULL_WMV;
  DEBUG_HEAP_SUB( g_iHeapLastClass, MAX_DEC_TABLES * sizeof(TableInitInfo) );

  for (i=0; i<pThis->m_alphabetSize; i++) {
    Huffman_WMV_fillEntry(pThis, pThis->m_encInfo[i].code , pThis->m_encInfo[i].length , 0, i, pThis->m_decInfo);
  }

#if 0 && DBG

  HuffDecInfo *pdecinfo;
  DWORD Count = numTables;

  DbgPrint("WORD g_Huffman_[] =\n{\n    // Tables");

  for (i = 0; i < numTables; i++)
  {
      if (i % 8 == 0)
      {
          DbgPrint("\n    ");
      }

      DbgPrint("0x%04X, ", Count | (pThis->m_tableInfo[i].bits << 12));

      Count += (1 << pThis->m_tableInfo[i].bits);
  }

  for (i = 0; i < numTables; i++)
  {
      pdecinfo = pThis->m_tableInfo[i].table;

      DWORD j;

      DbgPrint("\n    // Table %d", i);

      for (j = 0; j < (DWORD)(1 << pThis->m_tableInfo[i].bits); j++)
      {
          if (j % 8 == 0)
          {
              DbgPrint("\n    ");
          }

          DbgPrint("0x%04X, ", *(WORD *)pdecinfo);

          pdecinfo++;
      }

      DbgPrint("\n");
  }

  DbgPrint("\n};");

#endif

  return vrNoError;

 lerror:
  if (   pThis->m_initInfo != NULL_WMV ) {
      DEBUG_HEAP_SUB( g_iHeapLastClass, MAX_DEC_TABLES * sizeof(TableInitInfo) );
  }
  delete [] pThis->m_initInfo;
  pThis->m_initInfo=NULL_WMV;
  return vr;
}

VResult Huffman_WMV_findTables(Huffman_WMV * pThis, I32_WMV &totalTableNum, I32_WMV *maxBits, I32_WMV iMAX_STAGES)
{
  VResult vr;
  I32_WMV i, j, stage, tableNum, start, end, prefix, excessBits, nextTable;
  InitEncInfo *initEncInfo = NULL_WMV;
  I32_WMV myMaxBits[4];
  Bool_WMV found;
  // Set # of bits for each stage
  if (maxBits == NULL_WMV) {
    iMAX_STAGES = 3;
    myMaxBits[0] = BITS_STAGE1;
    myMaxBits[1] = BITS_STAGE2;
    myMaxBits[2] = pThis->m_maxCodeLength - (myMaxBits[0] + myMaxBits[1]);
  } else {
    for (i=0; i<iMAX_STAGES; i++) myMaxBits[i] = maxBits[i];
  }
#ifndef HITACHI
  initEncInfo = new InitEncInfo[pThis->m_alphabetSize];
#else
  initEncInfo =  (InitEncInfo *)wmvalloc(pThis->m_alphabetSize * (sizeof(InitEncInfo)));
#endif      
  CHECK_ALLOC(initEncInfo);
  DEBUG_HEAP_ADD( g_iHeapLastClass, pThis->m_alphabetSize * sizeof(InitEncInfo) );

#ifndef _CASIO_VIDEO_
  assert(MAX_DEC_TABLES <= (1<<16));
#endif

  for (i=0; i<pThis->m_alphabetSize; i++) {
    initEncInfo[i].code   = pThis->m_encInfo[i].code ;
    initEncInfo[i].length = pThis->m_encInfo[i].length ;
    initEncInfo[i].table  = 0;
  }
  pThis->m_initInfo[0].maxBits = pThis->m_maxCodeLength;
  for (i=1; i<MAX_DEC_TABLES; i++) {
    pThis->m_initInfo[i].maxBits = 0;
  }

  totalTableNum = 1;
  end           = 0;
  for (stage=0; stage<iMAX_STAGES; stage++) {
    start = end;
    end   = totalTableNum;
//    lprintf(2, "    At stage %d, we have %d tables", stage, end-start);
    for (tableNum=start; tableNum<end; tableNum++) {
      pThis->m_initInfo[tableNum].start = totalTableNum;
      pThis->m_initInfo[tableNum].end   = pThis->m_initInfo[tableNum].start;
      if (pThis->m_initInfo[tableNum].maxBits <= myMaxBits[stage]) {
        pThis->m_initInfo[tableNum].bits = pThis->m_initInfo[tableNum].maxBits;
        continue;
      } else {
        pThis->m_initInfo[tableNum].bits = myMaxBits[stage];
      }
      for (i=0; i<pThis->m_alphabetSize; i++) {
        if (initEncInfo[i].table == (U32_WMV)tableNum) {
          if (initEncInfo[i].length > (U32_WMV)pThis->m_initInfo[tableNum].bits) {
            excessBits = initEncInfo[i].length - pThis->m_initInfo[tableNum].bits;
            prefix = (initEncInfo[i].code >> excessBits);
            initEncInfo[i].length = excessBits;
#ifdef OPT_HUFFMAN_GET_WMV
            initEncInfo[i].code &= (((U32_WMV)0xffffffff)>>(32-excessBits));
#else
            initEncInfo[i].code &= GetMask_WMV[excessBits];
#endif
            found = false;
            for (j=pThis->m_initInfo[tableNum].start; j<pThis->m_initInfo[tableNum].end; j++) {
              if (pThis->m_initInfo[j].prefix == prefix) {
                found = true;
                if (excessBits > pThis->m_initInfo[j].maxBits) {
                  pThis->m_initInfo[j].maxBits = excessBits;
                }
                nextTable = j;
                break;
              }
            }
            if (!found) {
#ifndef _CASIO_VIDEO_
              assert(totalTableNum < MAX_DEC_TABLES);
#endif
              pThis->m_initInfo[tableNum].end++;
              pThis->m_initInfo[totalTableNum].prefix = prefix;
              pThis->m_initInfo[totalTableNum].maxBits = excessBits;
              nextTable = totalTableNum;
              totalTableNum++;
            }
            initEncInfo[i].table = nextTable;
          }
        }
      }
    }
  }

  if(initEncInfo != NULL_WMV) {
    DEBUG_HEAP_SUB( g_iHeapLastClass, pThis->m_alphabetSize * sizeof(InitEncInfo) );
  }
#ifndef HITACHI
  delete [] initEncInfo;
#else 
  if(initEncInfo != NULL_WMV)
    wmvfree(initEncInfo);
#endif  
  return vrNoError;

 lerror:
  if(initEncInfo != NULL_WMV) {
      DEBUG_HEAP_SUB( g_iHeapLastClass, pThis->m_alphabetSize * sizeof(InitEncInfo) );
  }
#ifndef HITACHI
  delete [] initEncInfo;
#else 
  if(initEncInfo != NULL_WMV)
    wmvfree(initEncInfo);

#endif  
  return vr;
}

VResult Huffman_WMV_allocTables(Huffman_WMV * pThis, I32_WMV numTables)
{
  VResult vr;
  I32_WMV i, j;

  // Allocate memory and set offsets
//  lprintf(2, "    Allocating %d bytes for next stage info",
//          numTables*sizeof(TableInfo));
  if (numTables > pThis->m_allocTables) {   // support reinitialisation
      if (pThis->m_tableInfo) {
          delete [] pThis->m_tableInfo;
          DEBUG_HEAP_SUB( g_iHeapLastClass, pThis->m_allocTables * sizeof(TableInfo) );
      }
      pThis->m_tableInfo = new TableInfo[pThis->m_allocTables = numTables];
      CHECK_ALLOC(pThis->m_tableInfo);
      DEBUG_HEAP_ADD( g_iHeapLastClass, pThis->m_allocTables * sizeof(TableInfo) );
  }

  pThis->m_numDecEntries = 0;
  for (i=0; i<numTables; i++) pThis->m_numDecEntries += 1<<pThis->m_initInfo[i].bits;
//  lprintf(2, "    Allocating %d bytes for huffman decoder table",
//          m_numDecEntries*sizeof(HuffDecInfo));
  if (pThis->m_numDecEntries > pThis->m_allocDecEntries) {  // support reinitialisation
      if (pThis->m_decInfo) {
          delete [] pThis->m_decInfo; 
          DEBUG_HEAP_SUB( g_iHeapLastClass, pThis->m_allocDecEntries * sizeof(HuffDecInfo) );
      }
      pThis->m_decInfo = new HuffDecInfo[pThis->m_allocDecEntries = pThis->m_numDecEntries];
      CHECK_ALLOC(pThis->m_decInfo);
      DEBUG_HEAP_ADD( g_iHeapLastClass, pThis->m_allocDecEntries * sizeof(HuffDecInfo) );

      // set everything to -1 for mpeg4 tables because there are illegal
      // entries in mpeg4 table, this way, we can detect bad data.
      for (i = 0; i < pThis->m_allocDecEntries; i++) {
          pThis->m_decInfo[i].length = -1;
      }
  }

  HUFFMANGET_DBG_STATUS(pThis->m_decInfo,numTables,pThis->m_numDecEntries)

  pThis->m_numDecEntries = 0;

  for (i=0; i<numTables; i++) {
    pThis->m_tableInfo[i].bits  = pThis->m_initInfo[i].bits;
    pThis->m_tableInfo[i].table = pThis->m_decInfo+pThis->m_numDecEntries;
    pThis->m_numDecEntries     += 1<<pThis->m_initInfo[i].bits;
  }

  for (i=0; i<numTables; i++) {
    for (j=pThis->m_initInfo[i].start; j<pThis->m_initInfo[i].end; j++) {
      (pThis->m_tableInfo[i].table)[pThis->m_initInfo[j].prefix].symbol = j;
      (pThis->m_tableInfo[i].table)[pThis->m_initInfo[j].prefix].length = 0;
    }
    if ( (unsigned)pThis->m_initInfo[i].end >= (1U<<HUFFDEC_SYMBOL_BITS) ) {
        assert( (unsigned)pThis->m_initInfo[i].end < (1U<<HUFFDEC_SYMBOL_BITS));
        vr = vrOutOfBounds;
        goto lerror;
    }
  }


  return vrNoError;

 lerror:
  return vr;
}

DEBUG_ONLY( I32_WMV giMaxSymbol_WMV = 0; )
DEBUG_ONLY( I32_WMV giMaxLength_WMV = 0; )

void Huffman_WMV_fillEntry(Huffman_WMV * pThis, I32_WMV cwd, I32_WMV length, I32_WMV tableNum,
                        I32_WMV index, HuffDecInfo *currDecTable)
{
  I32_WMV start, end, excessBits, j, prefix;

  if (length == 0) return;

  DEBUG_ONLY( I32_WMV iMaxSymbol = 0 );
  DEBUG_ONLY( I32_WMV iMaxLength = 0 );

  while (true) {
#ifndef _CASIO_VIDEO_
#ifdef SMALL_HUFFMAN
    assert(pThis->m_tableInfo[tableNum].bits < (1<<4)); // only 4 bits for length
                                                // one less for next stage
#else
    assert(pThis->m_tableInfo[tableNum].bits < (1<<16)); // should never happen
#endif
#endif
    if (length <= pThis->m_tableInfo[tableNum].bits) {
      excessBits = pThis->m_tableInfo[tableNum].bits - length;
      start      = cwd << excessBits;
      end        = start + (1 << excessBits);
      for (j=start; j<end; j++) {
        currDecTable[j].symbol = index;
        currDecTable[j].length = length;
        DEBUG_ONLY( if (iMaxSymbol<index) iMaxSymbol = index );
        DEBUG_ONLY( if (iMaxLength<length) iMaxLength = length );
      }
      // verify the indexes and lengths fit.
#ifndef _Embedded_x86
      DEBUG_ONLY( assert( iMaxSymbol < (1U<<HUFFDEC_SYMBOL_BITS) && iMaxLength < (1U<<HUFFDEC_SYMBOL_BITS) ) );
#endif
      DEBUG_ONLY( if (giMaxSymbol_WMV < iMaxSymbol) giMaxSymbol_WMV = iMaxSymbol );
      DEBUG_ONLY( if (giMaxLength_WMV < iMaxLength) giMaxLength_WMV = iMaxLength );
      return;
    } else {
      excessBits   = length - pThis->m_tableInfo[tableNum].bits;
      prefix       = cwd >> excessBits;
#ifndef _CASIO_VIDEO_
      assert(currDecTable[prefix].length == 0);
#endif
      tableNum     = currDecTable[prefix].symbol;
#ifdef OPT_HUFFMAN_GET_WMV
      cwd          = cwd & (((U32_WMV)0xffffffff)>>(32-excessBits)); // take excessBits LSB's
#else
      cwd          = cwd & GetMask_WMV[excessBits]; // take excessBits LSB's
#endif
      length       = excessBits;
      currDecTable = pThis->m_tableInfo[tableNum].table;
    }
  }
}

#ifndef OPT_HUFFMAN_GET_WMV

inline U32_WMV BS_showBitsInline(CInputBitStream_WMV * pThis, register U32_WMV dwNumBits){

//    inline I32_WMV igetMaxBits (register U32_WMV dwNumBits, I32_WMV* rgCodeSym, U8_WMV* rgCodeSize) {
        I32_WMV iBitPattern;
        I32_WMV iTmp;

//      //assert ( dwNumBits <=16);
        //if (m_fEof == FALSE && ((U32_WMV) (m_cbBuflen << 3) >= dwNumBits || m_dwBitsLeft + (m_cbBuflen << 3) >= dwNumBits)) {
        if (dwNumBits <= pThis->m_dwBitsLeft) {
            iBitPattern = ((pThis->m_dwDot >> (pThis->m_dwBitsLeft - dwNumBits)) & GetMask_WMV[dwNumBits]); //0x00000fff;
//            m_dwBitsLeft -= rgCodeSize[iBitPattern];
//          if (rgCodeSym [iBitPattern] == 255)
//              m_fStreamStaus = ILLEGAL_PATTERN;
            return iBitPattern;
        }
//
// The next most common case is when we have lots of data left in the buffer.
// and we can fully load (i.e., all 32-bits) our accumulator.  This is
// hard-wired to allow an optimizer to go crazy with all of the constants.
// Note that the data is byte-swapped on the way in.
//
        U32_WMV dwBitsLeft = pThis->m_dwBitsLeft;
        if (pThis->m_cbBuflen >= 2) {
            iTmp = pThis->m_dwDot << 16;
            //m_dwDot <<= 16;
            iTmp |= (U32_WMV)(pThis->m_pBuffer[1]);
            iTmp |= (U32_WMV)(pThis->m_pBuffer[0]) << 8;
//            m_pBuffer += 2;
//            m_cbBuflen -= 2;
            dwBitsLeft += 16;
            iBitPattern = ((iTmp >> (dwBitsLeft - dwNumBits)) & GetMask_WMV[dwNumBits]);
            return iBitPattern;
        }
//
//
        iTmp = pThis->m_dwDot; 
        if (pThis->m_cbBuflen) {
#ifndef _CASIO_VIDEO_
            assert(pThis->m_cbBuflen==1);
#endif
            iTmp <<= 8;
            iTmp |= *pThis->m_pBuffer;
            //--m_cbBuflen;
            dwBitsLeft += 8;
        }

        if (dwBitsLeft >= dwNumBits){ 
            iBitPattern = ((iTmp >> (dwBitsLeft - dwNumBits)) & GetMask_WMV[dwNumBits]);
            return iBitPattern;
        }
        else {
            iBitPattern = (iTmp & GetMask_WMV[dwBitsLeft]) << (dwNumBits - dwBitsLeft);
            return iBitPattern;
        }
}
inline Void_WMV BS_flushBitsInline(CInputBitStream_WMV * pThis, register U32_WMV dwNumBits){
//      //assert ( dwNumBits <=16);
        //if (m_fEof == FALSE && ((U32_WMV) (m_cbBuflen << 3) >= dwNumBits || m_dwBitsLeft + (m_cbBuflen << 3) >= dwNumBits)) {
//
#if DBG
g_TotalBits += dwNumBits;
#endif DBG

        if (dwNumBits <= pThis->m_dwBitsLeft) {
            pThis->m_dwBitsLeft -= dwNumBits;
            return; 
        }
//
// The next most common case is when we h ave lots of data left in the buffer.
// and we can fully load (i.e., all 32-bits) our accumulator.  This is
// hard-wired to allow an optimizer to go crazy with all of the constants.
// Note that the data is byte-swapped on the way in.
//
#ifdef __STREAMING_MODE_DECODE_
        if (pThis->m_cbBuflen <= 4 && pThis->m_bNotEndOfFrame) {
            if (!WMVDecCBGetDataWithPadding(pThis))
                return;
        }
#endif

        if (pThis->m_cbBuflen >= 2) {
            pThis->m_dwDot <<= 16;
            pThis->m_dwDot |= (U32_WMV)(pThis->m_pBuffer[1]);
            pThis->m_dwDot |= (U32_WMV)(pThis->m_pBuffer[0]) << 8;
            pThis->m_pBuffer += 2;
            pThis->m_cbBuflen -= 2;
            pThis->m_dwBitsLeft += 16;
//          iBitPattern = ((m_dwDot >> (m_dwBitsLeft - dwNumBits)) & GetMask[dwNumBits]);
            pThis->m_dwBitsLeft -= dwNumBits;
            return;
        }
//
//
        for (; pThis->m_cbBuflen;) {
            pThis->m_dwDot <<= 8;
            pThis->m_dwDot |= *pThis->m_pBuffer++;
            --pThis->m_cbBuflen;
            pThis->m_dwBitsLeft += 8;
        }
        if (pThis->m_dwBitsLeft >= dwNumBits){ 
//          iBitPattern = ((m_dwDot >> (m_dwBitsLeft - dwNumBits)) & GetMask[dwNumBits]);
            pThis->m_dwBitsLeft -= dwNumBits;
            return;
        }
        else {
//          iBitPattern = (m_dwDot & GetMask[m_dwBitsLeft]) << (dwNumBits - m_dwBitsLeft);
            pThis->m_fStreamStaus = END_OF_FILE;
            return;
//          return 255;
            }
}

#endif
I32_WMV getHuffman(CInputBitStream_WMV *bs, void * pHuffman);

#ifndef OPT_HUFFMAN_GET_WMV

I32_WMV Huffman_WMV_get(Huffman_WMV * pThis, CInputBitStream_WMV *bs)
{
  //if (m_maxCodeLength == 0) {
  //    return 0; // CHECKCHECK
  //}
// #define OPTIMIZE_HUFFMAN_GET

  I32_WMV index, tableNum;
  HuffDecInfo *decTable;
  HUFFMANGET_DEBUG_ONLY( I32_WMV cCount = 1 );
 
  tableNum = 0;
  decTable = pThis->m_decInfo;
  while (true) { 
    index = BS_showBitsInline(bs, pThis->m_tableInfo[tableNum].bits);
    HUFFMANGET_DBG_CACHE(decTable,index,sizeof(HuffDecInfo));
    if (decTable[index].length > 0) {
      BS_flushBitsInline(bs, decTable[index].length);

      HUFFMANGET_DBG_DMP((I32_WMV)decTable[index].symbol,decTable,index,cCount);
      assert((I32_WMV)decTable[index].symbol >= 0);
      return ((I32_WMV)decTable[index].symbol);
    }
    else if (decTable[index].length == 0) {
        BS_flushBitsInline(bs, pThis->m_tableInfo[tableNum].bits);
        tableNum = decTable[index].symbol;
        decTable = pThis->m_tableInfo[tableNum].table;
        HUFFMANGET_DEBUG_ONLY( cCount++ );
    }
    else {
        // bad node -- mpeg4 table is sparsely populated...
        BS_setInvalid(bs);
        return 0;
    }
  }
#ifndef _CASIO_VIDEO_
  assert(false);
#endif
  HUFFMANGET_DBG_DMP(0,decTable,0,0);
  return 0;

}

#endif

// #define  BS_mask      GetMask

#ifdef OPT_HUFFMAN_GET_WMV

//int dbg_cnt2,dbg_cnt3;

//I32_WMV gethuffman_end(CInputBitStream *bs, void *decTable, I32_WMV &nextbits_shift,I32_WMV & currBits,I32_WMV & numBits,I32_WMV & numBits2, I32_WMV & bitsOver, I32_WMV & wBitsLeft, I32_WMV & result, I32_WMV & index);

#ifndef _EMB_ASM_ARM_STRMHUFF_
U32_WMV getHuffman(CInputBitStream_WMV *bs,TableInfo *tableInfo, HuffDecInfo *decTable)
{
  I32_WMV index, tableNum, numBits, numBits2, bitsOver;  
  register I32_WMV wBitsLeft,   minus1=-1;
  wBitsLeft=bs->m_BMS8.m_wBitsLeft;
  numBits = tableInfo[0].bits;

EndlessLoop:   
  // showBits

 
  bitsOver = wBitsLeft - numBits ;
  if (bitsOver < 0) 
  {
    

      bs->m_BMS8.m_wBitsLeft=wBitsLeft;
      BS_updateCurrNext(bs);
      wBitsLeft=bs->m_BMS8.m_wBitsLeft;

      bitsOver = wBitsLeft - numBits ;
      if(bitsOver<0)
      {
        index=bs->m_currBits<<(-bitsOver);
        
      }
      else
        index = (bs->m_currBits >> (bitsOver));
  }
  else 
  {
     
     index = (bs->m_currBits >> (bitsOver)); 
  }

  index&=(((U32_WMV)0xffffffff)>>(32-numBits));
  
  numBits2 = decTable[index].length;
  if (numBits2 != 0) 
  {
    // Flush Bits

    bs->m_BMS8.m_wBitsLeft= wBitsLeft-numBits2;

    return (I32_WMV)decTable[index].symbol;
  }



  wBitsLeft-= numBits;
  
  tableNum  = decTable[index].symbol;
  decTable  = tableInfo[tableNum].table;
  numBits = tableInfo[tableNum].bits;
  goto EndlessLoop;



}

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\huffdec.c ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    HuffDec.cpp

Abstract:

    Huffman decoder. Simplified from Sanjeevm's huffman.cpp

Author:

    Wei-ge Chen (wchen) 19-July-1999

Revision History:


*************************************************************************/

#include "bldsetup.h"

#include <stdio.h>
#include <stdlib.h>
#include "macros.h"
#include "huffdec.h"

#ifdef PROFILE
#include "autoprofile.h"
#endif


WMARESULT huffDecGet(const U16 *pDecodeTable, CWMAInputBitStream *bs,
                     U32* puBitCnt, U32 *puResult, U32* puSign)
{
     const int FIRST_LOAD = 10;
     const int SECOND_LOAD = 12;

     unsigned int ret_value;
     const unsigned short* node_base = pDecodeTable;

     U32 uBits;
     U32 codeword;
     int i;

     WMARESULT  wmaResult;
#ifdef PROFILE
	 //profiling a function that gets called this often has too much overhead.
     //FunctionProfile fp;
     //FunctionProfileStart(&fp,HUFF_DEC_GET_PROFILE);
#endif

     TRACEWMA_EXIT(wmaResult, (*(bs->ibstrmpfnPeekBits))(bs, FIRST_LOAD + SECOND_LOAD + 1, &uBits));
     codeword = uBits;

     // Do first five 2-bit tables
     i = 5;
     do
     {
         node_base += ((codeword & 0xC0000000) >> 30);  // Use top 2 bits as offset
         ret_value = *node_base;
         if (ret_value & 0x8000)
             goto decode_complete;  // Found a leaf node!

         node_base += ret_value;    // No leaf node, follow the offset
         codeword <<= 2;            // Advance to next 2 bits
         i -= 1;
     } while (i > 0);

     // Do remaining three 2-bit tables
     i = 3;
     do
     {
         node_base += ((codeword & 0xC0000000) >> 30);  // Use top 2 bits as offset
         ret_value = *node_base;
         if (ret_value & 0x8000)
             goto decode_complete;  // Found a leaf node!

         node_base += ret_value;    // No leaf node, follow the offset
         codeword <<= 2;            // Advance to next 2 bits
         i -= 1;
     } while (i > 0);

     // Do six 1-bit tables
     i = 6;
     do
     {
         node_base += ((codeword & 0x80000000) >> 31);  // Use top bit as offset
         ret_value = *node_base;
         if (ret_value & 0x8000)
             goto decode_complete;  // Found a leaf node!

         node_base += ret_value;    // No leaf node, follow the offset
         codeword <<= 1;            // Advance to next bit
         i -= 1;
     } while (i > 0);


decode_complete:
     assert(ret_value & 0x8000);
     *puBitCnt = ((ret_value >> 10) & (0x0000001F));
     *puResult = ret_value & 0x000003FF;
     if (*puResult >= 0x03FC)
         *puResult = *(node_base + (*puResult & 0x0003) + 1);
     
     if (puSign != NULL)
        *puSign = uBits << *puBitCnt;

exit:
#ifdef PROFILE
    //FunctionProfileStop(&fp);
#endif
     return wmaResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\init_wmv.cpp ===
#include "bldsetup.h"

#include <stdlib.h>
#include <stdio.h>
#include "xplatform.h"
#include "limits.h"
#include "typedef.hpp"
#include "wmvdec_member.h"
#ifdef _WMV_TARGET_X86_
#include "cpudetect.h"
#endif // _WMV_TARGET_X86_
#include "tables_wmv.h"

#include "strmdec_wmv.hpp"
#include "motioncomp_wmv.h"
#include "idctdec_wmv2.h"
#include "repeatpad_wmv.h"
#include "postfilter_wmv.hpp"

#include "spatialpredictor_wmv.hpp"
#include "localhuffman_wmv.h"
#include "tables_wmv.h"
#include "wmvdec_function.h"

#define setTable(																\
		vlcTableInfo,															\
		hufDec_DCTAC,															\
		iTCOEF_ESCAPE,															\
		iNUMOFCODESINNOTLASTMinus1,												\
        igrgLevelAtIndx_HghMt,													\
        igrgRunAtIndx_HghMt,													\
		igrgIfNotLastNumOfLevelAtRun,											\
		igrgIfLastNumOfLevelAtRun,												\
		igrgIfNotLastNumOfRunAtLevel,											\
		igrgIfLastNumOfRunAtLevel												\
		)																		\
		vlcTableInfo.hufDCTACDec = hufDec_DCTAC;								\
		vlcTableInfo.iTcoef_ESCAPE = iTCOEF_ESCAPE;								\
		vlcTableInfo.iStartIndxOfLastRunMinus1 = iNUMOFCODESINNOTLASTMinus1;	\
		vlcTableInfo.pcLevelAtIndx = igrgLevelAtIndx_HghMt;						\
		vlcTableInfo.puiRunAtIndx = igrgRunAtIndx_HghMt;						\
		vlcTableInfo.puiNotLastNumOfLevelAtRun = igrgIfNotLastNumOfLevelAtRun;	\
		vlcTableInfo.puiLastNumOfLevelAtRun = igrgIfLastNumOfLevelAtRun;		\
		vlcTableInfo.puiNotLastNumOfRunAtLevel = igrgIfNotLastNumOfRunAtLevel;	\
		vlcTableInfo.puiLastNumOfRunAtLevel = igrgIfLastNumOfRunAtLevel;		\


#define UVTCOEF_ESCAPE_HghMt 168							
#define NUMOFCODESINNOTLASTINTERMinus1_HghMt 98
#define TCOEF_ESCAPEINTRAY_HghMt 185							
#define NUMOFCODESINNOTLASTINTRAMinus1_HghMt 118

#define UVTCOEF_ESCAPE_Talking 148							
#define NUMOFCODESINNOTLASTINTERMinus1_Talking 80
#define TCOEF_ESCAPEINTRAY_Talking 132							
#define NUMOFCODESINNOTLASTINTRAMinus1_Talking 84

#define UVTCOEF_ESCAPE_MPEG4 102							
#define NUMOFCODESINNOTLASTINTERMinus1_MPEG4 57
#define TCOEF_ESCAPEINTRAY_MPEG4 102
#define NUMOFCODESINNOTLASTINTRAMinus1_MPEG4 66

//I32_WMV sm_iIDCTDecCount = 0;


Void_WMV setVlcTableInfo(tWMVDecInternalMember *pWMVDec)
{
	/// Set tables for High Motion
    setTable(
		pWMVDec->InterDCTTableInfo_Dec_HghMt,
		&pWMVDec->m_hufDCTACInterDec_HghMt,
		UVTCOEF_ESCAPE_HghMt,
		NUMOFCODESINNOTLASTINTERMinus1_HghMt,
		//STARTINDEXOFLASTRUN_HghMt, 
        sm_rgLevelAtIndx_HghMt, 
        sm_rgRunAtIndx_HghMt, 
		sm_rgIfNotLastNumOfLevelAtRun_HghMt,
		sm_rgIfLastNumOfLevelAtRun_HghMt,
		sm_rgIfNotLastNumOfRunAtLevel_HghMt,
		sm_rgIfLastNumOfRunAtLevel_HghMt
		);

    setTable(
		pWMVDec->IntraDCTTableInfo_Dec_HghMt,
		&pWMVDec->m_hufDCTACIntraDec_HghMt,
		TCOEF_ESCAPEINTRAY_HghMt,
		NUMOFCODESINNOTLASTINTRAMinus1_HghMt,
		//STARTINDEXOFLASTRUN_HghMt, 
        sm_rgLevelAtIndxOfIntraY_HghMt, 
        sm_rgRunAtIndxOfIntraY_HghMt, 
		sm_rgIfNotLastNumOfLevelAtRunIntraY_HghMt,
		sm_rgIfLastNumOfLevelAtRunIntraY_HghMt,
		sm_rgIfNotLastNumOfRunAtLevelIntraY_HghMt,
		sm_rgIfLastNumOfRunAtLevelIntraY_HghMt
		);

	/// Set tables for Talking head
    setTable(
		pWMVDec->InterDCTTableInfo_Dec_Talking,
		&pWMVDec->m_hufDCTACInterDec_Talking,
		UVTCOEF_ESCAPE_Talking,
		NUMOFCODESINNOTLASTINTERMinus1_Talking,
		//STARTINDEXOFLASTRUN_Talking, 
        sm_rgLevelAtIndx_Talking, 
        sm_rgRunAtIndx_Talking, 
		sm_rgIfNotLastNumOfLevelAtRun_Talking,
		sm_rgIfLastNumOfLevelAtRun_Talking,
		sm_rgIfNotLastNumOfRunAtLevel_Talking,
		sm_rgIfLastNumOfRunAtLevel_Talking
		);

    setTable(
		pWMVDec->IntraDCTTableInfo_Dec_Talking,
		&pWMVDec->m_hufDCTACIntraDec_Talking,
		TCOEF_ESCAPEINTRAY_Talking,
		NUMOFCODESINNOTLASTINTRAMinus1_Talking,
		//STARTINDEXOFLASTRUN_Talking, 
        sm_rgLevelAtIndxOfIntraY_Talking, 
        sm_rgRunAtIndxOfIntraY_Talking, 
		sm_rgIfNotLastNumOfLevelAtRunIntraY_Talking,
		sm_rgIfLastNumOfLevelAtRunIntraY_Talking,
		sm_rgIfNotLastNumOfRunAtLevelIntraY_Talking,
		sm_rgIfLastNumOfRunAtLevelIntraY_Talking
		);

	/// Set tables for MPEG4
    setTable(
		pWMVDec->InterDCTTableInfo_Dec_MPEG4,
		&pWMVDec->m_hufDCTACInterDec_MPEG4,
		UVTCOEF_ESCAPE_MPEG4,
		NUMOFCODESINNOTLASTINTERMinus1_MPEG4,
		//STARTINDEXOFLASTRUN_MPEG4, 
        sm_rgLevelAtIndx_MPEG4, 
        sm_rgRunAtIndx_MPEG4, 
		sm_rgIfNotLastNumOfLevelAtRun_MPEG4,
		sm_rgIfLastNumOfLevelAtRun_MPEG4,
		sm_rgIfNotLastNumOfRunAtLevel_MPEG4,
		sm_rgIfLastNumOfRunAtLevel_MPEG4
		);

    setTable(
		pWMVDec->IntraDCTTableInfo_Dec_MPEG4,
		&pWMVDec->m_hufDCTACIntraDec_MPEG4,
		TCOEF_ESCAPEINTRAY_MPEG4,
		NUMOFCODESINNOTLASTINTRAMinus1_MPEG4,
		//STARTINDEXOFLASTRUN_MPEG4, 
        sm_rgLevelAtIndxOfIntraY_MPEG4, 
        sm_rgRunAtIndxOfIntraY_MPEG4, 
		sm_rgIfNotLastNumOfLevelAtRunIntraY_MPEG4,
		sm_rgIfLastNumOfLevelAtRunIntraY_MPEG4,
		sm_rgIfNotLastNumOfRunAtLevelIntraY_MPEG4,
		sm_rgIfLastNumOfRunAtLevelIntraY_MPEG4
		);

	pWMVDec->m_pInterDCTTableInfo_Dec_Set[0] = &pWMVDec->InterDCTTableInfo_Dec_Talking;
	pWMVDec->m_pInterDCTTableInfo_Dec_Set[1] = &pWMVDec->InterDCTTableInfo_Dec_HghMt;
	pWMVDec->m_pInterDCTTableInfo_Dec_Set[2] = &pWMVDec->InterDCTTableInfo_Dec_MPEG4;



	pWMVDec->m_pIntraDCTTableInfo_Dec_Set[0] = &pWMVDec->IntraDCTTableInfo_Dec_Talking;
	pWMVDec->m_pIntraDCTTableInfo_Dec_Set[1] = &pWMVDec->IntraDCTTableInfo_Dec_HghMt;
	pWMVDec->m_pIntraDCTTableInfo_Dec_Set[2] = &pWMVDec->IntraDCTTableInfo_Dec_MPEG4;

    pWMVDec->m_pHufDCTDCDec_Set[0] = &pWMVDec->m_hufDCTDCyDec_Talking;
    pWMVDec->m_pHufDCTDCDec_Set[1] = &pWMVDec->m_hufDCTDCcDec_Talking;
    pWMVDec->m_pHufDCTDCDec_Set[2] = &pWMVDec->m_hufDCTDCyDec_HghMt;
    pWMVDec->m_pHufDCTDCDec_Set[3] = &pWMVDec->m_hufDCTDCcDec_HghMt;


	pWMVDec->m_pHufMVDec_Set[0] = &pWMVDec->m_hufMVDec_Talking;
	pWMVDec->m_pHufMVDec_Set[1] = &pWMVDec->m_hufMVDec_HghMt;
	pWMVDec->m_puMvFromIndex_Set[0] = sm_uXMvFromIndex_Talking;
	pWMVDec->m_puMvFromIndex_Set[1] = sm_uYMvFromIndex_Talking;
	pWMVDec->m_puMvFromIndex_Set[2] = sm_uXMvFromIndex_HghMt;
	pWMVDec->m_puMvFromIndex_Set[3] = sm_uYMvFromIndex_HghMt;

}

Void_WMV freeFrame(tYUV420Frame_WMV* pFrm)
{
    FREE_PTR(pFrm->m_pucYPlane_Unaligned);
    FREE_PTR(pFrm->m_pucUPlane_Unaligned);
    FREE_PTR(pFrm->m_pucVPlane_Unaligned);
    FREE_PTR(pFrm);
}

#if defined(WANT_HEAP_MEASURE)
#   define DEBUG_HEAP_SUB_FRAME(a)                                          \
    {                                                                       \
        I32_WMV iWidthMBAligned = (pWMVDec->m_iFrmWidthSrc + 15) & ~15;     \
        I32_WMV iHeightMBAligned = (pWMVDec->m_iFrmHeightSrc + 15) & ~15;   \
        I32_WMV iSizeYplane = (iWidthMBAligned + EXPANDY_REFVOP * 2) * (iHeightMBAligned + EXPANDY_REFVOP * 2);                     \
        I32_WMV iSizeUVplane = ((iWidthMBAligned >> 1) + EXPANDUV_REFVOP * 2) * ((iHeightMBAligned  >> 1)+ EXPANDUV_REFVOP * 2);    \
        DEBUG_HEAP_SUB( 0, a * sizeof(tYUV420Frame_WMV) );                                                                             \
        DEBUG_HEAP_SUB( 1, a * (((iSizeYplane + 32)*sizeof(U8_WMV)) + 2*((iSizeUVplane + 32) * sizeof (U8_WMV)) ) );                \
    }
#else
#   define DEBUG_HEAP_SUB_FRAME(a)
#endif


tWMVDecodeStatus  VodecDestruct (tWMVDecInternalMember *pWMVDec)
{
    FREE_PTR(pWMVDec -> m_pInputBitstream);
    DEBUG_HEAP_SUB( 0, sizeof(CInputBitStream_WMV));
    freeFrame (pWMVDec->m_pfrmCurrQ);
    freeFrame (pWMVDec->m_pfrmPrev);
    DEBUG_HEAP_SUB_FRAME(2);
#ifdef _SUPPORT_POST_FILTERS_
    freeFrame (pWMVDec->m_pfrmPostQ);
    DEBUG_HEAP_SUB_FRAME(1);
#endif
    DELETE_ARRAY (pWMVDec->m_rgmv);
    DELETE_ARRAY (pWMVDec->m_rgmbmd);
    DELETE_PTR (pWMVDec->m_pmbmdZeroCBPCY);
    DELETE_ARRAY (pWMVDec->m_pAvgQuanDctCoefDec);
    DELETE_ARRAY (pWMVDec->m_pAvgQuanDctCoefDecC);
    DELETE_ARRAY (pWMVDec->m_pAvgQuanDctCoefDecLeft);
    DELETE_ARRAY (pWMVDec->m_pAvgQuanDctCoefDecTop);
    DEBUG_HEAP_SUB( 0, (pWMVDec->m_uintNumMBX * 2 * sizeof(CVector)) 
                  + (pWMVDec->m_uintNumMB * sizeof(CWMVMBMode)) 
                  + sizeof(CWMVMBMode) 
                  + (4 * BLOCK_SIZE_TIMES2 * sizeof(I16_WMV)) );

    DELETE_ARRAY (pWMVDec->m_rgiQuanCoefACPred);
    DELETE_ARRAY (pWMVDec->m_rgiQuanCoefACPredTable);
    DELETE_ARRAY (pWMVDec->m_rgchSkipPrevFrame);
    pWMVDec->m_pBMPBits = NULL_WMV;
    DEBUG_HEAP_SUB( 0, (pWMVDec->m_uintNumMBX * 2 * BLOCK_SIZE_TIMES2_TIMES6 * sizeof(I16_WMV))
                  + (pWMVDec->m_uintNumMBX * 2  * 36 * sizeof(I16_WMV*)) 
                  + (pWMVDec->m_uintNumMB*sizeof(U8_WMV)) );

    DEBUG_HEAP_SUB(g_iHeapLastClass,0);  // indicate the following huffman tables are localHuffman

    t_AltTablesDecoderDestruct (pWMVDec->m_pAltTables);
    t_SpatialPredictorDestruct (pWMVDec->m_pSp);
    t_ContextWMVDestruct (pWMVDec->m_pContext);

    DEBUG_HEAP_SUB(DHEAP_HUFFMAN,0);  // indicate the following huffman tables are regular tables (non-localHuffman)

    Huffman_WMV_destruct(&pWMVDec->m_hufMVDec_Talking);
    Huffman_WMV_destruct(&pWMVDec->m_hufMVDec_HghMt);

    Huffman_WMV_destruct(&pWMVDec->m_hufDCTDCyDec_Talking);
    Huffman_WMV_destruct(&pWMVDec->m_hufDCTDCcDec_Talking);

    Huffman_WMV_destruct(&pWMVDec->m_hufDCTDCyDec_HghMt);
    Huffman_WMV_destruct(&pWMVDec->m_hufDCTDCcDec_HghMt);

    Huffman_WMV_destruct(&pWMVDec->m_hufICBPCYDec);
    Huffman_WMV_destruct(&pWMVDec->m_hufPCBPCYDec);

    Huffman_WMV_destruct(&pWMVDec->m_hufPCBPCYDec_HighRate);
    Huffman_WMV_destruct(&pWMVDec->m_hufPCBPCYDec_MidRate);
    Huffman_WMV_destruct(&pWMVDec->m_hufPCBPCYDec_LowRate);

    Huffman_WMV_destruct(&pWMVDec->m_hufDCTACInterDec_HghMt);
    Huffman_WMV_destruct(&pWMVDec->m_hufDCTACIntraDec_HghMt);
    Huffman_WMV_destruct(&pWMVDec->m_hufDCTACInterDec_Talking);
    Huffman_WMV_destruct(&pWMVDec->m_hufDCTACIntraDec_Talking);
    Huffman_WMV_destruct(&pWMVDec->m_hufDCTACInterDec_MPEG4);
    Huffman_WMV_destruct(&pWMVDec->m_hufDCTACIntraDec_MPEG4);

    return WMV_Succeeded;

}

Void_WMV InitVars_Tmp(tWMVDecInternalMember *pWMVDec)
{
    pWMVDec->m_t = 0; 
// for _MPEG4_BITSTRM
    pWMVDec->m_tModuloBaseDecd = 0;
    pWMVDec->m_tModuloBaseDisp = 0;
    pWMVDec->m_iNumBitsTimeIncr = 0;
// _MPEG4_BITSTRM
	pWMVDec->m_iMvResolution = 0; 
    pWMVDec->m_bDCTTable_MB_ENABLED= FALSE_WMV; 
	pWMVDec->m_bDCTTable_MB= FALSE_WMV; 
	pWMVDec->m_bDCPred_IMBInPFrame= FALSE_WMV;
    pWMVDec->m_bMixedPel= FALSE_WMV; 
	pWMVDec->m_bLoopFilter= FALSE_WMV; 
	pWMVDec->m_bXformSwitch = FALSE_WMV;
    pWMVDec->m_bSKIPBIT_CODING_= FALSE_WMV; 
	pWMVDec->m_bNEW_PCBPCY_TABLE= FALSE_WMV; 
	pWMVDec->m_bXintra8Switch = FALSE_WMV;
    pWMVDec->m_bXintra8 = FALSE_WMV; 
	pWMVDec->m_bFrmHybridMVOn = FALSE_WMV;

    pWMVDec->m_bRndCtrlOn = FALSE_WMV;
    pWMVDec->m_bDeblockOn = FALSE_WMV; // no deblocking at the beginning
    pWMVDec->m_bDeringOn = FALSE_WMV;
    pWMVDec->m_fPrepared = FALSE_WMV;
    pWMVDec->m_fDecodedI = FALSE_WMV;    // Haven't seen an I-Picture yet.
    pWMVDec->m_rgchSkipPrevFrame = NULL_WMV; pWMVDec->m_rgmv = NULL_WMV;
    pWMVDec->m_pBMPBits = NULL_WMV;
    pWMVDec->m_rgiQuanCoefACPred = NULL_WMV;
    pWMVDec->m_rgiQuanCoefACPredTable= NULL_WMV;
    pWMVDec->m_pAvgQuanDctCoefDec = NULL_WMV;
    pWMVDec->m_pAvgQuanDctCoefDecC = NULL_WMV;
    pWMVDec->m_pAvgQuanDctCoefDecLeft = NULL_WMV;
    pWMVDec->m_pAvgQuanDctCoefDecTop = NULL_WMV;
    pWMVDec->m_rgmbmd = NULL_WMV;
    pWMVDec->m_pmbmdZeroCBPCY = NULL_WMV;
    pWMVDec->m_iPostProcessMode= 0;
    pWMVDec->m_bUseOldSetting= FALSE_WMV;
    pWMVDec->m_iPostFilterLevel= -1;
    pWMVDec->m_iDCTACInterTableIndx= 0;
    pWMVDec->m_iDCTACIntraTableIndx= 0;
    pWMVDec->m_bRefreshDisplay_AllMB_Enable= FALSE_WMV;
    pWMVDec->m_bRefreshDisplay_AllMB= FALSE_WMV;
    pWMVDec->m_iRefreshDisplay_AllMB_Cnt= 0;
    pWMVDec->m_iRefreshDisplay_AllMB_Period= 1000;
    pWMVDec->m_bCopySkipMBToPostBuf = TRUE_WMV;
}

#ifndef _XBOX
Bool_WMV g_bSupportMMX_WMV = 0;
#endif //  _XBOX

tWMVDecodeStatus VodecConstruct (
    tWMVDecInternalMember *pWMVDec,
    U32_WMV               dwFOURCC,
    I32_WMV                 iFrameRate,
    I32_WMV                 iWidthSource,
    I32_WMV                 iHeightSource,
    CInputBitStream_WMV     *pInputBitstream//,
)
{
    VResult vr;
    tWMVDecodeStatus tWMVStatus = WMV_Succeeded;
    I32_WMV maxBits[3];

#ifdef  _WMV_TARGET_X86_
#ifndef _XBOX
    g_bSupportMMX_WMV = g_SupportMMX ();
#endif //  _XBOX
#endif //  _WMV_TARGET_X86_

    //VOConstruct();
	pWMVDec->m_uintNumMBYSlice = 1;
    pWMVDec->m_bCODFlagOn = TRUE_WMV; 
    pWMVDec->m_bFirstEscCodeInFrame= TRUE_WMV; 
	pWMVDec->m_uiNumProcessors= 1;
    //VODecConstruct
    pWMVDec->m_iFrameRate = iFrameRate;

    pWMVDec->m_iRefreshDisplay_AllMB_Period= 1000;
    pWMVDec->m_iPostProcessMode= 0;
    pWMVDec->m_bCopySkipMBToPostBuf = TRUE_WMV;

    Huffman_WMV_construct(&pWMVDec->m_hufMVDec_Talking);
    Huffman_WMV_construct(&pWMVDec->m_hufMVDec_HghMt);

    Huffman_WMV_construct(&pWMVDec->m_hufDCTDCyDec_Talking);
    Huffman_WMV_construct(&pWMVDec->m_hufDCTDCcDec_Talking);

    Huffman_WMV_construct(&pWMVDec->m_hufDCTDCyDec_HghMt);
    Huffman_WMV_construct(&pWMVDec->m_hufDCTDCcDec_HghMt);

    Huffman_WMV_construct(&pWMVDec->m_hufICBPCYDec);
    Huffman_WMV_construct(&pWMVDec->m_hufPCBPCYDec);

    Huffman_WMV_construct(&pWMVDec->m_hufPCBPCYDec_HighRate);
    Huffman_WMV_construct(&pWMVDec->m_hufPCBPCYDec_MidRate);
    Huffman_WMV_construct(&pWMVDec->m_hufPCBPCYDec_LowRate);

    Huffman_WMV_construct(&pWMVDec->m_hufDCTACInterDec_HghMt);
    Huffman_WMV_construct(&pWMVDec->m_hufDCTACIntraDec_HghMt);
    Huffman_WMV_construct(&pWMVDec->m_hufDCTACInterDec_Talking);
    Huffman_WMV_construct(&pWMVDec->m_hufDCTACIntraDec_Talking);
    Huffman_WMV_construct(&pWMVDec->m_hufDCTACInterDec_MPEG4);
    Huffman_WMV_construct(&pWMVDec->m_hufDCTACIntraDec_MPEG4);

    InitVars_Tmp(pWMVDec);



    if (dwFOURCC == FOURCC_WMV2_WMV || dwFOURCC == FOURCC_wmv2_WMV)
        pWMVDec->m_cvCodecVersion = WMV2;
    else if (dwFOURCC == FOURCC_WMV1_WMV || dwFOURCC == FOURCC_wmv1_WMV)
        pWMVDec->m_cvCodecVersion = WMV1;
    else if (dwFOURCC == FOURCC_MP43_WMV || dwFOURCC == FOURCC_mp43_WMV)
        pWMVDec->m_cvCodecVersion = MP43;
    else if (dwFOURCC == FOURCC_MP42_WMV || dwFOURCC == FOURCC_mp42_WMV)
        pWMVDec->m_cvCodecVersion = MP42;
    else if (dwFOURCC == FOURCC_MP4S_WMV || dwFOURCC == FOURCC_mp4s_WMV)
        pWMVDec->m_cvCodecVersion = MP4S;
//    else if (dwFOURCC == FOURCC_MPG4 || dwFOURCC == FOURCC_mpg4)
//        pWMVDec->m_cvCodecVersion = WMV2;
    {
#if !defined(NO_WINDOWS) && defined(_MultiThread_Decode_)  
    SYSTEM_INFO sysinfo;
    GetSystemInfo (&sysinfo);
    pWMVDec->m_uiNumProcessors = sysinfo.dwNumberOfProcessors;
#else
	pWMVDec->m_uiNumProcessors = 1;
#endif
    }

#if defined (CALC_SNR)
    pWMVDec->m_uiNumProcessors = 1;  // implemented for only one processor
#endif

    if (pWMVDec->m_uiNumProcessors == 3)
        pWMVDec->m_uiNumProcessors = 2;
    if (pWMVDec->m_uiNumProcessors > 4)
        pWMVDec->m_uiNumProcessors = 4;
pWMVDec->m_uiNumProcessors = 1;


    g_InitDecGlobalVars ();
    decideMMXRoutines (pWMVDec);
    m_InitFncPtrAndZigzag(pWMVDec);
    tWMVStatus = InitDataMembers (pWMVDec, iWidthSource, iHeightSource);

	if (tWMVStatus != WMV_Succeeded) {
		return tWMVStatus;
	}

    pWMVDec->m_pbitstrmIn = pInputBitstream;

    // Set 32-byte aligned pointers to IDCT recon coeff and pixel error buffers
    pWMVDec->m_ppxliErrorQ = (Buffer *)(((I32_WMV)pWMVDec->m_riPixelError + 31) & ~31);
    pWMVDec->m_rgiCoefReconBuf = (Buffer *)(((I32_WMV)pWMVDec->m_riReconBuf + 31) & ~31);
    pWMVDec->m_rgiCoefRecon = (PixelI32 *)pWMVDec->m_rgiCoefReconBuf;

    pWMVDec->m_rgiCoefReconPlus1 = &pWMVDec->m_rgiCoefRecon[1];
    pWMVDec->m_iStepSize = 0;

    pWMVDec->m_pMotionComp = pWMVDec->m_pMotionCompUV = pWMVDec->m_pMotionCompRndCtrlOff;
    pWMVDec->m_pMotionCompAndAddError = pWMVDec->m_pMotionCompAndAddErrorUV = pWMVDec->m_pMotionCompAndAddErrorRndCtrlOff;
	
#ifdef DYNAMIC_EDGEPAD                
    pWMVDec->m_iMotionCompRndCtrl=VECTORIZE_MOTIONCOMP_RNDCTRL_OFF;
    pWMVDec->m_tEdgePad.m_iround_ctrl=pWMVDec->m_iMotionCompRndCtrl;
#endif
    
    //_MV

    DEBUG_HEAP_ADD(DHEAP_HUFFMAN,0);  // indicate these huffman tables are regular tables (non-localHuffman)

    maxBits[0] = 6,  maxBits[1] = 5,  maxBits[2] = 6;
    vr = Huffman_WMV_init(&pWMVDec->m_hufMVDec_Talking, pWMVDec->m_uiUserData, sm_HufMVTable_Talking, maxBits, 3);
    if (vr.failed()) goto lerror;

    maxBits[0] = 5,  maxBits[1] = 5,  maxBits[2] = 5;
    vr = Huffman_WMV_init(&pWMVDec->m_hufMVDec_HghMt, pWMVDec->m_uiUserData, sm_HufMVTable_HghMt, maxBits, 3);
    if (vr.failed()) goto lerror;

    maxBits[0] = 6,  maxBits[1] = 3,  maxBits[2] = 4;
    vr = Huffman_WMV_init(&pWMVDec->m_hufICBPCYDec,pWMVDec->m_uiUserData, sm_HufICBPCYTable, maxBits, 3);
    if (vr.failed()) goto lerror;

    maxBits[0] = 7; maxBits[1] = 6; maxBits[2] = 8;
    vr = Huffman_WMV_init(&pWMVDec->m_hufPCBPCYDec, pWMVDec->m_uiUserData, sm_HufPCBPCYTable, maxBits, 3);
    if (vr.failed()) goto lerror;

    //NEW_PCBPCY_TABLE
    maxBits[0] = 9; maxBits[1] = 7; maxBits[2] = 8;
    vr = Huffman_WMV_init(&pWMVDec->m_hufPCBPCYDec_HighRate, pWMVDec->m_uiUserData, sm_HufPCBPCYTable_HighRate, maxBits, 3);
    if (vr.failed()) goto lerror;

    maxBits[0] = 7; maxBits[1] = 6; maxBits[2] = 7;
    vr = Huffman_WMV_init(&pWMVDec->m_hufPCBPCYDec_MidRate, pWMVDec->m_uiUserData, sm_HufPCBPCYTable_MidRate, maxBits, 3);
    if (vr.failed()) goto lerror;
    
    maxBits[0] = 6; maxBits[1] = 6; maxBits[2] = 5;
    vr = Huffman_WMV_init(&pWMVDec->m_hufPCBPCYDec_LowRate, pWMVDec->m_uiUserData, sm_HufPCBPCYTable_LowRate, maxBits, 3);
    if (vr.failed()) goto lerror;

	//_DCTDC
    maxBits[0] = 8; maxBits[1] = 8; maxBits[2] = 8;
    vr = Huffman_WMV_init(&pWMVDec->m_hufDCTDCyDec_Talking, pWMVDec->m_uiUserData, sm_HufDCTDCyTable_Talking, maxBits, 3);
    if (vr.failed()) goto lerror;

    maxBits[0] = 8; maxBits[1] = 7; maxBits[2] = 8;
    vr = Huffman_WMV_init(&pWMVDec->m_hufDCTDCcDec_Talking, pWMVDec->m_uiUserData, sm_HufDCTDCcTable_Talking, maxBits, 3);
    if (vr.failed()) goto lerror;

    maxBits[0] = 9; maxBits[1] = 9; maxBits[2] = 8;    
    vr = Huffman_WMV_init(&pWMVDec->m_hufDCTDCyDec_HghMt, pWMVDec->m_uiUserData, sm_HufDCTDCyTable_HghMt, maxBits, 3);
    if (vr.failed()) goto lerror;

    maxBits[0] = 9; maxBits[1] = 8; maxBits[2] = 8;    
    vr = Huffman_WMV_init(&pWMVDec->m_hufDCTDCcDec_HghMt, pWMVDec->m_uiUserData, sm_HufDCTDCcTable_HghMt, maxBits, 3);
    if (vr.failed()) goto lerror;
	// _DCTAC
    maxBits[0] = 6,  maxBits[1] = 5,  maxBits[2] = 4;
	vr = Huffman_WMV_init(&pWMVDec->m_hufDCTACInterDec_HghMt, pWMVDec->m_uiUserData, sm_HufDCTACInterTable_HghMt, maxBits, 3);
    if (vr.failed()) goto lerror;

    maxBits[0] = 7; maxBits[1] = 4; maxBits[2] = 4;
	vr = Huffman_WMV_init(&pWMVDec->m_hufDCTACIntraDec_HghMt, pWMVDec->m_uiUserData, sm_HufDCTACIntraTable_HghMt, maxBits, 3);
    if (vr.failed()) goto lerror;

    maxBits[0] = 7; maxBits[1] = 4; maxBits[2] = 4;
	vr = Huffman_WMV_init(&pWMVDec->m_hufDCTACInterDec_Talking, pWMVDec->m_uiUserData, sm_HufDCTACInterTable_Talking, maxBits, 3);
    if (vr.failed()) goto lerror;

    maxBits[0] = 5; maxBits[1] = 4; maxBits[2] = 4;
	vr = Huffman_WMV_init(&pWMVDec->m_hufDCTACIntraDec_Talking, pWMVDec->m_uiUserData, sm_HufDCTACIntraTable_Talking, maxBits, 3);
    if (vr.failed()) goto lerror;

    maxBits[0] = 3; maxBits[1] = 6; maxBits[2] = 3;
	vr = Huffman_WMV_init(&pWMVDec->m_hufDCTACInterDec_MPEG4, pWMVDec->m_uiUserData, sm_HufDCTACInterTable_MPEG4, maxBits, 3);
    if (vr.failed()) goto lerror;

    maxBits[0] = 3; maxBits[1] = 6; maxBits[2] = 3;
	vr = Huffman_WMV_init(&pWMVDec->m_hufDCTACIntraDec_MPEG4, pWMVDec->m_uiUserData, sm_HufDCTACIntraTable_MPEG4, maxBits, 3);
    if (vr.failed()) goto lerror;


    pWMVDec->m_pAltTables = t_AltTablesDecoderConstruct (pWMVDec->m_uiUserData);
    if (pWMVDec->m_pAltTables == NULL_WMV)
        goto lerror;
    // Construct spatial predictor
    pWMVDec->m_pSp = t_SpatialPredictorConstruct ();
    if (!pWMVDec->m_pSp)
        goto lerror;

    // Construct contexts, and DCT array
    pWMVDec->m_pContext = t_ContextWMVConstruct (pWMVDec->m_uintNumMBX*2, 2);  // 2 rows enough
    if (!pWMVDec->m_pContext)
        goto lerror;

	setVlcTableInfo(pWMVDec);
    return WMV_Succeeded;

lerror:
    return WMV_BadMemory;
}


Void_WMV computePars (tWMVDecInternalMember *pWMVDec)
{
    if (pWMVDec->m_cvCodecVersion != MP4S) {
        pWMVDec->m_iWidthYRepeatPad = pWMVDec->m_iWidthY;
        pWMVDec->m_iWidthUVRepeatPad = pWMVDec->m_iWidthUV;
        pWMVDec->m_iHeightYRepeatPad = pWMVDec->m_iHeightY;
        pWMVDec->m_iHeightUVRepeatPad = pWMVDec->m_iHeightUV;
    }
    else {
        pWMVDec->m_iWidthYRepeatPad = pWMVDec->m_iFrmWidthSrc;
        pWMVDec->m_iWidthUVRepeatPad = pWMVDec->m_iFrmWidthSrc/2;
        pWMVDec->m_iHeightYRepeatPad = pWMVDec->m_iFrmHeightSrc;
        pWMVDec->m_iHeightUVRepeatPad = pWMVDec->m_iFrmHeightSrc/2;
    }
    pWMVDec->m_iWidthYPlusExp = pWMVDec->m_iWidthYRepeatPad + EXPANDY_REFVOP;
    pWMVDec->m_iWidthUVPlusExp = pWMVDec->m_iWidthUVRepeatPad + EXPANDUV_REFVOP;

    pWMVDec->m_bMBAligned = (pWMVDec->m_iWidthY == pWMVDec->m_iFrmWidthSrc && pWMVDec->m_iHeightY == pWMVDec->m_iFrmHeightSrc);
    // see if the size is multiples of MB_SIZE

    pWMVDec->m_uintNumMBX = pWMVDec->m_iWidthY >> 4; // divided by 16, MB size
    pWMVDec->m_uintNumMBY = pWMVDec->m_iHeightY >> 4;
    pWMVDec->m_uintNumMB = pWMVDec->m_uintNumMBX * pWMVDec->m_uintNumMBY;
    pWMVDec->m_uiRightestMB = pWMVDec->m_uintNumMBX - 1;

    // for motion compensation
    pWMVDec->m_iWidthPrevY = pWMVDec->m_iWidthY + (EXPANDY_REFVOP << 1);
    pWMVDec->m_iWidthPrevUV = pWMVDec->m_iWidthUV + (EXPANDUV_REFVOP << 1);
    pWMVDec->m_iHeightPrevY = pWMVDec->m_iHeightY + (EXPANDY_REFVOP << 1);
    pWMVDec->m_iHeightPrevUV = pWMVDec->m_iHeightUV + (EXPANDUV_REFVOP << 1);
    
    // for update
    pWMVDec->m_iWidthPrevYXExpPlusExp = pWMVDec->m_iWidthPrevY * EXPANDY_REFVOP + EXPANDY_REFVOP;
    pWMVDec->m_iWidthPrevUVXExpPlusExp = pWMVDec->m_iWidthPrevUV * EXPANDUV_REFVOP + EXPANDUV_REFVOP;

    // for motion estimation
	pWMVDec->m_iMBSizeXWidthPrevY = pWMVDec->m_iWidthPrevY << 4; // * MB_SIZE
	pWMVDec->m_iBlkSizeXWidthPrevUV = pWMVDec->m_iWidthPrevUV << 3; // * BLOCK_SIZE
}

#ifdef IPAQ_HACK
    I32_WMV ipaq_hack(U8_WMV * & pData, I32_WMV size);

#   define CHECK_MALLOC2(x,y)               \
    {                                       \
       I32_WMV reslt=ipaq_hack(ppxlTmp,y);  \
           x = ppxlTmp;                     \
        if (ppxlTmp == NULL_WMV)            \
            return WMV_BadMemory;           \
       DEBUG_HEAP_ADD(1,y);                 \
    }
#else
#   define CHECK_MALLOC2(x,y) DEBUG_HEAP_ADD(1,y);
#endif

tWMVDecodeStatus InitDataMembers (    
    tWMVDecInternalMember *pWMVDec, 
    I32_WMV                iWidthSource, 
    I32_WMV                iHeightSource
)
{
    I32_WMV iWidthMBAligned = (iWidthSource + 15) & ~15;
    I32_WMV iHeightMBAligned = (iHeightSource + 15) & ~15;
    I32_WMV iSizeYplane, iSizeUVplane;
    U8_WMV *ppxlTmp;

    pWMVDec->m_iFrmWidthSrc = iWidthSource;
    pWMVDec->m_iFrmHeightSrc = iHeightSource;
    pWMVDec->m_bMBAligned = (
        pWMVDec->m_iFrmWidthSrc == iWidthMBAligned && 
        pWMVDec->m_iFrmHeightSrc == iHeightMBAligned);

    pWMVDec->m_iMVLeftBound = -63; // in half pel
    pWMVDec->m_iMVRightBound = 63; // in half pel

    pWMVDec->m_iWidthY = iWidthMBAligned;
    pWMVDec->m_iWidthUV = pWMVDec->m_iWidthY >> 1;
    pWMVDec->m_iHeightY = iHeightMBAligned;
    pWMVDec->m_iHeightUV = pWMVDec->m_iHeightY >> 1;

    //I32_WMV result = assignVODataMembers ();
    computePars (pWMVDec);

    // Default transform-switching settings
    pWMVDec->m_iFrameXformMode = XFORMMODE_8x8;
    pWMVDec->m_bMBXformSwitching = FALSE_WMV;

    // Allocate Frame memory
    pWMVDec->m_pfrmCurrQ = NULL_WMV; 
    pWMVDec->m_pfrmPrev = NULL_WMV; 
    pWMVDec->m_pfrmPostQ = NULL_WMV;

    iSizeYplane = (iWidthMBAligned + EXPANDY_REFVOP * 2) * (iHeightMBAligned + EXPANDY_REFVOP * 2);
    iSizeUVplane = ((iWidthMBAligned >> 1) + EXPANDUV_REFVOP * 2) * ((iHeightMBAligned  >> 1)+ EXPANDUV_REFVOP * 2);

    pWMVDec->m_pfrmCurrQ = (tYUV420Frame_WMV*) wmvalloc (sizeof (tYUV420Frame_WMV));
    if (pWMVDec->m_pfrmCurrQ == NULL_WMV)
        return WMV_BadMemory;

    pWMVDec->m_pfrmPrev = (tYUV420Frame_WMV*) wmvalloc (sizeof (tYUV420Frame_WMV));
    if (pWMVDec->m_pfrmPrev == NULL_WMV)
        return WMV_BadMemory;

    DEBUG_HEAP_ADD( 0, 2 * sizeof (tYUV420Frame_WMV));

    pWMVDec->m_pfrmCurrQ->m_pucYPlane_Unaligned = ppxlTmp = (U8_WMV *) wmvalloc ((iSizeYplane + 32) * sizeof (U8_WMV));
    if (ppxlTmp == NULL_WMV)
        return WMV_BadMemory;

    CHECK_MALLOC2(pWMVDec->m_pfrmCurrQ->m_pucYPlane_Unaligned,(iSizeYplane + 32)*sizeof(U8_WMV));

    pWMVDec->m_pfrmCurrQ->m_pucYPlane  = (U8_WMV *)(((U32_WMV)ppxlTmp + 31) & ~31);

    pWMVDec->m_pfrmCurrQ->m_pucUPlane_Unaligned = ppxlTmp = (U8_WMV *) wmvalloc ((iSizeUVplane + 32) * sizeof (U8_WMV));
    if (ppxlTmp == NULL_WMV)
        return WMV_BadMemory;
    
    CHECK_MALLOC2(pWMVDec->m_pfrmCurrQ->m_pucUPlane_Unaligned,(iSizeUVplane + 32) * sizeof (U8_WMV));

    pWMVDec->m_pfrmCurrQ->m_pucUPlane  = (U8_WMV *)(((U32_WMV)ppxlTmp + 31) & ~31);
    pWMVDec->m_pfrmCurrQ->m_pucVPlane_Unaligned = ppxlTmp = (U8_WMV *) wmvalloc ((iSizeUVplane + 32) * sizeof (U8_WMV));
    if (ppxlTmp == NULL_WMV)
        return WMV_BadMemory;
    
    CHECK_MALLOC2(pWMVDec->m_pfrmCurrQ->m_pucVPlane_Unaligned,(iSizeUVplane + 32) * sizeof (U8_WMV));
    

    pWMVDec->m_pfrmCurrQ->m_pucVPlane  = (U8_WMV *)(((U32_WMV)ppxlTmp + 31) & ~31);

    pWMVDec->m_pfrmPrev->m_pucYPlane_Unaligned  = ppxlTmp = (U8_WMV *) wmvalloc ((iSizeYplane + 32) * sizeof (U8_WMV));
    if (ppxlTmp == NULL_WMV)
        return WMV_BadMemory;

    CHECK_MALLOC2(pWMVDec->m_pfrmPrev->m_pucYPlane_Unaligned,(iSizeYplane + 32) * sizeof (U8_WMV));
   

    pWMVDec->m_pfrmPrev->m_pucYPlane  = (U8_WMV *)(((U32_WMV)ppxlTmp + 31) & ~31);
    pWMVDec->m_pfrmPrev->m_pucUPlane_Unaligned  = ppxlTmp = (U8_WMV *) wmvalloc ((iSizeUVplane + 32) * sizeof (U8_WMV));
    if (ppxlTmp == NULL_WMV)
        return WMV_BadMemory;

    CHECK_MALLOC2(pWMVDec->m_pfrmPrev->m_pucUPlane_Unaligned ,(iSizeUVplane + 32) * sizeof (U8_WMV));
   

    pWMVDec->m_pfrmPrev->m_pucUPlane  = (U8_WMV *)(((U32_WMV)ppxlTmp + 31) & ~31);
    pWMVDec->m_pfrmPrev->m_pucVPlane_Unaligned  = ppxlTmp = (U8_WMV *) wmvalloc ((iSizeUVplane + 32) * sizeof (U8_WMV));
    if (ppxlTmp == NULL_WMV)
        return WMV_BadMemory;

    CHECK_MALLOC2(pWMVDec->m_pfrmPrev->m_pucVPlane_Unaligned, (iSizeUVplane + 32) * sizeof (U8_WMV));
   

    pWMVDec->m_pfrmPrev->m_pucVPlane  = (U8_WMV *)(((U32_WMV)ppxlTmp + 31) & ~31);

    pWMVDec->m_ppxliCurrQPlusExpY = pWMVDec->m_pfrmCurrQ->m_pucYPlane + pWMVDec->m_iWidthPrevYXExpPlusExp;
    pWMVDec->m_ppxliCurrQPlusExpU = pWMVDec->m_pfrmCurrQ->m_pucUPlane + pWMVDec->m_iWidthPrevUVXExpPlusExp;
    pWMVDec->m_ppxliCurrQPlusExpV = pWMVDec->m_pfrmCurrQ->m_pucVPlane + pWMVDec->m_iWidthPrevUVXExpPlusExp;
    pWMVDec->m_ppxliRef0Y = pWMVDec->m_pfrmPrev->m_pucYPlane;
    pWMVDec->m_ppxliRef0U = pWMVDec->m_pfrmPrev->m_pucUPlane;
    pWMVDec->m_ppxliRef0V = pWMVDec->m_pfrmPrev->m_pucVPlane;
    pWMVDec->m_ppxliRef0YPlusExp = pWMVDec->m_ppxliRef0Y + pWMVDec->m_iWidthPrevYXExpPlusExp;

#ifdef _SUPPORT_POST_FILTERS_
    pWMVDec->m_pfrmPostQ = (tYUV420Frame_WMV*) wmvalloc (sizeof (tYUV420Frame_WMV));
    if (pWMVDec->m_pfrmPostQ == NULL_WMV)
        return WMV_BadMemory;
    DEBUG_HEAP_ADD(0, sizeof (tYUV420Frame_WMV));

    pWMVDec->m_pfrmPostQ->m_pucYPlane_Unaligned  = ppxlTmp = (U8_WMV *) wmvalloc ((iSizeYplane + 32) * sizeof (U8_WMV));
    if (ppxlTmp == NULL_WMV)
        return WMV_BadMemory;
    pWMVDec->m_pfrmPostQ->m_pucYPlane  = (U8_WMV *)(((U32_WMV)ppxlTmp + 31) & ~31);
    DEBUG_HEAP_ADD(1, (iSizeYplane + 32) * sizeof (U8_WMV));

    pWMVDec->m_pfrmPostQ->m_pucUPlane_Unaligned  = ppxlTmp = (U8_WMV *) wmvalloc ((iSizeUVplane + 32) * sizeof (U8_WMV));
    if (ppxlTmp == NULL_WMV)
        return WMV_BadMemory;
    pWMVDec->m_pfrmPostQ->m_pucUPlane  = (U8_WMV *)(((U32_WMV)ppxlTmp + 31) & ~31);
    DEBUG_HEAP_ADD(1, (iSizeUVplane + 32) * sizeof (U8_WMV));

    pWMVDec->m_pfrmPostQ->m_pucVPlane_Unaligned  = ppxlTmp = (U8_WMV *) wmvalloc ((iSizeUVplane + 32) * sizeof (U8_WMV));
    if (ppxlTmp == NULL_WMV)
        return WMV_BadMemory;
    pWMVDec->m_pfrmPostQ->m_pucVPlane  = (U8_WMV *)(((U32_WMV)ppxlTmp + 31) & ~31);
    DEBUG_HEAP_ADD(1, (iSizeUVplane + 32) * sizeof (U8_WMV));

    pWMVDec->m_ppxliPostQPlusExpY = pWMVDec->m_pfrmPostQ->m_pucYPlane + pWMVDec->m_iWidthPrevYXExpPlusExp;
    pWMVDec->m_ppxliPostQPlusExpU = pWMVDec->m_pfrmPostQ->m_pucUPlane + pWMVDec->m_iWidthPrevUVXExpPlusExp;
    pWMVDec->m_ppxliPostQPlusExpV = pWMVDec->m_pfrmPostQ->m_pucVPlane + pWMVDec->m_iWidthPrevUVXExpPlusExp;
#endif // _SUPPORT_POST_FILTERS_

    pWMVDec->m_rgmv = new CVector [pWMVDec->m_uintNumMBX * 2];
    if (!pWMVDec->m_rgmv)
        return WMV_BadMemory;
    DEBUG_HEAP_ADD(0,pWMVDec->m_uintNumMBX * 2 * sizeof(CVector));

    // MB data
    pWMVDec->m_rgmbmd = new CWMVMBMode [pWMVDec->m_uintNumMB];
    if (!pWMVDec->m_rgmbmd)
        return WMV_BadMemory;
    DEBUG_HEAP_ADD(0,pWMVDec->m_uintNumMB * sizeof(CWMVMBMode));

    pWMVDec->m_pmbmdZeroCBPCY = new CWMVMBMode;
    if (!pWMVDec->m_pmbmdZeroCBPCY)
        return WMV_BadMemory;
    DEBUG_HEAP_ADD(0,sizeof(CWMVMBMode));

    pWMVDec->m_pmbmdZeroCBPCY->m_rgbCodedBlockPattern = 0; 

    // for block-based rendering
    pWMVDec->m_iWidthPrevYTimes8Minus8 = pWMVDec->m_iWidthPrevY * 8 - 8;
    pWMVDec->m_iWidthPrevUVTimes4Minus4 = pWMVDec->m_iWidthPrevUV * 4 - 4;

    pWMVDec->m_iNumOfQuanDctCoefForACPredPerRow = BLOCK_SIZE_TIMES2_TIMES6 * pWMVDec->m_uintNumMBX; 
    pWMVDec->m_rgiQuanCoefACPred = new I16_WMV [pWMVDec->m_uintNumMBX * 2 * BLOCK_SIZE_TIMES2_TIMES6]; // Allocate 2 rows buffer, 6 blocks in an MB
    if (!pWMVDec->m_rgiQuanCoefACPred)
        return WMV_BadMemory;
    DEBUG_HEAP_ADD(0,(pWMVDec->m_uintNumMBX * 2 * BLOCK_SIZE_TIMES2_TIMES6) * sizeof(I16_WMV));

    pWMVDec->m_rgiQuanCoefACPredTable = new I16_WMV* [pWMVDec->m_uintNumMBX * 2  * 36];
    if (!pWMVDec->m_rgiQuanCoefACPredTable)
        return WMV_BadMemory;
    DEBUG_HEAP_ADD(0,pWMVDec->m_uintNumMBX * 2  * 36 * sizeof(I16_WMV*));

    pWMVDec->m_pAvgQuanDctCoefDec = new I16_WMV [BLOCK_SIZE_TIMES2];
    pWMVDec->m_pAvgQuanDctCoefDecC = new I16_WMV [BLOCK_SIZE_TIMES2];
    pWMVDec->m_pAvgQuanDctCoefDecLeft = new I16_WMV [BLOCK_SIZE_TIMES2];
    pWMVDec->m_pAvgQuanDctCoefDecTop = new I16_WMV [BLOCK_SIZE_TIMES2];
    if (!pWMVDec->m_pAvgQuanDctCoefDec || !pWMVDec->m_pAvgQuanDctCoefDecC || !pWMVDec->m_pAvgQuanDctCoefDecLeft || !pWMVDec->m_pAvgQuanDctCoefDecTop)
        return WMV_BadMemory;
    DEBUG_HEAP_ADD(0, 4 * BLOCK_SIZE_TIMES2 * sizeof(I16_WMV));

    memset(pWMVDec->m_pAvgQuanDctCoefDec, 0, BLOCK_SIZE_TIMES2 * sizeof(I16_WMV));
    memset(pWMVDec->m_pAvgQuanDctCoefDecC, 0, BLOCK_SIZE_TIMES2 * sizeof(I16_WMV));
    memset(pWMVDec->m_pAvgQuanDctCoefDecLeft, 0, BLOCK_SIZE_TIMES2 * sizeof(I16_WMV));
    memset(pWMVDec->m_pAvgQuanDctCoefDecTop, 0, BLOCK_SIZE_TIMES2 * sizeof(I16_WMV));

    if (pWMVDec->m_cvCodecVersion == MP4S) {
        pWMVDec->m_pAvgQuanDctCoefDec[0] = pWMVDec->m_pAvgQuanDctCoefDec[BLOCK_SIZE] = 1024;
        pWMVDec->m_pAvgQuanDctCoefDecC[0] = pWMVDec->m_pAvgQuanDctCoefDecC[BLOCK_SIZE] = 1024;
        pWMVDec->m_bRndCtrlOn = TRUE_WMV;
    }
	else{
        pWMVDec->m_pAvgQuanDctCoefDec[0] = pWMVDec->m_pAvgQuanDctCoefDec[BLOCK_SIZE] = 128;
        pWMVDec->m_pAvgQuanDctCoefDecC[0] = pWMVDec->m_pAvgQuanDctCoefDecC[BLOCK_SIZE] = 128;
        pWMVDec->m_bRndCtrlOn = FALSE_WMV;
    }

    {

        U32_WMV ii;
        U32_WMV imby, i;        
        I16_WMV **pDct = pWMVDec->m_rgiQuanCoefACPredTable; 
        I16_WMV *pDct1  = pWMVDec->m_rgiQuanCoefACPred;
        I32_WMV iNumOfQuanDctCoefForACPredPerRow = - pWMVDec->m_iNumOfQuanDctCoefForACPredPerRow;
        
        for (ii = 0; ii < pWMVDec->m_uintNumMB; ii++) 
            pWMVDec->m_rgmbmd[ii].m_bBlkXformSwitchOn = FALSE_WMV;
        
        for (imby = 0, i = 0; imby < 2; imby++) {
            U32_WMV imbx;
            if (imby & 0x01)  // bTopRowBufferInOrder
                iNumOfQuanDctCoefForACPredPerRow = pWMVDec->m_iNumOfQuanDctCoefForACPredPerRow;
            
            for (imbx = 0; imbx < pWMVDec->m_uintNumMBX; i++, imbx++) {
                I32_WMV ib;
                for (ib = 0;ib < 6;ib++) {
                    switch (ib) {
                    case 0://Y_BLOCK1:
                        pDct[0] = pWMVDec->m_pAvgQuanDctCoefDec;
                        pDct[1] = pDct1 - BLOCK_SIZE_TIMES2_TIMES5; 
                        pDct[2] = pWMVDec->m_pAvgQuanDctCoefDec;
                        pDct[3] = pDct1 - iNumOfQuanDctCoefForACPredPerRow+ BLOCK_SIZE_TIMES2_TIMES2;
                        pDct[4] = pWMVDec->m_pAvgQuanDctCoefDec;
                        pDct[5] = pDct1 - iNumOfQuanDctCoefForACPredPerRow - BLOCK_SIZE_TIMES2_TIMES3;
                        break;
                    case 1://Y_BLOCK2:
                        pDct[6]  = pDct[7] =  pDct1 - BLOCK_SIZE_TIMES2;
                        pDct[8] = pWMVDec->m_pAvgQuanDctCoefDec;
                        pDct[9] = pDct1- iNumOfQuanDctCoefForACPredPerRow + BLOCK_SIZE_TIMES2_TIMES2;
                        pDct[10] = pWMVDec->m_pAvgQuanDctCoefDec;	   //(pWMVDec->m_uintNumMBX * 6 - 2)* 8 
                        pDct[11] = pDct1- iNumOfQuanDctCoefForACPredPerRow + BLOCK_SIZE_TIMES2;
                        break;
                    case 2://Y_BLOCK3:
                        pDct[12] = pWMVDec->m_pAvgQuanDctCoefDec;
                        pDct[13] = pDct1 - BLOCK_SIZE_TIMES2_TIMES5 ;
                        pDct[14] = pDct[15] = pDct1 - BLOCK_SIZE_TIMES2_TIMES2;	   //(pWMVDec->m_uintNumMBX * 6 - 2)* 8 
                        pDct[16] = pWMVDec->m_pAvgQuanDctCoefDec;
                        pDct[17] = pDct1 - BLOCK_SIZE_TIMES2_TIMES7 ;
                        break;
                    case 3://Y_BLOCK4:
                        pDct[18] = pDct[19] = pDct1 - BLOCK_SIZE_TIMES2;
                        pDct[20] = pDct[21] = pDct1 - BLOCK_SIZE_TIMES2_TIMES2;	   //(pWMVDec->m_uintNumMBX * 6 - 2)* 8 
                        pDct[22]= pDct[23] = pDct1 - BLOCK_SIZE_TIMES2_TIMES3;
                        break;
                    case 4://U_BLOCK:
                        pDct[24] = pWMVDec->m_pAvgQuanDctCoefDecC;
                        pDct[25] = pDct1- BLOCK_SIZE_TIMES2_TIMES6 ;
                        pDct[26] = pWMVDec->m_pAvgQuanDctCoefDecC;	   //(pWMVDec->m_uintNumMBX * 6 - 2)* 8 
                        pDct[27] = pDct1 - iNumOfQuanDctCoefForACPredPerRow ;
                        pDct[28] = pWMVDec->m_pAvgQuanDctCoefDecC;
                        pDct[29] = pDct1 - iNumOfQuanDctCoefForACPredPerRow - BLOCK_SIZE_TIMES2_TIMES6;
                        break;
                    case 5://V_BLOCK:
                        pDct[30] = pWMVDec->m_pAvgQuanDctCoefDecC;
                        pDct[31] = pDct1 - BLOCK_SIZE_TIMES2_TIMES6 ;
                        pDct[32] = pWMVDec->m_pAvgQuanDctCoefDecC;
                        pDct[33] = pDct1 - iNumOfQuanDctCoefForACPredPerRow ;
                        pDct[34] = pWMVDec->m_pAvgQuanDctCoefDecC;
                        pDct[35] = pDct1 - iNumOfQuanDctCoefForACPredPerRow - BLOCK_SIZE_TIMES2_TIMES6 ;
                        break;
                    }
                    pDct1 += BLOCK_SIZE_TIMES2;
                }
                pDct += 36;
            }
        }
    }


#if !defined(_WIN32)
    assert(pWMVDec->m_uintNumMB * sizeof(U8_WMV) <= UINT_MAX);
#endif

    pWMVDec->m_rgchSkipPrevFrame = new U8_WMV [pWMVDec->m_uintNumMB];
    if (pWMVDec->m_rgchSkipPrevFrame == NULL_WMV) {
        delete [] pWMVDec->m_rgchSkipPrevFrame; pWMVDec->m_rgchSkipPrevFrame = NULL_WMV;
        return WMV_BadMemory;
    }
    DEBUG_HEAP_ADD(0,pWMVDec->m_uintNumMB*sizeof(U8_WMV));

    memset (pWMVDec->m_rgchSkipPrevFrame, 0, (size_t) pWMVDec->m_uintNumMB);

    pWMVDec->m_iWidthPrevYxBlkMinusBlk = (pWMVDec->m_iWidthPrevY * BLOCK_SIZE) - BLOCK_SIZE;

    return WMV_Succeeded;
}


Void_WMV decideMMXRoutines (tWMVDecInternalMember *pWMVDec)
{
    // IDCT
    pWMVDec->m_pIntraIDCT_Dec = g_IDCTDec_WMV2;

#ifndef _EMB_WMV2_
    pWMVDec->m_pInterIDCT_Dec = g_IDCTDec_WMV2;
    pWMVDec->m_pInter8x4IDCT_Dec = g_8x4IDCTDec_WMV2;
    pWMVDec->m_pInter4x8IDCT_Dec = g_4x8IDCTDec_WMV2;
#endif

    // g_InitRepeatRefInfo
    g_pRepeatRef0Y = g_RepeatRef0Y;
    g_pRepeatRef0UV = g_RepeatRef0UV;
    // MC
    pWMVDec->m_pMotionCompAndAddErrorRndCtrlOn = g_MotionCompAndAddErrorRndCtrl;
    pWMVDec->m_pMotionCompRndCtrlOn = g_MotionCompRndCtrl;
    pWMVDec->m_pMotionCompAndAddErrorRndCtrlOff = g_MotionCompAndAddError;
    pWMVDec->m_pMotionCompRndCtrlOff = g_MotionComp;
    pWMVDec->m_pMotionCompZero = g_MotionCompZeroMotion_WMV;

#ifndef _EMB_WMV2_
    pWMVDec->m_pMotionCompMixed = MotionCompMixed;
    pWMVDec->m_pMotionCompMixedAndAddError = MotionCompMixedAndAddError;
#endif //_EMB_WMV2_

    // Loop Filter Selection
    pWMVDec->m_pFilterHorizontalEdge = g_FilterHorizontalEdge_WMV;
    pWMVDec->m_pFilterVerticalEdge = g_FilterVerticalEdge_WMV;

	pWMVDec->m_pBlkAvgX8_MMX = BlkAvgX8;

#if defined( _WMV_TARGET_X86_) || defined(_Embedded_x86)
    if (g_bSupportMMX_WMV) {
        pWMVDec->m_pInter8x4IDCT_Dec = g_8x4IDCTDecMMX_WMV2;
        pWMVDec->m_pInter4x8IDCT_Dec = g_4x8IDCTDecMMX_WMV2;
        pWMVDec->m_pInterIDCT_Dec = g_IDCTDecMMX_WMV2;
        pWMVDec->m_pIntraIDCT_Dec = g_IDCTDecMMX_WMV2;

        g_pRepeatRef0Y = g_RepeatRef0Y_MMX;
        g_pRepeatRef0UV = g_RepeatRef0UV_MMX;

        pWMVDec->m_pMotionCompAndAddErrorRndCtrlOn = g_MotionCompAndAddErrorRndCtrl_MMX;
        pWMVDec->m_pMotionCompAndAddErrorRndCtrlOff = g_MotionCompAndAddError_MMX;
        pWMVDec->m_pMotionCompRndCtrlOn = g_MotionCompRndCtrl_MMX;
        pWMVDec->m_pMotionCompRndCtrlOff = g_MotionComp_MMX;
        pWMVDec->m_pMotionCompZero = g_MotionCompZeroMotion_MMX_WMV;

        pWMVDec->m_pMotionCompMixed = MotionCompMixed_MMX;
        pWMVDec->m_pMotionCompMixedAndAddError = MotionCompMixedAndAddError_MMX;

        pWMVDec->m_pBlkAvgX8_MMX = BlkAvgX8_MMX;

        pWMVDec->m_pFilterHorizontalEdge = g_FilterHorizontalEdge_MMX;
        pWMVDec->m_pFilterVerticalEdge = g_FilterVerticalEdge_MMX;

    }
#ifndef _XBOX
    if (g_SupportSSE1())
#endif // _XBOX
    {
        pWMVDec->m_pMotionCompRndCtrlOff = g_MotionComp_KNI;
        //pWMVDec->m_pMotionCompRndCtrlOn = g_MotionCompRndCtrlOn_KNI;
        pWMVDec->m_pMotionCompRndCtrlOn = g_MotionCompRndCtrl_MMX;

        pWMVDec->m_pMotionCompMixed = MotionCompMixed_KNI;
        pWMVDec->m_pMotionCompMixedAndAddError = MotionCompMixedAndAddError_KNI;
    }
#endif // _M_IX86) || _Embedded_x86

#if defined(macintosh) && defined(_MAC_VEC_OPT)
    if (g_SupportAltiVec ()) {
        pWMVDec->m_pMotionCompRndCtrlOn = g_MotionCompRndCtrl_AltiVec;
        pWMVDec->m_pMotionCompRndCtrlOff = g_MotionComp_AltiVec;
        pWMVDec->m_pMotionCompZero = g_MotionCompZeroMotion_AltiVec;
		pWMVDec->m_bSupportAltiVec = TRUE_WMV;
    }
#endif

}

Void_WMV m_InitFncPtrAndZigzag(tWMVDecInternalMember *pWMVDec)
{
    pWMVDec->m_bRefreshDisplay_AllMB_Enable = TRUE_WMV;
    // At the decoder side, Both Intra and Inter Frame might use Rotated matrix depending on which idct is called.
    if (pWMVDec->m_cvCodecVersion == WMV2) {
        pWMVDec->m_p8x4ZigzagInv = grgi8x4ZigzagInv;
        pWMVDec->m_p4x8ZigzagInv = grgi4x8ZigzagInv;
        pWMVDec->m_p8x4ZigzagInvRotated = grgi8x4ZigzagInvRotated;
        pWMVDec->m_p4x8ZigzagInvRotated = grgi4x8ZigzagInvRotated;
        pWMVDec->m_bSKIPBIT_CODING_ = TRUE_WMV;
        pWMVDec->m_bNEW_PCBPCY_TABLE = TRUE_WMV;
    }

    if (pWMVDec->m_cvCodecVersion >= WMV1) {
        pWMVDec->m_pZigzagInv_I = grgiZigzagInv_NEW_I;
        pWMVDec->m_pZigzagInvRotated_I = grgiZigzagInvRotated_NEW_I;
        pWMVDec->m_pHorizontalZigzagInv = grgiHorizontalZigzagInv_NEW;
        pWMVDec->m_pVerticalZigzagInv = grgiVerticalZigzagInv_NEW;
        //Decoder Only
        pWMVDec->m_pHorizontalZigzagInvRotated = grgiHorizontalZigzagInvRotated_NEW;
        pWMVDec->m_pVerticalZigzagInvRotated = grgiVerticalZigzagInvRotated_NEW;

        pWMVDec->m_pZigzagInvRotated = grgiZigzagInvRotated_NEW;
        pWMVDec->m_pZigzagInv = grgiZigzagInv_NEW;

        pWMVDec->m_pDecodeIMBAcPred = DecodeIMBAcPred;    
        setRefreshPeriod(pWMVDec);
    }
    else{
        pWMVDec->m_pZigzagInv_I = grgiZigzagInv;
        pWMVDec->m_pZigzagInvRotated_I = grgiZigzagInvRotated;
        pWMVDec->m_pHorizontalZigzagInv = grgiHorizontalZigzagInv;
        pWMVDec->m_pVerticalZigzagInv = grgiVerticalZigzagInv;
        //Decoder Only
        pWMVDec->m_pHorizontalZigzagInvRotated = grgiVerticalZigzagInv;
        pWMVDec->m_pVerticalZigzagInvRotated = grgiHorizontalZigzagInv;

        pWMVDec->m_pZigzagInvRotated = grgiZigzagInvRotated;
        pWMVDec->m_pZigzagInv = grgiZigzagInv;

        pWMVDec->m_pDecodeIMBAcPred = DecodeIMBAcPred_MP4X;
    }

    pWMVDec->m_p8x4ZigzagScanOrder = pWMVDec->m_p8x4ZigzagInv;
    pWMVDec->m_p4x8ZigzagScanOrder = pWMVDec->m_p4x8ZigzagInv;
    pWMVDec->m_bRotatedIdct = FALSE_WMV;
    pWMVDec->m_pZigzagScanOrder = pWMVDec->m_pZigzagInv;
#ifdef  _WMV_TARGET_X86_
    if (g_bSupportMMX_WMV) { 
        pWMVDec->m_bRotatedIdct = TRUE_WMV;
        pWMVDec->m_pZigzagScanOrder = pWMVDec->m_pZigzagInvRotated;
    }
#endif //  _WMV_TARGET_X86_

    // Func Pointers
    pWMVDec->m_pDecodeI = WMVideoDecDecodeI;
    pWMVDec->m_pDecodeP = WMVideoDecDecodeP;
#ifndef _EMB_WMV2_
    pWMVDec->m_pDecodePMB=DecodePMB;
#else //_EMB_WMV2_
    pWMVDec->m_pDecodePMB=DecodePMB_EMB;
    InitEMB_FuncTable(pWMVDec);
#endif

    if (pWMVDec->m_cvCodecVersion != MP4S) {
        pWMVDec->m_iEscRunDiffV2V3 = (pWMVDec->m_cvCodecVersion >= MP43)? 1 : 0;
        pWMVDec->m_iDCPredCorrect = (pWMVDec->m_cvCodecVersion >= WMV1)? 1 : 0;

        pWMVDec->m_pDecodeInverseInterBlockQuantize = DecodeInverseInterBlockQuantizeEscCode;
        pWMVDec->m_pDecodeInverseInterBlockQuantize = DecodeInverseInterBlockQuantizeEscCode;

#ifdef  _WMV_TARGET_X86_
        if (g_bSupportMMX_WMV) 
            pWMVDec->m_pDecodeInverseInterBlockQuantize = DecodeInverseInterBlockQuantizeEscCode_MMX;
#endif //  _WMV_TARGET_X86_

        if (pWMVDec->m_cvCodecVersion >= MP43) {
            pWMVDec->m_pDecodeMBOverheadOfIVOP = decodeMBOverheadOfIVOP_MSV;
            pWMVDec->m_pDecodeMBOverheadOfPVOP = decodeMBOverheadOfPVOP_MSV; 
        }
        else{ // MP42
            pWMVDec->m_pDecodeMBOverheadOfIVOP = decodeMBOverheadOfIVOP_New;
            pWMVDec->m_pDecodeMBOverheadOfPVOP = decodeMBOverheadOfPVOP_New; 
        }
    }
    else{
        pWMVDec->m_iDCPredCorrect = 1;
        pWMVDec->m_uintNumMBYSlice = pWMVDec->m_uintNumMBY;
        pWMVDec->m_pDecodeInverseInterBlockQuantize = DecodeInverseInterBlockQuantizeEscCode_MPEG4;
#ifdef  _WMV_TARGET_X86_
        if (g_bSupportMMX_WMV) 
            pWMVDec->m_pDecodeInverseInterBlockQuantize = DecodeInverseInterBlockQuantizeEscCode_MMX_MPEG4;
#endif //  _WMV_TARGET_X86_
        pWMVDec->m_pDecodeMBOverheadOfIVOP = decodeMBOverheadOfIVOP_MPEG4;
        pWMVDec->m_pDecodeMBOverheadOfPVOP = decodeMBOverheadOfPVOP_MPEG4; 
    }
}

#if defined(WANT_HEAP_MEASURE)
    extern "C" unsigned int g_cbHeapSize[6] = {0}, g_cbMaxHeapSize[6] = {0}, g_iHeapLastClass = 0;
#endif;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\idctdec_wmv2_x86.cpp ===
#include "bldsetup.h"

#include "xplatform.h"
#include "typedef.hpp"
#include "idctdec_wmv2.h"
#include "cpudetect.h"
#include "wmvdec_api.h"


#ifdef _WMV_TARGET_X86_

#ifndef __DCT_COEF_INT_
#define __DCT_COEF_INT_

#define W1 2841L /* 2048*sqrt(2)*cos(1*pi/16) */
#define W2 2676L /* 2048*sqrt(2)*cos(2*pi/16) */
#define W3 2408L /* 2048*sqrt(2)*cos(3*pi/16) */
#define W5 1609L /* 2048*sqrt(2)*cos(5*pi/16) */
#define W6 1108L /* 2048*sqrt(2)*cos(6*pi/16) */
#define W7 565L  /* 2048*sqrt(2)*cos(7*pi/16) */

#define W1a 1892L /* 2048*cos(1*pi/8) */
#define W2a 1448L /* 2048*cos(2*pi/8) */
#define W3a 784L  /* 2048*cos(3*pi/8) */

#define W1_W7 2276L //(W1 - W7)
#define W1pW7 3406L //(W1 + W7)
#define W3_W5 799L  //(W3 - W5)
#define W3pW5 4017L //(W3 + W5)
#define W2_W6 1568L //(W2 - W6)
#define W2pW6 3784L //(W2 + W6)

#endif // __DCT_COEF_INT_

// MMX Version
// Input: 32-bit
// Output: 8-bit
Void_WMV g_IDCTDecMMX_WMV2 (U8_WMV* piDst, I32_WMV iOffsetToNextRowForDCT, const PixelI32 __huge* rgiCoefRecon)
{
  	I32_WMV buf [72];
    PixelI32 *rgblk = (PixelI32 *) (((I32_WMV)buf+32)&0xFFFFFFE0);

    static const Int64 M1 = 0x023508E4023508E4;     //W7,W1-W7
    static const Int64 M2 = 0x0235F2B20235F2B2;     //W7,0-(W1+W7)
    static const Int64 M3 = 0x0968FCE10968FCE1;     //W3,0-(W3-W5)
    static const Int64 M4 = 0x0968F04F0968F04F;     //W3,0-(W3+W5)
    static const Int64 M5 = 0x0454F1380454F138;     //W6,0-(W2+W6)
    static const Int64 M6 = 0x0454062004540620;     //W6,W2-W6
    static const Int64 M7 = 0x0000008000000080;
    static const Int64 M8 = 0x00B55a8000B55a80;     //181,(181<<16)
    static const Int64 M9 = 0x0000023500000235;
    static const Int64 M10 = 0x000000B5000000B5;    //181,181
    static const Int64 low15mask = 0x00007fff00007fff;
    Int64 t64;

    _asm{
            mov         esi,rgiCoefRecon
            mov         edi,rgblk
            mov         ecx,-4
            xor         ebx,ebx
HLoop:
            lea         eax,[esi+ecx*8]

            pcmpeqb     mm0,mm0
            psrld       mm0,16

            movq        mm4,[eax+32+16*2]
            movq        mm1,mm4
            movq        mm5,[eax+32+112*2]
            paddd       mm1,mm5
            pslld       mm1,16
            pand        mm4,mm0
            pand        mm5,mm0
            por         mm5,mm1
            por         mm4,mm1
            movq        mm1,M1
            pmaddwd     mm4,mm1
            movq        mm1,M2
            pmaddwd     mm5,mm1
            
            movq        mm6,[eax+32+80*2]
            movq        mm1,mm6
            movq        mm7,[eax+32+48*2]
            paddd       mm1,mm7
            pslld       mm1,16
            pand        mm6,mm0
            pand        mm7,mm0
            por         mm6,mm1
            por         mm7,mm1
            movq        mm1,M3
            pmaddwd     mm6,mm1
            movq        mm1,M4
            pmaddwd     mm7,mm1

            movq        mm3,[eax+32+32*2]
            movq        mm1,mm3
            movq        mm2,[eax+32+96*2]
            paddd       mm1,mm2
            pslld       mm1,16
            pand        mm3,mm0
            pand        mm2,mm0
            por         mm3,mm1
            por         mm2,mm1
            movq        mm1,M6
            pmaddwd     mm3,mm1
            movq        mm1,M5
            pmaddwd     mm2,mm1

            movq        mm0,mm6
            paddd       mm6,mm4
            psubd       mm4,mm0

            movq        mm0,mm7
            paddd       mm7,mm5
            psubd       mm5,mm0

            movq        mm0,mm5
            paddd       mm5,mm4
            psubd       mm4,mm0

            movq        mm0,mm5
            pand        mm0,low15mask
            movq        mm1,M10
            pmaddwd     mm0,mm1
            psrld       mm5,15
            pmaddwd     mm5,mm1
            pslld       mm5,15
            paddd       mm5,mm0
            movq        mm0,M7
            paddd       mm5,mm0
            psrad       mm5,8

            movq        mm0,mm4
            pand        mm0,low15mask
            pmaddwd     mm0,mm1
            psrld       mm4,15
            pmaddwd     mm4,mm1
            pslld       mm4,15
            paddd       mm4,mm0
            movq        mm1,M7
            paddd       mm4,mm1
            psrad       mm4,8

            movq        mm0,[esi+ecx*8+32]
            lea         eax,[esi+ecx*8]
            movq        [edi+4],mm4
            pslld       mm0,16
            psrad       mm0,5
            movq        mm1,M7
            paddd       mm0,mm1
            movq        mm1,[eax+32+64*2]
            pslld       mm1,16
            psrad       mm1,5
            movq        mm4,mm0
            psubd       mm0,mm1
            paddd       mm1,mm4

            movq        mm4,mm1
            psubd       mm1,mm3
            paddd       mm3,mm4

            movq        mm4,mm0
            psubd       mm0,mm2
            paddd       mm2,mm4

            movq        mm4,mm3
            psubd       mm3,mm6
            paddd       mm6,mm4
            psrad       mm3,8
            psrad       mm6,8

#if 0 // Old way of generating (181*(x4 + x5) + 128)>>8. Overflowed in certain cases
            
            movq        mm4,mm5
            pslld       mm4,17
            psrlw       mm4,1
            pslld       mm5,1
            psrld       mm5,16
            psllw       mm5,8
            por         mm5,mm4
            movq        mm4,M8
            pmaddwd     mm5,mm4
            movq        mm4,M7
            paddd       mm5,mm4
            psrad       mm5,8
#endif

            movq        mm4,mm2
            psubd       mm2,mm5
            paddd       mm5,mm4
            psrad       mm2,8
            psrad       mm5,8

            movq        mm4,mm6
            punpckldq   mm6,mm5
            punpckhdq   mm4,mm5
            packssdw    mm6,mm6
            
            movq        mm5,mm2
            punpckldq   mm2,mm3
            movd        [edi],mm6
            punpckhdq   mm5,mm3
            packssdw    mm5,mm5
            movd        [edi+12+16],mm5
            packssdw    mm2,mm4
            movq        mm4,[edi+4]
            movq        [edi+12],mm2

#if 0 // Old way of generating (181*(x4 + x5) + 128)>>8. Overflowed in certain cases

            movq        mm2,mm4
            pslld       mm4,17
            psrlw       mm4,1
            pslld       mm2,1
            psrld       mm2,16
            psllw       mm2,8
            por         mm2,mm4
            movq        mm4,M8
            pmaddwd     mm4,mm2
            movq        mm2,M7
            paddd       mm4,mm2
            psrad       mm4,8
#endif
            
            movq        mm2,mm0
            psubd       mm0,mm4
            paddd       mm4,mm2
            psrad       mm0,8
            psrad       mm4,8

            movq        mm2,mm1
            psubd       mm1,mm7
            paddd       mm7,mm2
            psrad       mm1,8
            psrad       mm7,8

            movq        mm2,mm4
            punpckldq   mm4,mm7
            punpckhdq   mm2,mm7

            movq        mm7,mm1
            punpckldq   mm1,mm0
            punpckhdq   mm7,mm0
            packssdw    mm4,mm1
            movq        [edi+4],mm4
            packssdw    mm2,mm7
            inc         ecx
            movq        [edi+4+16],mm2
            lea         edi,[edi+32]
            jl          HLoop

            xor         ecx,ecx
            mov         esi,rgblk
            mov         edi,piDst
            mov         edx,iOffsetToNextRowForDCT
VLoop:

            pcmpeqb     mm1,mm1    //Generate constant 4
            psrld       mm1,31
            pslld       mm1,2

            movd        mm4,[esi+ecx*2+16]
            movd        mm5,[esi+ecx*2+112]
            movq        mm0,mm4
            paddw       mm0,mm5
            punpcklwd   mm4,mm0
            punpcklwd   mm5,mm0
            movq        mm0,M1
            pmaddwd     mm4,mm0
            paddd       mm4,mm1
            movq        mm0,M2
            pmaddwd     mm5,mm0
            paddd       mm5,mm1
            psrad       mm4,3
            psrad       mm5,3
        
            movd        mm6,[esi+ecx*2+80]
            movd        mm7,[esi+ecx*2+48]
            movq        mm0,mm6
            paddw       mm0,mm7
            punpcklwd   mm6,mm0
            punpcklwd   mm7,mm0
            movq        mm0,M3
            pmaddwd     mm6,mm0
            paddd       mm6,mm1
            movq        mm0,M4
            pmaddwd     mm7,mm0
            paddd       mm7,mm1
            psrad       mm6,3
            psrad       mm7,3

            movd        mm2,[esi+ecx*2+96]
            movd        mm3,[esi+ecx*2+32]
            movq        mm0,mm2
            paddw       mm0,mm3
            punpcklwd   mm2,mm0
            punpcklwd   mm3,mm0
            movq        mm0,M5
            pmaddwd     mm2,mm0
            paddd       mm2,mm1
            movq        mm0,M6
            pmaddwd     mm3,mm0
            paddd       mm3,mm1
            psrad       mm2,3
            psrad       mm3,3

            movq        mm0,mm4
            psubd       mm4,mm6
            paddd       mm6,mm0

            movq        mm0,mm5
            psubd       mm5,mm7
            paddd       mm7,mm0

            movq        mm0,mm4
            psubd       mm4,mm5
            paddd       mm5,mm0
 
            movq        mm0,mm5
            pand        mm0,low15mask
            movq        mm1,M10
            pmaddwd     mm0,mm1
            psrld       mm5,15
            pmaddwd     mm5,mm1
            pslld       mm5,15
            paddd       mm5,mm0
            movq        mm0,M7
            paddd       mm5,mm0
            psrad       mm5,8            

            movq        mm0,mm4
            pand        mm0,low15mask
            pmaddwd     mm0,mm1
            psrld       mm4,15
            pmaddwd     mm4,mm1
            pslld       mm4,15
            paddd       mm4,mm0
            movq        mm1,M7
            paddd       mm4,mm1
            psrad       mm4,8

#if 0 // Old way of generating (181*(x4 + x5) + 128)>>8. Overflowed in certain cases
            
            pslld       mm1,5  //Generate constant 128
            movq        mm0,mm5
            pslld       mm0,17
            psrlw       mm0,1
            pslld       mm5,1
            psrld       mm5,16
            psllw       mm5,8
            por         mm5,mm0
            movq        mm0,M8
            pmaddwd     mm5,mm0
            movq        mm0,mm4
            paddd       mm5,mm1
            psrad       mm5,8

            pslld       mm0,17
            psrlw       mm0,1
            pslld       mm4,1
            psrld       mm4,16
            psllw       mm4,8
            por         mm4,mm0
            movq        mm0,M8
            pmaddwd     mm4,mm0
            paddd       mm4,mm1
            psrad       mm4,8
#endif

            movq        t64,mm4

            pslld       mm1,6   //Generate 8192

            movd        mm0,[esi+ecx*2]
            punpcklwd   mm0,mm0
            pslld       mm0,16
            psrad       mm0,8
            paddd       mm0,mm1
            movd        mm4,[esi+ecx*2+64]
            punpcklwd   mm4,mm4
            pslld       mm4,16
            psrad       mm4,8
            movq        mm1,mm0
            psubd       mm0,mm4
            paddd       mm4,mm1

            movq        mm1,mm4
            psubd       mm4,mm3
            paddd       mm3,mm1

            movq        mm1,mm0
            psubd       mm0,mm2
            paddd       mm2,mm1

            movq        mm1,mm3
            psubd       mm3,mm6
            psrad       mm3,14
            paddd       mm6,mm1
            psrad       mm6,14

            packssdw    mm6,mm6
            packuswb    mm6,mm6
            movd        eax,mm6
            mov         [edi],ax

            lea         ebx,[edi+edx*8]
            sub         ebx,edx
            packssdw    mm3,mm3
            packuswb    mm3,mm3
            movd        eax,mm3
            mov         [ebx],ax

            movq        mm6,t64

            movq        mm1,mm4
            psubd       mm4,mm7
            psrad       mm4,14
            paddd       mm7,mm1
            psrad       mm7,14

            packssdw    mm4,mm4
            packuswb    mm4,mm4
            movd        eax,mm4
            mov         [edi+edx*4],ax
            lea         ebx,[edi+edx*2]
            packssdw    mm7,mm7
            packuswb    mm7,mm7
            movd        eax,mm7
            mov         [ebx+edx],ax

            movq        mm1,mm2
            psubd       mm2,mm5
            psrad       mm2,14
            paddd       mm5,mm1
            psrad       mm5,14

            lea         ebx,[ebx+edx*2]
            packssdw    mm2,mm2
            packuswb    mm2,mm2
            movd        eax,mm2
            mov         [ebx+edx*2],ax
            
            packssdw    mm5,mm5
            packuswb    mm5,mm5
            movd        eax,mm5
            mov         [edi+edx],ax
  
            movq        mm3,mm0
            psubd       mm0,mm6
            psrad       mm0,14
            paddd       mm6,mm3
            psrad       mm6,14
            packssdw    mm0,mm0
            packuswb    mm0,mm0
            movd        eax,mm0
            mov         [ebx+edx],ax
            packssdw    mm6,mm6
            packuswb    mm6,mm6
            movd        eax,mm6
            mov         [edi+edx*2],ax

            add         edi,2
            add         ecx,2
            cmp         ecx,8
            jnz         VLoop
            emms
        }    
}

// MMX Version
// Input:  16-bit
// Output: 16-bit
Void_WMV g_8x4IDCTDecMMX_WMV2 (Buffer __huge* piDstBuf, I32_WMV iOffsetToNextRowForDCT, const Buffer __huge* rgiCoefReconBuf, I32_WMV iHalf)
{
    const PixelI __huge* rgiCoefRecon =  (PixelI*)rgiCoefReconBuf;
    PixelI __huge* piDst = piDstBuf->i16 + (iHalf*32);
	PixelI * blk = piDst;
	I32_WMV x0, x1, x2, x3, x4, x5, x6, x7, x8;
	I32_WMV i;

    for (i = 0; i < 4; i++, blk += iOffsetToNextRowForDCT, rgiCoefRecon += BLOCK_SIZE)
    {
        x4 = rgiCoefRecon [1];		
        x3 = rgiCoefRecon [2];
	    x7 = rgiCoefRecon [3];
	    x1 = (I32_WMV)rgiCoefRecon [4] << 11;
	    x6 = rgiCoefRecon [5];
	    x2 = rgiCoefRecon [6];		
	    x5 = rgiCoefRecon [7];

        *blk = rgiCoefRecon [0];

		x0 = (I32_WMV)((I32_WMV)blk [0] << 11) + 128L; /* for proper rounding in the fourth stage */
		/* first stage */
		x8 = W7 * (x4 + x5);
		x4 = x8 + (W1 - W7) * x4;
		x5 = x8 - (W1 + W7) * x5;
		x8 = W3 * (x6 + x7);
		x6 = x8 - (W3 - W5) * x6;
		x7 = x8 - (W3 + W5) * x7;

		/* second stage */
		x8 = x0 + x1;
		x0 -= x1;
		x1 = W6 * (x3 + x2);
		x2 = x1 - (W2 + W6) * x2;
		x3 = x1 + (W2 - W6) * x3;
		x1 = x4 + x6;
		x4 -= x6;
		x6 = x5 + x7;
		x5 -= x7;

		/* third stage */
		x7 = x8 + x3;
		x8 -= x3;
		x3 = x0 + x2;
		x0 -= x2;
		x2 = (I32_WMV)(181L * (x4 + x5) + 128L) >> 8;
		x4 = (I32_WMV)(181L * (x4 - x5) + 128L) >> 8;

		/* fourth stage */
		blk [0] = (PixelI) ((x7 + x1) >> 8);
		blk [1] = (PixelI) ((x3 + x2) >> 8);
		blk [2] = (PixelI) ((x0 + x4) >> 8);
		blk [3] = (PixelI) ((x8 + x6) >> 8);
		blk [4] = (PixelI) ((x8 - x6) >> 8);
		blk [5] = (PixelI) ((x0 - x4) >> 8);
		blk [6] = (PixelI) ((x3 - x2) >> 8);
		blk [7] = (PixelI) ((x7 - x1) >> 8);
    }

    {
        PixelI* blk0 = piDst;
        PixelI* blk1 = blk0 + iOffsetToNextRowForDCT;
        PixelI* blk2 = blk1 + iOffsetToNextRowForDCT;
        PixelI* blk3 = blk2 + iOffsetToNextRowForDCT;
        
        for (i = 0; i < BLOCK_SIZE; i++)
        {
            x4 = blk0[i];
            x5 = blk1[i];
            x6 = blk2[i];
            x7 = blk3[i];
            
            x0 = (x4 + x6)*W2a;
            x1 = (x4 - x6)*W2a;
            x2 = x5*W1a + x7*W3a;
            x3 = x5*W3a - x7*W1a;
            
            blk0[i] = (PixelI)((x0 + x2 + 32768L)>>16);
            blk1[i] = (PixelI)((x1 + x3 + 32768L)>>16);
            blk2[i] = (PixelI)((x1 - x3 + 32768L)>>16);
            blk3[i] = (PixelI)((x0 - x2 + 32768L)>>16);
        }
    }
}

// MMX Version
// Input:  16-bit
// Output: 16-bit
Void_WMV g_4x8IDCTDecMMX_WMV2 (Buffer __huge* piDstBuf, I32_WMV iOffsetToNextRowForDCT, const Buffer __huge* rgiCoefReconBuf, I32_WMV iHalf)
{
    const PixelI __huge* rgiCoefRecon = (PixelI*)rgiCoefReconBuf;
	PixelI __huge* piDst = piDstBuf->i16 + (iHalf*4);
	PixelI * blk = piDst;
	I32_WMV x0, x1, x2, x3, x4, x5, x6, x7, x8;
	I32_WMV i;

    for (i = 0; i < BLOCK_SIZE; i++, blk += iOffsetToNextRowForDCT, rgiCoefRecon += 4){

        x4 = rgiCoefRecon[0];
        x5 = rgiCoefRecon[1];
        x6 = rgiCoefRecon[2];
        x7 = rgiCoefRecon[3];

        x0 = (x4 + x6)*W2a;
        x1 = (x4 - x6)*W2a;
        x2 = x5*W1a + x7*W3a;
        x3 = x5*W3a - x7*W1a;

        blk[0] = (PixelI)((x0 + x2 + 64)>>7);
        blk[1] = (PixelI)((x1 + x3 + 64)>>7);
        blk[2] = (PixelI)((x1 - x3 + 64)>>7);
        blk[3] = (PixelI)((x0 - x2 + 64)>>7);
    }

    {
        PixelI* blk0 = piDst;
        PixelI* blk1 = blk0 + iOffsetToNextRowForDCT;
        PixelI* blk2 = blk1 + iOffsetToNextRowForDCT;
        PixelI* blk3 = blk2 + iOffsetToNextRowForDCT;
        PixelI* blk4 = blk3 + iOffsetToNextRowForDCT;
        PixelI* blk5 = blk4 + iOffsetToNextRowForDCT;
        PixelI* blk6 = blk5 + iOffsetToNextRowForDCT;
        PixelI* blk7 = blk6 + iOffsetToNextRowForDCT;
        
        for (i = 0; i < 4; i++)
        {
            x0 = (I32_WMV)((I32_WMV)blk0[i] << 8) + 8192L;
            x1 = (I32_WMV)blk4[i] << 8;
            x2 = blk6[i];
            x3 = blk2[i];
            x4 = blk1[i];
            x5 = blk7[i];
            x6 = blk5[i];
            x7 = blk3[i];
            
            /* first stage */
            x8 = W7 * (x4 + x5) + 4;
            x4 = (x8 + (W1 - W7) * x4) >> 3;
            x5 = (x8 - (W1 + W7) * x5) >> 3;
            x8 = W3 * (x6 + x7) + 4;
            x6 = (x8 - (W3 - W5) * x6) >> 3;
            x7 = (x8 - (W3 + W5) * x7) >> 3;
            
            /* second stage */
            x8 = x0 + x1;
            x0 -= x1;
            x1 = W6 * (x3 + x2) + 4;
            x2 = (x1 - (W2 + W6) * x2) >> 3;
            x3 = (x1 + (W2 - W6) * x3) >> 3;
            x1 = x4 + x6;
            x4 -= x6;
            x6 = x5 + x7;
            x5 -= x7;
            
            /* third stage */
            x7 = x8 + x3;
            x8 -= x3;
            x3 = x0 + x2;
            x0 -= x2;
            x2 = (I32_WMV) (181L * (x4 + x5) + 128L) >> 8;
            x4 = (I32_WMV) (181L * (x4 - x5) + 128L) >> 8;
            
            /* fourth stage */
            blk0[i] = (PixelI) ((x7 + x1) >> 14);
            blk1[i] = (PixelI) ((x3 + x2) >> 14);
            blk2[i] = (PixelI) ((x0 + x4) >> 14);
            blk3[i] = (PixelI) ((x8 + x6) >> 14);
            blk4[i] = (PixelI) ((x8 - x6) >> 14);
            blk5[i] = (PixelI) ((x0 - x4) >> 14);
            blk6[i] = (PixelI) ((x3 - x2) >> 14);
            blk7[i] = (PixelI) ((x7 - x1) >> 14);
        }
    }
}

// MMX Version
// Input:  16-bit
// Output: 16-bit
Void_WMV g_IDCTDecMMX_WMV2 (Buffer __huge* piDst, Buffer __huge* piSrc, I32_WMV iOffsetToNextRowForDCT, I32_WMV iDCTHorzFlags)
{
    static const Int64 M1 = 0x023508E4023508E4;     //W7,W1-W7
    static const Int64 M2 = 0x0235F2B20235F2B2;     //W7,0-(W1+W7)
    static const Int64 M3 = 0x0968FCE10968FCE1;     //W3,0-(W3-W5)
    static const Int64 M4 = 0x0968F04F0968F04F;     //W3,0-(W3+W5)
    static const Int64 M5 = 0x0454F1380454F138;     //W6,0-(W2+W6)
    static const Int64 M6 = 0x0454062004540620;     //W6,W2-W6
    static const Int64 M7 = 0x0000008000000080;
    static const Int64 M8 = 0x00B55a8000B55a80;     //181,(181<<16)
    static const Int64 M9 = 0x0000023500000235;
    static const Int64 M10 = 0x000000B5000000B5;    //181,181
    static const Int64 low15mask =  0x00007fff00007fff;
    I16_WMV buf[96];
    __int64 t64;
    I32_WMV iDCTFlag = iDCTHorzFlags;

    PixelI *rgiCoefRecon = (PixelI*)piSrc;
    PixelI *blk          = buf; 

        _asm{
            mov         esi,rgiCoefRecon
            mov         edi,blk
            mov         ecx,-4
            xor         ebx,ebx
HLoop:
            mov         eax,iDCTFlag
            shr         iDCTFlag,2
            and         eax,3
            test        eax,eax
            jnz         Calculate
            
#if 0            
            lea         eax,[esi+ecx*4]
            movq        mm0,[eax+16+64]
            movq        mm4,[eax+16+16]
            por         mm0,mm4
            movq        mm5,[eax+16+112]
            por         mm0,mm5
            movq        mm6,[eax+16+80]
            por         mm0,mm6
            movq        mm7,[eax+16+48]
            por         mm0,mm7
            movq        mm3,[eax+16+32]
            por         mm0,mm3
            movq        mm2,[eax+16+96]
            por         mm0,mm2

            movd        eax,mm0
            test        eax,eax
            jnz         Calculate
#endif

            movd        mm2,[esi+ecx*4+16]
            psllw       mm2,3
            punpcklwd   mm2,mm2
            movq        mm1,mm2
            punpckldq   mm2,mm2
            movq        [edi]   ,mm2
            punpckhdq   mm1,mm1
            movq        [edi+8] ,mm2
            psrlq       mm0,32
            movq        [edi+16],mm1
//            movd        eax,mm0
            inc         ecx
            movq        [edi+24],mm1
            lea         edi,[edi+32]
            jnl         EndHLoop
            jmp         HLoop

#if 0            
            test        eax,eax
            jnz         CalcSpecial

            movd        mm2,[esi+ecx*4+16]
            psllw       mm2,3
            punpcklwd   mm2,mm2
            movq        mm1,mm2
            punpckldq   mm2,mm2
            movq        [edi]   ,mm2
            punpckhdq   mm1,mm1
            movq        [edi+8] ,mm2
            inc         ecx
            movq        [edi+16],mm1
            movq        [edi+24],mm1
            lea         edi,[edi+32]
            jnl         EndHLoop
            jmp         HLoop

CalcSpecial:
            psrlq       mm4,32
            psrlq       mm5,32
            movd        mm2,[esi+ecx*4+16+96]
            psrlq       mm6,32
            psrlq       mm7,32
            psrlq       mm3,32
#endif
            
Calculate:  
            lea         eax,[esi+ecx*4]
//            movq        mm0,[eax+16+64]
            movq        mm4,[eax+16+16]
            movq        mm5,[eax+16+112]
            movq        mm6,[eax+16+80]
            movq        mm7,[eax+16+48]
            movq        mm3,[eax+16+32]
            movq        mm2,[eax+16+96]

            mov         ebx,esi
   
            movq        mm0,mm4
            paddw       mm0,mm5
            punpcklwd   mm4,mm0
            punpcklwd   mm5,mm0
            movq        mm1,M1
            movq        mm0,mm6
            pmaddwd     mm4,mm1
            movq        mm1,M2
            paddw       mm0,mm7
         
            punpcklwd   mm6,mm0
            pmaddwd     mm5,mm1
            punpcklwd   mm7,mm0
            movq        mm1,M3
            movq        mm0,mm3
            pmaddwd     mm6,mm1
            movq        mm1,M4
            paddw       mm0,mm2
            
            punpcklwd   mm3,mm0
            pmaddwd     mm7,mm1
            punpcklwd   mm2,mm0
            movq        mm1,M6
            pmaddwd     mm3,mm1
            movq        mm0,mm6
            movq        mm1,M5
            paddd       mm6,mm4
            pmaddwd     mm2,mm1

            psubd       mm4,mm0

            movq        mm0,mm7
            paddd       mm7,mm5
            psubd       mm5,mm0

            movq        mm0,mm5
            paddd       mm5,mm4
            psubd       mm4,mm0

            movq        mm0,mm5
            pand        mm0,low15mask
            movq        mm1,M10
            pmaddwd     mm0,mm1
            psrld       mm5,15
            pmaddwd     mm5,mm1
            pslld       mm5,15
            paddd       mm5,mm0
            movq        mm0,M7
            paddd       mm5,mm0
            psrad       mm5,8

            movq        mm0,mm4
            pand        mm0,low15mask
            pmaddwd     mm0,mm1
            psrld       mm4,15
            pmaddwd     mm4,mm1
            pslld       mm4,15
            paddd       mm4,mm0
            movq        mm1,M7
            paddd       mm4,mm1
            psrad       mm4,8

            movd        mm0,[esi+ecx*4+16]
            lea         eax,[esi+ecx*4]
            movq        [edi+4],mm4
            punpcklwd   mm0,mm0
            pslld       mm0,16
            psrad       mm0,5
            movq        mm1,M7
            paddd       mm0,mm1
            movd        mm1,[eax+16+64]
            punpcklwd   mm1,mm1
            pslld       mm1,16
            psrad       mm1,5
            movq        mm4,mm0
            psubd       mm0,mm1
            paddd       mm1,mm4

            movq        mm4,mm1
            psubd       mm1,mm3
            paddd       mm3,mm4

            movq        mm4,mm0
            psubd       mm0,mm2
            paddd       mm2,mm4

            movq        mm4,mm3
            psubd       mm3,mm6
            paddd       mm6,mm4
            psrad       mm3,8
            psrad       mm6,8

#if 0 // Old way of generating (181*(x4 + x5) + 128)>>8. Overflowed in certain cases
            movq        mm4,mm5
            pslld       mm4,17
            psrlw       mm4,1
            pslld       mm5,1
            psrld       mm5,16
            psllw       mm5,8
            por         mm5,mm4
            movq        mm4,M8
            pmaddwd     mm5,mm4
            movq        mm4,M7
            paddd       mm5,mm4
            psrad       mm5,8
#endif

            movq        mm4,mm2
            psubd       mm2,mm5
            paddd       mm5,mm4
            psrad       mm2,8
            psrad       mm5,8

            movq        mm4,mm6
            punpckldq   mm6,mm5
            punpckhdq   mm4,mm5
            packssdw    mm6,mm6
            
            movq        mm5,mm2
            punpckldq   mm2,mm3
            movd        [edi],mm6
            punpckhdq   mm5,mm3
            packssdw    mm5,mm5
            movd        [edi+12+16],mm5
            packssdw    mm2,mm4
            movq        mm4,[edi+4]
            movq        [edi+12],mm2

#if 0 // Old way of generating (181*(x4 + x5) + 128)>>8. Overflowed in certain cases
            movq        mm2,mm4
            pslld       mm4,17
            psrlw       mm4,1
            pslld       mm2,1
            psrld       mm2,16
            psllw       mm2,8
            por         mm2,mm4
            movq        mm4,M8
            pmaddwd     mm4,mm2
            movq        mm2,M7
            paddd       mm4,mm2
            psrad       mm4,8
#endif
            
            movq        mm2,mm0
            psubd       mm0,mm4
            paddd       mm4,mm2
            psrad       mm0,8
            psrad       mm4,8

            movq        mm2,mm1
            psubd       mm1,mm7
            paddd       mm7,mm2
            psrad       mm1,8
            psrad       mm7,8

            movq        mm2,mm4
            punpckldq   mm4,mm7
            punpckhdq   mm2,mm7

            movq        mm7,mm1
            punpckldq   mm1,mm0
            punpckhdq   mm7,mm0
            packssdw    mm4,mm1
            movq        [edi+4],mm4
            packssdw    mm2,mm7
            inc         ecx
            movq        [edi+4+16],mm2
            lea         edi,[edi+32]
            jl          HLoop
EndHLoop:
            test        ebx,ebx
            jz          VFast

            xor         ecx,ecx
VLoop:                
            mov         esi,blk
            mov         edi,piDst

            lea         edi,[edi+ecx*2]
            mov         edx,iOffsetToNextRowForDCT
            shl         edx,1

            movd        mm4,[esi+ecx*2+16]
            pcmpeqb     mm1,mm1    //Generate constant 4
            psrld       mm1,31
            movd        mm5,[esi+ecx*2+112]
            pslld       mm1,2
            
            movq        mm0,mm4
            paddw       mm0,mm5
            punpcklwd   mm4,mm0
            punpcklwd   mm5,mm0
            movq        mm0,M1
            pmaddwd     mm4,mm0
            paddd       mm4,mm1
            movq        mm0,M2
            pmaddwd     mm5,mm0
            movd        mm6,[esi+ecx*2+80]
            paddd       mm5,mm1
            psrad       mm4,3
            movd        mm7,[esi+ecx*2+48]
            psrad       mm5,3
      
            movq        mm0,mm6
            paddw       mm0,mm7
            punpcklwd   mm6,mm0
            punpcklwd   mm7,mm0
            movq        mm0,M3
            pmaddwd     mm6,mm0
            paddd       mm6,mm1
            movq        mm0,M4
            pmaddwd     mm7,mm0
            movd        mm2,[esi+ecx*2+96]
            paddd       mm7,mm1
            psrad       mm6,3
            movd        mm3,[esi+ecx*2+32]
            psrad       mm7,3

            movq        mm0,mm2
            paddw       mm0,mm3
            punpcklwd   mm2,mm0
            punpcklwd   mm3,mm0
            movq        mm0,M5
            pmaddwd     mm2,mm0
            paddd       mm2,mm1
            movq        mm0,M6
            pmaddwd     mm3,mm0
            paddd       mm3,mm1
            psrad       mm2,3
            psrad       mm3,3

            movq        mm0,mm4
            psubd       mm4,mm6
            paddd       mm6,mm0

            movq        mm0,mm5
            psubd       mm5,mm7
            paddd       mm7,mm0

            movq        mm0,mm4
            psubd       mm4,mm5
            paddd       mm5,mm0

            movq        mm0,mm5
            pand        mm0,low15mask
            movq        mm1,M10
            pmaddwd     mm0,mm1
            psrld       mm5,15
            pmaddwd     mm5,mm1
            pslld       mm5,15
            paddd       mm5,mm0
            movq        mm0,M7
            paddd       mm5,mm0
            psrad       mm5,8            

            movq        mm0,mm4
            pand        mm0,low15mask
            pmaddwd     mm0,mm1
            psrld       mm4,15
            pmaddwd     mm4,mm1
            pslld       mm4,15
            paddd       mm4,mm0
            movq        mm1,M7
            paddd       mm4,mm1
            psrad       mm4,8
            
#if 0 // Old way of generating (181*(x4 + x5) + 128)>>8. Overflowed in certain cases

            pslld       mm1,5  //Generate constant 128
            movq        mm0,mm5
            pslld       mm0,17
            psrlw       mm0,1
            pslld       mm5,1
            psrld       mm5,16
            psllw       mm5,8
            por         mm5,mm0
            movq        mm0,M8
            pmaddwd     mm5,mm0
            movq        mm0,mm4
            paddd       mm5,mm1
            psrad       mm5,8

            pslld       mm0,17
            psrlw       mm0,1
            pslld       mm4,1
            psrld       mm4,16
            psllw       mm4,8
            por         mm4,mm0
            movq        mm0,M8
            pmaddwd     mm4,mm0
            paddd       mm4,mm1
            psrad       mm4,8
#endif           
           
            movq        t64,mm4

            pslld       mm1,6   //Generate 8192

            movd        mm0,[esi+ecx*2]
            punpcklwd   mm0,mm0
            pslld       mm0,16
            psrad       mm0,8
            paddd       mm0,mm1
            movd        mm4,[esi+ecx*2+64]
            punpcklwd   mm4,mm4
            pslld       mm4,16
            psrad       mm4,8
            movq        mm1,mm0
            psubd       mm0,mm4
            paddd       mm4,mm1

            movq        mm1,mm4
            psubd       mm4,mm3
            paddd       mm3,mm1

            movq        mm1,mm0
            psubd       mm0,mm2
            paddd       mm2,mm1

            movq        mm1,mm3
            psubd       mm3,mm6
            psrad       mm3,14
            paddd       mm6,mm1
            psrad       mm6,14

            packssdw    mm6,mm6
            movd        [edi],mm6                        

            lea         ebx,[edi+edx*8]
            sub         ebx,edx

            packssdw    mm3,mm3
            movd        [ebx],mm3                   

            movq        mm6,t64

            movq        mm1,mm4
            psubd       mm4,mm7
            psrad       mm4,14
            paddd       mm7,mm1
            psrad       mm7,14

            packssdw    mm4,mm4
            movd        [edi+edx*4],mm4            

            lea         ebx,[edi+edx*2]
            movq        mm1,mm2
            
            packssdw    mm7,mm7
            movd        [ebx+edx],mm7             
            
            psubd       mm2,mm5
            psrad       mm2,14
            paddd       mm5,mm1
            psrad       mm5,14

            lea         ebx,[ebx+edx*2]
            packssdw    mm2,mm2
            movd        [ebx+edx*2],mm2
  
            movq        mm3,mm0
            psubd       mm0,mm6

            packssdw    mm5,mm5
            movd        [edi+edx],mm5           
            
            psrad       mm0,14
            paddd       mm6,mm3
            psrad       mm6,14

            packssdw    mm0,mm0
            movd        [ebx+edx],mm0       

            add         ecx,2
            cmp         ecx,8

            packssdw    mm6,mm6
            movd        [edi+edx*2],mm6     

            jnz         VLoop
            jmp         End

VFast:
            mov         esi,blk
            mov         edi,piDst

            mov         edx,iOffsetToNextRowForDCT
            shl         edx,1

            movd        mm4,[esi+16]
            pcmpeqb     mm1,mm1    //Generate constant 4
            psrld       mm1,31
            movd        mm5,[esi+112]
            pslld       mm1,2
            
            movq        mm0,mm4
            paddw       mm0,mm5
            punpcklwd   mm4,mm0
            punpcklwd   mm5,mm0
            movq        mm0,M1
            pmaddwd     mm4,mm0
            paddd       mm4,mm1
            movq        mm0,M2
            pmaddwd     mm5,mm0
            movd        mm6,[esi+80]
            paddd       mm5,mm1
            psrad       mm4,3
            movd        mm7,[esi+48]
            psrad       mm5,3
      
            movq        mm0,mm6
            paddw       mm0,mm7
            punpcklwd   mm6,mm0
            punpcklwd   mm7,mm0
            movq        mm0,M3
            pmaddwd     mm6,mm0
            paddd       mm6,mm1
            movq        mm0,M4
            pmaddwd     mm7,mm0
            movd        mm2,[esi+96]
            paddd       mm7,mm1
            psrad       mm6,3
            movd        mm3,[esi+32]
            psrad       mm7,3

            movq        mm0,mm2
            paddw       mm0,mm3
            punpcklwd   mm2,mm0
            punpcklwd   mm3,mm0
            movq        mm0,M5
            pmaddwd     mm2,mm0
            paddd       mm2,mm1
            movq        mm0,M6
            pmaddwd     mm3,mm0
            paddd       mm3,mm1
            psrad       mm2,3
            psrad       mm3,3

            movq        mm0,mm4
            psubd       mm4,mm6
            paddd       mm6,mm0

            movq        mm0,mm5
            psubd       mm5,mm7
            paddd       mm7,mm0

            movq        mm0,mm4
            psubd       mm4,mm5
            paddd       mm5,mm0

            movq        mm0,mm5
            pand        mm0,low15mask
            movq        mm1,M10
            pmaddwd     mm0,mm1
            psrld       mm5,15
            pmaddwd     mm5,mm1
            pslld       mm5,15
            paddd       mm5,mm0
            movq        mm0,M7
            paddd       mm5,mm0
            psrad       mm5,8            

            movq        mm0,mm4
            pand        mm0,low15mask
            pmaddwd     mm0,mm1
            psrld       mm4,15
            pmaddwd     mm4,mm1
            pslld       mm4,15
            paddd       mm4,mm0
            movq        mm1,M7
            paddd       mm4,mm1
            psrad       mm4,8
            
#if 0 // Old way of generating (181*(x4 + x5) + 128)>>8. Overflowed in certain cases

            pslld       mm1,5  //Generate constant 128
            movq        mm0,mm5
            pslld       mm0,17
            psrlw       mm0,1
            pslld       mm5,1
            psrld       mm5,16
            psllw       mm5,8
            por         mm5,mm0
            movq        mm0,M8
            pmaddwd     mm5,mm0
            movq        mm0,mm4
            paddd       mm5,mm1
            psrad       mm5,8

            pslld       mm0,17
            psrlw       mm0,1
            pslld       mm4,1
            psrld       mm4,16
            psllw       mm4,8
            por         mm4,mm0
            movq        mm0,M8
            pmaddwd     mm4,mm0
            paddd       mm4,mm1
            psrad       mm4,8
#endif
            
            movq        t64,mm4

            pslld       mm1,6   //Generate 8192

            movd        mm0,[esi]
            punpcklwd   mm0,mm0
            pslld       mm0,16
            psrad       mm0,8
            paddd       mm0,mm1
            movd        mm4,[esi+64]
            punpcklwd   mm4,mm4
            pslld       mm4,16
            psrad       mm4,8
            movq        mm1,mm0
            psubd       mm0,mm4
            paddd       mm4,mm1

            movq        mm1,mm4
            psubd       mm4,mm3
            paddd       mm3,mm1

            movq        mm1,mm0
            psubd       mm0,mm2
            paddd       mm2,mm1

            movq        mm1,mm3
            psubd       mm3,mm6
            psrad       mm3,14
            paddd       mm6,mm1
            psrad       mm6,14

            packssdw    mm6,mm6    
            movq        [edi],mm6

            lea         ebx,[edi+edx*8]
            sub         ebx,edx
            movq        [edi+8],mm6
            packssdw    mm3,mm3
            movq        [ebx],mm3

            movq        mm6,t64

            movq        mm1,mm4
            movq        [ebx+8],mm3
            psubd       mm4,mm7
            psrad       mm4,14
            paddd       mm7,mm1
            psrad       mm7,14

            packssdw    mm4,mm4
            movq        [edi+edx*4],mm4

            lea         ebx,[edi+edx*2]

            movq        mm1,mm2
            movq        [edi+edx*4+8],mm4
            psubd       mm2,mm5
            packssdw    mm7,mm7
            movq        [ebx+edx],mm7

            psrad       mm2,14
            paddd       mm5,mm1
            movq        [ebx+edx+8],mm7
            psrad       mm5,14

            lea         ebx,[ebx+edx*2]
            packssdw    mm2,mm2
            movq        [ebx+edx*2],mm2
  
            packssdw    mm5,mm5
            movq        [ebx+edx*2+8],mm2

            movq        mm3,mm0
            psubd       mm0,mm6
            movq        [edi+edx],mm5
            psrad       mm0,14
            paddd       mm6,mm3
            movq        [edi+edx+8],mm5
            psrad       mm6,14

            packssdw    mm0,mm0
            movq        [ebx+edx],mm0
            movq        [ebx+edx+8],mm0

            packssdw    mm6,mm6
            movq        [edi+edx*2],mm6
            movq        [edi+edx*2+8],mm6


End:        emms

            } 
}
#endif // _WMV_TARGET_X86_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\huffDTbl.c ===
// **************************************************************************
// Huffman Decoder Tables
//
// These tables are automatically generated by HuffDec.exe. Please do not
// edit these tables by hand. Instead you should make the necessary changes
// to HuffDec.exe and re-generate table using the program.
// **************************************************************************

const U16 g_rgiHuffDecTblMsk[226] =
{
  0x843c, 0x843c, 0x00a4, 0x0001, 0x903e, 0x009d, 0x0098, 0x0001, 
  0x0092, 0x008d, 0x0084, 0x0001, 0x007e, 0x0079, 0x0074, 0x0001, 
  0x006e, 0x0069, 0x005c, 0x0001, 0x0056, 0x0051, 0x0048, 0x0001, 
  0x0042, 0x003b, 0x0002, 0x000f, 0x0034, 0x0007, 0x0002, 0x0097, 
  0x0002, 0x00a5, 0xc800, 0x00a1, 0x0004, 0x0001, 0xc801, 0xc802, 
  0xc813, 0xc803, 0x00a4, 0x000d, 0x0002, 0x0015, 0x0006, 0x0001, 
  0x0002, 0x000d, 0xcc77, 0xcc04, 0x0002, 0x0097, 0xcc0a, 0xcc05, 
  0x009c, 0x0001, 0x0002, 0x0005, 0xcc76, 0xcc06, 0xcc07, 0xcc0f, 
  0xcc08, 0xcc09, 0x0008, 0x0001, 0x0002, 0x0003, 0xcc0b, 0xcc0c, 
  0xcc0e, 0xcc0d, 0x0002, 0x0003, 0xcc10, 0xcc12, 0xcc14, 0xcc11, 
  0xc417, 0x0001, 0xc85a, 0xc815, 0xc01c, 0xc018, 0xc058, 0x0001, 
  0xc419, 0xc416, 0xc056, 0xc01d, 0xc01a, 0xc01b, 0xb854, 0xb820, 
  0x0052, 0x0001, 0xbc1e, 0xbc1e, 0xbc1f, 0xbc1f, 0xb855, 0xb821, 
  0xb824, 0xb822, 0xb453, 0xb453, 0xb825, 0xb823, 0xb050, 0xb028, 
  0x0006, 0x0001, 0xb452, 0xb452, 0xb426, 0xb426, 0xb451, 0xb451, 
  0xb427, 0xb427, 0xb02c, 0xb04f, 0xb02a, 0xb029, 0xac2d, 0xac2d, 
  0xac2b, 0xac2b, 0xa84a, 0xa82e, 0x0026, 0x0029, 0xa848, 0xa830, 
  0xa849, 0xa82f, 0xa431, 0xa431, 0xa447, 0xa447, 0xa034, 0xa045, 
  0xa033, 0x0001, 0xa446, 0xa446, 0xa432, 0xa432, 0x9c43, 0x9c43, 
  0xa035, 0xa044, 0x9c42, 0x9c42, 0x9c36, 0x9c36, 0x9838, 0x9840, 
  0x9837, 0x9841, 0x9439, 0x9439, 0x943f, 0x943f, 0x8c3b, 0x8c3b, 
  0x903d, 0x903a, 0xac4c, 0xac4c, 0xac4b, 0xac4b, 0xac4d, 0xac4d, 
  0xac4e, 0xac4e, 0xbc57, 0xbc57, 0xbc59, 0xbc59, 0x0002, 0x0007, 
  0x0002, 0x0003, 0xcc61, 0xcc5b, 0xcc5c, 0xcc5d, 0x0002, 0x0003, 
  0xcc5e, 0xcc5f, 0xcc60, 0xcc68, 0xcc62, 0xcc63, 0x0002, 0x0003, 
  0xcc64, 0xcc65, 0xcc66, 0xcc75, 0xcc67, 0xcc78, 0x000c, 0x0001, 
  0x0010, 0x0001, 0xcc6e, 0xcc69, 0x0002, 0x0003, 0xcc6a, 0xcc6b, 
  0xcc6c, 0xcc6d, 0x0002, 0x0003, 0xcc6f, 0xcc70, 0xcc71, 0xcc72, 
  0xcc73, 0xcc74
}; 

const U16 g_rgiHuffDecTblNoisePower[76] = {
    0x0004,
    0x003b,
    0x0042,
    0x0045,
    0x0004,
    0x900c,
    0x0016,
    0x9012,
    0x0004,
    0x000f,
    0x940a,
    0x940a,
    0x0004,
    0x0007,
    0xa017,
    0xa007,
    0xa819,
    0xa802,
    0xa81b,
    0xa800,
    0xa41f,
    0xa41f,
    0xa41e,
    0xa41e,
    0xa01d,
    0xa01a,
    0x9c18,
    0x9c18,
    0x9414,
    0x9414,
    0x9816,
    0x0001,
    0x9c08,
    0x9c08,
    0x0002,
    0x0015,
    0xa821,
    0x0003,
    0xa404,
    0xa404,
    0x0004,
    0x0007,
    0x000a,
    0xb001,
    0xb420,
    0xb420,
    0xb405,
    0xb405,
    0xb422,
    0xb422,
    0xb423,
    0xb423,
    0xb424,
    0xb424,
    0xb403,
    0xb403,
    0xa406,
    0xa406,
    0xa41c,
    0xa41c,
    0x9010,
    0x0003,
    0x900b,
    0x9013,
    0x9415,
    0x9415,
    0x9409,
    0x9409,
    0x8c0e,
    0x8c0e,
    0x8c0f,
    0x8c0f,
    0x8c0d,
    0x8c0d,
    0x8c11,
    0x8c11};

#if defined (INSERT_VERSION_INFO)
const U16 g_rgiHuffDecTbl16smOb[] =
#else
const U16 g_rgiHuffDecTbl16smOb[872] =
#endif // INSERT_VERSION_INFO
{
  0x8802, 0x0017, 0x001e, 0x0001, 0x002c, 0x9005, 0x0026, 0x0001, 
  0x0004, 0x003b, 0x980d, 0x0079, 0x0004, 0x006b, 0xa017, 0x0071, 
  0x0004, 0x00bb, 0x0242, 0xa824, 0xb034, 0xb000, 0xad14, 0xad14, 
  0x9073, 0x000b, 0x9004, 0x0001, 0x0018, 0x002b, 0x9801, 0x98e8, 
  0x8c03, 0x8c03, 0x002a, 0x0005, 0x9406, 0x9406, 0x0032, 0x9809, 
  0x980a, 0x000f, 0x9407, 0x9407, 0x0014, 0x980c, 0x9408, 0x9408, 
  0x003c, 0x980b, 0x0022, 0x0009, 0xa013, 0x002b, 0x9c0e, 0x9c0e, 
  0x9c0f, 0x9c0f, 0x0042, 0xa15a, 0x9c10, 0x9c10, 0x0036, 0x00f1, 
  0x9c11, 0x9c11, 0x9d3a, 0x9d3a, 0xa018, 0x0063, 0x9c12, 0x9c12, 
  0x004c, 0xa076, 0x0076, 0xa014, 0x94b7, 0x94b7, 0x9874, 0x0001, 
  0x0064, 0x0013, 0x0016, 0xa015, 0x0110, 0xa016, 0x004a, 0xa077, 
  0xa0b8, 0x0003, 0x9d12, 0x9d12, 0xa419, 0xa419, 0x002e, 0xa8ba, 
  0x0084, 0xa820, 0xa41a, 0xa41a, 0x00c4, 0xa821, 0xa41b, 0xa41b, 
  0x00a4, 0xa87c, 0xa41c, 0xa41c, 0x0004, 0x008f, 0x9c75, 0x9c75, 
  0xa8bb, 0xa993, 0xa41d, 0xa41d, 0xa823, 0xa87e, 0xa41e, 0xa41e, 
  0x0060, 0x01b7, 0xa41f, 0xa41f, 0x0078, 0x020f, 0x001e, 0xa822, 
  0xa825, 0xa996, 0x005a, 0x0051, 0x0004, 0xa175, 0x000a, 0xa078, 
  0xa826, 0x008f, 0xa58e, 0xa58e, 0x00c4, 0x01af, 0xac27, 0xac27, 
  0x0040, 0x004f, 0xa828, 0xa880, 0x0004, 0xa87b, 0x0056, 0x0019, 
  0xad3b, 0xad3b, 0xac29, 0xac29, 0xac2a, 0xac2a, 0xacbd, 0xacbd, 
  0xa584, 0xa584, 0x0026, 0x0001, 0x0070, 0x00d3, 0xac2b, 0xac2b, 
  0xa8bc, 0x0003, 0xa47a, 0xa47a, 0x00f4, 0xb116, 0xac2c, 0xac2c, 
  0xb02e, 0xb02d, 0x0182, 0x0223, 0x0004, 0x0007, 0xa4b9, 0xa4b9, 
  0x01a8, 0xb02f, 0xb0ed, 0x0069, 0xb089, 0xb030, 0xad99, 0xad99, 
  0xa4e9, 0xa4e9, 0x0002, 0xa913, 0xac81, 0xac81, 0xb0bf, 0xb031, 
  0xb032, 0xb13c, 0x003e, 0x020f, 0xb033, 0xb0c2, 0x007a, 0x017d, 
  0xb185, 0x0173, 0xb090, 0xb035, 0xb036, 0x0125, 0xacec, 0xacec, 
  0xb037, 0x01c3, 0x012a, 0x0165, 0x00e8, 0xb038, 0xacbe, 0xacbe, 
  0x00c8, 0x01b3, 0xb039, 0x01fb, 0x01b4, 0x0133, 0x003a, 0x0001, 
  0xb43a, 0xb43a, 0x01ca, 0xb848, 0x0004, 0xb088, 0x015a, 0xb1a1, 
  0xb43b, 0xb43b, 0x0096, 0x0065, 0xb0c1, 0x00ed, 0x0002, 0x012b, 
  0xb849, 0xb8d1, 0xb43c, 0xb43c, 0x0004, 0x003f, 0x008e, 0xa87d, 
  0xb08c, 0x00b3, 0xb1a3, 0x0001, 0xb9b0, 0x01a3, 0xb43d, 0xb43d, 
  0xb43e, 0xb43e, 0x0228, 0x00cf, 0xad9c, 0xad9c, 0x0002, 0xb08b, 
  0x01c0, 0xb8f4, 0xb43f, 0xb43f, 0xb440, 0xb440, 0xb4ca, 0xb4ca, 
  0x0080, 0x0003, 0xac87, 0xac87, 0xb441, 0xb441, 0xb91b, 0xb9b4, 
  0x0064, 0xb8d0, 0xb842, 0x018d, 0xb491, 0xb491, 0xb845, 0xb843, 
  0x0004, 0xb08e, 0xb08a, 0x0021, 0x0030, 0xb844, 0x0092, 0xb93f, 
  0x0004, 0x009b, 0x00fa, 0xa87f, 0xb0c3, 0x0003, 0xac83, 0xac83, 
  0xb95e, 0xb898, 0xb846, 0xb8ce, 0x0004, 0xb176, 0xb08d, 0x0005, 
  0xb847, 0xb95d, 0xb53d, 0xb53d, 0xb84a, 0x013b, 0xb4c9, 0xb4c9, 
  0xb84b, 0xb8f8, 0x017e, 0xb8f7, 0xb9af, 0xb897, 0x0012, 0xb84c, 
  0xb8d3, 0x0003, 0x01dc, 0x00fd, 0xbc4d, 0xbc4d, 0xc106, 0xc0a9, 
  0xbdb2, 0xbdb2, 0xbc4e, 0xbc4e, 0xbc4f, 0xbc4f, 0xc0fe, 0xc12f, 
  0xc0a0, 0x008b, 0xbc50, 0xbc50, 0xa479, 0xa479, 0x0002, 0xa8ea, 
  0x0004, 0x0127, 0xac84, 0xac84, 0x00fc, 0x0003, 0x0012, 0x0005, 
  0xbc51, 0xbc51, 0xbc52, 0xbc52, 0xbc53, 0xbc53, 0xbda2, 0xbda2, 
  0x0134, 0xb8f9, 0xb9b1, 0x0001, 0xbc54, 0xbc54, 0xbd5f, 0xbd5f, 
  0xbc55, 0xbc55, 0xbd21, 0xbd21, 0xc056, 0xc0aa, 0xbd60, 0xbd60, 
  0xc0da, 0xc164, 0xc057, 0xc187, 0xac82, 0xac82, 0xb115, 0x0001, 
  0xb5aa, 0xb5aa, 0x0002, 0x0163, 0x007a, 0xc122, 0xc058, 0xc105, 
  0x0018, 0x0003, 0xb8d4, 0xb986, 0xbc59, 0xbc59, 0xbdb8, 0xbdb8, 
  0xb518, 0xb518, 0x001a, 0x0001, 0xbc5a, 0xbc5a, 0xbc5c, 0xbc5c, 
  0x0036, 0x00c3, 0x0002, 0x01b5, 0xc109, 0xc108, 0xbc5b, 0xbc5b, 
  0xbc5d, 0xbc5d, 0xbcdb, 0xbcdb, 0xb4c6, 0xb4c6, 0x0002, 0x0151, 
  0xc05f, 0xc153, 0xc0a2, 0xc05e, 0xbc9f, 0xbc9f, 0xbc60, 0xbc60, 
  0xc195, 0xc110, 0xc061, 0xc127, 0x004c, 0x00af, 0x0002, 0x0151, 
  0xc139, 0xc062, 0xc156, 0xc17e, 0xb08f, 0x0003, 0xad9f, 0xad9f, 
  0xb4f2, 0xb4f2, 0x001e, 0x0001, 0x00b2, 0x0003, 0xc14a, 0xc0dc, 
  0xc46f, 0xc463, 0xc1c0, 0xc064, 0xc131, 0xc162, 0xc066, 0xc10b, 
  0xc065, 0xc1a8, 0xb4c8, 0xb4c8, 0x0002, 0x008b, 0x0012, 0x015d, 
  0x0002, 0x002d, 0xc467, 0xc5cc, 0x0002, 0x0137, 0xc955, 0xc868, 
  0x0138, 0x0003, 0x0148, 0x0133, 0x0002, 0x00cf, 0xc972, 0xc869, 
  0xc46a, 0xc58d, 0x0122, 0x0003, 0xb4cf, 0xb4cf, 0xbca3, 0xbca3, 
  0xc1ca, 0x0001, 0xc46b, 0xc5d8, 0xb594, 0xb594, 0xb978, 0x0001, 
  0xbd7a, 0xbd7a, 0x0002, 0x0131, 0xc46c, 0xc4e4, 0xc46d, 0xc50c, 
  0x0130, 0x0003, 0xc0ab, 0xc0af, 0xc5d1, 0xc46e, 0xc4e7, 0xc470, 
  0xb5a7, 0xb5a7, 0x0002, 0x00e1, 0x00de, 0x0061, 0x0002, 0x0059, 
  0xc471, 0xc5c7, 0xb8f6, 0x0003, 0xb5a9, 0xb5a9, 0xc148, 0xc0a6, 
  0xc146, 0x0001, 0xc472, 0xc56a, 0x000c, 0x008b, 0xac85, 0xac85, 
  0xac86, 0xac86, 0xb0ee, 0xb0c4, 0xb896, 0xb93e, 0xb492, 0xb492, 
  0x011e, 0xb8d6, 0xb493, 0xb493, 0xb894, 0xb977, 0xb8f3, 0x00a3, 
  0xb495, 0xb495, 0xb4cc, 0xb4cc, 0xb499, 0xb499, 0xb49a, 0xb49a, 
  0xb89b, 0x00c3, 0xb4c5, 0xb4c5, 0xb91c, 0xb89c, 0xb4f1, 0xb4f1, 
  0xbcd5, 0xbcd5, 0xc09d, 0x0035, 0xb1a5, 0x0003, 0xad5b, 0xad5b, 
  0x0022, 0x0003, 0x00c6, 0x0093, 0xc09e, 0xc1bc, 0xc188, 0xc163, 
  0xb517, 0xb517, 0xb8f5, 0x0001, 0xc0a1, 0xc0a7, 0xbdb3, 0xbdb3, 
  0xc166, 0xc0a4, 0xbd00, 0xbd00, 0xc0a5, 0xc1c5, 0xc132, 0xc0ae, 
  0xc1a6, 0xc14b, 0xc0a8, 0xc143, 0xc16b, 0xc0b1, 0xc168, 0xc0ac, 
  0xc5c4, 0xc4ad, 0xc128, 0xc0b0, 0xc111, 0xc0b6, 0xc554, 0xc4b2, 
  0x00be, 0x00c9, 0x00b6, 0x0001, 0xc4b3, 0xc5c8, 0xc4b4, 0xc5d7, 
  0x003e, 0x0001, 0xc8b5, 0xc8e1, 0xaceb, 0xaceb, 0x0012, 0xb0c0, 
  0xb58f, 0xb58f, 0xb4c7, 0xb4c7, 0x002c, 0x006f, 0xb4cb, 0xb4cb, 
  0xb8cd, 0xb997, 0x004c, 0xb9ac, 0x004e, 0xb91e, 0xb4d2, 0xb4d2, 
  0xb55c, 0xb55c, 0x0002, 0xb919, 0xbcd7, 0xbcd7, 0xbcfd, 0xbcfd, 
  0xbcd8, 0xbcd8, 0xbdb6, 0xbdb6, 0xbd04, 0xbd04, 0xbcd9, 0xbcd9, 
  0xc0dd, 0x009b, 0xbcfc, 0xbcfc, 0xbd1f, 0xbd1f, 0xbcde, 0xbcde, 
  0xb5ab, 0xb5ab, 0x0038, 0x0001, 0xbd20, 0xbd20, 0xbcdf, 0xbcdf, 
  0xbce0, 0xbce0, 0xbcff, 0xbcff, 0xc938, 0xc8e2, 0xc90d, 0xc8e3, 
  0xbd1d, 0xbd1d, 0x0002, 0xc14c, 0xc5da, 0x0001, 0xc9d4, 0xc8e5, 
  0xbd90, 0xbd90, 0x0002, 0x0081, 0xc4e6, 0xc5d5, 0xb4ef, 0xb4ef, 
  0x003a, 0xb9ad, 0xb4f0, 0xb4f0, 0x0080, 0xb91a, 0xb8fa, 0x0021, 
  0xb5ae, 0xb5ae, 0xbd9d, 0xbd9d, 0xbcfb, 0xbcfb, 0xbd01, 0xbd01, 
  0x0060, 0x005d, 0xbd02, 0xbd02, 0xbd23, 0xbd23, 0xbd03, 0xbd03, 
  0xbd25, 0xbd25, 0xbd07, 0xbd07, 0xbd44, 0xbd44, 0xc10a, 0xc198, 
  0xc14e, 0xc192, 0xc56e, 0xc50e, 0xc145, 0xc161, 0xc10f, 0xc12b, 
  0xbd24, 0xbd24, 0xbd79, 0xbd79, 0xbd47, 0xbd47, 0xbd26, 0xbd26, 
  0xc17b, 0xc129, 0xc1bf, 0xc149, 0xbd9a, 0xbd9a, 0x0028, 0x0001, 
  0xc52a, 0xc552, 0x0004, 0x0051, 0xc1c3, 0xc1a4, 0xc534, 0xc52c, 
  0xc1cd, 0xc17f, 0xc12d, 0xc1c1, 0xc191, 0xc19b, 0xbd2e, 0xbd2e, 
  0xc165, 0xc150, 0xc142, 0xc130, 0xc933, 0xc9ce, 0xc535, 0xc569, 
  0x0002, 0x0019, 0x0002, 0xc98c, 0xcd37, 0xcd36, 0xbd40, 0xbd40, 
  0xbdb5, 0xbdb5, 0xbd41, 0xbd41, 0xc167, 0xc14d, 0xc54f, 0xc559, 
  0xc5cb, 0xc551, 0xc557, 0xc5c9, 0xc58a, 0xc558, 0xc56c, 0xc56d, 
  0xc56f, 0xc581, 0xc970, 0xc971, 0xc57d, 0xc573, 0xc574, 0xc59e, 
  0x001e, 0xc57c, 0xc580, 0xc5d9, 0xc5d3, 0x0001, 0xc9d2, 0x0001, 
  0xcddb, 0x0001, 0x0008, 0xd182, 0xc583, 0xc5cf, 0xc189, 0xc1be, 
  0xbdb9, 0xbdb9, 0xd5d0, 0xd58b, 0xbdb7, 0xbdb7, 0xbda0, 0xbda0, 
  0xbdba, 0xbdba, 0xbdbb, 0xbdbb, 0xc5c2, 0xc5bd, 0xc9c6, 0xc9d6,
#if defined (INSERT_VERSION_INFO)
  // Magic string
  0x4d57, 0x5641, 0x5245, 0x4953, 0x4e4f, 
  // Length of version info (num U16's)
  0x0005, 
  // version info
  0xbadc, 0x0deb, 0xadc0, 0xdeba, 0xdc0d,
#endif // INSERT_VERSION_INFO
}; 

const U16 g_rgiHuffDecTbl44smOb[2847] = {
0x8802,
0x0003,
0x0453,
0x0687,
0x8c03,
0x8c03,
0x9004,
0x0001,
0x0004,
0x01fc,
0x0297,
0x030b,
0x9cb9,
0x9cb9,
0x0002,
0x018a,
0x0004,
0xab5c,
0x0006,
0x009f,
0xaf93,
0xaf93,
0xac16,
0xac16,
0x0004,
0xb3b9,
0x0055,
0x0058,
0xbb5d,
0x0003,
0x003d,
0x004a,
0x0004,
0x0014,
0x0024,
0x0030,
0x0002,
0x000a,
0x0002,
0x0004,
0xcefd,
0xcffc,
0x0423,
0xcffd,
0xcffd,
0x04e8,
0x04d9,
0x0002,
0x0003,
0xcde8,
0xce1b,
0xce0c,
0xcee6,
0x0002,
0x0009,
0x0002,
0x0004,
0xcffd,
0xcf35,
0x0432,
0xcffd,
0xce1c,
0x04fe,
0x0002,
0x0004,
0xce4a,
0xcffc,
0x04f5,
0xcf58,
0xcd05,
0x0002,
0x0007,
0x0002,
0x0003,
0xcd9c,
0xcc8b,
0xcc9c,
0xcd11,
0x0002,
0xc87a,
0xcd12,
0xcffc,
0x0516,
0x0002,
0x0003,
0xc87d,
0xcb61,
0xcbfd,
0xcbfd,
0x048b,
0x0488,
0x0004,
0x0008,
0x0009,
0xc35e,
0x0002,
0xc4e9,
0xcbfd,
0xc9c7,
0x04ac,
0xc54a,
0xc596,
0xc7fd,
0xc545,
0x0468,
0xc2cb,
0x0003,
0xbccb,
0xbccb,
0xc543,
0xc672,
0xb7de,
0xb7de,
0xb7e0,
0xb7e0,
0x0004,
0x0018,
0x001b,
0x0034,
0xbfff,
0xbfff,
0x0004,
0x0005,
0x042a,
0x042a,
0xc462,
0xc4ea,
0xc7fd,
0x0002,
0x0472,
0x0002,
0xc8f3,
0xcd60,
0x0001,
0x0002,
0x0003,
0xd707,
0xd521,
0xd705,
0xd791,
0xc04f,
0xc1bd,
0xbe32,
0xbe32,
0xc3ff,
0x0004,
0x000a,
0x000f,
0x0447,
0x0002,
0x0003,
0xc873,
0xca76,
0xcbfd,
0xc8f0,
0x04ae,
0x0002,
0x0003,
0xcbb0,
0xc94e,
0xc9d0,
0xcaf9,
0x0002,
0x0005,
0xcbfd,
0xcbfd,
0x04bb,
0x04ad,
0xcb7e,
0xcbf4,
0x0006,
0xc270,
0xbffd,
0xbffd,
0x042e,
0x042e,
0xc542,
0xc544,
0x0004,
0x0033,
0x007c,
0x00c9,
0x0004,
0xb92f,
0xb9f3,
0x0007,
0xbfff,
0xbfff,
0xbe6d,
0xbe6d,
0x0427,
0x0427,
0xc2ab,
0xc181,
0x0002,
0x0003,
0xc730,
0xc4ed,
0xc540,
0x0001,
0x0002,
0x0010,
0x0002,
0x0008,
0x0002,
0x0003,
0xd6bf,
0xd703,
0xd7fd,
0xd6bc,
0x051f,
0x0002,
0x0003,
0xd6a3,
0xd4b5,
0xd5ea,
0xd5eb,
0x0002,
0x0007,
0x0002,
0x0003,
0xd6e2,
0xd65c,
0xd716,
0xd570,
0x0002,
0xd261,
0xd7fd,
0xd65e,
0x0504,
0xb426,
0xb426,
0xb82f,
0x0001,
0xbd7d,
0xbd7d,
0x0002,
0x0022,
0x0002,
0x0012,
0x0002,
0x0008,
0x0002,
0x0003,
0xd337,
0xd0b4,
0xd1e9,
0xd3fc,
0x0534,
0x0002,
0x0004,
0xd3fd,
0xd11a,
0x0530,
0xd34e,
0xd3fc,
0x052f,
0x0002,
0x0007,
0x0002,
0x0003,
0xd2a4,
0xd11c,
0xd0a7,
0xd167,
0x0002,
0x0003,
0xd0a4,
0xd0a3,
0xd0a2,
0xd2e1,
0x0002,
0x000f,
0x0002,
0x0007,
0x0002,
0x0003,
0xd2dd,
0xd28b,
0xd226,
0xd379,
0x0002,
0x0003,
0xd227,
0xd21a,
0xd25d,
0xd313,
0x0002,
0x0008,
0x0002,
0x0003,
0xd2da,
0xd382,
0xd311,
0xd3fc,
0x0535,
0x0002,
0x0003,
0xd087,
0xd295,
0xd3fd,
0xd3fd,
0x050f,
0x0515,
0xb578,
0xb578,
0xbbfd,
0x0002,
0x0403,
0x0004,
0x0019,
0x0028,
0x0036,
0x0002,
0x000f,
0x0002,
0x000b,
0x0002,
0x0005,
0xd3fd,
0xd3fd,
0x0511,
0x0519,
0xd3fd,
0xd3fd,
0x04ff,
0x0528,
0xcfc2,
0xcfca,
0x0002,
0x0003,
0xcd68,
0xcf62,
0xcf63,
0xcf66,
0x0002,
0x0008,
0x0002,
0x0003,
0xce04,
0xcff2,
0xcffd,
0xccf8,
0x04d7,
0x0002,
0x0003,
0xceb8,
0xce7b,
0xcc93,
0xcffc,
0x04e9,
0x0002,
0x0007,
0x0002,
0x0003,
0xcd0f,
0xcf9f,
0xcd09,
0xcf2a,
0x0002,
0x0003,
0xce51,
0xcd07,
0xcffd,
0xcefe,
0x0500,
0x0002,
0x0007,
0x0002,
0x0003,
0xcde1,
0xcfc7,
0xce62,
0xcfb5,
0x0002,
0x0004,
0xcc9b,
0xcffc,
0x04ea,
0xcffd,
0xcca6,
0x0428,
0x0004,
0x0016,
0xb8c7,
0xb9b8,
0x0004,
0x0009,
0x000a,
0x000d,
0x0002,
0x0003,
0xcb88,
0xc959,
0xc990,
0xc958,
0xc4e0,
0xc460,
0xc7fd,
0xc7fd,
0x0467,
0x0485,
0xc673,
0xc7fc,
0x0471,
0xc04d,
0xc0d6,
0xbc3e,
0xbc3e,
0xa719,
0xa719,
0x0002,
0x0027,
0xacbe,
0xacbe,
0xb01d,
0x0001,
0x0004,
0x001a,
0xb52d,
0xb52d,
0xbc41,
0xbc41,
0x0002,
0x0010,
0xc586,
0x0001,
0xcbfd,
0x0002,
0x047f,
0xcffd,
0x0002,
0x04b4,
0xd3fd,
0x0002,
0x0510,
0xd69b,
0x0001,
0xda9c,
0xdb15,
0xc7fd,
0xc7fd,
0x047a,
0x046b,
0x0004,
0xc052,
0xbc3f,
0xbc3f,
0xc7d6,
0xc7fc,
0x0473,
0x0004,
0xb3bd,
0xaf9a,
0xaf9a,
0x0004,
0x0010,
0x002a,
0x0033,
0xc0d7,
0x0005,
0xbffd,
0xbffd,
0x042c,
0x042c,
0x0002,
0x0004,
0xcbfd,
0xc8f4,
0x0404,
0xcb43,
0xc953,
0x0004,
0x000b,
0x0012,
0x0015,
0x0002,
0x0004,
0xca12,
0xcbfc,
0x04a9,
0xcbfd,
0xca79,
0x049c,
0x0002,
0x0004,
0xcbfd,
0xc9cf,
0x04b7,
0xcbfd,
0xcb21,
0x0490,
0x0002,
0xc638,
0xcb32,
0xc9d2,
0xc4e6,
0xc7fc,
0x046d,
0xc3ff,
0xc2f4,
0x0003,
0x0005,
0x0453,
0xc587,
0xc7fc,
0x0463,
0xc5fb,
0xc5c3,
0x0005,
0xc235,
0xc3fd,
0xc182,
0x044b,
0xc637,
0xc7fc,
0x0470,
0x0004,
0xa0ba,
0xa00b,
0x006e,
0xa4bb,
0xa4bb,
0x0002,
0xab67,
0xad29,
0xad29,
0xb0c0,
0x0001,
0x0005,
0xbbfe,
0x0008,
0x002c,
0x0406,
0xbf8c,
0xbf8c,
0xc3b7,
0xc3fc,
0x044d,
0xc3ff,
0xc3ff,
0x0004,
0x0013,
0x0459,
0x044f,
0x0002,
0x0008,
0x0002,
0x0004,
0xcffd,
0xcd24,
0x04ef,
0xcde7,
0xcd62,
0x0002,
0x0003,
0xce41,
0xce4d,
0xcffd,
0xcd10,
0x0503,
0x0002,
0x0008,
0x0002,
0x0003,
0xcd6a,
0xce85,
0xcffd,
0xcea5,
0x0522,
0x0002,
0x0003,
0xceb6,
0xcc90,
0xce91,
0xced2,
0x0004,
0x0015,
0x0025,
0x002b,
0x0002,
0x0009,
0x0002,
0x0003,
0xcee5,
0xcde4,
0xcffd,
0xcffd,
0x04d0,
0x04dc,
0x0002,
0x0004,
0xcffd,
0xce5a,
0x04fd,
0xcffd,
0xcc80,
0x04d8,
0x0002,
0x000b,
0x0002,
0x0005,
0xcffd,
0xcffd,
0x04f8,
0x0425,
0xcffd,
0xcffd,
0x0419,
0x0411,
0x0002,
0xca03,
0xcffd,
0xcfd7,
0x040f,
0x0002,
0x0004,
0xcbfd,
0xcab4,
0x04a0,
0xc950,
0xc9d5,
0x0002,
0x0005,
0xcbfd,
0xcbfd,
0x0491,
0x04a7,
0xc874,
0xcb33,
0xa812,
0x0003,
0xa40e,
0xa40e,
0xb01e,
0xb2c8,
0x0002,
0xb1f1,
0x0004,
0xb831,
0x000e,
0x0011,
0x0005,
0x0007,
0x0008,
0xc3fc,
0x0452,
0xc7fd,
0xc6ae,
0x047d,
0xc541,
0xc4e2,
0xc461,
0xc597,
0xbc42,
0xbc42,
0xbd34,
0xbd34,
0x0004,
0x0005,
0x0006,
0x0008,
0xc6cf,
0xc75f,
0xc4e5,
0xc6af,
0xc465,
0xc7fc,
0x047c,
0xc7fd,
0xc7fd,
0x0475,
0x0482,
0x9d26,
0x9d26,
0xa2a6,
0x0001,
0xa401,
0xa401,
0x0002,
0x0014,
0xac17,
0xac17,
0x0002,
0xb3c0,
0xb4c3,
0xb4c3,
0x0002,
0x0008,
0x0004,
0xc0dc,
0xbeca,
0xbeca,
0xc787,
0xc7fc,
0x0474,
0xbdf6,
0xbdf6,
0xbf2e,
0xbf2e,
0x0004,
0x0007,
0x0021,
0x004a,
0xb7e2,
0xb7e2,
0xb7e6,
0xb7e6,
0x0004,
0x0009,
0xb72d,
0xb72d,
0xc32f,
0xc055,
0xbffd,
0xbffd,
0x0429,
0x0429,
0xbc3d,
0xbc3d,
0x0002,
0x0008,
0x0002,
0x0003,
0xc9d6,
0xcbfa,
0xcbfd,
0xcab1,
0x04cb,
0x0002,
0x0003,
0xca77,
0xc9ce,
0xca78,
0xcb55,
0x0004,
0x0013,
0xb97b,
0x0021,
0x0004,
0x000c,
0xbc40,
0xbc40,
0x0002,
0x0004,
0xc86b,
0xcbfc,
0x04b2,
0xcbfd,
0xcbfd,
0x04a1,
0x03fc,
0xc7fd,
0xc598,
0x046f,
0xbfff,
0xbfff,
0xc053,
0x0003,
0x0431,
0x0431,
0xc46e,
0x0001,
0xc957,
0x0001,
0x0002,
0x0003,
0xd339,
0xd0a9,
0xd328,
0xd34a,
0xbdbb,
0xbdbb,
0xbffd,
0xbffd,
0x042b,
0x042b,
0xb427,
0xb427,
0xbac9,
0x0001,
0xc369,
0x0004,
0x0005,
0xc3fc,
0x0451,
0xc466,
0xc5fd,
0xc594,
0xc6f6,
0x0004,
0x00d7,
0x9c09,
0x9c09,
0xa9f0,
0xa928,
0x0002,
0x0097,
0xafa0,
0xafa0,
0x0002,
0x000a,
0x0005,
0xbbfe,
0xb7e8,
0xb7e8,
0x040a,
0xbf94,
0xbf94,
0xbd33,
0xbd33,
0xbb68,
0xbbfe,
0x0003,
0x0040,
0x0408,
0xc056,
0xc2cc,
0x0002,
0x0022,
0x0002,
0x0010,
0x0002,
0x0007,
0x0002,
0x0003,
0xd349,
0xd0b2,
0xd30f,
0xd34b,
0x0002,
0x0004,
0xd3fd,
0xd10a,
0x052d,
0xd30a,
0xd34c,
0x0002,
0x0008,
0x0002,
0x0003,
0xd0ac,
0xd165,
0xd123,
0xd3fc,
0x0509,
0x0002,
0x0004,
0xd3fd,
0xd25f,
0x052b,
0xd228,
0xd267,
0x0002,
0x0010,
0x0002,
0x0007,
0x0002,
0x0003,
0xd246,
0xd298,
0xd259,
0xd171,
0x0002,
0x0003,
0xd1e3,
0xd2c3,
0xd29d,
0xd3fc,
0x0507,
0x0002,
0x0003,
0xce80,
0xccae,
0xcffd,
0xcffd,
0x04eb,
0x04c7,
0x0004,
0x0013,
0x0022,
0x0032,
0x0002,
0x0007,
0x0002,
0x0003,
0xceff,
0xcf8f,
0xce49,
0xcfbc,
0x0002,
0x0004,
0xcffd,
0xcc91,
0x042d,
0xcfbf,
0xcffc,
0x0506,
0x0002,
0x0008,
0x0002,
0x0004,
0xcc98,
0xcffc,
0x04e7,
0xcebb,
0xccb6,
0x0002,
0x0003,
0xcded,
0xce25,
0xce24,
0xcffc,
0x0532,
0x0002,
0x000a,
0x0002,
0x0005,
0xcffd,
0xcffd,
0x04ca,
0x04de,
0xce7d,
0xcffc,
0x050d,
0x0002,
0x0003,
0xced5,
0xccff,
0xcd69,
0xced6,
0x0002,
0x0008,
0x0002,
0x0004,
0xcfd1,
0xcffc,
0x04e1,
0xcf48,
0xcfd4,
0x0002,
0x0004,
0xcffd,
0xcd9e,
0x04f2,
0xcffd,
0xcd15,
0x051d,
0xac00,
0xac00,
0x0002,
0xb01f,
0x0004,
0x002a,
0xb5b6,
0xb5b6,
0x0004,
0x0012,
0x0018,
0x001e,
0x0002,
0x0008,
0x0002,
0x0003,
0xcd1d,
0xce8e,
0xcdec,
0xcffc,
0x04ce,
0x0003,
0xcbfc,
0x04b5,
0xcffd,
0xcf24,
0x04d3,
0x0002,
0x0003,
0xc95b,
0xc9cd,
0xc9c6,
0xcbfc,
0x04bc,
0x0002,
0x0004,
0xcbfd,
0xc87e,
0x04cd,
0xc9af,
0xc9ee,
0x0002,
0x0003,
0xca05,
0xca3f,
0xcbf8,
0xc954,
0x0004,
0x0005,
0x0007,
0xc183,
0xc46a,
0xc5fc,
0xc591,
0xc7fc,
0x0481,
0xc6f7,
0xc731,
0x0004,
0x0040,
0xa72c,
0xa72c,
0x0004,
0xb3c5,
0x0013,
0xb3c8,
0x0004,
0x000c,
0xb428,
0xb428,
0xbfff,
0xbfff,
0xc3af,
0x0003,
0x0434,
0x0434,
0xc7fd,
0xc7dc,
0x0476,
0xbccc,
0xbccc,
0xc057,
0xc1f9,
0x0004,
0x000b,
0x0012,
0xb8c8,
0xc050,
0x0005,
0xbffd,
0xbffd,
0x0430,
0x0430,
0xc741,
0xc639,
0x0006,
0xc058,
0xbffd,
0xbffd,
0x0436,
0x0436,
0xc4e7,
0xc463,
0xc138,
0xc3fe,
0x0003,
0x000a,
0x0454,
0x0002,
0x0004,
0xcbfd,
0xcafa,
0x04c5,
0xcbfd,
0xca3e,
0x0499,
0x0002,
0x0004,
0xc8f7,
0xcbfc,
0x04a8,
0xca4c,
0xc87f,
0x0004,
0xb12b,
0xae6a,
0xae6a,
0xb5f2,
0xb5f2,
0xb830,
0x0001,
0x0004,
0x000a,
0x0011,
0x0016,
0x0002,
0x0004,
0xcbfd,
0xc87c,
0x04a4,
0xcb56,
0xc9d9,
0x0002,
0x0004,
0xcbab,
0xcbfc,
0x049b,
0xcb57,
0xcbfc,
0x04b6,
0x0002,
0x0003,
0xcba6,
0xcb60,
0xc901,
0xc9ca,
0x0003,
0xc7fc,
0x0478,
0xcbee,
0xc9d3,
0x8cb7,
0x8cb7,
0x0002,
0x0005,
0x9807,
0x99b2,
0x94b8,
0x94b8,
0x0004,
0x015c,
0x9573,
0x9573,
0x0004,
0x00df,
0x9e2d,
0x9e2d,
0x0004,
0xab70,
0x0047,
0xa975,
0x0004,
0x002d,
0xac18,
0xac18,
0x0005,
0x0011,
0x0020,
0xbbfc,
0x040e,
0x0004,
0x0006,
0x0007,
0xc051,
0xc7fd,
0xc464,
0x046a,
0xc54c,
0xc469,
0xc7fd,
0xc7fd,
0x046e,
0x0477,
0x0005,
0xc3fe,
0xbccf,
0xbccf,
0x044c,
0xc588,
0x0001,
0xcbfd,
0x0002,
0x03fe,
0x0002,
0xcfda,
0xd258,
0x0001,
0xd697,
0xd717,
0xbccd,
0xbccd,
0x0002,
0x0003,
0xc71f,
0xc71e,
0xc7d3,
0xc7d9,
0xb832,
0x0003,
0xb66b,
0xb66b,
0xbc43,
0xbc43,
0xc340,
0x0001,
0x0002,
0x0008,
0x0002,
0x0003,
0xcc9f,
0xce81,
0xcf83,
0xcffc,
0x051e,
0x0002,
0x0003,
0xcfe4,
0xcc97,
0xcd14,
0xccaa,
0x0004,
0x002c,
0xb020,
0x007b,
0xb9b9,
0x0004,
0xbbfd,
0xb835,
0x040c,
0xbc45,
0xbc45,
0x0002,
0x0010,
0x0002,
0x0007,
0x0002,
0x0003,
0xcf26,
0xcc8e,
0xce52,
0xcd00,
0x0002,
0x0003,
0xce84,
0xcd5c,
0xcf59,
0xcffc,
0x0513,
0x0002,
0x0007,
0x0002,
0x0003,
0xcf6e,
0xcf64,
0xcf99,
0xcc8c,
0x0002,
0x0005,
0xcffd,
0xcffd,
0x0525,
0x0517,
0xced8,
0xcffc,
0x041f,
0x0004,
0x0030,
0x0043,
0x0048,
0x0004,
0x0014,
0x001e,
0x0023,
0x0002,
0x0008,
0x0002,
0x0004,
0xcffd,
0xce4f,
0x04da,
0xcddc,
0xcfac,
0x0002,
0x0004,
0xcffd,
0xcfb1,
0x04f7,
0xcffd,
0xce23,
0x04f0,
0x0002,
0x0007,
0x0002,
0xc877,
0xcffd,
0xcffd,
0x04fc,
0x04e0,
0xcbfd,
0xc9c9,
0x04db,
0x0002,
0x0003,
0xc9ae,
0xc885,
0xc886,
0xc882,
0x0002,
0x0003,
0xc99f,
0xc884,
0xcbfd,
0xc9cc,
0x04cf,
0x0004,
0x000a,
0x000d,
0x000f,
0x0002,
0x0004,
0xc9cb,
0xcbfc,
0x04ba,
0xc95f,
0xc956,
0x0002,
0xc7df,
0xc8f5,
0xc95a,
0xc4e8,
0xc7fc,
0x0484,
0xc53f,
0xc4e3,
0x0004,
0xc3c1,
0xbc44,
0xbc44,
0xc754,
0xc468,
0xbe33,
0xbe33,
0xbffd,
0xbffd,
0x043a,
0x043a,
0x0004,
0xb834,
0xb833,
0x0009,
0x0004,
0xc0dd,
0xc1bf,
0x0003,
0xc5ff,
0xc76a,
0xc5fe,
0xc589,
0xbf9b,
0xbf9b,
0x0002,
0x0004,
0xc7fd,
0xc6f8,
0x049e,
0xc58a,
0xc592,
0xa813,
0x0003,
0x0028,
0x003f,
0xafa4,
0xafa4,
0x0002,
0x0007,
0xbbff,
0xbbff,
0xb7ed,
0xb7ed,
0x0412,
0x0416,
0x0005,
0xb930,
0xbb71,
0xbbfc,
0x0410,
0xbfff,
0xbfff,
0xc3ff,
0x0004,
0x0438,
0x0438,
0x045d,
0x0002,
0x000c,
0x0002,
0xc95d,
0xcffd,
0x0002,
0x04ed,
0x0003,
0xd3fc,
0x052c,
0xd6e3,
0xd7fc,
0x0533,
0xcbfd,
0xcb8e,
0x04b8,
0xadb4,
0xadb4,
0xb3cc,
0x0001,
0xba6c,
0x0003,
0xb7eb,
0xb7eb,
0xbd7e,
0xbd7e,
0x0002,
0x0007,
0x0002,
0x0003,
0xc961,
0xc8fa,
0xc98e,
0xca13,
0x0003,
0xc7fc,
0x047b,
0xc9de,
0xcbfc,
0x04d2,
0xb177,
0x0003,
0x001b,
0x0030,
0x0004,
0x0009,
0xb73e,
0xb73e,
0xc3ff,
0xc3ff,
0xbeaa,
0xbeaa,
0x045a,
0x0458,
0xbc47,
0xbc47,
0x0002,
0xc1be,
0xc7fd,
0x0002,
0x048d,
0xc9a0,
0x0001,
0x0002,
0x0003,
0xd2d7,
0xd2a2,
0xd304,
0xd2e4,
0x0004,
0x000b,
0xb4c4,
0xb4c4,
0xc3ba,
0x0005,
0xbffd,
0xbffd,
0x043c,
0x043c,
0xc795,
0xc5c4,
0xbfff,
0xbfff,
0x0004,
0xc236,
0x0433,
0x0433,
0xc7fd,
0xc7fd,
0x0489,
0x0480,
0xb429,
0xb429,
0xb579,
0xb579,
0x0004,
0xa174,
0x0006,
0xa00c,
0xa5b3,
0xa5b3,
0xa40f,
0xa40f,
0x0004,
0x00bf,
0xab7b,
0x00c1,
0xb0c1,
0x0003,
0x00a8,
0xb2f1,
0xb9f4,
0x0003,
0x0042,
0x0084,
0xbd35,
0xbd35,
0x0002,
0x0021,
0x0002,
0x0010,
0x0002,
0x0007,
0x0002,
0x0003,
0xd29f,
0xd346,
0xd29a,
0xd308,
0x0002,
0x0003,
0xd30d,
0xd296,
0xd302,
0xd3fc,
0x052e,
0x0002,
0x0007,
0x0002,
0x0003,
0xd28f,
0xd27f,
0xd27c,
0xd265,
0x0002,
0x0003,
0xd253,
0xd264,
0xd3fd,
0xd117,
0x0520,
0x0002,
0x0012,
0x0002,
0x0009,
0x0002,
0x0004,
0xd3fd,
0xd0af,
0x052a,
0xd222,
0xd3fc,
0x051c,
0x0002,
0x0004,
0xd256,
0xd3fc,
0x0521,
0xd166,
0xd21f,
0x0002,
0x0006,
0x0003,
0xcffc,
0x0523,
0xd219,
0xd220,
0xcf29,
0xcede,
0x0004,
0x0014,
0x0024,
0x0032,
0x0002,
0x0008,
0x0002,
0x0003,
0xcedf,
0xcd0e,
0xcffd,
0xcdad,
0x050a,
0x0002,
0x0003,
0xcde0,
0xcec4,
0xcffd,
0xcffd,
0x04e4,
0x04d6,
0x0002,
0x0009,
0x0002,
0x0004,
0xcffd,
0xcfa7,
0x0505,
0xcffd,
0xcca0,
0x0439,
0x0002,
0x0003,
0xcf77,
0xcd72,
0xcfc3,
0xcffc,
0x0502,
0x0002,
0x0008,
0x0002,
0x0004,
0xce44,
0xcffc,
0x0501,
0xcc9d,
0xcf4d,
0x0002,
0x0003,
0xcf84,
0xccab,
0xcf98,
0xcca1,
0x0002,
0x0007,
0x0002,
0x0003,
0xceee,
0xce63,
0xce68,
0xce54,
0x0003,
0xcbfc,
0x0409,
0xcffd,
0xce90,
0x04f3,
0x0004,
0x000a,
0x0011,
0x0019,
0x0002,
0x0004,
0xcbfd,
0xcb7f,
0x04c8,
0xca4b,
0xc8fb,
0x0002,
0x0004,
0xcb74,
0xcbfc,
0x04d5,
0xcb96,
0xcbfc,
0x04dd,
0x0002,
0x0005,
0xcbfd,
0xcbfd,
0x04bf,
0x0400,
0xcbfd,
0xca02,
0x04a2,
0xc54b,
0xc7fc,
0x0496,
0x0004,
0x000d,
0xb52e,
0xb52e,
0x0006,
0x0007,
0xc3fd,
0xc3fd,
0x0455,
0x045f,
0xc595,
0xc78d,
0xc54d,
0xc7a2,
0xbcce,
0xbcce,
0xbc46,
0xbc46,
0xac19,
0xac19,
0xb021,
0xb1b5,
0xafa9,
0xafa9,
0xad76,
0xad76,
0x9125,
0x0003,
0x0346,
0x9005,
0x0004,
0x016c,
0x9406,
0x9406,
0xa2c7,
0x0003,
0x0064,
0x0154,
0xa73d,
0xa73d,
0x0002,
0xa8bd,
0x0004,
0x001c,
0x0049,
0x0057,
0x0004,
0x0009,
0xb7f0,
0xb7f0,
0xc054,
0xc3fe,
0xc3fe,
0xc147,
0x0457,
0x0462,
0x0004,
0x0006,
0x0007,
0xc139,
0xc551,
0xc7fc,
0x047e,
0xc6d0,
0xc58c,
0xc7fd,
0x0002,
0x0487,
0xc94f,
0xcbfc,
0x04aa,
0x0004,
0x0015,
0x0027,
0xb836,
0xbe6e,
0xbe6e,
0x0002,
0x0008,
0x0002,
0x0003,
0xc9a8,
0xcbbb,
0xca3d,
0xcbfc,
0x04b3,
0x0002,
0x0003,
0xc8fe,
0xc9a3,
0xc9a9,
0xcbfc,
0x04b0,
0x0004,
0x0009,
0x000d,
0x000e,
0x0002,
0x0003,
0xcb23,
0xca07,
0xcb6b,
0xca06,
0x0002,
0xc7e3,
0xcbfd,
0xc9c8,
0x04bd,
0xc467,
0xc742,
0xc7f6,
0xc63b,
0xbc4a,
0xbc4a,
0xc05a,
0xc3fc,
0x045b,
0xb8c9,
0xbbfe,
0xbbfe,
0x0003,
0x0414,
0x0418,
0xbfff,
0xbfff,
0x0004,
0xc0de,
0x043d,
0x043d,
0xc7fd,
0xc479,
0x048a,
0xb7f5,
0xb7f5,
0xb42a,
0xb42a,
0x0004,
0xa814,
0x0028,
0x00ae,
0xacbf,
0xacbf,
0x0002,
0xb3cf,
0x0004,
0x000a,
0xb97c,
0x000c,
0xc148,
0xc3fe,
0xbffe,
0xbffe,
0x0456,
0x0442,
0x0442,
0xbfa1,
0xbfa1,
0xbf3f,
0xbf3f,
0x0004,
0xc2ad,
0xbdf7,
0xbdf7,
0xc471,
0x0001,
0x0002,
0x0009,
0x0003,
0xcffc,
0x04e6,
0xd3fd,
0x0002,
0x051a,
0xd56f,
0xd666,
0xcee7,
0xcffc,
0x04e5,
0x0004,
0x0029,
0xafae,
0xafae,
0xb7f3,
0xb7f3,
0x0002,
0xb837,
0xbcd9,
0xbcd9,
0x0002,
0x0010,
0x0002,
0x0008,
0x0002,
0x0003,
0xcefc,
0xcf10,
0xcebe,
0xcffc,
0x0405,
0x0002,
0x0003,
0xce9e,
0xcfdd,
0xcf38,
0xce8a,
0x0002,
0x0008,
0x0002,
0x0004,
0xcffd,
0xce87,
0x042f,
0xce86,
0xcf5b,
0x0002,
0x0003,
0xcfcb,
0xcf65,
0xce8c,
0xcfc4,
0xb42b,
0xb42b,
0x0002,
0x003f,
0x0004,
0x0017,
0x0028,
0x0033,
0x0002,
0x000a,
0x0002,
0x0005,
0xcffd,
0xcffd,
0x0437,
0x043b,
0xce18,
0xcffc,
0x050b,
0x0002,
0x0004,
0xcc96,
0xcffc,
0x0512,
0xcffd,
0xcffd,
0x0529,
0x0526,
0x0002,
0x0009,
0x0002,
0x0005,
0xcffd,
0xcffd,
0x0514,
0x04f6,
0xcda4,
0xce47,
0x0002,
0x0004,
0xcffd,
0xcd08,
0x0524,
0xcd13,
0xcffc,
0x051b,
0x0002,
0x0008,
0x0002,
0x0004,
0xcffd,
0xcd6d,
0x04fb,
0xcddb,
0xce4e,
0xc8fc,
0xcbfc,
0x0413,
0x0002,
0x0004,
0xcbfd,
0xca7a,
0x0417,
0xc89a,
0xcbfc,
0x04b1,
0x0004,
0x0009,
0x000e,
0x0013,
0x0002,
0x0003,
0xcad9,
0xc8f9,
0xc8f6,
0xc904,
0x0002,
0x0003,
0xc9a1,
0xca0f,
0xca0d,
0xc88d,
0x0002,
0x0003,
0xc9d7,
0xcb22,
0xcb34,
0xcbb8,
0x0003,
0xc7fc,
0x048f,
0xcb44,
0xcb45,
0x0004,
0x0019,
0xb022,
0x002a,
0x0004,
0x000d,
0x0010,
0xbb7c,
0x0005,
0x0006,
0xc271,
0xc3fc,
0x045c,
0xc58f,
0xc7e1,
0xc7fd,
0xc79c,
0x0483,
0xc3be,
0xc3cd,
0xbd7f,
0xbd7f,
0xbe34,
0xbe34,
0xc184,
0xc149,
0xb4c5,
0xb4c5,
0x0002,
0x000b,
0xc185,
0x0003,
0xbcd0,
0xbcd0,
0x0003,
0xc7fc,
0x0492,
0xcbfd,
0xc955,
0x04c4,
0xc3ff,
0xc2ac,
0xbfa5,
0xbfa5,
0x045e,
0x0006,
0xbbfe,
0x000d,
0xbbfd,
0x041a,
0x041b,
0xbcd3,
0xbcd3,
0xc059,
0x0001,
0xc7fd,
0x0002,
0x0479,
0xc883,
0xca2b,
0xbcd2,
0xbcd2,
0xbc48,
0xbc48,
0x0004,
0xab85,
0xa410,
0xa410,
0xac1a,
0xac1a,
0xb3d2,
0x0001,
0xbaf2,
0x0003,
0xb7f7,
0xb7f7,
0xc05b,
0xc372,
0xc3fd,
0xc3fd,
0x0450,
0x0465,
0x0004,
0x0111,
0x9c0a,
0x9c0a,
0x0004,
0x0061,
0xa750,
0xa750,
0x0004,
0xb3d5,
0x003a,
0xb12c,
0x0004,
0xb839,
0x0023,
0x002e,
0x0004,
0x000a,
0x0011,
0x0017,
0x0002,
0x0003,
0xca10,
0xca09,
0xc889,
0xcbfc,
0x04c6,
0x0002,
0x0004,
0xcab5,
0xcbfc,
0x0402,
0xcb75,
0xcbfc,
0x040b,
0x0002,
0x0003,
0xcad3,
0xca50,
0xc902,
0xcbfc,
0x04c0,
0x0002,
0x0003,
0xcb36,
0xc895,
0xcbfd,
0xcb9d,
0x04b9,
0x0004,
0x0005,
0xc1c0,
0x0006,
0xc7f1,
0xc4ef,
0xc7fd,
0xc58d,
0x049a,
0xc472,
0xc7fc,
0x049d,
0xbc49,
0xbc49,
0xc13a,
0x0001,
0xc59a,
0xc7fc,
0x0494,
0x0004,
0x0009,
0xb7f9,
0xb7f9,
0xbfff,
0xbfff,
0xbdf8,
0xbdf8,
0x043e,
0x043e,
0x0005,
0xc13c,
0xc3fd,
0x0004,
0x0461,
0xc63a,
0xc552,
0xc7fd,
0x0002,
0x048e,
0x0002,
0x0007,
0x0002,
0x0003,
0xd293,
0xd2c1,
0xd2a0,
0xd2c2,
0x0002,
0x0003,
0xd299,
0xd260,
0xd2eb,
0xd2dc,
0xafb2,
0xafb2,
0x0002,
0x002e,
0x0004,
0x0007,
0x000c,
0xb838,
0xbd80,
0xbd80,
0xbe6f,
0xbe6f,
0xbfff,
0xbfff,
0xbef3,
0xbef3,
0x0440,
0x0440,
0xbf52,
0xbf52,
0xc353,
0x0001,
0x0002,
0x000f,
0x0002,
0x0007,
0x0002,
0x0003,
0xd2e0,
0xd118,
0xd33b,
0xd0b0,
0x0002,
0x0003,
0xd2ed,
0xd33a,
0xd11e,
0xd309,
0x0002,
0x0007,
0x0002,
0x0003,
0xd122,
0xd0b1,
0xd30b,
0xd312,
0xce8d,
0xcffc,
0x0536,
0xb83b,
0xb9ba,
0x0002,
0x0043,
0x0004,
0x0014,
0x0023,
0x0031,
0x0002,
0x000a,
0x0002,
0x0005,
0xcffd,
0xcffd,
0x0531,
0x04f1,
0xce92,
0xcffc,
0x0435,
0x0002,
0x0003,
0xce7e,
0xce45,
0xceb9,
0xce43,
0x0002,
0x0008,
0x0002,
0x0004,
0xce2c,
0xcffc,
0x04ec,
0xce29,
0xceba,
0x0002,
0x0004,
0xce94,
0xcffc,
0x050e,
0xcebd,
0xcfa8,
0x0002,
0x0007,
0x0002,
0x0003,
0xcf25,
0xcd19,
0xcc94,
0xceef,
0x0002,
0x0003,
0xcf00,
0xcdaa,
0xcf7a,
0xcffc,
0x0518,
0x0002,
0x0007,
0x0002,
0x0003,
0xcc9e,
0xce08,
0xcf6f,
0xcf5a,
0x0002,
0x0003,
0xcf4f,
0xcf3c,
0xcf2b,
0xcf92,
0x0004,
0x0011,
0x001f,
0x0029,
0x0002,
0x0007,
0x0002,
0x0003,
0xcfad,
0xcde2,
0xcee8,
0xcee9,
0x0002,
0x0003,
0xcf18,
0xcdb1,
0xcd6c,
0xcdac,
0x0002,
0x0008,
0x0002,
0x0003,
0xcdab,
0xcd1f,
0xcf06,
0xcffc,
0x0537,
0x0002,
0x0003,
0xcd16,
0xcf01,
0xcfe5,
0xcd0b,
0x0002,
0x0007,
0x0002,
0x0003,
0xcfea,
0xcf0e,
0xcd64,
0xcfef,
0xcbfd,
0xc881,
0x040d,
0x0002,
0x0004,
0xcab7,
0xcbfc,
0x04d1,
0xcbfd,
0xcbfd,
0x04d4,
0x0407,
0x0004,
0xa815,
0x004b,
0x0083,
0xad2a,
0xad2a,
0x0002,
0x003e,
0x0004,
0x0024,
0x0030,
0x0036,
0x0004,
0x000a,
0x0011,
0x0016,
0x0002,
0x0004,
0xcbfd,
0xcb47,
0x04c1,
0xcb97,
0xc90c,
0x0002,
0x0004,
0xcb76,
0xcbfc,
0x04ab,
0xc99d,
0xcbfc,
0x04a6,
0x0002,
0x0003,
0xca11,
0xcbce,
0xca42,
0xca55,
0x0002,
0x0003,
0xca88,
0xcb6d,
0xcbfd,
0xcbfd,
0x04c3,
0x04f4,
0x0004,
0x0006,
0x0007,
0x0008,
0xc7fd,
0xc58b,
0x04a5,
0xc4ec,
0xc46d,
0xc476,
0xc7ec,
0xc63c,
0xc6d1,
0x0004,
0xc05d,
0xc31d,
0xc1c1,
0xc470,
0xc7fc,
0x048c,
0xbc4c,
0xbc4c,
0xc13b,
0xc3c9,
0xb7fb,
0xb7fb,
0xbb86,
0x0001,
0xbcd1,
0xbcd1,
0xbd36,
0xbd36,
0x0004,
0x0019,
0x001c,
0xb22f,
0xba31,
0x0003,
0xb8ca,
0x000a,
0xc05e,
0x0005,
0xbffd,
0xbffd,
0x043f,
0x043f,
0xc5d1,
0xc7fc,
0x049f,
0x0004,
0x0006,
0xbc4b,
0xbc4b,
0xc7e9,
0xc7fc,
0x0493,
0xc773,
0xc600,
0xb57a,
0xb57a,
0xb42d,
0xb42d,
0xb751,
0xb751,
0x0002,
0x0008,
0xbfff,
0xbfff,
0xc3ff,
0xc3c6,
0x0445,
0x0445,
0x0460,
0xbfff,
0xbfff,
0xc37d,
0x0003,
0x0446,
0x0446,
0x0002,
0x0005,
0x0002,
0xc892,
0xcd63,
0xcd6e,
0xcbfd,
0xcbfd,
0x0415,
0x041c,
0xaea7,
0xaea7,
0xb023,
0x0001,
0x0004,
0x0007,
0x000c,
0x002a,
0xbfaa,
0xbfaa,
0xbdbc,
0xbdbc,
0xbfff,
0xbfff,
0xbcd4,
0xbcd4,
0x0448,
0x0448,
0x0004,
0x000a,
0x0011,
0x0016,
0x0002,
0x0004,
0xcbfd,
0xcba3,
0x04e2,
0xcab2,
0xcb80,
0x0002,
0x0004,
0xcbfd,
0xc906,
0x04be,
0xcbfd,
0xc8fd,
0x04c9,
0x0002,
0x0003,
0xca15,
0xca16,
0xc903,
0xc9df,
0x0002,
0x0003,
0xc9d8,
0xca14,
0xcbb4,
0xc888,
0x0004,
0x0006,
0x0007,
0x0008,
0xc7fd,
0xc720,
0x0486,
0xc601,
0xc674,
0xc4f1,
0xc7e7,
0xc46f,
0xc7fc,
0x04af,
0x0004,
0x9808,
0x003f,
0x99ef,
0xa2f0,
0x0003,
0x9e69,
0x9e69,
0xaa2e,
0xab8b,
0x0002,
0x0016,
0xac1b,
0xac1b,
0x0002,
0xb024,
0x0006,
0x000a,
0xbbfd,
0xbbfd,
0x041d,
0x0420,
0xc2f5,
0xc3fe,
0xc2cd,
0xc0e1,
0x046c,
0xbfff,
0xbfff,
0xbcdb,
0xbcdb,
0x0441,
0x0441,
0x0004,
0x0007,
0x001a,
0xb3d8,
0xb630,
0xb630,
0xb42c,
0xb42c,
0x0004,
0xb83c,
0xbb1b,
0x000d,
0x0005,
0xc3fe,
0xc05f,
0xc13e,
0x0464,
0xc5c5,
0x0001,
0xca0b,
0x0001,
0xce2a,
0xcffc,
0x0508,
0xc05c,
0xc0df,
0xbf1c,
0xbf1c,
0xb6a8,
0xb6a8,
0xb5b7,
0xb5b7,
0xa00d,
0x0003,
0x00ae,
0xa127,
0x0004,
0x0014,
0xa4bc,
0xa4bc,
0xafb6,
0xafb6,
0x0002,
0xb0c2,
0xb4c6,
0xb4c6,
0x0003,
0xbbfc,
0x0422,
0xbfff,
0xbfff,
0xbfff,
0xbfff,
0x0444,
0x0444,
0x044e,
0x044e,
0xb31a,
0x0003,
0x0015,
0x0038,
0x0004,
0xb931,
0xb932,
0xb9f5,
0x0004,
0x0005,
0xc1c2,
0xc0eb,
0xc46c,
0xc478,
0xc6b0,
0x0001,
0x0002,
0x0003,
0xcd6b,
0xceea,
0xcffd,
0xce5b,
0x050c,
0x0005,
0x000a,
0xbbfd,
0x000e,
0x0426,
0xc146,
0xc0e4,
0xbffd,
0xbffd,
0x0443,
0x0443,
0xbcd5,
0xbcd5,
0xbffd,
0xbffd,
0x0449,
0x0449,
0xc3ff,
0x0004,
0xbcda,
0xbcda,
0x0466,
0x0002,
0x0007,
0x0002,
0x0003,
0xcde5,
0xcd20,
0xce21,
0xcedb,
0x0002,
0x0003,
0xcf90,
0xce1d,
0xcd1b,
0xce1e,
0x0004,
0xb83a,
0x0025,
0x0042,
0xbd37,
0xbd37,
0x0002,
0x0011,
0x0002,
0x0008,
0x0002,
0x0003,
0xcec0,
0xccad,
0xcffd,
0xcf9e,
0x0527,
0x0002,
0x0003,
0xcf14,
0xcc99,
0xcffd,
0xcf81,
0x04fa,
0x0002,
0x0008,
0x0002,
0x0003,
0xcd0d,
0xce82,
0xcf78,
0xcffc,
0x04f9,
0x0002,
0x0003,
0xcca5,
0xcf27,
0xcca8,
0xccb3,
0x0004,
0x0009,
0x000e,
0x0015,
0x0002,
0x0003,
0xcad4,
0xc9da,
0xcac6,
0xcac5,
0x0002,
0x0003,
0xcb8a,
0xca48,
0xc88a,
0xcb89,
0x0002,
0x0004,
0xcbfd,
0xca89,
0x04c2,
0xcbfd,
0xca40,
0x04cc,
0x0002,
0x0003,
0xca0e,
0xcb6c,
0xc9dd,
0xc9e6,
0x0004,
0x0009,
0x0010,
0x0012,
0x0002,
0x0003,
0xca17,
0xc9a5,
0xc9b0,
0xc88f,
0x0002,
0x0004,
0xc9a2,
0xcbfc,
0x0421,
0xcbfd,
0xc95e,
0x04ee,
0xc7fd,
0xc59b,
0x0498,
0xc593,
0xc675,
0xa411,
0xa411,
0x0002,
0x0027,
0x0004,
0x0015,
0xac1c,
0xac1c,
0x0006,
0x000b,
0xb7fd,
0xb7fd,
0x03fd,
0x03fd,
0xbfff,
0xbfff,
0xbcd8,
0xbcd8,
0x044a,
0x044a,
0x0004,
0xc2ce,
0xbc4e,
0xbc4e,
0xc599,
0xc5a6,
0xbbff,
0x0006,
0xb7fe,
0xb7fe,
0x0424,
0x03ff,
0x03ff,
0xbfb3,
0xbfb3,
0x0002,
0x0003,
0xc4ee,
0xc4f2,
0xc475,
0xc7fc,
0x04a3,
0xb025,
0xb3db,
0x0002,
0x0029,
0x0005,
0xbbfe,
0xbaa9,
0x000c,
0x041e,
0x0004,
0x0006,
0xc1fa,
0xc13d,
0xc5a7,
0xc7fc,
0x0497,
0xc5d4,
0xc7fc,
0x0495,
0x0005,
0xc3d0,
0xc3fd,
0x000e,
0x0469,
0xc47b,
0x0001,
0x0002,
0xcafb,
0xce83,
0x0001,
0x0002,
0x0003,
0xd70c,
0xd657,
0xd6a1,
0xd6ec,
0x0002,
0x0004,
0xcbfd,
0xca0a,
0x04e3,
0xcbfd,
0xcab3,
0x04df,
0xb7ff,
0xb7ff,
0xb42e,
0xb42e,
0x0401,
0x0401,};


const U16 g_rgiHuffDecTbl16ssOb[848] =
{
  0x0018, 0x8802, 0x0012, 0x0001, 0x9004, 0x0003, 0x90d8, 0x0021, 
  0x0004, 0x980d, 0x006a, 0x980e, 0x0088, 0x0003, 0x9d4a, 0x9d4a, 
  0xa4de, 0xa4de, 0x00f2, 0xa800, 0x000c, 0x0017, 0x000e, 0x9001, 
  0x0018, 0x9003, 0x0002, 0x0021, 0x9405, 0x9405, 0x001a, 0x9809, 
  0x9406, 0x9406, 0x9920, 0x980a, 0x0030, 0x980c, 0x9407, 0x9407, 
  0x0030, 0x003f, 0x9408, 0x9408, 0x0024, 0x0043, 0x980b, 0x001d, 
  0x0004, 0x002b, 0x002e, 0x0031, 0xa01a, 0x0043, 0x9c0f, 0x9c0f, 
  0x9cd9, 0x9cd9, 0x9c10, 0x9c10, 0x0030, 0x0003, 0x0006, 0x0009, 
  0x9c11, 0x9c11, 0x007e, 0x00f1, 0x9c13, 0x9c13, 0x9c12, 0x9c12, 
  0x9c14, 0x9c14, 0x006e, 0x0071, 0x9c15, 0x9c15, 0xa172, 0x00a1, 
  0x00c0, 0xa021, 0x9c16, 0x9c16, 0xa0db, 0xa023, 0x9c17, 0x9c17, 
  0x9c18, 0x9c18, 0x0082, 0x0041, 0xa019, 0xa01e, 0x0042, 0x002d, 
  0xa01b, 0x004f, 0xa0da, 0x0025, 0x0018, 0xa01c, 0x0042, 0x0045, 
  0x003c, 0x004b, 0x9c1d, 0x9c1d, 0x0014, 0x0023, 0xa01f, 0x0015, 
  0x0054, 0xa020, 0xa022, 0x0055, 0x0094, 0xa024, 0x00ae, 0x0021, 
  0x0054, 0xa836, 0xa425, 0xa425, 0x007c, 0xa835, 0xa426, 0xa426, 
  0xa429, 0xa429, 0xa427, 0xa427, 0xa428, 0xa428, 0x0250, 0x0217, 
  0xa521, 0xa521, 0xa42a, 0xa42a, 0xa42b, 0xa42b, 0xa988, 0x006d, 
  0x0054, 0xa83b, 0xa42c, 0xa42c, 0xa42d, 0xa42d, 0x008a, 0xa8e3, 
  0xa431, 0xa431, 0xa42e, 0xa42e, 0xa42f, 0xa42f, 0xa430, 0xa430, 
  0xa832, 0x00ab, 0xa83a, 0x003d, 0xa433, 0xa433, 0x01e6, 0xa845, 
  0xa834, 0xa922, 0x0026, 0xa8df, 0x022e, 0xa837, 0x002a, 0x00b9, 
  0xa4dc, 0xa4dc, 0x004e, 0xa838, 0xa439, 0xa439, 0x021c, 0xa844, 
  0x00a8, 0xa83c, 0xa4dd, 0xa4dd, 0xa840, 0x01ed, 0xa94b, 0xa83d, 
  0x0014, 0x00c7, 0x0162, 0xa83e, 0xa83f, 0x0027, 0xa923, 0x0021, 
  0xa841, 0x0205, 0x004e, 0xa8e0, 0xac42, 0xac42, 0xb057, 0x023b, 
  0x0184, 0x00ff, 0xac43, 0xac43, 0xac46, 0xac46, 0xaceb, 0xaceb, 
  0xac47, 0xac47, 0x00a6, 0x0081, 0x00b4, 0x0077, 0xa848, 0x00b9, 
  0xac49, 0xac49, 0xb052, 0x0061, 0x00fc, 0xb051, 0xac4a, 0xac4a, 
  0xac4b, 0xac4b, 0x008e, 0xb059, 0xac4c, 0xac4c, 0x0086, 0xb0fa, 
  0xa8e2, 0x0003, 0x002a, 0x0065, 0xb0fb, 0x0147, 0xac4d, 0xac4d, 
  0xb04e, 0xb060, 0x00ae, 0xb058, 0xace6, 0xace6, 0xb0f4, 0xb04f, 
  0x0110, 0x00ab, 0xb050, 0xb053, 0xac54, 0xac54, 0x00ce, 0x0069, 
  0x0004, 0x0037, 0x0032, 0x00f1, 0xac55, 0xac55, 0xb12c, 0xb0f8, 
  0x0020, 0xa98c, 0x0002, 0x009d, 0xac56, 0xac56, 0xace8, 0xace8, 
  0x00c4, 0xb05a, 0xad73, 0xad73, 0x0088, 0xb05b, 0xb063, 0xb0f7, 
  0xb062, 0xb05c, 0x00b6, 0x01f3, 0xa8e4, 0x0003, 0x0006, 0xa8e5, 
  0x01f2, 0x009f, 0xb05d, 0xb196, 0xb05e, 0xb072, 0xad4c, 0xad4c, 
  0xb197, 0xb05f, 0xb194, 0x00e9, 0x0004, 0xa8e1, 0xa584, 0xa584, 
  0x01b2, 0x000f, 0xb0f6, 0xb061, 0xb128, 0xb071, 0xb0f9, 0xb064, 
  0x019e, 0xb065, 0xb066, 0xb12a, 0xb54e, 0xb54e, 0xb467, 0xb467, 
  0xb468, 0xb468, 0xb59a, 0xb59a, 0x006c, 0x002f, 0xb0f0, 0x0001, 
  0xb469, 0xb469, 0xb46e, 0xb46e, 0xb06a, 0x004b, 0xacf2, 0xacf2, 
  0xb06f, 0xb073, 0xb06b, 0xb070, 0xb902, 0xb99d, 0xb46c, 0xb46c, 
  0x0004, 0xb100, 0x0022, 0x01af, 0xb93c, 0xb948, 0xb46d, 0xb46d, 
  0x0004, 0x008b, 0xacea, 0xacea, 0xb474, 0xb474, 0xb99e, 0x012b, 
  0xb475, 0xb475, 0xb478, 0xb478, 0xb476, 0xb476, 0xb9a1, 0xb8a3, 
  0xb991, 0xb903, 0xb477, 0xb477, 0xb501, 0xb501, 0xb879, 0xb897, 
  0x00fe, 0xb99b, 0xb87a, 0xb976, 0xb952, 0xb887, 0xb8a8, 0xb87b, 
  0x0004, 0x015d, 0xace9, 0xace9, 0xb938, 0xb943, 0xb93b, 0xb87c, 
  0x0166, 0x0033, 0x0002, 0x0059, 0xb535, 0xb535, 0xb47d, 0xb47d, 
  0x0004, 0x004f, 0x00aa, 0x0025, 0xb47e, 0xb47e, 0xb480, 0xb480, 
  0xb48f, 0xb48f, 0xb47f, 0xb47f, 0xb894, 0xb886, 0xb481, 0xb481, 
  0xb884, 0xb882, 0xb598, 0xb598, 0x005c, 0xb883, 0xb98f, 0xb957, 
  0xad25, 0xad25, 0x0002, 0x0019, 0x0102, 0x0115, 0xb885, 0xb88d, 
  0x010e, 0x008f, 0x0002, 0x0091, 0xbc88, 0xbc88, 0xbc98, 0xbc98, 
  0xb889, 0xb947, 0xb536, 0xb536, 0xb893, 0xb986, 0xb88a, 0xb9a6, 
  0xb954, 0xb88b, 0xb4fe, 0xb4fe, 0xb88c, 0xb8ab, 0xb88e, 0x014f, 
  0x0156, 0xb890, 0xb958, 0xb909, 0xb891, 0xb8ad, 0xb8aa, 0xb9a0, 
  0xb892, 0xb906, 0xb52f, 0xb52f, 0xb531, 0xb531, 0xb895, 0x002d, 
  0x0004, 0xb910, 0xb939, 0xb90f, 0xbc96, 0xbc96, 0xbda3, 0xbda3, 
  0x008e, 0x0089, 0x00d0, 0xb899, 0xb58d, 0xb58d, 0xb953, 0x0001, 
  0xbc9a, 0xbc9a, 0xbcc9, 0xbcc9, 0x0136, 0x00f9, 0x0002, 0x00fb, 
  0xbc9b, 0xbc9b, 0xbd17, 0xbd17, 0xacf3, 0xacf3, 0x0002, 0x0085, 
  0x007a, 0x0069, 0x0002, 0x012b, 0xbcb6, 0xbcb6, 0xbc9c, 0xbc9c, 
  0xbc9d, 0xbc9d, 0xbcca, 0xbcca, 0xbd46, 0xbd46, 0xbc9e, 0xbc9e, 
  0x0008, 0x0027, 0x013a, 0x0001, 0xbc9f, 0xbc9f, 0xbd5d, 0xbd5d, 
  0x006a, 0xc17b, 0xc0cd, 0xc0a0, 0x0040, 0x0051, 0x0032, 0x0001, 
  0xbca1, 0xbca1, 0xbcae, 0xbcae, 0x009a, 0xb127, 0x0002, 0x0009, 
  0x0038, 0x0003, 0x00f8, 0x00b7, 0xbd11, 0xbd11, 0xbca2, 0xbca2, 
  0x0004, 0xb956, 0xb955, 0xb93a, 0xbca4, 0xbca4, 0xbda5, 0xbda5, 
  0xc0a5, 0xc0b9, 0xc0bb, 0xc0bf, 0x0004, 0x010b, 0x0102, 0x00fd, 
  0xbca6, 0xbca6, 0xbd04, 0xbd04, 0xb8c0, 0xb914, 0xb90e, 0xb8a7, 
  0xbca9, 0xbca9, 0xbd13, 0xbd13, 0xbcac, 0xbcac, 0xbd59, 0xbd59, 
  0xbda4, 0xbda4, 0xbcaf, 0xbcaf, 0xb4fc, 0xb4fc, 0x000e, 0x0001, 
  0xbcb0, 0xbcb0, 0xbd1e, 0xbd1e, 0xc1ab, 0xc163, 0xc0b1, 0xc119, 
  0xbcb2, 0xbcb2, 0xbd1f, 0xbd1f, 0xc0c2, 0x0003, 0xbd6c, 0xbd6c, 
  0xc4d0, 0xc4b3, 0xc0b4, 0xc179, 0xc1ad, 0xc1b2, 0xbdaf, 0xbdaf, 
  0xbcb5, 0xbcb5, 0xbcd4, 0xbcd4, 0xbcb7, 0xbcb7, 0xbd41, 0xbd41, 
  0xbcb8, 0xbcb8, 0x001e, 0xc16e, 0xc0d5, 0xc0ba, 0xbd16, 0xbd16, 
  0xc0bc, 0xc0cf, 0xc582, 0xc4bd, 0x0082, 0x00ad, 0x0002, 0x0073, 
  0xbcbe, 0xbcbe, 0xbd7e, 0xbd7e, 0xacf1, 0xacf1, 0x0002, 0xb12b, 
  0xb59c, 0xb59c, 0xb907, 0x0001, 0xbd61, 0xbd61, 0x006e, 0xc0c1, 
  0xc4c3, 0x0069, 0xc0ce, 0xc0cc, 0xc0c4, 0xc0c8, 0xacec, 0xacec, 
  0x0002, 0xb14d, 0xb574, 0xb574, 0x0002, 0xb93d, 0xbd7d, 0xbd7d, 
  0xc167, 0xc0c5, 0xace7, 0xace7, 0x0002, 0xb185, 0xb4ff, 0xb4ff, 
  0x0002, 0x004d, 0xc145, 0xc0c7, 0xc0c6, 0xc16f, 0xbd95, 0xbd95, 
  0xbccb, 0xbccb, 0xbcd1, 0xbcd1, 0xbd66, 0xbd66, 0xb533, 0xb533, 
  0x0084, 0x0001, 0xbd40, 0xbd40, 0xbcd2, 0xbcd2, 0xbd49, 0xbd49, 
  0xbcd3, 0xbcd3, 0xbcd6, 0xbcd6, 0xbcd7, 0xbcd7, 0xaced, 0xaced, 
  0xad90, 0xad90, 0xad92, 0xad92, 0xacee, 0xacee, 0xb126, 0xb0ef, 
  0xad8e, 0xad8e, 0x0034, 0xb0f5, 0xad24, 0xad24, 0xb575, 0xb575, 
  0xb4fd, 0xb4fd, 0xbd5f, 0xbd5f, 0xbd05, 0xbd05, 0xb951, 0xb942, 
  0xb90b, 0xb908, 0xb90a, 0xb90c, 0xb589, 0xb589, 0xbd7c, 0xbd7c, 
  0xbd0d, 0xbd0d, 0xbd5b, 0xbd5b, 0xbd12, 0xbd12, 0xb550, 0xb550, 
  0x003e, 0xb915, 0xbd81, 0xbd81, 0xbd18, 0xbd18, 0xc11a, 0xc1a9, 
  0xc1b0, 0xc1ae, 0xc96a, 0xc91b, 0xc570, 0xc51c, 0xbd1d, 0xbd1d, 
  0xbd99, 0xbd99, 0xb529, 0xb529, 0xb52d, 0xb52d, 0xb532, 0xb532, 
  0xb52e, 0xb52e, 0xb54f, 0xb54f, 0xb530, 0xb530, 0xb534, 0xb534, 
  0xb99f, 0xb93e, 0xb937, 0xb978, 0xb95e, 0xb98a, 0xbd5a, 0xbd5a, 
  0xbd3f, 0xbd3f, 0xbd93, 0xbd93, 0xbd44, 0xbd44, 0xbd64, 0xbd64, 
  0xbd5c, 0xbd5c, 0xc169, 0xc160, 0xbda8, 0xbda8, 0xbd68, 0xbd68, 
  0xbd62, 0xbd62, 0xbd65, 0xbd65, 0xbd83, 0xbd83, 0xbd7a, 0xbd7a, 
  0xc1aa, 0x0001, 0xc5b1, 0xc56b, 0xbda7, 0xbda7, 0xbd6d, 0xbd6d, 
  0xbd80, 0xbd80, 0xbd71, 0xbd71, 0xbd8b, 0xbd8b, 0xbd77, 0xbd77, 
  0xbdac, 0xbdac, 0xbd7f, 0xbd7f, 0xbd87, 0xbd87, 0xbda2, 0xbda2
}; 

const U16 g_rgiHuffDecTbl44ssOb[2002] = {
0x8802,
0x0003,
0x0247,
0x042c,
0x9161,
0x0003,
0x9004,
0x0109,
0x9962,
0x9a27,
0x9808,
0x0001,
0x0004,
0x003d,
0x00f2,
0xa011,
0xa565,
0xa565,
0x0002,
0x0019,
0x0004,
0xb366,
0xac2b,
0xac2b,
0x0004,
0x000b,
0x000e,
0xb863,
0x0004,
0x0005,
0xc3da,
0xc371,
0xc4ce,
0xc641,
0xc6c3,
0xc4f6,
0xc0bb,
0xc0b2,
0xc2f5,
0xc3f6,
0xc199,
0xc36e,
0xbfc4,
0xbfc4,
0xb1e2,
0x0003,
0xb039,
0x0011,
0xb668,
0xb668,
0x0002,
0x0005,
0xbc7f,
0xbc7f,
0xbc98,
0xbc98,
0x0004,
0xc0a6,
0xc367,
0xc298,
0xc67b,
0x0001,
0xcaec,
0xc945,
0xb861,
0x0003,
0xb44e,
0xb44e,
0xc1f6,
0x0003,
0xbc82,
0xbc82,
0xc72e,
0xc679,
0xa821,
0x0003,
0x0036,
0x0085,
0xb369,
0x0003,
0x0016,
0xb22b,
0x0004,
0xb86c,
0xbb42,
0x0005,
0xbe35,
0xbe35,
0xbc88,
0xbc88,
0x0004,
0x0005,
0x0006,
0x0007,
0xc5ab,
0xc4f3,
0xc4f4,
0xc6f7,
0xc505,
0xc4d0,
0xc6c8,
0xc6c2,
0x0004,
0x0011,
0xb86d,
0x0015,
0x0004,
0x0005,
0x0006,
0x0007,
0xc683,
0xc530,
0xc6db,
0xc4d7,
0xc51a,
0xc51b,
0xc7fd,
0xc7fd,
0x040f,
0x040d,
0x0004,
0xc19c,
0xc1fa,
0xc0ab,
0xc50f,
0xc643,
0xc23e,
0xc343,
0xbe38,
0xbe38,
0x0004,
0x000b,
0x0016,
0x001d,
0x0004,
0xb866,
0xbba1,
0xb9ea,
0xbfbf,
0xbfbf,
0xbdef,
0xbdef,
0xb77e,
0xb77e,
0x0002,
0x0005,
0xc0c3,
0xc0ac,
0xc0b3,
0xc0af,
0xc3e0,
0xc1f8,
0xc23d,
0xc3f3,
0x0004,
0xb9eb,
0xb44d,
0xb44d,
0xbebc,
0xbebc,
0xbf55,
0xbf55,
0xb9ec,
0xb97e,
0x0002,
0x0011,
0xbf58,
0xbf58,
0x0002,
0x0007,
0x0002,
0x0003,
0xc946,
0xc940,
0xcab6,
0xcb7b,
0x0002,
0x0003,
0xc93f,
0xcb45,
0xc9b5,
0xc949,
0x0004,
0x0009,
0x000e,
0x0013,
0x0002,
0x0003,
0xcb40,
0xc948,
0xc94d,
0xc8f9,
0x0002,
0x0003,
0xca58,
0xcb39,
0xca61,
0xc9bb,
0x0002,
0x0003,
0xc938,
0xcb29,
0xcb0d,
0xca51,
0x0002,
0x0003,
0xcb52,
0xcbbd,
0xcbc9,
0xca5f,
0xac2c,
0xac2c,
0x0002,
0x0027,
0x0004,
0x0015,
0x0020,
0xb86b,
0x0004,
0x0009,
0x000c,
0x000d,
0x0002,
0x0003,
0xcbad,
0xc9bd,
0xcaa8,
0xcbb4,
0x0002,
0xc615,
0xcbb0,
0xc9bf,
0xc510,
0xc4e7,
0xc788,
0xc647,
0x0004,
0x0005,
0x0006,
0x0007,
0xc759,
0xc4e4,
0xc796,
0xc4cd,
0xc71c,
0xc4e1,
0xc4c9,
0xc4d6,
0xc0a8,
0xc276,
0xc29f,
0xc0c0,
0xb780,
0xb780,
0xb450,
0xb450,
0xa418,
0xa418,
0xa822,
0x0001,
0xb03b,
0x0003,
0xaf54,
0xaf54,
0x0004,
0xb97d,
0xb62e,
0xb62e,
0xbc9a,
0xbc9a,
0xbfca,
0xbfca,
0x95db,
0x95db,
0x0002,
0x007a,
0x9c0c,
0x9c0c,
0x0002,
0x003d,
0x0004,
0xab3c,
0xa823,
0x0023,
0x0004,
0xb28f,
0x0012,
0x0015,
0xb864,
0x0003,
0xb575,
0xb575,
0xbfc6,
0xbfc6,
0x0002,
0xc0ba,
0xc4de,
0x0001,
0xc92a,
0x0001,
0x0002,
0xcdd6,
0xd156,
0xd15e,
0xb782,
0xb782,
0xb454,
0xb454,
0xba6b,
0x0003,
0xb451,
0xb451,
0xc3e3,
0xc277,
0xc3df,
0x0001,
0xc70b,
0xc4d2,
0xac2d,
0xac2d,
0x0002,
0xb03d,
0x0004,
0x0007,
0xb44f,
0xb44f,
0xbc92,
0xbc92,
0xbc8c,
0xbc8c,
0xbc85,
0xbc85,
0x0002,
0x0004,
0xc7fd,
0xc663,
0x0405,
0xc7fd,
0xc5ac,
0x0428,
0xa716,
0xa716,
0xa9de,
0x0001,
0x0004,
0x0007,
0x0027,
0x002a,
0xb690,
0xb690,
0xb785,
0xb785,
0x0004,
0x000f,
0x0017,
0x001a,
0x0004,
0x0005,
0x0006,
0x0007,
0xc60a,
0xc726,
0xc681,
0xc4d9,
0xc4dc,
0xc6c5,
0xc5a2,
0xc64c,
0x0004,
0x0005,
0xc0c1,
0xc1f7,
0xc4e5,
0xc4cb,
0xc6c4,
0xc7fc,
0x040e,
0xc297,
0xc3e8,
0xbef1,
0xbef1,
0xbfc1,
0xbfc1,
0xbed3,
0xbed3,
0xb97f,
0xbba3,
0xb72b,
0xb72b,
0x0004,
0xbb05,
0xb455,
0xb455,
0xbc87,
0xbc87,
0xc275,
0xc3ed,
0x0004,
0xa2cf,
0x0028,
0xa012,
0xa5dd,
0xa5dd,
0xa968,
0x0001,
0xb03c,
0xb170,
0xb36b,
0x0001,
0x0004,
0x0007,
0xbb9f,
0x0009,
0xc19d,
0xc0ae,
0xc0bd,
0xc3e2,
0xbf06,
0xbf06,
0xbc8d,
0xbc8d,
0xbc89,
0xbc89,
0xc1fd,
0x0001,
0x0002,
0x0007,
0x0002,
0x0003,
0xce8a,
0xcdc3,
0xce1c,
0xcdd1,
0x0002,
0x0003,
0xcdd7,
0xcd5b,
0xcd20,
0xcee8,
0xa419,
0xa419,
0x0002,
0x007f,
0x0004,
0x000b,
0x0028,
0x002b,
0xbba5,
0xb86a,
0x0002,
0xba92,
0xbdf3,
0xbdf3,
0xbc96,
0xbc96,
0xb789,
0xb789,
0xb86e,
0x0001,
0xbc90,
0xbc90,
0x0002,
0x000f,
0x0002,
0x0007,
0x0002,
0x0003,
0xcd5d,
0xcee4,
0xcdd9,
0xcdcc,
0x0002,
0x0003,
0xce19,
0xcd55,
0xcd54,
0xcefc,
0x0002,
0x0005,
0x0002,
0xcafe,
0xce5b,
0xcee7,
0xc93a,
0xcb4e,
0xb5e5,
0xb5e5,
0xb453,
0xb453,
0x0004,
0x001f,
0x0036,
0x0043,
0x0004,
0x0009,
0x000e,
0x0013,
0x0002,
0x0003,
0xcb20,
0xc957,
0xc9c2,
0xcb30,
0x0002,
0x0003,
0xcafb,
0xcb53,
0xcb02,
0xcb6f,
0x0002,
0x0003,
0xc93c,
0xc9b2,
0xc9d3,
0xc928,
0x0002,
0x0003,
0xcb3b,
0xcb84,
0xc92e,
0xcbb2,
0x0004,
0x0009,
0x000e,
0x0012,
0x0002,
0x0003,
0xcaae,
0xca26,
0xc924,
0xca82,
0x0002,
0x0003,
0xca87,
0xcae6,
0xca25,
0xcacc,
0x0003,
0xc7fc,
0x0411,
0xcbcb,
0xc917,
0xc7fd,
0xc649,
0x0413,
0x0004,
0x0007,
0x0008,
0x0009,
0xc7fd,
0xc7fd,
0x0424,
0x042a,
0xc4e0,
0xc611,
0xc605,
0xc4f7,
0xc78e,
0xc7a0,
0x0004,
0x0005,
0x0006,
0xc0b5,
0xc6e0,
0xc5b6,
0xc60d,
0xc513,
0xc60b,
0xc4fb,
0x0004,
0xb304,
0xade0,
0xade0,
0x0004,
0x0007,
0xba6c,
0xbba9,
0xc0b8,
0xc2f3,
0xbfc0,
0xbfc0,
0xbdf2,
0xbdf2,
0xbf2c,
0xbf2c,
0x8c03,
0x8c03,
0x0002,
0x003f,
0x9406,
0x9406,
0x0002,
0x9809,
0x9e8d,
0x9e8d,
0x0002,
0xa164,
0xa824,
0x0003,
0x001c,
0x001f,
0x0004,
0x0007,
0x0014,
0xb03e,
0xb576,
0xb576,
0xb6d1,
0xb6d1,
0xb452,
0xb452,
0x0002,
0x0007,
0xc23b,
0x0003,
0xbebe,
0xbebe,
0xc500,
0xc4ee,
0xbe6f,
0xbe6f,
0xbfd3,
0xbfd3,
0xbb4b,
0xbad2,
0xb787,
0xb787,
0xac2f,
0xac2f,
0xac2e,
0xac2e,
0xb267,
0x0003,
0xac30,
0xac30,
0x0004,
0x0007,
0x000a,
0xbba6,
0xbfc8,
0xbfc8,
0xc1f9,
0xc2d7,
0xc0a7,
0xc3eb,
0xc2f2,
0xc0cf,
0xc204,
0xc308,
0xbc8a,
0xbc8a,
0x0004,
0x00b0,
0x00bb,
0x019d,
0x0004,
0x003d,
0x9d63,
0x9d63,
0xaa8e,
0x0003,
0xa41a,
0xa41a,
0xb16f,
0xb1e3,
0x0002,
0x000f,
0x0004,
0xba31,
0xb456,
0xb456,
0xbf5e,
0xbf5e,
0x0002,
0x0004,
0xc7fd,
0xc542,
0x042c,
0xc7fd,
0xc4ea,
0x0420,
0x0004,
0x0011,
0x001a,
0x001d,
0x0004,
0x0006,
0x0008,
0x0009,
0xc512,
0xc7fc,
0x041c,
0xc7fd,
0xc5a4,
0x041f,
0xc6a1,
0xc738,
0xc4d5,
0xc78a,
0x0004,
0x0005,
0x0006,
0xc3e1,
0xc75c,
0xc4f1,
0xc64b,
0xc5a0,
0xc648,
0xc5b0,
0xc1fc,
0xc0a5,
0xc3ef,
0xc0b1,
0xbfc3,
0xbfc3,
0xbdf1,
0xbdf1,
0xa825,
0x0003,
0x0006,
0x002a,
0xaf57,
0xaf57,
0xae66,
0xae66,
0x0004,
0xb03f,
0x0012,
0xb36d,
0x0004,
0xbabb,
0x0006,
0x0009,
0xbc86,
0xbc86,
0xbfcc,
0xbfcc,
0xc31b,
0xc29a,
0xbdf4,
0xbdf4,
0xbe36,
0xbe36,
0xbe37,
0xbe37,
0x0004,
0xb871,
0x0006,
0x000a,
0xbe39,
0xbe39,
0xbe6e,
0xbe6e,
0xc2c0,
0xc1fb,
0xc194,
0xc3fc,
0x03fe,
0xc19a,
0xc0a3,
0xbc8f,
0xbc8f,
0xae2a,
0xae2a,
0xb171,
0x0001,
0xb869,
0x0003,
0x001f,
0x002f,
0x0004,
0x000a,
0x000f,
0x0014,
0x0002,
0x0003,
0xcaad,
0xcaaa,
0xcaa5,
0xcbfc,
0x042e,
0x0002,
0x0003,
0xc94f,
0xc9be,
0xcb10,
0xca53,
0x0002,
0x0003,
0xca52,
0xc9c9,
0xca88,
0xca23,
0x0002,
0x0003,
0xcb4d,
0xcad9,
0xcaf9,
0xc95c,
0x0004,
0x0009,
0x000b,
0x000c,
0x0002,
0x0003,
0xc959,
0xcadc,
0xcab1,
0xc93d,
0xc7fd,
0xc6ca,
0x0429,
0xc502,
0xc5c1,
0xc4f0,
0xc77d,
0x0004,
0x0005,
0x0006,
0x0007,
0xc642,
0xc75f,
0xc744,
0xc4fd,
0xc4ed,
0xc4e9,
0xc6a6,
0xc4fa,
0x9c0d,
0x9c0d,
0xa013,
0x0001,
0xa41b,
0xa41b,
0x0002,
0xab41,
0xaed0,
0xaed0,
0xad6b,
0xad6b,
0x0004,
0x002c,
0x00b3,
0x00dc,
0xaa29,
0x0003,
0xa721,
0xa721,
0x0004,
0xb041,
0xac31,
0xac31,
0x0004,
0x0012,
0x0017,
0x001a,
0x0004,
0x0005,
0x0007,
0x000a,
0xc5b7,
0xc607,
0xc749,
0xc7fc,
0x041b,
0xc7fd,
0xc7fd,
0x041d,
0x041a,
0xc4f5,
0xc662,
0x0004,
0xc0c2,
0xc299,
0xc201,
0xc67f,
0xc6f6,
0xc23c,
0xc36c,
0xc3e9,
0xc203,
0xc23f,
0xc31a,
0xbe70,
0xbe70,
0x0004,
0x0030,
0xa826,
0x005a,
0x0004,
0x000b,
0x0017,
0xb370,
0xbb47,
0x0003,
0xbbab,
0xb875,
0xbc8b,
0xbc8b,
0xbfcd,
0xbfcd,
0xb459,
0xb459,
0x0002,
0x0005,
0xc1fe,
0xc200,
0xc0c4,
0xc37f,
0xc2c1,
0xc0ad,
0xc3f1,
0xc3fc,
0x0404,
0x0004,
0xb984,
0xbba7,
0x0005,
0xbc9b,
0xbc9b,
0xbf07,
0xbf07,
0xbc94,
0xbc94,
0xc3f9,
0x0001,
0x0002,
0xc514,
0xc941,
0x0001,
0x0002,
0xcd58,
0xd1d0,
0xd21f,
0xb040,
0x0003,
0x0006,
0x0011,
0xb5e7,
0xb5e7,
0xb78b,
0xb78b,
0x0004,
0x0007,
0xb45b,
0xb45b,
0xbc95,
0xbc95,
0xbc97,
0xbc97,
0xbc93,
0xbc93,
0xbd8e,
0xbd8e,
0xb5e6,
0xb5e6,
0x0002,
0x0009,
0xbfd7,
0xbfd7,
0x0002,
0x0003,
0xc606,
0xc515,
0xc616,
0xc60c,
0x0004,
0x0005,
0x0006,
0x0007,
0xc532,
0xc79c,
0xc680,
0xc52c,
0xc7a4,
0xc501,
0xc60f,
0xc504,
0x0004,
0x0019,
0xb372,
0xb042,
0x0004,
0x0011,
0xb988,
0xb980,
0x0004,
0x0005,
0x0007,
0x0009,
0xc50c,
0xc67c,
0xc50d,
0xc7fc,
0x0410,
0xc7fd,
0xc5bc,
0x0423,
0xc71f,
0xc5b8,
0xc3fb,
0xc244,
0xc3f5,
0xc375,
0x0004,
0xb9ed,
0xb578,
0xb578,
0xbfc7,
0xbfc7,
0xc0bf,
0x0001,
0xc7fd,
0x0002,
0x0427,
0x0002,
0x0003,
0xcee9,
0xce89,
0xce55,
0xcd51,
0xa41c,
0xa41c,
0x0002,
0x0011,
0xaf5a,
0xaf5a,
0x0002,
0x0009,
0xb735,
0xb735,
0x0002,
0xb86f,
0xbebd,
0xbebd,
0xc278,
0xc24e,
0xb62f,
0xb62f,
0xb458,
0xb458,
0xac32,
0xac32,
0x0002,
0x000f,
0xb78f,
0xb78f,
0x0002,
0x0007,
0xc0c5,
0xc3fe,
0xc3fe,
0xc217,
0x0412,
0x0403,
0xc309,
0xc3f8,
0xc3ee,
0xc0be,
0xb78d,
0xb78d,
0xb669,
0xb669,
0xa41d,
0xa41d,
0xa566,
0xa566,
0xa014,
0xa2ed,
0x9c0e,
0x9c0e,
0x0004,
0x00cc,
0x9005,
0x0201,
0x980a,
0x0003,
0x9407,
0x9407,
0x0004,
0x00a3,
0x9ddc,
0x9ddc,
0x0004,
0x001b,
0x0082,
0x0089,
0x0004,
0x000f,
0x0012,
0xb317,
0x0004,
0xbbac,
0x0006,
0xb874,
0xbc91,
0xbc91,
0xbf3e,
0xbf3e,
0xbc9e,
0xbc9e,
0xbf61,
0xbf61,
0xb9ee,
0xb983,
0xbb18,
0xb981,
0xb579,
0xb579,
0xb870,
0xba6d,
0x0004,
0xb044,
0x0006,
0x0051,
0xb899,
0xb87a,
0xb457,
0xb457,
0x0004,
0x0023,
0x0033,
0x003f,
0x0004,
0x000d,
0x0012,
0x0017,
0x0002,
0x0007,
0x0002,
0x0003,
0xcdd4,
0xcdd8,
0xce56,
0xce1e,
0xc93b,
0xcae2,
0x0002,
0x0003,
0xc9cf,
0xc91c,
0xcadf,
0xc91f,
0x0002,
0x0003,
0xcaeb,
0xca21,
0xc9c8,
0xc94e,
0x0002,
0x0003,
0xc9cb,
0xc9c4,
0xcb14,
0xcb01,
0x0004,
0x0009,
0x000b,
0x000c,
0x0002,
0x0003,
0xc9ca,
0xc953,
0xcb32,
0xcaa7,
0xc7fd,
0xc78c,
0x0415,
0xc51e,
0xc67e,
0xc52b,
0xc650,
0x0004,
0x0005,
0x0006,
0x0008,
0xc519,
0xc521,
0xc51d,
0xc511,
0xc547,
0xc7fc,
0x0426,
0xc6da,
0xc68c,
0x0004,
0x0005,
0x0006,
0xc1ff,
0xc646,
0xc64a,
0xc6a3,
0xc4fe,
0xc72f,
0xc6b0,
0x0004,
0x0007,
0x000a,
0x000d,
0xc377,
0xc0bc,
0xc3f0,
0xc0df,
0xc273,
0xc19f,
0xbfdc,
0xbfdc,
0xbdf5,
0xbdf5,
0xbf5b,
0xbf5b,
0xbfdd,
0xbfdd,
0xbd8b,
0xbd8b,
0xb043,
0x0003,
0xb374,
0xb047,
0xb878,
0xb982,
0xbbb1,
0xb873,
0xb046,
0xb22c,
0x0002,
0x000d,
0x0004,
0x0007,
0xba93,
0xb879,
0xc0c6,
0xc0d1,
0xbfcf,
0xbfcf,
0xbd8f,
0xbd8f,
0xbed4,
0xbed4,
0xba32,
0xbbae,
0xb791,
0xb791,
0xa827,
0xa969,
0x0002,
0x001a,
0x0004,
0x0010,
0xad6c,
0xad6c,
0xb577,
0xb577,
0x0002,
0x0005,
0xc0d3,
0xc240,
0xc29e,
0xc0d4,
0xc1a9,
0xc3fe,
0xbfd1,
0xbfd1,
0x03ff,
0x0004,
0xb877,
0xb45a,
0xb45a,
0xbc9f,
0xbc9f,
0xbf64,
0xbf64,
0xaf5d,
0xaf5d,
0xac34,
0xac34,
0x0004,
0x9a64,
0x006b,
0x008c,
0x0004,
0x0048,
0x9c01,
0x9c01,
0xa665,
0xa665,
0xab46,
0x0001,
0x0004,
0x000f,
0x001a,
0x001d,
0xb45d,
0xb45d,
0x0002,
0x0005,
0xbfd4,
0xbfd4,
0xbf36,
0xbf36,
0xbfd5,
0xbfd5,
0xbd8d,
0xbd8d,
0xb73d,
0xb73d,
0xba94,
0x0001,
0xbe71,
0xbe71,
0x0002,
0x0003,
0xc613,
0xc6de,
0xc6e1,
0xc6c9,
0xb57a,
0xb57a,
0xba95,
0xb87c,
0xbbbb,
0x0003,
0x000e,
0x001a,
0x0004,
0x0005,
0x0006,
0x0007,
0xc6c6,
0xc5aa,
0xc526,
0xc5b3,
0xc5af,
0xc4e6,
0xc792,
0xc52d,
0x0004,
0x0006,
0x0007,
0x0008,
0xc4f2,
0xc7fc,
0x0421,
0xc731,
0xc507,
0xc50a,
0xc4eb,
0xc794,
0xc4ff,
0xc2d8,
0xc32d,
0xc3f4,
0xc348,
0xa41e,
0xa41e,
0xa828,
0x0001,
0x0004,
0x000b,
0xb172,
0xb049,
0x0004,
0xb989,
0xb45c,
0xb45c,
0xc1a8,
0xc0da,
0xbfd2,
0xbfd2,
0x0004,
0xbbaf,
0x0006,
0x0009,
0xbfde,
0xbfde,
0xc0ca,
0xc2a0,
0xbd90,
0xbd90,
0xbf24,
0xbf24,
0xbd97,
0xbd97,
0xbf19,
0xbf19,
0xa015,
0x0003,
0x9c0f,
0x9c0f,
0xa400,
0xa400,
0x0002,
0xa829,
0x0004,
0xb048,
0x0006,
0x0009,
0xb45f,
0xb45f,
0xb876,
0xbbb7,
0xb87b,
0xb872,
0xb462,
0xb462,
0xb691,
0xb691,
0x0002,
0x0006,
0xc29b,
0xc0cc,
0xc3f2,
0xc3fc,
0x03fd,
0xc325,
0xc386,
0xc29d,
0xc3fc,
0x0406,
0x0004,
0x0027,
0x9eb7,
0x9eb7,
0x0004,
0x001f,
0xa72a,
0xa72a,
0xac33,
0xac33,
0xb04a,
0x0001,
0x0004,
0x0007,
0x000a,
0xba33,
0xc3ec,
0xc0c7,
0xc30a,
0xc274,
0xbd95,
0xbd95,
0xbe02,
0xbe02,
0xbfd0,
0xbfd0,
0xc24f,
0x0001,
0x0002,
0x0005,
0x0002,
0xca57,
0xce60,
0xcdd2,
0xc93e,
0xca5a,
0xac35,
0xac35,
0xade1,
0xade1,
0x0004,
0x0013,
0x0016,
0xa9df,
0xad6d,
0xad6d,
0xb1e4,
0x0001,
0x0004,
0x0007,
0xb795,
0xb795,
0xbd93,
0xbd93,
0xbfd6,
0xbfd6,
0xbd91,
0xbd91,
0xbd98,
0xbd98,
0xb376,
0xb2b9,
0xaf60,
0xaf60,
0xb045,
0x0003,
0x0022,
0x0025,
0xbb50,
0x0003,
0xb45e,
0xb45e,
0x0004,
0x0009,
0x000e,
0x0013,
0x0002,
0x0003,
0xc952,
0xc950,
0xcae5,
0xc939,
0x0002,
0x0003,
0xcb12,
0xcab3,
0xcafd,
0xcab2,
0x0002,
0x0003,
0xcb13,
0xc94a,
0xc943,
0xcaea,
0x0002,
0x0003,
0xca84,
0xcaac,
0xcb0e,
0xcb3a,
0xb57b,
0xb57b,
0xb79b,
0xb79b,
0x0004,
0x0019,
0x0025,
0x0031,
0x0004,
0x0009,
0x000e,
0x0011,
0x0002,
0x0003,
0xcab5,
0xc95f,
0xcaa9,
0xcaff,
0x0002,
0x0003,
0xcab4,
0xc9ae,
0xca5e,
0xca5c,
0x0002,
0xc79a,
0xca1b,
0xca24,
0xc533,
0xc727,
0x0004,
0x0005,
0x0006,
0x0007,
0xc527,
0xc71e,
0xc535,
0xc531,
0xc522,
0xc508,
0xc7a2,
0xc7fc,
0x0422,
0x0004,
0x0005,
0x0006,
0x0008,
0xc52f,
0xc790,
0xc5ce,
0xc503,
0xc7fd,
0xc654,
0x042f,
0xc6dd,
0xc60e,
0x0004,
0x0005,
0x0006,
0x0007,
0xc4fc,
0xc516,
0xc5b9,
0xc612,
0xc54b,
0xc614,
0xc5a1,
0xc5cd,
0x0004,
0x980b,
0x006b,
0x0130,
0xa228,
0x0003,
0xa016,
0x002e,
0x0004,
0x001c,
0xa41f,
0xa41f,
0x0004,
0x0014,
0xac37,
0xac37,
0x0004,
0x000b,
0xb88e,
0xbaf0,
0x0004,
0x0005,
0xc381,
0xc3fa,
0xc70c,
0xc6af,
0xc6a4,
0xc68b,
0xc3ff,
0xc33f,
0xbebf,
0xbebf,
0x0408,
0xb66a,
0xb66a,
0xb5e8,
0xb5e8,
0x0004,
0xb173,
0xaeee,
0xaeee,
0x0004,
0xbbb3,
0xb87d,
0x0005,
0xbd8c,
0xbd8c,
0xbfd9,
0xbfd9,
0xbca0,
0xbca0,
0xc3f7,
0xc373,
0x0004,
0xab4a,
0x001a,
0xaab8,
0x0004,
0x000f,
0xac36,
0xac36,
0xba34,
0xbbbc,
0x0002,
0x0005,
0xc0f8,
0xc337,
0xbd96,
0xbd96,
0xbca1,
0xbca1,
0xbcaa,
0xbcaa,
0x0004,
0xb884,
0xb460,
0xb460,
0xbf6a,
0xbf6a,
0xbca4,
0xbca4,
0xb379,
0xb322,
0x0002,
0xb174,
0xb985,
0x0003,
0x000e,
0x0011,
0xbfe6,
0xbfe6,
0xc3fd,
0x0002,
0x040c,
0x0003,
0xc7fc,
0x0414,
0xc944,
0x0001,
0xcd5a,
0xcd60,
0xbd92,
0xbd92,
0xbca2,
0xbca2,
0xbed5,
0xbed5,
0xbcb0,
0xbcb0,
0xa303,
0x0003,
0x0074,
0x008b,
0x0004,
0x004b,
0xa420,
0xa420,
0x0004,
0x0007,
0x0013,
0x0016,
0xbbb5,
0xbb23,
0xb6ef,
0xb6ef,
0x0004,
0xbbbe,
0xb6ba,
0xb6ba,
0xbc9d,
0xbc9d,
0x0002,
0x0003,
0xc5b4,
0xc686,
0xc5c7,
0xc7fc,
0x0416,
0xb793,
0xb793,
0xb57c,
0xb57c,
0x0004,
0x0011,
0x001c,
0x0026,
0x0004,
0x0006,
0x0008,
0x0009,
0xc7fd,
0xc620,
0x0409,
0xc67d,
0xc7fc,
0x0425,
0xc71d,
0xc765,
0xc537,
0xc7a8,
0x0004,
0x0005,
0x0006,
0x0007,
0xc523,
0xc518,
0xc5da,
0xc6a2,
0xc79e,
0xc7ba,
0xc6fa,
0xc4e8,
0x0005,
0x0006,
0x0007,
0xc3fc,
0x0401,
0xc610,
0xc778,
0xc50b,
0xc609,
0xc762,
0xc6cd,
0xc245,
0xc0c8,
0xc3fd,
0xc3fd,
0x041e,
0x040b,
0x0004,
0xb04b,
0x0018,
0x001b,
0x0004,
0x0009,
0x000c,
0x000f,
0xc0e3,
0xc3fe,
0xc2f4,
0xc3fd,
0x0402,
0x0407,
0xc24d,
0xc0d8,
0xc383,
0xc0ec,
0xbfe4,
0xbfe4,
0xbfd8,
0xbfd8,
0xbc9c,
0xbc9c,
0xbe72,
0xbe72,
0xb9f0,
0xbbc5,
0xb5e9,
0xb5e9,
0xb799,
0xb799,
0xb987,
0x0001,
0xc208,
0xc106,
0xbd9e,
0xbd9e,
0x0004,
0xa82a,
0xa567,
0xa567,
0xb37c,
0xb22d,
0xb04c,
0x0001,
0x0004,
0x0007,
0x000a,
0xbbb9,
0xbe3a,
0xbe3a,
0xbfe5,
0xbfe5,
0xbcb9,
0xbcb9,
0xbed6,
0xbed6,
0xbfe7,
0xbfe7,
0xbe96,
0xbe96,
0xa734,
0xa734,
0x0002,
0x0025,
0x0004,
0x000b,
0xad6e,
0xad6e,
0xb630,
0xb630,
0xb883,
0x0001,
0xc0dd,
0xc1a6,
0xc0db,
0xc218,
0x0004,
0x000b,
0x000e,
0x0011,
0xc3ff,
0xc3ff,
0xc3ff,
0xc3ff,
0x0418,
0x03fc,
0x040a,
0x0417,
0xc3ea,
0xc27a,
0xc37a,
0xc356,
0xbcb4,
0xbcb4,
0xbca9,
0xbca9,
0xbcb6,
0xbcb6,
0xbfdb,
0xbfdb,
0xaf63,
0xaf63,
0x0002,
0x0005,
0xb881,
0xb986,
0xb797,
0xb797,
0xb87e,
0x0003,
0xb468,
0xb468,
0xbd9b,
0xbd9b,
0xbcb7,
0xbcb7,
0x9c10,
0x9c10,
0xa017,
0x0001,
0xa96a,
0x0003,
0xab4f,
0x0023,
0xac38,
0xac38,
0x0002,
0x001b,
0xbbc2,
0xb98a,
0xb880,
0x0001,
0x0004,
0x0009,
0x000e,
0x0011,
0x0002,
0x0003,
0xcaab,
0xc9c5,
0xc929,
0xcb00,
0x0002,
0x0003,
0xca1a,
0xca22,
0xcae3,
0xcb0f,
0x0002,
0xc5a3,
0xc9d5,
0xcb11,
0xc5b1,
0xc685,
0xb465,
0xb465,
0xb79d,
0xb79d,
0xac3a,
0xac3a,
0x0002,
0x001f,
0xb467,
0xb467,
0x0002,
0x000f,
0x0004,
0x0005,
0x0007,
0x0009,
0xc61d,
0xc659,
0xc7fd,
0xc768,
0x042b,
0xc7fd,
0xc509,
0x042d,
0xc6c7,
0xc536,
0x0004,
0x0005,
0x0006,
0x0007,
0xc6cb,
0xc525,
0xc7aa,
0xc715,
0xc6ce,
0xc728,
0xc54c,
0xc534,
0x0004,
0x000f,
0x0015,
0x0018,
0x0004,
0x0005,
0x0006,
0x0007,
0xc7b8,
0xc65d,
0xc5c6,
0xc5c0,
0xc733,
0xc7b6,
0xc7ce,
0xc50e,
0x0005,
0xc1ad,
0xc0ef,
0xc3fc,
0x0419,
0xc6f8,
0xc5ba,
0xc29c,
0xc1a7,
0xc0e2,
0xc1a5,
0xc34c,
0xc351,
0xc3fd,
0xc398,
0x0400,};

const U16 g_rgiHuffDecTbl44smQb[] =
{
0x8802,
0x0003,
0x0274,
0x0341,
0x0004,
0x00a3,
0x01b8,
0x913f,
0x9405,
0x9405,
0x0002,
0x0075,
0xa015,
0x0003,
0xa228,
0x0019,
0x0004,
0xa944,
0xa420,
0xa420,
0xac3f,
0xac3f,
0x0002,
0x0009,
0xb877,
0xb9a6,
0xba1a,
0x0001,
0xc0cc,
0xc176,
0xc22e,
0xc28c,
0xb465,
0xb465,
0x0002,
0xba78,
0xbd7b,
0xbd7b,
0xbdaf,
0xbdaf,
0x0004,
0x002b,
0xa542,
0xa542,
0xac00,
0xac00,
0x0002,
0x0015,
0xb466,
0xb466,
0xb87f,
0x0001,
0xbdb1,
0xbdb1,
0x0002,
0x0007,
0x0002,
0x0003,
0xca35,
0xca24,
0xc992,
0xc9cd,
0x0002,
0x0003,
0xc9f7,
0xc91d,
0xc9f3,
0xca58,
0xb46a,
0xb46a,
0xba3b,
0x0001,
0x0004,
0x0005,
0x0006,
0x0007,
0xc4e5,
0xc659,
0xc65c,
0xc64f,
0xc530,
0xc5d0,
0xc501,
0xc4f8,
0xac3d,
0xac3d,
0x0002,
0x0021,
0x0004,
0x000f,
0x0016,
0x0019,
0x0004,
0x0005,
0x0006,
0x0007,
0xc604,
0xc627,
0xc4fa,
0xc4ee,
0xc504,
0xc509,
0xc699,
0xc68e,
0x0004,
0x0005,
0xc0bf,
0xc0c3,
0xc515,
0xc638,
0xc517,
0xc632,
0xc1ee,
0xc1e7,
0xc1bf,
0xc0eb,
0xbe2d,
0xbe2d,
0xbcae,
0xbcae,
0xb884,
0x0003,
0xb5de,
0xb5de,
0xbdb6,
0xbdb6,
0xbcb3,
0xbcb3,
0x9c0d,
0x9c0d,
0x0002,
0x0011,
0x0004,
0xa82d,
0xa82e,
0x0009,
0xac3b,
0xac3b,
0xb04d,
0x0001,
0xb671,
0xb671,
0xb46e,
0xb46e,
0xb267,
0xb14e,
0xb04f,
0xb14c,
0xa421,
0xa421,
0x0002,
0xa82f,
0xac3c,
0xac3c,
0x0002,
0xb052,
0xb555,
0xb555,
0x0002,
0x0005,
0xc0c9,
0xc286,
0xbca5,
0xbca5,
0xbdb8,
0xbdb8,
0xbe7f,
0xbe7f,
0x0004,
0x9809,
0x008e,
0x00eb,
0x0004,
0x0007,
0xa016,
0x0031,
0xa643,
0xa643,
0xa423,
0xa423,
0xa422,
0xa422,
0x0002,
0x0005,
0xb050,
0xb14d,
0xae60,
0xae60,
0xad48,
0xad48,
0xb1a1,
0x0001,
0x0004,
0x0009,
0x0014,
0x0019,
0xc0e8,
0x0003,
0xbde4,
0xbde4,
0xc5cb,
0xc63f,
0x0004,
0x0005,
0x0006,
0x0007,
0xc4e6,
0xc5ff,
0xc51e,
0xc528,
0xc5fc,
0xc695,
0xc584,
0xc590,
0x0004,
0xc0d3,
0xc247,
0xc252,
0xc58c,
0xc5f2,
0xc0da,
0xc0d4,
0xc0c6,
0xc230,
0x0004,
0x001b,
0x003e,
0xa830,
0xb054,
0x0003,
0xb14f,
0x000d,
0x0004,
0x0007,
0xb963,
0xba79,
0xc1bb,
0xc288,
0xbca4,
0xbca4,
0xbcbb,
0xbcbb,
0xbdb3,
0xbdb3,
0xb880,
0x0003,
0xb559,
0xb559,
0xbdb0,
0xbdb0,
0xbd78,
0xbd78,
0x0004,
0xb051,
0xb04c,
0x0009,
0xb46c,
0xb46c,
0xb881,
0x0001,
0xbcb8,
0xbcb8,
0xbe4c,
0xbe4c,
0xb883,
0x0003,
0x000e,
0x0011,
0x0004,
0xc0c1,
0xc0cb,
0xc1fe,
0xc626,
0x0001,
0x0002,
0x0003,
0xce09,
0xcd23,
0xce0a,
0xcd21,
0xc0db,
0xc268,
0xc289,
0xc290,
0xc0f3,
0xc0c0,
0xc0cd,
0xc1d5,
0x0004,
0xb23a,
0x000a,
0x0011,
0x0004,
0xb891,
0xb88c,
0xb882,
0xbcab,
0xbcab,
0xbe3d,
0xbe3d,
0xba2b,
0x0003,
0xb64b,
0xb64b,
0xbcb9,
0xbcb9,
0xbcb1,
0xbcb1,
0xb55b,
0xb55b,
0xb47c,
0xb47c,
0x9c0e,
0x9c0e,
0xa017,
0x0001,
0xa99d,
0xa831,
0x0002,
0xaa55,
0xb1dc,
0x0003,
0x0006,
0x003b,
0xb5a4,
0xb5a4,
0xb46f,
0xb46f,
0xb9ac,
0x0003,
0x001c,
0x0027,
0x0004,
0x0009,
0x000e,
0x0013,
0x0002,
0x0003,
0xc92a,
0xc916,
0xc998,
0xc924,
0x0002,
0x0003,
0xca06,
0xca07,
0xca41,
0xc93c,
0x0002,
0x0003,
0xc989,
0xc91c,
0xc981,
0xc92e,
0x0002,
0xc514,
0xc994,
0xca11,
0x0004,
0x0005,
0x0006,
0x0007,
0xc5ce,
0xc583,
0xc4e4,
0xc505,
0xc587,
0xc520,
0xc52f,
0xc534,
0x0004,
0x0005,
0x0006,
0x0007,
0xc53b,
0xc4e9,
0xc5d3,
0xc50f,
0xc4f0,
0xc599,
0xc5d6,
0xc532,
0x0004,
0x000b,
0x000e,
0x0011,
0x0004,
0x0005,
0xc1c9,
0xc0d8,
0xc58a,
0xc698,
0xc65f,
0xc642,
0xc221,
0xc28b,
0xc0c8,
0xc0de,
0xbd79,
0xbd79,
0xbe80,
0xbe80,
0xbd77,
0xbd77,
0xbca9,
0xbca9,
0x0004,
0xa018,
0x9c0f,
0x9c0f,
0xa424,
0xa424,
0x0002,
0xa945,
0x0004,
0x000b,
0x0012,
0xb057,
0x0004,
0xb9aa,
0xb46d,
0xb46d,
0xbdb7,
0xbdb7,
0xbc9f,
0xbc9f,
0xb556,
0xb556,
0xba7a,
0x0001,
0xbdb2,
0xbdb2,
0xbca7,
0xbca7,
0xb566,
0xb566,
0x0002,
0x0005,
0xbe81,
0xbe81,
0xbd74,
0xbd74,
0xbd75,
0xbd75,
0xbcac,
0xbcac,
0x9406,
0x9406,
0x0002,
0x00ad,
0x0004,
0x0047,
0x004a,
0xa141,
0x0004,
0x0019,
0xa832,
0x0039,
0xb055,
0x0003,
0xb05c,
0x0005,
0xb9e1,
0xb96b,
0xb618,
0xb618,
0xb558,
0xb558,
0x0002,
0x0007,
0x0004,
0xc28a,
0xc0d2,
0xc0d9,
0xc640,
0xc633,
0xc0e1,
0xc0e3,
0xbe3c,
0xbe3c,
0x0004,
0x000b,
0xb151,
0x0013,
0x0004,
0xb88e,
0xb5a5,
0xb5a5,
0xbde8,
0xbde8,
0xbd72,
0xbd72,
0x0004,
0xba5b,
0xb46b,
0xb46b,
0xbdc3,
0xbdc3,
0xc21f,
0x0001,
0xc588,
0xc519,
0xb88a,
0x0003,
0x0006,
0xb9a9,
0xbcf6,
0xbcf6,
0xbca8,
0xbca8,
0xbe82,
0xbe82,
0xbe46,
0xbe46,
0xb150,
0x0003,
0xb269,
0xb056,
0xb892,
0xb9ae,
0xb567,
0xb567,
0xa425,
0xa425,
0xa426,
0xa426,
0x0004,
0x0027,
0x002a,
0x0045,
0xad9f,
0xad9f,
0x0002,
0x0011,
0xb55a,
0xb55a,
0xb9ab,
0x0001,
0x0004,
0x0005,
0x0006,
0x0007,
0xc4f1,
0xc59a,
0xc513,
0xc536,
0xc4fd,
0xc4fe,
0xc4ff,
0xc57f,
0xb5df,
0xb5df,
0x0002,
0x0009,
0x0004,
0x0005,
0xc220,
0xc0c7,
0xc670,
0xc50d,
0xc591,
0xc5fd,
0xc0cf,
0xc1be,
0xbca0,
0xbca0,
0xae63,
0xae63,
0xb059,
0xb26b,
0x0004,
0xb1a2,
0xae29,
0xae29,
0x0004,
0xb96c,
0x0006,
0x0011,
0xbcb0,
0xbcb0,
0xbd70,
0xbd70,
0xbd71,
0xbd71,
0xc0d6,
0x0001,
0xc51b,
0x0001,
0x0002,
0xc9fb,
0xce0d,
0x0001,
0xd20c,
0xd210,
0xbd73,
0xbd73,
0xbcaf,
0xbcaf,
0x0004,
0xb217,
0xb05d,
0x0009,
0xb96a,
0x0003,
0xb55c,
0xb55c,
0xbca3,
0xbca3,
0xc18b,
0xc0e7,
0x0004,
0x0007,
0xba2c,
0xba7b,
0xc28d,
0xc26c,
0xc1f6,
0xc0ea,
0xbd7a,
0xbd7a,
0xbcb7,
0xbcb7,
0x9e15,
0x9e15,
0xa019,
0x0001,
0xa429,
0xa429,
0xa64a,
0xa64a,
0x9004,
0x0003,
0x8c03,
0x8c03,
0x980a,
0x0003,
0x0054,
0x0091,
0x9c10,
0x9c10,
0x0002,
0x001b,
0xa946,
0x0003,
0xa42a,
0xa42a,
0x0004,
0xb058,
0x0006,
0xb05a,
0xb619,
0xb619,
0xb651,
0xb651,
0xb886,
0x0003,
0xb55d,
0xb55d,
0xc1c5,
0x0003,
0xbe3e,
0xbe3e,
0x0002,
0x0003,
0xc927,
0xc9d1,
0xca13,
0xc931,
0xa427,
0xa427,
0x0002,
0x0015,
0xb152,
0x0003,
0xac40,
0xac40,
0x0004,
0xb96e,
0xb889,
0x0005,
0xbcaa,
0xbcaa,
0xbcc5,
0xbcc5,
0xbcb6,
0xbcb6,
0x0002,
0x0003,
0xc50c,
0xc608,
0xc614,
0xc602,
0x0004,
0x0007,
0x0016,
0xb05b,
0xb557,
0xb557,
0xb62a,
0xb62a,
0xb470,
0xb470,
0xba5e,
0x0001,
0x0004,
0x0005,
0x0006,
0x0007,
0xc506,
0xc500,
0xc649,
0xc510,
0xc5d8,
0xc5fa,
0xc58d,
0xc518,
0xb47d,
0xb47d,
0xb47b,
0xb47b,
0x0004,
0xa01a,
0x9c11,
0x9c11,
0xa428,
0xa428,
0x0002,
0x0023,
0x0004,
0x001d,
0xaddb,
0xaddb,
0x0004,
0x000d,
0x0010,
0x0013,
0x0004,
0x0005,
0x0006,
0xc103,
0xc53e,
0xc675,
0xc673,
0xc51a,
0xc58e,
0xc597,
0xc1bc,
0xc1ca,
0xc180,
0xc26a,
0xc248,
0xc253,
0xbcb2,
0xbcb2,
0xbdb5,
0xbdb5,
0xbde5,
0xbde5,
0xba7d,
0xb9e2,
0xb96f,
0xb894,
0xad49,
0xad49,
0x0002,
0x0009,
0xb89e,
0x0003,
0xb471,
0xb471,
0xbcad,
0xbcad,
0xbcb5,
0xbcb5,
0xb887,
0x0003,
0xb8ba,
0xb89c,
0xbdc0,
0xbdc0,
0xbdc2,
0xbdc2,
0x0004,
0xa239,
0xa01b,
0x000d,
0xa543,
0xa543,
0xaa5a,
0x0001,
0xac45,
0xac45,
0xb244,
0x0001,
0xb47a,
0xb47a,
0xb893,
0xb895,
0xa833,
0x0003,
0xa834,
0x0005,
0xb1a3,
0xb062,
0xac41,
0xac41,
0x0004,
0x000f,
0xac46,
0xac46,
0x0004,
0x0007,
0xb472,
0xb472,
0xc1c6,
0xc0e2,
0xc1d4,
0xc1ef,
0xc0f9,
0xc24d,
0xc22f,
0xc223,
0x0004,
0x0007,
0xb672,
0xb672,
0xbdb9,
0xbdb9,
0xbcc2,
0xbcc2,
0xbcf5,
0xbcf5,
0xc1f0,
0x0001,
0xc5d7,
0xc637,
0x0004,
0x0099,
0x009c,
0x012d,
0x0004,
0x99d9,
0x980b,
0x0005,
0xa19c,
0xa01c,
0x9c12,
0x9c12,
0x0004,
0x005b,
0xa01d,
0x0073,
0x0004,
0x002b,
0xa835,
0x0049,
0x0004,
0x0017,
0xac43,
0xac43,
0x0004,
0x0007,
0x000a,
0x000d,
0xbcb4,
0xbcb4,
0xbdc8,
0xbdc8,
0xbcbd,
0xbcbd,
0xbdc1,
0xbdc1,
0xbe83,
0xbe83,
0xbdc4,
0xbdc4,
0xbe1d,
0xbe1d,
0xbdba,
0xbdba,
0xba7c,
0x0003,
0xb676,
0xb676,
0x0004,
0x0005,
0x0006,
0x0007,
0xc526,
0xc51f,
0xc697,
0xc600,
0xc525,
0xc52c,
0xc593,
0xc502,
0xac42,
0xac42,
0x0002,
0x0011,
0xb476,
0xb476,
0x0002,
0x0009,
0x0004,
0x0005,
0xc0d5,
0xc0f2,
0xc596,
0xc634,
0xc693,
0xc533,
0xc225,
0xc0d7,
0xc28f,
0xc231,
0x0004,
0x0007,
0xb561,
0xb561,
0xc1f1,
0xc0f7,
0xbdea,
0xbdea,
0xbe85,
0xbe85,
0xbe87,
0xbe87,
0xac47,
0xac47,
0x0002,
0x0005,
0xb474,
0xb474,
0xb96d,
0xb888,
0xb8a6,
0xb89a,
0xb560,
0xb560,
0x0004,
0xa947,
0xa42b,
0xa42b,
0xb05e,
0x0003,
0x0010,
0xb063,
0xb885,
0x0003,
0xb9e3,
0xb9ad,
0xc13d,
0x0003,
0xbd7c,
0xbd7c,
0xc535,
0x0001,
0x0002,
0xca0e,
0xce0f,
0xcdd2,
0xb8a1,
0xb88f,
0xb674,
0xb674,
0xa836,
0x0003,
0xaa16,
0xa837,
0xb1dd,
0x0003,
0xada0,
0xada0,
0xb88d,
0x0003,
0x0006,
0x0009,
0xbcf4,
0xbcf4,
0xc292,
0xc186,
0xc1cf,
0xc185,
0xc257,
0xc26e,
0xc291,
0xc294,
0xc262,
0xc203,
0x959b,
0x959b,
0x9407,
0x9407,
0x0004,
0x0057,
0x980c,
0x9940,
0x9c13,
0x9c13,
0x0002,
0x0009,
0xa5da,
0xa5da,
0x0002,
0xa838,
0xb05f,
0xb26d,
0xad4a,
0xad4a,
0x0004,
0x0023,
0x0026,
0x0039,
0x0004,
0xb154,
0x0016,
0x0019,
0x0004,
0x0007,
0xb89b,
0x0009,
0xc201,
0xc24e,
0xbe84,
0xbe84,
0xbdb4,
0xbdb4,
0xbcbc,
0xbcbc,
0xbe66,
0xbe66,
0xc1f4,
0x0001,
0x0002,
0xc5cc,
0xca05,
0xca36,
0xb479,
0xb479,
0xb677,
0xb677,
0xba45,
0xb89d,
0xb562,
0xb562,
0xac49,
0xac49,
0xac44,
0xac44,
0xac48,
0xac48,
0x0002,
0x0005,
0xb478,
0xb478,
0xb55f,
0xb55f,
0xb565,
0xb565,
0xb896,
0x0001,
0xbdc7,
0xbdc7,
0x0002,
0x0003,
0xc60b,
0xc5f8,
0xc595,
0xc57d,
0x0004,
0x0007,
0xac4a,
0xac4a,
0xb55e,
0xb55e,
0xb564,
0xb564,
0xb475,
0xb475,
0xb47e,
0xb47e,
0xa01e,
0x0003,
0x9c14,
0x9c14,
0x0004,
0xa83e,
0xa839,
0x0027,
0x0004,
0x0007,
0xad4b,
0xad4b,
0xb473,
0xb473,
0xb5a8,
0xb5a8,
0x0004,
0x000f,
0x0014,
0x0017,
0x0004,
0x0005,
0x0006,
0x0007,
0xc57e,
0xc508,
0xc53a,
0xc539,
0xc538,
0xc52b,
0xc52d,
0xc50b,
0x0004,
0xc0d0,
0xc0fb,
0xc137,
0xc522,
0xc529,
0xc0ef,
0xc212,
0xc10a,
0xc1f5,
0xbcdc,
0xbcdc,
0xbcca,
0xbcca,
0x0004,
0xb153,
0xae65,
0xae65,
0x0004,
0xb897,
0xb656,
0xb656,
0xbde6,
0xbde6,
0xbdbd,
0xbdbd,
0x0004,
0x9801,
0x9408,
0x9408,
0xa01f,
0x0003,
0x002a,
0x0051,
0x0004,
0xa83a,
0x0012,
0x001d,
0x0004,
0xb064,
0xb068,
0xb060,
0x0004,
0xba7e,
0xba1b,
0x0005,
0xbe1e,
0xbe1e,
0xbded,
0xbded,
0xbcdd,
0xbcdd,
0xbcd1,
0xbcd1,
0x0004,
0x0007,
0xac53,
0xac53,
0xba61,
0xb899,
0xb569,
0xb569,
0xb568,
0xb568,
0xb8a2,
0xb898,
0xac4e,
0xac4e,
0x0002,
0xb061,
0xb48b,
0xb48b,
0xb5a7,
0xb5a7,
0xa42c,
0xa42c,
0x0002,
0xaa5d,
0xac4b,
0xac4b,
0x0002,
0x0015,
0x0004,
0x0007,
0x000a,
0x000d,
0xc0ec,
0xc0fc,
0xc222,
0xc296,
0xc0df,
0xc18f,
0xc254,
0xc182,
0xc107,
0xc111,
0xc10e,
0xc1f9,
0xc112,
0xc0ed,
0xbde9,
0xbde9,
0x0004,
0x0007,
0xb5e0,
0xb5e0,
0xbcbe,
0xbcbe,
0xbdec,
0xbdec,
0xbcce,
0xbcce,
0xbce0,
0xbce0,
0x0004,
0xa99e,
0xa650,
0xa650,
0xb069,
0xb26f,
0xb067,
0x0001,
0xba64,
0xba1c,
0xb890,
0x0001,
0xbdeb,
0xbdeb,
0xbcc4,
0xbcc4
};


const U16 g_rgiHuffDecTbl44ssQb[] =
{
0x0004,
0x8802,
0x0108,
0x029d,
0x9003,
0x0003,
0x005a,
0x00df,
0x9401,
0x9401,
0x0002,
0x9994,
0x9d3a,
0x9d3a,
0x0002,
0x0045,
0x0004,
0xa83b,
0x001a,
0xa9d2,
0x0004,
0x0007,
0xac59,
0xac59,
0xb613,
0xb613,
0xb4f8,
0xb4f8,
0xb8dd,
0x0003,
0x0006,
0x0009,
0xc1ea,
0xc188,
0xc119,
0xc1ce,
0xbdab,
0xbdab,
0xbcfc,
0xbcfc,
0xbd0d,
0xbd0d,
0xbd03,
0xbd03,
0x0004,
0x0017,
0x001e,
0x0021,
0x0004,
0x0007,
0x000a,
0x000d,
0xbd04,
0xbd04,
0xbd82,
0xbd82,
0xbdb3,
0xbdb3,
0xbddc,
0xbddc,
0xbd1a,
0xbd1a,
0xbcff,
0xbcff,
0xbce9,
0xbce9,
0xbd35,
0xbd35,
0x0004,
0xb96a,
0xb4b8,
0xb4b8,
0xbd18,
0xbd18,
0xbd81,
0xbd81,
0xb4b7,
0xb4b7,
0xb499,
0xb499,
0xb49f,
0xb49f,
0xb49e,
0xb49e,
0xa428,
0xa428,
0x0002,
0xa839,
0xb149,
0x0003,
0xac5b,
0xac5b,
0xb488,
0xb488,
0xb976,
0xb8da,
0x9808,
0x0003,
0x002a,
0x006f,
0x0004,
0x0013,
0x9dd1,
0x9dd1,
0xa53d,
0xa53d,
0x0002,
0x0009,
0xad43,
0xad43,
0xb079,
0x0001,
0xb490,
0xb490,
0xba07,
0xb9a7,
0xac7c,
0xac7c,
0xac5e,
0xac5e,
0xa83a,
0x0003,
0x000e,
0xa941,
0x0004,
0x0007,
0xac5d,
0xac5d,
0xb8d2,
0xb9a4,
0xb968,
0xb9f3,
0xb563,
0xb563,
0xb55a,
0xb55a,
0xadee,
0xadee,
0xac58,
0xac58,
0xa018,
0x0003,
0xa019,
0xa01c,
0x0004,
0x002d,
0xaa04,
0xa840,
0x0004,
0x0011,
0xb154,
0x0013,
0xb8b1,
0x0003,
0xb49d,
0xb49d,
0xc1ba,
0x0003,
0xbe11,
0xbe11,
0x0002,
0xc590,
0xc9c2,
0x0001,
0xcdcb,
0xcdcd,
0xb615,
0xb615,
0xb603,
0xb603,
0x0004,
0x0007,
0x000a,
0x000d,
0xbd1e,
0xbd1e,
0xbdac,
0xbdac,
0xbd84,
0xbd84,
0xbd1c,
0xbd1c,
0xbd21,
0xbd21,
0xbcee,
0xbcee,
0xbd71,
0xbd71,
0xbe21,
0xbe21,
0x0004,
0x0007,
0x000a,
0x000d,
0xb8d4,
0xb9a2,
0xb9f2,
0xb8ca,
0xb9a8,
0xb8cc,
0xb8ea,
0xb9b1,
0xb560,
0xb560,
0xb5a5,
0xb5a5,
0xb55e,
0xb55e,
0xb4a7,
0xb4a7,
0x0004,
0xa017,
0x9c0d,
0x9c0d,
0x0004,
0x0007,
0xa42d,
0xa42d,
0xae0a,
0xae0a,
0xac5c,
0xac5c,
0x0004,
0xb08b,
0xad99,
0xad99,
0xb4c3,
0xb4c3,
0xb4d1,
0xb4d1,
0x9809,
0x0003,
0x9405,
0x9405,
0x0004,
0xa01d,
0x9c0e,
0x9c0e,
0xa996,
0x0003,
0xa5fd,
0xa5fd,
0x0004,
0x000f,
0xb076,
0x0011,
0x0004,
0xb8e6,
0xb9a9,
0xb972,
0xbdf5,
0xbdf5,
0x0002,
0x0003,
0xc57e,
0xc57f,
0xc5cf,
0xc5c5,
0xb55c,
0xb55c,
0xb614,
0xb614,
0xb4a0,
0xb4a0,
0xb5f0,
0xb5f0,
0x0004,
0x00e1,
0x0120,
0x9139,
0x0004,
0x0079,
0x008c,
0x980a,
0x0004,
0x004b,
0x004e,
0xa13b,
0x0004,
0x0007,
0x001e,
0x003d,
0xac68,
0xac68,
0xb071,
0xb077,
0xac5a,
0xac5a,
0xb19c,
0x0001,
0x0004,
0x0007,
0x000a,
0x000d,
0xc1c9,
0xc12d,
0xc133,
0xc124,
0xc224,
0xc1c4,
0xc228,
0xc186,
0xc1b7,
0xc18b,
0xbd1f,
0xbd1f,
0xbdc1,
0xbdc1,
0xbd8f,
0xbd8f,
0x0004,
0x0017,
0x001a,
0xb1d4,
0x0004,
0x0007,
0x000a,
0x000d,
0xbdc0,
0xbdc0,
0xbe0d,
0xbe0d,
0xbd11,
0xbd11,
0xbd2e,
0xbd2e,
0xbd0f,
0xbd0f,
0xbdf4,
0xbdf4,
0xbdb6,
0xbdb6,
0xbd0a,
0xbd0a,
0xb9ff,
0xb9af,
0xba1d,
0xb8d7,
0xb8f1,
0xb9fa,
0xb8b0,
0xba19,
0xac7d,
0xac7d,
0x0002,
0xb210,
0xb575,
0xb575,
0xb4bc,
0xb4bc,
0xa53e,
0xa53e,
0xa42f,
0xa42f,
0x0004,
0xa842,
0x0010,
0xa942,
0xac63,
0xac63,
0x0002,
0xb14d,
0xb59e,
0xb59e,
0x0002,
0xb8d5,
0xbd05,
0xbd05,
0xc18c,
0x0001,
0xc5cc,
0xc5c3,
0x0004,
0x0007,
0x000a,
0xb1d5,
0xba1b,
0xb906,
0xb8de,
0xb9fb,
0xb4cf,
0xb4cf,
0xb4aa,
0xb4aa,
0xb616,
0xb616,
0xb927,
0x0001,
0xbdbb,
0xbdbb,
0xbdbc,
0xbdbc,
0x0004,
0xa01a,
0x9c0f,
0x9c0f,
0xa430,
0xa430,
0x0002,
0xa841,
0xac67,
0xac67,
0x0002,
0x0005,
0xb564,
0xb564,
0xb4c0,
0xb4c0,
0xb617,
0xb617,
0xb4ab,
0xb4ab,
0xa021,
0xa01b,
0x0002,
0x0035,
0x0004,
0x0027,
0xa400,
0xa400,
0xb075,
0x0003,
0xb07f,
0x000d,
0xb4be,
0xb4be,
0x0002,
0x0005,
0xbd83,
0xbd83,
0xbdd0,
0xbdd0,
0xbe25,
0xbe25,
0xbde4,
0xbde4,
0x0004,
0x0007,
0x000a,
0x000d,
0xbd1b,
0xbd1b,
0xbd93,
0xbd93,
0xbd17,
0xbd17,
0xbd20,
0xbd20,
0xbcf0,
0xbcf0,
0xbd0e,
0xbd0e,
0xbdfc,
0xbdfc,
0xbdf6,
0xbdf6,
0x0004,
0xb089,
0xad44,
0xad44,
0x0004,
0xb9a6,
0xb56b,
0xb56b,
0xbd70,
0xbd70,
0xbd34,
0xbd34,
0xa42e,
0xa42e,
0x0002,
0x0005,
0xac66,
0xac66,
0xac5f,
0xac5f,
0x0004,
0x000b,
0xac62,
0xac62,
0xb4a9,
0xb4a9,
0xb96e,
0x0001,
0xbdec,
0xbdec,
0xc1bf,
0xc1ca,
0xb55d,
0xb55d,
0xb4ce,
0xb4ce,
0x0004,
0x0007,
0x9406,
0x9406,
0xa01e,
0xa01f,
0x9c10,
0x9c10,
0xa020,
0x0003,
0x0016,
0x0029,
0x0004,
0x000b,
0xa431,
0xa431,
0x0004,
0xb074,
0xb1d6,
0xb157,
0xb4d0,
0xb4d0,
0xb4b6,
0xb4b6,
0xb19d,
0x0003,
0xac61,
0xac61,
0xb4af,
0xb4af,
0xb8d8,
0xb8e3,
0x0004,
0x000b,
0xa432,
0xa432,
0xb080,
0xb14e,
0x0002,
0xb14f,
0xb566,
0xb566,
0xb56c,
0xb56c,
0xb073,
0x0003,
0xb072,
0xb081,
0xb4f9,
0xb4f9,
0xb4bd,
0xb4bd,
0xa434,
0xa434,
0xa84e,
0x0001,
0xb212,
0x0003,
0xac64,
0xac64,
0xb4c9,
0xb4c9,
0xb4ae,
0xb4ae,
0x0004,
0x0047,
0x006e,
0x980b,
0x9c11,
0x9c11,
0x0002,
0x003d,
0x0004,
0xa845,
0x0012,
0x0035,
0xb0a4,
0x0003,
0xac69,
0xac69,
0xb55f,
0xb55f,
0x0002,
0x0005,
0xc18d,
0xc1e7,
0xc1e5,
0xc1e9,
0xbdb8,
0xbdb8,
0xbcef,
0xbcef,
0x0004,
0x0017,
0x001e,
0xb152,
0x0004,
0x0007,
0x000a,
0x000d,
0xbdde,
0xbdde,
0xbddf,
0xbddf,
0xbe01,
0xbe01,
0xbe0b,
0xbe0b,
0xbcfe,
0xbcfe,
0xbd32,
0xbd32,
0xbdb5,
0xbdb5,
0xbd30,
0xbd30,
0x0004,
0xb916,
0xb8e5,
0xba0f,
0xbe2a,
0xbe2a,
0xbe27,
0xbe27,
0xb90c,
0xb8e7,
0xb4b4,
0xb4b4,
0xb0a5,
0xb155,
0xad48,
0xad48,
0xa846,
0xa847,
0xa43e,
0xa43e,
0xa1f7,
0x0003,
0x0022,
0xa02a,
0x0004,
0xa844,
0xa853,
0x000d,
0xac65,
0xac65,
0xb078,
0x0001,
0xb8e4,
0x0003,
0xb55b,
0xb55b,
0xbd26,
0xbd26,
0xbd91,
0xbd91,
0x0004,
0xb085,
0x0006,
0x0009,
0xb4c5,
0xb4c5,
0xb4f4,
0xb4f4,
0xba1c,
0xb8e8,
0xba1e,
0xb967,
0xb936,
0xb9aa,
0xb910,
0xb907,
0xa435,
0xa435,
0xa84d,
0xa84a,
0x9c13,
0x9c13,
0x9c12,
0x9c12,
0x0004,
0x9004,
0x00c6,
0x0135,
0x0004,
0x005f,
0x0086,
0x00b1,
0x0004,
0xa022,
0x0026,
0x0031,
0x0004,
0x000f,
0x001e,
0xa843,
0x0004,
0x0007,
0xac60,
0xac60,
0xb4f7,
0xb4f7,
0xb565,
0xb565,
0xb5f1,
0xb5f1,
0xb56d,
0xb56d,
0xb0a2,
0xb082,
0x0002,
0x0009,
0xb8e0,
0x0003,
0xb4ad,
0xb4ad,
0xbdbd,
0xbdbd,
0xbde1,
0xbde1,
0xb4d6,
0xb4d6,
0xb4ac,
0xb4ac,
0xb08a,
0xb09a,
0xad47,
0xad47,
0xa84b,
0x0003,
0x0006,
0xaa06,
0xb1fe,
0xb093,
0xb086,
0xb095,
0xac6d,
0xac6d,
0xadd3,
0xadd3,
0x0004,
0x0017,
0xa437,
0xa437,
0xac6a,
0xac6a,
0x0002,
0x000d,
0x0004,
0x0007,
0xb938,
0xb923,
0xbd7d,
0xbd7d,
0xbd78,
0xbd78,
0xbd7a,
0xbd7a,
0xbd2c,
0xbd2c,
0xb8ec,
0xb937,
0xb92f,
0xb913,
0x0004,
0x0007,
0x000a,
0xb0bb,
0xb900,
0xb985,
0xb912,
0xb9be,
0xb90b,
0xb902,
0xb4c2,
0xb4c2,
0xb5d9,
0xb5d9,
0xb501,
0xb501,
0x0004,
0xa026,
0xa023,
0x0009,
0xa433,
0xa433,
0xa848,
0x0001,
0xb0a6,
0xb087,
0xad45,
0xad45,
0x0004,
0x000b,
0x0012,
0x0015,
0xb083,
0x0003,
0xad46,
0xad46,
0xb5d8,
0xb5d8,
0xb4b5,
0xb4b5,
0xac6c,
0xac6c,
0x0002,
0xb161,
0xb4c7,
0xb4c7,
0xb4b2,
0xb4b2,
0xb09b,
0xb084,
0xb0f6,
0xb0ba,
0xad9a,
0xad9a,
0xac7b,
0xac7b,
0x9c15,
0x9c15,
0x0002,
0x0015,
0xa84c,
0x0003,
0xa43f,
0xa43f,
0xae0c,
0xae0c,
0x0002,
0x0009,
0x0004,
0xb8f2,
0xb8ed,
0xb96f,
0xbd2a,
0xbd2a,
0xc1e0,
0xc17b,
0xba22,
0xb8fb,
0xb9ad,
0xb9db,
0xa602,
0xa602,
0xa854,
0x0001,
0x0004,
0x0007,
0x000a,
0xb153,
0xb9ae,
0xb909,
0xba00,
0xb922,
0xb4dc,
0xb4dc,
0xb605,
0xb605,
0xb5a0,
0xb5a0,
0xb4bf,
0xb4bf,
0x0004,
0xa02b,
0x9c14,
0x9c14,
0xa849,
0x0003,
0xa855,
0x0005,
0xb08d,
0xb158,
0xad4a,
0xad4a,
0xb1ef,
0xb098,
0xad4b,
0xad4b,
0x0004,
0x0017,
0x9407,
0x9407,
0xa195,
0x0003,
0xa027,
0xa025,
0xa850,
0x0003,
0xa436,
0xa436,
0x0004,
0x0007,
0xb08f,
0xb097,
0xb4db,
0xb4db,
0xb4cd,
0xb4cd,
0xb4c4,
0xb4c4,
0xb4d3,
0xb4d3,
0xa13c,
0x0003,
0x000a,
0x0011,
0xa43d,
0xa43d,
0x0002,
0xa852,
0xb0a3,
0xb151,
0xb150,
0xb1d7,
0xa53f,
0xa53f,
0x0002,
0xa997,
0xae0e,
0xae0e,
0xadf8,
0xadf8,
0x0004,
0x002f,
0x003e,
0xa851,
0x0004,
0x0017,
0x0022,
0x0025,
0x0004,
0x0007,
0x000a,
0x000d,
0xc192,
0xc189,
0xc18a,
0xc1e8,
0xbd80,
0xbd80,
0xbdeb,
0xbdeb,
0xbde6,
0xbde6,
0xbe23,
0xbe23,
0xbe29,
0xbe29,
0xbdc8,
0xbdc8,
0x0004,
0x0007,
0xb9b0,
0xb9c7,
0xbd31,
0xbd31,
0xbd2b,
0xbd2b,
0xbd29,
0xbd29,
0xbdb4,
0xbdb4,
0xb8fa,
0xb977,
0xb91d,
0xba1f,
0xb928,
0xb97c,
0xb8eb,
0xb8e1,
0x0004,
0x0007,
0x000a,
0xb091,
0xb4cb,
0xb4cb,
0xb574,
0xb574,
0xb61a,
0xb61a,
0xb4b3,
0xb4b3,
0xb5f9,
0xb5f9,
0xb4f3,
0xb4f3,
0xac6e,
0xac6e,
0xac6b,
0xac6b,
0x0004,
0x0023,
0x0026,
0x980c,
0xa029,
0x0003,
0xa024,
0x0019,
0x0004,
0xa84f,
0xa856,
0x000d,
0x0004,
0xb08c,
0xac7e,
0xac7e,
0xb4d9,
0xb4d9,
0xb9e2,
0x0001,
0xbdb9,
0xbdb9,
0xbd8e,
0xbd8e,
0xb0b9,
0x0003,
0xb094,
0xb096,
0xb4c6,
0xb4c6,
0xb4c1,
0xb4c1,
0xa43c,
0xa43c,
0xa438,
0xa438,
0x9ded,
0x9ded,
0x9c16,
0x9c16,
0x0004,
0x002b,
0x003e,
0xa02c,
0x0004,
0x0007,
0x000a,
0x001d,
0xac6f,
0xac6f,
0xac7a,
0xac7a,
0xb159,
0xb0f5,
0xad4c,
0xad4c,
0x0004,
0x0007,
0x000a,
0x000d,
0xb8fd,
0xb914,
0xb925,
0xb987,
0xb908,
0xb8e2,
0xb915,
0xba09,
0xb9e3,
0xb9dd,
0xba26,
0xba20,
0xb573,
0xb573,
0xb618,
0xb618,
0x0004,
0xb0a8,
0xb08e,
0xb162,
0xb5da,
0xb5da,
0xb569,
0xb569,
0x0004,
0xa998,
0xa857,
0x000d,
0xb09c,
0x0003,
0xad9b,
0xad9b,
0xb4df,
0xb4df,
0xb9b2,
0x0001,
0xbd79,
0xbd79,
0xbdc6,
0xbdc6,
0xb092,
0xb0a1,
0xac70,
0xac70,
0x0004,
0xaa08,
0xa540,
0xa540,
0xad56,
0xad56,
0x0002,
0x0005,
0xb59f,
0xb59f,
0xb5a1,
0xb5a1,
0xb4c8,
0xb4c8,
0xb5a3,
0xb5a3
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\idctdec_wmv2.cpp ===
/*************************************************************************

Copyright (C) 1996 -- 1998  Microsoft Corporation

Module Name:

	idct.cpp

Abstract:

	Inverse DCT routines

Author:

	Marc Holder (marchold@microsoft.com)    05/98
    Bruce Lin (blin@microsoft.com)          06/98
    Ming-Chieh Lee (mingcl@microsoft.com)   06/98

Revision History:

*************************************************************************/
#include "bldsetup.h"

#include "xplatform.h"
#include "typedef.hpp"
#include "idctdec_wmv2.h"
#include "wmvdec_api.h"

#ifndef __DCT_COEF_INT_
#define __DCT_COEF_INT_

#define W1 2841L /* 2048*sqrt(2)*cos(1*pi/16) */
#define W2 2676L /* 2048*sqrt(2)*cos(2*pi/16) */
#define W3 2408L /* 2048*sqrt(2)*cos(3*pi/16) */
#define W5 1609L /* 2048*sqrt(2)*cos(5*pi/16) */
#define W6 1108L /* 2048*sqrt(2)*cos(6*pi/16) */
#define W7 565L  /* 2048*sqrt(2)*cos(7*pi/16) */

#define W1a 1892L /* 2048*cos(1*pi/8) */
#define W2a 1448L /* 2048*cos(2*pi/8) */
#define W3a 784L  /* 2048*cos(3*pi/8) */

#define W1_W7 2276L //(W1 - W7)
#define W1pW7 3406L //(W1 + W7)
#define W3_W5 799L  //(W3 - W5)
#define W3pW5 4017L //(W3 + W5)
#define W2_W6 1568L //(W2 - W6)
#define W2pW6 3784L //(W2 + W6)

#endif // __DCT_COEF_INT_

#define SATURATE8(x)   (x < 0 ? 0 : (x > 255 ? 255 : x))

#define _USE_C_IDCT_


///////////////////////////////////////////////////////////////////////////
//
// Intra IDCT Functions
//
///////////////////////////////////////////////////////////////////////////

#ifndef OPT_IDCT_ARM
// C Version
// Input: 32-bit
// Output: 8-bit
Void_WMV g_IDCTDec_WMV2 (U8_WMV* piDst, I32_WMV iOffsetToNextRowForDCT, const PixelI32 __huge* rgiCoefRecon)
{
    I32_WMV x0, x1, x2, x3, x4, x5, x6, x7, x8;
    PixelI32 rgblk [64];
    PixelI32* blk = rgblk;
    I32_WMV iTest;

    I32_WMV  i;
	for (i = 0; i < BLOCK_SIZE; i++, blk += BLOCK_SIZE, rgiCoefRecon += BLOCK_SIZE) {
		x4 = rgiCoefRecon [1];
		x3 = rgiCoefRecon [2];
		x7 = rgiCoefRecon [3];
		x1 = (I32_WMV)rgiCoefRecon [4] << 11 ;
		x6 = rgiCoefRecon [5];
		x2 = rgiCoefRecon [6];
		x5 = rgiCoefRecon [7];
		x0 = ((I32_WMV)rgiCoefRecon [0] << 11) + 128L; /* for proper rounding in the fourth stage */
		/* first stage */
		x8 = W7 * (x4 + x5);
		x4 = x8 + (W1 - W7) * x4;
		x5 = x8 - (W1 + W7) * x5;
		x8 = W3 * (x6 + x7);
		x6 = x8 - (W3 - W5) * x6;
		x7 = x8 - (W3 + W5) * x7;

		/* second stage */
		x8 = x0 + x1;
		x0 -= x1;
		x1 = W6 * (x3 + x2);
		x2 = x1 - (W2 + W6) * x2;
		x3 = x1 + (W2 - W6) * x3;
		x1 = x4 + x6;
		x4 -= x6;
		x6 = x5 + x7;
		x5 -= x7;

		/* third stage */
		x7 = x8 + x3;
		x8 -= x3;
		x3 = x0 + x2;
		x0 -= x2;
		x2 = (I32_WMV) (181L * (x4 + x5) + 128L) >> 8;
		x4 = (I32_WMV) (181L * (x4 - x5) + 128L) >> 8;

		/* fourth stage */
		blk [0] = (PixelI32) ((x7 + x1) >> 8);
		blk [1] = (PixelI32) ((x3 + x2) >> 8);
		blk [2] = (PixelI32) ((x0 + x4) >> 8);
		blk [3] = (PixelI32) ((x8 + x6) >> 8);
		blk [4] = (PixelI32) ((x8 - x6) >> 8);
		blk [5] = (PixelI32) ((x0 - x4) >> 8);
		blk [6] = (PixelI32) ((x3 - x2) >> 8);
		blk [7] = (PixelI32) ((x7 - x1) >> 8);
	}

    {
        U8_WMV * blk0 = piDst;
        U8_WMV * blk1 = blk0 + iOffsetToNextRowForDCT;
        U8_WMV * blk2 = blk1 + iOffsetToNextRowForDCT;
        U8_WMV * blk3 = blk2 + iOffsetToNextRowForDCT;
        U8_WMV * blk4 = blk3 + iOffsetToNextRowForDCT;
        U8_WMV * blk5 = blk4 + iOffsetToNextRowForDCT;
        U8_WMV * blk6 = blk5 + iOffsetToNextRowForDCT;
        U8_WMV * blk7 = blk6 + iOffsetToNextRowForDCT;
        
        PixelI32* pBlk0 = rgblk;
        PixelI32* pBlk1 = pBlk0 + BLOCK_SIZE;
        PixelI32* pBlk2 = pBlk1 + BLOCK_SIZE;
        PixelI32* pBlk3 = pBlk2 + BLOCK_SIZE;
        PixelI32* pBlk4 = pBlk3 + BLOCK_SIZE;
        PixelI32* pBlk5 = pBlk4 + BLOCK_SIZE;
        PixelI32* pBlk6 = pBlk5 + BLOCK_SIZE;
        PixelI32* pBlk7 = pBlk6 + BLOCK_SIZE;
        
        for (i = 0; i < BLOCK_SIZE; i++){
            x0 = (I32_WMV) ((I32_WMV)*pBlk0++ << 8) + 8192L;
            x1 = (I32_WMV) *pBlk4++ << 8;
            x2 = *pBlk6++;
            x3 = *pBlk2++;
            x4 = *pBlk1++;
            x5 = *pBlk7++;
            x6 = *pBlk5++;
            x7 = *pBlk3++;
            
            /* first stage */
            x8 = W7 * (x4 + x5) + 4;
            x4 = (x8 + (W1 - W7) * x4) >> 3;
            x5 = (x8 - (W1 + W7) * x5) >> 3;
            x8 = W3 * (x6 + x7) + 4;
            x6 = (x8 - (W3 - W5) * x6) >> 3;
            x7 = (x8 - (W3 + W5) * x7) >> 3;
            
            /* second stage */
            x8 = x0 + x1;
            x0 -= x1;
            x1 = W6 * (x3 + x2) + 4;
            x2 = (x1 - (W2 + W6) * x2) >> 3;
            x3 = (x1 + (W2 - W6) * x3) >> 3;
            x1 = x4 + x6;
            x4 -= x6;
            x6 = x5 + x7;
            x5 -= x7;
            
            /* third stage */
            x7 = x8 + x3;
            x8 -= x3;
            x3 = x0 + x2;
            x0 -= x2;
            x2 = (181 * (x4 + x5) + 128) >> 8;
            x4 = (181 * (x4 - x5) + 128) >> 8;
            
            /* fourth stage */
            x5 = (x7 + x1) >> 14;
            x1 = (x7 - x1) >> 14;
            iTest = x1 | x5;
            x7 = (x3 + x2) >> 14;
            iTest |= x7;
            x2 = (x3 - x2) >> 14;
            iTest |= x2;
            x3 = (x0 + x4) >> 14;
            iTest |= x3;
            x4 = (x0 - x4) >> 14;
            iTest |= x4;
            x0 = (x8 + x6) >> 14;
            iTest |= x0;
            x6 = (x8 - x6) >> 14;
            iTest |= x6;
            
            if (iTest & ~255L)
            {
                x0 = SATURATE8(x0);
                x1 = SATURATE8(x1);
                x2 = SATURATE8(x2);
                x3 = SATURATE8(x3);
                x4 = SATURATE8(x4);
                x5 = SATURATE8(x5);
                x6 = SATURATE8(x6);
                x7 = SATURATE8(x7);
            }
            
            *blk0++ = (U8_WMV) x5;
            *blk1++ = (U8_WMV) x7;
            *blk2++ = (U8_WMV) x3;
            *blk3++ = (U8_WMV) x0;
            *blk4++ = (U8_WMV) x6;
            *blk5++ = (U8_WMV) x4;
            *blk6++ = (U8_WMV) x2;
            *blk7++ = (U8_WMV) x1;
        }
    }
}

///////////////////////////////////////////////////////////////////////////
//
// Inter IDCT Functions
//
///////////////////////////////////////////////////////////////////////////

// C Version
// Input:  16-bit
// Output: 16-bit
Void_WMV g_IDCTDec16_WMV2 (Buffer __huge* piDst, Buffer __huge* piSrc, I32_WMV iOffsetToNextRowForDCT, I32_WMV iDCTHorzFlags)
{
#   if !defined(_SH4_)
	FUNCTION_PROFILE_DECL_START(fpDecode,IDCT_PROFILE);
#	endif

	I32_WMV x0, x1, x2, x3, x4, x5, x6, x7, x8;
    const PixelI __huge* rgiCoefRecon = piSrc->i16;
	PixelI __huge* blk = piDst->i16;
    register I32_WMV iDCTVertFlag = 0;

    I32_WMV  i;  
    for (i = 0; i < BLOCK_SIZE; i++, blk += iOffsetToNextRowForDCT, rgiCoefRecon += BLOCK_SIZE){
        // Check to see if this row has all zero coefficients in columns 1-7 (0 is first column)
        if (!(iDCTHorzFlags & (1 << i))) 
        {
            // Columns 1-7 must be zero. Check to see if column zero coefficient is zero. 
            // If so, we don't have to do anything more for this row
            if (rgiCoefRecon [0] != 0)
			{
                // Column zero cofficient is nonzero so all coefficients in this row are DC
                blk [0] = blk [1] = blk [2] = blk [3] = blk [4] = blk [5] = blk [6] = blk [7] = rgiCoefRecon [0] << 3;
                // If this is not the first row, tell the second stage that it can't use DC
                // shortcut - it has to do the full transform for all the columns
                iDCTVertFlag = i;
			}
			continue;
		}

        // If this is not the first row, tell the second stage that it can't use DC shortcut 
        // - it has to do the full transform for all the columns
		iDCTVertFlag = i;

		x4 = rgiCoefRecon [1];		
		x3 = rgiCoefRecon [2];
		x7 = rgiCoefRecon [3];
		x1 = (I32_WMV)rgiCoefRecon [4] << 11;
		x6 = rgiCoefRecon [5];
		x2 = rgiCoefRecon [6];		
		x5 = rgiCoefRecon [7];

        x0 = (I32_WMV)((I32_WMV)rgiCoefRecon [0] << 11) + 128L; /* for proper rounding in the fourth stage */

        // first stage
        x8 = W7 * (x4 + x5);
		x4 = x8 + W1_W7 * x4;
		x5 = x8 - W1pW7 * x5;
		x8 = W3 * (x6 + x7);
		x6 = x8 - W3_W5 * x6;
		x7 = x8 - W3pW5 * x7;

		// second stage 
		x8 = x0 + x1;
		x0 -= x1;
		x1 = W6 * (x3 + x2);
		x2 = x1 - W2pW6 * x2;
		x3 = x1 + W2_W6 * x3;
		x1 = x4 + x6;
		x4 -= x6;
		x6 = x5 + x7;
		x5 -= x7;

		/* third stage */
		x7 = x8 + x3;
		x8 -= x3;
		x3 = x0 + x2;
		x0 -= x2;
		x2 = (I32_WMV)(181L * (x4 + x5) + 128L) >> 8;
		x4 = (I32_WMV)(181L * (x4 - x5) + 128L) >> 8;

		/* fourth stage */
		blk [0] = (PixelI) ((x7 + x1) >> 8);
		blk [1] = (PixelI) ((x3 + x2) >> 8);
		blk [2] = (PixelI) ((x0 + x4) >> 8);
		blk [3] = (PixelI) ((x8 + x6) >> 8);
		blk [4] = (PixelI) ((x8 - x6) >> 8);
		blk [5] = (PixelI) ((x0 - x4) >> 8);
		blk [6] = (PixelI) ((x3 - x2) >> 8);
		blk [7] = (PixelI) ((x7 - x1) >> 8);
	}

    {
        
        PixelI __huge *blk0 = piDst->i16;
        
        PixelI __huge *blk1 = blk0 + iOffsetToNextRowForDCT;
        PixelI __huge *blk2 = blk1 + iOffsetToNextRowForDCT;
        PixelI __huge *blk3 = blk2 + iOffsetToNextRowForDCT;
        PixelI __huge *blk4 = blk3 + iOffsetToNextRowForDCT;
        PixelI __huge *blk5 = blk4 + iOffsetToNextRowForDCT;
        PixelI __huge *blk6 = blk5 + iOffsetToNextRowForDCT;
        PixelI __huge *blk7 = blk6 + iOffsetToNextRowForDCT;
        
        for (i = 0; i < BLOCK_SIZE; i++){
            // If iDCTVertFlag is zero then we know that blk[1] thru blk[7] are zero.
            // Therefore, if blk[0] is zero we can skip to the next column. Otherwise we
            // can use the DC shortcut and just copy blk[0] to the rest of the column.
            if (iDCTVertFlag == 0)
            {
                // If blk[0] is nonzero, copy the value to the other 7 rows in this column		
                if (blk0[i] != 0)
                    blk0[i] = blk1[i] = blk2[i] = blk3[i] = blk4[i] = blk5[i] = blk6[i] = blk7[i] = (blk0[i] + 32) >> 6;
                continue;
            }
            
            x0 = (I32_WMV)((I32_WMV)blk0[i] << 8) + 8192L;
            x1 = (I32_WMV)blk4[i] << 8;
            x2 = blk6[i];
            x3 = blk2[i];
            x4 = blk1[i];
            x5 = blk7[i];
            x6 = blk5[i];
            x7 = blk3[i];
            
            // first stage 
            x8 = W7 * (x4 + x5) + 4;
            x4 = (x8 + W1_W7 * x4) >> 3;
            x5 = (x8 - W1pW7 * x5) >> 3;
            x8 = W3 * (x6 + x7) + 4;
            x6 = (x8 - W3_W5 * x6) >> 3;
            x7 = (x8 - W3pW5 * x7) >> 3;
            
            // second stage 
            x8 = x0 + x1;
            x0 -= x1;
            x1 = W6 * (x3 + x2) + 4;
            x2 = (x1 - W2pW6 * x2) >> 3;
            x3 = (x1 + W2_W6 * x3) >> 3;
            x1 = x4 + x6;
            x4 -= x6;
            x6 = x5 + x7;
            x5 -= x7;
            
            /* third stage */
            x7 = x8 + x3;
            x8 -= x3;
            x3 = x0 + x2;
            x0 -= x2;
            x2 = (I32_WMV) (181L * (x4 + x5) + 128L) >> 8;
            x4 = (I32_WMV) (181L * (x4 - x5) + 128L) >> 8;
            
            /* fourth stage */
            blk0[i] = (PixelI) ((x7 + x1) >> 14);
            blk1[i] = (PixelI) ((x3 + x2) >> 14);
            blk2[i] = (PixelI) ((x0 + x4) >> 14);
            blk3[i] = (PixelI) ((x8 + x6) >> 14);
            blk4[i] = (PixelI) ((x8 - x6) >> 14);
            blk5[i] = (PixelI) ((x0 - x4) >> 14);
            blk6[i] = (PixelI) ((x3 - x2) >> 14);
            blk7[i] = (PixelI) ((x7 - x1) >> 14); 
        }
    }
#   if !defined(_SH4_)
    FUNCTION_PROFILE_STOP(&fpDecode);
#	endif

}
#endif //OPT_IDCT_ARM

#ifndef _EMB_WMV2_
#ifdef _USE_C_IDCT_
// C Version
// Input:  32-bit
// Output: 32-bit
Void_WMV g_IDCTDec_WMV2 (Buffer __huge* piDst, Buffer __huge* piSrc, I32_WMV iOffsetToNextRowForDCT, I32_WMV iDCTHorzFlags)
{
#   if !defined(_SH4_)
	FUNCTION_PROFILE_DECL_START(fpDecode,IDCT_PROFILE);
#	endif

	I32_WMV x0, x1, x2, x3, x4, x5, x6, x7, x8;

	const PixelI32 __huge* rgiCoefRecon = piSrc->i32;
	PixelI32 __huge* blk = piDst->i32;


    register I32_WMV iDCTVertFlag = 0;

    I32_WMV  i;  
    for (i = 0; i < BLOCK_SIZE; i++, blk += iOffsetToNextRowForDCT, rgiCoefRecon += BLOCK_SIZE){
        // Check to see if this row has all zero coefficients in columns 1-7 (0 is first column)
        if (!(iDCTHorzFlags & (1 << i))) 
        {
            // Columns 1-7 must be zero. Check to see if column zero coefficient is zero. 
            // If so, we don't have to do anything more for this row
            if (rgiCoefRecon [0] != 0)
			{
                // Column zero cofficient is nonzero so all coefficients in this row are DC
                blk [0] = blk [1] = blk [2] = blk [3] = blk [4] = blk [5] = blk [6] = blk [7] = rgiCoefRecon [0] << 3;
                // If this is not the first row, tell the second stage that it can't use DC
                // shortcut - it has to do the full transform for all the columns
                iDCTVertFlag = i;
			}
			continue;
		}

        // If this is not the first row, tell the second stage that it can't use DC shortcut 
        // - it has to do the full transform for all the columns
		iDCTVertFlag = i;

		x4 = rgiCoefRecon [1];		
		x3 = rgiCoefRecon [2];
		x7 = rgiCoefRecon [3];
		x1 = (I32_WMV)rgiCoefRecon [4] << 11;
		x6 = rgiCoefRecon [5];
		x2 = rgiCoefRecon [6];		
		x5 = rgiCoefRecon [7];

        x0 = (I32_WMV)((I32_WMV)rgiCoefRecon [0] << 11) + 128L; /* for proper rounding in the fourth stage */

        // first stage
        x8 = W7 * (x4 + x5);
		x4 = x8 + W1_W7 * x4;
		x5 = x8 - W1pW7 * x5;
		x8 = W3 * (x6 + x7);
		x6 = x8 - W3_W5 * x6;
		x7 = x8 - W3pW5 * x7;

		// second stage 
		x8 = x0 + x1;
		x0 -= x1;
		x1 = W6 * (x3 + x2);
		x2 = x1 - W2pW6 * x2;
		x3 = x1 + W2_W6 * x3;
		x1 = x4 + x6;
		x4 -= x6;
		x6 = x5 + x7;
		x5 -= x7;

		/* third stage */
		x7 = x8 + x3;
		x8 -= x3;
		x3 = x0 + x2;
		x0 -= x2;
		x2 = (I32_WMV)(181L * (x4 + x5) + 128L) >> 8;
		x4 = (I32_WMV)(181L * (x4 - x5) + 128L) >> 8;

		/* fourth stage */
		blk [0] =  ((x7 + x1) >> 8);
		blk [1] =  ((x3 + x2) >> 8);
		blk [2] =  ((x0 + x4) >> 8);
		blk [3] =  ((x8 + x6) >> 8);
		blk [4] =  ((x8 - x6) >> 8);
		blk [5] =  ((x0 - x4) >> 8);
		blk [6] =  ((x3 - x2) >> 8);
		blk [7] =  ((x7 - x1) >> 8);
	}


    {
        PixelI32 __huge *blk0 = piDst->i32;
        PixelI32 __huge *blk1 = blk0 + iOffsetToNextRowForDCT;
        PixelI32 __huge *blk2 = blk1 + iOffsetToNextRowForDCT;
        PixelI32 __huge *blk3 = blk2 + iOffsetToNextRowForDCT;
        PixelI32 __huge *blk4 = blk3 + iOffsetToNextRowForDCT;
        PixelI32 __huge *blk5 = blk4 + iOffsetToNextRowForDCT;
        PixelI32 __huge *blk6 = blk5 + iOffsetToNextRowForDCT;
        PixelI32 __huge *blk7 = blk6 + iOffsetToNextRowForDCT;
        
        
        
        for (i = 0; i < BLOCK_SIZE; i++){
            // If iDCTVertFlag is zero then we know that blk[1] thru blk[7] are zero.
            // Therefore, if blk[0] is zero we can skip to the next column. Otherwise we
            // can use the DC shortcut and just copy blk[0] to the rest of the column.
            if (iDCTVertFlag == 0)
            {
                // If blk[0] is nonzero, copy the value to the other 7 rows in this column		
                if (blk0[i] != 0)
                {
                    
                    blk0[i] = blk1[i] = blk2[i] = blk3[i] = blk4[i] = blk5[i] = blk6[i] = blk7[i] = (blk0[i] + 32) >> 6;
                }
                
                
                continue;
            }
            
            x0 = (I32_WMV)((I32_WMV)blk0[i] << 8) + 8192L;
            x1 = (I32_WMV)blk4[i] << 8;
            x2 = blk6[i];
            x3 = blk2[i];
            x4 = blk1[i];
            x5 = blk7[i];
            x6 = blk5[i];
            x7 = blk3[i];
            
            // first stage 
            x8 = W7 * (x4 + x5) + 4;
            x4 = (x8 + W1_W7 * x4) >> 3;
            x5 = (x8 - W1pW7 * x5) >> 3;
            x8 = W3 * (x6 + x7) + 4;
            x6 = (x8 - W3_W5 * x6) >> 3;
            x7 = (x8 - W3pW5 * x7) >> 3;
            
            // second stage 
            x8 = x0 + x1;
            x0 -= x1;
            x1 = W6 * (x3 + x2) + 4;
            x2 = (x1 - W2pW6 * x2) >> 3;
            x3 = (x1 + W2_W6 * x3) >> 3;
            x1 = x4 + x6;
            x4 -= x6;
            x6 = x5 + x7;
            x5 -= x7;
            
            /* third stage */
            x7 = x8 + x3;
            x8 -= x3;
            x3 = x0 + x2;
            x0 -= x2;
            x2 = (I32_WMV) (181L * (x4 + x5) + 128L) >> 8;
            x4 = (I32_WMV) (181L * (x4 - x5) + 128L) >> 8;
            
            
            /* fourth stage */
            blk0[i] =  ((x7 + x1) >> 14);
            blk1[i] =  ((x3 + x2) >> 14);
            blk2[i] =  ((x0 + x4) >> 14);
            blk3[i] =  ((x8 + x6) >> 14);
            blk4[i] =  ((x8 - x6) >> 14);
            blk5[i] =  ((x0 - x4) >> 14);
            blk6[i] =  ((x3 - x2) >> 14);
            blk7[i] =  ((x7 - x1) >> 14); 
            
            
            
            
        }
    }
#   if !defined(_SH4_)
    FUNCTION_PROFILE_STOP(&fpDecode);
#	endif

}
#endif
#endif //_EMB_WMV2_



#ifndef _EMB_WMV2_
// C Version
// Input:  32-bit
// Output: 32-bit
Void_WMV g_8x4IDCTDec_WMV2 (Buffer __huge* piDstBuf, I32_WMV iOffsetToNextRowForDCT, const Buffer __huge* rgiCoefReconBuf, I32_WMV iHalf)
{
#   if !defined(_SH4_)
	FUNCTION_PROFILE_DECL_START(fpDecode,IDCT_PROFILE);
#	endif


    const PixelI32 __huge* rgiCoefRecon = rgiCoefReconBuf->i32;
	PixelI32 __huge* piDst = piDstBuf->i32 + (iHalf*32);
	PixelI32 * blk = piDst;

	I32_WMV x0, x1, x2, x3, x4, x5, x6, x7, x8;
	I32_WMV i;

    for (i = 0; i < 4; i++, blk += iOffsetToNextRowForDCT, rgiCoefRecon += BLOCK_SIZE)
    {
        x4 = rgiCoefRecon [1];		
        x3 = rgiCoefRecon [2];
	    x7 = rgiCoefRecon [3];
	    x1 = (I32_WMV)rgiCoefRecon [4] << 11;
	    x6 = rgiCoefRecon [5];
	    x2 = rgiCoefRecon [6];		
	    x5 = rgiCoefRecon [7];

        *blk = rgiCoefRecon [0];

		x0 = (I32_WMV)((I32_WMV)blk [0] << 11) + 128L; /* for proper rounding in the fourth stage */
		/* first stage */
		x8 = W7 * (x4 + x5);
		x4 = x8 + (W1 - W7) * x4;
		x5 = x8 - (W1 + W7) * x5;
		x8 = W3 * (x6 + x7);
		x6 = x8 - (W3 - W5) * x6;
		x7 = x8 - (W3 + W5) * x7;

		/* second stage */
		x8 = x0 + x1;
		x0 -= x1;
		x1 = W6 * (x3 + x2);
		x2 = x1 - (W2 + W6) * x2;
		x3 = x1 + (W2 - W6) * x3;
		x1 = x4 + x6;
		x4 -= x6;
		x6 = x5 + x7;
		x5 -= x7;

		/* third stage */
		x7 = x8 + x3;
		x8 -= x3;
		x3 = x0 + x2;
		x0 -= x2;
		x2 = (I32_WMV)(181L * (x4 + x5) + 128L) >> 8;
		x4 = (I32_WMV)(181L * (x4 - x5) + 128L) >> 8;

		/* fourth stage */
		blk [0] =  ((x7 + x1) >> 8);
		blk [1] =  ((x3 + x2) >> 8);
		blk [2] =  ((x0 + x4) >> 8);
		blk [3] =  ((x8 + x6) >> 8);
		blk [4] =  ((x8 - x6) >> 8);
		blk [5] =  ((x0 - x4) >> 8);
		blk [6] =  ((x3 - x2) >> 8);
		blk [7] =  ((x7 - x1) >> 8);
    }

    
    {
        PixelI32* blk0 = piDst;
        PixelI32* blk1 = blk0 + iOffsetToNextRowForDCT;
        PixelI32* blk2 = blk1 + iOffsetToNextRowForDCT;
        PixelI32* blk3 = blk2 + iOffsetToNextRowForDCT;
        
        
        
        for (i = 0; i < BLOCK_SIZE; i++)
        {
            x4 = blk0[i];
            x5 = blk1[i];
            x6 = blk2[i];
            x7 = blk3[i];
            
            x0 = (x4 + x6)*W2a;
            x1 = (x4 - x6)*W2a;
            x2 = x5*W1a + x7*W3a;
            x3 = x5*W3a - x7*W1a;
            
            
            blk0[i] = (PixelI32)((x0 + x2 + 32768L)>>16);
            blk1[i] = (PixelI32)((x1 + x3 + 32768L)>>16);
            blk2[i] = (PixelI32)((x1 - x3 + 32768L)>>16);
            blk3[i] = (PixelI32)((x0 - x2 + 32768L)>>16);
            
        }
    }
#   if !defined(_SH4_)
    FUNCTION_PROFILE_STOP(&fpDecode);
#	endif

}

// C Version
// Input:  32-bit
// Output: 32-bit
Void_WMV g_4x8IDCTDec_WMV2 (Buffer __huge* piDstBuf, I32_WMV iOffsetToNextRowForDCT, const Buffer __huge* rgiCoefReconBuf, I32_WMV iHalf)
{

#   if !defined(_SH4_)
   FUNCTION_PROFILE_DECL_START(fpDecode,IDCT_PROFILE);
#	endif

    const PixelI32 __huge* rgiCoefRecon = rgiCoefReconBuf->i32;
	PixelI32 __huge* piDst = piDstBuf->i32 + (iHalf*4);
	PixelI32 * blk = piDst;


	I32_WMV x0, x1, x2, x3, x4, x5, x6, x7, x8;
	I32_WMV i;

    for (i = 0; i < BLOCK_SIZE; i++,  rgiCoefRecon += 4){

        x4 = rgiCoefRecon[0];
        x5 = rgiCoefRecon[1];
        x6 = rgiCoefRecon[2];
        x7 = rgiCoefRecon[3];

        x0 = (x4 + x6)*W2a;
        x1 = (x4 - x6)*W2a;
        x2 = x5*W1a + x7*W3a;
        x3 = x5*W3a - x7*W1a;

        blk[0] = (PixelI32)((x0 + x2 + 64)>>7);
        blk[1] = (PixelI32)((x1 + x3 + 64)>>7);
        blk[2] = (PixelI32)((x1 - x3 + 64)>>7);
        blk[3] = (PixelI32)((x0 - x2 + 64)>>7);
        blk += iOffsetToNextRowForDCT;

    }
    
    {
        
        PixelI32* blk0 = piDst;
        PixelI32* blk1 = blk0 + iOffsetToNextRowForDCT;
        PixelI32* blk2 = blk1 + iOffsetToNextRowForDCT;
        PixelI32* blk3 = blk2 + iOffsetToNextRowForDCT;
        PixelI32* blk4 = blk3 + iOffsetToNextRowForDCT;
        PixelI32* blk5 = blk4 + iOffsetToNextRowForDCT;
        PixelI32* blk6 = blk5 + iOffsetToNextRowForDCT;
        PixelI32* blk7 = blk6 + iOffsetToNextRowForDCT;
        
        
        for (i = 0; i < 4; i++)
        {
            
            x0 = (I32_WMV)((I32_WMV)blk0[i] << 8) + 8192L;
            x1 = (I32_WMV)blk4[i] << 8;
            x2 = blk6[i];
            x3 = blk2[i];
            x4 = blk1[i];
            x5 = blk7[i];
            x6 = blk5[i];
            x7 = blk3[i];
            
            
            /* first stage */
            x8 = W7 * (x4 + x5) + 4;
            x4 = (x8 + (W1 - W7) * x4) >> 3;
            x5 = (x8 - (W1 + W7) * x5) >> 3;
            x8 = W3 * (x6 + x7) + 4;
            x6 = (x8 - (W3 - W5) * x6) >> 3;
            x7 = (x8 - (W3 + W5) * x7) >> 3;
            
            /* second stage */
            x8 = x0 + x1;
            x0 -= x1;
            x1 = W6 * (x3 + x2) + 4;
            x2 = (x1 - (W2 + W6) * x2) >> 3;
            x3 = (x1 + (W2 - W6) * x3) >> 3;
            x1 = x4 + x6;
            x4 -= x6;
            x6 = x5 + x7;
            x5 -= x7;
            
            /* third stage */
            x7 = x8 + x3;
            x8 -= x3;
            x3 = x0 + x2;
            x0 -= x2;
            x2 = (I32_WMV) (181L * (x4 + x5) + 128L) >> 8;
            x4 = (I32_WMV) (181L * (x4 - x5) + 128L) >> 8;
            
            /* fourth stage */
            
            blk0[i] = (PixelI32) ((x7 + x1) >> 14);
            blk1[i] = (PixelI32) ((x3 + x2) >> 14);
            blk2[i] = (PixelI32) ((x0 + x4) >> 14);
            blk3[i] = (PixelI32) ((x8 + x6) >> 14);
            blk4[i] = (PixelI32) ((x8 - x6) >> 14);
            blk5[i] = (PixelI32) ((x0 - x4) >> 14);
            blk6[i] = (PixelI32) ((x3 - x2) >> 14);
            blk7[i] = (PixelI32) ((x7 - x1) >> 14);
            
        }
    }

#   if !defined(_SH4_)
				FUNCTION_PROFILE_STOP(&fpDecode);
#	endif

}

// NOTE: These are not currently MMX versions of 8x4IDCT and 4x8IDCT. They are C versions
//  The only difference between these and the non-MMX versions are 
//  that these produce 16-bit output samples instead of 32-bit. This is to be compatible 
//  with the MMX motion comp routines which follow the IDCT. 
#endif //_EMB_WMV2_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\intradec.cpp ===
/*************************************************************************

Copyright (c) 2000  Microsoft Corporation

Module Name:
        Intradec.cpp

Abstract:
        New Intra decoder

Author:
        Sridhar Srinivasan (sridhsri@microsoft.com)
        28 July 2000

*************************************************************************/
#include "bldsetup.h"

#include "xplatform.h"
#include "limits.h"
#include "typedef.hpp"
#include "wmvdec_member.h"
#include "strmdec_wmv.hpp"
#include "idctdec_wmv2.h"
#include "localhuffman_wmv.h"

#include "spatialpredictor_wmv.hpp"
#include "tables_wmv.h"

extern U8_WMV  zigzagArray[];
extern U16_WMV aNullPredWts_WMV[];
static U8_WMV  *zigzagRedirectionArray[3];
static const I32_WMV iFlatOrients = 3;

//  Non-flat quantization : reconstruction levels
I16_WMV gaReconstructionLevels[] = {
    256,
    256, 256, 256, 256, 256, 259, 262, 265, 269, 272, 275, 278,
    282, 285, 288, 292, 295, 299, 303, 306, 310, 314, 317, 321,
    325, 329, 333, 337, 341, 345, 349, 353, 358, 362, 366, 371,
    375, 379, 384, 389, 393, 398, 403, 408, 413, 417, 422, 428,
    433, 438, 443, 448, 454, 459, 465, 470, 476, 482, 488, 493,
    499, 505, 511
};
static const I32_WMV i2to15 = 1 << 15;

extern I32_WMV LhdecDecodeSymbol (t_LocalHuffmanDecoder *pLhdec, CInputBitStream_WMV* pbitstrmIn,
                                  U32_WMV &uRun, I32_WMV &iLevel, I32_WMV &bLast);
extern I32_WMV LhdecDecodeOrient (t_LocalHuffmanDecoder *pLhdec, CInputBitStream_WMV* pbitstrmIn);
extern I32_WMV LhdecDecodeJoint  (t_LocalHuffmanDecoder *pLhdec, CInputBitStream_WMV* pbitstrmIn);
inline I32_WMV x8DequantizeDC(I32_WMV qVal, I32_WMV qLev) { return qLev * qVal;}
extern Void_WMV X8Deblock(U8_WMV *pCenter, I32_WMV iStride, I32_WMV iStepSize,
                          I32_WMV blockX, I32_WMV blockY, Bool_WMV bResidual, I32_WMV iOrient);

/****************************************************************************************
  performLifting (prior to IDCT)
****************************************************************************************/
static Void_WMV PerformLifting16 (PixelI *pDCTCoef, I32_WMV iOrient, I32_WMV dcCoef)
{
    I32_WMV  val;

    if (iOrient == 0) {
        val = (3811 * dcCoef + i2to15) >> 16;
        pDCTCoef[1] -= (PixelI) val;  pDCTCoef[8] -= (PixelI) val;

        val = (487 * dcCoef + i2to15) >> 16;
        pDCTCoef[2] -= (PixelI) val;  pDCTCoef[16] -= (PixelI) val;

        val = (506 * dcCoef + i2to15) >> 16;
        pDCTCoef[3] -= (PixelI) val;  pDCTCoef[24] -= (PixelI) val;

        val = (135 * dcCoef + i2to15) >> 16;
        pDCTCoef[4] -= (PixelI) val;  pDCTCoef[32] -= (PixelI) val;
        pDCTCoef[10] += (PixelI) val;  pDCTCoef[11] += (PixelI) val;
        pDCTCoef[17] += (PixelI) val;  pDCTCoef[25] += (PixelI) val;

        val = (173 * dcCoef + i2to15) >> 16;
        pDCTCoef[5] -= (PixelI) val;  pDCTCoef[40] -= (PixelI) val;

        val = (61 * dcCoef + i2to15) >> 16;
        pDCTCoef[6] -= (PixelI) val;  pDCTCoef[48] -= (PixelI) val;
        pDCTCoef[13] += (PixelI) val; pDCTCoef[41] += (PixelI) val;
    
        val = (42 * dcCoef + i2to15) >> 16;
        pDCTCoef[7] -= (PixelI) val;  pDCTCoef[56] -= (PixelI) val;
        pDCTCoef[12] += (PixelI) val; pDCTCoef[36] += (PixelI) val;
        pDCTCoef[33] += (PixelI) val;

        val = (1084 * dcCoef + i2to15) >> 16;
        pDCTCoef[9] += (PixelI) val;
    }
    else {
        if (t_SpatialPredictor::m_bIsMMX ^ (iOrient == 2)) {
            val = 0;
        }
        else {
            val = 3;
        }
        pDCTCoef[1<<val] -= (6269 * dcCoef + i2to15) >> 16;
        pDCTCoef[3<<val] -= (708 * dcCoef + i2to15) >> 16;
        pDCTCoef[5<<val] -= (172 * dcCoef + i2to15) >> 16;
        pDCTCoef[7<<val] -= (73 * dcCoef + i2to15) >> 16;
    }
}

/****************************************************************************************
  Overall IDCT function (handles both C and MMX cases)
****************************************************************************************/
static I8_WMV aAppearance[] = { -1, 0, -1, -1, 1, 1, 0, 0, 0, 2, 2, 2, 1 };

static Void_WMV IDCT_Dec (Buffer *pBuf, I32_WMV iOrient, I32_WMV iLast)
{
    iOrient = aAppearance[iOrient+1];
    I32_WMV   dcCoef = pBuf->i16[0];

    FUNCTION_PROFILE_DECL_START(fp,DECODEIX8LIFTINGDCT_PROFILE);

    if (dcCoef && iOrient >= 0)
        PerformLifting16 (pBuf->i16, iOrient, dcCoef);

    if (iLast /* AC terms exist */ || (dcCoef && iOrient >= 0) /* did lifting */) {
        // compute IDCT
#ifdef _WMV_TARGET_X86_
            if (t_SpatialPredictor::m_bIsMMX)
                g_IDCTDecMMX_WMV2 (pBuf, pBuf, 8, 0xff);
            else
#endif // _WMV_TARGET_X86_
                g_IDCTDec16_WMV2 (pBuf, pBuf, 8, 0xff);
    }
    else {
        dcCoef = ((dcCoef + 4) >> 3) & 0xffff;
        dcCoef = dcCoef * 0x10001;
        I32_WMV  *pBlock32 = pBuf->i32;
        for (I32_WMV i = 0; i < 32; i++)
            *pBlock32++ = dcCoef;
    }
    FUNCTION_PROFILE_STOP(&fp);
}

/****************************************************************************************
  Decoder specific function for adjusting for flat condition
****************************************************************************************/
static Void_WMV AdjustFlatCondition(I32_WMV iDcValue,
                                    PixelC *pRef, I32_WMV iRefStride, I32_WMV val,
                                    I32_WMV iStep, I32_WMV iInvStep)
{
    iDcValue <<= 3;       // convert to DC coefficient
    // adjust m_aLevel[0], in quantized domain
    val += /* x8QuantizeDC(m_iDcValue, iInvStep); */
        ((iDcValue * iInvStep + 0x8000) >> 16);

    // quantized reconstructed predictor
    val = (x8DequantizeDC(val, iStep) + 4) >> 3;
    // clamp value
    if (val < 0)
        val = 0;
    else if (val > 255)
        val = 255;

    // reset predictor, don't care about residual error
    U32_WMV val4 = val * 0x01010101;

    U32_WMV  *pIRef = (U32_WMV *)pRef;
    for (U32_WMV i = 0; i < 8; i++) {
        U32_WMV  *pIRef = (U32_WMV *)(pRef + i * iRefStride);
        pIRef[0] = pIRef[1] = val4;  // 4 pixels assigned at a time
    } 
}

/************************************************************************************************
  decodeI_X8block : block decoder for X8 blocks
************************************************************************************************/
#define SMALL_CODE_SIZE

static I32_WMV decodeI_X8block (tWMVDecInternalMember *pWMVDec, t_LocalHuffmanDecoder **pLhdec,
                                CInputBitStream_WMV *pBitstrm, PixelI *pReconBuf,
                                I32_WMV iStride, I32_WMV iDCStep,
                                I32_WMV blockX, I32_WMV blockY,
                                PixelC *pRecon, I32_WMV iEstRunMin, I32_WMV iDiffOrient,
                                I32_WMV iOrient, I32_WMV iInvDCStep, Bool_WMV bChroma)
{
    // Set context for DC value, and read it
    I32_WMV iContext;
    
    FUNCTION_PROFILE_DECL_START(fp,DECODEIX8BLOCK_PROFILE);

    iContext = (iEstRunMin == 0) ? LH_INTRAZ : LH_INTRANZ;
    if (bChroma) {
        iContext = LH_INTRAC0;
        blockX >>= 1;
        blockY >>= 1;
    }

    I32_WMV idc0 = LhdecDecodeJoint (pLhdec[iContext], pBitstrm);

    I32_WMV iLast = (idc0 & 1) ^ 1;
    I32_WMV iNumRun = 0;
    idc0 >>= 1;

    Bool_WMV  bResidual;
    I32_WMV   iZCoef;

    if (iLast) {
        bResidual = TRUE;
        // Decode DCT AC terms
        I32_WMV  iModeDefault, iNonflat = pWMVDec->m_iNonflatQuant;
        if (bChroma) {
            iContext = iModeDefault = LH_INTER;
        }
        else {
            if (iDiffOrient > 4) {
                iModeDefault = LH_INTER0;
                iEstRunMin = 0;
            }
            else {
                iModeDefault = LH_INTRAY;
            }
            iContext = LH_INTRAY0;
            if (iDiffOrient < iFlatOrients)
                iNonflat = 0;
        }

        // Get zigzag scan direction
        U8_WMV  *pZigzag = zigzagRedirectionArray[zigzagArray[iOrient]];

        U32_WMV  iRun;
        I32_WMV   iLevel, iLast1 = 0, iCoef = 1;
        I32_WMV   iDequant;
        const I32_WMV iLevelSign = 15;
        const I32_WMV i64Flag = 0x3f;

        I32_WMV  iSmSe = pWMVDec->m_iStepMinusStepIsEven;
        I32_WMV  iDSS = pWMVDec->m_iDoubleStepSize;

        do {
            if (++iNumRun >= iEstRunMin)
                iContext = iModeDefault;

            LhdecDecodeSymbol(pLhdec[iContext], pBitstrm, iRun, iLevel, iLast1);
            iCoef += iRun;

            // find zigzagged coef
            iZCoef = pZigzag [iCoef & i64Flag];
            iLast1 |= (iCoef >> 6); // if iCoef >= 64 - safety check

            // Dequantize DCT AC
            iDequant = iLevel >> iLevelSign;
            iDequant = (iDequant ^ iSmSe) - iDequant;
            pReconBuf[iZCoef] = ((iDSS * iLevel + iDequant)
                    * gaReconstructionLevels[iCoef & iNonflat]) >> 8;
            iCoef++;
        }
        while (iLast1 == 0);
        // handle error if iCoef>=64
        if (iCoef > 64) {
            FUNCTION_PROFILE_STOP(&fp);
            return 1;
        }
    }
    else {  
        // bIsFlat = m_pSp->isFlat() && (abs(idc0) < 2);
        if (pWMVDec->m_pSp->m_bFlat && ((U32_WMV)(idc0 + 1) < 3)) {
            // bIsFlat is true
            // prediction etc. done in adjustFlatCondition function
            AdjustFlatCondition(pWMVDec->m_pSp->m_iDcValue,
                pRecon, iStride, idc0, iDCStep, iInvDCStep);
            bResidual = TRUE;
            goto SkipChecks;
        }
        bResidual = idc0;
    }

    if (bResidual) {
        // Dequantize DC value
        pReconBuf[0] = (PixelI) x8DequantizeDC(idc0, iDCStep);
        I32_WMV iDir = iOrient;
        if (((blockX | blockY) == 0) || ((U32_WMV)(idc0 + 1) < 3))
            iDir = -1;
        // IDCT
        IDCT_Dec (pWMVDec->m_rgiCoefReconBuf, iDir, iLast);
        //m_pSp->IDCT_Dec (pBuffer,
        //    (((blockX | blockY) == 0) || (abs(idc0) < 2)) ? -1 : iOrient, iLast);
        // Spatial prediction: add predicted value and clean buffer
#ifdef SMALL_CODE_SIZE
    }
#endif // SMALL_CODE_SIZE
#ifdef  _WMV_TARGET_X86_
        if (pWMVDec->m_pSp->m_bIsMMX)
            predictDec_MMX (pWMVDec->m_pSp, iOrient, pRecon, iStride, pReconBuf, bResidual);
        else
#endif // _WMV_TARGET_X86_
            predictDec (pWMVDec->m_pSp, iOrient, pRecon, iStride, pReconBuf, bResidual);
#ifndef SMALL_CODE_SIZE
    }
    else {
        // Spatial prediction: add predicted value
        predict_0 (pWMVDec->m_pSp, iOrient, pRecon, iStride);
    }
#endif // !SMALL_CODE_SIZE

SkipChecks:
    // Update orientation and DCvalue/run contexts
    if (!bChroma)
        t_ContextPutDec (pWMVDec->m_pContext, blockX, blockY, iOrient, iNumRun);
    // Deblocking filter
    if (pWMVDec->m_bLoopFilter) {
        X8Deblock (pRecon, iStride, pWMVDec->m_iStepSize, blockX, blockY, bResidual, iOrient);
    }

    FUNCTION_PROFILE_STOP(&fp);
    return 0;
}

/************************************************************************************************
  SetupSpatialPredictor : setup function
************************************************************************************************/
static I32_WMV orderArray[]={0,8,4, 10,11, 2,6,9, 1,3,5,7};
static I32_WMV orderArrayH[]={8,0,4, 10,11, 1,7, 2,6,9, 3,5};
static I32_WMV orderArrayV[]={4,0,8, 11,10, 3,5, 2,6,9, 1,7};
#define EIGHT 8

static Bool_WMV SetupSpatialPredictor(t_SpatialPredictor *pSp, const U8_WMV *pRef, I32_WMV iRefStride,
                               I32_WMV iX, I32_WMV iY, I32_WMV iBlocksInX, I32_WMV &iPredOrient,
                               I32_WMV* &pOrder, I32_WMV iStepSize, Bool_WMV bChroma)
{
    //const U8_WMV meanGrey = 128, *pPtr;
    const U8_WMV *pPtr;
    I32_WMV  i;
    FUNCTION_PROFILE_DECL_START(fp,DECODEIX8SETUP_PROFILE)

    pSp->m_bFlat = FALSE_WMV;
    // initialize zero predictor setup
    pSp->m_bInitZeroPredictor = FALSE_WMV;

    // first initialize the neighbor pixel values
    if (iX == 0 && iY == 0) {
        pSp->m_iRefStride = -1;
        pSp->m_pRef = pSp->m_pLeft + 1;

        // memset(m_pNeighbors, meanGrey, sizeof(U8_WMV)*m_iNeighbors);
        U32_WMV  uMeanGrey = 0x80808080, *pPtr = (U32_WMV *) (pSp->m_pNeighbors + 12);
        for (i = 0; i < 13; i++)  // be sure this space is available
            pPtr[i] = uMeanGrey;
    }
    else if (iX == 0) {
        pSp->m_iRefStride = -1;
        pSp->m_pRef = pSp->m_pLeft + 1;

        pPtr = pRef - iRefStride;
        if (iX < iBlocksInX - 1) {
            U32_WMV  *pSrc = (U32_WMV *) pPtr;
            U32_WMV  *pDst = (U32_WMV *) pSp->m_pTop;
            pDst[0] = pSrc[0];
            pDst[1] = pSrc[1];
            pDst[2] = pSrc[2];
            pDst[3] = pSrc[3];
            pSrc = (U32_WMV *)(pPtr - iRefStride);
            pDst[4] = pSrc[0];
            pDst[5] = pSrc[1];
            // memcpy (m_pTop, pPtr, m_pSide * 2); // copy top row
            // memcpy (m_pTop+m_pSide*2, pPtr-iRefStride, m_pSide*2);
        }
        else {
            const U32_WMV *pSrc0 = (const U32_WMV *) pPtr;
            const U32_WMV *pSrc1 = (const U32_WMV *)(pPtr - iRefStride);
            U32_WMV  *pDst = (U32_WMV *) pSp->m_pTop;
            const U32_WMV  uSet0 = (U32_WMV) pPtr[EIGHT - 1] * 0x01010101;
            const U32_WMV  uSet1 = (U32_WMV) pPtr[EIGHT - 1 - iRefStride] * 0x01010101;

            pDst[0] = pSrc0[0];
            pDst[1] = pSrc0[1];
            pDst[2] = pDst[3] = uSet0;

            pDst[4] = pSrc1[0];
            pDst[5] = pSrc1[1];

            // memcpy (m_pTop, pPtr, m_pSide); // copy top row
            // memcpy (m_pTop+m_pSide*2, pPtr-iRefStride, m_pSide);
            // memset (m_pTop+m_pSide, pPtr[m_pSide-1], m_pSide);
            // memset (m_pTop+m_pSide*3, pPtr[m_pSide-1-iRefStride], m_pSide);            
        }
        I32_WMV sum = 0;
        for (i = 0; i < EIGHT; i++)  sum += pSp->m_pTop[i];
        sum = (sum + (EIGHT >> 1)) / EIGHT;

        U32_WMV  uSet = (U32_WMV) sum * 0x01010101, *pDst = (U32_WMV *) pSp->m_pTop;
        pDst -= 5;
        pDst[0] = pDst[1] = pDst[2] = pDst[3] = pDst[4] = uSet;

        // memset (m_pNeighbors, sum, m_pSide * 2 + 1);
    }
    else if (iY == 0) {
        pSp->m_pRef = pRef;
        pSp->m_iRefStride = iRefStride;

        pPtr = pRef - 1;
        I32_WMV sum = 0;
        for (i = 0; i < 8; i++)  {
            sum += (pSp->m_pLeft[- (i + 1)] = pPtr[i * iRefStride]);
            // m_pLeft[- (i + 1) - 8] = pPtr[i * iRefStride - 1];
        }
        sum = (sum + 4) >> 3;  // m_pSide = 8 assumed
        *pSp->m_pLeft = (PixelC) sum;

        U32_WMV  uSet = (U32_WMV) sum * 0x01010101, *pDst = (U32_WMV *) pSp->m_pTop;
        pDst[0] = pDst[1] = pDst[2] = pDst[3] =
        pDst[4] = pDst[5] = uSet;

        // memset(m_pLeft, sum, m_pSide * 4 + 1);
    }
    else { // all neighbors exist
        pSp->m_pRef = pRef;
        pSp->m_iRefStride = iRefStride;

        pPtr = pRef-iRefStride;
        if (iX < iBlocksInX - 1) {
            const U32_WMV  *pSrc0 = (const U32_WMV *) pPtr;
            U32_WMV  *pDst = (U32_WMV *) pSp->m_pTop;
            const U32_WMV  *pSrc1 = (const U32_WMV *)(pPtr - iRefStride);
            pDst[0] = pSrc0[0];
            pDst[1] = pSrc0[1];
            pDst[2] = pSrc0[2];
            pDst[3] = pSrc0[3];
            pDst[4] = pSrc1[0];
            pDst[5] = pSrc1[1];

            // memcpy (m_pTop, pPtr, m_pSide * 2); // copy top row
            // memcpy (m_pTop + m_pSide * 2, pPtr - iRefStride, m_pSide * 2);
        }
        else {
            const U32_WMV *pSrc0 = (const U32_WMV *) pPtr;
            U32_WMV  *pDst = (U32_WMV *) pSp->m_pTop;
            const U32_WMV *pSrc1 = (const U32_WMV *)(pPtr - iRefStride);

            const U32_WMV uSet0 = (U32_WMV) pPtr[EIGHT - 1] * 0x01010101;
            const U32_WMV uSet1 = (U32_WMV) pPtr[EIGHT - 1 - iRefStride] * 0x01010101;

            pDst[0] = pSrc0[0];
            pDst[1] = pSrc0[1];
            pDst[2] = pDst[3] = uSet0;

            pDst[4] = pSrc1[0];
            pDst[5] = pSrc1[1];

            // memcpy(m_pTop, pPtr, m_pSide); // copy top row
            // memcpy(m_pTop + m_pSide * 2, pPtr - iRefStride, m_pSide);
            // memset(m_pTop + m_pSide, pPtr[m_pSide - 1], m_pSide);
            // memset(m_pTop + m_pSide * 3, pPtr[m_pSide - 1 - iRefStride], m_pSide);            
        }
        pPtr = pRef-1;
        U8_WMV  *pDst0 = pSp->m_pLeft - 4;
        const U8_WMV *pPtrM1 = pPtr + iRefStride * 4;
        U8_WMV  *pDst1 = pDst0 - 4;
        pSp->m_pLeft[0] = pPtr[-iRefStride];

        pDst0[3] = pPtr[0];
        pDst1[3] = pPtrM1[0];
        pPtr += iRefStride;
        pPtrM1 += iRefStride;
        pDst0[2] = pPtr[0];
        pDst1[2] = pPtrM1[0];
        pPtr += iRefStride;
        pPtrM1 += iRefStride;
        pDst0[1] = pPtr[0];
        pDst1[1] = pPtrM1[0];
        pPtr += iRefStride;
        pPtrM1 += iRefStride;
        pDst0[0] = pPtr[0];
        pDst1[0] = pPtrM1[0];
    }

/** so now we have the following data elements:

    m_pLeft[0]   m_pTop[0] m_pTop[1] ... m_pTop[15] m_pTop[16] ... m_pTop[31]
    m_pLeft[-1]     xxx     xxx   ...   xxx
          :                ..
    m_pLeft[-14]                \ ..
    m_pLeft[-15]    xxx     xxx         xxx
**/

/** Find the DC value **/
    I32_WMV iRange;

    {
        I32_WMV iDC = pSp->m_pLeft[0];

#ifdef  _WMV_TARGET_X86_
        if (pSp->m_bIsMMX)
            GetRange (pSp->m_pTop, pSp->m_pLeft - 8, iRange, iDC);
        else
#endif // _WMV_TARGET_X86_
        {
            const U8_WMV *pLeft = pSp->m_pLeft - 8;
            I32_WMV iMin = iRange = pSp->m_pTop[0];
            for (i = 0; i < 8; i++) {
                I32_WMV  iT = pSp->m_pTop[i];
                I32_WMV  iL = pLeft[i];

                iDC += iT + iL;
                if (iT > iRange) iRange = iT;
                else if (iT < iMin) iMin = iT;
                if (iL > iRange) iRange = iL;
                else if (iL < iMin) iMin = iL;
            }
            iRange -= iMin;  // range
        }


        if ((iRange < iStepSize) || (iRange < 3)) {
            // prefer zero orientation when information is small
            iPredOrient = 0;
            if (iRange < 3) {
                pSp->m_bFlat = TRUE_WMV;
                // compute best bin for DC value
                iDC += pSp->m_pTop[EIGHT] + (I32_WMV) pSp->m_pTop[EIGHT + 1] + EIGHT + 1;
                // m_iDcValue /= (m_pSide + m_pSide + 3);
                // need 17 bit precision to divide exactly by 19
                // note 16 bit multiplies are good enough
#ifdef _WMV_TARGET_X86_
                pSp->m_iDcValue = (iDC * 6899) >> 17;
#else // #ifdef _WMV_TARGET_X86_
                // The above is being done in longhand to aVoid_WMV multiply
                I32_WMV  iAcc;
                iAcc = (iDC << 2) - iDC;
                iAcc >>= 4;
                iAcc += (iDC << 4) - iDC;
                iAcc >>= 5;
                iAcc += iDC;
                iAcc >>= 2;
                iAcc += iDC;
                iAcc >>= 1;
                iAcc += iDC;
                iAcc >>= 5;
                pSp->m_iDcValue = iAcc;
#endif // _WMV_TARGET_X86_
            }
        }
    }

    if (bChroma) {
        iPredOrient <<= 2;
        FUNCTION_PROFILE_STOP(&fp)
        return FALSE_WMV;
    }

    // choose order of prediction
    if (iPredOrient == 2) pOrder = orderArrayH;
    else if (iPredOrient == 1)  pOrder = orderArrayV;
    else pOrder = orderArray;

    // remap from 0-1-2 to 0-4-8
    iPredOrient <<= 2;

    // almost flat: if horiz, change to decaying horiz, if vert, change to decaying vert
    iStepSize <<= 1;
    if (iRange < iStepSize) { 
        if (iX && iY) {     // only for non-edge blocks!!
            if (iPredOrient == 4)  iPredOrient = 11;
            else if (iPredOrient == 8)  iPredOrient = 10;
        }
        else
            iPredOrient = 0;
    }
    FUNCTION_PROFILE_STOP(&fp)
    return (iRange < iStepSize) ? FALSE_WMV : TRUE_WMV;
}
#undef EIGHT //8

/************************************************************************************************
  decodeI_X8 : X_I32_WMVRA_8 decoder
************************************************************************************************/
tWMVDecodeStatus WMVideoDecDecodeI_X8 (tWMVDecInternalMember *pWMVDec)
{
    FUNCTION_PROFILE(fpX8[2]);
    FUNCTION_PROFILE_START(&fpX8[1],DECODEIX8_PROFILE);
    FUNCTION_PROFILE_START(&fpX8[0],DECODEIX8INIT_PROFILE)

        // Read nonflat quantization bit
    pWMVDec->m_iNonflatQuant = 0x3f * I32_WMV (BS_getBits ( pWMVDec->m_pbitstrmIn, 1));

    // Set image data poI32_WMVers
    PixelC __huge* ppxliCurrY = pWMVDec->m_ppxliCurrQPlusExpY;
    PixelC __huge* ppxliCurrU = pWMVDec->m_ppxliCurrQPlusExpU;
    PixelC __huge* ppxliCurrV = pWMVDec->m_ppxliCurrQPlusExpV;

    pWMVDec->m_bStepSizeIsEven       = ((pWMVDec->m_iStepSize % 2) == 0);
    pWMVDec->m_iStepMinusStepIsEven  = pWMVDec->m_iStepSize - pWMVDec->m_bStepSizeIsEven;
    pWMVDec->m_iDoubleStepSize       = pWMVDec->m_iStepSize << 1;

    // SET_NEW_FRAME
    t_AltTablesSetNewFrame (pWMVDec->m_pAltTables, pWMVDec->m_iStepSize, 1/*intra*/);

/** X8 I32_WMVra decoding starts here **/
    HUFFMANGET_DBG_HEADER(":WMVideoDecDecodeX8",4);
    pWMVDec->m_iDCStepSize = pWMVDec->m_iDCStepSizeC = pWMVDec->m_iStepSize;
    if (pWMVDec->m_iDCStepSizeC > 4)
        pWMVDec->m_iDCStepSizeC += (pWMVDec->m_iDCStepSizeC + 3) >> 3;

    I32_WMV  iInvDCStep  = (65536 + (pWMVDec->m_iDCStepSize >> 1)) / pWMVDec->m_iDCStepSize;
    I32_WMV  iInvDCStepC = (65536 + (pWMVDec->m_iDCStepSizeC >> 1)) / pWMVDec->m_iDCStepSizeC;

    I32_WMV  blockX, blockY;
    // Set the dequantization offset
    I32_WMV iStep = pWMVDec->m_iStepMinusStepIsEven;

    memset(pWMVDec->m_rgiCoefReconBuf, 0, sizeof(Buffer));  // zero out reconstruction
    if (pWMVDec->m_pSp->m_bIsMMX) {
        zigzagRedirectionArray[0] = pWMVDec->m_pZigzagInvRotated;
        zigzagRedirectionArray[1] = pWMVDec->m_pHorizontalZigzagInvRotated;
        zigzagRedirectionArray[2] = pWMVDec->m_pVerticalZigzagInvRotated;
    } else {
        zigzagRedirectionArray[0] = pWMVDec->m_pZigzagInv;
        zigzagRedirectionArray[1] = pWMVDec->m_pHorizontalZigzagInv;
        zigzagRedirectionArray[2] = pWMVDec->m_pVerticalZigzagInv;
    }
    pWMVDec->m_pSp->m_pClampTable = pWMVDec->m_rgiClapTabDec;

    const I32_WMV i64Flag = 0x3f;
    t_LocalHuffmanDecoder **pLhdec = pWMVDec->m_pAltTables->m_paLH;
    CInputBitStream_WMV *pBitstrm = pWMVDec->m_pbitstrmIn;
    PixelI  *pReconBuf = pWMVDec->m_rgiCoefReconBuf->i16;

    FUNCTION_PROFILE_STOP(&fpX8[0])

    /* Loop */
    for (blockY = 0; blockY < (I32_WMV) pWMVDec->m_uintNumMBY * 2; blockY++) {
        PixelC __huge* ppxliCodedY = ppxliCurrY + blockY * 8 * pWMVDec->m_iWidthPrevY;
        PixelC __huge* ppxliCodedU = ppxliCurrU + (blockY >> 1) * 8 * pWMVDec->m_iWidthPrevUV;
        PixelC __huge* ppxliCodedV = ppxliCurrV + (blockY >> 1) * 8 * pWMVDec->m_iWidthPrevUV;

        for (blockX = 0; blockX < (I32_WMV) pWMVDec->m_uintNumMBX * 2; blockX++) {
            /* Get orientation context/prediction */
            I32_WMV predOrient, *order, iOrient, iDiffOrient, estRunMin;
            t_ContextGetDec (pWMVDec->m_pContext, blockX, blockY, pWMVDec->m_iStepSize, &predOrient, &estRunMin);

            // Figure out whether to get differential orient
            Bool_WMV bSendOrient = SetupSpatialPredictor (pWMVDec->m_pSp, ppxliCodedY, pWMVDec->m_iWidthPrevY, blockX, blockY,
                               pWMVDec->m_uintNumMBX * 2, predOrient, order, pWMVDec->m_iDCStepSize, FALSE);

            // Decode differential orientation
            iDiffOrient = 0;
            iOrient = predOrient;
            if (bSendOrient) {
                iDiffOrient = LhdecDecodeOrient (pLhdec[LH_ORIENT], pBitstrm);
                iOrient = order[iDiffOrient];
            }

            if (decodeI_X8block(pWMVDec, pLhdec, pBitstrm, pReconBuf, pWMVDec->m_iWidthPrevY,
                pWMVDec->m_iDCStepSize, blockX, blockY, ppxliCodedY,
                estRunMin, iDiffOrient, iOrient, iInvDCStep, FALSE))
                goto Error;

            // Move output poI32_WMVer
            ppxliCodedY += 8;

            ////////////
            //  COLOR
            ////////////
            if (blockX & blockY & 1) {
                /* Find the prediction direction, and scan direction */
                I32_WMV iOrient0 = iOrient = t_ContextGetChromaDec (pWMVDec->m_pContext, blockX, blockY);

                SetupSpatialPredictor (pWMVDec->m_pSp, ppxliCodedU, pWMVDec->m_iWidthPrevUV, blockX>>1, blockY>>1,
                    pWMVDec->m_uintNumMBX, iOrient, order, pWMVDec->m_iDCStepSizeC, TRUE);
        
                if (decodeI_X8block(pWMVDec, pLhdec, pBitstrm, pReconBuf, pWMVDec->m_iWidthPrevUV,
                    pWMVDec->m_iDCStepSizeC, blockX, blockY, ppxliCodedU, 0xff, 0,
                    iOrient, iInvDCStepC, TRUE))
                    goto Error;

                SetupSpatialPredictor (pWMVDec->m_pSp, ppxliCodedV, pWMVDec->m_iWidthPrevUV, blockX>>1, blockY>>1,
                    pWMVDec->m_uintNumMBX, iOrient0, order, pWMVDec->m_iDCStepSizeC, TRUE);

                if (decodeI_X8block(pWMVDec, pLhdec, pBitstrm, pReconBuf, pWMVDec->m_iWidthPrevUV,
                    pWMVDec->m_iDCStepSizeC, blockX, blockY, ppxliCodedV, 0xff, 0,
                    iOrient0, iInvDCStepC, TRUE))
                    goto Error;

                // bump up poI32_WMVers
                ppxliCodedU += 8;
                ppxliCodedV += 8;
            }  // end of chroma block
        } // end of loop over blockX
    }  // end of loop over blockY

    // deblocking and color mapping operations
    if (pWMVDec->m_bDeblockOn) {
        pWMVDec->m_iRefreshDisplay_AllMB_Cnt = 0;
        pWMVDec->m_bCopySkipMBToPostBuf = FALSE_WMV;
    }
    else
        pWMVDec->m_bCopySkipMBToPostBuf = TRUE_WMV;

#ifdef  _WMV_TARGET_X86_
    if (pWMVDec->m_pSp->m_bIsMMX) {
        _asm  emms
    }
#endif // _WMV_TARGET_X86_

    if (!pWMVDec->m_bLoopFilter)
        memset (pWMVDec->m_rgchSkipPrevFrame, 0, (size_t) pWMVDec->m_uintNumMB);

    FUNCTION_PROFILE_STOP(&fpX8[1]);
    return WMV_Succeeded;

Error:
#ifdef  _WMV_TARGET_X86_
    if (pWMVDec->m_pSp->m_bIsMMX) {
        _asm  emms
    }
#endif _pWMVDec->m_IX86
    FUNCTION_PROFILE_STOP(&fpX8[1]);
    return WMV_Failed;
}

/****************************************************************************************
  setupZeroPredictor_C_fast : sets up boundary arrays for zero prediction mode
  "un-mmx'd" C version
****************************************************************************************/

static Void_WMV SetupZeroPredictor_C_fast (t_SpatialPredictor *pSp)
{
    // fewer temporaries to save/restor to stack, smaller code size
    // rename variables using Hungrian.
    // Note 46% of the X8 blocks in CE_320_240_06f_WMV2_X8 call this routine
    I16_WMV *pi16Top  = pSp->m_pBuffer16 + 12;
    I16_WMV *pi16Left = pSp->m_pBuffer16;
    I32_WMV j;

    {
        PixelC *ppxlTop = pSp->m_pTop, *ppxlLeft = pSp->m_pLeft-1;
        I16_WMV    *pi16TopT = pi16Top, *pi16LeftT = pi16Left;
        for( j=8; j>0;  j-- ) {
            *pi16TopT++  = I16_WMV( *ppxlTop++ );                   // [0,1,...,7]
            *pi16LeftT++ = I16_WMV( *ppxlLeft-- );
        }
        for( j=4; j>0; j-- ) {
            *pi16TopT++  = I16_WMV( *ppxlTop++ );                   // [8,9,10,11]
            *pi16LeftT++ = 0;
        }
    }

    I32_WMV pi32aS1[10], pi32aS3[10];   // space for two at a time - aligned 32
    pi32aS1[0] = pi32aS1[1] = 0;
    I32_WMV *pi32Top  = (I32_WMV*)pi16Top;
    I32_WMV *pi32Left = (I32_WMV*)pi16Left;
    I32_WMV *pi32S1 = pi32aS1 + 2;   
    I32_WMV *pi32S3 = pi32aS3 + 9;
    I32_WMV iTopAcc, iLeftAcc;

    *pi32S1++ = iLeftAcc = ((*pi32Left++) << 4);                // 1[2] = f( L[0] )
    *pi32S1++ = iTopAcc  = ((*pi32Top++)  << 4);                // 1[3] = f( T[0] )

    for( j=3; j>0; j-- ) {
        iLeftAcc >>= 1;
        iTopAcc  >>= 1;
        *pi32S1++ = iLeftAcc += ((*pi32Left++) << 4);           // 1[4,6,8] = f( LeftAcc, L[1,2,3] )
        *pi32S1++ = iTopAcc  += ((*pi32Top++)  << 4);           // 1[5,7,9] = f( TopAcc,  T[1,2,3] )
    }

    *pi32S3-- = (pi32Top[0] << 4) + (pi32Top[1] << 3);          // 3[9] = f( T[4], T[5] )
    *pi32S3-- = 0;                                              // 3[8] = 0
     pi32Top--;
    *pi32S3-- = (iTopAcc = pi32Top[0] << 4) + (pi32Top[1] << 3);// 3[7] = f( T[3], T[4] )
    *pi32S3-- = iLeftAcc = ((*--pi32Left) << 4);                // 3[6] = f( L[3] )

    for( j=3; j>0; j-- ) {
        iLeftAcc >>= 1;
        iTopAcc  >>= 1;
        *pi32S3-- = iTopAcc  += ((*--pi32Top)  << 4);           // 3[5,3,1] = f( TopAcc,  T[2,1,0] )
        *pi32S3-- = iLeftAcc += ((*--pi32Left) << 4);           // 3[4,2,0] = f( LeftAcc, L[2,1,0] )
    }

    I16_WMV *pi16S1 = (I16_WMV*)(pi32aS1);                              // S1[0]
    I16_WMV *pi16S3 = (I16_WMV*)(pi32aS3);                              // S3[0]
    U16_WMV *pu16TSum = pSp->m_pTopSum - 1;
    U16_WMV *pu16LSum = pSp->m_pLeftSum - 1;

    for( j=10; j>0; j-- ) {
        U16_WMV **ppu16XSum = (j&1) ? &pu16TSum : &pu16LSum;
        I16_WMV i16S1_0 = (I32_WMV)(*pi16S1++);
        I16_WMV i16S1_1 = (I32_WMV)(*pi16S1++);
        I16_WMV i16S3_0 = (I32_WMV)(*pi16S3++);
        I16_WMV i16S3_1 = (I32_WMV)(*pi16S3++);

        *(*ppu16XSum)++ = i16S1_1 + (i16S3_1 >> 1) + (((i16S1_0 + i16S3_0) * 181 + 128) >> 8);
        *(*ppu16XSum)++ = i16S3_0 + (i16S1_0 >> 1) + (((i16S1_1 + i16S3_1) * 181 + 128) >> 8);
    }
}

/****************************************************************************************
  Spatial prediction function
  The predictors are (being) optimized.  For more readable code, refer to
  spatialpredictor.cpp v5, in Scrunch\wmv2.
****************************************************************************************/
// for case 9
static const I8_WMV gaPredCase9Index[16] = { -2, -3, -4, -5, -6, -7, -8, -8,
        -8, -8, -8, -8, -8, -8, -8, -8};
// for case 1 
static const I8_WMV gaPredCase1Index[24] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 
        9, 10, 11, 12, 13, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15};

Void_WMV predictDec(t_SpatialPredictor *pSp, const I32_WMV iOrient,
                    PixelC *pRef, const I32_WMV iRefStride, PixelI *pDelta, Bool_WMV bClear)
{
    I32_WMV  i, j, k, iStridem8, tmp, iPred;
    const PixelC  *pVal;
    PixelI  *pDeltaOrig = pDelta;
    FUNCTION_PROFILE_DECL_START(fp,DECODEIX8PRED_PROFILE);

    iStridem8 = iRefStride-8;

    if (pSp->m_bFlat) {      // 2% of the time take this case on CE_320_240_06f_WMV2_300kX8
        // FUNCTION_PROFILE_COUNT(DECODEIX8PREDDEC_FLAT_COUNT);
        const I32_WMV iDcValue = pSp->m_iDcValue;    // hI32_WMV compiler
        for( i=8; i>0; i-- ) {
            for( j=8; j>0; j-- ) {
                *pRef++ = pSp->m_pClampTable[iDcValue + *pDelta++]; 
            }
            pRef += iStridem8; 
        }
        if (bClear)
            goto Clear;
        else {
            FUNCTION_PROFILE_STOP(&fp);
            return;
        }
    }

    // FUNCTION_PROFILE_COUNT(DECODEIX8PREDDEC_CASE0_COUNT+iOrient);
    switch(iOrient) {
    case 0:         // 41% of the time take this case on CE_320_240_06f_WMV2_300kX8
        SetupZeroPredictor_C_fast (pSp);
        {
            U16_WMV *pWts = aNullPredWts_WMV;
            U16_WMV *pLeftSum = pSp->m_pLeftSum;
            for( i=8; i>0; i-- ) {
                U16_WMV u16LSum = *pLeftSum++;
                U16_WMV* pu16TSum = pSp->m_pTopSum;
                for( j=8; j>0; j--) {
                    // sophisticated smoothing prediction
                    iPred = (*pu16TSum++ * pWts[0] + u16LSum * pWts[1] + 0x8000) >> 16;
                    *pRef++ = pSp->m_pClampTable[iPred + *pDelta++]; 
                    pWts += 2;
                }
                pRef += iStridem8;
            }
        }
        break;
    case 8:         // 16% of the time take this case on CE_320_240_06f_WMV2_300kX8
        {
            PixelC *pLeft = pSp->m_pLeft-1;
            pVal = pSp->m_pRef - 2;
            for( i=8; i>0; i-- ) {
                iPred = (*pLeft-- + pVal[0] + 1) >> 1;
                for( j=8; j>0; j-- ) {
                    *pRef++ = pSp->m_pClampTable[iPred + *pDelta++];
                }
                pVal += pSp->m_iRefStride;
                pRef += iStridem8;
            }
        }
        break;
    case 4:         //  9% of the time take this case on CE_320_240_06f_WMV2_300kX8
        {
            PixelC tmp8[8], *ptmp8 = tmp8, *pTopj = pSp->m_pTop, *pTopj16 = pSp->m_pTop+16;
            for (j=8; j>0; j--)
                *ptmp8++ = (*pTopj++ + *pTopj16++ + 1) >> 1;
            for( i=8; i>0; i-- ) {
                pVal = tmp8;
                for( j=8; j>0; j-- ) {
                    *pRef++ = pSp->m_pClampTable[*pVal++ + *pDelta++]; 
                }
                pRef += iStridem8;
            }
        }
        break;
    case 10:         //  9% of the time take this case on CE_320_240_06f_WMV2_300kX8
        {   // decaying horizontal continuity
            I32_WMV  tmp8[8], *ptmp8 = tmp8;
            PixelC *pLeft = pSp->m_pLeft - 1, *pTopj = pSp->m_pTop;
            for (j = 0; j < 8; j++) {
                *ptmp8++ = (*pTopj++) * j + 4;
            }
            for( i=8; i>0; i-- ) {
                I32_WMV *pTmp8 = tmp8;
                I32_WMV iLeft = *pLeft--;
                I32_WMV iAcc = iLeft << 3;
                for( j=8; j>0; j-- ) {
                    iPred = (iAcc + *pTmp8++) >> 3;
                    iAcc -= iLeft;
                    *pRef++ = pSp->m_pClampTable[iPred + *pDelta++];
                }
                pRef += iStridem8;
            }
        }
        break;
    case 11:          //  9% of the time take this case on CE_320_240_06f_WMV2_300kX8
        {   // decaying vertical continuity
            PixelC  *pLeft = pSp->m_pLeft - 1, *pTop = pSp->m_pTop;
            I32_WMV pTmp[8], *pTmp8 = pTmp;
            for (j=8; j>0; j--) {
                *pTmp8++ = (*pTop++) << 3;
            }
            for (i = 0; i < 8; i++ ) {
                I32_WMV     *pTmp8 = pTmp;
                PixelC  *pTop  = pSp->m_pTop;
                tmp = (*pLeft--) * i + 4;
                for( j=8; j>0; j-- ) {
                    iPred     = (*pTmp8  + tmp) >> 3; 
                    *pTmp8++ -= *pTop++;
                    *pRef++   = pSp->m_pClampTable[iPred + *pDelta++]; 
                }                
                pRef += iStridem8;
            }
        }
        break;
    case 1:
        {
            const I8_WMV *piPredCase1Index = gaPredCase1Index + 2;
            for( i=8; i>0; i-- ) {
                for( j=8; j>0; j-- ) {
                    *pRef++ = pSp->m_pClampTable[pSp->m_pTop[*piPredCase1Index++] + *pDelta++];
                }
                pRef += iStridem8;
                piPredCase1Index -= 6;
            }
        }
        break;
    case 2:   
        for (i = 0; i < 8; i++) {
            pVal = pSp->m_pTop + i + 1;
            for( j=8; j>0; j-- ) {
                *pRef++ = pSp->m_pClampTable[*pVal++ + *pDelta++]; 
            }
            pRef += iStridem8;
        }
        break;
    case 3:
        for (i=0; i<8; i++) {
            pVal = pSp->m_pTop + ((i + 1) >> 1);
            for( j=8; j>0; j-- ) {
                *pRef++ = pSp->m_pClampTable[*pVal++ + *pDelta++]; 
            }
            pRef += iStridem8;
        }
        break;
    case 5:
         for( i=0; i<8; i++ ) {
            k = 1-i;
            for( j=8; k<=0; j--, k+=2 ) {
                *pRef++ = pSp->m_pClampTable[pSp->m_pLeft[k] + *pDelta++]; 
            }
            PixelC *pTop = pSp->m_pTop;
            for( ; j>0; j-- ) {
                *pRef++ = pSp->m_pClampTable[*pTop++    + *pDelta++]; 
            }
            pRef += iStridem8;
        }
        break;
    case 7:
        PixelC  *pLeft, *pTop;
        for (i = 0; i < 4; i++) {
            // TODO - Add an OPT_TINY_CODE_SIZE Option
            pLeft = pSp->m_pLeft - i;
            for( j = i; j>0; j-- ) {                                // i==1             i==2 
                *pRef++ = pSp->m_pClampTable[*pLeft   + *pDelta++];      // R[0] = f(L[-i]); R[0,2] = f(L[-i,-i+1])
                *pRef++ = pSp->m_pClampTable[*pLeft++ + *pDelta++];      // R[1] = f(L[-i]); R[1,3] = f(L[-i,-i+1])
            }
            *pRef++ = pSp->m_pClampTable[pSp->m_pLeft[0] + *pDelta++];        // R[2*i] = f(L[0])
            pTop = pSp->m_pTop - 1;
            I32_WMV iPrior = *pTop++, iThis;
            for( j = 8-1-(i<<1); j>0; j--, iPrior = iThis ) {
                iPred = (iPrior + (iThis = *pTop++) + 1)>>1;
                *pRef++ = pSp->m_pClampTable[iPred + *pDelta++];         // R[2*i+1,...] = f(T[-1],T[0]),f(T[0],T[1]),...
            }
            pRef += iStridem8;
        }
        for ( ; i < 8; i++) {
            pLeft = pSp->m_pLeft - i;
            for( j=4; j>0; j-- ) {
                *pRef++ = pSp->m_pClampTable[*pLeft   + *pDelta++];
                *pRef++ = pSp->m_pClampTable[*pLeft++ + *pDelta++];
            }
            pRef += iStridem8;
        }
        break;
    case 6:
        for (i=0; i<8; i++) {
            pVal = pSp->m_pTop - i - 1;
            for( j=8; j>0; j-- ) {
                *pRef++ = pSp->m_pClampTable[*pVal++ + *pDelta++]; 
            }
            pRef += iStridem8;
        }
        break;
    case 9:
        for (i = 0; i < 8; i++) {
            const I8_WMV *piPredCase9Index = gaPredCase9Index + i;
            for( j=8; j>0; j-- ) {
                *pRef++ = pSp->m_pClampTable[pSp->m_pLeft[*piPredCase9Index++] + *pDelta++]; 
            }
            pRef += iStridem8;
        }
        break;
    }
    if (!bClear) {
        FUNCTION_PROFILE_STOP(&fp);
        return;
    }

Clear:
    ALIGNED32_MEMCLR_128U8( pDeltaOrig );
    FUNCTION_PROFILE_STOP(&fp);
    return;
}

/****************************************************************************************
  Spatial prediction function for decoder : no residual
****************************************************************************************/
#ifndef SMALL_CODE_SIZE
Void_WMV predict_0(t_SpatialPredictor *pSp, const I32_WMV iOrient,
                   PixelC *pRef, const I32_WMV iRefStride)
{
    I32_WMV  i, j, k, tmp;
    const PixelC  *pVal;
    const I32_WMV iRefStridem8 = iRefStride - 8;
#   ifdef OPT_TINY_CODE_SIZE
        I32_WMV iPred;
#   endif
    FUNCTION_PROFILE_DECL_START(fp,DECODEIX8PRED0_PROFILE);

    if (pSp->m_bFlat) {
        const U32_WMV u32Val = ALIGNED32_REPLICATE_4U8(pSp->m_iDcValue);
        // FUNCTION_PROFILE_COUNT(DECODEIX8PRED0_FLAT_COUNT);
        for( i=8; i>0; i-- ) {
            ALIGNED32_MEMSET_2U32( pRef, u32Val );
            pRef += iRefStride;
        }
        FUNCTION_PROFILE_STOP(&fp);
        return;
    }

    // FUNCTION_PROFILE_COUNT(DECODEIX8PRED0_CASE0_COUNT+iOrient);
    switch(iOrient) {
    case 0:          //  5% of the time take this case on CE_320_240_06f_WMV2_300kX8
        {
#ifdef _WMV_TARGET_X86_
            if (pSp->m_bIsMMX) {
                SetupZeroPredictor_MMX (pSp);
                predict_0_MMX (pSp->m_pTopSum, pSp->m_pLeftSum, aNullPredWts_WMV, pRef, iRefStride);
            }
            else
#endif // _WMV_TARGET_X86_
            {
                U16_WMV  iLSum, *pTSum;
                U16_WMV  *pWts = aNullPredWts_WMV;

                SetupZeroPredictor_C_fast (pSp);
                for (i=0; i<8; i++) {
                    iLSum = pSp->m_pLeftSum[i];
                    pTSum = pSp->m_pTopSum;
                    for (j=8; j>0; j--, pWts += 2) {
                        // sophisticated smoothing prediction
                        *pRef++ = (PixelC)(((*pTSum++) * pWts[0] + iLSum * pWts[1] + (1<<15)) >> 16);
                    }
                    pRef += iRefStridem8;
                }
                FUNCTION_PROFILE_STOP(&fp);
                return;
            }
        }
        FUNCTION_PROFILE_STOP(&fp);
        return;
    case 8:
        {
            pVal = pSp->m_pRef - 2;
            PixelC  *pLeft = pSp->m_pLeft - 1;
            for (i=0; i<8; i++) {
                tmp = (*pLeft-- + pVal[0] + 1) >> 1;
                ALIGNED32_MEMSET_8U8( pRef, tmp );
                pRef += iRefStride;
                pVal += pSp->m_iRefStride;
            }
        }
        FUNCTION_PROFILE_STOP(&fp);
        return;
    case 4:
        {
            U32_WMV    tmpU32[2];
            PixelC *tmp8 = (PixelC *) tmpU32;
            for (j=0; j<8; j++)
                tmp8[j] = (pSp->m_pTop[j] + pSp->m_pTop[j + 8 + 8] + 1) >> 1;
            for( j=8; j>0; j-- ) {
                ALIGNED32_MEMCPY8( pRef, tmp8 );
                pRef += iRefStride;
            }
        }
        FUNCTION_PROFILE_STOP(&fp);
        return;
    case 10: // decaying horizontal continuity
        {
            I32_WMV  tmp8[8];
            for (j = 0; j < 8; j++)
                tmp8[j] = pSp->m_pTop[j] * j + 4;
            for (i=0; i<8; i++) {
                tmp = pSp->m_pLeft[- 1 - i];
                I32_WMV iAcc = tmp << 3;
                I32_WMV *pTmp = tmp8;
                for ( j=8; j>0; j-- ) {
                    *pRef++ = (iAcc + (*pTmp++)) >> 3;
                    iAcc -= tmp;
                }
                pRef += iRefStridem8;
            }
        }
        FUNCTION_PROFILE_STOP(&fp);
        return;
    case 11: // decaying vertical continuity
        {
            PixelC  *pLeft = pSp->m_pLeft - 1;
            for (i = 0, k = 8; i < 8; i++, k--) {
                tmp = (*pLeft--) * i + 4;
                PixelC  *pTop = pSp->m_pTop;
                for( j=8; j>0; j-- ) {
                    *pRef++ = ((*pTop++) * k + tmp) >> 3;
                }
                pRef += iRefStridem8;
            }
        }
        FUNCTION_PROFILE_STOP(&fp);
        return;
    case 1:
#       ifdef OPT_TINY_CODE_SIZE
            for (i=0; i<8; i++) {
                k = i + i + 2;
                for (j=0; j<8; j++, k++) {
                    *pRef++ = pSp->m_pTop[(k > 15) ? 15:k];
                }
                pRef += iRefStridem8;
            }
#       else   // OPT_TINY_CODE_SIZE
            for (i=0; i<8; i++) {
                k = i + i + 2;
                PixelC *pTop = pSp->m_pTop + (k>15?15:k);
                k = k<8 ? 0 : (k-7);
                for( j=8; j>k; j--) {
                    *pRef++ = *pTop++;
                }
                const PixelC cT = *pTop;
                for(    ; j>0; j-- ) {
                    *pRef++ = cT;
                }
                pRef += iRefStridem8;
            }
#       endif
        FUNCTION_PROFILE_STOP(&fp);
        return;
    case 2:
        for (i=0; i<8; i++) {
            pVal = pSp->m_pTop + i + 1;
#ifdef _WMV_TARGET_X86_  // unaligned access
                U32_WMV  *pSrc = (U32_WMV *)pVal;
                U32_WMV  *pDst = (U32_WMV *)(pRef + i * iRefStride);
                *pDst++ = *pSrc++;
                *pDst   = *pSrc;
#else
                for ( j=8; j>0; j-- ) {
                    *pRef++ = *pVal++;
                }
                pRef += iRefStridem8;
#endif // _WMV_TARGET_X86_
        }
        FUNCTION_PROFILE_STOP(&fp);
        return;
    case 3:
        for (i=0; i<8; i++) {
            pVal = pSp->m_pTop + ((i + 1) >> 1);
            for (j=0; j<8; j++) {
                *pRef++ = *pVal++;
            }
            pRef += iRefStridem8;
        }
        FUNCTION_PROFILE_STOP(&fp);
        return;
    case 5:
#ifdef OPT_TINY_CODE_SIZE
            for (i=0; i<8; i++) {
                for (j=0; j<8; j++) {
                    k = j-((i+1)>>1);
                    if (k>=0) iPred = pSp->m_pTop[k];
                    else iPred = pSp->m_pLeft[j+j-i+1];
                    *pRef++ = iPred;
                }
                pRef += iRefStridem8;
            }
#       else    // OPT_TINY_CODE_SIZE
            for (i=0; i<8; i++) {
                PixelC *pLT = pSp->m_pLeft-i+1;
                k = 8-((i+1)>>1);                // k=8-[0,-1,-1,-2,-2,-3,-3,-4]
                for (j=8; j>k; j--) {
                    *pRef++ = *pLT;  pLT += 2;
                }
                pLT = pSp->m_pTop;
                for (    ; j>0; j-- ) {
                    *pRef++ = *pLT++;
                }
                pRef += iRefStridem8;
            }
#       endif   // OPT_TINY_CODE_SIZE
        FUNCTION_PROFILE_STOP(&fp);
        return;
    case 6:
        for (i=0; i<8; i++) {
            pVal = pSp->m_pTop - i - 1;
#           ifdef _WMV_TARGET_X86_  // unaligned access
                U32_WMV  *pSrc = (U32_WMV *)pVal;
                U32_WMV  *pDst = (U32_WMV *)pRef;
                *pDst++ = *pSrc++;
                *pDst   = *pSrc;
                pRef += iRefStride;
#           else
                for ( j=8; j>0; j-- ) {
                    *pRef++ = *pVal++;
                }
                pRef += iRefStridem8;
#           endif // _WMV_TARGET_X86_
        }
        FUNCTION_PROFILE_STOP(&fp);
        return;
    case 7:
#       ifdef OPT_TINY_CODE_SIZE
            for (i=0; i<8; i++) {
                for (j=0; j<8; j++) {
                    k = j-i-i-2;
                    if (k>=-1) iPred = (pSp->m_pTop[k]+pSp->m_pTop[k+1]+1)>>1;
                    else iPred = pSp->m_pLeft[(j >> 1) - i];
                    *pRef++ = iPred;
                }
                pRef += iRefStridem8;
            }
#       else   // OPT_TINY_CODE_SIZE
            for (i=0; i<8; i++) {
                PixelC *pLeft = pSp->m_pLeft - i;
                k = i<4 ? 8-(i<<1) : 0;                 // k = 10+[ -2, -4, -6, -8, -10, -12, -14, -16]
                for( j=8; j>k; j-=2 ) {
                    *pRef++ = *pLeft;                               // j==even, k==-even
                    *pRef++ = *pLeft++;                             // j==odd,  k==-odd.
                }
                if ( j>0 ) {
                    *pRef++ = *pLeft;                               // k==-2
                    j--;
                    PixelC *pTop = pSp->m_pTop - 1;                      // k==-1
                    I32_WMV iTk0 = *pTop++, iTk1;
                    for (    ; j>0; j--, iTk0 = iTk1) {
                        *pRef++ = ( iTk0 + (iTk1=*pTop++) + 1 )>>1;
                    }
                }
                pRef += iRefStridem8;
            }
#       endif  //OPT_TINY_CODE_SIZE
        FUNCTION_PROFILE_STOP(&fp);
        return;
    case 9:
#       ifdef OPT_TINY_CODE_SIZE
            for (i = 0; i < 8; i++) {
                k = - i - 2;
                for (j=0; j<8; j++, k--) {
                    *pRef++ = pSp->m_pLeft[(k > -8) ? k : -8];
                }
                pRef += iRefStridem8;
            }
#       else   // OPT_TINY_CODE_SIZE
            for (i = 0; i < 8; i++) {
                PixelC *pLeft = pSp->m_pLeft -2 -i;
                k = 1 + i;  
                for ( j=8; j>k; j--) {
                    *pRef++ = *pLeft--;
                }
                const PixelC pxlL8 = pSp->m_pLeft[-8];
                for (   ; j>0; j-- ) {
                    *pRef++ = pxlL8;
                }
                pRef += iRefStridem8;
            }
#       endif  // OPT_TINY_CODE_SIZE
        FUNCTION_PROFILE_STOP(&fp);
        return;
    }
    FUNCTION_PROFILE_STOP(&fp);
}
#endif // SMALL_CODE_SIZE
#pragma warning(default: 4799)  // reset emms warning disable

/****************************************************************************************
  End of decoder specific functions
*****************************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\localhuffman_wmv.cpp ===
/*************************************************************************

Copyright (c) 1996 -- 2000  Microsoft Corporation

Module Name:

	localHuffman.cpp

Abstract:

	Local Huffman code generator.

Revision History:

    Sridhar Srinivasan: 3/16/00

*************************************************************************/
#include "bldsetup.h"

#include "xplatform.h"
#include "typedef.hpp"
#include "wmvdec_api.h"
#include "localhuffman_wmv.h"
#include "wmvdec_function.h"

// fineTbl counts bit for "last"
static const U8_WMV fineTbl[] = {
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,
    0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,
    /* L0 */ 3,3, 2,3, 5,4,  2,2,2,3,3,  2,3,
    /* L1 */ 2,2,2,2,4,4, 2,3,4,  2,3,4,  2,3,
    /* Q0 */ 5, 5, 11, 14
};

static const U8_WMV fineTblJoint[] = {0,1,1,1,1, 2,2, 3,3, 4,4, 5,5, 6,6, 7,7,
                     0,1,1,1,1, 2,2, 3,3, 4,4, 5,5, 6,6, 7,7};

static const I32_WMV iLaplacianAlphabet = 17;
static const U8_WMV aNulls[]={0,0,0,0,0,0,0,0,0,0,0,0};
static const U8_WMV gacCodeLengthsJoint[]={
                3,3,4,5,6,6,7,8,8,9,10,12,13,13,13,13,13,
                2,2,4,5,8,8,9,10,13,13,13,13,13,13,13,13,13};

/**********************************************************************
 generateHuffman_balanced : generates optimum huffman code lengths
 for balanced codeword lengths
 Maximum codeword length allowed = 20
**********************************************************************/

static Void_WMV generateHuffman_balanced(tPackHuffmanCode_WMV *pCodeTable, I32_WMV iN)
{
    pCodeTable->code = iN;
    pCodeTable++;

    const I32_WMV iMaxLength = 20;
    I32_WMV  iLowest = 0;
    I32_WMV  pNextCode[iMaxLength];
    // set all next codes to 0
    memset (pNextCode, 0, sizeof(pNextCode));
    pNextCode[0] = 1 << iMaxLength;
 
    for (I32_WMV i = 0; i < iN; i++) {

        // first set output codeword
        I32_WMV  iLen, iCode, iNewCode;
        iLen = pCodeTable->length;
        iCode = pNextCode[iLen];
        // actual codeword is shifted appropriately
        pCodeTable->code = iCode >> (iMaxLength - iLen);
        pCodeTable++;

        // test last bit : if 1, set to next shorter code
        I32_WMV  iLSB = 1 << (iMaxLength - iLen);
        if (iCode & iLSB)
            iNewCode = pNextCode[iLen - 1];
        else
            iNewCode = iCode + iLSB;

        pNextCode[iLen] = iNewCode;
        if (iNewCode == (1 << iMaxLength))
            iLowest = iLen;

        // for all shorter codewords, check if same - add
        for (I32_WMV j = iLen - 1; j > iLowest; j--) {
            if (pNextCode[j] != iCode)
                break;

            iLSB <<= 1;
            if (pNextCode[j] & iLSB)
                pNextCode[j] = pNextCode[j - 1];
            else
                pNextCode[j] += iLSB;

            if (pNextCode[j] == (1 << iMaxLength))
                iLowest = j;
        }

        // for all longer codewords, check if same - add
        for (j = iLen + 1; j < iMaxLength; j++) {
            if (pNextCode[j] != iCode)
                break;
            pNextCode[j] = iNewCode;
        }
    }
}

U8_WMV zigzagArray[]={0,2,0,1, 1,1,0,2, 2,0, 1,2};

/**********************************************************************************
  Code length arrays : packed arrays
  Author:   Sridhar Srinivasan
  Updated:  4/20/2001
**********************************************************************************/
static U8_WMV gacCodeLengthsOrientLowRate[] = {
1,
0x11,0x22,0x52,0x54,0x55,0x55,
0x10,0x42,0x64,0x65,0x66,0x66,
};

static U8_WMV gacCodeLengthsOrientHighRate[] = {
2,
0x20,0x32,0x53,0x54,0x55,0x55,
0x44,0x14,0x31,0x24,0x33,0x44,
0x11,0x22,0x52,0x45,0x55,0x55,
0x32,0x13,0x41,0x34,0x44,0x44,
};

static U8_WMV gacCodeLengthsInterLowRate[] = {
3,
0x32,0x55,0x56,0x7e,0x8e,0x8e,0xee,0xde,0x54,0x88,0x66,0x18,0x32,0x43,0x75,0x56,0x76,0x6d,0x66,0x48,0x85,0x87,0xd8,0xdd,0xd7,0xdd,0xdd,0xdd,0xdd,0x8d,0xdd,0xdd,0xdd,0xd8,0xd8,0xdd,0x8d,0xdd,0x2d,
0x32,0x43,0x55,0x55,0x76,0x77,0xd7,0x99,0x43,0x65,0x54,0x34,0x44,0x55,0x55,0x65,0x77,0x66,0x66,0x67,0x76,0x77,0x9d,0xd8,0x84,0xdd,0x74,0xdd,0x5d,0x67,0x87,0xd7,0x7d,0xd8,0xdd,0x8d,0x4d,0x87,0x3d,
0x43,0xbb,0xbb,0xbb,0xbb,0xbb,0xaa,0xaa,0xaa,0xaa,0xaa,0xa,0x41,0x44,0xaa,0xaa,0xaa,0xaa,0xaa,0x4a,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0x7a,
0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x7,0x67,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x86,
0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x17,0x70,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x97,
0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x88,0x8,0x82,0x18,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x18,
0x31,0x44,0x55,0x76,0x77,0x88,0x89,0xe9,0x42,0x55,0x63,0x44,0x66,0x76,0x66,0x77,0x77,0x77,0x87,0x77,0x87,0x9e,0x99,0x9e,0x85,0xee,0x53,0xe9,0x5d,0xd7,0xd9,0xdd,0x7d,0x99,0xdd,0xdd,0x4d,0xd9,0x2d,
0x32,0x44,0x75,0x56,0xc6,0x77,0xcc,0x7c,0x43,0x56,0x65,0x25,0x44,0x53,0x55,0x74,0x55,0x55,0x77,0x46,0x66,0x6c,0xc7,0xcc,0x66,0xcc,0xc7,0xcc,0x7c,0x6c,0xc7,0xcc,0x7c,0xcc,0xcc,0x7c,0x5b,0xbb,0xfb,
};

static U8_WMV gacCodeLengthsInterHighRate[] = {
3,
0x21,0x43,0x65,0x66,0x78,0x77,0x99,0x99,0x63,0x98,0x65,0x36,0x43,0x44,0x55,0x55,0x66,0x66,0x66,0x76,0x98,0xdd,0xdd,0xd9,0xd8,0xdd,0xd7,0xdd,0x9d,0x6d,0x77,0xd8,0xdd,0xdd,0xdd,0xdd,0xcc,0xcc,0x2c,
0x42,0x56,0x75,0x77,0xdd,0xd6,0xdd,0xdd,0x75,0x7d,0xdd,0x1d,0x42,0x33,0x53,0x66,0x66,0x67,0x55,0x55,0xd7,0x77,0xd7,0xdd,0xd7,0xdd,0xcc,0xcc,0xcc,0x5c,0xcc,0xcc,0x6c,0xcc,0xcc,0xcc,0xcc,0xcc,0x1c,
0x21,0x32,0x44,0x55,0x66,0x76,0x77,0x98,0x53,0x87,0x85,0x47,0x55,0x65,0x66,0x66,0x66,0x66,0x66,0xf7,0xef,0xeb,0xee,0x97,0xb8,0xee,0xe7,0xee,0x8e,0x6e,0x77,0xba,0xee,0xee,0xee,0xee,0x8e,0xee,0x1e,
0x21,0x43,0x54,0x65,0x76,0x87,0x88,0x99,0x42,0x66,0x63,0x54,0x66,0x76,0x77,0x77,0x87,0x77,0x87,0x9a,0xea,0xe9,0xee,0xa8,0xb6,0xee,0x64,0x97,0x6a,0x79,0x97,0xb9,0xae,0xee,0xee,0xee,0x6e,0xbd,0x2b,
0x32,0x43,0x55,0x65,0x65,0x77,0x87,0x78,0x43,0x55,0x53,0x44,0x55,0x55,0x55,0x65,0x66,0x66,0x76,0x6a,0x76,0x88,0x98,0x98,0x75,0xee,0x63,0xe8,0x5e,0x69,0x77,0x89,0x8e,0x99,0xe9,0xdd,0x4d,0xd8,0x1d,
0x31,0x44,0x55,0x76,0x77,0xa8,0x97,0xea,0x42,0x65,0x53,0x54,0x76,0x76,0x76,0x76,0x87,0x88,0x88,0x8a,0xa9,0x9e,0xaa,0xa9,0x75,0xee,0x43,0x66,0x58,0x77,0xa9,0x9e,0x9e,0xe9,0xde,0xdd,0x4d,0xa9,0x18,
0x31,0x54,0x75,0x98,0x89,0xee,0xe9,0xe9,0x43,0x77,0x84,0x27,0x32,0x54,0x65,0x66,0x77,0x78,0xe9,0x58,0x85,0x79,0x97,0xee,0xe8,0xee,0xe7,0xee,0x8e,0x8e,0xee,0xee,0x9e,0xe9,0xee,0xee,0x7e,0xdd,0x3d,
0xa3,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0x9a,0x99,0x99,0x9,0x91,0x33,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0xf9,
};

static U8_WMV gacCodeLengthsIntraLowRate[] = {
3,
0x32,0x44,0x44,0x65,0x65,0x67,0x76,0x87,0x53,0x65,0x74,0x35,0x43,0x55,0x55,0x66,0x66,0x66,0x66,0x66,0x86,0x88,0x8a,0x75,0x64,0x88,0x96,0xdd,0x6d,0x69,0x87,0x67,0x6d,0x96,0xd9,0x9d,0x5d,0x78,0x1d,
0x31,0x44,0x65,0x66,0x87,0x88,0xe8,0xa9,0x42,0x65,0x43,0x53,0x66,0x77,0x76,0x78,0x88,0x88,0xa9,0x8a,0xa8,0x9e,0xee,0xee,0x75,0xee,0x63,0xa7,0x4e,0xa7,0xe9,0xee,0x8e,0xde,0xdd,0xdd,0x4d,0xdd,0x2d,
0x32,0x43,0x65,0x65,0x88,0xe7,0xe8,0xee,0x42,0x66,0x53,0x34,0x43,0x55,0x55,0x76,0x76,0x79,0x98,0x59,0x86,0x78,0x89,0xee,0x86,0xee,0x74,0xdd,0x5d,0x88,0x99,0xdd,0x7d,0xdd,0xd9,0x8d,0x5d,0x87,0x2d,
0x32,0x44,0x55,0x66,0x55,0x66,0x88,0x76,0x54,0x68,0x65,0x26,0x42,0x54,0x55,0x66,0x77,0x77,0x56,0x66,0x75,0xd8,0xdd,0x86,0x76,0xdd,0xd7,0xcc,0x7c,0x5c,0x86,0x65,0x6c,0xc6,0xcc,0xcc,0x7c,0x8c,0x1c,
0x31,0x44,0x55,0x66,0x76,0x88,0x99,0xe9,0x42,0x65,0x53,0x35,0x54,0x55,0x66,0x66,0x77,0x77,0x77,0x69,0x87,0x98,0xb9,0xb9,0x75,0xee,0x85,0xee,0x6e,0x9b,0xe9,0xab,0x7e,0xe8,0xeb,0xee,0x5d,0xab,0x2d,
0x32,0x43,0x54,0x76,0x8a,0x9a,0xea,0xee,0x43,0x65,0x64,0x25,0x43,0x44,0x54,0x65,0x77,0x67,0x87,0x4a,0x76,0x67,0x89,0xe8,0xe6,0xee,0xa6,0xde,0x6d,0x8d,0x99,0xd8,0x7d,0xda,0xdd,0x8d,0x6d,0xd8,0x2d,
0x32,0x43,0x44,0x54,0x46,0xc6,0xc6,0xc6,0x53,0x66,0x64,0x54,0x65,0x65,0xc6,0x66,0xcc,0x6b,0xb6,0x6b,0xbb,0xbb,0xbb,0x54,0x43,0x6b,0xb4,0xbb,0x5b,0x5b,0xbb,0xbb,0x5b,0xbb,0xbb,0xbb,0x4b,0x6b,0x2b,
0x32,0x54,0x75,0x77,0xea,0xee,0xee,0xee,0x53,0x86,0x74,0x17,0x42,0x44,0x55,0x77,0x78,0x76,0xa8,0x4e,0x76,0x78,0x88,0xee,0x97,0xee,0xe7,0xee,0x8e,0x7e,0xe8,0xee,0x8e,0xee,0xee,0x9e,0x6d,0xd8,0xfd,
};

static U8_WMV gacCodeLengthsIntraHighRate[] = {
3,
0x32,0x43,0x65,0x75,0x87,0x89,0x88,0xae,0x43,0x65,0x64,0x24,0x43,0x44,0x54,0x65,0x77,0x77,0x87,0x59,0x76,0x77,0x9a,0xea,0xd6,0xdd,0x95,0xdd,0x6d,0x7d,0xa8,0xa9,0x7d,0xd9,0xdd,0xdd,0x5d,0xa8,0x1d,
0x21,0x43,0x55,0x76,0x77,0x88,0xaa,0xaa,0x42,0x65,0x53,0x73,0x98,0x98,0xb9,0x99,0x99,0xba,0xb9,0xeb,0xee,0xde,0xdd,0xaa,0x97,0xdb,0x53,0x76,0x59,0xa7,0xd9,0xba,0xdd,0xdd,0xdd,0xdd,0x5d,0xaa,0x29,
0x32,0x54,0x76,0x77,0x89,0x99,0x9f,0xf9,0x42,0x75,0x42,0x63,0x88,0x88,0x98,0x99,0x99,0x89,0xa9,0x9f,0x9a,0x9a,0xaf,0xee,0x86,0xee,0x32,0x55,0x47,0xe6,0xee,0xae,0xae,0xaa,0xee,0xee,0x4e,0x7a,0x17,
0x21,0x33,0x44,0x55,0x55,0x66,0x77,0x87,0x53,0x86,0x75,0x56,0x55,0x55,0x66,0x66,0x66,0x66,0x77,0xa8,0xe9,0xee,0xee,0x76,0xb7,0xe8,0x86,0xee,0x7e,0x5a,0x76,0x67,0xa8,0xea,0xee,0xdd,0x7d,0xdd,0x1d,
0x31,0x54,0x65,0x76,0x77,0x88,0x99,0xbd,0x42,0x65,0x53,0x44,0x55,0x65,0x76,0x76,0x77,0x77,0x98,0x69,0x87,0x98,0x8a,0x98,0x76,0xbb,0x53,0x77,0x58,0x87,0x99,0x9a,0x8a,0xa8,0xda,0xad,0x5d,0x88,0x19,
0x21,0x43,0x54,0x65,0x66,0x77,0x87,0x89,0x42,0x76,0x64,0x45,0x65,0x66,0x77,0x76,0x77,0x77,0x87,0xa8,0xbb,0xce,0xee,0x87,0x97,0xc8,0x64,0x88,0x6e,0x7a,0x77,0x78,0xba,0xec,0xee,0xee,0x6e,0xad,0x2a,
0x32,0x43,0x54,0x65,0x77,0x87,0x88,0xba,0x42,0x65,0x53,0x34,0x54,0x65,0x66,0x66,0x76,0x77,0x78,0x69,0x87,0x8a,0xb9,0xe8,0x65,0xee,0x64,0xa8,0x5e,0x78,0x98,0xa9,0x7e,0xe8,0xee,0xdd,0x4d,0x89,0x1d,
0x31,0x54,0x66,0x77,0x88,0x98,0xee,0xee,0x42,0x65,0x53,0x73,0x87,0x89,0x89,0x99,0x9e,0xaa,0x9e,0x8e,0xea,0xae,0xea,0xea,0x96,0xee,0x42,0x66,0x48,0x86,0xea,0xdd,0x8d,0xd8,0xdd,0xdd,0x4d,0x7a,0xf9,
};

// Joint Laplacian coding for DCT DC components
static U8_WMV gacCodeLengthsDCHighRate[]={
3,
0x34,0x44,0x44,0x55,0x77,0xcc,0xcc,0xcc,0x1c,0x21,0x43,0x75,0xc8,0xcc,0xcc,0xcc,0xcc,
0x23,0x32,0x23,0x23,0x33,0x54,0x88,0xcc,0x5c,0x55,0x86,0x76,0xc8,0xcc,0xbb,0xb8,0xbb,
0x23,0x32,0x33,0x33,0x55,0x66,0xbb,0xbb,0x3b,0x32,0x54,0x65,0xb7,0xbb,0xbb,0xbb,0xaa,
0x13,0x22,0x22,0x33,0x55,0x76,0xdd,0xdd,0x8c,0x76,0xc7,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,
0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x6,0x61,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
0x34,0x54,0x55,0x56,0x56,0x67,0xc7,0xcc,0x2c,0x20,0x76,0xc8,0xcc,0xcc,0xcc,0xcc,0xbc,
0x13,0x22,0x33,0x54,0x66,0xd7,0x9d,0xd8,0x3d,0x42,0x75,0xd7,0xdd,0xdd,0xdd,0xdd,0xcd,
0x55,0x65,0x56,0x55,0x76,0x87,0xd9,0xdd,0xd,0x31,0x54,0x76,0xdd,0xdd,0xdd,0xdd,0xcc,
};

static U8_WMV gacCodeLengthsDCLowRate[] = {
3,
0x34,0x43,0x34,0x44,0x66,0xbb,0xbb,0xbb,0x2b,0x21,0x43,0x64,0xb7,0xbb,0xbb,0xbb,0xbb,
0x22,0x32,0x23,0x33,0x65,0xa6,0xaa,0xaa,0x5a,0x43,0x54,0x64,0xa6,0xa6,0xaa,0xaa,0x99,
0x66,0x65,0x65,0x77,0xcc,0xcc,0xcc,0xcc,0xb,0x21,0x54,0xb7,0xbb,0xbb,0xbb,0xbb,0xbb,
0x23,0x32,0x23,0x22,0x44,0xa6,0xaa,0xaa,0x4a,0x56,0x65,0x66,0xa6,0xaa,0xa6,0xaa,0x99,
0x67,0x66,0x78,0xd8,0xdd,0xdd,0xdd,0xcd,0x1c,0x20,0x53,0x86,0xcc,0xcc,0xcc,0xcc,0xcc,
0x66,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x5,0x55,0x55,0x55,
0x34,0x44,0x45,0x55,0x77,0xcc,0xcc,0xcc,0x1c,0x21,0x43,0x74,0xc8,0xcc,0xcc,0xcc,0xcc,
0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x6,0x61,0x66,0x66,0x66,0x66,0x66,0x66,0x66,
};

/**********************************************************************
 CLocalHuffmanDecoder : definition
**********************************************************************/
typedef struct t_LocalHuffmanDecoder
{
    t_AltTablesDecoder  *m_pAltTable;

    I32_WMV  m_iN;  // number of symbols inc escapes
    const U8_WMV *m_pFine;
    I32_WMV  m_iMode;
    I32_WMV  m_i1shiftMode;
    I32_WMV  m_iK;  // number of codeword tables
    I32_WMV  logK;
    U8_WMV   *opt;
    U8_WMV   *m_pCodeTablePtr;

    I32_WMV  *fineMask;
    Huffman_WMV  *m_pHuff;
    tPackHuffmanCode_WMV      *m_pCodeTable;

} t_CLocalHuffmanDecoder;

/**********************************************************************
  setCodes : setting local huffman codes based on QP
**********************************************************************/

static Void_WMV LhdecSetCodes (t_LocalHuffmanDecoder *pLhdec, I32_WMV inQP)
{
    // inter code tables
    if (pLhdec->m_iMode == LH_INTER0 || pLhdec->m_iMode == LH_INTER) {
        pLhdec->opt = (inQP < 13) ? gacCodeLengthsInterHighRate : gacCodeLengthsInterLowRate;
    }
    // intra code tables
    else if (pLhdec->m_iMode == LH_INTRAY0 || pLhdec->m_iMode == LH_INTRAY) {
        pLhdec->opt = (inQP < 13) ? gacCodeLengthsIntraHighRate : gacCodeLengthsIntraLowRate;
    }
    // Orientation tables
    else if (pLhdec->m_iMode == LH_ORIENT) {
        pLhdec->opt = (inQP < 13) ? gacCodeLengthsOrientHighRate : gacCodeLengthsOrientLowRate;
    }
    // DCT DC code tables
    else if (pLhdec->m_iMode > LH_ORIENT) {  // DCT DC codes
        pLhdec->opt = (inQP < 13) ? gacCodeLengthsDCHighRate : gacCodeLengthsDCLowRate;
    }

    pLhdec->m_iK = 1 << (pLhdec->logK = *pLhdec->opt++);
}

/**********************************************************************
 CLocalHuffmanDecoder : constructor
**********************************************************************/

static t_LocalHuffmanDecoder *LhdecConstruct (I32_WMV iMode,
                                              t_AltTablesDecoder *pAlt)
{
    t_LocalHuffmanDecoder *pLhdec = (t_LocalHuffmanDecoder *)
        wmvalloc (sizeof(t_LocalHuffmanDecoder));
    if (pLhdec == NULL_WMV)
        return NULL_WMV;
    DEBUG_HEAP_ADD(DHEAP_LOCALHUFF,sizeof(t_LocalHuffmanDecoder));

    pLhdec->m_pAltTable  = pAlt;
    pLhdec->m_pHuff = (Huffman_WMV *)wmvalloc(sizeof( Huffman_WMV));// Set Huffman object
    DEBUG_HEAP_ADD(DHEAP_LOCALHUFF,sizeof(t_LocalHuffmanDecoder));

    Huffman_WMV_construct(pLhdec->m_pHuff );

    pLhdec->m_iMode = iMode;  // no checks
    pLhdec->m_i1shiftMode = 1 << pLhdec->m_iMode;

    if (iMode < LH_ORIENT) {
        pLhdec->m_pFine = fineTbl;
        pLhdec->m_iN = X1+1;
    }
    else if (iMode == LH_ORIENT) {
        pLhdec->m_pFine = aNulls;
        pLhdec->m_iN = 12; /* number of orientations */
    }
    else {
        pLhdec->m_pFine = fineTblJoint;
        pLhdec->m_iN = iLaplacianAlphabet << 1;
    }

    pLhdec->m_pCodeTable = (tPackHuffmanCode_WMV *)
        wmvalloc ((pLhdec->m_iN + 2) * sizeof (tPackHuffmanCode_WMV));
    pLhdec->fineMask = (I32_WMV *) wmvalloc (pLhdec->m_iN * sizeof (I32_WMV));
    pLhdec->m_pCodeTablePtr = NULL_WMV;  // no table initialized
    DEBUG_HEAP_ADD(DHEAP_LOCALHUFF, ((pLhdec->m_iN + 2) * sizeof (tPackHuffmanCode_WMV)) + (pLhdec->m_iN * sizeof (I32_WMV)));

    // reset fineMask
    for (I32_WMV j = 0; j < pLhdec->m_iN; j++)
        pLhdec->fineMask[j] = (1 << pLhdec->m_pFine[j]) - 1;

    return pLhdec;
}

/**********************************************************************
 CLocalHuffmanDecoder : destructor
**********************************************************************/

static Void_WMV  LhdecDestruct (t_LocalHuffmanDecoder *pLhdec)
{
    if ( pLhdec != NULL_WMV ) {
        DEBUG_HEAP_SUB(DHEAP_LOCAL_COUNT,1); // count number of tables actually freed
        DEBUG_HEAP_SUB(DHEAP_LOCALHUFF,sizeof(t_LocalHuffmanDecoder)+sizeof(t_LocalHuffmanDecoder)+((pLhdec->m_iN + 2) * sizeof (tPackHuffmanCode_WMV)) + (pLhdec->m_iN * sizeof (I32_WMV)));
        Huffman_WMV_destruct(pLhdec->m_pHuff);
        if ( pLhdec->m_pHuff != NULL_WMV )
            wmvfree ( pLhdec->m_pHuff );
        if (pLhdec->m_pCodeTable != NULL_WMV )
            wmvfree (pLhdec->m_pCodeTable);
        if (pLhdec->fineMask != NULL_WMV )
            wmvfree (pLhdec->fineMask);
        wmvfree (pLhdec);
    }
}

/**********************************************************************
 CLocalHuffman::decodeHeader : decode header
**********************************************************************/

static Void_WMV LhdecDecodeHeader(t_LocalHuffmanDecoder *pLhdec,
                                  CInputBitStream_WMV* pin)
{
    I32_WMV  iCodeIndex = 0;
    FUNCTION_PROFILE_DECL_START(fp,DECODEIX8LHHEADER_PROFILE);

#ifdef LH_FULL_COMPLEXITY
    if ((pLhdec->m_pAltTable->m_iNewIntraFrame & pLhdec->m_i1shiftMode) == 0)
        iCodeIndex = 0;
    pLhdec->m_pAltTable->m_iNewIntraFrame |= pLhdec->m_i1shiftMode;

    if (pLhdec->m_iK > 1) {  // bit is sent only if multiple codetables exist
        if (pLhdec->m_pAltTable->m_bIntraFrame // Intra frame, or
            || BS_getBit(pin)) {  // there's a change in check bit
            iCodeIndex = BS_getBits(pin, pLhdec->logK);
#ifdef VERBOSE
        printf("[%d:%d_%d] ", pLhdec->m_iMode, iCodeIndex, pLhdec->logK);  // whether or not change
#endif  // VERBOSE
        }
    }
#else // default - used in WMV8
    iCodeIndex = BS_getBits(pin, pLhdec->logK);
#endif // LH_FULL_COMPLEXITY

    U8_WMV  *pLengths = pLhdec->opt + iCodeIndex * ((pLhdec->m_iN + 1) >> 1);
    if (pLhdec->m_pCodeTablePtr == pLengths) {
        FUNCTION_PROFILE_STOP(&fp);
        return;
    }
    pLhdec->m_pCodeTablePtr = pLengths;

    for (I32_WMV i = 0; i < pLhdec->m_iN; i++) {
        U8_WMV  c = *pLengths++;
        pLhdec->m_pCodeTable[i + 1].length = (c & 0xf) + 1;
        i++;
        pLhdec->m_pCodeTable[i + 1].length = ((c >> 4) & 0xf) + 1;
    }

    generateHuffman_balanced (pLhdec->m_pCodeTable, pLhdec->m_iN);
    /** reinitialize huffman table **/
    //pLhdec->m_pHuff->init(pLhdec->m_pAltTable->m_uiUserData, pLhdec->m_pCodeTable);
    DEBUG_HEAP_ADD(DHEAP_LOCAL_COUNT,1); // count number of tables actually allocated
    DEBUG_HEAP_ADD(DHEAP_LOCALHUFF,0);  // indicate this huffman table is for localHuffman
    Huffman_WMV_init ( pLhdec->m_pHuff, pLhdec->m_pAltTable->m_uiUserData, pLhdec->m_pCodeTable, NULL, 3);
    FUNCTION_PROFILE_STOP(&fp);
}

/**********************************************************************
 CLocalHuffman::if2rll : converts index, fine into run, level, last
**********************************************************************/
static const I8_WMV gOff0[]={16,24, 4,8, 32,16, 4,8,12,16,24, 3,7};
static const I8_WMV gOff1[]={16,20,24,28,32,48, 4,8,16, 4,8,16, 3,7};

static inline Void_WMV if2rll(I32_WMV iIndex, I32_WMV iFine, U32_WMV &uRun,
                          I32_WMV &iLevel, I32_WMV &bLast, I32_WMV *pFineMask)
{
    if (iIndex < L0a) {
        if (iIndex < (L0a>>1))  bLast=0;
        else {
            bLast=1;
            iIndex -= (L0a>>1);
        }
        if (iIndex < 16) {
            iLevel = 0;
            uRun = iIndex;
        }
        else if (iIndex < 20) {
            iLevel = 1;
            uRun = iIndex-16;
        }
        else if (iIndex < 22) {
            iLevel = 2;
            uRun = iIndex-20;
        }
        else {
            iLevel = 3;
            uRun = 0;
        }
        return;
    }

    HUFFMANGET_DBG_CACHE(pFineMask,index,4);

    iFine &= pFineMask[iIndex];
    iLevel = 0;

    if (iIndex < L1a) {
        bLast=0;
        if (iIndex <= L0b)
            uRun = gOff0[iIndex-L0a]+iFine;
        else if (iIndex<=L0d) {
            iLevel = 1;
            uRun = gOff0[iIndex-L0a]+iFine;
        }
        else if (iIndex==L0e) {
            uRun = gOff0[iIndex-L0a]+iFine;
        }
        else if (iIndex==L0f) {
            iLevel = 1;
            uRun = gOff0[iIndex-L0a]+iFine;
        }
        else if (iIndex <= L0v) {
            uRun=0;
            iLevel = gOff0[iIndex-L0a]+iFine;
        }
        else {
            uRun=1;
            iLevel = gOff0[iIndex-L0a]+iFine;
        }
        return;
    }

    else if (iIndex < Q0) {
        bLast=1;
        if (iIndex <= L1f)
            uRun = gOff1[iIndex-L1a]+iFine;
        else if (iIndex <= L1i) {
            iLevel = 1;
            uRun = gOff1[iIndex-L1a]+iFine;
        }
        else if (iIndex <= L1x) {
            uRun=0;
            iLevel=gOff1[iIndex-L1a]+iFine;
        }
        else {
            uRun=1;
            iLevel=gOff1[iIndex-L1a]+iFine;
        }
        return;
    }

    else if (iIndex < X0) {  // funkyQ processing
        I32_WMV  which=iFine&0x3;
        iFine>>=2;
        bLast=iIndex-Q0;
        switch (which) {
        case 0:
            uRun=2;
            iLevel=2+iFine;
            break;
        case 1:
            uRun=3+iFine;
            iLevel=2;
            break;
        case 2:
            uRun=3+(iFine&1);
            iLevel=3+(iFine>>1);
            break;
        case 3:
            uRun=5+(iFine&3);
            iLevel=3+(iFine>>2);
            break;
        default:;
        }
        return;
    }

    uRun=0;
    bLast = iFine&1;
    I32_WMV hfine = (iFine>>1);

// X0 and X1
    uRun = hfine&0x3f;
    iLevel = hfine>>6;
}

/**********************************************************************
 CLocalHuffman::decodeSymbol : decode symbol (run, level, last)
 Return value: 1 : use legacy decoding
               0 : symbol already decoded
**********************************************************************/

I32_WMV LhdecDecodeSymbol (t_LocalHuffmanDecoder *pLhdec,
                           CInputBitStream_WMV* pbitstrmIn,
                           U32_WMV &uRun, I32_WMV &iLevel, I32_WMV &bLast)
{
/** if m_iNewFrame is true, decode the header and initialize Huffman **/
    if ((pLhdec->m_pAltTable->m_iNewFrame & pLhdec->m_i1shiftMode) == 0) {
        LhdecDecodeHeader(pLhdec, pbitstrmIn);
        pLhdec->m_pAltTable->m_iNewFrame |= pLhdec->m_i1shiftMode;
    }

    //I32_WMV  iIndex = pLhdec->m_pHuff->get (pbitstrmIn);
    I32_WMV  iIndex = Huffman_WMV_get (pLhdec->m_pHuff, pbitstrmIn);
    I32_WMV  iFine = pLhdec->m_pFine[iIndex];
    if (iFine)
        iFine = BS_getBits (pbitstrmIn, iFine);

    if2rll (iIndex, iFine, uRun, iLevel, bLast, pLhdec->fineMask);
    iLevel = iLevel + 1;
    iFine = - (I32_WMV) BS_getBit(pbitstrmIn);
    iLevel = (iLevel ^ iFine) - iFine; // conditional change sign

    return 0;
}

/**********************************************************************
  CLocalHuffman::decodeOrient :  decode orientation
**********************************************************************/

I32_WMV LhdecDecodeOrient (t_LocalHuffmanDecoder *pLhdec,
                           CInputBitStream_WMV *pbitstrmIn)
{
    // if m_iNewFrame is true, decode header and initialize Huffman
    if ((pLhdec->m_pAltTable->m_iNewFrame & pLhdec->m_i1shiftMode) == 0) {
        LhdecDecodeHeader (pLhdec, pbitstrmIn);
        pLhdec->m_pAltTable->m_iNewFrame |= pLhdec->m_i1shiftMode;
    }
   // return pLhdec->m_pHuff->get(pbitstrmIn);
    return Huffman_WMV_get (pLhdec->m_pHuff, pbitstrmIn);
}

/**********************************************************************
  if2ll : index-fine to level-last
**********************************************************************/

static const U8_WMV gIntervals[]={5,7, 9,13, 17,25, 33,49, 65,97, 129,193};

inline static Void_WMV if2ll (I32_WMV index, I32_WMV fine,
                              I32_WMV &level, I32_WMV &last)
{
    last=0;
    if (index >= iLaplacianAlphabet) {
        last++;
        index -= iLaplacianAlphabet;
    }
    if (index >= 5) {
        index = gIntervals[index - 5] + (fine >> 1);  // assumed that fine is masked
    }
    fine = -(fine & 1);
    level = (index ^ fine) - fine;
}

/**********************************************************************
  CLocalHuffman::decodeJoint :  decode DC value (level, last)
**********************************************************************/

I32_WMV LhdecDecodeJoint (t_LocalHuffmanDecoder *pLhdec,
                          CInputBitStream_WMV *pbitstrmIn)
{
/** if m_iNewFrame is true, decode the header and initialize Huffman **/
    if ((pLhdec->m_pAltTable->m_iNewFrame & pLhdec->m_i1shiftMode) == 0) {
        LhdecDecodeHeader (pLhdec, pbitstrmIn);
        pLhdec->m_pAltTable->m_iNewFrame |= pLhdec->m_i1shiftMode;
    }

/** read index **/
    I32_WMV iLevel, iLast, iFine; // iIndex = pLhdec->m_pHuff->get(pbitstrmIn);
    I32_WMV iIndex = Huffman_WMV_get (pLhdec->m_pHuff, pbitstrmIn);

    iFine = pLhdec->m_pFine[iIndex];
    if (iFine)
        iFine = BS_getBits(pbitstrmIn, iFine);
    if2ll(iIndex, iFine, iLevel, iLast);

    iLevel += iLevel;
    iLevel += iLast;
    return iLevel;
}

/**********************************************************************
 CAltTablesDecoder : constructor
**********************************************************************/

t_AltTablesDecoder *t_AltTablesDecoderConstruct (U32_WMV uiUserData)
{
    t_AltTablesDecoder *pAltTab = (t_AltTablesDecoder *)
        wmvalloc (sizeof(t_AltTablesDecoder));
    pAltTab->m_bIntraFrame = FALSE_WMV;
    pAltTab->m_uiUserData = uiUserData;
    pAltTab->m_iNewFrame = 0;
    pAltTab->m_bIsFirstRun = TRUE_WMV;
    pAltTab->m_iNContexts = LH_INTRAC1 + 1;
    DEBUG_HEAP_ADD(DHEAP_LOCALHUFF,sizeof(t_AltTablesDecoder));

    for (I32_WMV i = 0; i < pAltTab->m_iNContexts; i++)
        pAltTab->m_paLH[i]  = LhdecConstruct (i, pAltTab);
    return pAltTab;
}

/**********************************************************************
 CAltTablesDecoder : destructor
**********************************************************************/

Void_WMV t_AltTablesDecoderDestruct (t_AltTablesDecoder *pAltTab)
{
    for (I32_WMV i=0; i<pAltTab->m_iNContexts; i++)
        LhdecDestruct (pAltTab->m_paLH[i]);
    wmvfree (pAltTab);
    DEBUG_HEAP_SUB(DHEAP_LOCALHUFF,sizeof(t_AltTablesDecoder));
}

/**********************************************************************
 CAltTables::setNewFrame
 clears m_iNewFrame parameter, and sets frame-level variables
**********************************************************************/

Void_WMV t_AltTablesSetNewFrame (t_AltTablesDecoder *pAltTab,
              I32_WMV iQLev, I32_WMV pOrI)
{
    pAltTab->m_iNewFrame = 0;
    pAltTab->m_iQLev = iQLev;
    if (pOrI)  {
        pAltTab->m_iNewIntraFrame = 0;
        pAltTab->m_bIntraFrame = TRUE_WMV;
    }
    else
        pAltTab->m_bIntraFrame = FALSE_WMV;

    // Set codes
    for (I32_WMV i = 0; i < pAltTab->m_iNContexts; i++)
        LhdecSetCodes(pAltTab->m_paLH[i], iQLev);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\intradec_x86.cpp ===
/*************************************************************************

Copyright (c) 2001  Microsoft Corporation

Module Name:
        intradec_x86.cpp

Abstract:
        X8 decoding functions specific to X86 platform (many with MMX)

Author:
        Sridhar Srinivasan (sridhsri@microsoft.com)
        24 April 2001

*************************************************************************/
#ifdef _WMV_TARGET_X86_

#include "bldsetup.h"

#include "xplatform.h"
#include "limits.h"

#include <stdio.h>
#include <math.h>
#include <stdlib.h>

#include "typedef.hpp"
#include "wmvdec_member.h"
#include "strmdec_wmv.hpp"
#include "idctdec_wmv2.h"
#include "localhuffman_wmv.h"
#include "spatialpredictor_wmv.hpp"

extern U16_WMV aNullPredWts_WMV[];

#pragma warning(disable: 4799)  // emms warning disable

Void_WMV predictDec_MMX(t_SpatialPredictor *pSp, const I32_WMV iOrient,
                        PixelC *pRef, const I32_WMV iRefStride, PixelI *pDelta,
                        Bool_WMV bClear)
{

//#ifdef  _WMV_TARGET_X86_  // put the ifdef here first...  move to outside of the function when
                 // everything is fixed
// all instances of m_pSide have been replaced by the constant 8 for speed
    const PixelC  *pVal;
    PixelI  *pDeltaOrig = pDelta;

    if (pSp->m_bFlat) {
            I32_WMV iDc = pSp->m_iDcValue;
            _asm {
                mov     ecx, 8    ; counter
                movd    mm1, iDc
                punpcklwd   mm1, mm1
                punpcklwd   mm1, mm1

                mov     edx, [pRef]
                mov     ebx, [pDelta]

StartOfLoopFlat:
                movq    mm2, [ebx]
                paddw   mm2, mm1

                movq    mm3, [ebx + 8]
                paddw   mm3, mm1

                packuswb    mm2, mm3
                movq    [edx], mm2

                ; increment pointers
                add     edx, iRefStride
                add     ebx, 16

                dec     ecx
                jnz     StartOfLoopFlat
            }
            if (bClear)
                goto Clear;
            else
                return;
    }

    switch(iOrient) {
    case 0:
        SetupZeroPredictor_MMX (pSp);
        {

            U16_WMV  *pTSum;
            U16_WMV  *pWts = aNullPredWts_WMV;
                pTSum = pSp->m_pTopSum;
                U16_WMV *pLSum = pSp->m_pLeftSum;
                _asm {
                    mov     eax, 0x8000
                    movd    mm7, eax
                    punpckldq   mm7, mm7    ; mm7 = 0000 8000 0000 8000

                    xor     ecx, ecx        ; counter i
                    pxor    mm0, mm0

                    mov     edi, [pTSum]
                    mov     esi, [pWts]
                    mov     edx, [pRef]
                    mov     ebx, [pDelta]

StartOfLoop:
                    mov     eax, [pLSum]
                    mov     ax, [eax + ecx * 2]
                    movd    mm2, eax
                    punpcklwd   mm2, mm2    ; mm2 = xxxx xxxx pLSum[i] pLSum[i]

                    ; first 4 elements
                    ; read in 4 deltas
                    movq    mm5, [ebx]      ; mm4 = pDelta[3] pDelta[2] pDelta[1] pDelta[0]

                    ; first 2 elements
                    movq    mm1, [esi]      ; mm1 = pWts[3] pWts[2] pWts[1] pWts[0]
                    movd    mm3, [edi]      ; mm3 = xxxx xxxx pTSum[1] pTSum[0]
                    punpcklwd   mm3, mm2    ; mm3 = pLSum[i] pTSum[1] pLSum[i] pTSum[0]
                    pmaddwd     mm3, mm1
                    paddd   mm3, mm7
                    psrad   mm3, 16

                    ; second 2 elements
                    movq    mm1, [esi + 8]
                    movd    mm4, [edi + 4]
                    punpcklwd   mm4, mm2
                    pmaddwd     mm4, mm1
                    paddd   mm4, mm7
                    psrad   mm4, 16

                    ; pack into mmx reg
                    packssdw    mm3, mm4
                    paddw   mm3, mm5

                    ; pack into output
                    packuswb    mm3, mm3
                    movd    [edx], mm3


                    ; second 4 elements
                    ; read in 4 deltas
                    movq    mm5, [ebx + 8]

                    ; first 2 elements
                    movq    mm1, [esi + 16]
                    movd    mm3, [edi + 8]
                    punpcklwd   mm3, mm2
                    pmaddwd     mm3, mm1
                    paddd   mm3, mm7
                    psrad   mm3, 16

                    ; second 2 elements
                    movq    mm1, [esi + 24]
                    movd    mm4, [edi + 12]
                    punpcklwd   mm4, mm2
                    pmaddwd     mm4, mm1
                    paddd   mm4, mm7
                    psrad   mm4, 16

                    ; pack into mmx reg
                    packssdw    mm3, mm4
                    paddw   mm3, mm5

                    ; pack into output
                    packuswb    mm3, mm3
                    movd    [edx + 4], mm3


                    ; increment pointers
                    add     esi, 32     ; pWts
                    add     ebx, 16     ; pDelta
                    add     edx, iRefStride     ; pRef

                    inc     ecx
                    cmp     ecx, 8
                    jnz     StartOfLoop
                }
            
        }
        break;
    case 4:
        {
                pVal = pSp->m_pTop;
                _asm {
                    ; set avg of top rows
                    mov     esi, [pVal]
                    pxor    mm0, mm0
                    pcmpeqw mm5, mm5    ; mm5 is all one
                    movq    mm7, [esi]
                    movq    mm1, [esi + 16]
                    movq    mm6, mm7
                    movq    mm2, mm1

                    ; first four words
                    punpcklbw   mm7, mm0
                    punpcklbw   mm1, mm0
                    punpckhbw   mm6, mm0
                    paddw   mm7, mm1
                    punpckhbw   mm2, mm0
                    psubw   mm7, mm5    ; mm7++

                    ; second four words
                    paddw   mm6, mm2
                    psraw   mm7, 1
                    psubw   mm6, mm5    ; mm6++
                    mov     ecx, 4      ; counter
                    psraw   mm6, 1

                    mov     eax, iRefStride
                    mov     edx, [pRef]
                    mov     ebx, [pDelta]

StartOfLoop4:
                    ; loop iter 1
                    movq    mm2, [ebx]
                    paddw   mm2, mm7
                    movq    mm3, [ebx + 8]
                    paddw   mm3, mm6
                    packuswb    mm2, mm3
                    movq    [edx], mm2

                    add     edx, eax

                    ; loop iter 2
                    movq    mm2, [ebx + 16]
                    paddw   mm2, mm7
                    movq    mm3, [ebx + 24]
                    paddw   mm3, mm6
                    packuswb    mm2, mm3
                    movq    [edx], mm2

                    ; increment pointers
                    add     ebx, 32
                    add     edx, eax

                    dec     ecx
                    jnz     StartOfLoop4
                }
        }
        break;
    default:
        predictDec (pSp, iOrient, pRef, iRefStride, pDelta, 0);
    }
    if (!bClear)
        return;

Clear:
    _asm {
        mov     edi, [pDeltaOrig]
        pxor    mm0, mm0
        ; rows 1 to 4
        movq    [edi], mm0
        movq    [edi + 8], mm0
        movq    [edi + 16], mm0
        movq    [edi + 24], mm0
        movq    [edi + 32], mm0
        movq    [edi + 40], mm0
        movq    [edi + 48], mm0
        movq    [edi + 56], mm0
        ; rows 5 to 8
        movq    [edi + 64], mm0
        movq    [edi + 72], mm0
        movq    [edi + 80], mm0
        movq    [edi + 88], mm0
        movq    [edi + 96], mm0
        movq    [edi + 104], mm0
        movq    [edi + 112], mm0
        movq    [edi + 120], mm0
    }
    return;
}

Void_WMV predict_0_MMX (U16_WMV *pTSum, U16_WMV *pLSum, U16_WMV *pWts, PixelC *pRef, I32_WMV iRefStride)
{
    _asm {
        mov     eax, 0x8000
        movd    mm7, eax
        punpckldq   mm7, mm7    ; mm7 = 0000 8000 0000 8000

        xor     ecx, ecx        ; counter i
        pxor    mm0, mm0

        mov     edi, [pTSum]
        mov     esi, [pWts]
        mov     edx, [pRef]

StartOfLoop:
        mov     eax, [pLSum]
        mov     ax, [eax + ecx * 2]
        movd    mm2, eax
        punpcklwd   mm2, mm2    ; mm2 = xxxx xxxx pLSum[i] pLSum[i]

        ; first 4 elements
        ; read in 4 deltas

        ; first 2 elements
        movq    mm1, [esi]      ; mm1 = pWts[3] pWts[2] pWts[1] pWts[0]
        movd    mm3, [edi]      ; mm3 = xxxx xxxx pTSum[1] pTSum[0]
        punpcklwd   mm3, mm2    ; mm3 = pLSum[i] pTSum[1] pLSum[i] pTSum[0]
        pmaddwd     mm3, mm1
        paddd   mm3, mm7
        psrad   mm3, 16

        ; second 2 elements
        movq    mm1, [esi + 8]
        movd    mm4, [edi + 4]
        punpcklwd   mm4, mm2
        pmaddwd     mm4, mm1
        paddd   mm4, mm7
        psrad   mm4, 16

        ; pack I32_WMVo mmx reg
        packssdw    mm3, mm4

        ; pack I32_WMVo output
        packuswb    mm3, mm3
        movd    [edx], mm3


        ; second 4 elements
        ; read in 4 deltas

        ; first 2 elements
        movq    mm1, [esi + 16]
        movd    mm3, [edi + 8]
        punpcklwd   mm3, mm2
        pmaddwd     mm3, mm1
        paddd   mm3, mm7
        psrad   mm3, 16

        ; second 2 elements
        movq    mm1, [esi + 24]
        movd    mm4, [edi + 12]
        punpcklwd   mm4, mm2
        pmaddwd     mm4, mm1
        paddd   mm4, mm7
        psrad   mm4, 16

        ; pack into mmx reg
        packssdw    mm3, mm4

        ; pack intoo output
        packuswb    mm3, mm3
        movd    [edx + 4], mm3


        ; increment pointers
        add     esi, 32     ; pWts
        add     edx, iRefStride     ; pRef

        inc     ecx
        cmp     ecx, 8
        jnz     StartOfLoop
    }
}

/****************************************************************************************
  setupZeroPredictor_MMX : sets up boundary arrays for zero prediction mode (MMX version)
****************************************************************************************/
Void_WMV SetupZeroPredictor_MMX (t_SpatialPredictor *pSp)
{
    U8_WMV  *mpTop = pSp->m_pTop;
    U8_WMV  *mpLeft = pSp->m_pLeft;
    I16_WMV      *pTop  = pSp->m_pBuffer16 + 12;
    I16_WMV      *pLeft = pSp->m_pBuffer16;
    U16_WMV     *pTsum = pSp->m_pTopSum;
    U16_WMV     *pLsum = pSp->m_pLeftSum;

    I64  S1[5], S3[5], *pS1, *pS3;
    pS1 = S1;
    *pS1 = 0;
    pS3 = S3;

#ifdef  _WMV_TARGET_X86_
    _asm {
        mov     esi, [pTop]
        mov     edi, [pLeft]

        mov     edx, [mpTop]
        pxor    mm0, mm0
        movq    mm1, [edx]
        movq    mm2, mm1
        punpcklbw   mm1, mm0
        movq    [esi], mm1
        punpckhbw   mm2, mm0
        movq    [esi + 8], mm2
        movd    mm1, [edx + 8]
        punpcklbw   mm1, mm0
        movq    [esi + 16], mm1

        mov     edx, [mpLeft]
        mov     eax, [edx - 4]
        mov     ebx, [edx - 8]
        bswap   eax
        bswap   ebx
        movd    mm1, eax
        movd    mm2, ebx
        punpcklbw   mm1, mm0
        punpcklbw   mm2, mm0
        movq    [edi], mm1
        movq    [edi + 8], mm2

        mov     edx, [pS1]
        mov     ecx, [pS3]

        ; k = 0, 1
        movd    mm2, [esi]
        movd    mm1, [edi]
        punpckldq   mm1, mm2    ; mm1 = pTop[1] pTop[0] pLeft[1] pLeft[0]
        psllw   mm1, 4      ; << D
        movq    mm7, mm1
        movq    [edx + 8], mm1

        ; k = 2, 3
        psraw   mm1, 1
        movd    mm2, [esi + 4]
        movd    mm6, [edi + 4]
        punpckldq   mm6, mm2
        psllw   mm6, 4
        paddw   mm1, mm6
        movq    [edx + 16], mm1

        ; k = 4, 5
        psraw   mm1, 1
        movd    mm2, [esi + 8]
        movd    mm5, [edi + 8]
        punpckldq   mm5, mm2
        psllw   mm5, 4
        paddw   mm1, mm5
        movq    [edx + 24], mm1

        ; k = 6, 7
        psraw   mm1, 1
        movd    mm2, [esi + 12]
        movd    mm4, [edi + 12]
        punpckldq   mm4, mm2
        psllw   mm4, 4
        paddw   mm1, mm4
        movq    mm2, mm4
        movq    [edx + 32], mm1

        psraw   mm2, 1
        paddw   mm5, mm2
        movq    [ecx + 16], mm5

        psraw   mm5, 1
        paddw   mm6, mm5
        movq    [ecx + 8], mm6

        psraw   mm6, 1
        paddw   mm7, mm6
        movq    [ecx], mm7

        ; 8, 9
        movd    mm2, [esi + 16]
        pxor    mm1, mm1
        punpckldq   mm1, mm2
        psllw   mm1, 3
        paddw   mm4, mm1
        movq    [ecx + 24], mm4
        psllw   mm1, 1

        ; 10, 11
        movd    mm2, [esi + 20]
        pxor    mm4, mm4
        punpckldq   mm4, mm2
        psllw   mm4, 3
        paddw   mm1, mm4
        movq    [ecx + 32], mm1

        ; add s??[1] terms (straight adds), * 181, + 128 and shift down
        mov     eax, 0x00800080 ; 128 128
        movd    mm3, eax
        punpcklwd   mm3, mm0    ; mm3 = 0 128 0 128
        xor     ebx, ebx
        mov     esi, [pLsum]
        mov     edi, [pTsum]

StartOfLoop:
        movq    mm7, [ecx + ebx * 8]
        movq    mm6, [edx + ebx * 8]
        movq    mm5, mm7
        movq    mm4, mm6
        paddw   mm7, mm6
        movq    mm6, mm7
        punpcklwd   mm7, mm0
        punpckhwd   mm6, mm0
        movq    mm1, mm7
        movq    mm2, mm6
        ; multiplying by 181
        pslld   mm1, 2
        pslld   mm2, 2
        paddd   mm7, mm1
        paddd   mm6, mm2

        pslld   mm1, 2
        pslld   mm2, 2
        paddd   mm7, mm1
        paddd   mm6, mm2
        paddd   mm7, mm1
        paddd   mm6, mm2
        paddd   mm7, mm1
        paddd   mm6, mm2

        pslld   mm1, 3
        pslld   mm2, 3
        paddd   mm7, mm1
        paddd   mm6, mm2
        ; adding 128
        paddd   mm7, mm3
        paddd   mm6, mm3
        ; shifting
        psrad   mm7, 8
        psrad   mm6, 8
        packssdw    mm7, mm6

        ; add first st of terms
        movq    mm1, mm3
        movq    mm6, mm5
        pcmpgtw mm1, mm0    ; 0 -1 0 -1

        pand    mm6, mm1
        movq    mm2, mm1
        pandn   mm2, mm4
        por     mm6, mm2

        movq    mm2, mm1
        pand    mm4, mm1
        pandn   mm1, mm5
        por     mm1, mm4
        psraw   mm1, 1
        paddw   mm6, mm1

        ; exchange mm6 words and add to mm7
        movq    mm5, mm6
        psrlq   mm5, 16
        pand    mm5, mm2
        psllq   mm6, 16
        pandn   mm2, mm6
        por     mm2, mm5
        paddw   mm7, mm2

        movd    [esi + ebx * 4 - 2], mm7
        psrlq   mm7, 32
        movd    [edi + ebx * 4 - 2], mm7

        inc     ebx
        cmp     ebx, 5
        jl      StartOfLoop;
    }
#endif // _WMV_TARGET_X86_
}

/****************************************************************************************
  GetRange : Finds range and sum
****************************************************************************************/
Void_WMV GetRange (U8_WMV *pTop, U8_WMV *pLeft, I32_WMV &iRange, I32_WMV &iDC)
{
    I32_WMV  iDC1, iRange1;
    _asm {
        pxor    mm0, mm0
        mov     esi, [pTop]
        mov     edi, [pLeft]
        mov     eax, 0x80808080

        ; subtract 128 ... 128
        movd    mm7, eax
        punpcklbw   mm7, mm7
        movq    mm1, [esi]
        movq    mm2, [edi]
        psubb   mm1, mm7
        psubb   mm2, mm7
        movq    mm3, mm1
        movq    mm4, mm2
        movq    mm5, mm3

        pcmpgtb mm1, mm2
        movq    mm7, mm1
        pand    mm5, mm1
        pand    mm4, mm1
        pandn   mm1, mm2
        pandn   mm7, mm3
        por     mm5, mm1    ; max
        por     mm4, mm7    ; min

        ; take negative of min
        pxor    mm6, mm6
        pcmpeqb mm6, mm6    ; mm6 = -1 ... -1
        pxor    mm1, mm1
        psubb   mm1, mm4
        paddb   mm1, mm6

        ; repack min-max
        movq    mm4, mm1
        punpckldq   mm4, mm5
        punpckhdq   mm1, mm5

        ; first: four compares each
        movq    mm7, mm1
        pcmpgtb mm7, mm4
        pand    mm1, mm7
        pandn   mm7, mm4
        por     mm1, mm7    ; mm1 has data

        ; second: two compares each
        movq    mm7, mm1
        psrld   mm1, 16
        movq    mm4, mm1
        pcmpgtb mm4, mm7
        pand    mm1, mm4
        pandn   mm4, mm7
        por     mm1, mm4    ; mm1 has data

        ; third: one compare each
        movq    mm7, mm1
        psrld   mm1, 8
        movq    mm4, mm1
        pcmpgtb mm4, mm7
        pand    mm1, mm4
        pandn   mm4, mm7
        por     mm1, mm4    ; mm1 has data

        pslld   mm1, 24
        psrad   mm1, 24
        movq    mm4, mm1
        psrlq   mm4, 32
        paddd   mm1, mm4

        movd    ebx, mm1
        inc     ebx
        mov     iRange1, ebx

        ; find sum
        movd    mm7, eax
        punpcklbw   mm7, mm7
        paddb   mm2, mm7
        paddb   mm3, mm7

        movq    mm1, mm3
        punpcklbw   mm1, mm0
        punpckhbw   mm3, mm0
        paddw   mm3, mm1
        movq    mm1, mm2
        punpcklbw   mm1, mm0
        punpckhbw   mm2, mm0
        paddw   mm2, mm1
        paddw   mm2, mm3
        movq    mm3, mm2
        psrlq   mm3, 32
        paddw   mm2, mm3
        movq    mm3, mm2
        psrlq   mm3, 16
        paddw   mm2, mm3    ; sum
        movd    eax, mm2
        shl     eax, 16
        shr     eax, 16
        mov     iDC1, eax
    }
    iDC += iDC1;
    iRange = iRange1;
}

#pragma warning(default: 4799)  // reset emms warning disable
#endif // _WMV_TARGET_X86_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\lowrate_common.c ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    LowRate.c

Abstract:

    Implementation of functions only used by low bitrate or mid bitrates
	e.g. MidRate and LowRate specific code

Author:

    Wei-ge Chen (wchen) 14-July-1998

Revision History:
	Sil Sanders (sils)	17-Dec-1999 - Added MidRate specific functions


*************************************************************************/

#ifdef ENABLE_ALL_ENCOPT

#include "bldsetup.h"

#include <math.h>
#include <limits.h>
#include "stdio.h"

#include "AutoProfile.h" 
#include "msaudio.h"

#include "lowrate_common.h"

#pragma warning (disable:4554)

#if defined(REFERENCE_RAND_24) || defined(REFERENCE_RAND_16)
#	pragma COMPILER_MESSAGE(__FILE__ "(36) : Warning - Non-32-bit random number generator in use.")
#endif

// DEBUG_BREAK at a particular Frame in prvInverseQuantizeHighRate or prvInverseQuantizeLowRate 
//#define INVERSE_QUANTIZE_AT_FRAME 178
// PRINT CoefRecon for all Frames in range (define or undefine both at once)
//#define PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST 177
//#define PRINT_INVERSE_QUANTIZE_AT_FRAME_LAST  177
#if defined(_DEBUG) && ( defined(INVERSE_QUANTIZE_AT_FRAME) || defined(PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST)  )
#	pragma COMPILER_MESSAGE(__FILE__ "(45) : Warning - Inverse Quantize LowRate/MidRate Debug Code Enabled.")
// these help match where we are with V4 which does not have a m_iFrameCount
extern int iInvQuantFrameCount = 0;
extern int iInvQuantSubFrameCount = 0;
#endif
#if defined(_DEBUG) && defined(INVERSE_QUANTIZE_AT_FRAME)
// these help match where we are with V4 which does not have a m_iFrameCount
#	define DEBUG_BREAK_AT_FRAME_INV_QUANT										\
		{ 																		\
			if ( pau->m_iCurrSubFrame == 0 && ppcinfo == pau->m_rgpcinfo )		\
			{	iInvQuantFrameCount++;	iInvQuantSubFrameCount = 0; }			\
			else if ( ppcinfo == pau->m_rgpcinfo ) iInvQuantSubFrameCount++;	\
			if ( iInvQuantFrameCount==INVERSE_QUANTIZE_AT_FRAME )				\
				DEBUG_BREAK();													\
		}
#elif defined(_DEBUG) && ( defined(PRINT_INVERSE_QUANTIZE_AT_FRAME) || defined(PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST) )
// these help match where we are with V4 which does not have a m_iFrameCount
#	define DEBUG_BREAK_AT_FRAME_INV_QUANT										\
		{ 																		\
			if ( pau->m_iCurrSubFrame == 0 && ppcinfo == pau->m_rgpcinfo )		\
			{	iInvQuantFrameCount++;	iInvQuantSubFrameCount = 0; }			\
			else if ( ppcinfo == pau->m_rgpcinfo ) iInvQuantSubFrameCount++;	\
		}
#else	// defined(_DEBUG) && defined(PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST) 
#	define DEBUG_BREAK_AT_FRAME_INV_QUANT
#endif	// ...

#ifdef BUILD_INTEGER
//Integer Version

//*********************************************************************************************************
// Verify CoefRecon
// Debug code which simulates V4 floating point code.
// If decoded inputs are in error, false verifications can occur.
// include this by defining VERIFY_DECODED_COEFS below or in the project file
//*********************************************************************************************************
//#define VERIFY_DECODED_COEFS
#if defined(_DEBUG) && defined(VERIFY_DECODED_COEFS)
#	pragma COMPILER_MESSAGE(__FILE__ "(83) : Warning - Inverse Quantize LowRate Verification Code Enabled.")
static int fIgnoreLRVerification = 1;		// avoid verify checks - set by hand in debugger only
static Float fltLowRateThreshold = 0.1F;	// change from the debugger ((really should be much smaller!!!))
void VerifyCoefReconLR( CAudioObject* pau, PerChannelInfo* ppcinfo, 
					  int iRecon, int iBark, I32 qrand, I32 iCoefRecon, int iCoefQ, int iWeightFactor, 
					  const U8* rgbBandNotCoded, int iNoiseBand, int cNoiseBand, 
					  const Int* rgiNoisePower, const FastFloat* rgffltSqrtBWRatio, const int* m_rgiBarkIndex )
{	// stolen and adapted from V4 
	if ( !fIgnoreLRVerification )
	{
		Float fltiCoefRecon = (Float)iCoefRecon/(1<<TRANSFORM_FRACT_BITS);
		Float fltNoise = ((Float) qrand / (Float) 0x20000000);
		Float fltInvMaxWeight = (Float)(1<<WEIGHTFACTOR_FRACT_BITS)/((Float)ppcinfo->m_iMaxWeight);
		Float fltWeightFactor = ((Float)iWeightFactor)/(1<<WEIGHTFACTOR_FRACT_BITS);
		double dblQuantStep = DOUBLE_FROM_QUANTSTEPTYPE(pau->m_qstQuantStep);
		Float dif, rel, fltCoefRecon, fltNoisePower;
		static fInBandNotCoded = 0;
		if (!pau->m_fNoiseSub) {
			if (iRecon < pau->m_cLowCutOff  || iRecon >= pau->m_cHighCutOff) 
				fltCoefRecon = 0;
			else
    			fltCoefRecon = (Float)( (Float)iCoefQ  * fltWeightFactor * dblQuantStep * fltInvMaxWeight );
		}
		else
		{
			if (iRecon < pau->m_cLowCutOff)  {
				fltNoise *= pau->m_fltDitherLevel;
				fltCoefRecon = (Float)(fltNoise * fltWeightFactor * dblQuantStep * fltInvMaxWeight);
				fInBandNotCoded = 0;
			}
			else if ( (fInBandNotCoded && iRecon >= m_rgiBarkIndex [iBark + 1] && rgbBandNotCoded [iBark+1] == 0) 
					|| (fInBandNotCoded==0 && iRecon >= pau->m_cHighCutOff) )  {
				fltNoise *= pau->m_fltDitherLevel;
				fltCoefRecon = (Float)(fltNoise * fltWeightFactor * dblQuantStep * fltInvMaxWeight);
				fInBandNotCoded = 0;
			}
			else if (iRecon >= pau->m_iFirstNoiseIndex && iBark < NUM_BARK_BAND && rgbBandNotCoded [iBark] == 1)
			{
				fltNoisePower = ((Float) pow (10, rgiNoisePower [iNoiseBand] / 20.0F)) * FloatFromFastFloat( rgffltSqrtBWRatio[iNoiseBand] );
				fltCoefRecon = fltNoise * fltNoisePower * fltWeightFactor * fltInvMaxWeight;
				fInBandNotCoded = 1;
			}
			else 
			{
				fltNoise *= pau->m_fltDitherLevel;
				fltCoefRecon = (Float)((iCoefQ + fltNoise) * fltWeightFactor * dblQuantStep * fltInvMaxWeight);
				fInBandNotCoded = 0;
			}
		}
		dif = (float) fabs(fltCoefRecon - fltiCoefRecon);
		rel = (float) fabs( (fabs(fltCoefRecon)>32) ? (dif/fltCoefRecon) : (dif/32));
		if ( rel > fltLowRateThreshold )
			DEBUG_BREAK();
		else 
		{	// when magnitude of integer version is much larger than float, we sometimes see differences
			// expect some false triggers, but often there is a relevant difference
			dif = (float)( fabs(fltiCoefRecon) - fabs(fltCoefRecon) );
			rel = (float) fabs( (fabs(fltCoefRecon)>32) ? (dif/fltCoefRecon) : (dif/32));
			if ( dif > 75.0f && rel > 0.000125f )		// test with all1_22s_22
				DEBUG_BREAK();
		}
	}
	MONITOR_RANGE(gMR_CoefRecon,iCoefRecon/((Float)(1<<TRANSFORM_FRACT_BITS)));
	MONITOR_RANGE(gMR_WeightRatio,(float)iWeightFactor/((float)ppcinfo->m_iMaxWeight));
	MONITOR_COUNT_CONDITIONAL(iCoefRecon==0,gMC_zeroCoefRecon,1);
#	if defined(PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST)
		if ( PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST <= iInvQuantFrameCount && iInvQuantFrameCount <= PRINT_INVERSE_QUANTIZE_AT_FRAME_LAST )
#           if UNDER_CE
			    MyOutputDbgStr(0,"%5d  %2d  %1d  %4d  %+16.6f  %+16.6f\n", 
				    iInvQuantFrameCount, iInvQuantSubFrameCount, ppcinfo-pau->m_rgpcinfo, iRecon, 
                    FLOAT_FROM_WEIGHT(rgiWeightFactor[iRecon]), FLOAT_FROM_COEF(rgiCoefRecon[iRecon]) );
#           else // !UNDER_CE
			    printf("%5d  %2d  %1d  %4d  %+16.6f  %+16.6f\n", 
				    iInvQuantFrameCount, iInvQuantSubFrameCount, ppcinfo-pau->m_rgpcinfo, iRecon, 
                    FLOAT_FROM_WEIGHT(rgiWeightFactor[iRecon]), FLOAT_FROM_COEF(rgiCoefRecon[iRecon]) );
#           endif   // UNDER_CE
#	endif
}
#define VERIFY_COEF_RECON_LR(idx,qRand,cNBand)																			\
	 VerifyCoefReconLR(	pau, ppcinfo,																					\
						iRecon, iBark, qRand, rgiCoefRecon[iRecon], rgiCoefQ[iCoefQ], rgiWeightFactor[idx],				\
						rgbBandNotCoded, iNoiseBand, cNBand, rgiNoisePower, rgffltSqrtBWRatio, pau->m_rgiBarkIndex )
#elif defined(_DEBUG) && defined(WMA_MONITOR)
#define VERIFY_COEF_RECON_LR(idx,qRand,cNBand)																			\
	MONITOR_RANGE(gMR_CoefRecon,rgiCoefRecon[iRecon]/((Float)(1<<TRANSFORM_FRACT_BITS)));                               \
	MONITOR_RANGE(gMR_WeightRatio,(float)rgiWeightFactor[iRecon]/((float)ppcinfo->m_wtMaxWeight));                      \
	MONITOR_COUNT_CONDITIONAL(rgiCoefRecon[iRecon]==0,gMC_zeroCoefRecon,1);
#elif defined(_DEBUG) && defined(PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST)
#   if UNDER_CE
#       define VERIFY_COEF_RECON_LR(idx,qRand,cNBand)																	\
            if ( PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST <= iInvQuantFrameCount                                           \
                 && iInvQuantFrameCount <= PRINT_INVERSE_QUANTIZE_AT_FRAME_LAST )                                       \
		        MyOutputDbgStr(0,"%5d  %2d  %1d  %4d  %+16.6f  %+16.6f\n",                                              \
				    iInvQuantFrameCount, iInvQuantSubFrameCount, ppcinfo-pau->m_rgpcinfo, iRecon,                       \
                    FLOAT_FROM_WEIGHT(rgiWeightFactor[iRecon]), FLOAT_FROM_COEF(rgiCoefRecon[iRecon]) );
#   else // !UNDER_CE
#       define VERIFY_COEF_RECON_LR(idx,qRand,cNBand)																	\
            if ( PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST <= iInvQuantFrameCount                                           \
                 && iInvQuantFrameCount <= PRINT_INVERSE_QUANTIZE_AT_FRAME_LAST )                                       \
		        printf("%5d  %2d  %1d  %4d  %+16.6f  %+16.6f\n",                                                        \
				    iInvQuantFrameCount, iInvQuantSubFrameCount, ppcinfo-pau->m_rgpcinfo, iRecon,                       \
                    FLOAT_FROM_WEIGHT(rgiWeightFactor[iRecon]), FLOAT_FROM_COEF(rgiCoefRecon[iRecon]) );
#   endif   // UNDER_CE
#else	// so not ( defined(_DEBUG) && defined(VERIFY_DECODED_COEFS) )
#define VERIFY_COEF_RECON_LR(idx,qRand,cNBand)
#endif	// defined(_DEBUG) && defined(VERIFY_DECODED_COEFS)




#define INV_MAX_WEIGHT_FRAC_BITS 30
#define MORE_WF_FRAC_BITS 0

#if defined(BUILD_INTEGER)

    // WinCE and embedded compilers have lousy performance for I64 multiplication and division.
    // On the SH3, this saves .35% of playtime decoding 16m_16 by speeding up InverseQuadRoot 14%.

    INLINE UInt uiInverseMaxWeight(WeightType wtMaxWeight)
    {   
        U32 uiMSF = wtMaxWeight;
        Int iExp = (32-INV_MAX_WEIGHT_FRAC_BITS)+(32-WEIGHTFACTOR_FRACT_BITS);  // (32-30)+(32-21)=13
        int iMSF8;
        U32 uiFrac1;

        // Check if inv max weight too large to fit in a U32 @ INV_MAX_WEIGHT_FRAC_BITS
        // We note mwMAX = 2^(21+30)/(2^32 - 1) ~= 2^(21+30)/2^32 = 2^(21+30-32)
        if ( uiMSF < ((U32)(1<<(INV_MAX_WEIGHT_FRAC_BITS + WEIGHTFACTOR_FRACT_BITS - 32))) ) 
            return 0xFFFFFFFF; // Return the largest number we've got

        // normalize the fractional part
        while( (uiMSF & 0xF0000000)==0 ) {
            iExp -= 4;
            uiMSF <<= 4;
        }
        while( (uiMSF & 0x80000000)==0 ) {
            iExp--;
            uiMSF <<= 1;
        }
        // discard the most significant one bit (it's presence is built into g_InverseFraction)
        iExp--;
        uiMSF <<= 1;
        assert( iExp >= 0 );
        if ( iExp < 0 )
            return 0xFFFFFFFF; // Return the largest number we've got

        // split into top INVERSE_FRACTION_TABLE_LOG2_SIZE==8 bits for fractional lookup and bottom bits for interpolation
        iMSF8 = uiMSF>>(32-INVERSE_FRACTION_TABLE_LOG2_SIZE);
        uiMSF <<= INVERSE_FRACTION_TABLE_LOG2_SIZE;
        // lookup and interpolate - tables are set up to return correct binary point for WeightType (we hope)
        uiFrac1  = g_InverseFraction[iMSF8++];
        uiFrac1 -= MULT_HI_UDWORD( uiMSF, uiFrac1 - g_InverseFraction[iMSF8] );
        return uiFrac1 >> iExp;
    }

#   define INVERSE_MAX_WEIGHT(mw) uiInverseMaxWeight(mw)

#else

#   define INVERSE_MAX_WEIGHT(mw) ((UInt)((((I64)1)<<(INV_MAX_WEIGHT_FRAC_BITS+WEIGHTFACTOR_FRACT_BITS))/(mw)))

#endif

//**************************************************************************************************
//
// prvInverseQuantizeLowRate handles LowRate inverse quantization
//
//**************************************************************************************************
WMARESULT prvInverseQuantizeLowRate (CAudioObject* pau, PerChannelInfo* ppcinfo, Int* rgiWeightFactor)
{
	Int iBark = 0;
	Int iCoefQ = 0;
	Int iRecon = 0;
    UInt uiWeightFactor, uiMaxWeight, uiQuantStepXInvMaxWeight;
    Int QuantStepXMaxWeightXWeightFactor, qrand, iNoise;
	Int cQSIMWFracBits, cFracBits, cFracBits2, cWFFracBits, cMaxWeightFracBits;
    Float fltCoefRecon;
    Int *rgiCoefRecon = ppcinfo->m_rgiCoefRecon;
    const I16* const rgiCoefQ                = ppcinfo->m_rgiCoefQ;
    const U8* const rgbBandNotCoded          = ppcinfo->m_rgbBandNotCoded;
    const Int* const rgiNoisePower           = ppcinfo->m_rgiNoisePower;
    const FastFloat* const rgffltSqrtBWRatio = ppcinfo->m_rgffltSqrtBWRatio;
    U8  cNoiseBand;
    Int iNoiseBand = 0;
	const Int iDitherFactor = 0x51EB851F;		// LPC  0.04 * 2^35 
	UInt uiInvMaxWeight = INVERSE_MAX_WEIGHT(ppcinfo->m_wtMaxWeight);
    FUNCTION_PROFILE(fp);
    FUNCTION_PROFILE_START(&fp,INVERSE_QUAN_LOW_RATE_PROFILE);
	//assert( uiInvMaxWeight == (UInt)((float)(1<<INV_MAX_WEIGHT_FRAC_BITS)*(float)(1<<WEIGHTFACTOR_FRACT_BITS)/((float)ppcinfo->m_wtMaxWeight) ) );
	//// Float 1/MaxWeight = uiInvMaxWeight/(1.0F*(1<<30))

	DEBUG_BREAK_AT_FRAME_INV_QUANT;
	MONITOR_COUNT(gMC_IQ,1);

    //Calculate QuantStep X invMaxWeight
    cQSIMWFracBits  = pau->m_qstQuantStep.iFracBits;                           
    uiQuantStepXInvMaxWeight = MULT_HI_DWORD(pau->m_qstQuantStep.iFraction,uiInvMaxWeight);
    //uiQuantStepXInvMaxWeight = (MULT_HI_DWORD(pau->m_qstQuantStep.iFraction,uiInvMaxWeight>>1)<<1);
	cQSIMWFracBits += (INV_MAX_WEIGHT_FRAC_BITS-32);
	// Float QSIMWF = uiQuantStepXInvMaxWeight*1.0F/(1<<cQSIMWFracBits)
	NormUInt( &uiQuantStepXInvMaxWeight, &cQSIMWFracBits, 0x3FFFFFFF );
	MONITOR_RANGE(gMR_QuantStepXInvMaxWeight,uiQuantStepXInvMaxWeight/pow(2,cQSIMWFracBits));

	// since all weights are less than MaxWeight, fast scale below by MaxWeight's FracBits
	uiMaxWeight = ppcinfo->m_wtMaxWeight<<MORE_WF_FRAC_BITS;;
	cMaxWeightFracBits = MORE_WF_FRAC_BITS;		// really should be WEIGHTFACTOR_FRACT_BITS+MORE_WF_FRAC_BITS but this way is for shift delta

	NormUInt( &uiMaxWeight, &cMaxWeightFracBits, 0x3FFFFFFF );

    if (!pau->m_fNoiseSub) {
		// Unusual case, but 8kHz Mono 8kpbs gets here
        memset (rgiCoefRecon, 0, pau->m_cLowCutOff * sizeof (Int));
        for (iRecon = pau->m_cLowCutOff; iRecon < pau->m_cHighCutOff; iRecon++, iCoefQ++)
		{	// rgfltCoefRecon [iRecon] = Float ((Float) (rgiCoefQ [iCoefQ]) * rgfltWeightFactor [iRecon] * dblQuantStep * fltInvMaxWeight);
			int iCoef;
			assert( rgiWeightFactor[iRecon] <= (0x7FFFFFFF>>cMaxWeightFracBits) );
			uiWeightFactor = rgiWeightFactor [iRecon] << cMaxWeightFracBits; 
			cWFFracBits = WEIGHTFACTOR_FRACT_BITS+cMaxWeightFracBits;
			//// Float WeightFactor = uiWeightFactor*1.0F/(1<<cWFFracBits)
			assert( uiWeightFactor <= 0x7FFFFFFF );
			NormUInt( &uiWeightFactor, &cWFFracBits, 0x3FFFFFFF );		
			MONITOR_RANGE(gMR_weightFactor,uiWeightFactor/pow(2,cWFFracBits));

			QuantStepXMaxWeightXWeightFactor = MULT_HI(uiQuantStepXInvMaxWeight,uiWeightFactor);		
			cFracBits = cQSIMWFracBits+cWFFracBits-31;
			//// Float QuantStep*WeightFactor/InvMaxWeight = QuantStepXMaxWeightXWeightFactor/(1.0F*(1<<cFracBits))
			MONITOR_RANGE(gMR_QuantStepXMaxWeightXWeightFactor,QuantStepXMaxWeightXWeightFactor/pow(2,cFracBits));

			iCoef = MULT_HI(((Int)(rgiCoefQ[iCoefQ])<<20),QuantStepXMaxWeightXWeightFactor);
			cFracBits += (20-31);
			//// Float Coef = iCoef*1.0F/(1<<cFracBits))

			rgiCoefRecon[iRecon] = Align2FracBits( iCoef, cFracBits, TRANSFORM_FRACT_BITS );
			//// Float CoefRecon = rgiCoefRecon[iRecon]/32.0F

			VERIFY_COEF_RECON_LR(iRecon,0,0);
		}
        memset (rgiCoefRecon + pau->m_cHighCutOff, 0, (pau->m_cSubband - pau->m_cHighCutOff) * sizeof (Int));
		FUNCTION_PROFILE_STOP(&fp);
		return WMA_OK;
    }

    cNoiseBand = rgbBandNotCoded [0];

	if (iRecon < pau->m_cLowCutOff ) {
		// not integerized since cLowCutOff is typically 0, so this is here for compatability with V1 
		Double dblQuantStep = DOUBLE_FROM_QUANTSTEPTYPE(pau->m_qstQuantStep);
		while  (iRecon < pau->m_cLowCutOff) 	{
			Float fltNoise = pau->m_fltDitherLevel * ((Float) quickRand (&(pau->m_tRandState)) / (Float) 0x20000000);//rgfltNoise [iRecon];
			Float fltWeightFactor = ((float)rgiWeightFactor [pau->m_cLowCutOff])/(1<<WEIGHTFACTOR_FRACT_BITS);
			// SH4 warning CBE4717 on the next line is ignorable - appraently a compiler mistake
			fltCoefRecon  = (Float) (fltNoise * fltWeightFactor * dblQuantStep * (float)(1<<WEIGHTFACTOR_FRACT_BITS)/((float)ppcinfo->m_wtMaxWeight) );
			rgiCoefRecon [iRecon] = (Int)(fltCoefRecon * (1<<TRANSFORM_FRACT_BITS));
			MONITOR_RANGE(gMR_CoefRecon,rgiCoefRecon[iRecon]/32.0f);
			MONITOR_RANGE(gMR_WeightRatio,(fltWeightFactor*(float)(1<<WEIGHTFACTOR_FRACT_BITS)/((float)ppcinfo->m_wtMaxWeight)));
			MONITOR_COUNT(gMC_IQ_Float,9);
			iRecon++;
		}
	}

	while  (iRecon < pau->m_iFirstNoiseIndex) {
        int iCoef,iCoefScaled,iCoefRecon,iNoiseScaled,iNoiseQuant;         
        assert(TRANSFORM_FRACT_BITS==5);
        qrand = quickRand (&(pau->m_tRandState));

        if (iRecon >= pau->m_rgiBarkIndex [iBark + 1]) 
			iBark++;
        assert(iBark < NUM_BARK_BAND);

	    // Since weight factors became unsigned, the following assert is not
	    // valid. Other wrap-around detection would have to be performed elsewhere.
		assert( rgiWeightFactor[iRecon] <= (0x7FFFFFFF>>cMaxWeightFracBits) );
        uiWeightFactor = rgiWeightFactor [iRecon] << cMaxWeightFracBits; 
        cWFFracBits = WEIGHTFACTOR_FRACT_BITS+cMaxWeightFracBits;
		//// Float WeightFactor = uiWeightFactor/(1.0F*(1<<cWFFracBits))
	    // Since weight factors became unsigned, the following assert is not
	    // valid. Other wrap-around detection would have to be performed elsewhere.
	    assert( uiWeightFactor <= 0x7FFFFFFF );
		NormUInt( &uiWeightFactor, &cWFFracBits, 0x3FFFFFFF );		// weightFactor with cWFFracBits fractional bits
		MONITOR_RANGE(gMR_weightFactor,uiWeightFactor/pow(2,cWFFracBits));
        
        QuantStepXMaxWeightXWeightFactor = MULT_HI(uiQuantStepXInvMaxWeight,uiWeightFactor);		
        cFracBits = cQSIMWFracBits+cWFFracBits-31;
        //// Float QuantStep*WeightFactor/MaxWeight = QuantStepXMaxWeightXWeightFactor/(1.0F*(1<<cFracBits))
		MONITOR_RANGE(gMR_QuantStepXMaxWeightXWeightFactor,QuantStepXMaxWeightXWeightFactor/pow(2,cFracBits));

        iCoef = MULT_HI(((Int)(rgiCoefQ[iCoefQ])<<20),QuantStepXMaxWeightXWeightFactor);
		cFracBits += (20-31);
		//// Float Coef = iCoef/(1.0F*(1<<cFracBits))

        //Rescale to TRANSFORM_FRACT_BITS for outputing to the inverse transform so that (float)iCoefScaled/(1<<TRANSFORM_FRACT_BITS)
		iCoefScaled = Align2FracBits( iCoef, cFracBits, TRANSFORM_FRACT_BITS );
		//// Float CoefScaled = iCoefScaled/32.0F

        iNoise = MULT_HI(iDitherFactor,qrand);
		cFracBits2 = 35+29-31;											// == 33
		//// Float Noise = iNoise/(1024.0F*(1<<(cFracBits2-10)))
        iNoiseQuant = MULT_HI(iNoise,QuantStepXMaxWeightXWeightFactor);
		cFracBits2 += ((cQSIMWFracBits+cWFFracBits-31)-31);
		//// Float NoiseQuant = iNoiseQuant/(1024.0F*(1<<(cFracBits2-10)))
		assert( (cFracBits+(33-20)) == cFracBits2 );

        //rescale iNoiseQuant so that (float)iNoiseScaled/(1<<TRANSFORM_FRACT_BITS)
		iNoiseScaled = Align2FracBits( iNoiseQuant, cFracBits2, TRANSFORM_FRACT_BITS );
		//// Float NoiseScaled = iNoiseScaled/32.0F

        iCoefRecon = iCoefScaled + iNoiseScaled;
        rgiCoefRecon [iRecon] = iCoefRecon;
		//// Float CoefRecon = rgiCoefRecon [iRecon]/32.0F

		VERIFY_COEF_RECON_LR(iRecon,qrand,cNoiseBand);

        iRecon++;
		iCoefQ++;
    }

    while  (iRecon < pau->m_cHighCutOff) {
		if (iRecon >= pau->m_rgiBarkIndex [iBark + 1]) 
			iBark++;
        assert(iBark < NUM_BARK_BAND);
        
		if (rgbBandNotCoded [iBark] == 1)
        {
			FastFloat ffltNoisePower;
            UInt uiNoisePowerXinvMaxWeight;
			Int iUBLimitOniRecon = min(pau->m_rgiBarkIndex [iBark + 1], pau->m_cHighCutOff);

			assert( iNoiseBand < cNoiseBand );

			ffltNoisePower = qstCalcQuantStep( rgiNoisePower[iNoiseBand] );
			//// Float Noise Power = ffltNoisePower.iFraction/(1.0F*(1<<ffltNoisePower.iFracBits))

			ffltNoisePower = ffltMultiply( ffltNoisePower, rgffltSqrtBWRatio[iNoiseBand] );
			//// Float Noise Power = ffltNoisePower.iFraction/(1.0F*(1<<ffltNoisePower.iFracBits))

            uiNoisePowerXinvMaxWeight = MULT_HI(ffltNoisePower.iFraction,uiInvMaxWeight>>1)<<1;
			cFracBits = ffltNoisePower.iFracBits + (INV_MAX_WEIGHT_FRAC_BITS-31);
			//// Float NoisePower/MaxWeight = uiNoisePowerXinvMaxWeight/(1.0F*(1<<cFracBits))
			NormUInt( &uiNoisePowerXinvMaxWeight, &cFracBits, 0x3FFFFFFF );

            while (iRecon < iUBLimitOniRecon)
            {
                Int iNoiseRand,iNoiseWeighted,iCoefRecon;

                qrand = quickRand (&(pau->m_tRandState));										// FB = 29												
                iNoiseRand = MULT_HI(uiNoisePowerXinvMaxWeight,qrand);
                cFracBits2 = cFracBits+29-31;
				//// Float NoiseRand = iNoiseRand/(1.0F*(1<<cFracBits2))

	            // Since weight factors became unsigned, the following assert is not
	            // valid. Other wrap-around detection would have to be performed elsewhere.
				assert( rgiWeightFactor[iRecon] <= (0x7FFFFFFF>>cMaxWeightFracBits) );
				uiWeightFactor = rgiWeightFactor [iRecon] << cMaxWeightFracBits; 
				cWFFracBits = WEIGHTFACTOR_FRACT_BITS+cMaxWeightFracBits;
				//// Float WeightFactor = 	uiWeightFactor/(1024.0F*(1<<(cWFFracBits-10)))
	            // Since weight factors became unsigned, the following assert is not
	            // valid. Other wrap-around detection would have to be performed elsewhere.
				assert( uiWeightFactor <= 0x7FFFFFFF );
				NormUInt( &uiWeightFactor, &cWFFracBits, 0x3FFFFFFF );		// uiWeightFactor with cWFFracBits fractional bits
				MONITOR_RANGE(gMR_weightFactor,uiWeightFactor/pow(2,cWFFracBits));

                iNoiseWeighted = MULT_HI(iNoiseRand,uiWeightFactor);	
				cFracBits2 += (cWFFracBits-31);
				//// Float NoiseWeighted = iNoiseWeighted/(1024.0F*(1<<(cFracBits2-10)))

				iCoefRecon = Align2FracBits( iNoiseWeighted, cFracBits2, TRANSFORM_FRACT_BITS );  //scale so that (float)iCoefRecon/(1<<TRANSFORM_FRACT_BITS)
                rgiCoefRecon [iRecon] = iCoefRecon;
				//// Float CoefRecon = rgiCoefRecon [iRecon]/32.0F

				VERIFY_COEF_RECON_LR(iRecon,qrand,cNoiseBand);

				iRecon++;	
			}

			iNoiseBand++;
		}
		else 
		{	// This should be the same as the first < FirstNoiseIndex loop
			// Float fltNoise = pau->m_fltDitherLevel * ((Float) quickRand (&(pau->m_tRandState)) / (Float) 0x20000000);
			// rgfltCoefRecon [iRecon] = (Float) ((rgiCoefQ [iCoefQ] + fltNoise) * rgfltWeightFactor[iRecon] * dblQuantStep * fltInvMaxWeight);			

            Int iCoef,iNoiseQuant,iCoefScaled,iCoefRecon;

            if (iRecon >= pau->m_rgiBarkIndex [iBark + 1]) 
				iBark++;
            assert(iBark < NUM_BARK_BAND);

			qrand = quickRand (&(pau->m_tRandState));

			assert( rgiWeightFactor[iRecon] <= (0x7FFFFFFF>>cMaxWeightFracBits) );
			uiWeightFactor = rgiWeightFactor [iRecon] << cMaxWeightFracBits; 
			cWFFracBits = WEIGHTFACTOR_FRACT_BITS+cMaxWeightFracBits;
			//// Float WeightFactor = uiWeightFactor/(1024.0F*(1<<(cWFFracBits-10)))
			assert( uiWeightFactor <= 0x7FFFFFFF );
			NormUInt( &uiWeightFactor, &cWFFracBits, 0x3FFFFFFF );		// uiWeightFactor with cWFFracBits fractional bits
			MONITOR_RANGE(gMR_weightFactor,uiWeightFactor/pow(2,cWFFracBits));

            QuantStepXMaxWeightXWeightFactor = MULT_HI(uiQuantStepXInvMaxWeight,uiWeightFactor);
            cFracBits = cQSIMWFracBits+cWFFracBits-31;
			//// Float QuantStep*WightFactor/MaxWeight = QuantStepXMaxWeightXWeightFactor/(1.0F*(1<<cFracBits))
			MONITOR_RANGE(gMR_QuantStepXMaxWeightXWeightFactor,QuantStepXMaxWeightXWeightFactor/pow(2,cFracBits));

            iNoise = MULT_HI(iDitherFactor,qrand); 
			cFracBits2 = 35+29-31;							// FP = 33
			//// Float Noise = iNoise/(1024.0F*(1<<(33-10)))

            iNoiseQuant = MULT_HI(iNoise,QuantStepXMaxWeightXWeightFactor);
			cFracBits2 += (cFracBits-31);
			//// Float NoiseQuant = iNoiseQuant/(1024.0F*(1<<(cFracBits2-10)))

            iCoef = MULT_HI( ((Int)rgiCoefQ[iCoefQ])<<20, QuantStepXMaxWeightXWeightFactor );
			cFracBits += (20-31);
			//// Float Coef = iCoef/(1.0F*(1<<cFracBits))

			iCoefScaled = Align2FracBits( iCoef, cFracBits, TRANSFORM_FRACT_BITS );  
			//// Float CoefScaled = iCoefScaled/32.0F

            assert(cFracBits2>=TRANSFORM_FRACT_BITS);
            iCoefRecon = iCoefScaled + (iNoiseQuant>>(cFracBits2-TRANSFORM_FRACT_BITS));
            rgiCoefRecon [iRecon] = iCoefRecon;
			//// Float CoefRecon = rgiCoefRecon [iRecon]/32.0F

			VERIFY_COEF_RECON_LR(iRecon,qrand,cNoiseBand);

            iRecon++;
		    iCoefQ++;
		}
	}

	{	//Calculate from highCutOff to m_cSubband
		UInt QuantStepXMaxWeightXWeightFactorXDither;
		
	    // Since weight factors became unsigned, the following assert is not
	    // valid. Other wrap-around detection would have to be performed elsewhere.
		assert( rgiWeightFactor[pau->m_cHighCutOff - 1] <= (0x7FFFFFFF>>cMaxWeightFracBits) );
		uiWeightFactor = rgiWeightFactor [pau->m_cHighCutOff - 1] << MORE_WF_FRAC_BITS;
		cWFFracBits = WEIGHTFACTOR_FRACT_BITS+MORE_WF_FRAC_BITS;
		//// Float WeightFactor = uiWeightFactor/(1024.0F*(1<<(cWFFracBits-10)))
		NormUInt( &uiWeightFactor, &cWFFracBits, 0x3FFFFFFF );		

		QuantStepXMaxWeightXWeightFactor = MULT_HI(uiQuantStepXInvMaxWeight,uiWeightFactor);
		cFracBits = cQSIMWFracBits+cWFFracBits-31;
		//// Float QuantStep*WeightFactor/MaxWeight = QuantStepXMaxWeightXWeightFactor/(1024.0F*(1<<(cFracBits-10)))
		NormUInt( (unsigned long *)&QuantStepXMaxWeightXWeightFactor, &cFracBits, 0x3FFFFFFF );

		QuantStepXMaxWeightXWeightFactorXDither = MULT_HI(QuantStepXMaxWeightXWeightFactor,iDitherFactor);
		cFracBits += (35-31);
		//// Float QS * WF/MaxWF * Dither = QuantStepXMaxWeightXWeightFactorXDither/(1024.0F*(1<<(cFracBits-10)))
		NormUInt( &QuantStepXMaxWeightXWeightFactorXDither, &cFracBits, 0x3FFFFFFF );

		while (iRecon < pau->m_cSubband) {
			Int iCoefScaled;
			Int qrand = quickRand (&(pau->m_tRandState));
			Int iCoefRecon = MULT_HI(QuantStepXMaxWeightXWeightFactorXDither,qrand);
			cFracBits2 = cFracBits + 29 - 31;
			//// Float CoefRecon = iCoefRecon/(1.0F*(1<<cFracBits2))
			
			iCoefScaled = Align2FracBits( iCoefRecon, cFracBits2, TRANSFORM_FRACT_BITS );
			rgiCoefRecon [iRecon] = iCoefScaled;		        
			//// Float CoefRecon = rgiCoefRecon [iRecon]/32.0F

			MONITOR_RANGE(gMR_QuantStepXMaxWeightXWeightFactor,QuantStepXMaxWeightXWeightFactor/pow(2,cFracBits));
			VERIFY_COEF_RECON_LR(pau->m_cHighCutOff - 1,qrand,cNoiseBand);

			iRecon++;
		}
	}

#   if defined(REFERENCE_RAND_24) || defined(REFERENCE_RAND_16)
        // call the random generator one extra time per subframe to improve subband randomness
        quickRand (&(pau->m_tRandState));
#   endif

	FUNCTION_PROFILE_STOP(&fp);
	return WMA_OK;
}
#pragma warning (default:4554)
#endif // BUILD_INTEGER

#endif //ENABLE_ALL_ENCOPT



//****************************************************************************
//****************************************************************************
//
//  MidRate 
//
//	Functions to implement MidRate
//
//****************************************************************************
//****************************************************************************

#ifdef ENABLE_ALL_ENCOPT

//function prototype, used to eliminate Mac warnings
Void prvGetBandWeightMidRate (CAudioObject* pau, PerChannelInfo* ppcinfo, const Int* const rgiBarkIndex, const Int* const rgiBarkIndexResampled, MaskResampleInfo MRI);

//*********************************************************************************
// prvGetBandWeightMidRate
// Calculate a band weight for bands which are not coded
// 
// BW = average( 10^(2*MaskQ[iBarkResampled]/16) ) over each linear frequency bin
// For most sampling rates, the bark scale when resampled does not equal the un-resampled bark scale
// But 32000 does have the nice property that the resampled bark scale = un-resampled in the noise substitution region
// So for 32000 Hz to 44099 Hz:  
//		BW = 10^((2/16)*MaskQ[iBarkResampled])
// For all other sampling frequencies:
//		BW = ( N1 * 10^(2*MarkQ[iBarkResampled]) + N2 * 10^(2*MarkQ[iBarkResampled+1]/16) ) / (N1 + N2)
//		where N1 is the number of linear frequency bins in the first resampled bark band
//		and   N2 is the number of linear frequency bins in the second resampled bark band
// BandWeights are only used as the sqrt of the ratio to the last noise BandWeight
// So for 32000 Hz to 44099 Hz
//		SqrtBWRatio = 10^((MaskQ[iBarkResampled] - MaskQ[iLast])/16)
// And for other sampling frequencies
//		SqrtBWRatio = sqrt( BW[i] / BW[last] )
// And for all cases where SqrtBWRatio[last] = 1
// Note that log to the base 10^(1/16) of the MaskQ are integers for 32000 but are not integers for non-32000Hz
// So doing all the inverse quantization in the exponent domain does not have the advantage of using integer exponents
// For this reason, SqrtBWRatio is stored and used as a FastFloat.
// TODO:  rgffltSqrtBWRatio seems to have a narrow range between 1/4 and 4. Consider making it a fixed point int.
// TODO:  Avoid recalculating when MaskQ's have not been updated and the resample ratio is the same as the previous subframe
//*********************************************************************************
Void prvGetBandWeightMidRate (CAudioObject* pau, PerChannelInfo* ppcinfo, 
							  const Int* const rgiBarkIndex, const Int* const rgiBarkIndexResampled, MaskResampleInfo MRI)
{
    U8*	rgbBandNotCoded			 = ppcinfo->m_rgbBandNotCoded;
	FastFloat* rgffltSqrtBWRatio = ppcinfo->m_rgffltSqrtBWRatio;
	Int* rgiMaskQ				 = ppcinfo->m_rgiMaskQ;
	U8 cNoiseBand	= 0;
	FastFloat fflt;
	Float flt;
	Int iCurrStart, iCurrBand, iCurrEnd;	// indexes for the current subframe
	Int iMaskStart, iMaskBand, iMaskEnd;	// indexes in the subframe where the MaskQ's were last updated
	Int iRsmpStart, iRsmpBand, iRsmpEnd;	// indexes for the current subframe resampled to the subframe where the MaskQ's were last updated
	int fAllBandsSynced = MRI.iMaskResampleRatioPow==MASKQ_RESAMPLE_OFFSET 
		|| ( pau->m_iVersion!=1 && 32000 <= pau->m_iSamplingRate && pau->m_iSamplingRate < 44100 );
	Int rgiMaskQ4BandNotCoded[10];			// used if bands Syncronized
	Float fltBandWeight[10];				// used if bands are no Syncronized
	Int cMaskHighCutOff;
    FUNCTION_PROFILE(fp);
    FUNCTION_PROFILE_START(&fp,GET_BAND_WEIGHTS_PROFILE);

	iCurrBand = pau->m_iFirstNoiseBand;
	iMaskBand = iRsmpBand = 0;
	if ( !fAllBandsSynced )
		cMaskHighCutOff = iResampleIndex( pau->m_cSubband, MRI ) * pau->m_cHighCutOffLong / pau->m_cFrameSampleHalf;

    while (WMAB_TRUE)    {
        assert (iCurrBand <= pau->m_cValidBarkBand);
        iCurrStart = max( rgiBarkIndex [iCurrBand], pau->m_iFirstNoiseIndex );
        if (iCurrStart >= pau->m_cHighCutOff)
            break;

		if (rgbBandNotCoded [iCurrBand] == 1)	{
			assert( cNoiseBand < 10 );		// probably (cNoiseBand < 5) would be OK

			// Determine the band for accessing the possibly resampled MaskQ's
			iMaskStart = iResampleIndex( iCurrStart, MRI );
			while ( rgiBarkIndexResampled [iMaskBand+1] <= iMaskStart ) 
				++iMaskBand;

			if ( fAllBandsSynced )
			{	// Current subFrame bands synced to band were MaskQ's were last updated
				rgiMaskQ4BandNotCoded[cNoiseBand] = rgiMaskQ[iMaskBand];
			}
			else
			{	// Have to check in detail about whether one or two MaskQ's are used by this BandNotCoded
				iCurrEnd   = min ( pau->m_cHighCutOff, rgiBarkIndex [iCurrBand + 1]);
				assert (iCurrEnd >= iCurrStart);
				iRsmpStart = iMaskStart;
				iMaskEnd = min( rgiBarkIndexResampled [ iMaskBand+1 ], cMaskHighCutOff );
				iRsmpEnd = min( iResampleIndex( iCurrEnd, MRI ), cMaskHighCutOff );
				while ( rgiBarkIndexResampled [iRsmpBand+1] <= (iRsmpEnd-1) ) 
					++iRsmpBand;
				assert( iMaskBand == iRsmpBand || (iMaskBand+1) == iRsmpBand );
				if ( iRsmpBand == iMaskBand )
				{	// just a constant MaskQ for the whole NoiseBand
					fflt = ffltMaskPower10( rgiMaskQ[iMaskBand] );
					flt = FLOAT_FROM_FASTFLOAT( fflt );
					fltBandWeight[cNoiseBand] = flt*flt;
					MONITOR_COUNT(gMC_GBW_floats,4);
				}
				else
				{	// Two different MaskQ's for this NoiseBand
					// BW = ( N1 * 10^(2*MarkQ[iBarkResampled]) + N2 * 10^(2*MarkQ[iBarkResampled+1]/16) ) / (N1 + N2)
					// This is not suited to FastFloat - leave in float.
					Float fltP1, fltP2;
					Int iUnRsmpEnd = iUnResampleIndex( iMaskEnd, MRI );
					fflt  = ffltMaskPower10( rgiMaskQ[iMaskBand] );
					fltP1 = FLOAT_FROM_FASTFLOAT( fflt );
					fflt  = ffltMaskPower10( rgiMaskQ[iRsmpBand] );
					fltP2 = FLOAT_FROM_FASTFLOAT( fflt );
					flt   = ( (iUnRsmpEnd-iCurrStart)*fltP1*fltP1 + (iCurrEnd-iUnRsmpEnd)*fltP2*fltP2 ) / (iCurrEnd - iCurrStart);
					fltBandWeight[cNoiseBand] = flt;
					MONITOR_COUNT(gMC_GBW_floats,13);
				}
			}
			cNoiseBand++;
		}
        iCurrBand++;
	}
	for( iCurrBand = 0; iCurrBand < (cNoiseBand-1); iCurrBand++ )
	{	
		if ( fAllBandsSynced )
		{
			fflt = ffltMaskPower10( rgiMaskQ4BandNotCoded[iCurrBand] - rgiMaskQ4BandNotCoded[cNoiseBand-1] );
			flt  = FLOAT_FROM_FASTFLOAT( fflt );
			rgffltSqrtBWRatio[iCurrBand] = fflt;
			//// float SqrtBWRatio = fflt.iFraction*1.0F/(1<<fflt.iFracBits)
		}
		else
		{
			// This calculation is not ideally suited to FastFloat, leave in float for time being
			// But note that limited range of the result probably means it can be done more quickly
			flt = (Float)sqrt( fltBandWeight[iCurrBand] / fltBandWeight[cNoiseBand-1] );
			fflt = FASTFLOAT_FROM_FLOAT( flt );
			rgffltSqrtBWRatio[iCurrBand] = fflt;
			//// float SqrtBWRatio = fflt.iFraction*1.0F/(1<<fflt.iFracBits)
		}
		MONITOR_RANGE(gMR_rgffltSqrtBWRatio,FLOAT_FROM_FASTFLOAT(fflt));
		MONITOR_COUNT(gMC_GBW_floats,14);		// count sqrt as 10.
	}
	if (cNoiseBand > 0)
	{	// last band has a ratio of 1.0

#if defined(BUILD_INTEGER)
		rgffltSqrtBWRatio[cNoiseBand-1].iFraction = 0x40000000;
		rgffltSqrtBWRatio[cNoiseBand-1].iFracBits = 30;
#else
		rgffltSqrtBWRatio[cNoiseBand-1] = 1.0F;
#endif
		MONITOR_RANGE(gMR_rgffltSqrtBWRatio,1.0F);
	}

	assert (cNoiseBand < pau->m_cValidBarkBand);
	assert (pau->m_iFirstNoiseBand > 0);
	rgbBandNotCoded [0] = cNoiseBand;				// used as cNoiseBand
    FUNCTION_PROFILE_STOP(&fp);
}


#pragma warning (disable:4554)

//*********************************************************************************************************
// Verify CoefRecon MidRate
// Debug code which simulates V4 floating point code.
// If decoded inputs are in error, false verifications can occur.
// include this by defining VERIFY_DECODED_COEFS below or in the project file
//*********************************************************************************************************
//#define VERIFY_DECODED_COEFS
#if defined(_DEBUG) && defined(VERIFY_DECODED_COEFS)
#	pragma COMPILER_MESSAGE(__FILE__ "(837) : Warning - Inverse Quantize MidRate Verification Code Enabled.")
static int fIgnoreMRVerification = 0;		// avoid verify checks - set by hand in debugger only
static Float fltMidRateThreshold = 0.025F;		// change from the debugger
void VerifyCoefReconMR( CAudioObject* pau, PerChannelInfo* ppcinfo, 
					  int iRecon, int iBark, int iBarkResampled, I32 qrand, I32 iCoefRecon, int iCoefQ,
					  const U8* const rgbBandNotCoded, int iNoiseBand, int cNoiseBand, 
					  const Int* const rgiNoisePower, const FastFloat* const rgffltSqrtBWRatio, const int* const m_rgiBarkIndex )
{	// stolen and adapted from V4 
	if ( !fIgnoreMRVerification  )
	{
		Float fltiCoefRecon = (Float)iCoefRecon/(1<<TRANSFORM_FRACT_BITS);
		Float fltNoise = ((Float) qrand / (Float) 0x20000000);
		Float fltWeightRatio = (float)pow(10,(ppcinfo->m_rgiMaskQ[iBarkResampled] - ppcinfo->m_iMaxMaskQ)/16.0);
		double dblQuantStep = DOUBLE_FROM_QUANTSTEPTYPE(pau->m_qstQuantStep);
		Float dif, rel, fltCoefRecon;
		Float fltNoisePower;
		double dblWeightedQuant;
		if (!pau->m_fNoiseSub) {
			if (iRecon < pau->m_cLowCutOff  || iRecon >= pau->m_cHighCutOff) 
				fltCoefRecon = 0;
			else
    			fltCoefRecon = (Float)( (Float)iCoefQ  * ( dblWeightedQuant = fltWeightRatio * dblQuantStep ) );
		}
		else
		{
			if (iRecon < pau->m_cLowCutOff)  
			{
				fltNoise *= pau->m_fltDitherLevel;
				fltCoefRecon = (Float)(fltNoise * (dblWeightedQuant = fltWeightRatio * dblQuantStep ) );
			}
			else if (iRecon >= pau->m_iFirstNoiseIndex && iBark < NUM_BARK_BAND && rgbBandNotCoded [iBark] == 1 )
			{
				fltNoisePower = ((Float) pow (10, rgiNoisePower [iNoiseBand] / 20.0F)) * 
									FloatFromFastFloat( rgffltSqrtBWRatio[iNoiseBand] );
				fltCoefRecon = fltNoise * (Float)(dblWeightedQuant = fltNoisePower * fltWeightRatio);
			}
			else if ( iRecon >= pau->m_cHighCutOff )  
			{
				fltNoise *= pau->m_fltDitherLevel;
				fltCoefRecon = (Float)(fltNoise * (dblWeightedQuant = fltWeightRatio * dblQuantStep) );
			}
			else 
			{
				fltNoise *= pau->m_fltDitherLevel;
				fltCoefRecon = (Float)((iCoefQ + fltNoise) * (dblWeightedQuant = fltWeightRatio * dblQuantStep) );
			}
		}
		dif = (float) fabs(fltCoefRecon - fltiCoefRecon);
		rel = (float) fabs( (fabs(fltCoefRecon)>32) ? (dif/fltCoefRecon) : (dif/32) );
		if (rel > ((dblWeightedQuant>131072.0) ? 10.0f*fltMidRateThreshold : fltMidRateThreshold) )
			DEBUG_BREAK();
		else 
		{	// when magnitude of integer version is much larger than float, we sometimes see differences
			// expect some false triggers, but often there is a relevant difference
			dif = (float)( fabs(fltiCoefRecon) - fabs(fltCoefRecon) );
			rel = (float) fabs( (fabs(fltCoefRecon)>32) ? (dif/fltCoefRecon) : (dif/32) );
			if ( dif > 75.0f && rel > 0.000125f )		// verify with all1_22s_22
				DEBUG_BREAK();
			else if ( fabs(fltCoefRecon) > (2.0F*(1<<30)) )
				DEBUG_BREAK();	// Overflow that should have been caught above
		}
	}
	MONITOR_RANGE(gMR_CoefRecon,iCoefRecon/((Float)(1<<TRANSFORM_FRACT_BITS)));
	MONITOR_RANGE(gMR_WeightRatio, (float)pow(10,(ppcinfo->m_rgiMaskQ[iBarkResampled] - ppcinfo->m_iMaxMaskQ)/16.0));
	MONITOR_COUNT_CONDITIONAL(iCoefRecon==0,gMC_zeroCoefRecon,1);
#	if defined(PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST)
		if ( PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST <= iInvQuantFrameCount && iInvQuantFrameCount <= PRINT_INVERSE_QUANTIZE_AT_FRAME_LAST )
			MyOutputDbgStr(0,"%5d  %2d  %1d  %4d  %+16.6f\n", 
				iInvQuantFrameCount, iInvQuantSubFrameCount, ppcinfo-pau->m_rgpcinfo, iRecon, iCoefRecon/((Float)(1<<TRANSFORM_FRACT_BITS)) );
#	endif
}
#define VERIFY_COEF_RECON_MR(idx,qRand,cNBand,iBarkRsmp)																			\
	 VerifyCoefReconMR(	pau, ppcinfo, iRecon, iBark, iBarkRsmp, qRand, rgiCoefRecon[iRecon], rgiCoefQ[iCoefQ],						\
						rgbBandNotCoded, iNoiseBand, cNBand, rgiNoisePower, ppcinfo->m_rgffltSqrtBWRatio, pau->m_rgiBarkIndex )
#elif defined(_DEBUG) && defined(WMA_MONITOR)
#define VERIFY_COEF_RECON_MR(idx,qRand,cNBand,iBarkRsmp)																			\
	MONITOR_RANGE(gMR_CoefRecon,FLOAT_FROM_COEF(rgiCoefRecon[iRecon]));											\
	MONITOR_RANGE(gMR_WeightRatio, (float)pow(10,(ppcinfo->m_rgiMaskQ[iBarkRsmp] - ppcinfo->m_iMaxMaskQ)/16.0F));					\
	MONITOR_COUNT_CONDITIONAL(rgiCoefRecon[iRecon]==0,gMC_zeroCoefRecon,1);
#elif defined(PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST)
#define VERIFY_COEF_RECON_MR(idx,qRand,cNBand,iBarkRsmp)                                                                                \
	if ( PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST <= iInvQuantFrameCount && iInvQuantFrameCount <= PRINT_INVERSE_QUANTIZE_AT_FRAME_LAST )  \
		MyOutputDbgStr(0,"%5d  %2d  %1d  %4d  %+16.6f\n",                                                                                         \
			iInvQuantFrameCount, iInvQuantSubFrameCount, ppcinfo-pau->m_rgpcinfo, iRecon, FLOAT_FROM_COEF(rgiCoefRecon[iRecon]) )
#else	// so not ( defined(_DEBUG) && defined(VERIFY_DECODED_COEFS) )
#define VERIFY_COEF_RECON_MR(idx,qRand,cNBand,iBarkRsmp)
#endif	// defined(_DEBUG) && defined(VERIFY_DECODED_COEFS)


// **********************************************************************
// Macros for DecodeCoefsMidRate with combined INTEGER and INT_FLOAT code

#if defined(BUILD_INTEGER)

#define MASK_X_QUANT(iLevel,ffltQuantizer) MULT_HI(((iLevel)<<16),ffltQuantizer.iFraction)
#define RAND_X_QUANT(rnd,ffltQuantizer) MULT_HI((rnd),ffltQuantizer.iFraction)
#define UNNORMED_MULT(fflt,c,shift) \
	fflt.iFraction = MULT_HI( fflt.iFraction, c );	\
	fflt.iFracBits += shift;

// SCALE_COEF_RECON shifts CoefRecon to give it TRANSFORM_FRACT_BITS==5 fractional bits
#if defined(PLATFORM_OPTIMIZE_MINIMIZE_BRANCHING)
	// This SCALE_COEF_RECON macro requires 6 ops and no branches
	// This SETUP_FOR_SCALE_COEF_RECON requires 5 ops plus 1 branch.
	// SCALE_COEFFICENT gets executed 25x as often as SETUP_FOR_SCALE_COEF_RECON, 
	// so this method requires 6.2 ops plus 0.04 branches per SCALE_COEFFICENT
#	define SCALE_COEF_RECON(iCR) ((((iCR)>>-iShift) & iMask2) | (((iCR)<<iShift) & iMask1))
//#	define SETUP_FOR_SCALE_COEF_RECON(iFB) iShift = iFB-TRANSFORM_FRACT_BITS;  \
//								      iMask2 = 0xFFFFFFFF ^ (iMask1 = (iShift>=0) ? 0xFFFFFFFF : 0)
// See comment below
#	define SETUP_FOR_SCALE_COEF_RECON(fftQ) iShift = fftQ.iFracBits-TRANSFORM_FRACT_BITS;  \
								      iMask2 = 0xFFFFFFFF ^ (iMask1 = (iShift>=0) ? 0xFFFFFFFF : 0)

#else
	// When branching is not a high penaty activity, do it the simplier way
	//   iCoefRecon = (t=iFracBits-5)<0 ? iCoefRecon>>-t : iCoefRecon<<t
	// This SCALE_COEF_RECON requires 3 ops plus 1 branch or 2 ops plus 1 branch.  
	// This SETUP_FOR_SCALE_COEF_RECON requires 2 ops
	// SCALE_COEFFICENT gets executed 25x as often as SETUP_FOR_SCALE_COEF_RECON, 
	// so this method requires 2.58 ops plus 0.04 branches per SCALE_COEFFICENT
	// On one test on a 500 MHz Pentium 686, this way saves 1% execution time over masking.
#	define SCALE_COEF_RECON(iCR) (iShift<0) ? (iCR)<<-iShift : (iCR)>>iShift
//#	define SETUP_FOR_SCALE_COEF_RECON(iFB) iShift=iFB-TRANSFORM_FRACT_BITS
// This more complex setup (with pre-normalization) is required to deal with 56_WMAv2.wma which ends
// with 1.5 seconds of DC bias at -890.  This results in a single large coef at 0 and the rest 0.
// Then in the noise band, iShift tries to be == 33...
#	define SETUP_FOR_SCALE_COEF_RECON(fftQ) \
    while( fftQ.iFracBits > (30+TRANSFORM_FRACT_BITS) ) { fftQ.iFracBits--; fftQ.iFraction>>=1; } \
    iShift=fftQ.iFracBits-TRANSFORM_FRACT_BITS;
#endif

#define COEF_PLUS_NOISE_FRAC_BITS 22
#define DITHER_FRAC_BITS 35
#define RAND_FRAC_BITS 29
#define MORE_WF_FRAC_BITS 0

#define RAND_TO_NOISE(qr) qr

// Inverse Quantize for "normal" case of CoefQ and Noise Dithering
static INLINE void CoefPlusNoiseInvQuant( const Int iRecon, const Int iCoefQ, I32 qrand, 
										  const I16* rgiCoefQ, I32* rgiCoefRecon, FastFloat ffltQuantizer, Int iShift )
{
	Int iNoise, iCoefPlusNoise, iCoefRecon;
	
	// Multiply by Dither and align iNoise fractional bits to be COEF_PLUS_NOISE_FRAC_BITS == 22
	iNoise = MULT_HI(cDitherFactorMR,qrand)>>((DITHER_FRAC_BITS+RAND_FRAC_BITS-31)-COEF_PLUS_NOISE_FRAC_BITS);
	//// Float Noise = iNoise/(1.0F*(1<<22))
	if ( abs(rgiCoefQ[iCoefQ]) >= (1<<(31-COEF_PLUS_NOISE_FRAC_BITS))  )
	{	// rare, but it does happen occasionally (e.g. tough_32m_32)
		Int iFB = 0;
		UInt uiCoefQ = abs(rgiCoefQ[iCoefQ]);
		while( uiCoefQ >= (1<<(31-COEF_PLUS_NOISE_FRAC_BITS)) )
		{
			uiCoefQ >>= 1;
			iFB++;
		}
		iCoefPlusNoise = (rgiCoefQ[iCoefQ]<<(COEF_PLUS_NOISE_FRAC_BITS-iFB)) + (iNoise>>iFB);
		//// Float Coef+Noise = iCoefPlusNoise/(1.0F*(1<<(22-iFB)))
		iCoefRecon = MULT_HI( iCoefPlusNoise, ffltQuantizer.iFraction );
		//// Float qrand = qrand/(1024.0F*(1<<25))
#if defined(BUILD_INTEGER)
        ffltQuantizer.iFracBits -= iFB;
		SETUP_FOR_SCALE_COEF_RECON(ffltQuantizer);
        ffltQuantizer.iFracBits += iFB;
#endif
		rgiCoefRecon [iRecon] = SCALE_COEF_RECON(iCoefRecon);
		//// Float CoefRecon = rgiCoefRecon[iRecon]/32.0F
		SETUP_FOR_SCALE_COEF_RECON(ffltQuantizer);
	}
	else
	{
		iCoefPlusNoise = (rgiCoefQ[iCoefQ]<<COEF_PLUS_NOISE_FRAC_BITS) + iNoise;	
		//// Float Coef+Noise = iCoefPlusNoise/(1.0F*(1<<22))
		iCoefRecon = MULT_HI( iCoefPlusNoise, ffltQuantizer.iFraction );
		//// Float qrand = qrand/(1024.0F*(1<<25))
		rgiCoefRecon [iRecon] = SCALE_COEF_RECON(iCoefRecon);
		//// Float CoefRecon = rgiCoefRecon[iRecon]/32.0F
	}
}

#else   // so must be BUILD_INT_FLOAT

#define MASK_X_QUANT(iLevel,ffltQuantizer) ((iLevel)*(ffltQuantizer))
#define RAND_X_QUANT(rnd,ffltQuantizer) ((rnd)*(ffltQuantizer))
#define UNNORMED_MULT(flt,c,shift) flt *= c

//#ifndef _XBOX
const Float cfltInverseRand2Float = 1.0f/0x20000000;		// 2^-29
//#else  // not needed anymore? // IW
//extern const Float cfltInverseRand2Float;
//#endif
#define RAND_TO_NOISE(qr) (qr * cfltInverseRand2Float)

// Inverse Quantize for "normal" case of CoefQ and Noise Dithering
#ifdef HITACHI
#pragma inline(CoefPlusNoiseInvQuant)
static  void CoefPlusNoiseInvQuant( const Int iRecon, const Int iCoefQ, I32 qrand, 
										  const I16* rgiCoefQ, CoefType* rgiCoefRecon, QuantFloat qfltQuantizer, Int iShift )
#else
static INLINE void CoefPlusNoiseInvQuant( const Int iRecon, const Int iCoefQ, I32 qrand, 
										  const I16* rgiCoefQ, CoefType* rgiCoefRecon, QuantFloat qfltQuantizer, Int iShift )
#endif
{
	Float fltNoise =  qrand * (cDitherFactorMR * cfltInverseRand2Float);
	rgiCoefRecon [iRecon] = (rgiCoefQ[iCoefQ] + fltNoise) * qfltQuantizer;
}

#endif


WMARESULT prvInitNoiseSub (CAudioObject* pau)
{
    Int iWin, iBand;
    Float fltSamplingPeriod;

    Int *piBarkIndex;
    Int cFrameSample;
    Int iNoiseIndex;

    pau->m_fNoiseSub = WMAB_TRUE;
    pau->m_fltFirstNoiseFreq = (Float)(pau->m_iSamplingRate*0.5f);
    // adjust...
    // HongCho: This is related to Bark bands (re-adjust when Bark bands change)
    if(pau->m_iVersion == 1) {

        // version 1 was incorrectly using the inequalities...
        // do not change!!!

        if(pau->m_iSamplingRate == 22050) {
            // somewhat different parameters...
            if (pau->m_fltWeightedBitsPerSample >= 1.16f)
                pau->m_fNoiseSub = WMAB_FALSE;
            else if(pau->m_fltWeightedBitsPerSample >= 0.72f)
                pau->m_fltFirstNoiseFreq *= (Float)0.70;
            else
                pau->m_fltFirstNoiseFreq *= (Float)0.60;
        }
        else if (pau->m_iSamplingRate == 44100) {
            if (pau->m_fltWeightedBitsPerSample >= 0.61f)
                pau->m_fNoiseSub = WMAB_FALSE;
            else
                pau->m_fltFirstNoiseFreq *= (Float) 0.4;
        }
        else if (pau->m_iSamplingRate == 16000) {
            if (pau->m_fltBitsPerSample <= 0.5f)
                pau->m_fltFirstNoiseFreq *= (Float) 0.30;
            else {
                pau->m_fltFirstNoiseFreq *= (Float) 0.50;
                pau->m_iNoisePeakIgnoreBand = 3;
            }
        }
        else if (pau->m_iSamplingRate == 11025) {
            assert(1 == pau->m_iNoisePeakIgnoreBand);
            pau->m_fltFirstNoiseFreq *= (Float) 0.70;
            if (pau->m_fltBitsPerSample >= 0.9f)
                pau->m_iNoisePeakIgnoreBand = 3;
        }
        else if (pau->m_iSamplingRate == 8000) {
            assert(1 == pau->m_iNoisePeakIgnoreBand);
            if (pau->m_fltBitsPerSample <=0.625f)
                pau->m_fltFirstNoiseFreq *= (Float) 0.50;
            else if (pau->m_fltBitsPerSample <= 0.75f)
                pau->m_fltFirstNoiseFreq *= (Float) 0.65;
            else
                pau->m_fNoiseSub = WMAB_FALSE;
        }
        else {
            if(pau->m_fltBitsPerSample >= 0.8f)
                pau->m_fltFirstNoiseFreq *= (Float)0.75;
            else if(pau->m_fltBitsPerSample >= 0.6f)
                pau->m_fltFirstNoiseFreq *= (Float)0.60;
            else
                pau->m_fltFirstNoiseFreq *= (Float)0.5;
        }

    }
    else {

        // for newer versions...  more correct using inequality...

        if (pau->m_iSamplingRate >= 44100) {
            if (pau->m_fltWeightedBitsPerSample >= 0.61f)
                pau->m_fNoiseSub = WMAB_FALSE;
            else
                pau->m_fltFirstNoiseFreq *= (Float) 0.4;
        }
        else if(pau->m_iSamplingRate >= 22050) {
            // somewhat different parameters...
            if (pau->m_fltWeightedBitsPerSample >= 1.16f)
                pau->m_fNoiseSub = WMAB_FALSE;
            else if(pau->m_fltWeightedBitsPerSample >= 0.72f)
                pau->m_fltFirstNoiseFreq *= (Float)0.70;
            else
                pau->m_fltFirstNoiseFreq *= (Float)0.60;
        }
        else if (pau->m_iSamplingRate >= 16000) {
            if (pau->m_fltBitsPerSample <= 0.5f)
                pau->m_fltFirstNoiseFreq *= (Float) 0.30;
            else {
                pau->m_fltFirstNoiseFreq *= (Float) 0.50;
                pau->m_iNoisePeakIgnoreBand = 3;
            }
        }
        else if (pau->m_iSamplingRate >= 11025) {
            assert(1 == pau->m_iNoisePeakIgnoreBand);
            pau->m_fltFirstNoiseFreq *= (Float) 0.70;
            if (pau->m_fltBitsPerSample >= 0.9f)
                pau->m_iNoisePeakIgnoreBand = 3;
        }
        else if (pau->m_iSamplingRate >= 8000) {
            assert(1 == pau->m_iNoisePeakIgnoreBand);
            if (pau->m_fltBitsPerSample <=0.625f)
                pau->m_fltFirstNoiseFreq *= (Float) 0.50;
            else if (pau->m_fltBitsPerSample <= 0.75f)
                pau->m_fltFirstNoiseFreq *= (Float) 0.65;
            else
                pau->m_fNoiseSub = WMAB_FALSE;
        }
        else {
            if(pau->m_fltBitsPerSample >= 0.8f)
                pau->m_fltFirstNoiseFreq *= (Float)0.75;
            else if(pau->m_fltBitsPerSample >= 0.6f)
                pau->m_fltFirstNoiseFreq *= (Float)0.60;
            else
                pau->m_fltFirstNoiseFreq *= (Float)0.5;
        }
    }

	if (!pau->m_fNoiseSub)
        return WMA_OK;

    pau->m_rgiFirstNoiseBand = (Int*) auMalloc (sizeof (Int) * pau->m_cPossibleWinSize);
    if(pau->m_rgiFirstNoiseBand == NULL)
        return TraceResult(WMA_E_OUTOFMEMORY);
    pau->m_rgbBandNotCoded	= (U8*) auMalloc (pau->m_cValidBarkBand * pau->m_cChannel);	
    if (pau->m_rgbBandNotCoded == NULL)
        return TraceResult(WMA_E_OUTOFMEMORY);
    pau->m_rgiNoisePower	= (Int*) auMalloc (sizeof (Int) * pau->m_cValidBarkBand * pau->m_cChannel);
    if (pau->m_rgiNoisePower == NULL)
        return TraceResult(WMA_E_OUTOFMEMORY);
#ifndef BUILD_INTEGER
    pau->m_rgfltBandWeight	= (Float*) auMalloc (sizeof (Float) * pau->m_cValidBarkBand * pau->m_cChannel);
    if (pau->m_rgfltBandWeight == NULL)
        return TraceResult(WMA_E_OUTOFMEMORY);
#endif
    pau->m_rgffltSqrtBWRatio	= (FastFloat*) auMalloc (sizeof (FastFloat) * pau->m_cValidBarkBand * pau->m_cChannel);
    if (pau->m_rgffltSqrtBWRatio == NULL)
        return TraceResult(WMA_E_OUTOFMEMORY);

    //calculate index of each bark freq
    fltSamplingPeriod = 1.0F / pau->m_iSamplingRate;
    // wchen: we need to think what to do with the cut off frequencies: not include at all or include zeros.
    //for long window
    piBarkIndex = pau->m_rgiBarkIndexOrig;

    // for the v1 compatibility
    if(pau->m_iVersion == 1)
    {
        // precalculate the first noise bands
        // wchen: who put these two lines here? No use!
        //pau->m_rgiFirstNoiseBand[0] = (Int)(pau->m_fltFirstNoiseFreq*pau->m_cFrameSample*fltSamplingPeriod + 0.5);
        //if(pau->m_rgiFirstNoiseBand[0] > pau->m_cSubband) pau->m_rgiFirstNoiseBand[0] = pau->m_cSubband;
        for(iBand = 0; iBand < pau->m_rgcValidBarkBand[0]; iBand++) {
            if(g_rgiBarkFreq[iBand] > (Int)pau->m_fltFirstNoiseFreq) {
                pau->m_rgiFirstNoiseBand[0] = iBand;
                break;
            }
        }
        // if not there, turn it off...
        if(iBand == pau->m_rgcValidBarkBand[0])
            pau->m_fNoiseSub = WMAB_FALSE;
    }
    else
    {
        for (iWin = 0; iWin < pau->m_cPossibleWinSize; iWin++)    {
            // precalculate the first noise bands
            pau->m_rgiFirstNoiseBand[iWin] = pau->m_rgcValidBarkBand[iWin] - 1;// init to max...
            cFrameSample = pau->m_cFrameSample / (1 << iWin);
            iNoiseIndex = (Int)(pau->m_fltFirstNoiseFreq*cFrameSample*fltSamplingPeriod + 0.5f);
            for(iBand = 1; iBand < pau->m_rgcValidBarkBand[iWin]; iBand++) {
                if(piBarkIndex[iBand] > iNoiseIndex) {
                    pau->m_rgiFirstNoiseBand[iWin] = iBand - 1;
                    break;
                }
            }
            piBarkIndex +=  NUM_BARK_BAND + 1;
        }
    }
    pau->m_iFirstNoiseBand = pau->m_rgiFirstNoiseBand[0];    
    return WMA_OK;
}

//#define PRINT_RESAMPLE_WEIGHT_FACTOR 100000000
#	ifdef PRINT_RESAMPLE_WEIGHT_FACTOR
		// this function must be defined in fft.c
		extern void DebugDctPrintCoefs(CAudioObject* pau, int def, int id, float fac, CoefType* pfCoef);
#		define WFR_PRINT(id,pfCoef)  \
		DebugDctPrintCoefs(pau,PRINT_RESAMPLE_WEIGHT_FACTOR,id,1.0f*(1<<WEIGHTFACTOR_FRACT_BITS),(CoefType*)pfCoef)
#   else
#       define WFR_PRINT(id,pfCoef)
#   endif

Void auResampleWeightFactorLPC (CAudioObject* pau, PerChannelInfo* ppcinfo)
{
    Int iRatio;
    Int i, j;

    UInt*  rguiWeightFactor = ppcinfo->m_rguiWeightFactor;
    Int iSizeSrc = pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame - 1];
    Int iSizeDst = pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame];
    assert (pau->m_iCurrSubFrame > 0);
#ifndef BUILD_INTEGER
	assert( sizeof(Int) == sizeof(Float) );		// rgfltWegihtFactor == rgiWeightFactor
#endif

    // This should only be called for LPC mode. Bark mode resamples weight factor
    // from the original weight factor array to avoid losing information.
    assert(LPC_MODE == pau->m_iWeightingMode);

    if (iSizeSrc > iSizeDst) {
        //downsample
        iRatio = iSizeSrc / iSizeDst;
        i = 0;
        while (i < pau->m_cSubband) {
            rguiWeightFactor [i] = rguiWeightFactor [i * iRatio];
            i++;
        }
    }
    else if (iSizeSrc < iSizeDst) {
        //upsample
        iRatio = iSizeDst / iSizeSrc;
        i = pau->m_cSubband / iRatio - 1;
        while (i >= 0) {
            for (j = 0; j < iRatio; j++)    {
                rguiWeightFactor [i * iRatio + j] = rguiWeightFactor [i];
            }
            i--;
        }                
    }
    //if == don't need to do anything
	WFR_PRINT(iSizeSrc > iSizeDst ? 5 :(iSizeSrc < iSizeDst ? 6 : 7),rguiWeightFactor);
}


//**************************************************************************************************
//
// prvInverseQuantizeMidRate handles only MidRate inverse quantization
//
// rgiWeightFactor is not used.
//
//**************************************************************************************************
WMARESULT prvInverseQuantizeMidRate (CAudioObject* pau, PerChannelInfo* ppcinfo, Int* rgiWeightFactor)
{
	Int iBark = 0;					// index barks using natural scale for this cSubband (at this sampling frequency)
	Int iBarkResampled = 0;			// index barks using resampled scale from cSubbands when the MaskQ's were last updated
	Int iCoefQ = 0;
	Int iRecon = 0;
    const I16* rgiCoefQ				= ppcinfo->m_rgiCoefQ;
    const U8*  rgbBandNotCoded		= ppcinfo->m_rgbBandNotCoded;
    const Int* rgiNoisePower		= ppcinfo->m_rgiNoisePower;
	const FastFloat* rgffltSqrtBWRatio	= ppcinfo->m_rgffltSqrtBWRatio;
	const Int* rgiMaskQ				= ppcinfo->m_rgiMaskQ;
	const Int  iMaxMaskQ			= ppcinfo->m_iMaxMaskQ;
    const Int *rgiBarkIndex;
	const Int *rgiBarkIndexResampled;
    CoefType* rgiCoefRecon			= (CoefType*)ppcinfo->m_rgiCoefRecon;
	CoefType iCoefRecon; 
    Int qrand, iReconTarget;
    U8  cNoiseBand = rgbBandNotCoded [0];
    Int iNoiseBand = 0;
    QuantFloat qfltQuantizer;
	MaskResampleInfo MRI;
#if defined(PLATFORM_OPTIMIZATION_MINIMIZE_BRANCHING) && defined(BUILD_INTEGER)
    Int iMask1, iMask2;
#endif
    Int iShift = 0;
    Bool *rgfMaskNeededForBark;
	// A mask value of a bark should be preserved if that bark:
	// (1) is needed for mask resampling,
	// (2) not coded (noise substituted),
	// (3) has a coded coeff with non-zero value,
	// (4) or has the maximum mask value used in normalization.
    
    FUNCTION_PROFILE(fp);
    FUNCTION_PROFILE_START(&fp,INVERSE_QUAN_MID_RATE_PROFILE);

    if (NULL != ppcinfo->ppcinfoENC)
        rgfMaskNeededForBark = ppcinfo->m_rgfMaskNeededForBark;
    else
        rgfMaskNeededForBark = NULL;


	DEBUG_BREAK_AT_FRAME_INV_QUANT;
	MONITOR_COUNT(gMC_IQ,1);
    assert (pau->m_fNoiseSub &&  pau->m_iWeightingMode == BARK_MODE);
    assert(TRANSFORM_FRACT_BITS==5);
    assert (pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame] != 0);         
    // assert (pau->m_cFrameSampleHalf <= (1<<MASKQ_RESAMPLE_OFFSET));       // why???                                  
    assert (pau->m_iSubFrameSizeWithUpdate != 0);                                           
	assert( pau->m_cPossibleWinSize <= MASKQ_RESAMPLE_OFFSET );
    
    // Initially, no bark-mask needs to be preserved.
    if (NULL != rgfMaskNeededForBark)
        memset(rgfMaskNeededForBark, 0, 25 * sizeof(Bool));
    
	// handle changing subFrame window sizes by resampling the indexes
    MRI.iMaskResampleRatio = (pau->m_iSubFrameSizeWithUpdate << MASKQ_RESAMPLE_OFFSET) /                           
                          pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame];    
    
	MRI.iMaskResampleRatioPow = LOG2(MRI.iMaskResampleRatio);
    rgiBarkIndexResampled     = pau->m_rgiBarkIndexOrig + (NUM_BARK_BAND + 1) *                    
                                  LOG2 (pau->m_cFrameSampleHalf / pau->m_iSubFrameSizeWithUpdate);   
    MRI.cValidBarkBandLatestUpdate = pau->m_rgcValidBarkBand [LOG2 (pau->m_cFrameSampleHalf / pau->m_iSubFrameSizeWithUpdate)];

	rgiBarkIndex  = pau->m_rgiBarkIndexOrig + (NUM_BARK_BAND + 1) * pau->m_iIncr;  

	prvGetBandWeightMidRate (pau, ppcinfo, rgiBarkIndex, rgiBarkIndexResampled, MRI);

    //Scan for the first bark index = note iRecon is 0 and rgiBarkIndex[1] ==0 for 16000 Hz and 11025 Hz frames with 128 or 64 samples
	prvScanForNextBarkIndex( iRecon, &iBarkResampled, pau->m_cLowCutOff, rgiBarkIndexResampled, MRI );
	while( iRecon >= rgiBarkIndex[iBark+1] )
		iBark++;

	if (iRecon < pau->m_cLowCutOff ) {
		// not integerized since cLowCutOff is typically 0, so this is here for compatability with V1 
		Double dblQuantStep = DOUBLE_FROM_QUANTSTEPTYPE(pau->m_qstQuantStep);
		Float fltCoefRecon;
		while  (iRecon < pau->m_cLowCutOff) 	{
			Float fltNoise = pau->m_fltDitherLevel * ((Float) quickRand (&(pau->m_tRandState)) / (Float) 0x20000000);//rgfltNoise [iRecon];
			Float fltWeightRatio = (float)pow(10.0f,(rgiMaskQ[iBarkResampled] - iMaxMaskQ)/16.0f);
			fltCoefRecon  = (Float) (fltNoise * fltWeightRatio * dblQuantStep);
			rgiCoefRecon [iRecon] = COEF_FROM_FLOAT(fltCoefRecon);
			MONITOR_COUNT(gMC_IQ_Float,9);
			iRecon++;
		}
	}

    while  (iRecon < pau->m_iFirstNoiseIndex) 
    {
        iReconTarget = prvScanForNextBarkIndex( iRecon, &iBarkResampled, pau->m_iFirstNoiseIndex, rgiBarkIndexResampled, MRI );
        
        qfltQuantizer = prvWeightedQuantization( pau, ppcinfo, iBarkResampled );
        INTEGER_ONLY( qfltQuantizer.iFracBits += COEF_PLUS_NOISE_FRAC_BITS - 31 );      // Account for MULT_HI in loop below
        //// Float Quantizer = qfltQuantizer.iFraction/(512.0F*(1<<qfltQuantizer.iFracBits)
        SETUP_FOR_SCALE_COEF_RECON(qfltQuantizer);              
        
        while ( iRecon < iReconTarget )
        {   
            //  CoefRecon[iR] = (CoefQ[iQ] + rand()*DitherLevel) * (10^(1/16)) ^ (MaskQ[iB]-Max(MaskQ[])) * (10^(1/20)) ^ QuantStepSize
            qrand = quickRand (&(pau->m_tRandState));       
            //// Float qrand = qrand/(1024.0F*(1<<25))
            CoefPlusNoiseInvQuant( iRecon, iCoefQ, qrand, rgiCoefQ, rgiCoefRecon, qfltQuantizer, iShift );
            //// Float CoefRecon = rgiCoefRecon[iRecon]/32.0F
            
            VERIFY_COEF_RECON_MR(iRecon,qrand,-1,iBarkResampled);

            if (NULL != rgfMaskNeededForBark && rgiCoefQ[iCoefQ])
                rgfMaskNeededForBark[iBark] = WMAB_TRUE;
            
            iRecon++;
            iCoefQ++;
        }
        if (iResampleIndex (iRecon+1, MRI) >= rgiBarkIndexResampled [iBarkResampled+1]) 
            iBarkResampled++;       // normal to increment except when hitting FirstNoiseIndex
        while( iRecon >= rgiBarkIndex[iBark+1] )
            iBark++;
    }
    
    while  (iRecon < pau->m_cHighCutOff) 
    {   // These Bands may or may not be coded, treat as appropriate
        
        if ( (rgbBandNotCoded [iBark] == 1))
        {   
            Int iLoopMax;
            
            
            // CoefRecon[iR] = rand() * ((10^(1/16)) ^ (MaskQ[iB]-Max(MaskQ[])) * sqrt( BandWeight[iN]/BandWeight[cN-1] ) * ((10^(1/20)) ^ NoisePower[iN])
            // Note BandsNotCoded span whole "natural" bark bands, which are not resampled and are not limited by m_cHighCutOff
            FastFloat ffltMaskPower, ffltNoisePower;
            
            if (NULL != rgfMaskNeededForBark)
                rgfMaskNeededForBark[iBark] = WMAB_TRUE;

            assert( iNoiseBand < cNoiseBand );
            
            // auCalcQuantStep( rgiNoisePower[iNoiseBand], &ffltNoisePower.iFraction, &ffltNoisePower.iFracBits );
            ffltNoisePower = FASTFLOAT_FROM_QUANTSTEPTYPE( qstCalcQuantStep( rgiNoisePower[iNoiseBand] ) );
            ffltNoisePower = FASTFLOAT_MULT( ffltNoisePower, rgffltSqrtBWRatio[iNoiseBand] );
            //// Float Noise Power = ffltNoisePower.iFraction/(4.0F*(1<<ffltNoisePower.iFracBits))
            
            iLoopMax = min(rgiBarkIndex[iBark+1], pau->m_cHighCutOff);
            while(iRecon < iLoopMax)
            {
                ffltMaskPower = ffltMaskPower10( rgiMaskQ[iBarkResampled] - iMaxMaskQ );
                //// Float Mask Power = ffltMaskPower.iFraction/(1.0F*(1<<ffltMaskPower.iFracBits))
                
                qfltQuantizer = FASTFLOAT_MULT( ffltMaskPower, ffltNoisePower );
                INTEGER_ONLY( qfltQuantizer.iFracBits += (RAND_FRAC_BITS - 31) );       // Account for MULT_HI in loop below
                //// Float Quantizer = qfltQuantizer.iFraction/(4.0F*(1<<qfltQuantizer.iFracBits))
                SETUP_FOR_SCALE_COEF_RECON(qfltQuantizer);
                
                iReconTarget = prvScanForNextBarkIndex( iRecon, &iBarkResampled, iLoopMax, rgiBarkIndexResampled, MRI );
                while ( iRecon < iReconTarget )
                {   
                    qrand = quickRand (&(pau->m_tRandState));
                    //// Float qrand = qrand/(1024.0F*(1<<25))
                    iCoefRecon = RAND_X_QUANT( RAND_TO_NOISE(qrand), qfltQuantizer );
                    //// Float CoefRecon = iCoefRecon/(1.0F*(1<<qfltQuantizer.iFracBits))
                    rgiCoefRecon [iRecon] = SCALE_COEF_RECON(iCoefRecon);
                    //// Float CoefRecon = rgiCoefRecon[iRecon]/32.0F
                    
                    VERIFY_COEF_RECON_MR(iRecon,qrand,cNoiseBand,iBarkResampled);
                    
                    iRecon++;
                }
                if (iResampleIndex (iRecon+1, MRI) >= rgiBarkIndexResampled [iBarkResampled+1]) 
                    iBarkResampled++;       // normal to increment except when hitting end of Bark Band
            }
            iNoiseBand++;
        }
        else 
        {   // This Band is Coded (just like those before FirstNoiseIndex)
            // CoefRecon[iR] = (CoefQ[iQ] + rand()*DitherLevel) * 10^(MaskQ[iB]-Max(MaskQ[]))*2.5*0.5/20 * 10^(QuantStepSize/20)
            iReconTarget = prvScanForNextBarkIndex( iRecon, &iBarkResampled, pau->m_cHighCutOff, rgiBarkIndexResampled, MRI );
            if ( iReconTarget > rgiBarkIndex [iBark + 1] )
                iReconTarget = rgiBarkIndex [iBark + 1];        
            qfltQuantizer = prvWeightedQuantization( pau, ppcinfo, iBarkResampled );
            //// Float Quantizer = qfltQuantizer.iFraction/(1.0F*(1<<qfltQuantizer.iFracBits))
            // account for MULT_HI in loop below
            INTEGER_ONLY( qfltQuantizer.iFracBits += COEF_PLUS_NOISE_FRAC_BITS - 31 );
            //// Float Quantizer = qfltQuantizer.iFraction/(512.0F*(1<<qfltQuantizer.iFracBits))
            SETUP_FOR_SCALE_COEF_RECON(qfltQuantizer);
            
            while ( iRecon < iReconTarget )
            {   
                //  CoefRecon[iR] = (CoefQ[iQ] + rand()*DitherLevel) * (10^(1/16)) ^ (MaskQ[iB]-Max(MaskQ[])) * (10^(1/20)) ^ QuantStepSize
                qrand = quickRand (&(pau->m_tRandState));
                //// Float qrand = qrand/(1024.0F*(1<<25))
                CoefPlusNoiseInvQuant( iRecon, iCoefQ, qrand, rgiCoefQ, rgiCoefRecon, qfltQuantizer, iShift );
                //// Float CoefRecon = rgiCoefRecon[iRecon]/32.0F
                
                if (NULL != rgfMaskNeededForBark && rgiCoefQ[iCoefQ])
                    rgfMaskNeededForBark[iBark] = WMAB_TRUE;

                VERIFY_COEF_RECON_MR(iRecon,qrand,-1,iBarkResampled);
                
                iRecon++;
                iCoefQ++;
            }
        }
        if (iResampleIndex (iRecon+1, MRI) >= rgiBarkIndexResampled [iBarkResampled+1]) 
            iBarkResampled++;       // normal to increment except when hitting HighCutOff
        while( iRecon >= rgiBarkIndex[iBark+1] )
            iBark++;
    }
    
    iReconTarget = pau->m_cSubband;
    if  (iRecon < iReconTarget) 
    {   //  CoefRecon[iR] = rand() * DitherLevel * (10^(1/16)) ^ (MaskQ[iB for HighCutOff-1]-Max(MaskQ[])) * (10^(1/20)) ^ QuantStepSize
        // We may have scaned past m_cHighCutOff doing a BandNotCoded, so search back to find it.
        while ( (((pau->m_cHighCutOff-1) << MRI.iMaskResampleRatioPow) >> MASKQ_RESAMPLE_OFFSET) < rgiBarkIndexResampled [iBarkResampled] ) 
            --iBarkResampled;
        
        qfltQuantizer = prvWeightedQuantization( pau, ppcinfo, iBarkResampled );
        //// Float Quantizer = qfltQuantizer.iFraction/(1.0F*(1<<qfltQuantizer.iFracBits))
        UNNORMED_MULT( qfltQuantizer, cDitherFactorMR, (DITHER_FRAC_BITS - 31) + (RAND_FRAC_BITS - 31) );
        //// Float Quantizer = qfltQuantizer.iFraction/(4.0F*(1<<qfltQuantizer.iFracBits))
        SETUP_FOR_SCALE_COEF_RECON(qfltQuantizer);
        
        while ( iRecon < iReconTarget )
        {   
            qrand = quickRand (&(pau->m_tRandState));
            //// Float qrand = qrand/(1024.0F*(1<<25))
            iCoefRecon = RAND_X_QUANT( RAND_TO_NOISE(qrand), qfltQuantizer );
            //// Float CoefRecon = iCoefRecon/(1.0F*(1<<qfltQuantizer.iFracBits))
            rgiCoefRecon [iRecon] = SCALE_COEF_RECON(iCoefRecon);
            //// Float CoefRecon = rgiCoefRecon[iRecon]/32.0F
            
            VERIFY_COEF_RECON_MR(iRecon,qrand,cNoiseBand,iBarkResampled);
            
            iRecon++;
        }
    }

#   if defined(REFERENCE_RAND_24) || defined(REFERENCE_RAND_16)
        // call the random generator one extra time per subframe to improve subband randomness
        quickRand (&(pau->m_tRandState));
#   endif

        // rgfMaskNeededForBark[bark corresponding to HighCutOff-1 should be made true. 
        if (NULL != rgfMaskNeededForBark)
        {
            for (iBark = pau->m_rgcValidBarkBand [pau->m_iIncr]-1; iBark >= 0; iBark--) {
                if ((pau->m_cHighCutOff >= rgiBarkIndex[iBark]) && (pau->m_cHighCutOff < rgiBarkIndex[iBark+1])) {
                    rgfMaskNeededForBark[iBark] = WMAB_TRUE;
                    break; 
                }
            }
        }
    
    FUNCTION_PROFILE_STOP(&fp);
	return WMA_OK;
}


#pragma warning (default:4554)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\lpc.c ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    MsAudio.cpp

Abstract:

    Implementation of public member functions for CAudioObject.

Author:

    Wei-ge Chen (wchen) 16-November-1998

Revision History:

    Sil Sanders (sils) 8-Feb-00 - combine Integer and Float versions and simplify


*************************************************************************/
#if defined(ENABLE_ALL_ENCOPT) && defined(ENABLE_LPC)

#include "bldsetup.h"

#if !defined(_WIN32_WCE) && !defined(HITACHI)
#include <time.h>
#endif  // _WIN32_WCE
#include <math.h>
#include <limits.h>
#include "msaudio.h"
#include "stdio.h"
#include "AutoProfile.h"
#include "float.h"


// *** one of these may be set by platform in macros.h ***
//// in performance figures an X86 tick = 1/1193182 seconds = 838 ns (500MHz Pentium Dell 610)
//// and a SH4 Tick = 80ns (Dreamcast SH4 200Mhz)
//// X86 tested with wmadec_s Release build w/ PROFILE and wmatest_sh4 Release Build with PROFILE

// **************** warning ***************************
// every time you change one of these PLATFORM_LPC defines below, you must rebuilt all!
// ****************************************************

// A pruned or decomposed FFT - fast (old default)
// But uses an excess amount of cache
//#define PLATFORM_LPC_PRUNED_NONREDUNDANT
//// X86 Tough_32s_22:  1,376,277               Tough_16m_16:    556,708
//// SH4 Tough_32s_22: 22,842,016               Tough_16m_16:  8,488,652

// A pruned or decomposed FFT - both fast and V4 numerically compatabible
//#define PLATFORM_LPC_PRUNED_STRAIGHT
//// X86 Tough_32s_22:  1,490,909               Tough_16m_16:    545,381
//// SH4 Tough_32s_22: 23,573,152               Tough_16m_16:  8.603.243

// PLATFORM_LPC_DIRECT using trig recurrsion
//#define PLATFORM_LPC_DIRECT
//// X86 Tough_32s_22:  5,300,299               Tough_16m_16:  1,533,753
//// SH4 Tough_32s_22: 43,303,596               Tough_16m_16: 12,927,913

// PLATFORM_LPC_LITDFT is theoretically the fastest but isnt.  
// Above methods are very clever but this does limited damage to the cache.
//#define PLATFORM_LPC_LITDFT
//// X86 Tough_32s_32:  2,868,037 = 1,281,738+1,560,625+1,186,050-1,160,376
//// SH4 Tough_32s_32: 41,381,752 

// PLATFORM_LPC_FOLDED is derived from ARM's implementation
//#define PLATFORM_LPC_FOLDED

// PLATFORM_LPC_FOLDED_PRUNED uses ARM's Folded Trick with otherwise PLATFORM_LPC_PRUNED_NONREDUNDANT
// Fast and uses little extra memory and so is the default
//#define PLATFORM_LPC_FOLDED_PRUNED

#if !(defined(PLATFORM_LPC_PRUNED_NONREDUNDANT) || defined(PLATFORM_LPC_DIRECT) \
   || defined(PLATFORM_LPC_LITDFT) || defined(PLATFORM_LPC_PRUNED_STRAIGHT)     \
   || defined(PLATFORM_LPC_FOLDED) || defined(PLATFORM_LPC_FOLDED_PRUNED) )
//  set the default if none is otherwise selected
#   define PLATFORM_LPC_FOLDED_PRUNED
#endif

#if defined(PI) != (defined(PLATFORM_LPC_PRUNED_NONREDUNDANT) +defined(PLATFORM_LPC_DIRECT) \
                  + defined(PLATFORM_LPC_LITDFT) + defined(PLATFORM_LPC_PRUNED_STRAIGHT)    \
                 +  defined(PLATFORM_LPC_FOLDED) + defined(PLATFORM_LPC_FOLDED_PRUNED))
#       pragma COMPILER_MESSAGE(__FILE__ "(84) : Warning - Multiple LPC Platforms selected.")
#endif

#if defined(PLATFORM_LPC_FOLDED_PRUNED)
// use a smaller trig table and calculate the 6 lpc constants from base sin/cos values
// so far, only implemented for PLATFORM_LPC_FOLDED_PRUNED
#   if !(defined(PLATFORM_LPC_SMALL_TRIG_TABLE) || defined(PLATFORM_LPC_NO_TRIG_TABLE))
// these two alternatives are essentially the same speed on the SH3.  NO_TRIG_TABLE saves rom/cache space.
//#     define PLATFORM_LPC_SMALL_TRIG_TABLE
#       define PLATFORM_LPC_NO_TRIG_TABLE
#   endif
#endif

// LPC in V4 has a couple of bugs 
// Define the symbol below to replicate that bug as well as V4 style computations for comparision
// Can be used with any of the methods above
//#define REPLICATE_V4_LPC

#if defined(V4V5_COMPARE_MODE) && !defined(REPLICATE_V4_LPC)
#define REPLICATE_V4_LPC
#endif

//#define REPLICATE_ARM_NON_TRUNCATED_LPC

#define MAX_LP_SPEC_SIZE 2048


#if defined(V4V5_COMPARE_MODE) && defined(BUILD_INT_FLOAT) && 0

// To be sure, use old version of lpc in lpc_float.c
// no longer exists #include        "lpc_float.c"

#else // so not V4V5_COMPARE_MODE 


#include "lpcConst.h"

//function prototype, used to eliminate Mac warnings
Void prvPq2lpc(CAudioObject* pau, LpType* p, LpType* q, LpType* lpc, Int order);
Void prvConvolve_odd(CAudioObject* pau, LpType* in1, Int l1, LpType* in2, Int l2, LpType* out, Int *lout);
Void prvConvolve(CAudioObject* pau, LpType *in1, Int l1, LpType *in2, Int l2, LpType *out, Int *lout);
Void prvLsp2pq(CAudioObject* pau, U8 *lsfQ, LpType *p, LpType *q, Int order);


// *****************************************************************************
//
// Conversion from LSF thru Parcor to LPC
//
// *****************************************************************************

// Parcor to LPC conversion
Void prvPq2lpc(CAudioObject* pau, LpType* p, LpType* q, LpType* lpc, Int order)
{
  I32 i;
  
  for(i=1; i<=order/2; i++) {
    lpc[i-1]= -DIV2(p[i]+q[i]);
    lpc[order-i]= -DIV2(p[i]-q[i]);
  }
}

/* symmetric convolution */
Void prvConvolve_odd(CAudioObject* pau, LpType* in1, Int l1, LpType* in2, Int l2, LpType* out, Int *lout)
{
  // In BUILD_INTEGER mode, in1 assumed to have FRACT_BITS_LSP and in2 to have FRACT_BITS_LP. Output will have
  // FRACT_BITS_LP.
  I32   i,j;
  LpType ret[100];
  
  for (i=0; (i<l1)&&(i<l2); i++) {
    ret[i]=0;
    for (j=0; j<=i; j++) {
      ret[i] += MULT_LSP(in1[j],in2[i-j]);
    }
  }
  
  for (i=l1; i<(l1+l2)/2; i++) {
    ret[i]=0;
    for (j=0; j<l1; j++) {
      ret[i] += MULT_LSP(in1[j],in2[i-j]);
    }
  }
  
  *lout=(l1+l2)-1;
  for (i=0; i<(*lout)/2; i++) {
    out[i]=ret[i];
    out[(*lout-1)-i]=ret[i];
  }
  out[*lout/2]=ret[*lout/2];
}

/* symmetric convolution */
Void prvConvolve(CAudioObject* pau, LpType *in1, Int l1, LpType *in2, Int l2, LpType *out, Int *lout)
{
  // In BUILD_INTEGER mode, in1 assumed to have FRACT_BITS_LSP and in2 to have FRACT_BITS_LP. Output will have
  // FRACT_BITS_LP.
  I32   i,j;
  LpType ret[100];
  
  for (i=0; (i<l1)&&(i<l2); i++) {
    ret[i]=0;
    for (j=0; j<=i; j++) {
      ret[i] += MULT_LSP(in1[j],in2[i-j]);
    }
  }
  
  for (i=l1; i<(l1+l2)/2; i++) {
    ret[i]=0;
    for (j=0; j<l1; j++) {
      ret[i] += MULT_LSP(in1[j],in2[i-j]);
    }
  }
  
  *lout=(l1+l2)-1;
  for (i=0; i<(*lout)/2; i++) {
    out[i]=ret[i];
    out[(*lout-1)-i]=ret[i];
  }
}

#if defined(REPLICATE_V4_LPC) && defined(BUILD_INT_FLOAT)
#define LSF_DECODE(i,lsfQ) -2.0F*(Float)cos(2.0*PI*(g_rgfltLsfReconLevel [i] [lsfQ[i]]) )
#define LP_DECODE(i,lsfQ)  LSF_DECODE((i),(lsfQ))
#else
#define LSF_DECODE(i,lsfQ) g_rgiLsfReconLevel[i][lsfQ[i]]
#if defined(BUILD_INTEGER)
#define LP_DECODE(i,lsfQ) (g_rgiLsfReconLevel[i][lsfQ[i]] >> (FRACT_BITS_LSP-FRACT_BITS_LP))
#else
#define LP_DECODE(i,lsfQ) LSF_DECODE((i),(lsfQ))
#endif // BUILD_INTEGER
#endif

// Only updates
#define ARRAY_RANGE_FMAX(a,b,c,d,init,i) if ((init)) d = -FLT_MAX; \
for ((i)=(b);(i)<(c);(i)++) (d) = ((d) < (a)[i]) ? (a)[i] : (d);
#define ARRAY_RANGE_FMIN(a,b,c,d,init,i) if ((init)) d = FLT_MAX; \
for ((i)=(b);(i)<(c);(i)++) (d) = ((d) > (a)[i]) ? (a)[i] : (d);

// Quantized LSF to PARCOR

Void prvLsp2pq(CAudioObject* pau, U8 *lsfQ, LpType *p, LpType *q, Int order)
{
    I32     i;
    LpType  long_seq[100];
    LspType short_seq[3];
    Int     long_length, short_length;
    
#if 0 // only to create preload for g_rgiLsfReconLevel in lpcconst.h
    static int first = 1;
    if (first)
    {
        for( i = 0; i<LPCORDER; i++ )
        {
            printf("LP_CONST16(");
            for( first = 0; first < 15; first++ )
                printf("%.10f,", g_rgfltLsfReconLevel [i] [first] != 0 ? -2.0F*(Float)cos(2.0*PI*(g_rgfltLsfReconLevel [i] [first]) ) : 0.0f );
            printf("%.10f),\n", g_rgfltLsfReconLevel [i] [first] != 0 ? -2.0F*(Float)cos(2.0*PI*(g_rgfltLsfReconLevel [i] [first]) ) : 0.0f );
        }
        first = 0;
    }
#endif
    
    short_length = 3; 
    long_length  = 2;
    
    short_seq[0] = short_seq[2] = LSP_FROM_FLOAT(1);
    long_seq[0]  = long_seq[1]  = LP_FROM_FLOAT(1);
    
    for (i = 0; i < order; i+= 2) {
        short_seq[1]= LSF_DECODE(i,lsfQ);   // -2.0F*(Float)cos(2.0*PI*lsp[i])
        prvConvolve(pau, short_seq, short_length, long_seq, long_length, 
            long_seq, &long_length);
    }
    
    for (i=1; i<=order/2; i++) {
        p[i] = long_seq[i];
    }
    
    long_length = 3;
    long_seq[0] = LP_FROM_FLOAT(1);
    long_seq[1] = LP_DECODE(1,lsfQ);             // -2.0F*(Float)cos(2.0*PI*lsp[1])
    long_seq[2] = LP_FROM_FLOAT(1);
    
    for (i = 3; i < order; i += 2) {
        short_seq[1]= LSF_DECODE(i,lsfQ);   // -2.0F*(Float)cos(2.0*PI*lsp[i])
        prvConvolve_odd(pau, short_seq, short_length, long_seq, long_length, 
            long_seq, &long_length);
    }
    
    for (i=1; i<=order/2; i++) {
        q[i]=long_seq[i]-long_seq[i-1];
    }
}

// Quantized LSF to LPC
Void    auLsp2lpc(CAudioObject* pau, U8 *lsfQ, LpType *lpc, Int order)
{
  LpType p[LPCORDER+2],q[LPCORDER+2];
  
  prvLsp2pq(pau, lsfQ,p,q,order);
  
  prvPq2lpc(pau, p,q,lpc,order);
}



// ************************************************************************************
//
// InverseQuadRoot(x) = (1/x)^(1/4) 
// where the 1/4 is one squareroot combined with the flattenfactor
//
// Do this three different ways:  Encoder, Integer Decoder, IntFloat Decoder
//
// ************************************************************************************

#ifdef BUILD_INTEGER

#ifndef LPCPOWER32

U8 gLZLTable[128];

void gLZLTableInit(void)
{
   int i,j;
   U8 mask;

   for(i=0;i<128;i++)
   {
	   mask=0x80;
	   for(j=0;j<8;j++)
	   {
         if((2*i)&mask)
			 break;
		 mask>>=1;
	   }

	   
	   gLZLTable[i]=j;

       mask=0x80;
	   for(j=0;j<8;j++)
	   {
         if((2*i+1)&mask)
			 break;
		 mask>>=1;
	   }

       gLZLTable[i]|=j<<4;
   }

}
#endif


#else   // so must be BUILD_INT_FLOAT

//Tables for inverse quad root calculation
UInt g_InvQuadRootExponent[0x100];
UInt g_InvQuadRootMantissa[1<<(PRECESSION_BITS_FOR_INVQUADROOT)];

//Build tables for fast inverse quad root calculation
Void prvInitInverseQuadRootTable (CAudioObject* pau)
{
    //Iterate through floating point numbers with 12 bits of presition
    //The folowing loop is equivalent to 
    //for (Float i = 1.0; i < 1.999756;i+=1.000244)
    Int i;
    for (i = 0; i < 1<<(PRECESSION_BITS_FOR_INVQUADROOT); i++){          
        Int fltInt = 0x3F800000 | (i << (23-PRECESSION_BITS_FOR_INVQUADROOT));//Build floating point      
        Float f = *(Float *)&fltInt;                       //number in the form of 1.i * pow(2,0);
        Float invQuadRoot = (Float)(1/sqrt(sqrt(f)));  //Calculate inverse quad root
        fltInt = *(Int *)&invQuadRoot;          
        g_InvQuadRootMantissa[i] = fltInt;             //Store value in table
    }
    
    //Iterate through floating point exponents from pow(2,-126)...pow(2,127) by powers of 2
    for (i = 1; i < 255; i++){
        Int fltInt = (i << 23);                             //Build floating point number in the form
        Float f = *(Float *)&fltInt;            //of 1.0 * pow(2,(i-125))
        f = (Float)(1/sqrt(sqrt(f)));           //calculate inverse quad root / 2
        g_InvQuadRootExponent[i] = *(Int *)&f;  //Store in table   
    }
    SETUP_LPC_SPEC_TRIG(pau);
}

INLINE WeightType InverseQuadRootF(Float f){
    Float frac = (*(Float *)&(g_InvQuadRootMantissa[((*(Int *)&f) &   0x7FFFFF) >> (23-PRECESSION_BITS_FOR_INVQUADROOT)]));
    Float exp  = (*(Float *)&(g_InvQuadRootExponent[((*(Int *)&f) & 0x7F800000) >> 23]));
    return (frac * exp);
}

INLINE WeightType InverseQuadRootI(Int f){
    Float frac = (*(Float *)&(g_InvQuadRootMantissa[(f &   0x7FFFFF) >> (23-PRECESSION_BITS_FOR_INVQUADROOT)]));
    Float exp  = (*(Float *)&(g_InvQuadRootExponent[(f & 0x7F800000) >> 23]));
    //fprintf(stdout, "%.20lf\n", ((double)*(Float*)(&f)));
    //fprintf(stdout, "%.20lf\n", ((double)frac * (double)exp));
    return (frac * exp);
}

// there appears to be no effect of calling The I suffix or the F suffix.  
// lpc_float.c called the I suffix.
#define InverseQuadRoot(X) InverseQuadRootI(*(Int*)&X)

#endif // of BUILD_INTEGER and BUILD_INT_FLOAT variations


// *****************************************************************************
//
// Support for Integer and Float versions of LPC to Spectrum 
//
// *****************************************************************************

#if defined(BUILD_INTEGER)
 
INLINE LpSpecPowerType square(LpSpecType x) {
    /* x must be less than sqrt(2^12)*2^19 to avoid overflow */
    if ( abs(x) < 0x01000000 )
        return (LpSpecPowerType) 
        (MULT_HI_DWORD(x<<((BITS_PER_DWORD-FRACT_BITS_LP_SPEC)>>1),x<<((BITS_PER_DWORD-FRACT_BITS_LP_SPEC+1)>>1)));
    return (LpSpecPowerType) 
        (MULT_HI_DWORD(x,x) << (BITS_PER_DWORD-FRACT_BITS_LP_SPEC));
}

INLINE LpSpecPowerType square64(LpSpecType x) {
    return (LpSpecPowerType)(((U64)x * (U64)x) >> (2 * FRACT_BITS_LP_SPEC - FRACT_BITS_LP_SPEC_POWER));
}

#if defined(_DEBUG)

static LpSpecPowerType DebugSquare(LpSpecType x) {
    UInt y;
    Float f2 = (float)x/(LP_SPEC_SCALE);
    Float f3 = f2*f2;
    Float f4 = f3*LP_SPEC_SCALE;
    Float dif,rel;
    y = (UInt) square(x);

    dif = (Float)fabs(f4-y);
    rel = (Float)fabs(dif/f4);
    if ((f4 > 10.0f) && (rel > .2f)) {
        assert(WMAB_FALSE);
    }
    return y;
}


static Int MultBp2Debug(int x, int y) {
    Float fx,fy,fa,rel,dif;
    Int a;
    a = MULT_BP2(x,y);
    fx = (Float)x;
    fy = (Float)y;
    fa = fx*fy/(1<<30);
    dif = (Float)fabs(fa-a);
    rel = (Float)fabs(dif/fa);
    if ((fa > 5.0f) && (rel > .5f)) {
        assert(WMAB_FALSE);
    }
    return a;
}

#if defined (LPCPOWER32)
#   define SQUARE(x) DebugSquare(x)
#   define SUM_SQUARES(x,y) (DebugSquare(x)+DebugSquare(y))
#elif defined(U64SQUARE32SR)
#   define SQUARE(x) U64SQUARE32SR(x, (2 * FRACT_BITS_LP_SPEC - FRACT_BITS_LP_SPEC_POWER))
#ifdef U64SUM_SQUARES32SR
#   define SUM_SQUARES(x,y) U64SUM_SQUARES32SR(x,y, (2 * FRACT_BITS_LP_SPEC - FRACT_BITS_LP_SPEC_POWER))
#else
#   define SUM_SQUARES(x,y) (square64(x)+square64(y))
#endif
#else 
#   define SQUARE(x) square64(x) 
#   define SUM_SQUARES(x,y) (square64(x)+square64(y))
#endif // LPCPOWER32
#   define MULT_BP2X(x,y) MultBp2Debug(x,y)

#else // so not _DEBUG

#if defined (LPCPOWER32)
#   define SQUARE(x) square(x)
#   define SUM_SQUARES(x,y) (square(x)+square(y))
#elif defined(U64SQUARE32SR)
#   define SQUARE(x) U64SQUARE32SR(x, (2 * FRACT_BITS_LP_SPEC - FRACT_BITS_LP_SPEC_POWER))
#ifdef U64SUM_SQUARES32SR
#   define SUM_SQUARES(x,y) U64SUM_SQUARES32SR(x,y, (2 * FRACT_BITS_LP_SPEC - FRACT_BITS_LP_SPEC_POWER))
#else
#   define SUM_SQUARES(x,y) (square64(x)+square64(y))
#endif
#else
#   define SQUARE(x) square64(x) 
#   define SUM_SQUARES(x,y) (square64(x)+square64(y))
#endif // LPCPOWER32
#   define MULT_BP2X(x,y) MULT_BP2(x,y)

#endif  // end of _DEBUG and not _DEBUG variations

#else // so must be BUILD_INT_FLOAT

#   define SQUARE(x) ((x)*(x))
#   define SUM_SQUARES(x,y) ((x)*(x)+(y)*(y))
#   define MULT_BP2X(x,y) ((x)*(y))

#endif

#if defined(REPLICATE_V4_LPC)
#       define SQRT2_2  BP2_FROM_FLOAT(0.7071067811865)
#       define SQRT2    BP2_FROM_FLOAT(1.414213562373)
#else
#       define SQRT2_2  BP2_FROM_FLOAT(0.70710678118654752440084436210485)
#       define SQRT2    BP2_FROM_FLOAT(1.4142135623730950488016887242097)
#endif

// Main LpcSpectrum function only calls the following function which can be optimized on a platform-by-platform basis
#if defined(PLATFORM_SPECIFIC_INVERSEQUADROOT)
extern WeightType InverseQuadRootOfSumSquares(LpSpecType F1, LpSpecType F2 );
#else

#if defined(BUILD_INTEGER) && !defined(LPCPOWER32)
// here we have a limited (256) size lookup table and will interpolate values between them.
// note that two times we call this with pF2==NULL, for F[0] and for F[2048>>xxx]

#if 0
U8 gLZLTable[128];

void gLZLTableInit(void)
{
   int i,j;
   U8 mask;

   for(i=0;i<128;i++)
   {
	   mask=0x80;
	   for(j=0;j<8;j++)
	   {
         if((2*i)&mask)
			 break;
		 mask>>=1;
	   }

	   
	   gLZLTable[i]=j;

       mask=0x80;
	   for(j=0;j<8;j++)
	   {
         if((2*i+1)&mask)
			 break;
		 mask>>=1;
	   }

       gLZLTable[i]|=j<<4;
   }

}

#endif


#if defined(WMA_TARGET_MIPS) && defined(BUILD_INTEGER)


#include "macros_mips_lpc.h"

#else

//INLINE
WeightType InverseQuadRootOfSumSquares(LpSpecType F1, LpSpecType F2 )
{
    // LpSpecPowerType is U64.
    LpSpecPowerType f = SUM_SQUARES( F1, F2 );
    U32 uiMSF = (U32)(f>>32);
    Int iExp = 0;
    int iMSF8;
    U32 uiFrac1;
	U8 index;
    if ( uiMSF==0 ) {
        iExp = 32;
        uiMSF = (U32)f;
    }
    if (uiMSF==0) 
        return(0xFFFFFFFF);
    // normalize the most significant fractional part
    while( (uiMSF & 0xFf000000)==0 ) {
        iExp += 8;
        uiMSF <<= 8;
    }


	index=(U8)(uiMSF>>24);
	iExp+=((gLZLTable[index>>1]>>((index&1)<<2)))&0xf;


    // discard the most significant one bit (it's presence is built into g_InvQuadRootFraction)
    iExp++;
    //MONITOR_COUNT(gMC_ScaleInverseQuadRoot,iExp);
    MONITOR_RANGE(gMC_ScaleInverseQuadRoot,iExp);
    // get all 32 bits from source
#if defined(PLATFORM_OPTIMIZE_MINIMIZE_BRANCHING)
    uiMSF = (U32)((f<<iExp)>>32);
#else
    uiMSF = (iExp>32) ? (U32)(f<<(iExp-32)) : (U32)(f>>(32-iExp));
#endif
    // split into top INVQUADROOT_FRACTION_TABLE_LOG2_SIZE==8 bits for fractional lookup and bottom bits for interpolation
    iMSF8 = uiMSF>>(32-INVQUADROOT_FRACTION_TABLE_LOG2_SIZE);
    uiMSF <<= INVQUADROOT_FRACTION_TABLE_LOG2_SIZE;
    // lookup and interpolate - tables are set up to return correct binary point for WeightType
    uiFrac1  = g_InvQuadRootFraction[iMSF8++];
    uiFrac1 -= MULT_HI_UDWORD( uiMSF, uiFrac1 - g_InvQuadRootFraction[iMSF8] );
    return MULT_HI_UDWORD( uiFrac1, g_InvQuadRootExponent[ iExp ] );
}

#endif

#else   // defined(BUILD_INTEGER) && !defined(LPCPOWER32)

INLINE WeightType InverseQuadRootOfSumSquares(LpSpecType F1, LpSpecType F2 )
{
    LpSpecPowerType f = SUM_SQUARES( F1, F2 );
    return InverseQuadRoot( f );
}

#endif  // defined(BUILD_INTEGER) && !defined(LPCPOWER32)

#endif  // PLATFORM_SPECIFIC_INVERSEQUADROOT

#if defined(_DEBUG) && defined(LPC_COMPARE)  //compare results

#   ifdef UNDER_CE
        extern void WMADebugMessage(const char* pszFmt, ... );
#       define MYPRINTF WMADebugMessage
#   else
#       define MYPRINTF printf
#   endif

void LpcCompareDebug( CAudioObject* pau, Int iFreq, Int iF, Int iT, LpSpecType* F, const LpType* rgLpcCoef )
{
    //to compare results find the line that reads
    //Float fltTemp = (iFreq + 0.5F) * PI / pau->m_cSubband;
    //and remove the + 0.5F
    static Float max = 0.001f;  //.00001f;
    static Int cnt = 0;
    static Float sum = 0;
    Float old_way, new_way;
    Float R = 1;
    Float I = 0;
    int j;
    cnt++;
    for (j = 0; j < LPCORDER; j++)  
    {
        R -= FLOAT_FROM_LP(rgLpcCoef [j]) * pau->m_rgfltLpsSpecCos [j] [iT];
        I -= FLOAT_FROM_LP(rgLpcCoef [j]) * pau->m_rgfltLpsSpecSin [j] [iT];
    }
    old_way = (Float)(1/pow((R * R + I * I),pau->m_fltFlatenFactor/2));
#   if defined(PLATFORM_LPC_FOLDED) || defined(PLATFORM_LPC_PRUNED_NONREDUNDANT) || defined( PLATFORM_LPC_FOLDED_PRUNED)
        new_way = FLOAT_FROM_WEIGHT(F[iF]);
#   else
        new_way = FLOAT_FROM_WEIGHT(InverseQuadRoot(F[iF]));
#   endif
    sum += (Float)fabs(old_way-new_way);
    if (fabs(old_way-new_way)  > max) 
    {
        max = (Float)fabs(old_way-new_way);
        MYPRINTF("max error=%f, %%=%f, Frame=%4d, iFreq=%4d, Size=%4d, ave err=%f\n", 
            max, 100*max/old_way, pau->m_iFrameNumber, iFreq, 
#           ifdef REPLICATE_V4_LPC
                pau->m_cFrameSampleHalf, 
#           else
                (pau->m_fV5Lpc) ? pau->m_cSubband : pau->m_cFrameSampleHalf, 
#           endif
            sum/cnt );
    }
}
#define LPC_COMPARE_DEBUG( pau, iFreq, iF, iT, F, rgLpcCoef ) LpcCompareDebug( pau, iFreq, iF, iT, F, rgLpcCoef )
#pragma COMPILER_MESSAGE(__FILE__ "(704) : Warning - LPC_COMPARE Mode - output to stdout!")
#else
#define LPC_COMPARE_DEBUG( pau, iFreq, iF, iT, F, rgLpcCoef )
#endif

// define LPC_SPEC_PRINT_FRAME to get a printout of particular frame
//#define LPC_SPEC_PRINT_FRAME 2
#if defined(_DEBUG) && defined(LPC_SPEC_PRINT_FRAME)
#define LPC_SPEC_PRINT(a,b,c,d,e)                               \
        if ( pau->m_iFrameNumber == LPC_SPEC_PRINT_FRAME )      \
                printf("%4d  %d  %4d  %10.6f  %10.6f\n",a,b,c,d,e);
#else
#define LPC_SPEC_PRINT(a,b,c,d,e)
#endif

// define LPC_FT_PRINT_FRAME to get a printout of particular frame
//#define LPC_FT_PRINT_FRAME 2
#if defined(_DEBUG) && defined(LPC_FT_PRINT_FRAME)
#define LPC_FT_PRINT(a,b,c,d,e,f)                               \
        if ( pau->m_iFrameNumber == LPC_FT_PRINT_FRAME )        \
                printf("%4d  %d  %4d  %10.6f  %10.6f  %10.6f\n",a,b,c,d,e,f);
#else
#define LPC_FT_PRINT(a,b,c,d,e,f)
#endif

//#define PRINT_WEIGHT_FACTOR 100000000
#	ifdef PRINT_WEIGHT_FACTOR
		// this function must be defined in fft.c
		extern void DebugDctPrintCoefs(CAudioObject* pau, int def, int id, float fac, CoefType* pfCoef);
#		define WF_PRINT(pfCoef)  DebugDctPrintCoefs(pau,PRINT_WEIGHT_FACTOR,4,1.0f*(1<<WEIGHTFACTOR_FRACT_BITS),pfCoef)
#   else
#       define WF_PRINT(pfCoef)
#   endif

#if defined(PLATFORM_LPC_FOLDED_PRUNED) && !defined(V4V5_COMPARE_MODE)

// ************************************************************************************
// ************************* This is the one we normally use **************************
// ************************************************************************************

//#pragma COMPILER_MESSAGE(__FILE__ "(735) : Warning - building PLATFORM_LPC_FOLDED_PRUNED LPC spectrum")

// ************************************************************************************
//
// LPC to Spectrum using a "Pruned" FFT and redundant calculation removal
//
// See Sorensen & Burrus, IEEE Trans Signal Processing V41 #3 March 93
// and the references sited there for a treatment of pruned and Transform-decomposited DFT
// Unclear how this particular implementation relates to those articles.
//
// Originally designed and implemented by Wei-ge and Marc.  
// Restructured by Sil to be a single routine.  
// Later restructured again to use only a small stack array (inspired by ARM's technique).
//
// The use of pointers instead of array indexes speeds up the SH4 and has no effect on the X86
//
// Cache usage: constants 14kb (note SH3 cache size is 16kb and we need 8k of WF plus constants)
//
// ************************************************************************************


#if defined(PLATFORM_LPC_NO_TRIG_TABLE) || defined(PLATFORM_LPC_SMALL_TRIG_TABLE)

#if defined(PLATFORM_SPECIFIC_DOLPC4)

extern void prvDoLpc4( const Int k, const LpSpecType* pTmp, WeightType* pWF, const Int iSizeBy2, const BP2Type S1, const BP2Type C1 );

#else // defined(PLATFORM_SPECIFIC_DOLPC4)

#if !(defined(WMA_TARGET_MIPS) && defined(BUILD_INTEGER))
void prvDoLpc4( const Int k, const LpSpecType* pTmp, WeightType* pWF, const Int iSizeBy2, const BP2Type S1, const BP2Type C1 ) 
{
    BP2Type    CmS, CpS;
    LpSpecType T2, T4, T6, T7, T8, T9, TA, TB;
    LpSpecType D, E;

    BP2Type    C2, S2, C3, S3;

//#define DOLPC4_BREAK 243
#if defined(DOLPC4_BREAK) && defined(_DEBUG)
    if ( k==DOLPC4_BREAK || (iSizeBy2-k)==DOLPC4_BREAK || (iSizeBy2+k)==DOLPC4_BREAK || ((iSizeBy2<<1)-k)==DOLPC4_BREAK )
    {
        DEBUG_BREAK();
    }
    
#endif
    CmS = C1 - S1;                              // cnst4[i*6+4];
    CpS = C1 + S1;                              // cnst4[i*6+5];
    assert( BP2_FROM_FLOAT(1.0) <= CpS && CpS < BP2_FROM_FLOAT(1.5) );
    T8 = MULT_BP2X(CmS,pTmp[2]) + MULT_BP2X(CpS,pTmp[3]);     // F[2048+j]    F[3072-j]
    T6 = MULT_BP2X(CpS,pTmp[2]) - MULT_BP2X(CmS,pTmp[3]);     // F[2048+j]    F[3072-j]

    S2 = MUL2(MULT_BP2X(C1,S1));                        // sin(2x)
    C2 = BP2_FROM_FLOAT(1.0f) - MUL2(MULT_BP2X(S1,S1)); // cos(2x)
    CmS = C2 - S2;                              // cnst4[i*6+2];
    CpS = C2 + S2;                              // cnst4[i*6+3];
    T7 = MULT_BP2X(CmS,pTmp[0]) + MULT_BP2X(CpS,pTmp[1]);     // F[1024+j]    F[2048-j]
    T4 = MULT_BP2X(CpS,pTmp[0]) - MULT_BP2X(CmS,pTmp[1]);     // F[1024+j]    F[2048-j]

    S3 = MULT_BP2X(S1,C2) + MULT_BP2X(C1,S2);   // sin(3x) = sin(x+2x)
    C3 = MULT_BP2X(C1,C2) - MULT_BP2X(S1,S2);   // cos(2x) = cos(x+2x)
    CmS = C3 - S3;                              // old cnst4[i*6];
    CpS = C3 + S3;                              // old cnst4[i*6+1];
    T9 = MULT_BP2X(CmS,pTmp[4]) + MULT_BP2X(CpS,pTmp[5]);     // F[3072+j]    F[4096-j]
    T2 = MULT_BP2X(CpS,pTmp[4]) - MULT_BP2X(CmS,pTmp[5]);     // F[3072+j]    F[4096-j]

    TA = pTmp[6] + pTmp[7];                                   // F[j]      +  F[1024-j];
    TB = pTmp[6] - pTmp[7];                                   // F[j]      -  F[1024-j];

    D  = DIV2(+ T7  + T8 + T9 + TA);
    E  = DIV2(+ T4  + T6 + T2 + TB);
    pWF[k]           = InverseQuadRootOfSumSquares(D, E);              // F[j]

    D  = DIV2(- T7  + T6 - T2 + TA);
    E  = DIV2(+ T4  + T8 - T9 - TB);
    pWF[iSizeBy2-k]  = InverseQuadRootOfSumSquares(D, E);              // F[1024-j]

    D  = DIV2(- T7  - T6 + T2 + TA);
    E  = DIV2(- T4  + T8 - T9 + TB);
    pWF[iSizeBy2+k]  = InverseQuadRootOfSumSquares(D, E);              // F[1024+j]

    D  = DIV2(- T4  + T6 + T2 - TB);
    E  = DIV2(+ T7  - T8 - T9 + TA);
    pWF[(iSizeBy2<<1)-k]  = InverseQuadRootOfSumSquares(D, E);         // F[2048-j]

    //INTEGER_ONLY( assert( F[j]>=0 && F[(1024>>iShrink)-j]>=0 && F[(1024>>iShrink)+j]>=0 && F[(2048>>iShrink)-j]>=0 ) );

    //** This block uses 36 adds and 20 mults plus either 4 more mults or 4 shifts
}
#else
void (*prvDoLpc4)( const Int k, const LpSpecType* pTmp, WeightType* pWF, const Int iSizeBy2, const BP2Type S1, const BP2Type C1 ) ;
#endif

#endif  // defined(PLATFORM_SPECIFIC_DOLPC4)
#else   // defined(PLATFORM_LPC_NO_TRIG_TABLE) || defined(PLATFORM_LPC_SMALL_TRIG_TABLE)

void prvDoLpc4( const Int k, const LpSpecType* pTmp, WeightType* pWF, const Int iSizeBy2, const Int iShrink ) 
{
    const BP2Type *pC4;
    BP2Type    CmS, CpS;
    LpSpecType T2, T4, T6, T7, T8, T9, TA, TB;
    LpSpecType D, E;


    // if we folded the constants, we could just increment rather than recalculate this pointer
    pC4 = &lpc_cnst4[k*(6<<iShrink)];

    CmS = *pC4++;   // old cnst4[i*6];
    CpS = *pC4++;   // old cnst4[i*6+1];
    T9 = MULT_BP2X(CmS,pTmp[4]) + MULT_BP2X(CpS,pTmp[5]);     // F[3072+j]    F[4096-j]
    T2 = MULT_BP2X(CpS,pTmp[4]) - MULT_BP2X(CmS,pTmp[5]);     // F[3072+j]    F[4096-j]

    CmS = *pC4++;   // cnst4[i*6+2];
    CpS = *pC4++;   // cnst4[i*6+3];
    T7 = MULT_BP2X(CmS,pTmp[0]) + MULT_BP2X(CpS,pTmp[1]);     // F[1024+j]    F[2048-j]
    T4 = MULT_BP2X(CpS,pTmp[0]) - MULT_BP2X(CmS,pTmp[1]);     // F[1024+j]    F[2048-j]

    CmS = *pC4++;   // cnst4[i*6+4];
    CpS = *pC4;     // cnst4[i*6+5];
    assert( BP2_FROM_FLOAT(1.0) <= CpS && CpS < BP2_FROM_FLOAT(1.5) );
    T8 = MULT_BP2X(CmS,pTmp[2]) + MULT_BP2X(CpS,pTmp[3]);     // F[2048+j]    F[3072-j]
    T6 = MULT_BP2X(CpS,pTmp[2]) - MULT_BP2X(CmS,pTmp[3]);     // F[2048+j]    F[3072-j]

    TA = pTmp[6] + pTmp[7];                                   // F[j]      +  F[1024-j];
    TB = pTmp[6] - pTmp[7];                                   // F[j]      -  F[1024-j];

    D  = DIV2(+ T7  + T8 + T9 + TA);
    E  = DIV2(+ T4  + T6 + T2 + TB);
    pWF[k]           = InverseQuadRootOfSumSquares(D, E);              // F[j]

    D  = DIV2(- T7  + T6 - T2 + TA);
    E  = DIV2(+ T4  + T8 - T9 - TB);
    pWF[iSizeBy2-k]  = InverseQuadRootOfSumSquares(D, E);              // F[1024-j]

    D  = DIV2(- T7  - T6 + T2 + TA);
    E  = DIV2(- T4  + T8 - T9 + TB);
    pWF[iSizeBy2+k]  = InverseQuadRootOfSumSquares(D, E);              // F[1024+j]

    D  = DIV2(- T4  + T6 + T2 - TB);
    E  = DIV2(+ T7  - T8 - T9 + TA);
    pWF[(iSizeBy2<<1)-k]  = InverseQuadRootOfSumSquares(D, E);              // F[2048-j]

    //INTEGER_ONLY( assert( F[j]>=0 && F[(1024>>iShrink)-j]>=0 && F[(1024>>iShrink)+j]>=0 && F[(2048>>iShrink)-j]>=0 ) );

    //** This block uses 36 adds and 20 mults plus either 4 more mults or 4 shifts
}
#endif
   

#if defined(PLATFORM_SPECIFIC_LPC_JLOOP_BOTTOM) && defined(PLATFORM_LPC_NO_TRIG_TABLE) 
    extern void prvLpcJLoopBottom( int j, const LpSpecType* pTmp, WeightType* pWF, const Int iSizeBy2, 
                            BP2Type *pS1, BP2Type *pC1, BP2Type *pS1p, BP2Type *pC1p, const BP2Type STEP1 ); 
#else
    // use this to generate optimized assembly to start your own asm version
    void prvLpcJLoopBottom( int j, const LpSpecType* pTmp, WeightType* pWF, const Int iSizeBy2, 
                            BP2Type *pS1, BP2Type *pC1, BP2Type *pS1p, BP2Type *pC1p, const BP2Type STEP1 ) 
    {
        BP2Type S1 = *pS1;
        BP2Type C1 = *pC1;
        BP2Type S2, C2, SLS1, SLC1, CLS1, CLC1;
        int iSizeBy8 = iSizeBy2>>2;
        const BP2Type SL8     = BP2_FROM_FLOAT(0.38268343236508977172845998403040);     // sim(pi/8)   = sin(pi*iSizeBy8*(1<<iShrink)/2048)
        const BP2Type CL8     = BP2_FROM_FLOAT(0.92387953251128675612818318939679);     // cos(pi/8)   = sin(pi*iSizeBy8*(1<<iShrink)/2048)
        const BP2Type SL4     = BP2_FROM_FLOAT(0.70710678118654752440084436210485);     // sim(pi/4)   = sin(pi*iSizeBy4*(1<<iShrink)/2048)
        const BP2Type CL4     = BP2_FROM_FLOAT(0.70710678118654752440084436210485);     // cos(pi/4)   = sin(pi*iSizeBy4*(1<<iShrink)/2048)
        DEBUG_ONLY( int iSize = iSizeBy2<<1; )
        DEBUG_ONLY( int iSizeBy4 = iSizeBy2>>1; )
        DEBUG_ONLY( int iShrink = LOG2(MAX_LP_SPEC_SIZE/iSize); )

        assert( fabs(FLOAT_FROM_BP2(S1)-sin(PI*j/iSize)) < 0.0001 
             && fabs(FLOAT_FROM_BP2(C1)-cos(PI*j/iSize)) < 0.0001 );

        prvDoLpc4( j, pTmp, pWF, iSizeBy2, S1, C1 );

        S2 = (SLC1 = MULT_BP2X(SL8,C1)) - (CLS1 = MULT_BP2X(CL8,S1));
        C2 = (CLC1 = MULT_BP2X(CL8,C1)) + (SLS1 = MULT_BP2X(SL8,S1));
        assert( fabs(FLOAT_FROM_BP2(S2)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy8-j,0)))<0.0001 
             && fabs(FLOAT_FROM_BP2(C2)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy8-j,1)))<0.0001 );
        prvDoLpc4( iSizeBy8 - j, pTmp+8,  pWF, iSizeBy2, S2, C2 );

        S2 = SLC1 + CLS1;
        C2 = CLC1 - SLS1;
        assert( fabs(FLOAT_FROM_BP2(S2)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy8+j,0)))<0.0001 
             && fabs(FLOAT_FROM_BP2(C2)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy8+j,1)))<0.0001 );
        prvDoLpc4( iSizeBy8 + j, pTmp+16, pWF, iSizeBy2, S2, C2 );

        S2 = MULT_BP2X(SL4,C1) - MULT_BP2X(CL4,S1);
        C2 = MULT_BP2X(CL4,C1) + MULT_BP2X(SL4,S1);
        assert( fabs(FLOAT_FROM_BP2(S2)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy4-j,0)))<0.0001 
             && fabs(FLOAT_FROM_BP2(C2)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy4-j,1)))<0.0001 );
        prvDoLpc4( (iSizeBy2>>1) - j, pTmp+24, pWF, iSizeBy2, S2, C2 );

		// rotate angle by b = pi/iSize
		// recursion: cos(a+b) = cos(a-b) + 2*sin(b)*sin(a)
		// and:       sin(a+b) = sin(a-b) - 2*sin(b)*cos(a)
		*pC1 = *pC1p - MULT_BP2X(STEP1,S1);
		*pS1 = *pS1p + MULT_BP2X(STEP1,C1);
		*pC1p = C1;
		*pS1p = S1;
    }
#   endif // defined(PLATFORM_SPECIFIC_LPC_JLOOP_BOTTOM)



WMARESULT prvLpcToSpectrum(CAudioObject* pau, const LpType* rgLpcCoef, PerChannelInfo* ppcinfo)
{
    // put often used variables near the top for easier access in platforms like the SH3 and SH4
    LpSpecType original[LPCORDER];
    LpSpecType *pFb;      
    Int i, j;
    LpSpecType t1pO7, t1mO7, tO1pO9, tO1mO9, tO0pO8, tO0mO8, tO4pO6, tO4mO6;
    LpSpecType t1pO7pO3, t1pO7mO3, tO1pO5pO9, tO0pO2pO4pO6pO8;
    LpSpecType tS2x; 
    LpSpecType tCpS1x, tCmS1x, tCpS2x, tCmS2x;
    LpSpecType CpS1, CmS1, CpS2, CmS2;
    LpSpecType D, E, F, G, H, I, J;
    
    LpSpecType* rgwtLpcSpec;
    WeightType wtLpcSpecMax, wtTemp;
    Int iFreq, iF, iLoopLimit;
    Int iShrink, iStride; 
    LpSpecType Tmp[32];
    WeightType* pWF = (WeightType*)INTEGER_OR_INT_FLOAT( (I32 *)ppcinfo->m_rguiWeightFactor, ppcinfo->m_rgfltWeightFactor ); 
    Int iSize, iSizeBy2, iSizeBy4, iSizeBy8, iSizeBy16;

#   if defined(PLATFORM_LPC_SMALL_TRIG_TABLE)
        BP2Type SLC1, CLS1, CLC1, SLS1;
        BP2Type S4, C4;
        BP2Type S1, C1;
        const BP2Type *pC4, *pC1;
        Int pCInc4, pCInc1;

        const BP2Type SL16    = BP2_FROM_FLOAT(0.19509032201612826784828486847702);     // sim(pi/16)  = sin(pi*iSizeBy16*(1<<iShrink)/2048)
        const BP2Type CL16    = BP2_FROM_FLOAT(0.98078528040323044912618223613424);     // cos(pi/16)  = sin(pi*iSizeBy16*(1<<iShrink)/2048)
        const BP2Type SL8     = BP2_FROM_FLOAT(0.38268343236508977172845998403040);     // sim(pi/8)   = sin(pi*iSizeBy8*(1<<iShrink)/2048)
        const BP2Type CL8     = BP2_FROM_FLOAT(0.92387953251128675612818318939679);     // cos(pi/8)   = sin(pi*iSizeBy8*(1<<iShrink)/2048)
        const BP2Type SL3by16 = BP2_FROM_FLOAT(0.55557023301960222474283081394853);     // sim(pi3/16) = sin(pi*3*iSizeBy16*(1<<iShrink)/2048)
        const BP2Type CL3by16 = BP2_FROM_FLOAT(0.83146961230254523707878837761791);     // cos(pi3/16) = sin(pi*3*iSizeBy16*(1<<iShrink)/2048)
        const BP2Type SL4     = BP2_FROM_FLOAT(0.70710678118654752440084436210485);     // sim(pi/4)   = sin(pi*iSizeBy4*(1<<iShrink)/2048)
        const BP2Type CL4     = BP2_FROM_FLOAT(0.70710678118654752440084436210485);     // cos(pi/4)   = sin(pi*iSizeBy4*(1<<iShrink)/2048)
#   elif defined(PLATFORM_LPC_NO_TRIG_TABLE)
#       if !defined(PLATFORM_SPECIFIC_LPC_JLOOP_BOTTOM)
            BP2Type SLC1, CLS1, CLC1, SLS1;
#       endif
        BP2Type CT, ST;
        const SinCosTable* pSinCosTable;
        BP2Type S4, C4, S4p, C4p, STEP4;
        BP2Type S1, C1, S1p, C1p, STEP1;

        const BP2Type SL16    = BP2_FROM_FLOAT(0.19509032201612826784828486847702);     // sim(pi/16)  = sin(pi*iSizeBy16*(1<<iShrink)/2048)
        const BP2Type CL16    = BP2_FROM_FLOAT(0.98078528040323044912618223613424);     // cos(pi/16)  = sin(pi*iSizeBy16*(1<<iShrink)/2048)
        const BP2Type SL8     = BP2_FROM_FLOAT(0.38268343236508977172845998403040);     // sim(pi/8)   = sin(pi*iSizeBy8*(1<<iShrink)/2048)
        const BP2Type CL8     = BP2_FROM_FLOAT(0.92387953251128675612818318939679);     // cos(pi/8)   = sin(pi*iSizeBy8*(1<<iShrink)/2048)
        const BP2Type SL3by16 = BP2_FROM_FLOAT(0.55557023301960222474283081394853);     // sim(pi3/16) = sin(pi*3*iSizeBy16*(1<<iShrink)/2048)
        const BP2Type CL3by16 = BP2_FROM_FLOAT(0.83146961230254523707878837761791);     // cos(pi3/16) = sin(pi*3*iSizeBy16*(1<<iShrink)/2048)
        const BP2Type SL4     = BP2_FROM_FLOAT(0.70710678118654752440084436210485);     // sim(pi/4)   = sin(pi*iSizeBy4*(1<<iShrink)/2048)
        const BP2Type CL4     = BP2_FROM_FLOAT(0.70710678118654752440084436210485);     // cos(pi/4)   = sin(pi*iSizeBy4*(1<<iShrink)/2048)
#   else
        Int k, jj;
        Int iMapLpcIdxOffset[4];
        LpSpecType* pTmp;
        const BP2Type* pC4;
        Int pCInc4;
#   endif
    
    FUNCTION_PROFILE(fp);
    FUNCTION_PROFILE_START(&fp,LPC_TO_SPECTRUM_PROFILE);
    
#ifdef REPLICATE_V4_LPC
    iSize = pau->m_cFrameSampleHalf;
#elif defined(REPLICATE_ARM_NON_TRUNCATED_LPC)
    iSize = pau->m_cSubband;
#else
    if (pau->m_fV5Lpc)
        iSize = pau->m_cSubband;
    else 
        iSize = pau->m_cFrameSampleHalf;
#endif
    iShrink = LOG2(MAX_LP_SPEC_SIZE/iSize);     // for smaller transforms, shrink or expand indexing
    iStride = MAX_LP_SPEC_SIZE/iSize;           // for smaller transforms, stride past unused (lpc_compare only)
    iSizeBy2 = iSize>>1;
    iSizeBy4 = iSizeBy2>>1;
    iSizeBy8 = iSizeBy4>>1;
    iSizeBy16 = iSizeBy8>>1;
    // iSize can be 2048, 1024, 512, 256, or 128.
    //      at 32000 Hz: 2048, 1024, 512 and 256
    //      at 22050 Hz: 1024, 512, 256 and 128
    //      at 16000 Hz: 512, 256, and 128
    //      at 11025 Hz: 512, 256, and 128
    //      at  8000 Hz: 512.

    
        
    // DEBUG_ONLY( if (pau->m_iFrameNumber==32) { DEBUG_BREAK(); } );
    
    assert(pau->m_fltFlatenFactor == 0.5f); //So we can use quadRoot instead of pow(x,m_fltFlatenFactor/2);
    assert( iSize <= MAX_LP_SPEC_SIZE );
    
    //for (i = 0; i < LPCORDER; i++) 
    //fprintf(stdout, "%.20lf\n", (double) FLOAT_FROM_LP(rgLpcCoef[i])); 
    
    for (i = 0; i < LPCORDER; i++) 
        original[i] = -LP_SPEC_FROM_LP(rgLpcCoef[i]); 
      
                                        // F[128]
    Tmp[14]  = (t1pO7 = LP_SPEC_FROM_FLOAT(1) + original[7]) + (tS2x = MULT_BP2X(SQRT2,original[3]));
                                        // F[256]  
    Tmp[22]  = (t1mO7 = LP_SPEC_FROM_FLOAT(1) - original[7]) + original[3];
    Tmp[30]  = t1mO7;                   // F[384]
    Tmp[31]  = t1pO7 - tS2x;            // F[640]
    Tmp[23]  = t1mO7 - original[3];     // F[768]
    Tmp[15]  = t1mO7;                   // F[896]
    
                                        // F[1152] 
    Tmp[8]  = (tO1pO9 = original[1] + original[9]) + (tS2x = MULT_BP2X(SQRT2,original[5]));
                                        // F[1280] 
    Tmp[16]  = (tO1mO9 = original[1] - original[9]) + original[5];
    Tmp[24]  = tO1mO9;                  // F[1408]
    Tmp[25]  = tO1pO9 - tS2x;           // F[1664]
    Tmp[17]  = tO1mO9 - original[5];    // F[1792]
    Tmp[9]  = tO1mO9;                   // F[1920] 
    
                                        // F[2176] 
    Tmp[10]  = (tO0pO8 = original[0] + original[8]) + (tS2x = MULT_BP2X(SQRT2,original[4]));
                                        // F[2304] 
    Tmp[18]  = (tO0mO8 = original[0] - original[8]) + original[4];
    Tmp[26]  = tO0mO8;                  // F[2432]
    Tmp[27]  = tO0pO8 - tS2x;           // F[2688]
    Tmp[19]  = tO0mO8 - original[4];    // F[2816] 
    Tmp[11]  = tO0mO8;                  // F[2944]
    
                                        // F[3200] 
    Tmp[12]  = original[2] + (tS2x = MULT_BP2X(SQRT2,original[6]));
    Tmp[20]  = original[2] + original[6]; // F[3328]
    Tmp[28]  = original[2];             // F[3456] 
    Tmp[29]  = original[2] - tS2x;      // F[3712]
    Tmp[21]  = original[2] - original[6]; // F[3840]
    Tmp[13]  = original[2];             // F[3968]
    
    tO4pO6 = original[4] + original[6];
    tO4mO6 = original[4] - original[6];
    t1pO7pO3 = t1pO7 + original[3];
    t1pO7mO3 = t1pO7 - original[3];
    tO1pO5pO9 = tO1pO9 + original[5];
    tO0pO2pO4pO6pO8 = tO0pO8 + tO4pO6 + original[2];

    D  = t1pO7pO3 + tO1pO5pO9 + tO0pO2pO4pO6pO8;    // F[0]
    E  = t1pO7mO3 + (tS2x = MULT_BP2X(SQRT2_2, tO0pO8 - tO4mO6 - original[2]));     // F[512]
    F  = t1pO7pO3 - tO1pO5pO9;                      // F[1024]
    G  = t1pO7mO3 - tS2x;                           // F[1536]
    H  = -tO1pO9 + original[5] + (tS2x = MULT_BP2X(SQRT2_2,tO0pO8 - tO4pO6 + original[2]));  // F[2560]
    I  =  tO0pO8 + tO4mO6 - original[2];            // F[3072]
    J  =  tO1pO9 - original[5] + tS2x;              // F[3584]
    
    // j==0 and i==0 below.
    pFb   =  (LpSpecType*) &pWF[0];      
    *pFb  =  InverseQuadRootOfSumSquares(D, 0);     // F[0]
    pFb  +=  iSizeBy4;   
    *pFb  =  InverseQuadRootOfSumSquares(E, J);     // F[512]    b: F[512]    a: F[3584]
    pFb  +=  iSizeBy4;    
    *pFb  =  InverseQuadRootOfSumSquares(F, I);     // F[1024]    b: F[1024]   a: F[3072]
    pFb  +=  iSizeBy4;    
    *pFb  =  InverseQuadRootOfSumSquares(G, H);     // F[1536]   b: F[1536]   a: F[2560]

    // k - example:  iSize = 0x100 = 256, j==0
    //         i:  0   1   2   3 
    //    kdx         10  20  30 
    // 80-kdx         70  60  50  
    // 80+kdx         90  a0  b0
    //100-kdx         f0  e0  d0  

#   if defined(PLATFORM_LPC_NO_TRIG_TABLE) || defined(PLATFORM_LPC_SMALL_TRIG_TABLE)

        assert( fabs(FLOAT_FROM_BP2(SL16)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy16,0)))<0.0001 
             && fabs(FLOAT_FROM_BP2(CL16)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy16,1)))<0.0001 );

        prvDoLpc4( iSizeBy16, Tmp+8, pWF, iSizeBy2, SL16, CL16 );

        assert( fabs(FLOAT_FROM_BP2(SL8)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy8,0)))<0.0001 
             && fabs(FLOAT_FROM_BP2(CL8)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy8,1)))<0.0001 );

        prvDoLpc4( iSizeBy8,  Tmp+16, pWF, iSizeBy2, SL8,  CL8 );

        assert( fabs(FLOAT_FROM_BP2(SL3by16)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy8 + iSizeBy16,0)))<0.0001 
             && fabs(FLOAT_FROM_BP2(CL3by16)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy8 + iSizeBy16,1)))<0.0001 );

        prvDoLpc4( iSizeBy8 + iSizeBy16, Tmp+24, pWF, iSizeBy2, SL3by16, CL3by16 );

#   else

        iMapLpcIdxOffset[0] = 0;  
        iMapLpcIdxOffset[1] = iSizeBy8;  
        iMapLpcIdxOffset[2] = iSizeBy8;  
        iMapLpcIdxOffset[3] = iSizeBy4;

        pTmp = Tmp+8;
        for( i = 1, jj = iSizeBy16; i<4; i++, pTmp += 8, jj = (i&1)*(iSizeBy16) ) 
        {
            k = iMapLpcIdxOffset[i] - jj;

            prvDoLpc4( k, pTmp, pWF, iSizeBy2, iShrink );
        }

#   endif

#   if defined(PLATFORM_LPC_SMALL_TRIG_TABLE)
        // 2 items per row, sample every fourth row.
        pC4 = &lpc_trig2048[(8<<iShrink)];
        pCInc4 = (8<<iShrink)-1;  // 1 of them gets done with ++
        // pC4 = lpc_Trigs[iShrink] + (2*4);
        // pCInc4 = 8-1;

        pC1 = &lpc_trig2048[(2<<iShrink)];
        pCInc1 = (2<<iShrink)-1;    // 1 of them gets done with ++;
        // pC1 = lpc_Trigs[iShrink] + 2;
        // pCInc1 = 1;

#   elif defined(PLATFORM_LPC_NO_TRIG_TABLE)

        assert( 64 <= iSize && iSize <= 2048 );

        pSinCosTable = rgSinCosTables[iSize>>7];
        S4  = pSinCosTable->sin_4PIbycSB;
        C4  = pSinCosTable->cos_4PIbycSB;
        S4p = 0;
        C4p = BP2_FROM_FLOAT(1.0f);
        STEP4 = MUL2(S4);

        S1  = BP2_FROM_BP1(pSinCosTable->sin_PIbycSB);
        C1  = BP2_FROM_BP1(pSinCosTable->cos_PIbycSB);
        S1p = 0;
        C1p = BP2_FROM_FLOAT(1.0f);
        STEP1 = BP2_FROM_BP1(pSinCosTable->two_sin_PIbycSB);

#   else   // so must be big lpc constants table

        pC4 = &lpc_cnst3[1*(4<<iShrink)];
        pCInc4 = (4<<iShrink)-3;  // 3 of them get done with ++

#   endif  // defined(PLATFORM_LPC_NO_TRIG_TABLE)

    for (j=1; j<iSizeBy16; j++ )
    {
#       if defined(PLATFORM_LPC_NO_TRIG_TABLE) || defined(PLATFORM_LPC_SMALL_TRIG_TABLE)
#           if !defined(PLATFORM_SPECIFIC_LPC_JLOOP_BOTTOM) || defined(PLATFORM_LPC_SMALL_TRIG_TABLE)
                BP2Type S2, C2;
#           endif
            BP2Type C8, S8;

#           if defined(PLATFORM_LPC_SMALL_TRIG_TABLE)
                S4 = *pC4++;                        // sin(x) = sin(pi*4*j/iSize)
                C4 = *pC4;                          // cos(x) = cos(pi*4*j/iSize)
                pC4 += pCInc4;
#           endif  // PLATFORM_LPC_SMALL_TRIG_TABLE

            assert( fabs(FLOAT_FROM_BP2(S4)-sin(PI*4*j/iSize)) < 0.0001 
                 && fabs(FLOAT_FROM_BP2(C4)-cos(PI*4*j/iSize)) < 0.0001 );

            CmS1 = -C4 + S4;                    // cnst3[i*(4<<iShrink)+3];
            CpS1 =  C4 + S4;                    // cnst3[i*(4<<iShinrk)+1];

            S8 = MUL2(MULT_BP2X(C4,S4));                        // sin(2x)
            C8 = BP2_FROM_FLOAT(1.0f) - MUL2(MULT_BP2X(S4,S4)); // cos(2x)
            CmS2 = -C8 + S8;                    // cnst3[i*(4<<iShrink)+2];
            CpS2 =  C8 + S8;                    // cnst3[i*(4<<iShink)];

#           if defined(PLATFORM_LPC_NO_TRIG_TABLE)
		        // rotate angle by b = 4*pi/iSize
		        // recursion: cos(a+b) = cos(a-b) + 2*sin(b)*sin(a)
		        // and:       sin(a+b) = sin(a-b) - 2*sin(b)*cos(a)
		        CT = C4p - MULT_BP2X(STEP4,S4);
		        ST = S4p + MULT_BP2X(STEP4,C4);
		        C4p = C4;  C4 = CT;
		        S4p = S4;  S4 = ST;
#           endif  // PLATFORM_LPC_NO_TRIG_TABLE

#       else    // PLATFORM_LPC_NO_TRIG_TABLE || PLATFORM_LPC_SMALL_TRIG_TABLE

            CpS2 = *pC4++;              // cnst3[i*(4<<iShink)];
            CpS1 = *pC4++;              // cnst3[i*(4<<iShinrk)+1];
            CmS2 = *pC4++;              // cnst3[i*(4<<iShrink)+2];
            CmS1 = *pC4;                // cnst3[i*(4<<iShrink)+3];
            pC4 += pCInc4;

#       endif
        assert( BP2_FROM_FLOAT(1) <= CpS2 && CpS2 <= BP2_FROM_FLOAT(1.5) );     

                                                        // F[j]
        Tmp[6]  = LP_SPEC_FROM_FLOAT(1) + (tCpS2x = MULT_BP2X(CpS2,original[7])) + (tCpS1x = MULT_BP2X(CpS1,original[3]));
                                                        // F[256-j]
        Tmp[14] = LP_SPEC_FROM_FLOAT(1) + (tCmS2x = MULT_BP2X(CmS2,original[7])) + tCpS1x;
                                                        // F[256+j]
        Tmp[22] = LP_SPEC_FROM_FLOAT(1) - tCpS2x - (tCmS1x = MULT_BP2X(CmS1,original[3]));    
        Tmp[30] = LP_SPEC_FROM_FLOAT(1) - tCmS2x + tCmS1x;  // F[512-j]
        Tmp[31] = LP_SPEC_FROM_FLOAT(1) + tCpS2x - tCpS1x;  // F[512+j]
        Tmp[23] = LP_SPEC_FROM_FLOAT(1) + tCmS2x - tCpS1x;  // F[768-j]
        Tmp[15] = LP_SPEC_FROM_FLOAT(1) - tCpS2x + tCmS1x;  // F[768+j]
        Tmp[7]  = LP_SPEC_FROM_FLOAT(1) - tCmS2x - tCmS1x;  // F[1024-j]
        
                                                        // F[1024+j]
        Tmp[0]  = original[1] + (tCpS2x = MULT_BP2X(CpS2,original[9])) + (tCpS1x = MULT_BP2X(CpS1,original[5]));
                                                        // F[1280-j]  
        Tmp[8]  = original[1] + (tCmS2x = MULT_BP2X(CmS2,original[9])) + tCpS1x;
                                                        // F[1280+j]  
        Tmp[16] = original[1] - tCpS2x - (tCmS1x = MULT_BP2X(CmS1,original[5]));
        Tmp[24] = original[1] - tCmS2x + tCmS1x;            // F[1536-j]
        Tmp[25] = original[1] + tCpS2x - tCpS1x;            // F[1536+j]
        Tmp[17] = original[1] + tCmS2x - tCpS1x;            // F[1792-j]
        Tmp[9]  = original[1] - tCpS2x + tCmS1x;            // F[1792+j]
        Tmp[1]  = original[1] - tCmS2x - tCmS1x;            // F[2048-j
        
                                                        // F[2048+j]  
        Tmp[2]  = original[0] + (tCpS2x = MULT_BP2X(CpS2,original[8])) + (tCpS1x = MULT_BP2X(CpS1,original[4]));
                                                        // F[2304-j]  
        Tmp[10] = original[0] + (tCmS2x = MULT_BP2X(CmS2,original[8])) + tCpS1x;
                                                        // F[2304+j]  
        Tmp[18] = original[0] - tCpS2x - (tCmS1x = MULT_BP2X(CmS1,original[4]));
        Tmp[26] = original[0] - tCmS2x + tCmS1x;            // F[2560-j]
        Tmp[27] = original[0] + tCpS2x - tCpS1x;            // F[2560+j]
        Tmp[19] = original[0] + tCmS2x - tCpS1x;            // F[2816-j]
        Tmp[11] = original[0] - tCpS2x + tCmS1x;            // F[2816+j]
        Tmp[3]  = original[0] - tCmS2x - tCmS1x;            // F[3072-j]
        
                                                        // F[3072+j] 
                                                        // F[3328-j]
        Tmp[4]  =  Tmp[12]  = original[2] + (tCpS1x = MULT_BP2X(CpS1,original[6]));
                                                        // F[3328+j] 
        Tmp[20] = original[2] - (tCmS1x = MULT_BP2X(CmS1,original[6]));
        Tmp[28] = original[2] + tCmS1x;                   // F[3584-j]
        Tmp[29] = original[2] - tCpS1x;                   // F[3584+j]
        Tmp[21] = original[2] - tCpS1x;                   // F[3840-j]
        Tmp[13] = original[2] + tCmS1x;                   // F[3840+j]
        Tmp[5]  = original[2] - tCmS1x;                   // F[4096-j]
        
        //** this block uses 52 adds and 14 mults??
       

        // example:  iSize = 0x100 = 256.
        //            j==1         |   j==2          |  j==3
        //       i:  0   1   2   3 |   0   1   2   3 |  0
        //    k      1  1f  21  3f |   2  1e  22  3e |  3 ...
        // 80+k     81  9f  a1  bf |  82  9e  a2  be | 83 ...
        // 80-k     7f  61  5f  41 |  7e  62  5e  42 | 7e ...
        //100-k     ff  e1  df  c1 |  fe  e2  de  c2 | fd ...


#if defined(PLATFORM_LPC_NO_TRIG_TABLE) || defined(PLATFORM_LPC_SMALL_TRIG_TABLE)

#   if defined(PLATFORM_SPECIFIC_LPC_JLOOP_BOTTOM) && defined(PLATFORM_LPC_NO_TRIG_TABLE)
        prvLpcJLoopBottom( j, Tmp, pWF, iSizeBy2, &S1, &C1, &S1p, &C1p, STEP1 );
#   else    //  defined(PLATFORM_SPECIFIC_LPC_JLOOP_BOTTOM)
#       if defined(PLATFORM_LPC_SMALL_TRIG_TABLE)
            S1 = *pC1++;                        // sin(x) = sin(pi*4*j/iSize)
            C1 = *pC1;                          // cos(x) = cos(pi*4*j/iSize)
            pC1 += pCInc1;
#       endif  // PLATFORM_LPC_SMALL_TRIG_TABLE

        assert( fabs(FLOAT_FROM_BP2(S1)-sin(PI*j/iSize)) < 0.0001 
             && fabs(FLOAT_FROM_BP2(C1)-cos(PI*j/iSize)) < 0.0001 );

        prvDoLpc4( j, Tmp, pWF, iSizeBy2, S1, C1 );

        S2 = (SLC1 = MULT_BP2X(SL8,C1)) - (CLS1 = MULT_BP2X(CL8,S1));
        C2 = (CLC1 = MULT_BP2X(CL8,C1)) + (SLS1 = MULT_BP2X(SL8,S1));
        assert( fabs(FLOAT_FROM_BP2(S2)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy8-j,0)))<0.0001 
             && fabs(FLOAT_FROM_BP2(C2)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy8-j,1)))<0.0001 );
        prvDoLpc4( iSizeBy8 - j, Tmp+8,  pWF, iSizeBy2, S2, C2 );

        S2 = SLC1 + CLS1;
        C2 = CLC1 - SLS1;
        assert( fabs(FLOAT_FROM_BP2(S2)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy8+j,0)))<0.0001 
             && fabs(FLOAT_FROM_BP2(C2)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy8+j,1)))<0.0001 );
        prvDoLpc4( iSizeBy8 + j, Tmp+16, pWF, iSizeBy2, S2, C2 );

        S2 = MULT_BP2X(SL4,C1) - MULT_BP2X(CL4,S1);
        C2 = MULT_BP2X(CL4,C1) + MULT_BP2X(SL4,S1);
        assert( fabs(FLOAT_FROM_BP2(S2)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy4-j,0)))<0.0001 
             && fabs(FLOAT_FROM_BP2(C2)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy4-j,1)))<0.0001 );
        prvDoLpc4( iSizeBy4 - j, Tmp+24, pWF, iSizeBy2, S2, C2 );

#       if defined(PLATFORM_LPC_NO_TRIG_TABLE)
		    // rotate angle by b = pi/iSize
		    // recursion: cos(a+b) = cos(a-b) + 2*sin(b)*sin(a)
		    // and:       sin(a+b) = sin(a-b) - 2*sin(b)*cos(a)
		    CT = C1p - MULT_BP2X(STEP1,S1);
		    ST = S1p + MULT_BP2X(STEP1,C1);
		    C1p = C1;  C1 = CT;
		    S1p = S1;  S1 = ST;
#       endif  // defined(PLATFORM_LPC_NO_TRIG_TABLE)
#   endif // defined(PLATFORM_SPECIFIC_LPC_JLOOP_BOTTOM)
#else

        pTmp = Tmp;
        for( i = 0, jj = j; i<4; i++, pTmp += 8, jj = -jj ) 
        {
            k = iMapLpcIdxOffset[i] + jj;

            prvDoLpc4( k, pTmp, pWF, iSizeBy2, iShrink );    
        }
    
#endif

    }
    //** this loop uses (512>>iShrink) * (36 adds and 24 mults)
    
    //** total to here: 
    //**   (46 adds and 14 mults) + (N/16) * (52 adds and 14 mults) + (N/4) * (36 adds and 24 mults)
    //** TA = 46 + 3.25N + 9N      = 46 + 12.250N
    //** TM = 14 + (14/16)N + 6*N  = 14 +  6.875N
    //** An FFT takes order N*log(N)
    //** so we may need to substitute an optimized FFT for this on some platforms.
    
    // The inverse quad root has already been computed. Copy to destination, find max etc remain here.
    
    rgwtLpcSpec  = INTEGER_OR_INT_FLOAT( (I32 *)ppcinfo->m_rguiWeightFactor, ppcinfo->m_rgfltWeightFactor ); 
    wtLpcSpecMax = WEIGHT_FROM_FLOAT(0.0F);
    iLoopLimit   = pau->m_cSubband;
    
    for (iFreq = 0, iF = 0; iFreq < iLoopLimit; iFreq++, iF += iStride) 
    {
        LPC_COMPARE_DEBUG( pau, iFreq, iFreq, iF, pWF, rgLpcCoef );

        wtTemp = pWF[iFreq];

        if ( wtTemp > wtLpcSpecMax )
            wtLpcSpecMax = wtTemp;
        
        INTEGER_ONLY( assert( wtTemp>= 0 ); );
        MONITOR_RANGE(gMR_rgfltWeightFactor,wtTemp);                                
        MONITOR_RANGE(gMR_fltLPC_F3,pWF[iFreq]);
    }
    
	WF_PRINT(pWF);

    if (wtLpcSpecMax == WEIGHT_FROM_FLOAT(0.0F))
    {
        FUNCTION_PROFILE_STOP(&fp);
        return TraceResult(WMA_E_FAIL);
    }
    
#if defined(INTEGER_ENCODER)
    ppcinfo->m_iMaxWeight = wtLpcSpecMax;
#endif
    ppcinfo->m_wtMaxWeight = wtLpcSpecMax;
    
    FUNCTION_PROFILE_STOP(&fp);
    return WMA_OK;
}

#else  // defined(PLATFORM_LPC_FOLDED_PRUNED) && !defined(V4V5_COMPARE_MODE)
# include "lpc_variants.c"
#endif // defined(PLATFORM_LPC_FOLDED_PRUNED) && !defined(V4V5_COMPARE_MODE)

#endif // (V4V5_COMPARE_MODE && BUILD_INT_FLOAT) and then the opposite

#ifdef REPLICATE_V4_LPC
#   pragma COMPILER_MESSAGE(__FILE__ "(1139) : Warning - Built with REPLICATE_V4_LPC!")
#endif


#if defined(_DEBUG) && defined(LPC_COMPARE)

void prvSetupLpcSpecTrig(CAudioObject* pau) 
{
    // precompute trig functions used in the slow spectral method used for comparision
    Int iFreq, i; 
    
    for (i = 0; i < LPCORDER; i++)  {
        if ( pau->m_rgfltLpsSpecCos [i] == NULL )
            pau->m_rgfltLpsSpecCos [i] = (Float*) wmvalloc (sizeof (Float) * MAX_LP_SPEC_SIZE);
        if ( pau->m_rgfltLpsSpecSin [i] == NULL );
            pau->m_rgfltLpsSpecSin [i] = (Float*) wmvalloc (sizeof (Float) * MAX_LP_SPEC_SIZE);
        assert( pau->m_rgfltLpsSpecCos [i] != NULL && pau->m_rgfltLpsSpecSin [i] != NULL );
    }
    if ( pau->m_rgfltLpsSpecCos [LPCORDER-1] != NULL && pau->m_rgfltLpsSpecSin [LPCORDER-1] != NULL )
    {
        for (iFreq = 0; iFreq < MAX_LP_SPEC_SIZE; iFreq++)   
        {
#           if defined(REPLICATE_V4_LPC) || defined(V4V5_COMPARE_MODE)
                Float  Temp = (Float)((iFreq) * PI / MAX_LP_SPEC_SIZE);
#           else
                Double Temp = ((iFreq) * PI / MAX_LP_SPEC_SIZE);
#           endif
            for (i = 0; i < LPCORDER; i++)  
            {
                pau->m_rgfltLpsSpecCos [i] [iFreq] = (Float) cos ((i + 1) * Temp);
                pau->m_rgfltLpsSpecSin [i] [iFreq] = (Float) sin ((i + 1) * Temp);
            }
        }
    }
}

#endif  // _DEBUG


#endif //defined(ENABLE_ALL_ENCOPT) && defined(ENABLE_LPC)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\lpc_variants.c ===
#include "bldsetup.h"


// included from lpc.c

// ***********************************************************************************
// ***********************************************************************************
//
// LPC to Spectrum 
//
// There are four versions of this routine.
// A: Direct computation
// B: One that calls the DCT's FFT routine instead of taking advantage of the zeros
// C: one that takes advantage of the large number of zeros to reduce compuatation
// D: like A but which attempts to duplicate the numerics of V4/V5
//
// ************************************************************************************
// ************************************************************************************

#if defined(PLATFORM_LPC_DIRECT) && !defined(V4V5_COMPARE_MODE)

#pragma COMPILER_MESSAGE(__FILE__ "(20) : Warning - building PLATFORM_LPC_DIRECT LPC spectrum.")

// ************************************************************************************
//
// LPC to Spectrum using direct computation 
//
// Not the fastest generally, but it takes the minimum amount of memory 
// and so flushes the cache the minimum of any of these methods.
//
// ************************************************************************************

WMARESULT prvLpcToSpectrum(CAudioObject* pau, const LpType* rgLpcCoef, PerChannelInfo* ppcinfo)
{
    LpSpecType* F = INTEGER_OR_INT_FLOAT( ppcinfo->m_rgiWeightFactor, ppcinfo->m_rgfltWeightFactor ); 
    Int i;
    
    WeightType* rgwtLpcSpec;
    WeightType  wtLpcSpecMax, wtTemp;
    Int iFreq, iF, iLoopLimit;
    
#ifdef REPLICATE_V4_LPC
    Int iSize = pau->m_cFrameSampleHalf;
#else
    Int iSize;
    if (pau->m_fV5Lpc)
        iSize = pau->m_cSubband;
    else 
        iSize = pau->m_cFrameSampleHalf;
#endif
    Int iStride = MAX_LP_SPEC_SIZE/iSize;
    BP2Type bp2Cos_i, bp2Sin_i, bp2Cos_i1, bp2Sin_i1, bp2Step_i;
    BP2Type bp2Cos_j, bp2Sin_j, bp2Cos_j1, bp2Sin_j1, bp2Step_j;
    BP2Type bp2CosT, bp2SinT;
    const SinCosTable* pSinCosTable;
    
    FUNCTION_PROFILE(fp);
    FUNCTION_PROFILE_START(&fp,LPC_TO_SPECTRUM_PROFILE);
    
    // DEBUG_ONLY( if (pau->m_iFrameNumber==32) { DEBUG_BREAK(); } );
    
    assert(pau->m_fltFlatenFactor == 0.5f); //So we can use quadRoot instead of pow(x,m_fltFlatenFactor/2);
    assert( iSize <= MAX_LP_SPEC_SIZE );
    
    // sin(a+b) = sin(a-b) + 2*sin(b)*cos(a)
    // cos(a+b) = cos(a-b) - 2*sin(b)*sin(a)
    pSinCosTable = rgSinCosTables[iSize>>7];
    bp2Cos_j1 = bp2Cos_j  = bp2Cos_i = BP2_FROM_FLOAT(1);
    bp2Step_j = bp2Sin_j1 = bp2Sin_j = bp2Sin_i = BP2_FROM_FLOAT(0);
    bp2Cos_i1 =  BP2_FROM_BP1(pSinCosTable->cos_PIbycSB);                           // BP2_FROM_FLOAT( cos( -PI/iSize ) );
    bp2Sin_i1 = -BP2_FROM_BP1(pSinCosTable->sin_PIbycSB);                           // BP2_FROM_FLOAT( sin( -PI/iSize ) );
    bp2Step_i = INTEGER_OR_INT_FLOAT( pSinCosTable->sin_PIbycSB, -MUL2(bp2Sin_i1) );        // 2*sin(PI/iSize)
    for( i = 0, iF = 0; i<iSize; i++, iF += iStride )
    {
        LpSpecType R = 1;
        LpSpecType I = 0;
        int j;
        for (j = 0; j < LPCORDER; j++)  
        {
            R -= MULT_BP2( LP_SPEC_FROM_LP(rgLpcCoef [j]), bp2Cos_j );
            I -= MULT_BP2( LP_SPEC_FROM_LP(rgLpcCoef [j]), bp2Sin_j );
            bp2SinT = bp2Sin_j1 + MULT_BP2(bp2Step_j,bp2Cos_j);
            bp2CosT = bp2Cos_j1 - MULT_BP2(bp2Step_j,bp2Sin_j);
            bp2Sin_j1 = bp2Sin_j;  bp2Sin_j = bp2SinT;
            bp2Cos_j1 = bp2Cos_j;  bp2Cos_j = bp2CosT;
        }
        F[i] = SQUARE( R ) + SQUARE( I );
        INTEGER_ONLY( assert( F[i] >= 0 ) );
        LPC_FT_PRINT(pau->m_iFrameNumber,pau->m_iCurrSubFrame,i,R,I,F[i]);
        bp2SinT = bp2Sin_i1 + MULT_BP2(bp2Step_i,bp2Cos_i);
        bp2CosT = bp2Cos_i1 - MULT_BP2(bp2Step_i,bp2Sin_i);
        bp2Sin_i1 = bp2Sin_i;  bp2Sin_j = bp2Sin_i = bp2SinT;
        bp2Cos_i1 = bp2Cos_i;  bp2Cos_j = bp2Cos_i = bp2CosT;
        bp2Sin_j1 = BP2_FROM_FLOAT(0);
        bp2Cos_j1 = BP2_FROM_FLOAT(1);
        bp2Step_j = MUL2( bp2Sin_j );
        // This takes 10*2*N multiplies and 10*2*N additions
        // Plus 2*N multiplies and N Additions
        // total = 22*N multiplies and 21*N additions
        // cache use is 4*N + 2048*10*4*2 = 160k +4N !!!
    }
    
    // the remainder should be identical to the other versions of this routine
    
    rgwtLpcSpec  = INTEGER_OR_INT_FLOAT( ppcinfo->m_rgiWeightFactor, ppcinfo->m_rgfltWeightFactor ); 
    wtLpcSpecMax = WEIGHT_FROM_FLOAT(0.0F);
    iLoopLimit   = pau->m_cSubband;
    
    for (iFreq = 0, iF = 0; iFreq < iLoopLimit; iFreq++, iF += iStride)     
    {
        LPC_COMPARE_DEBUG( pau, iFreq, iFreq, iF, F, rgLpcCoef );
        LPC_SPEC_PRINT(pau->m_iFrameNumber,pau->m_iCurrSubFrame,iFreq,F[iFreq],InverseQuadRoot(F[iFreq]));
        
        rgwtLpcSpec [iFreq] = wtTemp = InverseQuadRoot(F[iFreq]);
        
        if ( wtTemp > wtLpcSpecMax )
            wtLpcSpecMax = wtTemp;
        
        INTEGER_ONLY( assert( wtTemp>= 0 ); );
        MONITOR_RANGE(gMR_rgfltWeightFactor,wtTemp);                                                            
        MONITOR_RANGE(gMR_fltLPC_F3,F[iFreq]);
    }
    
    if (wtLpcSpecMax == WEIGHT_FROM_FLOAT(0.0F))
    {
        FUNCTION_PROFILE_STOP(&fp);
        return TraceResult(WMA_E_FAIL);
    }
    
#if defined(INTEGER_ENCODER)
    ppcinfo->m_iMaxWeight = wtLpcSpecMax;
#endif
    ppcinfo->m_wtMaxWeight = wtLpcSpecMax;
    
    FUNCTION_PROFILE_STOP(&fp);
    return WMA_OK;
}

#endif  // defined(PLATFORM_LPC_DIRECT) && !defined(V4V5_COMPARE_MODE)


#if defined(PLATFORM_LPC_LITDFT) && !defined(V4V5_COMPARE_MODE)

#pragma COMPILER_MESSAGE(__FILE__ "(142) : Warning - building PLATFORM_LPC_LITDFT LPC spectrum")

// ************************************************************************************
//
// LPC to Spectrum using Transform Decomposition DFT for a subset of input points
//
// See Sorensen & Burrus, "Efficent computation of the DFT with only a subset of input
// and ouput points", IEEE Trans. Signal Processing, Vol 41, No 3, March 1993, p1184-1200.
//
// Their algorithm is further reduced by taking advantage that the input is real.
//
// 
//
// ************************************************************************************

WMARESULT prvLpcToSpectrum(CAudioObject* pau, const LpType* rgLpcCoef, PerChannelInfo* ppcinfo)
{
    // compute in place reduces cahce use
    LpSpecType* F = INTEGER_OR_INT_FLOAT( ppcinfo->m_rgiWeightFactor, ppcinfo->m_rgfltWeightFactor );
    LpSpecType* pF;
    Int i,j,k;
    
    LpSpecType* rgwtLpcSpec;
    WeightType wtLpcSpecMax, wtTemp;
    Int iFreq, iF, iLoopLimit;
    
#ifdef REPLICATE_V4_LPC
    Int iSize = pau->m_cFrameSampleHalf;
#else
    Int iSize;
    if (pau->m_fV5Lpc)
        iSize = pau->m_cSubband;
    else 
        iSize = pau->m_cFrameSampleHalf;
#endif
    Int iStride = MAX_LP_SPEC_SIZE/iSize;
    extern void prvFFT4DCT(CoefType data[], Int nLog2np, FftDirection fftDirection);
    extern void four1(float data[], unsigned long nn, int isign);
    const BP2Type* pTrig = &rgBP2LpcLitdftTrig[2*LPCORDER*iStride];
    DEBUG_ONLY( double dDiff; )
        
        // Sorensen & Burrus' parameters
        const Int iN   = iSize; 
    const Int iNhalf  = iN>>1;
#       define LL (LPCORDER+1)
#       define PP  32
#       define LOGPP 5
#       define LL2 (2*LL)
#       define PP2 (2*PP)
#       define PPH (PP>>1)
    const Int iQ   = iN>>LOGPP;     // 64 to 4.
    const int iQ2  = iQ<<1;
    LpSpecType X[LL], XX[PP2*2], *pX, *pXX;      
    extern void prvFFT32( LpSpecType XXD[] );
    
    FUNCTION_PROFILE(fp);
    FUNCTION_PROFILE_START(&fp,LPC_TO_SPECTRUM_PROFILE);
    
    // DEBUG_ONLY( if (pau->m_iFrameNumber==32) { DEBUG_BREAK(); } );
    
    assert(pau->m_fltFlatenFactor == 0.5f); //So we can use quadRoot instead of pow(x,m_fltFlatenFactor/2);
    assert( iSize <= MAX_LP_SPEC_SIZE );
    assert( LL <= PP && (1<<LOG2(PP)) == PP);
    
#if defined(_DEBUG) && 0
    {       // this should match calculations in decoder\WMAConcepts.xls!SRFFT32
        LpSpecType XXD[PP2*2];      
        for( k = 0; k < 32; k++ )
        {
            XXD[2*k] = (((float)k)/PP)-(k>PPH ? 1 : 0);
            XXD[2*k+1] = 0;
        }
        prvFFT32( XXD );
    }
#endif
    
    pX = &X[0];
    *pX++ = LP_SPEC_FROM_FLOAT(1.0f);
    for (i = 1; i <= LPCORDER; i++) 
    {
        *pX++ = -(LP_SPEC_FROM_LP(rgLpcCoef[i-1]));
    }
    
    
    for( j = 1; j < iQ; j++ )
    {
        memset( XX+LL2, 0, sizeof(LpSpecType)*(PP2-LL2) );
        assert( (dDiff = fabs(FLOAT_FROM_BP2(pTrig[1])+sin((PI*j)/iN))) < 0.0001 );
        XX[0] = X[0];
        XX[1] = 0;
        pX = &X[1];
        pXX = &XX[2];
        for( k = 1; k<LL; k++, pX++ )
        {
            assert( (dDiff = fabs(FLOAT_FROM_BP2(pTrig[1])+sin((PI*j*k)/iN))) < 0.0001 );
            *pXX++ =  MULT_BP2(pTrig[0],*pX);
            *pXX++ =  MULT_BP2(pTrig[1],*pX);
            pTrig += 2;
        }
        //prvFFT4DCT( XX, LOGPP, FFT_FORWARD );  
        prvFFT32( XX );
        for( k = 0, pXX = &XX[0], pF = &F[j];  k<PPH;  k++, pXX += 2, pF += iQ2 )
        {
            *pF = SQUARE( pXX[0] ) + SQUARE( pXX[1] );
            LPC_FT_PRINT(pau->m_iFrameNumber,pau->m_iCurrSubFrame,2*iQ*k+j,XX[2*k],XX[2*k+1],F[2*iQ*k+j]);
        }
        for( k = 0, pF = &F[iSize-j];  k<PPH;  k++, pXX += 2, pF -= iQ2 )
        {
            *pF = SQUARE( pXX[0] ) + SQUARE( pXX[1] );
            LPC_FT_PRINT(pau->m_iFrameNumber,pau->m_iCurrSubFrame,iSize-(2*iQ*k+j),XX[PP+2*k],XX[PP+2*k+1],F[iSize-(2*iQ*k+j)]);
        }
        pTrig += (iStride-1)*20;
    }
    memset( XX, 0, sizeof(LpSpecType)*PP2*2 );      // all the imaginary parts must be zeroed
    for( k = 0, pX = &X[0], pXX = &XX[0]; 
    k<LL; 
    k++, pXX += 2 )
    {
        *pXX = *pX++;
    }
    prvFFT4DCT( XX, LOGPP+1, FFT_FORWARD );
    F[0] = SQUARE( XX[0] );         // XX[1] == 0
    for( k=1, pXX = &XX[2], pF = &F[iQ]; 
    k<PP; 
    k++, pXX += 2, pF += iQ )
    {
        *pF = SQUARE( pXX[0] ) + SQUARE( pXX[1] );
        LPC_FT_PRINT(pau->m_iFrameNumber,pau->m_iCurrSubFrame,iQ*k,XX[2*k],XX[2*k+1],F[iQ*k]);
    }
    
    // the remainder should be identical to the other versions of this routine
    
    rgwtLpcSpec  = INTEGER_OR_INT_FLOAT( ppcinfo->m_rgiWeightFactor, ppcinfo->m_rgfltWeightFactor ); 
    wtLpcSpecMax = WEIGHT_FROM_FLOAT(0.0F);
    iLoopLimit   = pau->m_cSubband;
    
    for (iFreq = 0, iF = 0; iFreq < iLoopLimit; iFreq++, iF += iStride)     
    {
        LPC_COMPARE_DEBUG( pau, iFreq, iFreq, iF, F, rgLpcCoef );
        LPC_SPEC_PRINT(pau->m_iFrameNumber,pau->m_iCurrSubFrame,iFreq,F[iFreq],InverseQuadRoot(F[iFreq]));
        
        rgwtLpcSpec [iFreq] = wtTemp = InverseQuadRoot(F[iFreq]);
        
        if ( wtTemp > wtLpcSpecMax )
            wtLpcSpecMax = wtTemp;
        
        INTEGER_ONLY( assert( wtTemp>= 0 ); );
        MONITOR_RANGE(gMR_rgfltWeightFactor,wtTemp);                                                            
        MONITOR_RANGE(gMR_fltLPC_F3,F[iFreq]);
    }
    
    if (wtLpcSpecMax == WEIGHT_FROM_FLOAT(0.0F))
    {
        FUNCTION_PROFILE_STOP(&fp);
        return TraceResult(WMA_E_FAIL);
    }
    
#if defined(INTEGER_ENCODER)
    ppcinfo->m_iMaxWeight = wtLpcSpecMax;
#endif
    ppcinfo->m_wtMaxWeight = wtLpcSpecMax;
    
    FUNCTION_PROFILE_STOP(&fp);
    return WMA_OK;
}


#endif  // defined(PLATFORM_LPC_LITDFT) && !defined(V4V5_COMPARE_MODE)


#if defined(PLATFORM_LPC_FOLDED) && !defined(V4V5_COMPARE_MODE)

// ************************* Reverse Engineered ARM's LPC2Spec.s **************************

#pragma COMPILER_MESSAGE(__FILE__ "(316) : Warning - building PLATFORM_LPC_FOLDED LPC spectrum - undebugged!!!")

// ************************************************************************************
//
// ARM's LPC2Spec.s translated into c
//
// Features no large stack array.
//
// Unlike ARM's asm code, there is no bit-reversal needed so indexing is easier and less 
// obscure dependencies on having a free shift in every instruction.
//
// ************************************************************************************

#ifndef CMPX_MULT_BP2
    INLINE void LpComplexTwiddle( LpSpecType* pa, LpSpecType* pb, LpSpecType x, LpSpecType y, BP2Type cr, BP2Type ci )
    {
        *pa = MULT_BP2(x,cr) - MULT_BP2(y,ci);
        *pb = MULT_BP2(x,ci) + MULT_BP2(y,cr);
    }
#   define CMPX_MULT_BP2(pa,pb,x,y,cr,ci) LpComplexTwiddle(pa,pb,x,y,cr+ci,ci)
#endif

// helper function - compute 4 WeightFactors from 4 pairs of input data and one set of 6 LPC constants
// called three times:
//   prvPowerCalcZero( 0x10, 0x1C, iSizeBy4, pWF, 6*510, Tmp );
//   prvPowerCalcZero( 0x08, 0x0C, iSizeBy4, pWF,     0, Tmp );
//   prvPowerCalcZero( 0x18, 0x14, iSizeBy4, pWF, 6*512, Tmp );

static void prvPowerCalcZero( int i, int j, int iOff, LpSpecType* pWF, int idxLpc, LpSpecType* pTmp )
{
    LpSpecType i1, i2, i3, i4, i5, i6, x, y, t1x, i5b, r3;
    const BP2Type* pLpc4 = lpc_cnst4+idxLpc;

    // {i3,i4} = {x,y}++ * {Lpc[3],Lpc[2]} 
    x = *pTmp++;  y = *pTmp++;                                      // T0 T1
    CMPX_MULT_BP2( &i4, &i3, x, y, pLpc4[3], pLpc4[2] );            // {t0,t1} = {T0,T1} * {W3,W2}

    // {i6,i5} = {x,y}++ * {Lpc[5],Lpc[4]}
    x = *pTmp++;  y = *pTmp++;                                      // T2 t3
    CMPX_MULT_BP2( &i6, &i5, x, y, pLpc4[5], pLpc4[4] );            // {t2,t3} = {T2,T3} * {W5,W4}

    // {i2,i1} = {x,y}++ * {Lpc[1],Lpc[0]}
    x = *pTmp++;  y = *pTmp++;                                      // T4 T5
    CMPX_MULT_BP2( &i2, &i1, x, y, pLpc4[1], pLpc4[0] );            // {t4,t5} = {T4,T5} * {W1,W0}

    // trivial Complex Multiply
    x = *pTmp++;  y = *pTmp++;                                      // T6 T7 
    x = x - y;                                                      // T6 - T7
    y = x + MUL2(y);     // original x + y                          // T6 + T7

    i5 += i3 + i1;                                                  // t3 + t1 + t5

    i1 = i5 - MUL2(i1 + i3) - i4 + x;                               // t3 - t1 - t5 - t0 + T6 - T7

    i5 += y;                                                        // t3 + t1 + t5 + T6 + T7
    i3 -= y;                                                        // t1 - T6 - T7

    t1x = i3 + MUL2(y);                                             // t1 + T6 + T7
    i5b = MUL2(t1x) - i5;                                           // t1 + T6 + T7 - t3 - t5

    r3 = i2 - i6 - i3;                                              // t4 - t2 - t1 + T6 + T7
    i3 = i6 - i3 - i2;                                              // t2 - t1 + T6 + T7 - t4

    t1x = i4 + i6 + i2 + x;                                         // t0 + t2 + t4 + T6 - T7

    i6 = i6 + i2 - i4 - x;                                          // t2 + t4 - t0 - T6 + T7;

    i4 = i1 + MUL2(i4) - MUL2(x);                                   // t3 - t5 + t0 - T6 + T7

    i5 = DIV2(i5);  t1x = DIV2(t1x);
    pWF[i] = InverseQuadRootOfSumSquares( i5, t1x );                // f( t3 + t1 + t5 + T6 + T7, 
                                                                    //    t0 + t2 + t4 + T6 - T7)
    
    i1 = DIV2(i1);  r3 = DIV2(r3);
    pWF[i^iOff] = InverseQuadRootOfSumSquares( i1, r3 );            // f( t3 - t1 - t5 - t0 + T6 - T7, 
                                                                    //    t4 - t2 - t1 + T6 + T7)

    i3 = DIV2(i3);  i4 = DIV4(i4);
    pWF[j] = InverseQuadRootOfSumSquares( i3, i4 );                 // f( t2 - t1 + T6 + T7 - t4, 
                                                                    //    t3 - t5 + t0 - T6 + T7)

    i5b = DIV2(i5b);  i6 = DIV2(i6);
    pWF[j^iOff] = InverseQuadRootOfSumSquares( i5b, i6 )  ;         // f( t1 + T6 + T7 - t3 - t5, 
                                                                    //    t2 - t0 + t4 - T6 + T7 )
}

// ********************************************************************************************
// This is the inner loop of the Lpc Spectrum calculation
// m_cSubband     2048    1024     512      256       128
// # times called  127      63      31       15         7
// 
static void prvLpcCalc4( const Int idx, const Int iSize, 
                         const BP2Type* pBP2Lpc4, const LpSpecType* pTmp, LpSpecType *pWF )
{
    LpSpecType i1, i2, i3, i4, i5, i6, x, y, I, i3b, i2b, i5b, t0x;
    Int jdx, kdx;
    Int iSizeBy2 = iSize>>1;
    Int iSizeBy4 = iSize>>2;
    Int iSizeBy8 = iSize>>3;

#define LPC_BREAK_IDX 8
#if defined(_DEBUG) && defined(LPC_BREAK_IDX)
        if ( idx == LPC_BREAK_IDX )
            DEBUG_BREAK();
#endif

    for( jdx =0;  jdx < 4; jdx++, pBP2Lpc4 += 6 ) {

        // {i3,i4} = ({x,y}++ * {Lpc4[3],Lpc4[2]} )*4
        x = *pTmp++;  y = *pTmp++;                                  // T0 T1
        CMPX_MULT_BP2( &i4, &i3, x, y, pBP2Lpc4[3], pBP2Lpc4[2] );  // {t0,t1} = {T0,T1} * {W3,W2}

        // {i6,i5} = {x,y}++ * {Lpc4[5],Lpc4[4]}
        x = *pTmp++;  y = *pTmp++;                                  // T2 t3
        CMPX_MULT_BP2( &i6, &i5, x, y, pBP2Lpc4[5], pBP2Lpc4[4] );  // {t2,t3} = {T2,T3} * {W5,W4}

        // {i2,i1} = {x,y}++ * {Lpc4[1],Lpc4[0]}
        x = *pTmp++;  y = *pTmp++;                                  // T4 T5
        CMPX_MULT_BP2( &i2, &i1, x, y, pBP2Lpc4[1], pBP2Lpc4[0] );  // {t4,t5} = {T4,T5} * {W1,W0}

        x = *pTmp++;  y = *pTmp++;                                  // T6 T7 

        t0x = (x-y);                                                // T6 - T7
        y = x + y + LP_SPEC_FROM_FLOAT(2.0f);                            // T6 + T7 + 2

        I  = -i4 + i5 - i1 + t0x;                                   // -t0 + t3 - t5 + T6 - T7
        i5 =  i3 + i5 + i1 + y;                                     // t1 + t3 + t5 + T6 + T7 + 2
        i3b =  i3 + y;                                              // t1 + T6 + T7 + 2
        i3 -= y;                                                    // t1 - T6 - T7 - 2

        i5b = MUL2(i3b) - i5;                                       // t1 + T6 + T7 + 2 - t3 - t5
        i3b = i4 + i6 + i2 + t0x;                                   // t0 + t2 + t4 + T6 - T7

        switch (jdx) {
        case 0:  kdx = idx; break;
        case 1:  kdx = iSizeBy8 - idx; break;
        case 2:  kdx = iSizeBy8 + idx; break;
        default: kdx = iSizeBy4 - idx;
        }
        // example:  iSize = 0x100 = 256.
        //            idx==1         | idx==2          | idx==3
        //       jdx:  0   1   2   3 |   0   1   2   3 |  0
        //    kdx      1  1f  21  3f |   2  1e  22  2e |  3 ...
        // 80+kdx     81  9f  a1  bf |  82  9e  a2  be | 83 ...
        // 80-kdx     7f  61  5f  41 |  7e  62  5e  42 | 7e ...
        //100-kdx     ff  e1  df  c1 |  fe  e2  de  c2 | fd ...

        i5 = DIV2(i5);  i3b = DIV2(i3b);
        pWF[kdx] = InverseQuadRootOfSumSquares( i5, i3b );          // (t1 + t3 + t5 + T6 + T7 + 2, t0 + t2 + t4 + T6 - T7)

        i2b = i6 - i2;                                              // t2 - t4
        i6  = MUL4(i6 + i2) - i4 - t0x;                             // t2 + t4 - t0 - T6 - T7
        i4  = MUL2(i4) + I - MUL2(t0x);                             // t0 + t3 - t5 - T6 + T7
        y   = i2b + i3;                                             // t2 - t4 + t1 - T6 - T7 - 2

        I = DIV2(I);  y = DIV2(I);
        pWF[iSizeBy2+kdx] = InverseQuadRootOfSumSquares( I, y );    // (-t0 + t3 - t5 + T6 - T7, t2 - t4 + t1 - T6 - T7 - 2)

        y = i2b - i3;                                               // t2 - t4 - t1 + T6 + T7 + 2

        i4 = DIV2(I);  y = DIV2(y);
        pWF[iSizeBy2-kdx] = InverseQuadRootOfSumSquares( i4, y );   // (t0 + t3 - t5 - T6 + T7, t2 - t4 + t1 - T6 - T7 - 2)

        i5b = DIV2(i5b);  i6 = DIV2(i6);
        pWF[iSize-kdx] = InverseQuadRootOfSumSquares( i5b, i6 );    // (t1 + T6 + T7 + 2 - t3 - t5, t2 + t4 - t0 - T6 - T7)
    }
}


WMARESULT prvLpcToSpectrum(CAudioObject* pau, const LpType* rgLpcCoef, PerChannelInfo* ppcinfo) {
    int iStride, iLoops, idx, i;
    int iStridem1x24, iMainLpc4Offset, iMainLpc4Stride, iMainLpc4Delta;
    LpSpecType Tmp[32];
    const BP2Type* pbp2Lpc3;
    const BP2Type* pBP2Lpc4;
    LpSpecType *pWF = (LpSpecType *)pau->m_rguiWeightFactor;  
    LpType LPC[LPCORDER];
    LpSpecType jv0, jv1, jv2, jv3, jv4, jv5, jv6, jv7, jv8, jv9, jv10, jv11, jv12;
#if 1
    LpSpecType iv0, iv1, iv2, iv3, iv4, iv5, iv6, iv7, iv8, iv9;
    LpSpecType k0, k1, k2, k3, k4, k5, k6, k8, k9, k10, kx;
#else
    // these register sets do not get used at the same time, so save a little stack space
#   define iv0 jv0
#   define iv1 jv1
#   define iv2 jv2
#   define iv3 jv3
#   define iv4 jv4
#   define iv5 jv5
#   define iv6 jv6
#   define iv7 jv7
#   define iv8 jv8
#   define iv9 jv9
#   define t0  jv10
#   define k0 jv0
#   define k1 jv1
#   define k2 jv2
#   define k3 jv3
#   define k4 jv4
#   define k5 jv5
#   define k6 jv6
#   define k8 jv8
#   define k9 jv9
#   define k10 jv10
#   define kx jv11
#endif
    LpSpecType wtLpcSpecMax = WEIGHT_FROM_FLOAT(0.0F);
    int iFreq, iF;

#ifdef REPLICATE_V4_LPC
    const Int iSize = pau->m_cFrameSampleHalf;
#else
    const Int iSize = (pau->m_fV5Lpc) ? pau->m_cSubband : pau->m_cFrameSampleHalf;
#endif
    const Int iSizeBy2 = iSize>>1;
    const Int iSizeBy4 = iSize>>2;
    const Int iSizeBy16 = iSize>>4;        

    FUNCTION_PROFILE(fp);
    FUNCTION_PROFILE_START(&fp,LPC_TO_SPECTRUM_PROFILE);

    // use this to break at a particular frame
    // DEBUG_ONLY( if (pau->m_iFrameNumber==32) { DEBUG_BREAK(); } );
    
    assert(pau->m_fltFlatenFactor == 0.5f); //So we can use quadRoot instead of pow(x,m_fltFlatenFactor/2);
    assert( iSize <= MAX_LP_SPEC_SIZE );
    assert( 10 == LPCORDER );

    for (i = 0; i < LPCORDER; i++) 
        LPC[i] = LP_SPEC_FROM_LP(rgLpcCoef[i]); 

    // m_cSubband   2048    1024     512      256       128
    // iStride         1       2       4        8        16
    // iLoopCntr     127     126     124      120
    // Loops         127      63      31       15         7
    iStride  = MAX_LP_SPEC_SIZE/iSize;

    // step constant array in main loop by stride * 4 inner_loops * (6 == 1 row per loop)
    iStridem1x24 = (iStride-1)*(4*6);    
    iLoops   = (iSize>>4) - 1;
    
    iMainLpc4Offset = 0;
    iMainLpc4Stride = iStride<<4;
    iMainLpc4Delta = 3;

    // Handle four sets of four points in each main loop
    // idx          iSize/2+idx     iSize/2-idx     iSize-idx
    // iSize/8-idx  5*iSize/8-idx   3*iSize/8+idx   7*iSize/8+idx
    // iSize/8+idx  5*iSize/8+idx   3*iSize/8-idx   7*iSize/8-idx
    // iSize/4-idx  3*iSize/4-idx   iSize/4+idx     3*iSize/4+idx

    for( idx = 1, pBP2Lpc4 = lpc_cnst4 + iStride*4*6 - 3*6; idx <= iLoops; idx++, pBP2Lpc4 += iStridem1x24 ) {

        // offsets into the Lpc constants array (numbers in hex)
        //
        //  512:  3D 7D BD FD 13D 17D 1BD 1FE 1BE 17E 13E FE BE 7E 3E 0 3F 7F BF FF 13F 17F 1BF 200 1B0 180 140 100 B0 80 40
        //  256:     7D    FD     17D     1FE     17E     FE    7E    0    7F    FF     17F     200     180     100    80
        //  128:           FD             1FE             FE          0          FF             200             100
        // 
        // show last two rows as an expression to see the component behavior
        //  256:  80-3, 100-3, 180-3, 200-2, 180-2, 100-2, 80-2, 0, 80-1, 100-1, 180-1, 200, 180, 100, 80
        //  128:        100-3,        200-2,        100-2,       0,       100-1,        200,      100

        iMainLpc4Offset += iMainLpc4Stride;
        if ( iMainLpc4Offset & 0x1FF ) {
            pbp2Lpc3 = lpc_cnst4 + (iMainLpc4Offset-iMainLpc4Delta)*6;
        } else {
            // iMainLpc4Offset is 0 or 512.  time to turn around
            iMainLpc4Stride = -iMainLpc4Stride;
            iMainLpc4Delta--;
            assert(iMainLpc4Delta>=0);
            pbp2Lpc3 = lpc_cnst4 + (iMainLpc4Offset>0 ? iMainLpc4Offset-iMainLpc4Delta*6 : 0);
        }

        // Comments below refer to LPC[i] as Li and BP2Lpc3[j] as wj

        iv0 = pbp2Lpc3[2];  iv1 = pbp2Lpc3[3];  iv2 = pbp2Lpc3[4];  iv3 = pbp2Lpc3[5];  // w2 w3 w4 w5
        iv1 += iv0;                             // W3 = w2 + w3
        iv2 = -iv2;                             // W4 = -w4
        iv3 = iv2 - iv3;                        // W5 = -w4 -w5

        iv8 = MULT_BP2(iv0,LPC[7]);             // w2*L7
        iv9 = MULT_BP2(iv1,LPC[7]);             // W3*L7
        iv0 = MULT_BP2(iv3,LPC[3]);             // W5*L3
        iv1 = MULT_BP2(iv2,LPC[3]);             // W4*L3
        iv2 = MULT_BP2(iv2,LPC[6]);             // W4*L6
        iv6 = MULT_BP2(iv3,LPC[6]);             // W5*L6

	    // Tmp[4:7]   = { W5*L6 - L2,  W4*L6 - L2, W5*L3 - W3*L7, W4*L3 - w2*L7 }
        // Tmp[12:15] = { W5*L6 - L2, -W4*L6 - L2, w2*L7 + W5*L3, W3*L7 - W4*L3 }
        // Tmp[20:23] = {  W4*L6 - L2, -W5*L6 - L2, W3*L7 + W4*L3, w2*L7 - W5*L3 }
        // Tmp[28:31] = { -W4*L6 - L2, -W5*L6 - L2, -w2*L7 - W4*L3, -W3*L7 - W5*L3 }

        Tmp[4] =   Tmp[12] = iv6 - LPC[2];      // W5*L6 - L2
        Tmp[5] =   Tmp[20] = iv2 - LPC[2];      // W4*L6 - L2
        Tmp[6] =  iv0 - iv9;                    // W5*L3 - W3*L7
        Tmp[7] =  iv1 - iv8;                    // W4*L3 - w2*L7
        Tmp[14] = iv8 + iv0;                    // w2*L7 + W5*L3
        Tmp[15] = iv9 - iv1;                    // W3*L7 - W4*L3

        Tmp[28] =   Tmp[13] = -LPC[2] - iv2;    // -W4*L6 - L2
        Tmp[29] =   Tmp[21] = -LPC[2] - iv6;    // -W5*L6 - L2
        Tmp[22] = iv9 + iv1;                    //  W3*L7 + W4*L3
        Tmp[23] = iv8 - iv0;                    //  w2*L7 - W5*L3
        Tmp[30] = -iv8 - iv1;                   // -w2*L7 - W4*L3
        Tmp[31] = -iv9 - iv0;                   // -W3*L7 - W5*L3

        // -----------------------------------------------------------

        // reload same lpc constants
        jv0 = pbp2Lpc3[2];  jv1 = pbp2Lpc3[3];  jv2 = pbp2Lpc3[4];  jv3 = pbp2Lpc3[5];  // w2 w3 w4 w5
        jv1 += jv0;                             // W3 = w2+w3
        jv3 += jv2;                             // W5 = w4+w5

        jv5  = MULT_BP2(jv1,LPC[9]);            // W3*L9
        jv11 = MULT_BP2(jv3,LPC[5]);            // W5*L5
        jv12 = MULT_BP2(jv0,LPC[9]);            // w2*L9
        jv10 = MULT_BP2(jv2,LPC[5]);            // w4*L5

        jv8  = MULT_BP2(jv1,LPC[8]);            // W3*L8
        jv1  = MULT_BP2(jv3,LPC[4]);            // W5*L4
        jv7  = MULT_BP2(jv0,LPC[8]);            // w2*L8
        jv2  = MULT_BP2(jv2,LPC[4]);            // w4*L4

        jv6  = jv7 - LPC[0] - jv1;              // w2*L8 - L0 - W5*L4
        jv9  = jv8 - LPC[0] + jv2;              // W3*L8 - L0 + w4*L4
        jv7 += LPC[0];                          // w2*L8 + L0
        jv8 += LPC[0];                          // W3*L8 + L0

        jv0   = LPC[1] - jv5;                   // L1 - W3*L9

	    // Tmp[8:11] = { w2*L9 - L1 - W5*L5, w4*L5 - L1 + W3*L9, w2*L8 - L0 - W5*L4, W3*L8 - L0 + w4*L4 }
        Tmp[8]  = jv12 - LPC[1] - jv11;         // w2*L9 - L1 - W5*L5
        Tmp[9]  = jv10 - jv0;                   // W3*L9 - L1 + w4*L5
        Tmp[10] = jv6;                          // w2*L8 - L0 - W5*L4
        Tmp[11] = jv9;                          // W3*L8 - L0 + w4*L4

        // Tmp[16:19] = {-w4*L5 - L1 + W3*L9, w2*L9 - L1 + W5*L5, W3*L8 - L0 - w4*L4, w2*L8 - L0 + W5*L4 }
        Tmp[16] = -jv10 - jv0;                  // W3*L9 - L1 - w4*L5
        Tmp[17] = jv12 - LPC[1] + jv11;         // w2*L9 - L1 + W5*L5
        Tmp[18] = jv9 - MUL2(jv2);              // W3*L8 - L0 - w4*L4
        Tmp[19] = jv6 + MUL2(jv1);              // w2*L8 - L0 + W5*L4

        // Tmp[0:3] = {-L1 - W3*L9 - W5*L5, -w2*L9 - L1 - w4*L5, -W3*L8 - L0 - W5*L4, -w2*L8 - L0 - w4*L4}
        Tmp[0]  = -jv5  - LPC[1] - jv11;        //-W3*L9 - L1  -W5*L5
        Tmp[1]  = -jv12 - LPC[1] - jv10;        //-w2*L9 - L1 - w4*L5
        Tmp[2]  = -( jv8 + jv1 );               //-W3*L8 - L0 - W5*L4
        Tmp[3]  = -( jv7 + jv2 );               //-w2*L8 - L0 - w4*L4

        // Tmp[24:27] = {-w2*L9 - L1 + w4*L5, -L1 - W3*L9 + W5*L5, -w2*L8 - L0 + w4*L4, -W3*L8 - L0 + W5*L4}
        Tmp[24] = -jv12 - LPC[1] + jv10;        //-w2*L9 - L1 + w4*L5
        Tmp[25] = -jv5  - LPC[1] + jv11;        //-W3*L9 - L1 + W5*L5
        Tmp[26] = -jv7  + jv2;                  //-w2*L8 - L0 + w4*L4
        Tmp[27] = -jv8  + jv1;                  //-W3*L8 - L0 + W5*L4

        // loop_fourvalues
        prvLpcCalc4( idx, iSize, pBP2Lpc4, Tmp, pWF );
    }

    // Final Batch of 16 points
    Tmp[1] = Tmp[16] = k1 = LPC[9] - LPC[1];        // L9 - L1
    Tmp[7] = Tmp[22] = kx = LPC[7] + LP_SPEC_FROM_FLOAT(1.0); // 1 + L7
    Tmp[8] = k1 - LPC[5];                           // L9 - L1 - L5
    Tmp[9] = k1 + LPC[5];                           // L9 - L1 + L5

    Tmp[14] = kx - LPC[3];                          // 1 + L7 - L3
    Tmp[15] = kx + LPC[3];                          // 1 + L7 + L3

    Tmp[3] = Tmp[18] = k8 = -LPC[0] + LPC[8];       // -L0 + L8

    Tmp[10] = k8 - LPC[4];                          // -L0 + L8 - L4
    Tmp[11] = k8 + LPC[4];                          // -L0 + L8 + L4

    kx = MULT_BP2( SQRT2, LPC[5] );                 // 1.414 * L5
    k9  = LPC[1] + LPC[9];
    Tmp[17] = -k9 + kx;                             // -L9 - L1 + 1.414*L5
    Tmp[0] = -k9 -kx;                               // -L1 - L9 - 1.414*L5
    k3 = k9 - LPC[5];                               //  L9 + L1 - L5 

    k10 = MULT_BP2( LPC[3], SQRT2 );                // 1.414*L3

    k1  = LP_SPEC_FROM_FLOAT(1.0) - LPC[7];              // 1 - L7
    Tmp[6] = k1 - k10;                              // 1 - L7 - 1.414*L3
    Tmp[23] = k10 + k1;                             // 1 - L7 + 1.414*L3

    k8 = LPC[0] + LPC[8];                           // L0 + L8
    kx =  MULT_BP2( LPC[4], SQRT2 );                // 1.414*L4
    Tmp[19] = -k8 + kx;                             // -L8 - L0 + 1.414*L4
    Tmp[2]  = -k8 - kx;                             // -L8 - L0 - 1.414*L4

    k1 -= LPC[3];                                   // 1 - L7 - L3
    k5 = k1 + k9 + LPC[5];                          // 1 - L7 - L3 + L9 + L1 + L5

    kx = MULT_BP2( SQRT2, LPC[6] );                 //  1.414*L6
    Tmp[21] = kx - LPC[2];                          //  1.414*L6 - L2
    Tmp[4]  = -kx - LPC[2];                         // -1.414*L6 - L2
    Tmp[5]  = Tmp[20] = -LPC[2];                    // -L2

    Tmp[12] = kx = -LPC[2] - LPC[6];                // -L2 - L6
    Tmp[13] = k6 = -LPC[2] + LPC[6];                // -L2 + L6
    k4 = LPC[4] - k8 - k6;                          // L4 - L8 - L0 + L2 - L6
    k0 = LPC[4] + k8 + kx;                          // L4 + L8 + L0 - L2 - L6

    kx = MULT_BP2( SQRT2_2, k4 );                   // 0.707*(L4 - L8 - L0 + L2 - L6)
    k1 = k1 + MUL2(LPC[3]);                         // 1 - L7 + L3
    k2 = k1 + kx;                                   // 1 - L7 + L3 + 0.707*(L4 - L8 - L0 + L2 - L6)
    k1 = k1 - kx;                                   // 1 - L7 + L3 - 0.707*(L4 - L8 - L0 + L2 - L6)

    k4 += MUL2(k6);                                 // L4 - L8 - L0 - L2 + L6
    k4 = MULT_BP2( SQRT2_2, k4 );                   // 0.707*(L4 - L8 - L0 - L2 + L6)

    k6 = k3 + k4;                                   // L9 + L1 - L5 + 0.707*(L4 - L8 - L0 - L2 + L6)
    k4 = k3 - k4;                                   // L9 + L1 - L5 - 0.707*(L4 - L8 - L0 - L2 + L6)

    kx = LP_SPEC_FROM_FLOAT(1.0);
    for( i=0; i<10; i++ ) 
        kx -= LPC[i];                               // 1 - L0 - L1 ... - L8 - L9

    // pWF[0] = invQuadRoot((1 - L7 - L3 - L9 - L1 - L5 - L8 - L0 - L4 - L2 - L6)^2)
    pWF[0] = InverseQuadRootOfSumSquares( kx, 0 );                          // wf[   0]

	// wf[ 64] = InvQuadRoot( ( 1 - L7 + L3 + 0.707 * (L4 - L8 - L0 + L2 - L6))^2 
    //                       +(L9 + L1 - L5 - 0.707 * (L4 - L8 - L0 - L2 + L6))^2 )
    pWF[iSizeBy4] = InverseQuadRootOfSumSquares( k2, k4 );                  // wf[0x40]

	// wf[128] = InvQuadRoot( ( 1 - L7 - L3 + L9 + L1 + L5)^2 
    //                       +(L4 + L8 + L0 - L2 - L6)^2 )
    pWF[iSizeBy2] = InverseQuadRootOfSumSquares( k5, k0 );                  // wf[0x80]

	// wf[192] = InvQuadRoot( ( 1 - L7 + L3 - 0.707 * (L4 - L8 - L0 + L2 - L6))^2
	//                       +(L9 + L1 - L5 + 0.707 * (L4 - L8 - L0 - L2 + L6))^2 )
    pWF[iSizeBy2 + iSizeBy4] = InverseQuadRootOfSumSquares( k1, k6 );       // wf[0xc0]
   

    prvPowerCalcZero(   iSizeBy16, 7*iSizeBy16, iSizeBy2, pWF, 6*510, Tmp );      // WF[10, 90, 70, f0]

    prvPowerCalcZero( 2*iSizeBy16, 6*iSizeBy16, iSizeBy2, pWF,     0, Tmp+8 );    // WF[20, a0, 60, e0]

    Tmp[8] = k10;                                   // 1 - L7 + 1.414*L3
    prvPowerCalcZero( 3*iSizeBy16, 5*iSizeBy16, iSizeBy2, pWF, 6*512, Tmp+16 );   // WF[30, b0, 50, d0]

    // now find maximum weight

    wtLpcSpecMax = WEIGHT_FROM_FLOAT(0.0F);
    
    for (iFreq = 0, iF = 0; iFreq < iSize; iFreq++, iF += iStride) 
    {
        LPC_COMPARE_DEBUG( pau, iFreq, iFreq, iF, pWF, rgLpcCoef );

        if ( pWF[iFreq] > wtLpcSpecMax )
            wtLpcSpecMax = pWF[iFreq];
        
        INTEGER_ONLY( assert( pWF[iFreq]>= 0 ); );
        MONITOR_RANGE(gMR_rgfltWeightFactor,pWF[iFreq]);                                
    }
    
    if (wtLpcSpecMax == WEIGHT_FROM_FLOAT(0.0F))
    {
        FUNCTION_PROFILE_STOP(&fp);
        return TraceResult(WMA_E_FAIL);
    }
    
#if defined(INTEGER_ENCODER)
    ppcinfo->m_iMaxWeight  = wtLpcSpecMax;
#endif
    ppcinfo->m_wtMaxWeight = wtLpcSpecMax;
    
    FUNCTION_PROFILE_STOP(&fp);
    return WMA_OK;
}


#endif  // defined(PLATFORM_LPC_FOLDED) && !defined(V4V5_COMPARE_MODE)



#if defined(PLATFORM_LPC_PRUNED_NONREDUNDANT) && !defined(V4V5_COMPARE_MODE)


//#pragma COMPILER_MESSAGE(__FILE__ "(961) : Warning - building PLATFORM_LPC_PRUNED_NONREDUNDANT LPC spectrum")

// ************************************************************************************
//
// LPC to Spectrum using a "Pruned" FFT and redundant calculation removal
//
// See Sorensen & Burrus, IEEE Trans Signal Processing V41 #3 March 93
// and the references sited there for a treatment of pruned and Transform-decomposited DFT
// Unclear how this particular implementation relates to those articles.
//
// Originally designed and implemented by Wei-ge and Marc.  
// Restructured by Sil to be a single routine.  
//
// The use of pointers instead of array indexes speeds up the SH4 and has no effect on the X86
// Question for Wei-ge: shouldn't F be malloced rather than demand 16kb of stack space?
//
// Cache usage: constants 14kb + F 16kb = 30kb (SH4 operand cache is 16kb so cache gets churned!)
//
// ************************************************************************************

WMARESULT prvLpcToSpectrum(CAudioObject* pau, const LpType* rgLpcCoef, PerChannelInfo* ppcinfo)
{
    // put often used variables near the top for easier access in platforms like the SH3 and SH4
    LpSpecType original[LPCORDER];
    LpSpecType *pFa, *pFb, *pFc, *pFd;      
    Int i, iFStep, iFStep2, iFStep4, iFStep8, iFStep16;
    LpSpecType t1pO7, t1mO7, tO1pO9, tO1mO9, tO0pO8, tO0mO8, tO4pO6, tO4mO6;
    LpSpecType t1pO7pO3, t1pO7mO3, tO1pO5pO9, tO0pO2pO4pO6pO8;
    LpSpecType tS2x; 
    const BP2Type* pC;
    Int pCInc;
    LpSpecType tC1x, tC2x, tC3x, tC4x;
    LpSpecType C1, C2, C3, C4, C5, C6;
    LpSpecType T2, T4, T6, T7, T8, T9, TA, TB;
    LpSpecType D, E, G, I, J;
    
    LpSpecType* rgwtLpcSpec;
    WeightType wtLpcSpecMax, wtTemp;
    Int iFreq, iF, iLoopLimit;
    Int iShrink, iStride; 
    LpSpecType F[2*MAX_LP_SPEC_SIZE];
    // Notes for BUILD_INTEGER: InverseQuadRoot returns UInt, yet is stored in Int array, F, temporarily.
    // These values are then copied to WeightType, which is UInt. There should not be any numeric loss
    // between the two transitions.
    Int iSize;
    
    FUNCTION_PROFILE(fp);
    FUNCTION_PROFILE_START(&fp,LPC_TO_SPECTRUM_PROFILE);
    
#ifdef REPLICATE_V4_LPC
    iSize = pau->m_cFrameSampleHalf;
#else
    if (pau->m_fV5Lpc)
        iSize = pau->m_cSubband;
    else 
        iSize = pau->m_cFrameSampleHalf;
#endif
    iShrink = LOG2(MAX_LP_SPEC_SIZE/iSize);     // for smaller transforms, shrink or expand indexing
    iStride = MAX_LP_SPEC_SIZE/iSize;           // for smaller transforms, stride past unused (lpc_compare only)
    
    
    
    // DEBUG_ONLY( if (pau->m_iFrameNumber==32) { DEBUG_BREAK(); } );
    
    assert(pau->m_fltFlatenFactor == 0.5f); //So we can use quadRoot instead of pow(x,m_fltFlatenFactor/2);
    assert( iSize <= MAX_LP_SPEC_SIZE );
    
    //for (i = 0; i < LPCORDER; i++) 
    //fprintf(stdout, "%.20lf\n", (double) FLOAT_FROM_LP(rgLpcCoef[i])); 
    
    for (i = 0; i < LPCORDER; i++) 
        original[i] = -LP_SPEC_FROM_LP(rgLpcCoef[i]); 
    
    DEBUG_ONLY( memset( F, 0, 2*MAX_LP_SPEC_SIZE*sizeof(LpSpecType) ) );
    
    iFStep   =  128>>iShrink;
    iFStep2  =  256>>iShrink;
    iFStep4  =  512>>iShrink;
    iFStep8  = 1024>>iShrink;
    iFStep16 = 2048>>iShrink;
    pFa = &F[iFStep];       // F[128]
    *pFa  = (t1pO7 = LP_SPEC_FROM_FLOAT(1) + original[7]) + (tS2x = MULT_BP2X(SQRT2,original[3]));
    pFa  += iFStep;         // F[256]  
    *pFa  = (t1mO7 = LP_SPEC_FROM_FLOAT(1) - original[7]) + original[3];
    pFa  += iFStep;         // F[384]  
    *pFa  = t1mO7;
    pFa  += iFStep2;        // F[640]
    *pFa  = t1pO7 - tS2x;
    pFa  += iFStep;         // F[768]
    *pFa  = t1mO7 - original[3];
    pFa  += iFStep;         // F[896]
    *pFa  = t1mO7;
    
    pFa  += iFStep2;        // F[1152] 
    *pFa  = (tO1pO9 = original[1] + original[9]) + (tS2x = MULT_BP2X(SQRT2,original[5]));
    pFa  += iFStep;         // F[1280] 
    *pFa  = (tO1mO9 = original[1] - original[9]) + original[5];
    pFa  += iFStep;         // F[1408]
    *pFa  = tO1mO9;
    pFa  += iFStep2;        // F[1664] 
    *pFa  = tO1pO9 - tS2x;
    pFa  += iFStep;         // F[1792] 
    *pFa  = tO1mO9 - original[5];
    pFa  += iFStep;         // F[1920] 
    *pFa  = tO1mO9;
    
    pFa  += iFStep2;        // F[2176] 
    *pFa  = (tO0pO8 = original[0] + original[8]) + (tS2x = MULT_BP2X(SQRT2,original[4]));
    pFa  += iFStep;         // F[2304] 
    *pFa  = (tO0mO8 = original[0] - original[8]) + original[4];
    pFa  += iFStep;         // F[2432] 
    *pFa  = tO0mO8;
    pFa  += iFStep2;        // F[2688]
    *pFa  = tO0pO8 - tS2x;
    pFa  += iFStep;         // F[2816] 
    *pFa  = tO0mO8 - original[4];
    pFa  += iFStep;         // F[2944] 
    *pFa  = tO0mO8;
    
    pFa  += iFStep2;        // F[3200] 
    *pFa  = original[2] + (tS2x = MULT_BP2X(SQRT2,original[6]));
    pFa  += iFStep;         // F[3328] 
    *pFa  = original[2] + original[6];
    pFa  += iFStep;         // F[3456] 
    *pFa  = original[2];
    pFa  += iFStep2;        // F[3712] 
    *pFa  = original[2] - tS2x;
    pFa  += iFStep;         // F[3840] 
    *pFa  = original[2] - original[6];
    pFa  += iFStep;         // F[3968]
    *pFa  = original[2];
    
    tO4pO6 = original[4] + original[6];
    tO4mO6 = original[4] - original[6];
    t1pO7pO3 = t1pO7 + original[3];
    t1pO7mO3 = t1pO7 - original[3];
    tO1pO5pO9 = tO1pO9 + original[5];
    tO0pO2pO4pO6pO8 = tO0pO8 + tO4pO6 + original[2];
    pFa   = &F[0];          // F[0]
    *pFa  = t1pO7pO3 + tO1pO5pO9 + tO0pO2pO4pO6pO8;
    pFa  += iFStep4;        // F[512]  
    *pFa  = t1pO7mO3 + (tS2x = MULT_BP2X(SQRT2_2, tO0pO8 - tO4mO6 - original[2]));
    pFa  += iFStep4;        // F[1024] 
    *pFa  = t1pO7pO3 - tO1pO5pO9;
    pFa  += iFStep4;        // F[1536] 
    *pFa  = t1pO7mO3 - tS2x;
    pFa  += iFStep4;        // F[2048] 
    *pFa  = t1pO7pO3 + tO1pO5pO9 - tO0pO2pO4pO6pO8;
    pFa  += iFStep4;        // F[2560] 
    *pFa  = -tO1pO9 + original[5] + (tS2x = MULT_BP2X(SQRT2_2,tO0pO8 - tO4pO6 + original[2]));
    pFa  += iFStep4;        // F[3072] 
    *pFa  =  tO0pO8 + tO4mO6 - original[2];
    pFa  += iFStep4;        // F[3584] 
    *pFa  =  tO1pO9 - original[5] + tS2x;
    
    // a few get squared.
    pFb   =  &F[0];      // F[0]
    *pFb  =  InverseQuadRootOfSumSquares(*pFb, 0);
    pFb  +=  iFStep4;   // b: F[512]  a: F[3584]
    *pFb  =  InverseQuadRootOfSumSquares(*pFb, *pFa);
    pFb  +=  iFStep4;    // b: F[1024]
    pFa  -=  iFStep4;    // a: F[3072]
    *pFb  =  InverseQuadRootOfSumSquares(*pFb, *pFa);
    pFb  +=  iFStep4;    // b: F[1536]
    pFa  -=  iFStep4;    // a: F[2560]
    *pFb  =  InverseQuadRootOfSumSquares(*pFb, *pFa);
    pFb  +=  iFStep4;    // b: F[2048]
    *pFb  =  InverseQuadRootOfSumSquares(*pFb, 0);
    
    //** up to here we have 46 adds and 14 mults
    
    
#if defined(_DEBUG) && defined(WMA_MONITOR)
    for(i=0; i<2*MAX_LP_SPEC_SIZE; i += 128)
        MONITOR_RANGE(gMR_fltLPC_F1,F[i]);
#endif
    
    pC = &lpc_cnst3[1*(4<<iShrink)];
    pCInc = (4<<iShrink)-3;  // 3 of them get done with ++
    for (i=1; i<iFStep; i++, pC += pCInc )
    {
        C1 = *pC++;  // cnst3[i*(4<<iShink)];
        C2 = *pC++;  // cnst3[i*(4<<iShinrk)+1];
        C3 = *pC++;  // cnst3[i*(4<<iShrink)+2];
        C4 = *pC;    // cnst3[i*(4<<iShrink)+3];
        assert( BP2_FROM_FLOAT(1) <= C1 && C1 <= BP2_FROM_FLOAT(1.5) );
        
        pFa   = &F[i];          // F[j]
        *pFa  = LP_SPEC_FROM_FLOAT(1) + (tC1x = MULT_BP2X(C1,original[7])) + (tC2x = MULT_BP2X(C2,original[3]));
        pFb   = &F[iFStep2-i];  // F[256-j]
        *pFb  = LP_SPEC_FROM_FLOAT(1) + (tC3x = MULT_BP2X(C3,original[7])) + tC2x;
        pFa  += iFStep2;        // F[256+j]  
        *pFa  = LP_SPEC_FROM_FLOAT(1) - tC1x - (tC4x = MULT_BP2X(C4,original[3]));
        pFb  += iFStep2;        // F[512-j]  
        *pFb  = LP_SPEC_FROM_FLOAT(1) - tC3x + tC4x;
        pFa  += iFStep2;        // F[512+j]  
        *pFa  = LP_SPEC_FROM_FLOAT(1) + tC1x - tC2x;
        pFb  += iFStep2;        // F[768-j]  
        *pFb  = LP_SPEC_FROM_FLOAT(1) + tC3x - tC2x;
        pFa  += iFStep2;        // F[768+j]  
        *pFa  = LP_SPEC_FROM_FLOAT(1) - tC1x + tC4x;
        pFb  += iFStep2;        // F[1024-j] 
        *pFb  = LP_SPEC_FROM_FLOAT(1) - tC3x - tC4x;
        
        pFa  += iFStep2;        // F[1024+j]
        *pFa  = original[1] + (tC1x = MULT_BP2X(C1,original[9])) + (tC2x = MULT_BP2X(C2,original[5]));
        pFb  += iFStep2;        // F[1280-j]  
        *pFb  = original[1] + (tC3x = MULT_BP2X(C3,original[9])) + tC2x;
        pFa  += iFStep2;        // F[1280+j]  
        *pFa  = original[1] - tC1x - (tC4x = MULT_BP2X(C4,original[5]));
        pFb  += iFStep2;        // F[1536-j]  
        *pFb  = original[1] - tC3x + tC4x;
        pFa  += iFStep2;        // F[1536+j]  
        *pFa  = original[1] + tC1x - tC2x;
        pFb  += iFStep2;        // F[1792-j]  
        *pFb  = original[1] + tC3x - tC2x;
        pFa  += iFStep2;        // F[1792+j]  
        *pFa  = original[1] - tC1x + tC4x;
        pFb  += iFStep2;        // F[2048-j]  
        *pFb  = original[1] - tC3x - tC4x;
        
        pFa  += iFStep2;        // F[2048+j]  
        *pFa  = original[0] + (tC1x = MULT_BP2X(C1,original[8])) + (tC2x = MULT_BP2X(C2,original[4]));
        pFb  += iFStep2;        // F[2304-j]  
        *pFb  = original[0] + (tC3x = MULT_BP2X(C3,original[8])) + tC2x;
        pFa  += iFStep2;        // F[2304+j]  
        *pFa  = original[0] - tC1x - (tC4x = MULT_BP2X(C4,original[4]));
        pFb  += iFStep2;        // F[2560-j]  
        *pFb  = original[0] - tC3x + tC4x;
        pFa  += iFStep2;        // F[2560+j]  
        *pFa  = original[0] + tC1x - tC2x;
        pFb  += iFStep2;        // F[2816-j]  
        *pFb  = original[0] + tC3x - tC2x;
        pFa  += iFStep2;        // F[2816+j]  
        *pFa  = original[0] - tC1x + tC4x;
        pFb  += iFStep2;        // F[3072-j]  
        *pFb  = original[0] - tC3x - tC4x;
        
        pFa  += iFStep2;        // F[3072+j] 
        pFb  += iFStep2;        // F[3328-j]
        *pFa  =  *pFb  = original[2] + (tC2x = MULT_BP2X(C2,original[6]));
        pFa  += iFStep2;        // F[3328+j] 
        *pFa  = original[2] - (tC4x = MULT_BP2X(C4,original[6]));
        pFb  += iFStep2;        // F[3584-j]
        *pFb  = original[2] + tC4x;
        pFa  += iFStep2;        // F[3584+j] 
        *pFa  = original[2] - tC2x;
        pFb  += iFStep2;        // F[3840-j]
        *pFb  = original[2] - tC2x;
        pFa  += iFStep2;        // F[3840+j] 
        *pFa  = original[2] + tC4x;
        pFb  += iFStep2;        // F[4096-j]
        *pFb  = original[2] - tC4x;
        
        //** this block uses 52 adds and 14 mults
    }
    //* This loop uses (128>>iShrink) * (52 adds and 14 mults)
    
#if defined(_DEBUG) && defined(WMA_MONITOR)
    for(i=0; i<2*MAX_LP_SPEC_SIZE; i += 1)
        MONITOR_RANGE(gMR_fltLPC_F2,F[i]);
#endif
    
    pC = &lpc_cnst4[1*(6<<iShrink)];
    pCInc = (6<<iShrink)-5;  // 5 of them get done with ++
    for (i=1; i<iFStep4; i++, pC += pCInc ){
        C1 = *pC++;   // cnst4[i*6];
        C2 = *pC++;   // cnst4[i*6+1];
        C3 = *pC++;   // cnst4[i*6+2];
        C4 = *pC++;   // cnst4[i*6+3];
        C5 = *pC++;   // cnst4[i*6+4];
        C6 = *pC;     // cnst4[i*6+5];
        assert( BP2_FROM_FLOAT(0) < C2 && C2 < BP2_FROM_FLOAT(1.5) );
        
        pFc = &F[iFStep8+i];        pFd = &F[iFStep16-i];       
        T7 = MULT_BP2X(C3,*pFc) + MULT_BP2X(C4,*pFd);           // F[1024+j]    F[2048-j]
        T4 = MULT_BP2X(C4,*pFc) - MULT_BP2X(C3,*pFd);           // F[1024+j]    F[2048-j]
        pFc += iFStep8;         pFd += iFStep8;
        T8 = MULT_BP2X(C5,*pFc) + MULT_BP2X(C6,*pFd);           // F[2048+j]    F[3072-j]
        pFc += iFStep8;         pFd += iFStep8;
        T9 = MULT_BP2X(C1,*pFc) + MULT_BP2X(C2,*pFd);           // F[3072+j]    F[4096-j]
        
        pFa = &F[i];            pFb = &F[iFStep8-i];
        TA = *pFa + *pFb;                           // F[j] + F[1024-j];
        TB = *pFa - *pFb;                           // F[j] - F[1024-j];
        
        D   = DIV2(+ T7  + T8 + T9 + TA);
        G   = DIV2(+ T4  + T8 - T9 - TB);
        I   = DIV2(- T4  + T8 - T9 + TB);
        J   = DIV2(+ T7  - T8 - T9 + TA);
        
        pFc -= iFStep8;         
        pFd -= iFStep8;
        T6 = MULT_BP2X(C6,*pFc) - MULT_BP2X(C5,*pFd);           // F[2048+j]    F[3072-j]
        pFc += iFStep8;         
        pFd += iFStep8;
        T2 = MULT_BP2X(C2,*pFc) - MULT_BP2X(C1,*pFd);           // F[3072+j]    F[4096-j]
        
        E     = DIV2(+ T4  + T6 + T2 + TB);
        *pFa  = InverseQuadRootOfSumSquares(D, E);           // F[j]
        
        E     = DIV2(- T7  + T6 - T2 + TA);
        *pFb  = InverseQuadRootOfSumSquares(E, G);           // F[1024-j]
        
        E     = DIV2(- T7  - T6 + T2 + TA);
        pFa  += iFStep8;
        *pFa  = InverseQuadRootOfSumSquares(E, I);               // F[1024+j]
        
        E     = DIV2(- T4  + T6 + T2 - TB);
        pFb  += iFStep8;
        *pFb  = InverseQuadRootOfSumSquares(E, J);               // F[2048-j]
        
        //INTEGER_ONLY( assert( F[i]>=0 && F[(1024>>iShrink)-i]>=0 && F[(1024>>iShrink)+i]>=0 && F[(2048>>iShrink)-i]>=0 ) );
        
        //** This block uses 36 adds and 20 mults plus either 4 more mults or 4 shifts
    }
    //** this loop uses (512>>iShrink) * (36 adds and 24 mults)
    
    //** total to here: 
    //**   (46 adds and 14 mults) + (N/16) * (52 adds and 14 mults) + (N/4) * (36 adds and 24 mults)
    //** TA = 46 + 3.25N + 9N      = 46 + 12.250N
    //** TM = 14 + (14/16)N + 6*N  = 14 +  6.875N
    //** An FFT takes order N*log(N)
    //** so we may need to substitute an optimized FFT for this on some platforms.
    
    // The inverse quad root has already been computed. Copy to destination, find max etc remain here.
    
    rgwtLpcSpec  = INTEGER_OR_INT_FLOAT( (I32 *)ppcinfo->m_rguiWeightFactor, ppcinfo->m_rgfltWeightFactor ); 
    wtLpcSpecMax = WEIGHT_FROM_FLOAT(0.0F);
    iLoopLimit   = pau->m_cSubband;
    
    for (iFreq = 0, iF = 0; iFreq < iLoopLimit; iFreq++, iF += iStride) 
    {
        LPC_COMPARE_DEBUG( pau, iFreq, iFreq, iF, F, rgLpcCoef );

        rgwtLpcSpec [iFreq] = wtTemp = F[iFreq];

#       if defined(_DEBUG) && 0
#           if defined(BUILD_INT_FLOAT)
                printf("%4d  %12.6f  0x%08x\n", iFreq, wtTemp, ((U32)((wtTemp)*(1<<21))) );
#           endif // BUILD_INT_FLOAT
#       endif // _DEBUG

        if ( wtTemp > wtLpcSpecMax )
            wtLpcSpecMax = wtTemp;
        
        INTEGER_ONLY( assert( wtTemp>= 0 ); );
        MONITOR_RANGE(gMR_rgfltWeightFactor,wtTemp);                                
        MONITOR_RANGE(gMR_fltLPC_F3,F[iFreq]);
    }
    
    if (wtLpcSpecMax == WEIGHT_FROM_FLOAT(0.0F))
    {
        FUNCTION_PROFILE_STOP(&fp);
        return TraceResult(WMA_E_FAIL);
    }
    
#if defined(INTEGER_ENCODER)
    ppcinfo->m_iMaxWeight = wtLpcSpecMax;
#endif
    ppcinfo->m_wtMaxWeight = wtLpcSpecMax;
    
    FUNCTION_PROFILE_STOP(&fp);
    return WMA_OK;
}

#endif // defined(PLATFORM_LPC_PRUNED_NONREDUNDANT) && !defined(V4V5_COMPARE_MODE)

#if defined(PLATFORM_LPC_PRUNED_STRAIGHT) || defined(V4V5_COMPARE_MODE)

//#pragma COMPILER_MESSAGE(__FILE__ "(961) : Warning - building PLATFORM_LPC_PRUNED_STRAIGHT LPC spectrum")

// warning - does not quite match V4_INT_FLOAT - must be a bug somewhere below

// ************************************************************************************
//
// LPC to Spectrum using a Pruned FFT (with little duplicate expression reduction)
//
// currently this uses a stride length >= 1 to handle tarnsforms less than 2048.
// This can cause unnecessary cache activity since sizeof(F[.]) = 16K bytes.
// This could be improved with some loss of readability
//
// ************************************************************************************

WMARESULT prvLpcToSpectrum(CAudioObject* pau, const LpType* rgLpcCoef, PerChannelInfo* ppcinfo)
{
    LpSpecType original[LPCORDER];
    LpSpecType F[2*MAX_LP_SPEC_SIZE];      
    Int i,j;
    
    LpSpecType* rgwtLpcSpec;
    WeightType wtLpcSpecMax, wtTemp;
    Int iFreq, iF, iLoopLimit;
    
#ifdef REPLICATE_V4_LPC
    Int iSize = pau->m_cFrameSampleHalf;
#else
    Int iSize;
    if (pau->m_fV5Lpc)
        iSize = pau->m_cSubband;
    else 
        iSize = pau->m_cFrameSampleHalf;
#endif
    Int iShrink = LOG2(MAX_LP_SPEC_SIZE/iSize);     // for smaller transforms, shrink or expand indexing
    Int iStride = MAX_LP_SPEC_SIZE/iSize;               // for smaller transforms, stride past unused F[.]
    
    BP2Type* pC;
    Int pCInc;
    FUNCTION_PROFILE(fp);
    FUNCTION_PROFILE_START(&fp,LPC_TO_SPECTRUM_PROFILE);
    
    // DEBUG_ONLY( if (pau->m_iFrameNumber==32) { DEBUG_BREAK(); } );
    
    assert(pau->m_fltFlatenFactor == 0.5f); //So we can use quadRoot instead of pow(x,m_fltFlatenFactor/2);
    assert( iSize <= MAX_LP_SPEC_SIZE );
    
    for (i = 0; i < LPCORDER; i++) 
        original[i] = -LP_SPEC_FROM_LP(rgLpcCoef[i]); 
    
    DEBUG_ONLY( memset( F, 0, 2*MAX_LP_SPEC_SIZE*sizeof(LpSpecType) ) );
    
    // All these indexes into F[.] are 0 mod 128.
    F[128]  = LP_SPEC_FROM_FLOAT(1) + original[7] + MULT_BP2X(SQRT2,original[3]);
    F[256]  = LP_SPEC_FROM_FLOAT(1) - original[7] + original[3];
    F[384]  = F[896] = LP_SPEC_FROM_FLOAT(1) - original[7];
    F[640]  = LP_SPEC_FROM_FLOAT(1) + original[7] - MULT_BP2X(SQRT2,original[3]);
    F[768]  = LP_SPEC_FROM_FLOAT(1) - original[7] - original[3];
    
    F[1152] = original[1] + original[9] + MULT_BP2X(SQRT2,original[5]);
    F[1280] = original[1] - original[9] + original[5];
    F[1664] = original[1] + original[9] - MULT_BP2X(SQRT2,original[5]);
    F[1792] = original[1] - original[9] - original[5];
    F[1920] = F[1408]     = original[1] - original[9];
    
    F[2176] = original[0] + original[8] + MULT_BP2X(SQRT2,original[4]);
    F[2304] = original[0] - original[8] + original[4];
    F[2688] = original[0] + original[8] - MULT_BP2X(SQRT2,original[4]);
    F[2816] = original[0] - original[8] - original[4];
    F[2944] = F[2432] = original[0] - original[8];
    
    F[3200] = original[2] + MULT_BP2X(SQRT2,original[6]);
    F[3328] = original[2] + original[6];
    F[3712] = original[2] - MULT_BP2X(SQRT2,original[6]);
    F[3840] = original[2] - original[6];
    F[3968] = F[3456] = original[2];
    
    // All these indexes are 0 mod 512.
    F[0 ]   = LP_SPEC_FROM_FLOAT(1) + original[7] + original[3] + original[1] + original[9] + original[5] + original[0] + original[8] + original[4] + original[2] + original[6];
    F[512]  = LP_SPEC_FROM_FLOAT(1) + original[7] - original[3] + MULT_BP2X(SQRT2_2, original[0] + original[8] - original[4] - original[2] + original[6]);
    F[1024] = LP_SPEC_FROM_FLOAT(1) + original[7] + original[3] - original[1] - original[9] - original[5];
    F[1536] = LP_SPEC_FROM_FLOAT(1) + original[7] - original[3] + MULT_BP2X(SQRT2_2, original[2] - original[6] - original[0] - original[8] + original[4] );
    F[2048] = LP_SPEC_FROM_FLOAT(1) + original[7] + original[3] + original[1] + original[9] + original[5] - original[0] - original[8] - original[4] - original[2] - original[6];
    F[2560] = -original[1] - original[9] + original[5] + MULT_BP2X(SQRT2_2,original[2] - original[6] + original[0] + original[8] - original[4]);
    F[3072] =  original[0] + original[8] + original[4] - original[2] - original[6];
    F[3584] =  original[1] + original[9] - original[5] + MULT_BP2X(SQRT2_2,original[0] + original[8] - original[4] + original[2] - original[6]);
    
    // a few get squared.
    F[0 ]   =   SQUARE(F[0]);
    F[512]  =   SQUARE(F[512])  + SQUARE(F[3584]);
    F[1024] =   SQUARE(F[1024]) + SQUARE(F[3072]);
    F[1536] =   SQUARE(F[1536]) + SQUARE(F[2560]);
    F[2048] =   SQUARE(F[2048]);
    
#if defined(_DEBUG) && defined(WMA_MONITOR)
    for(i=0; i<2*SPEC_SIZE; i += 128)
        MONITOR_RANGE(gMR_fltLPC_F1,F[i]);
#endif
    
    iLoopLimit = 128>>iShrink;
    pC = &lpc_cnst3[1*(4<<iShrink)];
    pCInc = (4<<iShrink)-3;  // 3 of them get done with ++
    for (i=1,j=iStride; i<iLoopLimit; i++, j += iStride, pC += pCInc )
    {
        LpSpecType C1, C2, C3, C4;
        C1 = *pC++;  // cnst3[i*(4<<iShink)];
        C2 = *pC++;  // cnst3[i*(4<<iShinrk)+1];
        C3 = *pC++;  // cnst3[i*(4<<iShrink)+2];
        C4 = *pC;    // cnst3[i*(4<<iShrink)+3];
        assert( BP2_FROM_FLOAT(1) <= C1 && C1 <= BP2_FROM_FLOAT(1.5) );
        
        F[j ]     = LP_SPEC_FROM_FLOAT(1) + MULT_BP2X(C1,original[7]) + MULT_BP2X(C2,original[3]);
        F[256-j]  = LP_SPEC_FROM_FLOAT(1) + MULT_BP2X(C3,original[7]) + MULT_BP2X(C2,original[3]);
        F[256+j]  = LP_SPEC_FROM_FLOAT(1) - MULT_BP2X(C1,original[7]) - MULT_BP2X(C4,original[3]);
        F[512-j]  = LP_SPEC_FROM_FLOAT(1) - MULT_BP2X(C3,original[7]) + MULT_BP2X(C4,original[3]);
        F[512+j]  = LP_SPEC_FROM_FLOAT(1) + MULT_BP2X(C1,original[7]) - MULT_BP2X(C2,original[3]);
        F[768-j]  = LP_SPEC_FROM_FLOAT(1) + MULT_BP2X(C3,original[7]) - MULT_BP2X(C2,original[3]);
        F[768+j]  = LP_SPEC_FROM_FLOAT(1) - MULT_BP2X(C1,original[7]) + MULT_BP2X(C4,original[3]);
        F[1024-j] = LP_SPEC_FROM_FLOAT(1) - MULT_BP2X(C3,original[7]) - MULT_BP2X(C4,original[3]);
        
        F[1024+j]  = original[1] + MULT_BP2X(C1,original[9]) + MULT_BP2X(C2,original[5]);
        F[1280-j]  = original[1] + MULT_BP2X(C3,original[9]) + MULT_BP2X(C2,original[5]);
        F[1280+j]  = original[1] - MULT_BP2X(C1,original[9]) - MULT_BP2X(C4,original[5]);
        F[1536-j]  = original[1] - MULT_BP2X(C3,original[9]) + MULT_BP2X(C4,original[5]);
        F[1536+j]  = original[1] + MULT_BP2X(C1,original[9]) - MULT_BP2X(C2,original[5]);
        F[1792-j]  = original[1] + MULT_BP2X(C3,original[9]) - MULT_BP2X(C2,original[5]);
        F[1792+j]  = original[1] - MULT_BP2X(C1,original[9]) + MULT_BP2X(C4,original[5]);
        F[2048-j]  = original[1] - MULT_BP2X(C3,original[9]) - MULT_BP2X(C4,original[5]);
        
        F[2048+j]  = original[0] + MULT_BP2X(C1,original[8]) + MULT_BP2X(C2,original[4]);
        F[2304-j]  = original[0] + MULT_BP2X(C3,original[8]) + MULT_BP2X(C2,original[4]);
        F[2304+j]  = original[0] - MULT_BP2X(C1,original[8]) - MULT_BP2X(C4,original[4]);
        F[2560-j]  = original[0] - MULT_BP2X(C3,original[8]) + MULT_BP2X(C4,original[4]);
        F[2560+j]  = original[0] + MULT_BP2X(C1,original[8]) - MULT_BP2X(C2,original[4]);
        F[2816-j]  = original[0] + MULT_BP2X(C3,original[8]) - MULT_BP2X(C2,original[4]);
        F[2816+j]  = original[0] - MULT_BP2X(C1,original[8]) + MULT_BP2X(C4,original[4]);
        F[3072-j]  = original[0] - MULT_BP2X(C3,original[8]) - MULT_BP2X(C4,original[4]);
        
        F[3072+j] = F[3328-j] = original[2] + MULT_BP2X(C2,original[6]);
        F[3328+j] = F[4096-j] = original[2] - MULT_BP2X(C4,original[6]);
        F[3584-j] = F[3840+j] = original[2] + MULT_BP2X(C4,original[6]);
        F[3584+j] = F[3840-j] = original[2] - MULT_BP2X(C2,original[6]);
        
    }
    
#if defined(_DEBUG) && defined(WMA_MONITOR)
    for(j=0; j<2*SPEC_SIZE; j += iLoopLimit)
        MONITOR_RANGE(gMR_fltLPC_F2,F[j]);
#endif
    
    iLoopLimit = 512>>iShrink;
    pC = &lpc_cnst4[1*(6<<iShrink)];
    pCInc = (6<<iShrink)-5;  // 5 of them get done with ++
    for (i=1, j=iStride; i<iLoopLimit; i++, j += iStride, pC += pCInc ){
        LpSpecType C1, C2, C3, C4, C5, C6;
        LpSpecType T7, T8, T9, TA, TB;
        LpSpecType D, E, G, I, J;
        C1 = *pC++;   // cnst4[i*6];
        C2 = *pC++;   // cnst4[i*6+1];
        C3 = *pC++;   // cnst4[i*6+2];
        C4 = *pC++;   // cnst4[i*6+3];
        C5 = *pC++;   // cnst4[i*6+4];
        C6 = *pC;     // cnst4[i*6+5];
        assert( BP2_FROM_FLOAT(0) < C2 && C2 < BP2_FROM_FLOAT(1.5) );
        
        T7 = MULT_BP2X(C3,F[1024+j]) + MULT_BP2X(C4,F[2048-j]);
        C4 = MULT_BP2X(C4,F[1024+j]) - MULT_BP2X(C3,F[2048-j]);
        T8 = MULT_BP2X(C5,F[2048+j]) + MULT_BP2X(C6,F[3072-j]);
        T9 = MULT_BP2X(C1,F[3072+j]) + MULT_BP2X(C2,F[4096-j]);
        
        TA = F[j] + F[1024-j];
        TB = F[j] - F[1024-j];
        
        D   = DIV2(+ T7  + T8 + T9 + TA);
        G   = DIV2(+ C4  + T8 - T9 - TB);
        I   = DIV2(- C4  + T8 - T9 + TB);
        J   = DIV2(+ T7  - T8 - T9 + TA);
        
        C6 = MULT_BP2X(C6,F[2048+j]) - MULT_BP2X(C5,F[3072-j]); 
        C2 = MULT_BP2X(C2,F[3072+j]) - MULT_BP2X(C1,F[4096-j]);
        
        E         = DIV2(+ C4  + C6 + C2 + TB);
        F[j]      = SQUARE(D) + SQUARE(E);
        
        E         = DIV2(- T7  + C6 - C2 + TA);
        F[1024-j] = SQUARE(E) + SQUARE(G);
        
        E         = DIV2(- T7  - C6 + C2 + TA);
        F[1024+j] = SQUARE(E) + SQUARE(I);
        
        E         = DIV2(- C4  + C6 + C2 - TB);
        F[2048-j] = SQUARE(E) + SQUARE(J);
        
        INTEGER_ONLY( assert( F[j]>=0 && F[1024-j]>=0 && F[1024+j]>=0 && F[2048-j]>=0 ) );
    }
    
    // the remainder should be identical to the other versions of this routine
    
    rgwtLpcSpec  = INTEGER_OR_INT_FLOAT( ppcinfo->m_rgiWeightFactor, ppcinfo->m_rgfltWeightFactor ); 
    wtLpcSpecMax = WEIGHT_FROM_FLOAT(0.0F);
    iLoopLimit   = pau->m_cSubband;
    
    for (iFreq = 0, iF = 0; iFreq < iLoopLimit; iFreq++, iF += iStride) 
    {
        LPC_COMPARE_DEBUG( pau, iFreq, iF, iF, F, rgLpcCoef );
        
        rgwtLpcSpec [iFreq] = wtTemp = InverseQuadRoot(F[iF]);
        
        if ( wtTemp > wtLpcSpecMax )
            wtLpcSpecMax = wtTemp;
        
        INTEGER_ONLY( assert( wtTemp>= 0 ); );
        MONITOR_RANGE(gMR_rgfltWeightFactor,wtTemp);                                
        MONITOR_RANGE(gMR_fltLPC_F3,F[iF]);
    }
    
    if (wtLpcSpecMax == WEIGHT_FROM_FLOAT(0.0F))
    {
        FUNCTION_PROFILE_STOP(&fp);
        return TraceResult(WMA_E_FAIL);
    }
    
#if defined(INTEGER_ENCODER)
    ppcinfo->m_iMaxWeight = wtLpcSpecMax;
#endif
    ppcinfo->m_wtMaxWeight = wtLpcSpecMax;
    
    FUNCTION_PROFILE_STOP(&fp);
    return WMA_OK;
}

#endif  // defined(PLATFORM_LPC_PRUNED_STRAIGHT) || defined(V4V5_COMPARE_MODE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\loopfilter_wmv_x86.cpp ===
/*************************************************************************

Copyright (c) 1996  Microsoft Corporation

Module Name:

        vopSes.cpp

Abstract:

        Base class for the encoder for one VOP session.

Author:

        Ming-Chieh Lee (mingcl@microsoft.com) 20-March-1996
        Chuang Gu (chuanggu@microsoft.com) 10-December-1999

Revision History:

*************************************************************************/
#include "bldsetup.h"

#include "xplatform.h"
#include "typedef.hpp"
#include "wmvdec_member.h"
#include <stdlib.h>
#include "motioncomp_wmv.h"
#include "tables_wmv.h"
#if defined(macintosh) && defined(_MAC_VEC_OPT)
#include "motioncomp_altivec.h"
#endif

#ifdef _WMV_TARGET_X86_
#include "opcodes.h"
#endif 

#ifdef _WMV_TARGET_X86_

Void_WMV g_FilterHorizontalEdge_MMX(U8_WMV* pV, I32_WMV iPixelDistance, I32_WMV iStepSize, 
                                 I32_WMV iNumPixel)
{
    static const Int64 x05 = 0x0005000500050005;
    static const Int64 x04 = 0x0004000400040004;

    pV -= iPixelDistance*3;
    iNumPixel >>= 2;
    _asm {        
        mov         eax,iPixelDistance
        mov         esi,pV
        mov         ecx,iNumPixel
        mov         ebx,eax
        neg         ebx
            
HLoop:                         
        // ---------------------------
        // DefaultMode4_KNI
        lea         edi,[esi+eax*4]
        add         edi,eax

        pxor        mm7,mm7
        movq        mm6,x05
        movq        mm5,x04

        //calculate a3.1
        movd        mm0,[esi+ebx]
        punpcklbw   mm0,mm7
        paddw       mm0,mm0
        movd        mm1,[esi]
        punpcklbw   mm1,mm7
        pmullw      mm1,mm6
        psubw       mm0,mm1
        movd        mm1,[esi+eax]
        punpcklbw   mm1,mm7
        movq        mm2,mm1
        pmullw      mm1,mm6
        paddw       mm0,mm1
        movd        mm1,[esi+eax*2]
        punpcklbw   mm1,mm7
        psubw       mm0,mm1
        psubw       mm0,mm1
        paddw       mm0,mm5
        psraw       mm0,3

        //Calculate a3.0
        paddw       mm2,mm2
        pmullw      mm1,mm6
        psubw       mm2,mm1
        movd        mm1,[edi+ebx*2]
        punpcklbw   mm1,mm7
        movq        mm3,mm1
        pmullw      mm1,mm6
        paddw       mm1,mm2
        movd        mm2,[edi+ebx]
        punpcklbw   mm2,mm7
        psubw       mm1,mm2
        psubw       mm1,mm2
        paddw       mm1,mm5
        psraw       mm1,3

        //Calculate a3.2
        paddw       mm3,mm3
        pmullw      mm2,mm6
        psubw       mm3,mm2
        movd        mm2,[edi]
        punpcklbw   mm2,mm7
        pmullw      mm2,mm6
        paddw       mm2,mm3
        movd        mm3,[edi+eax]
        punpcklbw   mm3,mm7
        psubw       mm2,mm3
        psubw       mm2,mm3
        paddw       mm2,mm5
        psraw       mm2,3

        //SIGN(a30)
        movq        mm5,mm1
        psraw       mm5,16
       
        //MIN(abs(a30),abs(a31),abs(a32))
        movq        mm3,mm0  //abs(a3.1)
        psraw       mm3,16
        pxor        mm0,mm3
        psubw       mm0,mm3

        movq        mm3,mm1  //abs(a3.0)
        movq        mm4,mm1
        psraw       mm3,16
        pxor        mm4,mm3
        psubw       mm4,mm3

        movq        mm3,mm2  //abs(a3,1)
        psraw       mm3,16
        pxor        mm2,mm3
        psubw       mm2,mm3

        movq        mm3,mm4  //if (abs(a3.0) < abs(a3.1)) mm0 = abs(a3.0) else mm0 = abs(a3.1)
        pcmpgtw     mm3,mm0  
        pand        mm0,mm3
        pandn       mm3,mm4
        por         mm0,mm3

        movq        mm3,mm2  //if (mm0 < abs(a3,2)) mm0 = a3.2
        pcmpgtw     mm3,mm0
        pand        mm0,mm3
        pandn       mm3,mm2
        por         mm0,mm3

        pxor        mm0,mm5  //a3.0' = mm0 = (mm0 * SIGN(a3.0))
        psubw       mm0,mm5

        //Broadcast iStepSize
        movd        mm5,iStepSize
        punpcklwd   mm5,mm5
        punpckldq   mm5,mm5
        
        // d = CLIP( (5*(A30-a30)/8),0,  ((v4-v5)/2)   *   ((abs(a30) < iStepSize) ? 1 : 0)   );
        movq        mm6,mm5     // generate mask for  * ((abs(a30) < iStepSize) ? 1 : 0)
        pcmpgtw     mm6,mm4

        psubw       mm0,mm1     //d_temp = 5*(A30-a30)/8
        pmullw      mm0,x05
        movq        mm5,mm0
        psraw       mm5,16
        pxor        mm0,mm5
        psubw       mm0,mm5
        psraw       mm0,3
        pxor        mm0,mm5
        psubw       mm0,mm5
        
        movd        mm3,[esi+eax*2]  //max = (v4-v5)/2
        punpcklbw   mm3,mm7
        movq        mm4,mm3
        movd        mm2,[edi+ebx*2]
        punpcklbw   mm2,mm7
        movq        mm7,mm2
        psubw       mm3,mm2
        pxor        mm3,mm5
        psubw       mm3,mm5
        psraw       mm3,1
        pxor        mm3,mm5
        psubw       mm3,mm5
        
        movq        mm5,mm3         //abs(max)     
        psraw       mm5,16
        pxor        mm3,mm5
        psubw       mm3,mm5
        pxor        mm0,mm5         //if (max < 0) d_temp = d_temp*-1;
        psubw       mm0,mm5

        movq        mm2,mm3         //Clip to less than max
        pcmpgtw     mm2,mm0
        pand        mm0,mm2
        pandn       mm2,mm3
        por         mm0,mm2
        
        pxor        mm2,mm2         //Clip to zero
        pcmpgtw     mm2,mm0
        pandn       mm2,mm0

        pxor        mm2,mm5         //Restore original sign
        psubw       mm2,mm5

        pand        mm2,mm6         //mask out 

        psubw       mm4,mm2
        paddw       mm7,mm2

        packuswb    mm4,mm4
        movd        [esi+eax*2],mm4
        packuswb    mm7,mm7
        movd        [edi+ebx*2],mm7

        // ---------------------------------
        add         esi,4
                
        dec         ecx;
        jnz         HLoop;

        emms;
    }
}


Void_WMV g_FilterVerticalEdge_MMX(U8_WMV* pV1, I32_WMV iPixelDistance, 
                              I32_WMV iStepSize, I32_WMV iVertSize)
{
    static const Int64 s1 = 0xFFFB0002FFFB0002;
    static const Int64 s2 = 0xFFFE0005FFFE0005;
    static const Int64 s3 = 0xFFFE0005FFFB0002;
    static const Int64 x00000004 = 0x0000000400000004;       
    static const Int64 x00000005 = 0x0000000500000005;
    // Filter vertical lines

    _asm {
        mov         esi,pV1
        mov         edi,iVertSize
        mov         eax,iPixelDistance
        pxor        mm7,mm7
            
MainLoop:        
        movzx       ecx,byte Ptr [esi+4]
        mov         eax,ecx
        movzx       ebx,byte Ptr [esi+5]
        
        movq        mm0,[esi+1]
        movq        mm5,s1
        movq        mm6,s2
        movq        mm1,mm0
        punpcklbw   mm1,mm7   
        pmaddwd     mm1,mm5
        movq        mm2,mm0
        psrlq       mm2,16
        punpcklbw   mm2,mm7   
        movq        mm3,mm2
        pmaddwd     mm2,mm6
        paddd       mm1,mm2
        paddd       mm1,x00000004
        psrad       mm1,3
        
        pxor        mm6,mm6
        pcmpgtb     mm6,mm1                    
        pxor        mm1,mm6
        psubd       mm1,mm6
        
        movq        mm4,mm1
        psrlq       mm1,32
        
        movd        edx,mm1
        cmp         edx,iStepSize
        jge         EndOfLoop
        
        sub         eax,ebx
        cdq
        xor         eax,edx
        sub         eax,edx
        
        shr         eax,1
        
        test        eax,eax
        jz          EndOfLoop
        
        movq        mm3,mm0
        punpckhbw   mm3,mm7
        pmaddwd     mm3,s3
        movq        mm2,mm3
        psrlq       mm2,32
        paddd       mm3,mm2
        paddd       mm3,x00000004
        psrad       mm3,3
        movq        mm2,mm1
        
        //From here on could be done 2 or 4 at a time
        //mm2=a30
        //mm3=a32
        //mm4=a31
        
        pxor        mm5,mm5
        pcmpgtd     mm5,mm3
        pxor        mm3,mm5
        psubd       mm3,mm5
        
        movq        mm5,mm2
        pcmpgtd     mm5,mm3
        pand        mm3,mm5
        pandn       mm5,mm2
        por         mm3,mm5
        
        movq        mm5,mm4
        pcmpgtd     mm5,mm3
        pand        mm3,mm5
        pandn       mm5,mm4
        por         mm3,mm5
        
        psubd       mm3,mm1
        
        pxor        mm4,mm4
        pcmpgtd     mm4,mm3
        pxor        mm3,mm4
        psubd       mm3,mm4
        
        pmaddwd     mm3,x00000005
        psrad       mm3,3        
        
        pxor        mm3,mm4
        psubd       mm3,mm4
        
        psrlq       mm6,32
        pxor        mm3,mm6
        psubd       mm3,mm6
        
        movd        mm5,edx
        
        pxor        mm3,mm5
        psubd       mm3,mm5
        
        movd        mm0,eax
        movq        mm1,mm0
        pcmpgtd     mm1,mm3
        pand        mm3,mm1
        pandn       mm1,mm0
        por         mm3,mm1
        
        pxor        mm1,mm1
        pcmpgtd     mm1,mm3
        pandn       mm1,mm3
        
        pxor        mm1,mm5
        psubd       mm1,mm5
        
        movd        eax,mm1
        
        sub         ecx,eax
        add         ebx,eax
        
        mov         [esi+4],cl          
        mov         [esi+5],bl
        
        
EndOfLoop:                
        mov        eax,iPixelDistance
        add        esi,eax
        
        dec        edi
        jnz        MainLoop

        emms;
    }

}

#endif // _WMV_TARGET_X86_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\motioncomp_wmv.cpp ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

	MB.hpp

Abstract:

	MacroBlock base class

Author:
	Bruce Lin (blin@microsoft.com) 25-Jan-1997
		Compute curr (Error + Pred) in MC routine.
	Bruce Lin (blin@microsoft.com) 23-Jan-1997
		Optimize MC routines by expanding inner loop
	Ming-Chieh Lee (mingcl@microsoft.com) 20-March-1996
	Bruce Lin (blin@microsoft.com) 20-March-1996
    Chuang Gu (chuanggu@microsoft.com) 2-Feb-2000

Revision History:

*************************************************************************/
#ifndef _EMB_WMV2_

#include "bldsetup.h"

#include "xplatform.h"
#include <limits.h>
#include "typedef.hpp"
#include "motioncomp_wmv.h"
#include "opcodes.h"
#include "wmvdec_api.h"
#include "wmvdec_member.h"

#define _USE_PORTABLE_C_

#ifdef UNDER_CE
#undef _FASTMC_
#endif

#if defined( _MIPS_)&&defined(MIPS_WMVIDEO)
#undef _USE_PORTABLE_C_
#define _USE_MIPS_ASM_
#endif


#if defined(_MIPS_)
extern "C" {
	Void_WMV __asm(char *,...);
}
#pragma intrinsic(__asm)
#endif


#include <stdlib.h>
#include <math.h>

#ifdef __MFC_
#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW
#endif // __MFC_

#ifdef UNDER_CE
#define __UNIXVIDEO__
#endif

#define maskStaturation 0xFFFFFF00

#ifndef __MACVIDEO__
#define packFourPixels(x0,x1,x2,x3) ((U32_WMV)x3<<24)|((U32_WMV)x2<<16)|((U32_WMV)x1<<8)|(U32_WMV)x0
#else
#define packFourPixels(x0,x1,x2,x3) ((U32_WMV)x0<<24)|((U32_WMV)x1<<16)|((U32_WMV)x2<<8)|(U32_WMV)x3
#endif
   
#ifdef BIG_ENDING 
#define packFourPixels(x0,x1,x2,x3) ((U32_WMV)x0<<24)|((U32_WMV)x1<<16)|((U32_WMV)x2<<8)|(U32_WMV)x3
#endif

I32_WMV g_iMotionCompDecEventCount_WMV = 0;


#ifdef _USE_PORTABLE_C_ 
Void_WMV g_MotionCompAndAddErrorRndCtrl (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* ppxlcCurrQMB,
    const Buffer __huge* ppxliErrorBuf, const U8_WMV* ppxlcRef,
    I32_WMV iWidthFrm, Bool_WMV bXEven, Bool_WMV bYEven,
    I32_WMV iMixedPelMV	
)
{
    const U8_WMV* rgiClapTab = pWMVDec->m_rgiClapTabDec; 

//#ifndef _CASIO_VIDEO_
//    assert (rgiClapTab != NULL_WMV);
//#endif
    FUNCTION_PROFILE_DECL_START(fpDecode,MOTIONCOMPADDERRORRNDCTRL_PROFILE);

    const PixelI32 *ppxliErrorQMB = ppxliErrorBuf->i32;

    I32_WMV iy;
    if (bYEven) {
        if (bXEven) {  //!bXSubPxl && !bYSubPxl
            for (iy = 0; iy < BLOCK_SIZE; iy++) {

                I32_WMV x0 = ppxliErrorQMB [0] + ppxlcRef [0];
                I32_WMV x1 = ppxliErrorQMB [1] + ppxlcRef [1];
                I32_WMV x2 = ppxliErrorQMB [2] + ppxlcRef [2];
                I32_WMV x3 = ppxliErrorQMB [3] + ppxlcRef [3];

#ifdef _FASTMC_               
                I32_WMV d0 = x2 << 16;
                I32_WMV d1 = x3 << 16;
                d0 = d0 | x0;
                d1 = d1 | x1;
                // Check for saturation
                if (((d0 | d1) & 0xff00ff00) == 0)
                {
                    *(U32_WMV *) ppxlcCurrQMB = d0 | (d1 << 8);
                }
                else
                {
                    *(U32_WMV *) ppxlcCurrQMB = packFourPixels (rgiClapTab [x0], rgiClapTab [x1], rgiClapTab [x2], rgiClapTab [x3]);
                }                
#else
                if ((((U32_WMV)x0|(U32_WMV)x1|(U32_WMV)x2|(U32_WMV)x3)&maskStaturation) == 0) {
                    *(U32_WMV *) ppxlcCurrQMB = packFourPixels (x0, x1, x2, x3);
                } else {
                    *(U32_WMV *) ppxlcCurrQMB = packFourPixels (rgiClapTab [x0], rgiClapTab [x1], rgiClapTab [x2], rgiClapTab [x3]);
                }
#endif

                x0 = ppxliErrorQMB [4] + ppxlcRef [4];
                x1 = ppxliErrorQMB [5] + ppxlcRef [5];
                x2 = ppxliErrorQMB [6] + ppxlcRef [6];
                x3 = ppxliErrorQMB [7] + ppxlcRef [7];


#ifdef _FASTMC_
                d0 = x2 << 16;
                d1 = x3 << 16;
                d0 = d0 | x0;
                d1 = d1 | x1;
                // Check for saturation
                if (((d0 | d1) & 0xff00ff00) == 0)
                {
                    *(U32_WMV *) (ppxlcCurrQMB+4) = d0 | (d1 << 8);
                }
                else
                {
                    *(U32_WMV *) (ppxlcCurrQMB+4) = packFourPixels (rgiClapTab [x0], rgiClapTab [x1], rgiClapTab [x2], rgiClapTab [x3]);
                }
#else
                if ((((U32_WMV)x0|(U32_WMV)x1|(U32_WMV)x2|(U32_WMV)x3)&maskStaturation) == 0) {
                    *(U32_WMV *) (ppxlcCurrQMB+4) = packFourPixels (x0, x1, x2, x3);
                } else {
                    *(U32_WMV *) (ppxlcCurrQMB+4) = packFourPixels (rgiClapTab [x0], rgiClapTab [x1], rgiClapTab [x2], rgiClapTab [x3]);       
                }
#endif

                ppxlcRef += iWidthFrm;
                ppxlcCurrQMB += iWidthFrm;
                ppxliErrorQMB += BLOCK_SIZE;
            }
          
        }
        else {  //bXSubPxl && !bYSubPxl
            for (iy = 0; iy < BLOCK_SIZE; iy++){

                I32_WMV x0 = ppxliErrorQMB [0] + ((ppxlcRef [1] + ppxlcRef [0]) >> 1);
                I32_WMV x1 = ppxliErrorQMB [1] + ((ppxlcRef [2] + ppxlcRef [1]) >> 1);
                I32_WMV x2 = ppxliErrorQMB [2] + ((ppxlcRef [3] + ppxlcRef [2]) >> 1);
                I32_WMV x3 = ppxliErrorQMB [3] + ((ppxlcRef [4] + ppxlcRef [3]) >> 1);

#ifdef _FASTMC_
                I32_WMV d0 = x2 << 16;
                I32_WMV d1 = x3 << 16;
                d0 = d0 | x0;
                d1 = d1 | x1;
                // Check for saturation
                if (((d0 | d1) & 0xff00ff00) == 0)
                {
                    *(U32_WMV *) ppxlcCurrQMB = d0 | (d1 << 8);
                }
                else
                {
                    *(U32_WMV *) ppxlcCurrQMB = packFourPixels (rgiClapTab [x0], rgiClapTab [x1], rgiClapTab [x2], rgiClapTab [x3]);            
                }

#else
                if ((((U32_WMV)x0|(U32_WMV)x1|(U32_WMV)x2|(U32_WMV)x3)&maskStaturation) == 0) {
                    *(U32_WMV *) ppxlcCurrQMB = packFourPixels (x0, x1, x2, x3);
                } else {
                    *(U32_WMV *) ppxlcCurrQMB = packFourPixels (rgiClapTab [x0], rgiClapTab [x1], rgiClapTab [x2], rgiClapTab [x3]);            
                }            
#endif

                x0 = ppxliErrorQMB [4] + ((ppxlcRef [5] + ppxlcRef [4]) >> 1);
                x1 = ppxliErrorQMB [5] + ((ppxlcRef [6] + ppxlcRef [5]) >> 1);
                x2 = ppxliErrorQMB [6] + ((ppxlcRef [7] + ppxlcRef [6]) >> 1);
                x3 = ppxliErrorQMB [7] + ((ppxlcRef [8] + ppxlcRef [7]) >> 1);

#ifdef _FASTMC_
                d0 = x2 << 16;
                d1 = x3 << 16;
                d0 = d0 | x0;
                d1 = d1 | x1;
                // Check for saturation
                if (((d0 | d1) & 0xff00ff00) == 0)
                {
                    *(U32_WMV *) (ppxlcCurrQMB+4) = d0 | (d1 << 8);
                }
                else
                {
                    *(U32_WMV *) (ppxlcCurrQMB+4) = packFourPixels (rgiClapTab [x0], rgiClapTab [x1], rgiClapTab [x2], rgiClapTab [x3]);
                }
#else
                if ((((U32_WMV)x0|(U32_WMV)x1|(U32_WMV)x2|(U32_WMV)x3)&maskStaturation) == 0) {
                    *(U32_WMV *) (ppxlcCurrQMB+4) = packFourPixels (x0, x1, x2, x3);
                } else {
                    *(U32_WMV *) (ppxlcCurrQMB+4) = packFourPixels (rgiClapTab [x0], rgiClapTab [x1], rgiClapTab [x2], rgiClapTab [x3]);         
                }
#endif                
                ppxlcRef += iWidthFrm;
                ppxlcCurrQMB += iWidthFrm;
                ppxliErrorQMB += BLOCK_SIZE;
            }
        }
    }
    else {
        const U8_WMV* ppxlcRefBot;
        if (bXEven) {  //!bXSubPxl&& bYSubPxl
            for (iy = 0; iy < BLOCK_SIZE; iy++) {

                ppxlcRefBot = ppxlcRef + iWidthFrm;		//UPln->pixels (xInt,yInt+1);

                I32_WMV x0 = ppxliErrorQMB [0] + ((ppxlcRef [0] + ppxlcRefBot [0]) >> 1);
                I32_WMV x1 = ppxliErrorQMB [1] + ((ppxlcRef [1] + ppxlcRefBot [1]) >> 1);
                I32_WMV x2 = ppxliErrorQMB [2] + ((ppxlcRef [2] + ppxlcRefBot [2]) >> 1);
                I32_WMV x3 = ppxliErrorQMB [3] + ((ppxlcRef [3] + ppxlcRefBot [3]) >> 1);

                
#ifdef _FASTMC_
                {
                    I32_WMV d0 = x2 << 16;
                    I32_WMV d1 = x3 << 16;
                    d0 = d0 | x0;
                    d1 = d1 | x1;
                    // Check for saturation
                    if (((d0 | d1) & 0xff00ff00) == 0)
                    {
                        *(U32_WMV *) ppxlcCurrQMB = d0 | (d1 << 8);
                    }
                    else
                    {
                        *(U32_WMV *) ppxlcCurrQMB = packFourPixels (rgiClapTab [x0], rgiClapTab [x1], rgiClapTab [x2], rgiClapTab [x3]);         
                    }
                }
#else
                if ((((U32_WMV)x0|(U32_WMV)x1|(U32_WMV)x2|(U32_WMV)x3)&maskStaturation) == 0) {
                    *(U32_WMV *) ppxlcCurrQMB = packFourPixels (x0, x1, x2, x3);
                } else {
                    *(U32_WMV *) ppxlcCurrQMB = packFourPixels (rgiClapTab [x0], rgiClapTab [x1], rgiClapTab [x2], rgiClapTab [x3]);         
                }
#endif

                x0 = ppxliErrorQMB [4] + ((ppxlcRef [4] + ppxlcRefBot [4]) >> 1);
                x1 = ppxliErrorQMB [5] + ((ppxlcRef [5] + ppxlcRefBot [5]) >> 1);
                x2 = ppxliErrorQMB [6] + ((ppxlcRef [6] + ppxlcRefBot [6]) >> 1);
                x3 = ppxliErrorQMB [7] + ((ppxlcRef [7] + ppxlcRefBot [7]) >> 1);

#ifdef _FASTMC_
                d0 = x2 << 16;
                d1 = x3 << 16;
                d0 = d0 | x0;
                d1 = d1 | x1;
                // Check for saturation
                if (((d0 | d1) & 0xff00ff00) == 0)
                {
                    *(U32_WMV *) (ppxlcCurrQMB+4) = d0 | (d1 << 8);
                }
                else
                {
                    *(U32_WMV *) (ppxlcCurrQMB+4) = packFourPixels (rgiClapTab [x0], rgiClapTab [x1], rgiClapTab [x2], rgiClapTab [x3]);
                }
#else
                if ((((U32_WMV)x0|(U32_WMV)x1|(U32_WMV)x2|(U32_WMV)x3)&maskStaturation) == 0) {
                    *(U32_WMV *) (ppxlcCurrQMB+4) = packFourPixels (x0, x1, x2, x3);
                } else {
                    *(U32_WMV *) (ppxlcCurrQMB+4) = packFourPixels (rgiClapTab [x0], rgiClapTab [x1], rgiClapTab [x2], rgiClapTab [x3]);            
                }
#endif                
                ppxlcRef = ppxlcRefBot;
                ppxlcCurrQMB += iWidthFrm;
                ppxliErrorQMB += BLOCK_SIZE;
            }
        }
        else { // bXSubPxl && bYSubPxl
            register U32_WMV x;
            for (iy = 0; iy < BLOCK_SIZE; iy++) {
                ppxlcRefBot = ppxlcRef + iWidthFrm;		//UPln->pixels (xInt,yInt+1);

#ifdef _FASTMC_
                {
                    I32_WMV x0, x1, x2, x3, d0, d1;
                    x = ppxlcRef [1] + ppxlcRefBot [1] + 1;
                    
                    x0 = ppxliErrorQMB [0] + ((ppxlcRef [0] + ppxlcRefBot [0] + x) >> 2);	                
                    x1 = ppxliErrorQMB [1] + ((ppxlcRef [2] + ppxlcRefBot [2] + x) >> 2);
                    x = ppxlcRef [3] + ppxlcRefBot [3] + 1;
                    x2 = ppxliErrorQMB [2] + ((ppxlcRef [2] + ppxlcRefBot [2] + x) >> 2);
                    x3 = ppxliErrorQMB [3] + ((ppxlcRef [4] + ppxlcRefBot [4] + x) >> 2);
                    
                    
                    d0 = x2 << 16;
                    d1 = x3 << 16;
                    d0 = d0 | x0;
                    d1 = d1 | x1;
                    // Check for saturation
                    if (((d0 | d1) & 0xff00ff00) == 0)
                    {
                        // If no saturation, write out merged bytes
                        *(U32_WMV *) ppxlcCurrQMB = d0 | (d1 << 8);
                    }
                    else
                    {
                        *(U32_WMV *) ppxlcCurrQMB = packFourPixels (rgiClapTab [x0], rgiClapTab [x1], rgiClapTab [x2], rgiClapTab [x3]);         
                    }
                    
                    x = ppxlcRef [5] + ppxlcRefBot [5] + 1;
                    
                    x0 = ppxliErrorQMB [4] + ((ppxlcRef [4] + ppxlcRefBot [4] + x) >> 2);	                
                    x1 = ppxliErrorQMB [5] + ((ppxlcRef [6] + ppxlcRefBot [6] + x) >> 2);
                    x = ppxlcRef [7] + ppxlcRefBot [7] + 1;
                    x2 = ppxliErrorQMB [6] + ((ppxlcRef [6] + ppxlcRefBot [6] + x) >> 2);
                    x3 = ppxliErrorQMB [7] + ((ppxlcRef [8] + ppxlcRefBot [8] + x) >> 2);
                    
                    d0 = x2 << 16;
                    d1 = x3 << 16;
                    d0 = d0 | x0;
                    d1 = d1 | x1;
                    // Check for saturation
                    if (((d0 | d1) & 0xff00ff00) == 0)
                    {
                        // If no saturation, write out merged bytes
                        *(U32_WMV *) (ppxlcCurrQMB+4) = d0 | (d1 << 8);
                    }
                    else
                    {/*
                     ppxlcCurrQMB [4] = rgiClapTab [x0];
                     ppxlcCurrQMB [5] = rgiClapTab [x1];
                     ppxlcCurrQMB [6] = rgiClapTab [x2];
                     ppxlcCurrQMB [7] = rgiClapTab [x3];
                        */
                        *(U32_WMV *) (ppxlcCurrQMB+4) = packFourPixels (rgiClapTab [x0], rgiClapTab [x1], rgiClapTab [x2], rgiClapTab [x3]);
                    }
                }
#else


                x = ppxlcRef [1] + ppxlcRefBot [1] + 1;
                ppxlcCurrQMB [0] = rgiClapTab [ppxliErrorQMB [0] + ((ppxlcRef [0] + ppxlcRefBot [0] + x) >> 2)];	                
                ppxlcCurrQMB [1] = rgiClapTab [ppxliErrorQMB [1] + ((ppxlcRef [2] + ppxlcRefBot [2] + x) >> 2)];
                x = ppxlcRef [3] + ppxlcRefBot [3] + 1;
                ppxlcCurrQMB [2] = rgiClapTab [ppxliErrorQMB [2] + ((ppxlcRef [2] + ppxlcRefBot [2] + x) >> 2)];
                ppxlcCurrQMB [3] = rgiClapTab [ppxliErrorQMB [3] + ((ppxlcRef [4] + ppxlcRefBot [4] + x) >> 2)];
                x = ppxlcRef [5] + ppxlcRefBot [5] + 1;
                ppxlcCurrQMB [4] = rgiClapTab [ppxliErrorQMB [4] + ((ppxlcRef [4] + ppxlcRefBot [4] + x) >> 2)];	                
                ppxlcCurrQMB [5] = rgiClapTab [ppxliErrorQMB [5] + ((ppxlcRef [6] + ppxlcRefBot [6] + x) >> 2)];
                x = ppxlcRef [7] + ppxlcRefBot [7] + 1;
                ppxlcCurrQMB [6] = rgiClapTab [ppxliErrorQMB [6] + ((ppxlcRef [6] + ppxlcRefBot [6] + x) >> 2)];
                ppxlcCurrQMB [7] = rgiClapTab [ppxliErrorQMB [7] + ((ppxlcRef [8] + ppxlcRefBot [8] + x) >> 2)];


#endif

                ppxlcRef = ppxlcRefBot;
                ppxlcCurrQMB += iWidthFrm;
                ppxliErrorQMB += BLOCK_SIZE;
            }
        }
    }
    FUNCTION_PROFILE_STOP(&fpDecode);
}
#endif

#pragma warning(disable:4244) 
Void_WMV g_MotionCompRndCtrl (
    tWMVDecInternalMember *pWMVDec,
	U8_WMV*             ppxlcPredMB,
	const U8_WMV*       ppxlcRefMB,
    I32_WMV             iWidthFrm,
    Bool_WMV            bInterpolateX,
    Bool_WMV            bInterpolateY,
    I32_WMV             iMixedPelMV	
)
{
    FUNCTION_PROFILE_DECL_START(fpDecode,MOTIONCOMPRNDCTRL_PROFILE);
#ifndef __UNIXVIDEO__

    I32_WMV iy;
    UWide	x01		= (UWide)0x0101010101010101;
    UWide	x7f 	= (UWide)0x7f7f7f7f7f7f7f7f;
    UWide   x3F     = (UWide)0x3F3F3F3F3F3F3F3F;
    UWide   x03     = (UWide)0x0303030303030303;

    UWide   *s1, *s2, *s3, *s4, *d;
    U8_WMV* ppxlcPred;
    const U8_WMV* ppxlcRef;

    if (bInterpolateY) {
        if (bInterpolateX) {  //!bXSubPxl && !bYSubPxl
            for (iy = 0; iy < 8; iy++) {
                //memcpy (ppxlcPredMB, ppxlcRefMB, 8);
                I32_WMV k;
                for (k = 0; k < 8; k += 8) {
                    *(U64 *)(ppxlcPredMB + k) = *(U64 *)(ppxlcRefMB + k);
                }
                ppxlcRefMB += iWidthFrm;
                ppxlcPredMB += iWidthFrm;
            }
        }
        else {  //bXSubPxl && !bYSubPxl
            I32_WMV ix;
            for (ix = 0; ix < 8; ix += sizeof(UWide)) {
                ppxlcPred = ppxlcPredMB+ix;
                ppxlcRef  = ppxlcRefMB+ix;
                for (iy = 0; iy < 8; iy++) {

                    s1 = (UWide*) ppxlcRef;
                    s2 = (UWide*) (ppxlcRef+1);
                    d  = (UWide*) ppxlcPred;

                    *d = (((*s1) >> 1) & x7f) + (((*s2) >> 1) & x7f) + (((*s1) & (*s2)) & x01);

                    ppxlcRef += iWidthFrm;
		            ppxlcPred += iWidthFrm;
	            } 
            }
        }
    }
    else {
        const U8_WMV* ppxlcRefBot;
        if (bInterpolateX) {  //!bXSubPxl&& bYSubPxl
            I32_WMV ix;
            for (ix = 0; ix < 8; ix += sizeof(UWide)) {
                ppxlcPred = ppxlcPredMB+ix;
                ppxlcRef  = ppxlcRefMB+ix;
                for (iy = 0; iy < 8; iy++) {
                    ppxlcRefBot = ppxlcRef + (iWidthFrm*1);		//UPln->pixels (xInt,yInt+1);

                    s1 = (UWide*) ppxlcRef;
                    s2 = (UWide*) ppxlcRefBot;
                    d  = (UWide*) ppxlcPred;

                    *d = (((*s1)>>1)&x7f)+(((*s2)>>1)&x7f)+(((*s1)&(*s2))&x01);

                    ppxlcRef += iWidthFrm;
                    ppxlcPred += iWidthFrm;
	            }
            }
        }
        else { // bXSubPxl && bYSubPxl
            I32_WMV ix;
            for (ix = 0; ix < 8; ix += sizeof(UWide) ) {
                ppxlcPred = ppxlcPredMB;
                ppxlcRef  = ppxlcRefMB;
                for (iy = 0; iy < 8; iy++) {
                    ppxlcRefBot = ppxlcRef + (iWidthFrm*1);

                    s1 = (UWide*) (ppxlcRef+1+ix);
                    s2 = (UWide*) (ppxlcRef+ix);
                    s3 = (UWide*) (ppxlcRefBot+1+ix);
                    s4 = (UWide*) (ppxlcRefBot+ix);
                    d  = (UWide*) (ppxlcPred+ix);

                    *d = (((*s1 >> 2) & x3F) + ((*s2 >> 2) & x3F) +
                          ((*s3 >> 2) & x3F) + ((*s4 >> 2) & x3F))+
                        ((((*s1       & x03) +  (*s2       & x03) +
                           (*s3       & x03) +  (*s4       & x03) + x01) >> 2) & x03);

                    ppxlcRef += iWidthFrm;
                    ppxlcPred += iWidthFrm;
                }
            }
        }
    }
#else // __UNIXVIDEO__
#ifndef _CASIO_VIDEO_
    assert ((8 % 8) == 0);
#endif

    I32_WMV iy;
    U32_WMV x01 = (U32_WMV)0x01010101;
    U32_WMV x7f = (U32_WMV)0x7f7f7f7f;
    U32_WMV x3F = (U32_WMV)0x3F3F3F3F;
    U32_WMV x03 = (U32_WMV)0x03030303;
    U8_WMV* ppxlcPred;
    const U8_WMV* ppxlcRef;
    if ((((U32_WMV) ppxlcRefMB) % 4) == 0) {// aligned
        if (bInterpolateY) {
            if (bInterpolateX) {  //!bXSubPxl && !bYSubPxl
                for (iy = BLOCK_SIZE; iy != 0; iy--) {
                    *(U64 *) ppxlcPredMB = *(U64 *) ppxlcRefMB;
                    ppxlcRefMB += iWidthFrm;
                    ppxlcPredMB += iWidthFrm;
                }
            }
            else {  //bXSubPxl && !bYSubPxl
                I32_WMV ix;
                for (ix = 0; ix < BLOCK_SIZE; ix += 4) {
                    ppxlcPred = ppxlcPredMB + ix;
                    ppxlcRef  = ppxlcRefMB + ix;
                    for (iy = BLOCK_SIZE; iy != 0; iy--) {
                        U32_WMV s1 = *(U32_WMV *) ppxlcRef;
#ifdef BIG_ENDING
                        U32_WMV s2 = (s1 << 8) | ppxlcRef [4];
#else
                        U32_WMV s2 = (s1 >> 8) | (((U32_WMV)ppxlcRef [4])<<24);
#endif
                        *(U32_WMV *) ppxlcPred = ((s1 >> 1) & x7f) + ((s2 >> 1) & x7f) + ((s1 & s2) & x01);
                        ppxlcRef += iWidthFrm;
                        ppxlcPred += iWidthFrm;
                    } 
                }
            }
        }
        else {
            const U8_WMV * ppxlcRefBot;
            if (bInterpolateX) {  //!bXSubPxl&& bYSubPxl
                I32_WMV ix;
                for (ix = 0; ix < BLOCK_SIZE; ix += 4) {
                    ppxlcPred = ppxlcPredMB + ix;
                    ppxlcRef  = ppxlcRefMB + ix;
                    for (iy = BLOCK_SIZE; iy != 0; iy--) {
                        ppxlcRefBot = ppxlcRef + iWidthFrm;		//UPln->pixels (xInt,yInt+1);
                        U32_WMV s1 = *(U32_WMV *) ppxlcRef;
                        U32_WMV s2 = *(U32_WMV *) ppxlcRefBot;
                        *(U32_WMV *) ppxlcPred = ((s1>>1)&x7f)+((s2>>1)&x7f)+((s1&s2)&x01);
                        ppxlcRef += iWidthFrm;
                        ppxlcPred += iWidthFrm;
                    }
                }
            }
            else { // bXSubPxl && bYSubPxl
                I32_WMV ix;
                for (ix = 0; ix < BLOCK_SIZE; ix += 4) {
                    ppxlcPred = ppxlcPredMB + ix;
                    ppxlcRef  = ppxlcRefMB + ix;
                    for (iy = BLOCK_SIZE; iy != 0; iy--) {
                        ppxlcRefBot = ppxlcRef + iWidthFrm;
                        U32_WMV s1 = *(U32_WMV *) ppxlcRef;
#ifdef BIG_ENDING
                        U32_WMV s2 = (s1 << 8) | ppxlcRef [4];
#else
                        U32_WMV s2 = (s1 >> 8) | (((U32_WMV)ppxlcRef [4])<<24);
#endif
                        U32_WMV s3 = *(U32_WMV *) ppxlcRefBot;
#ifdef BIG_ENDING
                        U32_WMV s4 = (s3 << 8) | ppxlcRefBot [4];
#else
                        U32_WMV s4 = (s3 >> 8) | (((U32_WMV)ppxlcRefBot [4])<<24);
#endif
                        *((U32_WMV *)ppxlcPred) = (((s1>>2)&x3F) + ((s2>>2)&x3F) +
                                                  ((s3>>2)&x3F) + ((s4>>2)&x3F))+
                                                ((((s1&x03) + (s2&x03) +
                                                   (s3&x03) + (s4&x03) + x01) >> 2) & x03);
                        ppxlcRef += iWidthFrm;
                        ppxlcPred += iWidthFrm;
                    }
                }
            }
        }
    } else {// not aligned
        if (bInterpolateY) {
            if (bInterpolateX) {  //!bXSubPxl && !bYSubPxl
                for (iy = BLOCK_SIZE; iy != 0; iy--) {
                    memcpy (ppxlcPredMB, ppxlcRefMB, BLOCK_SIZE);
                    ppxlcRefMB += iWidthFrm;
                    ppxlcPredMB += iWidthFrm;
                }
            }
            else {  //bXSubPxl && !bYSubPxl
                for (iy = 0; iy < BLOCK_SIZE; iy++){
                    ppxlcPredMB [0] = (ppxlcRefMB [1] + ppxlcRefMB [0]) >> 1;
                    ppxlcPredMB [1] = (ppxlcRefMB [2] + ppxlcRefMB [1]) >> 1;
                    ppxlcPredMB [2] = (ppxlcRefMB [3] + ppxlcRefMB [2]) >> 1;
                    ppxlcPredMB [3] = (ppxlcRefMB [4] + ppxlcRefMB [3]) >> 1;
                    ppxlcPredMB [4] = (ppxlcRefMB [5] + ppxlcRefMB [4]) >> 1;
                    ppxlcPredMB [5] = (ppxlcRefMB [6] + ppxlcRefMB [5]) >> 1;
                    ppxlcPredMB [6] = (ppxlcRefMB [7] + ppxlcRefMB [6]) >> 1;
                    ppxlcPredMB [7] = (ppxlcRefMB [8] + ppxlcRefMB [7]) >> 1;

                    ppxlcRefMB += iWidthFrm;
                    ppxlcPredMB += iWidthFrm;
                }
            }
        }
        else {
            const U8_WMV * ppxlcRefBot;
            if (bInterpolateX) {  //!bXSubPxl&& bYSubPxl
                for (iy = 0; iy < BLOCK_SIZE; iy++) {
                    ppxlcRefBot = ppxlcRefMB + iWidthFrm;		//UPln->pixels (xInt,yInt+1);

                    ppxlcPredMB [0] = (ppxlcRefMB [0] + ppxlcRefBot [0]) >> 1;
                    ppxlcPredMB [1] = (ppxlcRefMB [1] + ppxlcRefBot [1]) >> 1;
                    ppxlcPredMB [2] = (ppxlcRefMB [2] + ppxlcRefBot [2]) >> 1;
                    ppxlcPredMB [3] = (ppxlcRefMB [3] + ppxlcRefBot [3]) >> 1;
                    ppxlcPredMB [4] = (ppxlcRefMB [4] + ppxlcRefBot [4]) >> 1;
                    ppxlcPredMB [5] = (ppxlcRefMB [5] + ppxlcRefBot [5]) >> 1;
                    ppxlcPredMB [6] = (ppxlcRefMB [6] + ppxlcRefBot [6]) >> 1;
                    ppxlcPredMB [7] = (ppxlcRefMB [7] + ppxlcRefBot [7]) >> 1;

                    ppxlcRefMB = ppxlcRefBot;
                    ppxlcPredMB += iWidthFrm;
                }
            }
            else { // bXSubPxl && bYSubPxl
                register U32_WMV x, y;
                for (iy = 0; iy < BLOCK_SIZE; iy++) {
                    ppxlcRefBot = ppxlcRefMB + iWidthFrm;		//UPln->pixels (xInt,yInt+1);

                    x = ppxlcRefMB [1] + ppxlcRefBot [1] + 1;
                    ppxlcPredMB [0] = (x + ppxlcRefMB [0] + ppxlcRefBot [0]) >> 2;
                    y = ppxlcRefMB [2] + ppxlcRefBot [2];
                    ppxlcPredMB [1] = (x + y) >> 2;
                    x = y + 1;
                    y = ppxlcRefMB [3] + ppxlcRefBot [3];
                    ppxlcPredMB [2] = (x + y) >> 2;
                    x = y + 1;
                    y = ppxlcRefMB [4] + ppxlcRefBot [4];
                    ppxlcPredMB [3] = (x + y) >> 2;
                    x = y + 1;
                    y = ppxlcRefMB [5] + ppxlcRefBot [5];
                    ppxlcPredMB [4] = (x + y) >> 2;
                    x = y + 1;
                    y = ppxlcRefMB [6] + ppxlcRefBot [6];
                    ppxlcPredMB [5] = (x + y) >> 2;
                    x = y + 1;
                    y = ppxlcRefMB [7] + ppxlcRefBot [7];
                    ppxlcPredMB [6] = (x + y) >> 2;
                    x = y + 1;
                    ppxlcPredMB [7] = (x + ppxlcRefMB [8] + ppxlcRefBot [8]) >> 2;

                    ppxlcRefMB = ppxlcRefBot;
                    ppxlcPredMB += iWidthFrm;
                }
            }
        }
    }
#endif
    FUNCTION_PROFILE_STOP(&fpDecode);
}
#pragma warning(default:4244) 


#ifdef _USE_PORTABLE_C_

Void_WMV g_MotionCompAndAddError (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* ppxlcCurrQMB,
    const Buffer __huge* ppxliErrorBuf, const U8_WMV* ppxlcRef,
    I32_WMV iWidthFrm, Bool_WMV bXEven, Bool_WMV bYEven,
    I32_WMV iMixedPelMV	
)
{
    const U8_WMV* rgiClapTab = pWMVDec->m_rgiClapTabDec; 

//#ifndef _CASIO_VIDEO_
//    assert (rgiClapTab != NULL_WMV);
//#endif
    FUNCTION_PROFILE_DECL_START(fpDecode,MOTIONCOMPADDERROR_PROFILE);

    const PixelI32 *ppxliErrorQMB = ppxliErrorBuf->i32;

    
    I32_WMV iy;
    if (bYEven) {
        if (bXEven) {  //!bXSubPxl && !bYSubPxl
            for (iy = 0; iy < BLOCK_SIZE; iy++) {


                I32_WMV x0 = ppxliErrorQMB [0] + ppxlcRef [0];
                I32_WMV x1 = ppxliErrorQMB [1] + ppxlcRef [1];
                I32_WMV x2 = ppxliErrorQMB [2] + ppxlcRef [2];
                I32_WMV x3 = ppxliErrorQMB [3] + ppxlcRef [3];

#ifdef _FASTMC_
                I32_WMV d0 = x2 << 16;
                I32_WMV d1 = x3 << 16;
                d0 = d0 | x0;
                d1 = d1 | x1;
                // Check for saturation
                if (((d0 | d1) & 0xff00ff00) == 0)
                {
                    // If no saturation, write out merged bytes
                    *(U32_WMV *) ppxlcCurrQMB = d0 | (d1 << 8);
                }
                else
                {
                    *(U32_WMV *) ppxlcCurrQMB = packFourPixels (rgiClapTab [x0], rgiClapTab [x1], rgiClapTab [x2], rgiClapTab [x3]);
                }
#else
                if ((((U32_WMV)x0|(U32_WMV)x1|(U32_WMV)x2|(U32_WMV)x3)&maskStaturation) == 0) {
                    *(U32_WMV *) ppxlcCurrQMB = packFourPixels (x0, x1, x2, x3);
                } else {
                    *(U32_WMV *) ppxlcCurrQMB = packFourPixels (rgiClapTab [x0], rgiClapTab [x1], rgiClapTab [x2], rgiClapTab [x3]);          
                }
#endif

                x0 = ppxliErrorQMB [4] + ppxlcRef [4];
                x1 = ppxliErrorQMB [5] + ppxlcRef [5];
                x2 = ppxliErrorQMB [6] + ppxlcRef [6];
                x3 = ppxliErrorQMB [7] + ppxlcRef [7];


#ifdef _FASTMC_
                d0 = x2 << 16;
                d1 = x3 << 16;
                d0 = d0 | x0;
                d1 = d1 | x1;
                // Check for saturation
                if (((d0 | d1) & 0xff00ff00) == 0)
                {
                    // If no saturation, write out merged bytes
                    *(U32_WMV *) (ppxlcCurrQMB+4) = d0 | (d1 << 8);
                }
                else
                {
                    *(U32_WMV *) (ppxlcCurrQMB+4) = packFourPixels (rgiClapTab [x0], rgiClapTab [x1], rgiClapTab [x2], rgiClapTab [x3]);      
                }
#else
                if ((((U32_WMV)x0|(U32_WMV)x1|(U32_WMV)x2|(U32_WMV)x3)&maskStaturation) == 0) {
                    *(U32_WMV *) (ppxlcCurrQMB+4) = packFourPixels (x0, x1, x2, x3);
                } else {
                    *(U32_WMV *) (ppxlcCurrQMB+4) = packFourPixels (rgiClapTab [x0], rgiClapTab [x1], rgiClapTab [x2], rgiClapTab [x3]);      
                }
#endif
                ppxlcRef += iWidthFrm;
                ppxlcCurrQMB += iWidthFrm;
                ppxliErrorQMB += BLOCK_SIZE;
            }
        }
        else {  //bXSubPxl && !bYSubPxl
            for (iy = 0; iy < BLOCK_SIZE; iy++){
#ifdef _FASTMC_
                register U32_WMV x;
                x = ppxlcRef [1] + 1;

                I32_WMV x0 = ppxliErrorQMB [0] + ((x + ppxlcRef [0]) >> 1);
                I32_WMV x1 = ppxliErrorQMB [1] + ((x + ppxlcRef [2]) >> 1);
                x = ppxlcRef [3] + 1;
                I32_WMV x2 = ppxliErrorQMB [2] + ((x + ppxlcRef [2]) >> 1);
                I32_WMV x3 = ppxliErrorQMB [3] + ((x + ppxlcRef [4]) >> 1);

                I32_WMV d0 = x2 << 16;
                I32_WMV d1 = x3 << 16;
                d0 = d0 | x0;
                d1 = d1 | x1;
                // Check for saturation
                if (((d0 | d1) & 0xff00ff00) == 0)
                {
                    // If no saturation, write out merged bytes
                    *(U32_WMV *) ppxlcCurrQMB = d0 | (d1 << 8);
                }
                else
                {
                    *(U32_WMV *) ppxlcCurrQMB = packFourPixels (rgiClapTab [x0], rgiClapTab [x1], rgiClapTab [x2], rgiClapTab [x3]);      
                }

                x = ppxlcRef [5] + 1;


                x0 = ppxliErrorQMB [4] + ((x + ppxlcRef [4]) >> 1);
                x1 = ppxliErrorQMB [5] + ((x + ppxlcRef [6]) >> 1);
                x = ppxlcRef [7] + 1;
                x2 = ppxliErrorQMB [6] + ((x + ppxlcRef [6]) >> 1);
                x3 = ppxliErrorQMB [7] + ((x + ppxlcRef [8]) >> 1);

                d0 = x2 << 16;
                d1 = x3 << 16;
                d0 = d0 | x0;
                d1 = d1 | x1;
                // Check for saturation
                if (((d0 | d1) & 0xff00ff00) == 0)
                {
                    // If no saturation, write out merged bytes
                    *(U32_WMV *) (ppxlcCurrQMB+4) = d0 | (d1 << 8);
                }
                else
                {
                    *(U32_WMV *) (ppxlcCurrQMB+4) = packFourPixels (rgiClapTab [x0], rgiClapTab [x1], rgiClapTab [x2], rgiClapTab [x3]);      
                }
#else

                I32_WMV x0 = ppxliErrorQMB [0] + ((ppxlcRef [1] + ppxlcRef [0] + 1) >> 1);
                I32_WMV x1 = ppxliErrorQMB [1] + ((ppxlcRef [2] + ppxlcRef [1] + 1) >> 1);
                I32_WMV x2 = ppxliErrorQMB [2] + ((ppxlcRef [3] + ppxlcRef [2] + 1) >> 1);
                I32_WMV x3 = ppxliErrorQMB [3] + ((ppxlcRef [4] + ppxlcRef [3] + 1) >> 1);

                if ((((U32_WMV)x0|(U32_WMV)x1|(U32_WMV)x2|(U32_WMV)x3)&maskStaturation) == 0) {
                    *(U32_WMV *) ppxlcCurrQMB = packFourPixels (x0, x1, x2, x3);
                } else {
                    *(U32_WMV *) ppxlcCurrQMB = packFourPixels (rgiClapTab [x0], rgiClapTab [x1], rgiClapTab [x2], rgiClapTab [x3]);      
                }          

                x0 = ppxliErrorQMB [4] + ((ppxlcRef [5] + ppxlcRef [4] + 1) >> 1);
                x1 = ppxliErrorQMB [5] + ((ppxlcRef [6] + ppxlcRef [5] + 1) >> 1);
                x2 = ppxliErrorQMB [6] + ((ppxlcRef [7] + ppxlcRef [6] + 1) >> 1);
                x3 = ppxliErrorQMB [7] + ((ppxlcRef [8] + ppxlcRef [7] + 1) >> 1);

                if ((((U32_WMV)x0|(U32_WMV)x1|(U32_WMV)x2|(U32_WMV)x3)&maskStaturation) == 0) {
                    *(U32_WMV *) (ppxlcCurrQMB+4) = packFourPixels (x0, x1, x2, x3); 
                } else {
                    *(U32_WMV *) (ppxlcCurrQMB+4) = packFourPixels (rgiClapTab [x0], rgiClapTab [x1], rgiClapTab [x2], rgiClapTab [x3]);          
                }
#endif
                
                ppxlcRef += iWidthFrm;
                ppxlcCurrQMB += iWidthFrm;
                ppxliErrorQMB += BLOCK_SIZE;
            }
        }
    }
    else {
        const U8_WMV* ppxlcRefBot;
        if (bXEven) {  //!bXSubPxl&& bYSubPxl
            for (iy = 0; iy < BLOCK_SIZE; iy++) {

                ppxlcRefBot = ppxlcRef + iWidthFrm;		//UPln->pixels (xInt,yInt+1);

                I32_WMV x0 = ppxliErrorQMB [0] + ((ppxlcRef [0] + ppxlcRefBot [0] + 1) >> 1);
                I32_WMV x1 = ppxliErrorQMB [1] + ((ppxlcRef [1] + ppxlcRefBot [1] + 1) >> 1);
                I32_WMV x2 = ppxliErrorQMB [2] + ((ppxlcRef [2] + ppxlcRefBot [2] + 1) >> 1);
                I32_WMV x3 = ppxliErrorQMB [3] + ((ppxlcRef [3] + ppxlcRefBot [3] + 1) >> 1);

                if ((((U32_WMV)x0|(U32_WMV)x1|(U32_WMV)x2|(U32_WMV)x3)&maskStaturation) == 0) {
                    *(U32_WMV *) ppxlcCurrQMB = packFourPixels (x0, x1, x2, x3);
                } else {
                    *(U32_WMV *) ppxlcCurrQMB = packFourPixels (rgiClapTab [x0], rgiClapTab [x1], rgiClapTab [x2], rgiClapTab [x3]);         
                }

                x0 = ppxliErrorQMB [4] + ((ppxlcRef [4] + ppxlcRefBot [4] + 1) >> 1);
                x1 = ppxliErrorQMB [5] + ((ppxlcRef [5] + ppxlcRefBot [5] + 1) >> 1);
                x2 = ppxliErrorQMB [6] + ((ppxlcRef [6] + ppxlcRefBot [6] + 1) >> 1);
                x3 = ppxliErrorQMB [7] + ((ppxlcRef [7] + ppxlcRefBot [7] + 1) >> 1);

                if ((((U32_WMV)x0|(U32_WMV)x1|(U32_WMV)x2|(U32_WMV)x3)&maskStaturation) == 0) {
                    *(U32_WMV *) (ppxlcCurrQMB+4) = packFourPixels (x0, x1, x2, x3);
                } else {
                    *(U32_WMV *) (ppxlcCurrQMB+4) = packFourPixels (rgiClapTab [x0], rgiClapTab [x1], rgiClapTab [x2], rgiClapTab [x3]);   
                }
                 
                ppxlcRef = ppxlcRefBot;
                ppxlcCurrQMB += iWidthFrm;
                ppxliErrorQMB += BLOCK_SIZE;
            }
        }
        else { // bXSubPxl && bYSubPxl
            register U32_WMV x, y;
            for (iy = 0; iy < BLOCK_SIZE; iy++) {
                ppxlcRefBot = ppxlcRef + iWidthFrm;		//UPln->pixels (xInt,yInt+1);

#ifdef _FASTMC_


				x = ppxlcRef [1] + ppxlcRefBot [1] + 2;
                I32_WMV x0 = ppxliErrorQMB [0] + ((x + ppxlcRef [0] + ppxlcRefBot [0]) >> 2);
                y = ppxlcRef [2] + ppxlcRefBot [2];
                I32_WMV x1 = ppxliErrorQMB [1] + ((x + y) >> 2);
                x = y + 2;
                y = ppxlcRef [3] + ppxlcRefBot [3];
                I32_WMV x2 = ppxliErrorQMB [2] + ((x + y) >> 2);
                x = y + 2;
                y = ppxlcRef [4] + ppxlcRefBot [4];
                I32_WMV x3 = ppxliErrorQMB [3] + ((x + y) >> 2);


                I32_WMV d0 = x2 << 16;
                I32_WMV d1 = x3 << 16;
                d0 = d0 | x0;
                d1 = d1 | x1;
                // Check for saturation
                if (((d0 | d1) & 0xff00ff00) == 0)
                {
                    // If no saturation, write out merged bytes
                    *(U32_WMV *) ppxlcCurrQMB = d0 | (d1 << 8);
                }
                else
                {
                    *(U32_WMV *) ppxlcCurrQMB = packFourPixels (rgiClapTab [x0], rgiClapTab [x1], rgiClapTab [x2], rgiClapTab [x3]);      
                }

                x = y + 2;

                y = ppxlcRef [5] + ppxlcRefBot [5];
                x0 = ppxliErrorQMB [4] + ((x + y) >> 2);
                x = y + 2;
                y = ppxlcRef [6] + ppxlcRefBot [6];
                x1 = ppxliErrorQMB [5] + ((x + y) >> 2);
                x = y + 2;
                y = ppxlcRef [7] + ppxlcRefBot [7];
                x2 = ppxliErrorQMB [6] + ((x + y) >> 2);
                x = y + 2;
                x3 = ppxliErrorQMB [7] + ((x + ppxlcRef [8] + ppxlcRefBot [8]) >> 2);


                d0 = x2 << 16;
                d1 = x3 << 16;
                d0 = d0 | x0;
                d1 = d1 | x1;
                // Check for saturation
                if (((d0 | d1) & 0xff00ff00) == 0)
                {
                    // If no saturation, write out merged bytes
                    *(U32_WMV *) (ppxlcCurrQMB+4) = d0 | (d1 << 8);
                }
                else
                {
                    ppxlcCurrQMB [4] = rgiClapTab [x0];
                    ppxlcCurrQMB [5] = rgiClapTab [x1];
                    ppxlcCurrQMB [6] = rgiClapTab [x2];
                    ppxlcCurrQMB [7] = rgiClapTab [x3];
                }
#else



                x = ppxlcRef [1] + ppxlcRefBot [1] + 2;
                ppxlcCurrQMB [0] = rgiClapTab [ppxliErrorQMB [0] + ((x + ppxlcRef [0] + ppxlcRefBot [0]) >> 2)];
                y = ppxlcRef [2] + ppxlcRefBot [2];
                ppxlcCurrQMB [1] = rgiClapTab [ppxliErrorQMB [1] + ((x + y) >> 2)];
                x = y + 2;
                y = ppxlcRef [3] + ppxlcRefBot [3];
                ppxlcCurrQMB [2] = rgiClapTab [ppxliErrorQMB [2] + ((x + y) >> 2)];
                x = y + 2;
                y = ppxlcRef [4] + ppxlcRefBot [4];
                ppxlcCurrQMB [3] = rgiClapTab [ppxliErrorQMB [3] + ((x + y) >> 2)];
                x = y + 2;
                y = ppxlcRef [5] + ppxlcRefBot [5];
                ppxlcCurrQMB [4] = rgiClapTab [ppxliErrorQMB [4] + ((x + y) >> 2)];
                x = y + 2;
                y = ppxlcRef [6] + ppxlcRefBot [6];
                ppxlcCurrQMB [5] = rgiClapTab [ppxliErrorQMB [5] + ((x + y) >> 2)];
                x = y + 2;
                y = ppxlcRef [7] + ppxlcRefBot [7];
                ppxlcCurrQMB [6] = rgiClapTab [ppxliErrorQMB [6] + ((x + y) >> 2)];
                x = y + 2;
                ppxlcCurrQMB [7] = rgiClapTab [ppxliErrorQMB [7] + ((x + ppxlcRef [8] + ppxlcRefBot [8]) >> 2)];

#endif

                ppxlcRef = ppxlcRefBot;
                ppxlcCurrQMB += iWidthFrm;
                ppxliErrorQMB += BLOCK_SIZE;
            }
        }
    }
    FUNCTION_PROFILE_STOP(&fpDecode);
}

#endif

#pragma warning(disable:4244) 

Void_WMV g_MotionComp (
    tWMVDecInternalMember *pWMVDec,
	U8_WMV*              ppxlcPredMB,
	const U8_WMV*        ppxlcRefMB,
    I32_WMV                  iWidthFrm,
    Bool_WMV                 bInterpolateX,
    Bool_WMV                 bInterpolateY,
    I32_WMV iMixedPelMV	
)
{
    FUNCTION_PROFILE_DECL_START(fpDecode,MOTIONCOMP_PROFILE);
#ifndef __UNIXVIDEO__

    I32_WMV iy;
    UWide	x01		= (UWide)0x0101010101010101;
    UWide	x7f 	= (UWide)0x7f7f7f7f7f7f7f7f;
    UWide   x3F     = (UWide)0x3F3F3F3F3F3F3F3F;
    UWide   x03     = (UWide)0x0303030303030303;
    UWide   x02     = (UWide)0x0202020202020202;

    UWide   *s1, *s2, *s3, *s4, *d;

    U8_WMV*       ppxlcPred;
    const U8_WMV* ppxlcRef;

    if (bInterpolateY) {
        if (bInterpolateX) {  //!bXSubPxl && !bYSubPxl
            for (iy = 0; iy < 8; iy++) {
                //memcpy (ppxlcPredMB, ppxlcRefMB, 8);
                for (I32_WMV k = 0; k < 8; k += 8) {
                	*(U64 *)(ppxlcPredMB + k) = *(U64 *)(ppxlcRefMB + k);
                }
                ppxlcRefMB += iWidthFrm;
                ppxlcPredMB += iWidthFrm;
            }
        }
        else {  //bXSubPxl && !bYSubPxl
            int ix;
            for (ix = 0; ix < 8; ix += sizeof(UWide)) {
                ppxlcPred = ppxlcPredMB+ix;
                ppxlcRef  = ppxlcRefMB+ix;
                for (iy = 0; iy < 8; iy++) {
                    s1 = (UWide*) ppxlcRef;
                    s2 = (UWide*) (ppxlcRef+1);
                    d  = (UWide*) ppxlcPred;

                    *d = (((*s1) >> 1) & x7f) + (((*s2) >> 1) & x7f) + (((*s1) | (*s2)) & x01);

                    ppxlcRef += iWidthFrm;
		            ppxlcPred += iWidthFrm;
	            }
            }
        }
    }
    else {
        const U8_WMV* ppxlcRefBot;
        I32_WMV ioffset = iWidthFrm*1;
        if (bInterpolateX) {  //!bXSubPxl&& bYSubPxl
            for (int ix = 0; ix < 8; ix += sizeof(UWide)) {
                ppxlcPred = ppxlcPredMB+ix;
                ppxlcRef  = ppxlcRefMB+ix;
                for (iy = 0; iy < 8; iy++) {
                    ppxlcRefBot = ppxlcRef + ioffset; //UPln->pixels (xInt,yInt+1);

                    s1 = (UWide*) ppxlcRef;
                    s2 = (UWide*) ppxlcRefBot;
                    d  = (UWide*) ppxlcPred;
                    *d = (((*s1)>>1)&x7f)+(((*s2)>>1)&x7f)+(((*s1)|(*s2))&x01);

                    ppxlcRef += iWidthFrm;
                    ppxlcPred += iWidthFrm;
                }
            }
        }
        else { // bXSubPxl && bYSubPxl
            for (int ix = 0; ix < 8; ix += sizeof(UWide) ) {
                ppxlcPred = ppxlcPredMB;
                ppxlcRef  = ppxlcRefMB;
                for (iy = 0; iy < 8; iy++) {
                    ppxlcRefBot = ppxlcRef + ioffset;

                    s1 = (UWide*) (ppxlcRef+1+ix);
                    s2 = (UWide*) (ppxlcRef+ix);
                    s3 = (UWide*) (ppxlcRefBot+1+ix);
                    s4 = (UWide*) (ppxlcRefBot+ix);
                    d  = (UWide*) (ppxlcPred+ix);

                    *d = (((*s1 >> 2) & x3F) + ((*s2 >> 2) & x3F) +
                          ((*s3 >> 2) & x3F) + ((*s4 >> 2) & x3F))+
                        ((((*s1       & x03) +  (*s2       & x03) +
                           (*s3       & x03) +  (*s4       & x03) + x02) >> 2) & x03);

                    ppxlcRef += iWidthFrm;
                    ppxlcPred += iWidthFrm;
                }
            }
        }
    }
#endif
#ifdef __UNIXVIDEO__

    I32_WMV iy;
    U32_WMV x01 = (U32_WMV)0x01010101;
    U32_WMV x7f = (U32_WMV)0x7f7f7f7f;
    U32_WMV x3F = (U32_WMV)0x3F3F3F3F;
    U32_WMV x03 = (U32_WMV)0x03030303;
    U32_WMV x02 = (U32_WMV)0x02020202;
    U8_WMV* ppxlcPred;
    const U8_WMV* ppxlcRef;
    if ((((U32_WMV) ppxlcRefMB) % 4) == 0) {// aligned
        if (bInterpolateY) {
            if (bInterpolateX) {  //!bXSubPxl && !bYSubPxl
                for (iy = BLOCK_SIZE; iy != 0; iy--) {
                    *(U64 *) ppxlcPredMB = *(U64 *) ppxlcRefMB;
                    ppxlcRefMB += iWidthFrm;
                    ppxlcPredMB += iWidthFrm;
                }
            }
            else {  //bXSubPxl && !bYSubPxl
                for (I32_WMV ix = 0; ix < BLOCK_SIZE; ix += 4) {
                    ppxlcPred = ppxlcPredMB + ix;
                    ppxlcRef  = ppxlcRefMB + ix;
                    for (iy = BLOCK_SIZE; iy != 0; iy--) {
                        U32_WMV s1 = *(U32_WMV *) ppxlcRef;
#ifdef BIG_ENDING
                        U32_WMV s2 = (s1 << 8) | ppxlcRef [4];
#else
                        U32_WMV s2 = (s1 >> 8) | (((U32_WMV)ppxlcRef [4])<<24);
#endif
                        *(U32_WMV *) ppxlcPred = ((s1 >> 1) & x7f) + ((s2 >> 1) & x7f) + ((s1 | s2) & x01);
                        ppxlcRef += iWidthFrm;
		                ppxlcPred += iWidthFrm;
	                }
                }
            }
        }
        else {
            const U8_WMV * ppxlcRefBot;
            if (bInterpolateX) {  //!bXSubPxl&& bYSubPxl
                for (I32_WMV ix = 0; ix < BLOCK_SIZE; ix += 4) {
                    ppxlcPred = ppxlcPredMB + ix;
                    ppxlcRef  = ppxlcRefMB + ix;
                    for (iy = BLOCK_SIZE; iy != 0; iy--) {
                        ppxlcRefBot = ppxlcRef + iWidthFrm;		//UPln->pixels (xInt,yInt+1);
                        U32_WMV s1 = *(U32_WMV *) ppxlcRef;
                        U32_WMV s2 = *(U32_WMV *) ppxlcRefBot;
                        *(U32_WMV *) ppxlcPred = ((s1>>1)&x7f)+((s2>>1)&x7f)+((s1|s2)&x01);
                        ppxlcRef += iWidthFrm;
                        ppxlcPred += iWidthFrm;
                    }
                }
            }
            else { // bXSubPxl && bYSubPxl
                for (I32_WMV ix = 0; ix < BLOCK_SIZE; ix += 4) {
                    ppxlcPred = ppxlcPredMB + ix;
                    ppxlcRef  = ppxlcRefMB + ix;
                    for (iy = BLOCK_SIZE; iy != 0; iy--) {
                        ppxlcRefBot = ppxlcRef + iWidthFrm;
                        U32_WMV s1 = *(U32_WMV *) ppxlcRef;
#ifdef BIG_ENDING
                        U32_WMV s2 = (s1 << 8) | ppxlcRef [4];
#else
                        U32_WMV s2 = (s1 >> 8) | (((U32_WMV)ppxlcRef [4])<<24);
#endif
                        U32_WMV s3 = *(U32_WMV *) ppxlcRefBot;
#ifdef BIG_ENDING
                        U32_WMV s4 = (s3 << 8) | ppxlcRefBot [4];
#else
                        U32_WMV s4 = (s3 >> 8) | (((U32_WMV)ppxlcRefBot [4])<<24);
#endif
                        *((U32_WMV *)ppxlcPred) = (((s1>>2)&x3F) + ((s2>>2)&x3F) +
                                                  ((s3>>2)&x3F) + ((s4>>2)&x3F))+
                                                ((((s1&x03) + (s2&x03) +
                                                   (s3&x03) + (s4&x03) + x02) >> 2) & x03);
                        ppxlcRef += iWidthFrm;
                        ppxlcPred += iWidthFrm;
                    }
                }
            }
        }
    } else {// not aligned
        if (bInterpolateY) {
            if (bInterpolateX) {  //!bXSubPxl && !bYSubPxl
                for (iy = BLOCK_SIZE; iy != 0; iy--) {
                    memcpy (ppxlcPredMB, ppxlcRefMB, BLOCK_SIZE);
                    ppxlcRefMB += iWidthFrm;
                    ppxlcPredMB += iWidthFrm;
                }
            }
            else {  //bXSubPxl && !bYSubPxl
                for (iy = 0; iy < BLOCK_SIZE; iy++){
#ifdef _FASTMC_
                    register U32_WMV x;
                    x = ppxlcRefMB [1] + 1;
                    ppxlcPredMB [0] = (x + ppxlcRefMB [0]) >> 1;
                    ppxlcPredMB [1] = (x + ppxlcRefMB [2]) >> 1;
                    x = ppxlcRefMB [3] + 1;
                    ppxlcPredMB [2] = (x + ppxlcRefMB [2]) >> 1;
                    ppxlcPredMB [3] = (x + ppxlcRefMB [4]) >> 1;
                    x = ppxlcRefMB [5] + 1;
                    ppxlcPredMB [4] = (x + ppxlcRefMB [4]) >> 1;
                    ppxlcPredMB [5] = (x + ppxlcRefMB [6]) >> 1;
                    x = ppxlcRefMB [7] + 1;
                    ppxlcPredMB [6] = (x + ppxlcRefMB [6]) >> 1;
                    ppxlcPredMB [7] = (x + ppxlcRefMB [8]) >> 1;

#else
                    ppxlcPredMB [0] = (ppxlcRefMB [1] + ppxlcRefMB [0] + 1) >> 1;
                    ppxlcPredMB [1] = (ppxlcRefMB [2] + ppxlcRefMB [1] + 1) >> 1;
                    ppxlcPredMB [2] = (ppxlcRefMB [3] + ppxlcRefMB [2] + 1) >> 1;
                    ppxlcPredMB [3] = (ppxlcRefMB [4] + ppxlcRefMB [3] + 1) >> 1;
                    ppxlcPredMB [4] = (ppxlcRefMB [5] + ppxlcRefMB [4] + 1) >> 1;
                    ppxlcPredMB [5] = (ppxlcRefMB [6] + ppxlcRefMB [5] + 1) >> 1;
                    ppxlcPredMB [6] = (ppxlcRefMB [7] + ppxlcRefMB [6] + 1) >> 1;
                    ppxlcPredMB [7] = (ppxlcRefMB [8] + ppxlcRefMB [7] + 1) >> 1;
#endif

                    ppxlcRefMB += iWidthFrm;
                    ppxlcPredMB += iWidthFrm;
                }
            }
        }
        else {
            const U8_WMV * ppxlcRefBot;
            if (bInterpolateX) {  //!bXSubPxl&& bYSubPxl
                for (iy = 0; iy < BLOCK_SIZE; iy++) {

                    ppxlcRefBot = ppxlcRefMB + iWidthFrm;		//UPln->pixels (xInt,yInt+1);

                    ppxlcPredMB [0] = (ppxlcRefMB [0] + ppxlcRefBot [0] + 1) >> 1;
                    ppxlcPredMB [1] = (ppxlcRefMB [1] + ppxlcRefBot [1] + 1) >> 1;
                    ppxlcPredMB [2] = (ppxlcRefMB [2] + ppxlcRefBot [2] + 1) >> 1;
                    ppxlcPredMB [3] = (ppxlcRefMB [3] + ppxlcRefBot [3] + 1) >> 1;
                    ppxlcPredMB [4] = (ppxlcRefMB [4] + ppxlcRefBot [4] + 1) >> 1;
                    ppxlcPredMB [5] = (ppxlcRefMB [5] + ppxlcRefBot [5] + 1) >> 1;
                    ppxlcPredMB [6] = (ppxlcRefMB [6] + ppxlcRefBot [6] + 1) >> 1;
                    ppxlcPredMB [7] = (ppxlcRefMB [7] + ppxlcRefBot [7] + 1) >> 1;

                    ppxlcRefMB = ppxlcRefBot;
                    ppxlcPredMB += iWidthFrm;
                }
            }
            else { // bXSubPxl && bYSubPxl
                register U32_WMV x, y;
                for (iy = 0; iy < BLOCK_SIZE; iy++) {
                    ppxlcRefBot = ppxlcRefMB + iWidthFrm;		//UPln->pixels (xInt,yInt+1);

                    x = ppxlcRefMB [1] + ppxlcRefBot [1] + 2;
                    ppxlcPredMB [0] = (x + ppxlcRefMB [0] + ppxlcRefBot [0]) >> 2;
                    y = ppxlcRefMB [2] + ppxlcRefBot [2];
                    ppxlcPredMB [1] = (x + y) >> 2;
                    x = y + 2;
                    y = ppxlcRefMB [3] + ppxlcRefBot [3];
                    ppxlcPredMB [2] = (x + y) >> 2;
                    x = y + 2;
                    y = ppxlcRefMB [4] + ppxlcRefBot [4];
                    ppxlcPredMB [3] = (x + y) >> 2;
                    x = y + 2;
                    y = ppxlcRefMB [5] + ppxlcRefBot [5];
                    ppxlcPredMB [4] = (x + y) >> 2;
                    x = y + 2;
                    y = ppxlcRefMB [6] + ppxlcRefBot [6];
                    ppxlcPredMB [5] = (x + y) >> 2;
                    x = y + 2;
                    y = ppxlcRefMB [7] + ppxlcRefBot [7];
                    ppxlcPredMB [6] = (x + y) >> 2;
                    x = y + 2;
                    ppxlcPredMB [7] = (x + ppxlcRefMB [8] + ppxlcRefBot [8]) >> 2;

                    ppxlcRefMB = ppxlcRefBot;
                    ppxlcPredMB += iWidthFrm;
                }
            }
        }
    }
#endif // __UNIXVIDEO__
    FUNCTION_PROFILE_STOP(&fpDecode);
}
#endif //_EMB_WMV2_

#pragma warning(default:4244) 
#ifndef OPT_ZEROMOTION_ARM
Void_WMV g_MotionCompZeroMotion_WMV (
    U8_WMV* ppxliCurrQYMB, 
    U8_WMV* ppxliCurrQUMB, 
    U8_WMV* ppxliCurrQVMB,
    const U8_WMV* ppxliRefYMB, 
    const U8_WMV* ppxliRefUMB, 
    const U8_WMV* ppxliRefVMB,
    I32_WMV iWidthY,
    I32_WMV iWidthUV
)
{
#if !defined(_WIN32)
    assert(MB_SIZE < UINT_MAX);
    assert(BLOCK_SIZE < UINT_MAX);
#endif
    for (I32_WMV i = 0; i < BLOCK_SIZE; i++) {
        *(U64 *) ppxliCurrQYMB = *(U64 *) ppxliRefYMB;
        *(U64 *) (ppxliCurrQYMB + 8) = *(U64 *) (ppxliRefYMB + 8);
        ppxliCurrQYMB += iWidthY;
        ppxliRefYMB += iWidthY;
        *(U64 *) ppxliCurrQYMB = *(U64 *) ppxliRefYMB;
        *(U64 *) (ppxliCurrQYMB + 8) = *(U64 *) (ppxliRefYMB + 8);
        ppxliCurrQYMB += iWidthY;  
        ppxliRefYMB += iWidthY;
        *(U64 *) ppxliCurrQUMB = *(U64 *) ppxliRefUMB;
        ppxliCurrQUMB += iWidthUV;
        ppxliRefUMB += iWidthUV;
        *(U64 *) ppxliCurrQVMB = *(U64 *) ppxliRefVMB;
        ppxliCurrQVMB += iWidthUV;
        ppxliRefVMB += iWidthUV;
    }
}
#endif //OPT_ZEROMOTION_ARM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\motioncomp_wmv_x86.cpp ===
#include "bldsetup.h"

#include "xplatform.h"
#include <limits.h>
#include "typedef.hpp"
#include "motioncomp_wmv.h"
#include "opcodes.h"
#include "wmvdec_api.h"
#include "wmvdec_member.h"

#pragma warning( disable : 4731 ) // turn off ebp in inline assembly warning


#if defined(_WMV_TARGET_X86_) || defined(_Embedded_x86)
#if defined(_WIN32) || defined(_XBOX) || defined(_Embedded_x86)

Void_WMV g_MotionCompZeroMotion_MMX_WMV (
    U8_WMV* ppxliCurrQYMB, 
    U8_WMV* ppxliCurrQUMB, 
    U8_WMV* ppxliCurrQVMB,
    const U8_WMV* ppxliRefYMB, 
    const U8_WMV* ppxliRefUMB, 
    const U8_WMV* ppxliRefVMB,
    I32_WMV iWidthY,
    I32_WMV iWidthUV
)
{
#if defined(_WIN32) || defined(_XBOX)
__asm {
    mov			eax, dword ptr [ppxliCurrQYMB]
	mov			ebx, eax
    add         ebx, 8
    mov			ecx, dword ptr [ppxliRefYMB]
	mov			edx, ecx
    add         edx, 8
    mov         esi, iWidthY
    mov         edi, 16
LoopY:
    movq        mm0, [ecx]
    add         ecx, esi
    movq        [eax], mm0
    add         eax, esi
    movq        mm1, [edx]
    add         edx, esi
    movq        [ebx], mm1
    add         ebx, esi
    dec         edi
    jne         LoopY

    mov			eax, dword ptr [ppxliCurrQUMB]
	mov			ebx, dword ptr [ppxliCurrQVMB]
    mov			ecx, dword ptr [ppxliRefUMB]
	mov			edx, dword ptr [ppxliRefVMB]    
    mov         esi, iWidthUV
    mov         edi, 8
LoopUV:
    movq        mm0, [ecx]
    add         ecx, esi
    movq        [eax], mm0
    add         eax, esi
    movq        mm1, [edx]
    add         edx, esi
    movq        [ebx], mm1
    add         ebx, esi
    dec         edi
    jne         LoopUV
    emms
    }
#else
// if defined(_Embedded_x86)
asm volatile 
    (
    "mov %0, %%eax \n\t"
    "mov %1, %%ecx \n\t"
    "mov %2, %%esi \n\t"
    "mov $1, %%ebx \n\t"
    "mov	%%ecx, %%edx     \n\t"
    "add        $8, %%edx        \n\t"
    "mov        $16, %%edi       \n\t"
"LoopYa:                         \n\t"
    "movq       (%%ecx), %%mm0           \n\t"
    "add        %%esi, %%ecx           \n\t"
    "movq       %%mm0, (%%eax)           \n\t"
    "movq        (%%edx), %%mm1           \n\t"
    "add         %%esi, %%edx           \n\t"
    "movq        %%mm1, (%%eax, %%ebx, 8)           \n\t"
    "add         %%esi, %%eax           \n\t"
    "dec         %%edi           \n\t"
    "jne         LoopYa           \n\t"
    :
    : "m"  (ppxliCurrQYMB),
      "m"  (ppxliRefYMB),       
      "m"   (iWidthY)
    : "%eax", "%ecx", "%esi", "%ebx", "%edx", "%edi"
    );

asm volatile
  (
    "mov %0, %%eax   \n\t"
    "mov %1, %%ebx   \n\t"
    "mov %2, %%ecx   \n\t"
    "mov %3, %%edx   \n\t"
    "mov %4, %%esi   \n\t"
    "mov         $8, %%edi          \n\t"
"LoopUVa:                           \n\t"
    "movq        (%%ecx), %%mm0     \n\t"
    "add         %%esi, %%ecx       \n\t"
    "movq        %%mm0, (%%eax)     \n\t"
    "add         %%esi, %%eax       \n\t"
    "movq        (%%edx), %%mm1     \n\t"
    "add         %%esi, %%edx       \n\t"
    "movq        %%mm1, (%%ebx)     \n\t"
    "add         %%esi, %%ebx       \n\t"
    "dec         %%edi              \n\t"
    "jne         LoopUVa            \n\t"
    "emms                           \n\t"
    :
    :  "m" (ppxliCurrQUMB),
       "m" (ppxliCurrQVMB),
       "m" (ppxliRefUMB),
       "m" (ppxliRefVMB),   
       "m" (iWidthUV)
    : "%eax", "%ecx", "%esi", "%ebx", "%edx", "%edi"
    );
#endif
}

//ppxliErrorQMB is used as a 16bit int
Void_WMV g_MotionCompAndAddError_MMX (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* ppxlcCurrQMB,
    const Buffer __huge* ppxliErrorQMB, const U8_WMV* ppxlcRef,
    I32_WMV iWidthFrm, Bool_WMV bXEven, Bool_WMV bYEven, I32_WMV iMixedPelMV	
)
{
#if defined(_WIN32) || defined(_XBOX)
    if (bYEven) {
        if (bXEven) {  //!bXSubPxl && !bYSubPxl
			__asm {
				mov			eax, dword ptr [ppxlcCurrQMB]
				mov			ebx, dword ptr [ppxlcRef]
				mov			ecx, 8
				mov			edx, dword ptr [ppxliErrorQMB]
				mov			edi, dword ptr [iWidthFrm]
				pxor		mm7, mm7

			mainLoop1:
				movq		mm0, [ebx] // pred
				movq		mm1, [edx] // error
				movq		mm2, mm0
				punpcklbw	mm2, mm7
				paddw		mm1, mm2
				packuswb	mm1, mm7
				movd		[eax], mm1 // curr

				movq		mm1, [edx + 8]
				punpckhbw	mm0, mm7
				paddw		mm1, mm0
				packuswb	mm1, mm7
				movd		[eax + 4], mm1

				add			ebx, edi
				add			eax, edi
				add			edx, 16

				dec			ecx
				jne			mainLoop1
                emms
			}
        }
        else {  //bXSubPxl && !bYSubPxl
			static const __int64	x0101010101010101 = 0x0001000100010001;
			__asm {
				mov		eax, dword ptr [ppxlcCurrQMB]
				mov     ebx, dword ptr [ppxlcRef]
				mov     ecx, 8
				mov     edx, dword ptr [ppxliErrorQMB]
				mov		edi, dword ptr [iWidthFrm]
				movq	mm6, x0101010101010101
				pxor	mm7, mm7

			mainLoop2:
				movq		mm0, [ebx] // pred
				movq		mm1, [ebx + 1] // pred + 1
				movq		mm2, mm0
				movq		mm3, mm1
				punpcklbw	mm2, mm7
				punpcklbw	mm3, mm7
				paddw		mm2, mm3
				paddw		mm2, mm6
				psrlw		mm2, 1

				movq		mm3, [edx] // error
				paddw		mm2, mm3
				packuswb	mm2, mm7
				movd		[eax], mm2 // curr


				punpckhbw	mm0, mm7
				punpckhbw	mm1, mm7
				paddw		mm0, mm1
				paddw		mm0, mm6
				psrlw		mm0, 1

				movq		mm1, [edx + 8] // error
				paddw		mm0, mm1
				packuswb	mm0, mm7
				movd		[eax + 4], mm0 // curr

				add			ebx, edi
				add			eax, edi
				add			edx, 16

				dec			ecx
				jne			mainLoop2
                emms
			}   
        }
    }
    else {
        if (bXEven) {  //!bXSubPxl&& bYSubPxl
			static const __int64	x0001000100010001 = 0x0001000100010001;
			__asm {
				mov		eax, dword ptr [ppxlcCurrQMB]
				mov     ebx, dword ptr [ppxlcRef]
				mov     ecx, 8
				mov     edx, dword ptr [ppxliErrorQMB]
				mov		edi, dword ptr [iWidthFrm]
				movq	mm6, x0001000100010001
				pxor	mm7, mm7

			mainLoop3:
				movq		mm0, [ebx] // pred
				movq		mm1, [ebx + edi] // pred + 1
				movq		mm2, mm0
				movq		mm3, mm1
				punpcklbw	mm2, mm7
				punpcklbw	mm3, mm7
				paddw		mm2, mm3
				paddw		mm2, mm6
				psrlw		mm2, 1

				movq		mm3, [edx] // error
				paddw		mm2, mm3
				packuswb	mm2, mm7
				movd		[eax], mm2 // curr


				punpckhbw	mm0, mm7
				punpckhbw	mm1, mm7
				paddw		mm0, mm1
				paddw		mm0, mm6
				psrlw		mm0, 1

				movq		mm1, [edx + 8] // error
				paddw		mm0, mm1
				packuswb	mm0, mm7
				movd		[eax + 4], mm0 // curr

				add			ebx, edi
				add			eax, edi
				add			edx, 16

				dec			ecx
				jne			mainLoop3
                emms
			}
        }
        else { // bXSubPxl && bYSubPxl
			static const __int64	x0002000200020002 = 0x0002000200020002;
			__asm {
				mov			eax, dword ptr [ppxlcCurrQMB]
				mov			ebx, dword ptr [ppxlcRef]
				mov			ecx, 8
				mov			edx, dword ptr [ppxliErrorQMB]
				mov			edi, dword ptr [iWidthFrm]
				pxor		mm7, mm7

			mainLoop4:
				movq		mm0, [ebx] // pred
				movq		mm1, [ebx + 1] // pred + 1
				movq		mm2, [ebx + edi] // pred
				movq		mm3, [ebx + edi + 1] // pred + 1

				movq		mm4, mm0
				movq		mm5, mm1
				movq		mm6, mm2
				punpcklbw	mm4, mm7
				punpcklbw	mm5, mm7
				punpcklbw	mm6, mm7
				paddw		mm4, mm5
				paddw		mm4, mm6
				movq		mm5, mm3
				punpcklbw	mm5, mm7
				paddw		mm4, mm5
				paddw		mm4, x0002000200020002
				psrlw		mm4, 2

				movq		mm6, [edx] // error
				pxor		mm7, mm7

				paddw		mm4, mm6
				packuswb	mm4, mm7
				movd		[eax], mm4 // curr


				punpckhbw	mm0, mm7
				punpckhbw	mm1, mm7
				punpckhbw	mm2, mm7
				punpckhbw	mm3, mm7
				paddw		mm0, mm1
				paddw		mm0, mm2
				paddw		mm0, mm3
				paddw		mm0, x0002000200020002
				psrlw		mm0, 2

				movq		mm1, [edx + 8] // error
				pxor		mm7, mm7
				paddw		mm0, mm1
				packuswb	mm0, mm7
				movd		[eax + 4], mm0 // curr

				add			ebx, edi
				add			eax, edi
				add			edx, 16

				dec			ecx
				jne			mainLoop4
                emms
			}
        }
    }
#else // _Embedded_x86
    if (bYEven) {
        if (bXEven) {  //!bXSubPxl && !bYSubPxl
			asm volatile
            (
				"mov %0, %%eax    \n\t"
				"mov %1, %%ebx    \n\t"
				"mov %2, %%edx    \n\t"
				"mov %3, %%edi    \n\t"
				"mov			$1, %%esi    \n\t"
				"mov			$8, %%ecx    \n\t"
				"pxor		%%mm7, %%mm7      \n\t"
			"mainLoop1a:                       \n\t"
				"movq		(%%ebx), %%mm0          \n\t" // pred
				"movq		(%%edx), %%mm1          \n\t" // error
				"movq		%%mm0, %%mm2         \n\t"
				"punpcklbw	%%mm7, %%mm2         \n\t"
				"paddw		%%mm2, %%mm1         \n\t"
				"packuswb	%%mm7, %%mm1         \n\t"
				"movd		%%mm1, (%%eax)        \n\t" // curr

//				"movq		(%%edx, %%esi, 8), %%mm1 \n\t"
				"movq		8(%%edx), %%mm1 \n\t"
				"punpckhbw	%%mm7, %%mm0         \n\t"
				"paddw		%%mm0, %%mm1         \n\t"
				"packuswb	%%mm7, %%mm1         \n\t"

				"movd		%%mm1, 4(%%eax)         \n\t"
//				"movd		%%mm1, (%%eax, %%esi, 4)         \n\t"

				"add			%%edi, %%ebx         \n\t"
				"add			%%edi, %%eax         \n\t"
				"add			$16, %%edx         \n\t"

				"dec			%%ecx         \n\t"
				"jne			mainLoop1a         \n\t"
                "emms       \n\t"
                :
				:   "m"  (ppxlcCurrQMB),
				    "m"		(ppxlcRef),
				    "m"   (ppxliErrorQMB),
				    "m"   (iWidthFrm)
                :    "%eax", "%ebx", "%edx", "%edi", "%ecx", "%esi"
			);
        }
        else {  //bXSubPxl && !bYSubPxl
			static const __int64	x0101010101010101 = 0x0001000100010001;
//		    asm volatile ("\n\t movq	%0, %%mm6 \n ": : "m" (x0101010101010101));
			asm volatile
            (
                "mov  %0, %%eax              \n\t"
                "mov  %1, %%ebx              \n\t"
                "mov  %2, %%edx              \n\t"
                "mov  %3, %%edi              \n\t"
                "movq  %4, %%mm6              \n\t"
				"mov    $1, %%esi             \n\t"
				"mov    $8, %%ecx             \n\t"
//				"movq	$0x0001000100010001, %%mm6 \n\t"
				"pxor	%%mm7, %%mm7            \n\t"

			"mainLoop2:            \n\t"
				"movq		(%%ebx), %%mm0             \n\t" // pred
				"movq		1(%%ebx), %%mm1         \n\t" // pred + 1
//				"movq		(%%ebx , %%esi, 1), %%mm1         \n\t" // pred + 1
				"movq		%%mm0, %%mm2            \n\t"
				"movq		%%mm1, %%mm3            \n\t"
				"punpcklbw	%%mm7, %%mm2            \n\t"
				"punpcklbw	%%mm7, %%mm3            \n\t"
				"paddw		%%mm3, %%mm2            \n\t"
				"paddw		%%mm6, %%mm2            \n\t"
				"psrlw		$1, %%mm2            \n\t"

				"movq		(%%edx), %%mm3    \n\t" // error
				"paddw		%%mm3, %%mm2            \n\t"
				"packuswb	%%mm7, %%mm2            \n\t"
				"movd		%%mm2, (%%eax)  \n\t" // curr

				"punpckhbw	%%mm7, %%mm0            \n\t"
				"punpckhbw	%%mm7, %%mm1            \n\t"
				"paddw		%%mm1, %%mm0            \n\t"
				"paddw		%%mm6, %%mm0            \n\t"
				"psrlw		$1, %%mm0            \n\t"

//				"movq		(%%edx, %%esi, 8),  %%mm1            \n\t" // error
				"movq		8(%%edx),  %%mm1            \n\t" // error
				"paddw		%%mm1, %%mm0            \n\t"
				"packuswb	%%mm7, %%mm0            \n\t"
//				"movd		%%mm0, (%%eax, %%esi, 4)  \n\t" // curr
				"movd		%%mm0, 4(%%eax)  \n\t" // curr

				"add			%%edi, %%ebx             \n\t"
				"add			%%edi, %%eax           \n\t"
				"add			$16, %%edx            \n\t"

				"dec			%%ecx            \n\t"
				"jne			mainLoop2       \n\t"
                "emms       \n\t"
				:
                :    "m" (ppxlcCurrQMB),
				     "m" (ppxlcRef),
				     "m" (ppxliErrorQMB),
					 "m" (iWidthFrm),
			         "m" (x0101010101010101)
                :    "%eax", "%ebx", "%edx", "%edi", "%ecx", "%esi"
			);
        }
    }
    else {
        if (bXEven) {  //!bXSubPxl&& bYSubPxl
			static const __int64	x0001000100010001 = 0x0001000100010001;
//		    asm volatile ("\n\t movq	%0, %%mm6 \n ": : "m" (x0001000100010001));
			asm volatile
            (
				"mov    $1, %%esi            \n\t"
				"mov    $8, %%ecx            \n\t"
                "movq	%4, %%mm6            \n\t"
				"pxor	%%mm7, %%mm7   \n\t"

			"mainLoop3:                            \n\t"
				"movq		(%%ebx), %%mm0          \n\t" // pred
				"movq		(%%ebx, %%edi,1), %%mm1          \n\t" // pred + 1
				"movq		%%mm0, %%mm2          \n\t"
				"movq		%%mm1, %%mm3          \n\t"
				"punpcklbw	%%mm7, %%mm2          \n\t"
				"punpcklbw	%%mm7, %%mm3          \n\t"
				"paddw		%%mm3, %%mm2          \n\t"
				"paddw		%%mm6, %%mm2          \n\t"
				"psrlw		$1, %%mm2          \n\t"

				"movq		(%%edx), %%mm3          \n\t" // error
				"paddw		%%mm3, %%mm2          \n\t"
				"packuswb	%%mm7, %%mm2          \n\t"
				"movd		%%mm2, (%%eax)          \n\t" // curr


				"punpckhbw	%%mm7, %%mm0          \n\t"
				"punpckhbw	%%mm7, %%mm1          \n\t"
				"paddw		%%mm1, %%mm0          \n\t"
				"paddw		%%mm6, %%mm0          \n\t"
				"psrlw		$1, %%mm0          \n\t"

				"movq		8(%%edx), %%mm1          \n\t" // error
//				"movq		(%%edx, %%esi, 8), %%mm1          \n\t" // error
				"paddw		%%mm1, %%mm0          \n\t"
				"packuswb	%%mm7, %%mm0          \n\t"
//				"movd		%%mm0, (%%eax, %%esi, 4)           \n\t"// curr
				"movd		%%mm0, 4(%%eax)           \n\t"// curr

				"add		%%edi, %%ebx          \n\t"
				"add		%%edi, %%eax          \n\t"
				"add		$16, %%edx          \n\t"

				"dec			%%ecx          \n\t"
				"jne			mainLoop3          \n\t"
                "emms       \n\t"
                :
				:   "a" (ppxlcCurrQMB),
				    "b"   (ppxlcRef),
				    "d" (ppxliErrorQMB),
				    "D"	(iWidthFrm),
                    "m"	(x0001000100010001)
                :    "%eax", "%ebx", "%edx", "%edi", "%ecx", "%esi"
			);
        }
        else { // bXSubPxl && bYSubPxl
			static const __int64	x0002000200020002 = 0x0002000200020002;
			asm volatile
            (
                "mov        %0, %%eax \n\t"
                "mov        %1, %%ebx \n\t"
                "mov        %2, %%edx \n\t"
                "mov        %3, %%edi \n\t"
				"mov		$1, %%esi              \n\t"
				"mov		$8, %%ecx              \n\t"
				"pxor		%%mm7, %%mm7              \n\t"

			"mainLoop4:              \n\t"
				"movq		(%%ebx), %%mm0               \n\t" // pred
				"movq		1(%%ebx), %%mm1              \n\t" // pred + 1
				"movq		(%%ebx, %%edi,1), %%mm2              \n\t" // pred
				"movq		1(%%ebx, %%edi, 1), %%mm3              \n\t" // pred + 1
				"movq		%%mm0, %%mm4              \n\t"
				"movq		%%mm1, %%mm5              \n\t"
				"movq		%%mm2, %%mm6              \n\t"
				"punpcklbw	%%mm7, %%mm4              \n\t"
				"punpcklbw	%%mm7, %%mm5              \n\t"
				"punpcklbw	%%mm7, %%mm6              \n\t"
				"paddw		%%mm5, %%mm4              \n\t"
				"paddw		%%mm6, %%mm4              \n\t"
				"movq		%%mm3, %%mm5              \n\t"
				"punpcklbw	%%mm7, %%mm5              \n\t"
				"paddw		%%mm5, %%mm4              \n\t"
				"paddw		%4, %%mm4              \n\t"
//				"paddw		x0002000200020002, %%mm4              \n\t"
				"psrlw		$2, %%mm4              \n\t"

				"movq		(%%edx), %%mm6              \n\t" // error
				"pxor		%%mm7, %%mm7              \n\t"

				"paddw		%%mm6, %%mm4              \n\t"
				"packuswb	%%mm7, %%mm4              \n\t"
				"movd		%%mm4, (%%eax)               \n\t"// curr


				"punpckhbw	%%mm7, %%mm0              \n\t"
				"punpckhbw	%%mm7, %%mm1              \n\t"
				"punpckhbw	%%mm7, %%mm2              \n\t"
				"punpckhbw	%%mm7, %%mm3              \n\t"
				"paddw		%%mm1, %%mm0              \n\t"
				"paddw		%%mm2, %%mm0              \n\t"
				"paddw		%%mm3, %%mm0              \n\t"
				"paddw		%4, %%mm0              \n\t"
//				"paddw		x0002000200020002, %%mm0              \n\t"
				"psrlw		$2, %%mm0              \n\t"

				"movq		8(%%edx), %%mm1              \n\t" // error
				"pxor		%%mm7, %%mm7              \n\t"
				"paddw		%%mm1, %%mm0              \n\t"
				"packuswb	%%mm7, %%mm0              \n\t"
				"movd		%%mm0, 4(%%eax)               \n\t"// curr

				"add		%%edi, %%ebx              \n\t"
				"add		%%edi, %%eax              \n\t"
				"add		$16, %%edx              \n\t"

				"dec			%%ecx              \n\t"
				"jne			mainLoop4       \n\t"
                "emms       \n\t"
				:
                :   "m"	(ppxlcCurrQMB),
				    "m"	(ppxlcRef),
				    "m" (ppxliErrorQMB),
				    "m" (iWidthFrm),
                    "m" (x0002000200020002)
//                :    "%eax", "%ebx", "%edx", "%edi"
                :    "%eax", "%ebx", "%edx", "%edi", "%ecx", "%esi"
			);
        }
    }
#endif

}

Void_WMV g_MotionComp_MMX(
    tWMVDecInternalMember *pWMVDec,
	U8_WMV*             ppxlcPredMB,
	const U8_WMV*       ppxlcRefMB,
    I32_WMV             iWidthFrm,
    Bool_WMV            bInterpolateX,
    Bool_WMV            bInterpolateY,
    I32_WMV             iMixedPelMV	
)
{


  	static const Int64 x01 = (Int64)0x0101010101010101;
    static const Int64 x7f = (Int64)0x7f7f7f7f7f7f7f7f;
    static const Int64 x3F = (Int64)0x3F3F3F3F3F3F3F3F;
    static const Int64 x03 = (Int64)0x0303030303030303;
    static const Int64 x02 = (Int64)0x0202020202020202;

#if defined(_WIN32) || defined(_XBOX)
     if (bInterpolateY) {
        if (bInterpolateX) {  //!bXSubPxl && !bYSubPxl
            _asm {
            mov         esi,ppxlcRefMB
            mov         edi,ppxlcPredMB
            mov         eax,iWidthFrm
            mov         ebx,iWidthFrm
            mov         ecx,8
            cmp         ecx,16
            jz          CopyLoop2
CopyLoop1:
            movq        mm0,[esi]
            add         esi,eax
            movq        [edi],mm0
            add         edi,ebx
            dec         ecx
            jnz         CopyLoop1
            jmp         End
CopyLoop2:
            movq        mm0,[esi]
            movq        [edi],mm0
            movq        mm0,[esi+8]
            add         esi,eax
            movq        [edi+8],mm0
            add         edi,ebx
            dec         ecx
            jnz         CopyLoop2
            }
        }
        else {  //bXSubPxl && !bYSubPxl
            _asm {
            mov         esi,ppxlcRefMB
            mov         edi,ppxlcPredMB
            mov         edx,1
            mov         eax,iWidthFrm
            mov         ebx,iWidthFrm
            movq        mm7,x7f
            movq        mm6,x01
            mov         ecx,8
            cmp         ecx,16
            jz          HorizantalLoop2
HorizantalLoop1:
            movq        mm0,[esi]
            movq        mm1,[esi+edx]

            //avg mm0,mm1
            movq        mm5,mm0
            por         mm5,mm1
            psrlw       mm0,1
            psrlw       mm1,1
            pand        mm5,mm6
            pand        mm0,mm7
            pand        mm1,mm7
            paddw       mm0,mm5
            paddw       mm0,mm1

            movq        [edi],mm0
            add         esi,eax
            add         edi,ebx
            dec         ecx
            jnz         HorizantalLoop1
            jmp         End

HorizantalLoop2:
            movq        mm0,[esi]
            movq        mm1,[esi+edx]

            //avg mm0,mm1
            movq        mm5,mm0
            por         mm5,mm1
            psrlw       mm0,1
            psrlw       mm1,1
            pand        mm5,mm6
            pand        mm0,mm7
            pand        mm1,mm7
            paddw       mm0,mm5
            paddw       mm0,mm1

            movq        [edi],mm0

            movq        mm0,[esi+8]
            movq        mm1,[esi+edx+8]

            //avg mm0,mm1
            movq        mm5,mm0
            por         mm5,mm1
            psrlw       mm0,1
            psrlw       mm1,1
            pand        mm5,mm6
            pand        mm0,mm7
            pand        mm1,mm7
            paddw       mm0,mm5
            paddw       mm0,mm1

            movq        [edi+8],mm0

            add         esi,eax
            add         edi,ebx
            dec         ecx
            jnz         HorizantalLoop2
	        }
        }
    }
    else {
        if (bInterpolateX) {  //!bXSubPxl&& bYSubPxl
            _asm {
            mov         esi,ppxlcRefMB
            mov         edi,ppxlcPredMB
            mov         eax,iWidthFrm
            mov         edx,1
            imul        edx,eax
            mov         eax,iWidthFrm
            mov         ebx,iWidthFrm
            movq        mm7,x7f
            movq        mm6,x01
            mov         ecx,8
            cmp         ecx,16
            jz          VerticalLoop2
VerticalLoop1:
            movq        mm0,[esi]
            movq        mm1,[esi+edx]

            //avg mm0,mm1
            movq        mm5,mm0
            por         mm5,mm1
            psrlw       mm0,1
            psrlw       mm1,1
            pand        mm5,mm6
            pand        mm0,mm7
            pand        mm1,mm7
            paddw       mm0,mm5
            paddw       mm0,mm1

            movq        [edi],mm0
            add         esi,eax
            add         edi,ebx
            dec         ecx
            jnz         VerticalLoop1
            jmp         End

VerticalLoop2:
            movq        mm0,[esi]
            movq        mm1,[esi+edx]

            //avg mm0,mm1
            movq        mm5,mm0
            por         mm5,mm1
            psrlw       mm0,1
            psrlw       mm1,1
            pand        mm5,mm6
            pand        mm0,mm7
            pand        mm1,mm7
            paddw       mm0,mm5
            paddw       mm0,mm1

            movq        [edi],mm0

            movq        mm0,[esi+8]
            movq        mm1,[esi+edx+8]

            //avg mm0,mm1
            movq        mm5,mm0
            por         mm5,mm1
            psrlw       mm0,1
            psrlw       mm1,1
            pand        mm5,mm6
            pand        mm0,mm7
            pand        mm1,mm7
            paddw       mm0,mm5
            paddw       mm0,mm1

            movq        [edi+8],mm0

            add         esi,eax
            add         edi,ebx
            dec         ecx
            jnz         VerticalLoop2
	        }
        }
        else { // bXSubPxl && bYSubPxl
            _asm {
            mov         esi,ppxlcRefMB
            mov         edi,ppxlcPredMB

            mov         eax,1
            cmp         eax,-1
            jnz         PositiveXMV
            dec         esi
PositiveXMV:
            movq        mm7,x3F
            movq        mm6,x03
            mov         eax,iWidthFrm
            mov         edx,1
            imul        edx,eax
            mov         ecx,iWidthFrm
            mov         ebx,iWidthFrm
//            mov         [esp-4],ebp
            push        ebp; // for xbox->fix esp crash because the stack can't be accessed
            mov         ebp,8
            cmp         ebp,16
            jz          BilinearLoop2
BilinearLoop1:
            movq        mm0,[esi]
            movq        mm4,mm0
            pand        mm4,mm6
            movq        mm1,[esi+1]
            movq        mm5,mm1
            pand        mm5,mm6
            paddw       mm4,mm5
            movq        mm2,[esi+edx]
            movq        mm5,mm2
            pand        mm5,mm6
            paddw       mm4,mm5
            movq        mm3,[esi+edx+1]
            movq        mm5,mm3
            pand        mm5,mm6
            paddw       mm4,mm5
            paddw       mm4,x02
            psrlw       mm4,2
            pand        mm4,mm6
            psrlw       mm0,2
            pand        mm0,mm7
            psrlw       mm1,2
            pand        mm1,mm7
            paddw       mm0,mm1
            psrlw       mm2,2
            pand        mm2,mm7
            paddw       mm0,mm2
            psrlw       mm3,2
            pand        mm3,mm7
            paddw       mm0,mm3
            paddw       mm0,mm4
            movq        [edi],mm0

            add         esi,ecx
            add         edi,ebx
            dec         ebp
            jnz         BilinearLoop1
//            mov         ebp,[esp-4]
            pop         ebp 
            jmp         End

BilinearLoop2:
            movq        mm0,[esi]
            movq        mm4,mm0
            pand        mm4,mm6
            movq        mm1,[esi+1]
            movq        mm5,mm1
            pand        mm5,mm6
            paddw       mm4,mm5
            movq        mm2,[esi+edx]
            movq        mm5,mm2
            pand        mm5,mm6
            paddw       mm4,mm5
            movq        mm3,[esi+edx+1]
            movq        mm5,mm3
            pand        mm5,mm6
            paddw       mm4,mm5
            paddw       mm4,x02
            psrlw       mm4,2
            pand        mm4,mm6
            psrlw       mm0,2
            pand        mm0,mm7
            psrlw       mm1,2
            pand        mm1,mm7
            paddw       mm0,mm1
            psrlw       mm2,2
            pand        mm2,mm7
            paddw       mm0,mm2
            psrlw       mm3,2
            pand        mm3,mm7
            paddw       mm0,mm3
            paddw       mm0,mm4
            movq        [edi],mm0

            movq        mm0,[esi+8]
            movq        mm4,mm0
            pand        mm4,mm6
            movq        mm1,[esi+9]
            movq        mm5,mm1
            pand        mm5,mm6
            paddw       mm4,mm5
            movq        mm2,[esi+edx+8]
            movq        mm5,mm2
            pand        mm5,mm6
            paddw       mm4,mm5
            movq        mm3,[esi+edx+9]
            movq        mm5,mm3
            pand        mm5,mm6
            paddw       mm4,mm5
            paddw       mm4,x02
            psrlw       mm4,2
            pand        mm4,mm6
            psrlw       mm0,2
            pand        mm0,mm7
            psrlw       mm1,2
            pand        mm1,mm7
            paddw       mm0,mm1
            psrlw       mm2,2
            pand        mm2,mm7
            paddw       mm0,mm2
            psrlw       mm3,2
            pand        mm3,mm7
            paddw       mm0,mm3
            paddw       mm0,mm4
            movq        [edi+8],mm0

            add         esi,ecx
            add         edi,ebx
            dec         ebp
            jnz         BilinearLoop2
//            mov         ebp,[esp-4]
            pop         ebp; // for x-box
            }
        }
    }
End: _asm emms;
#else // _Embedded_x86
     if (bInterpolateY) {
        if (bInterpolateX) {  //!bXSubPxl && !bYSubPxl
            asm volatile
            (
            "cmp         $16, %%ecx \n\t"
            "jz          CopyLoop2a  \n\t"

"CopyLoop1a:             \n\t"
            "movq        (%%esi), %%mm0     \n\t"
            "add         %%eax, %%esi     \n\t"
            "movq        %%mm0, (%%edi)     \n\t"
            "add         %%ebx,%%edi     \n\t"
            "dec         %%ecx     \n\t"
            "jnz         CopyLoop1a     \n\t"
            "jmp         Enda     \n\t"

"CopyLoop2a:     \n\t"
            "movq        (%%esi), %%mm0     \n\t"
            "movq        %%mm0, (%%edi)     \n\t"
            "movq        8(%%esi), %%mm0     \n\t" 
            "add         %%eax,%%esi     \n\t"
            "movq        %%mm0, 8(%%edi)     \n\t"
            "add         %%ebx, %%edi     \n\t"
            "dec         %%ecx     \n\t"
            "jnz         CopyLoop2a     \n\t"
             :
             : "S"  (ppxlcRefMB),
               "D"  (ppxlcPredMB),
               "a"  (iWidthFrm),
               "b" (iWidthFrm),
               "c" (8)
             : "%esi", "%edi", "%eax", "%ebx", "%ecx", "%edx", "%ebp"
            );
        }     
        else {  //bXSubPxl && !bYSubPxl     
            asm volatile
            (
             "mov %0, %%esi         \n\t"
             "mov %1, %%edi         \n\t"
             "mov %2, %%edx         \n\t"
             "mov %3, %%eax         \n\t"
             "mov %4, %%ebx         \n\t"
             "mov %5, %%ecx         \n\t"
            "movq        %6, %%mm7     \n\t"
//            "movq        x7f, %%mm7     \n\t"
            "movq        %7, %%mm6     \n\t"
//            "movq        x01, %%mm6     \n\t"
            "cmp         $16, %%ecx     \n\t"
            "jz          HorizantalLoop2a     \n\t"
" HorizantalLoop1a:     \n\t"
            "movq        (%%esi), %%mm0     \n\t"
            "movq        (%%esi, %%edx, 1), %%mm1     \n\t"
     
            //avg %%mm0,%%mm1     \n\t"
            "movq        %%mm0,%%mm5     \n\t"
            "por         %%mm1,%%mm5     \n\t"
            "psrlw       $1, %%mm0     \n\t"
            "psrlw       $1, %%mm1     \n\t"
            "pand        %%mm6,%%mm5     \n\t"
            "pand        %%mm7,%%mm0     \n\t"
            "pand        %%mm7,%%mm1     \n\t"
            "paddw       %%mm5,%%mm0     \n\t"
            "paddw       %%mm1,%%mm0     \n\t"
    
            "movq        %%mm0, (%%edi)     \n\t"
            "add         %%eax, %%esi     \n\t"
            "add         %%ebx, %%edi     \n\t"
            "dec         %%ecx     \n\t"
            "jnz         HorizantalLoop1a     \n\t"
            "jmp         Enda     \n\t"

"HorizantalLoop2a:     \n\t"
            "movq        (%%esi), %%mm0     \n\t"
            "movq        (%%esi, %%edx, 1), %%mm1     \n\t"
     
            //avg %%mm0,%%mm1     \n\t"
            "movq        %%mm0,%%mm5     \n\t"
            "por         %%mm1,%%mm5     \n\t"
            "psrlw       $1, %%mm0     \n\t"
            "psrlw       $1, %%mm1     \n\t"
            "pand        %%mm6,%%mm5     \n\t"
            "pand        %%mm7,%%mm0     \n\t"
            "pand        %%mm7,%%mm1     \n\t"
            "paddw       %%mm5,%%mm0     \n\t"
            "paddw       %%mm1,%%mm0     \n\t"
     
            "movq        %%mm0, (%%edi)     \n\t"
     
            "movq        8(%%esi), %%mm0     \n\t"
            "movq        8(%%esi, %%edx, 1), %%mm1     \n\t"

            //avg %%mm0,%%mm1      // Here , IW
            "movq        %%mm0,%%mm5     \n\t"
            "por         %%mm1,%%mm5     \n\t"
            "psrlw       $1, %%mm0     \n\t"
            "psrlw       $1, %%mm1     \n\t"
            "pand        %%mm6,%%mm5     \n\t"
            "pand        %%mm7,%%mm0     \n\t"
            "pand        %%mm7,%%mm1     \n\t"
            "paddw       %%mm5,%%mm0     \n\t"
            "paddw       %%mm1,%%mm0     \n\t"
 
            "movq        %%mm0, 8(%%edi)     \n\t"

            "add         %%eax, %%esi     \n\t"
            "add         %%ebx, %%edi     \n\t"
            "dec         %%ecx     \n\t"
            "jnz         HorizantalLoop2a     \n\t"
            :
            :   "m"  (ppxlcRefMB),
                "m"  (ppxlcPredMB),
                "m"  (1),
                "m"  (iWidthFrm),
                "m"   (iWidthFrm),
                "m"  (8),
                "m"  (x7f),
                "m"  (x01)
            :  "%esi", "%edi", "%edx", "%eax", "%ebx", "%ecx", "%ebp"
            );
        }    
    }    
    else {
        if (bInterpolateX) {  //!bXSubPxl&& bYSubPxl
            asm volatile 
            ( 
            "mov %0, %%esi  \n\t"
            "mov %1, %%edi  \n\t"
            "mov %2, %%edx  \n\t"
            "mov %3, %%eax  \n\t"
            "mov %4, %%ebx  \n\t"
            "mov %5, %%ecx  \n\t"
//            "mov         $1, %%ebp     \n\t"
            "imul        %%eax, %%edx     \n\t"
            "mov         %3, %%eax     \n\t"
            "movq        %6, %%mm7     \n\t"
//            "movq        x7f, %%mm7     \n\t"
            "movq        %7, %%mm6     \n\t"
//            "movq        x01, %%mm6     \n\t"
            "cmp         $16, %%ecx     \n\t"
            "jz          VerticalLoop2a     \n\t"
"VerticalLoop1a:     \n\t"
            "movq        (%%esi), %%mm0     \n\t"
            "movq        (%%esi, %%edx, 1), %%mm1     \n\t"  // esi + edi

            //avg %%mm0,%%mm1
            "movq        %%mm0,%%mm5     \n\t"
            "por         %%mm1,%%mm5     \n\t"
            "psrlw       $1, %%mm0     \n\t"
            "psrlw       $1, %%mm1     \n\t"
            "pand        %%mm6,%%mm5     \n\t"
            "pand        %%mm7,%%mm0     \n\t"
            "pand        %%mm7,%%mm1     \n\t"
            "paddw       %%mm5,%%mm0     \n\t"
            "paddw       %%mm1,%%mm0     \n\t"

            "movq        %%mm0, (%%edi)     \n\t"
            "add         %%eax, %%esi     \n\t"
            "add         %%ebx, %%edi     \n\t"
            "dec         %%ecx     \n\t"
            "jnz         VerticalLoop1a     \n\t"
            "jmp         Enda     \n\t"
     
"VerticalLoop2a:     \n\t"
            "movq        (%%esi), %%mm0     \n\t"
            "movq        (%%esi, %%edx, 1), %%mm1     \n\t"  // esi + edi

            //avg %%mm0,%%mm1     
            "movq        %%mm0,%%mm5     \n\t"
            "por         %%mm1,%%mm5     \n\t"
            "psrlw       $1, %%mm0     \n\t"
            "psrlw       $1, %%mm1     \n\t"
            "pand        %%mm6,%%mm5     \n\t"
            "pand        %%mm7,%%mm0     \n\t"
            "pand        %%mm7,%%mm1     \n\t"
            "paddw       %%mm5,%%mm0     \n\t"
            "paddw       %%mm1,%%mm0     \n\t"

            "movq        %%mm0, (%%edi)     \n\t"

            "movq        8(%%esi), %%mm0     \n\t"
            "movq        8(%%esi, %%edx, 1), %%mm1     \n\t" // esi+edx + 8

            //avg %%mm0,%%mm1     
            "movq        %%mm0,%%mm5     \n\t"
            "por         %%mm1,%%mm5     \n\t"
            "psrlw       $1, %%mm0     \n\t"
            "psrlw       $1, %%mm1     \n\t"
            "pand        %%mm6,%%mm5     \n\t"
            "pand        %%mm7,%%mm0     \n\t"
            "pand        %%mm7,%%mm1     \n\t"
            "paddw       %%mm5,%%mm0     \n\t"
            "paddw       %%mm1,%%mm0     \n\t"

            "movq        %%mm0, 8(%%edi)     \n\t"

            "add         %%eax, %%esi     \n\t"
            "add         %%ebx, %%edi     \n\t"
            "dec         %%ecx     \n\t"
            "jnz         VerticalLoop2a     \n\t"
            :
            :   "m"  (ppxlcRefMB),
                "m"  (ppxlcPredMB),     
                "m"   (1),
                "m"   (iWidthFrm),  
                "m"   (iWidthFrm),
                "m"   (8),
                "m"   (x7f),
                "m"   (x01)
            :   "%esi", "%edi", "%edx", "%eax", "%ebx", "%ecx", "%ebp"
	    );     
        }     
        else { // bXSubPxl && bYSubPxl

//            asm volatile ("mov  %0, %%esi : :  "m" (ppxlcRefMB));
            asm volatile 
            (
            "mov  %0, %%esi  \n\t"
            "mov  %1, %%edi  \n\t"
            "mov  %2, %%eax  \n\t"
            "cmp         $-1, %%eax     \n\t"
            "jnz         PositiveXMV     \n\t"
            "dec         %%esi     \n\t"
"PositiveXMV:     \n\t"
            "movq        %3, %%mm7     \n\t"
            "movq        %4, %%mm6     \n\t"
            "mov         %5, %%eax     \n\t"
            "mov         %7, %%edx     \n\t"
//            "movq        x3F, %%mm7     \n\t"
//            "movq        x03, %%mm6     \n\t"
//            "mov         iWidthFrm, %%eax     \n\t"
//            "mov         1, %%edx     \n\t"
            "imul        %%eax, %%edx     \n\t"
            "mov         %5, %%ecx \n\t"
            "mov         %6, %%ebx  \n\t"
//            "mov         iWidthFrm, %%ecx \n\t"
//            "mov         iWidthFrm, %%ebx  \n\t"
//            mov         [esp-4],ebp     \n\t"
            "push        %%ebp  \n\t" // for xbox->fix esp crash because the stack can't be accessed     \n\t"
            "mov         %8, %%ebp  \n\t"
//            "mov         8, %%ebp  \n\t"
            "cmp         $16, %%ebp     \n\t"
            "jz          BilinearLoop2a     \n\t"
"BilinearLoop1a:     \n\t"
            "movq        (%%esi), %%mm0     \n\t"
            "movq        %%mm0,%%mm4     \n\t"
            "pand        %%mm6,%%mm4     \n\t" // here
            "movq        1(%%esi), %%mm1     \n\t"
            "movq        %%mm1,%%mm5     \n\t"
            "pand        %%mm6,%%mm5     \n\t"
            "paddw       %%mm5,%%mm4     \n\t"
            "movq        (%%esi, %%edx, 1), %%mm2     \n\t"
            "movq        %%mm2,%%mm5     \n\t"
            "pand        %%mm6,%%mm5     \n\t"
            "paddw       %%mm5,%%mm4     \n\t"
            "movq        1(%%esi, %%edx,1), %%mm3     \n\t"
            "movq        %%mm3,%%mm5     \n\t"
            "pand        %%mm6,%%mm5     \n\t"
            "paddw       %%mm5,%%mm4     \n\t"
            "paddw       %9, %%mm4 \n\t"
//            "paddw       x02, %%mm4 \n\t"
            "psrlw       $2, %%mm4     \n\t"
            "pand        %%mm6,%%mm4     \n\t"
            "psrlw       $2, %%mm0     \n\t"
            "pand        %%mm7,%%mm0     \n\t"
            "psrlw       $2, %%mm1     \n\t"
            "pand        %%mm7,%%mm1     \n\t"
            "paddw       %%mm1,%%mm0     \n\t"
            "psrlw       $2, %%mm2     \n\t"
            "pand        %%mm7,%%mm2     \n\t"
            "paddw       %%mm2,%%mm0     \n\t"
            "psrlw       $2, %%mm3     \n\t"
            "pand        %%mm7,%%mm3     \n\t"
            "paddw       %%mm3,%%mm0     \n\t"
            "paddw       %%mm4,%%mm0     \n\t"
            "movq        %%mm0, (%%edi)     \n\t"

            "add         %%ecx, %%esi     \n\t"
            "add         %%ebx, %%edi     \n\t"
            "dec          %%ebp     \n\t"
            "jnz         BilinearLoop1a     \n\t"
//            mov         ebp,[esp-4]     \n\t"
            "pop         %%ebp      \n\t"
            "jmp         Enda     \n\t"

"BilinearLoop2a:     \n\t"
            "movq        (%%esi), %%mm0     \n\t"
            "movq        %%mm0,%%mm4     \n\t"
            "pand        %%mm6,%%mm4     \n\t" // here
            "movq        1(%%esi), %%mm1     \n\t"
            "movq        %%mm1,%%mm5     \n\t"
            "pand        %%mm6,%%mm5     \n\t"
            "paddw       %%mm5,%%mm4     \n\t"
            "movq        (%%esi, %%edx, 1), %%mm2     \n\t"
            "movq        %%mm2,%%mm5     \n\t"
            "pand        %%mm6,%%mm5     \n\t"
            "paddw       %%mm5,%%mm4     \n\t"
            "movq        1(%%esi, %%edx, 1), %%mm3     \n\t"
            "movq        %%mm3,%%mm5     \n\t"
            "pand        %%mm6,%%mm5     \n\t"
            "paddw       %%mm5,%%mm4     \n\t"
            "paddw       %9, %%mm4 \n\t"
//            "paddw       x02, %%mm4 \n\t"
            "psrlw       $2, %%mm4     \n\t"
            "pand        %%mm6,%%mm4     \n\t"
            "psrlw       $2, %%mm0     \n\t"
            "pand        %%mm7,%%mm0     \n\t"
            "psrlw       $2, %%mm1     \n\t"
            "pand        %%mm7,%%mm1     \n\t"
            "paddw       %%mm1,%%mm0     \n\t"
            "psrlw       $2, %%mm2     \n\t"
            "pand        %%mm7,%%mm2     \n\t"
            "paddw       %%mm2,%%mm0     \n\t"
            "psrlw       $2, %%mm3     \n\t"
            "pand        %%mm7,%%mm3     \n\t"
            "paddw       %%mm3,%%mm0     \n\t"
            "paddw       %%mm4,%%mm0     \n\t"
            "movq        %%mm0, (%%edi)     \n\t"

            "movq        8(%%esi), %%mm0     \n\t"
            "movq        %%mm0,%%mm4     \n\t"
            "pand        %%mm6,%%mm4     \n\t" // here
            "movq        9(%%esi), %%mm1     \n\t" // esi + 9
            "movq        %%mm1,%%mm5     \n\t"
            "pand        %%mm6,%%mm5     \n\t"
            "paddw       %%mm5,%%mm4     \n\t"
            "movq        8(%%esi, %%edx, 1), %%mm2     \n\t" // esi+ edx +8
            "movq        %%mm2,%%mm5     \n\t"
            "pand        %%mm6,%%mm5     \n\t"
            "paddw       %%mm5,%%mm4     \n\t"
            "movq        9(%%esi, %%edx, 1), %%mm3     \n\t" //esi+edx+9
            "movq        %%mm3,%%mm5     \n\t"
            "pand        %%mm6,%%mm5     \n\t"
            "paddw       %%mm5,%%mm4     \n\t"
            "paddw       %9, %%mm4 \n\t"
//            "paddw       x02, %%mm4 \n\t"
            "psrlw       $2, %%mm4     \n\t"
            "pand        %%mm6,%%mm4     \n\t"
            "psrlw       $2, %%mm0     \n\t"
            "pand        %%mm7,%%mm0     \n\t"
            "psrlw       $2, %%mm1     \n\t"
            "pand        %%mm7,%%mm1     \n\t"
            "paddw       %%mm1,%%mm0     \n\t"
            "psrlw       $2, %%mm2     \n\t"
            "pand        %%mm7,%%mm2     \n\t"
            "paddw       %%mm2,%%mm0     \n\t"
            "psrlw       $2, %%mm3     \n\t"
            "pand        %%mm7,%%mm3     \n\t"
            "paddw       %%mm3,%%mm0     \n\t"
            "paddw       %%mm4,%%mm0     \n\t"
            "movq        %%mm0, 8(%%edi)     \n\t"

            "add         %%ecx, %%esi     \n\t"
            "add         %%ebx, %%edi     \n\t"
            "dec         %%ebp     \n\t"
            "jnz         BilinearLoop2a     \n\t"
//            mov         ebp,[esp-4]     \n\t"
            "pop         %%ebp \n\t" // for x-box
            :
            :   "m"  (ppxlcRefMB),
                "m"  (ppxlcPredMB),     
                "m"   (1),
                "m"  (x3F),
                "m"  (x03),
                "m"  (iWidthFrm),
                "m"  (iWidthFrm),
                "m"  (1),
                "m"  (8),
                "m"  (x02)
            :   "%esi", "%edi", "%edx", "%eax", "%ebx", "%ecx", "%ebp"
            );
        }
    }
    asm volatile
    (
"Enda: \n\t"
        "emms \n\t"
    );
#endif
}

//ppxliErrorQMB is used as a 16bit int
Void_WMV g_MotionCompAndAddErrorRndCtrl_MMX (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* ppxlcCurrQMB,
    const Buffer __huge* ppxliErrorQMB, const U8_WMV* ppxlcRef,
    I32_WMV iWidthFrm, Bool_WMV bXEven, Bool_WMV bYEven, I32_WMV iMixedPelMV	
)
{
#if defined(_WIN32) || defined(_XBOX)
    if (bYEven) {
        if (bXEven) {  //!bXSubPxl && !bYSubPxl
			__asm {
				mov			eax, dword ptr [ppxlcCurrQMB]
				mov			ebx, dword ptr [ppxlcRef]
				mov			ecx, 8
				mov			edx, dword ptr [ppxliErrorQMB]
				mov			edi, dword ptr [iWidthFrm]
				pxor		mm7, mm7

			mainLoop1:
				movq		mm0, [ebx] // pred
				movq		mm1, [edx] // error
				movq		mm2, mm0
				punpcklbw	mm2, mm7
				paddw		mm1, mm2
				packuswb	mm1, mm7
				movd		[eax], mm1 // curr

				movq		mm1, [edx + 8]
				punpckhbw	mm0, mm7
				paddw		mm1, mm0
				packuswb	mm1, mm7
				movd		[eax + 4], mm1

				add			ebx, edi
				add			eax, edi
				add			edx, 16

				dec			ecx
				jne			mainLoop1
                emms;

			}
        }
        else {  //bXSubPxl && !bYSubPxl
			//static const __int64	x0101010101010101 = 0x0001000100010001;
			__asm {
				mov		eax, dword ptr [ppxlcCurrQMB]
				mov     ebx, dword ptr [ppxlcRef]
				mov     ecx, 8
				mov     edx, dword ptr [ppxliErrorQMB]
				mov		edi, dword ptr [iWidthFrm]
				//movq	mm6, x0101010101010101
				pxor	mm7, mm7

			mainLoop2:
				movq		mm0, [ebx] // pred
				movq		mm1, [ebx + 1] // pred + 1
				movq		mm2, mm0
				movq		mm3, mm1
				punpcklbw	mm2, mm7
				punpcklbw	mm3, mm7
				paddw		mm2, mm3
				//paddw		mm2, mm6
				psrlw		mm2, 1

				movq		mm3, [edx] // error
				paddw		mm2, mm3
				packuswb	mm2, mm7
				movd		[eax], mm2 // curr


				punpckhbw	mm0, mm7
				punpckhbw	mm1, mm7
				paddw		mm0, mm1
				//paddw		mm0, mm6
				psrlw		mm0, 1

				movq		mm1, [edx + 8] // error
				paddw		mm0, mm1
				packuswb	mm0, mm7
				movd		[eax + 4], mm0 // curr

				add			ebx, edi
				add			eax, edi
				add			edx, 16

				dec			ecx
				jne			mainLoop2
                emms;

			}
        }
    }
    else {
        if (bXEven) {  //!bXSubPxl&& bYSubPxl
			//static const __int64	x0001000100010001 = 0x0001000100010001;
			__asm {
				mov		eax, dword ptr [ppxlcCurrQMB]
				mov     ebx, dword ptr [ppxlcRef]
				mov     ecx, 8
				mov     edx, dword ptr [ppxliErrorQMB]
				mov		edi, dword ptr [iWidthFrm]
				//movq	mm6, x0001000100010001
				pxor	mm7, mm7

			mainLoop3:
				movq		mm0, [ebx] // pred
				movq		mm1, [ebx + edi] // pred + 1
				movq		mm2, mm0
				movq		mm3, mm1
				punpcklbw	mm2, mm7
				punpcklbw	mm3, mm7
				paddw		mm2, mm3
				//paddw		mm2, mm6
				psrlw		mm2, 1

				movq		mm3, [edx] // error
				paddw		mm2, mm3
				packuswb	mm2, mm7
				movd		[eax], mm2 // curr


				punpckhbw	mm0, mm7
				punpckhbw	mm1, mm7
				paddw		mm0, mm1
				//paddw		mm0, mm6
				psrlw		mm0, 1

				movq		mm1, [edx + 8] // error
				paddw		mm0, mm1
				packuswb	mm0, mm7
				movd		[eax + 4], mm0 // curr

				add			ebx, edi
				add			eax, edi
				add			edx, 16

				dec			ecx
				jne			mainLoop3
                emms;

			}
        }
        else { // bXSubPxl && bYSubPxl
			static const __int64	x0001000100010001 = 0x0001000100010001;
			__asm {
				mov			eax, dword ptr [ppxlcCurrQMB]
				mov			ebx, dword ptr [ppxlcRef]
				mov			ecx, 8
				mov			edx, dword ptr [ppxliErrorQMB]
				mov			edi, dword ptr [iWidthFrm]
				pxor		mm7, mm7

			mainLoop4:
				movq		mm0, [ebx] // pred
				movq		mm1, [ebx + 1] // pred + 1
				movq		mm2, [ebx + edi] // pred
				movq		mm3, [ebx + edi + 1] // pred + 1

				movq		mm4, mm0
				movq		mm5, mm1
				movq		mm6, mm2
				punpcklbw	mm4, mm7
				punpcklbw	mm5, mm7
				punpcklbw	mm6, mm7
				paddw		mm4, mm5
				paddw		mm4, mm6
				movq		mm5, mm3
				punpcklbw	mm5, mm7
				paddw		mm4, mm5
				paddw		mm4, x0001000100010001
				psrlw		mm4, 2

				movq		mm6, [edx] // error
				pxor		mm7, mm7

				paddw		mm4, mm6
				packuswb	mm4, mm7
				movd		[eax], mm4 // curr


				punpckhbw	mm0, mm7
				punpckhbw	mm1, mm7
				punpckhbw	mm2, mm7
				punpckhbw	mm3, mm7
				paddw		mm0, mm1
				paddw		mm0, mm2
				paddw		mm0, mm3
				paddw		mm0, x0001000100010001
				psrlw		mm0, 2

				movq		mm1, [edx + 8] // error
				pxor		mm7, mm7
				paddw		mm0, mm1
				packuswb	mm0, mm7
				movd		[eax + 4], mm0 // curr

				add			ebx, edi
				add			eax, edi
				add			edx, 16

				dec			ecx
				jne			mainLoop4
                emms;
			}
        }
    }
#else // _Embedded_x86
    if (bYEven) {
        if (bXEven) {  //!bXSubPxl && !bYSubPxl
            asm volatile
            (
                "mov %0, %%eax    \n\t"
                "mov %1, %%ebx    \n\t"
                "mov %2, %%edx    \n\t"
                "mov %3, %%edi    \n\t"
                "mov            $8, %%ecx    \n\t"
                "pxor       %%mm7, %%mm7      \n\t"
            "mainLoop1:                       \n\t"
                "movq       (%%ebx), %%mm0          \n\t" // pred
                "movq       (%%edx), %%mm1          \n\t" // error
                "movq       %%mm0, %%mm2         \n\t"
                "punpcklbw  %%mm7, %%mm2         \n\t"
                "paddw      %%mm2, %%mm1         \n\t"
                "packuswb   %%mm7, %%mm1         \n\t"
                "movd       %%mm1, (%%eax)        \n\t" // curr

                "movq       8(%%edx), %%mm1 \n\t"
                "punpckhbw  %%mm7, %%mm0         \n\t"
                "paddw      %%mm0, %%mm1         \n\t"
                "packuswb   %%mm7, %%mm1         \n\t"

                "movd       %%mm1, 4(%%eax)         \n\t"

                "add            %%edi, %%ebx         \n\t"
                "add            %%edi, %%eax         \n\t"
                "add            $16, %%edx         \n\t"

                "dec            %%ecx         \n\t"
                "jne            mainLoop1         \n\t"
                "emms   \n\t"
                :
                :   "m"  (ppxlcCurrQMB),
                    "m"     (ppxlcRef),
                    "m"   (ppxliErrorQMB),
                    "m"   (iWidthFrm)
                :    "%eax", "%ebx", "%edx", "%edi", "%ecx", "%esi", "%ebp"
            );
        }
        else {  //bXSubPxl && !bYSubPxl
            static const __int64    x0101010101010101 = 0x0001000100010001;
//          asm volatile ("\n\t movq    %0, %%mm6 \n ": : "m" (x0101010101010101));
            asm volatile
            (
                "mov  %0, %%eax              \n\t"
                "mov  %1, %%ebx              \n\t"
                "mov  %2, %%edx              \n\t"
                "mov  %3, %%edi              \n\t"
//                "movq  %4, %%mm6              \n\t"
                "mov    $8, %%ecx             \n\t"
//              "movq   $0x0001000100010001, %%mm6 \n\t"
                "pxor   %%mm7, %%mm7            \n\t"

           "mainLoop2a:            \n\t"
                "movq       (%%ebx), %%mm0             \n\t" // pred
                "movq       1(%%ebx), %%mm1         \n\t" // pred + 1
                "movq       %%mm0, %%mm2            \n\t"
                "movq       %%mm1, %%mm3            \n\t"
                "punpcklbw  %%mm7, %%mm2            \n\t"
                "punpcklbw  %%mm7, %%mm3            \n\t"
                "paddw      %%mm3, %%mm2            \n\t"
//                "paddw      %%mm6, %%mm2            \n\t"
                "psrlw      $1, %%mm2            \n\t"

                "movq       (%%edx), %%mm3    \n\t" // error
                "paddw      %%mm3, %%mm2            \n\t"
                "packuswb   %%mm7, %%mm2            \n\t"
                "movd       %%mm2, (%%eax)  \n\t" // curr

                "punpckhbw  %%mm7, %%mm0            \n\t"
                "punpckhbw  %%mm7, %%mm1            \n\t"
                "paddw      %%mm1, %%mm0            \n\t"
//                "paddw      %%mm6, %%mm0            \n\t"
                "psrlw      $1, %%mm0            \n\t"

                "movq       8(%%edx),  %%mm1            \n\t" // error
                "paddw      %%mm1, %%mm0            \n\t"
                "packuswb   %%mm7, %%mm0            \n\t"
                "movd       %%mm0, 4(%%eax)  \n\t" // curr

                "add            %%edi, %%ebx             \n\t"
                "add            %%edi, %%eax           \n\t"
                "add            $16, %%edx            \n\t"

                "dec            %%ecx            \n\t"
                "jne            mainLoop2a       \n\t"
                "emms   \n\t"
                :
                :    "m" (ppxlcCurrQMB),
                     "m" (ppxlcRef),
                     "m" (ppxliErrorQMB),
                     "m" (iWidthFrm),
                     "m" (x0101010101010101)
                :    "%eax", "%ebx", "%edx", "%edi", "%ecx", "%esi", "%ebp"
            );
        }
    }
    else {
        if (bXEven) {  //!bXSubPxl&& bYSubPxl
            static const __int64    x0001000100010001 = 0x0001000100010001;
//          asm volatile ("\n\t movq    %0, %%mm6 \n ": : "m" (x0001000100010001));
            asm volatile
            (
                "mov    $8, %%ecx            \n\t"
                "movq   %4, %%mm6            \n\t"
                "pxor   %%mm7, %%mm7   \n\t"

            "mainLoop3a:                            \n\t"
                "movq       (%%ebx), %%mm0          \n\t" // pred
                "movq       (%%ebx, %%edi,1), %%mm1          \n\t" // pred + 1
                "movq       %%mm0, %%mm2          \n\t"
                "movq       %%mm1, %%mm3          \n\t"
                "punpcklbw  %%mm7, %%mm2          \n\t"
                "punpcklbw  %%mm7, %%mm3          \n\t"
                "paddw      %%mm3, %%mm2          \n\t"
//                "paddw      %%mm6, %%mm2          \n\t"
                "psrlw      $1, %%mm2          \n\t"

                "movq       (%%edx), %%mm3          \n\t" // error
                "paddw      %%mm3, %%mm2          \n\t"
                "packuswb   %%mm7, %%mm2          \n\t"
                "movd       %%mm2, (%%eax)          \n\t" // curr


                "punpckhbw  %%mm7, %%mm0          \n\t"
                "punpckhbw  %%mm7, %%mm1          \n\t"
                "paddw      %%mm1, %%mm0          \n\t"
//                "paddw      %%mm6, %%mm0          \n\t"
                "psrlw      $1, %%mm0          \n\t"

                "movq       8(%%edx), %%mm1          \n\t" // error
                "paddw      %%mm1, %%mm0          \n\t"
                "packuswb   %%mm7, %%mm0          \n\t"
                "movd       %%mm0, 4(%%eax)           \n\t"// curr

                "add        %%edi, %%ebx          \n\t"
                "add        %%edi, %%eax          \n\t"
                "add        $16, %%edx          \n\t"

                "dec            %%ecx          \n\t"
                "jne            mainLoop3a          \n\t"
                "emms   \n\t"
                :
                :   "a" (ppxlcCurrQMB),
                    "b"   (ppxlcRef),
                    "d" (ppxliErrorQMB),
                    "D" (iWidthFrm),
                    "m" (x0001000100010001)
                :    "%eax", "%ebx", "%edx", "%edi", "%ecx", "%esi", "%ebp"
            );
        }
        else { // bXSubPxl && bYSubPxl
            static const __int64    x0001000100010001 = 0x0001000100010001;
            asm volatile
            (
                "mov        %0, %%eax \n\t"
                "mov        %1, %%ebx \n\t"
                "mov        %2, %%edx \n\t"
                "mov        %3, %%edi \n\t"
                "mov        $1, %%esi              \n\t"
                "mov        $8, %%ecx              \n\t"
                "pxor       %%mm7, %%mm7              \n\t"

            "mainLoop4a:              \n\t"
                "movq       (%%ebx), %%mm0               \n\t" // pred
                "movq       1(%%ebx), %%mm1              \n\t" // pred + 1
                "movq       (%%ebx, %%edi,1), %%mm2              \n\t" // pred
              "movq         1(%%ebx, %%edi, 1), %%mm3              \n\t" // pred + 1
                "movq       %%mm0, %%mm4              \n\t"
                "movq       %%mm1, %%mm5              \n\t"
                "movq       %%mm2, %%mm6              \n\t"
                "punpcklbw  %%mm7, %%mm4              \n\t"
                "punpcklbw  %%mm7, %%mm5              \n\t"
                "punpcklbw  %%mm7, %%mm6              \n\t"
                "paddw      %%mm5, %%mm4              \n\t"
                "paddw      %%mm6, %%mm4              \n\t"
                "movq       %%mm3, %%mm5              \n\t"
                "punpcklbw  %%mm7, %%mm5              \n\t"
                "paddw      %%mm5, %%mm4              \n\t"
                "paddw      %4, %%mm4              \n\t"
//              "paddw      x0001000100010001, %%mm4              \n\t"
                "psrlw      $2, %%mm4              \n\t"

                "movq       (%%edx), %%mm6              \n\t" // error
                "pxor       %%mm7, %%mm7              \n\t"

                "paddw      %%mm6, %%mm4              \n\t"
                "packuswb   %%mm7, %%mm4              \n\t"
                "movd       %%mm4, (%%eax)               \n\t"// curr


                "punpckhbw  %%mm7, %%mm0              \n\t"
                "punpckhbw  %%mm7, %%mm1              \n\t"
                "punpckhbw  %%mm7, %%mm2              \n\t"
                "punpckhbw  %%mm7, %%mm3              \n\t"
                "paddw      %%mm1, %%mm0              \n\t"
                "paddw      %%mm2, %%mm0              \n\t"
                "paddw      %%mm3, %%mm0              \n\t"
                "paddw      %4, %%mm0              \n\t"
//              "paddw      x0001000100010001, %%mm0              \n\t"
                "psrlw      $2, %%mm0              \n\t"

                "movq       8(%%edx), %%mm1              \n\t" // error
                "pxor       %%mm7, %%mm7              \n\t"
                "paddw      %%mm1, %%mm0              \n\t"
                "packuswb   %%mm7, %%mm0              \n\t"
                "movd       %%mm0, 4(%%eax)               \n\t"// curr

                "add        %%edi, %%ebx              \n\t"
                "add        %%edi, %%eax              \n\t"
                "add        $16, %%edx              \n\t"

                "dec            %%ecx              \n\t"
                "jne            mainLoop4a       \n\t"
                "emms   \n\t"
                :
                :   "m" (ppxlcCurrQMB),
                    "m" (ppxlcRef),
                    "m" (ppxliErrorQMB),
                    "m" (iWidthFrm),
                    "m" (x0001000100010001)
//                :    "%eax", "%ebx", "%edx", "%edi"
                :    "%eax", "%ebx", "%edx", "%edi", "%ecx", "%esi", "%ebp"
            );
        }
    }
#endif
}

Void_WMV g_MotionCompRndCtrl_MMX(
    tWMVDecInternalMember *pWMVDec,
	U8_WMV*             ppxlcPredMB,
	const U8_WMV*       ppxlcRefMB,
    I32_WMV             iWidthFrm,
    Bool_WMV            bInterpolateX,
    Bool_WMV            bInterpolateY,
    I32_WMV             iMixedPelMV	
)
{
  	static const Int64 x01 = (Int64)0x0101010101010101;
    static const Int64 x7f = (Int64)0x7f7f7f7f7f7f7f7f;
    static const Int64 x3F = (Int64)0x3F3F3F3F3F3F3F3F;
    static const Int64 x03 = (Int64)0x0303030303030303;
    //static const Int64 x02 = (Int64)0x0202020202020202;

#if defined(_WIN32) || defined(_XBOX)
     if (bInterpolateY) {
        if (bInterpolateX) {  //!bXSubPxl && !bYSubPxl
            _asm {
            mov         esi,ppxlcRefMB
            mov         edi,ppxlcPredMB
            mov         eax,iWidthFrm
            mov         ebx,iWidthFrm
            mov         ecx,8
            cmp         ecx,16
            jz          CopyLoop2
CopyLoop1:
            movq        mm0,[esi]
            add         esi,eax
            movq        [edi],mm0
            add         edi,ebx
            dec         ecx
            jnz         CopyLoop1
            jmp         End
CopyLoop2:
            movq        mm0,[esi]
            movq        [edi],mm0
            movq        mm0,[esi+8]
            add         esi,eax
            movq        [edi+8],mm0
            add         edi,ebx
            dec         ecx
            jnz         CopyLoop2
            }
        }
        else {  //bXSubPxl && !bYSubPxl
            _asm {
            mov         esi,ppxlcRefMB
            mov         edi,ppxlcPredMB
            mov         edx,1
            mov         eax,iWidthFrm
            mov         ebx,iWidthFrm
            movq        mm7,x7f
            movq        mm6,x01
            mov         ecx,8
            cmp         ecx,16
            jz          HorizantalLoop2
HorizantalLoop1:
            movq        mm0,[esi]
            movq        mm1,[esi+edx]

            //avg mm0,mm1
            movq        mm5,mm0
            //por         mm5,mm1
            pand        mm5,mm1
            psrlw       mm0,1
            psrlw       mm1,1
            pand        mm5,mm6
            pand        mm0,mm7
            pand        mm1,mm7
            paddw       mm0,mm5
            paddw       mm0,mm1

            movq        [edi],mm0
            add         esi,eax
            add         edi,ebx
            dec         ecx
            jnz         HorizantalLoop1
            jmp         End

HorizantalLoop2:
            movq        mm0,[esi]
            movq        mm1,[esi+edx]

            //avg mm0,mm1
            movq        mm5,mm0
            //por         mm5,mm1
            pand        mm5,mm1
            psrlw       mm0,1
            psrlw       mm1,1
            pand        mm5,mm6
            pand        mm0,mm7
            pand        mm1,mm7
            paddw       mm0,mm5
            paddw       mm0,mm1

            movq        [edi],mm0

            movq        mm0,[esi+8]
            movq        mm1,[esi+edx+8]

            //avg mm0,mm1
            movq        mm5,mm0
            //por         mm5,mm1
            pand        mm5,mm1
            psrlw       mm0,1
            psrlw       mm1,1
            pand        mm5,mm6
            pand        mm0,mm7
            pand        mm1,mm7
            paddw       mm0,mm5
            paddw       mm0,mm1

            movq        [edi+8],mm0

            add         esi,eax
            add         edi,ebx
            dec         ecx
            jnz         HorizantalLoop2
	        }
        }
    }
    else {
        if (bInterpolateX) {  //!bXSubPxl&& bYSubPxl
            _asm {
            mov         esi,ppxlcRefMB
            mov         edi,ppxlcPredMB
            mov         eax,iWidthFrm
            mov         edx,1
            imul        edx,eax
            mov         eax,iWidthFrm
            mov         ebx,iWidthFrm
            movq        mm7,x7f
            movq        mm6,x01
            mov         ecx,8
            cmp         ecx,16
            jz          VerticalLoop2
VerticalLoop1:
            movq        mm0,[esi]
            movq        mm1,[esi+edx]

            //avg mm0,mm1
            movq        mm5,mm0
            //por         mm5,mm1
            pand        mm5,mm1
            psrlw       mm0,1
            psrlw       mm1,1
            pand        mm5,mm6
            pand        mm0,mm7
            pand        mm1,mm7
            paddw       mm0,mm5
            paddw       mm0,mm1

            movq        [edi],mm0
            add         esi,eax
            add         edi,ebx
            dec         ecx
            jnz         VerticalLoop1
            jmp         End

VerticalLoop2:
            movq        mm0,[esi]
            movq        mm1,[esi+edx]

            //avg mm0,mm1
            movq        mm5,mm0
            //por         mm5,mm1
            pand        mm5,mm1
            psrlw       mm0,1
            psrlw       mm1,1
            pand        mm5,mm6
            pand        mm0,mm7
            pand        mm1,mm7
            paddw       mm0,mm5
            paddw       mm0,mm1

            movq        [edi],mm0

            movq        mm0,[esi+8]
            movq        mm1,[esi+edx+8]

            //avg mm0,mm1
            movq        mm5,mm0
            //por         mm5,mm1
            pand        mm5,mm1
            psrlw       mm0,1
            psrlw       mm1,1
            pand        mm5,mm6
            pand        mm0,mm7
            pand        mm1,mm7
            paddw       mm0,mm5
            paddw       mm0,mm1

            movq        [edi+8],mm0

            add         esi,eax
            add         edi,ebx
            dec         ecx
            jnz         VerticalLoop2
	        }
        }
        else { // bXSubPxl && bYSubPxl
            _asm {            
            mov         esi,ppxlcRefMB
            mov         edi,ppxlcPredMB

            mov         eax,1
            cmp         eax,-1
            jnz         PositiveXMV
            dec         esi
PositiveXMV:
            movq        mm7,x3F
            movq        mm6,x03
            mov         eax,iWidthFrm
            mov         edx,1
            imul        edx,eax
            mov         ecx,iWidthFrm
            mov         ebx,iWidthFrm
            //mov         [esp-4],ebp
            push        ebp // for x-box
            mov         ebp,8
            cmp         ebp,16
            jz          BilinearLoop2
BilinearLoop1:
            movq        mm0,[esi]
            movq        mm4,mm0
            pand        mm4,mm6
            movq        mm1,[esi+1]
            movq        mm5,mm1
            pand        mm5,mm6
            paddw       mm4,mm5
            movq        mm2,[esi+edx]
            movq        mm5,mm2
            pand        mm5,mm6
            paddw       mm4,mm5
            movq        mm3,[esi+edx+1]
            movq        mm5,mm3
            pand        mm5,mm6
            paddw       mm4,mm5
            paddw       mm4,x01
            psrlw       mm4,2
            pand        mm4,mm6
            psrlw       mm0,2
            pand        mm0,mm7
            psrlw       mm1,2
            pand        mm1,mm7
            paddw       mm0,mm1
            psrlw       mm2,2
            pand        mm2,mm7
            paddw       mm0,mm2
            psrlw       mm3,2
            pand        mm3,mm7
            paddw       mm0,mm3
            paddw       mm0,mm4
            movq        [edi],mm0

            add         esi,ecx
            add         edi,ebx
            dec         ebp
            jnz         BilinearLoop1
            //mov         ebp,[esp-4]
            pop         ebp
            jmp         End

BilinearLoop2:
            movq        mm0,[esi]
            movq        mm4,mm0
            pand        mm4,mm6
            movq        mm1,[esi+1]
            movq        mm5,mm1
            pand        mm5,mm6
            paddw       mm4,mm5
            movq        mm2,[esi+edx]
            movq        mm5,mm2
            pand        mm5,mm6
            paddw       mm4,mm5
            movq        mm3,[esi+edx+1]
            movq        mm5,mm3
            pand        mm5,mm6
            paddw       mm4,mm5
            paddw       mm4,x01
            psrlw       mm4,2
            pand        mm4,mm6
            psrlw       mm0,2
            pand        mm0,mm7
            psrlw       mm1,2
            pand        mm1,mm7
            paddw       mm0,mm1
            psrlw       mm2,2
            pand        mm2,mm7
            paddw       mm0,mm2
            psrlw       mm3,2
            pand        mm3,mm7
            paddw       mm0,mm3
            paddw       mm0,mm4
            movq        [edi],mm0

            movq        mm0,[esi+8]
            movq        mm4,mm0
            pand        mm4,mm6
            movq        mm1,[esi+9]
            movq        mm5,mm1
            pand        mm5,mm6
            paddw       mm4,mm5
            movq        mm2,[esi+edx+8]
            movq        mm5,mm2
            pand        mm5,mm6
            paddw       mm4,mm5
            movq        mm3,[esi+edx+9]
            movq        mm5,mm3
            pand        mm5,mm6
            paddw       mm4,mm5
            paddw       mm4,x01
            psrlw       mm4,2
            pand        mm4,mm6
            psrlw       mm0,2
            pand        mm0,mm7
            psrlw       mm1,2
            pand        mm1,mm7
            paddw       mm0,mm1
            psrlw       mm2,2
            pand        mm2,mm7
            paddw       mm0,mm2
            psrlw       mm3,2
            pand        mm3,mm7
            paddw       mm0,mm3
            paddw       mm0,mm4
            movq        [edi+8],mm0

            add         esi,ecx
            add         edi,ebx
            dec         ebp
            jnz         BilinearLoop2
            //mov         ebp,[esp-4]
            pop         ebp // for x-box
            }
        }
    }
End: _asm emms;
#else // _Embedded_x86
     if (bInterpolateY) {
        if (bInterpolateX) {  //!bXSubPxl && !bYSubPxl
            asm volatile
            (
            "cmp         $16, %%ecx \n\t"
            "jz          CopyLoop2  \n\t"

"CopyLoop1:             \n\t"
            "movq        (%%esi), %%mm0     \n\t"
            "add         %%eax, %%esi     \n\t"
            "movq        %%mm0, (%%edi)     \n\t"
            "add         %%ebx,%%edi     \n\t"
            "dec         %%ecx     \n\t"
            "jnz         CopyLoop1     \n\t"
            "jmp         Endb     \n\t"

"CopyLoop2:     \n\t"
            "movq        (%%esi), %%mm0     \n\t"
            "movq        %%mm0, (%%edi)     \n\t"
            "movq        8(%%esi), %%mm0     \n\t"
            "add         %%eax,%%esi     \n\t"
            "movq        %%mm0, 8(%%edi)     \n\t"
            "add         %%ebx, %%edi     \n\t"
            "dec         %%ecx     \n\t"
            "jnz         CopyLoop2     \n\t"
             :
             : "S"  (ppxlcRefMB),
               "D"  (ppxlcPredMB),
               "a"  (iWidthFrm),
               "b" (iWidthFrm),
               "c" (8)
             : "%esi", "%edi", "%eax", "%ebx", "%ecx", "%edx", "%ebp"
            );
        } 
        else {  //bXSubPxl && !bYSubPxl
            asm volatile
            (
             "mov %0, %%esi         \n\t"
             "mov %1, %%edi         \n\t"
             "mov %2, %%edx         \n\t"
             "mov %3, %%eax         \n\t"
             "mov %4, %%ebx         \n\t"
             "mov %5, %%ecx         \n\t"
//            "mov         $1, %%ebp   \n\t" // IW
            "movq        %6, %%mm7     \n\t"
//            "movq        x7f, %%mm7     \n\t"
            "movq        %7, %%mm6     \n\t"
//            "movq        x01, %%mm6     \n\t"
            "cmp         $16, %%ecx     \n\t"
            "jz          HorizantalLoop2     \n\t"
" HorizantalLoop1:     \n\t"
            "movq        (%%esi), %%mm0     \n\t"
            "movq        (%%esi, %%edx, 1), %%mm1     \n\t"

            //avg %%mm0,%%mm1     \n\t"
            "movq        %%mm0,%%mm5     \n\t"
//            "por         %%mm1,%%mm5     \n\t"
            "pand         %%mm1,%%mm5     \n\t"
            "psrlw       $1, %%mm0     \n\t"
            "psrlw       $1, %%mm1     \n\t"
            "pand        %%mm6,%%mm5     \n\t"
            "pand        %%mm7,%%mm0     \n\t"
            "pand        %%mm7,%%mm1     \n\t"
            "paddw       %%mm5,%%mm0     \n\t"
            "paddw       %%mm1,%%mm0     \n\t"

            "movq        %%mm0, (%%edi)     \n\t"
            "add         %%eax, %%esi     \n\t"
            "add         %%ebx, %%edi     \n\t"
            "dec         %%ecx     \n\t"
            "jnz         HorizantalLoop1     \n\t"
            "jmp         Endb     \n\t"

"HorizantalLoop2:     \n\t"
            "movq        (%%esi), %%mm0     \n\t"
            "movq        (%%esi, %%edx, 1), %%mm1     \n\t"

            //avg %%mm0,%%mm1     \n\t"
            "movq        %%mm0,%%mm5     \n\t"
//            "por         %%mm1,%%mm5     \n\t"
            "pand         %%mm1,%%mm5     \n\t"
            "psrlw       $1, %%mm0     \n\t"
            "psrlw       $1, %%mm1     \n\t"
            "pand        %%mm6,%%mm5     \n\t"
            "pand        %%mm7,%%mm0     \n\t"
            "pand        %%mm7,%%mm1     \n\t"
            "paddw       %%mm5,%%mm0     \n\t"
            "paddw       %%mm1,%%mm0     \n\t"

            "movq        %%mm0, (%%edi)     \n\t"
    
            "movq        8(%%esi), %%mm0     \n\t"
            "movq        8(%%esi, %%edx, 1), %%mm1     \n\t"

            //avg %%mm0,%%mm1      // Here , IW
            "movq        %%mm0,%%mm5     \n\t"
//            "por         %%mm1,%%mm5     \n\t"
            "pand         %%mm1,%%mm5     \n\t"
            "psrlw       $1, %%mm0     \n\t"
            "psrlw       $1, %%mm1     \n\t"
            "pand        %%mm6,%%mm5     \n\t"
            "pand        %%mm7,%%mm0     \n\t"
            "pand        %%mm7,%%mm1     \n\t"
            "paddw       %%mm5,%%mm0     \n\t"
            "paddw       %%mm1,%%mm0     \n\t"

            "movq        %%mm0, 8(%%edi)     \n\t"

            "add         %%eax, %%esi     \n\t"
            "add         %%ebx, %%edi     \n\t"
            "dec         %%ecx     \n\t"
            "jnz         HorizantalLoop2     \n\t"
            :
            :   "m"  (ppxlcRefMB),
                "m"  (ppxlcPredMB),
                "m"  (1),
                "m"  (iWidthFrm),
                "m"   (iWidthFrm),
                "m"  (8),
                "m"  (x7f),
                "m"  (x01)
            :  "%esi", "%edi", "%edx", "%eax", "%ebx", "%ecx", "%ebp"
            );
        }
    }
    else {
        if (bInterpolateX) {  //!bXSubPxl&& bYSubPxl
            asm volatile
            (
            "mov %0, %%esi  \n\t"
            "mov %1, %%edi  \n\t"
            "mov %2, %%edx  \n\t"
            "mov %3, %%eax  \n\t"
            "mov %4, %%ebx  \n\t"
            "mov %5, %%ecx  \n\t"
//            "mov         $1, %%ebp     \n\t"
            "imul        %%eax, %%edx     \n\t"
            "mov         %3, %%eax     \n\t"
            "movq        %6, %%mm7     \n\t"
//            "movq        x7f, %%mm7     \n\t"
            "movq        %7, %%mm6     \n\t"
//            "movq        x01, %%mm6     \n\t"
            "cmp         $16, %%ecx     \n\t"
            "jz          VerticalLoop2     \n\t"
"VerticalLoop1:     \n\t"
            "movq        (%%esi), %%mm0     \n\t"
            "movq        (%%esi, %%edx, 1), %%mm1     \n\t"  // esi + edi

            //avg %%mm0,%%mm1
            "movq        %%mm0,%%mm5     \n\t"
//            "por         %%mm1,%%mm5     \n\t"
            "pand         %%mm1,%%mm5     \n\t"
            "psrlw       $1, %%mm0     \n\t"
            "psrlw       $1, %%mm1     \n\t"
            "pand        %%mm6,%%mm5     \n\t"
            "pand        %%mm7,%%mm0     \n\t"
            "pand        %%mm7,%%mm1     \n\t"
            "paddw       %%mm5,%%mm0     \n\t"
            "paddw       %%mm1,%%mm0     \n\t"

            "movq        %%mm0, (%%edi)     \n\t"
            "add         %%eax, %%esi     \n\t"
            "add         %%ebx, %%edi     \n\t"
            "dec         %%ecx     \n\t"
            "jnz         VerticalLoop1     \n\t"
            "jmp         Endb     \n\t"
    
"VerticalLoop2:     \n\t"
            "movq        (%%esi), %%mm0     \n\t"
            "movq        (%%esi, %%edx, 1), %%mm1     \n\t"  // esi + edi

            //avg %%mm0,%%mm1
            "movq        %%mm0,%%mm5     \n\t"
//            "por         %%mm1,%%mm5     \n\t"
            "pand         %%mm1,%%mm5     \n\t"
            "psrlw       $1, %%mm0     \n\t"
            "psrlw       $1, %%mm1     \n\t"
            "pand        %%mm6,%%mm5     \n\t"
            "pand        %%mm7,%%mm0     \n\t"
            "pand        %%mm7,%%mm1     \n\t"
            "paddw       %%mm5,%%mm0     \n\t"
            "paddw       %%mm1,%%mm0     \n\t"

            "movq        %%mm0, (%%edi)     \n\t"

            "movq        8(%%esi), %%mm0     \n\t"
            "movq        8(%%esi, %%edx,1), %%mm1     \n\t"

            //avg %%mm0,%%mm1
            "movq        %%mm0,%%mm5     \n\t"
//            "por         %%mm1,%%mm5     \n\t"
            "pand         %%mm1,%%mm5     \n\t"
            "psrlw       $1, %%mm0     \n\t"
            "psrlw       $1, %%mm1     \n\t"
            "pand        %%mm6,%%mm5     \n\t"
            "pand        %%mm7,%%mm0     \n\t"
            "pand        %%mm7,%%mm1     \n\t"
            "paddw       %%mm5,%%mm0     \n\t"
            "paddw       %%mm1,%%mm0     \n\t"

            "movq        %%mm0, 8(%%edi)     \n\t"

            "add         %%eax, %%esi     \n\t"
            "add         %%ebx, %%edi     \n\t"
            "dec         %%ecx     \n\t"
            "jnz         VerticalLoop2     \n\t"
            :
            :   "m"  (ppxlcRefMB),
                "m"  (ppxlcPredMB),
                "m"   (1),
                "m"   (iWidthFrm),
                "m"   (iWidthFrm),
                "m"   (8),
                "m"   (x7f),
                "m"   (x01)
            :   "%esi", "%edi", "%edx", "%eax", "%ebx", "%ecx", "%ebp"
            );
        }   
        else { // bXSubPxl && bYSubPxl

//            asm volatile ("mov  %0, %%esi : :  "m" (ppxlcRefMB));
            asm volatile
            (
            "mov  %0, %%esi  \n\t"
            "mov  %1, %%edi  \n\t"
            "mov  %2, %%eax  \n\t"
            "cmp         $-1, %%eax     \n\t"
            "jnz         PositiveXMVa     \n\t"
            "dec         %%esi     \n\t"
"PositiveXMVa:     \n\t"
            "movq        %3, %%mm7     \n\t"
            "movq        %4, %%mm6     \n\t"
            "mov         %5, %%eax     \n\t"
            "mov         %7, %%edx     \n\t"
//            "movq        x3F, %%mm7     \n\t"
//            "movq        x03, %%mm6     \n\t"
//            "mov         iWidthFrm, %%eax     \n\t"
//            "mov         1, %%edx     \n\t"
            "imul        %%eax, %%edx     \n\t"
            "mov         %5, %%ecx \n\t"
            "mov         %6, %%ebx  \n\t"
//            "mov         iWidthFrm, %%ecx \n\t"
//            "mov         iWidthFrm, %%ebx  \n\t"
//            mov         [esp-4],ebp     \n\t"
            "push        %%ebp  \n\t" // for xbox->fix esp crash because the stack can't be accessed     \n\t"
            "mov         %8, %%ebp  \n\t"
//            "mov         8, %%ebp  \n\t"
            "cmp         $16, %%ebp     \n\t"
            "jz          BilinearLoop2     \n\t"
"BilinearLoop1:     \n\t"
            "movq        (%%esi), %%mm0     \n\t"
            "movq        %%mm0,%%mm4     \n\t"
            "pand        %%mm6,%%mm4     \n\t" // here
            "movq        1(%%esi), %%mm1     \n\t"
            "movq        %%mm1,%%mm5     \n\t"
            "pand        %%mm6,%%mm5     \n\t"
            "paddw       %%mm5,%%mm4     \n\t"
            "movq        (%%esi, %%edx, 1), %%mm2     \n\t"
            "movq        %%mm2,%%mm5     \n\t"
            "pand        %%mm6,%%mm5     \n\t"
            "paddw       %%mm5,%%mm4     \n\t"
            "mov         %%edx, %%eax    \n\t"
            "movq        1(%%esi, %%edx,1), %%mm3     \n\t"
            "movq        %%mm3,%%mm5     \n\t"
            "pand        %%mm6,%%mm5     \n\t"
            "paddw       %%mm5,%%mm4     \n\t"
            "paddw       %9, %%mm4 \n\t"
//            "paddw       x02, %%mm4 \n\t"
            "psrlw       $2, %%mm4     \n\t"
            "pand        %%mm6,%%mm4     \n\t"
            "psrlw       $2, %%mm0     \n\t"
            "pand        %%mm7,%%mm0     \n\t"
            "psrlw       $2, %%mm1     \n\t"
            "pand        %%mm7,%%mm1     \n\t"
            "paddw       %%mm1,%%mm0     \n\t"
            "psrlw       $2, %%mm2     \n\t"
            "pand        %%mm7,%%mm2     \n\t"
            "paddw       %%mm2,%%mm0     \n\t"
            "psrlw       $2, %%mm3     \n\t"
            "pand        %%mm7,%%mm3     \n\t"
            "paddw       %%mm3,%%mm0     \n\t"
            "paddw       %%mm4,%%mm0     \n\t"
            "movq        %%mm0, (%%edi)     \n\t"

            "add         %%ecx, %%esi     \n\t"
            "add         %%ebx, %%edi     \n\t"
            "dec          %%ebp     \n\t"
            "jnz         BilinearLoop1     \n\t"
//            mov         ebp,[esp-4]     \n\t"
            "pop         %%ebp      \n\t"
            "jmp         Endb     \n\t"

"BilinearLoop2:     \n\t"
            "movq        (%%esi), %%mm0     \n\t"
            "movq        %%mm0,%%mm4     \n\t"
            "pand        %%mm6,%%mm4     \n\t" // here
            "movq        1(%%esi), %%mm1     \n\t"
            "movq        %%mm1,%%mm5     \n\t"
            "pand        %%mm6,%%mm5     \n\t"
            "paddw       %%mm5,%%mm4     \n\t"
            "movq        (%%esi, %%edx, 1), %%mm2     \n\t"
            "movq        %%mm2,%%mm5     \n\t"
            "pand        %%mm6,%%mm5     \n\t"
            "paddw       %%mm5,%%mm4     \n\t"
            "movq        1(%%esi, %%edx, 1), %%mm3     \n\t"
            "movq        %%mm3,%%mm5     \n\t"
            "pand        %%mm6,%%mm5     \n\t"
            "paddw       %%mm5,%%mm4     \n\t"
            "paddw       %9, %%mm4 \n\t"
//            "paddw       x02, %%mm4 \n\t"
            "psrlw       $2, %%mm4     \n\t"
            "pand        %%mm6,%%mm4     \n\t"
            "psrlw       $2, %%mm0     \n\t"
            "pand        %%mm7,%%mm0     \n\t"
            "psrlw       $2, %%mm1     \n\t"
            "pand        %%mm7,%%mm1     \n\t"
            "paddw       %%mm1,%%mm0     \n\t"
            "psrlw       $2, %%mm2     \n\t"
            "pand        %%mm7,%%mm2     \n\t"
            "paddw       %%mm2,%%mm0     \n\t"
            "psrlw       $2, %%mm3     \n\t"
            "pand        %%mm7,%%mm3     \n\t"
            "paddw       %%mm3,%%mm0     \n\t"
            "paddw       %%mm4,%%mm0     \n\t"
            "movq        %%mm0, (%%edi)     \n\t"

            "movq        8(%%esi), %%mm0     \n\t"
            "movq        %%mm0,%%mm4     \n\t"
            "pand        %%mm6,%%mm4     \n\t" // here
            "movq        9(%%esi), %%mm1     \n\t" // esi + 9
            "movq        %%mm1,%%mm5     \n\t"
            "pand        %%mm6,%%mm5     \n\t"
            "paddw       %%mm5,%%mm4     \n\t"
            "movq        8(%%esi, %%edx, 1), %%mm2     \n\t" // esi+ edx +8
            "movq        %%mm2,%%mm5     \n\t"
            "pand        %%mm6,%%mm5     \n\t"
            "paddw       %%mm5,%%mm4     \n\t"
            "movq        9(%%esi, %%edx, 1), %%mm3     \n\t" //esi+edx+9
            "movq        %%mm3,%%mm5     \n\t"
            "pand        %%mm6,%%mm5     \n\t"
            "paddw       %%mm5,%%mm4     \n\t"
            "paddw       %9, %%mm4 \n\t"
//            "paddw       x02, %%mm4 \n\t"
            "psrlw       $2, %%mm4     \n\t"
            "pand        %%mm6,%%mm4     \n\t"
            "psrlw       $2, %%mm0     \n\t"
            "pand        %%mm7,%%mm0     \n\t"
            "psrlw       $2, %%mm1     \n\t"
            "pand        %%mm7,%%mm1     \n\t"
            "paddw       %%mm1,%%mm0     \n\t"
            "psrlw       $2, %%mm2     \n\t"
            "pand        %%mm7,%%mm2     \n\t"
            "paddw       %%mm2,%%mm0     \n\t"
            "psrlw       $2, %%mm3     \n\t"
            "pand        %%mm7,%%mm3     \n\t"
            "paddw       %%mm3,%%mm0     \n\t"
            "paddw       %%mm4,%%mm0     \n\t"
            "movq        %%mm0, 8(%%edi)     \n\t"

            "add         %%ecx, %%esi     \n\t"
            "add         %%ebx, %%edi     \n\t"
            "dec         %%ebp     \n\t"
            "jnz         BilinearLoop2     \n\t"
//            mov         ebp,[esp-4]     \n\t"
            "pop         %%ebp \n\t" // for x-box
            :
            :   "m"  (ppxlcRefMB),
                "m"  (ppxlcPredMB),
                "m"   (1),
                "m"  (x3F),
                "m"  (x03),
                "m"  (iWidthFrm),
                "m"  (iWidthFrm),
                "m"  (1),
                "m"  (8),
                "m"  (x01)
            :   "%esi", "%edi", "%edx", "%eax", "%ebx", "%ecx", "%ebp"
            );
        }
    }
    asm volatile
    (
"Endb: \n\t"
        "emms \n\t"
    );
#endif
}
#endif
#endif

#if defined(_WMV_TARGET_X86_)
#if defined(_WIN32) || defined(_XBOX) || defined(_Embedded_x86)

////////////////////////////////////////////////////////////////////////////////
////////////////////////////// Katmai (P3) Versions ////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Void_WMV g_MotionComp_KNI(
    tWMVDecInternalMember *pWMVDec,
	U8_WMV*             ppxlcPredMB,
	const U8_WMV*       ppxlcRefMB,
    I32_WMV             iWidthFrm,
    Bool_WMV            bInterpolateX,
    Bool_WMV            bInterpolateY,
    I32_WMV             iMixedPelMV	
)
{
  	static const Int64 x01 = (Int64)0x0101010101010101;
    static const Int64 x7f = (Int64)0x7f7f7f7f7f7f7f7f;
    static const Int64 x3F = (Int64)0x3F3F3F3F3F3F3F3F;
    static const Int64 x03 = (Int64)0x0303030303030303;
    static const Int64 x02 = (Int64)0x0202020202020202;

     if (bInterpolateY) {
        if (bInterpolateX) {  //!bXSubPxl && !bYSubPxl
            _asm {
            mov         esi,ppxlcRefMB
            mov         edi,ppxlcPredMB
            mov         eax,iWidthFrm
            mov         ebx,iWidthFrm
            mov         ecx,8
            cmp         ecx,16
            jz          CopyLoop2
CopyLoop1:
            movq        mm0,[esi]
            add         esi,eax
            movq        [edi],mm0
            add         edi,ebx
            dec         ecx
            jnz         CopyLoop1
            jmp         End
CopyLoop2:
            movq        mm0,[esi]
            movq        [edi],mm0
            movq        mm0,[esi+8]
            add         esi,eax
            movq        [edi+8],mm0
            add         edi,ebx
            dec         ecx
            jnz         CopyLoop2
            }
        }
        else {  //bXSubPxl && !bYSubPxl
            _asm {
            mov         esi,ppxlcRefMB
            mov         edi,ppxlcPredMB
            mov         edx,1
            mov         eax,iWidthFrm
            mov         ebx,iWidthFrm
            movq        mm7,x7f
            movq        mm6,x01
            mov         ecx,8
            cmp         ecx,16
            jz          HorizantalLoop2
HorizantalLoop1:
            movq        mm0,[esi]
            movq        mm1,[esi+edx]
            pavgb       mm0_mm1
            movq        [edi],mm0
            add         esi,eax
            add         edi,ebx
            dec         ecx
            jnz         HorizantalLoop1
            jmp         End

HorizantalLoop2:
            movq        mm0,[esi]
            movq        mm1,[esi+edx]
            pavgb       mm0_mm1
            movq        [edi],mm0

            movq        mm0,[esi+8]
            movq        mm1,[esi+edx+8]
            pavgb       mm0_mm1
            movq        [edi+8],mm0

            add         esi,eax
            add         edi,ebx
            dec         ecx
            jnz         HorizantalLoop2
	        }
        }
    }
    else {
        if (bInterpolateX) {  //!bXSubPxl&& bYSubPxl
            _asm {
            mov         esi,ppxlcRefMB
            mov         edi,ppxlcPredMB
            mov         eax,iWidthFrm
            mov         edx,1
            imul        edx,eax
            mov         eax,iWidthFrm
            mov         ebx,iWidthFrm
            movq        mm7,x7f
            movq        mm6,x01
            mov         ecx,8
            cmp         ecx,16
            jz          VerticalLoop2
VerticalLoop1:
            movq        mm0,[esi]
            movq        mm1,[esi+edx]
            pavgb       mm0_mm1
            movq        [edi],mm0
            add         esi,eax
            add         edi,ebx
            dec         ecx
            jnz         VerticalLoop1
            jmp         End

VerticalLoop2:
            movq        mm0,[esi]
            movq        mm1,[esi+edx]
            pavgb       mm0_mm1
            movq        [edi],mm0

            movq        mm0,[esi+8]
            movq        mm1,[esi+edx+8]
            pavgb       mm0_mm1
            movq        [edi+8],mm0

            add         esi,eax
            add         edi,ebx
            dec         ecx
            jnz         VerticalLoop2
	        }
        }
        else { // bXSubPxl && bYSubPxl
            _asm {
            // for x-box->fix esp crash because the stack can't be accessed
            push        eax;
            push        eax;
            push        eax;
            push        eax;
            // -------------
            mov         esi,ppxlcRefMB
            mov         edi,ppxlcPredMB

            mov         eax,1
            cmp         eax,-1
            jnz         PositiveXMV
            dec         esi
PositiveXMV:
            mov         eax,1
            mov         edx,iWidthFrm
            cmp         eax,-1
            jnz         PositiveYMV
            sub         esi,edx
PositiveYMV:
            mov         [esp+8],esi // IW
            mov         [esp+12],edi // IW

            movq        mm7,x3F
            movq        mm6,x03
            mov         ecx,iWidthFrm
            mov         ebx,iWidthFrm
            mov         [esp+4],ebp // IW
            mov         ebp,8

            movq        mm0,[esi]
            movq        mm1,[esi+1]

            movq        mm4,mm0
            pand        mm4,mm6
            pxor        mm0,mm4

            movq        mm5,mm1
            pand        mm5,mm6
            pxor        mm1,mm5
            paddw       mm4,mm5

            pavgb       mm0_mm1

BilinearLoop1:

            movq        mm1,[esi+edx]
            movq        mm3,[esi+edx+1]

            movq        mm7,mm1
            pand        mm7,mm6
            pxor        mm1,mm7

            movq        mm5,mm3
            pand        mm5,mm6
            pxor        mm3,mm5
            paddw       mm7,mm5
            paddw       mm4,mm7
            paddw       mm4,x02
            psrlw       mm4,2
            pand        mm4,mm6

            pavgb       mm1_mm3
            movq        mm2,mm1
            pavgb       mm0_mm1
            paddw       mm0,mm4

            movq        [edi],mm0

            movq        mm0,mm2
            movq        mm4,mm7

            add         esi,ecx
            add         edi,ebx
            dec         ebp
            jnz         BilinearLoop1

            mov         ebp,[esp+4] // IW
            mov         ebp,8
            cmp         ebp,16
            jnz         Done

            mov         esi,[esp+8] // IW
            add         esi,8
            mov         edi,[esp+12] // IW
            add         edi,8

            movq        mm0,[esi]
            movq        mm1,[esi+1]

            movq        mm4,mm0
            pand        mm4,mm6
            pxor        mm0,mm4

            movq        mm5,mm1
            pand        mm5,mm6
            pxor        mm1,mm5
            paddw       mm4,mm5

            pavgb       mm0_mm1

BilinearLoop2:

            movq        mm1,[esi+edx]
            movq        mm3,[esi+edx+1]

            movq        mm7,mm1
            pand        mm7,mm6
            pxor        mm1,mm7

            movq        mm5,mm3
            pand        mm5,mm6
            pxor        mm3,mm5
            paddw       mm7,mm5
            paddw       mm4,mm7
            paddw       mm4,x02
            psrlw       mm4,2
            pand        mm4,mm6

            pavgb       mm1_mm3
            movq        mm2,mm1
            pavgb       mm0_mm1
            paddw       mm0,mm4

            movq        [edi],mm0

            movq        mm0,mm2
            movq        mm4,mm7

            add         esi,ecx
            add         edi,ebx
            dec         ebp
            jnz         BilinearLoop2

Done:       mov         ebp,[esp+4] // IW
            // for x-box
            pop         eax;
            pop         eax;
            pop         eax;
            pop         eax;
            // ------------
            }

        }
    }
End: _asm emms;
}
#endif
#endif

#pragma warning( default : 4731 )  // turn on ebp in inline assembly warning
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\postfilter_wmv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       postfilter.cpp
//
//--------------------------------------------------------------------------
#include "bldsetup.h"

#include "xplatform.h"

#ifdef _SUPPORT_POST_FILTERS_
#include "limits.h"
#include "stdio.h"
#include "stdlib.h"
#include "wmvdec_member.h"
#include "typedef.hpp"
#include "postfilter_wmv.hpp"
#ifdef _WMV_TARGET_X86_
#include "cpudetect.h"
#endif
#include "opcodes.h"
#include "tables_wmv.h"

//THR1 = the threshold before we consider neighboring pixels to be "diffrent"
#define THR1 2       
//THR2 = the total number of "diffrent" pixels under which we use stronger filter
#define THR2 6
#define INV_THR2 3

Void_WMV (*g_pDeblockMB)(DEBLOCKMB_ARGS);
Void_WMV (*g_pApplySmoothing)(APPLYSMOOTHING_ARGS);
Void_WMV (*g_pDetermineThreshold)(DETERMINETHR_ARGS);
Void_WMV (*g_pDeringMB) (DERINGMB_ARGS);

#ifdef _Embedded_x86
#include "postfilter_emb.h"
#endif

Void_WMV g_InitPostFilter (Bool_WMV bFastDeblock) 
{
    g_pDeblockMB = DeblockMB;
    g_pApplySmoothing = ApplySmoothing;
    g_pDetermineThreshold = DetermineThreshold;
    g_pDeringMB = DeringMB;

#if defined(_WMV_TARGET_X86_) ||  defined(_Embedded_x86)
    if (g_SupportMMX ()) {        
        if (bFastDeblock)
            g_pDeblockMB = DeblockMB_FASTEST_MMX;
        else
            g_pDeblockMB = DeblockMB_MMX;
        g_pApplySmoothing = ApplySmoothing_MMX;
        g_pDetermineThreshold = DetermineThreshold_MMX;
    }
#ifdef _WMV_TARGET_X86_
    if (g_SupportSSE1()){
        g_pDetermineThreshold = DetermineThreshold_KNI;
        g_pDeblockMB = DeblockMB_KNI;
    }
#endif
#endif
}

inline I32_WMV MIN (I32_WMV a,I32_WMV b,I32_WMV c) 
{
    if (a < b) {
        if (a < c) return a;
        return c;
    } else {
        if (b < c) return b;
        else return c;
    }
}

inline I32_WMV CLIP (I32_WMV a,I32_WMV b,I32_WMV c) 
{
    if (b < c) {
        if (a < b) a = b;
        if (a > c) a = c;
        return a;
    }
    if (a > b) a = b;
    if (a < c) a = c;
    return a;
}

I32_WMV MAX(int a,int b,int c,int d,int e,int f,int g,int h) 
{
    I32_WMV max = a;
    if (max < b) max  = b;
    if (max < c) max  = c;
    if (max < d) max  = d;
    if (max < e) max  = e;
    if (max < f) max  = f;
    if (max < g) max  = g;
    if (max < h) max  = h;
    return max;
}

I32_WMV MIN(int a,int b,int c,int d,int e,int f,int g,int h) 
{
    I32_WMV min = a;
    if (min > b) min  = b;
    if (min > c) min  = c;
    if (min > d) min  = d;
    if (min > e) min  = e;
    if (min > f) min  = f;
    if (min > g) min  = g;
    if (min > h) min  = h;
    return min;
}

// this fn defined in spatialpredictor.cpp
Bool_WMV bMin_Max_LE_2QP(int a,int b,int c,int d,int e,int f,int g,int h, int i2Qp);

/*
#define P(m) (((m < 1) && (abs(v1-v0) < iStepSize)) ? v0 :   \
             (m <  1)                              ? v1 :    \
             (m == 1)                              ? v1 :    \
             (m == 2)                              ? v2 :    \
             (m == 3)                              ? v3 :    \
             (m == 4)                              ? v4 :    \
             (m == 5)                              ? v5 :    \
             (m == 6)                              ? v6 :    \
             (m == 7)                              ? v7 :    \
             (m == 8)                              ? v8 :    \
             (abs(v8-v9) < iStepSize)              ? v9 : v8)

#define filt(n) g_rgiClapTabDec[((P(n-4) + P(n-3) + 2*P(n-2) + 2*P(n-1) + 4*P(n) + 2*P(n+1) + 2*P(n+2) + P(n+3) + P(n+4) + 8)>>4)]
*/
#define P_filt1 rgiClapTab[((6*v0 + 4*v1 + 2*v2 + 2*v3 + v4 + v5 + 8)>>4)]
#define P_filt2 rgiClapTab[((4*v0 + 2*v1 + 4*v2 + 2*v3 + 2*v4 + v5 + v6 + 8)>>4)]
#define P_filt3 rgiClapTab[((2*v0 + 2*v1 + 2*v2 + 4*v3 + 2*v4 + 2*v5 + v6 + v7 + 8)>>4)]
#define P_filt4 rgiClapTab[((v0 + v1 + 2*v2 + 2*v3 + 4*v4 + 2*v5 + 2*v6 + v7 + v8 + 8)>>4)]
#define P_filt5 rgiClapTab[((v1 + v2 + 2*v3 + 2*v4 + 4*v5 + 2*v6 + 2*v7 + v8 + v9 + 8)>>4)]
#define P_filt6 rgiClapTab[((v2 + v3 + 2*v4 + 2*v5 + 4*v6 + 2*v7 + 2*v8 + 2*v9 + 8)>>4)]
#define P_filt7 rgiClapTab[((v3 + v4 + 2*v5 + 2*v6 + 4*v7 + 2*v8 + 4*v9 + 8)>>4)]
#define P_filt8 rgiClapTab[((v4 + v5 + 2*v6 + 2*v7 + 4*v8 + 6*v9 + 8)>>4)]

#define phi(a) ((abs(a) <= THR1) ? 1 : 0)     
#define SIGN(a) ((a < 0) ? -1 : 1)

#define inverse_phi(a) ((abs(a) > THR1) ? 1 : 0)     

inline Void_WMV FilterEdge (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* ppxlcCenter, I32_WMV iPixelDistance, I32_WMV iPixelIncrement, I32_WMV iEdgeLength, I32_WMV iStepSize
) {

    U8_WMV* pV5 = ppxlcCenter;
    U8_WMV* pV4 = pV5 - iPixelDistance;
    U8_WMV* pV3 = pV4 - iPixelDistance;
    U8_WMV* pV2 = pV3 - iPixelDistance;
    U8_WMV* pV1 = pV2 - iPixelDistance;
    U8_WMV* pV0 = pV1 - iPixelDistance;
    U8_WMV* pV6 = pV5 + iPixelDistance;
    U8_WMV* pV7 = pV6 + iPixelDistance;
    U8_WMV* pV8 = pV7 + iPixelDistance;
    U8_WMV* pV9 = pV8 + iPixelDistance;
    I32_WMV i;
    const U8_WMV* rgiClapTab = pWMVDec->m_rgiClapTabDec; 

    for (i = 0; i < iEdgeLength; ++i) {
       
       I32_WMV v0 = *pV0;                                                                    
       I32_WMV v1 = *pV1;                                                                    
       I32_WMV v2 = *pV2;                                                                    
       I32_WMV v3 = *pV3;                                                                    
       I32_WMV v4 = *pV4;                                                                    
       I32_WMV v5 = *pV5;                                                                    
       I32_WMV v6 = *pV6;                                                                    
       I32_WMV v7 = *pV7;                                                                    
       I32_WMV v8 = *pV8;                                                                    
       I32_WMV v9 = *pV9;                                                                    
       
       I32_WMV eq_cnt = phi(v0 - v1) + phi(v1 - v2) + phi(v2 - v3) + phi(v3 - v4) + phi(v4 - v5) +                     
                    phi(v5 - v6) + phi(v6 - v7) + phi(v7 - v8) + phi(v8 - v9);       
       
////////////// Run Experiement to see if it benefit.
       /*
       I32_WMV eq_cnt = inverse_phi(v2 - v3) + inverse_phi(v3 - v4) + inverse_phi(v4 - v5) +                     
                    inverse_phi(v5 - v6) + inverse_phi(v6 - v7);    
       if (eq_cnt <= INV_THR2)                                                          
           eq_cnt = (5 - eq_cnt_inv) + phi(v0 - v1) + phi(v1 - v2) + phi(v7 - v8) + phi(v8 - v9);       
       */ 

       if (eq_cnt >= THR2) {                                                         
           //I32_WMV max = MAX(v1,v2,v3,v4,v5,v6,v7,v8);    //DC Offset mode                               
           //I32_WMV min = MIN(v1,v2,v3,v4,v5,v6,v7,v8);                                   
           //if (abs(max-min) < 2*iStepSize){
           if (bMin_Max_LE_2QP(v1,v2,v3,v4,v5,v6,v7,v8,2*iStepSize)){                                          
               if (abs(v1-v0) >= iStepSize) v0 = v1;
               if (abs(v8-v9) >= iStepSize) v9 = v8;
               *pV1 = P_filt1;                                                   
               *pV2 = P_filt2;                                                        
               *pV3 = P_filt3;                                                        
               *pV4 = P_filt4;                                                        
               *pV5 = P_filt5;                                                        
               *pV6 = P_filt6;                                                        
               *pV7 = P_filt7;                                                        
               *pV8 = P_filt8;                                                        
/*
               *pV1 = filt(1);                                                   
               *pV2 = filt(2);                                                        
               *pV3 = filt(3);                                                        
               *pV4 = filt(4);                                                        
               *pV5 = filt(5);                                                        
               *pV6 = filt(6);                                                        
               *pV7 = filt(7);                                                        
               *pV8 = filt(8);                                                        
*/
           }                                                                          
       } else {
		   I32_WMV v4_v5 = v4 - v5;
		   I32_WMV a30 = (2*(v3-v6) - 5*v4_v5 + 4) / 8;
		   if (abs(a30) < iStepSize) {
			   I32_WMV v2_v3 = v2 - v3;
			   I32_WMV v6_v7 = v6 - v7;
			   I32_WMV a31 = (2*(v1-v4) - 5*v2_v3 + 4) / 8;                                 
			   I32_WMV a32 = (2*(v5-v8) - 5*v6_v7 + 4) / 8;                                 
			   I32_WMV iMina31_a32 = min(abs(a31),abs(a32)); 
			   if (iMina31_a32 < abs(a30)){
				   I32_WMV dA30 = SIGN(a30) * iMina31_a32 - a30;
				   I32_WMV d = CLIP(5*dA30/8,0,v4_v5/2);
				   *pV4 = rgiClapTab[v4 - d];                                                                     
				   *pV5 = rgiClapTab[v5 + d];
			   }
		   }
           /* 
           I32_WMV a30 = (2*v3 - 5*v4 + 5*v5 - 2*v6 + 4) >> 3;                                 
           I32_WMV a31 = (2*v1 - 5*v2 + 5*v3 - 2*v4 + 4) >> 3;                                 
           I32_WMV a32 = (2*v5 - 5*v6 + 5*v7 - 2*v8 + 4) >> 3;                                 
           I32_WMV A30 = SIGN(a30) * ( MIN(abs(a30),abs(a31),abs(a32))   );                
           I32_WMV d = CLIP( (5*(A30-a30)/8),0,((v4-v5)/2) * ((abs(a30) < iStepSize) ? 1 : 0)   );
           *pV4 = g_rgiClapTabDec[v4 - d];                                                                     
           *pV5 = g_rgiClapTabDec[v5 + d]; 
           */
       }
      
       pV0 += iPixelIncrement;
       pV1 += iPixelIncrement;
       pV2 += iPixelIncrement;
       pV3 += iPixelIncrement;
       pV4 += iPixelIncrement;
       pV5 += iPixelIncrement;
       pV6 += iPixelIncrement;
       pV7 += iPixelIncrement;
       pV8 += iPixelIncrement;
       pV9 += iPixelIncrement;
    }
} 

inline Void_WMV FilterHalfEdge (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV* ppxlcCenter, I32_WMV iPixelDistance, I32_WMV iPixelIncrement, I32_WMV iEdgeLength, I32_WMV iStepSize)
{

    U8_WMV* pV5 = ppxlcCenter;
    U8_WMV* pV4 = pV5 - iPixelDistance;
    U8_WMV* pV3 = pV4 - iPixelDistance;
    U8_WMV* pV2 = pV3 - iPixelDistance;
    U8_WMV* pV1 = pV2 - iPixelDistance;
    U8_WMV* pV0 = pV1 - iPixelDistance;
    U8_WMV* pV6 = pV5 + iPixelDistance;
    U8_WMV* pV7 = pV6 + iPixelDistance;
    U8_WMV* pV8 = pV7 + iPixelDistance;
    U8_WMV* pV9 = pV8 + iPixelDistance;
    I32_WMV i;
    const U8_WMV* rgiClapTab = pWMVDec->m_rgiClapTabDec; 

    for (i = 0; i < iEdgeLength; ++i) {
       
       I32_WMV v0 = *pV0;                                                                    
       I32_WMV v1 = *pV1;                                                                    
       I32_WMV v2 = *pV2;                                                                    
       I32_WMV v3 = *pV3;                                                                    
       I32_WMV v4 = *pV4;                                                                    
       I32_WMV v5 = *pV5;                                                                    
       I32_WMV v6 = *pV6;                                                                    
       I32_WMV v7 = *pV7;                                                                    
       I32_WMV v8 = *pV8;                                                                    
       I32_WMV v9 = *pV9;                                                                    
                                                                                     
       I32_WMV eq_cnt = phi(v0 - v1) + phi(v1 - v2) + phi(v2 - v3) + phi(v3 - v4) + phi(v4 - v5) +                     
                    phi(v5 - v6) + phi(v6 - v7) + phi(v7 - v8) + phi(v8 - v9);       
                                                                                            
       if (eq_cnt >= THR2) {                                                         
           //I32_WMV max = MAX(v1,v2,v3,v4,v5,v6,v7,v8);    //DC Offset mode                               
           //I32_WMV min = MIN(v1,v2,v3,v4,v5,v6,v7,v8);                                   
           //if (abs(max-min) < 2*iStepSize){                                          
           if (bMin_Max_LE_2QP(v1,v2,v3,v4,v5,v6,v7,v8,2*iStepSize)){                                          
               if (abs(v1-v0) >= iStepSize) v0 = v1;
               *pV1 = P_filt1;                                                   
               *pV2 = P_filt2;                                                        
               *pV3 = P_filt3;                                                        
               *pV4 = P_filt4;                                                        
               /* 
               *pV1 = filt(1);                                                   
               *pV2 = filt(2);                                                        
               *pV3 = filt(3);                                                        
               *pV4 = filt(4);                                                        
               */
           }                                                                          
       } else {
		   I32_WMV v4_v5 = v4 - v5;
		   I32_WMV a30 = (2*(v3-v6) - 5*v4_v5 + 4) / 8;
		   if (abs(a30) < iStepSize) {
			   I32_WMV v2_v3 = v2 - v3;
			   I32_WMV v6_v7 = v6 - v7;
			   I32_WMV a31 = (2*(v1-v4) - 5*v2_v3 + 4) / 8;                                 
			   I32_WMV a32 = (2*(v5-v8) - 5*v6_v7 + 4) / 8;                                 
			   I32_WMV iMina31_a32 = min(abs(a31),abs(a32)); 
			   if (iMina31_a32 < abs(a30)){
				   I32_WMV dA30 = SIGN(a30) * iMina31_a32 - a30;
				   I32_WMV d = CLIP(5*dA30/8,0,v4_v5/2);
				   *pV4 = rgiClapTab [v4 - d];                                                                     
			   }
		   }
           /*
           I32_WMV a30 = (2*v3 - 5*v4 + 5*v5 - 2*v6 + 4) >> 3;                                 
           I32_WMV a31 = (2*v1 - 5*v2 + 5*v3 - 2*v4 + 4) >> 3;                                 
           I32_WMV a32 = (2*v5 - 5*v6 + 5*v7 - 2*v8 + 4) >> 3;                                 
                                                                                      
           I32_WMV A30 = SIGN(a30) * ( MIN(abs(a30),abs(a31),abs(a32))   );                
           I32_WMV d = CLIP( (5*(A30-a30)/8),0,((v4-v5)/2) * ((abs(a30) < iStepSize) ? 1 : 0)   );
           *pV4 = g_rgiClapTabDec[v4 - d];                                                                     
           */
       }
      
       pV0 += iPixelIncrement;
       pV1 += iPixelIncrement;
       pV2 += iPixelIncrement;
       pV3 += iPixelIncrement;
       pV4 += iPixelIncrement;
       pV5 += iPixelIncrement;
       pV6 += iPixelIncrement;
       pV7 += iPixelIncrement;
       pV8 += iPixelIncrement;
       pV9 += iPixelIncrement;
    
    }
}

//Find maxumum and minimum values in a 10x10 block
Void_WMV DetermineThreshold(U8_WMV *ptr, I32_WMV *thr, I32_WMV *range, I32_WMV width) 
{
    I32_WMV max = 0;                                         
    I32_WMV min = 255;  
    I32_WMV x, y;

    for (x = -1; x < 9; x++){                    
        for (y = -1; y < 9; y++){                
            I32_WMV pixelValue = ptr[x+(y*width)];       
            if (max < pixelValue) max = pixelValue;  
            if (min > pixelValue) min = pixelValue;  
        }                                            
    }
    *thr = (max + min + 1) / 2;
    *range = max - min;
}    

Void_WMV ApplySmoothing(U8_WMV *pixel,I32_WMV width, I32_WMV max_diff,I32_WMV thr)
{

    Bool_WMV bin[10][10];
    
    I32_WMV  x, y;
    U8_WMV output[8][8];

    for (x = 0; x < 10; x++){
        for (y = 0; y < 10; y++){
            U8_WMV pixelValue =  pixel[(x-1)+((y-1)*width)];
            bin [x][y] = (pixelValue >= thr) ? 1 : 0;
        }
    }


    for (x = 0; x < 8; x++){
        for (y = 0; y < 8; y++){
            if ((bin[x][y] == bin[x+1][y])    //If All 9 values equel (all 0 or all 1)
             && (bin[x][y] == bin[x+2][y])
             && (bin[x][y] == bin[x]  [y+1])
             && (bin[x][y] == bin[x+1][y+1])
             && (bin[x][y] == bin[x+2][y+1])
             && (bin[x][y] == bin[x]  [y+2])
             && (bin[x][y] == bin[x+1][y+2])
             && (bin[x][y] == bin[x+2][y+2])) {

                U8_WMV *ppxlcFilt = pixel+x+(y*width);

                //Apply Spoothing Filter
                I32_WMV filt = (  ppxlcFilt[-1-width] +  2*ppxlcFilt[0 -width] +   ppxlcFilt[+1-width] +
                            2*ppxlcFilt[-1      ] +  4*ppxlcFilt[0       ] + 2*ppxlcFilt[+1      ] +      
                              ppxlcFilt[-1+width] +  2*ppxlcFilt[0 +width] +   ppxlcFilt[+1+width] +8) >> 4;
                
                if ((filt - *ppxlcFilt) > max_diff) filt = *ppxlcFilt + max_diff;
                else if ((filt - *ppxlcFilt) < -max_diff) filt = *ppxlcFilt - max_diff;
                CLIP(filt,0,255);
                output[x][y] = (U8_WMV)filt;

            } else output[x][y] = *(pixel+x+(y*width));
        }
    }
    for (x = 0; x < 8; x++){
        for (y = 0; y < 8; y++){
        *(pixel+x+(y*width)) = output[x][y];
           
        }
    }
}

Void_WMV DeblockMB (
    tWMVDecInternalMember *pWMVDec,
    U8_WMV        *ppxliY,
    U8_WMV        *ppxliU,
    U8_WMV        *ppxliV,
    Bool_WMV                  bDoLeft,
    Bool_WMV                  bDoRightHalfEdge,
    Bool_WMV                  bDoTop,
    Bool_WMV                  bDoBottomHalfEdge,
    Bool_WMV                  bDoMiddle,
    I32_WMV                   iStepSize,
    I32_WMV                   iWidthPrevY,
    I32_WMV                   iWidthPrevUV
)
{
    
    if (bDoTop) {
        // Filter the top Y, U and V edges.
        FilterEdge (pWMVDec, ppxliY,iWidthPrevY,1,MB_SIZE,iStepSize);
        FilterEdge (pWMVDec, ppxliU,iWidthPrevUV,1,BLOCK_SIZE,iStepSize);
        FilterEdge (pWMVDec, ppxliV,iWidthPrevUV,1,BLOCK_SIZE,iStepSize);
    }

    if (bDoBottomHalfEdge) {
        // Filter the bottom Y, U and V edges.
        FilterHalfEdge (pWMVDec, ppxliY + (iWidthPrevY * MB_SIZE),iWidthPrevY,1,MB_SIZE,iStepSize);
        FilterHalfEdge (pWMVDec, ppxliU + (iWidthPrevUV * BLOCK_SIZE),iWidthPrevUV,1,BLOCK_SIZE,iStepSize);
        FilterHalfEdge (pWMVDec, ppxliV + (iWidthPrevUV * BLOCK_SIZE),iWidthPrevUV,1,BLOCK_SIZE,iStepSize);
    } 

    if (bDoMiddle) {
        // Filter the middle horizontal Y edge
        FilterEdge(pWMVDec, ppxliY+ iWidthPrevY * 8,iWidthPrevY,1,MB_SIZE,iStepSize);

        // Filter the middle vertical Y edge
        FilterEdge(pWMVDec, ppxliY + 8,1,iWidthPrevY,MB_SIZE,iStepSize);     
    }

    if (bDoLeft) {
        // Filter the left vertical Y, U and V edges.
        FilterEdge(pWMVDec, ppxliY,1,iWidthPrevY,MB_SIZE,iStepSize);
        FilterEdge(pWMVDec, ppxliU,1,iWidthPrevUV,BLOCK_SIZE,iStepSize);
        FilterEdge(pWMVDec, ppxliV,1,iWidthPrevUV,BLOCK_SIZE,iStepSize);
    }

    if (bDoRightHalfEdge) {
        // Filter the right vertical Y, U and V edges.
        FilterHalfEdge(pWMVDec, ppxliY + MB_SIZE,1,iWidthPrevY,MB_SIZE,iStepSize);
        FilterHalfEdge(pWMVDec, ppxliU + BLOCK_SIZE,1,iWidthPrevUV,BLOCK_SIZE,iStepSize);
        FilterHalfEdge(pWMVDec, ppxliV + BLOCK_SIZE,1,iWidthPrevUV,BLOCK_SIZE,iStepSize);
  } 
}

Void_WMV DeringMB (
    U8_WMV        *ppxlcY,
    U8_WMV        *ppxlcU,
    U8_WMV        *ppxlcV,
    I32_WMV                  iStepSize,
    I32_WMV                  iWidthPrevY,
    I32_WMV                  iWidthPrevUV
)
{  
    I32_WMV thr[6];
    I32_WMV range[6];
    I32_WMV k_max;
    I32_WMV max_range;
    I32_WMV k;
    
    g_pDetermineThreshold(ppxlcY,                                    &thr[0],&range[0],iWidthPrevY);
    g_pDetermineThreshold(ppxlcY+ BLOCK_SIZE,                        &thr[1],&range[1],iWidthPrevY);
    g_pDetermineThreshold(ppxlcY+(BLOCK_SIZE*iWidthPrevY),           &thr[2],&range[2],iWidthPrevY);
    g_pDetermineThreshold(ppxlcY+(BLOCK_SIZE*iWidthPrevY)+BLOCK_SIZE,&thr[3],&range[3],iWidthPrevY);
    g_pDetermineThreshold(ppxlcU,                                    &thr[4],&range[4],iWidthPrevUV);
    g_pDetermineThreshold(ppxlcV,                                    &thr[5],&range[5],iWidthPrevUV);
    
    k_max = (range[0]     > range[1]) ? 0     : 1;
    k_max = (range[k_max] > range[2]) ? k_max : 2;
    k_max = (range[k_max] > range[3]) ? k_max : 3;
    max_range = range[k_max];
    for (k = 0; k < 4; k++){
        if ((range[k] < 32) && (max_range >= 64)) thr[k] = thr[k_max];
        if (max_range < 16) thr[k] = 0;
    }

    g_pApplySmoothing(ppxlcY                                    ,iWidthPrevY ,iStepSize*2,thr[0]);
    g_pApplySmoothing(ppxlcY+BLOCK_SIZE                         ,iWidthPrevY ,iStepSize*2,thr[1]);
    g_pApplySmoothing(ppxlcY+(BLOCK_SIZE*iWidthPrevY)           ,iWidthPrevY ,iStepSize*2,thr[2]);
    g_pApplySmoothing(ppxlcY+BLOCK_SIZE+(BLOCK_SIZE*iWidthPrevY),iWidthPrevY ,iStepSize*2,thr[3]);
    g_pApplySmoothing(ppxlcU                                    ,iWidthPrevUV,iStepSize*2,thr[4]);
    g_pApplySmoothing(ppxlcV                                    ,iWidthPrevUV,iStepSize*2,thr[5]);
}

#endif // _SUPPORT_POST_FILTERS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\msaudiodec.c ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    MsAudioDec.cpp

Abstract:

    Implementation of top level functions of CAudioObjectDecoder.

Author:

    Wei-ge Chen (wchen) 14-July-1998

Revision History:


*************************************************************************/

#include "bldsetup.h"

#include "msaudiodec.h"
#include "macros.h"

#include "AutoProfile.h" 

#if defined(_DEBUG) || defined(BITRATE_REPORT)
extern Int g_cBitGet = 0;
#endif  // _DEBUG || BITRATE_REPORT

//***************************************************************************
// Local Function Prototypes
//***************************************************************************
Void auInitPcInfoDEC (CAudioObject* pau);
FastFloat prvCalcSqrtBWRatioDEC(const PerChannelInfo *ppcinfo,
                            const Int iNoiseBand,
                            const Int cNoiseBand);


//*****************************************************************************************
//*****************************************************************************************
//
//  Outline of decoding process - major function call graph (HighRate is >= 32kbps)
//  Decode
//  ..audecDecode
//  ....prvDecodePacket
//  ......audecDecodeData
//  ........auSaveHistoryMono
//  ........prvDecodeSubFrameHighRate
//  ..........prvDecodeFrameHeader
//  ............prvUpdateSubFrameConfig
//  ............auAdaptToSubFrameConfig
//  ............prvAdaptEqToSubFrame
//  ............prvSetDetTable
//  ............prvReconWeightingFactor
//  ..........qstCalcQuantStep                      ; calc sub frame's quantization step size
//  ..........prvDecodeCoefficentsHighRate<float.c> ; fills rgiCoefRecon[] from bitstream with amplitude as a function of frequency
//  ..........InverseQuantizeHighRate<float.c>
//  ..........dctIV
//  ............FFT
//  ......audecGetPCM
//  ......audecDecodeInfo
//*****************************************************************************************
//*****************************************************************************************


//*****************************************************************************************
//
// audecDelete
//   free up and delete the CAudioObjectDecoder
//
//*****************************************************************************************
Void audecDelete (CAudioObjectDecoder* paudec)
{
    auMallocSetState(MAS_DELETE, NULL, 0);

    auDelete (paudec->pau);
    paudec->pau = NULL;

    auFree(paudec);
}


//*****************************************************************************************
//
// audecFlush
//   usually this deos do anything unless a subframe was put on-hold
//   because of the peekBits()'s look ahead. we set it to NonStop mode and finish it off.
//
//*****************************************************************************************

WMARESULT audecFlush (CAudioObjectDecoder* paudec, 
                    U8*  pbDst, 
                    Int  cbDstLength,
                    Int* pcbDstUsed,
                    U8*  pbEqu,
                    Int  cbEquLength,
                    Int* pcbEquUsed,
                    U32* pcSamplesFromBefore)
{
    WMARESULT hr = WMA_OK;
    Int     cbSrcUsed;
    U32     cSamplesPrevPacket = 0;

    assert (pbDst != NULL);
    assert (pcbDstUsed != NULL);

#if defined(WMA_TARGET_X86) && !(defined(BUILD_INTEGER) || defined(UNDER_CE) || defined(_Embedded_x86))
    // This function may use the FFT. Therefore, on every call to this function,
    // we must check if the current thread has been initialized to use the Intel FFT.
    // This is because under the DMO, the thread which decoded may not be the
    // thread that does the flushing.
    if (paudec->pau->m_fIntelFFT)
        auInitIntelFFT(paudec->pau, INTELFFT_INIT_THREAD);
#endif // defined(WMA_TARGET_X86) && !(defined(BUILD_INTEGER) || defined(UNDER_CE))

    if (pcSamplesFromBefore != NULL)
        *pcSamplesFromBefore = cSamplesPrevPacket;
    if (pcbDstUsed != NULL)
        *pcbDstUsed = 0;
    if (pcbEquUsed != NULL)
        *pcbEquUsed = 0;

    paudec->m_ibstrm.ibstrmpfnPeekBits = ibstrmPeekBitsNonStop;

    if (paudec->pau->m_fAllowSuperFrame) {
        if (!paudec->m_fPacketLoss && 0 != paudec->m_cFrmInPacket)  
        {
            hr = prvDecodePacket (paudec, 
                                  NULL,
                                  0,
                                  &cbSrcUsed,
                                  pbDst,
                                  cbDstLength,
                                  pcbDstUsed,
                                  pbEqu,
                                  cbEquLength,
                                  pcbEquUsed,
                                  (I32 *)&cSamplesPrevPacket);

            if (pcSamplesFromBefore != NULL)
                *pcSamplesFromBefore = cSamplesPrevPacket;

            assert (*pcbDstUsed <= cbDstLength);
            if (*pcbDstUsed > cbDstLength)
                hr = TraceResult(WMA_E_BUFFEROVERFLOW);
        }
    }
    else                //don't do anything
        *pcbDstUsed = 0;

    audecReset(paudec);

    return hr;
} // audecFlush


//*****************************************************************************************
//
// audecNew
//   create and initialize a CAudioObjectDecoder object
//
//*****************************************************************************************
CAudioObjectDecoder* audecNew (void *pMemBuf, const I32 iMemBufSize)
{
    CAudioObjectDecoder* paudec;

    auMallocSetState(MAS_ALLOCATE, pMemBuf, iMemBufSize);
    paudec = (CAudioObjectDecoder*) auMalloc (sizeof (CAudioObjectDecoder));
    if(paudec == NULL)
    {
        TraceResult(WMA_E_OUTOFMEMORY);
        return paudec;
    }

    paudec->pau = NULL;
    paudec->m_fPacketLoss = WMAB_FALSE;
    paudec->m_cFrmInPacket = 0;
    paudec->m_pbSrcCurr = NULL;
    paudec->m_cbSrcCurrLength = 0; 
    paudec->m_decsts = BEGIN_PACKET;
    paudec->m_subfrmdecsts = SUBFRM_HDR;
    paudec->m_hdrdecsts = HDR_SIZE;
    paudec->m_rlsts = VLC;
    paudec->m_iChannel = 0;
    paudec->m_iBand = 0;
    paudec->m_fNoMoreData = WMAB_FALSE;
    paudec->m_fLastSubFrame = WMAB_TRUE;
    memset(&paudec->m_ibstrm, 0, sizeof(paudec->m_ibstrm));
    paudec->m_rgiRunEntry44ssQb = NULL;
    paudec->m_rgiLevelEntry44ssQb = NULL;
    paudec->m_rgiRunEntry44smQb = NULL;
    paudec->m_rgiLevelEntry44smQb = NULL;
    paudec->m_rgiRunEntry44ssOb = NULL;
    paudec->m_rgiLevelEntry44ssOb = NULL;
    paudec->m_rgiRunEntry44smOb = NULL;
    paudec->m_rgiLevelEntry44smOb = NULL;
    paudec->m_rgiRunEntry16ssOb = NULL;
    paudec->m_rgiLevelEntry16ssOb = NULL;
    paudec->m_rgiRunEntry16smOb = NULL;
    paudec->m_rgiLevelEntry16smOb = NULL;
#if defined(UNDER_CE) && defined(_ARM_)
    paudec->lPrivate1 = 0;
    paudec->lPrivate2 = 0;
#endif //defined(UNDER_CE) && defined(_ARM_)
#ifdef ENABLE_EQUALIZER
    memset(&paudec->m_rgfltEqBandWeight, 0, sizeof(paudec->m_rgfltEqBandWeight));
    memset(&paudec->m_rgwEqBandBoundary, 0, sizeof(paudec->m_rgwEqBandBoundary));
    paudec->m_cEqBand = 0;
    paudec->m_fNoEq = WMAB_TRUE; 
    memset(&paudec->m_rgbBandPower, 0, sizeof(paudec->m_rgbBandPower));
    paudec->m_fComputeBandPower = WMAB_FALSE;
    paudec->m_iEqFrameSize = 0;
#endif // ENABLE_EQUALIZER
#if defined(SEEK_DECODE_TEST)
    paudec->m_pSaveRandState = NULL;
#endif  // defined(SEEK_DECODE_TEST)
    paudec->m_pfnDecodeSubFrame = NULL;
    paudec->m_pfnDecodeCoefficient = NULL;
    
    return paudec;
}


//*****************************************************************************************
//
// audecInit
//   initialize a CAudioObjectDecoder for parameters from input file or stream
//
//*****************************************************************************************
WMARESULT audecInit (CAudioObjectDecoder* paudec, 
                   Int iVersionNumber,
                   Int cSubband, 
                   Int iSamplingRate, 
                   U16 cChannel, 
                   Int cBytePerSec, 
                   Int cbPacketLength,
                   U16 wEncodeOpt,
                   U16 wPlayerOpt,
                   PFNGETMOREDATA pfnGetMoreData,
                   U32 dwUserData,
                   I32 *piMemUsed)
{
    Float fltBitsPerSample = 0.0F;
    CAudioObject* pau = paudec->pau;
    WMARESULT   wmaResult = WMA_OK;

    if (pau == NULL)
        paudec->pau = pau = auNew ();

    // Fill in function ptrs with decoder fns
    pau->aupfnGetNextRun = prvGetNextRunDEC;

    if (pau->m_codecStatus == CODEC_BEGIN)
        goto exit;

    //wchen: in the future we should use the one directly from the bitstream.
    //but for now the one in the bistream doesn't represent Sample/Frame
    //instead it represents Sample/Raw Packet that is useless for the decoder
    //other than serving the stupidity in the V4RTM decoder. We can't change the format for now.
    //but it should be changed to reprsent Sample/Frame and that should nullify the following function call.
    cSubband = msaudioGetSamplePerFrame (iSamplingRate, cBytePerSec * 8, cChannel, iVersionNumber);

    TRACEWMA_EXIT(wmaResult, auInit (pau, iVersionNumber, cSubband, iSamplingRate, 
        cChannel, cBytePerSec, cbPacketLength, wEncodeOpt, wPlayerOpt));

    auInitPcInfoDEC (pau);

    if (cChannel == 1)
        paudec->m_pfnDecodeCoefficient = &prvDecodeCoefficientMono;
    else
        paudec->m_pfnDecodeCoefficient = &prvDecodeCoefficientStereo;

#ifdef ENABLE_EQUALIZER
    wmaResult = audecResetEqualizer(paudec);
    TraceError(wmaResult);
#endif //ENABLE_EQUALIZER

    ibstrmInit (&paudec->m_ibstrm, pau->m_fAllowSuperFrame);
    ibstrmSetOwner (&paudec->m_ibstrm, (U32)paudec); 

    if (NULL == pfnGetMoreData)
    {
        // Set us up for non-streaming mode
        assert(0 == dwUserData); // We ignore user-supplied data in non-streaming mode
        pfnGetMoreData = prvWMAGetMoreData;
        dwUserData = (U32)paudec;
    }

    ibstrmSetGetMoreData (&paudec->m_ibstrm, pfnGetMoreData);
    ibstrmSetUserData (&paudec->m_ibstrm, (U32)dwUserData); //need to change for real streaming mode

    if (pau->m_fAllowSuperFrame)
        paudec->m_ibstrm.ibstrmpfnPeekBits = ibstrmPeekBits;
    else
        paudec->m_ibstrm.ibstrmpfnPeekBits = ibstrmPeekBitsNonStop;

    if (pau->m_iEntropyMode == SIXTEENS_OB)   {
        pau->m_rgpcinfo [0].m_rgiHuffDecTbl = g_rgiHuffDecTbl16smOb;
        pau->m_rgpcinfo [0].m_rgiRunEntry   = gRun16smOb;
        pau->m_rgpcinfo [0].m_rgiLevelEntry = gLevel16smOb;
    }
#ifdef ENABLE_ALL_ENCOPT
    else if (pau->m_iEntropyMode == FOURTYFOURS_QB)   {
        pau->m_rgpcinfo [0].m_rgiHuffDecTbl = g_rgiHuffDecTbl44smQb; 
        pau->m_rgpcinfo [0].m_rgiRunEntry   = gRun44smQb; 
        pau->m_rgpcinfo [0].m_rgiLevelEntry = gLevel44smQb;
    }
    else if (pau->m_iEntropyMode == FOURTYFOURS_OB)   {
        pau->m_rgpcinfo [0].m_rgiHuffDecTbl = g_rgiHuffDecTbl44smOb; 
        pau->m_rgpcinfo [0].m_rgiRunEntry   = gRun44smOb; 
        pau->m_rgpcinfo [0].m_rgiLevelEntry = gLevel44smOb;
    }
#endif // ENABLE_ALL_ENCOPT
    else {
        assert (WMAB_FALSE);
        wmaResult = TraceResult(WMA_E_INVALIDARG);
        goto exit;
    }

    //init subfrm configration
    pau->m_subfrmconfigPrev.m_cSubFrame = 1;
    pau->m_subfrmconfigPrev.m_rgiSubFrameSize [0]  = pau->m_cFrameSampleHalf;
    pau->m_subfrmconfigPrev.m_rgiSubFrameStart [0] = 0;
    pau->m_subfrmconfigPrev.m_iFirstTransientSubFrm = -1;
    pau->m_subfrmconfigPrev.m_iLastTransientSubFrm  = -1;
    memcpy (&pau->m_subfrmconfigCurr, &pau->m_subfrmconfigPrev, sizeof (SubFrameConfigInfo));
    memcpy (&pau->m_subfrmconfigNext, &pau->m_subfrmconfigPrev, sizeof (SubFrameConfigInfo));

    pau->m_codecStatus = CODEC_BEGIN;
    pau->m_iPacketCurr = -2;                // force a Packet Loss to begin

#if 0
    {   Int i;
        // Initialize quant step table
        for (i = 0; i < ARRAY_SIZE(paudec->m_rgiQuantStepFract); i++)
        {
            paudec->m_rgiQuantStepFract[i] = (UInt)(pow(10, (Float)(i + 1) / QUANTSTEP_DENOMINATOR) *
                (1 << QUANTSTEP_FRACT_BITS));
        }
    }
#endif  // 0

    if (pau->m_iWeightingMode == LPC_MODE || pau->m_fNoiseSub)
    {
        //low rate or mid rate
        paudec->m_pfnDecodeSubFrame = prvDecodeSubFrame;
    }
    else
    {
        //high rate
        paudec->m_pfnDecodeSubFrame = prvDecodeSubFrameHighRate;
    }

#ifdef BITRATE_REPORT
    printf("Fr#\tSubF#\tTime\tPCM\tSF Bits\tSF Bitr\tFr Bits\tFr Bitrate\n");
    printf("---\t-----\t----\t---\t-------\t-------\t-------\t----------\n");
#endif   // BITRATE_REPORT

    if (NULL != piMemUsed)
        *piMemUsed = auMallocGetCount();

    auMallocSetState(MAS_LOCKED, NULL, 0);

    if (pau->m_iWeightingMode != BARK_MODE)
    {
        assert(prvInverseQuantizeLowRate == pau->aupfnInverseQuantize);
        pau->aupfnCalcSqrtBWRatio = prvCalcSqrtBWRatioDEC;
    }

exit:
    return wmaResult;
}


//*****************************************************************************************
//
// auInitPcInfoDEC
//
//*****************************************************************************************
Void auInitPcInfoDEC (CAudioObject* pau)
{
    I16 i;
    const U16 c_iSizeOfPrevOutput = (U16) DOUBLE(pau->m_fPad2XTransform,pau->m_cFrameSampleHalf) ;
    I16* piSignBase = pau->m_piPrevOutput + c_iSizeOfPrevOutput * pau->m_cChannel;
    for (i = 0; i < pau->m_cChannel; i++)
    {
        PerChannelInfo* ppcinfo = pau->m_rgpcinfo + i;

//      memset(ppcinfo->m_rgfltMask, 0, sizeof(ppcinfo->m_rgfltMask));
        ppcinfo->m_rgiCoefQ = NULL;
        ppcinfo->m_rgiMaskQ = pau->m_rgiMaskQ + pau->m_cValidBarkBand * i;
        ppcinfo->m_rgiHuffDecTbl = NULL;
        ppcinfo->m_rgiRunEntry = NULL;
        ppcinfo->m_rgiLevelEntry = NULL;
        ppcinfo->m_cSubbandActual = pau->m_cHighCutOff - pau->m_cLowCutOff;
        ppcinfo->m_iPower = 0;
        ppcinfo->m_iActualPower = 0;

        //ppcinfo->m_rgiWeightFactor: initialized below
        ppcinfo->m_rgiCoefRecon = pau->m_rgiCoefReconOrig + DOUBLE(pau->m_fPad2XTransform,
            pau->m_cSubband) * i;

        ppcinfo->m_iMaxMaskQ = 0;
        ppcinfo->m_iCurrGetPCM_SubFrame = (I16) pau->m_cSubFrameSampleHalfAdjusted;

        ppcinfo->m_rgiCoefReconCurr = ppcinfo->m_rgiCoefRecon + pau->m_cSubbandAdjusted /2;
        ppcinfo->m_piPrevOutput = pau->m_piPrevOutput + i;
        ppcinfo->m_piPrevOutputSign = piSignBase + i * (c_iSizeOfPrevOutput /
            BITS_PER_BYTE / sizeof (I16)); //non 17bit shouldn't use this pointer at all
        ppcinfo->m_piPrevOutputCurr = ppcinfo->m_piPrevOutput;

        ppcinfo->m_iSin = 0;
        ppcinfo->m_iCos = 0;
        ppcinfo->m_iSin1 = 0;
        ppcinfo->m_iCos1 = 0;
        ppcinfo->m_iStep = 0;

        ppcinfo->m_rgfltCoefRecon = (Float *)(ppcinfo->m_rgiCoefRecon); //This will soon be removed
    
        //ppcinfo->m_rgfltWeightFactor: initialized below
        ppcinfo->m_wtMaxWeight = 0; // Currently always used because LPC not integerized at encoder
    
        if (pau->m_iWeightingMode == LPC_MODE)
        { // LPC
            ppcinfo->m_rguiWeightFactor = pau->m_rguiWeightFactor + DOUBLE(pau->m_fPad2XTransform,pau->m_cSubband) * i;
            ppcinfo->m_rgfltWeightFactor = (float*)(pau->m_rguiWeightFactor + DOUBLE(pau->m_fPad2XTransform,pau->m_cSubband) * i);
        } else 
        {
            ppcinfo->m_rguiWeightFactor =(U32*) pau->m_rgpcinfo [i].m_rgiMaskQ;
            ppcinfo->m_rgfltWeightFactor = (float*)(pau->m_rgpcinfo [i].m_rgiMaskQ);
        }

        ppcinfo->m_rgbBandNotCoded = NULL;
        ppcinfo->m_rgffltSqrtBWRatio = NULL;
        ppcinfo->m_rgiNoisePower = NULL;
        ppcinfo->m_rgfltBandWeight = NULL;
#ifdef ENABLE_ALL_ENCOPT
        //set up default pcinfo for noise sub
        pau->m_rgpcinfo [i].m_rgbBandNotCoded   = pau->m_rgbBandNotCoded   + pau->m_cValidBarkBand * i;
        pau->m_rgpcinfo [i].m_rgffltSqrtBWRatio = pau->m_rgffltSqrtBWRatio + pau->m_cValidBarkBand * i;
        pau->m_rgpcinfo [i].m_rgiNoisePower     = pau->m_rgiNoisePower     + pau->m_cValidBarkBand * i;
#ifndef BUILD_INTEGER
        pau->m_rgpcinfo [i].m_rgfltBandWeight   = pau->m_rgfltBandWeight   + pau->m_cValidBarkBand * i;
#endif
#endif

        pau->m_rgpcinfo [i].ppcinfoENC = NULL;
    } // for
}

WMARESULT audecReset (CAudioObjectDecoder *paudec)
{
    CAudioObject* pau;
    if (paudec == NULL)
        return WMA_OK;
    pau = paudec->pau;

    //since a packet loss will be forced; the following are already being done there
#if 0
    for (i = 0; i < pau->m_cChannel; i++)
    {
        PerChannelInfo* ppcinfo = pau->m_rgpcinfo + i;
        ppcinfo->m_iCurrGetPCM_SubFrame = (I16) pau->m_iCoefRecurQ3;
    }

    if ( pau->m_piPrevOutput != NULL )
    {
        const int c_iSizeOfPrevOutput = sizeof (I16) * DOUBLE(pau->m_fPad2XTransform,pau->m_cFrameSampleHalf) * pau->m_cChannel;
#       ifndef PREVOUTPUT_16BITS
            const int c_iSizeOfPrevOutputSign = DOUBLE(pau->m_fPad2XTransform,pau->m_cFrameSampleHalf) * pau->m_cChannel / BITS_PER_BYTE + pau->m_cChannel*sizeof(I16);
#       else 
            const int c_iSizeOfPrevOutputSign = 0;
#       endif
        memset (pau->m_piPrevOutput, 0, c_iSizeOfPrevOutput + c_iSizeOfPrevOutputSign);
    }
#endif

    //this is not needed anymore
    //if we set packetheader to 0, meaning whatever left in the current packet
    //will be discarded by decodeInfo(). We just have to make sure
    //decodeInfo() gets called right after this. But it has to be since we are forcing
    //a packet loss situation.


	//to suppress packet loss check
    ibstrmReset(&paudec->m_ibstrm);
    ibstrmSetPacketHeader(&paudec->m_ibstrm, 0);

    // During a flush (eg, end-of-file), we use ibstrmPeekBitsNonStop. To start playing
    // at the start of a file once more, we need to reset to ibstrmPeekBitsNonStop.
    if (pau->m_fAllowSuperFrame)
        paudec->m_ibstrm.ibstrmpfnPeekBits = ibstrmPeekBits;
    else
        paudec->m_ibstrm.ibstrmpfnPeekBits = ibstrmPeekBitsNonStop;

    //unlock ourself because there is an error already
    //wouldn't continue to decode the frame, making sure decodeInfo will be called
    if (pau->m_codecStatus == CODEC_ONHOLD)
    {
        pau->m_codecStatus = CODEC_STEADY;
    }

    //== to codec begin
    pau->m_iPacketCurr = -2;        //make sure we see a packet loss

    return WMA_OK;
}

U32 prvOutputBufferSize(Bool fAllowSuperFrame, Int cSamplesPerFrame, Int cChannels) {
  return sizeof (I16) * ( fAllowSuperFrame ? 32 : 1 )
                      * cSamplesPerFrame * cChannels;

}

U32 audecOutputBufferSize(Int iVersion, Int iSamplingRate, Int cChannels, Int cBytesPerSec, U16 wEncodeOpt) {
  return prvOutputBufferSize(!!(wEncodeOpt & ENCOPT_SUPERFRAME),
                             msaudioGetSamplePerFrame (iSamplingRate,
                                                       cBytesPerSec * 8,
                                                       cChannels,
                                                       iVersion),
                             cChannels);
}

//*****************************************************************************************
//
// audecDecode
//   decode a frame or subframe
//
//*****************************************************************************************
WMARESULT audecDecode (CAudioObjectDecoder* paudec, 
                     const U8* pbSrc,
                     Int       cbSrcLength,
                     Int*      pcbSrcUsed,
                     U8*       pbDst,
                     Int       cbDstLength,
                     Int*      pcbDstUsed,
                     U8*       pbEqu,
                     Int       cbEqu,
                     Int*      pcbEquUsed,
                     I32*      pcSamplesFromBefore)
{   
    WMARESULT hr;
    Int cbRawPacket;
    Int cbSrcUsed; 
    Int cbDstUsed;
    Int cbEquUsed;
    Int cbEquRemaining;
    Int cSamplesPrevPacket = 0;
    Bool fFirstPacket = WMAB_TRUE;
    CAudioObject* pau = paudec->pau;
#ifdef PROFILE
    //FunctionProfile fp;
    //FunctionProfileStart(&fp,DECODE_PROFILE);
#endif

    assert (pbSrc != NULL && pcbSrcUsed != NULL && pbDst != NULL && pcbDstUsed != NULL);
    if (pbSrc == NULL || pcbSrcUsed == NULL || pbDst == NULL || pcbDstUsed == NULL)
        return TraceResult(WMA_E_INVALIDARG);

    if (cbSrcLength <= 0) {  //nothing to decode
        *pcbDstUsed   = 0;
        hr = WMA_OK;
        goto exit;
    }

    cbRawPacket = prvOutputBufferSize(pau->m_fAllowSuperFrame, pau->m_cFrameSampleHalfAdjusted, pau->m_cChannel);
    
    *pcbSrcUsed = 0;
    *pcbDstUsed = 0;
    if (NULL != pcbEquUsed)
        *pcbEquUsed = 0;

    cbEquRemaining = cbEqu;
    hr = WMA_OK;
    while (WMAB_TRUE)    {
        if ((cbSrcLength - *pcbSrcUsed) * BITS_PER_BYTE < pau->m_cBitPacketLength ||
            (cbDstLength - *pcbDstUsed) < cbRawPacket)      //this is to be safe, usually less than cbRawPacket is needed
            break;

        hr = prvDecodePacket  (paudec,
                               pbSrc, 
                               pau->m_cBitPacketLength/BITS_PER_BYTE, 
                               &cbSrcUsed,
                               pbDst, 
                               cbDstLength - *pcbDstUsed, 
                               &cbDstUsed,
                               pbEqu,
                               cbEquRemaining,
                               &cbEquUsed, 
                               &cSamplesPrevPacket);

        //first time
        if (fFirstPacket && pcSamplesFromBefore != NULL)
        {
            *pcSamplesFromBefore = cSamplesPrevPacket;
            fFirstPacket = WMAB_FALSE;
        }

        assert (cbSrcUsed == pau->m_cBitPacketLength/BITS_PER_BYTE);
        pbSrc       += cbSrcUsed;
        *pcbSrcUsed += cbSrcUsed;

        CHECKWMA_EXIT(hr);

        assert (cbDstUsed <= cbRawPacket);
        pbDst       += cbDstUsed;
        *pcbDstUsed += cbDstUsed;

        if (NULL != pbEqu)
        {
            pbEqu       += cbEquUsed;
            cbEquRemaining -= cbEquUsed;
            if (NULL != pcbEquUsed)
                *pcbEquUsed += cbEquUsed;
        }
        
    }
exit:
#ifdef PROFILE
    //FunctionProfileStop(&fp);
#endif

    return hr;
}

#if defined(_DEBUG)
static int iSampleTotal = 0;
#endif

//*****************************************************************************************
//
// prvDecodePacket
//
//*****************************************************************************************
WMARESULT prvDecodePacket (CAudioObjectDecoder* paudec, 
                         const  U8*           pbSrc,
                         Int                  cbSrcLength,
                         Int*                 pcbSrcUsed,
                         U8*                  pbDst,
                         Int                  cbDstLength,
                         Int*                 pcbDstUsed,
                         U8*                  pbEqu,
                         Int                  cbEquLength,
                         Int*                 pcbEquUsed,
                         I32*                 pcSamplesPrevPacket)
{
    WMARESULT hr;
    Int cbRawFrame;
    U16 cSampleDecoded = 0;
    CAudioObject* pau = paudec->pau;
    Int cIteration = 0;
    Bool fDoDecode = WMAB_TRUE;
#ifdef PROFILE
    //FunctionProfile fp;
#endif

    assert(pcbSrcUsed != NULL && pbDst != NULL && pcbDstUsed != NULL);
    assert(paudec->m_ibstrm.m_pfnGetMoreData == prvWMAGetMoreData); // non-streaming mode MUST use the std fn
    assert(paudec->m_ibstrm.m_dwUser == (U32)paudec);

    if (pcbSrcUsed == NULL || pbDst == NULL || pcbDstUsed == NULL)
        return TraceResult(WMA_E_INVALIDARG);

    *pcbSrcUsed = *pcbDstUsed = 0;
    *pcSamplesPrevPacket = 0;
    cbRawFrame = pau->m_cFrameSampleHalfAdjusted * sizeof (I16) * pau->m_cChannel;

    // Verify that we have enough space in destination for worst-case scenario
    if ((paudec->pau->m_fAllowSuperFrame && cbDstLength < 16 * cbRawFrame) ||
        (WMAB_FALSE == paudec->pau->m_fAllowSuperFrame && cbDstLength < cbRawFrame))
        return TraceResult(WMA_E_BUFFEROVERFLOW);

#if defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)
    if ( pau->m_fUpsample || pau->m_fPad2XTransform )
        cbRawFrame *= 2;    
#endif

#ifdef PROFILE
    //FunctionProfileStart(&fp,DECODE_PACKET_PROFILE);
#endif

    *pcbSrcUsed = 0;
    *pcbDstUsed = 0;
    if (NULL != pcbEquUsed)
        *pcbEquUsed = 0;

    //to be used by getMoreData
    paudec->m_pbSrcCurr = (U8*) pbSrc; 
    paudec->m_cbSrcCurrLength = (U16) min (cbSrcLength, paudec->pau->m_cBitPacketLength/BITS_PER_BYTE); 
   
    while (fDoDecode)
    {
        switch (pau->m_codecStatus)
        {
        case CODEC_BEGIN:
        case CODEC_STEADY:
            //only flush will call with null,but, in which case it goes to on-hold directly
            if (pbSrc == NULL || cbSrcLength <= 0)
            {
                hr = TraceResult(WMA_E_INVALIDARG);
                goto exit;
            }

            TRACEWMA_EXIT (hr, audecDecodeInfo (paudec));
            *pcSamplesPrevPacket = *pcbDstUsed / pau->m_cChannel / sizeof (I16);
            fDoDecode = WMAB_FALSE;

#           if defined(WMA_SHOW_FRAMES) && defined(_DEBUG)
            prvWmaShowFrames(paudec->pau, "\nDecPkt2", " %1d ", 
                paudec->m_cFrmInPacket );
#           endif

        case CODEC_ONHOLD:
            // If no superframes, WMA_S_NO_MORE_SRCDATA always happens at the end of
            // each frame and should constitute an exit condition. If superframes,
            // WMA_S_NO_MORE_SRCDATA should not exit this loop or we may not decode
            // last frame.
            while (WMAB_TRUE) 
            {
                HEAP_DEBUG_CHECK;
                hr = audecDecodeData (paudec, &cSampleDecoded);
                HEAP_DEBUG_CHECK;

                if (hr == WMA_E_ONHOLD)
                {
                    //remembers it
                    pau->m_codecStatus = CODEC_ONHOLD; 
                    //map it to okay
                    TraceResult (hr = WMA_OK);
                    goto exit;
                }
                else if (hr == WMA_E_BROKEN_FRAME)
                {
                    audecReset (paudec);
                    TraceResult (hr = WMA_OK);
                    goto exit;  //bits will be advanced
                }
                else if (hr == WMA_E_LOSTPACKET)
                {
                    TraceResult (hr = WMA_OK);
                    break;      //try it again will call decodeInfo next round
                }

                CHECKWMA_EXIT(hr);

#               if defined(WMA_SHOW_FRAMES) && defined(_DEBUG)
                prvWmaShowFrames(pau, "GetPCM2", " %4d 0x%08x %6d     @%8d",
                    cSampleDecoded, pbDst, cbDstLength - *pcbDstUsed, iSampleTotal);
#               endif

                HEAP_DEBUG_CHECK;
                audecGetPCM (paudec, &cSampleDecoded, pbDst, cbDstLength - *pcbDstUsed);
                HEAP_DEBUG_CHECK;

#               if defined(_DEBUG)
                assert(pau->m_rgpcinfo[0].m_iCurrGetPCM_SubFrame >= pau->m_iCoefRecurQ3);
                iSampleTotal += cSampleDecoded;
#               endif
                cSampleDecoded *= sizeof (I16) * paudec->pau->m_cChannel; //in bytes
                //when seeking, we can return the 1st half of the subframe
                //whose begining the packet timestamp points to 
                //we use this negative number as a workaround
                if (pau->m_fSeekAdjustment && pau->m_fAllowSuperFrame)
                {
                    *pcSamplesPrevPacket -= (pau->m_iCoefRecurQ2 - pau->m_iCoefRecurQ1);
                    pau->m_fSeekAdjustment = WMAB_FALSE;
                }

                pbDst           += cSampleDecoded;
                *pcbDstUsed     += cSampleDecoded;
                assert (*pcbDstUsed <= cbDstLength);
                if (*pcbDstUsed > cbDstLength)          //out of space
                {
                    //FUNCTION_PROFILE_STOP(&fp);
                    return TraceResult(WMA_E_BUFFEROVERFLOW);
                }
#ifdef ENABLE_EQUALIZER        
                if (paudec->m_fLastSubFrame)    
                {
                    if (NULL != pbEqu && paudec->m_fComputeBandPower) 
                    {
                        Int cbEquUsedFrame = sizeof (I8) * MAX_NO_EQBAND;
                        memcpy (pbEqu, paudec->m_rgbBandPower, cbEquUsedFrame);
                        pbEqu       += cbEquUsedFrame;
                        cbEquLength -= cbEquUsedFrame;
                        if (NULL != pcbEquUsed)
                            *pcbEquUsed += cbEquUsedFrame;
                    }
                }
#endif

                if (cIteration > pau->m_iMaxSubFrameDiv * 0x0F)
                    return TraceResult(WMA_E_BROKEN_FRAME);              //never overflow the stack
                else 
                {
                    cIteration++;
                    if (hr == WMA_S_NO_MORE_FRAME)
                        break;
                }
            }
            pau->m_codecStatus = CODEC_STEADY;
        }
    }

exit:
    // always tell them to give us the next packet.
    *pcbSrcUsed = pau->m_cBitPacketLength/BITS_PER_BYTE;

    //FUNCTION_PROFILE_STOP(&fp);
    HEAP_DEBUG_CHECK;
    return hr;
}

//*****************************************************************************************
//
// audecDecodeInfo
//
//*****************************************************************************************
WMARESULT audecDecodeInfo (CAudioObjectDecoder* paudec)
{   
    Int iPacketCurr;
    Int cBitLeftOver = 0;
    Int cBitLs, cBitRs;
    WMARESULT   wmaResult = WMA_OK;

    paudec->m_decsts = BEGIN_PACKET;
    paudec->m_fPacketLoss = WMAB_FALSE;
    paudec->m_cFrmInPacket = 1;

    if (paudec->pau->m_fAllowSuperFrame) 
    {
        //no left over
        while(ibstrmGetPacketHeader(&paudec->m_ibstrm) == 0) 
        {
            U32         iBufLen;

            ibstrmReset(&paudec->m_ibstrm);
            TRACEWMA_EXIT(wmaResult, ibstrmGetMoreData(&paudec->m_ibstrm, &iBufLen));

            if(paudec->m_fNoMoreData)
            {
                //wmaResult = WMA_S_NO_MORE_SRCDATA;
                //theoretically we can be on-hold but not tested as apps don't do this
                wmaResult = WMA_E_ONHOLD;
                goto exit;
            }
        }

        cBitLs = 0;
        cBitRs = (BITS_PER_DWORD - NBITS_PACKET_CNT);
        iPacketCurr = ibstrmGetPacketHeader(&paudec->m_ibstrm) >> cBitRs;
        if (iPacketCurr - paudec->pau->m_iPacketCurr == 1 || 
            iPacketCurr - paudec->pau->m_iPacketCurr + (1 << NBITS_PACKET_CNT) == 1) {
            paudec->m_fPacketLoss = WMAB_FALSE;
        }
        else 
            paudec->m_fPacketLoss = WMAB_TRUE;
        paudec->pau->m_iPacketCurr = iPacketCurr;

        cBitLs = NBITS_FRM_CNT;
        cBitRs = BITS_PER_DWORD - NBITS_FRM_CNT;
        paudec->m_cFrmInPacket = (U16) ((ibstrmGetPacketHeader(&paudec->m_ibstrm) 
                                 << cBitLs) >> cBitRs);
        assert (paudec->m_cFrmInPacket < (1 << NBITS_FRM_CNT));

        cBitLs = NBITS_PACKET_CNT + NBITS_FRM_CNT;
        cBitRs = BITS_PER_DWORD - (paudec->pau->m_cBitPackedFrameSize + 3); 
        cBitLeftOver = (ibstrmGetPacketHeader(&paudec->m_ibstrm) << cBitLs) >> cBitRs;
        if (cBitLeftOver == 0) 
            ibstrmResetPacket(&paudec->m_ibstrm);
        ibstrmSetPacketHeader(&paudec->m_ibstrm, 0);
    }
    else 
    {
        Int iCurrPrevDiff;

        // We should only hit this on very first frame
        if (paudec->pau->m_iPacketCurr < 0)
        {
            assert(ibstrmGetPacketHeader(&paudec->m_ibstrm) == 0);
            paudec->pau->m_iPacketCurr = ibstrmGetPacketHeader(&paudec->m_ibstrm);
        }

        iCurrPrevDiff = ibstrmGetPacketHeader(&paudec->m_ibstrm) -
            paudec->pau->m_iPacketCurr;

        // Non-superframe mode can't really lose packets
        assert(iCurrPrevDiff >= 0 || iCurrPrevDiff <= 1 - NONSUPER_WRAPAROUND);
        assert(iCurrPrevDiff < 0 || iCurrPrevDiff <= 1);
        assert(iCurrPrevDiff >= 0 || NONSUPER_WRAPAROUND + iCurrPrevDiff <= 1);

        // If, while processing the last frame we loaded in the start of next frame,
        // cue bitstream pointer to start of next frame
        if (iCurrPrevDiff != 0)
            ibstrmResetPacket(&paudec->m_ibstrm);

        // Advance to next payload: discard data until we hit next frame
        while (ibstrmGetPacketHeader(&paudec->m_ibstrm) == (U32)paudec->pau->m_iPacketCurr)
        {
            U32 iBufLen;

            ibstrmReset(&paudec->m_ibstrm);
            TRACEWMA_EXIT(wmaResult, ibstrmGetMoreData(&paudec->m_ibstrm, &iBufLen));

            if(paudec->m_fNoMoreData)
            {
                //wmaResult = WMA_S_NO_MORE_SRCDATA;
                wmaResult = WMA_E_ONHOLD;
                goto exit;
            }
        }

        paudec->pau->m_iPacketCurr = ibstrmGetPacketHeader(&paudec->m_ibstrm);

        if(paudec->m_fNoMoreData)
        {
            //wmaResult = WMA_S_NO_MORE_SRCDATA;
            wmaResult = WMA_E_FAIL;
            goto exit;
        }
    }

#if defined(SEEK_DECODE_TEST)
    if (paudec->m_pSaveRandState != NULL ) {
        *paudec->m_pSaveRandState = paudec->pau->m_tRandState;
        paudec->m_pSaveRandState = NULL;
    }
#   endif // SEEK_DECODE_TEST

    if (paudec->m_fPacketLoss == WMAB_FALSE)
    {
        wmaResult = WMA_OK;
        goto exit;
    }
    else    {
        CAudioObject* pau = paudec->pau;
        I16 i;
        const int c_iSizeOfPrevOutput = sizeof (I16) * DOUBLE(pau->m_fPad2XTransform,pau->m_cFrameSampleHalf) * pau->m_cChannel;
#       ifndef PREVOUTPUT_16BITS
            const int c_iSizeOfPrevOutputSign = DOUBLE(pau->m_fPad2XTransform,pau->m_cFrameSampleHalf) * pau->m_cChannel / BITS_PER_BYTE + pau->m_cChannel*sizeof(I16);
#       else 
            const int c_iSizeOfPrevOutputSign = 0;
#       endif

        //packet loss or a broken frame earlier, seek to next complete frm
        while (cBitLeftOver > 24)   {
            TRACEWMA_EXIT(wmaResult, ibstrmFlushBits (&paudec->m_ibstrm, 24));
            cBitLeftOver -= 24;
        }
        TRACEWMA_EXIT(wmaResult, ibstrmFlushBits (&paudec->m_ibstrm, cBitLeftOver));

        for (i = 0; i < pau->m_cChannel; i++)
        {
            PerChannelInfo* ppcinfo = pau->m_rgpcinfo + i;
            ppcinfo->m_iCurrGetPCM_SubFrame = (I16) CURRGETPCM_INVALID;
        }

        if (pau->m_piPrevOutput != NULL)
            memset (pau->m_piPrevOutput, 0, c_iSizeOfPrevOutput + c_iSizeOfPrevOutputSign);

		//so that the 1st frame doesn't output anything
        pau->m_fPacketLossAdj = WMAB_TRUE;
        pau->m_fSeekAdjustment = WMAB_TRUE; //not relavent in streaming mode

        // Ignore packet loss, we're already set to deal with it
        wmaResult = WMA_OK; // WMA_BROKEN_FRAME;
        goto exit;
    }

exit:
    return wmaResult;
}

#ifdef BITRATE_REPORT
#define BITRATE_REPORT_VARS         Int cBitGet
#define BITRATE_REPORT_CHECKPT      cBitGet = g_cBitGet
#define BITRATE_REPORT_PRINT        PrintSubframeStats(pau, cBitGet)

Float g_fltRunningTime = 0;
Int g_cSubframeBits = 0;

void PrintSubframeStats(const CAudioObject *pau, const Int cBitGetCheckPt)
{
    Int iSubframePCM;
    Int iBitsInSubframe;
    Float fltSubframeTime;

    iSubframePCM = pau->m_cSubbandAdjusted;
    iBitsInSubframe = g_cBitGet - cBitGetCheckPt;
    fltSubframeTime = iSubframePCM / (float)pau->m_iSamplingRate;

    // Print frame number only for first subframe (helps with visual formatting)
    if (0 == pau->m_iCurrSubFrame)
        printf("%d\t", pau->m_iFrameNumber);
    else
        printf("\t");

    // Print subframe stats
    printf("%d\t%6.3f\t%4d\t%6d\t%7.0f", pau->m_iCurrSubFrame,
        g_fltRunningTime, iSubframePCM, iBitsInSubframe,
        iBitsInSubframe / fltSubframeTime);

    g_fltRunningTime += fltSubframeTime;
    g_cSubframeBits += iBitsInSubframe;

    // If last subframe in frame, print frame summary
    if (pau->m_iCurrSubFrame + 1 >= pau->m_subfrmconfigCurr.m_cSubFrame)
    {
        const Float fltFrameTime = (float)(2048.0 / pau->m_iSamplingRate);
        printf("\t%6d\t%7.0f\n", g_cSubframeBits, g_cSubframeBits / fltFrameTime);
        g_cSubframeBits = 0;
    }
    else
        printf("\n");
}
#else    // BITRATE_REPORT
#define BITRATE_REPORT_VARS
#define BITRATE_REPORT_CHECKPT
#define BITRATE_REPORT_PRINT
#endif  // BITRATE_REPORT

//*****************************************************************************************
//
// audecDecodeData
//
//*****************************************************************************************
WMARESULT audecDecodeData (CAudioObjectDecoder* paudec, U16* pcSampleReady)
{
    CAudioObject* pau = paudec->pau;
    PerChannelInfo* ppcinfo = pau->m_rgpcinfo;
    WMARESULT hr = WMA_OK;
    I16 iChannel;
    Int cBitUsed = 0;
    U32 iBufLen;

#ifdef PROFILE
    //FunctionProfile fp;
    //FunctionProfileStart(&fp,AUDEC_DECODE_DATA_PROFILE);
#endif

#if defined(WMA_TARGET_X86) && !(defined(BUILD_INTEGER) || defined(UNDER_CE) || defined(_Embedded_x86))
    // This function may use the FFT. Therefore, on every call to this function,
    // we must check if the current thread has been initialized to use the Intel FFT.
    // This is because under the DMO, the thread which initialized us may not be the
    // thread that does the decoding.
    if (pau->m_fIntelFFT)
        auInitIntelFFT(pau, INTELFFT_INIT_THREAD);
#endif // defined(WMA_TARGET_X86) && !(defined(BUILD_INTEGER) || defined(UNDER_CE))

    *pcSampleReady = 0;
    //if we are being resumed, we need to get the new data
    if (paudec->m_fNoMoreData)
        TRACEWMA_EXIT(hr, ibstrmGetMoreData(&paudec->m_ibstrm, &iBufLen));

    while(1)
    {
        BITRATE_REPORT_VARS;
        switch (paudec->m_decsts)
        {
            case BEGIN_SUBFRAME :
                if (!paudec->m_fLastSubFrame) 
                {                   
                    for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++)
                    {
                        ppcinfo = pau->m_rgpcinfo + iChannel;
                        if (!(ppcinfo->m_iCurrGetPCM_SubFrame==pau->m_iCoefRecurQ3 || ppcinfo->m_iCurrGetPCM_SubFrame>=pau->m_iCoefRecurQ4))
                            CHECKWMA_EXIT( hr = WMA_E_BROKEN_FRAME );

                        HEAP_DEBUG_CHECK;
                        hr = auSaveHistoryMono (pau, ppcinfo, WMAB_FALSE);
                        HEAP_DEBUG_CHECK;

                        // Effectively disable GetPCM in case we find broken frame or packet
                        // (stupid caller maps WMA_E_LOSTPACKET to WMA_OK and therefore
                        // will try to retrieve the PCM, in which case we must return nothing)
                        pau->m_rgpcinfo[iChannel].m_iCurrGetPCM_SubFrame = CURRGETPCM_INVALID;
                    }

                    BITRATE_REPORT_CHECKPT;
                    paudec->m_decsts = DECODE_SUBFRAME; 
                    paudec->m_subfrmdecsts = SUBFRM_HDR;
                    paudec->m_hdrdecsts = HDR_SIZE;
                    paudec->m_iChannel = 0;  
                    paudec->m_iBand = 0;     

                }
                else 
                    paudec->m_decsts = END_SUBFRAME2;

            case DECODE_SUBFRAME :
                TRACEWMA_EXIT(hr, (*(paudec->m_pfnDecodeSubFrame))(paudec, &cBitUsed));

                HEAP_DEBUG_CHECK;
                BITRATE_REPORT_PRINT;
                if (paudec->m_subfrmdecsts == SUBFRM_DONE)
                    paudec->m_decsts = END_SUBFRAME1;

            case END_SUBFRAME1 :
                auPreGetPCM (pau, pcSampleReady);
                paudec->pau->m_iCurrSubFrame++;

            case END_SUBFRAME2 :
                if (paudec->m_fLastSubFrame) 
                {
                    //take care the end of a frame
                    if (pau->m_fAllowSuperFrame)
                    {
                        //copy next subfrm config to curr
                        memcpy (&pau->m_subfrmconfigPrev, &pau->m_subfrmconfigCurr, sizeof (SubFrameConfigInfo));
                        memcpy (&pau->m_subfrmconfigCurr, &pau->m_subfrmconfigNext, sizeof (SubFrameConfigInfo));
                    }
                    paudec->m_cFrmInPacket--;
                    //start decoding the next frame
                    paudec->m_decsts = BEGIN_FRAME; 

                    if (paudec->m_cFrmInPacket <= 0)
                    {
                        hr = WMA_S_NO_MORE_FRAME;
                        goto exit;
                    }
                }
                else                    
                    paudec->m_decsts = BEGIN_SUBFRAME; //goto the start of next subfrm
                goto exit;

           case BEGIN_PACKET:

                paudec->pau->m_fHeaderReset = WMAB_TRUE;
                assert (paudec->pau->m_fAllowSuperFrame || (paudec->m_cFrmInPacket == 1));
                paudec->m_decsts = BEGIN_FRAME; 

           case BEGIN_FRAME:
                paudec->pau->m_iFrameNumber++;
                paudec->pau->m_iCurrSubFrame = 0;
                paudec->m_fLastSubFrame = WMAB_FALSE;

                paudec->m_decsts = BEGIN_SUBFRAME;
                if (paudec->m_cFrmInPacket == 0)
                {
                    hr = WMA_S_NO_MORE_FRAME;
                    goto exit;
                }
                break;
         }
    }

exit:
    //FUNCTION_PROFILE_STOP(&fp);
#if defined(WMA_SHOW_FRAMES) && defined(_DEBUG)
        prvWmaShowFrames(paudec->pau, "RetDecD", hr<0 ? " 0x%08x " : " %d ", hr );
#endif
    HEAP_DEBUG_CHECK;

    return hr;
}

WMARESULT audecGetPCM (CAudioObjectDecoder* paudec, U16* pcSampleReady, U8* pbDst, U32 cbDstLength)
{
    WMARESULT wmaResult = WMA_OK;
    
#if 0
    // *** TODO: Enable this code to enhance efficiency.
    // No PCM required (or available) when doing simple transcode
    if (TT_SIMPLE == paudec->pau->m_ttTranscodeType)
    {
        *pcSampleReady = 0;
        return WMA_OK;
    }
#endif

    //get pcm only when we are in these states
    if (paudec->m_decsts == BEGIN_FRAME || paudec->m_decsts == BEGIN_SUBFRAME)
        wmaResult = auGetPCM (paudec->pau, pcSampleReady, pbDst, cbDstLength);
    else
        *pcSampleReady = 0;         //we are in a state of error; don't return anything

#if defined(WMA_SHOW_FRAMES) && defined(_DEBUG)
    prvWmaShowFrames(paudec->pau, "RetGetP", wmaResult<0 ? " 0x%08x " : " %d ", wmaResult );
#endif
    return wmaResult;
}



//*****************************************************************************************
//
// prvDecodeSubFrame
//
//*****************************************************************************************
WMARESULT prvDecodeSubFrame (CAudioObjectDecoder* paudec, Int* piBitCnt)
{
    WMARESULT hr = WMA_OK;
    Int     i, iChannel;
    CAudioObject* pau = paudec->pau;
    CoefType     ctTemp0, ctTemp1;
    CoefType*    pctCoefRecon0;
    CoefType*    pctCoefRecon1;

#ifdef PROFILE
    //FunctionProfile fp;
    //FunctionProfileStart(&fp,DECODE_SUB_FRAME_PROFILE);
#endif

    switch (paudec->m_subfrmdecsts)
    {
        case SUBFRM_HDR :   
            TRACEWMA_EXIT(hr, prvDecodeFrameHeader (paudec, piBitCnt));
            if (paudec->m_hdrdecsts == HDR_DONE)
            {
                paudec->m_subfrmdecsts = SUBFRM_COEF;
                paudec->pau->m_iCurrReconCoef = 0;             //iRecon is offset by -1 so comarison 
                paudec->m_iChannel = 0;
                paudec->m_rlsts = VLC;

            }
            else
                break;

        case SUBFRM_COEF:
            TRACEWMA_EXIT(hr, (*(paudec->m_pfnDecodeCoefficient))(paudec, pau->m_rgpcinfo, piBitCnt));
            paudec->m_subfrmdecsts = SUBFRM_DONE;

        case SUBFRM_DONE:
            // WMA Timestamps: To detect start-of-stream and discard correct amount of silence,
            // we need to verify claim that m_iPower[*] = 1, ForceMaskUpdate and actual power = 0.
            // If m_rgiCoefQ is all 0, we will accept that as actual power = 0 even though it is
            // theoretically possible for actual power != 0 if all bands inside noise-sub band are
            // substituted.
            if (CODEC_BEGIN == pau->m_codecStatus)
            {
                for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++)
                {
                    PerChannelInfo *ppcinfo = &(pau->m_rgpcinfo[iChannel]);
                    if (pau->m_rgpcinfo[iChannel].m_iPower != 0)
                        SetActualPower (ppcinfo->m_rgiCoefQ, ppcinfo->m_cSubbandActual,
                                       ppcinfo, pau->m_codecStatus);
                }
            }

            pau->m_qstQuantStep = qstCalcQuantStep(pau->m_iQuantStepSize);
            for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++) 
            {
                if (pau->m_rgpcinfo[iChannel].m_iPower != 0)
                {
                    TRACEWMA_EXIT(hr, (*pau->aupfnInverseQuantize)(pau, pau->m_rgpcinfo + iChannel,
                        (I32 *)(pau->m_rgpcinfo + iChannel)->m_rguiWeightFactor));
                }
                else
                {
                    memset (pau->m_rgpcinfo [iChannel].m_rgiCoefRecon, 0, sizeof (Int) * DOUBLE(pau->m_fPad2XTransform,pau->m_cSubband));
                }
            }

#if defined(WMA_SHOW_FRAMES) && defined(_DEBUG)
            if (pau->m_cChannel==1)
                prvWmaShowFrames(pau, "\nDecSub ", " %2d   0x%08x            [%4d %4d %4d]",
                    pau->m_rgpcinfo[0].m_iPower,
                    pau->m_rgpcinfo[0].m_rgiCoefRecon,
                    pau->m_cFrameSample,
                    pau->m_cSubFrameSample,
                    pau->m_cSubband );
            else
                prvWmaShowFrames(pau, "\nDecSub ", " %2d%2d 0x%08x 0x%08x [%4d %4d %4d]",
                    pau->m_rgpcinfo[0].m_iPower,
                    pau->m_rgpcinfo[1].m_iPower,
                    pau->m_rgpcinfo[0].m_rgiCoefRecon,
                    pau->m_rgpcinfo[1].m_rgiCoefRecon,
                    pau->m_cFrameSample,
                    pau->m_cSubFrameSample,
                    pau->m_cSubband );
#endif

            //convert s/d to l/r
            if (pau->m_cChannel == 2 && pau->m_stereoMode == STEREO_SUMDIFF && 
                            (pau->m_rgpcinfo[0].m_iPower != 0 || pau->m_rgpcinfo[1].m_iPower != 0)) {
                pctCoefRecon0 = (CoefType*)pau->m_rgpcinfo[0].m_rgiCoefRecon;
                pctCoefRecon1 = (CoefType*)pau->m_rgpcinfo[1].m_rgiCoefRecon;
                for (i = pau->m_cSubbandAdjusted; i > 0; i--)   
                {
                    ctTemp0 = *pctCoefRecon0;
                    ctTemp1 = *pctCoefRecon1;
                    *pctCoefRecon0++ = ctTemp0 + ctTemp1;
                    *pctCoefRecon1++ = ctTemp0 - ctTemp1;
                }
                pau->m_rgpcinfo[0].m_iPower = 1;
                pau->m_rgpcinfo[1].m_iPower = 1;
            }

            if ( ! pau->m_fNoiseSub )
            {   // V4 only zeroed above HighCutOff when NoiseSubstitution was not in effect - e.g. it only zeros for HighRate
                Int iHighToBeZeroed = sizeof(CoefType) * (pau->m_cSubbandAdjusted - pau->m_cHighCutOffAdjusted);
                for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++)
                {
                    memset (pau->m_rgpcinfo [iChannel].m_rgiCoefRecon + pau->m_cHighCutOffAdjusted, 0, iHighToBeZeroed);    
#           if defined(_DEBUG) && defined(WMA_MONITOR)
                    {   int ii;
                        for( ii = 0; ii < iHighToBeZeroed; ii += sizeof(Int) )
                            MONITOR_RANGE(gMR_CoefRecon,0);
                    }
#           endif
                }
            }

#ifdef ENABLE_EQUALIZER
            //equalize
            for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++) {
                if (pau->m_rgpcinfo[iChannel].m_iPower != 0) {
                    TRACEWMA_EXIT(hr, prvEqualize(paudec, pau->m_rgpcinfo + iChannel));

                    if (paudec->m_fComputeBandPower == WMAB_TRUE)
                        prvComputeBandPower (paudec);
                }
            }
#endif // ENABLE_EQUALIZER

            {
                Float fltAfterScaleFactor = (pau->m_iVersion == 1) ? pau->m_fltDctScale :
                    (Float)(2.0f/pau->m_cSubband);

                for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++) {
                    PerChannelInfo* ppcinfo = pau->m_rgpcinfo + iChannel;
#if defined(INTERPOLATED_DOWNSAMPLE)
                    if (paudec->pau->m_fLowPass)
                        auLowPass(paudec->pau, (CoefType*) ppcinfo->m_rgiCoefRecon, pau->m_cSubband / 2);
#endif  // defined(INTERPOLATED_DOWNSAMPLE)
                    if (ppcinfo->m_iPower != 0) 
                        (*pau->aupfnDctIV) (pau, (CoefType*) ppcinfo->m_rgiCoefRecon, fltAfterScaleFactor, NULL);
                }
            }
        }
exit:
    //FUNCTION_PROFILE_STOP(&fp);
    return hr;
}


//*****************************************************************************************
//
// prvUpdateSubFrameConfig
//
//*****************************************************************************************
WMARESULT prvUpdateSubFrameConfig (CAudioObjectDecoder* paudec, Int iSizeNext, Int iSizePrev,
                                 Int iSizeCurr)
{
    Int iStartCurr;
    CAudioObject* pau = paudec->pau;
/*** less than 0.5%
#ifdef PROFILE
    //FunctionProfile fp;
    //FunctionProfileStart(&fp,UPDATE_SUB_FRAME_CONFIG_PROFILE);
#endif
*///
    if (iSizeNext == 0) {
        assert (pau->m_subfrmconfigCurr.m_cSubFrame > 0);
        paudec->m_fLastSubFrame = WMAB_TRUE;
        return WMA_OK;
    }

    //only useful in case of packet loss and prev info lost or first in sequece
    if (iSizePrev != 0) {
        assert (pau->m_iCurrSubFrame == 0);
        pau->m_subfrmconfigPrev.m_cSubFrame = 1;
        pau->m_subfrmconfigPrev.m_rgiSubFrameSize [0] = iSizePrev;
    }

    //first frame in super and first sub frame; init
    if (iSizeCurr != 0) {
        assert (pau->m_iCurrSubFrame == 0);
        pau->m_subfrmconfigCurr.m_cSubFrame = 0;
        pau->m_subfrmconfigCurr.m_rgiSubFrameSize [0] = iSizeCurr;
        pau->m_subfrmconfigCurr.m_rgiSubFrameStart[0] = 0;
        pau->m_subfrmconfigCurr.m_cSubFrame++;
    }

    iStartCurr = pau->m_subfrmconfigCurr.m_rgiSubFrameStart [pau->m_iCurrSubFrame] 
                   + pau->m_subfrmconfigCurr.m_rgiSubFrameSize  [pau->m_iCurrSubFrame];
    if (iStartCurr >= pau->m_cFrameSampleHalf) {
        //init the next frame
        paudec->m_fLastSubFrame = WMAB_TRUE;
        pau->m_subfrmconfigNext.m_cSubFrame = 0;
        pau->m_subfrmconfigNext.m_rgiSubFrameSize [0] = iSizeNext;
        pau->m_subfrmconfigNext.m_rgiSubFrameStart[0] = 0;
        pau->m_subfrmconfigNext.m_cSubFrame++;
    }
    else {
        //must be within one frame; must have received the first one
        Int iCurr = pau->m_iCurrSubFrame;
        assert (pau->m_subfrmconfigCurr.m_cSubFrame == iCurr + 1);
        assert (iSizeNext < pau->m_cFrameSampleHalf);        //> 1 subfrm
        pau->m_subfrmconfigCurr.m_rgiSubFrameSize [iCurr + 1] = iSizeNext;
        pau->m_subfrmconfigCurr.m_rgiSubFrameStart[iCurr + 1] = 
            pau->m_subfrmconfigCurr.m_rgiSubFrameStart[iCurr] + 
            pau->m_subfrmconfigCurr.m_rgiSubFrameSize[iCurr];
        if (pau->m_subfrmconfigCurr.m_rgiSubFrameStart[iCurr + 1] + 
            pau->m_subfrmconfigCurr.m_rgiSubFrameSize [iCurr + 1] > pau->m_cFrameSampleHalf)  {
            assert (WMAB_FALSE);
            return TraceResult(WMA_E_BROKEN_FRAME);
        }
        pau->m_subfrmconfigCurr.m_cSubFrame++;
    }
/***
#ifdef PROFILE
    //FunctionProfileStop(&fp);
#endif
*///
    return WMA_OK;
}

//*****************************************************************************************
//
// prvDecodeSubFrameHighRate
//
//*****************************************************************************************
WMARESULT prvDecodeSubFrameHighRate (CAudioObjectDecoder* paudec, Int* piBitCnt)
{
    WMARESULT hr = WMA_OK;
    Int     iChannel,i;
    PerChannelInfo* ppcinfo;
    CoefType *pctCoefRecon0,*pctCoefRecon1, ctTemp0, ctTemp1;
    CAudioObject* pau = paudec->pau;

#ifdef PROFILE
    //FunctionProfile fp;
    //FunctionProfileStart(&fp,DECODE_SUB_FRAME_HIGH_RATE_PROFILE);
#endif  // PROFILE

    assert(0 == *piBitCnt); // Need this assumption, storing bit allocs for transcoding

    switch (paudec->m_subfrmdecsts)
    {
        case SUBFRM_HDR :   
            TRACEWMA_EXIT(hr, prvDecodeFrameHeader(paudec, piBitCnt));    
            pau->m_qstQuantStep = qstCalcQuantStep(pau->m_iQuantStepSize);
            if (paudec->m_hdrdecsts == HDR_DONE)
            {
                I16 iChannel;
                for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++)
                {
                    ppcinfo = pau->m_rgpcinfo + iChannel;
                    memset (ppcinfo->m_rgiCoefRecon, 0, sizeof (CoefType) * pau->m_cHighCutOff);
                }
                paudec->m_subfrmdecsts = SUBFRM_COEF;

                //iRecon is offset by -1 so comarison 
                paudec->pau->m_iCurrReconCoef = (I16) (pau->m_cLowCutOff-1);

                paudec->m_iChannel = 0;
                paudec->m_rlsts = VLC;
            }
            else
                break;

        case SUBFRM_COEF:
            //Decode coefficents for sum channel or left & right channels 
            for (; paudec->m_iChannel < pau->m_cChannel; paudec->m_iChannel++) 
            {
                ppcinfo = pau->m_rgpcinfo + paudec->m_iChannel;

                if (ppcinfo->m_iPower != 0)
                {
                    TRACEWMA_EXIT(hr, auReconCoefficentsHighRate (paudec->pau,
                        paudec, ppcinfo, piBitCnt));
                }

                if(pau->m_iVersion == 1) 
                {
                    *piBitCnt += ibstrmBitsLeft (&paudec->m_ibstrm) % 8;
                    ibstrmFlush(&paudec->m_ibstrm);
                }
                //usually only go up to highCutoff but certain V1 contents do go up as high as m_cSubband
                assert (paudec->pau->m_iCurrReconCoef <= (I16) pau->m_cSubband);
                paudec->pau->m_iCurrReconCoef = (I16) (pau->m_cLowCutOff-1);             //iRecon is offset by -1 so comarison 
            }
            paudec->m_subfrmdecsts = SUBFRM_DONE;

        case SUBFRM_DONE:
            for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++) {
                ppcinfo = pau->m_rgpcinfo + iChannel;
                if (ppcinfo->m_iPower != 0)
                {
                    // WMA Timestamps: To detect start-of-stream and discard correct amount of silence,
                    // we need to verify claim that m_iPower[*] = 1, ForceMaskUpdate and actual power = 0.
                    ppcinfo->m_iActualPower = 0;
                    if (CODEC_BEGIN == pau->m_codecStatus)
                    {
                        SetActualPowerHighRate (ppcinfo->m_rgiCoefRecon, 
                                                pau->m_cSubband, ppcinfo, pau->m_codecStatus);
                    }
                }
                else 
                {
                    memset (ppcinfo->m_rgiCoefRecon, 0, sizeof (CoefType) * pau->m_cSubbandAdjusted);
                    ppcinfo->m_iActualPower = 0;
                }
            }
#if defined(WMA_SHOW_FRAMES) && defined(_DEBUG)
            if (pau->m_cChannel==1)
                prvWmaShowFrames(pau, "\nDecSubH", " %2d   0x%08x            [%4d %4d %4d]",
                    pau->m_rgpcinfo[0].m_iPower,
                    pau->m_rgpcinfo[0].m_rgiCoefRecon,
                    pau->m_cFrameSample,
                    pau->m_cSubFrameSample,
                    pau->m_cSubband );
            else
                prvWmaShowFrames(pau, "\nDecSubH", " %2d%2d 0x%08x 0x%08x [%4d %4d %4d]",
                    pau->m_rgpcinfo[0].m_iPower,
                    pau->m_rgpcinfo[1].m_iPower,
                    pau->m_rgpcinfo[0].m_rgiCoefRecon,
                    pau->m_rgpcinfo[1].m_rgiCoefRecon,
                    pau->m_cFrameSample,
                    pau->m_cSubFrameSample,
                    pau->m_cSubband );
#endif

            //convert s/d to l/r
            if (pau->m_cChannel == 2 && pau->m_stereoMode == STEREO_SUMDIFF && 
                            (pau->m_rgpcinfo[0].m_iPower != 0 || pau->m_rgpcinfo[1].m_iPower != 0)) {
                pctCoefRecon0 = (CoefType*)pau->m_rgpcinfo[0].m_rgiCoefRecon;
                pctCoefRecon1 = (CoefType*)pau->m_rgpcinfo[1].m_rgiCoefRecon;
                for (i = pau->m_cHighCutOffAdjusted; i >0; i--) {
                    ctTemp0 = *pctCoefRecon0;
                    *pctCoefRecon0++ = ctTemp0 + (ctTemp1 = *pctCoefRecon1);
                    *pctCoefRecon1++ = ctTemp0 - ctTemp1;
                }
                pau->m_rgpcinfo[0].m_iPower = 1;
                pau->m_rgpcinfo[1].m_iPower = 1;
                assert( pctCoefRecon0 == (CoefType*)pau->m_rgpcinfo [0].m_rgiCoefRecon + pau->m_cHighCutOffAdjusted );
                assert( pctCoefRecon1 == (CoefType*)pau->m_rgpcinfo [1].m_rgiCoefRecon + pau->m_cHighCutOffAdjusted );
            }

#ifdef ENABLE_EQUALIZER
            //equalize
            for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++) {
                if (pau->m_rgpcinfo[iChannel].m_iPower != 0) {
                    TRACEWMA_EXIT(hr, prvEqualize(paudec, pau->m_rgpcinfo + iChannel));

                    if (paudec->m_fComputeBandPower == WMAB_TRUE)
                        prvComputeBandPower (paudec);
                }
            }
#endif // ENABLE_EQUALIZER
    
            {
                Float fltAfterScaleFactor = (pau->m_iVersion == 1) ? pau->m_fltDctScale :
                    (Float)(2.0f/pau->m_cSubband);

                for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++) {
                    PerChannelInfo* ppcinfo = pau->m_rgpcinfo + iChannel;
#if defined(INTERPOLATED_DOWNSAMPLE)
                    if (paudec->pau->m_fLowPass)
                        auLowPass(paudec->pau, (CoefType*) ppcinfo->m_rgiCoefRecon, pau->m_cSubband / 2);
#endif  // defined(INTERPOLATED_DOWNSAMPLE)
                    if (ppcinfo->m_iPower != 0) 
                        (*pau->aupfnDctIV) (pau, (CoefType*) ppcinfo->m_rgiCoefRecon, fltAfterScaleFactor, NULL);
                }
            }
    }

exit:
#ifdef PROFILE
    //FunctionProfileStop(&fp);
#endif  // PROFILE

    return hr;
}



//*****************************************************************************************
//
// Std WMA_GetMoreData for non-streaming mode
//
//*****************************************************************************************
WMARESULT prvWMAGetMoreData (U8 **ppBuffer, U32 *pcbBuffer,
                             U32 dwUserData)
{
    CAudioObjectDecoder* paudec = (CAudioObjectDecoder*) dwUserData;

    if(paudec == NULL || ppBuffer == NULL || pcbBuffer == NULL)
    {
        if(ppBuffer != NULL)
            *ppBuffer = NULL;
        if(pcbBuffer != NULL)
            *pcbBuffer = 0;

        assert(WMAB_FALSE);
        return TraceResult(WMA_E_INVALIDARG);
    }

    if (paudec->m_pbSrcCurr != NULL)
    {
        *ppBuffer  = paudec->m_pbSrcCurr;
        *pcbBuffer = paudec->m_cbSrcCurrLength;
        //make sure nothing is left
        paudec->m_pbSrcCurr = NULL;
        paudec->m_cbSrcCurrLength = 0;
    }
    return WMA_S_NEWPACKET;
}


//***************************************************************************
// Encoder/Decoder Separation
//***************************************************************************

FastFloat prvCalcSqrtBWRatioDEC(const PerChannelInfo *ppcinfo,
                            const Int iNoiseBand,
                            const Int cNoiseBand)
{
    const FastFloat* const rgffltSqrtBWRatio = ppcinfo->m_rgffltSqrtBWRatio;
    return rgffltSqrtBWRatio[iNoiseBand];
} // prvCalcSqrtBWRatioENC


// Start BLOCK B
// From lpc.c

// Forward decl
void gLZLTableInit(void);

#ifdef BUILD_INTEGER

// INVQUADROOT_FRACTION_TABLE_SIZE defined as 256 and interpolate
//UInt g_InvQuadRootFraction[1+INVQUADROOT_FRACTION_TABLE_SIZE];

//UInt g_InvQuadRootExponent[BITS_LP_SPEC_POWER];  // was [32-PRECESSION_BITS_FOR_INVQUADROOT]

Void prvInitInverseQuadRootTable (CAudioObject* pau)
{
#if 0
    Int i;
    
    for (i = 1; i < 1<<(PRECESSION_BITS_FOR_INVQUADROOT); i++){          
        Float f = (float)i/LP_SPEC_POWER_SCALE;
        Float invQuadRoot = (Float)(1/sqrt(sqrt(f)));                                   
        //// range is 11.3137:0.0525556 or in bits +3.5:-4.25
        // When PRECESSION_BITS_FOR_INVQUADROOT = 14, LP_SPEC_POWER_SCALE = 28, range is 128.000000:11.313881 ==> QR_FRAC = 32-8
        // When PRECESSION_BITS_FOR_INVQUADROOT = 14, LP_SPEC_POWER_SCALE = 30, range is 181.019333:16.000244 ==> QR_FRAC = 32-9
        // When PRECESSION_BITS_FOR_INVQUADROOT = 14, LP_SPEC_POWER_SCALE = 31, range is 215.269482:19.027604 ==> QR_FRAC = 32-8
        g_InvQuadRootFraction[i] = (UInt)(invQuadRoot*(1<<QR_FRACTION_FRAC_BITS));
    }
    g_InvQuadRootFraction[0] = (UInt)((1/(sqrt(sqrt(1.0/LP_SPEC_SCALE/2))))*(1<<QR_FRACTION_FRAC_BITS));
    
    for (i = -PRECESSION_BITS_FOR_INVQUADROOT; i < BITS_LP_SPEC_POWER-PRECESSION_BITS_FOR_INVQUADROOT; i++){
        Float invQuadRoot = (i<0) ? (float)pow(2,i) : (float)(1<<i);
                invQuadRoot = (Float)(1/sqrt(sqrt(invQuadRoot)));                               
                // range is 45.2548:3.36364 or in bits +5.5:1.75 for 32 bit power. 
        g_InvQuadRootExponent[i+PRECESSION_BITS_FOR_INVQUADROOT] = (UInt)(invQuadRoot*(1<<QR_EXPONENT_FRAC_BITS));
    }
        // range of product is 511.999:0.176778 or +9.0:-2.5
        // When PRECESSION_BITS_FOR_INVQUADROOT = 14, BITS_LP_SPEC_POWER = 64, range is 1.000000:0.005524 ==> QR_EXP = 32-2
        // So value should work with a LP_SPEC_FRAC_BITS of 22.
#endif
    SETUP_LPC_SPEC_TRIG(pau);
#ifndef LPCPOWER32

	gLZLTableInit();
#endif
}

//Debugging aid to dealwith LPC calculations separately from InverseQuadRoot
//#define FAKE_INVERSE_QUAD_ROOT


INLINE WeightType InverseQuadRoot(LpSpecPowerType f)
{
    //// 1.0f/(1<<30)
    WeightType uiResult;
    LpSpecPowerType uFrac;
    Int iExp;// can be -ve
    UInt uiExpVal;
    UInt uiTmp;
    
    uFrac = f;
    // Get normalized fractional portion with PRECESSION_BITS_FOR_INVQUADROOT
    // bits and corresponding exponent value
    if (uFrac == 0) {
      iExp = 0;
    } else {
      // Find the most significant bit with value 1.
#if defined (LPCPOWER32)
      // 32-bit input
      iExp = 0;
      uiTmp = uFrac;
#else 
      // 64-bit input: Look at each 32-bit portion
      // We are assuming that PRECESSION_BITS_FOR_INVQUADROOT is < 32.
      if ((uFrac >> 32) == 0) {
        iExp = 32;
        uiTmp = (UInt) uFrac;
      } else {
        iExp = 0;
        uiTmp = (UInt)(uFrac >> 32);
      }
#endif
      while (!(uiTmp & 0x80000000)) { uiTmp <<= 1; iExp++;};
      
      // Perform shifts on the input so that we have 
      // PRECESSION_BITS_FOR_INVQUADROOT bits of normalized 
      // fraction, and corresponding exponent values.
      
      uFrac = f;
      iExp = BITS_LP_SPEC_POWER - iExp - PRECESSION_BITS_FOR_INVQUADROOT;
      if (iExp < 0) 
        uFrac <<= (-iExp);
      if (iExp > 0)
        uFrac >>= iExp;
    }
    
    // QR_*_FRAC_BITS: same as used in prvInitInverseQuadRootTable
    MONITOR_COUNT(gMC_ScaleInverseQuadRoot,iExp);
    uFrac = g_InvQuadRootFraction[(Int)uFrac];
    //// iFrac*1.0f/(1<<23)
    uiExpVal = g_InvQuadRootExponent[iExp+PRECESSION_BITS_FOR_INVQUADROOT];
    //// iExp*1.0f/(1<<29)
    uiResult = MULT_HI_UDWORD(((UInt)uFrac),uiExpVal);  // frac_bits = 23+29-32 = 20
    //// iResult*1.0f/(1<<20)
#if ((QR_FRACTION_FRAC_BITS+QR_EXPONENT_FRAC_BITS-32) > WEIGHTFACTOR_FRACT_BITS)
    uiResult >>= (QR_FRACTION_FRAC_BITS+QR_EXPONENT_FRAC_BITS-31) - WEIGHTFACTOR_FRACT_BITS;
#elif ((QR_FRACTION_FRAC_BITS+QR_EXPONENT_FRAC_BITS-32) < WEIGHTFACTOR_FRACT_BITS)
    uiResult <<= WEIGHTFACTOR_FRACT_BITS - (QR_FRACTION_FRAC_BITS+QR_EXPONENT_FRAC_BITS-31);
#endif //((QR_FRACTION_FRAC_BITS+QR_EXPONENT_FRAC_BITS-32) > WEIGHTFACTOR_FRACT_BITS)
    // uiResult = (2^19/QR(iFrac*2^-19)) * 2^6 * (2^19/QR(2^iExp)) * 2^7 * 2^-32 = 2^19/QR(iFrac*2^-19*2^iExp)
    // uiResult = MULT_HI_DWORD(iFrac<<(BITS_PER_DWORD-FRACT_BITS_LP_SPEC>>1),(iExp<<((BITS_PER_DWORD-FRACT_BITS_LP_SPEC>>1)+1)));
    assert( uiResult >= 0 );
    
    //fprintf(stdout, "%lf\n", (double)uiResult/(1<<WEIGHTFACTOR_FRACT_BITS));
    return uiResult;
}
#endif  // BUILD_INTEGER
// End BLOCK B



// Decoder-only portion of auAdaptToSubFrameConfig
WMARESULT auAdaptToSubFrameConfigDEC (CAudioObject* pau)
{
    PerChannelInfo *ppcinfo = pau->m_rgpcinfo;

    ppcinfo->m_rgiCoefRecon   = pau->m_rgiCoefReconOrig 
                              + DOUBLE(pau->m_fPad2XTransform,
                                    pau->m_cFrameSampleHalf - pau->m_cSubFrameSampleHalf);
    ppcinfo->m_rgfltCoefRecon = (Float *)(ppcinfo->m_rgiCoefRecon);

    if (pau->m_cChannel == 2)   {
        ppcinfo = pau->m_rgpcinfo + 1;

        ppcinfo->m_rgiCoefRecon   = pau->m_rgiCoefReconOrig 
                                  + DOUBLE(pau->m_fPad2XTransform,
                                        2 * pau->m_cFrameSampleHalf - pau->m_cSubFrameSampleHalf);
        ppcinfo->m_rgfltCoefRecon = (Float *)(ppcinfo->m_rgiCoefRecon);
    }

    return WMA_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmvlib\decoder\postfilter_wmv_x86.cpp ===
#ifdef _SUPPORT_POST_FILTERS_
#include "bldsetup.h"

#include "xplatform.h"
#include "limits.h"
#include "stdio.h"
#include "stdlib.h"
#include "wmvdec_member.h"
#include "typedef.hpp"
#include "postfilter_wmv.hpp"
#include "cpudetect.h"
#include "opcodes.h"
#include "tables_wmv.h"

//THR1 = the threshold before we consider neighboring pixels to be "diffrent"
#define THR1 2       
//THR2 = the total number of "diffrent" pixels under which we use stronger filter
#define THR2 6
#define INV_THR2 3

#ifdef _WMV_TARGET_X86_
#pragma warning (disable:4799)
#pragma optimize ("",off)

Void_WMV FilterHorizantalEdge(U8_WMV* ppxlcCenter, I32_WMV iPixelDistance, I32_WMV iPixelIncrement, I32_WMV iEdgeLength, I32_WMV iStepSize)
{
 
    static const Int64 thr1 = THR1 | (THR1 << 8) | (THR1 << 16) | (THR1 << 24) | ((Int64)THR1 << 32) | ((Int64)THR1 << 40) | ((Int64)THR1 << 48) | ((Int64)THR1 << 56);
    //static const Int64 neg_thr1 = NTHR1 | (NTHR1 << 8) | (NTHR1 << 16) | (NTHR1 << 24) | ((Int64)NTHR1 << 32) | ((Int64)NTHR1 << 40) | ((Int64)NTHR1 << 48) | ((Int64)NTHR1 << 56);
    
    static const Int64 thr2 = (THR2-1) | ((THR2-1) << 8) | ((THR2-1) << 16) | ((THR2-1) << 24) | ((Int64)(THR2-1) << 32) | ((Int64)(THR2-1) << 40) | ((Int64)(THR2-1) << 48) | ((Int64)(THR2-1) << 56);
    static const Int64 x01 = 0x0101010101010101;
    static const Int64 x80 = 0x8080808080808080;
    static const Int64 x06 = 0x0006000600060006;
    static const Int64 x08 = 0x0008000800080008;
    static const Int64 x05 = 0x0005000500050005;
    static const Int64 x04 = 0x0004000400040004;
    static const Int64 x0001 = 0x0001000100010001;
    static const Int64 x0002 = 0x0002000200020002;

    Int64 act;
    Int64 iStepBroad, i2StepBroad;
    Int64 lminmax;
    Int64 lminmax2;
    Int64 mask;    
    I32_WMV i;
    I32_WMV mytemp;
    U8_WMV* pV0 = ppxlcCenter - (iPixelDistance*5);
    
    _asm {

        sub esp, 64 // IW
        movd        mm0,iStepSize       //Broadcast iStepSize
        punpcklbw   mm0,mm0
        punpcklwd   mm0,mm0
        punpckldq   mm0,mm0
        movq        mm5,mm0

/*        psllq       mm5,8
        por         mm0,mm5
        movq        mm5,mm0
        psllq       mm5,16
        por         mm0,mm5
        movq        mm5,mm0
        psllq       mm5,32
        por         mm0,mm5
        movq        mm5,mm0
  */      
        
        psllq       mm0,1
        psubb       mm5,x01 
        movq        iStepBroad,mm5
        movq        i2StepBroad,mm0
        
        mov         eax,iPixelDistance
        mov         esi,pV0
        lea         esi,[esi+eax*2]

        mov         ecx,iEdgeLength
        shr         ecx,3
HLoop:
        mov         i,ecx

        mov         eax,iPixelDistance
        mov         ebx,eax
        neg         ebx
        lea         edi,[esi+eax*4]
        add         edi,eax

        movq        mm7,thr1
        movq        mm6,x01

        //phi(v0 - v1)
        movq        mm0,[esi+ebx*2]     //Load
        movq        mm1,[esi+ebx]
        psubb       mm0,mm1             //Subtract
        pxor        mm2,mm2             //Absolute Value
        pcmpgtb     mm2,mm0
        pxor        mm0,mm2
        psubb       mm0,mm2
        pcmpgtb     mm0,mm7	            //if (mm0 <= THR1) mm0 = 1 else mm0 = 0
        pandn       mm0,mm6

        //phi(v1 - v2)
        movq        mm2,[esi]
        psubb       mm1,mm2     
        pxor        mm3,mm3     
        pcmpgtb     mm3,mm1
        pxor        mm1,mm3
        pand        mm3,mm6
        paddb       mm1,mm3
        pcmpgtb     mm1,mm7	    
        pandn       mm1,mm6
        paddb       mm0,mm1             

        //phi(v2 - v3)
        movq        mm1,[esi+eax]
        psubb       mm2,mm1 
        pxor        mm3,mm3     
        pcmpgtb     mm3,mm2
        pxor        mm2,mm3
        psubb       mm2,mm3
        pcmpgtb     mm2,mm7	    
        pandn       mm2,mm6
        paddb       mm0,mm2             

        //phi(v3 - v4)
        movq        mm2,[esi+eax*2]
        psubb       mm1,mm2     
        pxor        mm3,mm3     
        pcmpgtb     mm3,mm1
        pxor        mm1,mm3
        psubb       mm1,mm3
        pcmpgtb     mm1,mm7	    
        pandn       mm1,mm6
        paddb       mm0,mm1             

        //phi(v4 - v5)
        movq        mm1,[edi+ebx*2]
        psubb       mm2,mm1     
        pxor        mm3,mm3     
        pcmpgtb     mm3,mm2
        pxor        mm2,mm3
        psubb       mm2,mm3
        pcmpgtb     mm2,mm7	    
        pandn       mm2,mm6
        paddb       mm0,mm2             

        //phi(v5 - v6)
        movq        mm2,[edi+ebx]
        psubb       mm1,mm2     
        pxor        mm3,mm3     
        pcmpgtb     mm3,mm1
        pxor        mm1,mm3
        psubb       mm1,mm3
        pcmpgtb     mm1,mm7	    
        pandn       mm1,mm6
        paddb       mm0,mm1             
        
        //phi(v6 - v7)
        movq        mm1,[edi]
        psubb       mm2,mm1     
        pxor        mm3,mm3     
        pcmpgtb     mm3,mm2
        pxor        mm2,mm3
        psubb       mm2,mm3
        pcmpgtb     mm2,mm7	    
        pandn       mm2,mm6
        paddb       mm0,mm2             
        
        //phi(v7 - v8)
        movq        mm2,[edi+eax]
        psubb       mm1,mm2     
        pxor        mm3,mm3     
        pcmpgtb     mm3,mm1
        pxor        mm1,mm3
        psubb       mm1,mm3
        pcmpgtb     mm1,mm7	    
        pandn       mm1,mm6
        paddb       mm0,mm1             
        
        //phi(v8 - v9)
        movq        mm1,[edi+eax*2]
        psubb       mm2,mm1     
        pxor        mm3,mm3     
        pcmpgtb     mm3,mm2
        pxor        mm2,mm3
        psubb       mm2,mm3
        pcmpgtb     mm2,mm7	    
        pandn       mm2,mm6
        paddb       mm0,mm2             
        
        pcmpgtb     mm0,thr2

        movq        act,mm0

        movq        mm1,mm0
        movq        mm2,mm0
        psrlq       mm2,32
        psrlq       mm1,32
        pand        mm2,mm0
        por         mm1,mm0

        
        movq        mask,mm0

        movd        ebx,mm2     //check for 8 using DC offset mode (long filter)
        cmp         ebx,0xFFFFFFFF
        jz          DcOffsetMode2

        movd        eax,mm0     //check for all 8 using default mode (short filter)
        test        eax,eax
        jz          DefaultMode //Default Mode for all 8

        movd        ebx,mm0    //check for 4 using DC offset mode (long filter)
        cmp         ebx,0xFFFFFFFF
        jz          DcOffsetMode //DC Offset Mode for all 4

        mov         eax,iPixelDistance  //Setup pointers
        call        MinMaxMask_MMX
        movq        lminmax,mm6

        movd        mm7,mask           
        call        MixedMode4_MMX

        add         esi,4

        movq        mm0,act
        psrlq       mm0,32
//        movd        eax,mm0

        movd        eax,mm0     //check for all 8 using default mode (short filter)
        test        eax,eax
        jz          DefaultModeA //Default Mode for all 8
        
        movq        mm6,lminmax
        psrlq       mm6,32
        movq        lminmax,mm6

        movd        ebx,mm0    //check for 4 using DC offset mode (long filter)
        cmp         ebx,0xFFFFFFFF
        jz          DcOffsetModeA //DC Offset Mode for all 8
            
MixedModeA:

        mov         eax,iPixelDistance
        movq        mm6,lminmax
        movq        mm7,mask           
        psrlq       mm7,32
        call        MixedMode4_MMX 
        
        add         esi,4
        mov         ecx,i
        dec         ecx
        jnz         HLoop
        jmp         end

DcOffsetMode:    
        mov         eax,iPixelDistance  //Setup pointers
        call        MinMaxMask_MMX

        mov         eax,iPixelDistance
        movq        lminmax,mm6
        call        DcOffsetMode4_MMX

        add         esi,4

        movq        mm6,lminmax
        psrlq       mm6,32
        movq        lminmax,mm6

        movq        mm0,act
        psrlq       mm0,32
//        movd        eax,mm0

        movd        eax,mm0     //check for all 8 using default mode (short filter)
        test        eax,eax
        jz          DefaultModeA //Default Mode for all 8
       
        movd        ebx,mm0    //check for 4 using DC offset mode (long filter)
        cmp         ebx,0xFFFFFFFF
        jnz         MixedModeA
            
DcOffsetModeA:    
        mov         eax,iPixelDistance
        movq        mm6,lminmax
        call        DcOffsetMode4_MMX
        
        
        add         esi,4
        mov         ecx,i
        dec         ecx
        jnz         HLoop
        jmp         end

DcOffsetMode2:    

        call        MinMaxMask_MMX
        movq        lminmax,mm6
  
            
        mov         eax,iPixelDistance
        call        DcOffsetMode4_MMX
        
        add         esi,4

        movq        mm6,lminmax
        psrlq       mm6,32
        movq        lminmax,mm6

        mov         eax,iPixelDistance
        movq        mm6,lminmax
        call        DcOffsetMode4_MMX
        

        add         esi,4
        mov         ecx,i
        dec         ecx
        jnz         HLoop
        jmp         end

DefaultMode:
        mov         eax,iPixelDistance
        call        DefaultMode4_MMX

        add         esi,4

        movq        mm0,act
        psrlq       mm0,32
//        movd        eax,mm0

        movd        eax,mm0     //check for all 8 using default mode (short filter)
        test        eax,eax
        jz          DefaultModeA //Default Mode for all 8
    
        movd        mytemp,mm0

        mov         eax,iPixelDistance  //Setup pointers
        call        MinMaxMask_MMX
        movq        lminmax,mm6


        mov         ebx,mytemp    //check for 4 using DC offset mode (long filter)
        cmp         ebx,0xFFFFFFFF
        jz          DcOffsetModeA //DC Offset Mode for all 8
        
        jmp         MixedModeA

DefaultModeA:

        mov         eax,iPixelDistance
        call        DefaultMode4_MMX

        add         esi,4
        mov         ecx,i
        dec         ecx
        jnz         HLoop

end:    emms
        add esp, 64 // IW
        }

        return;

    _asm{        
MinMaxMask_MMX:
        mov         ebx,eax
        neg         ebx
        lea         edi,[esi+eax*4]
        add         edi,eax

        movq        mm7,x80

        movq        mm0,[esi+ebx]       //Load first line
        pxor        mm0,mm7
        movq        mm1,[esi]           //Load second line
        pxor        mm1,mm7
        movq        mm2,mm1             //Min Max first 2 lines
        pcmpgtb     mm2,mm0
        movq        mm4,mm0
        pand        mm0,mm2         
        pxor        mm4,mm0
        pandn       mm2,mm1
        pxor        mm1,mm2
        por         mm0,mm2
        por         mm1,mm4

        movq        mm2,[esi+eax]       //Load third line
        pxor        mm2,mm7
        movq        mm3,[esi+eax*2]     //Load forth line
        pxor        mm3,mm7
        movq        mm4,mm3             //Min Max next 2 lines
        pcmpgtb     mm4,mm2
        movq        mm5,mm2
        pand        mm2,mm4         
        pxor        mm5,mm2
        pandn       mm4,mm3
        pxor        mm3,mm4
        por         mm2,mm4
        por         mm3,mm5
        
        movq        mm4,mm2             //Min first 2 pairs
        pcmpgtb     mm4,mm0
        pand        mm0,mm4
        pandn       mm4,mm2
        por         mm0,mm4

        movq        mm4,mm1             //Max first 2 pairs
        pcmpgtb     mm4,mm3
        pand        mm1,mm4
        pandn       mm4,mm3
        por         mm1,mm4

        movq        mm2,[edi+ebx*2]     //Load fifth line
        pxor        mm2,mm7
        movq        mm3,[edi+ebx]       //Load sixth line
        pxor        mm3,mm7
        movq        mm4,mm3             //Min Max next 2 lines
        pcmpgtb     mm4,mm2
        movq        mm5,mm2
        pand        mm2,mm4         
        pxor        mm5,mm2
        pandn       mm4,mm3
        pxor        mm3,mm4
        por         mm2,mm4
        por         mm3,mm5
        
        movq        mm4,mm2             //Min last 2 pairs
        pcmpgtb     mm4,mm0
        pand        mm0,mm4
        pandn       mm4,mm2
        por         mm0,mm4

        movq        mm4,mm1             //Max last 2 pairs
        pcmpgtb     mm4,mm3
        pand        mm1,mm4
        pandn       mm4,mm3
        por         mm1,mm4

        movq        mm2,[edi]           //Load 7'th line
        pxor        mm2,mm7
        movq        mm3,[edi+eax]       //Load 8'th line
        pxor        mm3,mm7
        movq        mm4,mm3             //Min Max next 2 lines
        pcmpgtb     mm4,mm2
        movq        mm5,mm2
        pand        mm2,mm4         
        pxor        mm5,mm2
        pandn       mm4,mm3
        pxor        mm3,mm4
        por         mm2,mm4
        por         mm3,mm5
        
        movq        mm4,mm2             //Min last 2 pairs
        pcmpgtb     mm4,mm0
        pand        mm0,mm4
        pandn       mm4,mm2
        por         mm0,mm4

        movq        mm4,mm1             //Max last 2 pairs
        pcmpgtb     mm4,mm3
        pand        mm1,mm4
        pandn       mm4,mm3
        por         mm1,mm4

        pxor        mm0,mm7
        pxor        mm1,mm7

        psubb       mm1,mm0

        movq        mm0,i2StepBroad

        pxor        mm0,mm7
        pxor        mm1,mm7
        pcmpgtb     mm0,mm1             // (max-min) < 2*iStepSize

        movq        mm6,mm0

        ret
        }

    _asm{        
DcOffsetMode4_MMX:
        movq        lminmax2,mm6

        mov         ebx,eax
        neg         ebx
        lea         edi,[esi+eax*4]
        add         edi,eax

        movq        mm7,x80
        movd        mm1,[esi+ebx*2]           //calculate value that will be used as v0
        movd        mm0,[esi+ebx]
        movq        mm2,mm1
        movq        mm3,mm0
        psubusb     mm2,mm0
        psubusb     mm3,mm1
        por         mm2,mm3
        movq        mm5,iStepBroad
        pxor        mm2,mm7
        pxor        mm5,mm7
        pcmpgtb     mm2,mm5
        pand        mm0,mm2
        pandn       mm2,mm1
        por         mm0,mm2             //if (abs(v1-v0) < iStepSize) mm0 = v0 else mm0 = v1

        pxor        mm7,mm7
        
        movq        mm2,x06             //6*v0
        punpcklbw   mm0,mm7             
        movq        mm5,mm0
        movq        mm4,mm0
        psllw       mm5,2
        pmullw      mm0,mm2
                                        
        movd        mm2,[esi+ebx]       //v1
        punpcklbw   mm2,mm7
        movq        mm3,mm2
        paddw       mm5,mm2
        paddw       mm5,mm2
        paddw       mm4,mm2
        movq        mm6,mm4
        psllw       mm2,2
        paddw       mm0,mm2

        movd        mm2,[esi]           //v2 
        punpcklbw   mm2,mm7
        paddw       mm4,mm2
        paddw       mm3,mm2
        paddw       mm2,mm2
        paddw       mm6,mm2
        paddw       mm0,mm2
        paddw       mm2,mm2
        paddw       mm5,mm2

        movd        mm2,[esi+eax]       //v3
        punpcklbw   mm2,mm7
        paddw       mm2,mm2
        paddw       mm0,mm2
        paddw       mm5,mm2
        paddw       mm4,mm2
        paddw       mm6,mm2
        paddw       mm3,mm2

        movd        mm2,[esi+eax*2]     //v4
        punpcklbw   mm2,mm7
        paddw       mm0,mm2
        paddw       mm4,mm2
        paddw       mm2,mm2
        paddw       mm5,mm2
        paddw       mm6,mm2
        paddw       mm6,mm2
        paddw       mm3,mm2

        movd        mm2,[edi+ebx*2]     //v5
        punpcklbw   mm2,mm7
        paddw       mm0,mm2
        paddw       mm5,mm2
        paddw       mm4,mm2
        movq        mm1,x08
        paddw       mm4,mm4
        paddw       mm2,mm2
        paddw       mm6,mm2
        paddw       mm3,mm2
        paddw       mm3,mm2

        paddw       mm0,mm1
        psrlw       mm0,4

        packuswb    mm0,mm0

        movq        mm7,lminmax2          //Output masked  v1
        movd        mm2,[esi+ebx]
        pand        mm0,mm7
        pandn       mm7,mm2
        por         mm0,mm7
        movd        [esi+ebx],mm0    
        pxor        mm7,mm7

        movd        mm2,[edi+ebx]       //+ v6
        punpcklbw   mm2,mm7
        paddw       mm5,mm2
        paddw       mm4,mm2
        paddw       mm2,mm2
        paddw       mm6,mm2
        paddw       mm3,mm2
        movq        mm0,mm2

        paddw       mm5,mm1
        psrlw       mm5,4

        packuswb    mm5,mm5

        movq        mm7,lminmax2          //Output masked  v2
        movd        mm2,[esi]
        pand        mm5,mm7
        pandn       mm7,mm2
        por         mm5,mm7
        movd        [esp+8],mm5     
        pxor        mm7,mm7

        movd        mm2,[edi]           //+v7     
        punpcklbw   mm2,mm7
        paddw       mm4,mm2
        paddw       mm6,mm2
        paddw       mm2,mm2
        paddw       mm3,mm2

        movq        mm5,mm2

        paddw       mm4,mm1
        psrlw       mm4,4

        packuswb    mm4,mm4
        
        movq        mm7,lminmax2          //Output masked  v3
        movd        mm2,[esi+eax]
        pand        mm4,mm7
        pandn       mm7,mm2
        por         mm4,mm7
        movd        [esp+12],mm4     
  
        movq        mm7,mm0
        paddw       mm0,mm5
        movq        mm4,mm0
        paddw       mm0,mm7
        paddw       mm5,mm5
        paddw       mm5,mm7
        pxor        mm7,mm7
     
        movd        mm2,[edi+eax]       //v8
        punpcklbw   mm2,mm7
        paddw       mm6,mm2
        paddw       mm3,mm2
        paddw       mm2,mm2
        movq        mm7,x08
        paddw       mm0,mm2
        paddw       mm5,mm2
        paddw       mm4,mm2
        paddw       mm4,mm2

        paddw       mm6,mm7
        psrlw       mm6,4

        packuswb    mm6,mm6
        
        movq        mm7,lminmax2          //Output masked   v4
        movd        mm2,[esi+eax*2]
        pand        mm6,mm7
        pandn       mm7,mm2
        por         mm6,mm7
        movd        [esp+16],mm6     
        movq        mm6,mm0

        movq        mm7,mm3                   //calculate value that will be used as v9
        movd        mm1,[edi+eax*2]           
        movd        mm0,[edi+eax]
        movq        mm2,mm0
        movq        mm3,mm1
        psubusb     mm2,mm1
        psubusb     mm3,mm0
        por         mm2,mm3
        movq        mm3,mm7
        movq        mm7,iStepBroad
        pxor        mm7,x80
        pxor        mm2,x80
        pcmpgtb     mm2,mm7
        pand        mm0,mm2
        pandn       mm2,mm1
        por         mm0,mm2             //if (abs(v8-v9) < iStepSize) mm0 = v9 else mm0 = v8
        movq        mm1,mm3
        pxor        mm7,mm7

        movq        mm3,mm0             //v9
        punpcklbw   mm3,mm7
        paddw       mm1,mm3
        paddw       mm3,mm3
        paddw       mm6,mm3
        paddw       mm5,mm3
        paddw       mm5,mm3
        paddw       mm4,mm3
        paddw       mm4,mm3
        paddw       mm4,mm3


        movd        mm0,[esi]           //v2
        punpcklbw   mm0,mm7
        paddw       mm6,mm0
        movd        mm0,[esp+8] 
        movd        [esi],mm0    

        movd        mm0,[esi+eax]       //v3
        punpcklbw   mm0,mm7
        paddw       mm6,mm0
        paddw       mm5,mm0
        movd        mm0,[esp+12] 
        movd        [esi+eax],mm0    

        movd        mm0,[esi+eax*2]     //v4
        punpcklbw   mm0,mm7
        paddw       mm5,mm0
        paddw       mm4,mm0
        paddw       mm0,mm0
        paddw       mm6,mm0
        movd        mm0,[esp+16] 
        movd        [esi+eax*2],mm0    
        
        movd        mm0,[edi+ebx*2]     //v5
        punpcklbw   mm0,mm7
        paddw       mm4,mm0
        paddw       mm0,mm0
        movq        mm2,x08
        paddw       mm6,mm0
        paddw       mm5,mm0
        
        paddw       mm1,mm2
        psrlw       mm1,4

        packuswb    mm1,mm1

        movq        mm7,lminmax2          //Output masked v5
        movq        mm3,mm7
        movd        mm0,[edi+ebx*2]
        pand        mm1,mm3
        pandn       mm3,mm0
        por         mm1,mm3
        movd        [edi+ebx*2],mm1

        paddw       mm6,mm2
        psrlw       mm6,4

        packuswb    mm6,mm6

        movq        mm3,mm7             //Output masked v6
        movd        mm1,[edi+ebx]
        pand        mm6,mm3
        pandn       mm3,mm1
        por         mm6,mm3
        movd        [edi+ebx],mm6    

        paddw       mm5,mm2
        psrlw       mm5,4

        packuswb    mm5,mm5

        movq        mm3,mm7             //Output masked v7
        movd        mm1,[edi]
        pand        mm5,mm3
        pandn       mm3,mm1
        por         mm5,mm3
        movd        [edi],mm5    
        
        paddw       mm4,mm2
        psrlw       mm4,4

        packuswb    mm4,mm4
        
        movd        mm1,[edi+eax]        //Output masked v8
        pand        mm4,mm7
        pandn       mm7,mm1
        por         mm4,mm7
        movd        [edi+eax],mm4   

        ret
    }                           

    _asm{
DefaultMode4_MMX:
        mov         ebx,eax
        neg         ebx
        lea         edi,[esi+eax*4]
        add         edi,eax

        pxor        mm7,mm7
        movq        mm6,x05
        movq        mm5,x04

        //calculate a3.1
        movd        mm0,[esi+ebx]
        punpcklbw   mm0,mm7
        paddw       mm0,mm0
        movd        mm1,[esi]
        punpcklbw   mm1,mm7
        pmullw      mm1,mm6
        psubw       mm0,mm1
        movd        mm1,[esi+eax]
        punpcklbw   mm1,mm7
        movq        mm2,mm1
        pmullw      mm1,mm6
        paddw       mm0,mm1
        movd        mm1,[esi+eax*2]
        punpcklbw   mm1,mm7
        psubw       mm0,mm1
        psubw       mm0,mm1
        paddw       mm0,mm5
        psraw       mm0,3

        //Calculate a3.0
        paddw       mm2,mm2
        pmullw      mm1,mm6
        psubw       mm2,mm1
        movd        mm1,[edi+ebx*2]
        punpcklbw   mm1,mm7
        movq        mm3,mm1
        pmullw      mm1,mm6
        paddw       mm1,mm2
        movd        mm2,[edi+ebx]
        punpcklbw   mm2,mm7
        psubw       mm1,mm2
        psubw       mm1,mm2
        paddw       mm1,mm5
        psraw       mm1,3

        //Calculate a3.2
        paddw       mm3,mm3
        pmullw      mm2,mm6
        psubw       mm3,mm2
        movd        mm2,[edi]
        punpcklbw   mm2,mm7
        pmullw      mm2,mm6
        paddw       mm2,mm3
        movd        mm3,[edi+eax]
        punpcklbw   mm3,mm7
        psubw       mm2,mm3
        psubw       mm2,mm3
        paddw       mm2,mm5
        psraw       mm2,3

        //SIGN(a30)
        movq        mm5,mm1
        psraw       mm5,16
       
        //MIN(abs(a30),abs(a31),abs(a32))
        movq        mm3,mm0  //abs(a3.1)
        psraw       mm3,16
        pxor        mm0,mm3
        psubw       mm0,mm3

        movq        mm3,mm1  //abs(a3.0)
        movq        mm4,mm1
        psraw       mm3,16
        pxor        mm4,mm3
        psubw       mm4,mm3

        movq        mm3,mm2  //abs(a3,1)
        psraw       mm3,16
        pxor        mm2,mm3
        psubw       mm2,mm3

        movq        mm3,mm4  //if (abs(a3.0) < abs(a3.1)) mm0 = abs(a3.0) else mm0 = abs(a3.1)
        pcmpgtw     mm3,mm0  
        pand        mm0,mm3
        pandn       mm3,mm4
        por         mm0,mm3

        movq        mm3,mm2  //if (mm0 < abs(a3,2)) mm0 = a3.2
        pcmpgtw     mm3,mm0
        pand        mm0,mm3
        pandn       mm3,mm2
        por         mm0,mm3

        pxor        mm0,mm5  //a3.0' = mm0 = (mm0 * SIGN(a3.0))
        psubw       mm0,mm5

        //Broadcast iStepSize
        movd        mm5,iStepSize
        punpcklwd   mm5,mm5
        punpckldq   mm5,mm5
        
        // d = CLIP( (5*(A30-a30)/8),0,  ((v4-v5)/2)   *   ((abs(a30) < iStepSize) ? 1 : 0)   );
        movq        mm6,mm5     // generate mask for  * ((abs(a30) < iStepSize) ? 1 : 0)
        pcmpgtw     mm6,mm4

        psubw       mm0,mm1     //d_temp = 5*(A30-a30)/8
        pmullw      mm0,x05
        movq        mm5,mm0
        psraw       mm5,16
        pxor        mm0,mm5
        psubw       mm0,mm5
        psraw       mm0,3
        pxor        mm0,mm5
        psubw       mm0,mm5
        
        movd        mm3,[esi+eax*2]  //max = (v4-v5)/2
        punpcklbw   mm3,mm7
        movq        mm4,mm3
        movd        mm2,[edi+ebx*2]
        punpcklbw   mm2,mm7
        movq        mm7,mm2
        psubw       mm3,mm2
        pxor        mm3,mm5
        psubw       mm3,mm5
        psraw       mm3,1
        pxor        mm3,mm5
        psubw       mm3,mm5
        
        movq        mm5,mm3         //abs(max)     
        psraw       mm5,16
        pxor        mm3,mm5
        psubw       mm3,mm5
        pxor        mm0,mm5         //if (max < 0) d_temp = d_temp*-1;
        psubw       mm0,mm5

        movq        mm2,mm3         //Clip to less than max
        pcmpgtw     mm2,mm0
        pand        mm0,mm2
        pandn       mm2,mm3
        por         mm0,mm2
        
        pxor        mm2,mm2         //Clip to zero
        pcmpgtw     mm2,mm0
        pandn       mm2,mm0

        pxor        mm2,mm5         //Restore original sign
        psubw       mm2,mm5

        pand        mm2,mm6         //mask out 

        psubw       mm4,mm2
        paddw       mm7,mm2

        packuswb    mm4,mm4
        movd        [esi+eax*2],mm4
        packuswb    mm7,mm7
        movd        [edi+ebx*2],mm7

        ret
   }


    _asm{        

MixedMode4_MMX:

        movq        [esp+40],mm7 
        pand        mm6,mm7
        movq        lminmax2,mm6

        mov         ebx,eax
        neg         ebx
        lea         edi,[esi+eax*4]
        add         edi,eax

        movq        mm7,x80
        movd        mm0,[esi+ebx*2]           //calculate value that will be used as v0
        movd        mm1,[esi+ebx]
        movq        mm2,mm0
        movq        mm3,mm1
        psubusb     mm2,mm1
        psubusb     mm3,mm0
        por         mm2,mm3
        movq        mm5,iStepBroad
        pxor        mm2,mm7
        pxor        mm5,mm7
        pcmpgtb     mm2,mm5
        pand        mm1,mm2
        pandn       mm2,mm0
        por         mm1,mm2             //if (abs(v1-v0) < iStepSize) mm1 = v0 else mm1 = v1

        movq        mm0,mm1

        pxor        mm7,mm7

        movq        mm2,x06             //6*v0
        punpcklbw   mm0,mm7             
        movq        mm5,mm0
        movq        mm4,mm0
        psllw       mm5,2
        pmullw      mm0,mm2
                                        
        movd        mm2,[esi+ebx]       //v1
        punpcklbw   mm2,mm7
        movq        mm3,mm2
        paddw       mm5,mm2
        paddw       mm5,mm2
        paddw       mm4,mm2
        movq        mm6,mm4
        psllw       mm2,2
        paddw       mm0,mm2

        movd        mm2,[esi]           //v2 
        punpcklbw   mm2,mm7
        paddw       mm4,mm2
        paddw       mm3,mm2
        paddw       mm2,mm2
        paddw       mm6,mm2
        paddw       mm0,mm2
        paddw       mm2,mm2
        paddw       mm5,mm2

        movd        mm2,[esi+eax]       //v3
        punpcklbw   mm2,mm7
        paddw       mm2,mm2
        paddw       mm0,mm2
        paddw       mm5,mm2
        paddw       mm4,mm2
        paddw       mm6,mm2
        paddw       mm3,mm2


        movd        mm2,[esi+eax*2]     //v4
        punpcklbw   mm2,mm7
        paddw       mm0,mm2
        paddw       mm4,mm2
        paddw       mm2,mm2
        paddw       mm5,mm2
        paddw       mm6,mm2
        paddw       mm6,mm2
        paddw       mm3,mm2

        movd        mm2,[edi+ebx*2]     //v5
        punpcklbw   mm2,mm7
        paddw       mm0,mm2
        paddw       mm5,mm2
        paddw       mm4,mm2
        paddw       mm4,mm4
        paddw       mm2,mm2
        paddw       mm6,mm2
        paddw       mm3,mm2
        paddw       mm3,mm2

        paddw       mm0,x08
        psrlw       mm0,4
        packuswb    mm0,mm0

        movq        mm7,lminmax2          //Output masked  v1
        movd        mm2,[esi+ebx]
        pand        mm0,mm7
        pandn       mm7,mm2
        por         mm0,mm7
        movd        [esp+4],mm0 
        pxor        mm7,mm7


        movd        mm2,[edi+ebx]         //+ v6
        punpcklbw   mm2,mm7
        paddw       mm5,mm2
        paddw       mm4,mm2
        paddw       mm2,mm2
        paddw       mm6,mm2
        paddw       mm3,mm2
        movq        mm0,mm2

        paddw       mm5,x08
        psrlw       mm5,4
        packuswb    mm5,mm5

        movq        mm7,lminmax2          //Output masked  v2
        movd        mm2,[esi]
        pand        mm5,mm7
        pandn       mm7,mm2
        por         mm5,mm7
        movd        [esp+8],mm5     
        pxor        mm7,mm7


        movd        mm2,[edi]           //+v7     
        punpcklbw   mm2,mm7
        paddw       mm4,mm2
        paddw       mm6,mm2
        paddw       mm2,mm2
        paddw       mm3,mm2

        movq        mm5,mm2

        paddw       mm4,x08
        psrlw       mm4,4
        packuswb    mm4,mm4
        
        movq        mm7,lminmax2          //Output masked  v3
        movd        mm2,[esi+eax]
        pand        mm4,mm7
        pandn       mm7,mm2
        por         mm4,mm7
        movd        [esp+12],mm4     
  
        movq        mm7,mm0
        paddw       mm0,mm5
        movq        mm4,mm0
        paddw       mm0,mm7
        paddw       mm5,mm5
        paddw       mm5,mm7
        pxor        mm7,mm7
    
        movd        mm2,[edi+eax]      //v8
        punpcklbw   mm2,mm7
        paddw       mm6,mm2
        paddw       mm3,mm2
        paddw       mm2,mm2
        paddw       mm0,mm2
        paddw       mm5,mm2
        paddw       mm4,mm2
        paddw       mm4,mm2

        paddw       mm6,x08
        psrlw       mm6,4
        packuswb    mm6,mm6
        
        movq        mm7,lminmax2          //Output masked   v4
        movd        mm2,[esi+eax*2]
        pand        mm6,mm7
        pandn       mm7,mm2
        por         mm6,mm7
        movd        [esp+16],mm6     
        movq        mm6,mm0

        movq        mm7,mm3             //calculate value that will be used as v9
        movd        mm1,[edi+eax*2]           
        movd        mm0,[edi+eax]
        movq        mm2,mm0
        movq        mm3,mm1
        psubusb     mm2,mm1
        psubusb     mm3,mm0
        por         mm2,mm3
        movq        mm3,mm7
        movq        mm7,iStepBroad
        pxor        mm7,x80
        pxor        mm2,x80
        pcmpgtb     mm2,mm7
        pand        mm0,mm2
        pandn       mm2,mm1
        por         mm0,mm2             //if (abs(v8-v9) < iStepSize) mm0 = v9 else mm0 = v8
        movq        mm1,mm3
        pxor        mm7,mm7

        movq        mm3,mm0             //v9
        punpcklbw   mm3,mm7
        paddw       mm1,mm3
        paddw       mm3,mm3
        paddw       mm6,mm3
        movq        mm2,x08
        paddw       mm5,mm3
        paddw       mm5,mm3
        paddw       mm4,mm3
        paddw       mm4,mm3
        paddw       mm4,mm3

        paddw       mm1,mm2
        psrlw       mm1,4
        packuswb    mm1,mm1

        movq        mm3,lminmax2          //Output masked   v5
        movd        mm0,[edi+ebx*2]
        pand        mm1,mm3
        pandn       mm3,mm0
        por         mm1,mm3
        movd        [esp+20],mm1 

        movd        mm1,[esi]           //v2
        punpcklbw   mm1,mm7
        paddw       mm6,mm1

        movd        mm1,[esi+eax]       //v3
        punpcklbw   mm1,mm7
        paddw       mm6,mm1
        paddw       mm5,mm1

        movd        mm1,[esi+eax*2]     //v4
        punpcklbw   mm1,mm7
        paddw       mm5,mm1
        paddw       mm4,mm1
        paddw       mm1,mm1
        paddw       mm6,mm1
        
        movd        mm1,[edi+ebx*2]     //v5
        punpcklbw   mm1,mm7
        paddw       mm4,mm1
        paddw       mm1,mm1
        paddw       mm6,mm1
        paddw       mm5,mm1
        
        paddw       mm6,mm2
        psrlw       mm6,4
        packuswb    mm6,mm6

        movq        mm3,lminmax2          //Output masked v6
        movd        mm1,[edi+ebx]
        pand        mm6,mm3
        pandn       mm3,mm1
        por         mm6,mm3
        movd        [esp+24],mm6 

        paddw       mm5,mm2
        psrlw       mm5,4
        packuswb    mm5,mm5

        movq        mm3,lminmax2          //Output masked v7
        movd        mm0,[edi]
        pand        mm5,mm3
        pandn       mm3,mm0
        por         mm5,mm3
        movd        [esp+28],mm5 

        paddw       mm4,mm2
        psrlw       mm4,4
        packuswb    mm4,mm4
        
        movq        mm3,lminmax2          //Output masked  v8
        movd        mm0,[edi+eax]
        pand        mm4,mm3
        pandn       mm3,mm0
        por         mm4,mm3
        
        movd        [esp+32],mm4    

        movq        mm6,x05
        movq        mm5,x04

        //calculate a3.1
        movd        mm0,[esi+ebx]
        punpcklbw   mm0,mm7
        paddw       mm0,mm0
        movd        mm1,[esi]
        punpcklbw   mm1,mm7
        pmullw      mm1,mm6
        psubw       mm0,mm1
        movd        mm1,[esi+eax]
        punpcklbw   mm1,mm7
        movq        mm2,mm1
        pmullw      mm1,mm6
        paddw       mm0,mm1
        movd        mm1,[esi+eax*2]
        punpcklbw   mm1,mm7
        psubw       mm0,mm1
        psubw       mm0,mm1
        paddw       mm0,mm5
        psraw       mm0,3

        //Calculate a3.0
        paddw       mm2,mm2
        pmullw      mm1,mm6
        psubw       mm2,mm1
        movd        mm1,[edi+ebx*2]
        punpcklbw   mm1,mm7
        movq        mm3,mm1
        pmullw      mm1,mm6
        paddw       mm1,mm2
        movd        mm2,[edi+ebx]
        punpcklbw   mm2,mm7
        psubw       mm1,mm2
        psubw       mm1,mm2
        paddw       mm1,mm5
        psraw       mm1,3

        //Calculate a3.2
        paddw       mm3,mm3
        pmullw      mm2,mm6
        psubw       mm3,mm2
        movd        mm2,[edi]
        punpcklbw   mm2,mm7
        pmullw      mm2,mm6
        paddw       mm2,mm3
        movd        mm3,[edi+eax]
        punpcklbw   mm3,mm7
        psubw       mm2,mm3
        psubw       mm2,mm3
        paddw       mm2,mm5
        psraw       mm2,3
        
        //SIGN(a30)
        movq        mm5,mm1
        psraw       mm5,16
       
        //MIN(abs(a30),abs(a31),abs(a32))
        movq        mm3,mm0  //abs(a3.1)
        psraw       mm3,16
        pxor        mm0,mm3
        psubw       mm0,mm3

        movq        mm3,mm1  //abs(a3.0)
        movq        mm4,mm1
        psraw       mm3,16
        pxor        mm4,mm3
        psubw       mm4,mm3

        movq        mm3,mm2  //abs(a3,1)
        psraw       mm3,16
        pxor        mm2,mm3
        psubw       mm2,mm3

        movq        mm3,mm4  //if (abs(a3.0) < abs(a3.1)) mm0 = abs(a3.0) else mm0 = abs(a3.1)
        pcmpgtw     mm3,mm0  
        pand        mm0,mm3
        pandn       mm3,mm4
        por         mm0,mm3

        movq        mm3,mm2  //if (mm0 < abs(a3,2)) mm0 = a3.2
        pcmpgtw     mm3,mm0
        pand        mm0,mm3
        pandn       mm3,mm2
        por         mm0,mm3

        pxor        mm0,mm5  //a3.0' = mm0 = (mm0 * SIGN(a3.0))
        psubw       mm0,mm5

        //Broadcast iStepSize
        movd        mm5,iStepSize
        punpcklwd   mm5,mm5
        punpckldq   mm5,mm5

        // d = CLIP( (5*(A30-a30)/8),0,  ((v4-v5)/2)   *   ((abs(a30) < iStepSize) ? 1 : 0)   );
        movq        mm6,mm5     // generate mask for  * ((abs(a30) < iStepSize) ? 1 : 0)
        pcmpgtw     mm6,mm4

        psubw       mm0,mm1     //d_temp = 5*(A30-a30)/8
        pmullw      mm0,x05
        movq        mm5,mm0
        psraw       mm5,16
        pxor        mm0,mm5
        psubw       mm0,mm5
        psraw       mm0,3
        pxor        mm0,mm5
        psubw       mm0,mm5
        
        movd        mm3,[esi+eax*2]  //max = (v4-v5)/2
        punpcklbw   mm3,mm7
        movq        mm4,mm3
        movd        mm2,[edi+ebx*2]
        punpcklbw   mm2,mm7
        movq        mm7,mm2
        psubw       mm3,mm2
        pxor        mm3,mm5
        psubw       mm3,mm5
        psraw       mm3,1
        pxor        mm3,mm5
        psubw       mm3,mm5
        
        movq        mm5,mm3         //abs(max)     
        psraw       mm5,16
        pxor        mm3,mm5
        psubw       mm3,mm5
        pxor        mm0,mm5         //if (max < 0) d_temp = d_temp*-1;
        psubw       mm0,mm5

        movq        mm2,mm3         //Clip to less than max
        pcmpgtw     mm2,mm0
        pand        mm0,mm2
        pandn       mm2,mm3
        por         mm0,mm2
        
        pxor        mm2,mm2         //Clip to zero
        pcmpgtw     mm2,mm0
        pandn       mm2,mm0

        pxor        mm2,mm5         //Restore original sign
        psubw       mm2,mm5

        pand        mm2,mm6         //mask out 

        psubw       mm4,mm2
        paddw       mm7,mm2

        movd        mm2,[esp+40] 
        movq        mm3,mm2

        packuswb    mm4,mm4
        pandn       mm2,mm4
        
        packuswb    mm7,mm7
        pandn       mm3,mm7
        
        movd        mm0,[esp+4]            
        movd        [esi+ebx],mm0           //v1

        movd        mm0,[esp+8] 
        movd        [esi],mm0               //v2

        movd        mm0,[esp+12] 
        movd        [esi+eax],mm0           //v3

        movd        mm0,[esp+16] 
        movd        mm1,[esp+40] 
        pand        mm1,mm0
        por         mm1,mm2
        movd        [esi+eax*2],mm1         //v4

        movd        mm0,[esp+20] 
        movd        mm1,[esp+40] 
        pand        mm1,mm0
        por         mm1,mm3
        movd        [edi+ebx*2],mm1         //v5

        movd        mm0,[esp+24]            
        movd        [edi+ebx],mm0           //v6

        movd        mm0,[esp+28]            
        movd        [edi],mm0               //v7
        
        movd        mm0,[esp+32]            
        movd        [edi+eax],mm0           //v8
        ret
  
    } 
}      


Void_WMV FilterHalfHorizantalEdge(U8_WMV* ppxlcCenter, I32_WMV iPixelDistance, I32_WMV iPixelIncrement, I32_WMV iEdgeLength, I32_WMV iStepSize)
{
 
    static const Int64 thr1 = THR1 | (THR1 << 8) | (THR1 << 16) | (THR1 << 24) | ((Int64)THR1 << 32) | ((Int64)THR1 << 40) | ((Int64)THR1 << 48) | ((Int64)THR1 << 56);
    //static const Int64 neg_thr1 = NTHR1 | (NTHR1 << 8) | (NTHR1 << 16) | (NTHR1 << 24) | ((Int64)NTHR1 << 32) | ((Int64)NTHR1 << 40) | ((Int64)NTHR1 << 48) | ((Int64)NTHR1 << 56);
    
    static const Int64 thr2 = (THR2-1) | ((THR2-1) << 8) | ((THR2-1) << 16) | ((THR2-1) << 24) | ((Int64)(THR2-1) << 32) | ((Int64)(THR2-1) << 40) | ((Int64)(THR2-1) << 48) | ((Int64)(THR2-1) << 56);
    static const Int64 x01 = 0x0101010101010101;
    static const Int64 x80 = 0x8080808080808080;
    static const Int64 x06 = 0x0006000600060006;
    static const Int64 x08 = 0x0008000800080008;
    static const Int64 x05 = 0x0005000500050005;
    static const Int64 x04 = 0x0004000400040004;
    static const Int64 x0001 = 0x0001000100010001;
    static const Int64 x0002 = 0x0002000200020002;

    Int64 act;
    Int64 iStepBroad, i2StepBroad;
    Int64 lminmax;
    Int64 lminmax2;
    Int64 mask;
    I32_WMV mytemp;    
    I32_WMV i;
    U8_WMV* pV0 = ppxlcCenter - (iPixelDistance*5);
    
    
            _asm {

        sub esp, 64  // IW

        movd        mm0,iStepSize       //Broadcast iStepSize
        movq        mm5,mm0
        psllq       mm5,8
        por         mm0,mm5
        movq        mm5,mm0
        psllq       mm5,16
        por         mm0,mm5
        movq        mm5,mm0
        psllq       mm5,32
        por         mm0,mm5
        movq        mm5,mm0
        psllq       mm0,1
        psubb       mm5,x01 
        movq        iStepBroad,mm5
        movq        i2StepBroad,mm0
        
        mov         eax,iPixelDistance
        mov         esi,pV0
        lea         esi,[esi+eax*2]

        mov         ecx,iEdgeLength
        shr         ecx,3
HLoop:
        mov         i,ecx

        mov         eax,iPixelDistance
        mov         ebx,eax
        neg         ebx
        lea         edi,[esi+eax*4]
        add         edi,eax

        movq        mm7,thr1
        movq        mm6,x01

        //phi(v0 - v1)
        movq        mm0,[esi+ebx*2]     //Load
        movq        mm1,[esi+ebx]
        psubb       mm0,mm1             //Subtract
        pxor        mm2,mm2             //Absolute Value
        pcmpgtb     mm2,mm0
        pxor        mm0,mm2
        psubb       mm0,mm2
        pcmpgtb     mm0,mm7	            //if (mm0 <= THR1) mm0 = 1 else mm0 = 0
        pandn       mm0,mm6

        //phi(v1 - v2)
        movq        mm2,[esi]
        psubb       mm1,mm2     
        pxor        mm3,mm3     
        pcmpgtb     mm3,mm1
        pxor        mm1,mm3
        pand        mm3,mm6
        paddb       mm1,mm3
        pcmpgtb     mm1,mm7	    
        pandn       mm1,mm6
        paddb       mm0,mm1             

        //phi(v2 - v3)
        movq        mm1,[esi+eax]
        psubb       mm2,mm1 
        pxor        mm3,mm3     
        pcmpgtb     mm3,mm2
        pxor        mm2,mm3
        psubb       mm2,mm3
        pcmpgtb     mm2,mm7	    
        pandn       mm2,mm6
        paddb       mm0,mm2             

        //phi(v3 - v4)
        movq        mm2,[esi+eax*2]
        psubb       mm1,mm2     
        pxor        mm3,mm3     
        pcmpgtb     mm3,mm1
        pxor        mm1,mm3
        psubb       mm1,mm3
        pcmpgtb     mm1,mm7	    
        pandn       mm1,mm6
        paddb       mm0,mm1             

        //phi(v4 - v5)
        movq        mm1,[edi+ebx*2]
        psubb       mm2,mm1     
        pxor        mm3,mm3     
        pcmpgtb     mm3,mm2
        pxor        mm2,mm3
        psubb       mm2,mm3
        pcmpgtb     mm2,mm7	    
        pandn       mm2,mm6
        paddb       mm0,mm2             

        //phi(v5 - v6)
        movq        mm2,[edi+ebx]
        psubb       mm1,mm2     
        pxor        mm3,mm3     
        pcmpgtb     mm3,mm1
        pxor        mm1,mm3
        psubb       mm1,mm3
        pcmpgtb     mm1,mm7	    
        pandn       mm1,mm6
        paddb       mm0,mm1             
        
        //phi(v6 - v7)
        movq        mm1,[edi]
        psubb       mm2,mm1     
        pxor        mm3,mm3     
        pcmpgtb     mm3,mm2
        pxor        mm2,mm3
        psubb       mm2,mm3
        pcmpgtb     mm2,mm7	    
        pandn       mm2,mm6
        paddb       mm0,mm2             
        
        //phi(v7 - v8)
        movq        mm2,[edi+eax]
        psubb       mm1,mm2     
        pxor        mm3,mm3     
        pcmpgtb     mm3,mm1
        pxor        mm1,mm3
        psubb       mm1,mm3
        pcmpgtb     mm1,mm7	    
        pandn       mm1,mm6
        paddb       mm0,mm1             
        
        //phi(v8 - v9)
        movq        mm1,[edi+eax*2]
        psubb       mm2,mm1     
        pxor        mm3,mm3     
        pcmpgtb     mm3,mm2
        pxor        mm2,mm3
        psubb       mm2,mm3
        pcmpgtb     mm2,mm7	    
        pandn       mm2,mm6
        paddb       mm0,mm2             
        
        pcmpgtb     mm0,thr2

        movq        act,mm0

        movq        mm1,mm0
        movq        mm2,mm0
        psrlq       mm2,32
        psrlq       mm1,32
        pand        mm2,mm0
        por         mm1,mm0

        
        movq        mask,mm0

        movd        ebx,mm2     //check for 8 using DC offset mode (long filter)
        cmp         ebx,0xFFFFFFFF
        jz          DcOffsetMode2

        movd        eax,mm0     //check for all 8 using default mode (short filter)
        test        eax,eax
        jz          DefaultMode //Default Mode for all 8

        movd        ebx,mm0    //check for 4 using DC offset mode (long filter)
        cmp         ebx,0xFFFFFFFF
        jz          DcOffsetMode //DC Offset Mode for all 4

        mov         eax,iPixelDistance  //Setup pointers
        call        HalfMinMaxMask
        movq        lminmax,mm6

        movd        mm7,mask           
        call        HalfMixedMode4 

        add         esi,4

        movq        mm0,act
        psrlq       mm0,32
//        movd        eax,mm0

        movd        eax,mm0     //check for all 8 using default mode (short filter)
        test        eax,eax
        jz          DefaultModeA //Default Mode for all 8
        
        movq        mm6,lminmax
        psrlq       mm6,32
        movq        lminmax,mm6

        movd        ebx,mm0    //check for 4 using DC offset mode (long filter)
        cmp         ebx,0xFFFFFFFF
        jz          DcOffsetModeA //DC Offset Mode for all 8
            
MixedModeA:

        mov         eax,iPixelDistance
        movq        mm6,lminmax
        movq        mm7,mask           
        psrlq       mm7,32
        call        HalfMixedMode4 
        
        add         esi,4
        mov         ecx,i
        dec         ecx
        jnz         HLoop
        jmp         end

DcOffsetMode:    
        mov         eax,iPixelDistance  //Setup pointers
        call        HalfMinMaxMask

        mov         eax,iPixelDistance
        movq        lminmax,mm6
        call        HalfDcOffsetMode4

        add         esi,4

        movq        mm6,lminmax
        psrlq       mm6,32
        movq        lminmax,mm6

        movq        mm0,act
        psrlq       mm0,32
//        movd        eax,mm0

        movd        eax,mm0     //check for all 8 using default mode (short filter)
        test        eax,eax
        jz          DefaultModeA //Default Mode for all 8
       
        movd        ebx,mm0    //check for 4 using DC offset mode (long filter)
        cmp         ebx,0xFFFFFFFF
        jnz         MixedModeA
            
DcOffsetModeA:    
        mov         eax,iPixelDistance
        movq        mm6,lminmax
        call        HalfDcOffsetMode4
        
        
        add         esi,4
        mov         ecx,i
        dec         ecx
        jnz         HLoop
        jmp         end

DcOffsetMode2:    

        call        HalfMinMaxMask
        movq        lminmax,mm6
  
            
        mov         eax,iPixelDistance
        call        HalfDcOffsetMode4
        
        add         esi,4

        movq        mm6,lminmax
        psrlq       mm6,32
        movq        lminmax,mm6

        mov         eax,iPixelDistance
        movq        mm6,lminmax
        call        HalfDcOffsetMode4
        

        add         esi,4
        mov         ecx,i
        dec         ecx
        jnz         HLoop
        jmp         end

DefaultMode:
        mov         eax,iPixelDistance
        call        HalfDefaultMode4

        add         esi,4

        movq        mm0,act
        psrlq       mm0,32
//        movd        eax,mm0

        movd        eax,mm0     //check for all 8 using default mode (short filter)
        test        eax,eax
        jz          DefaultModeA //Default Mode for all 8
    
        movd        mytemp,mm0

        mov         eax,iPixelDistance  //Setup pointers
        call        HalfMinMaxMask
        movq        lminmax,mm6


        mov         ebx,mytemp    //check for 4 using DC offset mode (long filter)
        cmp         ebx,0xFFFFFFFF
        jz          DcOffsetModeA //DC Offset Mode for all 8
        
        jmp         MixedModeA

DefaultModeA:

        mov         eax,iPixelDistance
        call        HalfDefaultMode4

        add         esi,4
        mov         ecx,i
        dec         ecx
        jnz         HLoop

end:    emms
        add esp, 64  // IW
        }
        return;
    _asm{
HalfDefaultMode4:

        mov         ebx,eax
        neg         ebx
        lea         edi,[esi+eax*4]
        add         edi,eax

        pxor        mm7,mm7
        movq        mm6,x05
        movq        mm5,x04

        //calculate a3.1
        movd        mm0,[esi+ebx]
        punpcklbw   mm0,mm7
        paddw       mm0,mm0
        movd        mm1,[esi]
        punpcklbw   mm1,mm7
        pmullw      mm1,mm6
        psubw       mm0,mm1
        movd        mm1,[esi+eax]
        punpcklbw   mm1,mm7
        movq        mm2,mm1
        pmullw      mm1,mm6
        paddw       mm0,mm1
        movd        mm1,[esi+eax*2]
        punpcklbw   mm1,mm7
        psubw       mm0,mm1
        psubw       mm0,mm1
        paddw       mm0,mm5
        psraw       mm0,3

        //Calculate a3.0
        paddw       mm2,mm2
        pmullw      mm1,mm6
        psubw       mm2,mm1
        movd        mm1,[edi+ebx*2]
        punpcklbw   mm1,mm7
        movq        mm3,mm1
        pmullw      mm1,mm6
        paddw       mm1,mm2
        movd        mm2,[edi+ebx]
        punpcklbw   mm2,mm7
        psubw       mm1,mm2
        psubw       mm1,mm2
        paddw       mm1,mm5
        psraw       mm1,3

        //Calculate a3.2
        paddw       mm3,mm3
        pmullw      mm2,mm6
        psubw       mm3,mm2
        movd        mm2,[edi]
        punpcklbw   mm2,mm7
        pmullw      mm2,mm6
        paddw       mm2,mm3
        movd        mm3,[edi+eax]
        punpcklbw   mm3,mm7
        psubw       mm2,mm3
        psubw       mm2,mm3
        paddw       mm2,mm5
        psraw       mm2,3

        //SIGN(a30)
        movq        mm5,mm1
        psraw       mm5,16
       
        //MIN(abs(a30),abs(a31),abs(a32))
        movq        mm3,mm0  //abs(a3.1)
        psraw       mm3,16
        pxor        mm0,mm3
        psubw       mm0,mm3

        movq        mm3,mm1  //abs(a3.0)
        movq        mm4,mm1
        psraw       mm3,16
        pxor        mm4,mm3
        psubw       mm4,mm3

        movq        mm3,mm2  //abs(a3,1)
        psraw       mm3,16
        pxor        mm2,mm3
        psubw       mm2,mm3

        movq        mm3,mm4  //if (abs(a3.0) < abs(a3.1)) mm0 = abs(a3.0) else mm0 = abs(a3.1)
        pcmpgtw     mm3,mm0  
        pand        mm0,mm3
        pandn       mm3,mm4
        por         mm0,mm3

        movq        mm3,mm2  //if (mm0 < abs(a3,2)) mm0 = a3.2
        pcmpgtw     mm3,mm0
        pand        mm0,mm3
        pandn       mm3,mm2
        por         mm0,mm3

        pxor        mm0,mm5  //a3.0' = mm0 = (mm0 * SIGN(a3.0))
        psubw       mm0,mm5

        //Broadcast iStepSize
        movd        mm5,iStepSize
        punpcklwd   mm5,mm5
        punpckldq   mm5,mm5

        // d = CLIP( (5*(A30-a30)/8),0,  ((v4-v5)/2)   *   ((abs(a30) < iStepSize) ? 1 : 0)   );
        movq        mm6,mm5     // generate mask for  * ((abs(a30) < iStepSize) ? 1 : 0)
        pcmpgtw     mm6,mm4

        psubw       mm0,mm1     //d_temp = 5*(A30-a30)/8
        pmullw      mm0,x05
        movq        mm5,mm0
        psraw       mm5,16
        pxor        mm0,mm5
        psubw       mm0,mm5
        psraw       mm0,3
        pxor        mm0,mm5
        psubw       mm0,mm5
        
        movd        mm3,[esi+eax*2]  //max = (v4-v5)/2
        punpcklbw   mm3,mm7
        movq        mm4,mm3
        movd        mm2,[edi+ebx*2]
        punpcklbw   mm2,mm7
        movq        mm7,mm2
        psubw       mm3,mm2
        pxor        mm3,mm5
        psubw       mm3,mm5
        psraw       mm3,1
        pxor        mm3,mm5
        psubw       mm3,mm5
        
        movq        mm5,mm3         //abs(max)     
        psraw       mm5,16
        pxor        mm3,mm5
        psubw       mm3,mm5
        pxor        mm0,mm5         //if (max < 0) d_temp = d_temp*-1;
        psubw       mm0,mm5

        movq        mm2,mm3         //Clip to less than max
        pcmpgtw     mm2,mm0
        pand        mm0,mm2
        pandn       mm2,mm3
        por         mm0,mm2
        
        pxor        mm2,mm2         //Clip to zero
        pcmpgtw     mm2,mm0
        pandn       mm2,mm0

        pxor        mm2,mm5         //Restore original sign
        psubw       mm2,mm5

        pand        mm2,mm6         //mask out 

        psubw       mm4,mm2
        paddw       mm7,mm2

        packuswb    mm4,mm4
        movd        [esi+eax*2],mm4
        ret
   }

    _asm{     
HalfMinMaxMask:  // same as MinMaxMask      
        mov         ebx,eax
        neg         ebx
        lea         edi,[esi+eax*4]
        add         edi,eax

        movq        mm7,x80

        movq        mm0,[esi+ebx]       //Load first line
        pxor        mm0,mm7
        movq        mm1,[esi]           //Load second line
        pxor        mm1,mm7
        movq        mm2,mm1             //Min Max first 2 lines
        pcmpgtb     mm2,mm0
        movq        mm4,mm0
        pand        mm0,mm2         
        pxor        mm4,mm0
        pandn       mm2,mm1
        pxor        mm1,mm2
        por         mm0,mm2
        por         mm1,mm4

        movq        mm2,[esi+eax]       //Load third line
        pxor        mm2,mm7
        movq        mm3,[esi+eax*2]     //Load forth line
        pxor        mm3,mm7
        movq        mm4,mm3             //Min Max next 2 lines
        pcmpgtb     mm4,mm2
        movq        mm5,mm2
        pand        mm2,mm4         
        pxor        mm5,mm2
        pandn       mm4,mm3
        pxor        mm3,mm4
        por         mm2,mm4
        por         mm3,mm5
        
        movq        mm4,mm2             //Min first 2 pairs
        pcmpgtb     mm4,mm0
        pand        mm0,mm4
        pandn       mm4,mm2
        por         mm0,mm4

        movq        mm4,mm1             //Max first 2 pairs
        pcmpgtb     mm4,mm3
        pand        mm1,mm4
        pandn       mm4,mm3
        por         mm1,mm4

        movq        mm2,[edi+ebx*2]     //Load fifth line
        pxor        mm2,mm7
        movq        mm3,[edi+ebx]       //Load sixth line
        pxor        mm3,mm7
        movq        mm4,mm3             //Min Max next 2 lines
        pcmpgtb     mm4,mm2
        movq        mm5,mm2
        pand        mm2,mm4         
        pxor        mm5,mm2
        pandn       mm4,mm3
        pxor        mm3,mm4
        por         mm2,mm4
        por         mm3,mm5
        
        movq        mm4,mm2             //Min last 2 pairs
        pcmpgtb     mm4,mm0
        pand        mm0,mm4
        pandn       mm4,mm2
        por         mm0,mm4

        movq        mm4,mm1             //Max last 2 pairs
        pcmpgtb     mm4,mm3
        pand        mm1,mm4
        pandn       mm4,mm3
        por         mm1,mm4

        movq        mm2,[edi]           //Load 7'th line
        pxor        mm2,mm7
        movq        mm3,[edi+eax]       //Load 8'th line
        pxor        mm3,mm7
        movq        mm4,mm3             //Min Max next 2 lines
        pcmpgtb     mm4,mm2
        movq        mm5,mm2
        pand        mm2,mm4         
        pxor        mm5,mm2
        pandn       mm4,mm3
        pxor        mm3,mm4
        por         mm2,mm4
        por         mm3,mm5
        
        movq        mm4,mm2             //Min last 2 pairs
        pcmpgtb     mm4,mm0
        pand        mm0,mm4
        pandn       mm4,mm2
        por         mm0,mm4

        movq        mm4,mm1             //Max last 2 pairs
        pcmpgtb     mm4,mm3
        pand        mm1,mm4
        pandn       mm4,mm3
        por         mm1,mm4

        pxor        mm0,mm7
        pxor        mm1,mm7

        psubb       mm1,mm0

        movq        mm0,i2StepBroad

        pxor        mm0,mm7
        pxor        mm1,mm7
        pcmpgtb     mm0,mm1             // (max-min) < 2*iStepSize

        movq        mm6,mm0
        ret
        }

    _asm{      
HalfDcOffsetMode4:        
        movq        lminmax2,mm6

        mov         ebx,eax
        neg         ebx
        lea         edi,[esi+eax*4]
        add         edi,eax

        movq        mm7,x80
        movd        mm1,[esi+ebx*2]           //calculate value that will be used as v0
        movd        mm0,[esi+ebx]
        movq        mm2,mm1
        movq        mm3,mm0
        psubusb     mm2,mm0
        psubusb     mm3,mm1
        por         mm2,mm3
        movq        mm5,iStepBroad
        pxor        mm2,mm7
        pxor        mm5,mm7
        pcmpgtb     mm2,mm5
        pand        mm0,mm2
        pandn       mm2,mm1
        por         mm0,mm2             //if (abs(v1-v0) < iStepSize) mm0 = v0 else mm0 = v1

        pxor        mm7,mm7
        
        movq        mm2,x06             //6*v0
        punpcklbw   mm0,mm7             
        movq        mm5,mm0
        movq        mm4,mm0
        psllw       mm5,2
        pmullw      mm0,mm2
                                        
        movd        mm2,[esi+ebx]       //v1
        punpcklbw   mm2,mm7
        movq        mm3,mm2
        paddw       mm5,mm2
        paddw       mm5,mm2
        paddw       mm4,mm2
        movq        mm6,mm4
        psllw       mm2,2
        paddw       mm0,mm2

        movd        mm2,[esi]           //v2 
        punpcklbw   mm2,mm7
        paddw       mm4,mm2
        paddw       mm3,mm2
        paddw       mm2,mm2
        paddw       mm6,mm2
        paddw       mm0,mm2
        paddw       mm2,mm2
        paddw       mm5,mm2

        movd        mm2,[esi+eax]       //v3
        punpcklbw   mm2,mm7
        paddw       mm2,mm2
        paddw       mm0,mm2
        paddw       mm5,mm2
        paddw       mm4,mm2
        paddw       mm6,mm2
        paddw       mm3,mm2


        movd        mm2,[esi+eax*2]     //v4
        punpcklbw   mm2,mm7
        paddw       mm0,mm2
        paddw       mm4,mm2
        paddw       mm2,mm2
        paddw       mm5,mm2
        paddw       mm6,mm2
        paddw       mm6,mm2
        paddw       mm3,mm2

        movd        mm2,[edi+ebx*2]     //v5
        punpcklbw   mm2,mm7
        paddw       mm0,mm2
        paddw       mm5,mm2
        paddw       mm4,mm2
        movq        mm1,x08
        paddw       mm4,mm4
        paddw       mm2,mm2
        paddw       mm6,mm2
        paddw       mm3,mm2
        paddw       mm3,mm2

        paddw       mm0,mm1
        psrlw       mm0,4

        packuswb    mm0,mm0

        movq        mm7,lminmax2          //Output masked  v1
        movd        mm2,[esi+ebx]
        pand        mm0,mm7
        pandn       mm7,mm2
        por         mm0,mm7
        movd        [esi+ebx],mm0    
        pxor        mm7,mm7

        movd        mm2,[edi+ebx]       //+ v6
        punpcklbw   mm2,mm7
        paddw       mm5,mm2
        paddw       mm4,mm2
        paddw       mm2,mm2
        paddw       mm6,mm2
        paddw       mm3,mm2
        movq        mm0,mm2

        paddw       mm5,mm1
        psrlw       mm5,4

        packuswb    mm5,mm5

        movq        mm7,lminmax2          //Output masked  v2
        movd        mm2,[esi]
        pand        mm5,mm7
        pandn       mm7,mm2
        por         mm5,mm7
        movd        [esi],mm5    

        pxor        mm7,mm7


        movd        mm2,[edi]           //+v7     
        punpcklbw   mm2,mm7
        paddw       mm4,mm2
        paddw       mm6,mm2
        paddw       mm2,mm2
        paddw       mm3,mm2

        movq        mm5,mm2

        paddw       mm4,mm1
        psrlw       mm4,4

        packuswb    mm4,mm4
        
        movq        mm7,lminmax2          //Output masked  v3
        movd        mm2,[esi+eax]
        pand        mm4,mm7
        pandn       mm7,mm2
        por         mm4,mm7
        movd        [esi+eax],mm4    
  
        movq        mm7,mm0
        paddw       mm0,mm5
        movq        mm4,mm0
        paddw       mm0,mm7
        paddw       mm5,mm5
        paddw       mm5,mm7
        pxor        mm7,mm7
     
        movd        mm2,[edi+eax]       //v8
        punpcklbw   mm2,mm7
        paddw       mm6,mm2
        paddw       mm3,mm2
        paddw       mm2,mm2
        movq        mm7,x08
        paddw       mm0,mm2
        paddw       mm5,mm2
        paddw       mm4,mm2
        paddw       mm4,mm2

        paddw       mm6,mm7
        psrlw       mm6,4

        packuswb    mm6,mm6
        
        movq        mm7,lminmax2          //Output masked   v4
        movd        mm2,[esi+eax*2]
        pand        mm6,mm7
        pandn       mm7,mm2
        por         mm6,mm7
        movd        [esi+eax*2],mm6    
        ret
    }                           

    _asm{ 
        
HalfMixedMode4:
        movq        [esp+40],mm7
        pand        mm6,mm7
        movq        lminmax2,mm6

        mov         ebx,eax
        neg         ebx
        lea         edi,[esi+eax*4]
        add         edi,eax

        movq        mm7,x80
        movd        mm0,[esi+ebx*2]           //calculate value that will be used as v0
        movd        mm1,[esi+ebx]
        movq        mm2,mm0
        movq        mm3,mm1
        psubusb     mm2,mm1
        psubusb     mm3,mm0
        por         mm2,mm3
        movq        mm5,iStepBroad
        pxor        mm2,mm7
        pxor        mm5,mm7
        pcmpgtb     mm2,mm5
        pand        mm1,mm2
        pandn       mm2,mm0
        por         mm1,mm2             //if (abs(v1-v0) < iStepSize) mm1 = v0 else mm1 = v1

        movq        mm0,mm1

        pxor        mm7,mm7

        movq        mm2,x06             //6*v0
        punpcklbw   mm0,mm7             
        movq        mm5,mm0
        movq        mm4,mm0
        psllw       mm5,2
        pmullw      mm0,mm2
                                        
        movd        mm2,[esi+ebx]       //v1
        punpcklbw   mm2,mm7
        movq        mm3,mm2
        paddw       mm5,mm2
        paddw       mm5,mm2
        paddw       mm4,mm2
        movq        mm6,mm4
        psllw       mm2,2
        paddw       mm0,mm2

        movd        mm2,[esi]           //v2 
        punpcklbw   mm2,mm7
        paddw       mm4,mm2
        paddw       mm3,mm2
        paddw       mm2,mm2
        paddw       mm6,mm2
        paddw       mm0,mm2
        paddw       mm2,mm2
        paddw       mm5,mm2

        movd        mm2,[esi+eax]       //v3
        punpcklbw   mm2,mm7
        paddw       mm2,mm2
        paddw       mm0,mm2
        paddw       mm5,mm2
        paddw       mm4,mm2
        paddw       mm6,mm2
        paddw       mm3,mm2


        movd        mm2,[esi+eax*2]     //v4
        punpcklbw   mm2,mm7
        paddw       mm0,mm2
        paddw       mm4,mm2
        paddw       mm2,mm2
        paddw       mm5,mm2
        paddw       mm6,mm2
        paddw       mm6,mm2
        paddw       mm3,mm2

        movd        mm2,[edi+ebx*2]     //v5
        punpcklbw   mm2,mm7
        paddw       mm0,mm2
        paddw       mm5,mm2
        paddw       mm4,mm2
        paddw       mm4,mm4
        paddw       mm2,mm2
        paddw       mm6,mm2
        paddw       mm3,mm2
        paddw       mm3,mm2

        paddw       mm0,x08
        psrlw       mm0,4
        packuswb    mm0,mm0

        movq        mm7,lminmax2          //Output masked  v1
        movd        mm2,[esi+ebx]
        pand        mm0,mm7
        pandn       mm7,mm2
        por         mm0,mm7
        movd        [esp+4],mm0
        pxor        mm7,mm7


        movd        mm2,[edi+ebx]         //+ v6
        punpcklbw   mm2,mm7
        paddw       mm5,mm2
        paddw       mm4,mm2
        paddw       mm2,mm2
        paddw       mm6,mm2
        paddw       mm3,mm2
        movq        mm0,mm2

        paddw       mm5,x08
        psrlw       mm5,4
        packuswb    mm5,mm5

        movq        mm7,lminmax2          //Output masked  v2
        movd        mm2,[esi]
        pand        mm5,mm7
        pandn       mm7,mm2
        por         mm5,mm7
        movd        [esp+8],mm5    
        pxor        mm7,mm7


        movd        mm2,[edi]           //+v7     
        punpcklbw   mm2,mm7
        paddw       mm4,mm2
        paddw       mm6,mm2
        paddw       mm2,mm2
        paddw       mm3,mm2

        movq        mm5,mm2

        paddw       mm4,x08
        psrlw       mm4,4
        packuswb    mm4,mm4
        
        movq        mm7,lminmax2          //Output masked  v3
        movd        mm2,[esi+eax]
        pand        mm4,mm7
        pandn       mm7,mm2
        por         mm4,mm7
        movd        [esp+12],mm4    
  
        movq        mm7,mm0
        paddw       mm0,mm5
        movq        mm4,mm0
        paddw       mm0,mm7
        paddw       mm5,mm5
        paddw       mm5,mm7
        pxor        mm7,mm7
    
        movd        mm2,[edi+eax]      //v8
        punpcklbw   mm2,mm7
        paddw       mm6,mm2
        paddw       mm3,mm2
        paddw       mm2,mm2
        paddw       mm0,mm2
        paddw       mm5,mm2
        paddw       mm4,mm2
        paddw       mm4,mm2

        paddw       mm6,x08
        psrlw       mm6,4
        packuswb    mm6,mm6
        
        movq        mm7,lminmax2          //Output masked   v4
        movd        mm2,[esi+eax*2]
        pand        mm6,mm7
        pandn       mm7,mm2
        por         mm6,mm7
        movd        [esp+16],mm6    
        movq        mm6,mm0

        pxor        mm7,mm7
        movq        mm6,x05
        movq        mm5,x04

        //calculate a3.1
        movd        mm0,[esi+ebx]
        punpcklbw   mm0,mm7
        paddw       mm0,mm0
        movd        mm1,[esi]
        punpcklbw   mm1,mm7
        pmullw      mm1,mm6
        psubw       mm0,mm1
        movd        mm1,[esi+eax]
        punpcklbw   mm1,mm7
        movq        mm2,mm1
        pmullw      mm1,mm6
        paddw       mm0,mm1
        movd        mm1,[esi+eax*2]
        punpcklbw   mm1,mm7
        psubw       mm0,mm1
        psubw       mm0,mm1
        paddw       mm0,mm5
        psraw       mm0,3

        //Calculate a3.0
        paddw       mm2,mm2
        pmullw      mm1,mm6
        psubw       mm2,mm1
        movd        mm1,[edi+ebx*2]
        punpcklbw   mm1,mm7
        movq        mm3,mm1
        pmullw      mm1,mm6
        paddw       mm1,mm2
        movd        mm2,[edi+ebx]
        punpcklbw   mm2,mm7
        psubw       mm1,mm2
        psubw       mm1,mm2
        paddw       mm1,mm5
        psraw       mm1,3

        //Calculate a3.2
        paddw       mm3,mm3
        pmullw      mm2,mm6
        psubw       mm3,mm2
        movd        mm2,[edi]
        punpcklbw   mm2,mm7
        pmullw      mm2,mm6
        paddw       mm2,mm3
        movd        mm3,[edi+eax]
        punpcklbw   mm3,mm7
        psubw       mm2,mm3
        psubw       mm2,mm3
        paddw       mm2,mm5
        psraw       mm2,3
        
        //SIGN(a30)
        movq        mm5,mm1
        psraw       mm5,16
       
        //MIN(abs(a30),abs(a31),abs(a32))
        movq        mm3,mm0  //abs(a3.1)
        psraw       mm3,16
        pxor        mm0,mm3
        psubw       mm0,mm3

        movq        mm3,mm1  //abs(a3.0)
        movq        mm4,mm1
        psraw       mm3,16
        pxor        mm4,mm3
        psubw       mm4,mm3

        movq        mm3,mm2  //abs(a3,1)
        psraw       mm3,16
        pxor        mm2,mm3
        psubw       mm2,mm3

        movq        mm3,mm4  //if (abs(a3.0) < abs(a3.1)) mm0 = abs(a3.0) else mm0 = abs(a3.1)
        pcmpgtw     mm3,mm0  
        pand        mm0,mm3
        pandn       mm3,mm4
        por         mm0,mm3

        movq        mm3,mm2  //if (mm0 < abs(a3,2)) mm0 = a3.2
        pcmpgtw     mm3,mm0
        pand        mm0,mm3
        pandn       mm3,mm2
        por         mm0,mm3

        pxor        mm0,mm5  //a3.0' = mm0 = (mm0 * SIGN(a3.0))
        psubw       mm0,mm5

        //Broadcast iStepSize
        movd        mm5,iStepSize
        punpcklwd   mm5,mm5
        punpckldq   mm5,mm5
        /*
        movq        mm6,mm5
        psllq       mm5,16
        por         mm6,mm5
        movq        mm5,mm6
        psllq       mm5,32
        por         mm5,mm6
          */
        // d = CLIP( (5*(A30-a30)/8),0,  ((v4-v5)/2)   *   ((abs(a30) < iStepSize) ? 1 : 0)   );
        movq        mm6,mm5     // generate mask for  * ((abs(a30) < iStepSize) ? 1 : 0)
        pcmpgtw     mm6,mm4

        psubw       mm0,mm1     //d_temp = 5*(A30-a30)/8
        pmullw      mm0,x05
        movq        mm5,mm0
        psraw       mm5,16
        pxor        mm0,mm5
        psubw       mm0,mm5
        psraw       mm0,3
        pxor        mm0,mm5
        psubw       mm0,mm5
        
        movd        mm3,[esi+eax*2]  //max = (v4-v5)/2
        punpcklbw   mm3,mm7
        movq        mm4,mm3
        movd        mm2,[edi+ebx*2]
        punpcklbw   mm2,mm7
        movq        mm7,mm2
        psubw       mm3,mm2
        pxor        mm3,mm5
        psubw       mm3,mm5
        psraw       mm3,1
        pxor        mm3,mm5
        psubw       mm3,mm5
        

        movq        mm5,mm3         //abs(max)     
        psraw       mm5,16
        pxor        mm3,mm5
        psubw       mm3,mm5
        pxor        mm0,mm5         //if (max < 0) d_temp = d_temp*-1;
        psubw       mm0,mm5

        movq        mm2,mm3         //Clip to less than max
        pcmpgtw     mm2,mm0
        pand        mm0,mm2
        pandn       mm2,mm3
        por         mm0,mm2
        
        pxor        mm2,mm2         //Clip to zero
        pcmpgtw     mm2,mm0
        pandn       mm2,mm0

        pxor        mm2,mm5         //Restore original sign
        psubw       mm2,mm5

        pand        mm2,mm6         //mask out 

        psubw       mm4,mm2
        paddw       mm7,mm2

        movd        mm2,[esp+40]
        movq        mm3,mm2

        packuswb    mm4,mm4
        pandn       mm2,mm4
        
        packuswb    mm7,mm7
        pandn       mm3,mm7
        
        movd        mm0,[esp+4]           
        movd        [esi+ebx],mm0           //v1

        movd        mm0,[esp+8]
        movd        [esi],mm0               //v2

        movd        mm0,[esp+12]
        movd        [esi+eax],mm0           //v3

        movd        mm0,[esp+16]
        movd        mm1,[esp+40]
        pand        mm1,mm0
        por         mm1,mm2
        movd        [esi+eax*2],mm1         //v4

        ret
  
    }                    