ACE_ERROR(ConvertPkcsToCmsRecipientIndexError)
TRACE_ERROR(GetCmsRecipientIndexError)
SET_ERROR(NotKeyAgreeRecipientIndex, CRYPT_E_INVALID_INDEX)
SET_ERROR(UnprotectedAttrMissingError,CRYPT_E_ATTRIBUTES_MISSING)
#else
TRACE_ERROR(GetOssIssuerAndSerialNumberError)           // error already set
#endif  // CMS_PKCS7
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
}


//+=========================================================================
//  Data structures and functions to test and compare the NEW Net Meeting
//  ASN1 compiler and RTS with the OSS compiler and RTS.
//-=========================================================================

#ifdef DEBUG_CRYPT_ASN1

//#define DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG              0x010
//#define DEBUG_OSS_CRYPT_ASN1_CMSG_COMPARE_FLAG      0x020
//#define DEBUG_OSS_CRYPT_ASN1_SAME_ENCRYPT_FLAG      0x100

//static BOOL fGotDebugCryptAsn1Flags = FALSE;
//static int iDebugCryptAsn1Flags = 0;

#ifdef DEBUG_CRYPT_ASN1_MASTER

typedef HCRYPTMSG (WINAPI *PFN_CRYPT_MSG_OPEN_TO_ENCODE)(
    IN DWORD dwMsgEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN void const *pvMsgEncodeInfo,
    IN OPTIONAL LPSTR pszInnerContentObjID,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo
    );
static PFN_CRYPT_MSG_OPEN_TO_ENCODE pfnOssCryptMsgOpenToEncode = NULL;

typedef HCRYPTMSG (WINAPI *PFN_CRYPT_MSG_OPEN_TO_DECODE)(
    IN DWORD dwMsgEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN HCRYPTPROV hCryptProv,
    IN OPTIONAL PCERT_INFO pRecipientInfo,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo
    );
static PFN_CRYPT_MSG_OPEN_TO_DECODE pfnOssCryptMsgOpenToDecode = NULL;

typedef HCRYPTMSG (WINAPI *PFN_CRYPT_MSG_DUPLICATE)(
    IN HCRYPTMSG hCryptMsg
    );
static PFN_CRYPT_MSG_DUPLICATE pfnOssCryptMsgDuplicate = NULL;

typedef BOOL (WINAPI *PFN_CRYPT_MSG_CLOSE)(
    IN HCRYPTMSG hCryptMsg
    );
static PFN_CRYPT_MSG_CLOSE pfnOssCryptMsgClose = NULL;

typedef BOOL (WINAPI *PFN_CRYPT_MSG_UPDATE)(
    IN HCRYPTMSG hCryptMsg,
    IN const BYTE *pbData,
    IN DWORD cbData,
    IN BOOL fFinal
    );
static PFN_CRYPT_MSG_UPDATE pfnOssCryptMsgUpdate = NULL;

typedef BOOL (WINAPI *PFN_CRYPT_MSG_GET_PARAM)(
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    );
static PFN_CRYPT_MSG_GET_PARAM pfnOssCryptMsgGetParam = NULL;

typedef BOOL (WINAPI *PFN_CRYPT_MSG_CONTROL)(
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwFlags,
    IN DWORD dwCtrlType,
    IN void const *pvCtrlPara
    );
static PFN_CRYPT_MSG_CONTROL pfnOssCryptMsgControl = NULL;


#ifdef CMS_PKCS7

typedef BOOL (WINAPI *PFN_CRYPT_MSG_VERIFY_COUNTERSIGNATURE_ENCODED_EX)(
    IN HCRYPTPROV   hCryptProv,
    IN DWORD        dwEncodingType,
    IN PBYTE        pbSignerInfo,
    IN DWORD        cbSignerInfo,
    IN PBYTE        pbSignerInfoCountersignature,
    IN DWORD        cbSignerInfoCountersignature,
    IN DWORD        dwSignerType,
    IN void         *pvSigner,
    IN DWORD        dwFlags,
    IN OPTIONAL void *pvReserved
    );
static PFN_CRYPT_MSG_VERIFY_COUNTERSIGNATURE_ENCODED_EX
            pfnOssCryptMsgVerifyCountersignatureEncodedEx = NULL;

#endif  // CMS_PKCS7

typedef BOOL (WINAPI *PFN_CRYPT_MSG_COUNTERSIGN)(
    IN OUT HCRYPTMSG            hCryptMsg,
    IN DWORD                    dwIndex,
    IN DWORD                    cCountersigners,
    IN PCMSG_SIGNER_ENCODE_INFO rgCountersigners
    );
static PFN_CRYPT_MSG_COUNTERSIGN pfnOssCryptMsgCountersign = NULL;

typedef BOOL (WINAPI *PFN_CRYPT_MSG_COUNTERSIGN_ENCODED)(
    IN DWORD                    dwEncodingType,
    IN PBYTE                    pbSignerInfo,
    IN DWORD                    cbSignerInfo,
    IN DWORD                    cCountersigners,
    IN PCMSG_SIGNER_ENCODE_INFO rgCountersigners,
    OUT PBYTE                   pbCountersignature,
    IN OUT PDWORD               pcbCountersignature
    );
static PFN_CRYPT_MSG_COUNTERSIGN_ENCODED
            pfnOssCryptMsgCountersignEncoded = NULL;

#endif  // DEBUG_CRYPT_ASN1_MASTER


int
WINAPI
ICMTest_GetDebugCryptAsn1Flags()
{
    if (!fGotDebugCryptAsn1Flags) {
        char    *pszEnvVar;
        char    *p;
        int     iFlags;

        if (pszEnvVar = getenv("DEBUG_CRYPT_ASN1_FLAGS")) {
            iFlags = strtol(pszEnvVar, &p, 16);
#ifdef DEBUG_CRYPT_ASN1_MASTER
            if (iFlags) {
                if (NULL == (hOssCryptDll = LoadLibraryA("osscrypt.dll"))) {
                    iFlags = 0;
                    MessageBoxA(
                        NULL,           // hwndOwner
                        "LoadLibrary(osscrypt.dll) failed",
                        "CheckCryptMessageAsn1",
                        MB_TOPMOST | MB_OK | MB_ICONWARNING |
                            MB_SERVICE_NOTIFICATION
                        );
                } else if (NULL == (pfnOssCryptMsgOpenToEncode = 
                            (PFN_CRYPT_MSG_OPEN_TO_ENCODE) 
                                GetProcAddress(hOssCryptDll,
                                    "CryptMsgOpenToEncode")) ||
                        NULL == (pfnOssCryptMsgOpenToDecode = 
                            (PFN_CRYPT_MSG_OPEN_TO_DECODE) 
                                GetProcAddress(hOssCryptDll,
                                    "CryptMsgOpenToDecode")) ||
                        NULL == (pfnOssCryptMsgDuplicate = 
                            (PFN_CRYPT_MSG_DUPLICATE) 
                                GetProcAddress(hOssCryptDll,
                                    "CryptMsgDuplicate")) ||
                        NULL == (pfnOssCryptMsgClose = 
                            (PFN_CRYPT_MSG_CLOSE) 
                                GetProcAddress(hOssCryptDll,
                                    "CryptMsgClose")) ||
                        NULL == (pfnOssCryptMsgUpdate = 
                            (PFN_CRYPT_MSG_UPDATE) 
                                GetProcAddress(hOssCryptDll,
                                    "CryptMsgUpdate")) ||
                        NULL == (pfnOssCryptMsgControl = 
                            (PFN_CRYPT_MSG_CONTROL) 
                                GetProcAddress(hOssCryptDll,
                                    "CryptMsgControl")) ||
                        NULL == (pfnOssCryptMsgGetParam = 
                            (PFN_CRYPT_MSG_GET_PARAM) 
                                GetProcAddress(hOssCryptDll,
                                    "CryptMsgGetParam")) ||
#ifdef CMS_PKCS7
                        NULL == (pfnOssCryptMsgVerifyCountersignatureEncodedEx = 
                            (PFN_CRYPT_MSG_VERIFY_COUNTERSIGNATURE_ENCODED_EX) 
                                GetProcAddress(hOssCryptDll,
                                    "CryptMsgVerifyCountersignatureEncodedEx"))
                                        ||
#endif  // CMS_PKCS7
                        NULL == (pfnOssCryptMsgCountersign = 
                            (PFN_CRYPT_MSG_COUNTERSIGN) 
                                GetProcAddress(hOssCryptDll,
                                    "CryptMsgCountersign")) ||
                        NULL == (pfnOssCryptMsgCountersignEncoded = 
                            (PFN_CRYPT_MSG_COUNTERSIGN_ENCODED) 
                                GetProcAddress(hOssCryptDll,
                                    "CryptMsgCountersignEncoded"))) {
                    iFlags = 0;
                    MessageBoxA(
                        NULL,           // hwndOwner
                        "GetProcAddress(osscrypt.dll) failed",
                        "CheckCryptMessageAsn1",
                        MB_TOPMOST | MB_OK | MB_ICONWARNING |
                            MB_SERVICE_NOTIFICATION
                        );
                }
            }
#endif  // DEBUG_CRYPT_ASN1_MASTER
        } else
            iFlags = 0;

        if (iFlags & DEBUG_OSS_CRYPT_ASN1_CMSG_COMPARE_FLAG)
            iFlags &= ~DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG;

        iDebugCryptAsn1Flags = iFlags;
        fGotDebugCryptAsn1Flags = TRUE;
    }
    return iDebugCryptAsn1Flags;
}

HCRYPTKEY
ICMTest_GetSameEncryptKey()
{
    DWORD dwError = 0;
    HCRYPTPROV hCryptProv;                // doesn't need to be freed
    HCRYPTHASH hHash = 0;
    HCRYPTKEY hDeriveKey = 0;
    BYTE rgbBaseData[] = {1,2,3,4,5,6,7,8};

    hCryptProv = I_CryptGetDefaultCryptProvForEncrypt(
        0,          // aiPubKey
        CALG_RC2,
        0           // dwBitLen
        );

    if (0 == hCryptProv)
        goto GetDefaultCryptProvError;

    if (!CryptCreateHash(hCryptProv, CALG_SHA1, 0, 0, &hHash))
        goto CreateHashError;
    if (!CryptHashData(hHash, rgbBaseData, sizeof(rgbBaseData), 0))
        goto HashDataError;
    if (!CryptDeriveKey(hCryptProv, CALG_RC2, hHash, 0, &hDeriveKey))
        goto DeriveKeyError;

CommonReturn:
    if (hHash)
        CryptDestroyHash(hHash);
    ICM_SetLastError(dwError);
    return hDeriveKey;
ErrorReturn:
    dwError = GetLastError();
    if (hDeriveKey) {
        CryptDestroyKey(hDeriveKey);
        hDeriveKey = 0;
    }
    goto CommonReturn;

TRACE_ERROR(GetDefaultCryptProvError)
TRACE_ERROR(CreateHashError)
TRACE_ERROR(HashDataError)
TRACE_ERROR(DeriveKeyError)
}

#ifdef CMS_PKCS7

BOOL
WINAPI
ICM_DefaultGenContentEncryptKey(
    IN OUT PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    )
{
    int iOssAsn1Flags = ICMTest_GetDebugCryptAsn1Flags();

    if (0 == (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_SAME_ENCRYPT_FLAG))
        return ICMTest_DefaultGenContentEncryptKey(
            pContentEncryptInfo,
            dwFlags,
            pvReserved
            );

    pContentEncryptInfo->hContentEncryptKey = ICMTest_GetSameEncryptKey();
    if (pContentEncryptInfo->hContentEncryptKey)
        return TRUE;
    else
        return FALSE;
}

BOOL
WINAPI
ICM_DefaultExportKeyTrans(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTransEncodeInfo,
    IN OUT PCMSG_KEY_TRANS_ENCRYPT_INFO pKeyTransEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    )
{
    int iOssAsn1Flags = ICMTest_GetDebugCryptAsn1Flags();
    PCRYPT_DATA_BLOB pEncryptedKey;
    BYTE rgbEncryptedKey[] = {1,1,2,2,3,3,4,4,5,5};

    if (0 == (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_SAME_ENCRYPT_FLAG))
        return ICMTest_DefaultExportKeyTrans(
            pContentEncryptInfo,
            pKeyTransEncodeInfo,
            pKeyTransEncryptInfo,
            dwFlags,
            pvReserved
            );

    pEncryptedKey = &pKeyTransEncryptInfo->EncryptedKey;
    if (NULL == (pEncryptedKey->pbData = (PBYTE) ICM_Alloc(
            sizeof(rgbEncryptedKey))))
        return FALSE;
    pEncryptedKey->cbData = sizeof(rgbEncryptedKey);
    memcpy(pEncryptedKey->pbData, rgbEncryptedKey, sizeof(rgbEncryptedKey));
    return TRUE;
}

BOOL
WINAPI
ICM_DefaultImportKeyTrans(
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA pKeyTransDecryptPara,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT HCRYPTKEY *phContentEncryptKey
    )
{
    int iOssAsn1Flags = ICMTest_GetDebugCryptAsn1Flags();

    if (0 == (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_SAME_ENCRYPT_FLAG))
        return ICMTest_DefaultImportKeyTrans(
            pContentEncryptionAlgorithm,
            pKeyTransDecryptPara,
            dwFlags,
            pvReserved,
            phContentEncryptKey
            );
    *phContentEncryptKey = ICMTest_GetSameEncryptKey();
    if (*phContentEncryptKey)
        return TRUE;
    else
        return FALSE;
}

#endif  // CMS_PKCS7


#ifdef DEBUG_CRYPT_ASN1_MASTER

void
ICMTest_MessageBox(
    IN LPSTR pszText
    )
{
    int id;
    LPSTR pszAlloc = NULL;
    DWORD cchAlloc;

    static LPCSTR pszSelect =
        " Select Cancel to stop future OssCryptAsn1 Cryptographic Messages.";

    cchAlloc = strlen(pszText) + strlen(pszSelect) + 1;

    if (pszAlloc = (LPSTR) ICM_Alloc(cchAlloc)) {
        strcpy(pszAlloc, pszText);
        strcat(pszAlloc, pszSelect);
        pszText = pszAlloc;
    }

    id = MessageBoxA(
        NULL,           // hwndOwner
        pszText,
        "CheckCryptMessageAsn1",
        MB_TOPMOST | MB_OKCANCEL | MB_ICONQUESTION |
            MB_SERVICE_NOTIFICATION
        );
    if (IDCANCEL == id)
        iDebugCryptAsn1Flags = 0;

    ICM_Free(pszAlloc);
}

void
ICMTest_MessageBoxLastError(
    IN LPSTR pszText,
    IN DWORD dwOssErr,
    IN DWORD dwNewErr
    )
{
    char szText[512];

    if (dwNewErr == (DWORD) PkiAsn1ErrToHr(ASN1_ERR_BADTAG) &&
            (OSS_DATA_ERROR == dwOssErr || OSS_PDU_MISMATCH == dwOssErr))
        return;
    if (dwNewErr == (DWORD) PkiAsn1ErrToHr(ASN1_ERR_EOD) &&
            OSS_MORE_INPUT == dwOssErr)
        return;

    wsprintfA(szText,
        "%s:: failed with different LastError Oss: %d 0x%x New: %d 0x%x.",
        pszText, dwOssErr, dwOssErr, dwNewErr, dwNewErr
        );
    ICMTest_MessageBox(szText);
}

//+-------------------------------------------------------------------------
//  Write an encoded DER blob to a file
//--------------------------------------------------------------------------
BOOL
ICMTest_WriteDERToFile(
    LPCSTR  pszFileName,
    PBYTE   pbDER,
    DWORD   cbDER
    )
{
    BOOL fResult;

    // Write the Encoded Blob to the file
    HANDLE hFile;
    hFile = CreateFile(pszFileName,
                GENERIC_WRITE,
                0,                  // fdwShareMode
                NULL,               // lpsa
                CREATE_ALWAYS,
                0,                  // fdwAttrsAndFlags
                0);                 // TemplateFile
    if (INVALID_HANDLE_VALUE == hFile) {
        fResult = FALSE;
    } else {
        DWORD dwBytesWritten;
        fResult = WriteFile(
                hFile,
                pbDER,
                cbDER,
                &dwBytesWritten,
                NULL            // lpOverlapped
                );
        CloseHandle(hFile);
    }
    return fResult;
}


#define TEST_MAGIC -12348765

// Note, in the following data structure lMagic is at the same offest as
// lRefCnt in CRYPT_MSG_INFO. lRefCnt should never be negative.
typedef struct _OSS_CRYPT_ASN1_MSG_INFO {
    // The following must be ordered the same as CRYPT_MSG_INFO through
    // dwEncodingType. msghlpr.cpp does a (PCRYPT_MSG_INFO) cast to
    // access dwEncodingType.
    CRITICAL_SECTION        CriticalSection;
    LONG                    lMagic;             // lRefCnt in CRYPT_MSG_INFO
    HCRYPTPROV              hCryptProv;         // decode
    BOOL                    fDefaultCryptProv;  // decode
    DWORD                   dwKeySpec;          // key to use in CryptSignHash
    DWORD                   dwEncodingType;     // encode

    LONG                    lRefCnt;
    union {
        HCRYPTMSG               hNewCryptMsg;
        PCRYPT_MSG_INFO         pNewcmi;
    };
    union {
        HCRYPTMSG               hOssCryptMsg;
        PCRYPT_MSG_INFO         pOsscmi;
    };
    PFN_CMSG_STREAM_OUTPUT  pfnStreamOutput;
    void                    *pvArg;
    BYTE                    *pbOssOutput;
    DWORD                   cbOssOutput;
    BOOL                    fOssFinal;
    BYTE                    *pbNewOutput;
    DWORD                   cbNewOutput;
    BOOL                    fNewFinal;
    BOOL                    fDidCompare;
} OSS_CRYPT_ASN1_MSG_INFO, *POSS_CRYPT_ASN1_MSG_INFO;

BOOL
WINAPI
ICMTest_OssStreamOutput(
    IN const void *pvArg,
    IN BYTE *pbData,
    IN DWORD cbData,
    IN BOOL fFinal
    )
{
    POSS_CRYPT_ASN1_MSG_INFO pInfo = (POSS_CRYPT_ASN1_MSG_INFO) pvArg;
    assert(TEST_MAGIC == pInfo->lMagic);

    assert(!pInfo->fOssFinal);
    pInfo->fOssFinal = fFinal;

    if (cbData) {
        BYTE *pbOssOutput;

        if (pbOssOutput = (BYTE *) ICM_ReAlloc(pInfo->pbOssOutput,
                pInfo->cbOssOutput + cbData)) {
            memcpy(pbOssOutput + pInfo->cbOssOutput, pbData, cbData);
            pInfo->pbOssOutput = pbOssOutput;
            pInfo->cbOssOutput += cbData;
        }
    }
    return TRUE;
}

BOOL
WINAPI
ICMTest_NewStreamOutput(
    IN const void *pvArg,
    IN BYTE *pbData,
    IN DWORD cbData,
    IN BOOL fFinal
    )
{
    POSS_CRYPT_ASN1_MSG_INFO pInfo = (POSS_CRYPT_ASN1_MSG_INFO) pvArg;
    assert(TEST_MAGIC == pInfo->lMagic);

    assert(!pInfo->fNewFinal);
    pInfo->fNewFinal = fFinal;

    if (cbData) {
        BYTE *pbNewOutput;

        if (pbNewOutput = (BYTE *) ICM_ReAlloc(pInfo->pbNewOutput,
                pInfo->cbNewOutput + cbData)) {
            memcpy(pbNewOutput + pInfo->cbNewOutput, pbData, cbData);
            pInfo->pbNewOutput = pbNewOutput;
            pInfo->cbNewOutput += cbData;
        }
    }

    return pInfo->pfnStreamOutput(
        pInfo->pvArg,
        pbData,
        cbData,
        fFinal
        );
}

void
ICMTest_CompareMessageBox(
    IN LPSTR pszText,
    IN BYTE *pbOss,
    IN DWORD cbOss,
    IN BYTE *pbNew,
    IN DWORD cbNew
    )
{
    if (NULL == pbOss || NULL == pbNew)
        return;

    if (cbOss != cbNew || 0 != memcmp(pbOss, pbNew, cbNew)) {
        ICMTest_WriteDERToFile("ossasn1.der", pbOss, cbOss);
        ICMTest_WriteDERToFile("newasn1.der", pbNew, cbNew);
        
        ICMTest_MessageBox(pszText);
    }
}

void
ICMTest_CompareStreamOutput(
    IN POSS_CRYPT_ASN1_MSG_INFO pInfo,
    IN BOOL fForceCompare = FALSE
    )
{
    BOOL fDoCompare;

    if (NULL == pInfo->pfnStreamOutput || pInfo->fDidCompare)
        return;

    fDoCompare = fForceCompare;
    if (pInfo->fOssFinal || pInfo->fNewFinal)
        fDoCompare = TRUE;

    if (fDoCompare) {
        if (pInfo->fOssFinal != pInfo->fNewFinal) {
            if (pInfo->fOssFinal)
                ICMTest_MessageBox("No fFinal on NewStreamOutput.");
            else
                ICMTest_MessageBox("No fFinal on OssStreamOutput.");
        }

        ICMTest_CompareMessageBox(
            "StreamOutput compare failed. Check ossasn1.der and newasn1.der.",
            pInfo->pbOssOutput,
            pInfo->cbOssOutput,
            pInfo->pbNewOutput,
            pInfo->cbNewOutput
            );

        pInfo->fDidCompare = TRUE;
    }
}

void
ICMTest_CompareGetParam(
    IN POSS_CRYPT_ASN1_MSG_INFO pInfo,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    IN void *pvOssData,
    IN DWORD cbOssData,
    IN void *pvNewData,
    IN DWORD cbNewData
    )
{
    char szText[512];

    switch (dwParamType) {
        case CMSG_TYPE_PARAM:
        case CMSG_CONTENT_PARAM:
        case CMSG_BARE_CONTENT_PARAM:
        case CMSG_INNER_CONTENT_TYPE_PARAM:
        case CMSG_SIGNER_COUNT_PARAM:
        case CMSG_CERT_COUNT_PARAM:
        case CMSG_CERT_PARAM:
        case CMSG_CRL_COUNT_PARAM:
        case CMSG_CRL_PARAM:
        case CMSG_RECIPIENT_COUNT_PARAM:
        case CMSG_HASH_DATA_PARAM:
        case CMSG_COMPUTED_HASH_PARAM:
        case CMSG_ENCRYPTED_DIGEST:
        case CMSG_ENCODED_SIGNER:
        case CMSG_ENCODED_MESSAGE:
#ifdef CMS_PKCS7
        case CMSG_VERSION_PARAM:
        case CMSG_ATTR_CERT_COUNT_PARAM:
        case CMSG_ATTR_CERT_PARAM:
        case CMSG_CMS_RECIPIENT_COUNT_PARAM:
#endif  // CMS_PKCS7
            break;
        default:
            return;
    }

    if (NULL == pvOssData || NULL == pvNewData)
        return;


    wsprintfA(szText,
        "ParamType: %d compare failed. Check ossasn1.der and newasn1.der.",
        dwParamType
        );

    ICMTest_CompareMessageBox(
        szText,
        (BYTE *) pvOssData,
        cbOssData,
        (BYTE *) pvNewData,
        cbNewData
        );
}

inline
void
ICMTest_Lock(
    IN POSS_CRYPT_ASN1_MSG_INFO pInfo
    )
{
    EnterCriticalSection( &pInfo->CriticalSection);
}

inline
void
ICMTest_Unlock(
    IN POSS_CRYPT_ASN1_MSG_INFO pInfo
    )
{
    LeaveCriticalSection( &pInfo->CriticalSection);
}

HCRYPTMSG
WINAPI
CryptMsgOpenToEncode(
    IN DWORD dwMsgEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN void const *pvMsgEncodeInfo,
    IN OPTIONAL LPSTR pszInnerContentObjID,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo
    )
{
    int iOssAsn1Flags = ICMTest_GetDebugCryptAsn1Flags();

    if (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_CMSG_COMPARE_FLAG) {
        POSS_CRYPT_ASN1_MSG_INFO pInfo;
        CMSG_STREAM_INFO StreamInfo;
        DWORD dwOssErr;
        DWORD dwNewErr;

        if (NULL == (pInfo = (POSS_CRYPT_ASN1_MSG_INFO) ICM_AllocZero(
                sizeof(OSS_CRYPT_ASN1_MSG_INFO))))
            return NULL;
        pInfo->lMagic = TEST_MAGIC;

        if (pStreamInfo) {
            pInfo->pfnStreamOutput = pStreamInfo->pfnStreamOutput;
            pInfo->pvArg = pStreamInfo->pvArg;
            StreamInfo.cbContent = pStreamInfo->cbContent;
            // StreamInfo.pfnStreamOutput =
            StreamInfo.pvArg = pInfo;
            pStreamInfo = &StreamInfo;
        }

        StreamInfo.pfnStreamOutput = ICMTest_NewStreamOutput;
        pInfo->hNewCryptMsg = ICMTest_NewCryptMsgOpenToEncode(
            dwMsgEncodingType,
            dwFlags,
            dwMsgType,
            pvMsgEncodeInfo,
            pszInnerContentObjID,
            pStreamInfo
            );
        dwNewErr = GetLastError();

        StreamInfo.pfnStreamOutput = ICMTest_OssStreamOutput;
        pInfo->hOssCryptMsg = pfnOssCryptMsgOpenToEncode(
            dwMsgEncodingType,
            dwFlags & ~CMSG_CRYPT_RELEASE_CONTEXT_FLAG,
            dwMsgType,
            pvMsgEncodeInfo,
            pszInnerContentObjID,
            pStreamInfo
            );
        dwOssErr = GetLastError();

        if (pInfo->hNewCryptMsg) {
            if (pInfo->hOssCryptMsg) {
                pInfo->dwEncodingType = pInfo->pNewcmi->dwEncodingType;
                InitializeCriticalSection(&pInfo->CriticalSection);
                pInfo->lRefCnt = 1;
                return (HCRYPTMSG) pInfo;
            } else {
                HCRYPTMSG hRet;
                ICMTest_MessageBox("OssCryptMsgOpenToEncode failed.");
                hRet = pInfo->hNewCryptMsg;
                ICM_Free(pInfo);
                return hRet;
            }
        } else {
            if (pInfo->hOssCryptMsg) {
                ICMTest_MessageBox("OssCryptMsgOpenToEncode succeeded while NewCryptMsgOpenToEncoded failed.");
                pfnOssCryptMsgClose(pInfo->hOssCryptMsg);
            } else if (dwOssErr != dwNewErr)
                ICMTest_MessageBoxLastError("CryptMsgOpenToEncode",
                    dwOssErr, dwNewErr);

            ICM_Free(pInfo);
            SetLastError(dwNewErr);
            return NULL;
        }
    } else if (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG)
        return pfnOssCryptMsgOpenToEncode(
            dwMsgEncodingType,
            dwFlags,
            dwMsgType,
            pvMsgEncodeInfo,
            pszInnerContentObjID,
            pStreamInfo
            );
    else
        return ICMTest_NewCryptMsgOpenToEncode(
            dwMsgEncodingType,
            dwFlags,
            dwMsgType,
            pvMsgEncodeInfo,
            pszInnerContentObjID,
            pStreamInfo
            );
}

HCRYPTMSG
WINAPI
CryptMsgOpenToDecode(
    IN DWORD dwMsgEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN HCRYPTPROV hCryptProv,
    IN OPTIONAL PCERT_INFO pRecipientInfo,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo
    )
{
    int iOssAsn1Flags = ICMTest_GetDebugCryptAsn1Flags();

    if (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_CMSG_COMPARE_FLAG) {
        POSS_CRYPT_ASN1_MSG_INFO pInfo;
        CMSG_STREAM_INFO StreamInfo;
        DWORD dwOssErr;
        DWORD dwNewErr;

        if (NULL == (pInfo = (POSS_CRYPT_ASN1_MSG_INFO) ICM_AllocZero(
                sizeof(OSS_CRYPT_ASN1_MSG_INFO))))
            return NULL;
        pInfo->lMagic = TEST_MAGIC;

        if (pStreamInfo) {
            pInfo->pfnStreamOutput = pStreamInfo->pfnStreamOutput;
            pInfo->pvArg = pStreamInfo->pvArg;
            StreamInfo.cbContent = pStreamInfo->cbContent;
            // StreamInfo.pfnStreamOutput =
            StreamInfo.pvArg = pInfo;
            pStreamInfo = &StreamInfo;
        }

        StreamInfo.pfnStreamOutput = ICMTest_NewStreamOutput;
        pInfo->hNewCryptMsg = ICMTest_NewCryptMsgOpenToDecode(
            dwMsgEncodingType,
            dwFlags,
            dwMsgType,
            hCryptProv,
            pRecipientInfo,
            pStreamInfo
            );
        dwNewErr = GetLastError();

        StreamInfo.pfnStreamOutput = ICMTest_OssStreamOutput;
        pInfo->hOssCryptMsg = pfnOssCryptMsgOpenToDecode(
            dwMsgEncodingType,
            dwFlags & ~CMSG_CRYPT_RELEASE_CONTEXT_FLAG,
            dwMsgType,
            hCryptProv,
            pRecipientInfo,
            pStreamInfo
            );
        dwOssErr = GetLastError();

        if (pInfo->hNewCryptMsg) {
            if (pInfo->hOssCryptMsg) {
                pInfo->dwEncodingType = pInfo->pNewcmi->dwEncodingType;
                InitializeCriticalSection(&pInfo->CriticalSection);
                pInfo->lRefCnt = 1;
                return (HCRYPTMSG) pInfo;
            } else {
                HCRYPTMSG hRet;
                ICMTest_MessageBox("OssCryptMsgOpenToDecode failed.");
                hRet = pInfo->hNewCryptMsg;
                ICM_Free(pInfo);
                return hRet;
            }
        } else {
            if (pInfo->hOssCryptMsg) {
                ICMTest_MessageBox("OssCryptMsgOpenToDecode succeeded while NewCryptMsgOpenToDecode failed.");
                pfnOssCryptMsgClose(pInfo->hOssCryptMsg);
            } else if (dwOssErr != dwNewErr)
                ICMTest_MessageBoxLastError("CryptMsgOpenToDecode",
                    dwOssErr, dwNewErr);

            ICM_Free(pInfo);
            SetLastError(dwNewErr);
            return NULL;
        }
    } else if (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG)
        return pfnOssCryptMsgOpenToDecode(
            dwMsgEncodingType,
            dwFlags,
            dwMsgType,
            hCryptProv,
            pRecipientInfo,
            pStreamInfo
            );
    else
        return ICMTest_NewCryptMsgOpenToDecode(
            dwMsgEncodingType,
            dwFlags,
            dwMsgType,
            hCryptProv,
            pRecipientInfo,
            pStreamInfo
            );
}

HCRYPTMSG
WINAPI
CryptMsgDuplicate(
    IN HCRYPTMSG hCryptMsg
    )
{
    POSS_CRYPT_ASN1_MSG_INFO pInfo = (POSS_CRYPT_ASN1_MSG_INFO) hCryptMsg;
    if (pInfo && TEST_MAGIC == pInfo->lMagic) {
        InterlockedIncrement(&pInfo->lRefCnt);
        return hCryptMsg;
    } else if (ICMTest_GetDebugCryptAsn1Flags() &
                DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG)
        return pfnOssCryptMsgDuplicate(hCryptMsg);
    else
        return ICMTest_NewCryptMsgDuplicate(hCryptMsg);
}

BOOL
WINAPI
CryptMsgClose(
    IN HCRYPTMSG hCryptMsg
    )
{
    BOOL fRet;
    DWORD dwError;

    POSS_CRYPT_ASN1_MSG_INFO pInfo = (POSS_CRYPT_ASN1_MSG_INFO) hCryptMsg;

    if (NULL == pInfo)
        return TRUE;
    if (TEST_MAGIC != pInfo->lMagic) {
        if (iDebugCryptAsn1Flags &
                DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG)
            return pfnOssCryptMsgClose(hCryptMsg);
        else
            return ICMTest_NewCryptMsgClose(hCryptMsg);
    }
    if (0 != InterlockedDecrement(&pInfo->lRefCnt))
        return TRUE;

    // Preserve LastError
    dwError = GetLastError();

    assert(pInfo->hOssCryptMsg);
    assert(1 == ((PCRYPT_MSG_INFO) pInfo->hOssCryptMsg)->lRefCnt);
    assert(pInfo->hNewCryptMsg);
    assert(1 == ((PCRYPT_MSG_INFO) pInfo->hNewCryptMsg)->lRefCnt);

    ICMTest_CompareStreamOutput(pInfo, TRUE);

    pfnOssCryptMsgClose(pInfo->hOssCryptMsg);
    fRet = ICMTest_NewCryptMsgClose(pInfo->hNewCryptMsg);

    ICM_Free(pInfo->pbOssOutput);
    ICM_Free(pInfo->pbNewOutput);
    DeleteCriticalSection(&pInfo->CriticalSection);
    ICM_Free(pInfo);

    SetLastError(dwError);              // Preserve LastError
    return fRet;
}


BOOL
WINAPI
CryptMsgUpdate(
    IN HCRYPTMSG hCryptMsg,
    IN const BYTE *pbData,
    IN DWORD cbData,
    IN BOOL fFinal
    )
{
    BOOL fNew;
    DWORD dwNewErr;
    BOOL fOss;
    DWORD dwOssErr;

    POSS_CRYPT_ASN1_MSG_INFO pInfo = (POSS_CRYPT_ASN1_MSG_INFO) hCryptMsg;

    if (NULL == pInfo || TEST_MAGIC != pInfo->lMagic) {
        if (ICMTest_GetDebugCryptAsn1Flags() &
                DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG)
            return pfnOssCryptMsgUpdate(
                hCryptMsg,
                pbData,
                cbData,
                fFinal
                );
        else
            return ICMTest_NewCryptMsgUpdate(
                hCryptMsg,
                pbData,
                cbData,
                fFinal
                );
    }

    ICMTest_Lock(pInfo);

    fOss = pfnOssCryptMsgUpdate(
        pInfo->hOssCryptMsg,
        pbData,
        cbData,
        fFinal
        );
    dwOssErr = GetLastError();

    fNew = ICMTest_NewCryptMsgUpdate(
        pInfo->hNewCryptMsg,
        pbData,
        cbData,
        fFinal
        );
    dwNewErr = GetLastError();

    if (fNew) {
        if (fOss)
            ICMTest_CompareStreamOutput(pInfo);
        else
            ICMTest_MessageBox("OssCryptMsgUpdate failed.");
    } else {
        if (fOss)
            ICMTest_MessageBox("OssCryptMsgUpdate succeeded while NewCryptMsgUpdate failed.");
        else if (dwOssErr != dwNewErr)
            ICMTest_MessageBoxLastError("CryptMsgUpdate",
                dwOssErr, dwNewErr);

    }

    ICMTest_Unlock(pInfo);

    SetLastError(dwNewErr);
    return fNew;
}
    

BOOL
WINAPI
CryptMsgGetParam(
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    BOOL fOss;
    DWORD dwOssErr;
    void *pvOssData = NULL;
    DWORD cbOssData;
    BOOL fNew;
    DWORD dwNewErr;

    POSS_CRYPT_ASN1_MSG_INFO pInfo = (POSS_CRYPT_ASN1_MSG_INFO) hCryptMsg;

    if (NULL == pInfo || TEST_MAGIC != pInfo->lMagic) {
        if (ICMTest_GetDebugCryptAsn1Flags() &
                DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG)
            return pfnOssCryptMsgGetParam(
                hCryptMsg,
                dwParamType,
                dwIndex,
                pvData,
                pcbData
                );
        else
            return ICMTest_NewCryptMsgGetParam(
                hCryptMsg,
                dwParamType,
                dwIndex,
                pvData,
                pcbData
                );
    }

    ICMTest_Lock(pInfo);

    cbOssData = *pcbData;
    if (pvData)
        pvOssData = ICM_Alloc(cbOssData);

    fOss = pfnOssCryptMsgGetParam(
        pInfo->hOssCryptMsg,
        dwParamType,
        dwIndex,
        pvOssData,
        &cbOssData
        );
    dwOssErr = GetLastError();

    fNew = ICMTest_NewCryptMsgGetParam(
        pInfo->hNewCryptMsg,
        dwParamType,
        dwIndex,
        pvData,
        pcbData
        );
    dwNewErr = GetLastError();

    if (fNew) {
        if (fOss)
            ICMTest_CompareGetParam(
                pInfo,
                dwParamType,
                dwIndex,
                pvOssData,
                cbOssData,
                pvData,
                *pcbData
                );
        else
            ICMTest_MessageBox("OssCryptMsgGetParam failed.");
    } else {
        if (fOss)
            ICMTest_MessageBox("OssCryptMsgGetParam succeeded while NewCryptMsgGetParam failed.");
        else if (dwOssErr != dwNewErr)
            ICMTest_MessageBoxLastError("CryptMsgGetParam",
                dwOssErr, dwNewErr);
    }

    ICMTest_Unlock(pInfo);
    ICM_Free(pvOssData);
    SetLastError(dwNewErr);
    return fNew;
}


BOOL
WINAPI
CryptMsgControl(
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwFlags,
    IN DWORD dwCtrlType,
    IN void const *pvCtrlPara
    )
{
    BOOL fNew;
    DWORD dwNewErr;
    BOOL fOss;
    DWORD dwOssErr;

    POSS_CRYPT_ASN1_MSG_INFO pInfo = (POSS_CRYPT_ASN1_MSG_INFO) hCryptMsg;

    if (NULL == pInfo || TEST_MAGIC != pInfo->lMagic) {
        if (ICMTest_GetDebugCryptAsn1Flags() &
                DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG)
            return pfnOssCryptMsgControl(
                hCryptMsg,
                dwFlags,
                dwCtrlType,
                pvCtrlPara
                );
        else
            return ICMTest_NewCryptMsgControl(
                hCryptMsg,
                dwFlags,
                dwCtrlType,
                pvCtrlPara
                );
    }

    ICMTest_Lock(pInfo);

    fOss = pfnOssCryptMsgControl(
        pInfo->hOssCryptMsg,
        dwFlags & ~CMSG_CRYPT_RELEASE_CONTEXT_FLAG,
        dwCtrlType,
        pvCtrlPara
        );
    dwOssErr = GetLastError();

    fNew = ICMTest_NewCryptMsgControl(
        pInfo->hNewCryptMsg,
        dwFlags,
        dwCtrlType,
        pvCtrlPara
        );
    dwNewErr = GetLastError();

    if (fNew) {
        if (fOss)
            ICMTest_CompareStreamOutput(pInfo);
        else
            ICMTest_MessageBox("OssCryptMsgControl failed.");
    } else {
        if (fOss)
            ICMTest_MessageBox("OssCryptMsgControl succeeded while NewCryptMsgControl failed.");
        else if (dwOssErr != dwNewErr)
            ICMTest_MessageBoxLastError("CryptMsgControl",
                dwOssErr, dwNewErr);

    }

    ICMTest_Unlock(pInfo);

    SetLastError(dwNewErr);
    return fNew;
}



#ifdef CMS_PKCS7
BOOL
WINAPI
CryptMsgVerifyCountersignatureEncodedEx(
    IN HCRYPTPROV   hCryptProv,
    IN DWORD        dwEncodingType,
    IN PBYTE        pbSignerInfo,
    IN DWORD        cbSignerInfo,
    IN PBYTE        pbSignerInfoCountersignature,
    IN DWORD        cbSignerInfoCountersignature,
    IN DWORD        dwSignerType,
    IN void         *pvSigner,
    IN DWORD        dwFlags,
    IN OPTIONAL void *pvReserved
    )
{
    BOOL fOss;
    int iOssAsn1Flags = ICMTest_GetDebugCryptAsn1Flags();

    if (0 == (iOssAsn1Flags &
            (DEBUG_OSS_CRYPT_ASN1_CMSG_COMPARE_FLAG |
                DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG)))
        return ICMTest_NewCryptMsgVerifyCountersignatureEncodedEx(
            hCryptProv,
            dwEncodingType,
            pbSignerInfo,
            cbSignerInfo,
            pbSignerInfoCountersignature,
            cbSignerInfoCountersignature,
            dwSignerType,
            pvSigner,
            dwFlags,
            pvReserved
            );

    fOss = pfnOssCryptMsgVerifyCountersignatureEncodedEx(
            hCryptProv,
            dwEncodingType,
            pbSignerInfo,
            cbSignerInfo,
            pbSignerInfoCountersignature,
            cbSignerInfoCountersignature,
            dwSignerType,
            pvSigner,
            dwFlags,
            pvReserved
            );

    if (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_CMSG_COMPARE_FLAG) {
        DWORD dwOssErr = GetLastError();
        BOOL fNew;
        DWORD dwNewErr;

        fNew = ICMTest_NewCryptMsgVerifyCountersignatureEncodedEx(
            hCryptProv,
            dwEncodingType,
            pbSignerInfo,
            cbSignerInfo,
            pbSignerInfoCountersignature,
            cbSignerInfoCountersignature,
            dwSignerType,
            pvSigner,
            dwFlags,
            pvReserved
            );
        dwNewErr = GetLastError();

        if (fNew) {
            if (!fOss)
                ICMTest_MessageBox("OssCryptMsgVerifyCountersignatureEncodedEx failed.");
        } else {
            if (fOss)
                ICMTest_MessageBox("OssCryptMsgVerifyCountersignatureEncodedEx succeeded while NewCryptMsgVerifyCountersignatureEncodedEx failed.");
            else if (dwOssErr != dwNewErr)
                ICMTest_MessageBoxLastError("CryptMsgVerifyCountersignatureEncodedEx",
                    dwOssErr, dwNewErr);

        }

        SetLastError(dwOssErr);
    }

    return fOss;

}
#endif  // CMS_PKCS7

BOOL
WINAPI
CryptMsgCountersign(
    IN OUT HCRYPTMSG            hCryptMsg,
    IN DWORD                    dwIndex,
    IN DWORD                    cCountersigners,
    IN PCMSG_SIGNER_ENCODE_INFO rgCountersigners
    )
{
    BOOL fNew;
    DWORD dwNewErr;
    BOOL fOss;
    DWORD dwOssErr;

    POSS_CRYPT_ASN1_MSG_INFO pInfo = (POSS_CRYPT_ASN1_MSG_INFO) hCryptMsg;

    if (NULL == pInfo || TEST_MAGIC != pInfo->lMagic) {
        if (ICMTest_GetDebugCryptAsn1Flags() &
                DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG)
            return pfnOssCryptMsgCountersign(
                hCryptMsg,
                dwIndex,
                cCountersigners,
                rgCountersigners
                );
        else
            return ICMTest_NewCryptMsgCountersign(
                hCryptMsg,
                dwIndex,
                cCountersigners,
                rgCountersigners
                );
    }

    ICMTest_Lock(pInfo);

    fOss = pfnOssCryptMsgCountersign(
        pInfo->hOssCryptMsg,
        dwIndex,
        cCountersigners,
        rgCountersigners
        );
    dwOssErr = GetLastError();

    fNew = ICMTest_NewCryptMsgCountersign(
        pInfo->hNewCryptMsg,
        dwIndex,
        cCountersigners,
        rgCountersigners
        );
    dwNewErr = GetLastError();

    if (fNew) {
        if (!fOss)
            ICMTest_MessageBox("OssCryptMsgCountersign failed.");
    } else {
        if (fOss)
            ICMTest_MessageBox("OssCryptMsgCountersign succeeded while NewCryptMsgCountersign failed.");
        else if (dwOssErr != dwNewErr)
            ICMTest_MessageBoxLastError("CryptMsgCountersign",
                dwOssErr, dwNewErr);

    }

    ICMTest_Unlock(pInfo);

    SetLastError(dwNewErr);
    return fNew;
}

BOOL
WINAPI
CryptMsgCountersignEncoded(
    IN DWORD                    dwEncodingType,
    IN PBYTE                    pbSignerInfo,
    IN DWORD                    cbSignerInfo,
    IN DWORD                    cCountersigners,
    IN PCMSG_SIGNER_ENCODE_INFO rgCountersigners,
    OUT PBYTE                   pbCountersignature,
    IN OUT PDWORD               pcbCountersignature
    )
{
    BOOL fOss;
    int iOssAsn1Flags = ICMTest_GetDebugCryptAsn1Flags();
    BYTE *pbNew = NULL;
    DWORD cbNew;

    if (0 == (iOssAsn1Flags &
            (DEBUG_OSS_CRYPT_ASN1_CMSG_COMPARE_FLAG |
                DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG)))
        return ICMTest_NewCryptMsgCountersignEncoded(
            dwEncodingType,
            pbSignerInfo,
            cbSignerInfo,
            cCountersigners,
            rgCountersigners,
            pbCountersignature,
            pcbCountersignature
            );

    if (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_CMSG_COMPARE_FLAG) {
        cbNew = *pcbCountersignature;
        if (pbCountersignature)
            pbNew = (BYTE *) ICM_Alloc(cbNew);
    }

    fOss = pfnOssCryptMsgCountersignEncoded(
            dwEncodingType,
            pbSignerInfo,
            cbSignerInfo,
            cCountersigners,
            rgCountersigners,
            pbCountersignature,
            pcbCountersignature
            );

    if (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_CMSG_COMPARE_FLAG) {
        DWORD dwOssErr = GetLastError();
        BOOL fNew;
        DWORD dwNewErr;

        fNew = ICMTest_NewCryptMsgCountersignEncoded(
            dwEncodingType,
            pbSignerInfo,
            cbSignerInfo,
            cCountersigners,
            rgCountersigners,
            pbNew,
            &cbNew
            );
        dwNewErr = GetLastError();


        if (fNew) {
            if (fOss)
                ICMTest_CompareMessageBox(
                    "CountersignEncoded compare failed. Check ossasn1.der and newasn1.der.",
                    pbCountersignature,
                    *pcbCountersignature,
                    pbNew,
                    cbNew
                    );
            else
                ICMTest_MessageBox("NewCryptMsgCountersignEncoded failed.");
        } else {
            if (fOss)
                ICMTest_MessageBox("OssCryptMsgCountersignEncoded succeeded while NewCryptMsgCountersignEncoded failed.");
            else if (dwOssErr != dwNewErr)
                ICMTest_MessageBoxLastError("CryptMsgCountersignEncoded",
                    dwOssErr, dwNewErr);

        }

        SetLastError(dwOssErr);
    }

    ICM_Free(pbNew);
    return fOss;
}


#endif  // DEBUG_CRYPT_ASN1_MASTER

#endif  // DEBUG_CRYPT_ASN1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\errparse\errclass.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       errclass.cpp
//
//--------------------------------------------------------------------------

#include "errparse.h"


//**************************************************************
CErrorMessage::CErrorMessage( DWORD dwErrorNumber, char *pszSymbolicName, char *pszDescription )
// Constructor
//**************************************************************
{
    m_pszSymbolicName = m_pszDescription = NULL;
    m_dwErrorNumber = dwErrorNumber;

    if( NULL != pszSymbolicName )
    {
        m_pszSymbolicName = new char[( strlen( pszSymbolicName ) + 1 )];
        if( NULL != m_pszSymbolicName )
        {
            strcpy( m_pszSymbolicName, pszSymbolicName );
        }
    }

    if( NULL != pszDescription )
    {
        m_pszDescription = new char[( strlen( pszDescription ) + 1 )];
        if( NULL != m_pszDescription )
        {
            strcpy( m_pszDescription, pszDescription );
        }
    }
}


//**************************************************************
BOOL CErrorMessage::CSetErrorMessage( DWORD dwErrorNumber, char *pszSymbolicName, char *pszDescription )
// Real Constructor
//**************************************************************
{
    if( m_pszSymbolicName != NULL )
    {
        delete m_pszDescription;
    }

    if( m_pszDescription != NULL )
    {
        delete m_pszDescription;
    }
    m_pszSymbolicName = m_pszDescription = NULL;
    m_dwErrorNumber = dwErrorNumber;


    if( NULL != pszSymbolicName )
    {
        m_pszSymbolicName = new char[ ( strlen( pszSymbolicName ) + 1 ) ];
        if( NULL != m_pszSymbolicName )
        {
            strcpy( m_pszSymbolicName, pszSymbolicName );
        }
    }

    if( NULL != pszDescription )
    {
        m_pszDescription = new char[ ( strlen( pszDescription ) + 1 ) ];
        if( NULL != m_pszDescription )
        {
            strcpy( m_pszDescription, pszDescription );
        }
    }
    return( TRUE );
}


//**************************************************************
CErrorMessage::~CErrorMessage()
// Deconstructor
//**************************************************************
{
    delete m_pszSymbolicName;
    delete m_pszDescription;
}

//**************************************************************
BOOL CErrorMessage::CPrint( FILE * pFile )
// Prints out object info to given file
//**************************************************************
{
    char * pFirstChar;
    
    if( NULL == &pFile )
    {
        return( FALSE );
    }

    //We can store incorrectly, but we ensure here that we print correctly
    while( NULL != ( pFirstChar = strchr( m_pszDescription, '\\' ) ) )
    {
       *pFirstChar = '/';
    }

    while( NULL != ( pFirstChar = strchr( m_pszDescription, '\"' ) ) )
    {
       *pFirstChar = '\'';
    }
    
    if( 0 == (fprintf( pFile, "    { %lu, \"%s\", \"%s\" },\n", m_dwErrorNumber, m_pszSymbolicName, m_pszDescription) ) )
    {
        return( FALSE );
    }
    
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\wincrmsg\msghlpr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       msghlpr.cpp
//
//  Contents:   Cryptographic Message Helper APIs
//
//  APIs:       CryptMsgGetAndVerifySigner
//              CryptMsgSignCTL
//              CryptMsgEncodeAndSignCTL
//
//  History:    02-May-97   philh    created
//--------------------------------------------------------------------------

#include "global.hxx"
#include "pkialloc.h"

void *ICM_AllocAndGetMsgParam(
    IN HCRYPTMSG hMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex
    )
{
    void *pvData;
    DWORD cbData;

    if (!CryptMsgGetParam(
            hMsg,
            dwParamType,
            dwIndex,
            NULL,           // pvData
            &cbData) || 0 == cbData)
        goto GetParamError;
    if (NULL == (pvData = ICM_Alloc(cbData)))
        goto OutOfMemory;
    if (!CryptMsgGetParam(
            hMsg,
            dwParamType,
            dwIndex,
            pvData,
            &cbData)) {
        ICM_Free(pvData);
        goto GetParamError;
    }

CommonReturn:
    return pvData;
ErrorReturn:
    pvData = NULL;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(GetParamError)
}

#ifdef CMS_PKCS7

BOOL ICM_GetAndVerifySigner(
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwSignerIndex,
    IN DWORD cSignerStore,
    IN OPTIONAL HCERTSTORE *rghSignerStore,
    IN DWORD dwFlags,
    OUT OPTIONAL PCCERT_CONTEXT *ppSigner
    )
{
    BOOL fResult;
    PCERT_INFO pSignerId = NULL;
    PCCERT_CONTEXT pSigner = NULL;
    DWORD dwCertEncodingType;
    DWORD dwVerifyErr = 0;
    HCERTSTORE hCollection = NULL;

    if (NULL == (pSignerId = (PCERT_INFO) ICM_AllocAndGetMsgParam(
            hCryptMsg,
            CMSG_SIGNER_CERT_INFO_PARAM,
            dwSignerIndex
            ))) goto GetSignerError;

    // If no CertEncodingType, then, use the MsgEncodingType
    dwCertEncodingType = ((PCRYPT_MSG_INFO) hCryptMsg)->dwEncodingType;
    if (0 == (dwCertEncodingType & CERT_ENCODING_TYPE_MASK))
        dwCertEncodingType =
            (dwCertEncodingType >> 16) & CERT_ENCODING_TYPE_MASK;


    if (NULL == (hCollection = CertOpenStore(
                CERT_STORE_PROV_COLLECTION,
                0,                      // dwEncodingType
                0,                      // hCryptProv
                0,                      // dwFlags
                NULL                    // pvPara
                )))
        goto OpenCollectionStoreError;

    if (0 == (dwFlags & CMSG_TRUSTED_SIGNER_FLAG)) {
        HCERTSTORE hMsgCertStore;

        // Open a cert store initialized with certs from the message
        // and add to collection
        if (hMsgCertStore = CertOpenStore(
                CERT_STORE_PROV_MSG,
                dwCertEncodingType,
                0,                      // hCryptProv
                0,                      // dwFlags
                hCryptMsg               // pvPara
                )) {
            CertAddStoreToCollection(
                    hCollection,
                    hMsgCertStore,
                    CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG,
                    0                       // dwPriority
                    );
            CertCloseStore(hMsgCertStore, 0);
        }
    }

    // Add all the signer stores to the collection
    for ( ; cSignerStore > 0; cSignerStore--, rghSignerStore++) {
        HCERTSTORE hSignerStore = *rghSignerStore;
        if (NULL == hSignerStore)
            continue;

        CertAddStoreToCollection(
                hCollection,
                hSignerStore,
                CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG,
                0                       // dwPriority
                );
    }

    if (pSigner = CertGetSubjectCertificateFromStore(hCollection,
            dwCertEncodingType, pSignerId)) {
        CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA CtrlPara;

        if (dwFlags & CMSG_SIGNER_ONLY_FLAG)
            goto SuccessReturn;

        memset(&CtrlPara, 0, sizeof(CtrlPara));
        CtrlPara.cbSize = sizeof(CtrlPara);
        // CtrlPara.hCryptProv =
        CtrlPara.dwSignerIndex = dwSignerIndex;
        CtrlPara.dwSignerType = CMSG_VERIFY_SIGNER_CERT;
        CtrlPara.pvSigner = (void *) pSigner;

        if (CryptMsgControl(
                hCryptMsg,
                0,                  // dwFlags
                CMSG_CTRL_VERIFY_SIGNATURE_EX,
                &CtrlPara)) goto SuccessReturn;
        else {
            dwVerifyErr = GetLastError();

            if (CRYPT_E_MISSING_PUBKEY_PARA == dwVerifyErr) {
                PCCERT_CHAIN_CONTEXT pChainContext;
                CERT_CHAIN_PARA ChainPara;

                // Build a chain. Hopefully, the signer inherit's its public key
                // parameters from up the chain

                memset(&ChainPara, 0, sizeof(ChainPara));
                ChainPara.cbSize = sizeof(ChainPara);
                if (CertGetCertificateChain(
                        NULL,                   // hChainEngine
                        pSigner,
                        NULL,                   // pTime
                        hCollection,
                        &ChainPara,
                        CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL,
                        NULL,                   // pvReserved
                        &pChainContext
                        ))
                    CertFreeCertificateChain(pChainContext);


                // Try again. Hopefully the above chain building updated the
                // signer's context property with the missing public key
                // parameters
                if (CryptMsgControl(
                        hCryptMsg,
                        0,                  // dwFlags
                        CMSG_CTRL_VERIFY_SIGNATURE_EX,
                        &CtrlPara)) goto SuccessReturn;
            }
        }
        CertFreeCertificateContext(pSigner);
        pSigner = NULL;
    }

    if (dwVerifyErr)
        goto VerifySignatureError;
    else
        goto NoSignerError;

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    if (hCollection)
        CertCloseStore(hCollection, 0);
    ICM_Free(pSignerId);
    if (ppSigner)
        *ppSigner = pSigner;
    else if (pSigner)
        CertFreeCertificateContext(pSigner);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenCollectionStoreError)
TRACE_ERROR(GetSignerError)
SET_ERROR(NoSignerError, CRYPT_E_NO_TRUSTED_SIGNER)
SET_ERROR_VAR(VerifySignatureError, dwVerifyErr)
}

#else

BOOL ICM_GetAndVerifySigner(
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwSignerIndex,
    IN DWORD cSignerStore,
    IN OPTIONAL HCERTSTORE *rghSignerStore,
    IN DWORD dwFlags,
    OUT OPTIONAL PCCERT_CONTEXT *ppSigner
    )
{
    BOOL fResult;
    PCERT_INFO pSignerId = NULL;
    PCCERT_CONTEXT pSigner = NULL;
    DWORD dwCertEncodingType;
    DWORD dwVerifyErr = 0;

    if (NULL == (pSignerId = (PCERT_INFO) ICM_AllocAndGetMsgParam(
            hCryptMsg,
            CMSG_SIGNER_CERT_INFO_PARAM,
            dwSignerIndex
            ))) goto GetSignerError;

    // If no CertEncodingType, then, use the MsgEncodingType
    dwCertEncodingType = ((PCRYPT_MSG_INFO) hCryptMsg)->dwEncodingType;
    if (0 == (dwCertEncodingType & CERT_ENCODING_TYPE_MASK))
        dwCertEncodingType =
            (dwCertEncodingType >> 16) & CERT_ENCODING_TYPE_MASK;

    if (0 == (dwFlags & CMSG_TRUSTED_SIGNER_FLAG)) {
        HCERTSTORE hMsgCertStore;

        // Open a cert store initialized with certs from the message
        if (hMsgCertStore = CertOpenStore(
                CERT_STORE_PROV_MSG,
                dwCertEncodingType,
                0,                      // hCryptProv
                0,                      // dwFlags
                hCryptMsg               // pvPara
                )) {
            pSigner = CertGetSubjectCertificateFromStore(hMsgCertStore,
                dwCertEncodingType, pSignerId);
            CertCloseStore(hMsgCertStore, 0);
        }

        if (pSigner) {
            if (dwFlags & CMSG_SIGNER_ONLY_FLAG)
                goto SuccessReturn;
            if (CryptMsgControl(
                    hCryptMsg,
                    0,                  // dwFlags
                    CMSG_CTRL_VERIFY_SIGNATURE,
                    pSigner->pCertInfo)) goto SuccessReturn;
            else
                dwVerifyErr = GetLastError();
            CertFreeCertificateContext(pSigner);
            pSigner = NULL;
        }
    }

    for ( ; cSignerStore > 0; cSignerStore--, rghSignerStore++) {
        HCERTSTORE hSignerStore = *rghSignerStore;
        if (NULL == hSignerStore)
            continue;
        if (pSigner = CertGetSubjectCertificateFromStore(hSignerStore,
                dwCertEncodingType, pSignerId)) {
            if (dwFlags & CMSG_SIGNER_ONLY_FLAG)
                goto SuccessReturn;
            if (CryptMsgControl(
                    hCryptMsg,
                    0,                  // dwFlags
                    CMSG_CTRL_VERIFY_SIGNATURE,
                    pSigner->pCertInfo)) goto SuccessReturn;
            else
                dwVerifyErr = GetLastError();
            CertFreeCertificateContext(pSigner);
            pSigner = NULL;
        }
    }

    if (dwVerifyErr)
        goto VerifySignatureError;
    else
        goto NoSignerError;

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    ICM_Free(pSignerId);
    if (ppSigner)
        *ppSigner = pSigner;
    else if (pSigner)
        CertFreeCertificateContext(pSigner);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetSignerError)
SET_ERROR(NoSignerError, CRYPT_E_NO_TRUSTED_SIGNER)
SET_ERROR_VAR(VerifySignatureError, dwVerifyErr)
}

#endif  // CMS_PKCS7

//+-------------------------------------------------------------------------
//  Get and verify the signer of a cryptographic message.
//
//  If CMSG_TRUSTED_SIGNER_FLAG is set, then, treat the Signer stores as being
//  trusted and only search them to find the certificate corresponding to the
//  signer's issuer and serial number.  Otherwise, the SignerStores are
//  optionally provided to supplement the message's store of certificates.
//  If a signer certificate is found, its public key is used to verify
//  the message signature. The CMSG_SIGNER_ONLY_FLAG can be set to
//  return the signer without doing the signature verify.
//
//  If CMSG_USE_SIGNER_INDEX_FLAG is set, then, only get the signer specified
//  by *pdwSignerIndex. Otherwise, iterate through all the signers
//  until a signer verifies or no more signers.
//
//  For a verified signature, *ppSigner is updated with certificate context
//  of the signer and *pdwSignerIndex is updated with the index of the signer.
//  ppSigner and/or pdwSignerIndex can be NULL, indicating the caller isn't
//  interested in getting the CertContext and/or index of the signer.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptMsgGetAndVerifySigner(
    IN HCRYPTMSG hCryptMsg,
    IN DWORD cSignerStore,
    IN OPTIONAL HCERTSTORE *rghSignerStore,
    IN DWORD dwFlags,
    OUT OPTIONAL PCCERT_CONTEXT *ppSigner,
    IN OUT OPTIONAL DWORD *pdwSignerIndex
    )
{
    BOOL fResult = FALSE;
    DWORD dwSignerCount;
    DWORD dwSignerIndex;

    if (dwFlags & CMSG_USE_SIGNER_INDEX_FLAG) {
        dwSignerCount = 1;
        dwSignerIndex = *pdwSignerIndex;
    } else {
        DWORD cbData;

        dwSignerIndex = 0;
        if (pdwSignerIndex)
            *pdwSignerIndex = 0;
        cbData = sizeof(dwSignerCount);
        if (!CryptMsgGetParam(
                hCryptMsg,
                CMSG_SIGNER_COUNT_PARAM,
                0,                      // dwIndex
                &dwSignerCount,
                &cbData) || 0 == dwSignerCount)
            goto NoSignerError;
    }

    // Minimum of one iteration
    for ( ; dwSignerCount > 0; dwSignerCount--, dwSignerIndex++) {
        if (fResult = ICM_GetAndVerifySigner(
                hCryptMsg,
                dwSignerIndex,
                cSignerStore,
                rghSignerStore,
                dwFlags,
                ppSigner)) {
            if (pdwSignerIndex && 0 == (dwFlags & CMSG_USE_SIGNER_INDEX_FLAG))
                *pdwSignerIndex = dwSignerIndex;
            break;
        }
    }

CommonReturn:
    return fResult;
ErrorReturn:
    if (ppSigner)
        *ppSigner = NULL;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(NoSignerError, CRYPT_E_NO_TRUSTED_SIGNER)
}

//+-------------------------------------------------------------------------
//  Sign an encoded CTL.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptMsgSignCTL(
    IN DWORD dwMsgEncodingType,
    IN BYTE *pbCtlContent,
    IN DWORD cbCtlContent,
    IN PCMSG_SIGNED_ENCODE_INFO pSignInfo,
    IN DWORD dwFlags,
    OUT BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL fResult;
    HCRYPTMSG hMsg = NULL;

    DWORD dwMsgFlags;

#ifdef CMS_PKCS7
    if (dwFlags & CMSG_CMS_ENCAPSULATED_CTL_FLAG)
        dwMsgFlags = CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
    else
        dwMsgFlags = 0;
#else
    dwMsgFlags = 0;
#endif  // CMS_PKCS7

    if (NULL == pbEncoded) {
        if (0 == (*pcbEncoded = CryptMsgCalculateEncodedLength(
            dwMsgEncodingType,
            dwMsgFlags,
            CMSG_SIGNED,
            pSignInfo,
            szOID_CTL,
            cbCtlContent))) goto CalculateEncodedLengthError;
        fResult = TRUE;
    } else {
        if (NULL == (hMsg = CryptMsgOpenToEncode(
                dwMsgEncodingType,
                dwMsgFlags,
                CMSG_SIGNED,
                pSignInfo,
                szOID_CTL,
                NULL                        // pStreamInfo
                ))) goto OpenToEncodeError;
        if (!CryptMsgUpdate(
                hMsg,
                pbCtlContent,
                cbCtlContent,
                TRUE                        // fFinal
                )) goto UpdateError;

        fResult = CryptMsgGetParam(
            hMsg,
            CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            pbEncoded,
            pcbEncoded);
    }

CommonReturn:
    if (hMsg)
        CryptMsgClose(hMsg);
    return fResult;
ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CalculateEncodedLengthError)
TRACE_ERROR(OpenToEncodeError)
TRACE_ERROR(UpdateError)
}


//+-------------------------------------------------------------------------
//  Encode the CTL and create a signed message containing the encoded CTL.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptMsgEncodeAndSignCTL(
    IN DWORD dwMsgEncodingType,
    IN PCTL_INFO pCtlInfo,
    IN PCMSG_SIGNED_ENCODE_INFO pSignInfo,
    IN DWORD dwFlags,
    OUT BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL fResult;
    BYTE *pbContent = NULL;
    DWORD cbContent;
    DWORD dwEncodingType;
    LPCSTR lpszStructType;
    DWORD dwEncodeFlags;

    dwEncodingType = (dwMsgEncodingType >> 16) & CERT_ENCODING_TYPE_MASK;
    assert(dwEncodingType != 0);
    if (0 == dwEncodingType)
        goto InvalidArg;

    dwEncodeFlags = CRYPT_ENCODE_ALLOC_FLAG;
    if (dwFlags & CMSG_ENCODE_SORTED_CTL_FLAG) {
        lpszStructType = PKCS_SORTED_CTL;
        if (dwFlags & CMSG_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG)
            dwEncodeFlags |=
                CRYPT_SORTED_CTL_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG;
    } else {
        lpszStructType = PKCS_CTL;
    }


    if (!CryptEncodeObjectEx(
            dwEncodingType,
            lpszStructType,
            pCtlInfo,
            dwEncodeFlags,
            &PkiEncodePara,
            (void *) &pbContent,
            &cbContent
            )) goto EncodeError;

    fResult = CryptMsgSignCTL(
        dwMsgEncodingType,
        pbContent,
        cbContent,
        pSignInfo,
        dwFlags,
        pbEncoded,
        pcbEncoded
        );

CommonReturn:
    PkiFree(pbContent);
    return fResult;

ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(EncodeError)
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\errparse\main.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       main.cpp
//
//--------------------------------------------------------------------------

/***************************************************************************
Error File Parser.cpp
By: Zach Robinson (zachd@microsoft.com)
Created: Aug 26, 1996
Purpose:
    To parse a list of files for error codes.  Once parsing has occured,
    the list will be sorted and printed out into a C file.  This file
    will then be used to build a program that will supply information
    about error codes supplied to it.

Incarnation:
    errparse (FILE_LIST)
    where (FILE_LIST) is N number of files that will be parsed to build
    the complete list of applicable error codes.

Requirements:
    At this point, that error files will adhere to the structure
    established by the standard MS C++ file winerror.h.

Output:
    A C file.

**************************************************************************/

#include "errparse.h"

char *pErrFileName = NULL;
char *pParsedErrorsName = "errmsgs.h";
FILE *pErrorsFile , *pParsedErrorsFile;
DWORD dwErrorsParsed = 0;

//**************************************************************
void __cdecl main (int argc, char **argv)
// (see above program description)
//**************************************************************
{

    if (2 > argc )
    {
        Usage();
    }
    
    if( !( CreateErrorFile( pParsedErrorsName ) ) )
    {
        death( ( "Error creating output file.  Program terminated.\n" ) );
    }

    //Loop for each file supplied
    for( int i=1; i<argc; i++ )
    {

        pErrFileName = argv[i];

        if( !( OpenErrorFile( pErrFileName ) ) )
        {
            death( ( "Error opening file.  Program terminated.\n" ) );
        }


        //parse -> build linked list
        //This both gets the errors and sorts them, and is the real meat of the program
        GetErrors();
        
        //close the filehandle
        if( NULL != pErrorsFile )
        {
            (void) fclose( pErrorsFile );
        }
 
    }
    

    if( !( PrintErrorMessages() ) )
    {
        death( ( "Error printing out error messages.  Program terminating.\n" ) );
    }
    

    if( !( DestroyErrorMessages() ) )
    {
        death( ( "Error cleaning up memory.  Program terminating.\n" ) );
    }
    

    //Close the output file now ( all files have been processed & printed )
    if( NULL != pParsedErrorsFile )
    {
        (void) fclose( pParsedErrorsFile );
    }  
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\OnlineAccounts\inc\OnlineAccounts.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: OnlineAccounts.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the functions to muck with account status
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#ifdef _XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <xbox.h>

#include <winsockx.h>
#include <winsockp.h>
#endif

#include <xdbg.h>
#include <xonlinep.h>
#include <stdio.h>
#include <stdlib.h>

//
// how long should wait's wait
//

static const DWORD ONLINE_ACCOUNT_WAIT_INTERVAL = 30000;

//
// set up for cross compilation with windows and xbox
//

#ifndef _XBOX
class COnlineAccounts : public CXOnline
{
#else
class COnlineAccounts
{
#endif

protected:
	COnlineAccounts( LPSTR szName = NULL );

private:
	static COnlineAccounts* m_pAccounts;

public:

	//
	// destrcutor
	//

	~COnlineAccounts( void ) { delete m_pAccounts; }

	//
	// singleton pattern
	//

	static COnlineAccounts* Instance( LPSTR szName = NULL );

	//
	// Get N random user accounts, put them on the hard drive
	//

	HRESULT 
	PopulateUserAccountsHD( PXONLINEP_USER aUsers, DWORD dwNumAccounts, BOOL bRemoveUsers = TRUE );

	//
	// Populate an MU with an account
	//

	HRESULT
	PopulateUserAccountsMU( CHAR chDrive, PXONLINEP_USER pUser );

	//
	// get the users and put them into an array
	//

	HRESULT
	GetUsers( PXONLINEP_USER aUsers, DWORD dwNumAccounts );

	//
	// quickly logon to the service
	//

	HRESULT
	QuickLogonStart( void );

	//
	// quickly logoff the service
	//

	HRESULT
	QuickLogonFinish( void );

	//
	// generate a user name
	//

	HRESULT
	GenerateUserName( CHAR szName[XONLINE_NAME_SIZE] );

	//
	// generate a user account
	//

	HRESULT
	GenerateUserAccount( PXONLINEP_USER pUser );
};


//
// modify a machine account
//

//HRESULT 
//ModifyMachineAccount( ULONGLONG ullId, LPSTR szName, LPSTR szPassword );

//
// verify the data in a machine account is what the user thinks...
//

//BOOL
//VerifyMachineAccount( ULONGLONG ullId, LPSTR szName, LPSTR szPassword );

//
// create an account
//

//HRESULT CreateMachineAccount( void );

//
// remove a machine account
//

//HRESULT RemoveMachineAccount( void );

//
// validate a machine account
//

//HRESULT ValidateMachineAccount( void );

//
// update the eeprom with devkit data
//

//HRESULT WriteEEPROMDevkitData( void );

//
// See if old Machine Account exists
//

//BOOL HasOldMachineAccount( void );

//
// see if old user accounts exist
//

//BOOL HasOldUserAccounts( void );

//
// read a line of user data from an ini file
//

//HRESULT 
//ReadUserData( FILE* pIniFile, PXONLINEP_USER pUser );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\errsay\main.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       main.cpp
//
//--------------------------------------------------------------------------

#include "errmsgs.h"
#include "errsay.h"

char *pszDesiredNumber, *pszDesiredName, *pszErrorToFind;
DWORD dwDesiredNumber;
BOOL fFoundError = FALSE;



//*****************************************************************************
void Usage ()
// Informs the user of how to use this program
//*****************************************************************************
{
    printf( "Usage: errsay ERROR_ID\n" );
    printf( "     ERROR_ID can be either a number or a symbolic name.\n" );
    printf( "     If hex, ERROR_ID must begin with a leading \"0x\".\n" );
    printf( "Examples of each case:\n" );
    printf( "     errsay 23                                 [DECIMAL ID]\n" );
    printf( "     errsay 0x8009001F                         [HEX ID]\n" );
    printf( "     errsay ERROR_ATOMIC_LOCKS_NOT_SUPPORTED   [SYMBOLIC NAME]\n\n" );

    exit( 0 );
}

//*****************************************************************************
void NoErrorIDGiven()
// Inform the user that the error ID was not understood
//*****************************************************************************
{
    printf( "Unable to interpret error ID \"%s\".\n\n", pszErrorToFind );
    Usage();    
}

//*****************************************************************************
void NoErrorFound()
// Indicate to user that no corresponding error was found for the ID supplied
//*****************************************************************************
{
    printf( "The error %s (0x%X) was not found.\n\n", pszErrorToFind, StringToDWORD( pszErrorToFind ) );
    Usage();    
}



//*****************************************************************************
BOOL PrintErrorMessage( ERRORMESSAGE pEMessage )
// Indicate to user the correponding error(s) for the ID supplied
//*****************************************************************************
{
    if( fFoundError )
    {
        printf( "   [SYMBOL MULTIPLY DEFINED]\n" );
    }
        
    printf( "Error Number: %lu (0x%X)\n", pEMessage.num, pEMessage.num ); 
    printf( "Symbolic Name: %s\n", pEMessage.name );
    printf( "Text description: %s\n", pEMessage.desc );
    fFoundError = TRUE;

    return( TRUE );
}

//*****************************************************************************
DWORD StringToDWORD( char * pszStringToDWORD )
// Utility function to render a decimal string to a DWORD for later hexification
//*****************************************************************************
{
    DWORD dwTmpErrorNumber;
    
    if( 0 == ( sscanf( pszStringToDWORD, "%lu", &dwTmpErrorNumber ) ) )
    {
        return ( 0 );
    }    
    
    return( dwTmpErrorNumber );
}

//*****************************************************************************
BOOL GetErrorNumber()
// Take the input string, which should be either a hex or a dec number,
// and return a dec string
//*****************************************************************************
{
    DWORD dwTmpErrorNumber = 0;
    

    //This can be either hex or a digit
    //If this is a digit, there will be no Ox
    // This second search must belong in FindErrorNumber
    

    pszDesiredNumber = pszErrorToFind;

    if( 2 < strlen( pszErrorToFind ) )
    {
        if( ( 'x' == pszErrorToFind[1] ) || ( 'X' == pszErrorToFind[1] ) )
        {
            for( int iPos = 0, iLen =( strlen( pszErrorToFind ) ); iPos < iLen; iPos++ )
            {
                //This magically solves part of the scode mystery later!
                pszErrorToFind[iPos] = (char)tolower( pszErrorToFind[iPos] ); 
            }

            //Temporarily make the decimal string (which is hex) a  real hex num...
            if( 0 == ( sscanf( pszErrorToFind, "%x", &dwTmpErrorNumber ) ) )
            {
                return( FALSE );
            }


            //Make the new hex number a decimal string for seeking with
            if( sprintf( pszDesiredNumber, "%lu", dwTmpErrorNumber ) )
            {
                //We're returning now because we've handled the hex number
                return( TRUE );
            } 
            else
            {
                return( FALSE );
            }
        }
        else
        {
            pszDesiredNumber = pszErrorToFind;            
        }
    }

    else
    {        
        pszDesiredNumber = pszErrorToFind;
    }

    
    return( TRUE );
}
        
//*****************************************************************************
BOOL GetErrorName()
// We're searching by string - we're okay with what we have
//*****************************************************************************
{
    pszDesiredName = pszErrorToFind;

    return( TRUE );
}

//*****************************************************************************
BOOL SeekErrorByNumber()
// Seeks by decimal number for error message text, and then prints out the result
//*****************************************************************************
{
    //IF NUM
    for( int i = 0; i < MAX_MES; i++ )
    {
        if( StringToDWORD( pszDesiredNumber ) == eMessages[i].num )
        {
            PrintErrorMessage( eMessages[i] );
        }
    }

    //If we haven't found the error yet, we need to check if it's available as an scode
    if( !( fFoundError ) )
    {
        char * pszFirstChar;
        
        //ERROR: this does not cover scode decimals ... does it need to?

        char szHexErrorToFind[MAX_PATH];
        sprintf( szHexErrorToFind, "0x%X", StringToDWORD( pszErrorToFind ) ); 

        if (NULL != (pszFirstChar = strstr( szHexErrorToFind, "0x8" ) ) )
        {

        //Looks like SCODEs are taken care of elsewhere...
        /* dwDesiredNumber = SCODE_CODE( ( (HRESULT) szHexErrorToFind ) );           
            printf("SCODE found.  Converted to: %lu\n", dwDesiredNumber);
            
            
            sprintf( pszDesiredNumber, "%lu", dwDesiredNumber );
            for( i = 0; i < MAX_MES; i++ )
            {
                if( StringToDWORD( pszDesiredNumber ) == eMessages[i].num )
                {
                    PrintErrorMessage( eMessages[i] );      
                }
            }
*/                
            //Maybe this a Win32 Error Code?
            if (NULL != (pszFirstChar = strstr( szHexErrorToFind, "0x8007" ) ) )
            {

                //offset by "0x8007"
                sprintf( szHexErrorToFind, "%s", pszFirstChar + 6 );

                sscanf( szHexErrorToFind, "%X", &dwDesiredNumber );
                printf("Win32 Error Code found.  Converted to: %lu\n\n", dwDesiredNumber);

                sprintf( pszDesiredNumber, "%lu", dwDesiredNumber );
                for( i = 0; i < MAX_MES; i++ )
                {
                    if( StringToDWORD( pszDesiredNumber ) == eMessages[i].num )
                    {
                        PrintErrorMessage( eMessages[i] );      
                    }
                }
            }
        }
    }

    return( fFoundError );
}

//*****************************************************************************
BOOL SeekErrorByName()
// Seeks by Symbolic Name for error message text, and then print out the result
//*****************************************************************************
{

    for( int i = 0; i < MAX_MES; i++ )
    {        
        //Case insensitive compare to see if we have a weiner
        if( ( strlen( pszDesiredName ) == strlen( eMessages[i].name ) ) && ( 0 == _strnicmp( pszDesiredName, eMessages[i].name, ( strlen( pszDesiredName ) - 1 ) ) ) ) 
        {
            PrintErrorMessage( eMessages[i] );
        }        
    }

    return( fFoundError );
}



//*****************************************************************************
void __cdecl main ( int argc, char **argv )
// See Usage for exact details
// Takes an error ID in the form of either a dec or hex number or a symbolic
// name, and then returns the associated error code(s) as supplied by
// errparse's rendering of error header files.

// Possible future refinements:
//         Multiple arguments accepted & sought for (currently drops all but first)
//         Return/reply with error number as same value as received
//*****************************************************************************
{
    char * pErrText = NULL;

    if( 2 != argc )
    {  
        Usage();
    }

    //Get cmd line arg
    pszErrorToFind = argv[1];
    pszErrorToFind[( strlen( argv[1] ) )] = '\0';

    // Arg can either be symbolic name, hex, or decimal
    //Determine which now & handle appropriately
    if( ( isdigit( pszErrorToFind[0] ) ) || ( '-' == pszErrorToFind[0] ) )
    {
        if ( !( GetErrorNumber() ) )
        {
            NoErrorIDGiven();
        }
    
        if ( !( SeekErrorByNumber() ) )
        {
            NoErrorFound();
        }
    }
    else
    {
        if ( !( GetErrorName() ) )
        {
            NoErrorIDGiven();
        }
        if ( !( SeekErrorByName() ) )
        {
            NoErrorFound();
        }
    }

   exit( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\errparse\errparse.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       errparse.cpp
//
//--------------------------------------------------------------------------

#include "errparse.h"

struct NODE *pCapturedError, *pFirstCapturedError, *pCurrent;

//************************************************************************
char * FindDesiredWord( const char * pDesiredWord, char szCurFileLine[] )
// Find a keyword within our output file.  If we run out of file, we return
// false, otherwise we continue until we find the word.
//************************************************************************
{
	size_t i = 0;
	char * pFirstChar;  
	
    //While we still have lines in the file
	while( NULL != fgets( szCurFileLine, MAX_LINE, pErrorsFile ) )
	{
    
        
        //Check to see if current line contains desired keyphrase
	    if( NULL != ( pFirstChar = strstr( szCurFileLine, pDesiredWord ) ) )
        {
            //Point past the end of the keyphrase in the line
	        pFirstChar += strlen( pDesiredWord );
            //Ensure we're not pointing to end of line
            for( ;; )
            {
                if( EOF == *pFirstChar )
                {
                    return( NULL );
                }

                if( '\0' == *pFirstChar )
                {
                    //Get next line, point to it
                    if( NULL == fgets( szCurFileLine, MAX_LINE, pErrorsFile ) )
                    {
                        return( NULL );
                    }
                    pFirstChar = szCurFileLine;
                }
    	    
                //Skip to the next word/number for processing
                if( isalnum( *pFirstChar ) )
                {
                    if( 0 == strcmp( pDesiredWord, "MessageId:" ) ) 
                    {
                        char *pPtr;

                        pPtr = strstr( pFirstChar, "SymbolicName=" );
                        if( pPtr )
                        {
                            pFirstChar = pPtr + strlen( "SymbolicName=" );
                        }
                    }
                    //Return pointer to the first char of the word they're looking for
                    return( pFirstChar );  
                }
                pFirstChar++;
            }
            
            return( pFirstChar );
        }
	}
	//The file we were looking at did not contain the word we sought
    return( NULL );
}

//**************************************************************
void GetErrors()
//  The Big Kahuna function
//   In this function we will get all of the error entries from the
//   header files, and then place them sorted-wise into our linked list
//**************************************************************
{
    
    char *MSG_SYM_ID = "MessageId:";
	char *MSG_TXT_ID = "MessageText:";
    //We actually have to seek on the symbolic name, since that is the first
    //nonspace standardly before the identifying num
 
    char szCurFileLine[MAX_LINE + 1];
	char szTmpSymbolicName[MAX_LINE + 1];
    char szTmpErrorNumber[MAX_LINE + 1];
    char szTmpDefinition[MAX_LINE + 1];
    char *pszDesiredWord;
    DWORD dwTmpErrorNumber = 0;
    
	for( ; ; )
    {
 		//GetErrorSymbolicName()
        if( NULL != ( pszDesiredWord = FindDesiredWord( MSG_SYM_ID, szCurFileLine ) ) )
		{
			//We now have a pointer to the first letter of the word we want
            //Now - determine length of string, copy that string to a temp location for building object
            int iWordLen = 1;  
            for( ; __iscsym( pszDesiredWord[( iWordLen - 1 )] ); iWordLen++ )
            {
                ;
            }
            //We are pointing beyond the end of the string at this point, so -1
            strncpy( szTmpSymbolicName, pszDesiredWord, ( iWordLen  ) );
            szTmpSymbolicName[( iWordLen -1 )] = '\0';            
		}
        else
        {
            return;
        }


        //GetErrorText()
        if( NULL != ( pszDesiredWord = FindDesiredWord( MSG_TXT_ID, szCurFileLine ) ) )
		{
			//We now have a pointer to the first letter of the word we want
            //Now - determine length of string, copy that string to a temp location for building object
            int iWordLen = 1;  
            for( ; ( '\n' != pszDesiredWord[( iWordLen - 1 )] ) && ( '\0' != pszDesiredWord[( iWordLen - 1 )] ); iWordLen++)
            {
                ;
            }            

            //iWordLen is now beyond the end of the string
            strncpy( szTmpDefinition, pszDesiredWord, ( iWordLen - 1 ) );
            szTmpDefinition[( iWordLen - 1 )] = '\0';


            //Now we handle for multiple line error descriptions                                   
            //A line that has additional text on it will be a minimum of 4 chars long                                
            while( ( NULL != fgets( szCurFileLine, MAX_LINE, pErrorsFile ) ) && ( 3 < strlen( szCurFileLine ) ) )
            {
                int iLineLen = 0;
                                                                
                for( ; ( '\n' != pszDesiredWord[( iLineLen - 1 )] ) && ( '\0' != pszDesiredWord[( iLineLen - 1 )] ); iLineLen++)
                {
                    ;
                }            
                
                //We need to append a space to the prior string, since we end and begin on alphanum chars
                strcat( szTmpDefinition, " " );
                //iLineLen is now beyond the end of the string
                strncat( szTmpDefinition, pszDesiredWord, ( iLineLen - 1 ) );
                                               
                iWordLen += iLineLen;
        
            }
        }
        else
        {
            return;
        }


        //GetErrorNumber();
        //Symbolic Name should be the first whitespace before the ErrorID Num
        if( NULL != ( pszDesiredWord = FindDesiredWord( szTmpSymbolicName, szCurFileLine ) ) )
		{
			int iWordLen = 1;  
            char * pHresultLoc;

            //We must account for _HRESULT_TYPEDEF as found in Winerror.h
            //Here, we just move the pointer to point past it

            if(NULL != ( pHresultLoc = strstr( pszDesiredWord, "HRESULT" ) ) )
            
            {
                //strlen wasn't getting the ( as part of length
                pszDesiredWord += ( strlen( "HRESULT_TYPEDEF" ) + 2 );
            }

            
            for( ; isalnum( pszDesiredWord[( iWordLen -1 )] ); iWordLen++)
            {
                ;
            }
            //We are beyond the end of the string
            strncpy( szTmpErrorNumber, pszDesiredWord, ( iWordLen - 1 ) );
            
            
            //Ensure that we didn't catch an extra character (such as L...)
            if( !( isdigit( szTmpErrorNumber[( iWordLen - 2 )] ) ) )
            {
                //Decrement to account for extra unwanted letter
                iWordLen--;
            }
            szTmpErrorNumber[( iWordLen - 1 )] = '\0';
  
		}
        else
        {
            return;
        }
       
        //Now that we have the errornumber as a string, we want to convert it to a DWORD
        if( ( 'x' == szTmpErrorNumber[1] ) || ( 'X' == szTmpErrorNumber[1] ) )
        {
            for( int iPos = 0, iLen =( strlen( szTmpErrorNumber ) - 1 ); iPos < iLen; iPos++ )
            {
                szTmpErrorNumber[iPos] = (char)tolower( szTmpErrorNumber[iPos] );
            }
            if ( 0 == ( sscanf( szTmpErrorNumber, "%x", &dwTmpErrorNumber ) ) )
            {
                //death( ( "Could not process error number.  Terminating.\n" ) );
                printf( "Could not process error number.\n" );
                continue;
            }
        }
        else
        {
            if( 0 == ( sscanf( szTmpErrorNumber, "%lu", &dwTmpErrorNumber ) ) )
            {
                //death( ( "Could not process error number.  Terminating.\n" ) );
                printf( "Could not process error number.\n" );
                continue;
            }
        }

//        printf("Adding error 0x%08x name='%s' desc='%s'\n", dwTmpErrorNumber, szTmpSymbolicName, szTmpDefinition);
        //can't add to the list if there is no list yet
        if( 0 == dwErrorsParsed )
        {
            if( NULL == ( pCurrent = new struct NODE ) )
            {
                death( ( "Error creating object. Terminating.\n" ) );
            }
            pCapturedError = pCurrent;
            pCapturedError->ErrorMessage.CSetErrorMessage( dwTmpErrorNumber, szTmpSymbolicName, szTmpDefinition );
            // now we need a pointer to the first item in the list
            pFirstCapturedError = pCapturedError;
            pCapturedError->pNext = NULL;            
            dwErrorsParsed++;
        }
        else
        {
            if( NULL == ( pCurrent = new struct NODE ) )
            {
                death( ( "Error creating object. Terminating.\n" ) );
            }
            pCurrent->ErrorMessage.CSetErrorMessage( dwTmpErrorNumber, szTmpSymbolicName, szTmpDefinition );
            if( !( InsertIntoList( dwTmpErrorNumber, pCurrent ) ) )
            {
                death( ( "Error inserting object into list. Terminating.\n" ) );
            }                   
        }
    }
	return;
}


//**************************************************************
BOOL InsertIntoList( DWORD dwTmpErrorNumber, NODE *pCurrent )
// Inserts an element to the list in sorted order
//**************************************************************
{
    dwErrorsParsed++;

    //we want to put this new node in the right place.
    //in order to do that, we need:
    // 1. to find desired loc - (dwTmpErrorNumber is our index string)
    // 2. to switch the pointers

    pCapturedError = pFirstCapturedError;
    
    do
    {        
        //Special handling if we're at end of list (or if we just started, too)
        if( NULL == pCapturedError->pNext )
        {
            if( dwTmpErrorNumber <= pCapturedError->ErrorMessage.CGetErrorNumber() )
            {
                pCurrent->pNext = pCapturedError;
                pFirstCapturedError = pCurrent;

                return( TRUE );
            }
            else
            {   //We can swap normally
                pCurrent->pNext = NULL;
                pCapturedError->pNext = pCurrent;

                return( TRUE );
            }
        }
        //If we have the same # as the beginning of the list, this is our out
        if( dwTmpErrorNumber <= pFirstCapturedError->ErrorMessage.CGetErrorNumber() )
        {
            pCurrent->pNext = pFirstCapturedError;
            pFirstCapturedError = pCurrent;

            return( TRUE );
        }
        if( dwTmpErrorNumber <= pCapturedError->pNext->ErrorMessage.CGetErrorNumber() )
        {
            break;
        }

        pCapturedError = pCapturedError->pNext;
      
    } while( ( NULL != pCapturedError->pNext ) && ( dwTmpErrorNumber >= pCapturedError->pNext->ErrorMessage.CGetErrorNumber() ) );
        
    pCurrent->pNext = pCapturedError->pNext;
    pCapturedError->pNext = pCurrent;

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\errsay\errmsgs.h ===
#ifndef ERRMSGS_H
#define ERRMSGS_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

#define MAX_MES 2347

struct ERRORMESSAGE
{
    DWORD num;
    char * name; 
    char * desc; 
} ;

ERRORMESSAGE eMessages[MAX_MES] = 
{
    { 0, "ERROR_SUCCESS", "The operation completed successfully." },
    { 1, "ERROR_INVALID_FUNCTION", "Incorrect function." },
    { 2, "ERROR_FILE_NOT_FOUND", "The system cannot find the file specified." },
    { 3, "ERROR_PATH_NOT_FOUND", "The system cannot find the path specified." },
    { 4, "ERROR_TOO_MANY_OPEN_FILES", "The system cannot open the file." },
    { 5, "ERROR_ACCESS_DENIED", "Access is denied." },
    { 6, "ERROR_INVALID_HANDLE", "The handle is invalid." },
    { 7, "ERROR_ARENA_TRASHED", "The storage control blocks were destroyed." },
    { 8, "ERROR_NOT_ENOUGH_MEMORY", "Not enough storage is available to process this command." },
    { 9, "ERROR_INVALID_BLOCK", "The storage control block address is invalid." },
    { 10, "ERROR_BAD_ENVIRONMENT", "The environment is incorrect." },
    { 11, "ERROR_BAD_FORMAT", "An attempt was made to load a program with an incorrect format." },
    { 12, "ERROR_INVALID_ACCESS", "The access code is invalid." },
    { 13, "ERROR_INVALID_DATA", "The data is invalid." },
    { 14, "ERROR_OUTOFMEMORY", "Not enough storage is available to complete this operation." },
    { 15, "ERROR_INVALID_DRIVE", "The system cannot find the drive specified." },
    { 16, "ERROR_CURRENT_DIRECTORY", "The directory cannot be removed." },
    { 17, "ERROR_NOT_SAME_DEVICE", "The system cannot move the file to a different disk drive." },
    { 18, "ERROR_NO_MORE_FILES", "There are no more files." },
    { 19, "ERROR_WRITE_PROTECT", "The media is write protected." },
    { 20, "ERROR_BAD_UNIT", "The system cannot find the device specified." },
    { 21, "ERROR_NOT_READY", "The device is not ready." },
    { 22, "ERROR_BAD_COMMAND", "The device does not recognize the command." },
    { 23, "ERROR_CRC", "Data error (cyclic redundancy check)." },
    { 24, "ERROR_BAD_LENGTH", "The program issued a command but the command length is incorrect." },
    { 25, "ERROR_SEEK", "The drive cannot locate a specific area or track on the disk." },
    { 26, "ERROR_NOT_DOS_DISK", "The specified disk or diskette cannot be accessed." },
    { 27, "ERROR_SECTOR_NOT_FOUND", "The drive cannot find the sector requested." },
    { 28, "ERROR_OUT_OF_PAPER", "The printer is out of paper." },
    { 29, "ERROR_WRITE_FAULT", "The system cannot write to the specified device." },
    { 30, "ERROR_READ_FAULT", "The system cannot read from the specified device." },
    { 31, "ERROR_GEN_FAILURE", "A device attached to the system is not functioning." },
    { 32, "ERROR_SHARING_VIOLATION", "The process cannot access the file because it is being used by another process." },
    { 33, "ERROR_LOCK_VIOLATION", "The process cannot access the file because another process has locked a portion of the file." },
    { 34, "ERROR_WRONG_DISK", "The wrong diskette is in the drive. Insert %2 (Volume Serial Number: %3) into drive %1." },
    { 36, "ERROR_SHARING_BUFFER_EXCEEDED", "Too many files opened for sharing." },
    { 38, "ERROR_HANDLE_EOF", "Reached the end of the file." },
    { 39, "ERROR_HANDLE_DISK_FULL", "The disk is full." },
    { 50, "ERROR_NOT_SUPPORTED", "The network request is not supported." },
    { 51, "ERROR_REM_NOT_LIST", "The remote computer is not available." },
    { 52, "ERROR_DUP_NAME", "A duplicate name exists on the network." },
    { 53, "ERROR_BAD_NETPATH", "The network path was not found." },
    { 54, "ERROR_NETWORK_BUSY", "The network is busy." },
    { 55, "ERROR_DEV_NOT_EXIST", "The specified network resource or device is no longer available." },
    { 56, "ERROR_TOO_MANY_CMDS", "The network BIOS command limit has been reached." },
    { 57, "ERROR_ADAP_HDW_ERR", "A network adapter hardware error occurred." },
    { 58, "ERROR_BAD_NET_RESP", "The specified server cannot perform the requested operation." },
    { 59, "ERROR_UNEXP_NET_ERR", "An unexpected network error occurred." },
    { 60, "ERROR_BAD_REM_ADAP", "The remote adapter is not compatible." },
    { 61, "ERROR_PRINTQ_FULL", "The printer queue is full." },
    { 62, "ERROR_NO_SPOOL_SPACE", "Space to store the file waiting to be printed is not available on the server." },
    { 63, "ERROR_PRINT_CANCELLED", "Your file waiting to be printed was deleted." },
    { 64, "ERROR_NETNAME_DELETED", "The specified network name is no longer available." },
    { 65, "ERROR_NETWORK_ACCESS_DENIED", "Network access is denied." },
    { 66, "ERROR_BAD_DEV_TYPE", "The network resource type is not correct." },
    { 67, "ERROR_BAD_NET_NAME", "The network name cannot be found." },
    { 68, "ERROR_TOO_MANY_NAMES", "The name limit for the local computer network adapter card was exceeded." },
    { 69, "ERROR_TOO_MANY_SESS", "The network BIOS session limit was exceeded." },
    { 70, "ERROR_SHARING_PAUSED", "The remote server has been paused or is in the process of being started." },
    { 71, "ERROR_REQ_NOT_ACCEP", "No more connections can be made to this remote computer at this time because there are already as many connections as the computer can accept." },
    { 72, "ERROR_REDIR_PAUSED", "The specified printer or disk device has been paused." },
    { 80, "ERROR_FILE_EXISTS", "The file exists." },
    { 82, "ERROR_CANNOT_MAKE", "The directory or file cannot be created." },
    { 83, "ERROR_FAIL_I24", "Fail on INT 24." },
    { 84, "ERROR_OUT_OF_STRUCTURES", "Storage to process this request is not available." },
    { 85, "ERROR_ALREADY_ASSIGNED", "The local device name is already in use." },
    { 86, "ERROR_INVALID_PASSWORD", "The specified network password is not correct." },
    { 87, "ERROR_INVALID_PARAMETER", "The parameter is incorrect." },
    { 88, "ERROR_NET_WRITE_FAULT", "A write fault occurred on the network." },
    { 89, "ERROR_NO_PROC_SLOTS", "The system cannot start another process at this time." },
    { 100, "ERROR_TOO_MANY_SEMAPHORES", "Cannot create another system semaphore." },
    { 101, "ERROR_EXCL_SEM_ALREADY_OWNED", "The exclusive semaphore is owned by another process." },
    { 102, "ERROR_SEM_IS_SET", "The semaphore is set and cannot be closed." },
    { 103, "ERROR_TOO_MANY_SEM_REQUESTS", "The semaphore cannot be set again." },
    { 104, "ERROR_INVALID_AT_INTERRUPT_TIME", "Cannot request exclusive semaphores at interrupt time." },
    { 105, "ERROR_SEM_OWNER_DIED", "The previous ownership of this semaphore has ended." },
    { 106, "ERROR_SEM_USER_LIMIT", "Insert the diskette for drive %1." },
    { 107, "ERROR_DISK_CHANGE", "The program stopped because an alternate diskette was not inserted." },
    { 108, "ERROR_DRIVE_LOCKED", "The disk is in use or locked by another process." },
    { 109, "ERROR_BROKEN_PIPE", "The pipe has been ended." },
    { 110, "ERROR_OPEN_FAILED", "The system cannot open the device or file specified." },
    { 111, "ERROR_BUFFER_OVERFLOW", "The file name is too long." },
    { 112, "ERROR_DISK_FULL", "There is not enough space on the disk." },
    { 113, "ERROR_NO_MORE_SEARCH_HANDLES", "No more internal file identifiers available." },
    { 114, "ERROR_INVALID_TARGET_HANDLE", "The target internal file identifier is incorrect." },
    { 117, "ERROR_INVALID_CATEGORY", "The IOCTL call made by the application program is not correct." },
    { 118, "ERROR_INVALID_VERIFY_SWITCH", "The verify-on-write switch parameter value is not correct." },
    { 119, "ERROR_BAD_DRIVER_LEVEL", "The system does not support the command requested." },
    { 120, "ERROR_CALL_NOT_IMPLEMENTED", "This function is not supported on this system." },
    { 121, "ERROR_SEM_TIMEOUT", "The semaphore timeout period has expired." },
    { 122, "ERROR_INSUFFICIENT_BUFFER", "The data area passed to a system call is too small." },
    { 123, "ERROR_INVALID_NAME", "The filename, directory name, or volume label syntax is incorrect." },
    { 124, "ERROR_INVALID_LEVEL", "The system call level is not correct." },
    { 125, "ERROR_NO_VOLUME_LABEL", "The disk has no volume label." },
    { 126, "ERROR_MOD_NOT_FOUND", "The specified module could not be found." },
    { 127, "ERROR_PROC_NOT_FOUND", "The specified procedure could not be found." },
    { 128, "ERROR_WAIT_NO_CHILDREN", "There are no child processes to wait for." },
    { 129, "ERROR_CHILD_NOT_COMPLETE", "The %1 application cannot be run in Win32 mode." },
    { 130, "ERROR_DIRECT_ACCESS_HANDLE", "Attempt to use a file handle to an open disk partition for an operation other than raw disk I/O." },
    { 131, "ERROR_NEGATIVE_SEEK", "An attempt was made to move the file pointer before the beginning of the file." },
    { 132, "ERROR_SEEK_ON_DEVICE", "The file pointer cannot be set on the specified device or file." },
    { 133, "ERROR_IS_JOIN_TARGET", "A JOIN or SUBST command cannot be used for a drive that contains previously joined drives." },
    { 134, "ERROR_IS_JOINED", "An attempt was made to use a JOIN or SUBST command on a drive that has already been joined." },
    { 135, "ERROR_IS_SUBSTED", "An attempt was made to use a JOIN or SUBST command on a drive that has already been substituted." },
    { 136, "ERROR_NOT_JOINED", "The system tried to delete the JOIN of a drive that is not joined." },
    { 137, "ERROR_NOT_SUBSTED", "The system tried to delete the substitution of a drive that is not substituted." },
    { 138, "ERROR_JOIN_TO_JOIN", "The system tried to join a drive to a directory on a joined drive." },
    { 139, "ERROR_SUBST_TO_SUBST", "The system tried to substitute a drive to a directory on a substituted drive." },
    { 140, "ERROR_JOIN_TO_SUBST", "The system tried to join a drive to a directory on a substituted drive." },
    { 141, "ERROR_SUBST_TO_JOIN", "The system tried to SUBST a drive to a directory on a joined drive." },
    { 142, "ERROR_BUSY_DRIVE", "The system cannot perform a JOIN or SUBST at this time." },
    { 143, "ERROR_SAME_DRIVE", "The system cannot join or substitute a drive to or for a directory on the same drive." },
    { 144, "ERROR_DIR_NOT_ROOT", "The directory is not a subdirectory of the root directory." },
    { 145, "ERROR_DIR_NOT_EMPTY", "The directory is not empty." },
    { 146, "ERROR_IS_SUBST_PATH", "The path specified is being used in a substitute." },
    { 147, "ERROR_IS_JOIN_PATH", "Not enough resources are available to process this command." },
    { 148, "ERROR_PATH_BUSY", "The path specified cannot be used at this time." },
    { 149, "ERROR_IS_SUBST_TARGET", "An attempt was made to join or substitute a drive for which a directory on the drive is the target of a previous substitute." },
    { 150, "ERROR_SYSTEM_TRACE", "System trace information was not specified in your CONFIG.SYS file, or tracing is disallowed." },
    { 151, "ERROR_INVALID_EVENT_COUNT", "The number of specified semaphore events for DosMuxSemWait is not correct." },
    { 152, "ERROR_TOO_MANY_MUXWAITERS", "DosMuxSemWait did not execute; too many semaphores are already set." },
    { 153, "ERROR_INVALID_LIST_FORMAT", "The DosMuxSemWait list is not correct." },
    { 154, "ERROR_LABEL_TOO_LONG", "The volume label you entered exceeds the label character limit of the target file system." },
    { 155, "ERROR_TOO_MANY_TCBS", "Cannot create another thread." },
    { 156, "ERROR_SIGNAL_REFUSED", "The recipient process has refused the signal." },
    { 157, "ERROR_DISCARDED", "The segment is already discarded and cannot be locked." },
    { 158, "ERROR_NOT_LOCKED", "The segment is already unlocked." },
    { 159, "ERROR_BAD_THREADID_ADDR", "The address for the thread ID is not correct." },
    { 160, "ERROR_BAD_ARGUMENTS", "The argument string passed to DosExecPgm is not correct." },
    { 161, "ERROR_BAD_PATHNAME", "The specified path is invalid." },
    { 162, "ERROR_SIGNAL_PENDING", "A signal is already pending." },
    { 164, "ERROR_MAX_THRDS_REACHED", "No more threads can be created in the system." },
    { 167, "ERROR_LOCK_FAILED", "Unable to lock a region of a file." },
    { 170, "ERROR_BUSY", "The requested resource is in use." },
    { 173, "ERROR_CANCEL_VIOLATION", "A lock request was not outstanding for the supplied cancel region." },
    { 174, "ERROR_ATOMIC_LOCKS_NOT_SUPPORTED", "The file system does not support atomic changes to the lock type." },
    { 180, "ERROR_INVALID_SEGMENT_NUMBER", "The system detected a segment number that was not correct." },
    { 182, "ERROR_INVALID_ORDINAL", "The operating system cannot run %1." },
    { 183, "ERROR_ALREADY_EXISTS", "Cannot create a file when that file already exists." },
    { 186, "ERROR_INVALID_FLAG_NUMBER", "The flag passed is not correct." },
    { 187, "ERROR_SEM_NOT_FOUND", "The specified system semaphore name was not found." },
    { 188, "ERROR_INVALID_STARTING_CODESEG", "The operating system cannot run %1." },
    { 189, "ERROR_INVALID_STACKSEG", "The operating system cannot run %1." },
    { 190, "ERROR_INVALID_MODULETYPE", "The operating system cannot run %1." },
    { 191, "ERROR_INVALID_EXE_SIGNATURE", "Cannot run %1 in Win32 mode." },
    { 192, "ERROR_EXE_MARKED_INVALID", "The operating system cannot run %1." },
    { 193, "ERROR_BAD_EXE_FORMAT", "1 is not a valid Win32 application." },
    { 194, "ERROR_ITERATED_DATA_EXCEEDS_64k", "The operating system cannot run %1." },
    { 195, "ERROR_INVALID_MINALLOCSIZE", "The operating system cannot run %1." },
    { 196, "ERROR_DYNLINK_FROM_INVALID_RING", "The operating system cannot run this application program." },
    { 197, "ERROR_IOPL_NOT_ENABLED", "The operating system is not presently configured to run this application." },
    { 198, "ERROR_INVALID_SEGDPL", "The operating system cannot run %1." },
    { 199, "ERROR_AUTODATASEG_EXCEEDS_64k", "The operating system cannot run this application program." },
    { 200, "ERROR_RING2SEG_MUST_BE_MOVABLE", "The code segment cannot be greater than or equal to 64K." },
    { 201, "ERROR_RELOC_CHAIN_XEEDS_SEGLIM", "The operating system cannot run %1." },
    { 202, "ERROR_INFLOOP_IN_RELOC_CHAIN", "The operating system cannot run %1." },
    { 203, "ERROR_ENVVAR_NOT_FOUND", "The system could not find the environment option that was entered." },
    { 205, "ERROR_NO_SIGNAL_SENT", "No process in the command subtree has a signal handler." },
    { 206, "ERROR_FILENAME_EXCED_RANGE", "The filename or extension is too long." },
    { 207, "ERROR_RING2_STACK_IN_USE", "The ring 2 stack is in use." },
    { 208, "ERROR_META_EXPANSION_TOO_LONG", "The global filename characters, * or ?, are entered incorrectly or too many global filename characters are specified." },
    { 209, "ERROR_INVALID_SIGNAL_NUMBER", "The signal being posted is not correct." },
    { 210, "ERROR_THREAD_1_INACTIVE", "The signal handler cannot be set." },
    { 212, "ERROR_LOCKED", "The segment is locked and cannot be reallocated." },
    { 214, "ERROR_TOO_MANY_MODULES", "Too many dynamic-link modules are attached to this program or dynamic-link module." },
    { 215, "ERROR_NESTING_NOT_ALLOWED", "Cannot nest calls to LoadModule." },
    { 216, "ERROR_EXE_MACHINE_TYPE_MISMATCH", "The image file %1 is valid, but is for a machine type other than the current machine." },
    { 230, "ERROR_BAD_PIPE", "The pipe state is invalid." },
    { 231, "ERROR_PIPE_BUSY", "All pipe instances are busy." },
    { 232, "ERROR_NO_DATA", "The pipe is being closed." },
    { 233, "ERROR_PIPE_NOT_CONNECTED", "No process is on the other end of the pipe." },
    { 234, "ERROR_MORE_DATA", "More data is available." },
    { 240, "ERROR_VC_DISCONNECTED", "The session was canceled." },
    { 254, "ERROR_INVALID_EA_NAME", "The specified extended attribute name was invalid." },
    { 255, "ERROR_EA_LIST_INCONSISTENT", "The extended attributes are inconsistent." },
    { 258, "WAIT_TIMEOUT", "The wait operation timed out." },
    { 259, "ERROR_NO_MORE_ITEMS", "No more data is available." },
    { 266, "ERROR_CANNOT_COPY", "The copy functions cannot be used." },
    { 267, "ERROR_DIRECTORY", "The directory name is invalid." },
    { 275, "ERROR_EAS_DIDNT_FIT", "The extended attributes did not fit in the buffer." },
    { 276, "ERROR_EA_FILE_CORRUPT", "The extended attribute file on the mounted file system is corrupt." },
    { 277, "ERROR_EA_TABLE_FULL", "The extended attribute table file is full." },
    { 278, "ERROR_INVALID_EA_HANDLE", "The specified extended attribute handle is invalid." },
    { 282, "ERROR_EAS_NOT_SUPPORTED", "The mounted file system does not support extended attributes." },
    { 288, "ERROR_NOT_OWNER", "Attempt to release mutex not owned by caller." },
    { 298, "ERROR_TOO_MANY_POSTS", "Too many posts were made to a semaphore." },
    { 299, "ERROR_PARTIAL_COPY", "Only part of a ReadProcessMemory or WriteProcessMemory request was completed." },
    { 300, "ERROR_OPLOCK_NOT_GRANTED", "The oplock request is denied." },
    { 301, "ERROR_INVALID_OPLOCK_PROTOCOL", "An invalid oplock acknowledgment was received by the system." },
    { 317, "ERROR_MR_MID_NOT_FOUND", "The system cannot find message text for message number 0x%1 in the message file for %2." },
    { 487, "ERROR_INVALID_ADDRESS", "Attempt to access invalid address." },
    { 534, "ERROR_ARITHMETIC_OVERFLOW", "Arithmetic result exceeded 32 bits." },
    { 535, "ERROR_PIPE_CONNECTED", "There is a process on other end of the pipe." },
    { 536, "ERROR_PIPE_LISTENING", "Waiting for a process to open the other end of the pipe." },
    { 994, "ERROR_EA_ACCESS_DENIED", "Access to the extended attribute was denied." },
    { 995, "ERROR_OPERATION_ABORTED", "The I/O operation has been aborted because of either a thread exit or an application request." },
    { 996, "ERROR_IO_INCOMPLETE", "Overlapped I/O event is not in a signaled state." },
    { 997, "ERROR_IO_PENDING", "Overlapped I/O operation is in progress." },
    { 998, "ERROR_NOACCESS", "Invalid access to memory location." },
    { 999, "ERROR_SWAPERROR", "Error performing inpage operation." },
    { 1001, "ERROR_STACK_OVERFLOW", "Recursion too deep; the stack overflowed." },
    { 1002, "ERROR_INVALID_MESSAGE", "The window cannot act on the sent message." },
    { 1003, "ERROR_CAN_NOT_COMPLETE", "Cannot complete this function." },
    { 1004, "ERROR_INVALID_FLAGS", "Invalid flags." },
    { 1005, "ERROR_UNRECOGNIZED_VOLUME", "The volume does not contain a recognized file system. Please make sure that all required file system drivers are loaded and that the volume is not corrupted." },
    { 1006, "ERROR_FILE_INVALID", "The volume for a file has been externally altered so that the opened file is no longer valid." },
    { 1007, "ERROR_FULLSCREEN_MODE", "The requested operation cannot be performed in full-screen mode." },
    { 1008, "ERROR_NO_TOKEN", "An attempt was made to reference a token that does not exist." },
    { 1009, "ERROR_BADDB", "The configuration registry database is corrupt." },
    { 1010, "ERROR_BADKEY", "The configuration registry key is invalid." },
    { 1011, "ERROR_CANTOPEN", "The configuration registry key could not be opened." },
    { 1012, "ERROR_CANTREAD", "The configuration registry key could not be read." },
    { 1013, "ERROR_CANTWRITE", "The configuration registry key could not be written." },
    { 1014, "ERROR_REGISTRY_RECOVERED", "One of the files in the registry database had to be recovered by use of a log or alternate copy. The recovery was successful." },
    { 1015, "ERROR_REGISTRY_CORRUPT", "The registry is corrupted. The structure of one of the files containing registry data is corrupted, or the system's memory image of the file is corrupted, or the file could not be recovered because the alternate copy or log was absent or corrupted." },
    { 1016, "ERROR_REGISTRY_IO_FAILED", "An I/O operation initiated by the registry failed unrecoverably. The registry could not read in, or write out, or flush, one of the files that contain the system's image of the registry." },
    { 1017, "ERROR_NOT_REGISTRY_FILE", "The system has attempted to load or restore a file into the registry, but the specified file is not in a registry file format." },
    { 1018, "ERROR_KEY_DELETED", "Illegal operation attempted on a registry key that has been marked for deletion." },
    { 1019, "ERROR_NO_LOG_SPACE", "System could not allocate the required space in a registry log." },
    { 1020, "ERROR_KEY_HAS_CHILDREN", "Cannot create a symbolic link in a registry key that already has subkeys or values." },
    { 1021, "ERROR_CHILD_MUST_BE_VOLATILE", "Cannot create a stable subkey under a volatile parent key." },
    { 1022, "ERROR_NOTIFY_ENUM_DIR", "A notify change request is being completed and the information is not being returned in the caller's buffer. The caller now needs to enumerate the files to find the changes." },
    { 1051, "ERROR_DEPENDENT_SERVICES_RUNNING", "A stop control has been sent to a service that other running services are dependent on." },
    { 1052, "ERROR_INVALID_SERVICE_CONTROL", "The requested control is not valid for this service." },
    { 1053, "ERROR_SERVICE_REQUEST_TIMEOUT", "The service did not respond to the start or control request in a timely fashion." },
    { 1054, "ERROR_SERVICE_NO_THREAD", "A thread could not be created for the service." },
    { 1055, "ERROR_SERVICE_DATABASE_LOCKED", "The service database is locked." },
    { 1056, "ERROR_SERVICE_ALREADY_RUNNING", "An instance of the service is already running." },
    { 1057, "ERROR_INVALID_SERVICE_ACCOUNT", "The account name is invalid or does not exist, or the password is invalid for the account name specified." },
    { 1058, "ERROR_SERVICE_DISABLED", "The service cannot be started, either because it is disabled or because it has no enabled devices associated with it." },
    { 1059, "ERROR_CIRCULAR_DEPENDENCY", "Circular service dependency was specified." },
    { 1060, "ERROR_SERVICE_DOES_NOT_EXIST", "The specified service does not exist as an installed service." },
    { 1061, "ERROR_SERVICE_CANNOT_ACCEPT_CTRL", "The service cannot accept control messages at this time." },
    { 1062, "ERROR_SERVICE_NOT_ACTIVE", "The service has not been started." },
    { 1063, "ERROR_FAILED_SERVICE_CONTROLLER_CONNECT", "The service process could not connect to the service controller." },
    { 1064, "ERROR_EXCEPTION_IN_SERVICE", "An exception occurred in the service when handling the control request." },
    { 1065, "ERROR_DATABASE_DOES_NOT_EXIST", "The database specified does not exist." },
    { 1066, "ERROR_SERVICE_SPECIFIC_ERROR", "The service has returned a service-specific error code." },
    { 1067, "ERROR_PROCESS_ABORTED", "The process terminated unexpectedly." },
    { 1068, "ERROR_SERVICE_DEPENDENCY_FAIL", "The dependency service or group failed to start." },
    { 1069, "ERROR_SERVICE_LOGON_FAILED", "The service did not start due to a logon failure." },
    { 1070, "ERROR_SERVICE_START_HANG", "After starting, the service hung in a start-pending state." },
    { 1071, "ERROR_INVALID_SERVICE_LOCK", "The specified service database lock is invalid." },
    { 1072, "ERROR_SERVICE_MARKED_FOR_DELETE", "The specified service has been marked for deletion." },
    { 1073, "ERROR_SERVICE_EXISTS", "The specified service already exists." },
    { 1074, "ERROR_ALREADY_RUNNING_LKG", "The system is currently running with the last-known-good configuration." },
    { 1075, "ERROR_SERVICE_DEPENDENCY_DELETED", "The dependency service does not exist or has been marked for deletion." },
    { 1076, "ERROR_BOOT_ALREADY_ACCEPTED", "The current boot has already been accepted for use as the last-known-good control set." },
    { 1077, "ERROR_SERVICE_NEVER_STARTED", "No attempts to start the service have been made since the last boot." },
    { 1078, "ERROR_DUPLICATE_SERVICE_NAME", "The name is already in use as either a service name or a service display name." },
    { 1079, "ERROR_DIFFERENT_SERVICE_ACCOUNT", "The account specified for this service is different from the account specified for other services running in the same process." },
    { 1080, "ERROR_CANNOT_DETECT_DRIVER_FAILURE", "Failure actions can only be set for Win32 services, not for drivers." },
    { 1081, "ERROR_CANNOT_DETECT_PROCESS_ABORT", "This service runs in the same process as the service control manager. Therefore, the service control manager cannot take action if this service's process terminates unexpectedly." },
    { 1082, "ERROR_NO_RECOVERY_PROGRAM", "No recovery program has been configured for this service." },
    { 1083, "ERROR_SERVICE_NOT_IN_EXE", "The executable program that this service is configured to run in does not implement the service." },
    { 1100, "ERROR_END_OF_MEDIA", "The physical end of the tape has been reached." },
    { 1101, "ERROR_FILEMARK_DETECTED", "A tape access reached a filemark." },
    { 1102, "ERROR_BEGINNING_OF_MEDIA", "The beginning of the tape or a partition was encountered." },
    { 1103, "ERROR_SETMARK_DETECTED", "A tape access reached the end of a set of files." },
    { 1104, "ERROR_NO_DATA_DETECTED", "No more data is on the tape." },
    { 1105, "ERROR_PARTITION_FAILURE", "Tape could not be partitioned." },
    { 1106, "ERROR_INVALID_BLOCK_LENGTH", "When accessing a new tape of a multivolume partition, the current block size is incorrect." },
    { 1107, "ERROR_DEVICE_NOT_PARTITIONED", "Tape partition information could not be found when loading a tape." },
    { 1108, "ERROR_UNABLE_TO_LOCK_MEDIA", "Unable to lock the media eject mechanism." },
    { 1109, "ERROR_UNABLE_TO_UNLOAD_MEDIA", "Unable to unload the media." },
    { 1110, "ERROR_MEDIA_CHANGED", "The media in the drive may have changed." },
    { 1111, "ERROR_BUS_RESET", "The I/O bus was reset." },
    { 1112, "ERROR_NO_MEDIA_IN_DRIVE", "No media in drive." },
    { 1113, "ERROR_NO_UNICODE_TRANSLATION", "No mapping for the Unicode character exists in the target multi-byte code page." },
    { 1114, "ERROR_DLL_INIT_FAILED", "A dynamic link library (DLL) initialization routine failed." },
    { 1115, "ERROR_SHUTDOWN_IN_PROGRESS", "A system shutdown is in progress." },
    { 1116, "ERROR_NO_SHUTDOWN_IN_PROGRESS", "Unable to abort the system shutdown because no shutdown was in progress." },
    { 1117, "ERROR_IO_DEVICE", "The request could not be performed because of an I/O device error." },
    { 1118, "ERROR_SERIAL_NO_DEVICE", "No serial device was successfully initialized. The serial driver will unload." },
    { 1119, "ERROR_IRQ_BUSY", "Unable to open a device that was sharing an interrupt request (IRQ) with other devices. At least one other device that uses that IRQ was already opened." },
    { 1120, "ERROR_MORE_WRITES", "A serial I/O operation was completed by another write to the serial port. (The IOCTL_SERIAL_XOFF_COUNTER reached zero.)" },
    { 1121, "ERROR_COUNTER_TIMEOUT", "A serial I/O operation completed because the timeout period expired. (The IOCTL_SERIAL_XOFF_COUNTER did not reach zero.)" },
    { 1122, "ERROR_FLOPPY_ID_MARK_NOT_FOUND", "No ID address mark was found on the floppy disk." },
    { 1123, "ERROR_FLOPPY_WRONG_CYLINDER", "Mismatch between the floppy disk sector ID field and the floppy disk controller track address." },
    { 1124, "ERROR_FLOPPY_UNKNOWN_ERROR", "The floppy disk controller reported an error that is not recognized by the floppy disk driver." },
    { 1125, "ERROR_FLOPPY_BAD_REGISTERS", "The floppy disk controller returned inconsistent results in its registers." },
    { 1126, "ERROR_DISK_RECALIBRATE_FAILED", "While accessing the hard disk, a recalibrate operation failed, even after retries." },
    { 1127, "ERROR_DISK_OPERATION_FAILED", "While accessing the hard disk, a disk operation failed even after retries." },
    { 1128, "ERROR_DISK_RESET_FAILED", "While accessing the hard disk, a disk controller reset was needed, but even that failed." },
    { 1129, "ERROR_EOM_OVERFLOW", "Physical end of tape encountered." },
    { 1130, "ERROR_NOT_ENOUGH_SERVER_MEMORY", "Not enough server storage is available to process this command." },
    { 1131, "ERROR_POSSIBLE_DEADLOCK", "A potential deadlock condition has been detected." },
    { 1132, "ERROR_MAPPED_ALIGNMENT", "The base address or the file offset specified does not have the proper alignment." },
    { 1140, "ERROR_SET_POWER_STATE_VETOED", "An attempt to change the system power state was vetoed by another application or driver." },
    { 1141, "ERROR_SET_POWER_STATE_FAILED", "The system BIOS failed an attempt to change the system power state." },
    { 1142, "ERROR_TOO_MANY_LINKS", "An attempt was made to create more links on a file than the file system supports." },
    { 1150, "ERROR_OLD_WIN_VERSION", "The specified program requires a newer version of Windows." },
    { 1151, "ERROR_APP_WRONG_OS", "The specified program is not a Windows or MS-DOS program." },
    { 1152, "ERROR_SINGLE_INSTANCE_APP", "Cannot start more than one instance of the specified program." },
    { 1153, "ERROR_RMODE_APP", "The specified program was written for an earlier version of Windows." },
    { 1154, "ERROR_INVALID_DLL", "One of the library files needed to run this application is damaged." },
    { 1155, "ERROR_NO_ASSOCIATION", "No application is associated with the specified file for this operation." },
    { 1156, "ERROR_DDE_FAIL", "An error occurred in sending the command to the application." },
    { 1157, "ERROR_DLL_NOT_FOUND", "One of the library files needed to run this application cannot be found." },
    { 1158, "ERROR_NO_MORE_USER_HANDLES", "The current process has used all of its system allowance of handles for Window Manager objects." },
    { 1159, "ERROR_MESSAGE_SYNC_ONLY", "The message can be used only with synchronous operations." },
    { 1160, "ERROR_SOURCE_ELEMENT_EMPTY", "The indicated source element has no media." },
    { 1161, "ERROR_DESTINATION_ELEMENT_FULL", "The indicated destination element already contains media." },
    { 1162, "ERROR_ILLEGAL_ELEMENT_ADDRESS", "The indicated element does not exist." },
    { 1163, "ERROR_MAGAZINE_NOT_PRESENT", "The indicated element is part of a magazine that is not present." },
    { 1164, "ERROR_DEVICE_REINITIALIZATION_NEEDED", "The indicated device requires reinitialization due to hardware errors." },
    { 1165, "ERROR_DEVICE_REQUIRES_CLEANING", "The device has indicated that cleaning is required before further operations are attempted." },
    { 1166, "ERROR_DEVICE_DOOR_OPEN", "The device has indicated that its door is open." },
    { 1167, "ERROR_DEVICE_NOT_CONNECTED", "The device is not connected." },
    { 1168, "ERROR_NOT_FOUND", "Element not found." },
    { 1169, "ERROR_NO_MATCH", "There was no match for the specified key in the index." },
    { 1170, "ERROR_SET_NOT_FOUND", "The property set specified does not exist on the object." },
    { 1171, "ERROR_POINT_NOT_FOUND", "The point passed to GetMouseMovePoints is not in the buffer." },
    { 1172, "ERROR_NO_TRACKING_SERVICE", "The tracking (workstation) service is not running." },
    { 1173, "ERROR_NO_VOLUME_ID", "The Volume ID could not be found." },
    { 1175, "ERROR_UNABLE_TO_REMOVE_REPLACED", "Unable to remove the file to be replaced." },
    { 1176, "ERROR_UNABLE_TO_MOVE_REPLACEMENT", "Unable to move the replacement file to the file to be replaced. The file to be replaced has retained its original name." },
    { 1177, "ERROR_UNABLE_TO_MOVE_REPLACEMENT_2", "Unable to move the replacement file to the file to be replaced. The file to be replaced has been renamed using the backup name." },
    { 1178, "ERROR_JOURNAL_DELETE_IN_PROGRESS", "The volume change journal is being deleted." },
    { 1179, "ERROR_JOURNAL_NOT_ACTIVE", "The volume change journal service is not active." },
    { 1180, "ERROR_POTENTIAL_FILE_FOUND", "A file was found, but it may not be the correct file." },
    { 1181, "ERROR_JOURNAL_ENTRY_DELETED", "The journal entry has been deleted from the journal." },
    { 1200, "ERROR_BAD_DEVICE", "The specified device name is invalid." },
    { 1201, "ERROR_CONNECTION_UNAVAIL", "The device is not currently connected but it is a remembered connection." },
    { 1202, "ERROR_DEVICE_ALREADY_REMEMBERED", "An attempt was made to remember a device that had previously been remembered." },
    { 1203, "ERROR_NO_NET_OR_BAD_PATH", "No network provider accepted the given network path." },
    { 1204, "ERROR_BAD_PROVIDER", "The specified network provider name is invalid." },
    { 1205, "ERROR_CANNOT_OPEN_PROFILE", "Unable to open the network connection profile." },
    { 1206, "ERROR_BAD_PROFILE", "The network connection profile is corrupted." },
    { 1207, "ERROR_NOT_CONTAINER", "Cannot enumerate a noncontainer." },
    { 1208, "ERROR_EXTENDED_ERROR", "An extended error has occurred." },
    { 1209, "ERROR_INVALID_GROUPNAME", "The format of the specified group name is invalid." },
    { 1210, "ERROR_INVALID_COMPUTERNAME", "The format of the specified computer name is invalid." },
    { 1211, "ERROR_INVALID_EVENTNAME", "The format of the specified event name is invalid." },
    { 1212, "ERROR_INVALID_DOMAINNAME", "The format of the specified domain name is invalid." },
    { 1213, "ERROR_INVALID_SERVICENAME", "The format of the specified service name is invalid." },
    { 1214, "ERROR_INVALID_NETNAME", "The format of the specified network name is invalid." },
    { 1215, "ERROR_INVALID_SHARENAME", "The format of the specified share name is invalid." },
    { 1216, "ERROR_INVALID_PASSWORDNAME", "The format of the specified password is invalid." },
    { 1217, "ERROR_INVALID_MESSAGENAME", "The format of the specified message name is invalid." },
    { 1218, "ERROR_INVALID_MESSAGEDEST", "The format of the specified message destination is invalid." },
    { 1219, "ERROR_SESSION_CREDENTIAL_CONFLICT", "The credentials supplied conflict with an existing set of credentials." },
    { 1220, "ERROR_REMOTE_SESSION_LIMIT_EXCEEDED", "An attempt was made to establish a session to a network server, but there are already too many sessions established to that server." },
    { 1221, "ERROR_DUP_DOMAINNAME", "The workgroup or domain name is already in use by another computer on the network." },
    { 1222, "ERROR_NO_NETWORK", "The network is not present or not started." },
    { 1223, "ERROR_CANCELLED", "The operation was canceled by the user." },
    { 1224, "ERROR_USER_MAPPED_FILE", "The requested operation cannot be performed on a file with a user-mapped section open." },
    { 1225, "ERROR_CONNECTION_REFUSED", "The remote system refused the network connection." },
    { 1226, "ERROR_GRACEFUL_DISCONNECT", "The network connection was gracefully closed." },
    { 1227, "ERROR_ADDRESS_ALREADY_ASSOCIATED", "The network transport endpoint already has an address associated with it." },
    { 1228, "ERROR_ADDRESS_NOT_ASSOCIATED", "An address has not yet been associated with the network endpoint." },
    { 1229, "ERROR_CONNECTION_INVALID", "An operation was attempted on a nonexistent network connection." },
    { 1230, "ERROR_CONNECTION_ACTIVE", "An invalid operation was attempted on an active network connection." },
    { 1231, "ERROR_NETWORK_UNREACHABLE", "The network location cannot be reached. For information about network troubleshooting, see Windows Help." },
    { 1232, "ERROR_HOST_UNREACHABLE", "The network location cannot be reached. For information about network troubleshooting, see Windows Help." },
    { 1233, "ERROR_PROTOCOL_UNREACHABLE", "The network location cannot be reached. For information about network troubleshooting, see Windows Help." },
    { 1234, "ERROR_PORT_UNREACHABLE", "No service is operating at the destination network endpoint on the remote system." },
    { 1235, "ERROR_REQUEST_ABORTED", "The request was aborted." },
    { 1236, "ERROR_CONNECTION_ABORTED", "The network connection was aborted by the local system." },
    { 1237, "ERROR_RETRY", "The operation could not be completed. A retry should be performed." },
    { 1238, "ERROR_CONNECTION_COUNT_LIMIT", "A connection to the server could not be made because the limit on the number of concurrent connections for this account has been reached." },
    { 1239, "ERROR_LOGIN_TIME_RESTRICTION", "Attempting to log in during an unauthorized time of day for this account." },
    { 1240, "ERROR_LOGIN_WKSTA_RESTRICTION", "The account is not authorized to log in from this station." },
    { 1241, "ERROR_INCORRECT_ADDRESS", "The network address could not be used for the operation requested." },
    { 1242, "ERROR_ALREADY_REGISTERED", "The service is already registered." },
    { 1243, "ERROR_SERVICE_NOT_FOUND", "The specified service does not exist." },
    { 1244, "ERROR_NOT_AUTHENTICATED", "The operation being requested was not performed because the user has not been authenticated." },
    { 1245, "ERROR_NOT_LOGGED_ON", "The operation being requested was not performed because the user has not logged on to the network. The specified service does not exist." },
    { 1246, "ERROR_CONTINUE", "Continue with work in progress." },
    { 1247, "ERROR_ALREADY_INITIALIZED", "An attempt was made to perform an initialization operation when initialization has already been completed." },
    { 1248, "ERROR_NO_MORE_DEVICES", "No more local devices." },
    { 1249, "ERROR_NO_SUCH_SITE", "The specified site does not exist." },
    { 1250, "ERROR_DOMAIN_CONTROLLER_EXISTS", "A domain controller with the specified name already exists." },
    { 1251, "ERROR_ONLY_IF_CONNECTED", "This operation is supported only when you are connected to the server." },
    { 1252, "ERROR_OVERRIDE_NOCHANGES", "The group policy framework should call the extension even if there are no changes." },
    { 1253, "ERROR_BAD_USER_PROFILE", "The specified user does not have a valid profile." },
    { 1254, "ERROR_NOT_SUPPORTED_ON_SBS", "This operation is not supported on a Microsoft Small Business Server" },
    { 1300, "ERROR_NOT_ALL_ASSIGNED", "Not all privileges referenced are assigned to the caller." },
    { 1301, "ERROR_SOME_NOT_MAPPED", "Some mapping between account names and security IDs was not done." },
    { 1302, "ERROR_NO_QUOTAS_FOR_ACCOUNT", "No system quota limits are specifically set for this account." },
    { 1303, "ERROR_LOCAL_USER_SESSION_KEY", "No encryption key is available. A well-known encryption key was returned." },
    { 1304, "ERROR_NULL_LM_PASSWORD", "The password is too complex to be converted to a LAN Manager password. The LAN Manager password returned is a NULL string." },
    { 1305, "ERROR_UNKNOWN_REVISION", "The revision level is unknown." },
    { 1306, "ERROR_REVISION_MISMATCH", "Indicates two revision levels are incompatible." },
    { 1307, "ERROR_INVALID_OWNER", "This security ID may not be assigned as the owner of this object." },
    { 1308, "ERROR_INVALID_PRIMARY_GROUP", "This security ID may not be assigned as the primary group of an object." },
    { 1309, "ERROR_NO_IMPERSONATION_TOKEN", "An attempt has been made to operate on an impersonation token by a thread that is not currently impersonating a client." },
    { 1310, "ERROR_CANT_DISABLE_MANDATORY", "The group may not be disabled." },
    { 1311, "ERROR_NO_LOGON_SERVERS", "There are currently no logon servers available to service the logon request." },
    { 1312, "ERROR_NO_SUCH_LOGON_SESSION", "A specified logon session does not exist. It may already have been terminated." },
    { 1313, "ERROR_NO_SUCH_PRIVILEGE", "A specified privilege does not exist." },
    { 1314, "ERROR_PRIVILEGE_NOT_HELD", "A required privilege is not held by the client." },
    { 1315, "ERROR_INVALID_ACCOUNT_NAME", "The name provided is not a properly formed account name." },
    { 1316, "ERROR_USER_EXISTS", "The specified user already exists." },
    { 1317, "ERROR_NO_SUCH_USER", "The specified user does not exist." },
    { 1318, "ERROR_GROUP_EXISTS", "The specified group already exists." },
    { 1319, "ERROR_NO_SUCH_GROUP", "The specified group does not exist." },
    { 1320, "ERROR_MEMBER_IN_GROUP", "Either the specified user account is already a member of the specified group, or the specified group cannot be deleted because it contains a member." },
    { 1321, "ERROR_MEMBER_NOT_IN_GROUP", "The specified user account is not a member of the specified group account." },
    { 1322, "ERROR_LAST_ADMIN", "The last remaining administration account cannot be disabled or deleted." },
    { 1323, "ERROR_WRONG_PASSWORD", "Unable to update the password. The value provided as the current password is incorrect." },
    { 1324, "ERROR_ILL_FORMED_PASSWORD", "Unable to update the password. The value provided for the new password contains values that are not allowed in passwords." },
    { 1325, "ERROR_PASSWORD_RESTRICTION", "Unable to update the password. The value provided for the new password does not meet the length, complexity, or history requirement of the domain." },
    { 1326, "ERROR_LOGON_FAILURE", "Logon failure: unknown user name or bad password." },
    { 1327, "ERROR_ACCOUNT_RESTRICTION", "Logon failure: user account restriction." },
    { 1328, "ERROR_INVALID_LOGON_HOURS", "Logon failure: account logon time restriction violation." },
    { 1329, "ERROR_INVALID_WORKSTATION", "Logon failure: user not allowed to log on to this computer." },
    { 1330, "ERROR_PASSWORD_EXPIRED", "Logon failure: the specified account password has expired." },
    { 1331, "ERROR_ACCOUNT_DISABLED", "Logon failure: account currently disabled." },
    { 1332, "ERROR_NONE_MAPPED", "No mapping between account names and security IDs was done." },
    { 1333, "ERROR_TOO_MANY_LUIDS_REQUESTED", "Too many local user identifiers (LUIDs) were requested at one time." },
    { 1334, "ERROR_LUIDS_EXHAUSTED", "No more local user identifiers (LUIDs) are available." },
    { 1335, "ERROR_INVALID_SUB_AUTHORITY", "The subauthority part of a security ID is invalid for this particular use." },
    { 1336, "ERROR_INVALID_ACL", "The access control list (ACL) structure is invalid." },
    { 1337, "ERROR_INVALID_SID", "The security ID structure is invalid." },
    { 1338, "ERROR_INVALID_SECURITY_DESCR", "The security descriptor structure is invalid." },
    { 1340, "ERROR_BAD_INHERITANCE_ACL", "The inherited access control list (ACL) or access control entry (ACE) could not be built." },
    { 1341, "ERROR_SERVER_DISABLED", "The server is currently disabled." },
    { 1342, "ERROR_SERVER_NOT_DISABLED", "The server is currently enabled." },
    { 1343, "ERROR_INVALID_ID_AUTHORITY", "The value provided was an invalid value for an identifier authority." },
    { 1344, "ERROR_ALLOTTED_SPACE_EXCEEDED", "No more memory is available for security information updates." },
    { 1345, "ERROR_INVALID_GROUP_ATTRIBUTES", "The specified attributes are invalid, or incompatible with the attributes for the group as a whole." },
    { 1346, "ERROR_BAD_IMPERSONATION_LEVEL", "Either a required impersonation level was not provided, or the provided impersonation level is invalid." },
    { 1347, "ERROR_CANT_OPEN_ANONYMOUS", "Cannot open an anonymous level security token." },
    { 1348, "ERROR_BAD_VALIDATION_CLASS", "The validation information class requested was invalid." },
    { 1349, "ERROR_BAD_TOKEN_TYPE", "The type of the token is inappropriate for its attempted use." },
    { 1350, "ERROR_NO_SECURITY_ON_OBJECT", "Unable to perform a security operation on an object that has no associated security." },
    { 1351, "ERROR_CANT_ACCESS_DOMAIN_INFO", "Configuration information could not be read from the domain controller, either because the machine is unavailable, or access has been denied." },
    { 1352, "ERROR_INVALID_SERVER_STATE", "The security account manager (SAM) or local security authority (LSA) server was in the wrong state to perform the security operation." },
    { 1353, "ERROR_INVALID_DOMAIN_STATE", "The domain was in the wrong state to perform the security operation." },
    { 1354, "ERROR_INVALID_DOMAIN_ROLE", "This operation is only allowed for the Primary Domain Controller of the domain." },
    { 1355, "ERROR_NO_SUCH_DOMAIN", "The specified domain either does not exist or could not be contacted." },
    { 1356, "ERROR_DOMAIN_EXISTS", "The specified domain already exists." },
    { 1357, "ERROR_DOMAIN_LIMIT_EXCEEDED", "An attempt was made to exceed the limit on the number of domains per server." },
    { 1358, "ERROR_INTERNAL_DB_CORRUPTION", "Unable to complete the requested operation because of either a catastrophic media failure or a data structure corruption on the disk." },
    { 1359, "ERROR_INTERNAL_ERROR", "An internal error occurred." },
    { 1360, "ERROR_GENERIC_NOT_MAPPED", "Generic access types were contained in an access mask which should already be mapped to nongeneric types." },
    { 1361, "ERROR_BAD_DESCRIPTOR_FORMAT", "A security descriptor is not in the right format (absolute or self-relative)." },
    { 1362, "ERROR_NOT_LOGON_PROCESS", "The requested action is restricted for use by logon processes only. The calling process has not registered as a logon process." },
    { 1363, "ERROR_LOGON_SESSION_EXISTS", "Cannot start a new logon session with an ID that is already in use." },
    { 1364, "ERROR_NO_SUCH_PACKAGE", "A specified authentication package is unknown." },
    { 1365, "ERROR_BAD_LOGON_SESSION_STATE", "The logon session is not in a state that is consistent with the requested operation." },
    { 1366, "ERROR_LOGON_SESSION_COLLISION", "The logon session ID is already in use." },
    { 1367, "ERROR_INVALID_LOGON_TYPE", "A logon request contained an invalid logon type value." },
    { 1368, "ERROR_CANNOT_IMPERSONATE", "Unable to impersonate using a named pipe until data has been read from that pipe." },
    { 1369, "ERROR_RXACT_INVALID_STATE", "The transaction state of a registry subtree is incompatible with the requested operation." },
    { 1370, "ERROR_RXACT_COMMIT_FAILURE", "An internal security database corruption has been encountered." },
    { 1371, "ERROR_SPECIAL_ACCOUNT", "Cannot perform this operation on built-in accounts." },
    { 1372, "ERROR_SPECIAL_GROUP", "Cannot perform this operation on this built-in special group." },
    { 1373, "ERROR_SPECIAL_USER", "Cannot perform this operation on this built-in special user." },
    { 1374, "ERROR_MEMBERS_PRIMARY_GROUP", "The user cannot be removed from a group because the group is currently the user's primary group." },
    { 1375, "ERROR_TOKEN_ALREADY_IN_USE", "The token is already in use as a primary token." },
    { 1376, "ERROR_NO_SUCH_ALIAS", "The specified local group does not exist." },
    { 1377, "ERROR_MEMBER_NOT_IN_ALIAS", "The specified account name is not a member of the local group." },
    { 1378, "ERROR_MEMBER_IN_ALIAS", "The specified account name is already a member of the local group." },
    { 1379, "ERROR_ALIAS_EXISTS", "The specified local group already exists." },
    { 1380, "ERROR_LOGON_NOT_GRANTED", "Logon failure: the user has not been granted the requested logon type at this computer." },
    { 1381, "ERROR_TOO_MANY_SECRETS", "The maximum number of secrets that may be stored in a single system has been exceeded." },
    { 1382, "ERROR_SECRET_TOO_LONG", "The length of a secret exceeds the maximum length allowed." },
    { 1383, "ERROR_INTERNAL_DB_ERROR", "The local security authority database contains an internal inconsistency." },
    { 1384, "ERROR_TOO_MANY_CONTEXT_IDS", "During a logon attempt, the user's security context accumulated too many security IDs." },
    { 1385, "ERROR_LOGON_TYPE_NOT_GRANTED", "Logon failure: the user has not been granted the requested logon type at this computer." },
    { 1386, "ERROR_NT_CROSS_ENCRYPTION_REQUIRED", "A cross-encrypted password is necessary to change a user password." },
    { 1387, "ERROR_NO_SUCH_MEMBER", "A member could not be added to or removed from the local group because the member does not exist." },
    { 1388, "ERROR_INVALID_MEMBER", "A new member could not be added to a local group because the member has the wrong account type." },
    { 1389, "ERROR_TOO_MANY_SIDS", "Too many security IDs have been specified." },
    { 1390, "ERROR_LM_CROSS_ENCRYPTION_REQUIRED", "A cross-encrypted password is necessary to change this user password." },
    { 1391, "ERROR_NO_INHERITANCE", "Indicates an ACL contains no inheritable components." },
    { 1392, "ERROR_FILE_CORRUPT", "The file or directory is corrupted and unreadable." },
    { 1393, "ERROR_DISK_CORRUPT", "The disk structure is corrupted and unreadable." },
    { 1394, "ERROR_NO_USER_SESSION_KEY", "There is no user session key for the specified logon session." },
    { 1395, "ERROR_LICENSE_QUOTA_EXCEEDED", "The service being accessed is licensed for a particular number of connections. No more connections can be made to the service at this time because there are already as many connections as the service can accept." },
    { 1396, "ERROR_WRONG_TARGET_NAME", "Logon Failure: The target account name is incorrect." },
    { 1397, "ERROR_MUTUAL_AUTH_FAILED", "Mutual Authentication failed. The server's password is out of date at the domain controller." },
    { 1398, "ERROR_TIME_SKEW", "There is a time difference between the client and server." },
    { 1400, "ERROR_INVALID_WINDOW_HANDLE", "Invalid window handle." },
    { 1401, "ERROR_INVALID_MENU_HANDLE", "Invalid menu handle." },
    { 1402, "ERROR_INVALID_CURSOR_HANDLE", "Invalid cursor handle." },
    { 1403, "ERROR_INVALID_ACCEL_HANDLE", "Invalid accelerator table handle." },
    { 1404, "ERROR_INVALID_HOOK_HANDLE", "Invalid hook handle." },
    { 1405, "ERROR_INVALID_DWP_HANDLE", "Invalid handle to a multiple-window position structure." },
    { 1406, "ERROR_TLW_WITH_WSCHILD", "Cannot create a top-level child window." },
    { 1407, "ERROR_CANNOT_FIND_WND_CLASS", "Cannot find window class." },
    { 1408, "ERROR_WINDOW_OF_OTHER_THREAD", "Invalid window; it belongs to other thread." },
    { 1409, "ERROR_HOTKEY_ALREADY_REGISTERED", "Hot key is already registered." },
    { 1410, "ERROR_CLASS_ALREADY_EXISTS", "Class already exists." },
    { 1411, "ERROR_CLASS_DOES_NOT_EXIST", "Class does not exist." },
    { 1412, "ERROR_CLASS_HAS_WINDOWS", "Class still has open windows." },
    { 1413, "ERROR_INVALID_INDEX", "Invalid index." },
    { 1414, "ERROR_INVALID_ICON_HANDLE", "Invalid icon handle." },
    { 1415, "ERROR_PRIVATE_DIALOG_INDEX", "Using private DIALOG window words." },
    { 1416, "ERROR_LISTBOX_ID_NOT_FOUND", "The list box identifier was not found." },
    { 1417, "ERROR_NO_WILDCARD_CHARACTERS", "No wildcards were found." },
    { 1418, "ERROR_CLIPBOARD_NOT_OPEN", "Thread does not have a clipboard open." },
    { 1419, "ERROR_HOTKEY_NOT_REGISTERED", "Hot key is not registered." },
    { 1420, "ERROR_WINDOW_NOT_DIALOG", "The window is not a valid dialog window." },
    { 1421, "ERROR_CONTROL_ID_NOT_FOUND", "Control ID not found." },
    { 1422, "ERROR_INVALID_COMBOBOX_MESSAGE", "Invalid message for a combo box because it does not have an edit control." },
    { 1423, "ERROR_WINDOW_NOT_COMBOBOX", "The window is not a combo box." },
    { 1424, "ERROR_INVALID_EDIT_HEIGHT", "Height must be less than 256." },
    { 1425, "ERROR_DC_NOT_FOUND", "Invalid device context (DC) handle." },
    { 1426, "ERROR_INVALID_HOOK_FILTER", "Invalid hook procedure type." },
    { 1427, "ERROR_INVALID_FILTER_PROC", "Invalid hook procedure." },
    { 1428, "ERROR_HOOK_NEEDS_HMOD", "Cannot set nonlocal hook without a module handle." },
    { 1429, "ERROR_GLOBAL_ONLY_HOOK", "This hook procedure can only be set globally." },
    { 1430, "ERROR_JOURNAL_HOOK_SET", "The journal hook procedure is already installed." },
    { 1431, "ERROR_HOOK_NOT_INSTALLED", "The hook procedure is not installed." },
    { 1432, "ERROR_INVALID_LB_MESSAGE", "Invalid message for single-selection list box." },
    { 1433, "ERROR_SETCOUNT_ON_BAD_LB", "LB_SETCOUNT sent to non-lazy list box." },
    { 1434, "ERROR_LB_WITHOUT_TABSTOPS", "This list box does not support tab stops." },
    { 1435, "ERROR_DESTROY_OBJECT_OF_OTHER_THREAD", "Cannot destroy object created by another thread." },
    { 1436, "ERROR_CHILD_WINDOW_MENU", "Child windows cannot have menus." },
    { 1437, "ERROR_NO_SYSTEM_MENU", "The window does not have a system menu." },
    { 1438, "ERROR_INVALID_MSGBOX_STYLE", "Invalid message box style." },
    { 1439, "ERROR_INVALID_SPI_VALUE", "Invalid system-wide (SPI_*) parameter." },
    { 1440, "ERROR_SCREEN_ALREADY_LOCKED", "Screen already locked." },
    { 1441, "ERROR_HWNDS_HAVE_DIFF_PARENT", "All handles to windows in a multiple-window position structure must have the same parent." },
    { 1442, "ERROR_NOT_CHILD_WINDOW", "The window is not a child window." },
    { 1443, "ERROR_INVALID_GW_COMMAND", "Invalid GW_* command." },
    { 1444, "ERROR_INVALID_THREAD_ID", "Invalid thread identifier." },
    { 1445, "ERROR_NON_MDICHILD_WINDOW", "Cannot process a message from a window that is not a multiple document interface (MDI) window." },
    { 1446, "ERROR_POPUP_ALREADY_ACTIVE", "Popup menu already active." },
    { 1447, "ERROR_NO_SCROLLBARS", "The window does not have scroll bars." },
    { 1448, "ERROR_INVALID_SCROLLBAR_RANGE", "Scroll bar range cannot be greater than MAXLONG." },
    { 1449, "ERROR_INVALID_SHOWWIN_COMMAND", "Cannot show or remove the window in the way specified." },
    { 1450, "ERROR_NO_SYSTEM_RESOURCES", "Insufficient system resources exist to complete the requested service." },
    { 1451, "ERROR_NONPAGED_SYSTEM_RESOURCES", "Insufficient system resources exist to complete the requested service." },
    { 1452, "ERROR_PAGED_SYSTEM_RESOURCES", "Insufficient system resources exist to complete the requested service." },
    { 1453, "ERROR_WORKING_SET_QUOTA", "Insufficient quota to complete the requested service." },
    { 1454, "ERROR_PAGEFILE_QUOTA", "Insufficient quota to complete the requested service." },
    { 1455, "ERROR_COMMITMENT_LIMIT", "The paging file is too small for this operation to complete." },
    { 1456, "ERROR_MENU_ITEM_NOT_FOUND", "A menu item was not found." },
    { 1457, "ERROR_INVALID_KEYBOARD_HANDLE", "Invalid keyboard layout handle." },
    { 1458, "ERROR_HOOK_TYPE_NOT_ALLOWED", "Hook type not allowed." },
    { 1459, "ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION", "This operation requires an interactive window station." },
    { 1460, "ERROR_TIMEOUT", "This operation returned because the timeout period expired." },
    { 1461, "ERROR_INVALID_MONITOR_HANDLE", "Invalid monitor handle." },
    { 1500, "ERROR_EVENTLOG_FILE_CORRUPT", "The event log file is corrupted." },
    { 1501, "ERROR_EVENTLOG_CANT_START", "No event log file could be opened, so the event logging service did not start." },
    { 1502, "ERROR_LOG_FILE_FULL", "The event log file is full." },
    { 1503, "ERROR_EVENTLOG_FILE_CHANGED", "The event log file has changed between read operations." },
    { 1601, "ERROR_INSTALL_SERVICE_FAILURE", "The Windows Installer service could not be accessed.  Contact your support personnel to verify that the Windows Installer service is properly registered." },
    { 1602, "ERROR_INSTALL_USEREXIT", "User cancelled installation." },
    { 1603, "ERROR_INSTALL_FAILURE", "Fatal error during installation." },
    { 1604, "ERROR_INSTALL_SUSPEND", "Installation suspended, incomplete." },
    { 1605, "ERROR_UNKNOWN_PRODUCT", "This action is only valid for products that are currently installed." },
    { 1606, "ERROR_UNKNOWN_FEATURE", "Feature ID not registered." },
    { 1607, "ERROR_UNKNOWN_COMPONENT", "Component ID not registered." },
    { 1608, "ERROR_UNKNOWN_PROPERTY", "Unknown property." },
    { 1609, "ERROR_INVALID_HANDLE_STATE", "Handle is in an invalid state." },
    { 1610, "ERROR_BAD_CONFIGURATION", "The configuration data for this product is corrupt.  Contact your support personnel." },
    { 1611, "ERROR_INDEX_ABSENT", "Component qualifier not present." },
    { 1612, "ERROR_INSTALL_SOURCE_ABSENT", "The installation source for this product is not available.  Verify that the source exists and that you can access it." },
    { 1613, "ERROR_INSTALL_PACKAGE_VERSION", "This installation package cannot be installed by the Windows Installer service.  You must install a Windows service pack that contains a newer version of the Windows Installer service." },
    { 1614, "ERROR_PRODUCT_UNINSTALLED", "Product is uninstalled." },
    { 1615, "ERROR_BAD_QUERY_SYNTAX", "SQL query syntax invalid or unsupported." },
    { 1616, "ERROR_INVALID_FIELD", "Record field does not exist." },
    { 1617, "ERROR_DEVICE_REMOVED", "The device has been removed." },
    { 1618, "ERROR_INSTALL_ALREADY_RUNNING", "Another installation is already in progress.  Complete that installation before proceeding with this install." },
    { 1619, "ERROR_INSTALL_PACKAGE_OPEN_FAILED", "This installation package could not be opened.  Verify that the package exists and that you can access it, or contact the application vendor to verify that this is a valid Windows Installer package." },
    { 1620, "ERROR_INSTALL_PACKAGE_INVALID", "This installation package could not be opened.  Contact the application vendor to verify that this is a valid Windows Installer package." },
    { 1621, "ERROR_INSTALL_UI_FAILURE", "There was an error starting the Windows Installer service user interface.  Contact your support personnel." },
    { 1622, "ERROR_INSTALL_LOG_FAILURE", "Error opening installation log file. Verify that the specified log file location exists and that you can write to it." },
    { 1623, "ERROR_INSTALL_LANGUAGE_UNSUPPORTED", "The language of this installation package is not supported by your system." },
    { 1624, "ERROR_INSTALL_TRANSFORM_FAILURE", "Error applying transforms.  Verify that the specified transform paths are valid." },
    { 1625, "ERROR_INSTALL_PACKAGE_REJECTED", "This installation is forbidden by system policy.  Contact your system administrator." },
    { 1626, "ERROR_FUNCTION_NOT_CALLED", "Function could not be executed." },
    { 1627, "ERROR_FUNCTION_FAILED", "Function failed during execution." },
    { 1628, "ERROR_INVALID_TABLE", "Invalid or unknown table specified." },
    { 1629, "ERROR_DATATYPE_MISMATCH", "Data supplied is of wrong type." },
    { 1630, "ERROR_UNSUPPORTED_TYPE", "Data of this type is not supported." },
    { 1631, "ERROR_CREATE_FAILED", "The Windows Installer service failed to start.  Contact your support personnel." },
    { 1632, "ERROR_INSTALL_TEMP_UNWRITABLE", "The temp folder is either full or inaccessible.  Verify that the temp folder exists and that you can write to it." },
    { 1633, "ERROR_INSTALL_PLATFORM_UNSUPPORTED", "This installation package is not supported by this processor type. Contact your product vendor." },
    { 1634, "ERROR_INSTALL_NOTUSED", "Component not used on this computer." },
    { 1635, "ERROR_PATCH_PACKAGE_OPEN_FAILED", "This patch package could not be opened.  Verify that the patch package exists and that you can access it, or contact the application vendor to verify that this is a valid Windows Installer patch package." },
    { 1636, "ERROR_PATCH_PACKAGE_INVALID", "This patch package could not be opened.  Contact the application vendor to verify that this is a valid Windows Installer patch package." },
    { 1637, "ERROR_PATCH_PACKAGE_UNSUPPORTED", "This patch package cannot be processed by the Windows Installer service.  You must install a Windows service pack that contains a newer version of the Windows Installer service." },
    { 1638, "ERROR_PRODUCT_VERSION", "Another version of this product is already installed.  Installation of this version cannot continue.  To configure or remove the existing version of this product, use Add/Remove Programs on the Control Panel." },
    { 1639, "ERROR_INVALID_COMMAND_LINE", "Invalid command line argument.  Consult the Windows Installer SDK for detailed command line help." },
    { 1640, "ERROR_INSTALL_REMOTE_DISALLOWED", "Only administrators have permission to add, remove, or configure server software during a Terminal services remote session. If you want to install or configure software on the server, contact your network administrator." },
    { 1641, "ERROR_SUCCESS_REBOOT_INITIATED", "The requested operation completed successfully.  The system will be restarted so the changes can take effect." },
    { 1642, "ERROR_PATCH_TARGET_NOT_FOUND", "The upgrade patch cannot be installed by the Windows Installer service because the program to be upgraded may be missing, or the upgrade patch may update a different version of the program. Verify that the program to be upgraded exists on your comput er and that you have the correct upgrade patch." },
    { 1700, "RPC_S_INVALID_STRING_BINDING", "The string binding is invalid." },
    { 1701, "RPC_S_WRONG_KIND_OF_BINDING", "The binding handle is not the correct type." },
    { 1702, "RPC_S_INVALID_BINDING", "The binding handle is invalid." },
    { 1703, "RPC_S_PROTSEQ_NOT_SUPPORTED", "The RPC protocol sequence is not supported." },
    { 1704, "RPC_S_INVALID_RPC_PROTSEQ", "The RPC protocol sequence is invalid." },
    { 1705, "RPC_S_INVALID_STRING_UUID", "The string universal unique identifier (UUID) is invalid." },
    { 1706, "RPC_S_INVALID_ENDPOINT_FORMAT", "The endpoint format is invalid." },
    { 1707, "RPC_S_INVALID_NET_ADDR", "The network address is invalid." },
    { 1708, "RPC_S_NO_ENDPOINT_FOUND", "No endpoint was found." },
    { 1709, "RPC_S_INVALID_TIMEOUT", "The timeout value is invalid." },
    { 1710, "RPC_S_OBJECT_NOT_FOUND", "The object universal unique identifier (UUID) was not found." },
    { 1711, "RPC_S_ALREADY_REGISTERED", "The object universal unique identifier (UUID) has already been registered." },
    { 1712, "RPC_S_TYPE_ALREADY_REGISTERED", "The type universal unique identifier (UUID) has already been registered." },
    { 1713, "RPC_S_ALREADY_LISTENING", "The RPC server is already listening." },
    { 1714, "RPC_S_NO_PROTSEQS_REGISTERED", "No protocol sequences have been registered." },
    { 1715, "RPC_S_NOT_LISTENING", "The RPC server is not listening." },
    { 1716, "RPC_S_UNKNOWN_MGR_TYPE", "The manager type is unknown." },
    { 1717, "RPC_S_UNKNOWN_IF", "The interface is unknown." },
    { 1718, "RPC_S_NO_BINDINGS", "There are no bindings." },
    { 1719, "RPC_S_NO_PROTSEQS", "There are no protocol sequences." },
    { 1720, "RPC_S_CANT_CREATE_ENDPOINT", "The endpoint cannot be created." },
    { 1721, "RPC_S_OUT_OF_RESOURCES", "Not enough resources are available to complete this operation." },
    { 1722, "RPC_S_SERVER_UNAVAILABLE", "The RPC server is unavailable." },
    { 1723, "RPC_S_SERVER_TOO_BUSY", "The RPC server is too busy to complete this operation." },
    { 1724, "RPC_S_INVALID_NETWORK_OPTIONS", "The network options are invalid." },
    { 1725, "RPC_S_NO_CALL_ACTIVE", "There are no remote procedure calls active on this thread." },
    { 1726, "RPC_S_CALL_FAILED", "The remote procedure call failed." },
    { 1727, "RPC_S_CALL_FAILED_DNE", "The remote procedure call failed and did not execute." },
    { 1728, "RPC_S_PROTOCOL_ERROR", "A remote procedure call (RPC) protocol error occurred." },
    { 1730, "RPC_S_UNSUPPORTED_TRANS_SYN", "The transfer syntax is not supported by the RPC server." },
    { 1732, "RPC_S_UNSUPPORTED_TYPE", "The universal unique identifier (UUID) type is not supported." },
    { 1733, "RPC_S_INVALID_TAG", "The tag is invalid." },
    { 1734, "RPC_S_INVALID_BOUND", "The array bounds are invalid." },
    { 1735, "RPC_S_NO_ENTRY_NAME", "The binding does not contain an entry name." },
    { 1736, "RPC_S_INVALID_NAME_SYNTAX", "The name syntax is invalid." },
    { 1737, "RPC_S_UNSUPPORTED_NAME_SYNTAX", "The name syntax is not supported." },
    { 1739, "RPC_S_UUID_NO_ADDRESS", "No network address is available to use to construct a universal unique identifier (UUID)." },
    { 1740, "RPC_S_DUPLICATE_ENDPOINT", "The endpoint is a duplicate." },
    { 1741, "RPC_S_UNKNOWN_AUTHN_TYPE", "The authentication type is unknown." },
    { 1742, "RPC_S_MAX_CALLS_TOO_SMALL", "The maximum number of calls is too small." },
    { 1743, "RPC_S_STRING_TOO_LONG", "The string is too long." },
    { 1744, "RPC_S_PROTSEQ_NOT_FOUND", "The RPC protocol sequence was not found." },
    { 1745, "RPC_S_PROCNUM_OUT_OF_RANGE", "The procedure number is out of range." },
    { 1746, "RPC_S_BINDING_HAS_NO_AUTH", "The binding does not contain any authentication information." },
    { 1747, "RPC_S_UNKNOWN_AUTHN_SERVICE", "The authentication service is unknown." },
    { 1748, "RPC_S_UNKNOWN_AUTHN_LEVEL", "The authentication level is unknown." },
    { 1749, "RPC_S_INVALID_AUTH_IDENTITY", "The security context is invalid." },
    { 1750, "RPC_S_UNKNOWN_AUTHZ_SERVICE", "The authorization service is unknown." },
    { 1751, "EPT_S_INVALID_ENTRY", "The entry is invalid." },
    { 1752, "EPT_S_CANT_PERFORM_OP", "The server endpoint cannot perform the operation." },
    { 1753, "EPT_S_NOT_REGISTERED", "There are no more endpoints available from the endpoint mapper." },
    { 1754, "RPC_S_NOTHING_TO_EXPORT", "No interfaces have been exported." },
    { 1755, "RPC_S_INCOMPLETE_NAME", "The entry name is incomplete." },
    { 1756, "RPC_S_INVALID_VERS_OPTION", "The version option is invalid." },
    { 1757, "RPC_S_NO_MORE_MEMBERS", "There are no more members." },
    { 1758, "RPC_S_NOT_ALL_OBJS_UNEXPORTED", "There is nothing to unexport." },
    { 1759, "RPC_S_INTERFACE_NOT_FOUND", "The interface was not found." },
    { 1760, "RPC_S_ENTRY_ALREADY_EXISTS", "The entry already exists." },
    { 1761, "RPC_S_ENTRY_NOT_FOUND", "The entry is not found." },
    { 1762, "RPC_S_NAME_SERVICE_UNAVAILABLE", "The name service is unavailable." },
    { 1763, "RPC_S_INVALID_NAF_ID", "The network address family is invalid." },
    { 1764, "RPC_S_CANNOT_SUPPORT", "The requested operation is not supported." },
    { 1765, "RPC_S_NO_CONTEXT_AVAILABLE", "No security context is available to allow impersonation." },
    { 1766, "RPC_S_INTERNAL_ERROR", "An internal error occurred in a remote procedure call (RPC)." },
    { 1767, "RPC_S_ZERO_DIVIDE", "The RPC server attempted an integer division by zero." },
    { 1768, "RPC_S_ADDRESS_ERROR", "An addressing error occurred in the RPC server." },
    { 1769, "RPC_S_FP_DIV_ZERO", "A floating-point operation at the RPC server caused a division by zero." },
    { 1770, "RPC_S_FP_UNDERFLOW", "A floating-point underflow occurred at the RPC server." },
    { 1771, "RPC_S_FP_OVERFLOW", "A floating-point overflow occurred at the RPC server." },
    { 1772, "RPC_X_NO_MORE_ENTRIES", "The list of RPC servers available for the binding of auto handles has been exhausted." },
    { 1773, "RPC_X_SS_CHAR_TRANS_OPEN_FAIL", "Unable to open the character translation table file." },
    { 1774, "RPC_X_SS_CHAR_TRANS_SHORT_FILE", "The file containing the character translation table has fewer than 512 bytes." },
    { 1775, "RPC_X_SS_IN_NULL_CONTEXT", "A null context handle was passed from the client to the host during a remote procedure call." },
    { 1777, "RPC_X_SS_CONTEXT_DAMAGED", "The context handle changed during a remote procedure call." },
    { 1778, "RPC_X_SS_HANDLES_MISMATCH", "The binding handles passed to a remote procedure call do not match." },
    { 1779, "RPC_X_SS_CANNOT_GET_CALL_HANDLE", "The stub is unable to get the remote procedure call handle." },
    { 1780, "RPC_X_NULL_REF_POINTER", "A null reference pointer was passed to the stub." },
    { 1781, "RPC_X_ENUM_VALUE_OUT_OF_RANGE", "The enumeration value is out of range." },
    { 1782, "RPC_X_BYTE_COUNT_TOO_SMALL", "The byte count is too small." },
    { 1783, "RPC_X_BAD_STUB_DATA", "The stub received bad data." },
    { 1784, "ERROR_INVALID_USER_BUFFER", "The supplied user buffer is not valid for the requested operation." },
    { 1785, "ERROR_UNRECOGNIZED_MEDIA", "The disk media is not recognized. It may not be formatted." },
    { 1786, "ERROR_NO_TRUST_LSA_SECRET", "The workstation does not have a trust secret." },
    { 1787, "ERROR_NO_TRUST_SAM_ACCOUNT", "The security database on the server does not have a computer account for this workstation trust relationship." },
    { 1788, "ERROR_TRUSTED_DOMAIN_FAILURE", "The trust relationship between the primary domain and the trusted domain failed." },
    { 1789, "ERROR_TRUSTED_RELATIONSHIP_FAILURE", "The trust relationship between this workstation and the primary domain failed." },
    { 1790, "ERROR_TRUST_FAILURE", "The network logon failed." },
    { 1791, "RPC_S_CALL_IN_PROGRESS", "A remote procedure call is already in progress for this thread." },
    { 1792, "ERROR_NETLOGON_NOT_STARTED", "An attempt was made to logon, but the network logon service was not started." },
    { 1793, "ERROR_ACCOUNT_EXPIRED", "The user's account has expired." },
    { 1794, "ERROR_REDIRECTOR_HAS_OPEN_HANDLES", "The redirector is in use and cannot be unloaded." },
    { 1795, "ERROR_PRINTER_DRIVER_ALREADY_INSTALLED", "The specified printer driver is already installed." },
    { 1796, "ERROR_UNKNOWN_PORT", "The specified port is unknown." },
    { 1797, "ERROR_UNKNOWN_PRINTER_DRIVER", "The printer driver is unknown." },
    { 1798, "ERROR_UNKNOWN_PRINTPROCESSOR", "The print processor is unknown." },
    { 1799, "ERROR_INVALID_SEPARATOR_FILE", "The specified separator file is invalid." },
    { 1800, "ERROR_INVALID_PRIORITY", "The specified priority is invalid." },
    { 1801, "ERROR_INVALID_PRINTER_NAME", "The printer name is invalid." },
    { 1802, "ERROR_PRINTER_ALREADY_EXISTS", "The printer already exists." },
    { 1803, "ERROR_INVALID_PRINTER_COMMAND", "The printer command is invalid." },
    { 1804, "ERROR_INVALID_DATATYPE", "The specified datatype is invalid." },
    { 1805, "ERROR_INVALID_ENVIRONMENT", "The environment specified is invalid." },
    { 1806, "RPC_S_NO_MORE_BINDINGS", "There are no more bindings." },
    { 1807, "ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT", "The account used is an interdomain trust account. Use your global user account or local user account to access this server." },
    { 1808, "ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT", "The account used is a computer account. Use your global user account or local user account to access this server." },
    { 1809, "ERROR_NOLOGON_SERVER_TRUST_ACCOUNT", "The account used is a server trust account. Use your global user account or local user account to access this server." },
    { 1810, "ERROR_DOMAIN_TRUST_INCONSISTENT", "The name or security ID (SID) of the domain specified is inconsistent with the trust information for that domain." },
    { 1811, "ERROR_SERVER_HAS_OPEN_HANDLES", "The server is in use and cannot be unloaded." },
    { 1812, "ERROR_RESOURCE_DATA_NOT_FOUND", "The specified image file did not contain a resource section." },
    { 1813, "ERROR_RESOURCE_TYPE_NOT_FOUND", "The specified resource type cannot be found in the image file." },
    { 1814, "ERROR_RESOURCE_NAME_NOT_FOUND", "The specified resource name cannot be found in the image file." },
    { 1815, "ERROR_RESOURCE_LANG_NOT_FOUND", "The specified resource language ID cannot be found in the image file." },
    { 1816, "ERROR_NOT_ENOUGH_QUOTA", "Not enough quota is available to process this command." },
    { 1817, "RPC_S_NO_INTERFACES", "No interfaces have been registered." },
    { 1818, "RPC_S_CALL_CANCELLED", "The remote procedure call was cancelled." },
    { 1819, "RPC_S_BINDING_INCOMPLETE", "The binding handle does not contain all required information." },
    { 1820, "RPC_S_COMM_FAILURE", "A communications failure occurred during a remote procedure call." },
    { 1821, "RPC_S_UNSUPPORTED_AUTHN_LEVEL", "The requested authentication level is not supported." },
    { 1822, "RPC_S_NO_PRINC_NAME", "No principal name registered." },
    { 1823, "RPC_S_NOT_RPC_ERROR", "The error specified is not a valid Windows RPC error code." },
    { 1824, "RPC_S_UUID_LOCAL_ONLY", "A UUID that is valid only on this computer has been allocated." },
    { 1825, "RPC_S_SEC_PKG_ERROR", "A security package specific error occurred." },
    { 1826, "RPC_S_NOT_CANCELLED", "Thread is not canceled." },
    { 1827, "RPC_X_INVALID_ES_ACTION", "Invalid operation on the encoding/decoding handle." },
    { 1828, "RPC_X_WRONG_ES_VERSION", "Incompatible version of the serializing package." },
    { 1829, "RPC_X_WRONG_STUB_VERSION", "Incompatible version of the RPC stub." },
    { 1830, "RPC_X_INVALID_PIPE_OBJECT", "The RPC pipe object is invalid or corrupted." },
    { 1831, "RPC_X_WRONG_PIPE_ORDER", "An invalid operation was attempted on an RPC pipe object." },
    { 1832, "RPC_X_WRONG_PIPE_VERSION", "Unsupported RPC pipe version." },
    { 1898, "RPC_S_GROUP_MEMBER_NOT_FOUND", "The group member was not found." },
    { 1899, "EPT_S_CANT_CREATE", "The endpoint mapper database entry could not be created." },
    { 1900, "RPC_S_INVALID_OBJECT", "The object universal unique identifier (UUID) is the nil UUID." },
    { 1901, "ERROR_INVALID_TIME", "The specified time is invalid." },
    { 1902, "ERROR_INVALID_FORM_NAME", "The specified form name is invalid." },
    { 1903, "ERROR_INVALID_FORM_SIZE", "The specified form size is invalid." },
    { 1904, "ERROR_ALREADY_WAITING", "The specified printer handle is already being waited on" },
    { 1905, "ERROR_PRINTER_DELETED", "The specified printer has been deleted." },
    { 1906, "ERROR_INVALID_PRINTER_STATE", "The state of the printer is invalid." },
    { 1907, "ERROR_PASSWORD_MUST_CHANGE", "The user's password must be changed before logging on the first time." },
    { 1908, "ERROR_DOMAIN_CONTROLLER_NOT_FOUND", "Could not find the domain controller for this domain." },
    { 1909, "ERROR_ACCOUNT_LOCKED_OUT", "The referenced account is currently locked out and may not be logged on to." },
    { 1910, "OR_INVALID_OXID", "The object exporter specified was not found." },
    { 1911, "OR_INVALID_OID", "The object specified was not found." },
    { 1912, "OR_INVALID_SET", "The object resolver set specified was not found." },
    { 1913, "RPC_S_SEND_INCOMPLETE", "Some data remains to be sent in the request buffer." },
    { 1914, "RPC_S_INVALID_ASYNC_HANDLE", "Invalid asynchronous remote procedure call handle." },
    { 1915, "RPC_S_INVALID_ASYNC_CALL", "Invalid asynchronous RPC call handle for this operation." },
    { 1916, "RPC_X_PIPE_CLOSED", "The RPC pipe object has already been closed." },
    { 1917, "RPC_X_PIPE_DISCIPLINE_ERROR", "The RPC call completed before all pipes were processed." },
    { 1918, "RPC_X_PIPE_EMPTY", "No more data is available from the RPC pipe." },
    { 1919, "ERROR_NO_SITENAME", "No site name is available for this machine." },
    { 1920, "ERROR_CANT_ACCESS_FILE", "The file can not be accessed by the system." },
    { 1921, "ERROR_CANT_RESOLVE_FILENAME", "The name of the file cannot be resolved by the system." },
    { 1922, "RPC_S_ENTRY_TYPE_MISMATCH", "The entry is not of the expected type." },
    { 1923, "RPC_S_NOT_ALL_OBJS_EXPORTED", "Not all object UUIDs could be exported to the specified entry." },
    { 1924, "RPC_S_INTERFACE_NOT_EXPORTED", "Interface could not be exported to the specified entry." },
    { 1925, "RPC_S_PROFILE_NOT_ADDED", "The specified profile entry could not be added." },
    { 1926, "RPC_S_PRF_ELT_NOT_ADDED", "The specified profile element could not be added." },
    { 1927, "RPC_S_PRF_ELT_NOT_REMOVED", "The specified profile element could not be removed." },
    { 1928, "RPC_S_GRP_ELT_NOT_ADDED", "The group element could not be added." },
    { 1929, "RPC_S_GRP_ELT_NOT_REMOVED", "The group element could not be removed." },
    { 2000, "ERROR_INVALID_PIXEL_FORMAT", "The pixel format is invalid." },
    { 2001, "ERROR_BAD_DRIVER", "The specified driver is invalid." },
    { 2002, "ERROR_INVALID_WINDOW_STYLE", "The window style or class attribute is invalid for this operation." },
    { 2003, "ERROR_METAFILE_NOT_SUPPORTED", "The requested metafile operation is not supported." },
    { 2004, "ERROR_TRANSFORM_NOT_SUPPORTED", "The requested transformation operation is not supported." },
    { 2005, "ERROR_CLIPPING_NOT_SUPPORTED", "The requested clipping operation is not supported." },
    { 2010, "ERROR_INVALID_CMM", "The specified color management module is invalid." },
    { 2011, "ERROR_INVALID_PROFILE", "The specified color profile is invalid." },
    { 2012, "ERROR_TAG_NOT_FOUND", "The specified tag was not found." },
    { 2013, "ERROR_TAG_NOT_PRESENT", "A required tag is not present." },
    { 2014, "ERROR_DUPLICATE_TAG", "The specified tag is already present." },
    { 2015, "ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE", "The specified color profile is not associated with any device." },
    { 2016, "ERROR_PROFILE_NOT_FOUND", "The specified color profile was not found." },
    { 2017, "ERROR_INVALID_COLORSPACE", "The specified color space is invalid." },
    { 2018, "ERROR_ICM_NOT_ENABLED", "Image Color Management is not enabled." },
    { 2019, "ERROR_DELETING_ICM_XFORM", "There was an error while deleting the color transform." },
    { 2020, "ERROR_INVALID_TRANSFORM", "The specified color transform is invalid." },
    { 2021, "ERROR_COLORSPACE_MISMATCH", "The specified transform does not match the bitmap's color space." },
    { 2022, "ERROR_INVALID_COLORINDEX", "The specified named color index is not present in the profile." },
    { 2108, "ERROR_CONNECTED_OTHER_PASSWORD", "The network connection was made successfully, but the user had to be prompted for a password other than the one originally specified." },
    { 2202, "ERROR_BAD_USERNAME", "The specified username is invalid." },
    { 2250, "ERROR_NOT_CONNECTED", "This network connection does not exist." },
    { 2401, "ERROR_OPEN_FILES", "This network connection has files open or requests pending." },
    { 2402, "ERROR_ACTIVE_CONNECTIONS", "Active connections still exist." },
    { 2404, "ERROR_DEVICE_IN_USE", "The device is in use by an active process and cannot be disconnected." },
    { 3000, "ERROR_UNKNOWN_PRINT_MONITOR", "The specified print monitor is unknown." },
    { 3001, "ERROR_PRINTER_DRIVER_IN_USE", "The specified printer driver is currently in use." },
    { 3002, "ERROR_SPOOL_FILE_NOT_FOUND", "The spool file was not found." },
    { 3003, "ERROR_SPL_NO_STARTDOC", "A StartDocPrinter call was not issued." },
    { 3004, "ERROR_SPL_NO_ADDJOB", "An AddJob call was not issued." },
    { 3005, "ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED", "The specified print processor has already been installed." },
    { 3006, "ERROR_PRINT_MONITOR_ALREADY_INSTALLED", "The specified print monitor has already been installed." },
    { 3007, "ERROR_INVALID_PRINT_MONITOR", "The specified print monitor does not have the required functions." },
    { 3008, "ERROR_PRINT_MONITOR_IN_USE", "The specified print monitor is currently in use." },
    { 3009, "ERROR_PRINTER_HAS_JOBS_QUEUED", "The requested operation is not allowed when there are jobs queued to the printer." },
    { 3010, "ERROR_SUCCESS_REBOOT_REQUIRED", "The requested operation is successful. Changes will not be effective until the system is rebooted." },
    { 3011, "ERROR_SUCCESS_RESTART_REQUIRED", "The requested operation is successful. Changes will not be effective until the service is restarted." },
    { 3012, "ERROR_PRINTER_NOT_FOUND", "No printers were found." },
    { 4000, "ERROR_WINS_INTERNAL", "WINS encountered an error while processing the command." },
    { 4001, "ERROR_CAN_NOT_DEL_LOCAL_WINS", "The local WINS can not be deleted." },
    { 4002, "ERROR_STATIC_INIT", "The importation from the file failed." },
    { 4003, "ERROR_INC_BACKUP", "The backup failed. Was a full backup done before?" },
    { 4004, "ERROR_FULL_BACKUP", "The backup failed. Check the directory to which you are backing the database." },
    { 4005, "ERROR_REC_NON_EXISTENT", "The name does not exist in the WINS database." },
    { 4006, "ERROR_RPL_NOT_ALLOWED", "Replication with a nonconfigured partner is not allowed." },
    { 4100, "ERROR_DHCP_ADDRESS_CONFLICT", "The DHCP client has obtained an IP address that is already in use on the network. The local interface will be disabled until the DHCP client can obtain a new address." },
    { 4200, "ERROR_WMI_GUID_NOT_FOUND", "The GUID passed was not recognized as valid by a WMI data provider." },
    { 4201, "ERROR_WMI_INSTANCE_NOT_FOUND", "The instance name passed was not recognized as valid by a WMI data provider." },
    { 4202, "ERROR_WMI_ITEMID_NOT_FOUND", "The data item ID passed was not recognized as valid by a WMI data provider." },
    { 4203, "ERROR_WMI_TRY_AGAIN", "The WMI request could not be completed and should be retried." },
    { 4204, "ERROR_WMI_DP_NOT_FOUND", "The WMI data provider could not be located." },
    { 4205, "ERROR_WMI_UNRESOLVED_INSTANCE_REF", "The WMI data provider references an instance set that has not been registered." },
    { 4206, "ERROR_WMI_ALREADY_ENABLED", "The WMI data block or event notification has already been enabled." },
    { 4207, "ERROR_WMI_GUID_DISCONNECTED", "The WMI data block is no longer available." },
    { 4208, "ERROR_WMI_SERVER_UNAVAILABLE", "The WMI data service is not available." },
    { 4209, "ERROR_WMI_DP_FAILED", "The WMI data provider failed to carry out the request." },
    { 4210, "ERROR_WMI_INVALID_MOF", "The WMI MOF information is not valid." },
    { 4211, "ERROR_WMI_INVALID_REGINFO", "The WMI registration information is not valid." },
    { 4212, "ERROR_WMI_ALREADY_DISABLED", "The WMI data block or event notification has already been disabled." },
    { 4213, "ERROR_WMI_READ_ONLY", "The WMI data item or data block is read only." },
    { 4214, "ERROR_WMI_SET_FAILURE", "The WMI data item or data block could not be changed." },
    { 4300, "ERROR_INVALID_MEDIA", "The media identifier does not represent a valid medium." },
    { 4301, "ERROR_INVALID_LIBRARY", "The library identifier does not represent a valid library." },
    { 4302, "ERROR_INVALID_MEDIA_POOL", "The media pool identifier does not represent a valid media pool." },
    { 4303, "ERROR_DRIVE_MEDIA_MISMATCH", "The drive and medium are not compatible or exist in different libraries." },
    { 4304, "ERROR_MEDIA_OFFLINE", "The medium currently exists in an offline library and must be online to perform this operation." },
    { 4305, "ERROR_LIBRARY_OFFLINE", "The operation cannot be performed on an offline library." },
    { 4306, "ERROR_EMPTY", "The library, drive, or media pool is empty." },
    { 4307, "ERROR_NOT_EMPTY", "The library, drive, or media pool must be empty to perform this operation." },
    { 4308, "ERROR_MEDIA_UNAVAILABLE", "No media is currently available in this media pool or library." },
    { 4309, "ERROR_RESOURCE_DISABLED", "A resource required for this operation is disabled." },
    { 4310, "ERROR_INVALID_CLEANER", "The media identifier does not represent a valid cleaner." },
    { 4311, "ERROR_UNABLE_TO_CLEAN", "The drive cannot be cleaned or does not support cleaning." },
    { 4312, "ERROR_OBJECT_NOT_FOUND", "The object identifier does not represent a valid object." },
    { 4313, "ERROR_DATABASE_FAILURE", "Unable to read from or write to the database." },
    { 4314, "ERROR_DATABASE_FULL", "The database is full." },
    { 4315, "ERROR_MEDIA_INCOMPATIBLE", "The medium is not compatible with the device or media pool." },
    { 4316, "ERROR_RESOURCE_NOT_PRESENT", "The resource required for this operation does not exist." },
    { 4317, "ERROR_INVALID_OPERATION", "The operation identifier is not valid." },
    { 4318, "ERROR_MEDIA_NOT_AVAILABLE", "The media is not mounted or ready for use." },
    { 4319, "ERROR_DEVICE_NOT_AVAILABLE", "The device is not ready for use." },
    { 4320, "ERROR_REQUEST_REFUSED", "The operator or administrator has refused the request." },
    { 4321, "ERROR_INVALID_DRIVE_OBJECT", "The drive identifier does not represent a valid drive." },
    { 4322, "ERROR_LIBRARY_FULL", "Library is full.  No slot is available for use." },
    { 4323, "ERROR_MEDIUM_NOT_ACCESSIBLE", "The transport cannot access the medium." },
    { 4324, "ERROR_UNABLE_TO_LOAD_MEDIUM", "Unable to load the medium into the drive." },
    { 4325, "ERROR_UNABLE_TO_INVENTORY_DRIVE", "Unable to retrieve the drive status." },
    { 4326, "ERROR_UNABLE_TO_INVENTORY_SLOT", "Unable to retrieve the slot status." },
    { 4327, "ERROR_UNABLE_TO_INVENTORY_TRANSPORT", "Unable to retrieve status about the transport." },
    { 4328, "ERROR_TRANSPORT_FULL", "Cannot use the transport because it is already in use." },
    { 4329, "ERROR_CONTROLLING_IEPORT", "Unable to open or close the inject/eject port." },
    { 4330, "ERROR_UNABLE_TO_EJECT_MOUNTED_MEDIA", "Unable to eject the medium because it is in a drive." },
    { 4331, "ERROR_CLEANER_SLOT_SET", "A cleaner slot is already reserved." },
    { 4332, "ERROR_CLEANER_SLOT_NOT_SET", "A cleaner slot is not reserved." },
    { 4333, "ERROR_CLEANER_CARTRIDGE_SPENT", "The cleaner cartridge has performed the maximum number of drive cleanings." },
    { 4334, "ERROR_UNEXPECTED_OMID", "Unexpected on-medium identifier." },
    { 4335, "ERROR_CANT_DELETE_LAST_ITEM", "The last remaining item in this group or resource cannot be deleted." },
    { 4336, "ERROR_MESSAGE_EXCEEDS_MAX_SIZE", "The message provided exceeds the maximum size allowed for this parameter." },
    { 4337, "ERROR_VOLUME_CONTAINS_SYS_FILES", "The volume contains system or paging files." },
    { 4338, "ERROR_INDIGENOUS_TYPE", "The media type cannot be removed from this library since at least one drive in the library reports it can support this media type." },
    { 4339, "ERROR_NO_SUPPORTING_DRIVES", "This offline media cannot be mounted on this system since no enabled drives are present which can be used." },
    { 4350, "ERROR_FILE_OFFLINE", "The remote storage service was not able to recall the file." },
    { 4351, "ERROR_REMOTE_STORAGE_NOT_ACTIVE", "The remote storage service is not operational at this time." },
    { 4352, "ERROR_REMOTE_STORAGE_MEDIA_ERROR", "The remote storage service encountered a media error." },
    { 4390, "ERROR_NOT_A_REPARSE_POINT", "The file or directory is not a reparse point." },
    { 4391, "ERROR_REPARSE_ATTRIBUTE_CONFLICT", "The reparse point attribute cannot be set because it conflicts with an existing attribute." },
    { 4392, "ERROR_INVALID_REPARSE_DATA", "The data present in the reparse point buffer is invalid." },
    { 4393, "ERROR_REPARSE_TAG_INVALID", "The tag present in the reparse point buffer is invalid." },
    { 4394, "ERROR_REPARSE_TAG_MISMATCH", "There is a mismatch between the tag specified in the request and the tag present in the reparse point. " },
    { 4500, "ERROR_VOLUME_NOT_SIS_ENABLED", "Single Instance Storage is not available on this volume." },
    { 5001, "ERROR_DEPENDENT_RESOURCE_EXISTS", "The cluster resource cannot be moved to another group because other resources are dependent on it." },
    { 5002, "ERROR_DEPENDENCY_NOT_FOUND", "The cluster resource dependency cannot be found." },
    { 5003, "ERROR_DEPENDENCY_ALREADY_EXISTS", "The cluster resource cannot be made dependent on the specified resource because it is already dependent." },
    { 5004, "ERROR_RESOURCE_NOT_ONLINE", "The cluster resource is not online." },
    { 5005, "ERROR_HOST_NODE_NOT_AVAILABLE", "A cluster node is not available for this operation." },
    { 5006, "ERROR_RESOURCE_NOT_AVAILABLE", "The cluster resource is not available." },
    { 5007, "ERROR_RESOURCE_NOT_FOUND", "The cluster resource could not be found." },
    { 5008, "ERROR_SHUTDOWN_CLUSTER", "The cluster is being shut down." },
    { 5009, "ERROR_CANT_EVICT_ACTIVE_NODE", "A cluster node cannot be evicted from the cluster while it is online." },
    { 5010, "ERROR_OBJECT_ALREADY_EXISTS", "The object already exists." },
    { 5011, "ERROR_OBJECT_IN_LIST", "The object is already in the list." },
    { 5012, "ERROR_GROUP_NOT_AVAILABLE", "The cluster group is not available for any new requests." },
    { 5013, "ERROR_GROUP_NOT_FOUND", "The cluster group could not be found." },
    { 5014, "ERROR_GROUP_NOT_ONLINE", "The operation could not be completed because the cluster group is not online." },
    { 5015, "ERROR_HOST_NODE_NOT_RESOURCE_OWNER", "The cluster node is not the owner of the resource." },
    { 5016, "ERROR_HOST_NODE_NOT_GROUP_OWNER", "The cluster node is not the owner of the group." },
    { 5017, "ERROR_RESMON_CREATE_FAILED", "The cluster resource could not be created in the specified resource monitor." },
    { 5018, "ERROR_RESMON_ONLINE_FAILED", "The cluster resource could not be brought online by the resource monitor." },
    { 5019, "ERROR_RESOURCE_ONLINE", "The operation could not be completed because the cluster resource is online." },
    { 5020, "ERROR_QUORUM_RESOURCE", "The cluster resource could not be deleted or brought offline because it is the quorum resource." },
    { 5021, "ERROR_NOT_QUORUM_CAPABLE", "The cluster could not make the specified resource a quorum resource because it is not capable of being a quorum resource." },
    { 5022, "ERROR_CLUSTER_SHUTTING_DOWN", "The cluster software is shutting down." },
    { 5023, "ERROR_INVALID_STATE", "The group or resource is not in the correct state to perform the requested operation." },
    { 5024, "ERROR_RESOURCE_PROPERTIES_STORED", "The properties were stored but not all changes will take effect until the next time the resource is brought online." },
    { 5025, "ERROR_NOT_QUORUM_CLASS", "The cluster could not make the specified resource a quorum resource because it does not belong to a shared storage class." },
    { 5026, "ERROR_CORE_RESOURCE", "The cluster resource could not be deleted since it is a core resource." },
    { 5027, "ERROR_QUORUM_RESOURCE_ONLINE_FAILED", "The quorum resource failed to come online." },
    { 5028, "ERROR_QUORUMLOG_OPEN_FAILED", "The quorum log could not be created or mounted successfully." },
    { 5029, "ERROR_CLUSTERLOG_CORRUPT", "The cluster log is corrupt." },
    { 5030, "ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE", "The record could not be written to the cluster log since it exceeds the maximum size." },
    { 5031, "ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE", "The cluster log exceeds its maximum size." },
    { 5032, "ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND", "No checkpoint record was found in the cluster log." },
    { 5033, "ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE", "The minimum required disk space needed for logging is not available." },
    { 5034, "ERROR_QUORUM_OWNER_ALIVE", "The cluster node failed to take control of the quorum resource because the resource is owned by another active node." },
    { 5035, "ERROR_NETWORK_NOT_AVAILABLE", "A cluster network is not available for this operation." },
    { 5036, "ERROR_NODE_NOT_AVAILABLE", "A cluster node is not available for this operation." },
    { 5037, "ERROR_ALL_NODES_NOT_AVAILABLE", "All cluster nodes must be running to perform this operation." },
    { 5038, "ERROR_RESOURCE_FAILED", "A cluster resource failed." },
    { 5039, "ERROR_CLUSTER_INVALID_NODE", "The cluster node is not valid." },
    { 5040, "ERROR_CLUSTER_NODE_EXISTS", "The cluster node already exists." },
    { 5041, "ERROR_CLUSTER_JOIN_IN_PROGRESS", "A node is in the process of joining the cluster." },
    { 5042, "ERROR_CLUSTER_NODE_NOT_FOUND", "The cluster node was not found." },
    { 5043, "ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND", "The cluster local node information was not found." },
    { 5044, "ERROR_CLUSTER_NETWORK_EXISTS", "The cluster network already exists." },
    { 5045, "ERROR_CLUSTER_NETWORK_NOT_FOUND", "The cluster network was not found." },
    { 5046, "ERROR_CLUSTER_NETINTERFACE_EXISTS", "The cluster network interface already exists." },
    { 5047, "ERROR_CLUSTER_NETINTERFACE_NOT_FOUND", "The cluster network interface was not found." },
    { 5048, "ERROR_CLUSTER_INVALID_REQUEST", "The cluster request is not valid for this object." },
    { 5049, "ERROR_CLUSTER_INVALID_NETWORK_PROVIDER", "The cluster network provider is not valid." },
    { 5050, "ERROR_CLUSTER_NODE_DOWN", "The cluster node is down." },
    { 5051, "ERROR_CLUSTER_NODE_UNREACHABLE", "The cluster node is not reachable." },
    { 5052, "ERROR_CLUSTER_NODE_NOT_MEMBER", "The cluster node is not a member of the cluster." },
    { 5053, "ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS", "A cluster join operation is not in progress." },
    { 5054, "ERROR_CLUSTER_INVALID_NETWORK", "The cluster network is not valid." },
    { 5056, "ERROR_CLUSTER_NODE_UP", "The cluster node is up." },
    { 5057, "ERROR_CLUSTER_IPADDR_IN_USE", "The cluster IP address is already in use." },
    { 5058, "ERROR_CLUSTER_NODE_NOT_PAUSED", "The cluster node is not paused." },
    { 5059, "ERROR_CLUSTER_NO_SECURITY_CONTEXT", "No cluster security context is available." },
    { 5060, "ERROR_CLUSTER_NETWORK_NOT_INTERNAL", "The cluster network is not configured for internal cluster communication." },
    { 5061, "ERROR_CLUSTER_NODE_ALREADY_UP", "The cluster node is already up." },
    { 5062, "ERROR_CLUSTER_NODE_ALREADY_DOWN", "The cluster node is already down." },
    { 5063, "ERROR_CLUSTER_NETWORK_ALREADY_ONLINE", "The cluster network is already online." },
    { 5064, "ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE", "The cluster network is already offline." },
    { 5065, "ERROR_CLUSTER_NODE_ALREADY_MEMBER", "The cluster node is already a member of the cluster." },
    { 5066, "ERROR_CLUSTER_LAST_INTERNAL_NETWORK", "The cluster network is the only one configured for internal cluster communication between two or more active cluster nodes. The internal communication capability cannot be removed from the network." },
    { 5067, "ERROR_CLUSTER_NETWORK_HAS_DEPENDENTS", "One or more cluster resources depend on the network to provide service to clients. The client access capability cannot be removed from the network." },
    { 5068, "ERROR_INVALID_OPERATION_ON_QUORUM", "This operation cannot be performed on the cluster resource as it the quorum resource. You may not bring the quorum resource offline or modify its possible owners list." },
    { 5069, "ERROR_DEPENDENCY_NOT_ALLOWED", "The cluster quorum resource is not allowed to have any dependencies." },
    { 5070, "ERROR_CLUSTER_NODE_PAUSED", "The cluster node is paused." },
    { 5071, "ERROR_NODE_CANT_HOST_RESOURCE", "The cluster resource cannot be brought online. The owner node cannot run this resource." },
    { 5072, "ERROR_CLUSTER_NODE_NOT_READY", "The cluster node is not ready to perform the requested operation." },
    { 5073, "ERROR_CLUSTER_NODE_SHUTTING_DOWN", "The cluster node is shutting down." },
    { 5074, "ERROR_CLUSTER_JOIN_ABORTED", "The cluster join operation was aborted." },
    { 5075, "ERROR_CLUSTER_INCOMPATIBLE_VERSIONS", "The cluster join operation failed due to incompatible software versions between the joining node and its sponsor." },
    { 5076, "ERROR_CLUSTER_MAXNUM_OF_RESOURCES_EXCEEDED", "This resource cannot be created because the cluster has reached the limit on the number of resources it can monitor." },
    { 5077, "ERROR_CLUSTER_SYSTEM_CONFIG_CHANGED", "The system configuration changed during the cluster join or form operation. The join or form operation was aborted." },
    { 5078, "ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND", "The specified resource type was not found." },
    { 5079, "ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED", "The specified node does not support a resource of this type.  This may be due to version inconsistencies or due to the absence of the resource DLL on this node." },
    { 5080, "ERROR_CLUSTER_RESNAME_NOT_FOUND", "The specified resource name is not supported by this resource DLL. This may be due to a bad (or changed) name supplied to the resource DLL." },
    { 5081, "ERROR_CLUSTER_NO_RPC_PACKAGES_REGISTERED", "No authentication package could be registered with the RPC server." },
    { 5082, "ERROR_CLUSTER_OWNER_NOT_IN_PREFLIST", "You cannot bring the group online because the owner of the group is not in the preferred list for the group. To change the owner node for the group, move the group." },
    { 5083, "ERROR_CLUSTER_DATABASE_SEQMISMATCH", "The join operation failed because the cluster database sequence number has changed or is incompatible with the locker node. This may happen during a join operation if the cluster database was changing during the join." },
    { 5084, "ERROR_RESMON_INVALID_STATE", "The resource monitor will not allow the fail operation to be performed while the resource is in its current state. This may happen if the resource is in a pending state." },
    { 5085, "ERROR_CLUSTER_GUM_NOT_LOCKER", "A non locker code got a request to reserve the lock for making global updates." },
    { 5086, "ERROR_QUORUM_DISK_NOT_FOUND", "The quorum disk could not be located by the cluster service." },
    { 5087, "ERROR_DATABASE_BACKUP_CORRUPT", "The backed up cluster database is possibly corrupt." },
    { 5088, "ERROR_CLUSTER_NODE_ALREADY_HAS_DFS_ROOT", "A DFS root already exists in this cluster node." },
    { 5089, "ERROR_RESOURCE_PROPERTY_UNCHANGEABLE", "An attempt to modify a resource property failed because it conflicts with another existing property." },
    { 6000, "ERROR_ENCRYPTION_FAILED", "The specified file could not be encrypted." },
    { 6001, "ERROR_DECRYPTION_FAILED", "The specified file could not be decrypted." },
    { 6002, "ERROR_FILE_ENCRYPTED", "The specified file is encrypted and the user does not have the ability to decrypt it." },
    { 6003, "ERROR_NO_RECOVERY_POLICY", "There is no valid encryption recovery policy configured for this system." },
    { 6004, "ERROR_NO_EFS", "The required encryption driver is not loaded for this system." },
    { 6005, "ERROR_WRONG_EFS", "The file was encrypted with a different encryption driver than is currently loaded." },
    { 6006, "ERROR_NO_USER_KEYS", "There are no EFS keys defined for the user." },
    { 6007, "ERROR_FILE_NOT_ENCRYPTED", "The specified file is not encrypted." },
    { 6008, "ERROR_NOT_EXPORT_FORMAT", "The specified file is not in the defined EFS export format." },
    { 6009, "ERROR_FILE_READ_ONLY", "The specified file is read only." },
    { 6010, "ERROR_DIR_EFS_DISALLOWED", "The directory has been disabled for encryption." },
    { 6011, "ERROR_EFS_SERVER_NOT_TRUSTED", "The server is not trusted for remote encryption operation." },
    { 6118, "ERROR_NO_BROWSER_SERVERS_FOUND", "The list of servers for this workgroup is not currently available" },
    { 6200, "SCHED_E_SERVICE_NOT_LOCALSYSTEM", "The Task Scheduler service must be configured to run in the System account to function properly.  Individual tasks may be configured to run in other accounts." },
    { 7001, "ERROR_CTX_WINSTATION_NAME_INVALID", "The specified session name is invalid." },
    { 7002, "ERROR_CTX_INVALID_PD", "The specified protocol driver is invalid." },
    { 7003, "ERROR_CTX_PD_NOT_FOUND", "The specified protocol driver was not found in the system path." },
    { 7004, "ERROR_CTX_WD_NOT_FOUND", "The specified terminal connection driver was not found in the system path." },
    { 7005, "ERROR_CTX_CANNOT_MAKE_EVENTLOG_ENTRY", "A registry key for event logging could not be created for this session." },
    { 7006, "ERROR_CTX_SERVICE_NAME_COLLISION", "A service with the same name already exists on the system." },
    { 7007, "ERROR_CTX_CLOSE_PENDING", "A close operation is pending on the session." },
    { 7008, "ERROR_CTX_NO_OUTBUF", "There are no free output buffers available." },
    { 7009, "ERROR_CTX_MODEM_INF_NOT_FOUND", "The MODEM.INF file was not found." },
    { 7010, "ERROR_CTX_INVALID_MODEMNAME", "The modem name was not found in MODEM.INF." },
    { 7011, "ERROR_CTX_MODEM_RESPONSE_ERROR", "The modem did not accept the command sent to it. Verify that the configured modem name matches the attached modem." },
    { 7012, "ERROR_CTX_MODEM_RESPONSE_TIMEOUT", "The modem did not respond to the command sent to it. Verify that the modem is properly cabled and powered on." },
    { 7013, "ERROR_CTX_MODEM_RESPONSE_NO_CARRIER", "Carrier detect has failed or carrier has been dropped due to disconnect." },
    { 7014, "ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE", "Dial tone not detected within the required time. Verify that the phone cable is properly attached and functional." },
    { 7015, "ERROR_CTX_MODEM_RESPONSE_BUSY", "Busy signal detected at remote site on callback." },
    { 7016, "ERROR_CTX_MODEM_RESPONSE_VOICE", "Voice detected at remote site on callback." },
    { 7017, "ERROR_CTX_TD_ERROR", "Transport driver error" },
    { 7022, "ERROR_CTX_WINSTATION_NOT_FOUND", "The specified session cannot be found." },
    { 7023, "ERROR_CTX_WINSTATION_ALREADY_EXISTS", "The specified session name is already in use." },
    { 7024, "ERROR_CTX_WINSTATION_BUSY", "The requested operation cannot be completed because the terminal connection is currently busy processing a connect, disconnect, reset, or delete operation." },
    { 7025, "ERROR_CTX_BAD_VIDEO_MODE", "An attempt has been made to connect to a session whose video mode is not supported by the current client." },
    { 7035, "ERROR_CTX_GRAPHICS_INVALID", "The application attempted to enable DOS graphics mode. DOS graphics mode is not supported." },
    { 7037, "ERROR_CTX_LOGON_DISABLED", "Your interactive logon privilege has been disabled. Please contact your administrator." },
    { 7038, "ERROR_CTX_NOT_CONSOLE", "The requested operation can be performed only on the system console. This is most often the result of a driver or system DLL requiring direct console access." },
    { 7040, "ERROR_CTX_CLIENT_QUERY_TIMEOUT", "The client failed to respond to the server connect message." },
    { 7041, "ERROR_CTX_CONSOLE_DISCONNECT", "Disconnecting the console session is not supported." },
    { 7042, "ERROR_CTX_CONSOLE_CONNECT", "Reconnecting a disconnected session to the console is not supported." },
    { 7044, "ERROR_CTX_SHADOW_DENIED", "The request to control another session remotely was denied." },
    { 7045, "ERROR_CTX_WINSTATION_ACCESS_DENIED", "The requested session access is denied." },
    { 7049, "ERROR_CTX_INVALID_WD", "The specified terminal connection driver is invalid." },
    { 7050, "ERROR_CTX_SHADOW_INVALID", "The requested session cannot be controlled remotely. This may be because the session is disconnected or does not currently have a user logged on. Also, you cannot control a session remotely from the system console or control the system console remotely. And you cannot remote control your own current se ssion." },
    { 7051, "ERROR_CTX_SHADOW_DISABLED", "The requested session is not configured to allow remote control." },
    { 7052, "ERROR_CTX_CLIENT_LICENSE_IN_USE", "Your request to connect to this Terminal Server has been rejected. Your Terminal Server client license number is currently being used by another user. Please call your system administrator to obtain a new copy of the Terminal Server client with a valid, unique license number." },
    { 7053, "ERROR_CTX_CLIENT_LICENSE_NOT_SET", "Your request to connect to this Terminal Server has been rejected. Your Terminal Server client license number has not been entered for this copy of the Terminal Server client. Please call your system administrator for help in entering a valid, unique license number for this Terminal Server client." },
    { 7054, "ERROR_CTX_LICENSE_NOT_AVAILABLE", "The system has reached its licensed logon limit. Please try again later." },
    { 7055, "ERROR_CTX_LICENSE_CLIENT_INVALID", "The client you are using is not licensed to use this system.  Your logon request is denied." },
    { 7056, "ERROR_CTX_LICENSE_EXPIRED", "The system license has expired.  Your logon request is denied." },
    { 8001, "FRS_ERR_INVALID_API_SEQUENCE", "The file replication service API was called incorrectly." },
    { 8002, "FRS_ERR_STARTING_SERVICE", "The file replication service cannot be started." },
    { 8003, "FRS_ERR_STOPPING_SERVICE", "The file replication service cannot be stopped." },
    { 8004, "FRS_ERR_INTERNAL_API", "The file replication service API terminated the request. The event log may have more information." },
    { 8005, "FRS_ERR_INTERNAL", "The file replication service terminated the request. The event log may have more information." },
    { 8006, "FRS_ERR_SERVICE_COMM", "The file replication service cannot be contacted. The event log may have more information." },
    { 8007, "FRS_ERR_INSUFFICIENT_PRIV", "The file replication service cannot satisfy the request because the user has insufficient privileges. The event log may have more information." },
    { 8008, "FRS_ERR_AUTHENTICATION", "The file replication service cannot satisfy the request because authenticated RPC is not available. The event log may have more information." },
    { 8009, "FRS_ERR_PARENT_INSUFFICIENT_PRIV", "The file replication service cannot satisfy the request because the user has insufficient privileges on the domain controller. The event log may have more information." },
    { 8010, "FRS_ERR_PARENT_AUTHENTICATION", "The file replication service cannot satisfy the request because authenticated RPC is not available on the domain controller. The event log may have more information." },
    { 8011, "FRS_ERR_CHILD_TO_PARENT_COMM", "The file replication service cannot communicate with the file replication service on the domain controller. The event log may have more information." },
    { 8012, "FRS_ERR_PARENT_TO_CHILD_COMM", "The file replication service on the domain controller cannot communicate with the file replication service on this computer. The event log may have more information." },
    { 8013, "FRS_ERR_SYSVOL_POPULATE", "The file replication service cannot populate the system volume because of an internal error. The event log may have more information." },
    { 8014, "FRS_ERR_SYSVOL_POPULATE_TIMEOUT", "The file replication service cannot populate the system volume because of an internal timeout. The event log may have more information." },
    { 8015, "FRS_ERR_SYSVOL_IS_BUSY", "The file replication service cannot process the request. The system volume is busy with a previous request." },
    { 8016, "FRS_ERR_SYSVOL_DEMOTE", "The file replication service cannot stop replicating the system volume because of an internal error. The event log may have more information." },
    { 8017, "FRS_ERR_INVALID_SERVICE_PARAMETER", "The file replication service detected an invalid parameter." },
    { 8200, "ERROR_DS_NOT_INSTALLED", "An error occurred while installing the directory service. For more information, see the event log." },
    { 8201, "ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY", "The directory service evaluated group memberships locally." },
    { 8202, "ERROR_DS_NO_ATTRIBUTE_OR_VALUE", "The specified directory service attribute or value does not exist." },
    { 8203, "ERROR_DS_INVALID_ATTRIBUTE_SYNTAX", "The attribute syntax specified to the directory service is invalid." },
    { 8204, "ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED", "The attribute type specified to the directory service is not defined." },
    { 8205, "ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS", "The specified directory service attribute or value already exists." },
    { 8206, "ERROR_DS_BUSY", "The directory service is busy." },
    { 8207, "ERROR_DS_UNAVAILABLE", "The directory service is unavailable." },
    { 8208, "ERROR_DS_NO_RIDS_ALLOCATED", "The directory service was unable to allocate a relative identifier." },
    { 8209, "ERROR_DS_NO_MORE_RIDS", "The directory service has exhausted the pool of relative identifiers." },
    { 8210, "ERROR_DS_INCORRECT_ROLE_OWNER", "The requested operation could not be performed because the directory service is not the master for that type of operation." },
    { 8211, "ERROR_DS_RIDMGR_INIT_ERROR", "The directory service was unable to initialize the subsystem that allocates relative identifiers." },
    { 8212, "ERROR_DS_OBJ_CLASS_VIOLATION", "The requested operation did not satisfy one or more constraints associated with the class of the object." },
    { 8213, "ERROR_DS_CANT_ON_NON_LEAF", "The directory service can perform the requested operation only on a leaf object." },
    { 8214, "ERROR_DS_CANT_ON_RDN", "The directory service cannot perform the requested operation on the RDN attribute of an object." },
    { 8215, "ERROR_DS_CANT_MOD_OBJ_CLASS", "The directory service detected an attempt to modify the object class of an object." },
    { 8216, "ERROR_DS_CROSS_DOM_MOVE_ERROR", "The requested cross-domain move operation could not be performed." },
    { 8217, "ERROR_DS_GC_NOT_AVAILABLE", "Unable to contact the global catalog server." },
    { 8218, "ERROR_SHARED_POLICY", "The policy object is shared and can only be modified at the root." },
    { 8219, "ERROR_POLICY_OBJECT_NOT_FOUND", "The policy object does not exist." },
    { 8220, "ERROR_POLICY_ONLY_IN_DS", "The requested policy information is only in the directory service." },
    { 8221, "ERROR_PROMOTION_ACTIVE", "A domain controller promotion is currently active." },
    { 8222, "ERROR_NO_PROMOTION_ACTIVE", "A domain controller promotion is not currently active" },
    { 8224, "ERROR_DS_OPERATIONS_ERROR", "An operations error occurred." },
    { 8225, "ERROR_DS_PROTOCOL_ERROR", "A protocol error occurred." },
    { 8226, "ERROR_DS_TIMELIMIT_EXCEEDED", "The time limit for this request was exceeded." },
    { 8227, "ERROR_DS_SIZELIMIT_EXCEEDED", "The size limit for this request was exceeded." },
    { 8228, "ERROR_DS_ADMIN_LIMIT_EXCEEDED", "The administrative limit for this request was exceeded." },
    { 8229, "ERROR_DS_COMPARE_FALSE", "The compare response was false." },
    { 8230, "ERROR_DS_COMPARE_TRUE", "The compare response was true." },
    { 8231, "ERROR_DS_AUTH_METHOD_NOT_SUPPORTED", "The requested authentication method is not supported by the server." },
    { 8232, "ERROR_DS_STRONG_AUTH_REQUIRED", "A more secure authentication method is required for this server." },
    { 8233, "ERROR_DS_INAPPROPRIATE_AUTH", "Inappropriate authentication." },
    { 8234, "ERROR_DS_AUTH_UNKNOWN", "The authentication mechanism is unknown." },
    { 8235, "ERROR_DS_REFERRAL", "A referral was returned from the server." },
    { 8236, "ERROR_DS_UNAVAILABLE_CRIT_EXTENSION", "The server does not support the requested critical extension." },
    { 8237, "ERROR_DS_CONFIDENTIALITY_REQUIRED", "This request requires a secure connection." },
    { 8238, "ERROR_DS_INAPPROPRIATE_MATCHING", "Inappropriate matching." },
    { 8239, "ERROR_DS_CONSTRAINT_VIOLATION", "A constraint violation occurred." },
    { 8240, "ERROR_DS_NO_SUCH_OBJECT", "There is no such object on the server." },
    { 8241, "ERROR_DS_ALIAS_PROBLEM", "There is an alias problem." },
    { 8242, "ERROR_DS_INVALID_DN_SYNTAX", "An invalid dn syntax has been specified." },
    { 8243, "ERROR_DS_IS_LEAF", "The object is a leaf object." },
    { 8244, "ERROR_DS_ALIAS_DEREF_PROBLEM", "There is an alias dereferencing problem." },
    { 8245, "ERROR_DS_UNWILLING_TO_PERFORM", "The server is unwilling to process the request." },
    { 8246, "ERROR_DS_LOOP_DETECT", "A loop has been detected." },
    { 8247, "ERROR_DS_NAMING_VIOLATION", "There is a naming violation." },
    { 8248, "ERROR_DS_OBJECT_RESULTS_TOO_LARGE", "The result set is too large." },
    { 8249, "ERROR_DS_AFFECTS_MULTIPLE_DSAS", "The operation affects multiple DSAs" },
    { 8250, "ERROR_DS_SERVER_DOWN", "The server is not operational." },
    { 8251, "ERROR_DS_LOCAL_ERROR", "A local error has occurred." },
    { 8252, "ERROR_DS_ENCODING_ERROR", "An encoding error has occurred." },
    { 8253, "ERROR_DS_DECODING_ERROR", "A decoding error has occurred." },
    { 8254, "ERROR_DS_FILTER_UNKNOWN", "The search filter cannot be recognized." },
    { 8255, "ERROR_DS_PARAM_ERROR", "One or more parameters are illegal." },
    { 8256, "ERROR_DS_NOT_SUPPORTED", "The specified method is not supported." },
    { 8257, "ERROR_DS_NO_RESULTS_RETURNED", "No results were returned." },
    { 8258, "ERROR_DS_CONTROL_NOT_FOUND", "The specified control is not supported by the server." },
    { 8259, "ERROR_DS_CLIENT_LOOP", "A referral loop was detected by the client." },
    { 8260, "ERROR_DS_REFERRAL_LIMIT_EXCEEDED", "The preset referral limit was exceeded." },
    { 8301, "ERROR_DS_ROOT_MUST_BE_NC", "The root object must be the head of a naming context. The root object cannot have an instantiated parent." },
    { 8302, "ERROR_DS_ADD_REPLICA_INHIBITED", "The add replica operation cannot be performed. The naming context must be writable in order to create the replica." },
    { 8303, "ERROR_DS_ATT_NOT_DEF_IN_SCHEMA", "A reference to an attribute that is not defined in the schema occurred." },
    { 8304, "ERROR_DS_MAX_OBJ_SIZE_EXCEEDED", "The maximum size of an object has been exceeded." },
    { 8305, "ERROR_DS_OBJ_STRING_NAME_EXISTS", "An attempt was made to add an object to the directory with a name that is already in use." },
    { 8306, "ERROR_DS_NO_RDN_DEFINED_IN_SCHEMA", "An attempt was made to add an object of a class that does not have an RDN defined in the schema." },
    { 8307, "ERROR_DS_RDN_DOESNT_MATCH_SCHEMA", "An attempt was made to add an object using an RDN that is not the RDN defined in the schema." },
    { 8308, "ERROR_DS_NO_REQUESTED_ATTS_FOUND", "None of the requested attributes were found on the objects." },
    { 8309, "ERROR_DS_USER_BUFFER_TO_SMALL", "The user buffer is too small." },
    { 8310, "ERROR_DS_ATT_IS_NOT_ON_OBJ", "The attribute specified in the operation is not present on the object." },
    { 8311, "ERROR_DS_ILLEGAL_MOD_OPERATION", "Illegal modify operation. Some aspect of the modification is not permitted." },
    { 8312, "ERROR_DS_OBJ_TOO_LARGE", "The specified object is too large." },
    { 8313, "ERROR_DS_BAD_INSTANCE_TYPE", "The specified instance type is not valid." },
    { 8314, "ERROR_DS_MASTERDSA_REQUIRED", "The operation must be performed at a master DSA." },
    { 8315, "ERROR_DS_OBJECT_CLASS_REQUIRED", "The object class attribute must be specified." },
    { 8316, "ERROR_DS_MISSING_REQUIRED_ATT", "A required attribute is missing." },
    { 8317, "ERROR_DS_ATT_NOT_DEF_FOR_CLASS", "An attempt was made to modify an object to include an attribute that is not legal for its class." },
    { 8318, "ERROR_DS_ATT_ALREADY_EXISTS", "The specified attribute is already present on the object." },
    { 8320, "ERROR_DS_CANT_ADD_ATT_VALUES", "The specified attribute is not present, or has no values." },
    { 8321, "ERROR_DS_SINGLE_VALUE_CONSTRAINT", "Mutliple values were specified for an attribute that can have only one value." },
    { 8322, "ERROR_DS_RANGE_CONSTRAINT", "A value for the attribute was not in the acceptable range of values." },
    { 8323, "ERROR_DS_ATT_VAL_ALREADY_EXISTS", "The specified value already exists." },
    { 8324, "ERROR_DS_CANT_REM_MISSING_ATT", "The attribute cannot be removed because it is not present on the object." },
    { 8325, "ERROR_DS_CANT_REM_MISSING_ATT_VAL", "The attribute value cannot be removed because it is not present on the object." },
    { 8326, "ERROR_DS_ROOT_CANT_BE_SUBREF", "The specified root object cannot be a subref." },
    { 8327, "ERROR_DS_NO_CHAINING", "Chaining is not permitted." },
    { 8328, "ERROR_DS_NO_CHAINED_EVAL", "Chained evaluation is not permitted." },
    { 8329, "ERROR_DS_NO_PARENT_OBJECT", "The operation could not be performed because the object's parent is either uninstantiated or deleted." },
    { 8330, "ERROR_DS_PARENT_IS_AN_ALIAS", "Having a parent that is an alias is not permitted. Aliases are leaf objects." },
    { 8331, "ERROR_DS_CANT_MIX_MASTER_AND_REPS", "The object and parent must be of the same type, either both masters or both replicas." },
    { 8332, "ERROR_DS_CHILDREN_EXIST", "The operation cannot be performed because child objects exist. This operation can only be performed on a leaf object." },
    { 8333, "ERROR_DS_OBJ_NOT_FOUND", "Directory object not found." },
    { 8334, "ERROR_DS_ALIASED_OBJ_MISSING", "The aliased object is missing." },
    { 8335, "ERROR_DS_BAD_NAME_SYNTAX", "The object name has bad syntax." },
    { 8336, "ERROR_DS_ALIAS_POINTS_TO_ALIAS", "It is not permitted for an alias to refer to another alias." },
    { 8337, "ERROR_DS_CANT_DEREF_ALIAS", "The alias cannot be dereferenced." },
    { 8338, "ERROR_DS_OUT_OF_SCOPE", "The operation is out of scope." },
    { 8340, "ERROR_DS_CANT_DELETE_DSA_OBJ", "The DSA object cannot be deleted." },
    { 8341, "ERROR_DS_GENERIC_ERROR", "A directory service error has occurred." },
    { 8342, "ERROR_DS_DSA_MUST_BE_INT_MASTER", "The operation can only be performed on an internal master DSA object." },
    { 8343, "ERROR_DS_CLASS_NOT_DSA", "The object must be of class DSA." },
    { 8344, "ERROR_DS_INSUFF_ACCESS_RIGHTS", "Insufficient access rights to perform the operation." },
    { 8345, "ERROR_DS_ILLEGAL_SUPERIOR", "The object cannot be added because the parent is not on the list of possible superiors." },
    { 8346, "ERROR_DS_ATTRIBUTE_OWNED_BY_SAM", "Access to the attribute is not permitted because the attribute is owned by the Security Accounts Manager (SAM)." },
    { 8347, "ERROR_DS_NAME_TOO_MANY_PARTS", "The name has too many parts." },
    { 8348, "ERROR_DS_NAME_TOO_LONG", "The name is too long." },
    { 8349, "ERROR_DS_NAME_VALUE_TOO_LONG", "The name value is too long." },
    { 8350, "ERROR_DS_NAME_UNPARSEABLE", "The directory service encountered an error parsing a name." },
    { 8351, "ERROR_DS_NAME_TYPE_UNKNOWN", "The directory service cannot get the attribute type for a name." },
    { 8352, "ERROR_DS_NOT_AN_OBJECT", "The name does not identify an object; the name identifies a phantom." },
    { 8353, "ERROR_DS_SEC_DESC_TOO_SHORT", "The security descriptor is too short." },
    { 8354, "ERROR_DS_SEC_DESC_INVALID", "The security descriptor is invalid." },
    { 8355, "ERROR_DS_NO_DELETED_NAME", "Failed to create name for deleted object." },
    { 8356, "ERROR_DS_SUBREF_MUST_HAVE_PARENT", "The parent of a new subref must exist." },
    { 8357, "ERROR_DS_NCNAME_MUST_BE_NC", "The object must be a naming context." },
    { 8358, "ERROR_DS_CANT_ADD_SYSTEM_ONLY", "It is not permitted to add an attribute which is owned by the system." },
    { 8359, "ERROR_DS_CLASS_MUST_BE_CONCRETE", "The class of the object must be structural; you cannot instantiate an abstract class." },
    { 8360, "ERROR_DS_INVALID_DMD", "The schema object could not be found." },
    { 8361, "ERROR_DS_OBJ_GUID_EXISTS", "A local object with this GUID (dead or alive) already exists." },
    { 8362, "ERROR_DS_NOT_ON_BACKLINK", "The operation cannot be performed on a back link." },
    { 8363, "ERROR_DS_NO_CROSSREF_FOR_NC", "The cross reference for the specified naming context could not be found." },
    { 8364, "ERROR_DS_SHUTTING_DOWN", "The operation could not be performed because the directory service is shutting down." },
    { 8365, "ERROR_DS_UNKNOWN_OPERATION", "The directory service request is invalid." },
    { 8366, "ERROR_DS_INVALID_ROLE_OWNER", "The role owner attribute could not be read." },
    { 8367, "ERROR_DS_COULDNT_CONTACT_FSMO", "The requested FSMO operation failed. The current FSMO holder could not be contacted." },
    { 8368, "ERROR_DS_CROSS_NC_DN_RENAME", "Modification of a DN across a naming context is not permitted." },
    { 8369, "ERROR_DS_CANT_MOD_SYSTEM_ONLY", "The attribute cannot be modified because it is owned by the system." },
    { 8370, "ERROR_DS_REPLICATOR_ONLY", "Only the replicator can perform this function." },
    { 8371, "ERROR_DS_OBJ_CLASS_NOT_DEFINED", "The specified class is not defined." },
    { 8372, "ERROR_DS_OBJ_CLASS_NOT_SUBCLASS", "The specified class is not a subclass." },
    { 8373, "ERROR_DS_NAME_REFERENCE_INVALID", "The name reference is invalid." },
    { 8374, "ERROR_DS_CROSS_REF_EXISTS", "A cross reference already exists." },
    { 8375, "ERROR_DS_CANT_DEL_MASTER_CROSSREF", "It is not permitted to delete a master cross reference." },
    { 8376, "ERROR_DS_SUBTREE_NOTIFY_NOT_NC_HEAD", "Subtree notifications are only supported on NC heads." },
    { 8377, "ERROR_DS_NOTIFY_FILTER_TOO_COMPLEX", "Notification filter is too complex." },
    { 8378, "ERROR_DS_DUP_RDN", "Schema update failed: duplicate RDN." },
    { 8379, "ERROR_DS_DUP_OID", "Schema update failed: duplicate OID." },
    { 8380, "ERROR_DS_DUP_MAPI_ID", "Schema update failed: duplicate MAPI identifier." },
    { 8381, "ERROR_DS_DUP_SCHEMA_ID_GUID", "Schema update failed: duplicate schema-id GUID." },
    { 8382, "ERROR_DS_DUP_LDAP_DISPLAY_NAME", "Schema update failed: duplicate LDAP display name." },
    { 8383, "ERROR_DS_SEMANTIC_ATT_TEST", "Schema update failed: range-lower less than range upper." },
    { 8384, "ERROR_DS_SYNTAX_MISMATCH", "Schema update failed: syntax mismatch." },
    { 8385, "ERROR_DS_EXISTS_IN_MUST_HAVE", "Schema deletion failed: attribute is used in must-contain." },
    { 8386, "ERROR_DS_EXISTS_IN_MAY_HAVE", "Schema deletion failed: attribute is used in may-contain." },
    { 8387, "ERROR_DS_NONEXISTENT_MAY_HAVE", "Schema update failed: attribute in may-contain does not exist." },
    { 8388, "ERROR_DS_NONEXISTENT_MUST_HAVE", "Schema update failed: attribute in must-contain does not exist." },
    { 8389, "ERROR_DS_AUX_CLS_TEST_FAIL", "Schema update failed: class in aux-class list does not exist or is not an auxiliary class." },
    { 8390, "ERROR_DS_NONEXISTENT_POSS_SUP", "Schema update failed: class in poss-superiors does not exist." },
    { 8391, "ERROR_DS_SUB_CLS_TEST_FAIL", "Schema update failed: class in subclassof list does not exist or does not satisfy hierarchy rules." },
    { 8392, "ERROR_DS_BAD_RDN_ATT_ID_SYNTAX", "Schema update failed: Rdn-Att-Id has wrong syntax." },
    { 8393, "ERROR_DS_EXISTS_IN_AUX_CLS", "Schema deletion failed: class is used as auxiliary class." },
    { 8394, "ERROR_DS_EXISTS_IN_SUB_CLS", "Schema deletion failed: class is used as sub class." },
    { 8395, "ERROR_DS_EXISTS_IN_POSS_SUP", "Schema deletion failed: class is used as poss superior." },
    { 8396, "ERROR_DS_RECALCSCHEMA_FAILED", "Schema update failed in recalculating validation cache." },
    { 8397, "ERROR_DS_TREE_DELETE_NOT_FINISHED", "The tree deletion is not finished.  The request must be made again to continue deleting the tree." },
    { 8398, "ERROR_DS_CANT_DELETE", "The requested delete operation could not be performed." },
    { 8399, "ERROR_DS_ATT_SCHEMA_REQ_ID", "Cannot read the governs class identifier for the schema record." },
    { 8400, "ERROR_DS_BAD_ATT_SCHEMA_SYNTAX", "The attribute schema has bad syntax." },
    { 8401, "ERROR_DS_CANT_CACHE_ATT", "The attribute could not be cached." },
    { 8402, "ERROR_DS_CANT_CACHE_CLASS", "The class could not be cached." },
    { 8403, "ERROR_DS_CANT_REMOVE_ATT_CACHE", "The attribute could not be removed from the cache." },
    { 8404, "ERROR_DS_CANT_REMOVE_CLASS_CACHE", "The class could not be removed from the cache." },
    { 8405, "ERROR_DS_CANT_RETRIEVE_DN", "The distinguished name attribute could not be read." },
    { 8406, "ERROR_DS_MISSING_SUPREF", "A required subref is missing." },
    { 8407, "ERROR_DS_CANT_RETRIEVE_INSTANCE", "The instance type attribute could not be retrieved." },
    { 8408, "ERROR_DS_CODE_INCONSISTENCY", "An internal error has occurred." },
    { 8409, "ERROR_DS_DATABASE_ERROR", "A database error has occurred." },
    { 8410, "ERROR_DS_GOVERNSID_MISSING", "The attribute GOVERNSID is missing." },
    { 8411, "ERROR_DS_MISSING_EXPECTED_ATT", "An expected attribute is missing." },
    { 8412, "ERROR_DS_NCNAME_MISSING_CR_REF", "The specified naming context is missing a cross reference." },
    { 8413, "ERROR_DS_SECURITY_CHECKING_ERROR", "A security checking error has occurred." },
    { 8414, "ERROR_DS_SCHEMA_NOT_LOADED", "The schema is not loaded." },
    { 8415, "ERROR_DS_SCHEMA_ALLOC_FAILED", "Schema allocation failed. Please check if the machine is running low on memory." },
    { 8416, "ERROR_DS_ATT_SCHEMA_REQ_SYNTAX", "Failed to obtain the required syntax for the attribute schema." },
    { 8417, "ERROR_DS_GCVERIFY_ERROR", "The global catalog verification failed. The global catalog is not available or does not support the operation. Some part of the directory is currently not available." },
    { 8418, "ERROR_DS_DRA_SCHEMA_MISMATCH", "The replication operation failed because of a schema mismatch between the servers involved." },
    { 8419, "ERROR_DS_CANT_FIND_DSA_OBJ", "The DSA object could not be found." },
    { 8420, "ERROR_DS_CANT_FIND_EXPECTED_NC", "The naming context could not be found." },
    { 8421, "ERROR_DS_CANT_FIND_NC_IN_CACHE", "The naming context could not be found in the cache." },
    { 8422, "ERROR_DS_CANT_RETRIEVE_CHILD", "The child object could not be retrieved." },
    { 8423, "ERROR_DS_SECURITY_ILLEGAL_MODIFY", "The modification was not permitted for security reasons." },
    { 8424, "ERROR_DS_CANT_REPLACE_HIDDEN_REC", "The operation cannot replace the hidden record." },
    { 8425, "ERROR_DS_BAD_HIERARCHY_FILE", "The hierarchy file is invalid." },
    { 8426, "ERROR_DS_BUILD_HIERARCHY_TABLE_FAILED", "The attempt to build the hierarchy table failed." },
    { 8427, "ERROR_DS_CONFIG_PARAM_MISSING", "The directory configuration parameter is missing from the registry." },
    { 8428, "ERROR_DS_COUNTING_AB_INDICES_FAILED", "The attempt to count the address book indices failed." },
    { 8429, "ERROR_DS_HIERARCHY_TABLE_MALLOC_FAILED", "The allocation of the hierarchy table failed." },
    { 8430, "ERROR_DS_INTERNAL_FAILURE", "The directory service encountered an internal failure." },
    { 8431, "ERROR_DS_UNKNOWN_ERROR", "The directory service encountered an unknown failure." },
    { 8432, "ERROR_DS_ROOT_REQUIRES_CLASS_TOP", "A root object requires a class of 'top'." },
    { 8433, "ERROR_DS_REFUSING_FSMO_ROLES", "This directory server is shutting down, and cannot take ownership of new floating single-master operation roles." },
    { 8434, "ERROR_DS_MISSING_FSMO_SETTINGS", "The directory service is missing mandatory configuration information, and is unable to determine the ownership of floating single-master operation roles." },
    { 8435, "ERROR_DS_UNABLE_TO_SURRENDER_ROLES", "The directory service was unable to transfer ownership of one or more floating single-master operation roles to other servers." },
    { 8436, "ERROR_DS_DRA_GENERIC", "The replication operation failed." },
    { 8437, "ERROR_DS_DRA_INVALID_PARAMETER", "An invalid parameter was specified for this replication operation." },
    { 8438, "ERROR_DS_DRA_BUSY", "The directory service is too busy to complete the replication operation at this time." },
    { 8439, "ERROR_DS_DRA_BAD_DN", "The distinguished name specified for this replication operation is invalid." },
    { 8440, "ERROR_DS_DRA_BAD_NC", "The naming context specified for this replication operation is invalid." },
    { 8441, "ERROR_DS_DRA_DN_EXISTS", "The distinguished name specified for this replication operation already exists." },
    { 8442, "ERROR_DS_DRA_INTERNAL_ERROR", "The replication system encountered an internal error." },
    { 8443, "ERROR_DS_DRA_INCONSISTENT_DIT", "The replication operation encountered a database inconsistency." },
    { 8444, "ERROR_DS_DRA_CONNECTION_FAILED", "The server specified for this replication operation could not be contacted." },
    { 8445, "ERROR_DS_DRA_BAD_INSTANCE_TYPE", "The replication operation encountered an object with an invalid instance type." },
    { 8446, "ERROR_DS_DRA_OUT_OF_MEM", "The replication operation failed to allocate memory." },
    { 8447, "ERROR_DS_DRA_MAIL_PROBLEM", "The replication operation encountered an error with the mail system." },
    { 8448, "ERROR_DS_DRA_REF_ALREADY_EXISTS", "The replication reference information for the target server already exists." },
    { 8449, "ERROR_DS_DRA_REF_NOT_FOUND", "The replication reference information for the target server does not exist." },
    { 8450, "ERROR_DS_DRA_OBJ_IS_REP_SOURCE", "The naming context cannot be removed because it is replicated to another server." },
    { 8451, "ERROR_DS_DRA_DB_ERROR", "The replication operation encountered a database error." },
    { 8452, "ERROR_DS_DRA_NO_REPLICA", "The naming context is in the process of being removed or is not replicated from the specified server." },
    { 8453, "ERROR_DS_DRA_ACCESS_DENIED", "Replication access was denied." },
    { 8454, "ERROR_DS_DRA_NOT_SUPPORTED", "The requested operation is not supported by this version of the directory service." },
    { 8455, "ERROR_DS_DRA_RPC_CANCELLED", "The replication remote procedure call was cancelled." },
    { 8456, "ERROR_DS_DRA_SOURCE_DISABLED", "The source server is currently rejecting replication requests." },
    { 8457, "ERROR_DS_DRA_SINK_DISABLED", "The destination server is currently rejecting replication requests." },
    { 8458, "ERROR_DS_DRA_NAME_COLLISION", "The replication operation failed due to a collision of object names." },
    { 8459, "ERROR_DS_DRA_SOURCE_REINSTALLED", "The replication source has been reinstalled." },
    { 8460, "ERROR_DS_DRA_MISSING_PARENT", "The replication operation failed because a required parent object is missing." },
    { 8461, "ERROR_DS_DRA_PREEMPTED", "The replication operation was preempted." },
    { 8462, "ERROR_DS_DRA_ABANDON_SYNC", "The replication synchronization attempt was abandoned because of a lack of updates." },
    { 8463, "ERROR_DS_DRA_SHUTDOWN", "The replication operation was terminated because the system is shutting down." },
    { 8464, "ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET", "The replication synchronization attempt failed as the destination partial attribute set is not a subset of source partial attribute set." },
    { 8465, "ERROR_DS_DRA_SOURCE_IS_PARTIAL_REPLICA", "The replication synchronization attempt failed because a master replica attempted to sync from a partial replica." },
    { 8466, "ERROR_DS_DRA_EXTN_CONNECTION_FAILED", "The server specified for this replication operation was contacted, but that server was unable to contact an additional server needed to complete the operation." },
    { 8467, "ERROR_DS_INSTALL_SCHEMA_MISMATCH", "A schema mismatch is detected between the source and the build used during a replica install. The replica cannot be installed." },
    { 8468, "ERROR_DS_DUP_LINK_ID", "Schema update failed: An attribute with the same link identifier already exists." },
    { 8469, "ERROR_DS_NAME_ERROR_RESOLVING", "Name translation: Generic processing error." },
    { 8470, "ERROR_DS_NAME_ERROR_NOT_FOUND", "Name translation: Could not find the name or insufficient right to see name." },
    { 8471, "ERROR_DS_NAME_ERROR_NOT_UNIQUE", "Name translation: Input name mapped to more than one output name." },
    { 8472, "ERROR_DS_NAME_ERROR_NO_MAPPING", "Name translation: Input name found, but not the associated output format." },
    { 8473, "ERROR_DS_NAME_ERROR_DOMAIN_ONLY", "Name translation: Unable to resolve completely, only the domain was found." },
    { 8474, "ERROR_DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING", "Name translation: Unable to perform purely syntactical mapping at the client without going out to the wire." },
    { 8475, "ERROR_DS_CONSTRUCTED_ATT_MOD", "Modification of a constructed att is not allowed." },
    { 8476, "ERROR_DS_WRONG_OM_OBJ_CLASS", "The OM-Object-Class specified is incorrect for an attribute with the specified syntax." },
    { 8477, "ERROR_DS_DRA_REPL_PENDING", "The replication request has been posted; waiting for reply." },
    { 8478, "ERROR_DS_DS_REQUIRED", "The requested operation requires a directory service, and none was available." },
    { 8479, "ERROR_DS_INVALID_LDAP_DISPLAY_NAME", "The LDAP display name of the class or attribute contains non-ASCII characters." },
    { 8480, "ERROR_DS_NON_BASE_SEARCH", "The requested search operation is only supported for base searches." },
    { 8481, "ERROR_DS_CANT_RETRIEVE_ATTS", "The search failed to retrieve attributes from the database." },
    { 8482, "ERROR_DS_BACKLINK_WITHOUT_LINK", "The schema update operation tried to add a backward link attribute that has no corresponding forward link." },
    { 8483, "ERROR_DS_EPOCH_MISMATCH", "Source and destination of a cross-domain move do not agree on the object's epoch number.  Either source or destination does not have the latest version of the object." },
    { 8484, "ERROR_DS_SRC_NAME_MISMATCH", "Source and destination of a cross-domain move do not agree on the object's current name.  Either source or destination does not have the latest version of the object." },
    { 8485, "ERROR_DS_SRC_AND_DST_NC_IDENTICAL", "Source and destination for the cross-domain move operation are identical.  Caller should use local move operation instead of cross-domain move operation." },
    { 8486, "ERROR_DS_DST_NC_MISMATCH", "Source and destination for a cross-domain move are not in agreement on the naming contexts in the forest.  Either source or destination does not have the latest version of the Partitions container." },
    { 8487, "ERROR_DS_NOT_AUTHORITIVE_FOR_DST_NC", "Destination of a cross-domain move is not authoritative for the destination naming context." },
    { 8488, "ERROR_DS_SRC_GUID_MISMATCH", "Source and destination of a cross-domain move do not agree on the identity of the source object.  Either source or destination does not have the latest version of the source object." },
    { 8489, "ERROR_DS_CANT_MOVE_DELETED_OBJECT", "Object being moved across-domains is already known to be deleted by the destination server.  The source server does not have the latest version of the source object." },
    { 8490, "ERROR_DS_PDC_OPERATION_IN_PROGRESS", "Another operation which requires exclusive access to the PDC FSMO is already in progress." },
    { 8491, "ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD", "A cross-domain move operation failed such that two versions of the moved object exist - one each in the source and destination domains.  The destination object needs to be removed to restore the system to a consistent state." },
    { 8492, "ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION", "This object may not be moved across domain boundaries either because cross-domain moves for this class are disallowed, or the object has some special characteristics, eg: trust account or restricted RID, which prevent its move." },
    { 8493, "ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS", "Can't move objects with memberships across domain boundaries as once moved, this would violate the membership conditions of the account group.  Remove the object from any account group memberships and retry." },
    { 8494, "ERROR_DS_NC_MUST_HAVE_NC_PARENT", "A naming context head must be the immediate child of another naming context head, not of an interior node." },
    { 8495, "ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE", "The directory cannot validate the proposed naming context name because it does not hold a replica of the naming context above the proposed naming context.  Please ensure that the domain naming master role is held by a server that is configured as a g lobal catalog server, and that the server is up to date with its replication partners." },
    { 8496, "ERROR_DS_DST_DOMAIN_NOT_NATIVE", "Destination domain must be in native mode." },
    { 8497, "ERROR_DS_MISSING_INFRASTRUCTURE_CONTAINER", "The operation can not be performed because the server does not have an infrastructure container in the domain of interest." },
    { 8498, "ERROR_DS_CANT_MOVE_ACCOUNT_GROUP", "Cross-domain move of account groups is not allowed." },
    { 8499, "ERROR_DS_CANT_MOVE_RESOURCE_GROUP", "Cross-domain move of resource groups is not allowed." },
    { 8500, "ERROR_DS_INVALID_SEARCH_FLAG", "The search flags for the attribute are invalid. The ANR bit is valid only on attributes of Unicode or Teletex strings." },
    { 8501, "ERROR_DS_NO_TREE_DELETE_ABOVE_NC", "Tree deletions starting at an object which has an NC head as a descendant are not allowed." },
    { 8502, "ERROR_DS_COULDNT_LOCK_TREE_FOR_DELETE", "The directory service failed to lock a tree in preparation for a tree deletion because the tree was in use." },
    { 8503, "ERROR_DS_COULDNT_IDENTIFY_OBJECTS_FOR_TREE_DELETE", "The directory service failed to identify the list of objects to delete while attempting a tree deletion." },
    { 8504, "ERROR_DS_SAM_INIT_FAILURE", "Security Accounts Manager initialization failed because of the following error: %1. Error Status: 0x%2. Click OK to shut down the system and reboot into Directory Services Restore Mode. Check the event log for detailed information." },
    { 8505, "ERROR_DS_SENSITIVE_GROUP_VIOLATION", "Only an administrator can modify the membership list of an administrative group." },
    { 8506, "ERROR_DS_CANT_MOD_PRIMARYGROUPID", "Cannot change the primary group ID of a domain controller account." },
    { 8507, "ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD", "An attempt is made to modify the base schema." },
    { 8508, "ERROR_DS_NONSAFE_SCHEMA_CHANGE", "Adding a new mandatory attribute to an existing class, deleting a mandatory attribute from an existing class, or adding an optional attribute to the special class Top that is not a backlink attribute (directly or through inheritance, for example, by adding or deleting an auxiliary class) is not allowed." },
    { 8509, "ERROR_DS_SCHEMA_UPDATE_DISALLOWED", "Schema update is not allowed on this DC. Either the registry key is not set or the DC is not the schema FSMO Role Owner." },
    { 8510, "ERROR_DS_CANT_CREATE_UNDER_SCHEMA", "An object of this class cannot be created under the schema container. You can only create attribute-schema and class-schema objects under the schema container." },
    { 8511, "ERROR_DS_INSTALL_NO_SRC_SCH_VERSION", "The replica/child install failed to get the objectVersion attribute on the schema container on the source DC. Either the attribute is missing on the schema container or the credentials supplied do not have permission to read it." },
    { 8512, "ERROR_DS_INSTALL_NO_SCH_VERSION_IN_INIFILE", "The replica/child install failed to read the objectVersion attribute in the SCHEMA section of the file schema.ini in the system32 directory." },
    { 8513, "ERROR_DS_INVALID_GROUP_TYPE", "The specified group type is invalid." },
    { 8514, "ERROR_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN", "You cannot nest global groups in a mixed domain if the group is security-enabled." },
    { 8515, "ERROR_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN", "You cannot nest local groups in a mixed domain if the group is security-enabled." },
    { 8516, "ERROR_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER", "A global group cannot have a local group as a member." },
    { 8517, "ERROR_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER", "A global group cannot have a universal group as a member." },
    { 8518, "ERROR_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER", "A universal group cannot have a local group as a member." },
    { 8519, "ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER", "A global group cannot have a cross-domain member." },
    { 8520, "ERROR_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER", "A local group cannot have another cross domain local group as a member." },
    { 8521, "ERROR_DS_HAVE_PRIMARY_MEMBERS", "A group with primary members cannot change to a security-disabled group." },
    { 8522, "ERROR_DS_STRING_SD_CONVERSION_FAILED", "The schema cache load failed to convert the string default SD on a class-schema object." },
    { 8523, "ERROR_DS_NAMING_MASTER_GC", "Only DSAs configured to be Global Catalog servers should be allowed to hold the Domain Naming Master FSMO role." },
    { 8524, "ERROR_DS_DNS_LOOKUP_FAILURE", "The DSA operation is unable to proceed because of a DNS lookup failure." },
    { 8525, "ERROR_DS_COULDNT_UPDATE_SPNS", "While processing a change to the DNS Host Name for an object, the Service Principal Name values could not be kept in sync." },
    { 8526, "ERROR_DS_CANT_RETRIEVE_SD", "The Security Descriptor attribute could not be read." },
    { 8527, "ERROR_DS_KEY_NOT_UNIQUE", "The object requested was not found, but an object with that key was found." },
    { 8528, "ERROR_DS_WRONG_LINKED_ATT_SYNTAX", "The syntax of the linked attribute being added is incorrect. Forward links can only have syntax 2.5.5.1, 2.5.5.7, and 2.5.5.14, and backlinks can only have syntax 2.5.5.1" },
    { 8529, "ERROR_DS_SAM_NEED_BOOTKEY_PASSWORD", "Security Account Manager needs to get the boot password." },
    { 8530, "ERROR_DS_SAM_NEED_BOOTKEY_FLOPPY", "Security Account Manager needs to get the boot key from floppy disk." },
    { 8531, "ERROR_DS_CANT_START", "Directory Service cannot start." },
    { 8532, "ERROR_DS_INIT_FAILURE", "Directory Services could not start." },
    { 8533, "ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION", "The connection between client and server requires packet privacy or better." },
    { 8534, "ERROR_DS_SOURCE_DOMAIN_IN_FOREST", "The source domain may not be in the same forest as destination." },
    { 8535, "ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST", "The destination domain must be in the forest." },
    { 8536, "ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED", "The operation requires that destination domain auditing be enabled." },
    { 8537, "ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN", "The operation couldn't locate a DC for the source domain." },
    { 8538, "ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER", "The source object must be a group or user." },
    { 8539, "ERROR_DS_SRC_SID_EXISTS_IN_FOREST", "The source object's SID already exists in destination forest." },
    { 8540, "ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH", "The source and destination object must be of the same type." },
    { 8541, "ERROR_SAM_INIT_FAILURE", "Security Accounts Manager initialization failed because of the following error: %1. Error Status: 0x%2. Click OK to shut down the system and reboot into Safe Mode. Check the event log for detailed information." },
    { 8542, "ERROR_DS_DRA_SCHEMA_INFO_SHIP", "Schema information could not be included in the replication request." },
    { 8543, "ERROR_DS_DRA_SCHEMA_CONFLICT", "The replication operation could not be completed due to a schema incompatibility." },
    { 8544, "ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT", "The replication operation could not be completed due to a previous schema incompatibility." },
    { 8545, "ERROR_DS_DRA_OBJ_NC_MISMATCH", "The replication update could not be applied because either the source or the destination has not yet received information regarding a recent cross-domain move operation." },
    { 8546, "ERROR_DS_NC_STILL_HAS_DSAS", "The requested domain could not be deleted because there exist domain controllers that still host this domain." },
    { 8547, "ERROR_DS_GC_REQUIRED", "The requested operation can be performed only on a global catalog server." },
    { 8548, "ERROR_DS_LOCAL_MEMBER_OF_LOCAL_ONLY", "A local group can only be a member of other local groups in the same domain." },
    { 8549, "ERROR_DS_NO_FPO_IN_UNIVERSAL_GROUPS", "Foreign security principals cannot be members of universal groups." },
    { 8550, "ERROR_DS_CANT_ADD_TO_GC", "The attribute is not allowed to be replicated to the GC because of security reasons." },
    { 8551, "ERROR_DS_NO_CHECKPOINT_WITH_PDC", "The checkpoint with the PDC could not be taken because there too many modifications being processed currently." },
    { 8552, "ERROR_DS_SOURCE_AUDITING_NOT_ENABLED", "The operation requires that source domain auditing be enabled." },
    { 8553, "ERROR_DS_CANT_CREATE_IN_NONDOMAIN_NC", "Security principal objects can only be created inside domain naming contexts." },
    { 8554, "ERROR_DS_INVALID_NAME_FOR_SPN", "A Service Principal Name (SPN) could not be constructed because the provided hostname is not in the necessary format." },
    { 8555, "ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS", "A Filter was passed that uses constructed attributes." },
    { 8556, "ERROR_DS_UNICODEPWD_NOT_IN_QUOTES", "The unicodePwd attribute value must be enclosed in double quotes." },
    { 8557, "ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED", "Your computer could not be joined to the domain. You have exceeded the maximum number of computer accounts you are allowed to create in this domain. Contact your system administrator to have this limit reset or increased." },
    { 8558, "ERROR_DS_MUST_BE_RUN_ON_DST_DC", "For security reasons, the operation must be run on the destination DC." },
    { 8559, "ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER", "For security reasons, the source DC must be Service Pack 4 or greater." },
    { 8560, "ERROR_DS_CANT_TREE_DELETE_CRITICAL_OBJ", "Critical Directory Service System objects cannot be deleted during tree delete operations.  The tree delete may have been partially performed." },
    { 9001, "DNS_ERROR_RCODE_FORMAT_ERROR", "DNS server unable to interpret format." },
    { 9002, "DNS_ERROR_RCODE_SERVER_FAILURE", "DNS server failure." },
    { 9003, "DNS_ERROR_RCODE_NAME_ERROR", "DNS name does not exist." },
    { 9004, "DNS_ERROR_RCODE_NOT_IMPLEMENTED", "DNS request not supported by name server." },
    { 9005, "DNS_ERROR_RCODE_REFUSED", "DNS operation refused." },
    { 9006, "DNS_ERROR_RCODE_YXDOMAIN", "DNS name that ought not exist, does exist." },
    { 9007, "DNS_ERROR_RCODE_YXRRSET", "DNS RR set that ought not exist, does exist." },
    { 9008, "DNS_ERROR_RCODE_NXRRSET", "DNS RR set that ought to exist, does not exist." },
    { 9009, "DNS_ERROR_RCODE_NOTAUTH", "DNS server not authoritative for zone." },
    { 9010, "DNS_ERROR_RCODE_NOTZONE", "DNS name in update or prereq is not in zone." },
    { 9016, "DNS_ERROR_RCODE_BADSIG", "DNS signature failed to verify." },
    { 9017, "DNS_ERROR_RCODE_BADKEY", "DNS bad key." },
    { 9018, "DNS_ERROR_RCODE_BADTIME", "DNS signature validity expired." },
    { 9501, "DNS_INFO_NO_RECORDS", "No records found for given DNS query." },
    { 9502, "DNS_ERROR_BAD_PACKET", "Bad DNS packet." },
    { 9503, "DNS_ERROR_NO_PACKET", "No DNS packet." },
    { 9504, "DNS_ERROR_RCODE", "DNS error, check rcode." },
    { 9505, "DNS_ERROR_UNSECURE_PACKET", "Unsecured DNS packet." },
    { 9551, "DNS_ERROR_INVALID_TYPE", "Invalid DNS type." },
    { 9552, "DNS_ERROR_INVALID_IP_ADDRESS", "Invalid IP address." },
    { 9553, "DNS_ERROR_INVALID_PROPERTY", "Invalid property." },
    { 9554, "DNS_ERROR_TRY_AGAIN_LATER", "Try DNS operation again later." },
    { 9555, "DNS_ERROR_NOT_UNIQUE", "Record for given name and type is not unique." },
    { 9556, "DNS_ERROR_NON_RFC_NAME", "DNS name does not comply with RFC specifications." },
    { 9557, "DNS_STATUS_FQDN", "DNS name is a fully-qualified DNS name." },
    { 9558, "DNS_STATUS_DOTTED_NAME", "DNS name is dotted (multi-label)." },
    { 9559, "DNS_STATUS_SINGLE_PART_NAME", "DNS name is a single-part name." },
    { 9560, "DNS_ERROR_INVALID_NAME_CHAR", "DNS name contains an invalid character." },
    { 9561, "DNS_ERROR_NUMERIC_NAME", "DNS name is entirely numeric." },
    { 9601, "DNS_ERROR_ZONE_DOES_NOT_EXIST", "DNS zone does not exist." },
    { 9602, "DNS_ERROR_NO_ZONE_INFO", "DNS zone information not available." },
    { 9603, "DNS_ERROR_INVALID_ZONE_OPERATION", "Invalid operation for DNS zone." },
    { 9604, "DNS_ERROR_ZONE_CONFIGURATION_ERROR", "Invalid DNS zone configuration." },
    { 9605, "DNS_ERROR_ZONE_HAS_NO_SOA_RECORD", "DNS zone has no start of authority (SOA) record." },
    { 9606, "DNS_ERROR_ZONE_HAS_NO_NS_RECORDS", "DNS zone has no Name Server (NS) record." },
    { 9607, "DNS_ERROR_ZONE_LOCKED", "DNS zone is locked." },
    { 9608, "DNS_ERROR_ZONE_CREATION_FAILED", "DNS zone creation failed." },
    { 9609, "DNS_ERROR_ZONE_ALREADY_EXISTS", "DNS zone already exists." },
    { 9610, "DNS_ERROR_AUTOZONE_ALREADY_EXISTS", "DNS automatic zone already exists." },
    { 9611, "DNS_ERROR_INVALID_ZONE_TYPE", "Invalid DNS zone type." },
    { 9612, "DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP", "Secondary DNS zone requires master IP address." },
    { 9613, "DNS_ERROR_ZONE_NOT_SECONDARY", "DNS zone not secondary." },
    { 9614, "DNS_ERROR_NEED_SECONDARY_ADDRESSES", "Need secondary IP address." },
    { 9615, "DNS_ERROR_WINS_INIT_FAILED", "WINS initialization failed." },
    { 9616, "DNS_ERROR_NEED_WINS_SERVERS", "Need WINS servers." },
    { 9617, "DNS_ERROR_NBSTAT_INIT_FAILED", "NBTSTAT initialization call failed." },
    { 9618, "DNS_ERROR_SOA_DELETE_INVALID", "Invalid delete of start of authority (SOA)" },
    { 9651, "DNS_ERROR_PRIMARY_REQUIRES_DATAFILE", "Primary DNS zone requires datafile." },
    { 9652, "DNS_ERROR_INVALID_DATAFILE_NAME", "Invalid datafile name for DNS zone." },
    { 9653, "DNS_ERROR_DATAFILE_OPEN_FAILURE", "Failed to open datafile for DNS zone." },
    { 9654, "DNS_ERROR_FILE_WRITEBACK_FAILED", "Failed to write datafile for DNS zone." },
    { 9655, "DNS_ERROR_DATAFILE_PARSING", "Failure while reading datafile for DNS zone." },
    { 9701, "DNS_ERROR_RECORD_DOES_NOT_EXIST", "DNS record does not exist." },
    { 9702, "DNS_ERROR_RECORD_FORMAT", "DNS record format error." },
    { 9703, "DNS_ERROR_NODE_CREATION_FAILED", "Node creation failure in DNS." },
    { 9704, "DNS_ERROR_UNKNOWN_RECORD_TYPE", "Unknown DNS record type." },
    { 9705, "DNS_ERROR_RECORD_TIMED_OUT", "DNS record timed out." },
    { 9706, "DNS_ERROR_NAME_NOT_IN_ZONE", "Name not in DNS zone." },
    { 9707, "DNS_ERROR_CNAME_LOOP", "CNAME loop detected." },
    { 9708, "DNS_ERROR_NODE_IS_CNAME", "Node is a CNAME DNS record." },
    { 9709, "DNS_ERROR_CNAME_COLLISION", "A CNAME record already exists for given name." },
    { 9710, "DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT", "Record only at DNS zone root." },
    { 9711, "DNS_ERROR_RECORD_ALREADY_EXISTS", "DNS record already exists." },
    { 9712, "DNS_ERROR_SECONDARY_DATA", "Secondary DNS zone data error." },
    { 9713, "DNS_ERROR_NO_CREATE_CACHE_DATA", "Could not create DNS cache data." },
    { 9714, "DNS_ERROR_NAME_DOES_NOT_EXIST", "DNS name does not exist." },
    { 9715, "DNS_WARNING_PTR_CREATE_FAILED", "Could not create pointer (PTR) record." },
    { 9716, "DNS_WARNING_DOMAIN_UNDELETED", "DNS domain was undeleted." },
    { 9717, "DNS_ERROR_DS_UNAVAILABLE", "The directory service is unavailable." },
    { 9718, "DNS_ERROR_DS_ZONE_ALREADY_EXISTS", "DNS zone already exists in the directory service." },
    { 9719, "DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE", "DNS server not creating or reading the boot file for the directory service integrated DNS zone." },
    { 9751, "DNS_INFO_AXFR_COMPLETE", "DNS AXFR (zone transfer) complete." },
    { 9752, "DNS_ERROR_AXFR", "DNS zone transfer failed." },
    { 9753, "DNS_INFO_ADDED_LOCAL_WINS", "Added local WINS server." },
    { 9801, "DNS_STATUS_CONTINUE_NEEDED", "Secure update call needs to continue update request." },
    { 9851, "DNS_ERROR_NO_TCPIP", "TCP/IP network protocol not installed." },
    { 9852, "DNS_ERROR_NO_DNS_SERVERS", "No DNS servers configured for local system." },
    { 10004, "WSAEINTR", "A blocking operation was interrupted by a call to WSACancelBlockingCall." },
    { 10009, "WSAEBADF", "The file handle supplied is not valid." },
    { 10013, "WSAEACCES", "An attempt was made to access a socket in a way forbidden by its access permissions." },
    { 10014, "WSAEFAULT", "The system detected an invalid pointer address in attempting to use a pointer argument in a call." },
    { 10022, "WSAEINVAL", "An invalid argument was supplied." },
    { 10024, "WSAEMFILE", "Too many open sockets." },
    { 10035, "WSAEWOULDBLOCK", "A non-blocking socket operation could not be completed immediately." },
    { 10036, "WSAEINPROGRESS", "A blocking operation is currently executing." },
    { 10037, "WSAEALREADY", "An operation was attempted on a non-blocking socket that already had an operation in progress." },
    { 10038, "WSAENOTSOCK", "An operation was attempted on something that is not a socket." },
    { 10039, "WSAEDESTADDRREQ", "A required address was omitted from an operation on a socket." },
    { 10040, "WSAEMSGSIZE", "A message sent on a datagram socket was larger than the internal message buffer or some other network limit, or the buffer used to receive a datagram into was smaller than the datagram itself." },
    { 10041, "WSAEPROTOTYPE", "A protocol was specified in the socket function call that does not support the semantics of the socket type requested." },
    { 10042, "WSAENOPROTOOPT", "An unknown, invalid, or unsupported option or level was specified in a getsockopt or setsockopt call." },
    { 10043, "WSAEPROTONOSUPPORT", "The requested protocol has not been configured into the system, or no implementation for it exists." },
    { 10044, "WSAESOCKTNOSUPPORT", "The support for the specified socket type does not exist in this address family." },
    { 10045, "WSAEOPNOTSUPP", "The attempted operation is not supported for the type of object referenced." },
    { 10046, "WSAEPFNOSUPPORT", "The protocol family has not been configured into the system or no implementation for it exists." },
    { 10047, "WSAEAFNOSUPPORT", "An address incompatible with the requested protocol was used." },
    { 10048, "WSAEADDRINUSE", "Only one usage of each socket address (protocol/network address/port) is normally permitted." },
    { 10049, "WSAEADDRNOTAVAIL", "The requested address is not valid in its context." },
    { 10050, "WSAENETDOWN", "A socket operation encountered a dead network." },
    { 10051, "WSAENETUNREACH", "A socket operation was attempted to an unreachable network." },
    { 10052, "WSAENETRESET", "The connection has been broken due to keep-alive activity detecting a failure while the operation was in progress." },
    { 10053, "WSAECONNABORTED", "An established connection was aborted by the software in your host machine." },
    { 10054, "WSAECONNRESET", "An existing connection was forcibly closed by the remote host." },
    { 10055, "WSAENOBUFS", "An operation on a socket could not be performed because the system lacked sufficient buffer space or because a queue was full." },
    { 10056, "WSAEISCONN", "A connect request was made on an already connected socket." },
    { 10057, "WSAENOTCONN", "A request to send or receive data was disallowed because the socket is not connected and (when sending on a datagram socket using a sendto call) no address was supplied." },
    { 10058, "WSAESHUTDOWN", "A request to send or receive data was disallowed because the socket had already been shut down in that direction with a previous shutdown call." },
    { 10059, "WSAETOOMANYREFS", "Too many references to some kernel object." },
    { 10060, "WSAETIMEDOUT", "A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond." },
    { 10061, "WSAECONNREFUSED", "No connection could be made because the target machine actively refused it." },
    { 10062, "WSAELOOP", "Cannot translate name." },
    { 10063, "WSAENAMETOOLONG", "Name component or name was too long." },
    { 10064, "WSAEHOSTDOWN", "A socket operation failed because the destination host was down." },
    { 10065, "WSAEHOSTUNREACH", "A socket operation was attempted to an unreachable host." },
    { 10066, "WSAENOTEMPTY", "Cannot remove a directory that is not empty." },
    { 10067, "WSAEPROCLIM", "A Windows Sockets implementation may have a limit on the number of applications that may use it simultaneously." },
    { 10068, "WSAEUSERS", "Ran out of quota." },
    { 10069, "WSAEDQUOT", "Ran out of disk quota." },
    { 10070, "WSAESTALE", "File handle reference is no longer available." },
    { 10071, "WSAEREMOTE", "Item is not available locally." },
    { 10091, "WSASYSNOTREADY", "WSAStartup cannot function at this time because the underlying system it uses to provide network services is currently unavailable." },
    { 10092, "WSAVERNOTSUPPORTED", "The Windows Sockets version requested is not supported." },
    { 10093, "WSANOTINITIALISED", "Either the application has not called WSAStartup, or WSAStartup failed." },
    { 10101, "WSAEDISCON", "Returned by WSARecv or WSARecvFrom to indicate the remote party has initiated a graceful shutdown sequence." },
    { 10102, "WSAENOMORE", "No more results can be returned by WSALookupServiceNext." },
    { 10103, "WSAECANCELLED", "A call to WSALookupServiceEnd was made while this call was still processing. The call has been canceled." },
    { 10104, "WSAEINVALIDPROCTABLE", "The procedure call table is invalid." },
    { 10105, "WSAEINVALIDPROVIDER", "The requested service provider is invalid." },
    { 10106, "WSAEPROVIDERFAILEDINIT", "The requested service provider could not be loaded or initialized." },
    { 10107, "WSASYSCALLFAILURE", "A system call that should never fail has failed." },
    { 10108, "WSASERVICE_NOT_FOUND", "No such service is known. The service cannot be found in the specified name space." },
    { 10109, "WSATYPE_NOT_FOUND", "The specified class was not found." },
    { 10110, "WSA_E_NO_MORE", "No more results can be returned by WSALookupServiceNext." },
    { 10111, "WSA_E_CANCELLED", "A call to WSALookupServiceEnd was made while this call was still processing. The call has been canceled." },
    { 10112, "WSAEREFUSED", "A database query failed because it was actively refused." },
    { 11001, "WSAHOST_NOT_FOUND", "No such host is known." },
    { 11002, "WSATRY_AGAIN", "This is usually a temporary error during hostname resolution and means that the local server did not receive a response from an authoritative server." },
    { 11003, "WSANO_RECOVERY", "A non-recoverable error occurred during a database lookup." },
    { 11004, "WSANO_DATA", "The requested name is valid and was found in the database, but it does not have the correct associated data being resolved for." },
    { 11005, "WSA_QOS_RECEIVERS", "At least one reserve has arrived." },
    { 11006, "WSA_QOS_SENDERS", "At least one path has arrived." },
    { 11007, "WSA_QOS_NO_SENDERS", "There are no senders." },
    { 11008, "WSA_QOS_NO_RECEIVERS", "There are no receivers." },
    { 11009, "WSA_QOS_REQUEST_CONFIRMED", "Reserve has been confirmed." },
    { 11010, "WSA_QOS_ADMISSION_FAILURE", "Error due to lack of resources." },
    { 11011, "WSA_QOS_POLICY_FAILURE", "Rejected for administrative reasons - bad credentials." },
    { 11012, "WSA_QOS_BAD_STYLE", "Unknown or conflicting style." },
    { 11013, "WSA_QOS_BAD_OBJECT", "Problem with some part of the filterspec or providerspecific buffer in general." },
    { 11014, "WSA_QOS_TRAFFIC_CTRL_ERROR", "Problem with some part of the flowspec." },
    { 11015, "WSA_QOS_GENERIC_ERROR", "General QOS error." },
    { 11016, "WSA_QOS_ESERVICETYPE", "An invalid or unrecognized service type was found in the flowspec." },
    { 11017, "WSA_QOS_EFLOWSPEC", "An invalid or inconsistent flowspec was found in the QOS structure." },
    { 11018, "WSA_QOS_EPROVSPECBUF", "Invalid QOS provider-specific buffer." },
    { 11019, "WSA_QOS_EFILTERSTYLE", "An invalid QOS filter style was used." },
    { 11020, "WSA_QOS_EFILTERTYPE", "An invalid QOS filter type was used." },
    { 11021, "WSA_QOS_EFILTERCOUNT", "An incorrect number of QOS FILTERSPECs were specified in the FLOWDESCRIPTOR." },
    { 11022, "WSA_QOS_EOBJLENGTH", "An object with an invalid ObjectLength field was specified in the QOS provider-specific buffer." },
    { 11023, "WSA_QOS_EFLOWCOUNT", "An incorrect number of flow descriptors was specified in the QOS structure." },
    { 11024, "WSA_QOS_EUNKOWNPSOBJ", "An unrecognized object was found in the QOS provider-specific buffer." },
    { 11025, "WSA_QOS_EPOLICYOBJ", "An invalid policy object was found in the QOS provider-specific buffer." },
    { 11026, "WSA_QOS_EFLOWDESC", "An invalid QOS flow descriptor was found in the flow descriptor list." },
    { 11027, "WSA_QOS_EPSFLOWSPEC", "An invalid or inconsistent flowspec was found in the QOS provider specific buffer." },
    { 11028, "WSA_QOS_EPSFILTERSPEC", "An invalid FILTERSPEC was found in the QOS provider-specific buffer." },
    { 11029, "WSA_QOS_ESDMODEOBJ", "An invalid shape discard mode object was found in the QOS provider specific buffer." },
    { 11030, "WSA_QOS_ESHAPERATEOBJ", "An invalid shaping rate object was found in the QOS provider-specific buffer." },
    { 11031, "WSA_QOS_RESERVED_PETYPE", "A reserved policy element was found in the QOS provider-specific buffer." },
    { 197120, "STG_S_CONVERTED", "The underlying file was converted to compound file format." },
    { 197121, "STG_S_BLOCK", "The storage operation should block until more data is available." },
    { 197122, "STG_S_RETRYNOW", "The storage operation should retry immediately." },
    { 197123, "STG_S_MONITORING", "The notified event sink will not influence the storage operation." },
    { 197124, "STG_S_MULTIPLEOPENS", "Multiple opens prevent consolidated. (commit succeeded)." },
    { 197125, "STG_S_CONSOLIDATIONFAILED", "Consolidation of the storage file failed. (commit succeeded)." },
    { 197126, "STG_S_CANNOTCONSOLIDATE", "Consolidation of the storage file is inappropriate. (commit succeeded)." },
    { 262144, "OLE_S_USEREG", "Use the registry database to provide the requested information" },
    { 262145, "OLE_S_STATIC", "Success, but static" },
    { 262146, "OLE_S_MAC_CLIPFORMAT", "Macintosh clipboard format" },
    { 262400, "DRAGDROP_S_DROP", "Successful drop took place" },
    { 262401, "DRAGDROP_S_CANCEL", "Drag-drop operation canceled" },
    { 262402, "DRAGDROP_S_USEDEFAULTCURSORS", "Use the default cursor" },
    { 262448, "DATA_S_SAMEFORMATETC", "Data has same FORMATETC" },
    { 262464, "VIEW_S_ALREADY_FROZEN", "View is already frozen" },
    { 262512, "CACHE_S_FORMATETC_NOTSUPPORTED", "FORMATETC not supported" },
    { 262513, "CACHE_S_SAMECACHE", "Same cache" },
    { 262514, "CACHE_S_SOMECACHES_NOTUPDATED", "Some cache(s) not updated" },
    { 262528, "OLEOBJ_S_INVALIDVERB", "Invalid verb for OLE object" },
    { 262529, "OLEOBJ_S_CANNOT_DOVERB_NOW", "Verb number is valid but verb cannot be done now" },
    { 262530, "OLEOBJ_S_INVALIDHWND", "Invalid window handle passed" },
    { 262560, "INPLACE_S_TRUNCATED", "Message is too long; some of it had to be truncated before displaying" },
    { 262592, "CONVERT10_S_NO_PRESENTATION", "Unable to convert OLESTREAM to IStorage" },
    { 262626, "MK_S_REDUCED_TO_SELF", "Moniker reduced to itself" },
    { 262628, "MK_S_ME", "Common prefix is this moniker" },
    { 262629, "MK_S_HIM", "Common prefix is input moniker" },
    { 262630, "MK_S_US", "Common prefix is both monikers" },
    { 262631, "MK_S_MONIKERALREADYREGISTERED", "Moniker is already registered in running object table" },
    { 262656, "EVENT_S_SOME_SUBSCRIBERS_FAILED", "An event was able to invoke some but not all of the subscribers" },
    { 262658, "EVENT_S_NOSUBSCRIBERS", "An event was delivered but there were no subscribers" },
    { 267008, "SCHED_S_TASK_READY", "The task is ready to run at its next scheduled time." },
    { 267009, "SCHED_S_TASK_RUNNING", "The task is currently running." },
    { 267010, "SCHED_S_TASK_DISABLED", "The task will not run at the scheduled times because it has been disabled." },
    { 267011, "SCHED_S_TASK_HAS_NOT_RUN", "The task has not yet run." },
    { 267012, "SCHED_S_TASK_NO_MORE_RUNS", "There are no more runs scheduled for this task." },
    { 267013, "SCHED_S_TASK_NOT_SCHEDULED", "One or more of the properties that are needed to run this task on a schedule have not been set." },
    { 267014, "SCHED_S_TASK_TERMINATED", "The last run of the task was terminated by the user." },
    { 267015, "SCHED_S_TASK_NO_VALID_TRIGGERS", "Either the task has no triggers or the existing triggers are disabled or not set." },
    { 267016, "SCHED_S_EVENT_TRIGGER", "Event triggers don't have set run times." },
    { 524306, "CO_S_NOTALLINTERFACES", "Not all the requested interfaces were available" },
    { 590610, "SEC_I_CONTINUE_NEEDED", "The function completed successfully, but must be called again to complete the context" },
    { 590611, "SEC_I_COMPLETE_NEEDED", "The function completed successfully, but CompleteToken must be called" },
    { 590612, "SEC_I_COMPLETE_AND_CONTINUE", "The function completed successfully, but both CompleteToken and this function must be called to complete the context" },
    { 590613, "SEC_I_LOCAL_LOGON", "The logon was completed, but no network authority was available. The logon was made using locally known information" },
    { 590624, "SEC_I_INCOMPLETE_CREDENTIALS", "The credentials supplied were not complete, and could not be verified. Additional information can be returned from the context." },
    { 590625, "SEC_I_RENEGOTIATE", "The context data must be renegotiated with the peer." },
    { 590627, "SEC_I_NO_LSA_CONTEXT", "There is no LSA mode context associated with this context." },
    { 2147483649, "E_NOTIMPL", "Not implemented" },
    { 2147483650, "E_OUTOFMEMORY", "Ran out of memory" },
    { 2147483651, "E_INVALIDARG", "One or more arguments are invalid" },
    { 2147483652, "E_NOINTERFACE", "No such interface supported" },
    { 2147483653, "E_POINTER", "Invalid pointer" },
    { 2147483654, "E_HANDLE", "Invalid handle" },
    { 2147483655, "E_ABORT", "Operation aborted" },
    { 2147483656, "E_FAIL", "Unspecified error" },
    { 2147483657, "E_ACCESSDENIED", "General access denied error" },
    { 2147483658, "E_PENDING", "The data necessary to complete this operation is not yet available." },
    { 2147500033, "E_NOTIMPL", "Not implemented" },
    { 2147500034, "E_NOINTERFACE", "No such interface supported" },
    { 2147500035, "E_POINTER", "Invalid pointer" },
    { 2147500036, "E_ABORT", "Operation aborted" },
    { 2147500037, "E_FAIL", "Unspecified error" },
    { 2147500038, "CO_E_INIT_TLS", "Thread local storage failure" },
    { 2147500039, "CO_E_INIT_SHARED_ALLOCATOR", "Get shared memory allocator failure" },
    { 2147500040, "CO_E_INIT_MEMORY_ALLOCATOR", "Get memory allocator failure" },
    { 2147500041, "CO_E_INIT_CLASS_CACHE", "Unable to initialize class cache" },
    { 2147500042, "CO_E_INIT_RPC_CHANNEL", "Unable to initialize RPC services" },
    { 2147500043, "CO_E_INIT_TLS_SET_CHANNEL_CONTROL", "Cannot set thread local storage channel control" },
    { 2147500044, "CO_E_INIT_TLS_CHANNEL_CONTROL", "Could not allocate thread local storage channel control" },
    { 2147500045, "CO_E_INIT_UNACCEPTED_USER_ALLOCATOR", "The user supplied memory allocator is unacceptable" },
    { 2147500046, "CO_E_INIT_SCM_MUTEX_EXISTS", "The OLE service mutex already exists" },
    { 2147500047, "CO_E_INIT_SCM_FILE_MAPPING_EXISTS", "The OLE service file mapping already exists" },
    { 2147500048, "CO_E_INIT_SCM_MAP_VIEW_OF_FILE", "Unable to map view of file for OLE service" },
    { 2147500049, "CO_E_INIT_SCM_EXEC_FAILURE", "Failure attempting to launch OLE service" },
    { 2147500050, "CO_E_INIT_ONLY_SINGLE_THREADED", "There was an attempt to call CoInitialize a second time while single threaded" },
    { 2147500051, "CO_E_CANT_REMOTE", "A Remote activation was necessary but was not allowed" },
    { 2147500052, "CO_E_BAD_SERVER_NAME", "A Remote activation was necessary but the server name provided was invalid" },
    { 2147500053, "CO_E_WRONG_SERVER_IDENTITY", "The class is configured to run as a security id different from the caller" },
    { 2147500054, "CO_E_OLE1DDE_DISABLED", "Use of Ole1 services requiring DDE windows is disabled" },
    { 2147500055, "CO_E_RUNAS_SYNTAX", "A RunAs specification must be <domain name>/<user name> or simply <user name>" },
    { 2147500056, "CO_E_CREATEPROCESS_FAILURE", "The server process could not be started.  The pathname may be incorrect." },
    { 2147500057, "CO_E_RUNAS_CREATEPROCESS_FAILURE", "The server process could not be started as the configured identity.  The pathname may be incorrect or unavailable." },
    { 2147500058, "CO_E_RUNAS_LOGON_FAILURE", "The server process could not be started because the configured identity is incorrect.  Check the username and password." },
    { 2147500059, "CO_E_LAUNCH_PERMSSION_DENIED", "The client is not allowed to launch this server." },
    { 2147500060, "CO_E_START_SERVICE_FAILURE", "The service providing this server could not be started." },
    { 2147500061, "CO_E_REMOTE_COMMUNICATION_FAILURE", "This computer was unable to communicate with the computer providing the server." },
    { 2147500062, "CO_E_SERVER_START_TIMEOUT", "The server did not respond after being launched." },
    { 2147500063, "CO_E_CLSREG_INCONSISTENT", "The registration information for this server is inconsistent or incomplete." },
    { 2147500064, "CO_E_IIDREG_INCONSISTENT", "The registration information for this interface is inconsistent or incomplete." },
    { 2147500065, "CO_E_NOT_SUPPORTED", "The operation attempted is not supported." },
    { 2147500066, "CO_E_RELOAD_DLL", "A dll must be loaded." },
    { 2147500067, "CO_E_MSI_ERROR", "A Microsoft Software Installer error was encountered." },
    { 2147500068, "CO_E_ATTEMPT_TO_CREATE_OUTSIDE_CLIENT_CONTEXT", "The specified activation could not occur in the client context as specified." },
    { 2147549183, "E_UNEXPECTED", "Catastrophic failure" },
    { 2147549185, "RPC_E_CALL_REJECTED", "Call was rejected by callee." },
    { 2147549186, "RPC_E_CALL_CANCELED", "Call was canceled by the message filter." },
    { 2147549187, "RPC_E_CANTPOST_INSENDCALL", "The caller is dispatching an intertask SendMessage call and cannot call out via PostMessage." },
    { 2147549188, "RPC_E_CANTCALLOUT_INASYNCCALL", "The caller is dispatching an asynchronous call and cannot make an outgoing call on behalf of this call." },
    { 2147549189, "RPC_E_CANTCALLOUT_INEXTERNALCALL", "It is illegal to call out while inside message filter." },
    { 2147549190, "RPC_E_CONNECTION_TERMINATED", "The connection terminated or is in a bogus state and cannot be used any more. Other connections are still valid." },
    { 2147549191, "RPC_E_SERVER_DIED", "The callee (server [not server application]) is not available and disappeared; all connections are invalid. The call may have executed." },
    { 2147549192, "RPC_E_CLIENT_DIED", "The caller (client) disappeared while the callee (server) was processing a call." },
    { 2147549193, "RPC_E_INVALID_DATAPACKET", "The data packet with the marshalled parameter data is incorrect." },
    { 2147549194, "RPC_E_CANTTRANSMIT_CALL", "The call was not transmitted properly; the message queue was full and was not emptied after yielding." },
    { 2147549195, "RPC_E_CLIENT_CANTMARSHAL_DATA", "The client (caller) cannot marshall the parameter data - low memory, etc." },
    { 2147549196, "RPC_E_CLIENT_CANTUNMARSHAL_DATA", "The client (caller) cannot unmarshall the return data - low memory, etc." },
    { 2147549197, "RPC_E_SERVER_CANTMARSHAL_DATA", "The server (callee) cannot marshall the return data - low memory, etc." },
    { 2147549198, "RPC_E_SERVER_CANTUNMARSHAL_DATA", "The server (callee) cannot unmarshall the parameter data - low memory, etc." },
    { 2147549199, "RPC_E_INVALID_DATA", "Received data is invalid; could be server or client data." },
    { 2147549200, "RPC_E_INVALID_PARAMETER", "A particular parameter is invalid and cannot be (un)marshalled." },
    { 2147549201, "RPC_E_CANTCALLOUT_AGAIN", "There is no second outgoing call on same channel in DDE conversation." },
    { 2147549202, "RPC_E_SERVER_DIED_DNE", "The callee (server [not server application]) is not available and disappeared; all connections are invalid. The call did not execute." },
    { 2147549440, "RPC_E_SYS_CALL_FAILED", "System call failed." },
    { 2147549441, "RPC_E_OUT_OF_RESOURCES", "Could not allocate some required resource (memory, events, ...)" },
    { 2147549442, "RPC_E_ATTEMPTED_MULTITHREAD", "Attempted to make calls on more than one thread in single threaded mode." },
    { 2147549443, "RPC_E_NOT_REGISTERED", "The requested interface is not registered on the server object." },
    { 2147549444, "RPC_E_FAULT", "RPC could not call the server or could not return the results of calling the server." },
    { 2147549445, "RPC_E_SERVERFAULT", "The server threw an exception." },
    { 2147549446, "RPC_E_CHANGED_MODE", "Cannot change thread mode after it is set." },
    { 2147549447, "RPC_E_INVALIDMETHOD", "The method called does not exist on the server." },
    { 2147549448, "RPC_E_DISCONNECTED", "The object invoked has disconnected from its clients." },
    { 2147549449, "RPC_E_RETRY", "The object invoked chose not to process the call now.  Try again later." },
    { 2147549450, "RPC_E_SERVERCALL_RETRYLATER", "The message filter indicated that the application is busy." },
    { 2147549451, "RPC_E_SERVERCALL_REJECTED", "The message filter rejected the call." },
    { 2147549452, "RPC_E_INVALID_CALLDATA", "A call control interfaces was called with invalid data." },
    { 2147549453, "RPC_E_CANTCALLOUT_ININPUTSYNCCALL", "An outgoing call cannot be made since the application is dispatching an input-synchronous call." },
    { 2147549454, "RPC_E_WRONG_THREAD", "The application called an interface that was marshalled for a different thread." },
    { 2147549455, "RPC_E_THREAD_NOT_INIT", "CoInitialize has not been called on the current thread." },
    { 2147549456, "RPC_E_VERSION_MISMATCH", "The version of OLE on the client and server machines does not match." },
    { 2147549457, "RPC_E_INVALID_HEADER", "OLE received a packet with an invalid header." },
    { 2147549458, "RPC_E_INVALID_EXTENSION", "OLE received a packet with an invalid extension." },
    { 2147549459, "RPC_E_INVALID_IPID", "The requested object or interface does not exist." },
    { 2147549460, "RPC_E_INVALID_OBJECT", "The requested object does not exist." },
    { 2147549461, "RPC_S_CALLPENDING", "OLE has sent a request and is waiting for a reply." },
    { 2147549462, "RPC_S_WAITONTIMER", "OLE is waiting before retrying a request." },
    { 2147549463, "RPC_E_CALL_COMPLETE", "Call context cannot be accessed after call completed." },
    { 2147549464, "RPC_E_UNSECURE_CALL", "Impersonate on unsecure calls is not supported." },
    { 2147549465, "RPC_E_TOO_LATE", "Security must be initialized before any interfaces are marshalled or unmarshalled. It cannot be changed once initialized." },
    { 2147549466, "RPC_E_NO_GOOD_SECURITY_PACKAGES", "No security packages are installed on this machine or the user is not logged on or there are no compatible security packages between the client and server." },
    { 2147549467, "RPC_E_ACCESS_DENIED", "Access is denied." },
    { 2147549468, "RPC_E_REMOTE_DISABLED", "Remote calls are not allowed for this process." },
    { 2147549469, "RPC_E_INVALID_OBJREF", "The marshaled interface data packet (OBJREF) has an invalid or unknown format." },
    { 2147549470, "RPC_E_NO_CONTEXT", "No context is associated with this call. This happens for some custom marshalled calls and on the client side of the call." },
    { 2147549471, "RPC_E_TIMEOUT", "This operation returned because the timeout period expired." },
    { 2147549472, "RPC_E_NO_SYNC", "There are no synchronize objects to wait on." },
    { 2147549473, "RPC_E_FULLSIC_REQUIRED", "Full subject issuer chain SSL principal name expected from the server." },
    { 2147549474, "RPC_E_INVALID_STD_NAME", "Principal name is not a valid MSSTD name." },
    { 2147549475, "CO_E_FAILEDTOIMPERSONATE", "Unable to impersonate DCOM client" },
    { 2147549476, "CO_E_FAILEDTOGETSECCTX", "Unable to obtain server's security context" },
    { 2147549477, "CO_E_FAILEDTOOPENTHREADTOKEN", "Unable to open the access token of the current thread" },
    { 2147549478, "CO_E_FAILEDTOGETTOKENINFO", "Unable to obtain user info from an access token" },
    { 2147549479, "CO_E_TRUSTEEDOESNTMATCHCLIENT", "The client who called IAccessControl::IsAccessPermitted was not the trustee provided to the method" },
    { 2147549480, "CO_E_FAILEDTOQUERYCLIENTBLANKET", "Unable to obtain the client's security blanket" },
    { 2147549481, "CO_E_FAILEDTOSETDACL", "Unable to set a discretionary ACL into a security descriptor" },
    { 2147549482, "CO_E_ACCESSCHECKFAILED", "The system function, AccessCheck, returned false" },
    { 2147549483, "CO_E_NETACCESSAPIFAILED", "Either NetAccessDel or NetAccessAdd returned an error code." },
    { 2147549484, "CO_E_WRONGTRUSTEENAMESYNTAX", "One of the trustee strings provided by the user did not conform to the <Domain>/<Name> syntax and it was not the '*' string" },
    { 2147549485, "CO_E_INVALIDSID", "One of the security identifiers provided by the user was invalid" },
    { 2147549486, "CO_E_CONVERSIONFAILED", "Unable to convert a wide character trustee string to a multibyte trustee string" },
    { 2147549487, "CO_E_NOMATCHINGSIDFOUND", "Unable to find a security identifier that corresponds to a trustee string provided by the user" },
    { 2147549488, "CO_E_LOOKUPACCSIDFAILED", "The system function, LookupAccountSID, failed" },
    { 2147549489, "CO_E_NOMATCHINGNAMEFOUND", "Unable to find a trustee name that corresponds to a security identifier provided by the user" },
    { 2147549490, "CO_E_LOOKUPACCNAMEFAILED", "The system function, LookupAccountName, failed" },
    { 2147549491, "CO_E_SETSERLHNDLFAILED", "Unable to set or reset a serialization handle" },
    { 2147549492, "CO_E_FAILEDTOGETWINDIR", "Unable to obtain the Windows directory" },
    { 2147549493, "CO_E_PATHTOOLONG", "Path too long" },
    { 2147549494, "CO_E_FAILEDTOGENUUID", "Unable to generate a uuid." },
    { 2147549495, "CO_E_FAILEDTOCREATEFILE", "Unable to create file" },
    { 2147549496, "CO_E_FAILEDTOCLOSEHANDLE", "Unable to close a serialization handle or a file handle." },
    { 2147549497, "CO_E_EXCEEDSYSACLLIMIT", "The number of ACEs in an ACL exceeds the system limit." },
    { 2147549498, "CO_E_ACESINWRONGORDER", "Not all the DENY_ACCESS ACEs are arranged in front of the GRANT_ACCESS ACEs in the stream." },
    { 2147549499, "CO_E_INCOMPATIBLESTREAMVERSION", "The version of ACL format in the stream is not supported by this implementation of IAccessControl" },
    { 2147549500, "CO_E_FAILEDTOOPENPROCESSTOKEN", "Unable to open the access token of the server process" },
    { 2147549501, "CO_E_DECODEFAILED", "Unable to decode the ACL in the stream provided by the user" },
    { 2147549503, "CO_E_ACNOTINITIALIZED", "The COM IAccessControl object is not initialized" },
    { 2147549504, "CO_E_CANCEL_DISABLED", "Call Cancellation is disabled" },
    { 2147614719, "RPC_E_UNEXPECTED", "An internal error occurred." },
    { 2147614721, "DISP_E_UNKNOWNINTERFACE", "Unknown interface." },
    { 2147614723, "DISP_E_MEMBERNOTFOUND", "Member not found." },
    { 2147614724, "DISP_E_PARAMNOTFOUND", "Parameter not found." },
    { 2147614725, "DISP_E_TYPEMISMATCH", "Type mismatch." },
    { 2147614726, "DISP_E_UNKNOWNNAME", "Unknown name." },
    { 2147614727, "DISP_E_NONAMEDARGS", "No named arguments." },
    { 2147614728, "DISP_E_BADVARTYPE", "Bad variable type." },
    { 2147614729, "DISP_E_EXCEPTION", "Exception occurred." },
    { 2147614730, "DISP_E_OVERFLOW", "Out of present range." },
    { 2147614731, "DISP_E_BADINDEX", "Invalid index." },
    { 2147614732, "DISP_E_UNKNOWNLCID", "Unknown language." },
    { 2147614733, "DISP_E_ARRAYISLOCKED", "Memory is locked." },
    { 2147614734, "DISP_E_BADPARAMCOUNT", "Invalid number of parameters." },
    { 2147614735, "DISP_E_PARAMNOTOPTIONAL", "Parameter not optional." },
    { 2147614736, "DISP_E_BADCALLEE", "Invalid callee." },
    { 2147614737, "DISP_E_NOTACOLLECTION", "Does not support a collection." },
    { 2147614738, "DISP_E_DIVBYZERO", "Division by zero." },
    { 2147614739, "DISP_E_BUFFERTOOSMALL", "Buffer too small" },
    { 2147647510, "TYPE_E_BUFFERTOOSMALL", "Buffer too small." },
    { 2147647511, "TYPE_E_FIELDNOTFOUND", "Field name not defined in the record." },
    { 2147647512, "TYPE_E_INVDATAREAD", "Old format or invalid type library." },
    { 2147647513, "TYPE_E_UNSUPFORMAT", "Old format or invalid type library." },
    { 2147647516, "TYPE_E_REGISTRYACCESS", "Error accessing the OLE registry." },
    { 2147647517, "TYPE_E_LIBNOTREGISTERED", "Library not registered." },
    { 2147647527, "TYPE_E_UNDEFINEDTYPE", "Bound to unknown type." },
    { 2147647528, "TYPE_E_QUALIFIEDNAMEDISALLOWED", "Qualified name disallowed." },
    { 2147647529, "TYPE_E_INVALIDSTATE", "Invalid forward reference, or reference to uncompiled type." },
    { 2147647530, "TYPE_E_WRONGTYPEKIND", "Type mismatch." },
    { 2147647531, "TYPE_E_ELEMENTNOTFOUND", "Element not found." },
    { 2147647532, "TYPE_E_AMBIGUOUSNAME", "Ambiguous name." },
    { 2147647533, "TYPE_E_NAMECONFLICT", "Name already exists in the library." },
    { 2147647534, "TYPE_E_UNKNOWNLCID", "Unknown LCID." },
    { 2147647535, "TYPE_E_DLLFUNCTIONNOTFOUND", "Function not defined in specified DLL." },
    { 2147649725, "TYPE_E_BADMODULEKIND", "Wrong module kind for the operation." },
    { 2147649733, "TYPE_E_SIZETOOBIG", "Size may not exceed 64K." },
    { 2147649734, "TYPE_E_DUPLICATEID", "Duplicate ID in inheritance hierarchy." },
    { 2147649743, "TYPE_E_INVALIDID", "Incorrect inheritance depth in standard OLE hmember." },
    { 2147650720, "TYPE_E_TYPEMISMATCH", "Type mismatch." },
    { 2147650721, "TYPE_E_OUTOFBOUNDS", "Invalid number of arguments." },
    { 2147650722, "TYPE_E_IOERROR", "I/O Error." },
    { 2147650723, "TYPE_E_CANTCREATETMPFILE", "Error creating unique tmp file." },
    { 2147654730, "TYPE_E_CANTLOADLIBRARY", "Error loading type library/DLL." },
    { 2147654787, "TYPE_E_INCONSISTENTPROPFUNCS", "Inconsistent property functions." },
    { 2147654788, "TYPE_E_CIRCULARTYPE", "Circular dependency between types/modules." },
    { 2147680257, "STG_E_INVALIDFUNCTION", "Unable to perform requested operation." },
    { 2147680258, "STG_E_FILENOTFOUND", "1 could not be found." },
    { 2147680259, "STG_E_PATHNOTFOUND", "The path %1 could not be found." },
    { 2147680260, "STG_E_TOOMANYOPENFILES", "There are insufficient resources to open another file." },
    { 2147680261, "STG_E_ACCESSDENIED", "Access Denied." },
    { 2147680262, "STG_E_INVALIDHANDLE", "Attempted an operation on an invalid object." },
    { 2147680264, "STG_E_INSUFFICIENTMEMORY", "There is insufficient memory available to complete operation." },
    { 2147680265, "STG_E_INVALIDPOINTER", "Invalid pointer error." },
    { 2147680274, "STG_E_NOMOREFILES", "There are no more entries to return." },
    { 2147680275, "STG_E_DISKISWRITEPROTECTED", "Disk is write-protected." },
    { 2147680281, "STG_E_SEEKERROR", "An error occurred during a seek operation." },
    { 2147680285, "STG_E_WRITEFAULT", "A disk error occurred during a write operation." },
    { 2147680286, "STG_E_READFAULT", "A disk error occurred during a read operation." },
    { 2147680288, "STG_E_SHAREVIOLATION", "A share violation has occurred." },
    { 2147680289, "STG_E_LOCKVIOLATION", "A lock violation has occurred." },
    { 2147680336, "STG_E_FILEALREADYEXISTS", "1 already exists." },
    { 2147680343, "STG_E_INVALIDPARAMETER", "Invalid parameter error." },
    { 2147680368, "STG_E_MEDIUMFULL", "There is insufficient disk space to complete operation." },
    { 2147680496, "STG_E_PROPSETMISMATCHED", "Illegal write of non-simple property to simple property set." },
    { 2147680506, "STG_E_ABNORMALAPIEXIT", "An API call exited abnormally." },
    { 2147680507, "STG_E_INVALIDHEADER", "The file %1 is not a valid compound file." },
    { 2147680508, "STG_E_INVALIDNAME", "The name %1 is not valid." },
    { 2147680509, "STG_E_UNKNOWN", "An unexpected error occurred." },
    { 2147680510, "STG_E_UNIMPLEMENTEDFUNCTION", "That function is not implemented." },
    { 2147680511, "STG_E_INVALIDFLAG", "Invalid flag error." },
    { 2147680512, "STG_E_INUSE", "Attempted to use an object that is busy." },
    { 2147680513, "STG_E_NOTCURRENT", "The storage has been changed since the last commit." },
    { 2147680514, "STG_E_REVERTED", "Attempted to use an object that has ceased to exist." },
    { 2147680515, "STG_E_CANTSAVE", "Can't save." },
    { 2147680516, "STG_E_OLDFORMAT", "The compound file %1 was produced with an incompatible version of storage." },
    { 2147680517, "STG_E_OLDDLL", "The compound file %1 was produced with a newer version of storage." },
    { 2147680518, "STG_E_SHAREREQUIRED", "Share.exe or equivalent is required for operation." },
    { 2147680519, "STG_E_NOTFILEBASEDSTORAGE", "Illegal operation called on non-file based storage." },
    { 2147680520, "STG_E_EXTANTMARSHALLINGS", "Illegal operation called on object with extant marshallings." },
    { 2147680521, "STG_E_DOCFILECORRUPT", "The docfile has been corrupted." },
    { 2147680528, "STG_E_BADBASEADDRESS", "OLE32.DLL has been loaded at the wrong address." },
    { 2147680529, "STG_E_DOCFILETOOLARGE", "The compound file is too large for the current implementation" },
    { 2147680530, "STG_E_NOTSIMPLEFORMAT", "The compound file was not created with the STGM_SIMPLE flag" },
    { 2147680769, "STG_E_INCOMPLETE", "The file download was aborted abnormally.  The file is incomplete." },
    { 2147680770, "STG_E_TERMINATED", "The file download has been terminated." },
    { 2147745792, "OLE_E_OLEVERB", "Invalid OLEVERB structure" },
    { 2147745793, "OLE_E_ADVF", "Invalid advise flags" },
    { 2147745794, "OLE_E_ENUM_NOMORE", "Can't enumerate any more, because the associated data is missing" },
    { 2147745795, "OLE_E_ADVISENOTSUPPORTED", "This implementation doesn't take advises" },
    { 2147745796, "OLE_E_NOCONNECTION", "There is no connection for this connection ID" },
    { 2147745797, "OLE_E_NOTRUNNING", "Need to run the object to perform this operation" },
    { 2147745798, "OLE_E_NOCACHE", "There is no cache to operate on" },
    { 2147745799, "OLE_E_BLANK", "Uninitialized object" },
    { 2147745800, "OLE_E_CLASSDIFF", "Linked object's source class has changed" },
    { 2147745801, "OLE_E_CANT_GETMONIKER", "Not able to get the moniker of the object" },
    { 2147745802, "OLE_E_CANT_BINDTOSOURCE", "Not able to bind to the source" },
    { 2147745803, "OLE_E_STATIC", "Object is static; operation not allowed" },
    { 2147745804, "OLE_E_PROMPTSAVECANCELLED", "User canceled out of save dialog" },
    { 2147745805, "OLE_E_INVALIDRECT", "Invalid rectangle" },
    { 2147745806, "OLE_E_WRONGCOMPOBJ", "compobj.dll is too old for the ole2.dll initialized" },
    { 2147745807, "OLE_E_INVALIDHWND", "Invalid window handle" },
    { 2147745808, "OLE_E_NOT_INPLACEACTIVE", "Object is not in any of the inplace active states" },
    { 2147745809, "OLE_E_CANTCONVERT", "Not able to convert object" },
    { 2147745810, "OLE_E_NOSTORAGE", "Not able to perform the operation because object is not given storage yet" },
    { 2147745892, "DV_E_FORMATETC", "Invalid FORMATETC structure" },
    { 2147745893, "DV_E_DVTARGETDEVICE", "Invalid DVTARGETDEVICE structure" },
    { 2147745894, "DV_E_STGMEDIUM", "Invalid STDGMEDIUM structure" },
    { 2147745895, "DV_E_STATDATA", "Invalid STATDATA structure" },
    { 2147745896, "DV_E_LINDEX", "Invalid lindex" },
    { 2147745897, "DV_E_TYMED", "Invalid tymed" },
    { 2147745898, "DV_E_CLIPFORMAT", "Invalid clipboard format" },
    { 2147745899, "DV_E_DVASPECT", "Invalid aspect(s)" },
    { 2147745900, "DV_E_DVTARGETDEVICE_SIZE", "tdSize parameter of the DVTARGETDEVICE structure is invalid" },
    { 2147745901, "DV_E_NOIVIEWOBJECT", "Object doesn't support IViewObject interface" },
    { 2147746048, "DRAGDROP_E_NOTREGISTERED", "Trying to revoke a drop target that has not been registered" },
    { 2147746049, "DRAGDROP_E_ALREADYREGISTERED", "This window has already been registered as a drop target" },
    { 2147746050, "DRAGDROP_E_INVALIDHWND", "Invalid window handle" },
    { 2147746064, "CLASS_E_NOAGGREGATION", "Class does not support aggregation (or class object is remote)" },
    { 2147746065, "CLASS_E_CLASSNOTAVAILABLE", "ClassFactory cannot supply requested class" },
    { 2147746066, "CLASS_E_NOTLICENSED", "Class is not licensed for use" },
    { 2147746112, "VIEW_E_DRAW", "Error drawing view" },
    { 2147746128, "REGDB_E_READREGDB", "Could not read key from registry" },
    { 2147746129, "REGDB_E_WRITEREGDB", "Could not write key to registry" },
    { 2147746130, "REGDB_E_KEYMISSING", "Could not find the key in the registry" },
    { 2147746131, "REGDB_E_INVALIDVALUE", "Invalid value for registry" },
    { 2147746132, "REGDB_E_CLASSNOTREG", "Class not registered" },
    { 2147746133, "REGDB_E_IIDNOTREG", "Interface not registered" },
    { 2147746134, "REGDB_E_BADTHREADINGMODEL", "Threading model entry is not valid" },
    { 2147746144, "CAT_E_CATIDNOEXIST", "CATID does not exist" },
    { 2147746145, "CAT_E_NODESCRIPTION", "Description not found" },
    { 2147746148, "CS_E_PACKAGE_NOTFOUND", "No package in the software installation data in the Active Directory meets this criteria." },
    { 2147746149, "CS_E_NOT_DELETABLE", "Deleting this will break the referential integrity of the software installation data in the Active Directory." },
    { 2147746150, "CS_E_CLASS_NOTFOUND", "The CLSID was not found in the software installation data in the Active Directory." },
    { 2147746151, "CS_E_INVALID_VERSION", "The software installation data in the Active Directory is corrupt." },
    { 2147746152, "CS_E_NO_CLASSSTORE", "There is no software installation data in the Active Directory." },
    { 2147746153, "CS_E_OBJECT_NOTFOUND", "There is no software installation data object in the Active Directory." },
    { 2147746154, "CS_E_OBJECT_ALREADY_EXISTS", "The software installation data object in the Active Directory already exists." },
    { 2147746155, "CS_E_INVALID_PATH", "The path to the software installation data in the Active Directory is not correct." },
    { 2147746156, "CS_E_NETWORK_ERROR", "A network error interrupted the operation." },
    { 2147746157, "CS_E_ADMIN_LIMIT_EXCEEDED", "The size of this object exceeds the maximum size set by the Administrator." },
    { 2147746158, "CS_E_SCHEMA_MISMATCH", "The schema for the software installation data in the Active Directory does not match the required schema." },
    { 2147746159, "CS_E_INTERNAL_ERROR", "An error occurred in the software installation data in the Active Directory." },
    { 2147746160, "CACHE_E_NOCACHE_UPDATED", "Cache not updated" },
    { 2147746176, "OLEOBJ_E_NOVERBS", "No verbs for OLE object" },
    { 2147746177, "OLEOBJ_E_INVALIDVERB", "Invalid verb for OLE object" },
    { 2147746208, "INPLACE_E_NOTUNDOABLE", "Undo is not available" },
    { 2147746209, "INPLACE_E_NOTOOLSPACE", "Space for tools is not available" },
    { 2147746240, "CONVERT10_E_OLESTREAM_GET", "OLESTREAM Get method failed" },
    { 2147746241, "CONVERT10_E_OLESTREAM_PUT", "OLESTREAM Put method failed" },
    { 2147746242, "CONVERT10_E_OLESTREAM_FMT", "Contents of the OLESTREAM not in correct format" },
    { 2147746243, "CONVERT10_E_OLESTREAM_BITMAP_TO_DIB", "There was an error in a Windows GDI call while converting the bitmap to a DIB" },
    { 2147746244, "CONVERT10_E_STG_FMT", "Contents of the IStorage not in correct format" },
    { 2147746245, "CONVERT10_E_STG_NO_STD_STREAM", "Contents of IStorage is missing one of the standard streams" },
    { 2147746246, "CONVERT10_E_STG_DIB_TO_BITMAP", "There was an error in a Windows GDI call while converting the DIB to a bitmap. " },
    { 2147746256, "CLIPBRD_E_CANT_OPEN", "OpenClipboard Failed" },
    { 2147746257, "CLIPBRD_E_CANT_EMPTY", "EmptyClipboard Failed" },
    { 2147746258, "CLIPBRD_E_CANT_SET", "SetClipboard Failed" },
    { 2147746259, "CLIPBRD_E_BAD_DATA", "Data on clipboard is invalid" },
    { 2147746260, "CLIPBRD_E_CANT_CLOSE", "CloseClipboard Failed" },
    { 2147746272, "MK_E_CONNECTMANUALLY", "Moniker needs to be connected manually" },
    { 2147746273, "MK_E_EXCEEDEDDEADLINE", "Operation exceeded deadline" },
    { 2147746274, "MK_E_NEEDGENERIC", "Moniker needs to be generic" },
    { 2147746275, "MK_E_UNAVAILABLE", "Operation unavailable" },
    { 2147746276, "MK_E_SYNTAX", "Invalid syntax" },
    { 2147746277, "MK_E_NOOBJECT", "No object for moniker" },
    { 2147746278, "MK_E_INVALIDEXTENSION", "Bad extension for file" },
    { 2147746279, "MK_E_INTERMEDIATEINTERFACENOTSUPPORTED", "Intermediate operation failed" },
    { 2147746280, "MK_E_NOTBINDABLE", "Moniker is not bindable" },
    { 2147746281, "MK_E_NOTBOUND", "Moniker is not bound" },
    { 2147746282, "MK_E_CANTOPENFILE", "Moniker cannot open file" },
    { 2147746283, "MK_E_MUSTBOTHERUSER", "User input required for operation to succeed" },
    { 2147746284, "MK_E_NOINVERSE", "Moniker class has no inverse" },
    { 2147746285, "MK_E_NOSTORAGE", "Moniker does not refer to storage" },
    { 2147746286, "MK_E_NOPREFIX", "No common prefix" },
    { 2147746287, "MK_E_ENUMERATION_FAILED", "Moniker could not be enumerated" },
    { 2147746288, "CO_E_NOTINITIALIZED", "CoInitialize has not been called." },
    { 2147746289, "CO_E_ALREADYINITIALIZED", "CoInitialize has already been called." },
    { 2147746290, "CO_E_CANTDETERMINECLASS", "Class of object cannot be determined" },
    { 2147746291, "CO_E_CLASSSTRING", "Invalid class string" },
    { 2147746292, "CO_E_IIDSTRING", "Invalid interface string" },
    { 2147746293, "CO_E_APPNOTFOUND", "Application not found" },
    { 2147746294, "CO_E_APPSINGLEUSE", "Application cannot be run more than once" },
    { 2147746295, "CO_E_ERRORINAPP", "Some error in application program" },
    { 2147746296, "CO_E_DLLNOTFOUND", "DLL for class not found" },
    { 2147746297, "CO_E_ERRORINDLL", "Error in the DLL" },
    { 2147746298, "CO_E_WRONGOSFORAPP", "Wrong OS or OS version for application" },
    { 2147746299, "CO_E_OBJNOTREG", "Object is not registered" },
    { 2147746300, "CO_E_OBJISREG", "Object is already registered" },
    { 2147746301, "CO_E_OBJNOTCONNECTED", "Object is not connected to server" },
    { 2147746302, "CO_E_APPDIDNTREG", "Application was launched but it didn't register a class factory" },
    { 2147746303, "CO_E_RELEASED", "Object has been released" },
    { 2147746305, "EVENT_E_ALL_SUBSCRIBERS_FAILED", "An event was unable to invoke any of the subscribers" },
    { 2147746307, "EVENT_E_QUERYSYNTAX", "A syntax error occurred trying to evaluate a query string" },
    { 2147746308, "EVENT_E_QUERYFIELD", "An invalid field name was used in a query string" },
    { 2147746309, "EVENT_E_INTERNALEXCEPTION", "An unexpected exception was raised" },
    { 2147746310, "EVENT_E_INTERNALERROR", "An unexpected internal error was detected" },
    { 2147746311, "EVENT_E_INVALID_PER_USER_SID", "The owner SID on a per-user subscription doesn't exist" },
    { 2147746312, "EVENT_E_USER_EXCEPTION", "A user-supplied component or subscriber raised an exception" },
    { 2147746313, "EVENT_E_TOO_MANY_METHODS", "An interface has too many methods to fire events from" },
    { 2147746314, "EVENT_E_MISSING_EVENTCLASS", "A subscription cannot be stored unless its event class already exists" },
    { 2147746315, "EVENT_E_NOT_ALL_REMOVED", "Not all the objects requested could be removed" },
    { 2147746316, "EVENT_E_COMPLUS_NOT_INSTALLED", "COM+ is required for this operation, but is not installed" },
    { 2147750665, "SCHED_E_TRIGGER_NOT_FOUND", "Trigger not found." },
    { 2147750666, "SCHED_E_TASK_NOT_READY", "One or more of the properties that are needed to run this task have not been set." },
    { 2147750667, "SCHED_E_TASK_NOT_RUNNING", "There is no running instance of the task to terminate." },
    { 2147750668, "SCHED_E_SERVICE_NOT_INSTALLED", "The Task Scheduler Service is not installed on this computer." },
    { 2147750669, "SCHED_E_CANNOT_OPEN_TASK", "The task object could not be opened." },
    { 2147750670, "SCHED_E_INVALID_TASK", "The object is either an invalid task object or is not a task object." },
    { 2147750671, "SCHED_E_ACCOUNT_INFORMATION_NOT_SET", "No account information could be found in the Task Scheduler security database for the task indicated." },
    { 2147750672, "SCHED_E_ACCOUNT_NAME_NOT_FOUND", "Unable to establish existence of the account specified." },
    { 2147750673, "SCHED_E_ACCOUNT_DBASE_CORRUPT", "Corruption was detected in the Task Scheduler security database; the database has been reset." },
    { 2147750674, "SCHED_E_NO_SECURITY_SERVICES", "Task Scheduler security services are available only on Windows NT." },
    { 2147750675, "SCHED_E_UNKNOWN_OBJECT_VERSION", "The task object version is either unsupported or invalid." },
    { 2147750676, "SCHED_E_UNSUPPORTED_ACCOUNT_OPTION", "The task has been configured with an unsupported combination of account settings and run time options." },
    { 2147750677, "SCHED_E_SERVICE_NOT_RUNNING", "The Task Scheduler Service is not running." },
    { 2147803138, "CONTEXT_E_ABORTED", "The root transaction wanted to commit, but transaction aborted" },
    { 2147803139, "CONTEXT_E_ABORTING", "You made a method call on a COM+ component that has a transaction that has already aborted or in the process of aborting." },
    { 2147803140, "CONTEXT_E_NOCONTEXT", "There is no MTS object context" },
    { 2147803142, "CONTEXT_E_SYNCH_TIMEOUT", "The component is configured to use synchronization and a thread has timed out waiting to enter the context." },
    { 2147803143, "CONTEXT_E_OLDREF", "You made a method call on a COM+ component that has a transaction that has already committed or aborted." },
    { 2147803148, "CONTEXT_E_ROLENOTFOUND", "The specified role was not configured for the application" },
    { 2147803151, "CONTEXT_E_TMNOTAVAILABLE", "COM+ was unable to talk to the Microsoft Distributed Transaction Coordinator" },
    { 2147803169, "CO_E_ACTIVATIONFAILED", "An unexpected error occurred during COM+ Activation." },
    { 2147803170, "CO_E_ACTIVATIONFAILED_EVENTLOGGED", "COM+ Activation failed. Check the event log for more information" },
    { 2147803171, "CO_E_ACTIVATIONFAILED_CATALOGERROR", "COM+ Activation failed due to a catalog or configuration error." },
    { 2147803172, "CO_E_ACTIVATIONFAILED_TIMEOUT", "COM+ activation failed because the activation could not be completed in the specified amount of time." },
    { 2147803173, "CO_E_INITIALIZATIONFAILED", "COM+ Activation failed because an initialization function failed.  Check the event log for more information." },
    { 2147803174, "CONTEXT_E_NOJIT", "The requested operation requires that JIT be in the current context and it is not" },
    { 2147803175, "CONTEXT_E_NOTRANSACTION", "The requested operation requires that the current context have a Transaction, and it does not" },
    { 2147803176, "CO_E_THREADINGMODEL_CHANGED", "The components threading model has changed after install into a COM+ Application.  Please re-install component." },
    { 2147942405, "E_ACCESSDENIED", "General access denied error" },
    { 2147942406, "E_HANDLE", "Invalid handle" },
    { 2147942414, "E_OUTOFMEMORY", "Ran out of memory" },
    { 2147942487, "E_INVALIDARG", "One or more arguments are invalid" },
    { 2148007937, "CO_E_CLASS_CREATE_FAILED", "Attempt to create a class object failed" },
    { 2148007938, "CO_E_SCM_ERROR", "OLE service could not bind object" },
    { 2148007939, "CO_E_SCM_RPC_FAILURE", "RPC communication failed with OLE service" },
    { 2148007940, "CO_E_BAD_PATH", "Bad path to object" },
    { 2148007941, "CO_E_SERVER_EXEC_FAILURE", "Server execution failed" },
    { 2148007942, "CO_E_OBJSRV_RPC_FAILURE", "OLE service could not communicate with the object server" },
    { 2148007943, "MK_E_NO_NORMALIZED", "Moniker path could not be normalized" },
    { 2148007944, "CO_E_SERVER_STOPPING", "Object server is stopping when OLE service contacts it" },
    { 2148007945, "MEM_E_INVALID_ROOT", "An invalid root block pointer was specified" },
    { 2148007952, "MEM_E_INVALID_LINK", "An allocation chain contained an invalid link pointer" },
    { 2148007953, "MEM_E_INVALID_SIZE", "The requested allocation size was too large" },
    { 2148073473, "NTE_BAD_UID", "Bad UID." },
    { 2148073474, "NTE_BAD_HASH", "Bad Hash." },
    { 2148073475, "NTE_BAD_KEY", "Bad Key." },
    { 2148073476, "NTE_BAD_LEN", "Bad Length." },
    { 2148073477, "NTE_BAD_DATA", "Bad Data." },
    { 2148073478, "NTE_BAD_SIGNATURE", "Invalid Signature." },
    { 2148073479, "NTE_BAD_VER", "Bad Version of provider." },
    { 2148073480, "NTE_BAD_ALGID", "Invalid algorithm specified." },
    { 2148073481, "NTE_BAD_FLAGS", "Invalid flags specified." },
    { 2148073482, "NTE_BAD_TYPE", "Invalid type specified." },
    { 2148073483, "NTE_BAD_KEY_STATE", "Key not valid for use in specified state." },
    { 2148073484, "NTE_BAD_HASH_STATE", "Hash not valid for use in specified state." },
    { 2148073485, "NTE_NO_KEY", "Key does not exist." },
    { 2148073486, "NTE_NO_MEMORY", "Insufficient memory available for the operation." },
    { 2148073487, "NTE_EXISTS", "Object already exists." },
    { 2148073488, "NTE_PERM", "Access denied." },
    { 2148073489, "NTE_NOT_FOUND", "Object was not found." },
    { 2148073490, "NTE_DOUBLE_ENCRYPT", "Data already encrypted." },
    { 2148073491, "NTE_BAD_PROVIDER", "Invalid provider specified." },
    { 2148073492, "NTE_BAD_PROV_TYPE", "Invalid provider type specified." },
    { 2148073493, "NTE_BAD_PUBLIC_KEY", "Provider's public key is invalid." },
    { 2148073494, "NTE_BAD_KEYSET", "Keyset does not exist" },
    { 2148073495, "NTE_PROV_TYPE_NOT_DEF", "Provider type not defined." },
    { 2148073496, "NTE_PROV_TYPE_ENTRY_BAD", "Provider type as registered is invalid." },
    { 2148073497, "NTE_KEYSET_NOT_DEF", "The keyset is not defined." },
    { 2148073498, "NTE_KEYSET_ENTRY_BAD", "Keyset as registered is invalid." },
    { 2148073499, "NTE_PROV_TYPE_NO_MATCH", "Provider type does not match registered value." },
    { 2148073500, "NTE_SIGNATURE_FILE_BAD", "The digital signature file is corrupt." },
    { 2148073501, "NTE_PROVIDER_DLL_FAIL", "Provider DLL failed to initialize correctly." },
    { 2148073502, "NTE_PROV_DLL_NOT_FOUND", "Provider DLL could not be found." },
    { 2148073503, "NTE_BAD_KEYSET_PARAM", "The Keyset parameter is invalid." },
    { 2148073504, "NTE_FAIL", "An internal error occurred." },
    { 2148073505, "NTE_SYS_ERR", "A base error occurred." },
    { 2148073506, "NTE_SILENT_CONTEXT", "Provider could not perform the action since the context was acquired as silent." },
    { 2148073507, "NTE_TOKEN_KEYSET_STORAGE_FULL", "The security token does not have storage space available for an additional container." },
    { 2148073508, "NTE_TEMPORARY_PROFILE", "The profile for the user is a temporary profile." },
    { 2148073509, "NTE_FIXEDPARAMETER", "The key parameters could not be set because the CSP uses fixed parameters." },
    { 2148074240, "SEC_E_INSUFFICIENT_MEMORY", "Not enough memory is available to complete this request" },
    { 2148074241, "SEC_E_INVALID_HANDLE", "The handle specified is invalid" },
    { 2148074242, "SEC_E_UNSUPPORTED_FUNCTION", "The function requested is not supported" },
    { 2148074243, "SEC_E_TARGET_UNKNOWN", "The specified target is unknown or unreachable" },
    { 2148074244, "SEC_E_INTERNAL_ERROR", "The Local Security Authority cannot be contacted" },
    { 2148074245, "SEC_E_SECPKG_NOT_FOUND", "The requested security package does not exist" },
    { 2148074246, "SEC_E_NOT_OWNER", "The caller is not the owner of the desired credentials" },
    { 2148074247, "SEC_E_CANNOT_INSTALL", "The security package failed to initialize, and cannot be installed" },
    { 2148074248, "SEC_E_INVALID_TOKEN", "The token supplied to the function is invalid" },
    { 2148074249, "SEC_E_CANNOT_PACK", "The security package is not able to marshall the logon buffer, so the logon attempt has failed" },
    { 2148074250, "SEC_E_QOP_NOT_SUPPORTED", "The per-message Quality of Protection is not supported by the security package" },
    { 2148074251, "SEC_E_NO_IMPERSONATION", "The security context does not allow impersonation of the client" },
    { 2148074252, "SEC_E_LOGON_DENIED", "The logon attempt failed" },
    { 2148074253, "SEC_E_UNKNOWN_CREDENTIALS", "The credentials supplied to the package were not recognized" },
    { 2148074254, "SEC_E_NO_CREDENTIALS", "No credentials are available in the security package" },
    { 2148074255, "SEC_E_MESSAGE_ALTERED", "The message or signature supplied for verification has been altered" },
    { 2148074256, "SEC_E_OUT_OF_SEQUENCE", "The message supplied for verification is out of sequence" },
    { 2148074257, "SEC_E_NO_AUTHENTICATING_AUTHORITY", "No authority could be contacted for authentication." },
    { 2148074262, "SEC_E_BAD_PKGID", "The requested security package does not exist" },
    { 2148074263, "SEC_E_CONTEXT_EXPIRED", "The context has expired and can no longer be used." },
    { 2148074264, "SEC_E_INCOMPLETE_MESSAGE", "The supplied message is incomplete.  The signature was not verified." },
    { 2148074272, "SEC_E_INCOMPLETE_CREDENTIALS", "The credentials supplied were not complete, and could not be verified. The context could not be initialized." },
    { 2148074273, "SEC_E_BUFFER_TOO_SMALL", "The buffers supplied to a function was too small." },
    { 2148074274, "SEC_E_WRONG_PRINCIPAL", "The target principal name is incorrect." },
    { 2148074276, "SEC_E_TIME_SKEW", "The clocks on the client and server machines are skewed." },
    { 2148074277, "SEC_E_UNTRUSTED_ROOT", "The certificate chain was issued by an untrusted authority." },
    { 2148074278, "SEC_E_ILLEGAL_MESSAGE", "The message received was unexpected or badly formatted." },
    { 2148074279, "SEC_E_CERT_UNKNOWN", "An unknown error occurred while processing the certificate." },
    { 2148074280, "SEC_E_CERT_EXPIRED", "The received certificate has expired." },
    { 2148074281, "SEC_E_ENCRYPT_FAILURE", "The specified data could not be encrypted." },
    { 2148074288, "SEC_E_DECRYPT_FAILURE", "The specified data could not be decrypted. " },
    { 2148074289, "SEC_E_ALGORITHM_MISMATCH", "The client and server cannot communicate, because they do not possess a common algorithm." },
    { 2148074290, "SEC_E_SECURITY_QOS_FAILED", "The security context could not be established due to a failure in the requested quality of service (e.g. mutual authentication or delegation)." },
    { 2148077569, "CRYPT_E_MSG_ERROR", "An error occurred while performing an operation on a cryptographic message." },
    { 2148077570, "CRYPT_E_UNKNOWN_ALGO", "Unknown cryptographic algorithm." },
    { 2148077571, "CRYPT_E_OID_FORMAT", "The object identifier is poorly formatted." },
    { 2148077572, "CRYPT_E_INVALID_MSG_TYPE", "Invalid cryptographic message type." },
    { 2148077573, "CRYPT_E_UNEXPECTED_ENCODING", "Unexpected cryptographic message encoding." },
    { 2148077574, "CRYPT_E_AUTH_ATTR_MISSING", "The cryptographic message does not contain an expected authenticated attribute." },
    { 2148077575, "CRYPT_E_HASH_VALUE", "The hash value is not correct." },
    { 2148077576, "CRYPT_E_INVALID_INDEX", "The index value is not valid." },
    { 2148077577, "CRYPT_E_ALREADY_DECRYPTED", "The content of the cryptographic message has already been decrypted." },
    { 2148077578, "CRYPT_E_NOT_DECRYPTED", "The content of the cryptographic message has not been decrypted yet." },
    { 2148077579, "CRYPT_E_RECIPIENT_NOT_FOUND", "The enveloped-data message does not contain the specified recipient." },
    { 2148077580, "CRYPT_E_CONTROL_TYPE", "Invalid control type." },
    { 2148077581, "CRYPT_E_ISSUER_SERIALNUMBER", "Invalid issuer and/or serial number." },
    { 2148077582, "CRYPT_E_SIGNER_NOT_FOUND", "Cannot find the original signer." },
    { 2148077583, "CRYPT_E_ATTRIBUTES_MISSING", "The cryptographic message does not contain all of the requested attributes." },
    { 2148077584, "CRYPT_E_STREAM_MSG_NOT_READY", "The streamed cryptographic message is not ready to return data." },
    { 2148077585, "CRYPT_E_STREAM_INSUFFICIENT_DATA", "The streamed cryptographic message requires more data to complete the decode operation." },
    { 2148081665, "CRYPT_E_BAD_LEN", "The length specified for the output data was insufficient." },
    { 2148081666, "CRYPT_E_BAD_ENCODE", "An error occurred during encode or decode operation." },
    { 2148081667, "CRYPT_E_FILE_ERROR", "An error occurred while reading or writing to a file." },
    { 2148081668, "CRYPT_E_NOT_FOUND", "Cannot find object or property." },
    { 2148081669, "CRYPT_E_EXISTS", "The object or property already exists." },
    { 2148081670, "CRYPT_E_NO_PROVIDER", "No provider was specified for the store or object." },
    { 2148081671, "CRYPT_E_SELF_SIGNED", "The specified certificate is self signed." },
    { 2148081672, "CRYPT_E_DELETED_PREV", "The previous certificate or CRL context was deleted." },
    { 2148081673, "CRYPT_E_NO_MATCH", "Cannot find the requested object." },
    { 2148081674, "CRYPT_E_UNEXPECTED_MSG_TYPE", "The certificate does not have a property that references a private key." },
    { 2148081675, "CRYPT_E_NO_KEY_PROPERTY", "Cannot find the certificate and private key for decryption." },
    { 2148081676, "CRYPT_E_NO_DECRYPT_CERT", "Cannot find the certificate and private key to use for decryption." },
    { 2148081677, "CRYPT_E_BAD_MSG", "Not a cryptographic message or the cryptographic message is not formatted correctly." },
    { 2148081678, "CRYPT_E_NO_SIGNER", "The signed cryptographic message does not have a signer for the specified signer index." },
    { 2148081679, "CRYPT_E_PENDING_CLOSE", "Final closure is pending until additional frees or closes." },
    { 2148081680, "CRYPT_E_REVOKED", "The certificate is revoked." },
    { 2148081681, "CRYPT_E_NO_REVOCATION_DLL", "No Dll or exported function was found to verify revocation." },
    { 2148081682, "CRYPT_E_NO_REVOCATION_CHECK", "The revocation function was unable to check revocation for the certificate." },
    { 2148081683, "CRYPT_E_REVOCATION_OFFLINE", "The revocation function was unable to check revocation because the revocation server was offline." },
    { 2148081684, "CRYPT_E_NOT_IN_REVOCATION_DATABASE", "The certificate is not in the revocation server's database." },
    { 2148081696, "CRYPT_E_INVALID_NUMERIC_STRING", "The string contains a non-numeric character." },
    { 2148081697, "CRYPT_E_INVALID_PRINTABLE_STRING", "The string contains a non-printable character." },
    { 2148081698, "CRYPT_E_INVALID_IA5_STRING", "The string contains a character not in the 7 bit ASCII character set." },
    { 2148081699, "CRYPT_E_INVALID_X500_STRING", "The string contains an invalid X500 name attribute key, oid, value or delimiter." },
    { 2148081700, "CRYPT_E_NOT_CHAR_STRING", "The dwValueType for the CERT_NAME_VALUE is not one of the character strings.  Most likely it is either a CERT_RDN_ENCODED_BLOB or CERT_TDN_OCTED_STRING." },
    { 2148081701, "CRYPT_E_FILERESIZED", "The Put operation can not continue.  The file needs to be resized.  However, there is already a signature present.  A complete signing operation must be done." },
    { 2148081702, "CRYPT_E_SECURITY_SETTINGS", "The cryptographic operation failed due to a local security option setting." },
    { 2148081703, "CRYPT_E_NO_VERIFY_USAGE_DLL", "No DLL or exported function was found to verify subject usage." },
    { 2148081704, "CRYPT_E_NO_VERIFY_USAGE_CHECK", "The called function was unable to do a usage check on the subject." },
    { 2148081705, "CRYPT_E_VERIFY_USAGE_OFFLINE", "Since the server was offline, the called function was unable to complete the usage check." },
    { 2148081706, "CRYPT_E_NOT_IN_CTL", "The subject was not found in a Certificate Trust List (CTL)." },
    { 2148081707, "CRYPT_E_NO_TRUSTED_SIGNER", "None of the signers of the cryptographic message or certificate trust list is trusted." },
    { 2148081708, "CRYPT_E_MISSING_PUBKEY_PARA", "The public key's algorithm parameters are missing." },
    { 2148085760, "CRYPT_E_OSS_ERROR", "OSS Certificate encode/decode error code base  See asn1code.h for a definition of the OSS runtime errors. The OSS error values are offset by CRYPT_E_OSS_ERROR." },
    { 2148085761, "OSS_MORE_BUF", "OSS ASN.1 Error: Output Buffer is too small." },
    { 2148085762, "OSS_NEGATIVE_UINTEGER", "OSS ASN.1 Error: Signed integer is encoded as a unsigned integer." },
    { 2148085763, "OSS_PDU_RANGE", "OSS ASN.1 Error: Unknown ASN.1 data type." },
    { 2148085764, "OSS_MORE_INPUT", "OSS ASN.1 Error: Output buffer is too small, the decoded data has been truncated." },
    { 2148085765, "OSS_DATA_ERROR", "OSS ASN.1 Error: Invalid data." },
    { 2148085766, "OSS_BAD_ARG", "OSS ASN.1 Error: Invalid argument." },
    { 2148085767, "OSS_BAD_VERSION", "OSS ASN.1 Error: Encode/Decode version mismatch." },
    { 2148085768, "OSS_OUT_MEMORY", "OSS ASN.1 Error: Out of memory." },
    { 2148085769, "OSS_PDU_MISMATCH", "OSS ASN.1 Error: Encode/Decode Error." },
    { 2148085770, "OSS_LIMITED", "OSS ASN.1 Error: Internal Error." },
    { 2148085771, "OSS_BAD_PTR", "OSS ASN.1 Error: Invalid data." },
    { 2148085772, "OSS_BAD_TIME", "OSS ASN.1 Error: Invalid data." },
    { 2148085773, "OSS_INDEFINITE_NOT_SUPPORTED", "OSS ASN.1 Error: Unsupported BER indefinite-length encoding." },
    { 2148085774, "OSS_MEM_ERROR", "OSS ASN.1 Error: Access violation." },
    { 2148085775, "OSS_BAD_TABLE", "OSS ASN.1 Error: Invalid data." },
    { 2148085776, "OSS_TOO_LONG", "OSS ASN.1 Error: Invalid data." },
    { 2148085777, "OSS_CONSTRAINT_VIOLATED", "OSS ASN.1 Error: Invalid data." },
    { 2148085778, "OSS_FATAL_ERROR", "OSS ASN.1 Error: Internal Error." },
    { 2148085779, "OSS_ACCESS_SERIALIZATION_ERROR", "OSS ASN.1 Error: Multi-threading conflict." },
    { 2148085780, "OSS_NULL_TBL", "OSS ASN.1 Error: Invalid data." },
    { 2148085781, "OSS_NULL_FCN", "OSS ASN.1 Error: Invalid data." },
    { 2148085782, "OSS_BAD_ENCRULES", "OSS ASN.1 Error: Invalid data." },
    { 2148085783, "OSS_UNAVAIL_ENCRULES", "OSS ASN.1 Error: Encode/Decode function not implemented." },
    { 2148085784, "OSS_CANT_OPEN_TRACE_WINDOW", "OSS ASN.1 Error: Trace file error." },
    { 2148085785, "OSS_UNIMPLEMENTED", "OSS ASN.1 Error: Function not implemented." },
    { 2148085786, "OSS_OID_DLL_NOT_LINKED", "OSS ASN.1 Error: Program link error." },
    { 2148085787, "OSS_CANT_OPEN_TRACE_FILE", "OSS ASN.1 Error: Trace file error." },
    { 2148085788, "OSS_TRACE_FILE_ALREADY_OPEN", "OSS ASN.1 Error: Trace file error." },
    { 2148085789, "OSS_TABLE_MISMATCH", "OSS ASN.1 Error: Invalid data." },
    { 2148085790, "OSS_TYPE_NOT_SUPPORTED", "OSS ASN.1 Error: Invalid data." },
    { 2148085791, "OSS_REAL_DLL_NOT_LINKED", "OSS ASN.1 Error: Program link error." },
    { 2148085792, "OSS_REAL_CODE_NOT_LINKED", "OSS ASN.1 Error: Program link error." },
    { 2148085793, "OSS_OUT_OF_RANGE", "OSS ASN.1 Error: Program link error." },
    { 2148085794, "OSS_COPIER_DLL_NOT_LINKED", "OSS ASN.1 Error: Program link error." },
    { 2148085795, "OSS_CONSTRAINT_DLL_NOT_LINKED", "OSS ASN.1 Error: Program link error." },
    { 2148085796, "OSS_COMPARATOR_DLL_NOT_LINKED", "OSS ASN.1 Error: Program link error." },
    { 2148085797, "OSS_COMPARATOR_CODE_NOT_LINKED", "OSS ASN.1 Error: Program link error." },
    { 2148085798, "OSS_MEM_MGR_DLL_NOT_LINKED", "OSS ASN.1 Error: Program link error." },
    { 2148085799, "OSS_PDV_DLL_NOT_LINKED", "OSS ASN.1 Error: Program link error." },
    { 2148085800, "OSS_PDV_CODE_NOT_LINKED", "OSS ASN.1 Error: Program link error." },
    { 2148085801, "OSS_API_DLL_NOT_LINKED", "OSS ASN.1 Error: Program link error." },
    { 2148085802, "OSS_BERDER_DLL_NOT_LINKED", "OSS ASN.1 Error: Program link error." },
    { 2148085803, "OSS_PER_DLL_NOT_LINKED", "OSS ASN.1 Error: Program link error." },
    { 2148085804, "OSS_OPEN_TYPE_ERROR", "OSS ASN.1 Error: Program link error." },
    { 2148085805, "OSS_MUTEX_NOT_CREATED", "OSS ASN.1 Error: System resource error." },
    { 2148085806, "OSS_CANT_CLOSE_TRACE_FILE", "OSS ASN.1 Error: Trace file error." },
    { 2148086016, "CRYPT_E_ASN1_ERROR", "ASN1 Certificate encode/decode error code base.  The ASN1 error values are offset by CRYPT_E_ASN1_ERROR." },
    { 2148086017, "CRYPT_E_ASN1_INTERNAL", "ASN1 internal encode or decode error." },
    { 2148086018, "CRYPT_E_ASN1_EOD", "ASN1 unexpected end of data." },
    { 2148086019, "CRYPT_E_ASN1_CORRUPT", "ASN1 corrupted data." },
    { 2148086020, "CRYPT_E_ASN1_LARGE", "ASN1 value too large." },
    { 2148086021, "CRYPT_E_ASN1_CONSTRAINT", "ASN1 constraint violated." },
    { 2148086022, "CRYPT_E_ASN1_MEMORY", "ASN1 out of memory." },
    { 2148086023, "CRYPT_E_ASN1_OVERFLOW", "ASN1 buffer overflow." },
    { 2148086024, "CRYPT_E_ASN1_BADPDU", "ASN1 function not supported for this PDU." },
    { 2148086025, "CRYPT_E_ASN1_BADARGS", "ASN1 bad arguments to function call." },
    { 2148086026, "CRYPT_E_ASN1_BADREAL", "ASN1 bad real value." },
    { 2148086027, "CRYPT_E_ASN1_BADTAG", "ASN1 bad tag value met." },
    { 2148086028, "CRYPT_E_ASN1_CHOICE", "ASN1 bad choice value." },
    { 2148086029, "CRYPT_E_ASN1_RULE", "ASN1 bad encoding rule." },
    { 2148086030, "CRYPT_E_ASN1_UTF8", "ASN1 bad unicode (UTF8)." },
    { 2148086067, "CRYPT_E_ASN1_PDU_TYPE", "ASN1 bad PDU type." },
    { 2148086068, "CRYPT_E_ASN1_NYI", "ASN1 not yet implemented." },
    { 2148086273, "CRYPT_E_ASN1_EXTENDED", "ASN1 skipped unknown extension(s)." },
    { 2148086274, "CRYPT_E_ASN1_NOEOD", "ASN1 end of data expected" },
    { 2148089857, "CERTSRV_E_BAD_REQUESTSUBJECT", "The request subject name is invalid or too long." },
    { 2148089858, "CERTSRV_E_NO_REQUEST", "The request does not exist." },
    { 2148089859, "CERTSRV_E_BAD_REQUESTSTATUS", "The request's current status does not allow this operation." },
    { 2148089860, "CERTSRV_E_PROPERTY_EMPTY", "The requested property value is empty." },
    { 2148089861, "CERTSRV_E_INVALID_CA_CERTIFICATE", "The certification authority's certificate contains invalid data." },
    { 2148089862, "CERTSRV_E_SERVER_SUSPENDED", "Certificate service has been suspended for a database restore operation." },
    { 2148089863, "CERTSRV_E_ENCODING_LENGTH", "The certificate contains an encoded length that is potentially incompatible with older enrollment software." },
    { 2148091904, "CERTSRV_E_UNSUPPORTED_CERT_TYPE", "The requested certificate template is not supported by this CA." },
    { 2148091905, "CERTSRV_E_NO_CERT_TYPE", "The request contains no certificate template information." },
    { 2148098049, "TRUST_E_SYSTEM_ERROR", "A system-level error occurred while verifying trust." },
    { 2148098050, "TRUST_E_NO_SIGNER_CERT", "The certificate for the signer of the message is invalid or not found." },
    { 2148098051, "TRUST_E_COUNTER_SIGNER", "One of the counter signatures was invalid." },
    { 2148098052, "TRUST_E_CERT_SIGNATURE", "The signature of the certificate can not be verified." },
    { 2148098053, "TRUST_E_TIME_STAMP", "The timestamp signature and/or certificate could not be verified or is malformed." },
    { 2148098064, "TRUST_E_BAD_DIGEST", "The digital signature of the object did not verify." },
    { 2148098073, "TRUST_E_BASIC_CONSTRAINTS", "A certificate's basic constraint extension has not been observed." },
    { 2148098078, "TRUST_E_FINANCIAL_CRITERIA", "The certificate does not meet or contain the Authenticode financial extensions." },
    { 2148102145, "MSSIPOTF_E_OUTOFMEMRANGE", "Tried to reference a part of the file outside the proper range." },
    { 2148102146, "MSSIPOTF_E_CANTGETOBJECT", "Could not retrieve an object from the file." },
    { 2148102147, "MSSIPOTF_E_NOHEADTABLE", "Could not find the head table in the file." },
    { 2148102148, "MSSIPOTF_E_BAD_MAGICNUMBER", "The magic number in the head table is incorrect." },
    { 2148102149, "MSSIPOTF_E_BAD_OFFSET_TABLE", "The offset table has incorrect values." },
    { 2148102150, "MSSIPOTF_E_TABLE_TAGORDER", "Duplicate table tags or tags out of alphabetical order." },
    { 2148102151, "MSSIPOTF_E_TABLE_LONGWORD", "A table does not start on a long word boundary." },
    { 2148102152, "MSSIPOTF_E_BAD_FIRST_TABLE_PLACEMENT", "First table does not appear after header information." },
    { 2148102153, "MSSIPOTF_E_TABLES_OVERLAP", "Two or more tables overlap." },
    { 2148102154, "MSSIPOTF_E_TABLE_PADBYTES", "Too many pad bytes between tables or pad bytes are not 0." },
    { 2148102155, "MSSIPOTF_E_FILETOOSMALL", "File is too small to contain the last table." },
    { 2148102156, "MSSIPOTF_E_TABLE_CHECKSUM", "A table checksum is incorrect." },
    { 2148102157, "MSSIPOTF_E_FILE_CHECKSUM", "The file checksum is incorrect." },
    { 2148102160, "MSSIPOTF_E_FAILED_POLICY", "The signature does not have the correct attributes for the policy." },
    { 2148102161, "MSSIPOTF_E_FAILED_HINTS_CHECK", "The file did not pass the hints check." },
    { 2148102162, "MSSIPOTF_E_NOT_OPENTYPE", "The file is not an OpenType file." },
    { 2148102163, "MSSIPOTF_E_FILE", "Failed on a file operation (open, map, read, write)." },
    { 2148102164, "MSSIPOTF_E_CRYPT", "A call to a CryptoAPI function failed." },
    { 2148102165, "MSSIPOTF_E_BADVERSION", "There is a bad version number in the file." },
    { 2148102166, "MSSIPOTF_E_DSIG_STRUCTURE", "The structure of the DSIG table is incorrect." },
    { 2148102167, "MSSIPOTF_E_PCONST_CHECK", "A check failed in a partially constant table." },
    { 2148102168, "MSSIPOTF_E_STRUCTURE", "Some kind of structural error." },
    { 2148204545, "TRUST_E_PROVIDER_UNKNOWN", "Unknown trust provider." },
    { 2148204546, "TRUST_E_ACTION_UNKNOWN", "The trust verification action specified is not supported by the specified trust provider." },
    { 2148204547, "TRUST_E_SUBJECT_FORM_UNKNOWN", "The form specified for the subject is not one supported or known by the specified trust provider." },
    { 2148204548, "TRUST_E_SUBJECT_NOT_TRUSTED", "The subject is not trusted for the specified action." },
    { 2148204549, "DIGSIG_E_ENCODE", "Error due to problem in ASN.1 encoding process." },
    { 2148204550, "DIGSIG_E_DECODE", "Error due to problem in ASN.1 decoding process." },
    { 2148204551, "DIGSIG_E_EXTENSIBILITY", "Reading / writing Extensions where Attributes are appropriate, and visa versa." },
    { 2148204552, "DIGSIG_E_CRYPTO", "Unspecified cryptographic failure." },
    { 2148204553, "PERSIST_E_SIZEDEFINITE", "The size of the data could not be determined." },
    { 2148204554, "PERSIST_E_SIZEINDEFINITE", "The size of the indefinite-sized data could not be determined." },
    { 2148204555, "PERSIST_E_NOTSELFSIZING", "This object does not read and write self-sizing data." },
    { 2148204800, "TRUST_E_NOSIGNATURE", "No signature was present in the subject." },
    { 2148204801, "CERT_E_EXPIRED", "A required certificate is not within its validity period when verifying against the current system clock or the timestamp in the signed file." },
    { 2148204802, "CERT_E_VALIDITYPERIODNESTING", "The validity periods of the certification chain do not nest correctly." },
    { 2148204803, "CERT_E_ROLE", "A certificate that can only be used as an end-entity is being used as a CA or visa versa." },
    { 2148204804, "CERT_E_PATHLENCONST", "A path length constraint in the certification chain has been violated." },
    { 2148204805, "CERT_E_CRITICAL", "A certificate contains an unknown extension that is marked 'critical'." },
    { 2148204806, "CERT_E_PURPOSE", "A certificate being used for a purpose other than the ones specified by its CA." },
    { 2148204807, "CERT_E_ISSUERCHAINING", "A parent of a given certificate in fact did not issue that child certificate." },
    { 2148204808, "CERT_E_MALFORMED", "A certificate is missing or has an empty value for an important field, such as a subject or issuer name." },
    { 2148204809, "CERT_E_UNTRUSTEDROOT", "A certificate chain processed correctly, but terminated in a root certificate which is not trusted by the trust provider." },
    { 2148204810, "CERT_E_CHAINING", "An internal certificate chaining error has occurred." },
    { 2148204811, "TRUST_E_FAIL", "Generic trust failure." },
    { 2148204812, "CERT_E_REVOKED", "A certificate was explicitly revoked by its issuer." },
    { 2148204813, "CERT_E_UNTRUSTEDTESTROOT", "The certification path terminates with the test root which is not trusted with the current policy settings." },
    { 2148204814, "CERT_E_REVOCATION_FAILURE", "The revocation process could not continue - the certificate(s) could not be checked." },
    { 2148204815, "CERT_E_CN_NO_MATCH", "The certificate's CN name does not match the passed value." },
    { 2148204816, "CERT_E_WRONG_USAGE", "The certificate is not valid for the requested usage." },
    { 2148204817, "TRUST_E_EXPLICIT_DISTRUST", "The certificate was explicitly marked as untrusted by the user." },
    { 2148204818, "CERT_E_UNTRUSTEDCA", "A certification chain processed correctly, but one of the CA certificates is not trusted by the policy provider." },
    { 2148466688, "SPAPI_E_EXPECTED_SECTION_NAME", "A non-empty line was encountered in the INF before the start of a section." },
    { 2148466689, "SPAPI_E_BAD_SECTION_NAME_LINE", "A section name marker in the INF is not complete, or does not exist on a line by itself." },
    { 2148466690, "SPAPI_E_SECTION_NAME_TOO_LONG", "An INF section was encountered whose name exceeds the maximum section name length." },
    { 2148466691, "SPAPI_E_GENERAL_SYNTAX", "The syntax of the INF is invalid." },
    { 2148466944, "SPAPI_E_WRONG_INF_STYLE", "The style of the INF is different than what was requested." },
    { 2148466945, "SPAPI_E_SECTION_NOT_FOUND", "The required section was not found in the INF." },
    { 2148466946, "SPAPI_E_LINE_NOT_FOUND", "The required line was not found in the INF." },
    { 2148466947, "SPAPI_E_NO_BACKUP", "The files affected by the installation of this file queue have not been backed up for uninstall." },
    { 2148467200, "SPAPI_E_NO_ASSOCIATED_CLASS", "The INF or the device information set or element does not have an associated install class." },
    { 2148467201, "SPAPI_E_CLASS_MISMATCH", "The INF or the device information set or element does not match the specified install class." },
    { 2148467202, "SPAPI_E_DUPLICATE_FOUND", "An existing device was found that is a duplicate of the device being manually installed." },
    { 2148467203, "SPAPI_E_NO_DRIVER_SELECTED", "There is no driver selected for the device information set or element." },
    { 2148467204, "SPAPI_E_KEY_DOES_NOT_EXIST", "The requested device registry key does not exist." },
    { 2148467205, "SPAPI_E_INVALID_DEVINST_NAME", "The device instance name is invalid." },
    { 2148467206, "SPAPI_E_INVALID_CLASS", "The install class is not present or is invalid." },
    { 2148467207, "SPAPI_E_DEVINST_ALREADY_EXISTS", "The device instance cannot be created because it already exists." },
    { 2148467208, "SPAPI_E_DEVINFO_NOT_REGISTERED", "The operation cannot be performed on a device information element that has not been registered." },
    { 2148467209, "SPAPI_E_INVALID_REG_PROPERTY", "The device property code is invalid." },
    { 2148467210, "SPAPI_E_NO_INF", "The INF from which a driver list is to be built does not exist." },
    { 2148467211, "SPAPI_E_NO_SUCH_DEVINST", "The device instance does not exist in the hardware tree." },
    { 2148467212, "SPAPI_E_CANT_LOAD_CLASS_ICON", "The icon representing this install class cannot be loaded." },
    { 2148467213, "SPAPI_E_INVALID_CLASS_INSTALLER", "The class installer registry entry is invalid." },
    { 2148467214, "SPAPI_E_DI_DO_DEFAULT", "The class installer has indicated that the default action should be performed for this installation request." },
    { 2148467215, "SPAPI_E_DI_NOFILECOPY", "The operation does not require any files to be copied." },
    { 2148467216, "SPAPI_E_INVALID_HWPROFILE", "The specified hardware profile does not exist." },
    { 2148467217, "SPAPI_E_NO_DEVICE_SELECTED", "There is no device information element currently selected for this device information set." },
    { 2148467218, "SPAPI_E_DEVINFO_LIST_LOCKED", "The operation cannot be performed because the device information set is locked." },
    { 2148467219, "SPAPI_E_DEVINFO_DATA_LOCKED", "The operation cannot be performed because the device information element is locked." },
    { 2148467220, "SPAPI_E_DI_BAD_PATH", "The specified path does not contain any applicable device INFs." },
    { 2148467221, "SPAPI_E_NO_CLASSINSTALL_PARAMS", "No class installer parameters have been set for the device information set or element." },
    { 2148467222, "SPAPI_E_FILEQUEUE_LOCKED", "The operation cannot be performed because the file queue is locked." },
    { 2148467223, "SPAPI_E_BAD_SERVICE_INSTALLSECT", "A service installation section in this INF is invalid." },
    { 2148467224, "SPAPI_E_NO_CLASS_DRIVER_LIST", "There is no class driver list for the device information element." },
    { 2148467225, "SPAPI_E_NO_ASSOCIATED_SERVICE", "The installation failed because a function driver was not specified for this device instance." },
    { 2148467226, "SPAPI_E_NO_DEFAULT_DEVICE_INTERFACE", "There is presently no default device interface designated for this interface class." },
    { 2148467227, "SPAPI_E_DEVICE_INTERFACE_ACTIVE", "The operation cannot be performed because the device interface is currently active." },
    { 2148467228, "SPAPI_E_DEVICE_INTERFACE_REMOVED", "The operation cannot be performed because the device interface has been removed from the system." },
    { 2148467229, "SPAPI_E_BAD_INTERFACE_INSTALLSECT", "An interface installation section in this INF is invalid." },
    { 2148467230, "SPAPI_E_NO_SUCH_INTERFACE_CLASS", "This interface class does not exist in the system." },
    { 2148467231, "SPAPI_E_INVALID_REFERENCE_STRING", "The reference string supplied for this interface device is invalid." },
    { 2148467232, "SPAPI_E_INVALID_MACHINENAME", "The specified machine name does not conform to UNC naming conventions." },
    { 2148467233, "SPAPI_E_REMOTE_COMM_FAILURE", "A general remote communication error occurred." },
    { 2148467234, "SPAPI_E_MACHINE_UNAVAILABLE", "The machine selected for remote communication is not available at this time." },
    { 2148467235, "SPAPI_E_NO_CONFIGMGR_SERVICES", "The Plug and Play service is not available on the remote machine." },
    { 2148467236, "SPAPI_E_INVALID_PROPPAGE_PROVIDER", "The property page provider registry entry is invalid." },
    { 2148467237, "SPAPI_E_NO_SUCH_DEVICE_INTERFACE", "The requested device interface is not present in the system." },
    { 2148467238, "SPAPI_E_DI_POSTPROCESSING_REQUIRED", "The device's co-installer has additional work to perform after installation is complete." },
    { 2148467239, "SPAPI_E_INVALID_COINSTALLER", "The device's co-installer is invalid." },
    { 2148467240, "SPAPI_E_NO_COMPAT_DRIVERS", "There are no compatible drivers for this device." },
    { 2148467241, "SPAPI_E_NO_DEVICE_ICON", "There is no icon that represents this device or device type." },
    { 2148467242, "SPAPI_E_INVALID_INF_LOGCONFIG", "A logical configuration specified in this INF is invalid." },
    { 2148467243, "SPAPI_E_DI_DONT_INSTALL", "The class installer has denied the request to install or upgrade this device." },
    { 2148467244, "SPAPI_E_INVALID_FILTER_DRIVER", "One of the filter drivers installed for this device is invalid." },
    { 2148467245, "SPAPI_E_NON_WINDOWS_NT_DRIVER", "The driver selected for this device does not support Windows 2000." },
    { 2148467246, "SPAPI_E_NON_WINDOWS_DRIVER", "The driver selected for this device does not support Windows." },
    { 2148467247, "SPAPI_E_NO_CATALOG_FOR_OEM_INF", "The third-party INF does not contain digital signature information." },
    { 2148467248, "SPAPI_E_DEVINSTALL_QUEUE_NONNATIVE", "An invalid attempt was made to use a device installation file queue for verification of digital signatures relative to other platforms." },
    { 2148467249, "SPAPI_E_NOT_DISABLEABLE", "The device cannot be disabled." },
    { 2148467250, "SPAPI_E_CANT_REMOVE_DEVINST", "The device could not be dynamically removed." },
    { 2148470784, "SPAPI_E_ERROR_NOT_INSTALLED", "No installed components were detected." },
    { 2148532225, "SCARD_F_INTERNAL_ERROR", "An internal consistency check failed." },
    { 2148532226, "SCARD_E_CANCELLED", "The action was cancelled by an SCardCancel request." },
    { 2148532227, "SCARD_E_INVALID_HANDLE", "The supplied handle was invalid." },
    { 2148532228, "SCARD_E_INVALID_PARAMETER", "One or more of the supplied parameters could not be properly interpreted." },
    { 2148532229, "SCARD_E_INVALID_TARGET", "Registry startup information is missing or invalid." },
    { 2148532230, "SCARD_E_NO_MEMORY", "Not enough memory available to complete this command." },
    { 2148532231, "SCARD_F_WAITED_TOO_LONG", "An internal consistency timer has expired." },
    { 2148532232, "SCARD_E_INSUFFICIENT_BUFFER", "The data buffer to receive returned data is too small for the returned data." },
    { 2148532233, "SCARD_E_UNKNOWN_READER", "The specified reader name is not recognized." },
    { 2148532234, "SCARD_E_TIMEOUT", "The user-specified timeout value has expired." },
    { 2148532235, "SCARD_E_SHARING_VIOLATION", "The smart card cannot be accessed because of other connections outstanding." },
    { 2148532236, "SCARD_E_NO_SMARTCARD", "The operation requires a Smart Card, but no Smart Card is currently in the device." },
    { 2148532237, "SCARD_E_UNKNOWN_CARD", "The specified smart card name is not recognized." },
    { 2148532238, "SCARD_E_CANT_DISPOSE", "The system could not dispose of the media in the requested manner." },
    { 2148532239, "SCARD_E_PROTO_MISMATCH", "The requested protocols are incompatible with the protocol currently in use with the smart card." },
    { 2148532240, "SCARD_E_NOT_READY", "The reader or smart card is not ready to accept commands." },
    { 2148532241, "SCARD_E_INVALID_VALUE", "One or more of the supplied parameters values could not be properly interpreted." },
    { 2148532242, "SCARD_E_SYSTEM_CANCELLED", "The action was cancelled by the system, presumably to log off or shut down." },
    { 2148532243, "SCARD_F_COMM_ERROR", "An internal communications error has been detected." },
    { 2148532244, "SCARD_F_UNKNOWN_ERROR", "An internal error has been detected, but the source is unknown." },
    { 2148532245, "SCARD_E_INVALID_ATR", "An ATR obtained from the registry is not a valid ATR string." },
    { 2148532246, "SCARD_E_NOT_TRANSACTED", "An attempt was made to end a non-existent transaction." },
    { 2148532247, "SCARD_E_READER_UNAVAILABLE", "The specified reader is not currently available for use." },
    { 2148532248, "SCARD_P_SHUTDOWN", "The operation has been aborted to allow the server application to exit." },
    { 2148532249, "SCARD_E_PCI_TOO_SMALL", "The PCI Receive buffer was too small." },
    { 2148532250, "SCARD_E_READER_UNSUPPORTED", "The reader driver does not meet minimal requirements for support." },
    { 2148532251, "SCARD_E_DUPLICATE_READER", "The reader driver did not produce a unique reader name." },
    { 2148532252, "SCARD_E_CARD_UNSUPPORTED", "The smart card does not meet minimal requirements for support." },
    { 2148532253, "SCARD_E_NO_SERVICE", "The Smart card resource manager is not running." },
    { 2148532254, "SCARD_E_SERVICE_STOPPED", "The Smart card resource manager has shut down." },
    { 2148532255, "SCARD_E_UNEXPECTED", "An unexpected card error has occurred." },
    { 2148532256, "SCARD_E_ICC_INSTALLATION", "No Primary Provider can be found for the smart card." },
    { 2148532257, "SCARD_E_ICC_CREATEORDER", "The requested order of object creation is not supported." },
    { 2148532258, "SCARD_E_UNSUPPORTED_FEATURE", "This smart card does not support the requested feature." },
    { 2148532259, "SCARD_E_DIR_NOT_FOUND", "The identified directory does not exist in the smart card." },
    { 2148532260, "SCARD_E_FILE_NOT_FOUND", "The identified file does not exist in the smart card." },
    { 2148532261, "SCARD_E_NO_DIR", "The supplied path does not represent a smart card directory." },
    { 2148532262, "SCARD_E_NO_FILE", "The supplied path does not represent a smart card file." },
    { 2148532263, "SCARD_E_NO_ACCESS", "Access is denied to this file." },
    { 2148532264, "SCARD_E_WRITE_TOO_MANY", "An attempt was made to write more data than would fit in the target object." },
    { 2148532265, "SCARD_E_BAD_SEEK", "There was an error trying to set the smart card file object pointer." },
    { 2148532266, "SCARD_E_INVALID_CHV", "The supplied PIN is incorrect." },
    { 2148532267, "SCARD_E_UNKNOWN_RES_MNG", "An unrecognized error code was returned from a layered component." },
    { 2148532268, "SCARD_E_NO_SUCH_CERTIFICATE", "The requested certificate does not exist." },
    { 2148532269, "SCARD_E_CERTIFICATE_UNAVAILABLE", "The requested certificate could not be obtained." },
    { 2148532270, "SCARD_E_NO_READERS_AVAILABLE", "Cannot find a smart card reader." },
    { 2148532271, "SCARD_E_COMM_DATA_LOST", "A communications error with the smart card has been detected.  Retry the operation." },
    { 2148532325, "SCARD_W_UNSUPPORTED_CARD", "The reader cannot communicate with the smart card, due to ATR configuration conflicts." },
    { 2148532326, "SCARD_W_UNRESPONSIVE_CARD", "The smart card is not responding to a reset." },
    { 2148532327, "SCARD_W_UNPOWERED_CARD", "Power has been removed from the smart card, so that further communication is not possible." },
    { 2148532328, "SCARD_W_RESET_CARD", "The smart card has been reset, so any shared state information is invalid." },
    { 2148532329, "SCARD_W_REMOVED_CARD", "The smart card has been removed, so that further communication is not possible." },
    { 2148532330, "SCARD_W_SECURITY_VIOLATION", "Access was denied because of a security violation." },
    { 2148532331, "SCARD_W_WRONG_CHV", "The card cannot be accessed because the wrong PIN was presented." },
    { 2148532332, "SCARD_W_CHV_BLOCKED", "The card cannot be accessed because the maximum number of PIN entry attempts has been reached." },
    { 2148532333, "SCARD_W_EOF", "The end of the smart card file has been reached." },
    { 2148532334, "SCARD_W_CANCELLED_BY_USER", "The action was cancelled by the user." },
    { 2148598785, "COMADMIN_E_OBJECTERRORS", "Errors occurred accessing one or more objects - the ErrorInfo collection may have more detail" },
    { 2148598786, "COMADMIN_E_OBJECTINVALID", "One or more of the object's properties are missing or invalid" },
    { 2148598787, "COMADMIN_E_KEYMISSING", "The object was not found in the catalog" },
    { 2148598788, "COMADMIN_E_ALREADYINSTALLED", "The object is already registered" },
    { 2148598791, "COMADMIN_E_APP_FILE_WRITEFAIL", "Error occurred writing to the application file" },
    { 2148598792, "COMADMIN_E_APP_FILE_READFAIL", "Error occurred reading the application file" },
    { 2148598793, "COMADMIN_E_APP_FILE_VERSION", "Invalid version number in application file" },
    { 2148598794, "COMADMIN_E_BADPATH", "The file path is invalid" },
    { 2148598795, "COMADMIN_E_APPLICATIONEXISTS", "The application is already installed" },
    { 2148598796, "COMADMIN_E_ROLEEXISTS", "The role already exists" },
    { 2148598797, "COMADMIN_E_CANTCOPYFILE", "An error occurred copying the file" },
    { 2148598799, "COMADMIN_E_NOUSER", "One or more users are not valid" },
    { 2148598800, "COMADMIN_E_INVALIDUSERIDS", "One or more users in the application file are not valid" },
    { 2148598801, "COMADMIN_E_NOREGISTRYCLSID", "The component's CLSID is missing or corrupt" },
    { 2148598802, "COMADMIN_E_BADREGISTRYPROGID", "The component's progID is missing or corrupt" },
    { 2148598803, "COMADMIN_E_AUTHENTICATIONLEVEL", "Unable to set required authentication level for update request" },
    { 2148598804, "COMADMIN_E_USERPASSWDNOTVALID", "The identity or password set on the application is not valid" },
    { 2148598808, "COMADMIN_E_CLSIDORIIDMISMATCH", "Application file CLSIDs or IIDs do not match corresponding DLLs" },
    { 2148598809, "COMADMIN_E_REMOTEINTERFACE", "Interface information is either missing or changed" },
    { 2148598810, "COMADMIN_E_DLLREGISTERSERVER", "DllRegisterServer failed on component install" },
    { 2148598811, "COMADMIN_E_NOSERVERSHARE", "No server file share available" },
    { 2148598813, "COMADMIN_E_DLLLOADFAILED", "DLL could not be loaded" },
    { 2148598814, "COMADMIN_E_BADREGISTRYLIBID", "The registered TypeLib ID is not valid" },
    { 2148598815, "COMADMIN_E_APPDIRNOTFOUND", "Application install directory not found" },
    { 2148598819, "COMADMIN_E_REGISTRARFAILED", "Errors occurred while in the component registrar" },
    { 2148598820, "COMADMIN_E_COMPFILE_DOESNOTEXIST", "The file does not exist" },
    { 2148598821, "COMADMIN_E_COMPFILE_LOADDLLFAIL", "The DLL could not be loaded" },
    { 2148598822, "COMADMIN_E_COMPFILE_GETCLASSOBJ", "GetClassObject failed in the DLL" },
    { 2148598823, "COMADMIN_E_COMPFILE_CLASSNOTAVAIL", "The DLL does not support the components listed in the TypeLib" },
    { 2148598824, "COMADMIN_E_COMPFILE_BADTLB", "The TypeLib could not be loaded" },
    { 2148598825, "COMADMIN_E_COMPFILE_NOTINSTALLABLE", "The file does not contain components or component information" },
    { 2148598826, "COMADMIN_E_NOTCHANGEABLE", "Changes to this object and its sub-objects have been disabled" },
    { 2148598827, "COMADMIN_E_NOTDELETEABLE", "The delete function has been disabled for this object" },
    { 2148598828, "COMADMIN_E_SESSION", "The server catalog version is not supported" },
    { 2148598829, "COMADMIN_E_COMP_MOVE_LOCKED", "The component move was disallowed, because the source or destination application is either a system application or currently locked against changes" },
    { 2148598830, "COMADMIN_E_COMP_MOVE_BAD_DEST", "The component move failed because the destination application no longer exists" },
    { 2148598832, "COMADMIN_E_REGISTERTLB", "The system was unable to register the TypeLib" },
    { 2148598835, "COMADMIN_E_SYSTEMAPP", "This operation can not be performed on the system application" },
    { 2148598836, "COMADMIN_E_COMPFILE_NOREGISTRAR", "The component registrar referenced in this file is not available" },
    { 2148598837, "COMADMIN_E_COREQCOMPINSTALLED", "A component in the same DLL is already installed" },
    { 2148598838, "COMADMIN_E_SERVICENOTINSTALLED", "The service is not installed" },
    { 2148598839, "COMADMIN_E_PROPERTYSAVEFAILED", "One or more property settings are either invalid or in conflict with each other" },
    { 2148598840, "COMADMIN_E_OBJECTEXISTS", "The object you are attempting to add or rename already exists" },
    { 2148598843, "COMADMIN_E_REGFILE_CORRUPT", "The registration file is corrupt" },
    { 2148598844, "COMADMIN_E_PROPERTY_OVERFLOW", "The property value is too large" },
    { 2148598846, "COMADMIN_E_NOTINREGISTRY", "Object was not found in registry" },
    { 2148598847, "COMADMIN_E_OBJECTNOTPOOLABLE", "This object is not poolable" },
    { 2148598854, "COMADMIN_E_APPLID_MATCHES_CLSID", "A CLSID with the same GUID as the new application ID is already installed on this machine" },
    { 2148598855, "COMADMIN_E_ROLE_DOES_NOT_EXIST", "A role assigned to a component, interface, or method did not exist in the application" },
    { 2148598856, "COMADMIN_E_START_APP_NEEDS_COMPONENTS", "You must have components in an application in order to start the application" },
    { 2148598857, "COMADMIN_E_REQUIRES_DIFFERENT_PLATFORM", "This operation is not enabled on this platform" },
    { 2148598858, "COMADMIN_E_CAN_NOT_EXPORT_APP_PROXY", "Application Proxy is not exportable" },
    { 2148598859, "COMADMIN_E_CAN_NOT_START_APP", "Failed to start application because it is either a library application or an application proxy" },
    { 2148598860, "COMADMIN_E_CAN_NOT_EXPORT_SYS_APP", "System application is not exportable" },
    { 2148598861, "COMADMIN_E_CANT_SUBSCRIBE_TO_COMPONENT", "Can not subscribe to this component (the component may have been imported)" },
    { 2148599296, "COMQC_E_APPLICATION_NOT_QUEUED", "Only COM+ applications marked 'queued' can be created using the 'queue' moniker." },
    { 2148599297, "COMQC_E_NO_QUEUEABLE_INTERFACES", "At least one interface must be marked 'queued' in order to create a queued component instance with the 'queue' moniker." },
    { 2148599298, "COMQC_E_QUEUING_SERVICE_NOT_AVAILABLE", "MSMQ, which is required for the requested operation, is not installed." },
    { 2148599816, "COMADMIN_E_OBJECT_PARENT_MISSING", "One of the objects being inserted or updated does not belong to a valid parent collection" },
    { 2148599817, "COMADMIN_E_OBJECT_DOES_NOT_EXIST", "One of the specified objects cannot be found" },
} ; 


#endif //ERRMSGS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\errsay\errsay.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       errsay.h
//
//--------------------------------------------------------------------------

#ifndef ERRSAY_H
#define ERRSAY_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wtypes.h>
#include <windows.h>

#define SCODE_CODE(sc)      ((sc) & 0xFFFF)

extern char *pszDesiredNumber, *pszDesiredName, *pszErrorToFind;
extern DWORD dwDesiredNumber;
extern BOOL fFoundError;

//Function prototypes
DWORD StringToDWORD( char * pszStringToDWORD );
BOOL PrintErrorMessage( ERRORMESSAGE pEMessage );
BOOL GetErrorNumber();
BOOL GetErrorName();
void NoErrorIDGiven();
void NoErrorFound();
BOOL SeekErrorByNumber();
BOOL SeekErrorByName();
void Usage();


#endif // ERRSAY_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\errparse\errparse.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       errparse.h
//
//--------------------------------------------------------------------------

#ifndef ERRPARSE_H
#define ERRPARSE_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

#define MAX_LINE 1024

//extern BOOL fFoundIfDef;
extern char *pErrFileName;
extern char *pParsedErrorsName;
extern FILE *pErrorsFile , *pParsedErrorsFile;
extern DWORD dwErrorsParsed;
extern struct NODE *pCapturedError, *pFirstCapturedError;

//Prototypes for functions
void Usage( ); 
void PrintErrorFileHead( int iErrorCount );
BOOL PrintErrorMessages( );
void PrintErrorFileTail( );
BOOL OpenErrorFile( char * pFileName );
BOOL CreateErrorFile( char * pFileName );
void GetErrors( );
BOOL InsertIntoList( DWORD dwTmpErrorNumber, NODE * pCurrent );
BOOL DestroyErrorMessages( );

void death( char * pError );
            

//**************************************************************
class CErrorMessage
// Class to hold error messages for later spewing
// Basic functions: constructors, deconstructors,
// Members: ErrorNumber, SymbolicName, Description
//**************************************************************
{
public:
    CErrorMessage( DWORD dwErrorNumber = 0, char *pszSymbolicName = NULL, char *pszDescription = NULL);
    ~CErrorMessage();
    BOOL CPrint( FILE * pFile );
    BOOL CSetErrorMessage( DWORD dwErrorNumber, char *pszSymbolicName = NULL, char *pszDescription = NULL);
    DWORD CGetErrorNumber() { return( m_dwErrorNumber ); };
    const char * CGetSymbolicName() { return( m_pszSymbolicName ); };
    const char * CGetDescription() { return( m_pszDescription ); };

private:
    DWORD m_dwErrorNumber;
    char * m_pszSymbolicName;
    char * m_pszDescription;
} ;


//**************************************************************
struct NODE
//Struct for linked list
//**************************************************************
{
    CErrorMessage  ErrorMessage;
    NODE *pNext;
} ;


#endif //ERRPARSE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\errparse\utils.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       utils.cpp
//
//--------------------------------------------------------------------------

#include "errparse.h"


//**************************************************************
void Usage() 
//Show the user how to use this program
//**************************************************************
{
    printf( "Usage: errparse ...\n"
            "  FILENAME     Error file(s) to be parsed"
            "Example:\n"
            "    errparse mmserrror.h winerror.h\n\n ");

    exit( 0 );
}

//**************************************************************
void PrintErrorFileHead( DWORD dwErrorCount )
// Prints out header with the total number of error messages.
// Also define struct that error messages will adhere to.
//**************************************************************
{
    
    fprintf( pParsedErrorsFile, "#ifndef ERRMSGS_H\n" );
    fprintf( pParsedErrorsFile, "#define ERRMSGS_H\n\n" );

    fprintf( pParsedErrorsFile, "#include <stdio.h>\n" );
    fprintf( pParsedErrorsFile, "#include <stdlib.h>\n" );
    fprintf( pParsedErrorsFile, "#include <string.h>\n" );
    fprintf( pParsedErrorsFile, "#include <windows.h>\n\n" );

    fprintf( pParsedErrorsFile, "#define MAX_MES %lu\n\n", dwErrorCount );

    fprintf( pParsedErrorsFile, "struct ERRORMESSAGE\n" );
    fprintf( pParsedErrorsFile, "{\n" );
    fprintf( pParsedErrorsFile, "    DWORD num;\n" );
    fprintf( pParsedErrorsFile, "    char * name; \n" );
    fprintf( pParsedErrorsFile, "    char * desc; \n" );
    fprintf( pParsedErrorsFile, "} ;\n\n" );    
    fprintf( pParsedErrorsFile, "ERRORMESSAGE eMessages[MAX_MES] = \n" );
    fprintf( pParsedErrorsFile, "{\n" );
}


//**************************************************************
BOOL PrintErrorMessages()
//Print out all error messages to the output file
//Return false if we fail, main will cleanup
//**************************************************************
{
    PrintErrorFileHead(dwErrorsParsed);

    //Move to the front of the list for printing purposes
    pCapturedError = pFirstCapturedError;
    
    //Error Print Section
    //Continue printing until either we exit or reach the NULL pointer
    // indicating end of list
    for( ;; )
    {
        //Print contents of this element
        if ( !( pCapturedError->ErrorMessage.CPrint( pParsedErrorsFile ) ) )
        {
            return( FALSE );
        }

        //NULL pointer would indicate that the item we are on is the last item in the list
        if( NULL == pCapturedError->pNext )
        {
            break;
        }
        //Move to next element (since there now should be one <g>)
        pCapturedError = pCapturedError->pNext;
    }

    PrintErrorFileTail();

    return( TRUE );
}


//**************************************************************
void PrintErrorFileTail ()
// Closes the struct array in the c file we built
//**************************************************************
{
    fprintf( pParsedErrorsFile, "} ; \n\n\n" );
    fprintf( pParsedErrorsFile, "#endif //ERRMSGS_H\n" );
}



//**************************************************************
BOOL DestroyErrorMessages( )
//Destroy the linked list
//**************************************************************
{    
    NODE pTemp;

    pCapturedError = pFirstCapturedError;
    pTemp.pNext = pCapturedError->pNext;
    
    while( NULL != pCapturedError->pNext )
    {
        pCapturedError->ErrorMessage.~CErrorMessage();
        pCapturedError = pTemp.pNext;
        pTemp.pNext = pCapturedError->pNext;        
    }    
    
    pCapturedError->ErrorMessage.~CErrorMessage();

    return( TRUE );
}



//**************************************************************
void death( char * pError )
//The Little Death function.  Returns error, closes files.
//**************************************************************
{
    printf("%s", pError);
    if( NULL != pParsedErrorsFile )
    {
        (void) fclose( pParsedErrorsFile );
    }
    if( NULL != pErrorsFile )
    {
        (void) fclose( pErrorsFile );
    }
    exit( 1 );
}

//**************************************************************
BOOL OpenErrorFile( char * pFileName )
// Simply opens the error file for output
//**************************************************************
{
       
    //Error check: Show me what we're trying to open
    printf( "File: %s\n", pFileName );
        
    //open error file
    pErrorsFile = fopen( pFileName, "r" );
        
    //ensure fopen succeeded
    return( NULL != pErrorsFile );
}

//**************************************************************
BOOL CreateErrorFile( char * pFileName )
// Open the output file for writing to
//**************************************************************
{
    //Error check: Show me what we're trying to open
    printf( "Output file: %s\n", pFileName );
        
    //open error file
    pParsedErrorsFile = fopen( pFileName, "w" );
        
    //ensure fopen succeeded
    return( NULL != pParsedErrorsFile );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\rc4hmac\rc4Hmac.cpp ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#include <windows.h>
#include <objbase.h>
#include <stdio.h>
#include <assert.h>
#include "md5.h"
#include "sha.h"
#include "rc4.h"

//////////////////////////////////////////////////////////////////////////
//
// SHA1 HMAC calculation
//
//////////////////////////////////////////////////////////////////////////
static void shaHmac(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData // length must be A_SHA_DIGEST_LEN
    )
{
	#define HMAC_K_PADSIZE 64
    BYTE Kipad[HMAC_K_PADSIZE];
    BYTE Kopad[HMAC_K_PADSIZE];
    BYTE HMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];
    ULONG dwBlock;
    A_SHA_CTX shaHash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    RtlZeroMemory(Kipad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kipad, pbKeyMaterial, cbKeyMaterial);

    RtlZeroMemory(Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kopad, pbKeyMaterial, cbKeyMaterial);

    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)Kipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)Kopad)[dwBlock] ^= 0x5C5C5C5C;
    }

    //
    // prepend Kipad to data, Hash to get H1
    //

    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
    {
        A_SHAUpdate(&shaHash, pbData, cbData);
    }
    if (cbData2 != 0)
    {
        A_SHAUpdate(&shaHash, pbData2, cbData2);
    }

    // Finish off the hash
    A_SHAFinal(&shaHash,HMACTmp+HMAC_K_PADSIZE);

    // prepend Kopad to H1, hash to get HMAC
    RtlCopyMemory(HMACTmp, Kopad, HMAC_K_PADSIZE);

    // final hash: output value into passed-in buffer
    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash,HMACTmp, sizeof(HMACTmp));
    A_SHAFinal(&shaHash,HmacData);
}

//////////////////////////////////////////////////////////////////////////
//
// MD5 HMAC calculation
//
//////////////////////////////////////////////////////////////////////////
static void md5Hmac(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData // length must be MD5_LEN
    )
{
	#define HMAC_K_PADSIZE 64
    BYTE Kipad[HMAC_K_PADSIZE];
    BYTE Kopad[HMAC_K_PADSIZE];
    BYTE HMACTmp[HMAC_K_PADSIZE+MD5_LEN];
    ULONG dwBlock;
    MD5_CTX Md5Hash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    RtlZeroMemory(Kipad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kipad, pbKeyMaterial, cbKeyMaterial);

    RtlZeroMemory(Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kopad, pbKeyMaterial, cbKeyMaterial);

    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)Kipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)Kopad)[dwBlock] ^= 0x5C5C5C5C;
    }

    //
    // prepend Kipad to data, Hash to get H1
    //
    MD5Init(&Md5Hash);
    MD5Update(&Md5Hash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
    {
        MD5Update(&Md5Hash, pbData, cbData);
    }
    if (cbData2 != 0)
    {
        MD5Update(&Md5Hash, pbData2, cbData2);
    }

    // Finish off the hash
    MD5Final(&Md5Hash);
    RtlCopyMemory(HMACTmp+HMAC_K_PADSIZE, Md5Hash.digest, MD5_LEN);

    // prepend Kopad to H1, hash to get HMAC
    RtlCopyMemory(HMACTmp, Kopad, HMAC_K_PADSIZE);

    // final hash: output value into passed-in buffer
    MD5Init(&Md5Hash);
    MD5Update(&Md5Hash,HMACTmp, sizeof(HMACTmp));
    MD5Final(&Md5Hash);
    RtlCopyMemory(HmacData, Md5Hash.digest, MD5_LEN);

}


#define RC4_CONFOUNDER_LEN 8

typedef struct RC4_SHA1_HEADER {
    UCHAR Checksum[A_SHA_DIGEST_LEN];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
} *PRC4_SHA1_HEADER;

typedef struct RC4_MD5_HEADER {
    UCHAR Checksum[MD5_LEN];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
} *PRC4_MD5_HEADER;

static void rc4Sha1HmacEncrypt(
    IN PUCHAR confounder, // RC4_CONFOUNDER_LEN bytes
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbHeader // A_SHA_DIGEST_LEN + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    BYTE LocalKey[A_SHA_DIGEST_LEN];
    RC4_KEYSTRUCT Rc4KeyStruct;

    //
    // Create the header - the confounder & checksum
    //
    RtlZeroMemory( CryptHeader->Checksum, A_SHA_DIGEST_LEN );
    RtlCopyMemory( CryptHeader->Confounder, confounder, RC4_CONFOUNDER_LEN );

    //
    // Checksum everything but the checksum
    //
    shaHmac( pbKey, cbKey,
             CryptHeader->Confounder, RC4_CONFOUNDER_LEN,
             pbInput, cbInput,
             CryptHeader->Checksum );

    //
    // HMAC the checksum into the key
    //
    shaHmac( pbKey, cbKey,
             CryptHeader->Checksum, A_SHA_DIGEST_LEN,
             NULL, 0,
             LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    rc4_key( &Rc4KeyStruct, A_SHA_DIGEST_LEN, LocalKey );

    //
    // Encrypt everything but the checksum
    //
    rc4( &Rc4KeyStruct, RC4_CONFOUNDER_LEN, CryptHeader->Confounder );
    rc4( &Rc4KeyStruct, cbInput, pbInput );
}

static BOOL rc4Sha1HmacDecrypt(
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    IN PUCHAR pbHeader // A_SHA_DIGEST_LEN + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    RC4_SHA1_HEADER TempHeader;
    BYTE LocalKey[A_SHA_DIGEST_LEN];
    RC4_KEYSTRUCT Rc4KeyStruct;

    RtlCopyMemory( TempHeader.Confounder, CryptHeader->Confounder, RC4_CONFOUNDER_LEN );

    //
    // HMAC the checksum into the key
    //
    shaHmac( pbKey, cbKey,
             CryptHeader->Checksum, A_SHA_DIGEST_LEN,
             NULL, 0,
             LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    rc4_key( &Rc4KeyStruct, A_SHA_DIGEST_LEN, LocalKey );

    //
    // Decrypt confounder and data
    //
    rc4( &Rc4KeyStruct, RC4_CONFOUNDER_LEN, TempHeader.Confounder );
    rc4( &Rc4KeyStruct, cbInput, pbInput );

    //
    // Now verify the checksum.
    //
    shaHmac( pbKey, cbKey,
             TempHeader.Confounder, RC4_CONFOUNDER_LEN,
             pbInput, cbInput,
             TempHeader.Checksum );

    //
    // Decrypt is successful only if checksum matches
    //
    return ( RtlEqualMemory(
                 TempHeader.Checksum,
                 CryptHeader->Checksum,
                 A_SHA_DIGEST_LEN) );
}

static void rc4Md5HmacEncrypt(
    IN PUCHAR confounder, // RC4_CONFOUNDER_LEN bytes
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbHeader // MD5_LEN + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_MD5_HEADER CryptHeader = (PRC4_MD5_HEADER) pbHeader;
    BYTE LocalKey[MD5_LEN];
    RC4_KEYSTRUCT Rc4KeyStruct;

    //
    // Create the header - the confounder & checksum
    //
    RtlZeroMemory( CryptHeader->Checksum, MD5_LEN );
    RtlCopyMemory( CryptHeader->Confounder, confounder, RC4_CONFOUNDER_LEN );

    //
    // Checksum everything but the checksum
    //
    md5Hmac( pbKey, cbKey,
             CryptHeader->Confounder, RC4_CONFOUNDER_LEN,
             pbInput, cbInput,
             CryptHeader->Checksum );

    //
    // HMAC the checksum into the key
    //
    md5Hmac( pbKey, cbKey,
             CryptHeader->Checksum, MD5_LEN,
             NULL, 0,
             LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    rc4_key( &Rc4KeyStruct, MD5_LEN, LocalKey );

    //
    // Encrypt everything but the checksum
    //
    rc4( &Rc4KeyStruct, RC4_CONFOUNDER_LEN, CryptHeader->Confounder );
    rc4( &Rc4KeyStruct, cbInput, pbInput );
}

static BOOL rc4Md5HmacDecrypt(
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    IN PUCHAR pbHeader // MD5_LEN + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_MD5_HEADER CryptHeader = (PRC4_MD5_HEADER) pbHeader;
    RC4_MD5_HEADER TempHeader;
    BYTE LocalKey[MD5_LEN];
    RC4_KEYSTRUCT Rc4KeyStruct;

    RtlCopyMemory( TempHeader.Confounder, CryptHeader->Confounder, RC4_CONFOUNDER_LEN );

    //
    // HMAC the checksum into the key
    //
    md5Hmac( pbKey, cbKey,
             CryptHeader->Checksum, MD5_LEN,
             NULL, 0,
             LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    rc4_key( &Rc4KeyStruct, MD5_LEN, LocalKey );

    //
    // Decrypt confounder and data
    //
    rc4( &Rc4KeyStruct, RC4_CONFOUNDER_LEN, TempHeader.Confounder );
    rc4( &Rc4KeyStruct, cbInput, pbInput );

    //
    // Now verify the checksum.
    //
    md5Hmac( pbKey, cbKey,
             TempHeader.Confounder, RC4_CONFOUNDER_LEN,
             pbInput, cbInput,
             TempHeader.Checksum );

    {
        char statekey[64],localkey[64];
        DWORD k;
        for (k=0; k<cbKey; ++k)
        {
            sprintf(statekey+2*k,"%02X", pbKey[k]);
            sprintf(localkey+2*k,"%02X", LocalKey[k]);
        }
        statekey[2*cbKey] = localkey[2*cbKey] = '\0';	        
        printf( "rc4Md5HmacDecrypt salted key is %s\n",
            statekey);
        printf( "rc4Md5HmacDecrypt local key is %s\n",
            localkey );
    }

    //
    // Decrypt is successful only if checksum matches
    //
    return ( RtlEqualMemory(
                 TempHeader.Checksum,
                 CryptHeader->Checksum,
                 MD5_LEN) );
}

void PrintUsage()
{
    printf("Usage: rc4Hmac Type KeyInHex DataInHex\n");
}

int __cdecl main(
    int argc,
    char** argv
    )
{
	BYTE key[24];
	BYTE StateKey[MD5_LEN];
	BYTE data[1024];
	int byte;
	ULONG ulType;
	
	int i;
	int cbKey;
	int cbData;
	
	if (argc < 4)
	{
		PrintUsage();
		return 1;
	}

	ulType = atol(argv[1]);
	
	cbKey = strlen(argv[2]) >> 1;
	assert( cbKey < sizeof(key) );
	for (i = 0;  i < cbKey; ++i)
	{
        sscanf(&(argv[2][i*2]), "%2x", &byte );
        key[i] = (BYTE)byte;
	}
	
	cbData = strlen(argv[3]) >> 1;
	assert( cbData < sizeof(data) );
	assert( cbData > sizeof(RC4_MD5_HEADER) );
	for (i = 0;  i < cbData; ++i)
	{
        sscanf(&(argv[3][i*2]), "%2x", &byte );
        data[i] = (BYTE)byte;
	}

    md5Hmac( key, cbKey, (PBYTE) &ulType, sizeof(ULONG), NULL, 0, StateKey);

    {
        char keybuf[64];
        int k;
        for (k=0; k<cbKey; ++k)
        {
            sprintf(keybuf+2*k,"%02X", key[k]);
        }
        keybuf[2*cbKey] = '\0';	        
        printf( "rc4Md5HmacDecrypt salt is %d\n",
            ulType);
        printf( "rc4Md5HmacDecrypt raw key is %s\n",
            keybuf);
    }

	if (rc4Md5HmacDecrypt( StateKey, MD5_LEN, data + sizeof(RC4_MD5_HEADER), cbData - sizeof(RC4_MD5_HEADER), data ))
	{
		printf("rc4Md5HmacDecrypt succeeded!\n");
		for (i = sizeof(RC4_MD5_HEADER); i < cbData; ++i)
		{
	        printf( "%02X", data[i] );
		}
		printf("\n");
		for (i = sizeof(RC4_MD5_HEADER); i < cbData; ++i)
		{
	        printf( "%c", (char)data[i] );
		}		
		printf("\n");
	}
	else
	{
		printf("rc4Md5HmacDecrypt failed!\n");
	}

    if (cbData > 100000)
    {
    	rc4Sha1HmacEncrypt( 0,0,0,0,0,0 );
    	rc4Sha1HmacDecrypt( 0,0,0,0,0 );
    	rc4Md5HmacEncrypt( 0,0,0,0,0,0 );
    }
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\PwdToKey\md4ms.cpp ===
/*

    This second implementation of MD4 entry points is the newer style,
    optimized implementation, compatible with newer code expecting these
    entry point names.

    Modelled after MD5 and SHA-1.

    Scott Field (sfield)    21-Oct-97

*/

#include <windows.h>
#include <malloc.h>
#include "md4.h"
#include "uint4.h"

#ifndef RSA32API 
#define RSA32API
#endif

/* Compile-time macro declarations for MD4.
*/

/* ROTATE_LEFT rotates x left n bits.
 */
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))

void MD4Transform (UINT4 state[4], unsigned char block[64]);


#define S11 3
#define S12 7
#define S13 11
#define S14 19
#define S21 3
#define S22 5
#define S23 9
#define S24 13
#define S31 3
#define S32 9
#define S33 11
#define S34 15


static const unsigned char PADDING[64] = {
  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};


/* F, G and H are basic MD4 functions.
 */

#define F(x, y, z) ((z) ^ ((x) & ((y) ^ (z))))
#define G(x, y, z) (((x) & (y)) | ((z) & ((x) | (y))))
#define H(x, y, z) ((x) ^ (y) ^ (z))


/* FF, GG and HH are MD4 transformations for rounds 1, 2 and 3 */
/* Rotation is separate from addition to prevent recomputation */
#define FF(a, b, c, d, x, s) \
  {(a) += F ((b), (c), (d)) + (x); \
   (a) = ROTATE_LEFT ((a), (s));}
#define GG(a, b, c, d, x, s) \
  {(a) += G ((b), (c), (d)) + (x) + (UINT4)013240474631; \
   (a) = ROTATE_LEFT ((a), (s));}
#define HH(a, b, c, d, x, s) \
  {(a) += H ((b), (c), (d)) + (x) + (UINT4)015666365641; \
   (a) = ROTATE_LEFT ((a), (s));}


#ifdef KMODE_RSA32
#pragma alloc_text(PAGER32C, MD4Init)
#pragma alloc_text(PAGER32C, MD4Update)
#pragma alloc_text(PAGER32C, MD4Transform)
#pragma alloc_text(PAGER32C, MD4Final)
#endif  // KMODE_RSA32

/* MD4 initialization. Begins an MD4 operation, writing a new context.
 */
void
RSA32API
MD4Init (
    MD4_CTX *context                                         /* context */
    )
{
    context->count[0] = 0;
    context->count[1] = 0;

    /* Load magic initialization constants.
     */

    context->state[0] = 0x67452301;
    context->state[1] = 0xefcdab89;
    context->state[2] = 0x98badcfe;
    context->state[3] = 0x10325476;
}

/* MD4 block update operation. Continues an MD4 message-digest
     operation, processing another message block, and updating the
     context.
 */

void
RSA32API
MD4Update (
    MD4_CTX *context,                                        /* context */
    unsigned char *input,                                /* input block */
    unsigned int inputLen                      /* length of input block */
    )
{

  unsigned int bufferLen;

  /* Compute number of bytes mod 64 */
  bufferLen = (unsigned int)((context->count[0] >> 3) & 0x3F);

  /* Update number of bits */
  if ((context->count[0] += ((DWORD)inputLen << 3)) < ((DWORD)inputLen << 3))
    context->count[1]++;

  context->count[1] += ((DWORD)inputLen >> 29);

  /* If previous input in buffer, buffer new input and transform if
       possible.
   */
  if (bufferLen > 0 && bufferLen + inputLen >= 64) {
    memcpy(context->buffer+bufferLen, input, 64-bufferLen);
    input += (64-bufferLen);
    inputLen -= (64-bufferLen);
    MD4Transform (context->state, context->buffer);
    bufferLen = 0;
  }

    if( (DWORD_PTR)input & (sizeof(DWORD_PTR) - 1) ) {
        /* Copy input to aligned temporary buffer
         */
        while (inputLen >= 64) {
            memcpy( context->buffer, input, 64 );
            MD4Transform (context->state, context->buffer);
            input += 64;
            inputLen -= 64;
        }
    } else {
        /* Transform directly from input.
         */
        while (inputLen >= 64) {
            MD4Transform (context->state, input);
            input += 64;
            inputLen -= 64;
        }
    }

  /* Buffer remaining input */
  if (inputLen)
    memcpy(context->buffer+bufferLen, input, inputLen);

}

/* MD4 finalization. Ends an MD4 message-digest operation, writing the
     message digest and zeroizing the context.
 */
void
RSA32API
MD4Final (
    MD4_CTX *context                                         /* context */
    )
{
    unsigned int index, padLen;

    /* Save number of bits */

#if !defined(BIGENDIAN) || !BIGENDIAN
    ((unsigned long *)context->digest)[0] = context->count[0];
    ((unsigned long *)context->digest)[1] = context->count[1];
#else
  DWORDToLittleEndian (context->digest, context->count, 8);
#endif

    /* Pad out to 56 mod 64. */

    index = (unsigned int)((context->count[0] >> 3) & 0x3f);
    padLen = (index < 56) ? (56 - index) : (120 - index);
    MD4Update (context, (unsigned char *)PADDING, padLen);

    /* Append length (before padding) */

    MD4Update (context, context->digest, 8);

    /* Store state in digest */

#if !defined(BIGENDIAN) || !BIGENDIAN
    ((unsigned long *)context->digest)[0] = context->state[0];
    ((unsigned long *)context->digest)[1] = context->state[1];
    ((unsigned long *)context->digest)[2] = context->state[2];
    ((unsigned long *)context->digest)[3] = context->state[3];
#else
  DWORDToLittleEndian (context->digest, context->state, 16);
#endif

}

/* MD4 basic transformation. Transforms state based on block.
 */

//#ifndef _X86_ // use optimized .asm version of MD4Transform on x86

void
MD4Transform (
    UINT4 state[4],
    unsigned char block[64]
    )
{
  UINT4 a = state[0], b = state[1], c = state[2], d = state[3];

#if !defined(BIGENDIAN) || !BIGENDIAN
  unsigned long *x = (unsigned long*)block;
#else
  unsigned long x[16];
  DWORDFromLittleEndian (x, (unsigned char *)block, 64);
#endif

  /* Round 1 */
  FF (a, b, c, d, x[ 0], S11); /* 1 */
  FF (d, a, b, c, x[ 1], S12); /* 2 */
  FF (c, d, a, b, x[ 2], S13); /* 3 */
  FF (b, c, d, a, x[ 3], S14); /* 4 */
  FF (a, b, c, d, x[ 4], S11); /* 5 */
  FF (d, a, b, c, x[ 5], S12); /* 6 */
  FF (c, d, a, b, x[ 6], S13); /* 7 */
  FF (b, c, d, a, x[ 7], S14); /* 8 */
  FF (a, b, c, d, x[ 8], S11); /* 9 */
  FF (d, a, b, c, x[ 9], S12); /* 10 */
  FF (c, d, a, b, x[10], S13); /* 11 */
  FF (b, c, d, a, x[11], S14); /* 12 */
  FF (a, b, c, d, x[12], S11); /* 13 */
  FF (d, a, b, c, x[13], S12); /* 14 */
  FF (c, d, a, b, x[14], S13); /* 15 */
  FF (b, c, d, a, x[15], S14); /* 16 */

  /* Round 2 */
  GG (a, b, c, d, x[ 0], S21); /* 17 */
  GG (d, a, b, c, x[ 4], S22); /* 18 */
  GG (c, d, a, b, x[ 8], S23); /* 19 */
  GG (b, c, d, a, x[12], S24); /* 20 */
  GG (a, b, c, d, x[ 1], S21); /* 21 */
  GG (d, a, b, c, x[ 5], S22); /* 22 */
  GG (c, d, a, b, x[ 9], S23); /* 23 */
  GG (b, c, d, a, x[13], S24); /* 24 */
  GG (a, b, c, d, x[ 2], S21); /* 25 */
  GG (d, a, b, c, x[ 6], S22); /* 26 */
  GG (c, d, a, b, x[10], S23); /* 27 */
  GG (b, c, d, a, x[14], S24); /* 28 */
  GG (a, b, c, d, x[ 3], S21); /* 29 */
  GG (d, a, b, c, x[ 7], S22); /* 30 */
  GG (c, d, a, b, x[11], S23); /* 31 */
  GG (b, c, d, a, x[15], S24); /* 32 */

  /* Round 3 */
  HH (a, b, c, d, x[ 0], S31); /* 33 */
  HH (d, a, b, c, x[ 8], S32); /* 34 */
  HH (c, d, a, b, x[ 4], S33); /* 35 */
  HH (b, c, d, a, x[12], S34); /* 36 */
  HH (a, b, c, d, x[ 2], S31); /* 37 */
  HH (d, a, b, c, x[10], S32); /* 38 */
  HH (c, d, a, b, x[ 6], S33); /* 39 */
  HH (b, c, d, a, x[14], S34); /* 40 */
  HH (a, b, c, d, x[ 1], S31); /* 41 */
  HH (d, a, b, c, x[ 9], S32); /* 42 */
  HH (c, d, a, b, x[ 5], S33); /* 43 */
  HH (b, c, d, a, x[13], S34); /* 44 */
  HH (a, b, c, d, x[ 3], S31); /* 45 */
  HH (d, a, b, c, x[11], S32); /* 46 */
  HH (c, d, a, b, x[ 7], S33); /* 47 */
  HH (b, c, d, a, x[15], S34); /* 48 */

  state[0] += a;
  state[1] += b;
  state[2] += c;
  state[3] += d;
}


//+-------------------------------------------------------------------------

BOOL
KerbPasswordToKey(
    IN LPSTR pszPassword,
    OUT PUCHAR Key
    )
{
    BOOL fSucceed = FALSE;
    MD4_CTX md4Ctx;
    DWORD dwPasswordLen;
    DWORD dwResult;
    WCHAR* pwcUnicodePassword;

    dwPasswordLen = strlen(pszPassword);

    pwcUnicodePassword = (WCHAR*)_alloca( (dwPasswordLen + 1) * sizeof(WCHAR) );
    if (pwcUnicodePassword == NULL)
    {
        goto Cleanup;
    }
    
    dwResult = MultiByteToWideChar(
         CP_ACP,
         MB_PRECOMPOSED,
         pszPassword,
         dwPasswordLen,
         pwcUnicodePassword,
         dwPasswordLen * sizeof(WCHAR)
         );

    if (dwResult == 0) {
        goto Cleanup;
    }
    
    MD4Init( &md4Ctx );
    MD4Update( &md4Ctx, (unsigned char *)pwcUnicodePassword, dwPasswordLen * sizeof(WCHAR) );
    MD4Final( &md4Ctx );

    RtlCopyMemory( Key, md4Ctx.digest, MD4_LEN );
    
    fSucceed = TRUE;

Cleanup:
    return(fSucceed);
}

//#endif // !_X86_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\onlineaccounts2\inc\onlineaccounts2.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: OnlineAccounts.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the functions to muck with account status
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#ifdef _XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <xbox.h>

#include <winsockx.h>
#include <winsockp.h>
#endif

#include <xdbg.h>
#include <xonlinep.h>
#include <stdio.h>
#include <stdlib.h>

//
// how long should wait's wait
//

static const DWORD ONLINE_ACCOUNT_WAIT_INTERVAL = 30000;

//
// set up for cross compilation with windows and xbox
//

#ifndef _XBOX
class COnlineAccounts : public CXOnline
{
#else
class COnlineAccounts
{
#endif

protected:
	COnlineAccounts( LPSTR szName = NULL );

public:

	XONLINETASK_HANDLE m_hTask;

	//
	// destrcutor
	//

	~COnlineAccounts( void ) { }

	//
	// Get N random user accounts, put them on the hard drive
	//

	HRESULT 
	PopulateUserAccountsHD( PXONLINEP_USER aUsers, DWORD dwNumAccounts, BOOL bRemoveUsers = TRUE );

	//
	// Populate an MU with an account
	//

	HRESULT
	PopulateUserAccountsMU( CHAR chDrive, PXONLINEP_USER pUser );

	//
	// get the users and put them into an array
	//

	HRESULT
	GetUsers( PXONLINEP_USER aUsers, DWORD dwNumAccounts );

	//
	// quickly logon to the service
	//

	HRESULT
	QuickLogonStart( void );

	//
	// quickly logoff the service
	//

	HRESULT
	QuickLogonFinish( void );

	//
	// generate a user name
	//

	HRESULT
	GenerateUserName( CHAR szName[XONLINE_NAME_SIZE] );

	//
	// generate a user account
	//

	HRESULT
	GenerateUserAccount( PXONLINEP_USER pUser );
};


//
// modify a machine account
//

//HRESULT 
//ModifyMachineAccount( ULONGLONG ullId, LPSTR szName, LPSTR szPassword );

//
// verify the data in a machine account is what the user thinks...
//

//BOOL
//VerifyMachineAccount( ULONGLONG ullId, LPSTR szName, LPSTR szPassword );

//
// create an account
//

//HRESULT CreateMachineAccount( void );

//
// remove a machine account
//

//HRESULT RemoveMachineAccount( void );

//
// validate a machine account
//

//HRESULT ValidateMachineAccount( void );

//
// update the eeprom with devkit data
//

//HRESULT WriteEEPROMDevkitData( void );

//
// See if old Machine Account exists
//

//BOOL HasOldMachineAccount( void );

//
// see if old user accounts exist
//

//BOOL HasOldUserAccounts( void );

//
// read a line of user data from an ini file
//

//HRESULT 
//ReadUserData( FILE* pIniFile, PXONLINEP_USER pUser );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\SetupOnline\AccountCreationScreen.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: AccountCreationScreen.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the Interface for the account creation screen
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#include <xtl.h>
#include "myError.h"
#include <xonlinep.h>
#include <OnlineAccounts.h>

#include "UserInterfaceScreen.h"
#include "UserInterfaceText.h"
#include "PinEntryText.h"

//
// the strings
//

static const LPSTR CREATION_TEXTS[] = { "Creating User on PartnerNet.  ",
                                        "Creating User on PartnerNet . ",
								        "Creating User on PartnerNet  .",
									    "Creating User on PartnerNet . " };

static const LPSTR CREATION_SUCCEEDED_TEXT = "User Creation Succeeded";
static const LPSTR CREATION_ERROR_TEXT = "User Creation Failed";
static const LPSTR CREATION_DISK_FULL_TEXT = "User Creation Failed: Drive Full";
static const LPSTR CREATION_NULL_USER_TEXT = "No Name Entered: Generating Random Name";
static const LPSTR CREATION_USER_EXISTS_TEXT = "User Name Exists: Generated Random Name";
static const LPSTR CREATION_A_TEXT = "(A) OK";
static const LPSTR CREATION_B_TEXT = "(B) Back";

//
// the number of text states
//

static const DWORD NUM_CREATION_TEXT_STATES = 4;

//
// the CREATION screen colors
//

static const DWORD CREATION_SCREEN_FG_COLOR = 0xFFFFFFFF;
static const DWORD CREATION_SCREEN_BG_COLOR = 0xFF000000;

//
// the x and y location of text
//

static const DWORD CREATION_SCREEN_X = 320;
static const DWORD CREATION_SCREEN_Y = 250;

static const DWORD CREATION_A_X = 500;
static const DWORD CREATION_A_Y = 400;
static const DWORD CREATION_B_X = 140;
static const DWORD CREATION_B_Y = 400;

static const DWORD CREATION_INFO_X = 320;
static const DWORD CREATION_INFO_Y = 320;

//
// the fg / bg color
//

static const DWORD CREATION_A_FG_COLOR = 0xFF00FF00;
static const DWORD CREATION_A_BG_COLOR = 0xFF000000;
static const DWORD CREATION_B_FG_COLOR = 0xFFFF0000;
static const DWORD CREATION_B_BG_COLOR = 0xFF000000;

static const DWORD CREATION_INFO_FG_COLOR = 0xFFFFFFFF;
static const DWORD CREATION_INFO_BG_COLOR = 0xFF000000;

//
// struct to hold thread params for USer account creation
//

struct SUserParams {
	LPBYTE pBytes;
	LPSTR szName;
};

//
// the account creation screen class
//

class CAccountCreationScreen : public CUserInterfaceScreen {

public:

	//
	// constructor / destructor
	//

	CAccountCreationScreen( CUserInterfaceScreen* pParent );

	~CAccountCreationScreen( void );

	//
	// overloaded user input
	//

	virtual CUserInterfaceScreen* Update( CUserInterfaceInput* pInput, 
		                                  CUserInterfaceAudio* pAudio );

	//
	// set the pin and the name
	//

	void SetPin( LPBYTE pBytes ) { m_params.pBytes = pBytes; };
	void SetName( LPSTR szName ) { m_params.szName = szName; };

private:

	//
	// helper to update text based on thread status
	//

	void UpdateText( void );

	//
	// code to generate create user on partnernet
	//

	static DWORD WINAPI GenerateUser( LPVOID lpParam );

	//
	// handle for the thread
	//

	HANDLE m_hThread;

	//
	// the final hr value
	//

	HRESULT m_hrFinal;

	//
	// ui text
	//

	CUserInterfaceText m_aText;
	CUserInterfaceText m_bText;
	CUserInterfaceText m_infoText;

	//
	// the params
	//

	SUserParams m_params;

	//
	// place to hold the current creation text index
	//

	DWORD m_dwTextIndex;

	//
	// only have 1 creation per time
	//

	BOOL m_bCreationOnce;

	//
	// the current creation state
	//
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\PwdToKey\PwdToKey.cpp ===
//===================================================================
//
// Copyright Microsoft Corporation. All Right Reserved.
//
//===================================================================
#include <windows.h>
#include <stdio.h>
#include <assert.h>
#include "md4.h"

BOOL
KerbPasswordToKey(
    IN LPSTR pszPassword,
    OUT PUCHAR Key
    );

void PrintUsage()
{
    printf("Usage: PwdToKey password\n");
}

extern "C"
int
_cdecl
main(
    int argc,
    char** argv
    )
{
    int i;
    BYTE key[MD4_LEN];
    
    if (argc != 2)
    {
        PrintUsage();
        return 1;
    }

    if (!KerbPasswordToKey( argv[1], key ))
    {
        printf("PwdToKey: error in KerbPasswordToKey\n");
        return 1;
    }

    printf("PwdToKey: key is 0x");
    for (i=0; i<MD4_LEN; ++i)
    {
        printf("%02X", key[i]);
    }
    printf("\n");
    
    printf("key is \"");
    for (i=0; i<MD4_LEN; ++i)
    {
        printf("\\x%02X", key[i]);
    }
    printf("\"\n");
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\OnlineAccounts\src\OnlineAccounts.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: OnlineAccounts.cpp
//
// Author: Dan Rosenstein (danrose)
//
// Description: the functions to muck with account status
//
///////////////////////////////////////////////////////////////////////////////

#ifdef _XBOX
#define NTLEANANDMEAN
#define _WIN32_WINNT 0x0500
 
#include <nt.h>
#include <ntrtl.h>
#endif

#include "OnlineAccounts.h"

#ifdef _XBOX
extern "C" { 
#include <init.h> 
}
#include <xboxp.h>
#endif

//#include <cryptkeys.h>
#ifdef _XBOX
#include <xconfig.h>
#endif
//#include <memory.h>
#include <time.h>
/*
BOOL
KerbPasswordToKey(
    IN LPSTR pszPassword,
    OUT BYTE* Key
    );
*/
///////////////////////////////////////////////////////////////////////////////
//
// global logon handle
//
///////////////////////////////////////////////////////////////////////////////

XONLINETASK_HANDLE g_hTask = NULL;

//
// init static variables
//

COnlineAccounts* COnlineAccounts::m_pAccounts = NULL;

///////////////////////////////////////////////////////////////////////////////
//
// Name: Constructor
//
// Input: szName - the name of the online object
//
// Output: an instance of the class
//
// Description: creates the OnlineAccounts class
//
///////////////////////////////////////////////////////////////////////////////

COnlineAccounts::COnlineAccounts( LPSTR szName )
#ifndef _XBOX
	: CXOnline( szName )
#endif

{
	ASSERT( NULL == m_pAccounts );

	m_pAccounts = this;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Instance
//
// Input: szName - the name of the online object
//
// Output: a pointer to the class
//
// Description: createsa singleton of the class
//
///////////////////////////////////////////////////////////////////////////////

COnlineAccounts*
COnlineAccounts::Instance( LPSTR szName )
{
	if ( NULL == m_pAccounts )
	{
		m_pAccounts = new COnlineAccounts( szName );
		ASSERT( m_pAccounts );
	}

	return m_pAccounts;
}

/*
///////////////////////////////////////////////////////////////////////////////
//
// Name: ModifyMachineAccount
//
// Input: ullId - the new id
//
//        szName - the new name of the machine account
//		           If it is NULL, the machine name is cleared out
//
//		  szPassword - the new password of the machine account
//                     If it is NULL, the machine password is cleared out
//
// Output: S_OK if removing machine data from the Config Sector was successful 
//
// Description: Modifies the machine name and machine password
//
///////////////////////////////////////////////////////////////////////////////

HRESULT 
ModifyMachineAccount( ULONGLONG ullId, LPSTR szName, LPSTR szPassword )
{
#if 1
    RIP("should not call this anymore");
    return E_FAIL;
#else
	HRESULT hr = S_OK;
    XC_ONLINE_MACHINE_ACCOUNT_STRUCT machineAccount;

	//
	// Zero out the machine account
	//

	ZeroMemory( &machineAccount, sizeof( XC_ONLINE_MACHINE_ACCOUNT_STRUCT ) );

	//
	// setup the id for the machine account
	//

	machineAccount.xuid.qwUserID = ullId;

	//
	// Only fill in the name if it was passed in
	//
	
	if ( szName )
	{
		strcpy( machineAccount.name, szName );

		//
		// make the machine account noevmeber 11/01 compatible
		//

		machineAccount.reserved[XONLINE_ACCOUNT_RESERVED_SIZE - 4] = '1';
		machineAccount.reserved[XONLINE_ACCOUNT_RESERVED_SIZE - 3] = '1';
		machineAccount.reserved[XONLINE_ACCOUNT_RESERVED_SIZE - 2] = '0';
		machineAccount.reserved[XONLINE_ACCOUNT_RESERVED_SIZE - 1] = '1';
	}

	//
	// Only fill in the password if it was passed in, then encrypt it
	//

	if ( szPassword )
	{
		hr = KerbPasswordToKey( szPassword, machineAccount.key ) ? S_OK : E_FAIL;
		ASSERT( SUCCEEDED( hr ) || !"Could not convert password to key" );
		EncryptKeyWithHardDriveKey( machineAccount.key, 
			                        sizeof( machineAccount.key ) );
	}

	//
	// Update the config sector
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = XSetConfigValue( &g_OnlineMainConfigSectorInfo,
							  XC_ONLINE_MACHINE_ACCOUNT, 
							  REG_BINARY,
							  &machineAccount, 
							  sizeof( XC_ONLINE_MACHINE_ACCOUNT_STRUCT ) );

		hr = SUCCEEDED( hr ) ? S_OK : E_FAIL;
		ASSERT( SUCCEEDED( hr ) || !"Could not update config sector" );
	}

	//
	// spit back the final hresult
	//

	return hr;
#endif
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: RemoveMachineAccount
//
// Input: None
//
// Output: S_OK if removing machine data from the Config Sector was successful 
//
// Description: Removes the machine name and machine password
//
///////////////////////////////////////////////////////////////////////////////

HRESULT 
RemoveMachineAccount( void )
{
	return ModifyMachineAccount( 0, NULL, NULL );
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: CreateMachineAccount
//
// Input: None
//
// Output: S_OK if populating the Config Sector was successful 
//
// Description: creates the machine name and machine password
//
///////////////////////////////////////////////////////////////////////////////

HRESULT 
CreateMachineAccount( void )
{
	return ModifyMachineAccount( 1, 
		                         "SN999999999999@machines.xbox.com", 
								 "PASSWORD" );	
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: WriteEEPROMDevkitData
//
// Input: None
//
// Output: S_OK if populating the EEPROM was successful 
//
// Description: propogates the DEVKIT online key and serial number
//
///////////////////////////////////////////////////////////////////////////////

HRESULT WriteEEPROMDevkitData( void )
{
    BYTE buf[EEPROM_TOTAL_MEMORY_SIZE];
    EEPROM_LAYOUT* eeprom;
    XBOX_FACTORY_SETTINGS* factorySettings;
    BYTE OnlineKey[16];
    NTSTATUS status;
    DWORD type, size;
    BOOL bResult;
    HRESULT hr;

    eeprom = (EEPROM_LAYOUT*) buf;
    factorySettings = (XBOX_FACTORY_SETTINGS*) &eeprom->FactorySection;

    //
    // read EEPROM Data
    //
    status = ExQueryNonVolatileSetting(XC_MAX_ALL, &type, buf, sizeof(buf), &size);
    if (!NT_SUCCESS(status))
    {
        return E_FAIL;
    }

    ASSERT( type == REG_BINARY );
    ASSERT( size == EEPROM_TOTAL_MEMORY_SIZE );

    //
    // Put in the all 9 serial number for dev kits
    //
    if (!RtlEqualMemory( factorySettings->SerialNumber, "999999999999", sizeof(factorySettings->SerialNumber) ))
    {
        //
        // Save Serial Number into the EEPROM
        //
        status = ExSaveNonVolatileSetting(XC_FACTORY_SERIAL_NUMBER, REG_BINARY, "999999999999", sizeof(factorySettings->SerialNumber));
        if (!NT_SUCCESS(status))
        {
            return E_FAIL;
        }
    }


    //
    // Figure out the devkit online key and morph it
    //
    ASSERT( sizeof(OnlineKey) == sizeof(factorySettings->OnlineKey) );
    ASSERT( sizeof(OnlineKey) == DEVKIT_ONLINE_RAND_KEY_LEN );
    RtlCopyMemory( OnlineKey, DEVKIT_ONLINE_RAND_KEY, DEVKIT_ONLINE_RAND_KEY_LEN );
    MorphKeyByHardDriveKey( OnlineKey, sizeof(OnlineKey) );

    if (!RtlEqualMemory( factorySettings->OnlineKey, OnlineKey, sizeof(factorySettings->OnlineKey) ))
    {
        //
        // Save Online Key into the EEPROM
        //
        status = ExSaveNonVolatileSetting(XC_FACTORY_ONLINE_KEY, REG_BINARY, OnlineKey, sizeof(OnlineKey));
        if (!NT_SUCCESS(status))
        {
            return E_FAIL;
        }
    }
    
    //
    // Zero out the memory
    //
    RtlZeroMemory( factorySettings, sizeof(*factorySettings) );
    RtlZeroMemory( OnlineKey, sizeof(OnlineKey) );

    return S_OK;
}


HRESULT 
OldWriteEEPROMDevkitData( void )
{
    HRESULT hr = S_OK;
    NTSTATUS status = ERROR_SUCCESS;
    XBOX_FACTORY_SETTINGS factorySettings;

	if ( SUCCEEDED( hr ) )
	{

		//
		// Put in the all 9 serial number for dev kits
		//

		CopyMemory( factorySettings.SerialNumber, 
			        "999999999999", 
					sizeof( factorySettings.SerialNumber ) );

		//
		// Save Serial Number into the EEPROM
		//
		status = XSetValue( XC_FACTORY_SERIAL_NUMBER, 
							REG_BINARY, 
							factorySettings.SerialNumber, 
							sizeof( factorySettings.SerialNumber ) );

		hr = ERROR_SUCCESS == status ? S_OK : E_FAIL;
		ASSERT( SUCCEEDED( hr ) || !"Could not save serial number to EEPROM" );

	}

	if ( SUCCEEDED( hr ) )
	{

		//
		// copy in the DEVKIT Online Key
		//

		CopyMemory( factorySettings.OnlineKey, 
			        "\x7b\x59\x2e\x4f\x81\x78\xb4\xc7\x57\x88\x53\x1b\x2e\x74\x76\x87", 
					sizeof( factorySettings.OnlineKey ) );
		
		//
		// Morph with the hard-drive key
		//

		MorphKeyByHardDriveKey( factorySettings.OnlineKey, sizeof(factorySettings.OnlineKey) );

		//
		// Save Online Key into the EEPROM
		//

		status = XSetValue( XC_FACTORY_ONLINE_KEY, 
							REG_BINARY, 
							factorySettings.OnlineKey, 
							sizeof( factorySettings.OnlineKey ) );

		hr = ERROR_SUCCESS == status ? S_OK : E_FAIL;
		ASSERT( SUCCEEDED( hr ) || !"could not save online key to EEPROM" );
	}

    //
    // Zero out the memory
    //

    ZeroMemory( &factorySettings, sizeof( factorySettings ) );

	//
	// Convert the status to an HR
	//

    return ERROR_SUCCESS == status ? S_OK : E_FAIL;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: ValidateMachineAccount
//
// Input: None
//
// Output: S_OK if either the machine account exists OR creation of a machine
//         account was successful
//
// Description: checks for a valid machine account on an xbox, and if need be
//              populates the xbox with the xdk serial number and 
//              XDK online key, and then creates the machine account
//
///////////////////////////////////////////////////////////////////////////////


HRESULT 
ValidateMachineAccount( void )
{
#if 1
    RIP("should not call this anymore");
    return E_FAIL;
#else
	//
	// Setup error codes
	//

	HRESULT	hr = S_OK;
	DWORD dwRet = ERROR_SUCCESS;

	//
	// Check to see if the xbox has a machine account
	//

	if ( ! XOnlineHasMachineAccount() )
	{
		//
		// If it does not, populate the EEPROM
		// (Faking the manufacturing process)
		//

		hr = WriteEEPROMDevkitData();
		hr = SUCCEEDED( hr ) ? S_OK : E_FAIL;
		ASSERT( SUCCEEDED( hr ) || !"could not populate EEPROM" );

		//
		// Create the machine account
		//

		if ( SUCCEEDED( hr ) )
		{
		//	hr = CreateMachineAccount();

            // hr = XOnlineCreateMachineAccount();
            hr = E_FAIL;    //@@@ drm: XOnlineCreateMachineAccount doesn't exist anymore
			hr = SUCCEEDED( hr ) ? S_OK : E_FAIL;
			ASSERT( SUCCEEDED( hr ) || !"Could not create machine account" );
		}

	}

	//
	// return the final hr
	//

	return hr;
#endif
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: HasOldMachineAccount
//
// Input: None
//
// Output: TRUE if an old account exists
//         FALSE
//
// Description: checks to see if an old machine account exists
//
///////////////////////////////////////////////////////////////////////////////

BOOL HasOldMachineAccount( void )
{
#if 1
    RIP("should not call this anymore");
    return FALSE;
#else
	DWORD dwRet = 0;
	DWORD cbResultLength = 0;
	DWORD dwType = 0;
	INT iVal = 0;

	XC_ONLINE_MACHINE_ACCOUNT_STRUCT machineAccount;

	//
	// Zero out the machine account
	//

	ZeroMemory( &machineAccount, sizeof( XC_ONLINE_MACHINE_ACCOUNT_STRUCT ) );

	//
	// check to see if a machine account exists
	//

	if ( ! XOnlineHasMachineAccount() )
	{
		return FALSE;
	}

	//
	// pull out the machine account information
	//


	dwRet = XQueryConfigValue( &g_OnlineMainConfigSectorInfo,
                               XC_ONLINE_MACHINE_ACCOUNT, 
							   &dwType,
							   &machineAccount, 
							   sizeof( XC_ONLINE_MACHINE_ACCOUNT_STRUCT ), 
							   &cbResultLength );

	//
	// if htis call failed, something must be wrong
	// we return true to signify that this section should be wiped
	//

	ASSERT( ERROR_SUCCESS == dwRet || !"Could not read config sector" );

	if ( ERROR_SUCCESS != dwRet )
	{
		return TRUE;
	}

	//
	// check the last four bytes for 1101 november time stamp
	//

	iVal = memcmp( machineAccount.reserved + XONLINE_ACCOUNT_RESERVED_SIZE - 4,
			       "1101",
				   4 );
	
	//
	// if iVal is 0, that means the account is November. We want hte negation
	// of that
	//

	return 0 != iVal;
#endif
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: HasOldUserAccounts
//
// Input: None
//
// Output: TRUE if an old user account exists
//         FALSE otherwise
//
// Description: decides if old user accounts exist. If even one of the
//              users is old, all are wiped out
//
///////////////////////////////////////////////////////////////////////////////

BOOL HasOldUserAccounts( void )
{
	HRESULT hr = S_OK;

	INT iVal = 0;
	DWORD cUsers = 0;
	DWORD cFinalUsers = 0;
	XONLINE_USER aUsers[XONLINE_MAX_STORED_ONLINE_USERS];

	//
	// zero out the user array
	//

	ZeroMemory( aUsers, sizeof( aUsers ) );

	//
	// query the users
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = XOnlineGetUsers( aUsers, &cUsers );
		ASSERT( SUCCEEDED( hr ) || !"Could not get users" );
	}

	//
	// copy the number of final users
	//

	cFinalUsers = cUsers;

	//
	// cycle through the users, removing the ones on MU
	//

	for ( DWORD i = 0; i < cUsers && SUCCEEDED( hr ); i++ )
	{
		if ( XONLINE_USER_OPTION_CAME_FROM_MU & aUsers[i].dwUserOptions )
		{
			cFinalUsers--;
			ZeroMemory( aUsers + i, sizeof( XONLINE_USER ) );
		}
	}

	//
	// cycle through the users
	//

	for ( DWORD i = 0; i < cFinalUsers && SUCCEEDED( hr ); i++ )
	{
		//
		// look for the november 1101 tag
		//

		iVal = memcmp( aUsers[i].reserved + XONLINE_USER_RESERVED_SIZE - 4,
			           "1101",
					   4 );

		//
		// return if the user tag is not 1101
		//

		if ( 0 != iVal )
		{
			return TRUE;
		}
	}

	//
	// if we got here, there were no old users
	//

	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: VerifyMachineAcount
//
// Input: ullId - the id
//        szName - the name of the machine
//        szPassword - the password for the machine
//
// Output: TRUE if the machine accounts match
//         FALSE otherwise
//
// Description: decides if the machine account on the box is the same
//              as the one passed in
//
///////////////////////////////////////////////////////////////////////////////

BOOL
VerifyMachineAccount( ULONGLONG ullId, LPSTR szName, LPSTR szPassword )
{
#if 1
    RIP("should not call this anymore");
    return FALSE;
#else
	DWORD dwRet = 0;
	DWORD cbResultLength = 0;
	DWORD dwType = 0;
	INT iVal = 0;
	BYTE byKey[XONLINE_KEY_LENGTH];

	XC_ONLINE_MACHINE_ACCOUNT_STRUCT machineAccount;

	//
	// Zero out the machine account and the key
	//

	ZeroMemory( &machineAccount, sizeof( XC_ONLINE_MACHINE_ACCOUNT_STRUCT ) );
	ZeroMemory( byKey, sizeof( byKey ) );

	//
	// get the config sector info
	//

	dwRet = XQueryConfigValue( &g_OnlineMainConfigSectorInfo,
                               XC_ONLINE_MACHINE_ACCOUNT, 
							   &dwType,
							   &machineAccount, 
							   sizeof( XC_ONLINE_MACHINE_ACCOUNT_STRUCT ), 
							   &cbResultLength );

	//
	// if there was a failure reading the config sector, fail
	//

	if ( ERROR_SUCCESS != dwRet )
	{
		return FALSE;
	}

	//
	// decrypt the key
	//

	DecryptKeyWithHardDriveKey( machineAccount.key, sizeof( machineAccount.key ) );
	KerbPasswordToKey( szPassword, byKey );

	//
	// decide on the result
	//
	
	return ullId == machineAccount.id && 
		   0 == strcmp( machineAccount.name, szName ) &&
		   0 == memcmp( machineAccount.key, byKey, XONLINE_KEY_LENGTH );
#endif
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: ReadUserData
//
// Input: pIniFile - an open file pointer to the ini file to read from
//        pNewUser - where the user data should be placed
//
// Output: S_OK on success, E_OUTOFMEMORY when no more data to read E_XXXX otherwise
//
// Description: reads 1 line of user data, and populate the user
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
ReadUserData( FILE* pIniFile, PXONLINEP_USER pNewUser )
{
#if 1
    RIP("should not call this anymore");
	return E_FAIL;
#else

	HRESULT hr = S_OK;
	INT iVal = 0;

	CHAR szString[256];
	BYTE byPin[XONLINE_PIN_LENGTH];

	union un {
		ULONGLONG ullVals[2];
		BYTE byVals[16];
	} unn;

	//
	// make sure the ini file is not NULL
	//

	if ( NULL == pIniFile )
	{
		hr = E_POINTER;
		ASSERT( SUCCEEDED( hr ) || !"Ini file pointer was null" );
	}

	//
	// make sure the user is not NULL
	//

	if ( NULL == pNewUser )
	{
		hr = E_POINTER;
		ASSERT( SUCCEEDED( hr ) || !"User pointer was NULL" );
	}

	if ( SUCCEEDED( hr ) )
	{

		ZeroMemory( szString, sizeof( szString ) );

		//
		// the format string is:
		//
		// 16 hex charecters put into an 8 byte value
		// , delimieter
		// 63 maximum valid email string charecters
		// , delimeter
		// 32 hex charecters (16 + 16) put into 2-8 byte values
		// , delimiter
		// 255 maximum valid string charecters (optional)

		iVal = fscanf( pIniFile, 
					   "%16I64x,%16[a-zA-Z0-9!#$%&'*+./=?^_`{|}~@-],%12[a-zA-Z0-9!#$%&'*+./=?^_`{|}~@-],%20[a-zA-Z0-9!#$%&'*+./=?^_`{|}~@-],%16I64x%16I64x,%255[a-zA-Z0-9,]", 
					   &pNewUser->xuid.qwUserID,
					   pNewUser->name,
					   pNewUser->kingdom,
					   pNewUser->domain,
					   unn.ullVals + 1,
					   unn.ullVals,
					   szString );

		hr = 0 != iVal ? S_OK : E_FAIL;

		ASSERT( SUCCEEDED( hr ) || !"Bad ini data" );

		if ( EOF == iVal )
		{
			hr = E_OUTOFMEMORY;
		}

	}

	
	//
	// copy the realm value
	// AND
	// copy the values from the union into the key
	//

	if ( SUCCEEDED( hr ) )
	{
		strcpy( pNewUser->realm, "passport.net" );

		for ( DWORD i = 0; i < sizeof( ULONGLONG ) * 2 && SUCCEEDED( hr ); i++ )
		{
			pNewUser->key[i] = unn.byVals[sizeof( ULONGLONG ) * 2 - i - 1];
		}
	}
	
	//
	// Parse the optional params. These are (all optional)
	// 8 bytes flags
	// , delimieter
	// 8 bytes pin
	// , delimiter
	// 237 chars
	//

	if ( SUCCEEDED( hr ) )
	{
		iVal = sscanf( szString, "%8x,%8x", &pNewUser->dwUserOptions, byPin );

		hr = 0 != iVal ? S_OK : E_FAIL;
		ASSERT( SUCCEEDED( hr ) || !"Bad ini data" );
	}

	//
	// rearange the pin value
	//
	
	if ( SUCCEEDED( hr ) )
	{
		for ( DWORD i = 0; i < XONLINE_PIN_LENGTH && SUCCEEDED( hr ); i++ )
		{
			pNewUser->pin[i] = byPin[XONLINE_PIN_LENGTH - i - 1];
		}
	}
	
	//
	// spit back the hr
	//

	return hr;
#endif

}
*/

///////////////////////////////////////////////////////////////////////////////
//
// Name: QuickLogonStart
//
// Input: none
//
// Output: S_OK on success,  E_XXXX otherwise
//
// Description: does a quick logon to the user account creation server
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
COnlineAccounts::QuickLogonStart( void )
{
	//
	// handles to communicate with Xbox Online
	//

	HRESULT hr = S_OK;
	HRESULT hrTask = S_OK;
	HANDLE hEvent = NULL;

	DWORD dwWait = 0;

	//
	// create the event handle, make sure it is valid
	//

	hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

	if ( NULL == hEvent )
	{
		hr = E_OUTOFMEMORY;
	}

	//
	// since no users will be logged in (this is just a ping), we
	// want to only hit the user account server
	//

    DWORD aServices[] = { XONLINE_USER_ACCOUNT_SERVICE };

	//
	// create the user array, zero it out
	//

	XONLINE_USER aUsers[XONLINE_MAX_LOGON_USERS];
	ZeroMemory( aUsers, sizeof( aUsers ) );

	//
	// generate the async logon to the user account service
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = XOnlineLogon( aUsers, 
						   aServices,
			               sizeof( aServices ) / sizeof( DWORD ),
						   hEvent, 
						   &g_hTask );

	}

	//
	// pump the task handle until logon completes
	//

	if ( SUCCEEDED( hr ) )
	{

		do
		{   
			//
			// wait for data to be ready for processing
			//

			dwWait = WaitForSingleObject( hEvent, ONLINE_ACCOUNT_WAIT_INTERVAL );

			//
			// see if the wait failed due to memory
			//

			if ( WAIT_FAILED == dwWait )
			{
				hr = E_OUTOFMEMORY;
			}

			//
			// see if the wait timed out
			//
        
			if ( WAIT_TIMEOUT == dwWait )
			{
				hr = E_FAIL;
			}

			//
			// continue pumping the handle
			//

			if ( SUCCEEDED( hr ) )
			{
				hrTask = XOnlineTaskContinue( g_hTask );
			}

		} while ( hrTask == XONLINETASK_S_RUNNING && SUCCEEDED( hr ) );
	}

    //
    // close the event
    //

    if ( NULL != hEvent )
    {
        CloseHandle( hEvent );
        hEvent = NULL;
    }

	return SUCCEEDED( hrTask ) ? hr : hrTask;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: QuickLogonFinish
//
// Input: none
//
// Output: S_OK on success,  E_XXXX otherwise
//
// Description: does a quick logoff to the user account creation server
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
COnlineAccounts::QuickLogonFinish( void )
{
	HRESULT hr = S_OK;

	//
	// close the handle, wether we have falied or not
	//

	if ( NULL != g_hTask )
	{
		XOnlineTaskClose( g_hTask );
	}

	//
	// reset the task handle
	//

	g_hTask = NULL;

	//
	// spit back the hr
	//

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: GenerateUserName
//
// Input: szUserName - an array of XONLINE_NAME_SIZE bytes ot get 
//        the new user name                      
//        
// Output: S_OK on success, E_XXXX otherwise
//
// Description: create a random user name based on the Ethernet MAC address
//              and 3 bytes of charecter values
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
COnlineAccounts::GenerateUserName( CHAR szName[XONLINE_NAME_SIZE] )
{
	HRESULT hr = S_OK;

	DWORD dwStatus = 0;
	DWORD dwType = 0;
	DWORD cbResultLength = 0;

	CHAR abMacAddress[6];

	//
	// zero out the char array
	//

	ZeroMemory( abMacAddress, 6 );

	//
	// get the Ethernet MAC address
	//

	if ( SUCCEEDED( hr ) )
	{
		//
		// get the address
		//
#ifdef _XBOX
		dwStatus = ExQueryNonVolatileSetting( XC_FACTORY_ETHERNET_ADDR, &dwType, abMacAddress, 6, &cbResultLength );
		hr = NT_SUCCESS( dwStatus ) ? S_OK : E_FAIL;
		
		ASSERT( SUCCEEDED( hr ) || !"Could not get ethernet MAC address" );

#else

		sprintf( abMacAddress, "%6.6s", getenv("COMPUTERNAME") );

#endif
	}

	//
	// now populate the user name
	//

	if ( SUCCEEDED( hr ) )
	{
		//
		// populate user name with the last 4 bytes of the ethernet mac address
		//

		for ( DWORD i = 0; i < 4; i++ )
		{
			//
			// print the current byte
			//

			sprintf( szName + i * 2, "%02x", (BYTE) abMacAddress[i + 2] );
		}

		//
		// stuff the last 7 bytes with a random char
		//

		sprintf( szName + 8, 
				 "%c%c%c%c%c%c%c", 
				 (BYTE) rand() % ( 'Z' - 'A' ) + 'A',
				 (BYTE) rand() % ( 'Z' - 'A' ) + 'A',
				 (BYTE) rand() % ( 'Z' - 'A' ) + 'A',
				 (BYTE) rand() % ( 'Z' - 'A' ) + 'A',
				 (BYTE) rand() % ( 'Z' - 'A' ) + 'A', 
				 (BYTE) rand() % ( 'Z' - 'A' ) + 'A', 
				 (BYTE) rand() % ( 'Z' - 'A' ) + 'A' );
	}

	//
	// spit back the hr
	//

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: GenerateUserAccount
//
// Input: pUser - the user to fill in                     
//        
// Output: S_OK on success, E_XXXX otherwise
//
// Description: fill in and create a user
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
COnlineAccounts::GenerateUserAccount( PXONLINEP_USER pUser )
{
	HRESULT hr = S_OK;

	HRESULT hrTask = S_OK;
	HANDLE hEvent = NULL;

	XONLINETASK_HANDLE hTask = NULL;

	DWORD dwWait = 0;

	HRESULT hrGenName = S_OK;

	//
	// create the event handle, make sure it is valid
	//

	hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

	if ( NULL == hEvent )
	{
		hr = E_OUTOFMEMORY;
		ASSERT( SUCCEEDED( hr ) || !"Could not create event handle for account creation" );
	}

	if ( SUCCEEDED( hr ) )
	{
		do
		{
			//
			// see if name needs to be populated
			//

			if ( SUCCEEDED( hr ) && 0 == strcmp( pUser->name, "" ) )
			{
				//
				// go ahead and generate the user name
				//

				hr = GenerateUserName( pUser->name );
				ASSERT( SUCCEEDED( hr ) || !"Could not generate user name" );

				DbgPrint( pUser->name );
				DbgPrint( "\n" );
			}

			//
			// fill in the kingdom
			//

			if ( SUCCEEDED( hr ) && 0 == strcmp( pUser->kingdom, "" ) )
			{
				strcpy( pUser->kingdom, "Feb2002" );
			}

			//
			// create the account
			//

			if ( SUCCEEDED( hr ) )
			{
				hr = _XOnlineAccountTempCreate( (PXONLINE_USER) pUser, hEvent, &hTask );
		//		ASSERT( SUCCEEDED( hr ) || !"Creation of temp account failed" );
			}

			//
			// pump the task handle until user creation completes
			//

			if ( SUCCEEDED( hr ) )
			{
				do
				{   
					//
					// wait for data to be ready for processing
					//

					dwWait = WaitForSingleObject( hEvent, ONLINE_ACCOUNT_WAIT_INTERVAL );

					if ( WAIT_FAILED == dwWait )
					{
						hr = E_OUTOFMEMORY;
					}
    
					//
					// make sure the wait did not time out
					//

					else if ( WAIT_TIMEOUT == dwWait )
					{
						hr = E_FAIL;
					}

					//
					// continue pumping the handle
					//

					if ( SUCCEEDED( hr ) )
					{
						hrTask = XOnlineTaskContinue( hTask );
					}

				} while ( XONLINETASK_S_RUNNING == hrTask && SUCCEEDED( hr ) );
			}

			//
			// if the name was taken, zero it out
			//

			if ( XONLINE_S_ACCOUNTS_NAME_TAKEN == hrTask && SUCCEEDED( hr ) )
			{
				hrGenName = S_FALSE;

				hrTask = S_OK;
				ZeroMemory( pUser->name, XONLINE_NAME_SIZE );

				//
				// close down the handle
				//

				if ( NULL != hTask )
				{
					hrTask = XOnlineTaskClose( hTask );
					ASSERT( SUCCEEDED( hrTask ) || !"Could not close handle" );
					hTask = NULL;
				}

				hr = SUCCEEDED( hr ) ? hrTask : hr;
			}

			else if ( FAILED( hrTask ) )
			{
				hr = hrTask;
			}

			//
			// keep going until the name is filled
			//

		} while ( 0 == strcmp( pUser->name, "" ) && SUCCEEDED( hr ) );
	}

	//
	// Now retrieve the created account
	//

    if ( SUCCEEDED( hr ) )
    {
		hr = _XOnlineAccountTempCreateGetResults( hTask, (PXONLINE_USER) pUser );
		ASSERT( SUCCEEDED( hr ) || !"Creation of temp account failed" );
    }

	//
	// close the handle, wether we have falied or not
	//

	if ( NULL != hTask )
	{
		hrTask = XOnlineTaskClose( hTask );
		ASSERT( SUCCEEDED( hrTask ) || !"Could not close handle" );
		hTask = NULL;
	}

	hr = SUCCEEDED( hr ) ? hrTask : hr;

    //
    // close the event
    //

    if ( NULL != hEvent )
    {
        CloseHandle( hEvent );
        hEvent = NULL;
    }

	return SUCCEEDED( hr ) ? hrGenName : hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: GetUsers
//
// Input: aUsers - an output array of users
//        dwNumAccounts - the number of accounts to fill                       
//        
// Output: S_OK on success, E_XXXX otherwise
//
// Description: creates N users using UAPS
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
COnlineAccounts::GetUsers( PXONLINEP_USER aUsers, DWORD dwNumAccounts )
{
	//
	// handles to communicate with xonline
	//

	HRESULT hr = S_OK;
	HRESULT hrTask = S_OK;
	HRESULT hrGenName = S_OK;

	DWORD dwNumCreated = 0;

	//
	// seed the random number generator
	// 

	srand( time( NULL ) );

	//
	// we need to specify the user array, this pointer can't be NULL
	//

	if ( NULL == aUsers )
	{
		hr = E_INVALIDARG;
		ASSERT( SUCCEEDED( hr ) || !"Must pass an array of users. aUsers can not be NULL" );
	}

	//
	// initiate a logon
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = QuickLogonStart();
//		ASSERT( SUCCEEDED( hr ) || !"Could not logon" );
	}

	//
	// create accounts for each item
	//

	for( dwNumCreated = 0; dwNumCreated < dwNumAccounts && SUCCEEDED( hr ); dwNumCreated++ )
	{
		//
		// generate the user
		//

		hr = GenerateUserAccount( aUsers + dwNumCreated );
		hrGenName = hr;
	//	ASSERT( SUCCEEDED( hr ) || !"GenerateUserAccounts failed" );

		if ( SUCCEEDED( hr ) )
		{
			hr = _XOnlineAddUserToHD( (PXONLINE_USER) aUsers + dwNumCreated );
		}
	}

	//
	// verify the number of accounts requested was the same as the number created
	//

	if ( SUCCEEDED( hr ) && dwNumCreated != dwNumAccounts )
	{
		hr = E_FAIL;
		ASSERT( SUCCEEDED( hr ) || !"Number of accounts created is not correct" );
	}

	//
	// verify the number of accounts created is in the right range
	//

	if ( SUCCEEDED( hr ) && dwNumCreated > XONLINE_MAX_STORED_ONLINE_USERS )
	{
		hr = E_FAIL;
		ASSERT( SUCCEEDED( hr ) || !"Can not create more than max users!" );
	}

	//
	// end the logon
	//

	hrTask = QuickLogonFinish();

	hr = SUCCEEDED( hr ) ? hrTask : hr;

	//
	// spit back the hr
	//

	return SUCCEEDED( hr ) ? hrGenName : hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: PopulateUserAccountsMU
//
// Input: chDrive - the drive letter of the MU to populate
//
//        pUser - an XONLINEP_USER pointer. if the pointer is NULL, then the
//                user is erased off the MU. 
//                if the name is NULL, a random name will generated
//        
// Output: S_OK on success, E_XXXX otherwise
//
// Description: creates 1 user on the MU using XUACS
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
COnlineAccounts::PopulateUserAccountsMU( CHAR chDrive, PXONLINEP_USER pUser )
{
	HRESULT hr = S_OK;
	HRESULT hrGenName = S_OK;

	XONLINEP_USER user;

	//
	// zero out the internal user
	//

	ZeroMemory( &user, sizeof( XONLINEP_USER ) );

	//
	// if no user was passed in, then we want to erase the user
	// on the MU
	//

	if ( NULL == pUser )
	{
		pUser = &user;
	}

	//
	// otherwise, see if we need to populate the name and kingdom
	//

	else
	{
		hr = GenerateUserAccount( pUser );
		hrGenName = hr;

		if ( SUCCEEDED( hr ) )
		{
			hr = _XOnlineSetUserInMU( chDrive, (PXONLINE_USER) pUser );
		}
	}

	//
	// spit back the hr
	//
	
	return SUCCEEDED( hr ) ? hrGenName : hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: PopulateUserAccountsHD
//
// Input: aUsers - the array of the xonline users to populate
//
//                 dwNumAccounts elements in this array will be filled. if
//                 the inputed name and kingdom are NULL, then a random 
//                 name and kingdom are generated and used. if the name and
//                 kingdom are both not null, then the specified name/kingdom
//                 are used to generate the user in UAPS. if this pointer is NULL
//                 then the function will internally allocate random users
//
//        dwNumAccounts -  the number of accounts to populate the
//                         drive with
//
//                         dwNumAccounts == 0, then the drive will have all 
//                         accounts removed and no new accounts will be added
//
//        bRemoveUsers - if set, then users are removed from the HD before creating
//                       new ones. Set by default
//
// Output: S_OK on success
//         E_XXXX on failutre
//         S_FALSE if less users were populated then expected.
//
// Description: Populates the hard disk with the specified number of users.
//              this function will clear off any users on the drive before 
//              populating the drive
//
///////////////////////////////////////////////////////////////////////////////

HRESULT 
COnlineAccounts::PopulateUserAccountsHD( PXONLINEP_USER aUsers, DWORD dwNumAccounts, BOOL bRemoveUsers )
{
	HRESULT hr = S_OK;
	HRESULT hrGenName = S_OK;
	DWORD dwNumUsers = 0;
	XONLINEP_USER aExistingUsers[XONLINE_MAX_STORED_ONLINE_USERS];

	//
	// clear out the user array
	//

	ZeroMemory( aExistingUsers, sizeof( aExistingUsers ) );

	//
	// make sure no more than 8 users are asked for
	//

	if ( dwNumAccounts > XONLINE_MAX_HD_ONLINE_USERS )
	{
		hr = E_INVALIDARG;
		ASSERT( SUCCEEDED( hr ) || !"can not ask for more than 8 users!" );
	}

	//
	// get the users on the drive currently
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = _XOnlineGetUsersFromHD( (PXONLINE_USER) aExistingUsers, &dwNumUsers );
		ASSERT( SUCCEEDED( hr ) || !"Could not get users on drive" );
	}

	//
	// if we have a FULL drive, then let's error out, only if removal was not asked for
	//

	if ( SUCCEEDED( hr ) && XONLINE_MAX_HD_ONLINE_USERS == dwNumUsers && FALSE == bRemoveUsers )
	{
		hr = E_OUTOFMEMORY;
	}

	//
	// remove the users on the drive
	//

	for ( DWORD i = 0; i < dwNumUsers && SUCCEEDED( hr ) && TRUE == bRemoveUsers; i++ )
	{ 
		hr = _XOnlineRemoveUserFromHD( (PXONLINE_USER) ( aExistingUsers + i ) );
		ASSERT( SUCCEEDED( hr ) || !"Could not remove user" );
	}

	//
	// allow for NULL user list
	//

	if ( NULL == aUsers )
	{
		aUsers = aExistingUsers;
		ZeroMemory( aUsers, sizeof( aExistingUsers ) );
	}

	//
	// create the users
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = GetUsers( aUsers, dwNumAccounts );
		hrGenName = hr;
	//	ASSERT( SUCCEEDED( hr ) || !"Could not get users" );
	}

	//
	// return the hr
	//

	return SUCCEEDED( hr ) ? hrGenName : hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\SetupOnline\AccountCreationScreen.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: AccountCreationScreen.cpp
//
// Author: Dan Rosenstein (danrose)
//
// Description: the implementation for AccountCreation screen
//
///////////////////////////////////////////////////////////////////////////////

#include "AccountCreationScreen.h"

///////////////////////////////////////////////////////////////////////////////
//
// Name:  account creation screen constructor
//
// Input: pParent - the parent screen for this screen
//
// Output: None
//
// Description: creates an instance of the account creation screen
//
///////////////////////////////////////////////////////////////////////////////

CAccountCreationScreen::CAccountCreationScreen( CUserInterfaceScreen* pParent )

	//
	// the parent of the account creation screen
	//

	: CUserInterfaceScreen( pParent, 
	                        CREATION_SCREEN_FG_COLOR, 
							CREATION_SCREEN_BG_COLOR, 
							CREATION_SCREEN_X, 
							CREATION_SCREEN_Y ),

	//
	// the text
	//

	  m_aText( CREATION_A_TEXT, CREATION_A_X, CREATION_A_Y, CREATION_A_FG_COLOR, CREATION_A_BG_COLOR ),
      m_bText( CREATION_B_TEXT, CREATION_B_X, CREATION_B_Y, CREATION_B_FG_COLOR, CREATION_B_BG_COLOR ),
      m_infoText( "", CREATION_INFO_X, CREATION_INFO_Y, CREATION_INFO_FG_COLOR, CREATION_INFO_BG_COLOR ),

	//
	// start with no thread
	//

	  m_hThread( NULL ),

	//
	// the final hr value from the creation
	//
	
	 m_hrFinal( 0xFFFFFFFF ),

	 //
	 // the creation text index
	 //

	 m_dwTextIndex( 0 ),

	 //
	 // init state of creation
	 //

	 m_bCreationOnce( FALSE )

{	
	//
	// set the initial text
	//

	SetText( CREATION_TEXTS[m_dwTextIndex] );

	//
	// add the ui text
	//

	AddUIText( &m_aText );
	AddUIText( &m_bText );
	AddUIText( &m_infoText );

	//
	// hide the text
	//

	m_aText.Hide( TRUE );
	m_bText.Hide( TRUE );
	m_infoText.Hide( TRUE );
}

///////////////////////////////////////////////////////////////////////////////
//
// Name:  account creation screen destructor
//
// Input: None
//
// Output: None
//
// Description: destroys an instance of the account creation screen
//
///////////////////////////////////////////////////////////////////////////////

CAccountCreationScreen::~CAccountCreationScreen( void )
{
	//
	// check if the thread handle exists
	//

	if ( m_hThread && INVALID_HANDLE_VALUE != m_hThread )
	{
		//
		// close it off if it does
		//

		CloseHandle( m_hThread );
		m_hThread = NULL;
	}
	else if ( INVALID_HANDLE_VALUE == m_hThread )
	{
		m_hThread = NULL;
	}
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: GenerateUser
//
// Input: None
//
// Output: S_OK if user generation completed successfuly (in a DWORD)
//
// Description: tries to see create a user
//
///////////////////////////////////////////////////////////////////////////////

DWORD WINAPI
CAccountCreationScreen::GenerateUser( LPVOID lpVoid )
{
	HRESULT hr = S_OK;

	LPSTR szName = NULL;
	LPBYTE pBytes = NULL;
	XONLINEP_USER user;

	if ( NULL == lpVoid )
	{
		return E_INVALIDARG;
	}

	//
	// zero out the user
	//
	
	ZeroMemory( &user, sizeof( XONLINEP_USER ) );

	//
	// get the inputed text
	//

	if ( SUCCEEDED( hr ) )
	{
		szName = ((SUserParams*) lpVoid)->szName;

		if ( NULL != szName )
		{
			strcpy( user.name, szName );
		}	
	}

	//
	// fill in the pin
	//

	if ( SUCCEEDED( hr ) )
	{
		pBytes = ((SUserParams*) lpVoid)->pBytes;

		if ( NULL != pBytes )
		{
			memcpy( user.pin, pBytes, XONLINE_PIN_LENGTH );

			//
			// set the require pin flag, if a pin exists
			//

			if ( 0 != *pBytes )
			{
				user.dwUserOptions |= XONLINE_USER_OPTION_REQUIRE_PIN;
			}
		}
	}

	//
	// try to create a user
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = COnlineAccounts::Instance()->PopulateUserAccountsHD( &user, 1, FALSE );
	}

	//
	// spit bakc the hr
	//

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: UpdateText
//
// Input: None
//
// Output: None
//
// Description: Updates the UI text
//
///////////////////////////////////////////////////////////////////////////////

void
CAccountCreationScreen::UpdateText( void )
{
	HRESULT hrThread = S_OK;

	//
	// only update the text if a thread handle exists
	//

	if ( m_hThread && INVALID_HANDLE_VALUE != m_hThread )
	{
		//
		// see if the thread is terminated yet
		//

		if ( GetExitCodeThread( m_hThread, (LPDWORD) &hrThread ) )
		{
			//
			// if the thread is still alive, then we are
			// still creating user on parterNET
			//

			if ( STILL_ACTIVE == hrThread )
			{
				SetText( CREATION_TEXTS[++m_dwTextIndex % NUM_CREATION_TEXT_STATES] );
			}

			//
			// if a random user name was generated, warn the user
			//

			else if ( S_FALSE == hrThread )
			{
				SetText( CREATION_SUCCEEDED_TEXT );
				m_hrFinal = S_OK;

				m_infoText.SetText( CREATION_USER_EXISTS_TEXT );
				m_infoText.Hide( FALSE );
			}

			//
			// if the handle is S_OK, then we created a user without a prob
			//

			else if ( SUCCEEDED( hrThread ) )
			{
				SetText( CREATION_SUCCEEDED_TEXT );
				m_hrFinal = S_OK;

			}

			//
			// the drive may be full
			//

			else if ( E_OUTOFMEMORY == hrThread )
			{
				SetText( CREATION_DISK_FULL_TEXT );
				m_hrFinal = E_FAIL;

			}

			//
			// otherwise, we did not successfuly create the user
			//

			else
			{
				SetText( CREATION_ERROR_TEXT );
				m_hrFinal = E_FAIL;

			}
		}

		//
		// some how getexitcode bailed
		//

		else
		{
			SetText( S_GENERAL_ERROR );
			m_hrFinal = E_FAIL;
		}
	}
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Update
//
// Input: pInput - the input ui
//        pAudio - the audio ui
//
// Output: the next screen
//
// Description: process the input for the screen
//
///////////////////////////////////////////////////////////////////////////////

CUserInterfaceScreen* 
CAccountCreationScreen::Update( CUserInterfaceInput* pInput, CUserInterfaceAudio* pAudio )
{
	HRESULT hr = S_OK;
	CUserInterfaceScreen* pRet = NULL;

	//
	// make sure params are good
	//

	hr = pInput && pAudio ? S_OK : E_BAD_ARG;
	MY_ASSERT( hr, S_BAD_ARG );

	if ( ! pInput || ! pAudio )
	{
		return pRet;
	}

	//
	// update the text
	//

	UpdateText();

	//
	// if we have created, and an a or b was pressed
	//

	if ( TRUE == m_bCreationOnce && ( pInput->APressed() || pInput->BPressed() ) )
	{
		//
		// we can come back to this screen, so reset internal state
		//

		m_bCreationOnce = FALSE;
		m_hrFinal = 0xFFFFFFFF;
		m_dwTextIndex = 0;

		//
		// hide a again
		//

		m_aText.Hide( TRUE );
		m_bText.Hide( TRUE );

		//
		// reset the text
		//

		SetText( CREATION_TEXTS[m_dwTextIndex] );

		//
		// hide the info text
		//

		m_infoText.Hide( TRUE );

		//
		// goto the parent screen
		//

		pRet = ParentScreen()->Update( pInput, pAudio );

	}

	//
	// if the thread has been created and is completed
	//

	else if ( ( NULL != m_hThread && INVALID_HANDLE_VALUE != m_hThread ) && 
		      ( S_OK == m_hrFinal || E_FAIL == m_hrFinal ) )
	{

		//
		// destroy the handle if it exists
		//

		if ( m_hThread && INVALID_HANDLE_VALUE != m_hThread )
		{
			CloseHandle( m_hThread );
			m_hThread = NULL;
		}

		else if ( INVALID_HANDLE_VALUE == m_hThread )
		{
			m_hThread = NULL;
		}

		//
		// decide which sound to play
		//

		if ( S_OK == m_hrFinal )
		{	
			hr = pAudio->PlaySelectButton();
		}

		else
		{
			hr = pAudio->PlayBackButton();
		}

		//
		// reset the final state
		//

		m_hrFinal = S_OK;

		//
		// we've done the creation
		//

		m_bCreationOnce = TRUE;

		//
		// unhide text
		//

		m_aText.Hide( FALSE );
		m_bText.Hide( FALSE );

	}

	//
	// if the thread was never created
	//

	else if ( ( NULL == m_hThread || INVALID_HANDLE_VALUE == m_hThread ) && FALSE == m_bCreationOnce )
	{
		//
		// set the text index back to 0
		//

		m_dwTextIndex = 0;

		//
		// update the text
		//

		SetText( CREATION_TEXTS[m_dwTextIndex] );

		//
		// if no user name was entered, generate a warning
		//

		if ( NULL == m_params.szName || '\0' == *m_params.szName )
		{
			m_infoText.SetText( CREATION_NULL_USER_TEXT );
			m_infoText.Hide( FALSE );
		}

		//
		// create the thread
		//

		m_hThread = CreateThread( NULL, 0, &CAccountCreationScreen::GenerateUser, (LPVOID) &m_params, 0, NULL );
		hr = 0 != m_hThread ? S_OK : E_MEMORY_ALLOCATION;
		MY_ASSERT( hr, S_MEMORY_ALLOCATION );

		//
		// if the thread could not be created, report it
		//

		if ( ! m_hThread )
		{
			//
			// update the text
			//

			SetText( CREATION_ERROR_TEXT );

			//
			// play the failed sound
			//

			hr = pAudio->PlayBackButton();

			//
			// do not return any screen
			//

			pRet = NULL;
		}
	}

	return pRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\onlineaccounts2\src\onlineaccounts.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: OnlineAccounts.cpp
//
// Author: Dan Rosenstein (danrose)
//
// Description: the functions to muck with account status
//
///////////////////////////////////////////////////////////////////////////////

#ifdef _XBOX
#define NTLEANANDMEAN
#define _WIN32_WINNT 0x0500
 
#include <nt.h>
#include <ntrtl.h>
#endif

#include "OnlineAccounts2.h"

#ifdef _XBOX
extern "C" { 
#include <init.h> 
}
#include <xboxp.h>
#endif

//#include <cryptkeys.h>
#ifdef _XBOX
#include <xconfig.h>
#endif
//#include <memory.h>
#include <time.h>
/*
BOOL
KerbPasswordToKey(
    IN LPSTR pszPassword,
    OUT BYTE* Key
    );
*/

///////////////////////////////////////////////////////////////////////////////
//
// Name: Constructor
//
// Input: szName - the name of the online object
//
// Output: an instance of the class
//
// Description: creates the OnlineAccounts class
//
///////////////////////////////////////////////////////////////////////////////

COnlineAccounts::COnlineAccounts( LPSTR szName )
#ifndef _XBOX
	: CXOnline( szName )
#endif

{
    m_hTask = NULL;
}

/*
///////////////////////////////////////////////////////////////////////////////
//
// Name: ModifyMachineAccount
//
// Input: ullId - the new id
//
//        szName - the new name of the machine account
//		           If it is NULL, the machine name is cleared out
//
//		  szPassword - the new password of the machine account
//                     If it is NULL, the machine password is cleared out
//
// Output: S_OK if removing machine data from the Config Sector was successful 
//
// Description: Modifies the machine name and machine password
//
///////////////////////////////////////////////////////////////////////////////

HRESULT 
ModifyMachineAccount( ULONGLONG ullId, LPSTR szName, LPSTR szPassword )
{
#if 1
    RIP("should not call this anymore");
    return E_FAIL;
#else
	HRESULT hr = S_OK;
    XC_ONLINE_MACHINE_ACCOUNT_STRUCT machineAccount;

	//
	// Zero out the machine account
	//

	ZeroMemory( &machineAccount, sizeof( XC_ONLINE_MACHINE_ACCOUNT_STRUCT ) );

	//
	// setup the id for the machine account
	//

	machineAccount.xuid.qwUserID = ullId;

	//
	// Only fill in the name if it was passed in
	//
	
	if ( szName )
	{
		strcpy( machineAccount.name, szName );

		//
		// make the machine account noevmeber 11/01 compatible
		//

		machineAccount.reserved[XONLINE_ACCOUNT_RESERVED_SIZE - 4] = '1';
		machineAccount.reserved[XONLINE_ACCOUNT_RESERVED_SIZE - 3] = '1';
		machineAccount.reserved[XONLINE_ACCOUNT_RESERVED_SIZE - 2] = '0';
		machineAccount.reserved[XONLINE_ACCOUNT_RESERVED_SIZE - 1] = '1';
	}

	//
	// Only fill in the password if it was passed in, then encrypt it
	//

	if ( szPassword )
	{
		hr = KerbPasswordToKey( szPassword, machineAccount.key ) ? S_OK : E_FAIL;
		ASSERT( SUCCEEDED( hr ) || !"Could not convert password to key" );
		EncryptKeyWithHardDriveKey( machineAccount.key, 
			                        sizeof( machineAccount.key ) );
	}

	//
	// Update the config sector
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = XSetConfigValue( &g_OnlineMainConfigSectorInfo,
							  XC_ONLINE_MACHINE_ACCOUNT, 
							  REG_BINARY,
							  &machineAccount, 
							  sizeof( XC_ONLINE_MACHINE_ACCOUNT_STRUCT ) );

		hr = SUCCEEDED( hr ) ? S_OK : E_FAIL;
		ASSERT( SUCCEEDED( hr ) || !"Could not update config sector" );
	}

	//
	// spit back the final hresult
	//

	return hr;
#endif
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: RemoveMachineAccount
//
// Input: None
//
// Output: S_OK if removing machine data from the Config Sector was successful 
//
// Description: Removes the machine name and machine password
//
///////////////////////////////////////////////////////////////////////////////

HRESULT 
RemoveMachineAccount( void )
{
	return ModifyMachineAccount( 0, NULL, NULL );
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: CreateMachineAccount
//
// Input: None
//
// Output: S_OK if populating the Config Sector was successful 
//
// Description: creates the machine name and machine password
//
///////////////////////////////////////////////////////////////////////////////

HRESULT 
CreateMachineAccount( void )
{
	return ModifyMachineAccount( 1, 
		                         "SN999999999999@machines.xbox.com", 
								 "PASSWORD" );	
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: WriteEEPROMDevkitData
//
// Input: None
//
// Output: S_OK if populating the EEPROM was successful 
//
// Description: propogates the DEVKIT online key and serial number
//
///////////////////////////////////////////////////////////////////////////////

HRESULT WriteEEPROMDevkitData( void )
{
    BYTE buf[EEPROM_TOTAL_MEMORY_SIZE];
    EEPROM_LAYOUT* eeprom;
    XBOX_FACTORY_SETTINGS* factorySettings;
    BYTE OnlineKey[16];
    NTSTATUS status;
    DWORD type, size;
    BOOL bResult;
    HRESULT hr;

    eeprom = (EEPROM_LAYOUT*) buf;
    factorySettings = (XBOX_FACTORY_SETTINGS*) &eeprom->FactorySection;

    //
    // read EEPROM Data
    //
    status = ExQueryNonVolatileSetting(XC_MAX_ALL, &type, buf, sizeof(buf), &size);
    if (!NT_SUCCESS(status))
    {
        return E_FAIL;
    }

    ASSERT( type == REG_BINARY );
    ASSERT( size == EEPROM_TOTAL_MEMORY_SIZE );

    //
    // Put in the all 9 serial number for dev kits
    //
    if (!RtlEqualMemory( factorySettings->SerialNumber, "999999999999", sizeof(factorySettings->SerialNumber) ))
    {
        //
        // Save Serial Number into the EEPROM
        //
        status = ExSaveNonVolatileSetting(XC_FACTORY_SERIAL_NUMBER, REG_BINARY, "999999999999", sizeof(factorySettings->SerialNumber));
        if (!NT_SUCCESS(status))
        {
            return E_FAIL;
        }
    }


    //
    // Figure out the devkit online key and morph it
    //
    ASSERT( sizeof(OnlineKey) == sizeof(factorySettings->OnlineKey) );
    ASSERT( sizeof(OnlineKey) == DEVKIT_ONLINE_RAND_KEY_LEN );
    RtlCopyMemory( OnlineKey, DEVKIT_ONLINE_RAND_KEY, DEVKIT_ONLINE_RAND_KEY_LEN );
    MorphKeyByHardDriveKey( OnlineKey, sizeof(OnlineKey) );

    if (!RtlEqualMemory( factorySettings->OnlineKey, OnlineKey, sizeof(factorySettings->OnlineKey) ))
    {
        //
        // Save Online Key into the EEPROM
        //
        status = ExSaveNonVolatileSetting(XC_FACTORY_ONLINE_KEY, REG_BINARY, OnlineKey, sizeof(OnlineKey));
        if (!NT_SUCCESS(status))
        {
            return E_FAIL;
        }
    }
    
    //
    // Zero out the memory
    //
    RtlZeroMemory( factorySettings, sizeof(*factorySettings) );
    RtlZeroMemory( OnlineKey, sizeof(OnlineKey) );

    return S_OK;
}


HRESULT 
OldWriteEEPROMDevkitData( void )
{
    HRESULT hr = S_OK;
    NTSTATUS status = ERROR_SUCCESS;
    XBOX_FACTORY_SETTINGS factorySettings;

	if ( SUCCEEDED( hr ) )
	{

		//
		// Put in the all 9 serial number for dev kits
		//

		CopyMemory( factorySettings.SerialNumber, 
			        "999999999999", 
					sizeof( factorySettings.SerialNumber ) );

		//
		// Save Serial Number into the EEPROM
		//
		status = XSetValue( XC_FACTORY_SERIAL_NUMBER, 
							REG_BINARY, 
							factorySettings.SerialNumber, 
							sizeof( factorySettings.SerialNumber ) );

		hr = ERROR_SUCCESS == status ? S_OK : E_FAIL;
		ASSERT( SUCCEEDED( hr ) || !"Could not save serial number to EEPROM" );

	}

	if ( SUCCEEDED( hr ) )
	{

		//
		// copy in the DEVKIT Online Key
		//

		CopyMemory( factorySettings.OnlineKey, 
			        "\x7b\x59\x2e\x4f\x81\x78\xb4\xc7\x57\x88\x53\x1b\x2e\x74\x76\x87", 
					sizeof( factorySettings.OnlineKey ) );
		
		//
		// Morph with the hard-drive key
		//

		MorphKeyByHardDriveKey( factorySettings.OnlineKey, sizeof(factorySettings.OnlineKey) );

		//
		// Save Online Key into the EEPROM
		//

		status = XSetValue( XC_FACTORY_ONLINE_KEY, 
							REG_BINARY, 
							factorySettings.OnlineKey, 
							sizeof( factorySettings.OnlineKey ) );

		hr = ERROR_SUCCESS == status ? S_OK : E_FAIL;
		ASSERT( SUCCEEDED( hr ) || !"could not save online key to EEPROM" );
	}

    //
    // Zero out the memory
    //

    ZeroMemory( &factorySettings, sizeof( factorySettings ) );

	//
	// Convert the status to an HR
	//

    return ERROR_SUCCESS == status ? S_OK : E_FAIL;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: ValidateMachineAccount
//
// Input: None
//
// Output: S_OK if either the machine account exists OR creation of a machine
//         account was successful
//
// Description: checks for a valid machine account on an xbox, and if need be
//              populates the xbox with the xdk serial number and 
//              XDK online key, and then creates the machine account
//
///////////////////////////////////////////////////////////////////////////////


HRESULT 
ValidateMachineAccount( void )
{
#if 1
    RIP("should not call this anymore");
    return E_FAIL;
#else
	//
	// Setup error codes
	//

	HRESULT	hr = S_OK;
	DWORD dwRet = ERROR_SUCCESS;

	//
	// Check to see if the xbox has a machine account
	//

	if ( ! XOnlineHasMachineAccount() )
	{
		//
		// If it does not, populate the EEPROM
		// (Faking the manufacturing process)
		//

		hr = WriteEEPROMDevkitData();
		hr = SUCCEEDED( hr ) ? S_OK : E_FAIL;
		ASSERT( SUCCEEDED( hr ) || !"could not populate EEPROM" );

		//
		// Create the machine account
		//

		if ( SUCCEEDED( hr ) )
		{
		//	hr = CreateMachineAccount();

            // hr = XOnlineCreateMachineAccount();
            hr = E_FAIL;    //@@@ drm: XOnlineCreateMachineAccount doesn't exist anymore
			hr = SUCCEEDED( hr ) ? S_OK : E_FAIL;
			ASSERT( SUCCEEDED( hr ) || !"Could not create machine account" );
		}

	}

	//
	// return the final hr
	//

	return hr;
#endif
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: HasOldMachineAccount
//
// Input: None
//
// Output: TRUE if an old account exists
//         FALSE
//
// Description: checks to see if an old machine account exists
//
///////////////////////////////////////////////////////////////////////////////

BOOL HasOldMachineAccount( void )
{
#if 1
    RIP("should not call this anymore");
    return FALSE;
#else
	DWORD dwRet = 0;
	DWORD cbResultLength = 0;
	DWORD dwType = 0;
	INT iVal = 0;

	XC_ONLINE_MACHINE_ACCOUNT_STRUCT machineAccount;

	//
	// Zero out the machine account
	//

	ZeroMemory( &machineAccount, sizeof( XC_ONLINE_MACHINE_ACCOUNT_STRUCT ) );

	//
	// check to see if a machine account exists
	//

	if ( ! XOnlineHasMachineAccount() )
	{
		return FALSE;
	}

	//
	// pull out the machine account information
	//


	dwRet = XQueryConfigValue( &g_OnlineMainConfigSectorInfo,
                               XC_ONLINE_MACHINE_ACCOUNT, 
							   &dwType,
							   &machineAccount, 
							   sizeof( XC_ONLINE_MACHINE_ACCOUNT_STRUCT ), 
							   &cbResultLength );

	//
	// if htis call failed, something must be wrong
	// we return true to signify that this section should be wiped
	//

	ASSERT( ERROR_SUCCESS == dwRet || !"Could not read config sector" );

	if ( ERROR_SUCCESS != dwRet )
	{
		return TRUE;
	}

	//
	// check the last four bytes for 1101 november time stamp
	//

	iVal = memcmp( machineAccount.reserved + XONLINE_ACCOUNT_RESERVED_SIZE - 4,
			       "1101",
				   4 );
	
	//
	// if iVal is 0, that means the account is November. We want hte negation
	// of that
	//

	return 0 != iVal;
#endif
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: HasOldUserAccounts
//
// Input: None
//
// Output: TRUE if an old user account exists
//         FALSE otherwise
//
// Description: decides if old user accounts exist. If even one of the
//              users is old, all are wiped out
//
///////////////////////////////////////////////////////////////////////////////

BOOL HasOldUserAccounts( void )
{
	HRESULT hr = S_OK;

	INT iVal = 0;
	DWORD cUsers = 0;
	DWORD cFinalUsers = 0;
	XONLINE_USER aUsers[XONLINE_MAX_STORED_ONLINE_USERS];

	//
	// zero out the user array
	//

	ZeroMemory( aUsers, sizeof( aUsers ) );

	//
	// query the users
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = XOnlineGetUsers( aUsers, &cUsers );
		ASSERT( SUCCEEDED( hr ) || !"Could not get users" );
	}

	//
	// copy the number of final users
	//

	cFinalUsers = cUsers;

	//
	// cycle through the users, removing the ones on MU
	//

	for ( DWORD i = 0; i < cUsers && SUCCEEDED( hr ); i++ )
	{
		if ( XONLINE_USER_OPTION_CAME_FROM_MU & aUsers[i].dwUserOptions )
		{
			cFinalUsers--;
			ZeroMemory( aUsers + i, sizeof( XONLINE_USER ) );
		}
	}

	//
	// cycle through the users
	//

	for ( DWORD i = 0; i < cFinalUsers && SUCCEEDED( hr ); i++ )
	{
		//
		// look for the november 1101 tag
		//

		iVal = memcmp( aUsers[i].reserved + XONLINE_USER_RESERVED_SIZE - 4,
			           "1101",
					   4 );

		//
		// return if the user tag is not 1101
		//

		if ( 0 != iVal )
		{
			return TRUE;
		}
	}

	//
	// if we got here, there were no old users
	//

	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: VerifyMachineAcount
//
// Input: ullId - the id
//        szName - the name of the machine
//        szPassword - the password for the machine
//
// Output: TRUE if the machine accounts match
//         FALSE otherwise
//
// Description: decides if the machine account on the box is the same
//              as the one passed in
//
///////////////////////////////////////////////////////////////////////////////

BOOL
VerifyMachineAccount( ULONGLONG ullId, LPSTR szName, LPSTR szPassword )
{
#if 1
    RIP("should not call this anymore");
    return FALSE;
#else
	DWORD dwRet = 0;
	DWORD cbResultLength = 0;
	DWORD dwType = 0;
	INT iVal = 0;
	BYTE byKey[XONLINE_KEY_LENGTH];

	XC_ONLINE_MACHINE_ACCOUNT_STRUCT machineAccount;

	//
	// Zero out the machine account and the key
	//

	ZeroMemory( &machineAccount, sizeof( XC_ONLINE_MACHINE_ACCOUNT_STRUCT ) );
	ZeroMemory( byKey, sizeof( byKey ) );

	//
	// get the config sector info
	//

	dwRet = XQueryConfigValue( &g_OnlineMainConfigSectorInfo,
                               XC_ONLINE_MACHINE_ACCOUNT, 
							   &dwType,
							   &machineAccount, 
							   sizeof( XC_ONLINE_MACHINE_ACCOUNT_STRUCT ), 
							   &cbResultLength );

	//
	// if there was a failure reading the config sector, fail
	//

	if ( ERROR_SUCCESS != dwRet )
	{
		return FALSE;
	}

	//
	// decrypt the key
	//

	DecryptKeyWithHardDriveKey( machineAccount.key, sizeof( machineAccount.key ) );
	KerbPasswordToKey( szPassword, byKey );

	//
	// decide on the result
	//
	
	return ullId == machineAccount.id && 
		   0 == strcmp( machineAccount.name, szName ) &&
		   0 == memcmp( machineAccount.key, byKey, XONLINE_KEY_LENGTH );
#endif
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: ReadUserData
//
// Input: pIniFile - an open file pointer to the ini file to read from
//        pNewUser - where the user data should be placed
//
// Output: S_OK on success, E_OUTOFMEMORY when no more data to read E_XXXX otherwise
//
// Description: reads 1 line of user data, and populate the user
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
ReadUserData( FILE* pIniFile, PXONLINEP_USER pNewUser )
{
#if 1
    RIP("should not call this anymore");
	return E_FAIL;
#else

	HRESULT hr = S_OK;
	INT iVal = 0;

	CHAR szString[256];
	BYTE byPin[XONLINE_PIN_LENGTH];

	union un {
		ULONGLONG ullVals[2];
		BYTE byVals[16];
	} unn;

	//
	// make sure the ini file is not NULL
	//

	if ( NULL == pIniFile )
	{
		hr = E_POINTER;
		ASSERT( SUCCEEDED( hr ) || !"Ini file pointer was null" );
	}

	//
	// make sure the user is not NULL
	//

	if ( NULL == pNewUser )
	{
		hr = E_POINTER;
		ASSERT( SUCCEEDED( hr ) || !"User pointer was NULL" );
	}

	if ( SUCCEEDED( hr ) )
	{

		ZeroMemory( szString, sizeof( szString ) );

		//
		// the format string is:
		//
		// 16 hex charecters put into an 8 byte value
		// , delimieter
		// 63 maximum valid email string charecters
		// , delimeter
		// 32 hex charecters (16 + 16) put into 2-8 byte values
		// , delimiter
		// 255 maximum valid string charecters (optional)

		iVal = fscanf( pIniFile, 
					   "%16I64x,%16[a-zA-Z0-9!#$%&'*+./=?^_`{|}~@-],%12[a-zA-Z0-9!#$%&'*+./=?^_`{|}~@-],%20[a-zA-Z0-9!#$%&'*+./=?^_`{|}~@-],%16I64x%16I64x,%255[a-zA-Z0-9,]", 
					   &pNewUser->xuid.qwUserID,
					   pNewUser->name,
					   pNewUser->kingdom,
					   pNewUser->domain,
					   unn.ullVals + 1,
					   unn.ullVals,
					   szString );

		hr = 0 != iVal ? S_OK : E_FAIL;

		ASSERT( SUCCEEDED( hr ) || !"Bad ini data" );

		if ( EOF == iVal )
		{
			hr = E_OUTOFMEMORY;
		}

	}

	
	//
	// copy the realm value
	// AND
	// copy the values from the union into the key
	//

	if ( SUCCEEDED( hr ) )
	{
		strcpy( pNewUser->realm, "passport.net" );

		for ( DWORD i = 0; i < sizeof( ULONGLONG ) * 2 && SUCCEEDED( hr ); i++ )
		{
			pNewUser->key[i] = unn.byVals[sizeof( ULONGLONG ) * 2 - i - 1];
		}
	}
	
	//
	// Parse the optional params. These are (all optional)
	// 8 bytes flags
	// , delimieter
	// 8 bytes pin
	// , delimiter
	// 237 chars
	//

	if ( SUCCEEDED( hr ) )
	{
		iVal = sscanf( szString, "%8x,%8x", &pNewUser->dwUserOptions, byPin );

		hr = 0 != iVal ? S_OK : E_FAIL;
		ASSERT( SUCCEEDED( hr ) || !"Bad ini data" );
	}

	//
	// rearange the pin value
	//
	
	if ( SUCCEEDED( hr ) )
	{
		for ( DWORD i = 0; i < XONLINE_PIN_LENGTH && SUCCEEDED( hr ); i++ )
		{
			pNewUser->pin[i] = byPin[XONLINE_PIN_LENGTH - i - 1];
		}
	}
	
	//
	// spit back the hr
	//

	return hr;
#endif

}
*/

///////////////////////////////////////////////////////////////////////////////
//
// Name: QuickLogonStart
//
// Input: none
//
// Output: S_OK on success,  E_XXXX otherwise
//
// Description: does a quick logon to the user account creation server
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
COnlineAccounts::QuickLogonStart( void )
{
	//
	// handles to communicate with Xbox Online
	//

	HRESULT hr = S_OK;
	HRESULT hrTask = S_OK;
	HANDLE hEvent = NULL;

	DWORD dwWait = 0;

	//
	// create the event handle, make sure it is valid
	//

	hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

	if ( NULL == hEvent )
	{
		hr = E_OUTOFMEMORY;
	}

	//
	// since no users will be logged in (this is just a ping), we
	// want to only hit the user account server
	//

    DWORD aServices[] = { XONLINE_USER_ACCOUNT_SERVICE };

	//
	// create the user array, zero it out
	//

	XONLINE_USER aUsers[XONLINE_MAX_LOGON_USERS];
	ZeroMemory( aUsers, sizeof( aUsers ) );

	//
	// generate the async logon to the user account service
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = XOnlineLogon( aUsers, 
						   aServices,
			               sizeof( aServices ) / sizeof( DWORD ),
						   hEvent, 
						   &m_hTask );

	}

	//
	// pump the task handle until logon completes
	//

	if ( SUCCEEDED( hr ) )
	{

		do
		{   
			//
			// wait for data to be ready for processing
			//

			dwWait = WaitForSingleObject( hEvent, ONLINE_ACCOUNT_WAIT_INTERVAL );

			//
			// see if the wait failed due to memory
			//

			if ( WAIT_FAILED == dwWait )
			{
				hr = E_OUTOFMEMORY;
			}

			//
			// see if the wait timed out
			//
        
			if ( WAIT_TIMEOUT == dwWait )
			{
				hr = E_FAIL;
			}

			//
			// continue pumping the handle
			//

			if ( SUCCEEDED( hr ) )
			{
				hrTask = XOnlineTaskContinue( m_hTask );
			}
                        Sleep(1);
		} while ( hrTask == XONLINETASK_S_RUNNING && SUCCEEDED( hr ) );
	}

    //
    // close the event
    //

    if ( NULL != hEvent )
    {
        CloseHandle( hEvent );
        hEvent = NULL;
    }

	return SUCCEEDED( hrTask ) ? hr : hrTask;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: QuickLogonFinish
//
// Input: none
//
// Output: S_OK on success,  E_XXXX otherwise
//
// Description: does a quick logoff to the user account creation server
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
COnlineAccounts::QuickLogonFinish( void )
{
	HRESULT hr = S_OK;

	//
	// close the handle, wether we have falied or not
	//

	if ( NULL != m_hTask )
	{
		XOnlineTaskClose( m_hTask );
	}

	//
	// reset the task handle
	//

	m_hTask = NULL;

	//
	// spit back the hr
	//

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: GenerateUserName
//
// Input: szUserName - an array of XONLINE_NAME_SIZE bytes ot get 
//        the new user name                      
//        
// Output: S_OK on success, E_XXXX otherwise
//
// Description: create a random user name based on the Ethernet MAC address
//              and 3 bytes of charecter values
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
COnlineAccounts::GenerateUserName( CHAR szName[XONLINE_NAME_SIZE] )
{
	HRESULT hr = S_OK;

	DWORD dwStatus = 0;
	DWORD dwType = 0;
	DWORD cbResultLength = 0;

	CHAR abMacAddress[6];

	//
	// zero out the char array
	//

	ZeroMemory( abMacAddress, 6 );

	//
	// get the Ethernet MAC address
	//

	if ( SUCCEEDED( hr ) )
	{
		//
		// get the address
		//
#ifdef _XBOX
		dwStatus = ExQueryNonVolatileSetting( XC_FACTORY_ETHERNET_ADDR, &dwType, abMacAddress, 6, &cbResultLength );
		hr = NT_SUCCESS( dwStatus ) ? S_OK : E_FAIL;
		
		ASSERT( SUCCEEDED( hr ) || !"Could not get ethernet MAC address" );

#else

		sprintf( abMacAddress, "%6.6s", getenv("COMPUTERNAME") );

#endif
	}

	//
	// now populate the user name
	//

	if ( SUCCEEDED( hr ) )
	{
		//
		// populate user name with the last 4 bytes of the ethernet mac address
		//

		for ( DWORD i = 0; i < 4; i++ )
		{
			//
			// print the current byte
			//

			sprintf( szName + i * 2, "%02x", (BYTE) abMacAddress[i + 2] );
		}

		//
		// stuff the last 7 bytes with a random char
		//

		sprintf( szName + 8, 
				 "%c%c%c%c%c%c%c", 
				 (BYTE) rand() % ( 'Z' - 'A' ) + 'A',
				 (BYTE) rand() % ( 'Z' - 'A' ) + 'A',
				 (BYTE) rand() % ( 'Z' - 'A' ) + 'A',
				 (BYTE) rand() % ( 'Z' - 'A' ) + 'A',
				 (BYTE) rand() % ( 'Z' - 'A' ) + 'A', 
				 (BYTE) rand() % ( 'Z' - 'A' ) + 'A', 
				 (BYTE) rand() % ( 'Z' - 'A' ) + 'A' );
	}

	//
	// spit back the hr
	//

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: GenerateUserAccount
//
// Input: pUser - the user to fill in                     
//        
// Output: S_OK on success, E_XXXX otherwise
//
// Description: fill in and create a user
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
COnlineAccounts::GenerateUserAccount( PXONLINEP_USER pUser )
{
	HRESULT hr = S_OK;

	HRESULT hrTask = S_OK;
	HANDLE hEvent = NULL;

	XONLINETASK_HANDLE hTask = NULL;

	DWORD dwWait = 0;

	HRESULT hrGenName = S_OK;

	//
	// create the event handle, make sure it is valid
	//

	hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

	if ( NULL == hEvent )
	{
		hr = E_OUTOFMEMORY;
		ASSERT( SUCCEEDED( hr ) || !"Could not create event handle for account creation" );
	}

	if ( SUCCEEDED( hr ) )
	{
		do
		{
			//
			// see if name needs to be populated
			//

			if ( SUCCEEDED( hr ) && 0 == strcmp( pUser->name, "" ) )
			{
				//
				// go ahead and generate the user name
				//

				hr = GenerateUserName( pUser->name );
				ASSERT( SUCCEEDED( hr ) || !"Could not generate user name" );

				DbgPrint( pUser->name );
				DbgPrint( "\n" );
			}

			//
			// fill in the kingdom
			//

			if ( SUCCEEDED( hr ) && 0 == strcmp( pUser->kingdom, "" ) )
			{
				strcpy( pUser->kingdom, "Feb2002" );
			}

			//
			// create the account
			//

			if ( SUCCEEDED( hr ) )
			{
				hr = _XOnlineAccountTempCreate( (PXONLINE_USER) pUser, hEvent, &hTask );
		//		ASSERT( SUCCEEDED( hr ) || !"Creation of temp account failed" );
			}

			//
			// pump the task handle until user creation completes
			//

			if ( SUCCEEDED( hr ) )
			{
				do
				{   
					//
					// wait for data to be ready for processing
					//

					dwWait = WaitForSingleObject( hEvent, ONLINE_ACCOUNT_WAIT_INTERVAL );

					if ( WAIT_FAILED == dwWait )
					{
						hr = E_OUTOFMEMORY;
					}
    
					//
					// make sure the wait did not time out
					//

					else if ( WAIT_TIMEOUT == dwWait )
					{
						hr = E_FAIL;
					}

					//
					// continue pumping the handle
					//

					if ( SUCCEEDED( hr ) )
					{
						hrTask = XOnlineTaskContinue( hTask );
					}
                                        Sleep(1);
				} while ( XONLINETASK_S_RUNNING == hrTask && SUCCEEDED( hr ) );
			}

			//
			// if the name was taken, zero it out
			//

			if ( XONLINE_S_ACCOUNTS_NAME_TAKEN == hrTask && SUCCEEDED( hr ) )
			{
				hrGenName = S_FALSE;

				hrTask = S_OK;
				ZeroMemory( pUser->name, XONLINE_NAME_SIZE );

				//
				// close down the handle
				//

				if ( NULL != hTask )
				{
					hrTask = XOnlineTaskClose( hTask );
					ASSERT( SUCCEEDED( hrTask ) || !"Could not close handle" );
					hTask = NULL;
				}

				hr = SUCCEEDED( hr ) ? hrTask : hr;
			}

			else if ( FAILED( hrTask ) )
			{
				hr = hrTask;
			}

			//
			// keep going until the name is filled
			//

		} while ( 0 == strcmp( pUser->name, "" ) && SUCCEEDED( hr ) );
	}

	//
	// Now retrieve the created account
	//

    if ( SUCCEEDED( hr ) )
    {
		hr = _XOnlineAccountTempCreateGetResults( hTask, (PXONLINE_USER) pUser );
		ASSERT( SUCCEEDED( hr ) || !"Creation of temp account failed" );
    }

	//
	// close the handle, wether we have falied or not
	//

	if ( NULL != hTask )
	{
		hrTask = XOnlineTaskClose( hTask );
		ASSERT( SUCCEEDED( hrTask ) || !"Could not close handle" );
		hTask = NULL;
	}

	hr = SUCCEEDED( hr ) ? hrTask : hr;

    //
    // close the event
    //

    if ( NULL != hEvent )
    {
        CloseHandle( hEvent );
        hEvent = NULL;
    }

	return SUCCEEDED( hr ) ? hrGenName : hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: GetUsers
//
// Input: aUsers - an output array of users
//        dwNumAccounts - the number of accounts to fill                       
//        
// Output: S_OK on success, E_XXXX otherwise
//
// Description: creates N users using UAPS
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
COnlineAccounts::GetUsers( PXONLINEP_USER aUsers, DWORD dwNumAccounts )
{
	//
	// handles to communicate with xonline
	//

	HRESULT hr = S_OK;
	HRESULT hrTask = S_OK;
	HRESULT hrGenName = S_OK;

	DWORD dwNumCreated = 0;

	//
	// seed the random number generator
	// 

	srand( time( NULL ) );

	//
	// we need to specify the user array, this pointer can't be NULL
	//

	if ( NULL == aUsers )
	{
		hr = E_INVALIDARG;
		ASSERT( SUCCEEDED( hr ) || !"Must pass an array of users. aUsers can not be NULL" );
	}

	//
	// initiate a logon
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = QuickLogonStart();
//		ASSERT( SUCCEEDED( hr ) || !"Could not logon" );
	}

	//
	// create accounts for each item
	//

	for( dwNumCreated = 0; dwNumCreated < dwNumAccounts && SUCCEEDED( hr ); dwNumCreated++ )
	{
		//
		// generate the user
		//

		hr = GenerateUserAccount( aUsers + dwNumCreated );
		hrGenName = hr;
	//	ASSERT( SUCCEEDED( hr ) || !"GenerateUserAccounts failed" );

		if ( SUCCEEDED( hr ) )
		{
			hr = _XOnlineAddUserToHD( (PXONLINE_USER) aUsers + dwNumCreated );
		}
	}

	//
	// verify the number of accounts requested was the same as the number created
	//

	if ( SUCCEEDED( hr ) && dwNumCreated != dwNumAccounts )
	{
		hr = E_FAIL;
		ASSERT( SUCCEEDED( hr ) || !"Number of accounts created is not correct" );
	}

	//
	// verify the number of accounts created is in the right range
	//

	if ( SUCCEEDED( hr ) && dwNumCreated > XONLINE_MAX_STORED_ONLINE_USERS )
	{
		hr = E_FAIL;
		ASSERT( SUCCEEDED( hr ) || !"Can not create more than max users!" );
	}

	//
	// end the logon
	//

	hrTask = QuickLogonFinish();

	hr = SUCCEEDED( hr ) ? hrTask : hr;

	//
	// spit back the hr
	//

	return SUCCEEDED( hr ) ? hrGenName : hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: PopulateUserAccountsMU
//
// Input: chDrive - the drive letter of the MU to populate
//
//        pUser - an XONLINEP_USER pointer. if the pointer is NULL, then the
//                user is erased off the MU. 
//                if the name is NULL, a random name will generated
//        
// Output: S_OK on success, E_XXXX otherwise
//
// Description: creates 1 user on the MU using XUACS
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
COnlineAccounts::PopulateUserAccountsMU( CHAR chDrive, PXONLINEP_USER pUser )
{
	HRESULT hr = S_OK;
	HRESULT hrGenName = S_OK;

	XONLINEP_USER user;

	//
	// zero out the internal user
	//

	ZeroMemory( &user, sizeof( XONLINEP_USER ) );

	//
	// if no user was passed in, then we want to erase the user
	// on the MU
	//

	if ( NULL == pUser )
	{
		pUser = &user;
	}

	//
	// otherwise, see if we need to populate the name and kingdom
	//

	else
	{
		hr = GenerateUserAccount( pUser );
		hrGenName = hr;

		if ( SUCCEEDED( hr ) )
		{
			hr = _XOnlineSetUserInMU( chDrive, (PXONLINE_USER) pUser );
		}
	}

	//
	// spit back the hr
	//
	
	return SUCCEEDED( hr ) ? hrGenName : hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: PopulateUserAccountsHD
//
// Input: aUsers - the array of the xonline users to populate
//
//                 dwNumAccounts elements in this array will be filled. if
//                 the inputed name and kingdom are NULL, then a random 
//                 name and kingdom are generated and used. if the name and
//                 kingdom are both not null, then the specified name/kingdom
//                 are used to generate the user in UAPS. if this pointer is NULL
//                 then the function will internally allocate random users
//
//        dwNumAccounts -  the number of accounts to populate the
//                         drive with
//
//                         dwNumAccounts == 0, then the drive will have all 
//                         accounts removed and no new accounts will be added
//
//        bRemoveUsers - if set, then users are removed from the HD before creating
//                       new ones. Set by default
//
// Output: S_OK on success
//         E_XXXX on failutre
//         S_FALSE if less users were populated then expected.
//
// Description: Populates the hard disk with the specified number of users.
//              this function will clear off any users on the drive before 
//              populating the drive
//
///////////////////////////////////////////////////////////////////////////////

HRESULT 
COnlineAccounts::PopulateUserAccountsHD( PXONLINEP_USER aUsers, DWORD dwNumAccounts, BOOL bRemoveUsers )
{
	HRESULT hr = S_OK;
	HRESULT hrGenName = S_OK;
	DWORD dwNumUsers = 0;
	XONLINEP_USER aExistingUsers[XONLINE_MAX_STORED_ONLINE_USERS];

	//
	// clear out the user array
	//

	ZeroMemory( aExistingUsers, sizeof( aExistingUsers ) );

	//
	// make sure no more than 8 users are asked for
	//

	if ( dwNumAccounts > XONLINE_MAX_HD_ONLINE_USERS )
	{
		hr = E_INVALIDARG;
		ASSERT( SUCCEEDED( hr ) || !"can not ask for more than 8 users!" );
	}

	//
	// get the users on the drive currently
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = _XOnlineGetUsersFromHD( (PXONLINE_USER) aExistingUsers, &dwNumUsers );
		ASSERT( SUCCEEDED( hr ) || !"Could not get users on drive" );
	}

	//
	// if we have a FULL drive, then let's error out, only if removal was not asked for
	//

	if ( SUCCEEDED( hr ) && XONLINE_MAX_HD_ONLINE_USERS == dwNumUsers && FALSE == bRemoveUsers )
	{
		hr = E_OUTOFMEMORY;
	}

	//
	// remove the users on the drive
	//

	for ( DWORD i = 0; i < dwNumUsers && SUCCEEDED( hr ) && TRUE == bRemoveUsers; i++ )
	{ 
		hr = _XOnlineRemoveUserFromHD( (PXONLINE_USER) ( aExistingUsers + i ) );
		ASSERT( SUCCEEDED( hr ) || !"Could not remove user" );
	}

	//
	// allow for NULL user list
	//

	if ( NULL == aUsers )
	{
		aUsers = aExistingUsers;
		ZeroMemory( aUsers, sizeof( aExistingUsers ) );
	}

	//
	// create the users
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = GetUsers( aUsers, dwNumAccounts );
		hrGenName = hr;
	//	ASSERT( SUCCEEDED( hr ) || !"Could not get users" );
	}

	//
	// return the hr
	//

	return SUCCEEDED( hr ) ? hrGenName : hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\SetupOnline\CreationStateScreen.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: CreationStateScreen.cpp
//
// Author: Dan Rosenstein (danrose)
//
// Description: the implementation for creation state screen
//
///////////////////////////////////////////////////////////////////////////////

#include "CreationStateScreen.h"

///////////////////////////////////////////////////////////////////////////////
//
// Name:  creation state screen constructor
//
// Input: pParent - the parent screen for this screen
//
// Output: None
//
// Description: creates an instance of the creation state screen
//
///////////////////////////////////////////////////////////////////////////////

CCreationStateScreen::CCreationStateScreen( CUserInterfaceScreen* pParent )

	//
	// the parent of the creation state screen
	//

	: CUserInterfaceScreen( pParent, 
	                        CREATION_STATE_SCREEN_FG_COLOR, 
							CREATION_STATE_SCREEN_BG_COLOR, 
							CREATION_STATE_SCREEN_X, 
							CREATION_STATE_SCREEN_Y ),

	//
	// start in the start state
	//

	m_creationState( START_STATE ),
	
	//
	// start off with screens
	//

	m_pNameScreen( NULL ),
	m_pPinScreen( NULL ),
	m_pCreationScreen( NULL )

{
	//
	// init the screens... this can't fail
	//

	m_pNameScreen = new CNameEntryScreen( this );
	m_pPinScreen = new CPinEntryScreen( this );
	m_pCreationScreen = new CAccountCreationScreen( this );

	ASSERT( m_pNameScreen && m_pPinScreen && m_pCreationScreen );

	//
	// needs to have some kind text
	//

	SetText( "" );

}

///////////////////////////////////////////////////////////////////////////////
//
// Name:  creation state screen destructor
//
// Input: None
//
// Output: None
//
// Description: destroys an instance of the creation state screen
//
///////////////////////////////////////////////////////////////////////////////

CCreationStateScreen::~CCreationStateScreen( void )
{
	//
	// no code here
	//
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Update
//
// Input: pInput - the input ui
//        pAudio - the audio ui
//
// Output: the next screen
//
// Description: process the input for the screen
//
///////////////////////////////////////////////////////////////////////////////

CUserInterfaceScreen* 
CCreationStateScreen::Update( CUserInterfaceInput* pInput, CUserInterfaceAudio* pAudio )
{
	HRESULT hr = S_OK;
	CUserInterfaceScreen* pRet = NULL;

	//
	// if b was pressed from the name entry screen, make sure our state gets update
	// a NULL pInput can be generated if CANCEL was selected on the keyboard
	//

	if ( ( NULL == pInput || pInput->BPressed() ) && NAME_ENTRY_STATE == m_creationState )
	{
		m_creationState = START_STATE;

		pAudio->PlayBackButton();
		return ParentScreen();
	}

	//
	// if b was pressed from the pin entry screen, make sure our state gets update
	//

	if ( pInput->BPressed() && PIN_ENTRY_STATE == m_creationState )
	{
		m_creationState = NAME_ENTRY_STATE;

		pAudio->PlayBackButton();
		return m_pNameScreen;
	}

	//
	// if b was pressed from the creation screen, make sure our state gets update
	//

	if ( pInput->BPressed() && USER_CREATION_STATE == m_creationState )
	{
		m_creationState = PIN_ENTRY_STATE;

		pAudio->PlayBackButton();
		return m_pPinScreen;
	}

	//
	// if a was pressed from the pin entry  or name entry or creation play the select
	//

	if ( pInput->APressed() && ( NAME_ENTRY_STATE == m_creationState || 
		                         PIN_ENTRY_STATE == m_creationState  ||
								 USER_CREATION_STATE == m_creationState ) )
	{
		pAudio->PlaySelectButton();
	}

	//
	// decide which state we are in, which to goto
	//

	switch( m_creationState )
	{
		case START_STATE:
		{
			//
			// from start goto name
			//

			pRet = m_pNameScreen;
			m_creationState = NAME_ENTRY_STATE;

			break;
		}

		case NAME_ENTRY_STATE:
		{
			//
			// from name goto pin
			//

			pRet = m_pPinScreen;
			m_creationState = PIN_ENTRY_STATE;
			break;
		}

		case PIN_ENTRY_STATE:
		{
			//
			// set the name and pin on the creation screen
			//

			m_pCreationScreen->SetName( m_pNameScreen->GetName() );
			m_pCreationScreen->SetPin( m_pPinScreen->GetPin() );

			//
			// from pin goto creation
			//

			pRet = m_pCreationScreen;
			m_creationState = USER_CREATION_STATE;
			break;
		}

		case USER_CREATION_STATE:
		{
			//
			// from creation goto done
			//

			pRet = ParentScreen();
			m_creationState = DONE_STATE;

			break;
		}

		case DONE_STATE:
		{
			m_creationState = START_STATE;
			pRet = NULL;
			break;
		}


	}

	return pRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\SetupOnline\AccountsScreen.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: AccountsScreen.cpp
//
// Author: Dan Rosenstein (danrose)
//
// Description: the implementation for the account screen
//
///////////////////////////////////////////////////////////////////////////////

#include "AccountsScreen.h"

///////////////////////////////////////////////////////////////////////////////
//
// Name: CAccountsScreen constructor
//
// Input: pParent - the parent screen of the current screen
//
// Output: None
//
// Description: creates an instance of the Account screen
//
///////////////////////////////////////////////////////////////////////////////

CAccountsScreen::CAccountsScreen( CUserInterfaceScreen* pParent )

	//
	// set up the parent user interface object
	//

	: CUserInterfaceScreen( pParent, 
	                        ACCOUNT_SCREEN_FG_COLOR, 
							ACCOUNT_SCREEN_BG_COLOR, 
							ACCOUNT_SCREEN_X, 
							ACCOUNT_SCREEN_Y ),

	//
	// create the ini menu using the first user array list
	//

/*	  m_iniMenu( INI_NAME, 
	             ACCOUNT_SCREEN_FG_COLOR, 
				 ACCOUNT_SCREEN_BG_COLOR, 
				 ACCOUNT_SCREEN_X,
				 ACCOUNT_SCREEN_Y,
				 m_aapUserLists[0], 
				 &m_pClipboardUser,
				 &m_aSelectText,
				 &m_aAddUserText,
				 &m_xText ),
*/
	//
	// create the uiText elements
	//

	  m_aText( ACCOUNT_A_SELECT_TEXT, 
	           ACCOUNT_A_X, 
		       ACCOUNT_A_Y, 
			   ACCOUNT_A_FG_COLOR, 
			   ACCOUNT_A_BG_COLOR ),

      m_xText( ACCOUNT_X_TEXT, 
	           ACCOUNT_X_X, 
			   ACCOUNT_X_Y, 
			   ACCOUNT_X_FG_COLOR, 
			   ACCOUNT_X_BG_COLOR ),

	  m_bText( ACCOUNT_B_TEXT, 
	           ACCOUNT_B_X, 
			   ACCOUNT_B_Y, 
			   ACCOUNT_B_FG_COLOR, 
			   ACCOUNT_B_BG_COLOR ),

	  m_leftText( ACCOUNT_LEFT_TEXT, 
	              ACCOUNT_LEFT_X, 
				  ACCOUNT_LEFT_Y, 
				  ACCOUNT_LEFT_FG_COLOR, 
				  ACCOUNT_LEFT_BG_COLOR ),

	  m_rightText( ACCOUNT_RIGHT_TEXT, 
	               ACCOUNT_RIGHT_X, 
				   ACCOUNT_RIGHT_Y, 
				   ACCOUNT_RIGHT_FG_COLOR, 
				   ACCOUNT_RIGHT_BG_COLOR ),

	  m_overwriteText( ACCOUNT_OVERWRITE_TEXT,
	                   ACCOUNT_OVERWRITE_X,
					   ACCOUNT_OVERWRITE_Y,
					   ACCOUNT_OVERWRITE_FG_COLOR,
					   ACCOUNT_OVERWRITE_BG_COLOR ),


	//
	// init all non array members
	//

	  m_pClipboardUser( NULL ),
	  m_dwMUs( 0 ),
	  m_bInit( FALSE ),
	  m_chUpdate( INVALID_DEVICE_CHAR ),
	  m_dwLastActive( 0 ),
	  m_bJustEntered( TRUE ),
	  m_dwBadMUs( 0 )
{
	//
	// the constructor will do some internal init, but
	// will report errors by setting the screen text
	//

	HRESULT hr = S_OK;

	//
	// zero out the array members
	//

	ZeroMemory( m_aapUserLists, sizeof( m_aapUserLists ) );
	ZeroMemory( m_apDeviceMenus, sizeof( m_apDeviceMenus ) );

	//
	// add the ui text to the screen
	//

	AddUIText( &m_aText );
	AddUIText( &m_bText );
	AddUIText( &m_xText );
	AddUIText( &m_leftText );
	AddUIText( &m_rightText );
	AddUIText( &m_overwriteText );

	//
	// hide non visible text
	//

	m_xText.Hide( TRUE );
	m_leftText.Hide( TRUE );
	m_rightText.Hide( TRUE );
	m_aText.Hide( TRUE );
	m_overwriteText.Hide( TRUE );

	//
	// Parse the ini file
	//

//	hr = ParseIniFile();

	//
	// the ini file does not have to exist, so assert is not needed
	//

	//
	// if parsing of the ini file failed, report it to the user
	//

//	if ( FAILED( hr ) )
//	{
//		SetText( S_PARSE_INI_FILE );
//		m_aSelectText.Hide( TRUE );
//	}

	SetText( "" );

}

///////////////////////////////////////////////////////////////////////////////
//
// Name: CAccountsScreen destructor
//
// Input: None
//
// Output: None
//
// Description: destroys an instance of the Account screen
//
///////////////////////////////////////////////////////////////////////////////

CAccountsScreen::~CAccountsScreen( void )
{
	DWORD dwError = 0;
	HRESULT hr = S_OK;

	//
	// first clean up the menu lists
	//

	CleanupLists();

	//
	// unmount the mus, destroy the list
	//

	for ( DWORD i = 0; i < NUM_DEVICE_MENUS; i++ )
	{
		//
		// delete the menu
		//

		delete m_apDeviceMenus[i];
		m_apDeviceMenus[i] = NULL;

		//
		// if hte mu was mounted, unmount it
		//

		if ( 0 != i && m_dwMUs & ( 1 << i ) )
		{
			//
			// convert from bit flag to port/slot value
			//

			dwError = XUnmountMU( ( i - 1 ) & 0xC, ( i - 1 ) >> 2 );
			hr = 0 == dwError ? S_OK : E_MU_UNMOUNT;

		//	MY_ASSERT( hr, S_MU_UNMOUNT );
		}
	}
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: ParseIniFile
//
// Input: None
//
// Output: S_OK if ini file was opened and parsed properly
//
// Description: tries to open and parse the user ini file for online
//
///////////////////////////////////////////////////////////////////////////////
/*
HRESULT 
CAccountsScreen::ParseIniFile( void )
{
	HRESULT hr = S_OK;
	FILE* pIniFile = NULL;
	int iVal = 0;
	DWORD dwCount = 0;

	PXONLINEP_USER pNewUser = NULL;

	//
	// open the ini file
	//

	if ( SUCCEEDED( hr ) )
	{
		pIniFile = fopen( INI_FILE_LOCATION, "rb" );
		hr = pIniFile ? S_OK : E_OPEN_INI_FILE;

		//
		// ini file may not exist, so no assert is needed
		//
	}

	//
	// add the ini menu to the menus
	//

	if ( SUCCEEDED( hr ) )
	{
		AddMenu( &m_iniMenu );
	}

	//
	// read the user data out of the ini file
	//

	while ( SUCCEEDED( hr ) )
	{
		//
		// create a new user pointer
		//

		pNewUser = new XONLINEP_USER();

		hr = pNewUser ? S_OK : E_MEMORY_ALLOCATION;
		MY_ASSERT( hr, S_MEMORY_ALLOCATION );

		//
		// read the data out of the ini
		//

		if ( SUCCEEDED( hr ) )
		{
			hr = ReadUserData( pIniFile, pNewUser );
			
			if ( E_OUTOFMEMORY == hr )
			{
				hr = S_OK;
				break;
			}
		}

		MY_ASSERT( hr, S_PARSE_INI_FILE );
		
		//
		// Add the user to the ini user list
		//

		if ( SUCCEEDED( hr ) )
		{
			m_aapUserLists[0][dwCount] = pNewUser;
			m_iniMenu.AddItem( pNewUser->name, NULL );
			
		}

		dwCount++;

	}

	//
	// close the ini file
	//

	
	if ( pIniFile )
	{
		iVal = fclose( pIniFile );
		pIniFile = NULL;
		hr = 0 == iVal ? S_OK : E_CLOSE_INI_FILE;

		MY_ASSERT( hr, S_CLOSE_INI_FILE );
	}

	return hr;
}
*/
///////////////////////////////////////////////////////////////////////////////
//
// Name: CleanupList
//
// Input: dwIndex - the index of the list to clean
//
// Output: None
//
// Description: runs through the specified list, and cleans it up
//
///////////////////////////////////////////////////////////////////////////////

void
CAccountsScreen::CleanupList( DWORD dwIndex )
{
	for ( DWORD j = 0; j < XONLINE_MAX_STORED_ONLINE_USERS; j++ )
	{
		//
		// only delete the list if it exists
		//

		if ( m_aapUserLists[dwIndex][j] )
		{
			delete m_aapUserLists[dwIndex][j];
			m_aapUserLists[dwIndex][j] = NULL;
		}
	}
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: CleanupLists
//
// Input: None
//
// Output: None
//
// Description: runs through each of the lists, and cleans them up
//
///////////////////////////////////////////////////////////////////////////////

void 
CAccountsScreen::CleanupLists( void )
{
	for ( DWORD i = 0; i < NUM_MENUS; i++ )
	{
		CleanupList( i );
	}
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: PopulateDriveList
//
// Input: chDrive - a char representing a drive to mount and get data from
//
// Output: S_OK if drive mounting and list insertion completed without error,
//         S_FALSE if drive could not be mounted
//         E_XXXX if an error occured
//
// Description: tries to mount the given drive, and populates the user list
//              with the user data on the drive
//
///////////////////////////////////////////////////////////////////////////////

HRESULT 
CAccountsScreen::PopulateDriveList( CHAR chDrive )
{
	HRESULT hr = S_OK;
	PXONLINEP_USER pUsers = NULL;
	PXONLINEP_USER pUser = NULL;
	DWORD dwPort = 0;
	DWORD dwSlot = 0;
	DWORD dwUsers = 0;
	CHAR chRetDrive = '\0';
	DWORD dwRet = 0;
	DWORD dwMask = 0;

	CHAR * szName = NULL;

	//
	// decide the index into the master array
	//

	DWORD dwUserIndex = 0 == chDrive ? 1 : 2 + chDrive - 'F';
	DWORD dwDeviceIndex = 0;

	//
	// if this is not the hard disk, mount the drive
	//

	if ( SUCCEEDED( hr ) && 0 != chDrive )
	{
		//
		// decide which port / slot cooresponds to the passed in drive
		//

		switch ( chDrive )
		{
			case 'F': 
				dwPort = XDEVICE_PORT0;
				dwSlot = XDEVICE_TOP_SLOT;
				dwMask = 1 << 0;
				break;

			case 'G': 
				dwPort = XDEVICE_PORT0;
				dwSlot = XDEVICE_BOTTOM_SLOT;
				dwMask = 1 << 4;
				break;

			case 'H': 
				dwPort = XDEVICE_PORT1;
				dwSlot = XDEVICE_TOP_SLOT;
				dwMask = 1 << 1;
				break;

			case 'I': 
				dwPort = XDEVICE_PORT1;
				dwSlot = XDEVICE_BOTTOM_SLOT;
				dwMask = 1 << 5;
				break;

			case 'J': 
				dwPort = XDEVICE_PORT2;
				dwSlot = XDEVICE_TOP_SLOT;
				dwMask = 1 << 2;
				break;

			case 'K': 
				dwPort = XDEVICE_PORT2;
				dwSlot = XDEVICE_BOTTOM_SLOT;
				dwMask = 1 << 6;
				break;

			case 'L': 
				dwPort = XDEVICE_PORT3;
				dwSlot = XDEVICE_TOP_SLOT;
				dwMask = 1 << 3;
				break;

			case 'M': 
				dwPort = XDEVICE_PORT3;
				dwSlot = XDEVICE_BOTTOM_SLOT;
				dwMask = 1 << 7;
				break;
		}

		//
		// only mount if not mounted
		//

		if ( ! ( m_dwMUs & dwMask ) )
		{
			dwRet = XMountMU( dwPort, dwSlot, &chRetDrive );

			//
			// if the drive could not be mounted, short circuit the function
			//

			if ( ERROR_DEVICE_NOT_CONNECTED  == dwRet )
			{
				return S_FALSE;
			}

			//
			// make sure mounting of the mu succeeded
			//

			hr = ERROR_SUCCESS == dwRet ? S_OK : E_MU_MOUNT;

			//
			// save the mounted MU Id
			//

			if ( SUCCEEDED( hr ) )
			{
				m_dwMUs |= dwMask;
			}

			//
			// save the bad MU id
			//

			else
			{
				m_dwBadMUs |= dwMask;
			}

			//
			// make sure we got back the expected drive letter
			//

			if ( SUCCEEDED( hr ) )
			{
				hr = toupper( chDrive ) == toupper( chRetDrive ) ? S_OK : E_MU_MOUNT;
			}

		}

		//
		// calcualte the device index
		//
	
		dwDeviceIndex = ( ( dwSlot << 2 ) | dwPort ) + 1;
	}

	//
	// Allocate an array of online users
	//

	if ( SUCCEEDED( hr ) )
	{
		pUsers = new XONLINEP_USER[XONLINE_MAX_STORED_ONLINE_USERS];

		hr = pUsers ? S_OK : E_MEMORY_ALLOCATION;
		MY_ASSERT( hr, S_MEMORY_ALLOCATION );
	}

	//
	// Get the users from the drives
	//

	if ( SUCCEEDED( hr ) )
	{
		//
		// Get Users from HD
		//

		if ( 0 == chDrive )
		{

			hr = _XOnlineGetUsersFromHD( (PXONLINE_USER) pUsers, &dwUsers );
			MY_ASSERT( hr, S_GET_USERS_FAILED );

			//
			// make sure we got a sane amount of users
			//

			if ( SUCCEEDED( hr ) )
			{
				hr = dwUsers <= XONLINE_MAX_HD_ONLINE_USERS ? S_OK : E_INVALID_USER_COUNT; 
				MY_ASSERT( hr, S_INVALID_USER_COUNT );
			}
		}

		//
		// otherwise, get them from MU
		//

		else
		{
			hr = _XOnlineGetUserFromMU( dwPort, dwSlot, (PXONLINE_USER) pUsers );

			//
			// only 1 user on an MU
			//

			if ( SUCCEEDED( hr ) )
			{
				dwUsers = 1;
			}

			//
			// no users on the MU
			//

			else if ( XONLINE_E_NO_USER == hr )
			{
				hr = S_OK;
				dwUsers = 0;
			}
			
			//
			// otherwise, it's an errpr
			//

			else
			{
				MY_ASSERT( hr, S_GET_USERS_FAILED );
			}
		}
	}

	//
	// allocate the menu for each user
	//

	if ( SUCCEEDED( hr ) )
	{
		//
		// delete the user before allocating a new one
		//

		delete m_apDeviceMenus[dwDeviceIndex];

		m_apDeviceMenus[dwDeviceIndex] = new CDeviceMenu( MU_NAMES[dwDeviceIndex], 
			                                              FGColor(), 
														  BGColor(), 
														  ACCOUNT_SCREEN_X,
														  ACCOUNT_SCREEN_Y,
														  m_aapUserLists[dwDeviceIndex + 1], 
														  &m_pClipboardUser, 
														  &m_aText,
														  &m_xText,
														  &m_overwriteText,
														  &m_chUpdate );

		hr = m_apDeviceMenus[dwDeviceIndex] ? S_OK : E_MEMORY_ALLOCATION;
		MY_ASSERT( hr, S_MEMORY_ALLOCATION );
	}

	//
	// rebuild the menus
	//

	RebuildMenus();

	//
	// insert the users into the list
	//

	for ( DWORD i = 0; i < dwUsers && SUCCEEDED( hr ); i++ )
	{
		//
		// allocate 1 user
		//

		if ( SUCCEEDED( hr ) )
		{
			pUser = new XONLINEP_USER();
			hr = pUser ? S_OK : E_MEMORY_ALLOCATION;
			MY_ASSERT( hr, S_MEMORY_ALLOCATION );
		}

		//
		// copy the data out of the user array
		//

		if ( SUCCEEDED( hr ) )
		{
			CopyMemory( pUser, pUsers + i, sizeof( XONLINEP_USER ) );
		}

		//
		// insert the user into the list
		//

		if ( SUCCEEDED( hr ) )
		{
			//
			// 
			//

			m_aapUserLists[dwDeviceIndex+1][i] = pUser;

			//
			// create a copy of the name 
			//

			szName = new CHAR[XONLINE_USERNAME_SIZE + 2];

			//
			// make sure the name string was allocated
			//

			if ( NULL == szName )
			{
				hr = E_MEMORY_ALLOCATION;
				MY_ASSERT( hr, S_MEMORY_ALLOCATION );
			}

			//
			// make the name online friendly
			//

			if ( SUCCEEDED( hr ) )
			{
				sprintf( szName, "%s.%s", pUser->name, pUser->kingdom ); 

				m_apDeviceMenus[dwDeviceIndex]->AddItem( szName, NULL );
			}
		}
	}

	//
	// destroy the user array
	//

	delete [] pUsers;
	pUsers = NULL;

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Rebuild Menus
//
// Input: None
//
// Output: None
//
// Description: rebuilds the menus
//
///////////////////////////////////////////////////////////////////////////////

void
CAccountsScreen::RebuildMenus( void )
{
	//
	// save off the last active menu index
	//

	m_dwLastActive = ActiveMenuIndex();

	//
	// rebuild the list so menus are in correct order
	//

	RemoveMenus();

	//
	// add the ini menu back
	//

//	AddMenu( &m_iniMenu );

	//
	// add the hard disk and mus back
	//

	for ( DWORD dw = 0; dw < 5; dw++ )
	{
		//
		// menus are added like this to preserve letter order
		//

		if ( NULL != m_apDeviceMenus[dw] )
		{
			AddMenu( m_apDeviceMenus[dw] );
		}

		//
		// make sure we do not add the same menu twice
		//

		if ( NULL != m_apDeviceMenus[dw+4] && 0 != dw )
		{
			AddMenu( m_apDeviceMenus[dw+4] );
		}
	}

	//
	// make the last active menu the currently active menu after the
	// menu recreation
	//

	for ( DWORD i = 0; i < m_dwLastActive; i++ )
	{
		ScrollActiveMenuDown();
	}

	//
	// erase the clipboard
	//

	m_pClipboardUser = NULL;

	//
	// set the a text as select
	//

	m_aText.SetText( ACCOUNT_A_SELECT_TEXT );
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: PopulateDriveLists
//
// Input: None
//
// Output: S_OK if drive mounting completed without error
//
// Description: runs through each of the valid drives, mounts them, and
//              populates the cooresponding user list if possible
//
///////////////////////////////////////////////////////////////////////////////

HRESULT 
CAccountsScreen::PopulateDriveLists( void )
{
	HRESULT hr = S_OK;

	//
	// the drive letters of the valid drives where user data can live
	//

	static const CHAR chDrives[] = { 0, 
									 'F',
									 'G',
									 'H',
									 'I',
									 'J',
									 'K',
									 'L',
									 'M' };


	
	//
	// go through each drive, and populate it's list
	//

	for ( DWORD i = 0; i < NUM_DEVICE_MENUS && SUCCEEDED( hr ); i++ )
	{
		hr = PopulateDriveList( chDrives[i] );
//		MY_ASSERT( hr, S_POPULATE_DRIVE_LIST );
	}

	//
	// spit back the hr
	//

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: UpdateLists
//
// Input: None
//
// Output: S_OK if updating the lists succeeded, E_XXXX otherwise
//
// Description: checks for mu insertions / deletions and acts on them
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
CAccountsScreen::UpdateLists( void )
{	
	HRESULT hr = S_OK;
	DWORD dwInsertions = 0;
	DWORD dwRemovals = 0;
	DWORD dwError = 0;
	DWORD dwPort = 0;
	DWORD dwSlot = 0;
	DWORD dwMask = 1;

	CHAR chDrive = '\255';

	//
	// get the changed mu state
	//

	if ( XGetDeviceChanges( XDEVICE_TYPE_MEMORY_UNIT, &dwInsertions, &dwRemovals ) )
	{
		//
		// strip off useless bits
		//

		dwRemovals &= 0x000F000F;
		dwInsertions &= 0x000F000F;

		//
		// handle insertions / removals
		//

		for ( DWORD i = 0;
			  i < 8 && SUCCEEDED( hr );
			  i++,
			  dwRemovals >>= 1,
			  dwInsertions >>= 1 )
		{
			//
			// handle removals
			//

			if ( dwRemovals & 0x1 && !( m_dwBadMUs & ( 1 << i ) ) && SUCCEEDED( hr ) )
			{
				//
				// unmount the mu
				//

				dwError = XUnmountMU( dwPort, dwSlot );
				hr = ERROR_SUCCESS == dwError ? S_OK : E_MU_UNMOUNT;
			//	MY_ASSERT( hr, S_MU_UNMOUNT );

				if ( SUCCEEDED( hr ) )
				{

					//
					// clear out the flag
					//

					m_dwMUs &= ~( 1 << i );

					//
					// empty out the list
					//

					CleanupList( i + 2 );

					//
					// remove the mu from the menus
					//

					delete m_apDeviceMenus[i + 1];
					m_apDeviceMenus[i + 1] = NULL;

					//
					// rebuild the menus
					//

					RebuildMenus();
				}

			} 
			else if ( m_dwBadMUs & 0x1 )
			{
				m_dwBadMUs &= ~( 1 << i );
			}

			//
			// handle insertions
			//

			if ( dwInsertions & 0x1 && SUCCEEDED( hr ) )
			{
				//
				// decide what the drive letter should be
				//

				chDrive = (CHAR) ( ( dwPort << 1 ) | dwSlot ) + 'F';	

				//
				// update the drive list for that drive
				//

				hr = PopulateDriveList( chDrive );
			//	MY_ASSERT( hr, S_POPULATE_DRIVE_LIST );
			}
		
			//
			// goto the next mask
			//
			
			dwMask <<= 1; 

			//
			// goto the next port
			//

			dwPort++;

			//
			// reset values if after the 3rd mu
			//

			if ( 3 == i )
			{

				//
				// goto the next slot
				//

				dwSlot = ( dwSlot + 1 ) % 2;

				//
				// skip over unsed bits
				//

				dwRemovals >>= 12;
				dwInsertions >>= 12;

				//
				// reset port and slot values
				//

				dwPort = 0;
			}
		}		
	}

	//
	// spit back the hresult
	//

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: InitDevices
//
// Input: None
//
// Output: S_OK if device init succeeded, E_XXXX otherwise
//
// Description: initializes the devices
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
CAccountsScreen::InitDevices( void )
{
	HRESULT hr = S_OK;

	//
	// only do this the first time
	//

	if ( SUCCEEDED( hr ) && ! m_bInit )
	{
		SetText( NULL );

		//
		// Populate the drive list
		//

		hr = PopulateDriveLists();
//		MY_ASSERT( hr, S_POPULATE_DRIVE_LIST );	

		//
		// set state to initialized
		//

		m_bInit = TRUE;
		m_bJustEntered = FALSE;

	}

	//
	// spit back the hr
	//

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Update
//
// Input: pInput - a pointer to the user interface input class
//        pAudio - a pointer to the ui audio class
//
// Output: a pointer to the new screen. if this is null, the screen should
//         stay the same
//
// Description: initializes the devices
//
///////////////////////////////////////////////////////////////////////////////

CUserInterfaceScreen*
CAccountsScreen::Update( CUserInterfaceInput* pInput, CUserInterfaceAudio* pAudio )
{
	HRESULT hr = S_OK;
	CUserInterfaceScreen* pRet = NULL;

	//
	// make sure params are good
	//

	hr = pInput && pAudio ? S_OK : E_BAD_ARG;
	MY_ASSERT( hr, S_BAD_ARG );

	if ( ! pInput || ! pAudio )
	{
		return pRet;
	}

	//
	// init the devices
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = InitDevices();
//		MY_ASSERT( hr, S_INIT_DEVICES );
	}

	//
	// if we just entered the screen, update the lists
	//

	if ( SUCCEEDED( hr ) && TRUE == m_bJustEntered )
	{
		hr = PopulateDriveLists();
//		MY_ASSERT( hr, S_POPULATE_DRIVE_LIST );

		if ( FAILED( hr ) )
		{
			SetText( S_POPULATE_DRIVE_LIST );
		}

		m_bJustEntered = FALSE;
	}

	//
	// process the input
	//

	if ( SUCCEEDED( hr ) )
	{
		//
		// if left was pressed and there are multiple menus
		//

		if ( pInput->LeftPressed() && HasMultipleMenus() )
		{
			//
			// scroll up
			//

			ScrollActiveMenuUp();
			hr = pAudio->PlayMenuItem();
		}

		//
		// if right was pressed and there are multiple menus
		//

		else if ( pInput->RightPressed() && HasMultipleMenus() )
		{

			//
			// scroll down
			//

			ScrollActiveMenuDown();
			hr = pAudio->PlayMenuItem();
		}

		//
		// if b was pressed
		//

		else if ( pInput->BPressed() )
		{
			//
			// switch to the parent screen
			//

			pRet = ParentScreen();
			hr = pAudio->PlayBackButton();

			//
			// we should set up for regen of lists
			//

			m_bJustEntered = TRUE;
		}

		//
		// if there are menus on the screen and no text to display
		//

		else if ( ! NoActiveMenus() && ! GetText() )
		{
			//
			// let the active menu handle the input
			//

			pRet = ActiveMenu()->Update( pInput, pAudio );
		} 

		//
		// if a was pressed when text was written
		//

		else if ( GetText() && pInput->APressed() )
		{
			pRet = ParentScreen();
			hr = pAudio->PlayBackButton();
		}

		//
		// get a usabale string if audio playback failed
		//

		hr = SUCCEEDED( hr ) ? S_OK : E_AUDIO_PLAYBACK;

		if ( FAILED( hr ) )
		{
			SetText( S_AUDIO_PLAYBACK );
		}
	}

	//
	// update the screen text
	//

	if ( SUCCEEDED( hr ) )
	{
		//
		// activate the left and right arrows
		//

		m_leftText.Hide( FALSE );
		m_rightText.Hide( FALSE );

		//
		// if we are on the ONLY menu
		//

		if ( FirstActive() && LastActive() )
		{
			m_leftText.Hide( TRUE );
			m_rightText.Hide( TRUE );
		}

		//
		// if we are on the first menu
		//

		else if ( FirstActive() )
		{
			//
			// hide the left indicators
			//

		//	m_leftText.Hide( TRUE );

		}

		//
		// if we are on the last menu
		//

		else if ( LastActive() )
		{
			//
			// hide the right indicators
			//

		//	m_rightText.Hide( TRUE );
		}

		//
		// if there is only one menu
		//

		else if ( ! HasMultipleMenus() )
		{
			//
			// hide both
			//

			m_leftText.Hide( TRUE );
			m_rightText.Hide( TRUE );
		}

		if ( GetText() )
		{
			m_leftText.Hide( TRUE );
			m_rightText.Hide( TRUE );
			m_aText.Hide( TRUE );
		}
	}

	//
	// update the lists
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = UpdateLists();
	//	MY_ASSERT( hr, S_UPDATE_LISTS );

	//	if ( FAILED( hr ) )
	//	{
	//		SetText( S_UPDATE_LISTS );
	//	}
	}

	//
	// if one of the menus has changed state, update the menus
	//

	if ( SUCCEEDED( hr ) && '\255' != m_chUpdate )
	{
		hr = PopulateDriveList( m_chUpdate );
		hr = PopulateDriveLists();
	//	MY_ASSERT( hr, S_POPULATE_DRIVE_LIST );

	//	if ( FAILED( hr ) )
	//	{
	//		SetText( S_POPULATE_DRIVE_LIST );
	//	}

		m_chUpdate = '\255';
	}

	//
	// spit back the hr
	//

	return pRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\SetupOnline\AccountsScreen.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: AccountsScreen.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the Interface for the Account Manipulation Screen
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#include <xtl.h>
#include <xonlinep.h>
//#include <OnlineAccounts.h>
#include "myError.h"

#include "UserInterfaceScreen.h"
//#include "INIMenu.h"
#include "DeviceMenu.h"

//
// the number of menus in the screen
//

static const DWORD NUM_MENUS = 10;

//
// the number of device menus in the screen
//

static const DWORD NUM_DEVICE_MENUS = NUM_MENUS - 1;

//
// the name of the ini file menu
//

//static const LPSTR INI_NAME = "INI File";

//
// used to title the menu and report which device menu needs updating
//

static const LPSTR MU_NAMES[] = { "HARD DISK", 
								  "F: (Controller 1, Top Slot)",
								  "H: (Controller 2, Top Slot)",
								  "J: (Controller 3, Top Slot)",
								  "L: (Controller 4, Top Slot)",
								  "G: (Controller 1, Bottom Slot)",	
								  "I: (Controller 2, Bottom Slot)",
								  "K: (Controller 3, Bottom Slot)",
								  "M: (Controller 4, Bottom Slot)" };

//
// the account screen colors
//

static const DWORD ACCOUNT_SCREEN_FG_COLOR = 0xFFFFFFFF;
static const DWORD ACCOUNT_SCREEN_BG_COLOR = 0xFF000000;

//
// the x and y location of text
//

static const DWORD ACCOUNT_SCREEN_X = 320;
static const DWORD ACCOUNT_SCREEN_Y = 250;

//
// the value of an invalid device
//

static const CHAR INVALID_DEVICE_CHAR = '\255';

//
// the number of charecters on 1 line of an ini file
//

//static const DWORD INI_FILE_STRING_SIZE = 256;

//
// the location of the ini file
//

//static const LPSTR INI_FILE_LOCATION = "d:\\users.ini";

//
// the ini file format string
//

//	!#$%&'*+./=?^_`{|}~@-

//static const LPSTR INI_FORMAT_STRING = "%16I64x,%63[a-zA-Z0-9@._-],%16I64x%16I64x,%255[a-zA-Z0-9@._,-]";
//static const LPSTR INI_FORMAT_STRING = "%16I64x,%63[a-zA-Z0-9!#$%&'*+./=?^_`{|}~@-],%16I64x%16I64x,%255[a-zA-Z0-9,]";

//
// ui text stuff
//

static const DWORD ACCOUNT_A_X = 500;
static const DWORD ACCOUNT_A_Y = 400;
static const DWORD ACCOUNT_A_FG_COLOR = 0xFF00FF00;
static const DWORD ACCOUNT_A_BG_COLOR = 0xFF000000;

static const LPSTR ACCOUNT_X_TEXT = "(X) Delete User";
static const DWORD ACCOUNT_X_X = 320;
static const DWORD ACCOUNT_X_Y = 400;
static const DWORD ACCOUNT_X_FG_COLOR = 0xFF0000FF;
static const DWORD ACCOUNT_X_BG_COLOR = 0xFF000000;

static const LPSTR ACCOUNT_B_TEXT = "(B) Back";
static const DWORD ACCOUNT_B_X = 140;
static const DWORD ACCOUNT_B_Y = 400;
static const DWORD ACCOUNT_B_FG_COLOR = 0xFFFF0000;
static const DWORD ACCOUNT_B_BG_COLOR = 0xFF000000;

static const LPSTR ACCOUNT_LEFT_TEXT = "<<";
static const DWORD ACCOUNT_LEFT_X = 130;
static const DWORD ACCOUNT_LEFT_Y = 240;
static const DWORD ACCOUNT_LEFT_FG_COLOR = 0xFFFFFFFF;
static const DWORD ACCOUNT_LEFT_BG_COLOR = 0xFF000000;

static const LPSTR ACCOUNT_RIGHT_TEXT = ">>";
static const DWORD ACCOUNT_RIGHT_X = 500;
static const DWORD ACCOUNT_RIGHT_Y = 240;
static const DWORD ACCOUNT_RIGHT_FG_COLOR = 0xFFFFFFFF;
static const DWORD ACCOUNT_RIGHT_BG_COLOR = 0xFF000000;

static const LPSTR ACCOUNT_OVERWRITE_TEXT = "User Account On MU Will Be Overwritten";
static const DWORD ACCOUNT_OVERWRITE_X = 320;
static const DWORD ACCOUNT_OVERWRITE_Y = 320;
static const DWORD ACCOUNT_OVERWRITE_FG_COLOR = 0xFFFFFFFF;
static const DWORD ACCOUNT_OVERWRITE_BG_COLOR = 0xFF000000;

//
// the account screen class
//

class CAccountsScreen : public CUserInterfaceScreen {

public:

	//
	// constructor and descturctor
	//

	CAccountsScreen( CUserInterfaceScreen* pParent );

	~CAccountsScreen( void );

	//
	// overloaded update function
	//

	virtual CUserInterfaceScreen* Update( CUserInterfaceInput* pInput, 
		                                  CUserInterfaceAudio* pAudio );

private:

	//
	// helper function to init the mus
	//

	HRESULT InitDevices( void );

	//
	// helper code to parse the ini file
	//

//	HRESULT ParseIniFile( void );

	//
	// Helper code to manipulate the drive lists
	//

	HRESULT PopulateDriveList( CHAR chDrive );
	HRESULT PopulateDriveLists( void );

	//
	// MU handling
	//

	HRESULT UpdateLists( void );

	//
	// code to clean up the lists
	//

	void CleanupList( DWORD dwIndex );
	void CleanupLists( void );

	//
	// rebuild the menus
	//

	void RebuildMenus( void );

	//
	// the user lists for the ini file, the mounted MUs and the HD
	// these are indexed as follows:
	//
	// 0 - ini file
	// 1 - hard disk
	// 2 - controller 1, mu 1
	// 3 - controller 1, mu 2
	// 4 - controller 2, mu 1
	// 5 - controller 2, mu 2
	// 6 - controller 3, mu 1
	// 7 - controller 3, mu 2
	// 8 - controller 4, mu 1
	// 9 - controller 4, mu 2
	//

	PXONLINEP_USER m_aapUserLists[NUM_MENUS][XONLINE_MAX_STORED_ONLINE_USERS];

	//
	// the ui text
	//

	CUserInterfaceText m_bText;
	CUserInterfaceText m_xText;
	CUserInterfaceText m_leftText;
	CUserInterfaceText m_rightText;
	CUserInterfaceText m_aText;
	CUserInterfaceText m_overwriteText;

	//
	// the ini menu. it is differnet than a device because you can
	// not remove users from it
	//

//	CINIMenu m_iniMenu;

	//
	// the other menus. these are:
	//
	// 0 - the hard disk
	// 8 - F:
	// 7 - H:
	// 6 - J:
	// 5 - L:
	// 4 - G:
	// 3 - I:
	// 2 - K:
	// 1 - L:
	//

	CDeviceMenu* m_apDeviceMenus[NUM_DEVICE_MENUS];

	//
	// the bit mask of the mounted mus
	//
	// only the low 8 bits are used. these are (from right to left):
	//
	// bit 0 - F:
	// bit 1 - H:
	// bit 2 - J:
	// bit 3 - L:
	// bit 4 - G:
	// bit 5 - I:
	// bit 6 - K:
	// bit 7 - L:
	//

	DWORD m_dwMUs;

	//
	// a pointer to the online user currently selected on one of the menus
	// for copying / pasting to other menus
	//

	PXONLINEP_USER m_pClipboardUser;

	//
	// flag to guarentee init code only happnes once
	//

	BOOL m_bInit;

	//
	// an indicator that is used to decide of menus need to be updated
	//

	CHAR m_chUpdate;

	//
	// the index of the last active menu, used to decide what menu should
	// be displayed after an MU insertion/ removal
	//

	DWORD m_dwLastActive;

	//
	// check state to see if lists should be updated
	//

	BOOL m_bJustEntered;

	//
	// place to hold a list of bad MU's, so we don't unmount them
	//

	DWORD m_dwBadMUs;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\SetupOnline\CreationStateScreen.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: CreationStateScreen.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the Interface for the creation state screen
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#include <xtl.h>
#include "myError.h"
#include <xonlinep.h>
#include <OnlineAccounts.h>

#include "UserInterfaceScreen.h"
#include "AccountCreationScreen.h"
#include "PinEntryScreen.h"
#include "NameEntryScreen.h"

//
// the creation state screen colors
//

static const DWORD CREATION_STATE_SCREEN_FG_COLOR = 0xFFFFFFFF;
static const DWORD CREATION_STATE_SCREEN_BG_COLOR = 0xFF000000;

//
// the x and y location of text
//

static const DWORD CREATION_STATE_SCREEN_X = 320;
static const DWORD CREATION_STATE_SCREEN_Y = 250;

//
// the creation state enumeration
//

enum CREATION_STATE 
{
	START_STATE,
	NAME_ENTRY_STATE,
	PIN_ENTRY_STATE,
	USER_CREATION_STATE,
	DONE_STATE
};

//
// the creation state screen class
//

class CCreationStateScreen : public CUserInterfaceScreen {

public:

	//
	// constructor / destructor
	//

	CCreationStateScreen( CUserInterfaceScreen* pParent );

	~CCreationStateScreen( void );

	//
	// overloaded user input
	//

	virtual CUserInterfaceScreen* Update( CUserInterfaceInput* pInput, 
		                                  CUserInterfaceAudio* pAudio );

private:

	//
	// the current state
	//

	CREATION_STATE m_creationState;

	//
	// the pointer to the screens
	//

	CNameEntryScreen* m_pNameScreen;
	CPinEntryScreen* m_pPinScreen;
	CAccountCreationScreen* m_pCreationScreen;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\SetupOnline\DeviceMenu.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: DeviceMenu.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the Interface for the device menus
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#include <xtl.h>
#include <xonlinep.h>
#include "myError.h"

#include "UserInterfaceMenu.h"
#include "UserInterfaceText.h"

//
// the foreground and background colors for copying of a user
//

static const DWORD DEVICE_MENU_COPY_FG_COLOR = 0xFF00FF00;
static const DWORD DEVICE_MENU_COPY_BG_COLOR = 0xFF000000;

//
// the a text
//

static const LPSTR ACCOUNT_A_SELECT_TEXT = "(A) Select";
static const LPSTR ACCOUNT_A_UNSELECT_TEXT = "(A) Unselect";
static const LPSTR ACCOUNT_A_PASTE_TEXT = "(A) Paste";

//
// the title of the hard disk
//

static const LPSTR HARD_DISK_TITLE = "HARD DISK";

//
// the device menu class
//

class CDeviceMenu : public CUserInterfaceMenu {

public:

	//
	// constructor and descturctor
	//

	CDeviceMenu( LPSTR szTitle, 
		         DWORD dwFGColor, 
				 DWORD dwBGColor, 
				 DWORD dwTextX,
				 DWORD dwTextY,
				 PXONLINEP_USER* apUserList, 
				 PXONLINEP_USER* ppClipboardUser, 
				 CUserInterfaceText* pSelectUserText,
				 CUserInterfaceText* pEraseUserText,
				 CUserInterfaceText* pOverwriteText,
				 PCHAR pchUpdate );

	~CDeviceMenu( void );

	//
	// the overrided update function to process input
	//

	virtual CUserInterfaceScreen* Update( CUserInterfaceInput* pInput,
		                                  CUserInterfaceAudio* pAudio );

private:

	//
	// variable to hold if an item in the menu is selected
	// and also which one it is
	//

	DWORD m_dwSelected;

	//
	// the online user list for the device
	//

	PXONLINEP_USER* m_apUserList;

	//
	// the golbal clipboard user
	//

    PXONLINEP_USER* m_ppClipboardUser;

	//
	// the text for state handling
	//

	CUserInterfaceText* m_pSelectUserText;
	CUserInterfaceText* m_pEraseUserText;
	CUserInterfaceText* m_pOverwriteText;

	//
	// pointer used to notify the screen that a menu needs update
	//

	PCHAR m_pchUpdate;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\SetupOnline\DeviceMenu.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: DeviceMenu.cpp
//
// Author: Dan Rosenstein (danrose)
//
// Description: the implementation for device menus
//
///////////////////////////////////////////////////////////////////////////////

#include "DeviceMenu.h"

///////////////////////////////////////////////////////////////////////////////
//
// Name: Device Menu constructor
//
// Input: szTitle - the title of the device menu
//        dwFGColor - the foreground text color
//        dwBGColor - the background text color
//        dwTextX - the x location of the text
//        dwTextY - the y location of the text
//        apUserList - the list of users for this menu
//        ppClipboardUser - the user being copied from another menu
//        pSelectUserText - the a select text
//        pAddUserText - the a add text
//        pEraseUserText - the x erase text
//        pchUpdate - a pointer to the charecter used to tell the
//                    screen to update a menu
//
// Output: None
//
// Description: creates an instance of the device menu class
//
///////////////////////////////////////////////////////////////////////////////

CDeviceMenu::CDeviceMenu( LPSTR szTitle, 
						  DWORD dwFGColor, 
						  DWORD dwBGColor, 
						  DWORD dwTextX,
						  DWORD dwTextY,
						  PXONLINEP_USER* apUserList, 
						  PXONLINEP_USER* ppClipboardUser, 
						  CUserInterfaceText* pSelectUserText,
						  CUserInterfaceText* pEraseUserText,
						  CUserInterfaceText* pOverwriteText,
						  PCHAR pchUpdate )

	//
	// create the parent ui menu
	//

	: CUserInterfaceMenu( szTitle, 
	                      dwFGColor, 
						  dwBGColor, 
						  dwTextX, 
						  dwTextY ),

	  m_apUserList( apUserList ),
	  m_dwSelected( -1 ),
	  m_ppClipboardUser( ppClipboardUser ),
	  m_pSelectUserText( pSelectUserText ),
	  m_pEraseUserText( pEraseUserText ),
	  m_pOverwriteText( pOverwriteText ),
	  m_pchUpdate( pchUpdate )
{
	//
	// no code here
	//
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Device Menu destructor
//
// Input: None
//
// Output: None
//
// Description: destroys an instance of the device menu class
//
///////////////////////////////////////////////////////////////////////////////

CDeviceMenu::~CDeviceMenu( void )
{
	//
	// no code here
	//
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Update
//
// Input: pInput - the ui input class
//        pAudio - the ui audio class
//
// Output: a pointer to the next active screen
//
// Description: process the input for this menu
//
///////////////////////////////////////////////////////////////////////////////

CUserInterfaceScreen* 
CDeviceMenu::Update( CUserInterfaceInput* pInput, CUserInterfaceAudio* pAudio )
{
	HRESULT hr = S_OK;

	CUserInterfaceScreen* pRet = NULL;
	LPSTR szTitle = NULL;

	//
	// create an empty user to clear out the MU
	//

	XONLINE_USER emptyUser;
	ZeroMemory( &emptyUser, sizeof( XONLINE_USER ) );

	//
	// verify input pointers are good
	//

	hr = pInput && pAudio ? S_OK : E_BAD_ARG;
	MY_ASSERT( hr, S_BAD_ARG );

	if ( ! pInput || ! pAudio )
	{
		return pRet;
	}

	//
	// if up was pressed and there are multiple items
	//

	if ( pInput->UpPressed() && HasMultipleItems() )
	{
		//
		// scroll up an item
		//

		ScrollActiveItemUp();
		hr = pAudio->PlayMenuItem();
	}

	//
	// if down was pressed and there are multiple items
	//

	else if ( pInput->DownPressed() && HasMultipleItems() )
	{
		//
		// scroll down an item
		//

		ScrollActiveItemDown();
		hr = pAudio->PlayMenuItem();
	}

	//
	// if a was pressed
	//

	else if ( pInput->APressed() )
	{
		//
		// nothing on this menu is selected,
		// nothing on any menu is selected
		// and there are items on this menu
		//

		if ( -1 == m_dwSelected && 
			 NULL == *m_ppClipboardUser && 
			 NumItems() > 0 )
		{
			//
			// set the foreground and background colors
			// to the chosen color
			//

			SetFGColorActive( DEVICE_MENU_COPY_FG_COLOR );
			SetBGColorActive( DEVICE_MENU_COPY_BG_COLOR );

			//
			// mark the active one as chosen
			//

			m_dwSelected = ActiveItemIndex();

			//
			// set the screen's chosen user as the chosen one
			//

			*m_ppClipboardUser = m_apUserList[m_dwSelected];

			//
			// play audio
			// 

			hr = pAudio->PlaySelectButton();
		}

		//
		// nothing on this menu is selected,
		// but there is an item selected on another menu
		//

		else if ( -1 == m_dwSelected && *m_ppClipboardUser&& NumItems() < XONLINE_MAX_HD_ONLINE_USERS )
		{
			//
			// get the title of the device
			//

			szTitle = GetTitle();

			//
			// if this is the hard disk, then the drive we want is '\0'
			//

			if ( 0 == strcmp( HARD_DISK_TITLE, szTitle ) )
			{
				szTitle = "";

				//
				// add the clipboard user as the cached user to the HD
				//
				
				hr = _XOnlineAddUserToHD( (PXONLINE_USER) *m_ppClipboardUser );
			}
			else
			{
				//
				// add the clipboard user as the cached user to the MU
				//

				hr = _XOnlineSetUserInMU( *szTitle, (PXONLINE_USER) *m_ppClipboardUser );
			}

			//
			// verify the result
			//

			hr = SUCCEEDED( hr ) || E_OUTOFMEMORY == hr || NTE_EXISTS == hr ? S_OK : hr;
			MY_ASSERT( hr, S_ADD_CACHED_USER );

			//
			// remove the items from the menu
			//

			RemoveItems();

			//
			// notify the screen that there is a device update
			//

			*m_pchUpdate = *szTitle;

			//
			// erase the clipboard user
			//

			*m_ppClipboardUser = NULL;

			//
			// play the audio
			//

			hr = pAudio->PlaySelectButton();
		}

		//
		// the current item is selected
		//

		else if ( -1 != m_dwSelected && ActiveItemIndex() == m_dwSelected )
		{
			//
			// reset it to the menus default colors
			//

			SetFGColorActive( FGColor() );
			SetBGColorActive( BGColor() );

			//
			// cancel the copy user
			//

			*m_ppClipboardUser = NULL;

			//
			// reset the selected state
			//

			m_dwSelected = -1;

			//
			// play the audio
			//

			hr = pAudio->PlaySelectButton();
		}
	}

	//
	// x is pressed, the menu has items and the items do not 
	// point to screens
	//

	else if ( pInput->XPressed() && 
		      ! NoActiveItems() && 
			  ! ActiveItemHasScreen() )
	{
		//
		// no items are selected on the menu
		//

		if ( -1 == m_dwSelected )
		{
			//
			// select the current item
			//

			m_dwSelected = ActiveItemIndex();

			//
			// get hte title
			//

			szTitle = GetTitle();

			//
			// remove the current user from the device
			//

			if ( 0 == strcmp( HARD_DISK_TITLE, szTitle ) )
			{
				szTitle = "";

				//
				// remove the user from the hd
				//

				hr = _XOnlineRemoveUserFromHD( (PXONLINE_USER) m_apUserList[m_dwSelected] );
			}
			else
			{
				//
				// remove the user from the MU
				//

				hr = _XOnlineSetUserInMU( *szTitle, &emptyUser );
			}


			MY_ASSERT( hr, S_REMOVE_CACHED_USER );

			//
			// reset the user list
			//

			m_apUserList[m_dwSelected] = NULL;

			//
			// remove items from the list
			//

			RemoveItems();

			//
			// tell the screen to update the list
			//

			*m_pchUpdate = *szTitle;

			//
			// play the audio
			//

			hr = pAudio->PlaySelectButton();
		}
	}

	//
	// decide on text
	//

	if ( SUCCEEDED( hr ) )
	{

		//
		// hide the MU warning
		//

		m_pOverwriteText->Hide( TRUE );

		//
		// nothing in list, nothing on clipboard, nothing selected
		//

		if ( 0 == NumItems() && NULL == *m_ppClipboardUser && -1 == m_dwSelected )
		{
			m_pSelectUserText->Hide( TRUE );
		//	m_pAddUserText->Hide( TRUE );
			m_pEraseUserText->Hide( TRUE );
		}

		//
		// nothing in list, somethin on clipboard, nothing selected
		//

		if ( 0 == NumItems() && *m_ppClipboardUser && -1 == m_dwSelected )
		{
			m_pSelectUserText->SetText( ACCOUNT_A_PASTE_TEXT );
			m_pSelectUserText->Hide( FALSE );
		//	m_pAddUserText->Hide( FALSE );
			m_pEraseUserText->Hide( TRUE );
		}

		//
		// something in list, nothing on clipboard, nothing selected
		//

		if ( NumItems() > 0 && NULL == *m_ppClipboardUser && -1 == m_dwSelected )
		{
			m_pSelectUserText->SetText( ACCOUNT_A_SELECT_TEXT );
			m_pSelectUserText->Hide( FALSE );
		//	m_pAddUserText->Hide( TRUE );
			m_pEraseUserText->Hide( FALSE );
		}

		//
		// something in list, something on clipboard, something selected,
		// selected item is active
		//

		if ( NumItems() > 0 && *m_ppClipboardUser && ActiveItemIndex() == m_dwSelected )
		{
			m_pSelectUserText->SetText( ACCOUNT_A_UNSELECT_TEXT );
			m_pSelectUserText->Hide( FALSE );
		//	m_pAddUserText->Hide( TRUE );
			m_pEraseUserText->Hide( TRUE );
		}

		//
		// something in list, something on clipboard, something selected,
		// selected item is not active
		//

		if ( NumItems() > 0 && *m_ppClipboardUser && ActiveItemIndex() != m_dwSelected )
		{
			m_pSelectUserText->Hide( TRUE );
		//	m_pAddUserText->Hide( TRUE );
			m_pEraseUserText->Hide( TRUE );
		}

		//
		// something in list, something on clipboard, currently an MU selected
		//

		if ( NumItems() > 0 && *m_ppClipboardUser && 0 != strcmp( HARD_DISK_TITLE, GetTitle() ) ) 
		{
			m_pOverwriteText->Hide( FALSE );
		}

		//
		// something in list, something on clipboard, currently an mu is selected, selected
		// item is on current MU
		//

		if ( NumItems() > 0 && 
			 *m_ppClipboardUser && 
			 0 != strcmp( HARD_DISK_TITLE, GetTitle() ) &&
			 ActiveItemIndex() == m_dwSelected ) 
		{
			m_pOverwriteText->Hide( TRUE );
		}

		//
		// something in list, something on clipboard, nothing selected
		//

		if ( NumItems() > 0 && *m_ppClipboardUser && -1 == m_dwSelected )
		{
			if ( NumItems() < XONLINE_MAX_HD_ONLINE_USERS )
			{
				m_pSelectUserText->SetText( ACCOUNT_A_PASTE_TEXT );
				m_pSelectUserText->Hide( FALSE );
		//		m_pAddUserText->Hide( FALSE );
			}
			else
			{
				m_pSelectUserText->Hide( TRUE );
			//	m_pAddUserText->Hide( TRUE );
			}

			m_pEraseUserText->Hide( FALSE );
		}

	}

	//
	// get a usabale string if audio playback failed
	//

	hr = SUCCEEDED( hr ) ? S_OK : E_AUDIO_PLAYBACK;
	MY_ASSERT( hr, S_AUDIO_PLAYBACK );

	return pRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\SetupOnline\ExitScreen.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: ExitScreen.cpp
//
// Author: Dan Rosenstein (danrose)
//
// Description: the implementation for exit screen
//
///////////////////////////////////////////////////////////////////////////////

#include "ExitScreen.h"

///////////////////////////////////////////////////////////////////////////////
//
// Name:  exit screen constructor
//
// Input: pParent - the parent screen for this screen
//
// Output: None
//
// Description: creates an instance of the exit screen
//
///////////////////////////////////////////////////////////////////////////////

CExitScreen::CExitScreen( CUserInterfaceScreen* pParent )

	//
	// the parent of the ping screen
	//

	: CUserInterfaceScreen( pParent, 
	                        EXIT_SCREEN_FG_COLOR, 
							EXIT_SCREEN_BG_COLOR, 
							EXIT_SCREEN_X, 
							EXIT_SCREEN_Y )

{
	//
	// set the initial text
	//

	SetText( "" );
}

///////////////////////////////////////////////////////////////////////////////
//
// Name:  exit screen destructor
//
// Input: None
//
// Output: None
//
// Description: destroys an instance of the exit screen
//
///////////////////////////////////////////////////////////////////////////////

CExitScreen::~CExitScreen( void )
{
	//
	// No code here
	//
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Update
//
// Input: pInput - the input ui
//        pAudio - the audio ui
//
// Output: the next screen
//
// Description: process the input for the screen
//
///////////////////////////////////////////////////////////////////////////////

CUserInterfaceScreen* 
CExitScreen::Update( CUserInterfaceInput* pInput, CUserInterfaceAudio* pAudio )
{

	//
	// if update of this screen is called, reboot back
	//

	XLaunchNewImage( NULL, NULL );

	//
	// this really will never be reached
	//

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\SetupOnline\ExitScreen.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: Exit.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the Interface for the exit screen
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#include <xtl.h>
#include "myError.h"
#include <xonlinep.h>
#include <OnlineAccounts.h>

#include "UserInterfaceScreen.h"

//
// the ping screen colors
//

static const DWORD EXIT_SCREEN_FG_COLOR = 0xFFFFFFFF;
static const DWORD EXIT_SCREEN_BG_COLOR = 0xFF000000;

//
// the x and y location of text
//

static const DWORD EXIT_SCREEN_X = 320;
static const DWORD EXIT_SCREEN_Y = 250;

//
// the ping screen class
//

class CExitScreen : public CUserInterfaceScreen {

public:

	//
	// constructor / destructor
	//

	CExitScreen( CUserInterfaceScreen* pParent );

	~CExitScreen( void );

	//
	// overloaded user input
	//

	virtual CUserInterfaceScreen* Update( CUserInterfaceInput* pInput, 
		                                  CUserInterfaceAudio* pAudio );

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\SetupOnline\INIMenu.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: IniMenu.cpp
//
// Author: Dan Rosenstein (danrose)
//
// Description: the implementation for the ini menu
//
///////////////////////////////////////////////////////////////////////////////

#include "INIMenu.h"

///////////////////////////////////////////////////////////////////////////////
//
// Name: Ini Menu constructor
//
// Input: szTitle - the title of the device menu
//        dwFGColor - the foreground text color
//        dwBGColor - the background text color
//        dwTextX - the x location of the text
//        dwTextY - the y location of the text
//        apUserList - the list of users for this menu
//        ppClipboardUser - the user being copied from another menu
//        pSelectText - the text object used to display select text
//        pAddUserText - the text object used to display add user text
//        pEraseUserText - the text object used to display erase user text
//
// Output: None
//
// Description: creates an instance of the ini menu class
//
///////////////////////////////////////////////////////////////////////////////

CINIMenu::CINIMenu( LPSTR szTitle, 
				    DWORD dwFGColor, 
					DWORD dwBGColor, 
					DWORD dwTextX, 
					DWORD dwTextY, 
					PXONLINEP_USER* apUserList, 
					PXONLINEP_USER* ppClipboardUser,
					CUserInterfaceText* pSelectText,
					CUserInterfaceText* pAddUserText,
					CUserInterfaceText* pEraseUserText )

	//
	// create the parent menu
	//


  : CUserInterfaceMenu( szTitle, 
                        dwFGColor, 
						dwBGColor, 
						dwTextX, 
						dwTextY ),

	m_dwSelected( -1 ),
	m_apUserList( apUserList ),
	m_ppClipboardUser( ppClipboardUser ),
	m_pSelectText( pSelectText ),
	m_pAddUserText( pAddUserText ),
	m_pEraseUserText( pEraseUserText )
{
	//
	// no code here
	//
}


///////////////////////////////////////////////////////////////////////////////
//
// Name: Ini Menu constructor
//
// Input: None
//
// Output: None
//
// Description: destroys an instance of the ini menu class
//
///////////////////////////////////////////////////////////////////////////////

CINIMenu::~CINIMenu( void )
{
	//
	// no code here
	//
}


///////////////////////////////////////////////////////////////////////////////
//
// Name: Ini Menu constructor
//
// Input: pInput - a pointer to the ui input class
//        pAudio - a pointer to the ui audio class
//
// Output: the next screen to display
//
// Description: creates an instance of the ini menu class
//
///////////////////////////////////////////////////////////////////////////////

CUserInterfaceScreen* 
CINIMenu::Update( CUserInterfaceInput* pInput, CUserInterfaceAudio* pAudio )
{
	HRESULT hr = S_OK;

	CUserInterfaceScreen* pRet = NULL;

	//
	// verify input pointers are good
	//

	hr = pInput && pAudio ? S_OK : E_BAD_ARG;
	MY_ASSERT( hr, S_BAD_ARG );

	if ( ! pInput || ! pAudio )
	{
		return pRet;
	}

	//
	// act on input. if up was pressed and there are multiple
	// items in this menu
	//

	if ( pInput->UpPressed() && HasMultipleItems() )
	{
		//
		// scroll up to next item
		//

		ScrollActiveItemUp();
		hr = pAudio->PlayMenuItem();
	}

	//
	// down was pressed an there are multiple items
	//

	else if ( pInput->DownPressed() && HasMultipleItems() )
	{
		//
		// scroll down
		//

		ScrollActiveItemDown();
		hr = pAudio->PlayMenuItem();
	}
	
	//
	// process an a press
	//

	else if ( pInput->APressed() )
	{

		//
		// if nothing is selected on this or any menu
		//

		if ( -1 == m_dwSelected && NULL == *m_ppClipboardUser )
		{
			//
			// set the foregrond and background colors
			//

			SetFGColorActive( INI_MENU_COPY_FG_COLOR );
			SetBGColorActive( INI_MENU_COPY_BG_COLOR );

			//
			// set hte active menu item as highlited
			//

			m_dwSelected = ActiveItemIndex();

			//
			// set the clipboard user
			//

			*m_ppClipboardUser = m_apUserList[m_dwSelected];

			//
			// play the sound
			//

			hr = pAudio->PlaySelectButton();
		}

		//
		// if the current active selection is highlited
		//

		else if ( -1 != m_dwSelected && ActiveItemIndex() == m_dwSelected )
		{

			//
			// reset the font to the defualt for the menu
			//

			SetFGColorActive( FGColor() );
			SetBGColorActive( BGColor() );

			//
			// reest the clipbaord user
			//

			*m_ppClipboardUser = NULL;

			//
			// reset the highlited state
			//

			m_dwSelected = -1;

			//
			// play the audio
			//

			hr = pAudio->PlaySelectButton();
		}

	}

	//
	// decide on the rest of the text
	//

	if ( SUCCEEDED( hr ) )
	{

		//
		// erase the x text, add user text
		//

		m_pEraseUserText->Hide( TRUE );
		m_pAddUserText->Hide( TRUE );

		//
		// current active item is selected
		//

		if ( -1 != m_dwSelected && ActiveItemIndex() == m_dwSelected )
		{
			m_pSelectText->Hide( FALSE );
		}

		//
		// current active item is not selected
		//

		else if ( -1 != m_dwSelected )
		{
			m_pSelectText->Hide( TRUE );
		}
	}

	//
	// get a usabale string if audio playback failed
	//

	hr = SUCCEEDED( hr ) ? S_OK : E_AUDIO_PLAYBACK;
	MY_ASSERT( hr, S_AUDIO_PLAYBACK );

	return pRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\SetupOnline\INIMenu.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: INIMenu.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the Interface for the ini menu
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#include <xtl.h>
#include <xonlinep.h>
#include "myError.h"

#include "UserInterfaceMenu.h"
#include "UserInterfaceText.h"

//
// the foreground and background colors for copying of a user
//

static const DWORD INI_MENU_COPY_FG_COLOR = 0xFF00FF00;
static const DWORD INI_MENU_COPY_BG_COLOR = 0xFF000000;

//
// the ini menu class
//

class CINIMenu : public CUserInterfaceMenu {

public:

	//
	// constructor / destructor
	//

	CINIMenu( LPSTR szTitle, 
		      DWORD dwFGColor, 
			  DWORD dwBGColor, 
			  DWORD dwTextX,
			  DWORD dwTextY,
			  PXONLINEP_USER* apUserList, 
			  PXONLINEP_USER* ppClipboardUser,
			  CUserInterfaceText* pSelectText,
			  CUserInterfaceText* pAddUserText,
			  CUserInterfaceText* pEraseUserText );

	~CINIMenu( void );

	//
	// overloaded update input handler
	//

	virtual CUserInterfaceScreen* Update( CUserInterfaceInput* pInput, 
		                                  CUserInterfaceAudio* pAudio );

private:

	//
	// member to hold if an item is selected, and which it is
	//

	DWORD m_dwSelected;

	//
	// the user list for the ini menu
	//

	PXONLINEP_USER* m_apUserList;

	//
	// the global clipboard user
	//

    PXONLINEP_USER* m_ppClipboardUser;

	//
	// the a text
	//

	CUserInterfaceText* m_pSelectText;
	CUserInterfaceText* m_pAddUserText; 
	CUserInterfaceText* m_pEraseUserText;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\SetupOnline\MachineCreationScreen.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: MachineCreationScreen.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the Interface for the machine account creation screen
//
// Note: DEPRECATED
//
///////////////////////////////////////////////////////////////////////////////
#pragma once

#include <xtl.h>
#include "myError.h"
#include <xonlinep.h>

#include "UserInterfaceScreen.h"
#include "UserInterfaceText.h"

enum SCREEN_STATE {
	STATE_VERIFYING,
	STATE_PROMPTED,
	STATE_PRESSED,
	STATE_EXISTS,
	STATE_DONE,
	STATE_EXITED
};


//
// the machine creation class
//

class CMachineCreationScreen : public CUserInterfaceScreen {

public:

	//
	// constructor and destructor
	//

	CMachineCreationScreen( CUserInterfaceScreen* pParent, CUserInterfaceScreen* pChild );
	~CMachineCreationScreen( void );

	//
	// the update input method
	//

	virtual CUserInterfaceScreen* Update( CUserInterfaceInput* pInput, 
		                                  CUserInterfaceAudio* pAudio );

private:

	//
	// the child screen
	//

	CUserInterfaceScreen* m_pChildScreen;

	//
	// ui text
	//

	CUserInterfaceText m_aText;
	CUserInterfaceText m_bText;

	//
	// state variables
	//

	SCREEN_STATE m_state;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\SetupOnline\MachineCreationScreen.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: MachineCreationScreen.cpp
//
// Author: Dan Rosenstein (danrose)
//
// Description: the implementation for machine creation screen
//
// Note: DEPRECATED
//
///////////////////////////////////////////////////////////////////////////////

#include "MachineCreationScreen.h"
#include <OnlineAccounts.h>

///////////////////////////////////////////////////////////////////////////////
//
// Name: Machine account creation screen constructor
//
// Input: pChild - the child screen
//
// Output: None
//
// Description: creates an instance of the machine creation screen
//
///////////////////////////////////////////////////////////////////////////////

CMachineCreationScreen::CMachineCreationScreen( CUserInterfaceScreen* pParent, CUserInterfaceScreen* pChild )
  : CUserInterfaceScreen( pParent, 0xFFFFFFFF, 0xFF000000, 320, 250 ),
    m_aText( "(A) Action", 100, 400, 0xFF00FF00, 0xFF000000 ),
	m_bText( "(B) Back", 520, 400, 0xFFFF0000, 0xFF000000 ),
    m_pChildScreen( pChild ),
	m_state( STATE_VERIFYING )
{
	//
	// set the text
	//

	SetText( "Machine Account Already Exists" );

	//
	// add the ui text
	//

	AddUIText( &m_aText );
	AddUIText( &m_bText );
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Machine account creation screen destructor
//
// Input: pChildScreen - the child of this screen
//
// Output: None
//
// Description: destroys an instance of the machine creation screen
//
///////////////////////////////////////////////////////////////////////////////

CMachineCreationScreen::~CMachineCreationScreen( void )
{
	//
	// no code here
	//
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Update
//
// Input: pInput - the ui input class
//        pAudio - the ui audio class
//
// Output: the screen to goto
//
// Description: process input
//
///////////////////////////////////////////////////////////////////////////////

CUserInterfaceScreen* 
CMachineCreationScreen::Update( CUserInterfaceInput* pInput, 
		                        CUserInterfaceAudio* pAudio )
{
	//
	// Setup error codes
	//

	HRESULT	hr = S_OK;
	DWORD dwRet = ERROR_SUCCESS;
	BOOL bHasMachineAccount = TRUE;

	//
	// Check to see if the xbox has a machine account
	//

	if ( ! bHasMachineAccount && STATE_VERIFYING == m_state || 
		 ! bHasMachineAccount && STATE_EXITED == m_state )
	{
		SetText( "Press A to create a new machine account" );
		m_state = STATE_PROMPTED;
	}
	else if ( STATE_EXITED == m_state )
	{
		SetText( "Machine Account Already Exists" );
		m_state = STATE_EXITED;
	}
	else if ( STATE_VERIFYING == m_state )
	{
		m_state = STATE_EXISTS;
	}

	//
	// check if a is pressed
	//

	if ( pInput->APressed() && STATE_PROMPTED == m_state )
	{
		//
		// update the text
		//

		SetText( "Creating machine account..." );
		m_state = STATE_PRESSED;
	}

	//
	// and on next update actualy submit the machine account creation
	//

	else if ( STATE_PRESSED == m_state )
	{

		//
		// populate the EEPROM
		// (Faking the manufacturing process)
		//

		hr = WriteEEPROMDevkitData();
		hr = SUCCEEDED( hr ) ? S_OK : E_WRITE_EEPROM_DATA;
		MY_ASSERT( hr, S_WRITE_EEPROM_DATA );

		//
		// set text as appropriate
		//

		if ( SUCCEEDED( hr ) )
		{
			SetText( "Machine account Created. Press A to continue." );
			m_state = STATE_DONE;
		}
		else
		{
			SetText( "Machine account creation failed" );
			m_state = STATE_DONE;
		}
	}

	else if ( pInput->BPressed() || ( pInput->APressed() && STATE_EXITED == m_state ) )
	{
		m_state = STATE_EXITED;
		return ParentScreen();
	}

	//
	// if we are done, goto the child screen
	//

	else if ( pInput->APressed() && STATE_DONE == m_state || STATE_EXISTS == m_state )
	{
		m_state = STATE_EXITED;
		return m_pChildScreen;
	}

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\SetupOnline\myError.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: myError.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: error and assertion functions
//
///////////////////////////////////////////////////////////////////////////////
#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <stdio.h>

//
// nt error stuff
//

typedef LONG NTSTATUS;
typedef NTSTATUS *PNTSTATUS;

//
// the error codes
//

enum ERROR_CODES {
	E_BASE = 0xF0000000,
	E_BAD_ARG,
	E_PARSE_INI_FILE,
	E_OPEN_INI_FILE,
    E_CLOSE_INI_FILE,
    E_INI_BAD_DATA,
	E_MU_UNMOUNT,
	E_MU_MOUNT,
	E_MEMORY_ALLOCATION,
	E_INVALID_USER_COUNT,
	E_AUDIO_PLAYBACK,
	E_PASSWORD_TO_KEY,
	E_UPDATE_CONFIG_SECTOR,
	E_UPDATE_EEPROM_SN,
	E_UPDATE_EEPROM_KEY,
	E_WRITE_EEPROM_DATA,
	E_CREATE_MACHINE_ACCOUNT,
	E_LOGON_FAIL
};

//
// the error strings
//

#define S_GENERAL_ERROR "General error" 
#define S_BAD_ARG "Bad Argument" 
#define S_PARSE_INI_FILE "Please copy users.ini to xe:\\Tools\\SetupOnline" 
#define S_OPEN_INI_FILE "Could not open users.ini file" 
#define S_CLOSE_INI_FILE "Could not close users.ini file" 
#define S_INI_BAD_DATA "Malformed data in users.ini file" 
#define S_MU_UNMOUNT "Could not unmount mu" 
#define S_MU_MOUNT "Could not mount mu" 
#define S_MEMORY_ALLOCATION "Could not allocate memory" 
#define S_INVALID_USER_COUNT "An invalid user count was returned" 
#define S_AUDIO_PLAYBACK "Audio file could not be played" 
#define S_PASSWORD_TO_KEY "Could not convert password to key" 
#define S_UPDATE_CONFIG_SECTOR "Could not update config sector" 
#define S_UPDATE_EEPROM_SN "Could not update EEPROM with SN" 
#define S_UPDATE_EEPROM_KEY "Could not update EEPROM with Key" 
#define S_WRITE_EEPROM_DATA "Could not write EEPROM data" 
#define S_CREATE_MACHINE_ACCOUNT "Could not create machine account" 
#define S_LOGON_FAIL "Logon to PartnerNet failed" 

#define S_REMOVE_MACHINE_ACCOUNT "Could not remove machine account" 
#define S_GET_USERS_FAILED "Could not get users" 
#define S_POPULATE_DRIVE_LIST "Could not populate the drive menu" 
#define S_INIT_DEVICES "Could not init devices" 
#define S_UPDATE_LISTS "Could not update menus" 
#define S_ADD_CACHED_USER "Could not add user" 
#define S_REMOVE_CACHED_USER "Could not remove user" 

//#define MY_ASSERT( hr, str )
#define MY_ASSERT( hr, str ) ASSERT( SUCCEEDED( hr ) || ! str )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\SetupOnline\NameEntryScreen.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: NameEntryScreen.cpp
//
// Author: Dan Rosenstein (danrose)
//
// Description: the implementation for Name Entry screen
//
///////////////////////////////////////////////////////////////////////////////

#include "NameEntryScreen.h"

///////////////////////////////////////////////////////////////////////////////
//
// Name:  Name Entry screen constructor
//
// Input: pParent - the parent screen for this screen
//
// Output: None
//
// Description: creates an instance of the Name Entry screen
//
///////////////////////////////////////////////////////////////////////////////

CNameEntryScreen::CNameEntryScreen( CUserInterfaceScreen* pParent )

	//
	// the parent of the Name Entry screen
	//

	: CUserInterfaceScreen( pParent, 
	                        NAME_ENTRY_SCREEN_FG_COLOR, 
							NAME_ENTRY_SCREEN_BG_COLOR, 
							NAME_ENTRY_SCREEN_X, 
							NAME_ENTRY_SCREEN_Y ),

	//
	// the text
	//

	  m_aText( NAME_ENTRY_A_TEXT, NAME_ENTRY_A_X, NAME_ENTRY_A_Y, NAME_ENTRY_A_FG_COLOR, NAME_ENTRY_A_BG_COLOR ),
      m_bText( NAME_ENTRY_B_TEXT, NAME_ENTRY_B_X, NAME_ENTRY_B_Y, NAME_ENTRY_B_FG_COLOR, NAME_ENTRY_B_BG_COLOR ),
      m_nameText( "", NAME_X, NAME_Y, NAME_FG_COLOR, NAME_BG_COLOR ),

    //
	// start the row and index on ok
	//

	  m_dwRowIndex( 0 ),
	  m_dwColIndex( NUM_COLS - 1 ),

	//
	// start the string index at the first char
	//

	  m_dwStrIndex( 0 ),

	//
	// start off in an update necessary state
	//

	  m_bUpdate( TRUE ),

	//
	// init to false
	//

	  m_bInit( FALSE )

{
	ZeroMemory( m_szName, sizeof( m_szName ) );

	//
	// needs to have some kind of text
	//

	SetText( NAME_ENTRY_TITLE );

	//
	// add the ui text
	//

	AddUIText( &m_aText );
	AddUIText( &m_bText );
	AddUIText( &m_nameText );

	//
	// create the keys
	//

	for ( DWORD dwRow = 0; dwRow < NUM_ROWS; dwRow++ )
	{
		for ( DWORD dwCol = 0; dwCol < NUM_COLS; dwCol++ )
		{
			//
			// calculate the x and y location on the fly for the keys
			//

			m_pKeys[dwRow][dwCol] = new CUserInterfaceText( KEYBOARD_STRINGS[dwRow][dwCol],
				                                            KEY_X + dwCol * HORI_DIST,
															KEY_Y + dwRow * VERT_DIST,
															KEY_FG_COLOR,
															KEY_BG_COLOR );

			//
			// this should never fail
			//

			ASSERT( m_pKeys[dwRow][dwCol] );

			//
			// add the key to the screen
			//

			AddUIText( m_pKeys[dwRow][dwCol] );
		}
	}
}

///////////////////////////////////////////////////////////////////////////////
//
// Name:  Name Entry screen destructor
//
// Input: None
//
// Output: None
//
// Description: destroys an instance of the Name Entry screen
//
///////////////////////////////////////////////////////////////////////////////

CNameEntryScreen::~CNameEntryScreen( void )
{
	for ( DWORD dwRow = 0; dwRow < NUM_ROWS; dwRow++ )
	{
		for ( DWORD dwCol = 0; dwCol < NUM_COLS; dwCol++ )
		{
			delete m_pKeys[dwRow][dwCol];
		}
	}
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Update
//
// Input: pInput - the input ui
//        pAudio - the audio ui
//
// Output: the next screen
//
// Description: process the input for the screen
//
///////////////////////////////////////////////////////////////////////////////

CUserInterfaceScreen* 
CNameEntryScreen::Update( CUserInterfaceInput* pInput, CUserInterfaceAudio* pAudio )
{
	CUserInterfaceScreen* pRet = NULL;
	LPSTR szText = m_pKeys[m_dwRowIndex][m_dwColIndex]->Text();

	//
	// leave screen on b
	//

	if ( pInput->BPressed() )
	{
		pRet = ParentScreen()->Update( pInput, pAudio );
	}

	//
	// if a is pressed, handle it and decide what action to do
	//

	if ( pInput->APressed() )
	{
		//
		// on cancel, go to parent screen
		//

		if ( 0 == strcmp( KEY_CANCEL, szText ) )
		{
			pRet = ParentScreen()->Update( NULL, pAudio );
		}

		//
		// on ok ,goto parent screen
		//

		else if ( 0 == strcmp( KEY_OK, szText ) )
		{
			pRet = ParentScreen()->Update( pInput, pAudio );
		}

		//
		// on back, erase a letter
		//

		else if ( 0 == strcmp( KEY_BACK, szText ) && 0 != m_dwStrIndex )
		{
			m_szName[--m_dwStrIndex] = '\0';
			pAudio->PlayBackButton();
		}

		//
		// on a letter, add it
		//

		else if ( 0 != strcmp( KEY_BACK, szText ) && m_dwStrIndex < XONLINE_MAX_NAME_LENGTH )
		{
			m_szName[m_dwStrIndex++] = *szText;

			pAudio->PlaySelectButton();
		}

		m_nameText.SetText( m_szName );
	}

	//
	// move around the grid
	//

	else if ( pInput->DownPressed() )
	{
		m_dwRowIndex = ++m_dwRowIndex % NUM_ROWS;
		m_bUpdate = TRUE;
	}

	else if ( pInput->UpPressed() )
	{
		m_dwRowIndex = --m_dwRowIndex % NUM_ROWS;
		m_bUpdate = TRUE;
	}

	else if ( pInput->LeftPressed() )
	{
	//	m_dwColIndex = --m_dwColIndex % NUM_COLS;

		if ( 0xFFFFFFFF == --m_dwColIndex )
			m_dwColIndex = NUM_COLS - 1;

		m_bUpdate = TRUE;
	}

	else if ( pInput->RightPressed() )
	{
		m_dwColIndex = ++m_dwColIndex % NUM_COLS;
		m_bUpdate = TRUE;
	}

	//
	// reverse the color on the highlited letter, make the rest normal
	//

	if ( TRUE == m_bUpdate )
	{
		for ( DWORD dwRow = 0; dwRow < NUM_ROWS; dwRow++ )
		{
			for ( DWORD dwCol = 0; dwCol < NUM_COLS; dwCol++ )
			{
				if ( m_dwRowIndex == dwRow && m_dwColIndex == dwCol )
				{
					m_pKeys[dwRow][dwCol]->SetFGColor( BGColor() );
					m_pKeys[dwRow][dwCol]->SetBGColor( FGColor() );
				}
				else
				{
					m_pKeys[dwRow][dwCol]->SetFGColor( FGColor() );
					m_pKeys[dwRow][dwCol]->SetBGColor( BGColor() );			
				}
			}
		}

		m_bUpdate = FALSE;

		//
		// only play the sound if we moved
		//

		if ( TRUE == m_bInit )
		{
			pAudio->PlayKeyboardStroke();
		}
		else
		{	
			m_bInit = TRUE;
		}
	}

	return pRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\SetupOnline\MachineRemovalScreen.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: MachineRemovalScreen.cpp
//
// Author: Dan Rosenstein (danrose)
//
// Description: the implementation machine removal screen
//
///////////////////////////////////////////////////////////////////////////////

#include "MachineRemovalScreen.h"
#include <OnlineAccounts.h>

///////////////////////////////////////////////////////////////////////////////
//
// Name: Machine account removal screen constructor
//
// Input: pParent - the parent screen for this screen
//
// Output: None
//
// Description: creates an instance of the machine removal screen
//
///////////////////////////////////////////////////////////////////////////////

CMachineRemovalScreen::CMachineRemovalScreen( CUserInterfaceScreen* pParent )
	
	//
	// create the parent screen
	//

	: CUserInterfaceScreen( pParent, 
	                        MACHINE_ACCOUNT_SCREEN_FG_COLOR, 
							MACHINE_ACCOUNT_SCREEN_BG_COLOR, 
							MACHINE_ACCOUNT_SCREEN_X, 
							MACHINE_ACCOUNT_SCREEN_Y ),

	  //
	  // the text
	  //

	  m_aText( MACHINE_A_TEXT, 
	           MACHINE_A_X, 
			   MACHINE_A_Y, 
			   MACHINE_A_FG_COLOR, 
			   MACHINE_A_BG_COLOR ),

      m_bText( MACHINE_B_TEXT, 
	           MACHINE_B_X, 
			   MACHINE_B_Y, 
			   MACHINE_B_FG_COLOR, 
			   MACHINE_B_BG_COLOR ),

	  //
	  // set completion to false
	  //

	  m_bComplete( FALSE )
{
	//
	// set the text of the screen
	//

	SetText( CREATION_PROMPT_STRING );

	//
	// add the ui text
	//

	AddUIText( &m_aText );
	AddUIText( &m_bText );
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Machine account removal screen destructor
//
// Input: None
//
// Output: None
//
// Description: destroys an instance of the machine removal screen
//
///////////////////////////////////////////////////////////////////////////////

CMachineRemovalScreen::~CMachineRemovalScreen( void )
{
	//
	// no code here
	//
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Update
//
// Input: pInput - the ui input
//        pAudio - the ui audio
//
// Output: the next screen to display
//
// Description: processes input for the screen
//
///////////////////////////////////////////////////////////////////////////////

CUserInterfaceScreen*
CMachineRemovalScreen::Update( CUserInterfaceInput* pInput, CUserInterfaceAudio* pAudio )
{
	HRESULT hr = S_OK;
	CUserInterfaceScreen* pRet = NULL;

	//
	// verify input pointers are good
	//

	hr = pInput && pAudio ? S_OK : E_BAD_ARG;
	MY_ASSERT( hr, S_BAD_ARG );

	if ( ! pInput || ! pAudio )
	{
		return pRet;
	}

	//
	// if b was pressed, or if a is pressed and we are done
	//

	if ( pInput->BPressed() || ( pInput->APressed() && m_bComplete ) )
	{
		//
		// reset the state
		//

		m_bComplete = FALSE;

		//
		// reset the text
		//

		SetText( CREATION_PROMPT_STRING );

		//
		// goto the parent screen
		//

		pRet = ParentScreen();
		hr = pAudio->PlayBackButton();
	}

	//
	// if a was pressed and not done erasing the machine account
	//

	else if ( pInput->APressed() && ! m_bComplete )
	{

		//
		// remove the account
		//

		hr = RemoveMachineAccount();
		MY_ASSERT( hr, S_REMOVE_MACHINE_ACCOUNT );

		//
		// update screen text
		//

		if ( SUCCEEDED( hr ) )
		{
			//
			// display completion string
			//

			SetText( COMPLETION_PROMPT_STRING );
			hr = pAudio->PlaySelectButton();
		}
		else
		{

			//
			// display error string
			//

			SetText( S_REMOVE_MACHINE_ACCOUNT );
			hr = pAudio->PlayBackButton();
		}

		//
		// we are completed
		//

		m_bComplete = TRUE;
	}

	//
	// get a usabale string if audio playback failed
	//

	hr = SUCCEEDED( hr ) ? S_OK : E_AUDIO_PLAYBACK;
	MY_ASSERT( hr, S_AUDIO_PLAYBACK );

	if ( FAILED( hr ) )
	{
		SetText( S_AUDIO_PLAYBACK );
	}

	return pRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\SetupOnline\main.cpp ===
#include <xtl.h>
#include <xdbg.h>
#include "UserInterface.h"
#include "UserInterfaceScreen.h"
#include "UserInterfaceMenu.h"
#include "UserInterfaceText.h"
#include "PingScreen.h"
#include "AccountsScreen.h"
#include "CreationStateScreen.h"
#include "ExitScreen.h"

///////////////////////////////////////////////////////////////////////////////
//
// Name: main
//
// Input: None
//
// Output: None
//
// Description: the real work horse. set up the UI, Renders the UI, 
//              gets input for the UI, and updates the UI
//
///////////////////////////////////////////////////////////////////////////////

void __cdecl main( void )
{
	HRESULT	hr = S_OK;
	int iRet = 0;

	WSADATA wsaData;
	XNetStartupParams xnsp;

	XNADDR xnaddr;
	DWORD dwResult = 0L;

	//
	// zero out the winsock data
	//

	ZeroMemory( &wsaData, sizeof( WSADATA ) );
	ZeroMemory( &xnsp, sizeof( XNetStartupParams ) );

	//
	// Setup net stack
	//

	if ( SUCCEEDED( hr ) )
	{
		//
		// we want to disable secure communication
		//

		xnsp.cfgSizeOfStruct = sizeof( XNetStartupParams );
		xnsp.cfgFlags = XNET_STARTUP_BYPASS_SECURITY;

		hr = XNetStartup( &xnsp );
		ASSERT( SUCCEEDED( hr ) || !"Could not start up network" );
	}

	//
	// wait for DNS to succeed
	//
 
	do
	{
		dwResult = XNetGetTitleXnAddr ( &xnaddr );  
	} 
	while ( XNET_GET_XNADDR_PENDING == dwResult );

	//
	// setup online
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = XOnlineStartup( NULL );
		ASSERT( SUCCEEDED( hr ) || !"Could not startup online" );
	}

	//
	// create the screens
	//

	CUserInterfaceScreen mainScreen( NULL, 
		                             0xFFFFFFFF, 
									 0x00000000, 
									 320, 
									 250 );

	CPingScreen pingScreen( &mainScreen );
	CAccountsScreen accountsScreen( &mainScreen );
	CCreationStateScreen creationStateScreen( &mainScreen );
	CExitScreen exitScreen( &mainScreen );

	//
	// create the menus
	//

	CUserInterfaceMenu mainMenu( NULL, 0xFFFFFFFF, 0x00000000, 320, 250 );

	//
	// create the text
	//

	CUserInterfaceText aText( "(A) Select", 500, 400, 0xFF00FF00, 0xFF000000 );

	//
	// add items to the menus
	//

	mainMenu.AddItem( "Ping PartnerNet", &pingScreen );
	mainMenu.AddItem( "Create User Accounts", &creationStateScreen );
	mainMenu.AddItem( "Manage User Accounts", &accountsScreen );
	mainMenu.AddItem( "Exit SetupOnline", &exitScreen );

	//
	// add menus to screens
	//

	mainScreen.AddMenu( &mainMenu );

	//
	// add ui text ot screens
	//

	mainScreen.AddUIText( &aText );

	//
	// Setup the UI
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = CUserInterface::Instance()->Initialize( &mainScreen,
													 640, 
													 480, 
													 0,
													 "d:\\media\\images\\back.bmp" );

		ASSERT( SUCCEEDED( hr ) || !"Could not setup user interface" );
	}

	//
	// Begin the app loop
	//

	while ( SUCCEEDED( hr ) )
	{
		//
		// Update the scene
		//

		hr = CUserInterface::Instance()->Update();
		ASSERT( SUCCEEDED( hr ) || !"Could not update the scene" );
	}

	//
	// Clean up the net stack
	//

	hr = XNetCleanup();
	ASSERT( SUCCEEDED( hr ) || !"Could not release network" );

	hr = XOnlineCleanup();
	ASSERT( SUCCEEDED( hr ) || !"Could not release online" );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\SetupOnline\PinEntryScreen.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: PinEntryScreen.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the Interface for the Pin Entry screen
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#include <xtl.h>
#include "myError.h"
#include <xonlinep.h>
#include <OnlineAccounts.h>

#include "UserInterfaceScreen.h"

//
// the text
// 

static const LPSTR PIN_ENTRY_TITLE = "Please Input New PIN";
static const LPSTR PIN_ENTRY_A_TEXT = "(A) Select";
static const LPSTR PIN_ENTRY_B_BACK_TEXT = "(B) Back";
static const LPSTR PIN_ENTRY_B_ERASE_TEXT = "(B) Erase";

//
// the pin entry screen colors
//

static const DWORD PIN_ENTRY_SCREEN_FG_COLOR = 0xFFFFFFFF;
static const DWORD PIN_ENTRY_SCREEN_BG_COLOR = 0xFF000000;

//
// the x and y location of text
//

static const DWORD PIN_ENTRY_SCREEN_X = 320;
static const DWORD PIN_ENTRY_SCREEN_Y = 140;

static const DWORD PIN_ENTRY_A_X = 500;
static const DWORD PIN_ENTRY_A_Y = 400;
static const DWORD PIN_ENTRY_B_X = 140;
static const DWORD PIN_ENTRY_B_Y = 400;

static const DWORD PIN_X = 320;
static const DWORD PIN_Y = 200;

//
// the fg/ bg color
//

static const DWORD PIN_ENTRY_A_FG_COLOR = 0xFF00FF00;
static const DWORD PIN_ENTRY_A_BG_COLOR = 0xFF000000;
static const DWORD PIN_ENTRY_B_FG_COLOR = 0xFFFF0000;
static const DWORD PIN_ENTRY_B_BG_COLOR = 0xFF000000;

static const DWORD PIN_FG_COLOR = 0xFFFFFFFF;
static const DWORD PIN_BG_COLOR = 0xFF000000;

//
// the pin entry screen class
//

class CPinEntryScreen : public CUserInterfaceScreen {

public:

	//
	// constructor / destructor
	//

	CPinEntryScreen( CUserInterfaceScreen* pParent );

	~CPinEntryScreen( void );

	//
	// overloaded user input
	//

	virtual CUserInterfaceScreen* Update( CUserInterfaceInput* pInput, 
		                                  CUserInterfaceAudio* pAudio );

	//
	// get the PIN
	//

	LPBYTE GetPin( void ) { return m_aPINByte; };

private:

	//
	// init function
	//

	HRESULT Init( void );

	//
	// update the text
	//

	HRESULT UpdateText( void );

	//
	// ui text
	//

	CUserInterfaceText m_aText;
	CUserInterfaceText m_bText;
	CUserInterfaceText m_pinText;

	//
	// the hnadle use for pin input
	//

	XPININPUTHANDLE m_handle;

	//
	// the input state
	//

    XINPUT_STATE m_inputState;

	//
	// the actual pin
	//

    BYTE m_aPINByte[4];

	//
	// the string
	//

	CHAR m_szStr[64];

	//
	// the current char index
	//

	DWORD m_dwCurIndex;

	//
	// init flag
	//

	BOOL m_bInit;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\SetupOnline\NameEntryScreen.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: NameEntryScreen.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the Interface for the Name Entry screen
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#include <xtl.h>
#include "myError.h"
#include <xonlinep.h>
#include <OnlineAccounts.h>

#include "UserInterfaceScreen.h"

//
// the text
// 

static const LPSTR NAME_ENTRY_TITLE = "Please Enter User Name";
static const LPSTR NAME_ENTRY_A_TEXT = "(A) Select";
static const LPSTR NAME_ENTRY_B_TEXT = "(B) Back";

//
// the Name Entry screen colors
//

static const DWORD NAME_ENTRY_SCREEN_FG_COLOR = 0xFFFFFFFF;
static const DWORD NAME_ENTRY_SCREEN_BG_COLOR = 0xFF000000;

//
// the x and y location of text
//

static const DWORD NAME_ENTRY_SCREEN_X = 320;
static const DWORD NAME_ENTRY_SCREEN_Y = 140;

static const DWORD NAME_ENTRY_A_X = 500;
static const DWORD NAME_ENTRY_A_Y = 400;
static const DWORD NAME_ENTRY_B_X = 140;
static const DWORD NAME_ENTRY_B_Y = 400;

static const DWORD KEY_X = 130;
static const DWORD KEY_Y = 220;

static const DWORD NAME_X = 320;
static const DWORD NAME_Y = 170;

//
// the fg/ bg color
//

static const DWORD NAME_ENTRY_A_FG_COLOR = 0xFF00FF00;
static const DWORD NAME_ENTRY_A_BG_COLOR = 0xFF000000;
static const DWORD NAME_ENTRY_B_FG_COLOR = 0xFFFF0000;
static const DWORD NAME_ENTRY_B_BG_COLOR = 0xFF000000;

static const DWORD KEY_FG_COLOR = 0xFFFFFFFF;
static const DWORD KEY_BG_COLOR = 0xFF000000;

static const DWORD NAME_FG_COLOR = 0xFFFFFFFF;
static const DWORD NAME_BG_COLOR = 0xFF000000;

//
// the number of rows and columns in the keyboard
//

static const DWORD NUM_ROWS = 4;
static const DWORD NUM_COLS = 10;

//
// the vert and horizontal distance for keys
//

static const DWORD HORI_DIST = 40;
static const DWORD VERT_DIST = 40;

//
// the special keys
//

static const LPSTR KEY_OK = "ok";
static const LPSTR KEY_CANCEL = "cancel";
static const LPSTR KEY_BACK = "<<";

//
// the array of strings
//

static const LPSTR KEYBOARD_STRINGS[NUM_ROWS][NUM_COLS] = 
{
	{ "0", "1", "2", "3", "4", "5", "6", "7", "8", KEY_OK     },
	{ "9", "a", "b", "c", "d", "e", "f", "g", "h", KEY_CANCEL },
	{ "i", "j", "k", "l", "m", "n", "o", "p", "q", "_"        },
	{ "r", "s", "t", "u", "v", "w", "x", "y", "z", KEY_BACK   }
};

//
// the name entry screen class
//

class CNameEntryScreen : public CUserInterfaceScreen {

public:

	//
	// constructor / destructor
	//

	CNameEntryScreen( CUserInterfaceScreen* pParent );

	~CNameEntryScreen( void );

	//
	// overloaded user input
	//

	virtual CUserInterfaceScreen* Update( CUserInterfaceInput* pInput, 
		                                  CUserInterfaceAudio* pAudio );

	//
	// get the name
	//

	LPSTR GetName( void ) { return m_szName; };

private:

	//
	// ui text
	//

	CUserInterfaceText m_aText;
	CUserInterfaceText m_bText;

	CUserInterfaceText m_nameText;

	//
	// the name
	//

	CHAR m_szName[XONLINE_NAME_SIZE];

	//
	// the index into the string
	//

	DWORD m_dwStrIndex;

	//
	// the row and col index
	//

	DWORD m_dwRowIndex;
	DWORD m_dwColIndex;

	//
	// the actual key text elements
	//

	CUserInterfaceText* m_pKeys[NUM_ROWS][NUM_COLS];

	//
	// keep track of when updates are needed
	//

	BOOL m_bUpdate;

	//
	// init flag
	//

	BOOL m_bInit;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\SetupOnline\MachineRemovalScreen.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: MachineRemovalScreen.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the Interface for the machine account removal screen
//
///////////////////////////////////////////////////////////////////////////////
#pragma once

#include <xtl.h>
#include "myError.h"
#include <xonlinep.h>

#include "UserInterfaceScreen.h"
#include "UserInterfaceText.h"

//
// the strings
//

static const LPSTR CREATION_PROMPT_STRING = "Press A to erase machine account";
static const LPSTR COMPLETION_PROMPT_STRING = "Machine account erased. Press A to continue";
static const LPSTR MACHINE_A_TEXT = "(A) Action";
static const LPSTR MACHINE_B_TEXT = "(B) Go Back";

//
// the machine account screen colors
//

static const DWORD MACHINE_ACCOUNT_SCREEN_FG_COLOR = 0xFFFFFFFF;
static const DWORD MACHINE_ACCOUNT_SCREEN_BG_COLOR = 0xFF000000;

//
// the x and y location of text
//

static const DWORD MACHINE_ACCOUNT_SCREEN_X = 320;
static const DWORD MACHINE_ACCOUNT_SCREEN_Y = 250;

static const DWORD MACHINE_A_X = 100;
static const DWORD MACHINE_A_Y = 400;
static const DWORD MACHINE_B_X = 520;
static const DWORD MACHINE_B_Y = 400;

//
// the fg/ bg color
//

static const DWORD MACHINE_A_FG_COLOR = 0xFF00FF00;
static const DWORD MACHINE_A_BG_COLOR = 0xFF000000;
static const DWORD MACHINE_B_FG_COLOR = 0xFFFF0000;
static const DWORD MACHINE_B_BG_COLOR = 0xFF000000;

//
// the machine removal screen ui
//

class CMachineRemovalScreen : public CUserInterfaceScreen {

public:

	//
	// constructor / desctructor
	//

	CMachineRemovalScreen( CUserInterfaceScreen* pParent );

	~CMachineRemovalScreen( void );

	//
	// the update input method
	//

	virtual CUserInterfaceScreen* Update( CUserInterfaceInput* pInput, 
		                                  CUserInterfaceAudio* pAudio );

private:


	//
	// ui text
	//

	CUserInterfaceText m_aText;
	CUserInterfaceText m_bText;

	//
	// member to hold wether machine account removal is complete
	//

	BOOL m_bComplete;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\SetupOnline\PinEntryScreen.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: PinEntryScreen.cpp
//
// Author: Dan Rosenstein (danrose)
//
// Description: the implementation for pin entry screen
//
///////////////////////////////////////////////////////////////////////////////

#include "PinEntryScreen.h"

///////////////////////////////////////////////////////////////////////////////
//
// Name:  pin entry screen constructor
//
// Input: pParent - the parent screen for this screen
//
// Output: None
//
// Description: creates an instance of the pin entry screen
//
///////////////////////////////////////////////////////////////////////////////

CPinEntryScreen::CPinEntryScreen( CUserInterfaceScreen* pParent )

	//
	// the parent of the pin entry screen
	//

	: CUserInterfaceScreen( pParent, 
	                        PIN_ENTRY_SCREEN_FG_COLOR, 
							PIN_ENTRY_SCREEN_BG_COLOR, 
							PIN_ENTRY_SCREEN_X, 
							PIN_ENTRY_SCREEN_Y ),

	//
	// the text
	//

	  m_aText( PIN_ENTRY_A_TEXT, PIN_ENTRY_A_X, PIN_ENTRY_A_Y, PIN_ENTRY_A_FG_COLOR, PIN_ENTRY_A_BG_COLOR ),
      m_bText( PIN_ENTRY_B_BACK_TEXT, PIN_ENTRY_B_X, PIN_ENTRY_B_Y, PIN_ENTRY_B_FG_COLOR, PIN_ENTRY_B_BG_COLOR ),
	  m_pinText( m_szStr, PIN_X, PIN_Y, PIN_FG_COLOR, PIN_BG_COLOR ),

	  m_handle( NULL ),
	  m_dwCurIndex( -1 ),
	  m_bInit( FALSE )

{
	ZeroMemory( m_szStr, sizeof( m_szStr ) );

	//
	// needs to have some kind text
	//

	SetText( PIN_ENTRY_TITLE );

	//
	// add the ui text
	//

	AddUIText( &m_aText );
	AddUIText( &m_bText );
	AddUIText( &m_pinText );
}

///////////////////////////////////////////////////////////////////////////////
//
// Name:  pin entry screen destructor
//
// Input: None
//
// Output: None
//
// Description: destroys an instance of the pin entry screen
//
///////////////////////////////////////////////////////////////////////////////

CPinEntryScreen::~CPinEntryScreen( void )
{
	HRESULT hr = XOnlinePINEndInput( m_handle );
	ASSERT( SUCCEEDED( hr ) );
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Init
//
// Input: None
//
// Output: an hr
//
// Description: initializes the pin entry text
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
CPinEntryScreen::Init( void )
{
	HRESULT hr = S_OK;

	//
	// reset the index
	//

	m_dwCurIndex = -1;

	//
	// zero out the internal state
	//
	ZeroMemory( m_szStr, sizeof( m_szStr ) );
	ZeroMemory( &m_inputState, sizeof( XINPUT_STATE ) );
	ZeroMemory( m_aPINByte, XONLINE_PIN_LENGTH );

	//
	// call startup
	//

	if ( SUCCEEDED( hr ) )
	{
		m_handle = XOnlinePINStartInput( &m_inputState );
		hr = NULL == m_handle ? E_OUTOFMEMORY : S_OK;
	}

	//
	// rest the init flag only if success
	//

	if ( SUCCEEDED( hr ) )
	{
		m_bInit = TRUE;
	}

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: UpdateText
//
// Input: None
//
// Output: the final HR
//
// Description: update the text
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
CPinEntryScreen::UpdateText( void )
{
	HRESULT hr = S_OK;

	m_pinText.SetText( m_szStr );

	if ( SUCCEEDED( hr ) )
	{
		hr = XOnlinePINDecodeInput( m_handle, &m_inputState, m_aPINByte + m_dwCurIndex );
	}

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Update
//
// Input: pInput - the input ui
//        pAudio - the audio ui
//
// Output: the next screen
//
// Description: process the input for the screen
//
///////////////////////////////////////////////////////////////////////////////

CUserInterfaceScreen* 
CPinEntryScreen::Update( CUserInterfaceInput* pInput, CUserInterfaceAudio* pAudio )
{
	HRESULT hr = S_OK;
	CUserInterfaceScreen* pRet = NULL;

	//
	// zero out the input state
	//

	ZeroMemory( &m_inputState, sizeof( XINPUT_STATE ) );

	//
	// init the class
	// 

	if ( SUCCEEDED( hr ) && FALSE == m_bInit )
	{
		hr = Init();
	}

	//
	// if b was pressed and the pin is empty, go back OR if A was pressed
	//

	if ( ( pInput->BPressed() && 0 == strcmp( "", m_szStr ) ) ||
		 pInput->APressed() )
	{
		//
		// let the parent intercept the update
		//

		pRet = ParentScreen()->Update( pInput, pAudio );
	}

	//
	// otherwise if b was pressed, clear out the pin
	//

	else if ( pInput->BPressed() )
	{
		//
		// reset the index
		//

		m_dwCurIndex = -1;

		//
		// zero out the internal state
		//

		ZeroMemory( m_szStr, sizeof( m_szStr ) );
		ZeroMemory( &m_inputState, sizeof( XINPUT_STATE ) );
		ZeroMemory( m_aPINByte, XONLINE_PIN_LENGTH );

		pAudio->PlayBackButton();
	}

	//
	// process the input
	//

	if ( pInput->LeftPressed() )
	{
		m_inputState.Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_LEFT;

		if ( ++m_dwCurIndex == XONLINE_PIN_LENGTH )
			m_dwCurIndex = XONLINE_PIN_LENGTH - 1;

		else
			strcat( m_szStr, "LEFT     " );

		pAudio->PlayKeyboardStroke();
	}

	else if ( pInput->RightPressed() )
	{
		m_inputState.Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_RIGHT;

		if ( ++m_dwCurIndex == XONLINE_PIN_LENGTH )
			m_dwCurIndex = XONLINE_PIN_LENGTH - 1;	

		else
			strcat( m_szStr, "RIGHT    " );

		pAudio->PlayKeyboardStroke();
	}

	else if ( pInput->UpPressed() )
	{
		m_inputState.Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_UP;

		if ( ++m_dwCurIndex == XONLINE_PIN_LENGTH )
			m_dwCurIndex = XONLINE_PIN_LENGTH - 1;

		else
			strcat( m_szStr, "UP       " );

		pAudio->PlayKeyboardStroke();
	}

	else if ( pInput->DownPressed() )
	{
		m_inputState.Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_DOWN;

		if ( ++m_dwCurIndex == XONLINE_PIN_LENGTH )
			m_dwCurIndex = XONLINE_PIN_LENGTH - 1;	

		else
			strcat( m_szStr, "DOWN     " );

		pAudio->PlayKeyboardStroke();
	}

	else if ( pInput->XPressed() )
	{
		m_inputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X] = 255;

		if ( ++m_dwCurIndex == XONLINE_PIN_LENGTH )
			m_dwCurIndex = XONLINE_PIN_LENGTH - 1;	

		else
			strcat( m_szStr, "X        " );

		pAudio->PlayKeyboardStroke();
	}

	else if ( pInput->YPressed() )
	{
		m_inputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] = 255;

		if ( ++m_dwCurIndex == XONLINE_PIN_LENGTH )
			m_dwCurIndex = XONLINE_PIN_LENGTH - 1;	

		else
			strcat( m_szStr, "Y        " );

		pAudio->PlayKeyboardStroke();
	}

	else if ( pInput->BlackPressed() )
	{
		m_inputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] = 255;

		if ( ++m_dwCurIndex == XONLINE_PIN_LENGTH )
			m_dwCurIndex = XONLINE_PIN_LENGTH - 1;	

		else
			strcat( m_szStr, "BLACK    " );

		pAudio->PlayKeyboardStroke();
	}

	else if ( pInput->WhitePressed() )
	{
		m_inputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE] = 255;

		if ( ++m_dwCurIndex == XONLINE_PIN_LENGTH )
			m_dwCurIndex = XONLINE_PIN_LENGTH - 1;	

		else
			strcat( m_szStr, "WHITE    " );

		pAudio->PlayKeyboardStroke();
	}

	else if ( pInput->LeftTriggerPressed() )
	{
		m_inputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] = 255;

		if ( ++m_dwCurIndex == XONLINE_PIN_LENGTH )
			m_dwCurIndex = XONLINE_PIN_LENGTH - 1;	

		else
			strcat( m_szStr, "LTRIGGER " );

		pAudio->PlayKeyboardStroke();
	}

	else if ( pInput->RightTriggerPressed() )
	{

		m_inputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] = 255;

		if ( ++m_dwCurIndex == XONLINE_PIN_LENGTH )
			m_dwCurIndex = XONLINE_PIN_LENGTH - 1;	

		else
			strcat( m_szStr, "RTRIGGER " );

		pAudio->PlayKeyboardStroke();
	}

	//
	// if we have entered pin data, then update the UI
	//

	if ( -1 != m_dwCurIndex )
	{
		m_bText.SetText( PIN_ENTRY_B_ERASE_TEXT );
	}

	else
	{
		m_bText.SetText( PIN_ENTRY_B_BACK_TEXT );
	}

	//
	// update the text
	//

	if ( SUCCEEDED( hr ) )
	{
		UpdateText();
	}

	return pRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\SetupOnline\PingScreen.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: PingScreen.cpp
//
// Author: Dan Rosenstein (danrose)
//
// Description: the implementation for ping screen
//
///////////////////////////////////////////////////////////////////////////////

#include "PingScreen.h"

///////////////////////////////////////////////////////////////////////////////
//
// Name:  ping screen constructor
//
// Input: pParent - the parent screen for this screen
//
// Output: None
//
// Description: creates an instance of the ping screen
//
///////////////////////////////////////////////////////////////////////////////

CPingScreen::CPingScreen( CUserInterfaceScreen* pParent )

	//
	// the parent of the ping screen
	//

	: CUserInterfaceScreen( pParent, 
	                        PING_SCREEN_FG_COLOR, 
							PING_SCREEN_BG_COLOR, 
							PING_SCREEN_X, 
							PING_SCREEN_Y ),

	//
	// the text
	//

	  m_aText( PING_A_TEXT, PING_A_X, PING_A_Y, PING_A_FG_COLOR, PING_A_BG_COLOR ),
      m_bText( PING_B_TEXT, PING_B_X, PING_B_Y, PING_B_FG_COLOR, PING_B_BG_COLOR ),

	//
	// start with no thread
	//

	  m_hThread( NULL ),
	  
	//
	// the final hr value from the ping
	//
	
	 m_hrFinal( 0xFFFFFFFF ),

	 //
	 // the ping text index
	 //

	 m_dwPingTextIndex( 0 ),
	 
	 //
	 // init state of ping
	 //

	 m_bPingOnce( FALSE )

{
	//
	// set the initial text
	//

	SetText( PING_TEXTS[m_dwPingTextIndex] );

	//
	// add the ui text
	//

	AddUIText( &m_aText );
	AddUIText( &m_bText );

	//
	// hide the text
	//

	m_aText.Hide( TRUE );
	m_bText.Hide( TRUE );

}

///////////////////////////////////////////////////////////////////////////////
//
// Name:  ping screen destructor
//
// Input: None
//
// Output: None
//
// Description: destroys an instance of the ping screen
//
///////////////////////////////////////////////////////////////////////////////

CPingScreen::~CPingScreen( void )
{
	//
	// check if the thread handle exists
	//

	if ( m_hThread && INVALID_HANDLE_VALUE != m_hThread )
	{
		//
		// close it off if it does
		//

		CloseHandle( m_hThread );
		m_hThread = NULL;
	}
	else if ( INVALID_HANDLE_VALUE == m_hThread )
	{
		m_hThread = NULL;
	}
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: GeneratePing
//
// Input: None
//
// Output: S_OK if ping completed successfuly (in a DWORD)
//
// Description: tries to see if the user can log onto PartnerNet
//
///////////////////////////////////////////////////////////////////////////////

DWORD WINAPI
CPingScreen::GeneratePing( LPVOID lpVoid )
{
	HRESULT hr = S_OK;
	HRESULT hrTask = S_OK;

	//
	// initiate a quick logon
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = COnlineAccounts::Instance()->QuickLogonStart();
	}

	//
	// end the logon
	//

	hrTask = COnlineAccounts::Instance()->QuickLogonFinish();

	//
	// fire back the final hr.
	//

	return SUCCEEDED( hr ) ? hrTask : hr;

}

///////////////////////////////////////////////////////////////////////////////
//
// Name: UpdateText
//
// Input: None
//
// Output: None
//
// Description: Updates the screen text 
//
///////////////////////////////////////////////////////////////////////////////

void
CPingScreen::UpdateText( void )
{
	HRESULT hrThread = S_OK;

	//
	// only update the text if a thread handle exists
	//

	if ( m_hThread && INVALID_HANDLE_VALUE != m_hThread )
	{
		//
		// see if the thread is terminated yet
		//

		if ( GetExitCodeThread( m_hThread, (LPDWORD) &hrThread ) )
		{
			//
			// if the thread is still alive, then we are
			// still pinging parterNET
			//

			if ( STILL_ACTIVE == hrThread )
			{
				SetText( PING_TEXTS[++m_dwPingTextIndex % NUM_TEXT_STATES] );
			}

			//
			// if the handle is S_OK, then we pinged without a prob
			//

			else if ( SUCCEEDED( hrThread ) )
			{
				SetText( PING_SUCCEEDED_TEXT );
				m_hrFinal = S_OK;
			}

			//
			// otherwise, we did not successfuly ping
			//

			else
			{
				SetText( PING_FAILED_TEXT );
				m_hrFinal = E_FAIL;
			}
		}

		//
		// some how getexitcode bailed
		//

		else
		{
			SetText( PING_FAILED_TEXT );
			m_hrFinal = E_FAIL;
		}
	}
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Update
//
// Input: pInput - the input ui
//        pAudio - the audio ui
//
// Output: the next screen
//
// Description: process the input for the screen
//
///////////////////////////////////////////////////////////////////////////////

CUserInterfaceScreen* 
CPingScreen::Update( CUserInterfaceInput* pInput, CUserInterfaceAudio* pAudio )
{
	HRESULT hr = S_OK;
	CUserInterfaceScreen* pRet = NULL;

	//
	// make sure params are good
	//

	hr = pInput && pAudio ? S_OK : E_BAD_ARG;
	MY_ASSERT( hr, S_BAD_ARG );

	if ( ! pInput || ! pAudio )
	{
		return pRet;
	}

	//
	// update the text
	//

	UpdateText();

	//
	// if we have pinged, and either a or b is pressed
	//

	if ( TRUE == m_bPingOnce && pInput->APressed() )
	{
		//
		// we can come back to this screen, so reset internal state
		//

		m_bPingOnce = FALSE;
		m_hrFinal = 0xFFFFFFFF;
		m_dwPingTextIndex = 0;

		//
		// hide a again
		//

		m_aText.Hide( TRUE );
		m_bText.Hide( TRUE );

		//
		// reset the text
		//

		SetText( PING_TEXTS[m_dwPingTextIndex] );

		//
		// goto the parent screen
		//

		pRet = ParentScreen();

		//
		// play the back sound
		//

		hr = pAudio->PlaySelectButton();
	}

	//
	// if the thread has been created and is completed
	//

	else if ( ( NULL != m_hThread && INVALID_HANDLE_VALUE != m_hThread ) && 
		      ( S_OK == m_hrFinal || E_FAIL == m_hrFinal ) )
	{

		//
		// destroy the handle if it exists
		//

		if ( m_hThread && INVALID_HANDLE_VALUE != m_hThread )
		{
			CloseHandle( m_hThread );
			m_hThread = NULL;
		}

		else if ( INVALID_HANDLE_VALUE == m_hThread )
		{
			m_hThread = NULL;
		}

		//
		// decide which sound to play
		//

		if ( S_OK == m_hrFinal )
		{	
			hr = pAudio->PlaySelectButton();
		}

		else
		{
			hr = pAudio->PlayBackButton();
		}

		//
		// reset the final state
		//

		m_hrFinal = S_OK;

		//
		// we've done the ping
		//

		m_bPingOnce = TRUE;

		//
		// unhide text
		//

		m_aText.Hide( FALSE );
	//	m_bText.Hide( FALSE );

	}

	//
	// if the thread was never created
	//

	else if ( ( NULL == m_hThread || INVALID_HANDLE_VALUE == m_hThread ) && FALSE == m_bPingOnce )
	{
		//
		// set the text index back to 0
		//

		m_dwPingTextIndex = 0;

		//
		// update the text
		//

		SetText( PING_TEXTS[m_dwPingTextIndex] );

		//
		// create the thread
		//

		m_hThread = CreateThread( NULL, 0, &CPingScreen::GeneratePing, NULL, 0, NULL );
		hr = 0 != m_hThread ? S_OK : E_MEMORY_ALLOCATION;
		MY_ASSERT( hr, S_MEMORY_ALLOCATION );

		//
		// if the thread could not be created, report it
		//

		if ( ! m_hThread )
		{
			//
			// update the text
			//

			SetText( PING_FAILED_TEXT );

			//
			// play the failed sound
			//

			hr = pAudio->PlayBackButton();

			//
			// do not return any screen
			//

			pRet = NULL;
		}
	}

	return pRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\SetupOnline\PinEntryText.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: PinEntry.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the Interface for the pin entry class
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#include <xtl.h>
#include "myError.h"
#include <xonlinep.h>

#include "UserInterfaceText.h"

//
// the pin entry class
//

class CPinEntryText : public CUserInterfaceText {

public:

	//
	// constructor and destructor
	//

	CPinEntryText( DWORD dwX, 
				   DWORD dwY, 
				   DWORD dwFGColor, 
				   DWORD dwBGColor );

	~CPinEntryText( void );

	//
	// Update the UI Text
	//

	virtual HRESULT Update( CUserInterfaceInput* pInput, CUserInterfaceAudio* pAudio );

	//
	// get the PIN
	//

	LPBYTE GetPin( void ) { return m_aPINByte; };

private:

	//
	// init function
	//

	HRESULT Init( void );

	//
	// update the text
	//

	HRESULT UpdateText( void );

	//
	// the hnadle use for pin input
	//

	XPININPUTHANDLE m_handle;

	//
	// the input state
	//

    XINPUT_STATE m_inputState;

	//
	// the actual pin
	//

    BYTE m_aPINByte[4];

	//
	// the string
	//

	CHAR m_szStr[64];

	//
	// the current char index
	//

	DWORD m_dwCurIndex;

	//
	// init flag
	//

	BOOL m_bInit;

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\SetupOnline\PinEntryText.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: PinEntryText.cpp
//
// Author: Dan Rosenstein (danrose)
//
// Description: the implementation for pin entry text class
//
///////////////////////////////////////////////////////////////////////////////

#include "PinEntryText.h"

///////////////////////////////////////////////////////////////////////////////
//
// Name: constructor
//
// Input: dwX - the X location for the text
//        dwY - the Y location for the text
//        dwFGColor - the foreground color for the text
//        dwBGColor - the background color for the text
//
// Output: None
//
// Description: creates pint entry text object
//
///////////////////////////////////////////////////////////////////////////////

CPinEntryText::CPinEntryText( DWORD dwX, 
							  DWORD dwY, 
							  DWORD dwFGColor, 
							  DWORD dwBGColor )

	: CUserInterfaceText( "", dwX, dwY, dwFGColor, dwBGColor ),
	  m_handle( NULL ),
	  m_dwCurIndex( -1 ),
	  m_bInit( FALSE )

{
	//
	// no code here
	//
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Init
//
// Input: None
//
// Output: an hr
//
// Description: initializes the pin entry text
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
CPinEntryText::Init( void )
{
	HRESULT hr = S_OK;

	//
	// reset the index
	//

	m_dwCurIndex = -1;

	//
	// zero out the internal state
	//
	ZeroMemory( m_szStr, 64 );
	ZeroMemory( &m_inputState, sizeof( XINPUT_STATE ) );
	ZeroMemory( m_aPINByte, 4 );

	//
	// call startup
	//

	if ( SUCCEEDED( hr ) )
	{
		m_handle = XOnlinePINStartInput( &m_inputState );
		hr = NULL == m_handle ? E_OUTOFMEMORY : S_OK;
	}

	//
	// rest the init flag only if success
	//

	if ( SUCCEEDED( hr ) )
	{
		m_bInit = TRUE;
	}

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Destructor
//
// Input: None
//
// Output: None
//
// Description: destroys a pin entry Text object
//
///////////////////////////////////////////////////////////////////////////////

CPinEntryText::~CPinEntryText( void )
{
	HRESULT hr = XOnlinePINEndInput( m_handle );
	ASSERT( SUCCEEDED( hr ) );
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: UpdateText
//
// Input: None
//
// Output: the final HR
//
// Description: update the text
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
CPinEntryText::UpdateText( void )
{
	HRESULT hr = S_OK;

	SetText( m_szStr );

	if ( SUCCEEDED( hr ) )
	{
		hr = XOnlinePINDecodeInput( m_handle, &m_inputState, m_aPINByte + m_dwCurIndex );
	}

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Update
//
// Input: pInput - the input ui class
//        pAudio - the input audio class
//
// Output: the final HR
//
// Description: process input
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
CPinEntryText::Update( CUserInterfaceInput* pInput, CUserInterfaceAudio* pAudio )
{
	HRESULT hr = S_OK;

	//
	// init the class
	// 

	if ( SUCCEEDED( hr ) && FALSE == m_bInit )
	{
		hr = Init();
	}

	//
	// zero out the input state
	//

	ZeroMemory( &m_inputState, sizeof( XINPUT_STATE ) );

	//
	// process the input
	//

	if ( pInput->LeftPressed() )
	{
		m_inputState.Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_LEFT;

		if ( ++m_dwCurIndex == 4 )
			m_dwCurIndex = 3;

		else
			strcat( m_szStr, "LEFT     " );
	}

	if ( pInput->RightPressed() )
	{
		m_inputState.Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_RIGHT;

		if ( ++m_dwCurIndex == 4 )
			m_dwCurIndex = 3;	

		else
			strcat( m_szStr, "RIGHT    " );
	}

	if ( pInput->UpPressed() )
	{
		m_inputState.Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_UP;

		if ( ++m_dwCurIndex == 4 )
			m_dwCurIndex = 3;

		else
			strcat( m_szStr, "UP       " );
	}

	if ( pInput->DownPressed() )
	{
		m_inputState.Gamepad.wButtons |= XINPUT_GAMEPAD_DPAD_DOWN;

		if ( ++m_dwCurIndex == 4 )
			m_dwCurIndex = 3;	

		else
			strcat( m_szStr, "DOWN     " );
	}

	if ( pInput->XPressed() )
	{
		m_inputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X] = 255;

		if ( ++m_dwCurIndex == 4 )
			m_dwCurIndex = 3;	

		else
			strcat( m_szStr, "X        " );
	}

	if ( pInput->YPressed() )
	{
		m_inputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] = 255;

		if ( ++m_dwCurIndex == 4 )
			m_dwCurIndex = 3;	

		else
			strcat( m_szStr, "Y        " );
	}

	if ( pInput->BlackPressed() )
	{
		m_inputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] = 255;

		if ( ++m_dwCurIndex == 4 )
			m_dwCurIndex = 3;	

		else
			strcat( m_szStr, "BLACK    " );
	}

	if ( pInput->WhitePressed() )
	{
		m_inputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE] = 255;

		if ( ++m_dwCurIndex == 4 )
			m_dwCurIndex = 3;	

		else
			strcat( m_szStr, "WHITE    " );
	}

	if ( pInput->LeftTriggerPressed() )
	{
		m_inputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] = 255;

		if ( ++m_dwCurIndex == 4 )
			m_dwCurIndex = 3;	

		else
			strcat( m_szStr, "LTRIGGER " );
	}

	if ( pInput->RightTriggerPressed() )
	{

		m_inputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] = 255;

		if ( ++m_dwCurIndex == 4 )
			m_dwCurIndex = 3;	

		else
			strcat( m_szStr, "RTRIGGER " );
	}

	if ( pInput->BPressed() )
	{
		if ( -1 != m_dwCurIndex )
			memset( m_szStr + m_dwCurIndex-- * 9, 0, 9 );

	}

	//
	// update the text
	//

	if ( SUCCEEDED( hr ) )
	{
		UpdateText();
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\algid.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology 
* reference implementation, version 1.0
* 
* The Private Communication Technology reference implementation, version 1.0 
* ("PCTRef"), is being provided by Microsoft to encourage the development and 
* enhancement of an open standard for secure general-purpose business and 
* personal communications on open networks.  Microsoft is distributing PCTRef 
* at no charge irrespective of whether you use PCTRef for non-commercial or 
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without 
* warranty of any kind, either express or implied, including, without 
* limitation, the implied warranties or merchantability, fitness for a 
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out 
* of use or performance of PCTRef remains with you.
* 
* Please see the file LICENSE.txt, 
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
* 
* Please see http://pct.microsoft.com/pct/pct.htm for The Private 
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/ 

#ifndef _ALGID_H_
#define _ALGID_H_

/* ALG_ID crackers */
#define GET_ALG_CLASS(x)                (x & (3 << 14))
#define GET_ALG_TYPE(x)                 (x & (15 << 10))
#define GET_ALG_SID(x)                  (x & (511))

/* Algorithm classes */

#define ALG_CLASS_SIGNATURE             (0 << 14)
#define ALG_CLASS_MSG_ENCRYPT           (1 << 14)
#define ALG_CLASS_DATA_ENCRYPT          (2 << 14)
#define ALG_CLASS_HASH                  (3 << 14)
#define ALG_CLASS_KEY_EXCHANGE          (4 << 14)

/* Algorithm types */

#define ALG_TYPE_ANY                    (0)
#define ALG_TYPE_DSA                    (1 << 10)
#define ALG_TYPE_RSA                    (2 << 10)
#define ALG_TYPE_BLOCK                  (3 << 10)
#define ALG_TYPE_STREAM                 (4 << 10)

/* Some RSA sub-ids */

#define ALG_SID_RSA_ANY                         0
#define ALG_SID_RSA_PKCS                        1
#define ALG_SID_RSA_MSATWORK                    2
#define ALG_SID_RSA_ENTRUST                     3
#define ALG_SID_RSA_PGP                         4

/* Some DSS sub-ids */

#define ALG_SID_DSS_ANY                         0
#define ALG_SID_DSS_PKCS                        1
#define ALG_SID_DSS_DMS                         2

/* Block cipher sub ids */
/* DES sub_ids */
#define ALG_SID_DES_ECB                         0
#define ALG_SID_DES_CBC                         1
#define ALG_SID_DES_CFB                         2
#define ALG_SID_DES_OFB                         3

/* RC2 sub-ids */
#define ALG_SID_RC2_ECB                         4
#define ALG_SID_RC2_CBC                         5
#define ALG_SID_RC2_CFB                         6
#define ALG_SID_RC2_OFB                         7

/* Stream cipher sub-ids */
#define ALG_SID_RC4                             0
#define ALG_SID_SEAL                            1

/* Hash sub ids */
#define ALG_SID_MD2                                     0
#define ALG_SID_MD4                                     1
#define ALG_SID_MD5                                     2
#define ALG_SID_SHA                                     3

/* Our silly example sub-id */    

#define ALG_SID_EXAMPLE         80

typedef int ALG_ID;


#define MD2                                     ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MD2
#define MD4                                     ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MD4
#define MD5                                     ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MD5
#define SHA                                     ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SHA
#define RSA_SIGNATURE           ALG_CLASS_SIGNATURE | ALG_TYPE_RSA | ALG_SID_RSA_ANY
#define DSS_SIGNATURE           ALG_CLASS_SIGNATURE | ALG_TYPE_DSA | ALG_SID_DSA_ANY
#define RSA_KEYEXCHANGE         ALG_CLASS_KEY_EXCHANGE | ALG_TYPE_RSA | ALG_SID_RSA_ANY
#define DES_ECB                         ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_BLOCK | ALG_SID_DES_ECB
#define DES_CBC                         ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_BLOCK | ALG_SID_DES_CBC
#define DES_CFB                         ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_BLOCK | ALG_SID_DES_CFB
#define DES_OFB                         ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_BLOCK | ALG_SID_DES_OFB
#define RC2_ECB                         ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_BLOCK | ALG_SID_RC2_ECB
#define RC2_CBC                         ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_BLOCK | ALG_SID_RC2_CBC
#define RC2_CFB                         ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_BLOCK | ALG_SID_RC2_CFB
#define RC2_OFB                         ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_BLOCK | ALG_SID_RC2_OFB
#define RC4                                     ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_STREAM | ALG_SID_RC4
#define SEAL                            ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_STREAM | ALG_SID_SEAL



#define MAXNAMELEN                      0x60

#define BASIC_RSA       0
#define MD2_WITH_RSA    1
#define MD5_WITH_RSA    2
#define RC4_STREAM      3

#endif /* _ALGID_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\ber.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology 
* reference implementation, version 1.0
* 
* The Private Communication Technology reference implementation, version 1.0 
* ("PCTRef"), is being provided by Microsoft to encourage the development and 
* enhancement of an open standard for secure general-purpose business and 
* personal communications on open networks.  Microsoft is distributing PCTRef 
* at no charge irrespective of whether you use PCTRef for non-commercial or 
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without 
* warranty of any kind, either express or implied, including, without 
* limitation, the implied warranties or merchantability, fitness for a 
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out 
* of use or performance of PCTRef remains with you.
* 
* Please see the file LICENSE.txt, 
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
* 
* Please see http://pct.microsoft.com/pct/pct.htm for The Private 
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/ 

#ifndef __BER_H__
#define __BER_H__


#define BER_UNIVERSAL           0x00
#define BER_APPLICATION         0x40
#define BER_CONTEXT_SPECIFIC    0x80
#define BER_PRIVATE             0xC0

#define BER_PRIMITIVE           0x00
#define BER_CONSTRUCTED         0x20

#define BER_BOOL                1
#define BER_INTEGER             2
#define BER_BIT_STRING          3
#define BER_OCTET_STRING        4
#define BER_NULL                5
#define BER_OBJECT_ID           6
#define BER_OBJECT_DESC         7
#define BER_EXTERNAL            8
#define BER_REAL                9
#define BER_ENUMERATED          10

#define BER_SEQUENCE            (16 | BER_CONSTRUCTED)
#define BER_SET                 (17 | BER_CONSTRUCTED)

#define BER_NUMERIC_STRING      0x12
#define BER_PRINTABLE_STRING    0x13
#define BER_TELETEX_STRING      0x14
#define BER_VIDEOTEX_STRING     0x15
#define BER_IA5STRING           0x16
#define BER_GRAPHIC_STRING      0x19

#define BER_UTC_TIME            23

typedef int (* OutputFn)(char *, ...);
typedef BOOL (* StopFn)(void);

int
ber_decode(
    OutputFn Out,
    StopFn  Stop,
    LPBYTE  pBuffer,
    int   Indent,
    int   Offset,
    int   TotalLength,
    int   BarDepth);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\SetupOnline\PingScreen.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: PingScreen.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the Interface for the ping screen
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#include <xtl.h>
#include "myError.h"
#include <xonlinep.h>
#include <OnlineAccounts.h>

#include "UserInterfaceScreen.h"
#include "UserInterfaceText.h"

//
// the strings
//

static const LPSTR PING_TEXTS[] = { "Pinging PartnerNet.  ",
                                    "Pinging PartnerNet . ",
								    "Pinging PartnerNet  .",
									"Pinging PartnerNet . " };

static const LPSTR PING_SUCCEEDED_TEXT = "Ping Succeeded";
static const LPSTR PING_FAILED_TEXT = "Ping Failed";
static const LPSTR PING_A_TEXT = "(A) OK";
static const LPSTR PING_B_TEXT = "(B) Back";

//
// the ping screen colors
//

static const DWORD PING_SCREEN_FG_COLOR = 0xFFFFFFFF;
static const DWORD PING_SCREEN_BG_COLOR = 0xFF000000;

//
// the number of text states
//

static const DWORD NUM_TEXT_STATES = 4;

//
// the x and y location of text
//

static const DWORD PING_SCREEN_X = 320;
static const DWORD PING_SCREEN_Y = 250;

static const DWORD PING_A_X = 500;
static const DWORD PING_A_Y = 400;
static const DWORD PING_B_X = 140;
static const DWORD PING_B_Y = 400;

//
// the fg/ bg color
//

static const DWORD PING_A_FG_COLOR = 0xFF00FF00;
static const DWORD PING_A_BG_COLOR = 0xFF000000;
static const DWORD PING_B_FG_COLOR = 0xFFFF0000;
static const DWORD PING_B_BG_COLOR = 0xFF000000;

//
// the ping screen class
//

class CPingScreen : public CUserInterfaceScreen {

public:

	//
	// constructor / destructor
	//

	CPingScreen( CUserInterfaceScreen* pParent );

	~CPingScreen( void );

	//
	// overloaded user input
	//

	virtual CUserInterfaceScreen* Update( CUserInterfaceInput* pInput, 
		                                  CUserInterfaceAudio* pAudio );

private:

	//
	// helper ot update text based on thread status
	//

	void UpdateText( void );

	//
	// code to generate ping to partenrnet
	//

	static DWORD WINAPI GeneratePing( LPVOID lpParam );

	//
	// handle for the thread
	//

	HANDLE m_hThread;

	//
	// the final hr value
	//

	HRESULT m_hrFinal;

	//
	// ui text
	//

	CUserInterfaceText m_aText;
	CUserInterfaceText m_bText;

	//
	// place to hold the current ping text index
	//

	DWORD m_dwPingTextIndex;

	//
	// only have 1 ping per time
	//

	BOOL m_bPingOnce;

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\bullet.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/

#include <stdlib.h>
#include <spbase.h>
#include <wincrypt.h>

#ifdef ENABLE_SELECTIVE_CRYPTO
#include <scrypt.h>

//  Isser:
//      2.5.4.6=US
//      2.5.4.10=Bolt Beranek & Newman, Inc.
//      2.5.4.3=Serial No. 950140 283
//  Signature Algorithm: 1.2.840.113549.1.1.2
//  Subject:
//      2.5.4.3=Evil


static BYTE g_SCVerifyKey[] = {
        0x01, 0x00, 0x00, 0x00,
        0x9c, 0x00, 0x00, 0x00,
        'R', 'S', 'A', '1',			// key data....
        0x88, 0x00, 0x00, 0x00,     // key length
        0x00, 0x04, 0x00, 0x00,     // bit length
        0x7f, 0x00, 0x00, 0x00,     // data length
        0x01, 0x00, 0x01, 0x00,     // public exponent.
        0x51, 0x01, 0x98, 0x56, 0x37, 0xc6, 0xa2, 0x0c,  // modulus
        0x21, 0x91, 0xfb, 0x99, 0xcd, 0xbb, 0x2d, 0x4f,
        0x96, 0x0f, 0xf2, 0x02, 0xaa, 0x5a, 0x6e, 0xe0,
        0x4b, 0x2e, 0x5a, 0x0a, 0xf3, 0x6f, 0x29, 0xce,
        0x5b, 0xa1, 0x8e, 0xc6, 0xcf, 0x21, 0xe4, 0xe1,
        0x1e, 0x6a, 0xc5, 0xed, 0x86, 0x7b, 0xd1, 0x72,
        0x25, 0x4e, 0x20, 0x3b, 0x6f, 0xca, 0x38, 0x8d,
        0x8d, 0x29, 0x63, 0xb9, 0x17, 0x80, 0x64, 0xeb,
        0xde, 0x40, 0x29, 0xca, 0x40, 0x48, 0x40, 0x7a,
        0xc0, 0xce, 0xcb, 0x7a, 0x69, 0x42, 0x24, 0xc9,
        0xff, 0xe4, 0x3d, 0x79, 0x68, 0x7d, 0x69, 0x65,
        0xde, 0x81, 0x54, 0x94, 0x38, 0x4e, 0x84, 0xd4,
        0x75, 0xa5, 0x94, 0x41, 0xbe, 0xc8, 0xce, 0x49,
        0xe4, 0x8e, 0x3e, 0x8b, 0xdc, 0xf8, 0x8d, 0x66,
        0xf2, 0xcb, 0x80, 0x1c, 0x85, 0xb4, 0x0c, 0xe3,
        0x15, 0xb8, 0xec, 0xdf, 0xf6, 0x60, 0xcb, 0xc2,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};





BOOL VerifyFinCert(LPCTSTR Filename, BYTE *Sig, DWORD SigSize)
{
    HANDLE              hFile, hMap;
    LPBYTE              lpContents;
    DWORD               dwSize;
    BYTE                FileHash[16];
    BOOL                bSigWorked;
    
    bSigWorked = FALSE;
    hFile = INVALID_HANDLE_VALUE;
    hMap = NULL;
    lpContents = NULL;
    
    // check the file.  
    do
    {


        hFile = CreateFile(Filename,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
			   0);

        if (hFile == INVALID_HANDLE_VALUE)
            break;

        dwSize = GetFileSize(hFile, NULL);
        
        hMap = CreateFileMapping(hFile,
                                 NULL,
                                 PAGE_WRITECOPY,
                                 0,
                                 0,
                                 NULL);

        if (hMap == NULL)
            break;
        
        lpContents = (LPBYTE)MapViewOfFile(hMap, FILE_MAP_COPY, 0, 0, 0);

        if (lpContents == NULL)
            break;
        
        bSigWorked = sigRSAMD5.Verify(lpContents,
                                      dwSize,
                                      Sig,
                                      SigSize,
                                      (PctPublicKey *)g_SCVerifyKey);
	
	    break;
	
    } while(1);

    if (lpContents)
        UnmapViewOfFile(lpContents);

    if (hMap != NULL)
        CloseHandle(hMap);

    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    return bSigWorked;
}

#endif

SP_STATUS
SPEnableFinanceCipher(VOID)
{
    
#ifdef ENABLE_SELECTIVE_CRYPTO
    HMODULE     hCaller;
    TCHAR       pszModFile[MAX_PATH_LEN], *pszPureFile;
    DWORD       dwPathLen, i, dwType, dwLen, err, disp;
    PBYTE       SCSig;

    
    // we need to look for a financial certificate for the application.

    // find the application
    hCaller = GetModuleHandle(NULL);
    dwPathLen = GetModuleFileName(hCaller, pszModFile, MAX_PATH_LEN);
        
    pszPureFile = pszModFile+dwPathLen;

    // grab the filename from the path.
    while(pszPureFile > pszModFile)
    {
        if(*(pszPureFile-1) == '\\')
        {
            break;
        }
        pszPureFile--;
        
    }

    SCSig = NULL;
        
    while(TRUE)
    {
        dwLen = 0;
        err = RegQueryValueEx(g_hkBase,
                              pszPureFile,
                              NULL,
                              &dwType,
                              NULL,
                              &dwLen);

        if(err || (dwLen == 0))
        {
            break;
        }
        SCSig = SPExternalAlloc(dwLen);
        if(SCSig == NULL)
        {
            break;
        }

        err = RegQueryValueEx(g_hkBase,
                              pszPureFile,
                              NULL,
                              &dwType,
                              SCSig,
                              &dwLen);

        if(err || (dwLen == 0))
        {
            break;
        }

        // We have a signature for this file.

        if (VerifyFinCert(pszModFile, SCSig, dwLen))
        {
            PCipherInfo pInfo;
            pInfo = GetCipherInfo(SP_CIPHER_RC4 | SP_ENC_BITS_64 | SP_MAC_BITS_128);
            pInfo->fProtocol |= SP_PROT_CLIENTS;
        }
        break;
    }

    if(SCSig != NULL)
    {
        SPExternalFree(SCSig);
    }
    
#endif
    return (PCT_ERR_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\cache.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/

//
// SHolden - I have changed the caching for WinCE. Before an array was created
//           (with a default of 100) cache entries. This is totally huge
//           for WinCE. Now I will have a linked list with a persistent
//           maximum of g_dwCacheSize. However, the list size will be able
//           to grow beyond the max and then shrink back later.
//

#include "spbase.h"
#include <linklist.h>
#include <limits.h>

#ifdef DEBUG
    DWORD g_cCacheEntryDebugCount = 0;
#endif // DEBUG

typedef struct _tagSERVER_CACHE_ENTRY
{
    LIST_ENTRY    _ListEntry;
    SessCacheItem _CacheItem;
} SERVER_CACHE_ENTRY, *LPSERVER_CACHE_ENTRY;

#ifdef PCT_CI_EMPTY
# undef PCT_CI_EMPTY
# undef PCT_CI_FULL
# undef CACHE_EXPIRE_TICKS
#endif

#define PCT_CI_EMPTY	0
#define PCT_CI_FULL	1


LIST_ENTRY ServerCacheList;

DWORD g_dwCacheSize;    // = 0;
DWORD g_dwCacheMaxSize  = SP_DEF_SERVER_CACHE_SIZE;
DWORD g_cUsedCacheItems; // = 0;
DWORD g_dwExpireTime    = DEF_EXPIRE_TIME;

CRITICAL_SECTION CacheCritSec;
#define SPAcquireCache(pcritsec) EnterCriticalSection(pcritsec)
#define SPReleaseCache(pcritsec) LeaveCriticalSection(pcritsec)

static BOOL
SPCacheDelete(
    SessCacheItem *pItem
    );

// Implementation.

SP_STATUS
SPInitSessionCache(VOID)
{
    DEBUGMSG(ZONE_SERVERCACHE,
             (TEXT("+SPInitSessionCache()\r\n"))
             );

    InitializeCriticalSection(&CacheCritSec);
    InitializeListHead(&ServerCacheList);

    DEBUGMSG(ZONE_SERVERCACHE,
             (TEXT("-SPInitSessionCache [PCT_ERR_OK]\r\n"))
             );

    return (PCT_ERR_OK);
}

SP_STATUS
SPShutdownSessionCache(VOID)
{
    PLIST_ENTRY pNextItem;
    PSessCacheItem pCacheItem;

    SPAcquireCache(&CacheCritSec);

    DEBUGMSG(ZONE_SERVERCACHE,
             (TEXT("+SPShutdownSessionCache\r\n"))
             );

    for (pNextItem = ServerCacheList.Flink;
         pNextItem != &ServerCacheList;
         )
    {
        pCacheItem = (PSessCacheItem)pNextItem;
        pNextItem  = pNextItem->Flink;

        // Blindly kill.
        pCacheItem->cRef = 1;
        SPCacheDereference(pCacheItem);
        RemoveEntryList((PLIST_ENTRY)pCacheItem);
        SPExternalFree(pCacheItem);
        g_dwCacheSize--;
    }

    ASSERT(g_dwCacheSize == 0);

    DEBUGMSG(ZONE_SERVERCACHE,
             (TEXT("-SPShutdownSessionCache [PCT_ERR_OK]\r\n"))
             );

    SPReleaseCache(&CacheCritSec);
    DeleteCriticalSection(&CacheCritSec);

    return (PCT_ERR_OK);
}

LONG
SPCacheReference(SessCacheItem *pItem)
{
    long cRet;

    if(pItem == NULL)
    {
        return -1;
    }

    SPAcquireCache(&CacheCritSec);

    if (1 == (cRet = InterlockedIncrement(&pItem->cRef)))
    {
        g_cUsedCacheItems++;
    }

    DEBUGMSG(ZONE_SERVERCACHE,
             (TEXT("SPCacheReference %d: %d->%d\r\n"),
              pItem->DebugId,
              cRet -1, cRet)
             );

    SPReleaseCache(&CacheCritSec);
    return (cRet);
}

LONG
SPCacheDereference(SessCacheItem *pItem)
{
    long cRet;

    if(pItem == NULL)
    {
        return -1;
    }

    SPAcquireCache(&CacheCritSec);

    if(0 == (cRet = InterlockedDecrement(&pItem->cRef)))
    {
        SPCacheDelete(pItem);
        g_cUsedCacheItems--;
    }

    DEBUGMSG(ZONE_SERVERCACHE,
             (TEXT("SPCacheDereference %d: %d->%d\r\n"),
              pItem->DebugId,
              cRet + 1,
              cRet)
             );

    SPReleaseCache(&CacheCritSec);
    return cRet;
}

BOOL
SPCacheDelete(
    SessCacheItem *pItem
    )
{
    if (pItem == NULL)
    {
        return (FALSE);
    }

    // Mark this item as non-retrievable.
    pItem->ZombieJuju = FALSE;

    // Delete all items pointed to by the cache.
    if (pItem->pServerCert)
    {
        DereferenceCert(pItem->pServerCert);
        pItem->pServerCert = NULL;
    }

    if (pItem->pClientCert)
    {
        DereferenceCert(pItem->pClientCert);
        pItem->pClientCert = NULL;
    }

#ifdef FOO
    if(pItem->pMapper)
    {
        if(pItem->hLocator)
        {
            pItem->pMapper->CloseLocator(pItem->hLocator);
            pItem->hLocator = NULL;
        }
    }
#endif
    /* close the HLOCATOR here */

    return (TRUE);
}

BOOL SPCacheRetrieveBySession(
                         DWORD fProtocol,
                         PUCHAR SessionID,
                         DWORD cbSessionID,
                         PSessCacheItem *ppRetItem
                        )
{
    BOOL fFound = FALSE;
    PLIST_ENTRY pNextItem;
    PSessCacheItem pCacheItem;

    SPAcquireCache(&CacheCritSec);

    DEBUGMSG(ZONE_SERVERCACHE,
             (TEXT("+SPCacheRetrieveBySession(0x%.8X, 0x%.8X, 0x%.8X, 0x%.8X)\r\n"),
              fProtocol,
              SessionID,
              cbSessionID,
              ppRetItem)
             );

    if(ppRetItem == NULL)
    {
        DEBUGMSG(ZONE_SERVERCACHE,
                 (TEXT("-SPCacheRetrieveBySession [FALSE]\r\n"))
                 );

        SPReleaseCache(&CacheCritSec);
        return (FALSE);
    }

    if(cbSessionID)
    {
        // NOTE:  Any items that are owned by the cache will have at least
        // on reference count for that.  They are therefore not going to be
        // deleted from the cache during this process because the
        // cache access is crit-sectioned.

        for (pNextItem = ServerCacheList.Flink;
             pNextItem != &ServerCacheList;
             pNextItem = pNextItem->Flink
             )
        {
            pCacheItem = (PSessCacheItem)pNextItem;

            // Is the ref count non zero.
            // The cache should always have a reference
            // to the item if it is a valid item, nobody
            // but the caching code can inc the ref count
            // from zero to 1, and nobody but the cache
            // code can dec from 1 to 0.  Therefore it's safe
            // to say that if the ref count is zero, the
            // item doesn't exist, and it won't exist.
            // If the item is greater than 1, then the referenceres
            // of the item can dereference it during the cache search,
            // but since the cache holds a reference to the item as
            // well, it won't be deleted out from under us.

            if(pCacheItem->cRef == 0)
            {
                continue;
            }

            // Is this item retrievable
            if (!pCacheItem->ZombieJuju)
            {
                continue;
            }

             // Has this item expired?
            if(pCacheItem->Time < GetTickCount())
            {
                continue;
            }
           // Is this item for the protocol we're using.
            if(0 == (fProtocol & pCacheItem->fProtocol))
            {
                continue;
            }

            if(cbSessionID != pCacheItem->cbSessionID)
            {
                continue;
            }

            if ( memcmp(SessionID, pCacheItem->SessionID, cbSessionID) == 0)
            {

                // Found item in cache!!

                pCacheItem->Time = GetTickCount() + g_dwExpireTime;
                // Are we replacing something?
                // Then dereference the thing we are replacing.
                if(*ppRetItem)
                {
                    SPCacheDereference(*ppRetItem);
                }

                // Return item referenced.
                *ppRetItem = pCacheItem;
                SPCacheReference(pCacheItem);
                fFound = TRUE;
                break;
            }
        }
    }

    DEBUGMSG(ZONE_SERVERCACHE,
             (TEXT("-SPCacheRetrieveBySession [%s]\r\n"),
              (fFound == TRUE) ? TEXT("TRUE") : TEXT("FALSE"))
             );

    SPReleaseCache(&CacheCritSec);

    return (fFound);
}


BOOL SPCacheRetrieveByName(
                         DWORD fProtocol,
                         PCHAR szName,
                         PSessCacheItem *ppRetItem
                        )
{
    BOOL fFound = FALSE;
    PLIST_ENTRY pNextItem;
    PSessCacheItem pCacheItem;

    SPAcquireCache(&CacheCritSec);

    DEBUGMSG(ZONE_SERVERCACHE,
             (TEXT("+SPCacheRetrieveByName(0x%.8X, %a, 0x%.8X[%d])\r\n"),
              fProtocol,
              szName,
              ppRetItem,
              ppRetItem ? (*ppRetItem)->DebugId : -1)
             );

    if(ppRetItem == NULL)
    {
        DEBUGMSG(ZONE_SERVERCACHE,
                 (TEXT("-SPCacheRetrieveByName [FALSE]\r\n"))
                 );

        SPReleaseCache(&CacheCritSec);

        return (FALSE);
    }

    DEBUGMSG(ZONE_SERVERCACHE,
             (TEXT("Looking for [%a] in cache.\r\n"),
              szName ? szName : "NULL")
             );

    for (pNextItem = ServerCacheList.Flink;
         pNextItem != &ServerCacheList;
         pNextItem = pNextItem->Flink
         )
    {
        pCacheItem = (PSessCacheItem)pNextItem;

        // Is the ref count non zero.
        // The cache should always have a reference
        // to the item if it is a valid item, nobody
        // but the caching code can inc the ref count
        // from zero to 1, and nobody but the cache
        // code can dec from 1 to 0.  Therefore it's safe
        // to say that if the ref count is zero, the
        // item doesn't exist, and it won't exist.
        // If the item is greater than 1, then the referenceres
        // of the item can dereference it during the cache search,
        // but since the cache holds a reference to the item as
        // well, it won't be deleted out from under us.

        if(pCacheItem->cRef == 0)
        {
            continue;
        }
        // Is this item retrievable
        if (!pCacheItem->ZombieJuju)
        {
            continue;
        }

        // Has this item expired?
        if(pCacheItem->Time < GetTickCount())
        {
            continue;
        }

        // Is this item for the protocol we're using.
        if(0 == (fProtocol & pCacheItem->fProtocol))
        {
            continue;
        }


        if((pCacheItem->szCacheID[0] == 0 && szName == NULL) ||
           (strcmp(szName, pCacheItem->szCacheID) == 0))
        {
            pCacheItem->Time = GetTickCount() + g_dwExpireTime;
            if(*ppRetItem)
            {
                SPCacheDereference(*ppRetItem);
            }
            *ppRetItem = pCacheItem;
            SPCacheReference(pCacheItem);
            fFound = TRUE;
            break;
        }
    }

    DEBUGMSG(ZONE_SERVERCACHE,
             (TEXT("-SPCacheRetrieveByName [%s]\r\n"),
              (fFound == TRUE)? TEXT("TRUE") : TEXT("FALSE"))
             );

    SPReleaseCache(&CacheCritSec);

    return (fFound);
}


/* allocate a new cache item to be used
 * by a context.  Initialize it with the
 * pszTarget if the target exists.
 * Auto-Generate a SessionID
 */
BOOL
SPCacheRetrieveNew(
                   PUCHAR pszTarget,
                   PSessCacheItem *ppRetItem
                  )
{
    DWORD timeNow, timeOldest;
    PLIST_ENTRY pNextItem;
    PSessCacheItem pCacheItem;
    PSessCacheItem pOldestItem = NULL;
#ifdef DEBUG
    DWORD i = 0;
#endif // DEBUG

    SPAcquireCache(&CacheCritSec);

    DEBUGMSG(ZONE_SERVERCACHE,
             (TEXT("+SPCacheRetrieveNew(%a, 0x%.8X)\r\n"),
              pszTarget,
              ppRetItem)
             );

    timeNow = GetTickCount();
    timeOldest = timeNow + g_dwExpireTime;

    for (pNextItem = ServerCacheList.Flink;
         pNextItem != &ServerCacheList;
         pNextItem = pNextItem->Flink
         )
    {
    #ifdef DEBUG
        i++;
    #endif // DEBUG

        pCacheItem = (PSessCacheItem)pNextItem;

        // Did we find an empty slot in cache.
        if (pCacheItem->cRef == 0)
        {
            break;
        }

        // Check to see if we have any elements that we
        // can expire.
        if(pCacheItem->cRef == 1)
        {
            if(pCacheItem->ZombieJuju == FALSE)
            {
                // Special Case, if this item is only held by the
                // cache, but it hasn't been marked as searchable,
                // then this is an aborted zombie (yeuch).
                // We can use this one.

                DEBUGMSG(ZONE_SERVERCACHE,
                         (TEXT("\tExpiring aborted zombie - Id = %d.\r\n"),
                          pCacheItem->DebugId)
                         );

                SPCacheDereference(pCacheItem);
                break;

            }

            if (pCacheItem->Time < timeNow)
            {
                DEBUGMSG(ZONE_SERVERCACHE,
                         (TEXT("\tExpiring old element.\r\n"))
                         );

                SPCacheDereference(pCacheItem);
                break;
            }

            // keep index and time of oldest unexpired entry

            if (timeOldest > pCacheItem->Time)
            {
                timeOldest  = pCacheItem->Time;
                pOldestItem = pCacheItem;

                DEBUGMSG(ZONE_SERVERCACHE,
                         (TEXT("Oldest element - %d.\r\n"),
                          pOldestItem->DebugId)
                         );
            }
        }
    }

    ASSERT(i <= g_dwCacheSize);

    if (pNextItem == &ServerCacheList)
    {
        ASSERT(i == g_dwCacheSize);

        if ((pOldestItem == NULL) || (g_dwCacheSize < g_dwCacheMaxSize))
        {
            // Need to add a new entry to the list.
            pNextItem = (PLIST_ENTRY)SPExternalAlloc(sizeof(SessCacheItem));

            if (pNextItem == NULL)
            {
                SPReleaseCache(&CacheCritSec);

                DEBUGMSG(ZONE_ERROR,
                         (TEXT("-SPCacheRetrieveByName [FALSE] Out of Memory!\r\n"))
                         );

                return (FALSE);
            }

            ZeroMemory(pNextItem, sizeof(SessCacheItem));
            InsertTailList(&ServerCacheList, (PLIST_ENTRY)pNextItem);
            pCacheItem = (PSessCacheItem)pNextItem;
            g_dwCacheSize++;
        #ifdef DEBUG
            pCacheItem->DebugId = ++g_cCacheEntryDebugCount;
        #endif //DEBUG

            DEBUGMSG(ZONE_SERVERCACHE,
                     (TEXT("Creating new cache element - Id = %d.\r\n"),
                      pCacheItem->DebugId)
                     );

        }
        else
        {
            // We will replace the oldest item.
            pCacheItem = pOldestItem;
            DEBUGMSG(ZONE_SERVERCACHE,
                     (TEXT("\tReplacing oldest element - Id = %d\r\n"),
                      pCacheItem->DebugId)
                     );

            SPCacheDereference(pCacheItem);
        }
    }

    ASSERT(pCacheItem != NULL);
    ASSERT(pCacheItem->cRef == 0);

    // pCacheItem is our new element, so
    // "Put it in the cache"
    SPCacheReference(pCacheItem);

    if(pszTarget)
    {
        CopyMemory(pCacheItem->szCacheID,
                   pszTarget,
                   min(strlen(pszTarget)+1, (SP_MAX_CACHE_ID-1))
                  );
    }
    else
    {
        pCacheItem->szCacheID[0] = '\0';
    }

    // Pre seed the session ID with random bits
    GenerateRandomBits(pCacheItem->SessionID, SP_MAX_SESSION_ID);

    // Size of session ID is zero
    pCacheItem->cbSessionID = 0;
    pCacheItem->Time = timeNow + g_dwExpireTime;
    pCacheItem->ZombieJuju = FALSE;
    pCacheItem->fProtocol = g_ProtEnabled;
    pCacheItem->phMapper = NULL;
    pCacheItem->cbClearKey = 0;
    pCacheItem->cbMasterKey = 0;
    pCacheItem->pServerCert = NULL;
    pCacheItem->pClientCert = NULL;
    pCacheItem->hLocator = 0;
    pCacheItem->fSGC = 0;

    // We've set up this element, so reference it for the caller.

    SPCacheReference(pCacheItem);

    *ppRetItem = pCacheItem;

    DEBUGMSG(ZONE_SERVERCACHE,
             (TEXT("%d/%d [Cache items/Cache max peristent size]. ")
              TEXT("%d cache items used.\r\n"),
              g_dwCacheSize,
              g_dwCacheMaxSize,
              g_cUsedCacheItems)
             );

    // If the cache is larger that we want to allow, go through and delete
    // expired zombies and old elements. Also, we can delete unreferenced
    // items, although I am not sure that we really get any of these.
    if (g_dwCacheMaxSize < g_dwCacheSize)
    {
        for (pNextItem = ServerCacheList.Flink;
             pNextItem != &ServerCacheList;)
        {
            pCacheItem = (PSessCacheItem)pNextItem;

            // Need to increment now in case we delete a node in the list.
            pNextItem = pNextItem->Flink;

            if (pCacheItem->cRef == 0)
            {
                DEBUGMSG(ZONE_SERVERCACHE,
                         (TEXT("\tDeleting unreferenced cache item - %d.\r\n"),
                          pCacheItem->DebugId)
                         );
                RemoveEntryList((PLIST_ENTRY)pCacheItem);
                g_dwCacheSize--;
            }
            else if (pCacheItem->cRef == 1)
            {
                if ((pCacheItem->ZombieJuju == FALSE) ||
                    (pCacheItem->Time < timeNow )
                    )
                {
                    DEBUGMSG(ZONE_SERVERCACHE,
                             (TEXT("\tDeleting %s cache item - %d.\r\n"),
                              (pCacheItem->ZombieJuju == FALSE) ?
                                    TEXT("expired zombie") : TEXT("old"),
                              pCacheItem->DebugId)
                             );

                    SPCacheDereference(pCacheItem);
                    RemoveEntryList((PLIST_ENTRY)pCacheItem);
                    SPExternalFree(pCacheItem);
                    g_dwCacheSize--;
                }
            }

            if (g_dwCacheMaxSize >= g_dwCacheSize)
            {
                break;
            }
        }
    }

    DEBUGMSG(ZONE_SERVERCACHE,
             (TEXT("-SPCacheRetrieveNew [TRUE]\r\n"))
             );

    SPReleaseCache(&CacheCritSec);

    return (TRUE);
}

BOOL SPCacheAdd(
                   SessCacheItem *pItem
                )
{
    DEBUGMSG(ZONE_SERVERCACHE,
             (TEXT("SPCacheAdd %d->ZombieJuju\r\n"),
              pItem->DebugId)
             );

    if(pItem == NULL)
    {
        return FALSE;
    }

    // Allow cache ownership of this item
    pItem->ZombieJuju = TRUE;

    return TRUE;

}

/* Allocate a new cache item, and copy 
 * over relevant information from old item,
 * and dereference old item.  This is a helper
 * for REDO
 */
BOOL
SPCacheClone(PSessCacheItem *ppItem)
{
    PSessCacheItem pNewItem = NULL;

    if(ppItem == NULL || *ppItem == NULL)
    {
        return FALSE;
    }

    // Get a fresh cache item.
    if(!SPCacheRetrieveNew((*ppItem)->szCacheID, &pNewItem))
    {
        return FALSE;
    }
    
    // Copy over old relevant data
    
     
    pNewItem->fProtocol = (*ppItem)->fProtocol;
    pNewItem->fSGC      = (*ppItem)->fSGC;

    SPCacheDereference(*ppItem);
    *ppItem = pNewItem;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\cache.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/



typedef struct _SessCacheItem {
    LIST_ENTRY      _ListEntry;
    LONG            cRef;                 // cache item reference count.
    BOOL            ZombieJuju;           // FALSE, item is owned by the cache
                                          // TRUE, item is not owned by cache.

    DWORD           fProtocol;
    DWORD	        Time;

    HMAPPER        *phMapper;
    BOOL            fSGC;                 // enable SGC ciphers

    // Session ID for this session
    DWORD	        cbSessionID;
    UCHAR	        SessionID[SP_MAX_SESSION_ID];


    // Data used to generate keys/
    DWORD           cbMasterKey;
    UCHAR	        pMasterKey[SP_MAX_MASTER_KEY];

    // Clear key saved for PCT
    DWORD           cbClearKey;
    UCHAR           pClearKey[SP_MAX_MASTER_KEY];

    // cache ID (usually machine name or addr)
    UCHAR	        szCacheID[SP_MAX_CACHE_ID];

    CipherSpec	    SessCiphSpec;   // Ciphers used
    HashSpec	    SessHashSpec;
    ExchSpec	    SessExchSpec;


    // References to certificate objects.

    PPctCertificate pServerCert;
    PPctCertificate pClientCert;

    // Server Side Client Auth related items
    /* HLOCATOR */
    HLOCATOR            hLocator;

#ifdef DEBUG
    DWORD DebugId;
#endif // DEBUG;
} SessCacheItem, *PSessCacheItem;

extern DWORD g_dwCacheMaxSize;
extern DWORD g_dwExpireTime;



/* SPInitSessionCache() */
SP_STATUS SPInitSessionCache(VOID);

// Shutdown cache.
SP_STATUS SPShutdownSessionCache(VOID);

// Reference and dereference cache items
LONG SPCacheReference(SessCacheItem *pItem);

LONG SPCacheDereference(SessCacheItem *pItem);



/* Retrieve item from cache by SessionID.
 * Auto-Reference the item if successful */
BOOL SPCacheRetrieveBySession(
                         DWORD fProtocol,
                         PUCHAR SessionID,
                         DWORD cbSessionID,
                         PSessCacheItem *ppRetItem
                        );

/* Retrieve item from cache by ID.
 * Auto-Reference the item if successful */
BOOL SPCacheRetrieveByName(
                         DWORD Protocol,
                         PCHAR szName,
                         PSessCacheItem *ppRetItem
                        );

/* find an empty cache item for use by a context */
BOOL
SPCacheRetrieveNew(
                   PUCHAR pszTarget,
                   PSessCacheItem *ppRetItem
                  );

/* Locks a recently retrieved item into the cache */
BOOL SPCacheAdd(
                   SessCacheItem *pItem
                );

BOOL
SPCacheClone(PSessCacheItem *ppItem);

#define DEF_EXPIRE_TIME     100 * 1000
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\cert.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/

#include <stdlib.h>
#include <spbase.h>
#include <ssl2msg.h>
#include <ssl3msg.h>
#include <wincrypt.h>

const BYTE g_DER_OID_SERVER_GATED_CRYPTO[] = //1.3.6.1.4.1.311.10.3.3
    {0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x0a, 0x03, 0x03};
const BYTE g_DER_OID_NETSCAPE_SGC[] = //2.16.840.1.113730.4.1
    {0x60, 0x86, 0x48, 0x01, 0x86, 0xf8, 0x42, 0x04, 0x01};
extern PPctCertificate g_pGenevaRoot, g_pVerisign3Root;

SP_STATUS
SPLoadCertificate(
    DWORD      fProtocol,
    CertSpec   Spec,
    PUCHAR     pCertificate,
    DWORD      cbCertificate,
    PPctCertificate *ppCert,
    DWORD       *pdwSGC          // out,optional: 1 if SGC enabled
    )
{

    SP_STATUS           pctRet;
    PPctCertificate pResult, pThis, pChild;
    const CertSystem *  pCertSys = NULL;
    SignatureSystem *   pSigSys = NULL;
    PUCHAR pCurrentRaw;
    LONG cbCurrentRaw;

    pCertSys = CertFromSpec(Spec, fProtocol);

    if(ppCert == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(pCertSys == NULL)
    {
        return  SP_LOG_RESULT(PCT_INT_BAD_CERT);
    }


    // Dereference the cert that we are replacing.
    if (*ppCert)
    {
        DereferenceCert(*ppCert);
        *ppCert = NULL;
    }
    if (pdwSGC)
        *pdwSGC = 0;

    pResult = NULL;
    pChild = NULL;
    pCurrentRaw = pCertificate;
    cbCurrentRaw = cbCertificate;
    pctRet = PCT_ERR_BAD_CERTIFICATE;

    do {
        if(fProtocol & SP_PROT_SSL3)
        {
            // SSL3 style cert chain, where the length
            // of earch cert is prepended.
            pCurrentRaw += 3;
            cbCurrentRaw -= 3;
        }

        if(!pCertSys->Decode(pCurrentRaw,
                             cbCurrentRaw,
                             &pThis))
        {
            if (pResult)
            {
                DereferenceCert(pResult);
            }
            return SP_LOG_RESULT(PCT_ERR_BAD_CERTIFICATE);
        }
        // We successfully loaded this cert,
        // so move our pointers to the next cert
        // raw data.
        pCurrentRaw += pThis->cbRawCert;
        cbCurrentRaw -= pThis->cbRawCert;

        // Verify this certificates child with this certificate.
        if(pChild)
        {
            const SignatureSystem     *pSigSys = NULL;
            pSigSys = SigFromSpec(pChild->SigType, SP_PROT_ALL);
            if(pSigSys == NULL)
            {
                if (pThis) DereferenceCert(pThis);
                if (pResult) DereferenceCert(pResult);
                return SP_LOG_RESULT(PCT_ERR_BAD_CERTIFICATE);
            }


            if(!pSigSys->Verify(pChild->pSignedPortion,
                                pChild->cbSignedPortion,
                                pChild->pSig,
                                pChild->cbSig,
                                pThis->pPublicKey))
            {
                if (pThis) DereferenceCert(pThis);
                if (pResult) DereferenceCert(pResult);
                return SP_LOG_RESULT(PCT_ERR_BAD_CERTIFICATE);
            }
        }
        // We successfully loaded and verified, so
        // move on to the next cert in the chain.
        if(pChild)
        {
            pChild->pIssuerCertificate = pThis;
        }
        else
        {
            pResult = pThis;
        }
        pChild = pThis;
        // We've run off the end of our cert list without
        // Successfully finding a CA, so this chain is
        // unverified.
        if(cbCurrentRaw <= 0)
        {
            break;
        }
    } while(pThis->pIssuerCertificate == NULL);

    // Verify the last certificate against the root
    // certificate
    if(pThis->pIssuerCertificate)
    {
        const SignatureSystem     *pSigSys = NULL;
        BOOL fGenevaRoot = FALSE;
        BOOL fVerisign3Root = FALSE;
        pSigSys = SigFromSpec(pThis->SigType, SP_PROT_ALL);
        if(pSigSys == NULL)
        {
            if (pResult) DereferenceCert(pResult);
            return SP_LOG_RESULT(PCT_ERR_BAD_CERTIFICATE);
        }
        if(!pSigSys->Verify(pThis->pSignedPortion,
                            pThis->cbSignedPortion,
                            pThis->pSig,
                            pThis->cbSig,
                            pThis->pIssuerCertificate->pPublicKey))
        {
            if (pResult) DereferenceCert(pResult);
            return SP_LOG_RESULT(PCT_ERR_BAD_CERTIFICATE);
        }
        // check for special Server Gated Crypto root issuers
        while (pThis && pThis->pIssuerCertificate != pThis)
            pThis = pThis->pIssuerCertificate;

        if (g_pVerisign3Root && pThis == g_pVerisign3Root)
            fVerisign3Root = TRUE;
        else if (g_pGenevaRoot && pThis == g_pGenevaRoot)
            fGenevaRoot = TRUE;
            
        // check for Server Gated Crypto OIDs
        if ( pdwSGC && (fVerisign3Root || fGenevaRoot) && pResult->pEnhancedKeyUsage)
        {
            UINT i;
            for (i = 0; i < pResult->pEnhancedKeyUsage->cObjIds; i++)
            {
                ObjIdDesc *poid = &pResult->pEnhancedKeyUsage->aObjIds[i];
                if (poid->cbObjId == sizeof(g_DER_OID_NETSCAPE_SGC)
                    && memcmp(poid->pbObjId,g_DER_OID_NETSCAPE_SGC,sizeof(g_DER_OID_NETSCAPE_SGC)) == 0
                    )
                {
                    if (fVerisign3Root)
                    {
                        (*pdwSGC) |= 1;
                          DEBUGMSG(ZONE_CERT,(TEXT("SPLoadCertificate: NETSCAPE SGC\r\n")));
                    }
                }
                else if (poid->cbObjId == sizeof(g_DER_OID_SERVER_GATED_CRYPTO)
                    && memcmp(poid->pbObjId,g_DER_OID_SERVER_GATED_CRYPTO,sizeof(g_DER_OID_SERVER_GATED_CRYPTO)) == 0
                    )

                {
                    if (fVerisign3Root || fGenevaRoot)
                    {
                        (*pdwSGC) |= 1;
                          DEBUGMSG(ZONE_CERT,(TEXT("SPLoadCertificate: MS SGC\r\n")));
                    }
                }
            }
        }
    }


    *ppCert = pResult;

    return PCT_ERR_OK;

}


SP_STATUS
SPSerializeCertificate(
    DWORD      fProtocol,
    PUCHAR *   ppCertificate,
    DWORD  *   pcbCertificate,
    PPctCertificate pCert
)
{
    PPctCertificate pThisCert;
    DWORD cbCert;
    PUCHAR pByte;

    pThisCert = pCert;
    cbCert = 0;
    if(pcbCertificate == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }
    // First calculate the size
    while(pThisCert != NULL)
    {
        cbCert += pThisCert->cbRawCert;
        if(fProtocol & SP_PROT_SSL3)
        {
            cbCert += CB_SSL3_CERT_VECTOR;
        }
        // Is this cert self signed?
        if(pThisCert == pThisCert->pIssuerCertificate)
        {
            break;
        }
        pThisCert = pThisCert->pIssuerCertificate;
    }

    //cbCert now contains the number of bytes
    if(ppCertificate == NULL)
    {
        *pcbCertificate = cbCert;
        return (PCT_ERR_OK);
    }
    if(*ppCertificate == NULL)
    {
        *ppCertificate = (PUCHAR)SPExternalAlloc(cbCert);
        if(*ppCertificate == NULL)
        {
            return SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY);
        }
    }
    pThisCert = pCert;
    pByte = *ppCertificate;
    while(pThisCert != NULL)
    {
        if(fProtocol & SP_PROT_SSL3)
            {
		    pByte[0] = MS24BOF(pThisCert->cbRawCert);
		    pByte[1] = MSBOF(pThisCert->cbRawCert);
		    pByte[2] = LSBOF(pThisCert->cbRawCert);
		    pByte += CB_SSL3_CERT_VECTOR;
        }
        CopyMemory(pByte, pThisCert->pRawCert,pThisCert->cbRawCert);
        pByte += pThisCert->cbRawCert;
        // Is this cert self signed?
        if(pThisCert == pThisCert->pIssuerCertificate)
        {
            break;
        }
        pThisCert = pThisCert->pIssuerCertificate;
    }
    *pcbCertificate = cbCert;

    return(PCT_ERR_OK);
}


LONG
ReferenceCert(PPctCertificate pCert)
{
    if(pCert == NULL)
    {
        DEBUGMSG(ZONE_CERT,
                (TEXT("ReferenceCert(NULL).\r\n"))
                );

        return -1;
    }
    DEBUGMSG(ZONE_CERT,
            (TEXT("ReferenceCert(%d),   cRef = %d->%d\r\n"),
             pCert->dwDebugId,
             pCert->cRef,
             pCert->cRef + 1)
            );

    return InterlockedIncrement(&pCert->cRef);
}

LONG
DereferenceCert(PPctCertificate pCert)
{
    LONG cRet;
    PCertSysInfo pInfo;

    if(pCert == NULL)
    {
        DEBUGMSG(ZONE_CERT,
                (TEXT("DereferenceCert(NULL).\r\n"))
                );

        return -1;
    }

    DEBUGMSG(ZONE_CERT,
            (TEXT("DereferenceCert(%d), cRef = %d->%d.\r\n"),
             pCert->dwDebugId,
             pCert->cRef,
             pCert->cRef - 1)
            );

    if(0 == (cRet = InterlockedDecrement(&pCert->cRef)))
    {
        pInfo = GetCertSysInfo(pCert->Spec);
        if(pInfo == NULL)
        {
            return -1;
        }
        if(!pInfo->System->Delete(pCert))
        {
            return -1;
        }
        return 0;
    }
    return (cRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\cert.h ===
/*+----------------------------------------------------------------------------
// Copyright (C) Microsoft Corporation, 1995 - 1996.
// All rights reserved.
//
// This file is part of the Microsoft Private Communication Technology
// reference implementation, version 1.0
//
// The Private Communication Technology reference implementation, version 1.0
// ("PCTRef"), is being provided by Microsoft to encourage the development and
// enhancement of an open standard for secure general-purpose business and
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/

#define SERIALNUMBER_LENGTH 16


#ifdef DEBUG
    extern DWORD g_cPctCertDebugIds;
#endif // DEBUG

typedef struct 
{
    UINT cbObjId;    // size of encoded object id
    PBYTE pbObjId;    // points to encoded object id
} ObjIdDesc;

typedef struct
{
    UINT cObjIds;    // count of ObjIdDesc structs in array
    ObjIdDesc aObjIds[1];
} EnhancedKeyUsage;

typedef struct PctCertificate {
#ifdef DEBUG
    DWORD           dwDebugId;
#endif // DEBUG
    long            cRef;       // Reference Count.
    CertSpec        Spec;

    PctPublicKey    *pPublicKey;

    SigSpec         SigType;
    DWORD           cbSig;
    PUCHAR          pSig;
    BOOL            fTrusted;

    struct PctCertificate  *pIssuerCertificate;

    PUCHAR          szSigningAuthority;

    PBYTE           pbIssuer;
    DWORD           cbIssuer;

    PBYTE           pbSubject;
    DWORD           cbSubject;

	PUCHAR          pSignedPortion;
	DWORD           cbSignedPortion;

    FILETIME        ValidFrom;
    FILETIME        ValidUntil;

    PUCHAR          pRawPubKey;
    DWORD           cbRawPubKey;

    PUCHAR          pRawCert;
    DWORD           cbRawCert;

    PUCHAR          pszSubject;
    PUCHAR          pCert;
	EnhancedKeyUsage *pEnhancedKeyUsage;	// list of OIDs
} PctCertificate, * PPctCertificate;


typedef BOOL
(WINAPI *CertDecodeFn)(
    PUCHAR               pbCertificate,
    DWORD               cbCertificate,
    PPctCertificate *  ppCertificate);

typedef BOOL
(WINAPI *CertDeleteFn)(
    PPctCertificate   pCertificate);

typedef struct _CertSystem {
     CertSpec      Spec;
     CertDecodeFn  Decode;
     CertDeleteFn  Delete;
} CertSystem, *PCertSystem;

extern const CertSystem certX509;

LONG ReferenceCert(PPctCertificate pCert);
LONG DereferenceCert(PPctCertificate);

SP_STATUS
SPLoadCertificate(
    DWORD      fProtocol,
    CertSpec   Spec,
    PUCHAR     pCertificate,
    DWORD      cbCertificate,
    PPctCertificate *ppCert,
    PDWORD      pdwSGC
    );

SP_STATUS
SPSerializeCertificate(
    DWORD      fProtocol,
    PUCHAR *   ppCertificate,
    DWORD  *   pcbCertificate,
    PPctCertificate pCert
);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\bulk.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/

#include "spbase.h"


/* optimized hash startup code.  This prevents a bunch of allocations
 * whenever we need to hash something.
 */

void CloneHashBuf(HashBuf Buf,
                  PCheckSumBuffer HashState,
                  const CheckSumFunction *Hashfn
                  )
{
    CopyMemory((UCHAR *)Buf, (UCHAR *)HashState, Hashfn->cbBufferSize);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\bulk.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
* RSA Public Key Cryptosystem, RC4, MD2, MD5 and RSA are trademarks
* of RSA Data Security, Inc.
*----------------------------------------------------------------------------*/

#ifndef __BULK_H__
#define __BULK_H__



typedef PVOID   PStateBuffer;

typedef
BOOL
(WINAPI * CryptInitializeFn)(
    PUCHAR          pbKey,
    DWORD           cbKey,
    PStateBuffer *  ppBuffer);

typedef
SP_STATUS
(WINAPI * CryptEncryptFn)(
    PStateBuffer    pBuffer,
    PSPBuffer      pEncrypted,
    PSPBuffer      pClean);

typedef
SP_STATUS
(WINAPI * CryptDecryptFn)(
    PStateBuffer    pBuffer,
    PSPBuffer      pEncrypted,
    PSPBuffer      pClean);

typedef
BOOL
(WINAPI * CryptDiscardFn)(
    PStateBuffer *  ppBuffer);

typedef struct _CryptoSystem {
    DWORD               Type;
    DWORD               BlockSize;
    PSTR                pszName;
    CryptInitializeFn   Initialize;
    CryptEncryptFn      Encrypt;
    CryptDecryptFn      Decrypt;
    CryptDiscardFn      Discard;
} CryptoSystem, * PCryptoSystem;


typedef void * PCheckSumBuffer;


typedef
BOOL
(WINAPI * SumInitializeFn)(
    PCheckSumBuffer     pBuffer,
    DWORD               Flags);

typedef
BOOL
(WINAPI * SumSumFn)(
    PCheckSumBuffer     pBuffer,
    DWORD               cbData,
    PUCHAR              pbData);

typedef
BOOL
(WINAPI * SumFinalizeFn)(
    PCheckSumBuffer     pBuffer,
    PUCHAR              pFinalSum);



typedef struct _CheckSumFunction {
    ULONG           Type;
    ULONG           cbCheckSum;
    ULONG	        cbBufferSize;
    PSTR            pszName;
    SumInitializeFn Initialize;
    SumSumFn        Sum;
    SumFinalizeFn   Finalize;
} CheckSumFunction, * PCheckSumFunction;

#define MAX_HASHBUF_LEN		256

typedef UCHAR	HashBuf[MAX_HASHBUF_LEN];

void CloneHashBuf(HashBuf Buf,
		  PCheckSumBuffer HashState,
		  const CheckSumFunction *Hashfn
		  );


/* instantiations of systems */


extern const CryptoSystem  csRC4;
extern const CryptoSystem  csNONE;
extern const CheckSumFunction ckMD5;
extern const CheckSumFunction ckSHA;

#endif /* __BULK_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\cert509.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
* RSA Public Key Cryptosystem, RC4, MD2, MD5 and RSA are trademarks
* of RSA Data Security, Inc.
*----------------------------------------------------------------------------*/

#include <spbase.h>
#include "cert509.h"


#ifdef DEBUG
DWORD g_cPctCertDebugIds = 0;
#endif // DEBUG

const BYTE g_DER_OID_EnhancedKeyUsage[] = {0x55, 0x1d, 0x25};	//2.5.29.37

#ifdef DEBUG
// Convert the object id to dot format and dump it
void
DumpOid(PBYTE pbObjId, UINT cbObjId)
{
    TCHAR szDumpBuf[128];   // should be long enough
    int i;
    if (!cbObjId)
        return;

    i = wsprintf(szDumpBuf,TEXT(" %d.%d"),(*pbObjId)/40, (*pbObjId)%40);
    --cbObjId;
    while (cbObjId)
    {
        UINT value = 0;
        do
        {
            ++pbObjId;
            --cbObjId;
            value = (value << 7) + ((*pbObjId) & 0x7f);
        }
        while (*pbObjId & 0x80);

        i += wsprintf(&szDumpBuf[i], TEXT(".%d"), value);

    }
    DEBUGMSG(ZONE_CERT,
                (TEXT("%s"),
                 szDumpBuf)
                );
   
}
#endif

BOOL WINAPI
X509DecodeCertificate(
    PUCHAR              pbCertificate,
    DWORD               cbCertificate,
    PPctCertificate *   ppCertificate)
{
    DWORD   cbCertInfo;
    PUCHAR  pCertInfo;
    PUCHAR  pbCert;
    int     Result;
    EnhancedKeyUsage *peku = NULL;
//    PUCHAR  SignedPortion;

    DWORD   cCurCert;

    PX509Certificate    pCertificate;
    const KeyExchangeSystem *pSys = NULL;
    DWORD       PubKeyAlg;
    PUCHAR      PubKeyBuffer;
    DWORD       SigAlg;

    DWORD       dwLength;


    DWORD       dwIssuerOffset;
    DWORD       dwSubjectOffset;
    DWORD       dwSignedOffset;
    DWORD       cbIssuer;
    DWORD       cbSubject;

    SP_BEGIN("X509DecodeCertificate");
    *ppCertificate = NULL;
    pbCert = pbCertificate;
    cCurCert = cbCertificate;


    cCurCert -= Result = DecodeHeader(&cbCertInfo, pbCert, cCurCert);
    if (Result < 0)
    {
        DebugLog((DEB_WARN, "Initial header wrong\n"));
        SP_RETURN(FALSE);
    }

    pCertInfo = pbCert + Result;
    dwSignedOffset = Result;
    cbCertInfo += Result;  // This is the complete length of the cert.


    /* Break Out certificate info */


    cCurCert -= Result = DecodeHeader(&dwLength, pCertInfo, cCurCert);
    if (Result < 0)
    {
        DebugLog((DEB_WARN, "Cert Data header wrong\n"));
        SP_RETURN(FALSE);
    }

    pCertificate = (PX509Certificate)SPExternalAlloc(sizeof(X509Certificate) );
    if (!pCertificate)
    {
        SP_RETURN(FALSE);
    }

    pCertInfo += Result;

    if (0xa0 == *pCertInfo)
    {
        pCertInfo += 1; // Skip the [0] tag.
        cCurCert -= 1;
        cCurCert -= Result = DecodeLength(&dwLength, pCertInfo, cCurCert);
        if (Result < 0)
        {
            DebugLog((DEB_WARN, "Bad Version Number in certificate\n"));
            goto Crack_CleanUp;
        }
        pCertInfo += Result;

        DebugLog((DEB_TRACE, "%3d:Decoding Version\n", cCurCert-cbCertificate));
        cCurCert -= Result = DecodeInteger( (BYTE *) &pCertificate->Version,
                                sizeof(pCertificate->Version),
                                &dwLength,
                                pCertInfo,
                                cCurCert,
                                TRUE );

        if (Result < 0)
        {
            DebugLog((DEB_WARN, "Bad Version Number in certificate\n"));
            goto Crack_CleanUp;
        }
        pCertInfo += Result;
    }

    DebugLog((DEB_TRACE, "%3d:Decoding Serial Number\n", cCurCert-cbCertificate));
    cCurCert -= Result = DecodeInteger( (BYTE *) pCertificate->SerialNumber,
                            sizeof(pCertificate->SerialNumber),
                            &dwLength,
                            pCertInfo,
                            cCurCert,
                            TRUE );

    if (Result < 0)
    {
        DebugLog((DEB_WARN, "No Serial Number in certificate\n"));
        goto Crack_CleanUp;
    }

    pCertInfo += Result;

    DebugLog((DEB_TRACE, "%3d:Decoding Algorithm\n", cCurCert-cbCertificate));
    cCurCert -= Result = DecodeSigAlg(&SigAlg,
                                pCertInfo, cCurCert,
                                TRUE);

    if (Result < 0)
    {
        DebugLog((DEB_WARN, "Algorithm has non-null parameters!\n"));
        goto Crack_CleanUp;
    }

    pCertInfo += Result;

    dwIssuerOffset = (DWORD)pCertInfo-(DWORD)pbCertificate;

    Result = DecodeDN( NULL, &dwLength, pCertInfo, cCurCert, FALSE);
    if (Result < 0)
    {
        DebugLog((DEB_WARN, "No issuer name in certificate\n"));
        goto Crack_CleanUp;
    }

    cbIssuer = Result;

    pCertificate->pszIssuer = (PSTR)SPExternalAlloc(dwLength + 2);
    if (!pCertificate->pszIssuer)
    {
        DebugLog((DEB_WARN, "Out of memory\n"));
        goto Crack_CleanUp;
    }

    DebugLog((DEB_TRACE, "%3d:Decoding Issuer\n", cCurCert-cbCertificate));
    cCurCert -= Result = DecodeDN(pCertificate->pszIssuer,
                        &dwLength,
                        pCertInfo, cCurCert,
                        TRUE);
    pCertInfo += Result;

    cCurCert -= Result = DecodeHeader(&dwLength, pCertInfo, cCurCert);
    if (Result < 0)
    {
        DebugLog((DEB_WARN, "Header for Validity times not found\n"));
        goto Crack_CleanUp;
    }

    DebugLog((DEB_TRACE, "%3d:Decoding From Time\n", cCurCert-cbCertificate));
    pCertInfo += Result;
    cCurCert -= Result = DecodeFileTime(&pCertificate->ValidFrom,
                            pCertInfo, cCurCert,
                            TRUE);

    if (Result < 0)
    {
        DebugLog((DEB_WARN, "Valid from not found\n"));
        goto Crack_CleanUp;
    }

    DebugLog((DEB_TRACE, "%3d:Decoding Until Time\n", cCurCert-cbCertificate));
    pCertInfo += Result;
    cCurCert -= Result = DecodeFileTime(&pCertificate->ValidUntil,
                            pCertInfo, cCurCert,
                            TRUE);

    if (Result < 0)
    {
        DebugLog((DEB_WARN, "Valid until not found\n"));
        goto Crack_CleanUp;
    }

    pCertInfo += Result;

    dwSubjectOffset = (DWORD)pCertInfo-(DWORD)pbCertificate;

    Result = DecodeDN(NULL, &dwLength, pCertInfo, cCurCert, FALSE);

    if (Result < 0)
    {
        DebugLog((DEB_WARN, "Subject name not found\n"));
        goto Crack_CleanUp;
    }

    cbSubject = Result;

    pCertificate->pszSubject = (PSTR)SPExternalAlloc(dwLength + 2);

    if (!pCertificate->pszSubject)
    {
        DebugLog((DEB_WARN, "Out of memory\n"));
        goto Crack_CleanUp;
    }

    DebugLog((DEB_TRACE, "%3d:Decoding Subject\n", cCurCert-cbCertificate));
    cCurCert -= Result = DecodeDN(  pCertificate->pszSubject,
                        &dwLength,
                        pCertInfo, cCurCert,
                        TRUE);

    if (Result < 0)
    {
        DebugLog((DEB_WARN, "Could not decode DN of subject\n"));
        goto Crack_CleanUp;
    }

    DebugLog((DEB_TRACE, "Subject: %s\n", pCertificate->pszSubject));


    pCertInfo += Result;


    /* Now, get subjectPublicKeyInfo */


    cCurCert -= Result = DecodeHeader(&dwLength, pCertInfo, cCurCert);
    if (Result < 0)
    {
        DebugLog((DEB_WARN, "No header for pubkey\n"));
        goto Crack_CleanUp;
    }

    pCertInfo += Result;

    DebugLog((DEB_TRACE, "%3d:Get Pubkey Alg\n", cCurCert-cbCertificate));
    cCurCert -= Result = DecodeKeyType(&PubKeyAlg,
                             pCertInfo, cCurCert,
                             TRUE);

    if (Result < 0)
    {
        DebugLog((DEB_WARN, "No algorithm\n"));
        goto Crack_CleanUp;
    }

    pCertInfo += Result;

    DebugLog((DEB_TRACE, "%3d:Get Pubkey\n", cCurCert-cbCertificate));
    Result = DecodeBitString(NULL, &dwLength, pCertInfo, cCurCert, FALSE);
    if (Result < 0)
    {
        DebugLog((DEB_WARN, "No pubkey bitstring\n"));
        goto Crack_CleanUp;
    }

    PubKeyBuffer = (PUCHAR)SPExternalAlloc(dwLength);
    if (!PubKeyBuffer)
    {
        DebugLog((DEB_WARN, "Out of memory\n"));
        goto Crack_CleanUp;
    }

    cCurCert -= Result = DecodeBitString(PubKeyBuffer, &dwLength, pCertInfo, cCurCert, TRUE);
    DebugLog((DEB_TRACE, "Filled Bit Buffer with %d bytes\n",dwLength));
    pCertInfo += Result;

    pCertificate->pPublicKey = NULL;
    DebugLog((DEB_TRACE, "Looking for decode method for algid %lx\n", PubKeyAlg));

    pSys =  KeyExchangeFromSpec(PubKeyAlg, SP_PROT_CRED);
    if(pSys == NULL) goto Crack_CleanUp;
    if( 0 > pSys->DecodePublic(PubKeyBuffer, dwLength, &pCertificate->pPublicKey))
    {
        goto Crack_CleanUp;
    }

    if(pCertificate->pPublicKey == NULL) goto Crack_CleanUp;

    //
    // Suck up  optional X.509 V2 fields:
    //  issuerUniqueId and subjectUniqueId
    //

    while (0xa1 == (*pCertInfo) || 0xa2 == (*pCertInfo))
    {
        pCertInfo += 1; // Skip the tag.
        cCurCert -= 1;
        cCurCert -= Result = DecodeLength(&dwLength, pCertInfo, cCurCert);
        if (Result < 0)
        {
            DebugLog((DEB_WARN, "Bad optional field in certificate\n"));
            goto Crack_CleanUp;
        }
        DebugLog((DEB_TRACE, "%4x:Skipping (%d)\n", cbCertificate-cCurCert, dwLength));
        pCertInfo += Result + dwLength;
        cCurCert -= dwLength;   // georgej added
    }

    // look at the extensions
    if (cCurCert > 0 && 0xa3 == *pCertInfo) {
        DWORD cbExtensions;
        pCertInfo += 1;    // skip the tag
        cCurCert -= 1;
        cCurCert -= Result = DecodeLength(&dwLength, pCertInfo, cCurCert);
        if (Result < 0)
        {
            DebugLog((DEB_WARN, "Bad extensions header in certificate\n"));
            goto Crack_CleanUp;
        }
        pCertInfo += Result;
        // skip past Extensions header (SEQ OF)
        cCurCert -= Result = DecodeHeader(&dwLength, pCertInfo, cCurCert);
        if (Result < 0)
        {
            DebugLog((DEB_WARN, "Bad extensions header in certificate\n"));
            goto Crack_CleanUp;
        }
        pCertInfo += Result;
        cbExtensions = dwLength;
        while (cbExtensions)
        {
            CertExtension certExt;
            cCurCert -= Result = DecodeExtension(&certExt, pCertInfo, cbExtensions);
            if (Result < 0)
            {
                DebugLog((DEB_WARN, "Bad extension field in certificate\n"));
                goto Crack_CleanUp;
            }
            pCertInfo += Result;
            cbExtensions -= Result;
#ifdef DEBUG
            
            DumpOid(certExt.pExtId, certExt.cbExtId);

            DEBUGMSG(ZONE_CERT,
                    (TEXT(" extn length %d.\r\n"),
                     certExt.cbValue)
                    );
#endif
            // is this an extension we're interested in?
            if (certExt.cbExtId == sizeof(g_DER_OID_EnhancedKeyUsage)
                && memcmp(certExt.pExtId, g_DER_OID_EnhancedKeyUsage, certExt.cbExtId) == 0)
            {
                // decode the Enhanced Key Usage extension
                // will allocate memory for EnhancedKeyUsage struct and oids
                
                if (DecodeEnhancedKeyUsage(&peku, certExt.pbValue, certExt.cbValue) < 0)
                {
                    DebugLog((DEB_WARN, "Error decoding Enhanced Key Usage\n"));
                }
#ifdef DEBUG
                else
                {
                    UINT i;
                    DEBUGMSG(ZONE_CERT,(TEXT("Enhanced Key Usage objIds\r\n")));
                    for (i=0;i<peku->cObjIds;i++)
                    {
                        DumpOid(peku->aObjIds[i].pbObjId, peku->aObjIds[i].cbObjId);
                        DEBUGMSG(ZONE_CERT,(TEXT("\r\n")));
                    }
                }
#endif

            }
            
        }

    }

    *ppCertificate = (PPctCertificate)SPExternalAlloc(sizeof(PctCertificate));
    if (NULL == *ppCertificate)
    {
        DebugLog((DEB_WARN, "Out of memory\n"));
        goto Crack_CleanUp;
    }
#ifdef DEBUG
    (*ppCertificate)->dwDebugId = ++g_cPctCertDebugIds;
#endif // DEBUG
    (*ppCertificate)->fTrusted = FALSE;
    (*ppCertificate)->pRawCert = NULL;
    (*ppCertificate)->pRawPubKey = PubKeyBuffer;
    (*ppCertificate)->cbRawPubKey = dwLength;
    (*ppCertificate)->pCert = (PUCHAR)pCertificate;
    (*ppCertificate)->pszSubject = (PUCHAR)pCertificate->pszSubject;
    (*ppCertificate)->pPublicKey = pCertificate->pPublicKey;
    (*ppCertificate)->pIssuerCertificate = FindIssuerKey(pCertificate->pszIssuer);
    (*ppCertificate)->szSigningAuthority = pCertificate->pszIssuer;
    (*ppCertificate)->ValidFrom = pCertificate->ValidFrom;
    (*ppCertificate)->ValidUntil = pCertificate->ValidUntil;
    (*ppCertificate)->Spec = SP_CERT_X509;

    (*ppCertificate)->cbRawCert = cbCertInfo;
    (*ppCertificate)->pRawCert = (PUCHAR)SPExternalAlloc(cbCertInfo);
    if (NULL == (*ppCertificate)->pRawCert)
    {
        DebugLog((DEB_WARN, "Out of memory\n"));
        goto Crack_CleanUp;
    }
    CopyMemory((*ppCertificate)->pRawCert, pbCertificate, cbCertInfo);
    (*ppCertificate)->cbSignedPortion = ((DWORD)pCertInfo - (DWORD)pbCert) - dwSignedOffset;
    (*ppCertificate)->pSignedPortion = (*ppCertificate)->pRawCert + dwSignedOffset;

    (*ppCertificate)->pbIssuer =(*ppCertificate)->pRawCert + dwIssuerOffset;
    (*ppCertificate)->cbIssuer = cbIssuer;

    (*ppCertificate)->pbSubject =(*ppCertificate)->pRawCert + dwSubjectOffset;
    (*ppCertificate)->cbSubject = cbSubject;
	(*ppCertificate)->pEnhancedKeyUsage = peku;

    DebugLog((DEB_TRACE, "%3d:Get Sig Alg\n", cCurCert-cbCertificate));
    cCurCert -= Result = DecodeSigAlg( &(*ppCertificate)->SigType, pCertInfo, cCurCert, TRUE );
    if (Result < 0)
    {
        DebugLog((DEB_WARN, "No signature algorithm...\n"));
        goto Crack_CleanUp;
    }

    pCertInfo += Result;

    DebugLog((DEB_TRACE, "%3d:Get Signature\n", cCurCert-cbCertificate));
    Result = DecodeBitString(NULL, &dwLength, pCertInfo, cCurCert, FALSE );
    if (Result < 0)
    {
        DebugLog((DEB_WARN, "No signature bitstring?\n"));
        goto Crack_CleanUp;
    }

    (*ppCertificate)->pSig = (PUCHAR)SPExternalAlloc(dwLength);
    (*ppCertificate)->cbSig = dwLength;
    if (!(*ppCertificate)->pSig)
    {
        DebugLog((DEB_WARN, "Out of memory\n"));
        goto Crack_CleanUp;
    }

    cCurCert -= Result = DecodeBitString((*ppCertificate)->pSig, &dwLength, pCertInfo, cCurCert, TRUE );
    DebugLog((DEB_TRACE, "Bytes left (%d)\n", cCurCert, dwLength));

    SPExternalFree(PubKeyBuffer);
    ReferenceCert(*ppCertificate);

#ifdef DEBUG

    {
        SYSTEMTIME stValidFrom;
        SYSTEMTIME stValidUntil;

        FileTimeToSystemTime(&pCertificate->ValidFrom, &stValidFrom);
        FileTimeToSystemTime(&pCertificate->ValidUntil, &stValidUntil);

        DEBUGMSG(ZONE_CERT,
                (TEXT("Certificate %d.\r\n"),
                 (*ppCertificate)->dwDebugId)
                );

        DEBUGMSG(ZONE_CERT,
                (TEXT("Issuer = %hs\r\n"), pCertificate->pszIssuer)
                );

        DEBUGMSG(ZONE_CERT,
                (TEXT("Subject= %hs\r\n"), pCertificate->pszSubject)
                );

        DEBUGMSG(ZONE_CERT,
                (TEXT("\t\tYr\tMo\tDay\tHr\tMin\tSec\tms\r\n"))
                );

        DEBUGMSG(ZONE_CERT,
                (TEXT("From\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\r\n"),
                 stValidFrom.wYear,      stValidFrom.wMonth,
                 stValidFrom.wDayOfWeek, stValidFrom.wDay,
                 stValidFrom.wHour,      stValidFrom.wMinute,
                 stValidFrom.wSecond,    stValidFrom.wMilliseconds)
                );

        DEBUGMSG(ZONE_CERT,
                (TEXT("Until\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\r\n"),
                 stValidUntil.wYear,      stValidUntil.wMonth,
                 stValidUntil.wDayOfWeek, stValidUntil.wDay,
                 stValidUntil.wHour,      stValidUntil.wMinute,
                 stValidUntil.wSecond,    stValidUntil.wMilliseconds)
                );

        DEBUGMSG(ZONE_CERT, (TEXT("\r\n")));

    }

#endif // DEBUG

    SP_RETURN( TRUE );

Crack_CleanUp:

    DebugLog((DEB_WARN, "Error return from CrackCertificate, Cert at %x, current pointer at %x\n",
                pbCertificate, pCertInfo));

    if (NULL != *ppCertificate)
    {
        if (NULL != (*ppCertificate)->pRawCert)
        {
            SPExternalFree((*ppCertificate)->pRawCert);
        }
        SPExternalFree(*ppCertificate);
        *ppCertificate = NULL;
    }

    if (pCertificate->pszSubject)
    {
        SPExternalFree(pCertificate->pszSubject);
    }

    if (pCertificate->pszIssuer)
    {
        SPExternalFree(pCertificate->pszIssuer);
    }
    if (peku)
    {
        SPExternalFree(peku);
    }

    SPExternalFree(pCertificate);

    SP_RETURN(FALSE);


}

BOOL
WINAPI X509DeleteCert(
       PPctCertificate  pCertificate)
{
      PX509Certificate    pX509Cert;

      DEBUGMSG(ZONE_CERT,
              (TEXT("X509DeleteCert(0x%.8X) - DebugId = %d.\r\n"),
               pCertificate,
               pCertificate->dwDebugId)
              );

      SPExternalFree(pCertificate->pPublicKey);
      SPExternalFree(pCertificate->pSig);
      SPExternalFree(pCertificate->pRawCert);
      if (pCertificate->pEnhancedKeyUsage)
      {
          SPExternalFree(pCertificate->pEnhancedKeyUsage);
      }
      
      pX509Cert = (PX509Certificate)pCertificate->pCert;
      if (pX509Cert->pszSubject)
      {
          SPExternalFree(pX509Cert->pszSubject);
      }

      if (pX509Cert->pszIssuer)
      {
          SPExternalFree(pX509Cert->pszIssuer);
      }

      if (pCertificate->pIssuerCertificate)
        DereferenceCert(pCertificate->pIssuerCertificate);
      SPExternalFree(pCertificate->pCert);
      SPExternalFree(pCertificate);
      return TRUE;
}


const CertSystem certX509 = { SP_CERT_X509, X509DecodeCertificate, X509DeleteCert };
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\cert509.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology 
* reference implementation, version 1.0
* 
* The Private Communication Technology reference implementation, version 1.0 
* ("PCTRef"), is being provided by Microsoft to encourage the development and 
* enhancement of an open standard for secure general-purpose business and 
* personal communications on open networks.  Microsoft is distributing PCTRef 
* at no charge irrespective of whether you use PCTRef for non-commercial or 
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without 
* warranty of any kind, either express or implied, including, without 
* limitation, the implied warranties or merchantability, fitness for a 
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out 
* of use or performance of PCTRef remains with you.
* 
* Please see the file LICENSE.txt, 
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
* 
* Please see http://pct.microsoft.com/pct/pct.htm for The Private 
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/ 



#define SERIALNUMBER_LENGTH 16

#define CF_VERIFY_SIG           1
#define CF_CERT_FROM_FILE       2

#define CERT_HEADER_LEN         17


BOOL
CrackCertificate(
    PBYTE               pbCertificate,
    DWORD               cbCertificate,
    PX509Certificate *  ppCertificate);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\certmap.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       certmap.h
//
//  Contents:   CertMapper 
//              Prototypes and structure definitions
//
//  Functions:  CertMapper API
//
//  History:    5/29/96   a-petesk   Created
//
//----------------------------------------------------------------------------

#ifndef __CERTMAP_H__
#define __CERTMAP_H__

#define CERT_FAR
#define CERT_API __stdcall

#ifdef __cplusplus__
extern "C" 
{
#endif //__cplusplus__


// definitions of mapper basic types.

struct _MAPPER_VTABLE;

typedef struct  _HMAPPER
{
    struct _MAPPER_VTABLE *m_vtable;
    DWORD                  m_dwMapperVersion;
    VOID                  *m_Reserved1;   // For schannel use only
}   HMAPPER, *PHMAPPER;

typedef DWORD HLOCATOR, *PHLOCATOR;


LONG WINAPI ReferenceMapper(
    HMAPPER     *phMapper     // in
);

typedef LONG (WINAPI FAR *REF_MAPPER_FN)(
    HMAPPER     *phMapper     // in
);

LONG WINAPI DeReferenceMapper(
    HMAPPER     *phMapper     // in
);

typedef LONG (WINAPI FAR *DEREF_MAPPER_FN)(
    HMAPPER     *phMapper     // in
);


BOOL WINAPI GetIssuerList(
    HMAPPER        *phMapper,           // in
    VOID *          Reserved,           // in
    BYTE *          pIssuerList,       // out
    DWORD *         pcbIssuerList       // out
);

typedef BOOL (WINAPI FAR * GET_ISSUER_LIST_FN)(
    HMAPPER	        *phMapper	,       // in
    VOID *          Reserved,           // in
    BYTE *          pIssuerList,       // out
    DWORD *         pcbIssuerList       // out
);

BOOL WINAPI GetChallenge(
    HMAPPER         *phMapper,          // in
    BYTE *          pAuthenticatorId,   // in
    DWORD           cbAuthenticatorId,  // in
    BYTE *          pChallenge,        // out
    DWORD *         pcbChallenge        // out
);

typedef BOOL (WINAPI FAR * GET_CHALLENGE_FN)(
    HMAPPER	        *phMapper	,           // in
    BYTE *          pAuthenticatorId,   // in
    DWORD           cbAuthenticatorId,  // in
    BYTE *          pChallenge,        // out
    DWORD *         pcbChallenge        // out
);


BOOL WINAPI MapCredential(
    HMAPPER     *phMapper,            // in
    DWORD       dwCredentialType,   // in
    const BYTE *    pbCredential,   // in
    DWORD       cbCredential,       // in
    HLOCATOR *  phLocator           // out
);


typedef BOOL (WINAPI FAR * MAP_CREDENTIAL_FN)(
	HMAPPER		*phMapper,            // in
    DWORD 		dwCredentialType,	// in
    const BYTE *	pbCredential,   // in
	DWORD		cbCredential,		// in
	HLOCATOR *	phLocator           // out
);


BOOL WINAPI CloseLocator(
    HMAPPER  *phMapper,
	HLOCATOR hLocator	//in
);

typedef BOOL (WINAPI FAR * CLOSE_LOCATOR_FN)(
    HMAPPER  *phMapper,
	HLOCATOR hLocator	//in
);


BOOL WINAPI GetAccessToken(
    HMAPPER     *phMapper,
    HLOCATOR    hLocator,   // in
    HANDLE *    phToken     // out
);

typedef BOOL (WINAPI FAR * GET_ACCESS_TOKEN_FN)(
    HMAPPER     *phMapper,
    HLOCATOR    hLocator,   // in
    HANDLE *    phToken     // out
);


typedef struct _MAPPER_VTABLE {
    REF_MAPPER_FN       ReferenceMapper;
    DEREF_MAPPER_FN     DeReferenceMapper;
    GET_ISSUER_LIST_FN  GetIssuerList;
    GET_CHALLENGE_FN    GetChallenge;
    MAP_CREDENTIAL_FN   MapCredential;
    GET_ACCESS_TOKEN_FN GetAccessToken;
    CLOSE_LOCATOR_FN    CloseLocator;	
} MAPPER_VTABLE, *PMAPPER_VTABLE;

#define MAPPER_INTERFACE_VER 0x00000001


#define X509_ASN_CHAIN      0x00000001


typedef struct _MAPPER_BLOB
{
    DWORD   cbBytes;
    BYTE *  pBytes;
} MAPPER_BLOB, *PMAPPER_BLOB;

typedef struct _MAPPER_X509_ASN_CHAIN
{
    DWORD   dwFlags;            // See definitions below

    DWORD   SerialNumber[4];    // Serial number of leaf cert.
    DWORD   cbSubject;
    PBYTE   pSubject;           // DER encoded subject
    DWORD   cbIssuer;
    PBYTE   pIssuer;            // DER encoded base issuer name
    FILETIME        ValidFrom;
    FILETIME        ValidUntil;

    DWORD   cCerts;             // Number of certs in the chain
    MAPPER_BLOB     aCerts[1];  // An array of BLOBS pointing to X509 Certs
} MAPPER_X509_ASN_CHAIN, *PMAPPER_X509_ASN_CHAIN;

// Flag definitions
#define X509_UNKNOWN_ISSUER     0x00000002    // We do not know the root issuer for the chain
#define X509_EXPIRED            0x00000004    // A certificate in the chain has expired


#ifdef __cplusplus__
}
#endif //__cplusplus__

#endif // __CERTMAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\ciphnone.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/
#include <spbase.h>



BOOL
WINAPI
noneInitialize(  PUCHAR          pbKey,
                DWORD           dwOptions,
                PStateBuffer *  psbBuffer);

SP_STATUS
WINAPI
noneEncrypt(     PStateBuffer    psbBuffer,
                PSPBuffer      pInput,
                PSPBuffer      pOutput);

SP_STATUS
WINAPI
noneDecrypt(     PStateBuffer    psbBuffer,
                PSPBuffer      pInput,
                PSPBuffer      pOutput);

BOOL
WINAPI
noneFinish(      PStateBuffer *  psbBuffer);



const CryptoSystem    csNONE = {
    0,
    1,                      /* Blocksize (stream) */
    "None",
    noneInitialize,
    noneEncrypt,
    noneEncrypt,             /* Same operation... */
    noneFinish
    };

/* none implementation */


BOOL
WINAPI
noneInitialize(  PUCHAR          pbKey,
                DWORD           cbKey,
                PStateBuffer *  psbBuffer)
{

    DebugLog((DEB_TRACE, "Initialize NONE\n"));
    *psbBuffer = NULL;
    return(TRUE);
}


SP_STATUS
WINAPI
noneEncrypt(     PStateBuffer    psbBuffer,
                PSPBuffer      pInput,
                PSPBuffer      pOutput)
{

    if (pInput->pvBuffer != pOutput->pvBuffer)
    {
        DebugLog((DEB_WARN, "rc4Encrypt:  Unnecessary MoveMemory, performance hog"));

        if(pInput->cbData > pOutput->cbBuffer)
        {
            return (PCT_INT_BUFF_TOO_SMALL);
        }
        MoveMemory((PUCHAR)pOutput->pvBuffer,
                   (PUCHAR)pInput->pvBuffer,
                   pInput->cbData);
    }
    if(pInput->cbData > pOutput->cbBuffer)
    {
        return (SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    pOutput->cbData = pInput->cbData;

    return(PCT_ERR_OK);
}


BOOL
WINAPI
noneFinish(      PStateBuffer *  psbBuffer)
{

    *psbBuffer = NULL;

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\cliprot.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/


/* TBD: add redo capability? */

#include <spbase.h>
#include <pct1msg.h>
#include <pct1prot.h>
#include <md5.h>
#include <sha.h>
#include <ssl2msg.h>
#include <ssl3msg.h>
#include <ssl2prot.h>


DWORD g_ProtEnabled = SP_PROT_ALL;


const UNICipherMap UniAvailableCiphers[] = {
    // Pct ciphers
    {
        UNI_CK_PCT,
            SP_PROT_PCT1,
            SP_HASH_UNKNOWN,
            SP_CIPHER_UNKNOWN,
            SP_EXCH_UNKNOWN
    },

    {
        SSL_MKFAST(PCT_SSL_CERT_TYPE, MSBOF(SP_CERT_X509), LSBOF(SP_CERT_X509)),
            SP_PROT_PCT1,
            SP_HASH_UNKNOWN,
            SP_CIPHER_UNKNOWN,
            SP_EXCH_UNKNOWN
    },

    {
        SSL_MKFAST(PCT_SSL_HASH_TYPE, MSBOF(SP_HASH_MD5), LSBOF(SP_HASH_MD5)),
            SP_PROT_PCT1,
            SP_HASH_MD5,
            SP_CIPHER_UNKNOWN,
            SP_EXCH_UNKNOWN
    },
    {
        SSL_MKFAST(PCT_SSL_HASH_TYPE, MSBOF(SP_HASH_SHA), LSBOF(SP_HASH_SHA)),
            SP_PROT_PCT1,
            SP_HASH_SHA,
            SP_CIPHER_UNKNOWN,
            SP_EXCH_UNKNOWN
    },

    {
        SSL_MKFAST(PCT_SSL_EXCH_TYPE, MSBOF(SP_EXCH_RSA_PKCS1),  LSBOF(SP_EXCH_RSA_PKCS1)),
            SP_PROT_PCT1,
            SP_HASH_UNKNOWN,
            SP_CIPHER_UNKNOWN,
            SP_EXCH_RSA_PKCS1
    },

    // Domestic Ciphers
    // PCT1
    {
        SSL_MKFAST(PCT_SSL_CIPHER_TYPE_1ST_HALF, MSBOF(SP_CIPHER_RC4>>16), LSBOF(SP_CIPHER_RC4>>16)),
            SP_PROT_PCT1,
            SP_HASH_UNKNOWN,
            SP_CIPHER_RC4 | SP_ENC_BITS_128 | SP_MAC_BITS_128,
            SP_EXCH_UNKNOWN
    },

    {
        SSL_MKFAST(PCT_SSL_CIPHER_TYPE_2ND_HALF, MSBOF(SP_ENC_BITS_128), LSBOF(SP_MAC_BITS_128)),
            SP_PROT_PCT1,
            SP_HASH_UNKNOWN,
            SP_CIPHER_RC4 | SP_ENC_BITS_128 | SP_MAC_BITS_128,
            SP_EXCH_UNKNOWN
    },

    // Ssl3 ciphers (Domestic)
    {
        SSL3_RSA_WITH_RC4_128_MD5,
            SP_PROT_SSL3,
            SP_HASH_MD5 ,
            SP_CIPHER_RC4 | SP_ENC_BITS_128 | SP_MAC_BITS_128,
            SP_EXCH_RSA_PKCS1
    },
    {
        SSL3_RSA_WITH_RC4_128_SHA,
            SP_PROT_SSL3,
            SP_HASH_SHA ,
            SP_CIPHER_RC4 | SP_ENC_BITS_128 | SP_MAC_BITS_128,
            SP_EXCH_RSA_PKCS1
    },

    // Ssl2 ciphers (Domestic)
    {
        SSL_CK_RC4_128_WITH_MD5,
            SP_PROT_SSL2 ,
            SP_HASH_MD5 ,
            SP_CIPHER_RC4 | SP_ENC_BITS_128 | SP_MAC_BITS_128,
            SP_EXCH_RSA_PKCS1
    },

    // FInance Ciphers
    // PCT1
    {
        SSL_MKFAST(PCT_SSL_CIPHER_TYPE_1ST_HALF, MSBOF(SP_CIPHER_RC4>>16), LSBOF(SP_CIPHER_RC4>>16)),
            SP_PROT_PCT1,
            SP_HASH_UNKNOWN,
            SP_CIPHER_RC4 | SP_ENC_BITS_64 | SP_MAC_BITS_128,
            SP_EXCH_UNKNOWN
    },

    {
        SSL_MKFAST(PCT_SSL_CIPHER_TYPE_2ND_HALF, MSBOF(SP_ENC_BITS_64), LSBOF(SP_MAC_BITS_128)),
            SP_PROT_PCT1,
            SP_HASH_UNKNOWN,
            SP_CIPHER_RC4 | SP_ENC_BITS_64 | SP_MAC_BITS_128,
            SP_EXCH_UNKNOWN
    },
    // SSL3
    {
        SSL_RSA_FINANCE64_WITH_RC4_64_MD5,
            SP_PROT_SSL3,
            SP_HASH_MD5 ,
            SP_CIPHER_RC4 | SP_ENC_BITS_64 | SP_MAC_BITS_128,
            SP_EXCH_RSA_PKCS1
    },
    {
        SSL_RSA_FINANCE64_WITH_RC4_64_SHA,
            SP_PROT_SSL3,
            SP_HASH_SHA,
            SP_CIPHER_RC4 | SP_ENC_BITS_64 | SP_MAC_BITS_128,
            SP_EXCH_RSA_PKCS1
    },

    // SSL2
    {
        SSL_CK_RC4_128_FINANCE64_WITH_MD5,
            SP_PROT_SSL2 | SP_PROT_SSL3,
            SP_HASH_MD5 ,
            SP_CIPHER_RC4 | SP_ENC_BITS_64 | SP_MAC_BITS_128,
            SP_EXCH_RSA_PKCS1
    },

    // Export Ciphers
    // PCT1
    {
        SSL_MKFAST(PCT_SSL_CIPHER_TYPE_1ST_HALF, MSBOF(SP_CIPHER_RC4>>16), LSBOF(SP_CIPHER_RC4>>16)),
            SP_PROT_PCT1,
            SP_HASH_UNKNOWN,
            SP_CIPHER_RC4 | SP_ENC_BITS_40 | SP_MAC_BITS_128,
            SP_EXCH_UNKNOWN
    },

    {
        SSL_MKFAST(PCT_SSL_CIPHER_TYPE_2ND_HALF, MSBOF(SP_ENC_BITS_40), LSBOF(SP_MAC_BITS_128)),
            SP_PROT_PCT1,
            SP_HASH_UNKNOWN,
            SP_CIPHER_RC4 | SP_ENC_BITS_40 | SP_MAC_BITS_128,
            SP_EXCH_UNKNOWN
    },

    //SSL3

    {
        SSL3_RSA_EXPORT_WITH_RC4_40_MD5,
            SP_PROT_SSL3,
            SP_HASH_MD5 ,
            SP_CIPHER_RC4 | SP_ENC_BITS_40 | SP_MAC_BITS_128,
            SP_EXCH_RSA_PKCS1
    },


    // SSL2

    {
        SSL_CK_RC4_128_EXPORT40_WITH_MD5,
            SP_PROT_SSL2 ,
            SP_HASH_MD5 ,
            SP_CIPHER_RC4 | SP_ENC_BITS_40 | SP_MAC_BITS_128,
            SP_EXCH_RSA_PKCS1
#if 0
    // SHolden - I was informed that these zero privacy ciphers should be
    //           disabled for both export and domestic.
    },

    // Zero Privacy ciphers
    // SSL3
    {
        SSL3_RSA_WITH_NULL_MD5,
            SP_PROT_SSL3,
            SP_HASH_MD5 ,
            SP_CIPHER_NONE | SP_ENC_BITS_128 | SP_MAC_BITS_128,
            SP_EXCH_RSA_PKCS1
    },
    {
        SSL3_RSA_WITH_NULL_SHA,
            SP_PROT_SSL3,
            SP_HASH_SHA ,
            SP_CIPHER_NONE | SP_ENC_BITS_128 | SP_MAC_BITS_128,
            SP_EXCH_RSA_PKCS1
#endif // 0
    }
};

SP_STATUS WINAPI
GenerateSsl2StyleHello(
    PSPContext              pContext,
    PSPBuffer               pOutput,
    WORD                    fProtocol);


SP_STATUS WINAPI
GenerateHello(
    PSPContext              pContext,
    PSPBuffer               pOutput,
    BOOL                    fCache)
{


    /* Check to see if we can find this target in the cache */


    DWORD           fProt;

    if (!pOutput)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }



    if(fCache)
    {
        // Look this id up in the cache
        SPCacheRetrieveByName(g_ProtEnabled, pContext->RipeZombie->szCacheID, &pContext->RipeZombie);
    }

    // We should have a zombie identity here
    if(pContext->RipeZombie == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    fProt = pContext->RipeZombie->fProtocol & g_ProtEnabled;

    if(SP_PROT_UNI_CLIENT & fProt)
    {
        pContext->State             = UNI_STATE_CLIENT_HELLO;
        pContext->ProtocolHandler   = ClientProtocolHandler;

        return GenerateUniHello(pContext, pOutput, g_ProtEnabled);
    }
#ifdef SCHANNEL_PCT    
    else
    if(SP_PROT_PCT1_CLIENT & fProt)
    {
        pContext->State             = PCT1_STATE_CLIENT_HELLO;
        pContext->ProtocolHandler   = Pct1ClientProtocolHandler;

        return GeneratePct1StyleHello(pContext, pOutput);
    }
#endif

    else
    if(SP_PROT_SSL3_CLIENT & fProt)
    {
        pContext->State             = SSL3_STATE_CLIENT_HELLO;
        pContext->ProtocolHandler   = Ssl3ClientProtocolHandler;

        return GenerateSsl3ClientHello(pContext,  pOutput);
    }

    else
    if(SP_PROT_SSL2_CLIENT & fProt)
    {
        pContext->State             = SSL2_STATE_CLIENT_HELLO;
        pContext->ProtocolHandler   = Ssl2ClientProtocolHandler;

        return GenerateUniHello(pContext, pOutput, SP_PROT_SSL2_CLIENT);
    }
    else
    {
        return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
    }
}


SP_STATUS WINAPI
GenerateUniHelloMessage(
    PSPContext              pContext,
    Ssl2_Client_Hello *     pHelloMessage,
    DWORD                   fProtocol
    )
{
    DWORD                i;
    SP_STATUS pctRet = PCT_INT_INTERNAL_ERROR;
    UCHAR bOffset = 2;
    DWORD                fClientProt = fProtocol & SP_PROT_CLIENTS;

    SP_BEGIN("GenerateUniHello");


    if (!pHelloMessage)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }


    pContext->Flags |= CONTEXT_FLAG_CLIENT;


    pHelloMessage->cCipherSpecs = 0;
    // Generate a cipher list
    //
    for(i=0; i < sizeof(UniAvailableCiphers)/sizeof(UNICipherMap); i++)
    {
        DWORD  fAllowedProt = UniAvailableCiphers[i].fProt & fClientProt;
        if(0 == fAllowedProt)
        {
            continue;
        }
        if((UniAvailableCiphers[i].Hash != SP_HASH_UNKNOWN) &&
           (NULL == HashFromSpec(UniAvailableCiphers[i].Hash, fAllowedProt)))
        {
            continue;
        }

        if((UniAvailableCiphers[i].Cipher != SP_CIPHER_UNKNOWN) &&
           (NULL == CipherFromSpec(UniAvailableCiphers[i].Cipher,
                        fAllowedProt | (pContext->RipeZombie->fSGC ? SP_PROT_SGC : 0))))
        {
            continue;
        }

        if((UniAvailableCiphers[i].KeyExch != SP_EXCH_UNKNOWN) &&
           (NULL == KeyExchangeFromSpec(UniAvailableCiphers[i].KeyExch, fAllowedProt)))
        {
            continue;
        }
        // this cipher is good to request
        pHelloMessage->CipherSpecs[pHelloMessage->cCipherSpecs++] = UniAvailableCiphers[i].CipherKind;

    }


    // We're minimally version 2
    pHelloMessage->dwVer = SSL2_CLIENT_VERSION;



    if(fClientProt & SP_PROT_SSL3_CLIENT)
    {
        pHelloMessage->dwVer = SSL3_CLIENT_VERSION;
    }

   /* Build the hello message. */
    pHelloMessage->cbSessionID = 0;


    if (pContext->RipeZombie && pContext->RipeZombie->cbSessionID)
    {
        CopyMemory(pHelloMessage->SessionID,
                   pContext->RipeZombie->SessionID,
                   pContext->RipeZombie->cbSessionID);

        pHelloMessage->cbSessionID =  pContext->RipeZombie->cbSessionID;
    }

    CopyMemory(  pHelloMessage->Challenge,
                pContext->pChallenge,
                pContext->cbChallenge);
    pHelloMessage->cbChallenge = pContext->cbChallenge;



    SP_RETURN(PCT_ERR_OK);

}


SP_STATUS WINAPI
GenerateUniHello(
    PSPContext             pContext,
    PSPBuffer               pOutput,
    DWORD                   fProtocol
    )

{
    SP_STATUS pctRet;
    Ssl2_Client_Hello    HelloMessage;

    SP_BEGIN("GenerateUniHello");

    GenerateRandomBits( pContext->pChallenge, SSL2_CHALLENGE_SIZE );
    pContext->cbChallenge = SSL2_CHALLENGE_SIZE;

    pctRet = GenerateUniHelloMessage(pContext, &HelloMessage, fProtocol);

    pContext->ReadCounter = 0;

    if(PCT_ERR_OK != pctRet)
    {
        SP_RETURN(pctRet);
    }
    if(PCT_ERR_OK != (pctRet = Ssl2PackClientHello(&HelloMessage,  pOutput)))
    {
        SP_RETURN(pctRet);
    }

    // In case this is a PCT session, save the hello
    // so we can hash it later.

    pContext->pClHello = SPExternalAlloc(pOutput->cbData);
    if(pContext->pClHello == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY));
    }
    CopyMemory(pContext->pClHello, pOutput->pvBuffer, pOutput->cbData);
    pContext->cbClHello = pOutput->cbData;



    // In case of SSL3, do the handshare hash.
	UpdateHandshakeHash(pContext,
                        (PUCHAR)pOutput->pvBuffer + 2,
                        pOutput->cbData - 2,
                        TRUE);
    /* We set this here to tell the protocol engine that we just send a client
     * hello, and we're expecing a pct server hello */

    pContext->WriteCounter = 1;
    pContext->ReadCounter = 0;

    SP_RETURN(PCT_ERR_OK);
}

SP_STATUS WINAPI
ClientProtocolHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput,
    PSPBuffer pAppOutput)
{
    SP_STATUS pctRet = 0;
    PUCHAR pb;
    DWORD dwVersion;

    /* PCTv1.0 Server Hello starts with
     * RECORD_LENGTH_MSB  (ignore)
     * RECORD_LENGTH_LSB  (ignore)
     * PCT1_SERVER_HELLO  (must be equal)
     * SH_PAD
     * PCT1_CLIENT_VERSION_MSB (must be pct1)
     * PCT1_CLIENT_VERSION_LSB (must be pct1)
     *
     * ... PCT hello ...
     */


    /* SSLv2 Hello starts with
     * RECORD_LENGTH_MSB  (ignore)
     * RECORD_LENGTH_LSB  (ignore)
     * SSL2_SERVER_HELLO  (must be equal)
     * SESSION_ID_HIT
     * CERTIFICATE_TYPE
     * SSL2_CLIENT_VERSION_MSB (Must be ssl2)
     * SSL2_CLIENT_VERSION_LSB (Must be ssl2)
     *
     * ... SSLv2 Hello ...
     */


    /* SSLv3 Type 3 Server Hello starts with
     * 0x15 Hex (HANDSHAKE MESSAGE)
     * VERSION MSB
     * VERSION LSB
     * RECORD_LENGTH_MSB  (ignore)
     * RECORD_LENGTH_LSB  (ignore)
     * HS TYPE (SERVER_HELLO)
     * 3 bytes HS record length
     * HS Version
     * HS Version
     */

    // We need at least 5 bytes to determine what we have.
    if (pCommInput->cbData < 7)
    {
        return(PCT_INT_INCOMPLETE_MSG);
    }

    pb = pCommInput->pvBuffer;
    // If the first byte is 0x15, then check if we have a
    // SSLv3 Type3 client hello

    if(pb[0] == SSL3_CT_HANDSHAKE)
    {
        if(!(SP_PROT_SSL3_CLIENT & g_ProtEnabled))
        {
            return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
        }

        // SSLv3 message
        // This appears to be a ssl3 server hello
        pContext->ProtocolHandler = Ssl3ClientProtocolHandler;
        pContext->DecryptHandler = Ssl3DecryptHandler;
        return(Ssl3ClientProtocolHandler(pContext, pCommInput, pCommOutput, pAppOutput));
   }

    if(pb[2] == SSL2_MT_SERVER_HELLO)
    {
        dwVersion = COMBINEBYTES(pb[5], pb[6]);
        if(dwVersion ==SSL2_CLIENT_VERSION)
        {
            if(!(SP_PROT_SSL2_CLIENT & g_ProtEnabled))
            {
                return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
            }
            // This appears to be a ssl2 server hello
            pContext->ProtocolHandler = Ssl2ClientProtocolHandler;
            pContext->DecryptHandler = Ssl2DecryptHandler;
            return(Ssl2ClientProtocolHandler(pContext, pCommInput, pCommOutput, pAppOutput));
        }
    }
#ifdef SCHANNEL_PCT    
    if(pb[2] == PCT1_MSG_SERVER_HELLO)
    {
        DWORD i;
        dwVersion = COMBINEBYTES(pb[4], pb[5]);
        if(dwVersion ==PCT_VERSION_1)
        {
            // Convert challenge from 16 byte to 32 byte
            if(!(SP_PROT_PCT1_CLIENT & g_ProtEnabled))
            {
                return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
            }

            for(i=0; i < pContext->cbChallenge; i++)
            {
                pContext->pChallenge[i + pContext->cbChallenge] = ~pContext->pChallenge[i];
            }
            pContext->cbChallenge = 2*pContext->cbChallenge;
            // This appears to be a ssl2 server hello
            pContext->ProtocolHandler = Pct1ClientProtocolHandler;
            pContext->DecryptHandler = Pct1DecryptHandler;
            return(Pct1ClientProtocolHandler(pContext, pCommInput, pCommOutput, pAppOutput));
        }
    }
#endif    

    return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\ciphrc4.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------
* RSA Public Key Cryptosystem, RC4, MD2, MD5 and RSA are trademarks
* of RSA Data Security, Inc.
*----------------------------------------------------------------------------*/


#include <spbase.h>
#ifdef __cplusplus
extern "C" {
#endif

#include <rc4.h>

#ifdef __cplusplus
}
#endif




BOOL
WINAPI
rc4Initialize(  PUCHAR          pbKey,
                DWORD           dwOptions,
                PStateBuffer *  psbBuffer);

SP_STATUS
WINAPI
rc4Encrypt(     PStateBuffer    psbBuffer,
                PSPBuffer      pInput,
                PSPBuffer      pOutput);

SP_STATUS
WINAPI
rc4Decrypt(     PStateBuffer    psbBuffer,
                PSPBuffer      pInput,
                PSPBuffer      pOutput);

BOOL
WINAPI
rc4Finish(      PStateBuffer *  psbBuffer);

const CryptoSystem    csRC4 = {
    CALG_RC4,
    1,                      /* Blocksize (stream) */
    "RC4",
    rc4Initialize,
    rc4Encrypt,
    rc4Encrypt,             /* Same operation... */
    rc4Finish
    };

/* rc4 implementation */

typedef struct RC4_KEYSTRUCT RC4Key;

BOOL
WINAPI
rc4Initialize(  PUCHAR          pbKey,
                DWORD           cbKey,
                PStateBuffer *  psbBuffer)
{
    RC4Key *    pRC4Key;

    DebugLog((DEB_TRACE, "Initialize RC4\n"));
    pRC4Key = (RC4Key *)SPExternalAlloc(sizeof(RC4Key));

    if (!pRC4Key)
    {
        return(FALSE);
    }

    rc4_key(pRC4Key, cbKey, pbKey);
    *psbBuffer = (PStateBuffer) pRC4Key;
    return(TRUE);
}


SP_STATUS
WINAPI
rc4Encrypt(     PStateBuffer    psbBuffer,
                PSPBuffer      pInput,
                PSPBuffer      pOutput)
{

    if (pInput->pvBuffer != pOutput->pvBuffer)
    {
        DebugLog((DEB_WARN, "rc4Encrypt:  Unnecessary MoveMemory, performance hog\n"));

        if(pInput->cbData > pOutput->cbBuffer)
        {
            return (PCT_INT_BUFF_TOO_SMALL);
        }
        MoveMemory((PUCHAR)pOutput->pvBuffer,
                   (PUCHAR)pInput->pvBuffer,
                   pInput->cbData);
    }
    if(pInput->cbData > pOutput->cbBuffer)
    {
        return (SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    pOutput->cbData = pInput->cbData;

    rc4((RC4Key *) psbBuffer, pOutput->cbData, (PUCHAR)pOutput->pvBuffer);
    return(PCT_ERR_OK);
}


BOOL
WINAPI
rc4Finish(      PStateBuffer *  psbBuffer)
{
    SPExternalFree( *psbBuffer );

    *psbBuffer = NULL;

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\certmap.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology 
* reference implementation, version 1.0
* 
* The Private Communication Technology reference implementation, version 1.0 
* ("PCTRef"), is being provided by Microsoft to encourage the development and 
* enhancement of an open standard for secure general-purpose business and 
* personal communications on open networks.  Microsoft is distributing PCTRef 
* at no charge irrespective of whether you use PCTRef for non-commercial or 
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without 
* warranty of any kind, either express or implied, including, without 
* limitation, the implied warranties or merchantability, fitness for a 
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out 
* of use or performance of PCTRef remains with you.
* 
* Please see the file LICENSE.txt, 
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
* 
* Please see http://pct.microsoft.com/pct/pct.htm for The Private 
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/ 

#include "spbase.h"

INIT_CERT_MAPPER_FN         g_InitCertMapper = NULL;
DELETE_ISSUER_LIST_FN       g_DeleteIssuerList = NULL;
TERMINATE_CERT_MAPPER_FN    g_TerminateCertMapper = NULL;
CERT_MAPPER_FN              g_CertMapper = NULL;
REFRESH_TOKEN_FN            g_RefreshToken = NULL;
CLOSE_TOKEN_HANDLE_FN       g_CloseTokenHandle = NULL;

HINSTANCE g_hCertMapper = NULL;

BOOL 
CERT_API
InitCertMapper(
    IssuerAccepted ** ppIssuer,
    DWORD           * pdwIssuer
    )
{
    DWORD dwSize;
    DWORD err;
    TCHAR pszCertMapperPath[512];
    DWORD dwType;

    dwSize = sizeof(pszCertMapperPath);
    err = RegQueryValueEx(g_hkBase, SP_REG_VAL_CERTMAPPER, NULL, &dwType, (PUCHAR)pszCertMapperPath, &dwSize);
    if(err) {
        return FALSE;
    }


    g_hCertMapper = LoadLibrary(pszCertMapperPath);

    if(g_hCertMapper == NULL)
    {
        return FALSE;
    }

    g_InitCertMapper =      (INIT_CERT_MAPPER_FN)GetProcAddress(g_hCertMapper, INIT_CERT_MAPPER_FN_NAME);
    g_DeleteIssuerList =    (DELETE_ISSUER_LIST_FN)GetProcAddress(g_hCertMapper, DELETE_ISSUER_LIST_FN_NAME);
    g_TerminateCertMapper = (TERMINATE_CERT_MAPPER_FN)GetProcAddress(g_hCertMapper, TERMINATE_CERT_MAPPER_FN_NAME);
    g_CertMapper =          (CERT_MAPPER_FN)GetProcAddress(g_hCertMapper, CERT_MAPPER_FN_NAME);
    g_RefreshToken =        (REFRESH_TOKEN_FN)GetProcAddress(g_hCertMapper, REFRESH_TOKEN_FN_NAME);
    g_CloseTokenHandle =    (CLOSE_TOKEN_HANDLE_FN)GetProcAddress(g_hCertMapper, CLOSE_TOKEN_HANDLE_FN_NAME);


    if(!g_InitCertMapper)
    {
        return FALSE;
    }
    return (*g_InitCertMapper)(ppIssuer, pdwIssuer);
}

BOOL 
CERT_API
DeleteIssuerList(
    IssuerAccepted * pIssuer,
    DWORD dwIssuer
    )
{
    if(g_DeleteIssuerList)
    {
        return (*g_DeleteIssuerList)(pIssuer, dwIssuer);
    }
    return FALSE;
}

BOOL 
CERT_API
TerminateCertMapper(
    VOID
    )
{
    BOOL fResult = FALSE;
    if(g_TerminateCertMapper)
    {
        fResult = (*g_TerminateCertMapper)();

    }
    if(g_hCertMapper)
    {
        FreeLibrary(g_hCertMapper);
    }
    g_InitCertMapper = NULL;
    g_DeleteIssuerList = NULL;
    g_TerminateCertMapper = NULL;
    g_CertMapper = NULL;
    g_RefreshToken = NULL;
    g_CloseTokenHandle = NULL;


    return fResult;
}

BOOL 
CERT_API
CertMapper(
    PCert_Map  pCert,
    DWORD    * pdwUserHandle,
    HANDLE   * phToken,
    LPSTR      pszUserName,
    LPDWORD    pdwNameLen
    )
{
    if(g_CertMapper)
    {
        return (*g_CertMapper)(pCert, pdwUserHandle, phToken, pszUserName, pdwNameLen);
    }
    return FALSE;
}


BOOL 
CERT_API
RefreshToken( 
    DWORD    dwUserHandle, 
    HANDLE * phToken
    )
{
    if(g_RefreshToken)
    {
        return (*g_RefreshToken)(dwUserHandle, phToken);
    }
    return FALSE;
}

BOOL 
CERT_API
CloseTokenHandle( 
    DWORD dwUserHandle
    )
{
    if(g_CloseTokenHandle)
    {
        return (*g_CloseTokenHandle)(dwUserHandle);
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\context.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/

//UNDONE: these are copied from ssl2msg.h God knows why this file is not including any files.
// May be for PCTREF, SO for now, I'm copying these defenitions...
//These defines MAY not change as often as you think, these are from SSL3 SPEC...

#define CB_SSL3_RANDOM		 32
#define CB_SSL3_UNIXTIME	  4
#define CB_SSL3_PRE_MASTER_SECRET  48
#define CB_SSL3_MASTER_KEY_BLOCK    80



#define SP_CONTEXT_MAGIC   *(DWORD *)"!Tcp"

#define CONTEXT_KEY_SIZE    16


typedef struct _SPContext
{
    DWORD               Magic;          /* tags structure */

    DWORD               State;          /* the current state the connection is in */

    DWORD               Flags;

    /* data for the context that can be used
     * to start a new session */
    SessCacheItem *     RipeZombie;   /* cacheable context that is being used  */


    /* credential used when creating context */
    PSPCredential      pCred;
    PctPrivateKey       *pPrivateKey;

    /* virtual function tables to various crypto functions */

    const CryptoSystem      * pSystem;
    const CheckSumFunction  * pCheck;
    const KeyExchangeSystem * pKeyExch;

    /* functions pointing to the various handlers for this protocol */
    SPDecryptMessageFn  Decrypt;
	SPEncryptMessageFn  Encrypt;
    SPProtocolHandlerFn ProtocolHandler;
    SPDecryptHandlerFn  DecryptHandler;
    SPInitiateHelloFn   InitiateHello;

    /* session crypto state */

    // encryption key size.
    DWORD               KeySize;

    // Encryption States
    PStateBuffer        pReadState;     /* keying struct for readkey */
    PStateBuffer        pWriteState;    /* keying struct for writekey */

    // Mac secret values
    UCHAR               ReadMACKey[SP_MAX_MAC_KEY];
    UCHAR               WriteMACKey[SP_MAX_MAC_KEY];

    // MAC states
    HashBuf             InHSHBuf;

    HashBuf             RdMACBuf;
    HashBuf             WrMACBuf;

    PCheckSumBuffer     InitMACState;

    PCheckSumBuffer     ReadMACState;
    PCheckSumBuffer     WriteMACState;


    // Packet Sequence counters.

    DWORD               ReadCounter;
    DWORD               WriteCounter;


    DWORD               cbConnectionID;
    UCHAR               pConnectionID[SP_MAX_CONNECTION_ID];

    DWORD               cbChallenge;
    UCHAR               pChallenge[SP_MAX_CHALLENGE];

    DWORD               cbKeyArgs;
    UCHAR               pKeyArgs[SP_MAX_KEY_ARGS];


    // Save copy of client hello to hash for verification.
    DWORD               cbClHello;      /* length of client hello message */
    PUCHAR              pClHello;       /* points to client hello message */

    CipherSpec	    PendingCiphSpec;
    HashSpec	    PendingHashSpec;
    ExchSpec	    PendingExchSpec;

    // PCT1 specific items.

    HashBuf             pVerifyPrelude; /* running hash to calc VP */

    // SSL3 specific items.

    BOOL				fExchKey; // Did we sent a Exchnage key message
    BOOL				fCertReq; //Did we request a certificate ?? this is for ssl3 Serverside..
    BOOL                fSGC;     // Does the server support Server Gated Crypto
    HashBuf             MD5Handshake;
    HashBuf             SHAHandshake;

    HashBuf             RdMACBuf1;		//SSL3 needs 1 more pre hashed buffers
    PCheckSumBuffer     ReadMACState1;	//SSL3 needs 1 more Pre hashed states.
    HashBuf             WrMACBuf1;		
    PCheckSumBuffer     WriteMACState1;

    PUCHAR              pbIssuerList;
    DWORD               cbIssuerList;

    short				wS3CipherSuiteClient;
    short				wS3CipherSuiteServer;
    short				wS3pendingCipherSuite;
    UCHAR               Ssl3MasterKeyBlock[CB_SSL3_MASTER_KEY_BLOCK];

    UCHAR 				rgbS3CRandom[CB_SSL3_RANDOM];
    UCHAR				rgbS3SRandom[CB_SSL3_RANDOM];

} SPContext, * PSPContext;




/* Flags */
#define CONTEXT_FLAG_CLIENT                 0x00000001
#define CONTEXT_FLAG_CLIAUTH                0x00000100
#define CONTEXT_FLAG_EXT_ERR                0x00000200  /* Generate error message on error */
#define CONTEXT_FLAG_NO_INCOMPLETE_CRED_MSG 0x00000400  /* don't generate an INCOMPLETE CREDS message */
#define CONTEXT_FLAG_CONNECTION_MODE        0x00001000  /* as opposed to stream mode */
#define CONTEXT_FLAG_NOCACHE                0x00001000  /* do not look things up in the cache */



#ifdef DBG
PSTR DbgGetNameOfCrypto(DWORD x);
#endif

void InitHashBuf(HashBuf Buf,
                 PSPContext pContext
                 );

PSTR
CopyString(
           PSTR        pszString);



PSPContext SPContextCreate(PUCHAR pszTarget);

BOOL SPContextDelete(PSPContext pContext);

SP_STATUS
SPContextSetCredentials(
    PSPContext pContext,
    PSPCredential  pCred);


SP_STATUS
ContextInitCiphers(SPContext *pContext);

SP_STATUS
SPContextDoMapping(
    PSPContext pContext);

SP_STATUS
SPContextGetIssuers(
    PSPContext pContext,
    PBYTE pbIssuers,
    DWORD *pcbIssuers);

BOOL FGetServerIssuer(
    PBYTE pbIssuer,	
    DWORD *pdwIssuer);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\context.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("SPRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing SPRef
* at no charge irrespective of whether you use SPRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for SPRef and all derivatives of
* it.  SPRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you SPRef or your modifications.  The entire risk arising out
* of use or performance of SPRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://SP.microsoft.com/SP/SPlicen.txt
* for more information on licensing.
*
* Please see http://SP.microsoft.com/SP/SP.htm for The Private
* Communication Technology Specification version 1.0 ("SP Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/


/* TBD: add redo capability? */

#include <spbase.h>
#include <pct1msg.h>
#include <ssl2msg.h>
#include <pct1prot.h>
#include <ssl2prot.h>
#include <certmap.h>


DWORD g_cContext; // = 0;

/*
 *
 * Creation and Deletion of Context Objects.
 *
 */

/************************************************************************
* SPContext SPCreateContext(void)
*
* Create a new SPContext, and initialize it.
*
* Returns - PSPContext pointer to context object.
*
\***********************************************************************/

PSPContext SPContextCreate(PUCHAR pszTarget)
{

    PSPContext pContext;

    SP_BEGIN("SPCreateContext");

    pContext = (PSPContext)SPExternalAlloc( sizeof(SPContext));
    if(!pContext)
    {
        SP_RETURN(NULL);
    }

    FillMemory(pContext, sizeof(SPContext), 0);

    pContext->Magic = SP_CONTEXT_MAGIC;
    pContext->Flags = 0;
    if(!SPCacheRetrieveNew(pszTarget, &pContext->RipeZombie))
    {
        SPExternalFree(pContext);
        SP_RETURN(NULL);
    }

    g_cContext++;
    SP_RETURN(pContext);
}


/************************************************************************
* VOID SPDeleteContext(PSPContext pContext)
*
* Delete an existing context object.
*
\***********************************************************************/

BOOL
SPContextDelete(PSPContext pContext)
{
    SP_BEGIN("SPDeleteContext");

	if(pContext == NULL || pContext->Magic != SP_CONTEXT_MAGIC) {
		DebugLog((DEB_WARN, "Attempt to delete invalid context\n"));
		SP_RETURN(FALSE);
	}

    if(pContext->pbIssuerList)
    {
        SPExternalFree(pContext->pbIssuerList);
    }

    if (pContext->pReadState)
    {
        pContext->pSystem->Discard( &pContext->pReadState );
    }

    if (pContext->pWriteState)
    {
        pContext->pSystem->Discard( &pContext->pWriteState );
    }

    if (pContext->pClHello)
    {
        SPExternalFree(pContext->pClHello);
    }
    
    SPDereferenceCredential(pContext->pCred);


    SPCacheDereference(pContext->RipeZombie);

    FillMemory( pContext, sizeof( SPContext ), 0 );
    g_cContext--;

    SPExternalFree( pContext );
    SP_RETURN(TRUE);
}



/************************************************************************
* SPContext SPContextSetCredentials
*
* Associate a set of credentials with a context.
*
* Returns - PSPContext pointer to context object.
*
\***********************************************************************/
SP_STATUS
SPContextSetCredentials(
    PSPContext pContext,
    PSPCredential  pCred)
{

    SP_BEGIN("SPContextSetCredentials");

    if(pContext->Magic != SP_CONTEXT_MAGIC)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    // Reference the new credential
    if(pCred)
    {
        if(!SPReferenceCredential(pCred))
        {
            SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
        }
    }

    // Dereference the credential we are replacing.
    if(pContext->pCred)
    {
        SPDereferenceCredential(pContext->pCred);
        pContext->pCred = pCred;
    }
    else
    {
        pContext->pCred = pCred;
        pContext->RipeZombie->fProtocol = pCred->Type;
        switch(pContext->RipeZombie->fProtocol)
        {
            case SP_PROT_UNI_CLIENT:
            case SP_PROT_UNI_SERVER:
            case SP_PROT_PCT1_CLIENT:
            case SP_PROT_PCT1_SERVER:
            case SP_PROT_SSL2_CLIENT:
            case SP_PROT_SSL2_SERVER:
            case SP_PROT_SSL3_CLIENT:
            case SP_PROT_SSL3_SERVER:

                pContext->ProtocolHandler = ServerProtocolHandler;
                pContext->InitiateHello =  GenerateHello;
                break;

            default:
                return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);

        }
    }

    SP_RETURN(PCT_ERR_OK);

}


SP_STATUS
ContextInitCiphers(SPContext *pContext)
{

    SP_BEGIN("ContextInitCiphers");


    if((pContext == NULL) ||
        (pContext->RipeZombie == NULL))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    pContext->pSystem = CipherFromSpec(
                            pContext->RipeZombie->SessCiphSpec,
                            pContext->RipeZombie->fProtocol | (pContext->RipeZombie->fSGC ? SP_PROT_SGC : 0));
    if (NULL == pContext->pSystem)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_SPECS_MISMATCH));
    }

    pContext->pCheck = HashFromSpec(pContext->RipeZombie->SessHashSpec, pContext->RipeZombie->fProtocol);
    if (NULL == pContext->pCheck)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_SPECS_MISMATCH));
    }

    pContext->pKeyExch = KeyExchangeFromSpec(pContext->RipeZombie->SessExchSpec, pContext->RipeZombie->fProtocol);
    if (NULL == pContext->pKeyExch)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_SPECS_MISMATCH));
    }

    /* we want to minimize allocations, so we'll do one here by starting */
    /* up the initMACstate using the regular hashing functions.  We'll then */
    /* clone the hash state and throw away the allocated one.  This lets */
    /* us get rid of a few alloc'ed hashes in the future. */
    pContext->InitMACState = (PCheckSumBuffer)(pContext->InHSHBuf);
    pContext->pCheck->Initialize(pContext->InitMACState, 0);

    SP_RETURN(PCT_ERR_OK);

}


SP_STATUS
SPContextDoMapping(
    PSPContext pContext)
{
    PSessCacheItem      pZombie;
    PSPCredential       pCred;
//    DWORD               cbCert;
//    PUCHAR              pCert;
//    SP_STATUS           pctRet;
    DWORD               iMapper;
    MAPPER_X509_ASN_CHAIN *pChain;
    DWORD               cCerts;
    DWORD               cbChain;

    pZombie = pContext->RipeZombie;
    pCred = pContext->pCred;


    if(pCred->cMappers)
    {

        PPctCertificate pThis;
        X509Certificate *pX509Cert;
        DWORD iCert;
        // we have a cert mapper, so now we
        // build a credential and then call the
        // cert mapper

        cCerts = 0;

        pThis = pZombie->pClientCert;
        while(pThis)
        {
            cCerts++;
            if(pThis == pThis->pIssuerCertificate)
            {
                break;
            }
            pThis = pThis->pIssuerCertificate;
        }
        cbChain = sizeof(MAPPER_X509_ASN_CHAIN)+sizeof(MAPPER_BLOB)*cCerts;

        pChain = (MAPPER_X509_ASN_CHAIN *)SPExternalAlloc(cbChain);

        if(pChain == NULL)
        {
            return(SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY));
        }
        pChain->cCerts = cCerts;

        iCert = 0;
        pThis = pZombie->pClientCert;
        while(pThis)
        {
            pChain->aCerts[iCert].cbBytes = pThis->cbRawCert;
            pChain->aCerts[iCert].pBytes = pThis->pRawCert;

            iCert++;
            if(pThis == pThis->pIssuerCertificate)
            {
                break;
            }
            pThis = pThis->pIssuerCertificate;
        }
        if(NULL == pThis)
        {
            pChain->dwFlags |= X509_UNKNOWN_ISSUER;
        }
        pThis = pZombie->pClientCert;
        pX509Cert = (X509Certificate *)pThis->pCert;
        pChain->ValidFrom = pThis->ValidFrom;
        pChain->ValidUntil = pThis->ValidUntil;
        pChain->SerialNumber[0] = pX509Cert->SerialNumber[0];
        pChain->SerialNumber[1] = pX509Cert->SerialNumber[1];
        pChain->SerialNumber[2] = pX509Cert->SerialNumber[2];
        pChain->SerialNumber[3] = pX509Cert->SerialNumber[3];
        pChain->pIssuer = pThis->pbIssuer;
        pChain->cbIssuer = pThis->cbIssuer;
        pChain->pSubject = pThis->pbSubject;
        pChain->cbSubject = pThis->cbSubject;

        for(iMapper = 0; iMapper < pCred->cMappers; iMapper++)
        {
            if(pCred->pahMappers[iMapper]->m_vtable->MapCredential(pCred->pahMappers[iMapper],
                                        X509_ASN_CHAIN,
                                        (PUCHAR)pChain,
                                        cbChain,
                                        &pZombie->hLocator))
            {
                pZombie->phMapper = pCred->pahMappers[iMapper];
                pZombie->phMapper->m_vtable->ReferenceMapper(pZombie->phMapper);
                break;
            }
        }
        SPExternalFree(pChain);

    }
    return PCT_ERR_OK;
}

SP_STATUS
SPContextGetIssuers(
    PSPContext pContext,
    PBYTE pbIssuers,
    DWORD *pcbIssuers)
{
    PSPCredential       pCred;
    DWORD               iMapper;
    DWORD               cbIssuerLen;
    DWORD               cbTotalIssuerLen = 0;
    PBYTE               pbCurIssuer;



    pCred = pContext->pCred;


    if(pCred->cMappers)
    {
        pbCurIssuer = pbIssuers;
        for(iMapper = 0; iMapper < pCred->cMappers; iMapper++)
        {
            cbIssuerLen = (*pcbIssuers) - cbTotalIssuerLen;
            if(pCred->pahMappers[iMapper]->m_vtable->GetIssuerList(pCred->pahMappers[iMapper],
                                                                    NULL,
                                                                    (PUCHAR)pbCurIssuer,
                                                                    &cbIssuerLen))
            {

                cbTotalIssuerLen += cbIssuerLen;
                if(pbIssuers)
                {
                    pbCurIssuer += cbIssuerLen;
                }
            }
        }
    }
    else
    {
        // Issuer name
        if(!GetDefaultIssuers(pbIssuers, pcbIssuers))
        {
    	    return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
        }
    }
    return PCT_ERR_OK;
}

/*
 *
 * Misc Utility functions.
 *
 */



#if DBG
typedef struct _DbgMapCrypto {
    DWORD   C;
    PSTR    psz;
} DbgMapCrypto;

DbgMapCrypto    DbgCryptoNames[] = { {SP_CIPHER_RC4, "RC4 "},
};

CHAR    DbgNameSpace[100];
PSTR    DbgAlgNames[] = { "Basic RSA", "RSA with MD2", "RSA with MD5", "RC4 stream"};
#define AlgName(x) ((x < sizeof(DbgAlgNames) / sizeof(PSTR)) ? DbgAlgNames[x] : "Unknown")

PSTR
DbgGetNameOfCrypto(DWORD x)
{
    int i;
    for (i = 0; i < sizeof(DbgCryptoNames) / sizeof(DbgMapCrypto) ; i++ )
    {
        if ((x & SP_CIPHER_ALG) == DbgCryptoNames[i].C)
        {
            sprintf(DbgNameSpace, "%s %d / %d MACbits",
                    (DbgCryptoNames[i].psz),
                    (x & SP_CIPHER_STRENGTH) >> SP_CSTR_POS,
                    (x & SP_CIPHER_MAC));
            return DbgNameSpace;
        }
    }

    return("Unknown");
}
#endif

/* allow quick initialization of hashes */

void InitHashBuf(HashBuf Buf,
                 PSPContext pContext
                 )
{
    CloneHashBuf(Buf, pContext->InitMACState, pContext->pCheck);

    return;
}

PSTR
CopyString(
           PSTR        pszString)
{
    PSTR    pszNewString;
    DWORD   cchString;

    cchString = strlen(pszString) + 1;

    pszNewString = (PSTR)SPExternalAlloc(cchString);

    if (pszNewString)
    {
        CopyMemory(pszNewString, pszString, cchString);
    }

    return(pszNewString);
}




#ifdef LTS

int __cdecl memcmp (
        const void * buf1,
        const void * buf2,
        size_t count
        )
{
        if (!count)
                return(0);

        while ( --count && *(char *)buf1 == *(char *)buf2 ) {
                buf1 = (char *)buf1 + 1;
                buf2 = (char *)buf2 + 1;
        }

        return( *((unsigned char *)buf1) - *((unsigned char *)buf2) );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\cryptapi.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : cryptapi.c                                             //
//  DESCRIPTION   : Crypto API interface                                   //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Dec  6 1994 larrys  New                                            //
//      Jan 16 1995 larrys  Added key verify                               //
//      Jan 25 1995 larrys  Added thread safe                              //
//      Jan 27 1995 larrys  Added Unicode support                          //
//      Feb 21 1995 larrys  Added Unicode support for CryptAcquireContext  //
//      Feb 21 1995 larrys  Fixed Unicode problem in CryptAcquireContext   //
//      Mar 08 1995 larrys  Removed CryptGetLastError                      //
//      Mar 20 1995 larrys  Removed Certificate APIs                       //
//      Mar 22 1995 larrys  #ifdef in WIN95 code                           //
//      Apr 06 1995 larrys  Increased signature key to 1024 bits           //
//      Apr 07 1995 larrys  Removed CryptConfigure                         //
//      Jun 14 1995 larrys  Removed pointer from RSA key struct            //
//      Jun 29 1995 larrys  Changed AcquireContext                         //
//      Jul 17 1995 larrys  Worked on AcquireContext                       //
//      Aug 01 1995 larrys  Removed CryptTranslate                         //
//                          And CryptDeinstallProvider                     //
//                          Changed CryptInstallProvider to                //
//                          CryptSetProvider                               //
//      Aug 03 1995 larrys  Cleanup                                        //
//      Aug 10 1995 larrys  CryptAcquireContext returns error              //
//                          NTE_BAD_KEYSEY_PARAM now                       //
//      Aug 14 1995 larrys  Removed key exchange stuff                     //
//      Aug 17 1995 larrys  Changed registry entry to decimcal             //
//      Aug 23 1995 larrys  Changed CryptFinishHash to CryptGetHashValue   //
//      Aug 28 1995 larrys  Removed parameter from CryptVerifySignature    //
//      Aug 31 1995 larrys  Remove GenRandom                               //
//      Sep 14 1995 larrys  Code review changes                            //
//      Sep 26 1995 larrys  Added Microsoft's signing key                  //
//      Sep 27 1995 larrys  Updated with more review changes               //
//      Oct 06 1995 larrys  Added more APIs Get/SetHash/ProvParam          //
//      Oct 12 1995 larrys  Remove CryptGetHashValue                       //
//      Oct 20 1995 larrys  Changed test key                               //
//      Oct 24 1995 larrys  Removed return of KeySet name                  //
//      Oct 30 1995 larrys  Removed WIN95                                  //
//      Nov  9 1995 larrys  Disable BUILD1057                              //
//      Nov 10 1995 larrys  Fix a problem in EnterHashCritSec              //
//      May 30 1996 larrys  Added hWnd support                             //
//      Oct 10 1996 jeffspel Reordered SetLastErrors and save error on     //
//                           AcquireContext failure                        //
//      Mar 21 1997 jeffspel Added second tier signatures, new APIs        //
//      Apr 11 1997 jeffspel Replace critical sections with interlocked    //
//                           inc/dec                                       //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include <xtl.h>


#include <wincrypt.h>   // Include here, since not included by LEAN_AND_MEAN
#include <rsa.h>
#include <md5.h>
#include <rc4.h>

// #define _HRESULT_TYPEDEF_ (unsigned long)

#ifndef RC4_KEYSIZE
#define RC4_KEYSIZE 5
#endif

#define IDR_PUBKEY1                     102


typedef struct _VTableStruc {
// ******************** WARNING **********************************************
// Do not place anything before these FARPROCs we init the table assuming
// that the first Function to call is the first thing in the table.
// ***************************************************************************
    FARPROC FuncAcquireContext;
    FARPROC FuncReleaseContext;
    FARPROC FuncGenKey;
    FARPROC FuncDeriveKey;
    FARPROC FuncDestroyKey;
    FARPROC FuncSetKeyParam;
    FARPROC FuncGetKeyParam;
    FARPROC FuncExportKey;
    FARPROC FuncImportKey;
    FARPROC FuncEncrypt;
    FARPROC FuncDecrypt;
    FARPROC FuncCreateHash;
    FARPROC FuncHashData;
    FARPROC FuncHashSessionKey;
    FARPROC FuncDestroyHash;
    FARPROC FuncSignHash;
    FARPROC FuncVerifySignature;
    FARPROC FuncGenRandom;
    FARPROC FuncGetUserKey;
    FARPROC FuncSetProvParam;
    FARPROC FuncGetProvParam;
    FARPROC FuncSetHashParam;
    FARPROC FuncGetHashParam;
    FARPROC FuncNULL;

    FARPROC OptionalFuncDuplicateKey;
    FARPROC OptionalFuncDuplicateHash;
    FARPROC OptionalFuncNULL;

    HANDLE      DllHandle;                     // Handle to open DLL
    HCRYPTPROV  hProv;                         // Handle to provider
    DWORD       Version;
    DWORD       Inuse;
    LONG        RefCnt;
} VTableStruc, *PVTableStruc;

typedef struct _VKeyStruc {
// ******************** WARNING **********************************************
// Do not place anything before these FARPROCs we init the table assuming
// that the first Function to call is the first thing in the table.
// ***************************************************************************
    FARPROC FuncGenKey;
    FARPROC FuncDeriveKey;
    FARPROC FuncDestroyKey;
    FARPROC FuncSetKeyParam;
    FARPROC FuncGetKeyParam;
    FARPROC FuncExportKey;
    FARPROC FuncImportKey;
    FARPROC FuncEncrypt;
    FARPROC FuncDecrypt;

    FARPROC OptionalFuncDuplicateKey;

    HCRYPTPROV  hProv;                         // Handle to provider
    HCRYPTKEY   hKey;                          // Handle to key
    DWORD       Version;
    DWORD       Inuse;
} VKeyStruc, *PVKeyStruc;

typedef struct _VHashStruc {
// ******************** WARNING **********************************************
// Do not place anything before these FARPROCs we init the table assuming
// that the first Function to call is the first thing in the table.
// ***************************************************************************
    FARPROC FuncCreateHash;
    FARPROC FuncHashData;
    FARPROC FuncHashSessionKey;
    FARPROC FuncDestroyHash;
    FARPROC FuncSignHash;
    FARPROC FuncVerifySignature;
    FARPROC FuncSetHashParam;
    FARPROC FuncGetHashParam;

    FARPROC OptionalFuncDuplicateHash;

    HCRYPTPROV  hProv;                         // Handle to provider
    HCRYPTHASH  hHash;                         // Handle to hash
    DWORD       Version;
    DWORD       Inuse;
} VHashStruc, *PVHashStruc;

//
// Crypto providers have to have the following entry points:
//
LPCTSTR FunctionNames[] = {
    TEXT("CPAcquireContext"),
    TEXT("CPReleaseContext"),
    TEXT("CPGenKey"),
    TEXT("CPDeriveKey"),
    TEXT("CPDestroyKey"),
    TEXT("CPSetKeyParam"),
    TEXT("CPGetKeyParam"),
    TEXT("CPExportKey"),
    TEXT("CPImportKey"),
    TEXT("CPEncrypt"),
    TEXT("CPDecrypt"),
    TEXT("CPCreateHash"),
    TEXT("CPHashData"),
    TEXT("CPHashSessionKey"),
    TEXT("CPDestroyHash"),
    TEXT("CPSignHash"),
    TEXT("CPVerifySignature"),
    TEXT("CPGenRandom"),
    TEXT("CPGetUserKey"),
    TEXT("CPSetProvParam"),
    TEXT("CPGetProvParam"),
    TEXT("CPSetHashParam"),
    TEXT("CPGetHashParam"),
    NULL
    };

LPCTSTR OptionalFunctionNames[] = {
    TEXT("CPDuplicateKey"),
    TEXT("CPDuplicateHash"),
    NULL
    };

BOOL KeyDecrypted = FALSE;

DWORD hWnd = 0;
BYTE *pbContextInfo = NULL;
DWORD cbContextInfo = 0;

#define KEYSIZE512 0x48
#define KEYSIZE1024 0x88

typedef struct _SECONDTIER_SIG
{
    DWORD           dwMagic;
    DWORD           cbSig;
    BSAFE_PUB_KEY   Pub;
} SECOND_TIER_SIG, *PSECOND_TIER_SIG;

#ifdef TEST_BUILD_EXPONENT
#pragma message("WARNING: building advapai32.dll with TESTKEY enabled!")
struct _TESTKEY {
    BSAFE_PUB_KEY    PUB;
    unsigned char pubmodulus[KEYSIZE512];
} TESTKEY = {
    {
	0x66b8443b,
	0x6f5fc900,
	0xa12132fe,
	0xff1b06cf,
	0x2f4826eb,
    },
    {
	0x3e, 0x69, 0x4f, 0x45, 0x31, 0x95, 0x60, 0x6c,
	0x80, 0xa5, 0x41, 0x99, 0x3e, 0xfc, 0x92, 0x2c,
	0x93, 0xf9, 0x86, 0x23, 0x3d, 0x48, 0x35, 0x81,
	0x19, 0xb6, 0x7c, 0x04, 0x43, 0xe6, 0x3e, 0xd4,
	0xd5, 0x43, 0xaf, 0x52, 0xdd, 0x51, 0x20, 0xac,
	0xc3, 0xca, 0xee, 0x21, 0x9b, 0x4a, 0x2d, 0xf7,
	0xd8, 0x5f, 0x32, 0xeb, 0x49, 0x72, 0xb9, 0x8d,
	0x2e, 0x1a, 0x76, 0x7f, 0xde, 0xc6, 0x75, 0xab,
	0xaf, 0x67, 0xe0, 0xf0, 0x8b, 0x30, 0x20, 0x92,
    }
};
#endif


#ifdef MS_INTERNAL_KEY
struct _mskey {
    BSAFE_PUB_KEY    PUB;
    unsigned char pubmodulus[KEYSIZE1024];
} MSKEY = {
    {
	0x2bad85ae,
	0x883adacc,
	0xb32ebd68,
	0xa7ec8b06,
	0x58dbeb81,
    },
    {
	0x42, 0x34, 0xb7, 0xab, 0x45, 0x0f, 0x60, 0xcd,
	0x8f, 0x77, 0xb5, 0xd1, 0x79, 0x18, 0x34, 0xbe,
	0x66, 0xcb, 0x5c, 0x66, 0x4a, 0x9f, 0x03, 0x18,
	0x13, 0x36, 0x8e, 0x88, 0x21, 0x78, 0xb1, 0x94,
	0xa1, 0xd5, 0x8f, 0x8c, 0xa5, 0xd3, 0x9f, 0x86,
	0x43, 0x89, 0x05, 0xa0, 0xe3, 0xee, 0xe2, 0xd0,
	0xe5, 0x1d, 0x5f, 0xaf, 0xff, 0x85, 0x71, 0x7a,
	0x0a, 0xdb, 0x2e, 0xd8, 0xc3, 0x5f, 0x2f, 0xb1,
	0xf0, 0x53, 0x98, 0x3b, 0x44, 0xee, 0x7f, 0xc9,
	0x54, 0x26, 0xdb, 0xdd, 0xfe, 0x1f, 0xd0, 0xda,
	0x96, 0x89, 0xc8, 0x9e, 0x2b, 0x5d, 0x96, 0xd1,
	0xf7, 0x52, 0x14, 0x04, 0xfb, 0xf8, 0xee, 0x4d,
	0x92, 0xd1, 0xb6, 0x37, 0x6a, 0xe0, 0xaf, 0xde,
	0xc7, 0x41, 0x06, 0x7a, 0xe5, 0x6e, 0xb1, 0x8c,
	0x8f, 0x17, 0xf0, 0x63, 0x8d, 0xaf, 0x63, 0xfd,
	0x22, 0xc5, 0xad, 0x1a, 0xb1, 0xe4, 0x7a, 0x6b,
	0x1e, 0x0e, 0xea, 0x60, 0x56, 0xbd, 0x49, 0xd0,
    }
};
#endif


struct _key {
    BSAFE_PUB_KEY    PUB;
    unsigned char pubmodulus[KEYSIZE1024];
} KEY = {
    {
	0x3fcbf1a9,
	0x08f597db,
	0xe4aecab4,
	0x75360f90,
	0x9d6c0f00,
    },
    {
	0x85, 0xdd, 0x9b, 0xf4, 0x4d, 0x0b, 0xc4, 0x96,
	0x3e, 0x79, 0x86, 0x30, 0x6d, 0x27, 0x31, 0xee,
	0x4a, 0x85, 0xf5, 0xff, 0xbb, 0xa9, 0xbd, 0x81,
	0x86, 0xf2, 0x4f, 0x87, 0x6c, 0x57, 0x55, 0x19,
	0xe4, 0xf4, 0x49, 0xa3, 0x19, 0x27, 0x08, 0x82,
	0x9e, 0xf9, 0x8a, 0x8e, 0x41, 0xd6, 0x91, 0x71,
	0x47, 0x48, 0xee, 0xd6, 0x24, 0x2d, 0xdd, 0x22,
	0x72, 0x08, 0xc6, 0xa7, 0x34, 0x6f, 0x93, 0xd2,
	0xe7, 0x72, 0x57, 0x78, 0x7a, 0x96, 0xc1, 0xe1,
	0x47, 0x38, 0x78, 0x43, 0x53, 0xea, 0xf3, 0x88,
	0x82, 0x66, 0x41, 0x43, 0xd4, 0x62, 0x44, 0x01,
	0x7d, 0xb2, 0x16, 0xb3, 0x50, 0x89, 0xdb, 0x0a,
	0x93, 0x17, 0x02, 0x02, 0x46, 0x49, 0x79, 0x76,
	0x59, 0xb6, 0xb1, 0x2b, 0xfc, 0xb0, 0x9a, 0x21,
	0xe6, 0xfa, 0x2d, 0x56, 0x07, 0x36, 0xbc, 0x13,
	0x7f, 0x1c, 0xde, 0x55, 0xfb, 0x0d, 0x67, 0x0f,
	0xc2, 0x17, 0x45, 0x8a, 0x14, 0x2b, 0xba, 0x55,
    }
};


struct _key2 {
    BSAFE_PUB_KEY    PUB;
    unsigned char pubmodulus[KEYSIZE1024];
} KEY2 =  {
    {
	0x685fc690,
	0x97d49b6b,
	0x1dccd9d2,
	0xa5ec9b52,
	0x64fd29d7,
    },
    {
	0x03, 0x8c, 0xa3, 0x9e, 0xfb, 0x93, 0xb6, 0x72,
	0x2a, 0xda, 0x6f, 0xa5, 0xec, 0x26, 0x39, 0x58,
	0x41, 0xcd, 0x3f, 0x49, 0x10, 0x4c, 0xcc, 0x7e,
	0x23, 0x94, 0xf9, 0x5d, 0x9b, 0x2b, 0xa3, 0x6b,
	0xe8, 0xec, 0x52, 0xd9, 0x56, 0x64, 0x74, 0x7c,
	0x44, 0x6f, 0x36, 0xb7, 0x14, 0x9d, 0x02, 0x3c,
	0x0e, 0x32, 0xb6, 0x38, 0x20, 0x25, 0xbd, 0x8c,
	0x9b, 0xd1, 0x46, 0xa7, 0xb3, 0x58, 0x4a, 0xb7,
	0xdd, 0x0e, 0x38, 0xb6, 0x16, 0x44, 0xbf, 0xc1,
	0xca, 0x4d, 0x6a, 0x9f, 0xcb, 0x6f, 0x3c, 0x5f,
	0x03, 0xab, 0x7a, 0xb8, 0x16, 0x70, 0xcf, 0x98,
	0xd0, 0xca, 0x8d, 0x25, 0x57, 0x3a, 0x22, 0x8b,
	0x44, 0x96, 0x37, 0x51, 0x30, 0x00, 0x92, 0x1b,
	0x03, 0xb9, 0xf9, 0x0d, 0xb3, 0x1a, 0xe2, 0xb4,
	0xc5, 0x7b, 0xc9, 0x4b, 0xe2, 0x42, 0x25, 0xfe,
	0x3d, 0x42, 0xfa, 0x45, 0xc6, 0x94, 0xc9, 0x8e,
	0x87, 0x7e, 0xf6, 0x68, 0x90, 0x30, 0x65, 0x10,
    }
};


#define TABLEPROV       0x11111111
#define TABLEKEY        0x22222222
#define TABLEHASH       0x33333333

WCHAR szusertypeW[] = L"Comm\\Security\\Crypto\\Providers\\Type ";
WCHAR szmachinetypeW[] = L"Comm\\Security\\Crypto\\Defaults\\Provider Types\\Type ";
WCHAR szproviderW[] = L"Comm\\Security\\Crypto\\Defaults\\Provider\\";
WCHAR szenumprovidersW[] = L"Comm\\Security\\Crypto\\Defaults\\Provider";
WCHAR szprovidertypesW[] = L"Comm\\Security\\Crypto\\Defaults\\Provider Types";

BOOL EnterProviderCritSec(IN PVTableStruc pVTable);
void LeaveProviderCritSec(IN PVTableStruc pVTable);
BOOL EnterKeyCritSec(IN PVKeyStruc pVKey);
void LeaveKeyCritSec(IN PVKeyStruc pVKey);
BOOL EnterHashCritSec(IN PVHashStruc pVHash);
void LeaveHashCritSec(IN PVHashStruc pVHash);

BOOL CProvVerifyImage(LPCWSTR lpszImage,
		              BYTE *pSigData);

BOOL NewVerifyImage(LPCWSTR lpszImage,
		            BYTE *pSigData,
                    DWORD cbData,
                    BOOL fUnknownLen);

BOOL BuildVKey(IN PVKeyStruc *ppVKey,
               IN PVTableStruc pVTable);

BOOL BuildVHash(
                IN PVHashStruc *ppVKey,
                IN PVTableStruc pVTable
                );

BOOL CPReturnhWnd(DWORD *phWnd);

static void __ltoaW(DWORD val, WCHAR *buf);


DWORD StrToLW(WCHAR *InStr)
{
    DWORD dwVal = 0;

    while(*InStr)
    {
        dwVal = (10 * dwVal) + (*InStr - L'0');
        InStr++;
    }

    return dwVal;
}



/*
 -      CryptAcquireContextW
 -
 *      Purpose:
 *               The CryptAcquireContext function is used to acquire a context
 *               handle to a cryptograghic service provider (CSP).
 *
 *
 *      Parameters:
 *               OUT    phProv         -  Handle to a CSP
 *               IN OUT pszIdentity    -  Pointer to the name of the context's
 *                                        keyset.
 *               IN OUT pszProvName    -  Pointer to the name of the provider.
 *               IN     dwReqProvider  -  Requested CSP type
 *               IN     dwFlags        -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptAcquireContextW(OUT    HCRYPTPROV *phProv,
                IN     LPCWSTR pszIdentity,
                IN     LPCWSTR pszProvName,
                IN     DWORD dwReqProvider,
                IN     DWORD dwFlags)
{
    HANDLE          handle = 0;
    DWORD           bufsize;
    DWORD           *pTable;
    PVTableStruc    pVTable = NULL;
    WCHAR           *pszTmpProvName = NULL;
    DWORD           i;
    HKEY            hKey = 0;
    DWORD           cbValue;
    DWORD           cbTemp;
    WCHAR            *pszValue = NULL;
//    WCHAR            *pszDest;
    BYTE            *SignatureBuf = NULL;
    DWORD           provtype;
    BOOL            rt = CRYPT_FAILED;
    DWORD           dwType;
    LONG            err;
    DWORD           dwErr;
    WCHAR            typebuf[9]; // sfield = {0, 0, 0, 0, 0, 0, 0, 0, 0};
    VTableProvStruc VTableProv;

#ifndef XBOX

    if (dwReqProvider == 0 || dwReqProvider > 999)
    {
        SetLastError((DWORD) NTE_BAD_PROV_TYPE);
        return(CRYPT_FAILED);
    }

    try
    {
        if (pszProvName != NULL && pszProvName[0] != L'\0' )
	    {
            // Do nothing just check for invalid pointers
            ;
	    }
    } except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    if (pszProvName != NULL && pszProvName[0] != L'\0')
    {
        cbValue = lstrlenW(pszProvName) * sizeof(WCHAR);

        if ((pszValue = (WCHAR *) LocalAlloc(LMEM_ZEROINIT,
                                            (UINT) cbValue +
                                            sizeof(szproviderW) )) == NULL)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        if ((pszTmpProvName = (PWSTR)LocalAlloc(LMEM_ZEROINIT,
                                            (UINT) cbValue + sizeof(WCHAR))) == NULL)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        lstrcpyW(pszTmpProvName, pszProvName);
        lstrcpyW(pszValue, szproviderW);
        lstrcatW(pszValue, pszProvName);

    }
    else
    {
        if ((pszValue = (WCHAR *) LocalAlloc(LMEM_ZEROINIT,
                                            (5 *sizeof(WCHAR)) + sizeof(szusertypeW))) == NULL)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        lstrcpyW(pszValue, szusertypeW);
        __ltoaW(dwReqProvider, typebuf);
        lstrcatW(pszValue, &typebuf[5]);

        err = RegOpenKeyExW(HKEY_CURRENT_USER, (const WCHAR *) pszValue,
                           0L, KEY_READ, &hKey);

        RegCloseKey(HKEY_CURRENT_USER);
        if (err != ERROR_SUCCESS)
        {
            LocalFree(pszValue);
            if ((pszValue = (WCHAR *) LocalAlloc(LMEM_ZEROINIT,
                                                (5*sizeof(WCHAR)) + sizeof(szmachinetypeW))) == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            lstrcpyW(pszValue, szmachinetypeW);
            lstrcatW(pszValue, &typebuf[5]);

            if ((err = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                    (const WCHAR *) pszValue, 0L,
                                    KEY_READ, &hKey)) != ERROR_SUCCESS)
            {
                SetLastError((DWORD) NTE_PROV_TYPE_NOT_DEF);
                goto Ret;
            }
        }

        if ((err = RegQueryValueExW(hKey, L"Name", NULL, &dwType,
                                   NULL, &cbValue)) != ERROR_SUCCESS)
        {
            SetLastError((DWORD) NTE_PROV_TYPE_ENTRY_BAD);
            goto Ret;
        }

        LocalFree(pszValue);
        if ((pszValue = (WCHAR *) LocalAlloc(LMEM_ZEROINIT,
                                            cbValue +
                                            sizeof(szproviderW) )) == NULL)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        if ((pszTmpProvName = (PWSTR)LocalAlloc(LMEM_ZEROINIT,
                                            (UINT) cbValue )) == NULL)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }
        
        lstrcpyW(pszValue, szproviderW);

        cbTemp = cbValue;

        if ((err = RegQueryValueExW(hKey, L"Name", NULL, &dwType,
                                   (LPBYTE)pszTmpProvName,
                                   &cbTemp)) != ERROR_SUCCESS)
        {
            SetLastError((DWORD) NTE_PROV_TYPE_ENTRY_BAD);
            goto Ret;
        }
        
        lstrcatW(pszValue, pszTmpProvName);
        
        RegCloseKey(hKey);
        hKey = 0;

    }

    if ((err = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                            (const WCHAR *) pszValue,
                            0L, KEY_READ, &hKey)) != ERROR_SUCCESS)
    {
        SetLastError((DWORD) NTE_KEYSET_NOT_DEF);
        goto Ret;
    }

    LocalFree(pszValue);
    pszValue = NULL;

    cbValue = sizeof(DWORD);
    if ((err = RegQueryValueExW(hKey, L"Type", NULL, &dwType,
                               (CHAR *) &provtype,
                               &cbValue)) != ERROR_SUCCESS)
    {
        SetLastError((DWORD) NTE_KEYSET_ENTRY_BAD);
        goto Ret;
    }

    // Check that requested provider type is same as registry entry
    if (provtype != dwReqProvider)
    {
        SetLastError((DWORD) NTE_PROV_TYPE_NO_MATCH);
        goto Ret;
    }

    // Determine size of path for provider
    if ((err = RegQueryValueExW(hKey, L"Image Path", NULL,
                               &dwType, NULL, &cbValue)) != ERROR_SUCCESS)
    {
        SetLastError((DWORD) NTE_KEYSET_ENTRY_BAD);
        goto Ret;
    }

    if ((pszValue = (WCHAR *) LocalAlloc(LMEM_ZEROINIT,
                                        (UINT) cbValue)) == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }

    // Get value from registry
    if ((err = RegQueryValueExW(hKey, L"Image Path", NULL, &dwType,
                               (LPBYTE)pszValue, &cbValue)) != ERROR_SUCCESS)
    {
        SetLastError((DWORD) NTE_KEYSET_ENTRY_BAD);
        goto Ret;
    }
/*
#ifndef UNDER_CE

    pszDest = NULL;
    cbTemp = 0;

    if ((cbTemp = ExpandEnvironmentStringsW(pszValue, (WCHAR *) &pszDest, cbTemp))  == 0)
    {
        LocalFree(pszValue);
        RegCloseKey(hKey);
        return(CRYPT_FAILED);
    }

    if ((pszDest = (WCHAR *) LocalAlloc(LMEM_ZEROINIT,
                                       (UINT) cbTemp * sizeof(WCHAR))) == NULL)
    {
        LocalFree(pszValue);
        RegCloseKey(hKey);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(CRYPT_FAILED);
    }

    if ((cbTemp = ExpandEnvironmentStringsW(pszValue, pszDest,
                                           cbTemp))  == 0)
    {
        LocalFree(pszValue);
        LocalFree(pszDest);
        RegCloseKey(hKey);
        return(CRYPT_FAILED);
    }

    LocalFree(pszValue);
    pszValue = pszDest;
    cbValue = cbTemp;

#endif // UNDER_CE
*/

    // Determine size of signature
    if ((err = RegQueryValueExW(hKey, L"Signature", NULL,
                               &dwType, NULL, &cbValue)) != ERROR_SUCCESS)
    {
        SetLastError((DWORD) NTE_BAD_SIGNATURE);
        goto Ret;
    }

    if ((SignatureBuf = (CHAR *) LocalAlloc(LMEM_ZEROINIT,
                                            (UINT) cbValue )) == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }

    // Get Digital signature from registry
    if ((err = RegQueryValueExW(hKey, L"Signature", NULL, &dwType,
                               (CHAR *) SignatureBuf,
                               &cbValue)) != ERROR_SUCCESS)
    {
        SetLastError((DWORD) NTE_KEYSET_ENTRY_BAD);
        goto Ret;
    }

    if (RCRYPT_FAILED(NewVerifyImage(pszValue, SignatureBuf, cbValue, FALSE)))
    {
        SetLastError((DWORD) NTE_BAD_SIGNATURE);
        goto Ret;
    }

    // Check to see if DLL exists
    if ((handle = LoadLibraryW(pszValue)) == NULL)
    {
        SetLastError((DWORD) NTE_PROVIDER_DLL_FAIL);
        goto Ret;
    }

     // DLLs exist allocate VTable struct to hold address of entry points
    bufsize = sizeof(VTableStruc);

    if ((pVTable = (PVTableStruc) LocalAlloc(LMEM_ZEROINIT,
                                             (UINT) bufsize)) == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }

    pTable = (DWORD *) pVTable;

    // Build table of pointers to Crypto API for this DLL
    i = 0;
    while (FunctionNames[i] != NULL)
    {
        *pTable = (DWORD) GetProcAddress(handle, FunctionNames[i]);
        if (*pTable == 0)
        {
            SetLastError((DWORD) NTE_PROVIDER_DLL_FAIL);
            goto Ret;
        }
        pTable++;
        i++;
    }

    // Build the table of optional pointers to Crypto API for this DLL
    i = 0;
    pTable++;
    while (OptionalFunctionNames[i] != NULL)
    {
        *pTable = (DWORD) GetProcAddress(handle, OptionalFunctionNames[i]);
        pTable++;
        i++;
    }
    pVTable->DllHandle = handle;

    memset(&VTableProv, 0, sizeof(VTableProv));
    VTableProv.Version = 3;
    VTableProv.FuncVerifyImage = CProvVerifyImage;
    VTableProv.FuncReturnhWnd = CPReturnhWnd;
    VTableProv.dwProvType = dwReqProvider;
    VTableProv.pszProvName = pszTmpProvName;
    VTableProv.pbContextInfo = pbContextInfo;
    VTableProv.cbContextInfo = cbContextInfo;

    try
    {
        rt = pVTable->FuncAcquireContext(phProv, pszIdentity, dwFlags,
                                         &VTableProv);
        if (RCRYPT_SUCCEEDED(rt) &&
            ((dwFlags & CRYPT_DELETEKEYSET) != CRYPT_DELETEKEYSET))
        {
            pVTable->hProv = *phProv;
            *phProv = (HCRYPTPROV) pVTable;

            pVTable->Version = TABLEPROV;
            pVTable->Inuse = 1;
            pVTable->RefCnt = 1;
        }
    } except ( EXCEPTION_EXECUTE_HANDLER )
    {
        rt = CRYPT_FAILED;
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

Ret:
    dwErr = GetLastError();
    if (pszTmpProvName)
        LocalFree(pszTmpProvName);
    if (pszValue)
        LocalFree(pszValue);
    if (hKey)
        RegCloseKey(hKey);
    if (SignatureBuf)
        LocalFree(SignatureBuf);
    if ((CRYPT_SUCCEED != rt) || (dwFlags & CRYPT_DELETEKEYSET))
    {
        if (handle)
            FreeLibrary(handle);
        if (pVTable)
            LocalFree(pVTable);
        SetLastError(dwErr);
    }
#endif // ndef XBOX
    return rt;

}

/*
 -      CryptContextAddRef
 -
 *      Purpose:
 *               Increments the reference counter on the provider handle.
 *
 *      Parameters:
 *               IN  hProv         -  Handle to a CSP
 *               IN  pdwReserved   -  Reserved parameter
 *               IN  dwFlags       -  Flags values
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptContextAddRef(
                          IN HCRYPTPROV hProv,
                          IN DWORD *pdwReserved,
			              IN DWORD dwFlags
                          )
{
    PVTableStruc    pVTable;
    BOOL            fRet = CRYPT_FAILED;

    try
    {
        if ((NULL != pdwReserved) || (0 != dwFlags))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        pVTable = (PVTableStruc) hProv;

        if (pVTable->Version != TABLEPROV)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (InterlockedIncrement(&pVTable->RefCnt) <= 0)
            SetLastError(ERROR_INVALID_PARAMETER);
        else
            fRet = CRYPT_SUCCEED;
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

Ret:
    return fRet;
}

/*
 -      CryptReleaseContext
 -
 *      Purpose:
 *               The CryptReleaseContext function is used to release a
 *               context created by CryptAcquireContext.
 *
 *     Parameters:
 *               IN  hProv         -  Handle to a CSP
 *               IN  dwFlags       -  Flags values
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptReleaseContext(IN HCRYPTPROV hProv,
                           IN DWORD dwFlags)
{
    PVTableStruc    pVTable;
    BOOL            rt;
    BOOL            fRet = CRYPT_FAILED;
    DWORD           dwErr = ERROR_INVALID_PARAMETER;

    try
    {
        pVTable = (PVTableStruc) hProv;

        if (pVTable->Version != TABLEPROV)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (pVTable->RefCnt <= 0)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (0 == InterlockedDecrement(&pVTable->RefCnt))
        {
            if (0 < InterlockedDecrement(&pVTable->Inuse))
            {
                InterlockedIncrement(&pVTable->Inuse);
                SetLastError(ERROR_BUSY);
                goto Ret;
            }
            InterlockedIncrement(&pVTable->Inuse);

            if (FALSE == (rt = pVTable->FuncReleaseContext(pVTable->hProv, dwFlags)))
            {
                dwErr = GetLastError();
            }
            pVTable->Version = 0;
#ifndef XBOX            
            FreeLibrary(pVTable->DllHandle);
#endif // ! XBOX
            LocalFree(pVTable);
            if (!rt)
            {
                SetLastError(dwErr);
                goto Ret;
            }
        }
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    return fRet;
}

/*
 -      CryptGenKey
 -
 *      Purpose:
 *                Generate cryptographic keys
 *
 *
 *      Parameters:
 *               IN      hProv   -  Handle to a CSP
 *               IN      Algid   -  Algorithm identifier
 *               IN      dwFlags -  Flags values
 *               OUT     phKey   -  Handle to a generated key
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptGenKey(IN HCRYPTPROV hProv,
            IN ALG_ID Algid,
            IN DWORD dwFlags,
            OUT HCRYPTKEY * phKey)
{
    PVTableStruc    pVTable;
    PVKeyStruc      pVKey = NULL;
    BOOL            fProvCritSec = FALSE;
    DWORD           dwErr;
    BOOL            fRet = CRYPT_FAILED;

    try
    {
        pVTable = (PVTableStruc) hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        if (RCRYPT_FAILED(BuildVKey(&pVKey, pVTable)))
        {
            goto Ret;
        }

        if (RCRYPT_FAILED(pVTable->FuncGenKey(pVTable->hProv, Algid, dwFlags,
                            phKey)))
        {
            goto Ret;
        }

        pVKey->hKey = *phKey;

        *phKey = (HCRYPTKEY) pVKey;

        pVKey->Version = TABLEKEY;

        pVKey->hProv = hProv;

        pVKey->Inuse = 1;

    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    dwErr = GetLastError();
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    if (CRYPT_SUCCEED != fRet)
    {
        if (pVKey)
            LocalFree(pVKey);
        SetLastError(dwErr);
    }
    return fRet;
}

/*
 -      CryptDuplicateKey
 -
 *      Purpose:
 *                Duplicate a cryptographic key
 *
 *
 *      Parameters:
 *               IN      hKey           -  Handle to the key to be duplicated
 *               IN      pdwReserved    -  Reserved for later use
 *               IN      dwFlags        -  Flags values
 *               OUT     phKey          -  Handle to the new duplicate key
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptDuplicateKey(
                         IN HCRYPTKEY hKey,
		                 IN DWORD *pdwReserved,
		                 IN DWORD dwFlags,
		                 OUT HCRYPTKEY * phKey
                         )
{
    PVTableStruc    pVTable;
    PVKeyStruc      pVKey;
    PVKeyStruc      pVNewKey = NULL;
    HCRYPTKEY       hNewKey;
    BOOL            fProvCritSecSet = FALSE;
    DWORD           dwErr = 0;
    BOOL            fRet = CRYPT_FAILED;

    try
    {
        pVKey = (PVKeyStruc) hKey;

        if (pVKey->Version != TABLEKEY)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (NULL == pVKey->OptionalFuncDuplicateKey)
        {
            SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
            goto Ret;
        }

        pVTable = (PVTableStruc) pVKey->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }
        fProvCritSecSet = TRUE;

        if (RCRYPT_FAILED(BuildVKey(&pVNewKey, pVTable)))
        {
            goto Ret;
        }

        if (RCRYPT_FAILED(pVKey->OptionalFuncDuplicateKey(pVTable->hProv, pVKey->hKey,
                                                          pdwReserved, dwFlags, &hNewKey)))
        {
            goto Ret;
        }

        pVNewKey->hKey = hNewKey;

        pVNewKey->Version = TABLEKEY;

        pVNewKey->hProv = pVKey->hProv;

        pVKey->Inuse = 1;

        *phKey = (HCRYPTKEY) pVNewKey;
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    dwErr = GetLastError();
    if (fProvCritSecSet)
        LeaveProviderCritSec(pVTable);
    if (fRet == CRYPT_FAILED)
    {
        if (NULL != pVNewKey)
            LocalFree(pVNewKey);
        SetLastError(dwErr);
    }

    return fRet;
}

/*
 -      CryptDeriveKey
 -
 *      Purpose:
 *                Derive cryptographic keys from base data
 *
 *
 *      Parameters:
 *               IN      hProv      -  Handle to a CSP
 *               IN      Algid      -  Algorithm identifier
 *               IN      hHash      -  Handle to hash of base data
 *               IN      dwFlags    -  Flags values
 *               IN OUT  phKey      -  Handle to a generated key
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptDeriveKey(IN HCRYPTPROV hProv,
                IN ALG_ID Algid,
                IN HCRYPTHASH hHash,
                IN DWORD dwFlags,
                IN OUT HCRYPTKEY * phKey)
{
    PVTableStruc    pVTable;
    PVKeyStruc      pVKey = NULL;
    PVHashStruc     pVHash;
    BOOL            fProvCritSec = FALSE;
    BOOL            fKeyCritSec = FALSE;
    BOOL            fHashCritSec = FALSE;
    BOOL            fUpdate = FALSE;
    DWORD           dwErr;
    BOOL            fRet = CRYPT_FAILED;

    try
    {
        pVTable = (PVTableStruc) hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        pVHash = (PVHashStruc) hHash;

        if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
        {
            goto Ret;
        }
        fHashCritSec = TRUE;

        if (dwFlags & CRYPT_UPDATE_KEY)
        {
            fUpdate = TRUE;
            pVKey = (PVKeyStruc) phKey;

            if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Ret;
            }
            fKeyCritSec = TRUE;
        }
        else
        {
            if (RCRYPT_FAILED(BuildVKey(&pVKey, pVTable)))
            {
                goto Ret;
            }
        }

        if (RCRYPT_FAILED(pVTable->FuncDeriveKey(pVTable->hProv, Algid,
                        pVHash->hHash, dwFlags, phKey)))
        {
            goto Ret;
        }

        if ((dwFlags & CRYPT_UPDATE_KEY) != CRYPT_UPDATE_KEY)
        {
            pVKey->hKey = *phKey;

            *phKey = (HCRYPTKEY)pVKey;

            pVKey->hProv = hProv;

            pVKey->Version = TABLEKEY;

            pVKey->Inuse = 1;
        }

    } except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (CRYPT_SUCCEED != fRet)
        dwErr = GetLastError();
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    if (fHashCritSec)
        LeaveHashCritSec(pVHash);
    if (fKeyCritSec)
        LeaveKeyCritSec(pVKey);
    if (CRYPT_SUCCEED != fRet)
    {
        if (pVKey && (!fUpdate))
            LocalFree(pVKey);
        SetLastError(dwErr);
    }
    return fRet;
}


/*
 -      CryptDestroyKey
 -
 *      Purpose:
 *                Destroys the cryptographic key that is being referenced
 *                with the hKey parameter
 *
 *
 *      Parameters:
 *               IN      hKey   -  Handle to a key
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptDestroyKey(IN HCRYPTKEY hKey)
{
    PVTableStruc    pVTable;
    PVKeyStruc      pVKey;
    BOOL            fProvCritSec = FALSE;
    BOOL            rt;
    DWORD           dwErr;
    BOOL            fRet = CRYPT_FAILED;

    try
    {
        pVKey = (PVKeyStruc) hKey;

        if (pVKey->Version != TABLEKEY)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (0 < InterlockedDecrement(&pVKey->Inuse))
        {
            InterlockedIncrement(&pVKey->Inuse);
            SetLastError(ERROR_BUSY);
            goto Ret;
        }
        InterlockedIncrement(&pVKey->Inuse);

        pVTable = (PVTableStruc) pVKey->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        if (FALSE == (rt = pVKey->FuncDestroyKey(pVTable->hProv, pVKey->hKey)))
            dwErr = GetLastError();

        pVKey->Version = 0;
        LocalFree(pVKey);

        if (!rt)
        {
            SetLastError(dwErr);
            goto Ret;
        }
    } except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (CRYPT_SUCCEED != fRet)
        dwErr = GetLastError();
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    if (CRYPT_SUCCEED != fRet)
        SetLastError(dwErr);
    return fRet;
}


/*
 -      CryptSetKeyParam
 -
 *      Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a key
 *
 *      Parameters:
 *               IN      hKey    -  Handle to a key
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptSetKeyParam(IN HCRYPTKEY hKey,
            IN DWORD dwParam,
            IN BYTE *pbData,
            IN DWORD dwFlags)
{
    PVTableStruc    pVTable;
    PVKeyStruc      pVKey;
    BOOL            rt = CRYPT_FAILED;
    BOOL            fCritSec = FALSE;

    try
    {
        pVKey = (PVKeyStruc) hKey;

        if (pVKey->Version != TABLEKEY)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (0 < InterlockedDecrement(&pVKey->Inuse))
        {
            InterlockedIncrement(&pVKey->Inuse);
            SetLastError(ERROR_BUSY);
            goto Ret;
        }
        InterlockedIncrement(&pVKey->Inuse);

        pVTable = (PVTableStruc) pVKey->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fCritSec = TRUE;

        rt = pVKey->FuncSetKeyParam(pVTable->hProv, pVKey->hKey,
                                    dwParam, pbData, dwFlags);
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fCritSec)
        LeaveProviderCritSec(pVTable);
    return(rt);
}


/*
 -      CryptGetKeyParam
 -
 *      Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a key
 *
 *      Parameters:
 *               IN      hKey       -  Handle to a key
 *               IN      dwParam    -  Parameter number
 *               IN      pbData     -  Pointer to data
 *               IN      pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptGetKeyParam(IN HCRYPTKEY hKey,
			IN DWORD dwParam,
			IN BYTE *pbData,
			IN DWORD *pdwDataLen,
			IN DWORD dwFlags)
{
    PVTableStruc    pVTable;
    PVKeyStruc      pVKey;
    BOOL            rt = CRYPT_FAILED;
    BOOL            fKeyCritSec = FALSE;
    BOOL            fTableCritSec = FALSE;

    try
    {
        pVKey = (PVKeyStruc) hKey;

        if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
        {
            goto Ret;
        }
        fKeyCritSec = TRUE;

        pVTable = (PVTableStruc) pVKey->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fTableCritSec = TRUE;

        rt = pVKey->FuncGetKeyParam(pVTable->hProv, pVKey->hKey,
                                    dwParam, pbData, pdwDataLen,
                                    dwFlags);

    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fKeyCritSec)
        LeaveKeyCritSec(pVKey);
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    return(rt);
}


/*
 -      CryptGenRandom
 -
 *      Purpose:
 *                Used to fill a buffer with random bytes
 *
 *
 *      Parameters:
 *               IN  hProv      -  Handle to the user identifcation
 *               IN  dwLen      -  Number of bytes of random data requested
 *               OUT pbBuffer   -  Pointer to the buffer where the random
 *                                 bytes are to be placed
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptGenRandom(IN HCRYPTPROV hProv,
		      IN DWORD dwLen,
		      OUT BYTE *pbBuffer)

{
    PVTableStruc    pVTable;
    BOOL            fTableCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    try
    {
        pVTable = (PVTableStruc) hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fTableCritSec = TRUE;
    
	    rt = pVTable->FuncGenRandom(pVTable->hProv, dwLen, pbBuffer);

    } except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    return(rt);
}

/*
 -      CryptGetUserKey
 -
 *      Purpose:
 *                Gets a handle to a permanent user key
 *
 *
 *      Parameters:
 *               IN  hProv      -  Handle to the user identifcation
 *               IN  dwKeySpec  -  Specification of the key to retrieve
 *               OUT phUserKey  -  Pointer to key handle of retrieved key
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptGetUserKey(IN HCRYPTPROV hProv,
                       IN DWORD dwKeySpec,
                       OUT HCRYPTKEY *phUserKey)
{

    PVTableStruc    pVTable;
    PVKeyStruc      pVKey = NULL;
    BOOL            fTableCritSec = FALSE;
    BOOL            fRet = CRYPT_FAILED;

    try
    {
        pVTable = (PVTableStruc) hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fTableCritSec = TRUE;

        if (RCRYPT_FAILED(BuildVKey(&pVKey, pVTable)))
        {
            goto Ret;
        }

        if (RCRYPT_FAILED(pVTable->FuncGetUserKey(pVTable->hProv, dwKeySpec,
                                                  phUserKey)))
        {
            goto Ret;
        }

        pVKey->hKey = *phUserKey;

        pVKey->hProv = hProv;

        *phUserKey = (HCRYPTKEY)pVKey;

        pVKey->Version = TABLEKEY;

        pVKey->Inuse = 1;

    } except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    if ((CRYPT_SUCCEED != fRet) && pVKey)
        LocalFree(pVKey);
    return fRet;
}



/*
 -      CryptExportKey
 -
 *      Purpose:
 *                Export cryptographic keys out of a CSP in a secure manner
 *
 *
 *      Parameters:
 *               IN  hKey       - Handle to the key to export
 *               IN  hPubKey    - Handle to the exchange public key value of
 *                                the destination user
 *               IN  dwBlobType - Type of key blob to be exported
 *               IN  dwFlags -    Flags values
 *               OUT pbData -     Key blob data
 *               OUT pdwDataLen - Length of key blob in bytes
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptExportKey(IN HCRYPTKEY hKey,
                IN HCRYPTKEY hPubKey,
                IN DWORD dwBlobType,
                IN DWORD dwFlags,
                OUT BYTE *pbData,
                OUT DWORD *pdwDataLen)
{
    PVTableStruc    pVTable;
    PVKeyStruc      pVKey;
    PVKeyStruc      pVPublicKey;
    BOOL            fKeyCritSec = FALSE;
    BOOL            fPubKeyCritSec = FALSE;
    BOOL            fTableCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    try
    {
        pVKey = (PVKeyStruc) hKey;

        if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
        {
            goto Ret;
        }
        fKeyCritSec = TRUE;

        pVTable = (PVTableStruc) pVKey->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fTableCritSec = TRUE;

        pVPublicKey = (PVKeyStruc) hPubKey;

        if (pVPublicKey != NULL)
        {
            if (RCRYPT_FAILED(EnterKeyCritSec(pVPublicKey)))
            {
                goto Ret;
            }
            fPubKeyCritSec = TRUE;
        }

        rt = pVKey->FuncExportKey(pVTable->hProv, pVKey->hKey,
                                  (pVPublicKey == NULL ? 0 : pVPublicKey->hKey),
                                  dwBlobType, dwFlags, pbData,
                                  pdwDataLen);

    } except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fKeyCritSec)
        LeaveKeyCritSec(pVKey);
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    if (pVPublicKey != NULL)
    {
        if (fPubKeyCritSec)
            LeaveKeyCritSec(pVPublicKey);
    }
    return(rt);
}


/*
 -      CryptImportKey
 -
 *      Purpose:
 *                Import cryptographic keys
 *
 *
 *      Parameters:
 *               IN  hProv     -  Handle to the CSP user
 *               IN  pbData    -  Key blob data
 *               IN  dwDataLen -  Length of the key blob data
 *               IN  hPubKey   -  Handle to the exchange public key value of
 *                                the destination user
 *               IN  dwFlags   -  Flags values
 *               OUT phKey     -  Pointer to the handle to the key which was
 *                                Imported
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptImportKey(IN HCRYPTPROV hProv,
		      IN CONST BYTE *pbData,
		      IN DWORD dwDataLen,
		      IN HCRYPTKEY hPubKey,
		      IN DWORD dwFlags,
		      OUT HCRYPTKEY *phKey)
{
    PVTableStruc    pVTable;
    PVKeyStruc      pVKey = NULL;
    PVKeyStruc      pVPublicKey;
    BOOL            fKeyCritSec = FALSE;
    BOOL            fPubKeyCritSec = FALSE;
    BOOL            fTableCritSec = FALSE;
    BOOL            fBuiltKey = FALSE;
    BOOL            fRet = CRYPT_FAILED;

    try
    {
        pVTable = (PVTableStruc) hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fTableCritSec = TRUE;

        pVPublicKey = (PVKeyStruc)hPubKey;

        if (pVPublicKey != NULL)
        {
            if (RCRYPT_FAILED(EnterKeyCritSec(pVPublicKey)))
            {
                goto Ret;
            }
            fPubKeyCritSec = TRUE;
        }

        if (dwFlags & CRYPT_UPDATE_KEY)
        {
            pVKey = (PVKeyStruc) phKey;

            if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
            {
                goto Ret;
            }
            fKeyCritSec = TRUE;
        }
        else
        {
            if (RCRYPT_FAILED(BuildVKey(&pVKey, pVTable)))
            {
                goto Ret;
            }
            fBuiltKey = TRUE;
        }

        if (RCRYPT_FAILED(pVTable->FuncImportKey(pVTable->hProv, pbData,
                                                 dwDataLen,
                                                 (pVPublicKey == NULL ? 0 : pVPublicKey->hKey),
                                                 dwFlags, phKey)))
        {
            goto Ret;
	    }

	    if ((dwFlags & CRYPT_UPDATE_KEY) != CRYPT_UPDATE_KEY)
	    {
            pVKey->hKey = *phKey;

            *phKey = (HCRYPTKEY) pVKey;

            pVKey->hProv = hProv;

            pVKey->Version = TABLEKEY;
        }
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    if (pVPublicKey != NULL)
    {
        if (fPubKeyCritSec)
            LeaveKeyCritSec(pVPublicKey);
    }
    if ((dwFlags & CRYPT_UPDATE_KEY) && fKeyCritSec)
    {
        LeaveKeyCritSec(pVKey);
    }
    else if ((CRYPT_SUCCEED != fRet) && fBuiltKey && pVKey)
    {
        LocalFree(pVKey);
    }

    return fRet;
}


/*
 -      CryptEncrypt
 -
 *      Purpose:
 *                Encrypt data
 *
 *
 *      Parameters:
 *               IN  hKey          -  Handle to the key
 *               IN  hHash         -  Optional handle to a hash
 *               IN  Final         -  Boolean indicating if this is the final
 *                                    block of plaintext
 *               IN  dwFlags       -  Flags values
 *               IN OUT pbData     -  Data to be encrypted
 *               IN OUT pdwDataLen -  Pointer to the length of the data to be
 *                                    encrypted
 *               IN dwBufLen       -  Size of Data buffer
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptEncrypt(IN HCRYPTKEY hKey,
            IN HCRYPTHASH hHash,
		    IN BOOL Final,
		    IN DWORD dwFlags,
		    IN OUT BYTE *pbData,
		    IN OUT DWORD *pdwDataLen,
		    IN DWORD dwBufLen)
{
    PVTableStruc    pVTable;
    PVKeyStruc      pVKey;
    PVHashStruc     pVHash;
    BOOL            fKeyCritSec = FALSE;
    BOOL            fTableCritSec = FALSE;
    BOOL            fHashCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    try
    {
        pVKey = (PVKeyStruc) hKey;

        if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
        {
            goto Ret;
        }
        fKeyCritSec = TRUE;

        pVTable = (PVTableStruc) pVKey->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fTableCritSec = TRUE;

        pVHash = (PVHashStruc) hHash;

        if (pVHash != NULL)
        {
            if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
            {
                goto Ret;
            }
            fHashCritSec = TRUE;
        }

        rt = pVKey->FuncEncrypt(pVTable->hProv, pVKey->hKey,
                                (pVHash == NULL ? 0 : pVHash->hHash),
                                Final, dwFlags, pbData,
                                pdwDataLen, dwBufLen);

    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    if (fKeyCritSec)
        LeaveKeyCritSec(pVKey);
    if (pVHash != NULL)
    {
        if (fHashCritSec)
            LeaveHashCritSec(pVHash);
    }
    return rt;
}


/*
 -      CryptDecrypt
 -
 *      Purpose:
 *                Decrypt data
 *
 *
 *      Parameters:
 *               IN  hKey          -  Handle to the key
 *               IN  hHash         -  Optional handle to a hash
 *               IN  Final         -  Boolean indicating if this is the final
 *                                    block of ciphertext
 *               IN  dwFlags       -  Flags values
 *               IN OUT pbData     -  Data to be decrypted
 *               IN OUT pdwDataLen -  Pointer to the length of the data to be
 *                                    decrypted
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptDecrypt(IN HCRYPTKEY hKey,
		    IN HCRYPTHASH hHash,
		    IN BOOL Final,
		    IN DWORD dwFlags,
		    IN OUT BYTE *pbData,
		    IN OUT DWORD *pdwDataLen)

{
    PVTableStruc    pVTable;
    PVKeyStruc      pVKey;
    PVHashStruc     pVHash;
    BOOL            fKeyCritSec = FALSE;
    BOOL            fTableCritSec = FALSE;
    BOOL            fHashCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    try
    {
        pVKey = (PVKeyStruc) hKey;

        if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
        {
            goto Ret;
        }
        fKeyCritSec = TRUE;

        pVTable = (PVTableStruc) pVKey->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fTableCritSec = TRUE;

        pVHash = (PVHashStruc) hHash;

        if (pVHash != NULL)
        {
            if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
            {
                goto Ret;
            }
            fHashCritSec = TRUE;
        }
    
        rt = pVKey->FuncDecrypt(pVTable->hProv, pVKey->hKey,
                                (pVHash == NULL ? 0 : pVHash->hHash),
                                Final, dwFlags, pbData, pdwDataLen);
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    if (fKeyCritSec)
        LeaveKeyCritSec(pVKey);
	if (pVHash != NULL)
    {
        if (fHashCritSec)
            LeaveHashCritSec(pVHash);
    }
    return(rt);
}


/*
 -      CryptCreateHash
 -
 *      Purpose:
 *                initate the hashing of a stream of data
 *
 *
 *      Parameters:
 *               IN  hProv   -  Handle to the user identifcation
 *               IN  Algid   -  Algorithm identifier of the hash algorithm
 *                              to be used
 *               IN  hKey    -  Optional key for MAC algorithms
 *               IN  dwFlags -  Flags values
 *               OUT pHash   -  Handle to hash object
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptCreateHash(IN HCRYPTPROV hProv,
		       IN ALG_ID Algid,
		       IN HCRYPTKEY hKey,
		       IN DWORD dwFlags,
		       OUT HCRYPTHASH *phHash)
{
    PVTableStruc    pVTable;
    DWORD           bufsize;
    PVKeyStruc      pVKey;
    PVHashStruc     pVHash = NULL;
    BOOL            fTableCritSec = FALSE;
    BOOL            fKeyCritSec = FALSE;
    BOOL            fRet = CRYPT_FAILED;

    try
    {
        pVTable = (PVTableStruc) hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }
        fTableCritSec = TRUE;

        pVKey = (PVKeyStruc) hKey;

        if (pVKey != NULL)
        {
            if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Ret;
            }
            fKeyCritSec = TRUE;
        }

        bufsize = sizeof(VHashStruc);

        if (!BuildVHash(&pVHash, pVTable))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        if (RCRYPT_FAILED(pVTable->FuncCreateHash(pVTable->hProv, Algid,
                                                  (pVKey == NULL ? 0 : pVKey->hKey),
                                                  dwFlags, phHash)))
	    {
            goto Ret;
	    }

        pVHash->hHash = *phHash;

        *phHash = (HCRYPTHASH) pVHash;

        pVHash->Version = TABLEHASH;

        pVHash->Inuse = 1;
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    if (pVKey != NULL)
    {
        if (fKeyCritSec)
            LeaveKeyCritSec(pVKey);
    }
    if ((CRYPT_SUCCEED != fRet) && pVHash)
        LocalFree(pVHash);
    return fRet;
}

/*
 -      CryptDuplicateHash
 -
 *      Purpose:
 *                Duplicate a cryptographic hash
 *
 *
 *      Parameters:
 *               IN      hHash          -  Handle to the hash to be duplicated
 *               IN      pdwReserved    -  Reserved for later use
 *               IN      dwFlags        -  Flags values
 *               OUT     phHash         -  Handle to the new duplicate hash
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptDuplicateHash(
                         IN HCRYPTHASH hHash,
		                 IN DWORD *pdwReserved,
		                 IN DWORD dwFlags,
		                 OUT HCRYPTHASH * phHash
                         )
{
    PVTableStruc    pVTable;
    PVHashStruc     pVHash;
    PVHashStruc     pVNewHash = NULL;
    HCRYPTHASH      hNewHash;
    BOOL            fProvCritSecSet = FALSE;
    DWORD           dwErr;
    BOOL            fRet = CRYPT_FAILED;

    try
    {
        pVHash = (PVHashStruc) hHash;

        if (pVHash->Version != TABLEHASH)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (NULL == pVHash->OptionalFuncDuplicateHash)
        {
            SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
            goto Ret;
        }

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        fProvCritSecSet = TRUE;


        if (RCRYPT_FAILED(BuildVHash(&pVNewHash, pVTable)))
        {
            goto Ret;
        }

        if (RCRYPT_FAILED(pVHash->OptionalFuncDuplicateHash(pVTable->hProv, pVHash->hHash,
                                                          pdwReserved, dwFlags, &hNewHash)))
        {
            goto Ret;
        }

        pVNewHash->hHash = hNewHash;

        pVNewHash->Version = TABLEHASH;

        pVNewHash->hProv = pVHash->hProv;

        pVHash->Inuse = 1;

        *phHash = (HCRYPTHASH) pVNewHash;
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (CRYPT_SUCCEED != fRet)
        dwErr = GetLastError();
    if ((fRet == CRYPT_FAILED) && (NULL != pVNewHash))
        LocalFree(pVNewHash);
    if (fProvCritSecSet)
        LeaveProviderCritSec(pVTable);
    if (CRYPT_SUCCEED != fRet)
        SetLastError(dwErr);

    return fRet;
}

/*
 -      CryptHashData
 -
 *      Purpose:
 *                Compute the cryptograghic hash on a stream of data
 *
 *
 *      Parameters:
 *               IN  hHash     -  Handle to hash object
 *               IN  pbData    -  Pointer to data to be hashed
 *               IN  dwDataLen -  Length of the data to be hashed
 *               IN  dwFlags   -  Flags values
 *
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptHashData(IN HCRYPTHASH hHash,
		     IN CONST BYTE *pbData,
		     IN DWORD dwDataLen,
		     IN DWORD dwFlags)
{
    PVTableStruc    pVTable;
    PVHashStruc     pVHash;
    BOOL            fProvCritSec = FALSE;
    BOOL            fHashCritSec = FALSE;
    DWORD           dwErr;
    BOOL            fRet = CRYPT_FAILED;

    try
    {
        pVHash = (PVHashStruc) hHash;

        if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
        {
            goto Ret;
        }
        fHashCritSec = TRUE;

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        if (!pVHash->FuncHashData(pVTable->hProv,
                                  pVHash->hHash,
                                  pbData, dwDataLen, dwFlags))
            goto Ret;

    } except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (CRYPT_SUCCEED != fRet)
        dwErr = GetLastError();
    if (fHashCritSec)
        LeaveHashCritSec(pVHash);
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    if (CRYPT_SUCCEED != fRet)
        SetLastError(dwErr);

    return fRet;

}

/*
 -      CryptHashSessionKey
 -
 *      Purpose:
 *                Compute the cryptograghic hash on a key object
 *
 *
 *      Parameters:
 *               IN  hHash     -  Handle to hash object
 *               IN  hKey      -  Handle to a key object
 *               IN  dwFlags   -  Flags values
 *
 *      Returns:
 *               CRYPT_FAILED
 *               CRYPT_SUCCEED
 */
WINADVAPI
BOOL
WINAPI CryptHashSessionKey(IN HCRYPTHASH hHash,
			   IN  HCRYPTKEY hKey,
			   IN DWORD dwFlags)
{
    PVTableStruc    pVTable;
    PVHashStruc     pVHash;
    PVKeyStruc      pVKey;
    BOOL            fHashCritSec = FALSE;
    BOOL            fProvCritSec = FALSE;
    BOOL            fKeyCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    try
    {
        pVHash = (PVHashStruc) hHash;

        if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
        {
            goto Ret;
        }
        fHashCritSec = TRUE;

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        pVKey = (PVKeyStruc) hKey;

        if (pVKey != NULL)
        {
            if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
            {
                goto Ret;
            }
            fKeyCritSec = TRUE;
        }

        rt = pVHash->FuncHashSessionKey(pVTable->hProv,
                                        pVHash->hHash,
                                        pVKey->hKey,
                                        dwFlags);

    } except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fHashCritSec)
        LeaveHashCritSec(pVHash);
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    if (pVKey != NULL)
    {
        if (fKeyCritSec)
            LeaveKeyCritSec(pVKey);
    }
    return rt;
}


/*
 -      CryptDestoryHash
 -
 *      Purpose:
 *                Destory the hash object
 *
 *
 *      Parameters:
 *               IN  hHash     -  Handle to hash object
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptDestroyHash(IN HCRYPTHASH hHash)
{
    PVTableStruc    pVTable;
    PVHashStruc     pVHash;
    BOOL            fProvCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    try
    {
        pVHash = (PVHashStruc) hHash;

        if (pVHash->Version != TABLEHASH)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (0 < InterlockedDecrement(&pVHash->Inuse))
        {
            InterlockedIncrement(&pVHash->Inuse);
            SetLastError(ERROR_BUSY);
            goto Ret;
        }
        InterlockedIncrement(&pVHash->Inuse);

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        rt = pVHash->FuncDestroyHash(pVTable->hProv, pVHash->hHash);

        pVHash->Version = 0;
        LocalFree(pVHash);
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    return rt;
}

WINADVAPI
BOOL
WINAPI LocalSignHashW(IN  HCRYPTHASH hHash,
		      IN  DWORD dwKeySpec,
		      IN  LPCWSTR sDescription,
		      IN  DWORD dwFlags,
		      OUT BYTE *pbSignature,
		      OUT DWORD *pdwSigLen)
{
    PVTableStruc    pVTable;
    PVHashStruc     pVHash;
    BOOL            fHashCritSec = FALSE;
    BOOL            fProvCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    try
    {
        pVHash = (PVHashStruc) hHash;

        if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
        {
            goto Ret;
        }
        fHashCritSec = TRUE;

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        rt = pVHash->FuncSignHash(pVTable->hProv, pVHash->hHash,
                                  dwKeySpec,
                                  sDescription, dwFlags,
                                  pbSignature, pdwSigLen);
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fHashCritSec)
        LeaveHashCritSec(pVHash);
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    return rt;
}


/*
 -      CryptSignHashW
 -
 *      Purpose:
 *                Create a digital signature from a hash
 *
 *
 *      Parameters:
 *               IN  hHash        -  Handle to hash object
 *               IN  dwKeySpec    -  Key pair that is used to sign with
 *                                   algorithm to be used
 *               IN  sDescription -  Description of data to be signed
 *               IN  dwFlags      -  Flags values
 *               OUT pbSignture   -  Pointer to signature data
 *               OUT pdwSigLen    -  Pointer to the len of the signature data
 *
 *      Returns:
 */
#ifndef WIN95
WINADVAPI
BOOL
WINAPI CryptSignHashW(IN  HCRYPTHASH hHash,
		      IN  DWORD dwKeySpec,
		      IN  LPCWSTR sDescription,
		      IN  DWORD dwFlags,
		      OUT BYTE *pbSignature,
		      OUT DWORD *pdwSigLen)
{
    return LocalSignHashW(hHash, dwKeySpec, sDescription,
                          dwFlags, pbSignature, pdwSigLen);
}
#else
WINADVAPI
BOOL
WINAPI CryptSignHashW(IN  HCRYPTHASH hHash,
		      IN  DWORD dwKeySpec,
		      IN  LPCWSTR sDescription,
		      IN  DWORD dwFlags,
		      OUT BYTE *pbSignature,
		      OUT DWORD *pdwSigLen)
{
    SetLastError((DWORD)ERROR_CALL_NOT_IMPLEMENTED);
    return CRYPT_FAILED;
}
#endif



WINADVAPI
BOOL
WINAPI LocalVerifySignatureW(IN HCRYPTHASH hHash,
			     IN CONST BYTE *pbSignature,
			     IN DWORD dwSigLen,
			     IN HCRYPTKEY hPubKey,
			     IN LPCWSTR sDescription,
			     IN DWORD dwFlags)
{
    PVTableStruc    pVTable;
    PVHashStruc     pVHash;
    PVKeyStruc      pVKey;
    BOOL            fHashCritSec = FALSE;
    BOOL            fProvCritSec = FALSE;
    BOOL            fKeyCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    try
    {
        pVHash = (PVHashStruc) hHash;

        if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
        {
            goto Ret;
        }
        fHashCritSec = TRUE;

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        pVKey = (PVKeyStruc) hPubKey;

        if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
        {
            goto Ret;
        }
        fKeyCritSec = TRUE;

        rt = pVHash->FuncVerifySignature(pVTable->hProv,
                        pVHash->hHash, pbSignature,
                        dwSigLen,
                        (pVKey == NULL ? 0 : pVKey->hKey),
                        sDescription, dwFlags);
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fHashCritSec)
        LeaveHashCritSec(pVHash);
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    if (fKeyCritSec)
        LeaveKeyCritSec(pVKey);
    return rt;
}

/*
 -      CryptVerifySignatureW
 -
 *      Purpose:
 *                Used to verify a signature against a hash object
 *
 *
 *      Parameters:
 *               IN  hHash        -  Handle to hash object
 *               IN  pbSignture   -  Pointer to signature data
 *               IN  dwSigLen     -  Length of the signature data
 *               IN  hPubKey      -  Handle to the public key for verifying
 *                                   the signature
 *               IN  sDescription -  String describing the signed data
 *               IN  dwFlags      -  Flags values
 *
 *      Returns:
 */
#ifndef WIN95
WINADVAPI
BOOL
WINAPI CryptVerifySignatureW(IN HCRYPTHASH hHash,
			     IN CONST BYTE *pbSignature,
			     IN DWORD dwSigLen,
			     IN HCRYPTKEY hPubKey,
			     IN LPCWSTR sDescription,
			     IN DWORD dwFlags)
{
    return LocalVerifySignatureW(hHash, pbSignature, dwSigLen,
			                     hPubKey, sDescription, dwFlags);
}
#else
WINADVAPI
BOOL
WINAPI CryptVerifySignatureW(IN HCRYPTHASH hHash,
			     IN CONST BYTE *pbSignature,
			     IN DWORD dwSigLen,
			     IN HCRYPTKEY hPubKey,
			     IN LPCWSTR sDescription,
			     IN DWORD dwFlags)
{
    SetLastError((DWORD)ERROR_CALL_NOT_IMPLEMENTED);
    return CRYPT_FAILED;
}
#endif



/*
 -      CryptSetProvParam
 -
 *      Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a provider
 *
 *      Parameters:
 *               IN      hProv   -  Handle to a provider
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptSetProvParam(IN HCRYPTPROV hProv,
			 IN DWORD dwParam,
			 IN BYTE *pbData,
			 IN DWORD dwFlags)
{
    PVTableStruc    pVTable;
    BYTE            *pbTmp;
    CRYPT_DATA_BLOB *pBlob;
    BOOL            rt = CRYPT_FAILED;

    try
    {
        if (dwParam == PP_CLIENT_HWND)
        {
            hWnd = *((DWORD *) pbData);
            rt = CRYPT_SUCCEED;
            goto Ret;
        }
        else if (dwParam == PP_CONTEXT_INFO)
        {
            pBlob = (CRYPT_DATA_BLOB*)pbData;

            // allocate space for the new context info
            if (NULL == (pbTmp = (BYTE*)LocalAlloc(LMEM_ZEROINIT, pBlob->cbData)))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }
            memcpy(pbTmp, pBlob->pbData, pBlob->cbData);

            // free any previously allocated context info
            if (NULL != pbContextInfo)
            {
                LocalFree(pbContextInfo);
            }
            cbContextInfo = pBlob->cbData;
            pbContextInfo = pbTmp;

            rt = CRYPT_SUCCEED;
            goto Ret;
        }

        pVTable = (PVTableStruc) hProv;

        if (pVTable->Version != TABLEPROV)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (0 < InterlockedDecrement(&pVTable->Inuse))
        {
            InterlockedIncrement(&pVTable->Inuse);
            SetLastError(ERROR_BUSY);
            goto Ret;
        }
        InterlockedIncrement(&pVTable->Inuse);

        rt = pVTable->FuncSetProvParam(pVTable->hProv, dwParam, pbData,
                                       dwFlags);
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    return(rt);
}


/*
 -      CryptGetProvParam
 -
 *      Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a provider
 *
 *      Parameters:
 *               IN      hProv      -  Handle to a proivder
 *               IN      dwParam    -  Parameter number
 *               IN      pbData     -  Pointer to data
 *               IN      pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptGetProvParam(IN HCRYPTPROV hProv,
			 IN DWORD dwParam,
			 IN BYTE *pbData,
			 IN DWORD *pdwDataLen,
			 IN DWORD dwFlags)
{
    PVTableStruc    pVTable;
    BOOL            fProvCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    try
    {
        pVTable = (PVTableStruc) hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        rt = pVTable->FuncGetProvParam(pVTable->hProv, dwParam, pbData,
                                       pdwDataLen, dwFlags);
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    return rt;
}


/*
 -      CryptSetHashParam
 -
 *      Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a hash
 *
 *      Parameters:
 *               IN      hHash   -  Handle to a hash
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptSetHashParam(IN HCRYPTHASH hHash,
			 IN DWORD dwParam,
			 IN BYTE *pbData,
			 IN DWORD dwFlags)
{
    PVTableStruc    pVTable;
    PVHashStruc     pVHash;
    BOOL            fProvCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    try
    {
        pVHash = (PVHashStruc) hHash;

        if (pVHash->Version != TABLEHASH)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (0 < InterlockedDecrement(&pVHash->Inuse))
        {
            InterlockedIncrement(&pVHash->Inuse);
            SetLastError(ERROR_BUSY);
            goto Ret;
        }
        InterlockedIncrement(&pVHash->Inuse);

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        rt = pVHash->FuncSetHashParam(pVTable->hProv, pVHash->hHash,
                                      dwParam, pbData, dwFlags);
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    return rt;
}


/*
 -      CryptGetHashParam
 -
 *      Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a hash
 *
 *      Parameters:
 *               IN      hHash      -  Handle to a hash
 *               IN      dwParam    -  Parameter number
 *               IN      pbData     -  Pointer to data
 *               IN      pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptGetHashParam(IN HCRYPTKEY hHash,
			 IN DWORD dwParam,
			 IN BYTE *pbData,
			 IN DWORD *pdwDataLen,
			 IN DWORD dwFlags)
{
    PVTableStruc    pVTable;
    PVHashStruc     pVHash;
    BOOL            fHashCritSec = FALSE;
    BOOL            fProvCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    try
    {
        pVHash = (PVHashStruc) hHash;

        if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
        {
            goto Ret;
        }
        fHashCritSec = TRUE;

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        rt = pVHash->FuncGetHashParam(pVTable->hProv, pVHash->hHash,
                                      dwParam, pbData, pdwDataLen,
                                      dwFlags);
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fHashCritSec)
        LeaveHashCritSec(pVHash);
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    return rt;
}



/*
 -      CryptSetProviderW
 -
 *      Purpose:
 *                Set a cryptography provider
 *
 *
 *      Parameters:
 *
 *                IN  pszProvName    - Name of the provider to install
 *                IN  dwProvType     - Type of the provider to install
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptSetProviderW(IN LPCWSTR pszProvName,
			 IN DWORD  dwProvType)
{
    HKEY        hKey = 0;
    LONG        err;
    DWORD       dwIgn;
    DWORD       cbValue;
    WCHAR        *pszValue = NULL;
    WCHAR       typebuf[9]; // sfield = {0, 0, 0, 0, 0, 0, 0, 0, 0};
    BOOL        fRet = CRYPT_FAILED;

#ifndef XBOX

    try
    {
        if (dwProvType == 0 || dwProvType > 999 || pszProvName == NULL)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        cbValue = (lstrlenW(pszProvName) + 1 ) * sizeof(WCHAR);

        if ((pszValue = (WCHAR *) LocalAlloc(LMEM_ZEROINIT,
                        sizeof(szusertypeW) + ((5 + 1) * sizeof(WCHAR))
                        )) == NULL)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        lstrcpyW(pszValue, szusertypeW);
        __ltoaW(dwProvType, typebuf);
        lstrcatW(pszValue, &typebuf[5]);

        if ((err = RegCreateKeyExW(HKEY_CURRENT_USER,
                        (const WCHAR *) pszValue,
                        0L, L"", REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE, NULL, &hKey,
                        &dwIgn)) != ERROR_SUCCESS)
        {
            SetLastError(err);
            goto Ret;
        }

        RegCloseKey(HKEY_CURRENT_USER);

        if ((err = RegSetValueExW(hKey, L"Name", 0L, REG_SZ,
                        (const LPBYTE) pszProvName,
                        cbValue)) != ERROR_SUCCESS)
        {
            SetLastError(err);
            goto Ret;
        }

    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (pszValue)
        LocalFree(pszValue);
    if (hKey)
        RegCloseKey(hKey);
#endif

    return fRet;
}


/*
 -      CryptSetProviderExW
 -
 *      Purpose:
 *                Set the cryptographic provider as the default
 *                either for machine or for user.
 *
 *
 *      Parameters:
 *
 *                IN  pszProvName    - Name of the provider to install
 *                IN  dwProvType     - Type of the provider to install
 *                IN  pdwReserved    - Reserved for future use
 *                IN  dwFlags        - Flags parameter (for machine or for user)
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptSetProviderExW(
                           IN LPCWSTR pszProvName,
                           IN DWORD dwProvType,
                           IN DWORD *pdwReserved,
                           IN DWORD dwFlags
                           )
{
    HKEY        hRegKey = 0;
    LONG        err;
    DWORD       dwDisp;
    DWORD       cbValue;
    WCHAR        *pszValue = NULL;
    WCHAR        *pszFullName = NULL;
    DWORD       cbFullName;
    WCHAR        typebuf[9]; // sfield: = {0, 0, 0, 0, 0, 0, 0, 0, 0};
    DWORD       dwKeyType;
    DWORD       dw;
    DWORD       cbProvType;
    BOOL        fRet = CRYPT_FAILED;

#ifndef XBOX

    try
    {
        if ((dwProvType == 0) || (dwProvType > 999) ||
            (pszProvName == NULL) || (pdwReserved != NULL))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if ((dwFlags & ~(CRYPT_MACHINE_DEFAULT | CRYPT_USER_DEFAULT | CRYPT_DELETE_DEFAULT)) ||
            ((dwFlags & CRYPT_MACHINE_DEFAULT) && (dwFlags & CRYPT_USER_DEFAULT)))
        {
            SetLastError((DWORD)NTE_BAD_FLAGS);
            goto Ret;
        }

        cbValue = (lstrlenW(pszProvName) + 1) * sizeof(WCHAR);

        // check if the CSP has been installed
        cbFullName = cbValue + sizeof(szenumprovidersW) + sizeof(WCHAR);

        if (NULL == (pszFullName = (WCHAR *) LocalAlloc(LMEM_ZEROINIT, cbFullName)))
	    {
		    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		    goto Ret;
	    }

        lstrcpyW(pszFullName, szenumprovidersW);
        pszFullName[(sizeof(szenumprovidersW) / sizeof(WCHAR)) - 1] = L'\\';
        lstrcpyW((LPWSTR)((LPBYTE)pszFullName + sizeof(szenumprovidersW)), pszProvName);

        if ((err = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                        (const WCHAR *) pszFullName,
                        0L, KEY_READ, &hRegKey)) != ERROR_SUCCESS)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        cbProvType = sizeof(dw);
        if (ERROR_SUCCESS != (err = RegQueryValueExW(hRegKey,
                                                    (const WCHAR *) L"Type",
                                                    NULL, &dwKeyType, (BYTE*)&dw,
                                                    &cbProvType)))
        {
            SetLastError(err);
            goto Ret;
        }
        if (dwProvType != dw)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (ERROR_SUCCESS != (err = RegCloseKey(hRegKey)))
        {
            SetLastError(err);
            goto Ret;
        }

	    if (dwFlags & CRYPT_MACHINE_DEFAULT)
	    {
            if ((pszValue = (WCHAR *) LocalAlloc(LMEM_ZEROINIT,
                            (lstrlenW(szmachinetypeW) + 5 + 1) * sizeof(WCHAR) )) == NULL)
		    {
			    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			    goto Ret;
		    }

            lstrcpyW(pszValue, szmachinetypeW);
            __ltoaW(dwProvType, typebuf);
            lstrcatW(pszValue, &typebuf[5]);

            if ((err = RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                            (const WCHAR *) pszValue,
                            0L, NULL, REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_WRITE, NULL, &hRegKey, &dwDisp)) != ERROR_SUCCESS)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Ret;
            }

            // check the delete flag
            if (dwFlags & CRYPT_DELETE_DEFAULT)
            {
                if (ERROR_SUCCESS != (err = RegDeleteKeyW(HKEY_LOCAL_MACHINE,
                                                         (const WCHAR *)pszValue)))
                {
                    SetLastError(err);
                    goto Ret;
                }
                fRet = CRYPT_SUCCEED;
                goto Ret;
            }
	    }
	    else if (dwFlags & CRYPT_USER_DEFAULT)
	    {
            if ((pszValue = (WCHAR *) LocalAlloc(LMEM_ZEROINIT,
                            (lstrlenW(szusertypeW) + 5 + 1) * sizeof(WCHAR) )) == NULL)
		    {
			    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			    goto Ret;
		    }

            lstrcpyW(pszValue, szusertypeW);
            __ltoaW(dwProvType, typebuf);
            lstrcatW(pszValue, &typebuf[5]);

            if ((err = RegCreateKeyExW(HKEY_CURRENT_USER,
                            (const WCHAR *) pszValue,
                            0L, NULL, REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_WRITE, NULL, &hRegKey, &dwDisp)) != ERROR_SUCCESS)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Ret;
            }


            // check the delete flag
            if (dwFlags & CRYPT_DELETE_DEFAULT)
            {
                if (ERROR_SUCCESS != (err = RegDeleteKeyW(HKEY_CURRENT_USER,
                                                         (const WCHAR *)pszValue)))
                {
                    RegCloseKey(HKEY_CURRENT_USER);
                    SetLastError(err);
                    goto Ret;
                }
                fRet = CRYPT_SUCCEED;
                RegCloseKey(HKEY_CURRENT_USER);
                goto Ret;
            }
            RegCloseKey(HKEY_CURRENT_USER);
	    }

        if (ERROR_SUCCESS != (err = RegSetValueExW(hRegKey, L"Name", 0L, REG_SZ,
                                                  (const LPBYTE) pszProvName, cbValue)))
	    {
		    SetLastError(err);
		    goto Ret;
	    }
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

	fRet = CRYPT_SUCCEED;
Ret:
    if (pszFullName)
        LocalFree(pszFullName);
    if (pszValue)
        LocalFree(pszValue);
    if (hRegKey)
        RegCloseKey(hRegKey);
#endif

    return fRet;
}

/*
 -      CryptGetDefaultProviderW
 -
 *      Purpose:
 *                Get the default cryptographic provider of the specified
 *                type for either the machine or for the user.
 *
 *
 *      Parameters:
 *                IN  dwProvType     - Type of the provider to install
 *                IN  pdwReserved    - Reserved for future use
 *                IN  dwFlags        - Flags parameter (for machine or for user)
 *                OUT pszProvName    - Name of the default provider
 *                IN OUT pcbProvName - Length in bytes of the provider name
 *                                     including the NULL terminator
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINAPI CryptGetDefaultProviderW(
                                IN DWORD dwProvType,
                                IN DWORD *pdwReserved,
                                IN DWORD dwFlags,
                                OUT LPWSTR pszProvName,
                                IN OUT DWORD *pcbProvName
                                )
{
    HKEY        hRegKey = 0;
    LONG        err;
    WCHAR        *pszValue = NULL;
    DWORD       dwValType;
    WCHAR        typebuf[9]; // sfield = {0, 0, 0, 0, 0, 0, 0, 0, 0};
    DWORD       cbProvName = 0;
    BOOL        fRet = CRYPT_FAILED;

#ifndef XBOX

    try
    {
        if (dwProvType == 0 || dwProvType > 999 || pdwReserved != NULL)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if ((dwFlags & ~(CRYPT_MACHINE_DEFAULT | CRYPT_USER_DEFAULT)) ||
            ((dwFlags & CRYPT_MACHINE_DEFAULT) && (dwFlags & CRYPT_USER_DEFAULT)))
        {
            SetLastError((DWORD)NTE_BAD_FLAGS);
            goto Ret;
        }

        if (dwFlags & CRYPT_MACHINE_DEFAULT)
        {
            if ((pszValue = (WCHAR *) LocalAlloc(LMEM_ZEROINIT,
                            sizeof(szmachinetypeW) + ((5 + 1) * sizeof(WCHAR)))) == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            lstrcpyW(pszValue, szmachinetypeW);
            __ltoaW(dwProvType, typebuf);
            lstrcatW(pszValue, &typebuf[5]);

            if ((err = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                            (const WCHAR *) pszValue,
                            0L, KEY_READ, &hRegKey)) != ERROR_SUCCESS)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Ret;
            }
        }
        else
        {
            if ((pszValue = (WCHAR *) LocalAlloc(LMEM_ZEROINIT,
                            sizeof(szusertypeW) + ((5 + 1) * sizeof(WCHAR)))) == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            lstrcpyW(pszValue, szusertypeW);
            __ltoaW(dwProvType, typebuf);
            lstrcatW(pszValue, &typebuf[5]);

            if ((err = RegOpenKeyExW(HKEY_CURRENT_USER,
                            (const WCHAR *) pszValue,
                            0L, KEY_READ, &hRegKey)) != ERROR_SUCCESS)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Ret;
            }
            RegCloseKey(HKEY_CURRENT_USER);
        }

        if ((err = RegQueryValueExW(hRegKey, L"Name", 0L, &dwValType,
                        NULL,
                        &cbProvName)) != ERROR_SUCCESS)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (NULL == pszProvName)
        {
            fRet = CRYPT_SUCCEED;
            goto Ret;
        }

        if (cbProvName > *pcbProvName)
        {
            SetLastError(ERROR_MORE_DATA);
            goto Ret;
        }

        if ((err = RegQueryValueExW(hRegKey, L"Name", 0L, &dwValType,
                        (BYTE*)pszProvName,
                        &cbProvName)) != ERROR_SUCCESS)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;

Ret:
    *pcbProvName = cbProvName;
    if (hRegKey)
        RegCloseKey(hRegKey);
    if (pszValue)
        LocalFree(pszValue);
#endif

    return fRet;
}


/*
 -      CryptEnumProviderTypesW
 -
 *      Purpose:
 *                Enumerate the provider types.
 *
 *      Parameters:
 *                IN  dwIndex        - Index to the provider types to enumerate
 *                IN  pdwReserved    - Reserved for future use
 *                IN  dwFlags        - Flags parameter
 *                OUT pdwProvType    - Pointer to the provider type
 *                OUT pszTypeName    - Name of the enumerated provider type
 *                IN OUT pcbTypeName - Length of the enumerated provider type
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptEnumProviderTypesW(
                               IN DWORD dwIndex,
                               IN DWORD *pdwReserved,
                               IN DWORD dwFlags,
                               OUT DWORD *pdwProvType,
                               OUT LPWSTR pszTypeName,
                               IN OUT DWORD *pcbTypeName
                               )
{
    HKEY        hRegKey = 0;
    LONG        err;
    WCHAR        *pszRegKeyName = NULL;
    DWORD       cbClass;
    FILETIME    ft;
    WCHAR        rgcType[] = {L'T', L'y', L'p', L'e', L' '};
    LPWSTR       pszValue;
    long        Type;
    DWORD       cSubKeys;
    DWORD       cbMaxKeyName;
    DWORD       cbMaxClass;
    DWORD       cValues;
    DWORD       cbMaxValName;
    DWORD       cbMaxValData;
    BOOL        fRet = CRYPT_FAILED;

#ifndef XBOX
    try
    {
        if (0 != dwFlags)
        {
            SetLastError((DWORD)NTE_BAD_FLAGS);
            goto Ret;
        }

        if (NULL != pdwReserved)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (NULL != pcbTypeName)
        {
            *pcbTypeName = 0;   // we never return type names
        }

        if (ERROR_SUCCESS != (err = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                                 (const WCHAR *) szprovidertypesW,
                                                 0L,
                                                 KEY_READ,
                                                 &hRegKey)))
        {
            SetLastError(err);
            goto Ret;
        }

        if (ERROR_SUCCESS != (err = RegQueryInfoKeyW(hRegKey,
                                                    NULL,
                                                    &cbClass,
                                                    NULL,
                                                    &cSubKeys,
                                                    &cbMaxKeyName,
                                                    &cbMaxClass,
                                                    &cValues,
                                                    &cbMaxValName,
                                                    &cbMaxValData,
                                                    NULL,
                                                    &ft)))
        {
            SetLastError(err);
            goto Ret;
        }
        ++cbMaxKeyName;     // allow for trailing NULL
        if (NULL == (pszRegKeyName = LocalAlloc(LMEM_ZEROINIT, cbMaxKeyName*sizeof(WCHAR))))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        if (ERROR_SUCCESS != (err = RegEnumKeyExW(hRegKey,
                                                 dwIndex, pszRegKeyName, &cbMaxKeyName, NULL,
                                                 NULL, NULL, &ft)))
        {
            SetLastError(err);
            goto Ret;
        }

        if (memcmp(pszRegKeyName, rgcType, sizeof(rgcType)))
        {
            SetLastError((DWORD)NTE_FAIL);
            goto Ret;
        }
        pszValue = pszRegKeyName + sizeof(rgcType)/sizeof(TCHAR);

        if (0 == (Type = StrToLW(pszValue)))
        {
            SetLastError((DWORD)NTE_FAIL);
            goto Ret;
        }
        *pdwProvType = (DWORD)Type;
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (hRegKey)
        RegCloseKey(hRegKey);
    if (pszRegKeyName)
        LocalFree(pszRegKeyName);
#endif

    return fRet;
}


/*
 -      CryptEnumProvidersW
 -
 *      Purpose:
 *                Enumerate the providers.
 *
 *      Parameters:
 *                IN  dwIndex        - Index to the providers to enumerate
 *                IN  pdwReserved    - Reserved for future use
 *                IN  dwFlags        - Flags parameter
 *                OUT pdwProvType    - The type of the provider
 *                OUT pszProvName    - Name of the enumerated provider
 *                IN OUT pcbProvName - Length of the enumerated provider
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptEnumProvidersW(
                           IN DWORD dwIndex,
                           IN DWORD *pdwReserved,
                           IN DWORD dwFlags,
                           OUT DWORD *pdwProvType,
                           OUT LPWSTR pszProvName,
                           IN OUT DWORD *pcbProvName
                           )
{
    HKEY        hRegKey = 0;
    HKEY        hProvRegKey = 0;
    LONG        err;
    DWORD       cbClass;
    FILETIME    ft;
    DWORD       dwKeyType;
    DWORD       cbProvType;
    DWORD       dw;
    DWORD       cSubKeys;
    DWORD       cbMaxKeyName;
    DWORD       cbMaxClass;
    DWORD       cValues;
    DWORD       cbMaxValName;
    DWORD       cbMaxValData;
    LPWSTR       pszTmpProvName = NULL;
    DWORD       cbTmpProvName;
    BOOL        fRet = CRYPT_FAILED;

#ifndef XBOX
    try
    {
        if (0 != dwFlags)
        {
            SetLastError((DWORD)NTE_BAD_FLAGS);
            goto Ret;
        }

        if (ERROR_SUCCESS != (err = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                                 (const WCHAR *) szenumprovidersW,
                                                 0L, KEY_READ, &hRegKey)))
        {
            SetLastError((DWORD)NTE_FAIL);
            goto Ret;
        }

        if (ERROR_SUCCESS != (err = RegQueryInfoKeyW(hRegKey,
                                                    NULL,
                                                    &cbClass,
                                                    NULL,
                                                    &cSubKeys,
                                                    &cbMaxKeyName,
                                                    &cbMaxClass,
                                                    &cValues,
                                                    &cbMaxValName,
                                                    &cbMaxValData,
                                                    NULL,
                                                    &ft)))
        {
            SetLastError((DWORD)NTE_FAIL);
            goto Ret;
        }

        ++cbMaxKeyName;

        if (NULL == (pszTmpProvName = LocalAlloc(LMEM_ZEROINIT, cbMaxKeyName*sizeof(WCHAR))))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        if (ERROR_SUCCESS != (err = RegEnumKeyExW(hRegKey, dwIndex, pszTmpProvName,
                                                 &cbMaxKeyName, NULL,
                                                 NULL, NULL, &ft)))
        {
            SetLastError(err);
            goto Ret;
        }

        if (ERROR_SUCCESS != (err = RegOpenKeyExW(hRegKey,
                                                 (const WCHAR *) pszTmpProvName,
                                                 0L, KEY_READ, &hProvRegKey)))
        {
            SetLastError((DWORD)NTE_FAIL);
            goto Ret;
        }

        cbProvType = sizeof(dw);
        if (ERROR_SUCCESS != (err = RegQueryValueExW(hProvRegKey,
                                                    (const WCHAR *) L"Type",
                                                    NULL, &dwKeyType, (BYTE*)&dw,
                                                    &cbProvType)))
        {
            SetLastError(err);
            goto Ret;
        }
        *pdwProvType = dw;

        // SFIELD: review if cbProvname should be number of chars rather
        // than bytes.
        cbTmpProvName = (lstrlenW(pszTmpProvName) + 1) * sizeof(WCHAR);

        if (NULL != pszProvName)
        {
            if (*pcbProvName < cbTmpProvName)
            {
                *pcbProvName = cbTmpProvName;
                SetLastError(ERROR_MORE_DATA);
                goto Ret;
            }
            lstrcpyW(pszProvName, pszTmpProvName);
        }

        *pcbProvName = cbTmpProvName;
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (pszTmpProvName)
        LocalFree(pszTmpProvName);
    if (hRegKey)
        RegCloseKey(hRegKey);
    if (hProvRegKey)
        RegCloseKey(hProvRegKey);
#endif

    return fRet;
}

BOOL EnterProviderCritSec(IN PVTableStruc pVTable)
{
    try
    {
        if (pVTable->Version != TABLEPROV)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Try_Error_Return;
        }

        InterlockedIncrement(&pVTable->Inuse);

    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Try_Error_Return;
    }

    return(CRYPT_SUCCEED);
Try_Error_Return:
    return(CRYPT_FAILED);
}


void LeaveProviderCritSec(IN PVTableStruc pVTable)
{
    InterlockedDecrement(&pVTable->Inuse);
}

BOOL EnterKeyCritSec(IN PVKeyStruc pVKey)
{

    try
    {
        if (pVKey->Version != TABLEKEY)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Try_Error_Return;
        }

        InterlockedIncrement(&pVKey->Inuse);
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Try_Error_Return;
    }

    return(CRYPT_SUCCEED);
Try_Error_Return:
    return(CRYPT_FAILED);

}


void LeaveKeyCritSec(IN PVKeyStruc pVKey)
{
    InterlockedDecrement(&pVKey->Inuse);
}

BOOL EnterHashCritSec(IN PVHashStruc pVHash)
{

    try
    {
        if (pVHash->Version != TABLEHASH)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Try_Error_Return;
        }

        InterlockedIncrement(&pVHash->Inuse);
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Try_Error_Return;
    }

    return(CRYPT_SUCCEED);

Try_Error_Return:
    return(CRYPT_FAILED);

}


void LeaveHashCritSec(IN PVHashStruc pVHash)
{
    InterlockedDecrement(&pVHash->Inuse);
}


BOOL BuildVKey(IN PVKeyStruc *ppVKey,
               IN PVTableStruc pVTable)
{
    DWORD           bufsize;
    PVKeyStruc pVKey;

    bufsize = sizeof(VKeyStruc);

    if ((pVKey = (PVKeyStruc) LocalAlloc(LMEM_ZEROINIT,
                                         (UINT) bufsize)) == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(CRYPT_FAILED);
    }

    pVKey->FuncGenKey = pVTable->FuncGenKey;
    pVKey->FuncDeriveKey = pVTable->FuncDeriveKey;
    pVKey->FuncDestroyKey = pVTable->FuncDestroyKey;
    pVKey->FuncSetKeyParam = pVTable->FuncSetKeyParam;
    pVKey->FuncGetKeyParam = pVTable->FuncGetKeyParam;
    pVKey->FuncExportKey = pVTable->FuncExportKey;
    pVKey->FuncImportKey = pVTable->FuncImportKey;
    pVKey->FuncEncrypt = pVTable->FuncEncrypt;
    pVKey->FuncDecrypt = pVTable->FuncDecrypt;

    pVKey->OptionalFuncDuplicateKey = pVTable->OptionalFuncDuplicateKey;

    pVKey->hProv = pVTable->hProv;

    *ppVKey = pVKey;

    return(CRYPT_SUCCEED);
}

BOOL BuildVHash(
                IN PVHashStruc *ppVHash,
                IN PVTableStruc pVTable
                )
{
    DWORD           bufsize;
    PVHashStruc     pVHash;


    bufsize = sizeof(VHashStruc);

    if ((pVHash = (PVHashStruc) LocalAlloc(LMEM_ZEROINIT, (UINT) bufsize)) == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(CRYPT_FAILED);
    }

    pVHash->FuncCreateHash = pVTable->FuncCreateHash;
    pVHash->FuncHashData = pVTable->FuncHashData;
    pVHash->FuncHashSessionKey = pVTable->FuncHashSessionKey;
    pVHash->FuncDestroyHash = pVTable->FuncDestroyHash;
    pVHash->FuncSignHash = pVTable->FuncSignHash;
    pVHash->FuncVerifySignature = pVTable->FuncVerifySignature;
    pVHash->FuncGetHashParam = pVTable->FuncGetHashParam;
    pVHash->FuncSetHashParam = pVTable->FuncSetHashParam;

    pVHash->OptionalFuncDuplicateHash = pVTable->OptionalFuncDuplicateHash;

    pVHash->hProv = (HCRYPTPROV)pVTable;

    *ppVHash = pVHash;

    return(CRYPT_SUCCEED);
}

void EncryptKey(BYTE *pdata, DWORD size, BYTE val)
{
    RC4_KEYSTRUCT key;
    BYTE          RealKey[RC4_KEYSIZE] = {0xa2, 0x17, 0x9c, 0x98, 0xca};
    DWORD         index;

    for (index = 0; index < RC4_KEYSIZE; index++)
    {
        RealKey[index] = RealKey[index] ^ val;
    }

    rc4_key(&key, RC4_KEYSIZE, RealKey);

    rc4(&key, size, pdata);

}

void MD5HashData(
                 BYTE *pb,
                 DWORD cb,
                 BYTE *pbHash
                 )
{
    MD5_CTX     HashState;

    MD5Init(&HashState);

    try
    {
        MD5Update(&HashState, pb, cb);
    } except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError((DWORD) NTE_SIGNATURE_FILE_BAD);
        return;
    }

    // Finish the hash
    MD5Final(&HashState);

    memcpy(pbHash, HashState.digest, 16);
}


BOOL CheckSignature(
                    BYTE *pbKey,
                    DWORD cbKey,
                    BYTE *pbSig,
                    DWORD cbSig,
                    BYTE *pbHash,
                    BOOL fUnknownLen)
{
    BYTE                rgbResult[KEYSIZE1024];
    BYTE                rgbSig[KEYSIZE1024];
    BYTE                rgbKey[sizeof(BSAFE_PUB_KEY) + KEYSIZE1024];
    BYTE                rgbKeyHash[16];
    BYTE                *pbSecondKey;
    DWORD               cbSecondKey;
    BYTE                *pbKeySig;
    PSECOND_TIER_SIG    pSecondTierSig;
    LPBSAFE_PUB_KEY     pTmp;
    BOOL                fRet = FALSE;

    memset(rgbResult, 0, KEYSIZE1024);
    memset(rgbSig, 0, KEYSIZE1024);

    // just check the straight signature if version is 1
    pTmp = (LPBSAFE_PUB_KEY)pbKey;

    // check if sig length is the same as the key length
    if (fUnknownLen || (cbSig == pTmp->keylen))
    {
        memcpy(rgbSig, pbSig, pTmp->keylen);
        BSafeEncPublic(pTmp, rgbSig, rgbResult);

        if (RtlEqualMemory(pbHash, rgbResult, 16) &&
            rgbResult[cbKey-1] == 0 &&
            rgbResult[cbKey-2] == 1 &&
            rgbResult[16] == 0)
        {
            fRet = TRUE;
            goto Ret;
        }
    }

    // check the the second tier signature if the magic equals 2
    pSecondTierSig = (PSECOND_TIER_SIG)pbSig;
    if (0x00000002 != pSecondTierSig->dwMagic)
        goto Ret;

    if (0x31415352 != pSecondTierSig->Pub.magic)
        goto Ret;

    // assign the pointers
    cbSecondKey = sizeof(BSAFE_PUB_KEY) + pSecondTierSig->Pub.keylen;
    pbSecondKey = pbSig + (sizeof(SECOND_TIER_SIG) - sizeof(BSAFE_PUB_KEY));
    pbKeySig = pbSecondKey + cbSecondKey;

    // hash the second tier key
    MD5HashData(pbSecondKey, cbSecondKey, rgbKeyHash);

    // Decrypt the signature data on the second tier key
    memset(rgbResult, 0, sizeof(rgbResult));
    memset(rgbSig, 0, sizeof(rgbSig));
    memcpy(rgbSig, pbKeySig, pSecondTierSig->cbSig);
    BSafeEncPublic(pTmp, rgbSig, rgbResult);

    if ((FALSE == RtlEqualMemory(rgbKeyHash, rgbResult, 16)) ||
        rgbResult[cbKey-1] != 0 ||
        rgbResult[cbKey-2] != 1 ||
        rgbResult[16] != 0)
    {
        goto Ret;
    }

    // Decrypt the signature data on the CSP
    memset(rgbResult, 0, sizeof(rgbResult));
    memset(rgbSig, 0, sizeof(rgbSig));
    memset(rgbKey, 0, sizeof(rgbKey));
    memcpy(rgbSig, pbKeySig + pSecondTierSig->cbSig, pSecondTierSig->cbSig);
    memcpy(rgbKey, pbSecondKey, cbSecondKey);
    pTmp = (LPBSAFE_PUB_KEY)rgbKey;
    BSafeEncPublic(pTmp, rgbSig, rgbResult);

    if (RtlEqualMemory(pbHash, rgbResult, 16) &&
        rgbResult[pTmp->keylen-1] == 0 &&
        rgbResult[pTmp->keylen-2] == 1 &&
        rgbResult[16] == 0)
    {
        fRet = TRUE;
    }
Ret:
    return fRet;
}

/*
 -      NewVerifyImage
 -
 *      Purpose:
 *                Check signature of file
 *
 *
 *      Parameters:
 *                IN lpszImage      - address of file
 *                IN pSigData       - address of signature data
 *                IN cbSig          - length of signature data
 *                IN fUnknownLen    - BOOL to tell if length is not passed in
 *
 *      Returns:
 *                BOOL
 */
BOOL NewVerifyImage(LPCWSTR lpszImage,
		            BYTE *pSigData,
                    DWORD cbSig,
                    BOOL fUnknownLen)
{

    HANDLE      hFileProv = INVALID_HANDLE_VALUE;
    DWORD       NumBytes;
    DWORD       lpdwFileSizeHigh;
    LPVOID      lpvAddress = NULL;
    DWORD       NumBytesRead;
    BYTE        rgbHash[16];
    BYTE        rgbKey[sizeof(BSAFE_PUB_KEY) + KEYSIZE1024];
    BYTE        rgbKey2[sizeof(BSAFE_PUB_KEY) + KEYSIZE1024];
#ifdef MS_INTERNAL_KEY
    BYTE        rgbMSKey[sizeof(BSAFE_PUB_KEY) + KEYSIZE1024];
#endif

#ifdef TEST_BUILD_EXPONENT
    BYTE        rgbTestKey[sizeof(BSAFE_PUB_KEY) + KEYSIZE512];
#endif

    BOOL        fRet = CRYPT_FAILED;

    DWORD cchImage = lstrlenW(lpszImage) + 1;
    LPSTR pszAnsiImage = _alloca(cchImage * sizeof(WCHAR));
    if (pszAnsiImage == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }

    WideCharToMultiByte(
                CP_ACP,
                0,
                lpszImage,
                cchImage,
                pszAnsiImage,
                cchImage * sizeof(WCHAR),
                NULL,
                NULL);

    if (INVALID_HANDLE_VALUE == (hFileProv = CreateFile(
    			pszAnsiImage,
    			GENERIC_READ,
    			FILE_SHARE_READ,
    			NULL,
    			OPEN_EXISTING,
    			0,
    			NULL)))
    {
        SetLastError((DWORD) NTE_PROV_DLL_NOT_FOUND);
        goto Ret;
    }

    if (0xffffffff == (NumBytes = GetFileSize(hFileProv,
                                              &lpdwFileSizeHigh)))
    {
        SetLastError((DWORD) NTE_SIGNATURE_FILE_BAD);
        goto Ret;
    }

    if (NULL == (lpvAddress = VirtualAlloc(NULL, NumBytes, MEM_RESERVE | MEM_COMMIT,
                                           PAGE_READWRITE)))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Ret;
    }

    if (!ReadFile((HANDLE) hFileProv, lpvAddress, NumBytes, &NumBytesRead, 0))
    {
        SetLastError((DWORD) NTE_SIGNATURE_FILE_BAD);
        goto Ret;
    }

    MD5HashData(lpvAddress, NumBytes, rgbHash);

    // decrypt the keys once for each process
    memcpy(rgbKey, (BYTE*)&KEY, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024);
    EncryptKey(rgbKey, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024, 0);

#ifdef MS_INTERNAL_KEY
    memcpy(rgbMSKey, (BYTE*)&MSKEY, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024);
    EncryptKey(rgbMSKey, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024, 1);
#endif
    memcpy(rgbKey2, (BYTE*)&KEY2, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024);
    EncryptKey(rgbKey2, sizeof(BSAFE_PUB_KEY) + KEYSIZE1024, 2);

#ifdef TEST_BUILD_EXPONENT
    memcpy(rgbTestKey, (BYTE*)&TESTKEY, sizeof(BSAFE_PUB_KEY) + KEYSIZE512);
    EncryptKey(rgbTestKey, sizeof(BSAFE_PUB_KEY) + KEYSIZE512, 3);
#endif // TEST_BUILD_EXPONENT

    if (CRYPT_SUCCEED == (fRet = CheckSignature(rgbKey, 128, pSigData,
                                                cbSig, rgbHash, fUnknownLen)))
        goto Ret;

#ifdef MS_INTERNAL_KEY
    if (CRYPT_SUCCEED == (fRet = CheckSignature(rgbMSKey, 128, pSigData,
                                                cbSig, rgbHash, fUnknownLen)))
        goto Ret;
#endif

    if (CRYPT_SUCCEED == (fRet = CheckSignature(rgbKey2, 128, pSigData,
                                                cbSig, rgbHash, fUnknownLen)))
        goto Ret;

#ifdef TEST_BUILD_EXPONENT
    if (CRYPT_SUCCEED == (fRet = CheckSignature(rgbTestKey, 64, pSigData,
                                                cbSig, rgbHash, fUnknownLen)))
        goto Ret;
#endif // TEST_BUILD_EXPONENT

    SetLastError((DWORD) NTE_BAD_SIGNATURE);
Ret:
    if (NULL != lpvAddress)
        VirtualFree(lpvAddress, 0, MEM_RELEASE);
    if (INVALID_HANDLE_VALUE != hFileProv)
        CloseHandle(hFileProv);

    return fRet;

}

/*
 -      CProvVerifyImage
 -
 *      Purpose:
 *                Check signature of file
 *
 *
 *      Parameters:
 *                IN lpszImage      - address of file
 *                IN lpSigData      - address of signature data
 *
 *      Returns:
 *                BOOL
 */
BOOL CProvVerifyImage(LPCWSTR lpszImage,
		              BYTE *pSigData)
{
    return NewVerifyImage(lpszImage, pSigData, 0, TRUE);
}


/*
 -      CPReturnhWnd
 -
 *      Purpose:
 *                Return a window handle back to a CSP
 *
 *
 *      Parameters:
 *                OUT phWnd      - pointer to a hWnd to return
 *
 *      Returns:
 *                BOOL
 */
BOOL CPReturnhWnd(DWORD *phWnd)
{
    try
    {

        *phWnd = hWnd;

    } except ( EXCEPTION_EXECUTE_HANDLER )
    {
	SetLastError(ERROR_INVALID_PARAMETER);
	goto Try_Error_Return;
    }

    return(CRYPT_SUCCEED);

Try_Error_Return:
    return(CRYPT_FAILED);

}

static void __ltoaW(DWORD val, WCHAR *buf)
{
    WCHAR *p;            /* pointer to traverse string */
    WCHAR *firstdig;     /* pointer to first digit */
    WCHAR temp;          /* temp char */
    unsigned digval;    /* value of digit */
    int  i;

    p = buf;

    firstdig = p;       /* save pointer to first digit */

    for (i = 0; i < 8; i++) {
        digval = (unsigned) (val % 10);
        val /= 10;      /* get next digit */

        /* convert to ascii and store */
        *p++ = (WCHAR) (digval + L'0');    /* a digit */
    }

    /* We now have the digit of the number in the buffer, but in reverse
       order.  Thus we reverse them now. */

    *p-- = L'\0';                /* terminate string; p points to last digit */

    do {
        temp = *p;
        *p = *firstdig;
        *firstdig = temp;       /* swap *p and *firstdig */
        --p;
        ++firstdig;             /* advance to next two digits */
    } while (firstdig < p); /* repeat until halfway */
}

#define FRENCHCHECKKEY  L"Comm\\Security\\Crypto\\Defaults\\CheckInfo"
#define FRENCHCHECKVALUE  L"Mask"

#define DH_PROV_ENABLED     1
#define RSA_PROV_ENABLED    2
#define DH_SCH_ENABLED      4
#define RSA_SCH_ENABLED     8

BOOL WINAPI
IsEncryptionPermitted(
                           IN DWORD dwProvType
                           )
/*++

Routine Description:

    This routine checks whether encryption is getting the system default
    LCID and checking whether the country code is CTRY_FRANCE.

Arguments:

    none


Return Value:

    TRUE - encryption is permitted
    FALSE - encryption is not permitted


--*/

{
#ifndef NO_FRANCE_CHECK
    LCID    DefaultLcid;
    WCHAR CountryCode[10];
    LPCWSTR CountryFrance = L"33"; // CTRY_FRANCE converted to Unicode string
    HKEY    hKey = 0;
    DWORD   cb = sizeof(DWORD);
    DWORD   dw = 0;
    DWORD   dwType;
    BOOL    fRet = FALSE;

    //*pfInFrance = FALSE;

#ifndef XBOX

    DefaultLcid = GetSystemDefaultLCID();

    //
    // Check if the default language is Standard French
    // or if the users's country is set to FRANCE
    //

    if (GetLocaleInfoW(DefaultLcid,LOCALE_ICOUNTRY,CountryCode,10) == 0)
    {
        goto Ret;
    }
    if ((memcmp(CountryCode, CountryFrance, sizeof(CountryFrance)) == 0)
        || (LANGIDFROMLCID(DefaultLcid) == 0x40c))
    {
        // this is a check to see if a registry key to enable encryption is
        // available, do not remove, use or publicize this check without
        // thorough discussions with Microsoft Legal handling French Import
        // issues (tomalb and/or irar)
	    if (ERROR_SUCCESS != RegOpenKeyExW(HKEY_LOCAL_MACHINE,
		                                  FRENCHCHECKKEY,
		                                  0,		// dwOptions
		                                  KEY_READ,
		                                  &hKey))
        {
            hKey = 0;
            goto Ret;
        }

        // get the mask value from the registry indicating which crypto
        // services are to be allowed
	    if (ERROR_SUCCESS != RegQueryValueExW(hKey,
		                                  FRENCHCHECKVALUE,
		                                  NULL, &dwType,		// dwOptions
		                                  (BYTE*)&dw,
		                                  &cb))
        {
            goto Ret;
        }

        switch(dwProvType)
        {
            case PROV_RSA_FULL:
            case PROV_RSA_SIG:
            {
                if (dw & RSA_PROV_ENABLED)
                {
                    fRet = TRUE;
                }
                break;
            }

            case PROV_RSA_SCHANNEL:
            {
                if (dw & RSA_SCH_ENABLED)
                {
                    fRet = TRUE;
                }
                break;
            }

            case PROV_DSS:
            case PROV_DSS_DH:
            {
                if (dw & DH_PROV_ENABLED)
                {
                    fRet = TRUE;
                }
                break;
            }

#ifdef PROV_DH_SCHANNEL
            case PROV_DH_SCHANNEL:
            {
                if (dw & DH_SCH_ENABLED)
                {
                    fRet = TRUE;
                }
                break;
            }
#endif
            default:
                goto Ret;
        }
    }
    else
    {
        fRet = TRUE;
    }
Ret:
    if (hKey)
        RegCloseKey(hKey);
#endif // ndef XBOX

    return fRet;
#else
    //*pfInFrance = FALSE;
    return TRUE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\debug.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/


/*
 *  For ease of debugging the SPMgr, all the debug support functions have
 *  been stuck here.  Basically, we read info from win.ini, since that allows
 *  us to configure the debug level via a text file (and DOS, for example).
 *
 *  Format is:
 *
 *  win.ini
 *
 *  [Schannel]
 *      DebugFlags=<Flag>[<,Flag>]*
 *
 *  WHERE:
 *      Flag is one of the following:
 *          Error, Warning, Trace
 */


#include <spbase.h>

#if DBG         /* NOTE:  This file not compiled for retail builds */

DWORD  g_dwEventLogging=0;
HANDLE g_hfLogFile = NULL;

#include <stdio.h>
#include <stdarg.h>

#ifdef HEAPDUMP
//#include <winbasep.h>
#endif

#define WINDEBUG

#ifndef min
#define min(x,y) ((x)<(y)?(x):(y))
#endif

DWORD   g_dwInfoLevel  = 0;
DWORD   g_dwDebugBreak = 0;
DWORD   PctTraceIndent = 0;


#define MAX_DEBUG_BUFFER 2048


// This function simply outputs information to the debugging log file handle.

void
SPDebugOutput(char *szOutString)
{
    DWORD dwWritten;

    if (NULL != g_hfLogFile)
    {
        WriteFile(
		g_hfLogFile,
		szOutString,
		strlen(szOutString),
		&dwWritten,
		NULL);
    }
    OutputDebugStringA(szOutString);
}


void
InitDebugSupport(void)
{

}


void
DbgDumpHexString(const unsigned char *String, DWORD cbString)
{
#ifndef XBOX
    unsigned int i;

    for (i = 0; i < cbString; i++)
    {
	int j;
	char *pch;
	char ach[9];

	pch = &ach[sprintf(ach,  "%2.2x", String[i])];
	SP_ASSERT(pch - ach <= sizeof(ach) - 4);


	if ((i & 1) == 1)
	{
	    *pch++ = ' ';
	}
	if ((i & 7) == 7)
	{
	    *pch++ = ' ';
	}
	if ((i & 15) == 15)
	{
	    *pch++ = '\n';
	}
	*pch = '\0';
	SPDebugOutput(ach);
    }
#endif
}


char *aszSPDebugLevel[] = {
    "Error  ",
    "Warning",
    "Trace  ",
    "Mem    ",
    "Result "
};


void
SPDebugLog(long Mask, const char *Format, ...)
{
    va_list ArgList;
    int     Level = 0;
    int     PrefixSize = 0;
    int     iOut;
    char    szOutString[MAX_DEBUG_BUFFER];
    long    OriginalMask = Mask;

    if (Mask & g_dwInfoLevel)
    {
	while (!(Mask & 1))
	{
	    Level++;
	    Mask >>= 1;
	}
	if (Level >= sizeof(aszSPDebugLevel) / sizeof(char *))
	{
	    Level = sizeof(aszSPDebugLevel) / sizeof(char *) - 1;
	}
	// Make the prefix first:  "Process.Thread> GINA-XXX"

	iOut = sprintf(
			szOutString,
			"%3d.%3d> %s: ",
			333,
			GetCurrentThreadId(),
			aszSPDebugLevel[Level]);

	PrefixSize = min(60, PctTraceIndent * 3);
	FillMemory(szOutString+iOut, PrefixSize, ' ');
	PrefixSize += iOut;
	szOutString[PrefixSize] = '\0';

	va_start(ArgList, Format);

	if (vsprintf(&szOutString[PrefixSize], Format, ArgList) < 0)
	{
	    static char szOverFlow[] = "\n<256 byte OVERFLOW!>\n";

	    // Less than zero indicates that the string would not fit into the
	    // buffer.  Output a special message indicating overflow.

	    strcpy(
		&szOutString[sizeof(szOutString) - sizeof(szOverFlow)],
		szOverFlow);
	}
	va_end(ArgList);
	SPDebugOutput(szOutString);
    }
}


long
SPLogErrorCode(
    long err,
    const char *szFile,
    long lLine)
{
    char *szName = "Unknown";

    switch(err)
    {
    case PCT_ERR_OK: szName = "PCT_ERR_OK"; break;
    case PCT_ERR_BAD_CERTIFICATE: szName = "PCT_ERR_BAD_CERTIFICATE"; break;
    case PCT_ERR_CLIENT_AUTH_FAILED: szName = "PCT_ERR_CLIENT_AUTH_FAILED"; break;
    case PCT_ERR_ILLEGAL_MESSAGE: szName = "PCT_ERR_ILLEGAL_MESSAGE"; break;
    case PCT_ERR_INTEGRITY_CHECK_FAILED: szName = "PCT_ERR_INTEGRITY_CHECK_FAILED"; break;
    case PCT_ERR_SERVER_AUTH_FAILED: szName = "PCT_ERR_SERVER_AUTH_FAILED"; break;
    case PCT_ERR_SPECS_MISMATCH: szName = "PCT_ERR_SPECS_MISMATCH"; break;
    case PCT_ERR_SSL_STYLE_MSG: szName = "PCT_ERR_SSL_STYLE_MSG"; break;

    case PCT_INT_BUFF_TOO_SMALL: szName = "PCT_INT_BUFF_TOO_SMALL"; break;
    case PCT_INT_INCOMPLETE_MSG: szName = "PCT_INT_INCOMPLETE_MSG"; break;
    case PCT_INT_DROP_CONNECTION: szName = "PCT_INT_DROP_CONNECTION"; break;
    case PCT_INT_BAD_CERT: szName = "PCT_INT_BAD_CERT"; break;
    case PCT_INT_CLI_AUTH: szName = "PCT_INT_CLI_AUTH"; break;
    case PCT_INT_ILLEGAL_MSG: szName = "PCT_INT_ILLEGAL_MSG"; break;
    case PCT_INT_MSG_ALTERED: szName = "PCT_INT_MSG_ALTERED"; break;
    case PCT_INT_INTERNAL_ERROR: szName = "PCT_INT_INTERNAL_ERROR"; break;
    case PCT_INT_OUT_OF_MEMORY: szName = "PCT_INT_OUT_OF_MEMORY"; break;
    case PCT_INT_DATA_OVERFLOW: szName = "PCT_INT_DATA_OVERFLOW"; break;
    case PCT_INT_SPECS_MISMATCH: szName = "PCT_INT_SPECS_MISMATCH"; break;

    case WSAEINTR:               szName = "WSAEINTR";               break;
    case WSAEBADF:               szName = "WSAEBADF";               break;
    case WSAEACCES:              szName = "WSAEACCES";              break;
    case WSAEFAULT:              szName = "WSAEFAULT";              break;
    case WSAEINVAL:              szName = "WSAEINVAL";              break;
    case WSAEMFILE:              szName = "WSAEMFILE";              break;

    case WSAEWOULDBLOCK:         szName = "WSAEWOULDBLOCK";         break;
    case WSAEINPROGRESS:         szName = "WSAEINPROGRESS";         break;
    case WSAEALREADY:            szName = "WSAEALREADY";            break;
    case WSAENOTSOCK:            szName = "WSAENOTSOCK";            break;
    case WSAEDESTADDRREQ:        szName = "WSAEDESTADDRREQ";        break;
    case WSAEMSGSIZE:            szName = "WSAEMSGSIZE";            break;
    case WSAEPROTOTYPE:          szName = "WSAEPROTOTYPE";          break;
    case WSAENOPROTOOPT:         szName = "WSAENOPROTOOPT";         break;
    case WSAEPROTONOSUPPORT:     szName = "WSAEPROTONOSUPPORT";     break;
    case WSAESOCKTNOSUPPORT:     szName = "WSAESOCKTNOSUPPORT";     break;
    case WSAEOPNOTSUPP:          szName = "WSAEOPNOTSUPP";          break;
    case WSAEPFNOSUPPORT:        szName = "WSAEPFNOSUPPORT";        break;
    case WSAEAFNOSUPPORT:        szName = "WSAEAFNOSUPPORT";        break;
    case WSAEADDRINUSE:          szName = "WSAEADDRINUSE";          break;
    case WSAEADDRNOTAVAIL:       szName = "WSAEADDRNOTAVAIL";       break;
    case WSAENETDOWN:            szName = "WSAENETDOWN";            break;
    case WSAENETUNREACH:         szName = "WSAENETUNREACH";         break;
    case WSAENETRESET:           szName = "WSAENETRESET";           break;
    case WSAECONNABORTED:        szName = "WSAECONNABORTED";        break;
    case WSAECONNRESET:          szName = "WSAECONNRESET";          break;
    case WSAENOBUFS:             szName = "WSAENOBUFS";             break;
    case WSAEISCONN:             szName = "WSAEISCONN";             break;
    case WSAENOTCONN:            szName = "WSAENOTCONN";            break;
    case WSAESHUTDOWN:           szName = "WSAESHUTDOWN";           break;
    case WSAETOOMANYREFS:        szName = "WSAETOOMANYREFS";        break;
    case WSAETIMEDOUT:           szName = "WSAETIMEDOUT";           break;
    case WSAECONNREFUSED:        szName = "WSAECONNREFUSED";        break;
    case WSAELOOP:               szName = "WSAELOOP";               break;
    case WSAENAMETOOLONG:        szName = "WSAENAMETOOLONG";        break;
    case WSAEHOSTDOWN:           szName = "WSAEHOSTDOWN";           break;
    case WSAEHOSTUNREACH:        szName = "WSAEHOSTUNREACH";        break;
    case WSAENOTEMPTY:           szName = "WSAENOTEMPTY";           break;
    case WSAEPROCLIM:            szName = "WSAEPROCLIM";            break;
    case WSAEUSERS:              szName = "WSAEUSERS";              break;
    case WSAEDQUOT:              szName = "WSAEDQUOT";              break;
    case WSAESTALE:              szName = "WSAESTALE";              break;
    case WSAEREMOTE:             szName = "WSAEREMOTE";             break;

    case WSASYSNOTREADY:         szName = "WSASYSNOTREADY";         break;
    case WSAVERNOTSUPPORTED:     szName = "WSAVERNOTSUPPORTED";     break;
    case WSANOTINITIALISED:      szName = "WSANOTINITIALISED";      break;
    case WSAEDISCON:             szName = "WSAEDISCON";             break;
    case WSAENOMORE:             szName = "WSAENOMORE";             break;
    case WSAECANCELLED:          szName = "WSAECANCELLED";          break;
    case WSAEINVALIDPROCTABLE:   szName = "WSAEINVALIDPROCTABLE";   break;
    case WSAEINVALIDPROVIDER:    szName = "WSAEINVALIDPROVIDER";    break;
    case WSAEPROVIDERFAILEDINIT: szName = "WSAEPROVIDERFAILEDINIT"; break;
    case WSASYSCALLFAILURE:      szName = "WSASYSCALLFAILURE";      break;
    case WSASERVICE_NOT_FOUND:   szName = "WSASERVICE_NOT_FOUND";   break;
    case WSATYPE_NOT_FOUND:      szName = "WSATYPE_NOT_FOUND";      break;
    case WSA_E_NO_MORE:          szName = "WSA_E_NO_MORE";          break;
    case WSA_E_CANCELLED:        szName = "WSA_E_CANCELLED";        break;
    case WSAEREFUSED:            szName = "WSAEREFUSED";            break;

    }

    SPDebugLog(SP_LOG_RES, "Result: %s (0x%lx) - %s, Line %d\n", szName, err, szFile, lLine);

    return err;
}

#pragma warning(disable:4206)   /* Disable the empty translation unit */
				/* warning/error */

void
SPAssert(
    void * FailedAssertion,
    void * FileName,
    unsigned long LineNumber,
    char * Message)
{

    SPDebugLog(SP_LOG_ERROR,
               "Assertion FAILED, %s, %s : %d\n",
               FailedAssertion,
		       FileName,
		       LineNumber);

}

#ifdef HEAPDUMP

int HeapFlags = 0;

VOID
DumpHeapState(char *pszMsg)
{
    DWORD dwWritten;
    if (HeapFlags & 2)
    {
	HANDLE BaseHeap = RtlProcessHeap();
	HEAP_SUMMARY HeapSum;
	char szOutString[256];

	wsprintf(szOutString, "%s: HeapSummary(%x): ", pszMsg, BaseHeap);
	HeapSum.cb = sizeof(HeapSum);
	if (!HeapSummary(BaseHeap, 0, &HeapSum))
	{
	    wsprintf(
		&szOutString[lstrlen(szOutString)],
		"FAILED: %u\n",
		GetLastError());
	}
	else
	{
	    wsprintf(
		&szOutString[lstrlen(szOutString)],
		"Allocated=%x  Committed=%x\n",
		HeapSum.cbAllocated,
		HeapSum.cbCommitted);
	}
	SPDebugOutput(szOutString);
    }
}


VOID
CaptureStackBackTrace(
    EXCEPTION_POINTERS *pep,
    ULONG cSkip,
    ULONG cFrames,
    ULONG *aeip)
{
    FillMemory(aeip, cFrames * sizeof(aeip[0]), 0);

#if i386 == 1
    {
	ULONG ieip, *pebp;
	ULONG *pebpMax;
	ULONG *pebpMin;

	if (pep == NULL)
	{
	    ieip = 0;
	    cSkip++;                    // always skip current frame
	    pebp = ((ULONG *) &pep) - 2;
	}
	else
	{
	    ieip = 1;
	    SP_ASSERT(cSkip == 0);
	    aeip[0] = pep->ContextRecord->Eip;
	    pebp = (ULONG *) pep->ContextRecord->Ebp;
	}

	pebpMin = (ULONG *) &pep - 3;   // start below current frame
	pebpMax = pebpMin + 16*1024/sizeof(ULONG);
	if (pebp >= pebpMin && pebp < pebpMax)
	{
//          __try
	    {
		for ( ; ieip < cSkip + cFrames; ieip++)
		{
		    ULONG *pebpNext;

		    if (ieip >= cSkip)
		    {
			aeip[ieip - cSkip] = *(pebp + 1);  // save an eip
		    }

		    pebpNext = (ULONG *) *pebp;
		    if (pebpNext < pebp + 2 || pebpNext >= pebpMax - 1)
		    {
			break;
		    }
		    pebp = pebpNext;
		}
	    }
//          __except(EXCEPTION_EXECUTE_HANDLER)
	    {
	    }
	}
    }
#endif // i386 == 1
}


#define CMEMMAX 500
#define CEIP    6

int cMemAlloc;
int cMemAlloc2;
ULONG cbMemTotal;
ULONG cbMemTotal2;

typedef struct _MEM {
    VOID *pv;
    ULONG cb;
    ULONG aeip[CEIP];
} MEM;

MEM amem[CMEMMAX];

#endif // ifdef HEAPDUMP


VOID *
SPExternalAlloc(DWORD cb)
{
    VOID *pv;
#ifdef HEAPDUMP
    int i;
    char szOutString[256];
    int iRecorded = -1;
    MEM mem;

    DumpHeapState("Before Alloc");

    if (HeapFlags & 2)
    {
	CaptureStackBackTrace(NULL, 1, CEIP, mem.aeip);
	wsprintf(szOutString, "AllocMem(%x bytes): ", cb);
	cMemAlloc2++;
	cbMemTotal2 += cb;
	mem.cb = cb;
    }
#endif // ifdef HEAPDUMP
    pv = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cb);
#ifdef HEAPDUMP
    if (HeapFlags & 2)
    {
	mem.pv = pv;
	if (pv != NULL)
	{
	    for (i = 0; i < CMEMMAX; i++)
	    {
		if (amem[i].pv == pv)
		{
		    char szOutString2[256];

		    wsprintf(
			szOutString2,
			"FreeDup(%x) (%x bytes) from %x %x %x %x %x %x (%d)\n",
			pv,
			amem[i].cb,
			amem[i].aeip[0],
			amem[i].aeip[1],
			amem[i].aeip[2],
			amem[i].aeip[3],
			amem[i].aeip[4],
			amem[i].aeip[5],
			i);
		    SPDebugOutput(szOutString2);
		    cMemAlloc--;
		    cbMemTotal -= amem[i].cb;
		    amem[i].pv = NULL;
		}
		if (amem[i].pv == NULL && iRecorded == -1)
		{
		    amem[i] = mem;
		    cMemAlloc++;
		    cbMemTotal += cb;
		    iRecorded = i;
		}
	    }
	}
	else
	{
	    lstrcat(szOutString, "FAILED: ");
	}
	wsprintf(
	    &szOutString[lstrlen(szOutString)],
	    "%x from %x %x %x %x %x %x (%d)\n",
	    mem.pv,
	    mem.aeip[0],
	    mem.aeip[1],
	    mem.aeip[2],
	    mem.aeip[3],
	    mem.aeip[4],
	    mem.aeip[5],
	    iRecorded);
	SPDebugOutput(szOutString);
    }
    DumpHeapState("After Alloc");
#endif // ifdef HEAPDUMP
    return(pv);
}


VOID
SPExternalFree(VOID *pv)
{
#ifdef HEAPDUMP
    int i;
    char szOutString[256];

    DumpHeapState("Before Free");
    if (HeapFlags & 2)
    {
	cMemAlloc2--;
	wsprintf(szOutString, "FreeMem(%x)", pv);
	for (i = 0; i < CMEMMAX; i++)
	{
	    if (pv == amem[i].pv)
	    {
		cMemAlloc--;
		cbMemTotal -= amem[i].cb;
		amem[i].pv = NULL;
		wsprintf(
		    &szOutString[lstrlen(szOutString)],
		    " (%x bytes) from %x %x %x %x %x %x (%d)",
		    amem[i].cb,
		    amem[i].aeip[0],
		    amem[i].aeip[1],
		    amem[i].aeip[2],
		    amem[i].aeip[3],
		    amem[i].aeip[4],
		    amem[i].aeip[5],
		    i);
		break;
	    }
	}
    }
#endif // ifdef HEAPDUMP
    LocalFree(pv);
#ifdef HEAPDUMP
    if (HeapFlags & 2)
    {
	    lstrcat(szOutString, "\n");
	    SPDebugOutput(szOutString);
    }
    DumpHeapState("After Free");
#endif // ifdef HEAPDUMP
}


#endif /* DBG */ /* NOTE:  This file not compiled for retail builds */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\debug.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology 
* reference implementation, version 1.0
* 
* The Private Communication Technology reference implementation, version 1.0 
* ("PCTRef"), is being provided by Microsoft to encourage the development and 
* enhancement of an open standard for secure general-purpose business and 
* personal communications on open networks.  Microsoft is distributing PCTRef 
* at no charge irrespective of whether you use PCTRef for non-commercial or 
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without 
* warranty of any kind, either express or implied, including, without 
* limitation, the implied warranties or merchantability, fitness for a 
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out 
* of use or performance of PCTRef remains with you.
* 
* Please see the file LICENSE.txt, 
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
* 
* Please see http://pct.microsoft.com/pct/pct.htm for The Private 
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/ 

#ifndef __DEBUG_H__
#define __DEBUG_H__

extern DWORD   g_dwEventLogging;
#ifdef DEBUG    // WINCE
#define DebugLog(x) CESPDebugLog x
#define DEB_ERROR           DEBUGZONE(ZONE_ERROR)
#define DEB_WARN            DEBUGZONE(ZONE_WARN)
#define DEB_TRACE           DEBUGZONE(ZONE_FUNCTION)
void    CESPDebugLog(long, const char *, ...);
#else
#define DebugLog(x)
#endif

#if DBG

extern DWORD   PctInfoLevel;
extern DWORD   PctTraceIndent;

extern DWORD   g_dwInfoLevel;
extern DWORD   g_dwDebugBreak;
extern HANDLE   g_hfLogFile;

#define DEB_ERROR           SP_LOG_ERROR
#define DEB_WARN            SP_LOG_WARNING
#define DEB_TRACE           SP_LOG_TRACE

//#define DebugLog(x) SPDebugLog x
#define SP_BEGIN(x) SPDebugLog(DEB_TRACE,"BEGIN:" x "\n"); PctTraceIndent++;
#define SP_RETURN(x) { PctTraceIndent--; SPDebugLog(DEB_TRACE, "END  Line %d\n", __LINE__); return (x); }
#define SP_LOG_RESULT(x) SPLogErrorCode((x), __FILE__, __LINE__)
#define SP_END()    { PctTraceIndent--; SPDebugLog(DEB_TRACE, "END:Line %d\n",  __LINE__); }
#define SP_BREAK()  { SPDebugLog(DEB_TRACE, "BREAK  Line %d\n",  __LINE__); }
long    SPLogErrorCode(long, const char *, long);
void    SPDebugLog(long, const char *, ...);
void    InitDebugSupport(void);

void    DbgDumpHexString(const unsigned char*, DWORD);


#else

//#define DebugLog(x)
#define SP_BEGIN(x) 
#define SP_RETURN(x) return (x)
#define SP_LOG_RESULT(x) x
#define SP_END()
#define SP_BREAK()

#endif



#endif /* __DEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\cred.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/

#include <stdlib.h>
#include <spbase.h>
#include <wincrypt.h>


#ifdef MULTI_THREADED
#define LockCredential(p)   EnterCriticalSection(&((PSPCredential) p)->csLock)
#define UnlockCredential(p) LeaveCriticalSection(&((PSPCredential) p)->csLock)
#else
#define LockCredential(p)
#define UnlockCredential(p)
#endif

SP_STATUS
UnpackCredSecret(
    PPctPrivateKey *ppOutKey,
    PVOID pSecret
    );

SP_STATUS
UnpackCredCertificate(
    PPctCertificate *ppOutCert,
    PVOID pCertificate
    );



SP_STATUS
SPCreateCredential(
   PSPCredential *ppCred,
   DWORD Type,
   PSCH_CRED pCredData)
{
    PSPCredential  pCred = NULL;
    SP_STATUS       Result;
    PUCHAR          pPrivateKeySave = NULL;


    SP_BEGIN("SPCreateCredential");



    pCred = (PSPCredential)SPExternalAlloc(sizeof(SPCredential));

    if(pCred == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY));
    }

    pCred->Magic = PCT_CRED_MAGIC;
    pCred->Type = Type;

#ifdef MULTI_THREADED
    InitializeCriticalSection(&pCred->csLock);
#endif

    pCred->RefCount = 0;
    pCred->cCerts = 0;
    pCred->paCerts = NULL;
    pCred->paPrivateKeys = NULL;
    pCred->cMappers = 0;
    pCred->pahMappers = NULL;
    Result = PCT_ERR_OK;
    pCred->Flags = 0;



    if(pCredData != NULL)
    {

        switch(pCredData->dwVersion)
        {
            case SCH_CRED_VERSION:
            pCred->cMappers = pCredData->cMappers;
            if(pCred->cMappers)
            {
                pCred->pahMappers = SPExternalAlloc(pCred->cMappers*sizeof(HMAPPER *));
                if(pCred->pahMappers == NULL)
                {
                    Result = SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY);
                    goto error;
                }
                CopyMemory(pCred->pahMappers, pCredData->aphMappers, pCred->cMappers * sizeof(HMAPPER *));
            }

            // fall through to v1 cred
            case SCH_CRED_V1:  // Our current version.
            {
                DWORD iCertData, iCred;

                // Allocate the certificate array.
                pCred->paCerts =
                    (PctCertificate **)SPExternalAlloc(sizeof(PctCertificate *) *
                                                             pCredData->cCreds);

                if(!pCred->paCerts)
                {
                    Result = SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY);
                    goto error; // bail
                }


                // Allocate memory for the private keys.
                pCred->paPrivateKeys =
                    (PctPrivateKey **)SPExternalAlloc(sizeof(PctPrivateKey *) *
                                                             pCredData->cCreds);

                ZeroMemory(pCred->paPrivateKeys, sizeof(PctPrivateKey *) *
                                                             pCredData->cCreds);

                if(!pCred->paPrivateKeys)
                {
                    Result = SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY);
                    goto error; // Leave polish loop
                }

                pCred->cCerts = pCredData->cCreds;
                // Loop through each credential, unpacking it, and adding it to our list.
                for (iCertData = 0, iCred = 0; iCertData < pCredData->cCreds; iCertData++)
                {
                    BYTE aVerifyClean[16];
                    BYTE aVerifySigned[255];
                    DWORD dwSigned;
                    DWORD dwClean;
                    const SignatureSystem *System;

                    Result = UnpackCredSecret(&pCred->paPrivateKeys[iCred], pCredData->paSecret[iCertData]);

                    if(Result != PCT_ERR_OK)
                    {
                        goto error;
                    }

                    Result = UnpackCredCertificate(&pCred->paCerts[iCred], pCredData->paPublic[iCertData]);
                    if(Result != PCT_ERR_OK)
                    {
                        goto error;
                    }

                    System = SigFromSpec(SP_SIG_RSA_MD5, SP_PROT_ALL);

                    if(System == NULL)
                    {
                        Result = SP_LOG_RESULT(PCT_INT_UNKNOWN_CREDENTIAL);
                        goto error;
                    }

                    // Verify that the credential and secret match.
                    dwClean = sizeof(aVerifyClean);
                    dwSigned = sizeof(aVerifySigned);
                    GenerateRandomBits(aVerifyClean, dwClean);
                    if(!System->Sign(aVerifyClean,
                                    dwClean,
                                    aVerifySigned,
                                    &dwSigned,
                                    pCred->paPrivateKeys[iCred]))
                    {
                        Result = SP_LOG_RESULT(PCT_INT_UNKNOWN_CREDENTIAL);
                        goto error;
                    }


                    if(!System->Verify(aVerifyClean,
                                    dwClean,
                                    aVerifySigned,
                                    dwSigned,
                                    pCred->paCerts[iCred]->pPublicKey))
                    {
                        Result = SP_LOG_RESULT(PCT_INT_UNKNOWN_CREDENTIAL);
                        goto error;
                    }

                    iCred++;
                }
                pCred->cCerts = iCred;
                break;
            }
            default:
                Result = SP_LOG_RESULT(PCT_INT_UNKNOWN_CREDENTIAL);
                goto error;

        }
    }

    SPReferenceCredential(pCred);
    *ppCred = pCred;
    SP_RETURN(PCT_ERR_OK);


error:
    // Error case, free the credential
    SPDeleteCredential(pCred);
    SP_RETURN(Result);
}


BOOL
SPDeleteCredential(
    PSPCredential  pCred)
{
    DWORD i;

    SP_BEGIN("SPDeleteCredential");


#ifdef MULTI_THREADED
    DeleteCriticalSection(&pCred->csLock);
#endif



    for (i = 0; i < pCred->cCerts; i++)
    {
       if(pCred->paPrivateKeys[i])
       {
          if(pCred->paPrivateKeys[i])
          {
              FillMemory(pCred->paPrivateKeys[i], pCred->paPrivateKeys[i]->cbKey, 0);
              SPExternalFree(pCred->paPrivateKeys[i]);
              pCred->paPrivateKeys[i]=NULL;
          }
        }

        if(pCred->paCerts[i])
        {
            DereferenceCert(pCred->paCerts[i]);
            pCred->paCerts[i]=NULL;
        }
    }
    if(pCred->cMappers && pCred->pahMappers)
    {
        for(i=0; i < pCred->cMappers; i++)
        {
            pCred->pahMappers[i]->m_vtable->DeReferenceMapper(pCred->pahMappers[i]);
        }
        SPExternalFree(pCred->pahMappers);
    }


    pCred->Magic = PCT_INVALID_MAGIC;

    SPExternalFree(pCred);
    SP_RETURN(TRUE);
}


// Reference a credential.
// Note: This should only be called by someone who already
// has a reference to the credential, or by the CreateCredential
// call.

BOOL
SPReferenceCredential(
    PSPCredential  pCred)
{
    BOOL fRet = FALSE;
    SP_BEGIN("PctReferenceCredential");

    fRet =  (InterlockedIncrement(&pCred->RefCount) > 0);

    DebugLog((SP_LOG_TRACE, "Reference Cred %lx: %d\n", pCred, pCred->RefCount));
    SP_RETURN(fRet);
}


BOOL
SPDereferenceCredential(
    PSPCredential  pCred)
{
//    LONG    Ref;
    BOOL fRet = FALSE;

    SP_BEGIN("PctDereferenceCredential");
    if(pCred == NULL)
    {
        return FALSE;
    }
    if(pCred->Magic != PCT_CRED_MAGIC)
    {
        return FALSE;
    }

    if(0 >= pCred->RefCount)
    {
        return FALSE;
    }
    fRet = TRUE;

    DebugLog((SP_LOG_TRACE, "Reference Cred %lx: %d\n", pCred, pCred->RefCount-1));

    if(0 ==  InterlockedDecrement(&pCred->RefCount))
    {
	    fRet = SPDeleteCredential(pCred);
    }

    SP_RETURN(fRet);

}


SP_STATUS
UnpackCredSecret(
    PPctPrivateKey *ppOutKey,
    PVOID pSecret
    )
{

    DWORD          dwType;
    PPctPrivateKey pResult;
//    DWORD Result;

    /*
     * We accept the following kinds of keys
     * in the pKeyData array.
     * 1) Der encoded private key
     * 2) PCT_CAPI_PRIVATE_KEY Structure
     * 3) WinSock2 LSP callback function
     */

    if(pSecret == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }
    dwType = *(DWORD *)pSecret;

    switch(dwType)
    {
        case SCHANNEL_SECRET_TYPE_WINSOCK2:
        {
            pResult = (PPctPrivateKey)SPExternalAlloc((DWORD)(((PPctPrivateKey)NULL)->pKey)+sizeof(SCH_CRED_SECRET_WINSOCK2));
            if(pResult == NULL)
            {
                return SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY);
            }
            CopyMemory(pResult->pKey,
                       pSecret,
                       sizeof(SCH_CRED_SECRET_WINSOCK2));
            pResult->cbKey = sizeof(SCH_CRED_SECRET_WINSOCK2);
            pResult->Type = SP_EXCH_RSA_PKCS1;   // probably not used

            *ppOutKey = pResult;
            break;
        }

        case SCHANNEL_SECRET_TYPE_CAPI:
        {
            PSCH_CRED_SECRET_CAPI pCapiKey;

            pCapiKey = (PSCH_CRED_SECRET_CAPI)pSecret;

            pResult = (PPctPrivateKey)SPExternalAlloc(SP_OFFSET_OF(PPctPrivateKey, pKey)+sizeof(HCRYPTPROV));
            if(pResult == NULL)
            {
                return SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY);
            }
            *(HCRYPTPROV *)(pResult->pKey) = pCapiKey->hProv;
            pResult->cbKey = sizeof(HCRYPTPROV);
            pResult->Type = SP_EXCH_RSA_PKCS1;

            *ppOutKey = pResult;
            break;
        }

        case SCHANNEL_SECRET_PRIVKEY:
        {
            PUCHAR pPrivateKeySave;
            PSCH_CRED_SECRET_PRIVKEY pPrivKey;
            long lRet;

            pPrivKey = (PSCH_CRED_SECRET_PRIVKEY)pSecret;
            // Make a copy of the private key, as it is
            // decrypted in place, and we don't want
            // to damage the key.
            pPrivateKeySave = SPExternalAlloc(pPrivKey->cbPrivateKey);
            if(pPrivateKeySave == NULL)
            {
                return SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY);
            }

            CopyMemory(pPrivateKeySave,
                       pPrivKey->pPrivateKey,
                       pPrivKey->cbPrivateKey);

            lRet = DecodePrivateKeyFile( ppOutKey,
                                    pPrivateKeySave,
                                    pPrivKey->cbPrivateKey,
                                    pPrivKey->pszPassword );

            SPExternalFree(pPrivateKeySave);
            if(lRet < 0)
            {
                return SP_LOG_RESULT(PCT_INT_UNKNOWN_CREDENTIAL);
            }
            break;
        }
        default:
        {
            return SP_LOG_RESULT(PCT_INT_UNKNOWN_CREDENTIAL);
        }
    }



    return PCT_ERR_OK;
}

SP_STATUS
UnpackCredCertificate(
    PPctCertificate *ppOutCert,
    PVOID pCertificate
    )
{
    DWORD          dwType;
//    PPctCertificate pResult;
//    DWORD Result;

    if(pCertificate == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }
    dwType = *(DWORD *)pCertificate;


    switch(dwType)
    {
        case SCH_CRED_X509_CERTCHAIN:
        {
            PSCH_CRED_PUBLIC_CERTCHAIN pCertChain;
//            BOOL bRet;
//            PPctCertificate pResult, pThis, pChild;
//            PUCHAR pCurrentRaw;
//            long  cbCurrentRaw;

            pCertChain = (PSCH_CRED_PUBLIC_CERTCHAIN)pCertificate;
            /* Decode the certificate */
            return SPLoadCertificate(SP_PROT_CRED,
                                     SP_CERT_X509,
                                     pCertChain->pCertChain,
                                     pCertChain->cbCertChain,
                                     ppOutCert,
                                     NULL);
        }
        default:
        {
            return SP_LOG_RESULT(PCT_INT_UNKNOWN_CREDENTIAL);
        }
    }

    return PCT_ERR_OK;
}


SP_STATUS
SPCredPickCertificate(
    DWORD               fProtocol,
    PSPCredential       pCred,
    CertSpec *          aServerPref,
    DWORD               cServerPref,
    CertSpec *          aClientPref,
    DWORD               cClientPref,
    PPctCertificate *   ppCert,
    PPctPrivateKey  *   ppPrivateKey)
{

    DWORD i, j, k;

    /* pick a cert, any cert   */
    /* Server order of preference for certificates:
     * Hardcoded Preference (CertRank)
     *    Client Preference    (Hello)
     *        What server has     (pCred)
     */

    if(ppCert == NULL || ppPrivateKey == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    for(i=0; i < cServerPref; i++)
    {
        // Is this cert type enabled?
        if(NULL == CertFromSpec(aServerPref[i], fProtocol))
        {
            continue;
        }

        for(j=0; j<cClientPref; j++)
        {
            // Does the client want this type of cert
            if(aServerPref[i] != aClientPref[j])
            {
                continue;
            }

            for(k=0; k<pCred->cCerts; k++)
            {
                // Do we have one of these certs
                if(pCred->paCerts[k]->Spec == aClientPref[j])
                {
                    /* Set up the certificate */

                    // We're referencing the certificate for whomever
                    // we're passing it out to.
                    if(ReferenceCert(pCred->paCerts[k]) <= 0)
                    {
                        // We couldn't reference this cert, so try
                        // another
                        break;
                    }
                    // Now dereference the cert that we are replacing.
                    DereferenceCert(*ppCert);

                    *ppCert = pCred->paCerts[k];
                    *ppPrivateKey = pCred->paPrivateKeys[k];
                    return PCT_ERR_OK;

                }
            }
        }
    }

    return SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH)    ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\cred.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology 
* reference implementation, version 1.0
* 
* The Private Communication Technology reference implementation, version 1.0 
* ("PCTRef"), is being provided by Microsoft to encourage the development and 
* enhancement of an open standard for secure general-purpose business and 
* personal communications on open networks.  Microsoft is distributing PCTRef 
* at no charge irrespective of whether you use PCTRef for non-commercial or 
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without 
* warranty of any kind, either express or implied, including, without 
* limitation, the implied warranties or merchantability, fitness for a 
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out 
* of use or performance of PCTRef remains with you.
* 
* Please see the file LICENSE.txt, 
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
* 
* Please see http://pct.microsoft.com/pct/pct.htm for The Private 
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/ 

#ifndef __CRED_H__
#define __CRED_H__

#define PCT_CRED_MAGIC  *(DWORD *)"CtcP"


typedef struct _SPCredential {
    DWORD               Magic;
    DWORD               Type;
    DWORD               Flags;
    CRITICAL_SECTION    csLock;
    DWORD               cMappers;
    HMAPPER            **pahMappers;
    LONG                RefCount;
    DWORD               cCerts;
    PctCertificate      **paCerts;
    PctPrivateKey       **paPrivateKeys;
} SPCredential, * PSPCredential;


SP_STATUS
SPCreateCredential(
    PSPCredential *ppCred,
    DWORD Type, 
    PSCH_CRED pCertData);


BOOL
SPReferenceCredential(
    PSPCredential  pCred);

BOOL
SPDereferenceCredential(
    PSPCredential  pCred);


BOOL 
SPDeleteCredential(PSPCredential pCred);

SP_STATUS 
SPCredPickCertificate(
    DWORD               fProtocol,
    PSPCredential       pCred,
    CertSpec *          aServerPref,
    DWORD               cServerPref,
    CertSpec *          aClientPref,
    DWORD               cClientPref,
    PPctCertificate *   ppCert,
    PPctPrivateKey  *   ppPrivateKey);


// flag bit definitions
#define CF_SC_ENABLED		1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\enc.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/

#include <spbase.h>

#include <ber.h>

int __cdecl stricmp(const char *, const char *);

typedef struct __EncAlgs {
    DWORD       Id;
    UCHAR       Sequence[16];
    DWORD       SequenceLen;
} _EncAlgs;


#define iso_member          0x2a,               /* iso(1) memberbody(2) */
#define us                  0x86, 0x48,         /* us(840) */
#define rsadsi              0x86, 0xf7, 0x0d,   /* rsadsi(113549) */
#define pkcs                0x01,               /* pkcs(1) */

#define pkcs_1              iso_member us rsadsi pkcs
#define pkcs_len            7
#define rsa_dsi             iso_member us rsadsi
#define rsa_dsi_len         6

#define joint_iso_ccitt_ds  0x55,
#define attributetype       0x04,

#define attributeType       joint_iso_ccitt_ds attributetype
#define attrtype_len        2


const _EncAlgs EncKnownAlgs[] =
{
    {ALGTYPE_SIG_RSA_MD5, {pkcs_1 1, 4}, pkcs_len + 2},
    {ALGTYPE_KEYEXCH_RSA_MD5, {pkcs_1 1, 1}, pkcs_len + 2},
    {ALGTYPE_CIPHER_RC4_MD5, {rsa_dsi 3, 4}, rsa_dsi_len + 2}
};



typedef struct _NameTypes {
    PSTR        Prefix;
    DWORD       PrefixLen;
    UCHAR       Sequence[8];
    DWORD       SequenceLen;
} NameTypes;

#define CNTYPE_INDEX        0

const NameTypes EncKnownNameTypes[] =
{
    {"CN=", 3, {attributeType 3},  attrtype_len + 1},
    {"C=",  2, {attributeType 6},  attrtype_len + 1},
    {"L=",  2, {attributeType 7},  attrtype_len + 1},
    {"S=",  2, {attributeType 8},  attrtype_len + 1},
    {"O=",  2, {attributeType 10}, attrtype_len + 1},
    {"OU=", 3, {attributeType 11}, attrtype_len + 1}
};


/************************************************************/
/* EncodeLength ASN1 encodes a length field.  The parameter */
/* dwLen is the length to be encoded, it is a DWORD and     */
/* therefore may be no larger than 2^32.  The pbEncoded     */
/* parameter is the encoded result, and memory must be      */
/* allocated for it by the caller.  The Writeflag parameter */
/* indicates if the result is to be written to the pbEncoded*/
/* parameter.  The function cannot fail and returns the     */
/* number of total bytes in the encoded length.             */
/* encoded length.                                          */
/************************************************************/

// Notes:	Encodes 0x0000 to 0x007f as <lobyte>
//		Encodes 0x0080 to 0x00ff as <81>, <lobyte>
//		Encodes 0x0100 to 0xffff as <82>, <hibyte>, <lobyte>

long
EncodeLength(
    BYTE *  pbEncoded,
    DWORD   dwLen,
    BOOL    Writeflag)
{
    // length is between 2^8 and 2^16 - 1

    if (dwLen > 0xFF)
    {
        if (Writeflag)
        {
            pbEncoded[0] = 0x82;
            pbEncoded[1] = (BYTE) (dwLen >> 8);
            pbEncoded[2] = (BYTE) dwLen;
        }
        return (3);
    }

    // length is between 2^7 and 2^8 - 1

    if (dwLen > 0x7F)
    {
        if (Writeflag)
        {
            pbEncoded[0] = 0x81;
            pbEncoded[1] = (BYTE) dwLen;
        }
        return (2);
    }

    // length is between 0 and 2^7 - 1

    if (Writeflag)
    {
	pbEncoded[0] = (BYTE) dwLen;
    }
    return (1);
}


long
EncodeNull(
    PUCHAR pbEncoded,
    BOOL WriteFlag )
{
    if (WriteFlag)
    {
        *pbEncoded++ = NULL_TAG;
        *pbEncoded = 0;
    }

    return( 2 );
}



/************************************************************/
/* EncodeAlgid ASN1 encodes an algorithm identifier. The    */
/* parameter Algid is the algorithm identifier as an ALG_ID */
/* type.  pbEncoded is the parameter used to pass back the  */
/* encoded result, and memory must be allocated for it by   */
/* the caller.  The Writeflag parameter indicates if the    */
/* result is to be written to the pbEncoded parameter       */
/* The function returns a -1 if it fails and otherwise      */
/* returns the number of total bytes in the encoded         */
/* algorithm identifier.                                    */
/************************************************************/
long
EncodeAlgid(
    BYTE *  pbEncoded,
    DWORD   Algid,
    BOOL    Writeflag)
{
    DWORD   i;
    PUCHAR  pbLen;

    /* determine the algorithm id which is to be encoded and */
    /* copy the appropriate encoded algid into the destination */

    if (Writeflag)
    {
        *pbEncoded++ = OBJECT_ID_TAG;
        pbLen = pbEncoded++;
    }

    for (i = 0; i < sizeof(EncKnownAlgs) / sizeof(_EncAlgs) ; i++ )
    {
        if (Algid == EncKnownAlgs[i].Id)
        {
            if (Writeflag)
            {
                CopyMemory( pbEncoded,
                            EncKnownAlgs[i].Sequence,
                            EncKnownAlgs[i].SequenceLen);

                *pbLen = (UCHAR) EncKnownAlgs[i].SequenceLen;
            }

            return(EncKnownAlgs[i].SequenceLen + 2);

        }
    }

    return(-1);
}



long
EncodeAlgorithm(
    BYTE *pbEncoded,
    DWORD AlgId,
    BOOL WriteFlag)
{
    BYTE Temp[32];
    long Result;
    BYTE *pBuffer;
    long HeaderLength;

    pBuffer = Temp;

    // Take a guess at the total length:
    HeaderLength = EncodeHeader(pBuffer, sizeof(Temp), TRUE);
    pBuffer += HeaderLength;

    Result = EncodeAlgid(pBuffer, AlgId, TRUE);
    if (Result == -1)
    {
	return(-1);
    }
    pBuffer += Result;

    Result += EncodeNull(pBuffer, TRUE);
    SP_ASSERT(pBuffer - Temp <= sizeof(Temp));

    // Fix up the total length:
    Result += EncodeHeader(Temp, Result, TRUE);
    SP_ASSERT(Result <= sizeof(Temp));

    if (WriteFlag)
    {
        CopyMemory(pbEncoded, Temp, Result);
    }
    return(Result);

}




/****************************************************************/
/* EncodeInteger ASN1 encodes an integer.  The pbInt parameter  */
/* is the integer as an array of bytes, and dwLen is the number */
/* of bytes in the array.  The least significant byte of the    */
/* integer is the zeroth byte of the array.  The encoded result */
/* is passed back in the pbEncoded parameter.  The Writeflag    */
/* indicates if the result is to be written to the pbEncoded    */
/* parameter. The function cannot fail and returns the number   */
/* of total bytes in the encoded integer.                       */
/* This implementation will only deal with positive integers.   */
/****************************************************************/

long
EncodeInteger(
    BYTE *pbEncoded,
    BYTE *pbInt,
    DWORD dwLen,
    BOOL Writeflag)
{
    DWORD i;
    long j;			// Must be signed!
    BYTE *pb = pbEncoded;

    if (Writeflag)
    {
        *pb = INTEGER_TAG;
    }
    pb++;

    /* find the most significant non-zero byte */

    for (i = dwLen - 1; pbInt[i] == 0; i--)
    {
	if (i == 0)	/* if the integer value is 0 */
	{
	    if (Writeflag)
	    {
		pb[0] = 0x01;
		pb[1] = 0x00;
	    }
	    return(3);
	}
    }

    /* if the most significant bit of the most sig byte is set */
    /* then need to add a 0 byte to the beginning. */

    if (pbInt[i] > 0x7F)
    {
	/* encode the length */
	pb += EncodeLength(pb, i + 2, Writeflag);

	if (Writeflag)
	{
	    /* set the first byte of the integer to 0 and increment pointer */
	    *pb = 0;
	}
	pb++;
    }
    else
    {
	/* encode the length */
	pb += EncodeLength(pb, i + 1, Writeflag);
    }

    /* copy the integer bytes into the encoded buffer */
    if (Writeflag)
    {
	/* copy the integer bytes into the encoded buffer */
	for (j = i; j >= 0; j--)
	{
	    *pb++ = pbInt[j];
	}
    }
    else
    {
	pb += i;
    }
    return(pb - pbEncoded);
}


/****************************************************************/
/* EncodeString ASN1 encodes a character string.  The pbStr     */
/* parameter is the string as an array of characters, and dwLen */
/* is the number of characters in the array.  The encoded result*/
/* is passed back in the pbEncoded parameter.  The Writeflag    */
/* indicates if the result is to be written to the pbEncoded    */
/* parameter. The function cannot fail and returns the number   */
/* of total bytes in the encoded string.                        */
/****************************************************************/

long
EncodeString(
    BYTE *  pbEncoded,
    BYTE *  pbStr,
    DWORD   dwLen,
    BOOL    Writeflag)
{
    long lengthlen;

    if (Writeflag)
    {
        *pbEncoded++ = CHAR_STRING_TAG;
    }
    lengthlen = EncodeLength(pbEncoded, dwLen, Writeflag);

    if (Writeflag)
    {
        CopyMemory(pbEncoded + lengthlen, pbStr, dwLen);
    }
    return(1 + lengthlen + dwLen);
}


/****************************************************************/
/* EncodeOctetString ASN1 encodes a string of hex valued        */
/* characters. The pbStr parameter is an array of characters,   */
/* and dwLen is the number of characters in the array.  The     */
/* encoded result is passed back in the pbEncoded parameter. The*/
/* Writeflag parameter indicates if the result is to be written */
/* to the pbEncoded parameter. The function cannot fail and     */
/* returns the number of total bytes in the encoded octet string*/
/****************************************************************/

long
EncodeOctetString(
    BYTE *  pbEncoded,
    BYTE *  pbStr,
    DWORD   dwLen,
    BOOL    Writeflag)
{
    long lengthlen;

    if (Writeflag)
    {
        *pbEncoded++ = OCTET_STRING_TAG;
    }
    lengthlen = EncodeLength(pbEncoded, dwLen, Writeflag);

    if (Writeflag)
    {
        CopyMemory(pbEncoded + lengthlen, pbStr, dwLen);
    }
    return(1 + lengthlen + dwLen);
}


/****************************************************************/
/* EncodeBitString ASN1 encodes a string of bit characters. The */
/* pbStr parameter is an array of characters (bits), and dwLen  */
/* is the number of characters in the array.  The encoded result*/
/* is passed back in the pbEncoded parameter.  The Writeflag    */
/* indicates if the result is to be written to the pbEncoded    */
/* parameter. The function cannot fail and returns the number   */
/* of total bytes in the encoded string.  This function uses    */
/* the DER.                                                     */
/****************************************************************/
long
EncodeBitString(
    BYTE *  pbEncoded,
    BYTE *  pbStr,
    DWORD   dwLen,
    BOOL    Writeflag)
{
    long lengthlen;

    if (Writeflag)
    {
        *pbEncoded++ = BIT_STRING_TAG;
    }

    lengthlen = EncodeLength(pbEncoded, dwLen + 1, Writeflag);

    if (Writeflag)
    {
	pbEncoded += lengthlen;

        // the next byte tells how many unused bits there are in the last byte,
        // but this will always be zero in this implementation (DER)

        *pbEncoded++ = 0;
        CopyMemory(pbEncoded, pbStr, dwLen);
    }
    return(1 + lengthlen + 1 + (long) dwLen);
}


#ifndef SECURITY_LINUX
//+---------------------------------------------------------------------------
//
/*  Function:   EncodeFileTime */
//
/*  Synopsis:   Encodes a FILETIME to a ASN.1 format time string. */
//
/*  Arguments:  [pbEncoded] -- */
/*              [Time]      -- */
/*              [UTC]       -- Indicate Time is UTC (true) or local (false) */
/*              [WriteFlag] -- */
//
/*  History:    8-10-95   RichardW   Created */
//
/*  Notes: */
//
//----------------------------------------------------------------------------
long
EncodeFileTime(
    BYTE *pbEncoded,
    FILETIME Time,
    BOOL UTC,
    BOOL WriteFlag)
{
    if (WriteFlag)
    {
	SYSTEMTIME st;
	FILETIME ft;
	int count;

	if (UTC)
	{
	    ft = Time;
	}
	else
	{
	    LocalFileTimeToFileTime(&Time, &ft);
	}

	FileTimeToSystemTime(&ft, &st);

	*pbEncoded++ = UTCTIME_TAG;

	count = EncodeLength(pbEncoded, 13, TRUE);

	SP_ASSERT(count == 1);

	pbEncoded++;
	st.wYear %= 100;

	*pbEncoded++ = (BYTE) ((st.wYear / 10) + '0');
	*pbEncoded++ = (BYTE) ((st.wYear % 10) + '0');

	*pbEncoded++ = (BYTE) ((st.wMonth / 10) + '0');
	*pbEncoded++ = (BYTE) ((st.wMonth % 10) + '0');

	*pbEncoded++ = (BYTE) ((st.wDay / 10) + '0');
	*pbEncoded++ = (BYTE) ((st.wDay % 10) + '0');

	*pbEncoded++ = (BYTE) ((st.wHour / 10) + '0');
	*pbEncoded++ = (BYTE) ((st.wHour % 10) + '0');

	*pbEncoded++ = (BYTE) ((st.wMinute / 10) + '0');
	*pbEncoded++ = (BYTE) ((st.wMinute % 10) + '0');

	*pbEncoded++ = (BYTE) ((st.wSecond / 10) + '0');
	*pbEncoded++ = (BYTE) ((st.wSecond % 10) + '0');

	*pbEncoded = 'Z';
    }
    // Tag(1) + Len(1) + Year(2) + Month(2) + Day(2) +
    // Hour(2) + Min(2) + Sec(2) + 'Z'(1) --> 15
    return(15);


}

#else /* SECURITY_LINUX */
/****************************************************************/
/* EncodeUTCTime ASN1 encodes a time_t value into a Universal   */
/* time type. The Time parameter is the time passed into the    */
/* function as a time_t type.  The encoded result is passed back*/
/* in the pbEncoded parameter.  The Writeflag indicates if the  */
/* result is to be written to the pbEncoded parameter.  The     */
/* function returns a -1 if it fails and otherwise returns the  */
/* number of total bytes in the encoded universal time.         */
/****************************************************************/

long
EncodeUTCTime(BYTE *pbEncoded, time_t Time, BOOL Writeflag)
{
    struct tm   *ptmTime;
    long        count;

    ptmTime = gmtime (&Time);

    if (Writeflag)
    {
        /* place the encoded time content into temporary memory */

        /* place the tag into the field */
        pbEncoded[0] = UTCTIME_TAG;

        /* encode the length */
        if ((count = EncodeLength (pbEncoded + 1, 13, TRUE)) < 0)
            return -1;

        /* get the year information */
        pbEncoded[count + 1] = (BYTE)(ptmTime->tm_year / 0xA + 0x30);
        pbEncoded[count + 2] = (BYTE)(ptmTime->tm_year % 0xA + 0x30);

        /* get the month information */
        pbEncoded[count + 3] = (BYTE)(ptmTime->tm_mon / 0xA + 0x30);
        pbEncoded[count + 4] = (BYTE)(ptmTime->tm_mon % 0xA + 0x30);

        /* get the day information */
        pbEncoded[count + 5] = (BYTE)(ptmTime->tm_mday / 0xA + 0x30);
        pbEncoded[count + 6] = (BYTE)(ptmTime->tm_mday % 0xA + 0x30);

        /* get the hour information */
        pbEncoded[count + 7] = (BYTE)(ptmTime->tm_hour / 0xA + 0x30);
        pbEncoded[count + 8] = (BYTE)(ptmTime->tm_hour % 0xA + 0x30);

        /* get the minute information */
        pbEncoded[count + 9] = (BYTE)(ptmTime->tm_min / 0xA + 0x30);
        pbEncoded[count + 10] = (BYTE)(ptmTime->tm_min % 0xA + 0x30);

        /* get the second information */
        pbEncoded[count + 11] = (BYTE)(ptmTime->tm_sec / 0xA + 0x30);
        pbEncoded[count + 12] = (BYTE)(ptmTime->tm_sec % 0xA + 0x30);

        pbEncoded[count + 13] = 'Z';
    }
    return 15;
}

#endif


/****************************************************************/
/* EncodeHeader ASN1 encodes a header for a sequence type. The  */
/* dwLen is the length of the encoded information in the        */
/* sequence.  The Writeflag indicates if the result is to be    */
/* written to the pbEncoded parameter.  The function cannot     */
/* fail and returns the number of total bytes in the encoded    */
/* header.                                                      */
/****************************************************************/

// Notes:	Encodes header as <SEQUENCE_TAG>, <length>

long
EncodeHeader(
    BYTE *  pbEncoded,
    DWORD   dwLen,
    BOOL    Writeflag)
{
    if (Writeflag)
    {
        *pbEncoded++ = SEQUENCE_TAG;
    }
    return(1 + EncodeLength(pbEncoded, dwLen, Writeflag));
}


/****************************************************************/
/* EncodeSetOfHeader ASN1 encodes a header for a set of type.   */
/* The dwLen is the length of the encoded information in the    */
/* set of.  The Writeflag indicates if the result is to be      */
/* written to the pbEncoded parameter.  The function cannot     */
/* fail and returns the number of total bytes in the encoded    */
/* header.                                                      */
/****************************************************************/

// Notes:	Encodes header as <SET_OF_TAG>, <length>

long
EncodeSetOfHeader(
    BYTE *  pbEncoded,
    DWORD   dwLen,
    BOOL    Writeflag)
{
    if (Writeflag)
    {
        *pbEncoded++ = SET_OF_TAG;
    }
    return(1 + EncodeLength(pbEncoded, dwLen, Writeflag));
}


// Notes:	Encodes header as <ATTRIBUTE_TAG>, <length>

long
EncodeAttributeHeader(
    BYTE *  pbEncoded,
    DWORD   dwLen,
    BOOL    Writeflag)
{
    if (Writeflag)
    {
        *pbEncoded++ = ATTRIBUTE_TAG;
    }
    return(1 + EncodeLength(pbEncoded, dwLen, Writeflag));
}


// Notes:	Encodes header as <BER_SET>, <length>

long
EncodeSetHeader(
    BYTE *  pbEncoded,
    DWORD   dwLen,
    BOOL    WriteFlag)
{
    if (WriteFlag)
    {
        *pbEncoded++ = BER_SET;
    }
    return(1 + EncodeLength(pbEncoded, dwLen, WriteFlag));
}



/****************************************************************/
/* EncodeName ASN1 encodes a Name type. The pbName parameter is */
/* the name and dwLen is the length of the name in bytes.       */
/* The Writeflag indicates if the result is to be written to    */
/* the pbEncoded parameter.  The function cannot fail and       */
/* returns the number of total bytes in the encoded name.       */
/****************************************************************/

long
EncodeName(
    BYTE *  pbEncoded,
    BYTE *  pbName,
    DWORD   dwLen,
    BOOL    Writeflag)
{
    BYTE        Type[MAXOBJIDLEN];
    long        TypeLen;
    BYTE        Value[MAXNAMEVALUELEN+MINHEADERLEN];
    long        ValueLen;
    BYTE        Attribute[MAXNAMELEN];
    long        AttributeLen;
    BYTE        SetHdr[MINHEADERLEN];
    long        HdrLen;
    long        NameLen;

    /* encode the name value */
    ValueLen = EncodeString(Value, pbName, dwLen, Writeflag);
    SP_ASSERT(ValueLen > 0 && ValueLen <= sizeof(Value));

    /* encode the attribute type, this is an object identifier and here it */
    /* is a fake encoding */
    Type[0] = 0x06;
    Type[1] = 0x01;
    Type[2] = 0x00;

    TypeLen = 3;

    /* enocde the header for the attribute */
    AttributeLen = EncodeHeader(
			    Attribute,
			    (DWORD) (ValueLen + TypeLen),
			    Writeflag);
    SP_ASSERT(AttributeLen > 0);
    SP_ASSERT(AttributeLen + TypeLen + ValueLen <= sizeof(Attribute));

    /* copy the attribute type and value into the attribute */
    CopyMemory(Attribute + AttributeLen, Type, (size_t) TypeLen);
    AttributeLen += TypeLen;
    CopyMemory(Attribute + AttributeLen, Value, (size_t) ValueLen);
    AttributeLen += ValueLen;

    /* encode set of header */
    HdrLen = EncodeSetOfHeader(SetHdr, (DWORD) AttributeLen, Writeflag);
    SP_ASSERT(HdrLen > 0 && HdrLen <= sizeof(SetHdr));

    /* encode Name header */
    NameLen = EncodeHeader(
			pbEncoded,
			(DWORD) (HdrLen + AttributeLen),
			Writeflag);
    SP_ASSERT(NameLen > 0);

    CopyMemory(pbEncoded + NameLen, SetHdr, (size_t) HdrLen);
    NameLen += HdrLen;
    CopyMemory(pbEncoded + NameLen, Attribute, (size_t) AttributeLen);

    return(NameLen + AttributeLen);
}

long
EncodeRDN(
    BYTE *  pbEncoded,
    PSTR    pszRDN,
    BOOL    WriteFlag)
{
    LONG    Result;
    DWORD   RelLength;
    long    Length;
    const NameTypes * pNameType;
    char ach[4];

    SP_ASSERT(pszRDN != NULL);
    if (pszRDN[0] == '\0' ||
	pszRDN[1] == '\0' ||
	pszRDN[2] == '\0' ||
	(pszRDN[1] != '=' && pszRDN[2] != '='))
    {
	return(-1);
    }
    ach[0] = pszRDN[0];
    ach[1] = pszRDN[1];
    if (ach[1] == '=')
    {
	ach[2] = '\0';
    }
    else
    {
	ach[2] = pszRDN[2];
	ach[3] = '\0';
    }

    for (pNameType = EncKnownNameTypes; ; pNameType++)
    {
        if (pNameType ==
            &EncKnownNameTypes[sizeof(EncKnownNameTypes) /
                       sizeof(EncKnownNameTypes[0])])
        {
            return(-1);
        }
        SP_ASSERT(strlen(pNameType->Prefix) < sizeof(ach));

        //
        // SHolden - stricmp defined in schannel.lib
        //

        if (stricmp(ach, pNameType->Prefix) == 0)
        {
            break;
        }
    }

    RelLength = strlen(&pszRDN[pNameType->PrefixLen]);

    // Prefix data takes up 9 bytes

    Length = EncodeSetHeader(pbEncoded, RelLength + 9, WriteFlag);
    pbEncoded += Length;

    Result = EncodeHeader(pbEncoded, RelLength + 7, WriteFlag);
    pbEncoded += Result;
    Length += Result + 2 + pNameType->SequenceLen;

    if (WriteFlag)
    {
        *pbEncoded++ = OBJECT_ID_TAG;
        *pbEncoded++ = (BYTE) pNameType->SequenceLen;

	CopyMemory(pbEncoded, pNameType->Sequence, pNameType->SequenceLen);
	pbEncoded += pNameType->SequenceLen;

	*pbEncoded++ =
	    pNameType == &EncKnownNameTypes[CNTYPE_INDEX]?
		TELETEX_STRING_TAG : PRINTABLE_STRING_TAG;

    }
    Length++;

    Result = EncodeLength(pbEncoded, RelLength, WriteFlag);
    Length += Result;

    if (WriteFlag)
    {
        CopyMemory(
		pbEncoded + Result,
		&pszRDN[pNameType->PrefixLen],
		RelLength);
    }
    return(Length + RelLength);
}


long
EncodeDN(
    BYTE *  pbEncoded,
    PSTR    pszDN,
    BOOL    WriteFlag)
{
//    PSTR pszNext;
    PSTR pszRDN;
    long Result;
    long Length;
    long SaveResult;

    SP_ASSERT(pszDN != NULL);

    SaveResult = 0;		 // force one full iteration
    Length = 2 * strlen(pszDN); // your guess is as good as mine
    while (TRUE)
    {
	PSTR pszNext;
	BYTE *pb;

	pb = pbEncoded;

	Result = EncodeHeader(pb, Length, WriteFlag);
	if (SaveResult == Result)
	{
	    break;
	}
	pb += Result;
	SaveResult = Result;

	Length = 0;
	pszRDN = pszDN;
	while (*pszRDN != '\0')
	{
	    for (pszNext = pszRDN; ; pszNext++)
	    {
		if (*pszNext == ',')
		{
		    *pszNext = '\0';
		    break;
		}
		if (*pszNext == '\0')
		{
		    pszNext = NULL;
		    break;
		}
	    }

	    Result = EncodeRDN(pb, pszRDN, WriteFlag);

	    // Restore the comma before checking for error

	    if (NULL != pszNext)
	    {
		*pszNext = ',';
	    }
	    if (Result < 0)
	    {
		DebugLog((DEB_TRACE, "EncodeDN: Error: %s\n", pszRDN));
		Length = 0;
		goto error;	// return(-1)
	    }

	    pb += Result;
	    Length += Result;

	    if (NULL == pszNext)
	    {
		break;
	    }

	    pszRDN = pszNext + 1;
	    while (*pszRDN == ' ')
	    {
		pszRDN++;
	    }
	    DebugLog((DEB_TRACE, "EncodeDN: Length = %d\n", Length));
	}
    }
    SP_ASSERT(0 != SaveResult);
error:
    return(Result + Length);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\hack.h ===
// hack.h

#ifndef UNDER_CE
    #ifdef DEBUG
        extern DWORD DebugFlag;
        void LogMessage(TCHAR *pFormat, ...);
        #define DbgPrint LogMessage
        #define DEBUGREGISTER(p)
        #define DEBUGZONE(n) ((0x0001<<n) & DebugFlag)
        // #define DEBUGMSG(exp,m) ((exp) ? DbgPrint m : (0))
        #define DEBUGMSG(exp,m) (0)
        #define ASSERT(exp) (0)
    #else
        #define DEBUGREGISTER(exp)  (0)
        #define DEBUGMSG(exp, m)    (0)
        #define ASSERT(exp)         (0)
    #endif // DEBUG
#endif // !UNDER_CE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\defkeys.h ===
// defkeys.h
//
//	resource defines for certificates in the schannel.dll resource
//


#define IDS_RSACCA                      4
#define IDS_RSASSCA                     5
#define IDS_VSCLASS2                    6
#define IDS_VSCLASS3                    7
#define IDS_VSCLASS4                    8
#define IDS_VSCLASS1                    9
#define IDS_KEYWITNESS                  11
#define IDS_CYBERTRUST                  12
#define IDS_THAWTE_SERVER_BASIC         13
#define IDS_THAWTE_SERVER_PREMIUM       14
#define IDS_KEYWITNESSv2	            15
#define IDS_CYBERTRUSTv2                16
#define IDS_THAWTE_PERSONAL_BASIC       17
#define IDS_THAWTE_PERSONAL_FREEMAIL    18
#define IDS_THAWTE_PERSONAL_PREMIUM     19
#define IDS_MICROSOFT_ROOT_AUTH         20
#define IDS_GENEVA_SGC_CERT             21

#define IDR_RSACCA                      107
#define IDR_RSASSCA                     108
#define IDR_VSCLASS2                    109
#define IDR_VSCLASS3                    110
#define IDR_VSCLASS4                    111
#define IDR_VSCLASS1                    112
#define IDR_KEYWITNESS                  114
#define IDR_CYBERTRUST                  115
#define IDR_THAWTE_SERVER_BASIC         116
#define IDR_THAWTE_SERVER_PREMIUM       117
#define IDR_KEYWITNESSv2                118
#define IDR_CYBERTRUSTv2                119
#define IDR_THAWTE_PERSONAL_BASIC       120
#define IDR_THAWTE_PERSONAL_FREEMAIL    121
#define IDR_THAWTE_PERSONAL_PREMIUM     122
#define IDR_MICROSOFT_ROOT_AUTH         123
#define IDR_ENTRUST_SECURE_SERVER       124
#define IDR_ENTRUST_2K_SECURE_SERVER    125

#define IDR_GENEVA_SGC_CERT             150
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\encode.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/

#include <spbase.h>

#include "ber.h"


/************************************************************/
/* EncodeLength ASN1 encodes a length field.  The parameter */
/* dwLen is the length to be encoded, it is a DWORD and     */
/* therefore may be no larger than 2^32.  The pbEncoded     */
/* parameter is the encoded result, and memory must be      */
/* allocated for it by the caller.  The Writeflag parameter */
/* indicates if the result is to be written to the pbEncoded*/
/* parameter.  The function returns a -1 if it fails and    */
/* otherwise returns the number of total bytes in the       */
/* encoded length.                                          */
/************************************************************/

typedef struct __Algorithms {
    DWORD       Id;
    UCHAR       Sequence[16];
    DWORD       SequenceLen;
} _Algorithms;

typedef struct __CryptAlgs {
    DWORD       Id;
    DWORD       idHash;
    UCHAR       Sequence[16];
    DWORD       SequenceLen;
} _CryptAlgs;

#define iso_member          0x2a,               /* iso(1) memberbody(2) */
#define us                  0x86, 0x48,         /* us(840) */
#define rsadsi              0x86, 0xf7, 0x0d,   /* rsadsi(113549) */
#define pkcs              iso_member us rsadsi 0x01,  /* pkcs */

#define pkcs_len            7
#define rsa_dsi             iso_member us rsadsi
#define rsa_dsi_len         6

#define joint_iso_ccitt_ds  0x55,
#define attributetype       0x04,

#define attributeType       joint_iso_ccitt_ds attributetype
#define attrtype_len        2


const _Algorithms     KnownSigAlgs[] = {
                                      {SP_SIG_RSA_MD2, {pkcs 1, 1}, pkcs_len + 2},
                                      {SP_SIG_RSA_MD2, {pkcs 1, 2}, pkcs_len + 2},
                                      {SP_SIG_RSA_MD5, {pkcs 1, 4}, pkcs_len + 2},
                                      {SP_SIG_RSA_SHA, {pkcs 1, 5}, pkcs_len + 2}
                                  };


const _Algorithms     KnownKeyExchAlgs[] = {{SP_EXCH_RSA_PKCS1, {pkcs 1, 1}, pkcs_len + 2},
                                      {SP_EXCH_RSA_PKCS1, {pkcs 1, 2}, pkcs_len + 2},
                                      {SP_EXCH_RSA_PKCS1, {pkcs 1, 4}, pkcs_len + 2}
                                 };
const _CryptAlgs     KnownCryptAlgs[] =  {
                                      {SP_CIPHER_RC4 | SP_ENC_BITS_128 | SP_MAC_BITS_128, SP_HASH_MD5, {rsa_dsi 3, 4}, rsa_dsi_len + 2}
                                    };

typedef struct _NameTypes {
    PSTR        Prefix;
    UCHAR       Sequence[12];
    DWORD       SequenceLen;
} NameTypes;

const NameTypes   KnownNameTypes[] = { {"CN=", {attributeType 3}, attrtype_len + 1},
                                 {"C=", {attributeType 6}, attrtype_len + 1},
                                 {"L=", {attributeType 7}, attrtype_len + 1},
                                 {"S=", {attributeType 8}, attrtype_len + 1},
                                 {"O=", {attributeType 10}, attrtype_len + 1},
                                 {"OU=", {attributeType 11}, attrtype_len + 1},
                                 {"Email=", {pkcs 9, 1}, pkcs_len + 2},
                                 {"Name=", {pkcs 9, 2}, pkcs_len + 2},
                                 {"Addr=", {pkcs 9, 8}, pkcs_len + 2}
                               };





/************************************************************/
/* DecodeLength decodes an ASN1 encoded length field.  The  */
/* pbEncoded parameter is the encoded length. pdwLen is     */
/* used to return the length therefore the length may be no */
/* larger than 2^32. The function returns a -1 if it fails  */
/* and otherwise returns the number of total bytes in the   */
/* encoded length.                                          */
/************************************************************/
long
DecodeLength(
    DWORD * pdwLen,
    BYTE *  pbEncoded,
    DWORD cEncoded)
{
    long    index = 0;
    BYTE    count;

    SP_ASSERT(pdwLen != NULL);
    SP_ASSERT(pbEncoded != NULL);

    if(cEncoded < 1) {
       DebugLog((DEB_TRACE, "cEncode overflow %d\n", cEncoded));
       return(SP_LOG_RESULT(-1));
    }


    /* determine what the length of the length field is */
    if ((count = pbEncoded[0]) > 0x80)
    {

        /* if there is more than one byte in the length field then */
        /* the lower seven bits tells us the number of bytes */
        count = count ^ 0x80;

        /* this function only allows the length field to be 3 bytes */
        /* if the field is longer then the function fails */
        if (count > 2)
        {
            DebugLog((DEB_WARN, "Length field reported to be over 3 bytes\n"));
            return(SP_LOG_RESULT(-1));
        }

        if(count > cEncoded) {
            DebugLog((DEB_TRACE, "cEncode overflow %d\n", cEncoded));
           return(SP_LOG_RESULT(-1));
    }

        *pdwLen = 0;

        /* go through the bytes of the length field */
        for (index = 1; index <= count; index++)
        {
            *pdwLen = (*pdwLen << 8) + (DWORD) (pbEncoded[index]);
        }

    }

    /* the length field is just one byte long */
    else
    {
        *pdwLen = (DWORD) (pbEncoded[0]);
        index = 1;
    }

    /* return how many bytes there were in the length field */
    return index;
}



/************************************************************/
/* DecodeSigAlgid decodes an ASN1 encoded algorithm identifier.*/
/* pbEncoded parameter is the encoded identifier. pAlgid is */
/* the parameter used to return the ALG_ID type algorithm   */
/* identifier.  The Writeflag parameter tells the function  */
/* whether to write to pAlgid or not, if TRUE write wlse    */
/* don't. The function returns a -1 if it fails and         */
/* otherwise returns the number of total bytes in the       */
/* encoded algorithm identifier.                            */
/************************************************************/

long
DecodeSigAlgid(
    DWORD *     pAlgid,
    BYTE *      pbEncoded,
    DWORD       cEncoded,
    BOOL    Writeflag)
{

    DWORD   i;
    DWORD   len;

    SP_ASSERT(pbEncoded != NULL);
    SP_ASSERT(pAlgid != NULL);

    SP_ASSERT((!Writeflag) || (pAlgid != NULL));
    if(cEncoded < 2)
    {
        return(SP_LOG_RESULT(-1));
    }

    if (*pbEncoded++ != OBJECT_ID_TAG)
    {
        return(SP_LOG_RESULT(-1));
    }

    len = *pbEncoded++;

    if(cEncoded < 2 + len) return(SP_LOG_RESULT(-1));

    for (i = 0; i < sizeof(KnownSigAlgs) / sizeof(_Algorithms) ; i++ )
    {
        if (KnownSigAlgs[i].SequenceLen == len)
        {
            if (memcmp(pbEncoded, KnownSigAlgs[i].Sequence, len) == 0)
            {
                if (Writeflag)
                {
                    *pAlgid = KnownSigAlgs[i].Id;
                }
                return(len + 2);
            }
        }
    }
    return(SP_LOG_RESULT(-1));
}
/************************************************************/
/* DecodeSigAlgid decodes an ASN1 encoded algorithm identifier.*/
/* pbEncoded parameter is the encoded identifier. pAlgid is */
/* the parameter used to return the ALG_ID type algorithm   */
/* identifier.  The Writeflag parameter tells the function  */
/* whether to write to pAlgid or not, if TRUE write wlse    */
/* don't. The function returns a -1 if it fails and         */
/* otherwise returns the number of total bytes in the       */
/* encoded algorithm identifier.                            */
/************************************************************/

long
DecodeCryptAlgid(
    DWORD *     pAlgid,
    DWORD *     pHashid,
    BYTE *      pbEncoded,
    DWORD       cEncoded,
    BOOL    Writeflag)
{

    DWORD   i;
    DWORD   len;

    SP_ASSERT(pbEncoded != NULL);
    SP_ASSERT(pAlgid != NULL);

    SP_ASSERT((!Writeflag) || (pAlgid != NULL));
    if(cEncoded < 2) return(SP_LOG_RESULT(-1));

    if (*pbEncoded++ != OBJECT_ID_TAG)
    {
        return(SP_LOG_RESULT(-1));
    }

    len = *pbEncoded++;

    if(cEncoded < 2 + len)
    {
        return(SP_LOG_RESULT(-1));
    }

    for (i = 0; i < sizeof(KnownCryptAlgs) / sizeof(_CryptAlgs) ; i++ )
    {
        if (KnownCryptAlgs[i].SequenceLen == len)
        {
            if (memcmp(pbEncoded, KnownCryptAlgs[i].Sequence, len) == 0)
            {
                if (Writeflag)
                {
                    *pAlgid = KnownCryptAlgs[i].Id;
                    *pHashid = KnownCryptAlgs[i].idHash;
                }
                return(len + 2);
            }
        }
    }
    return(SP_LOG_RESULT(-1));
}


/************************************************************/
/* DecodeKeyExchId decodes an ASN1 encoded algorithm identifier.*/
/* pbEncoded parameter is the encoded identifier. pAlgid is */
/* the parameter used to return the ALG_ID type algorithm   */
/* identifier.  The Writeflag parameter tells the function  */
/* whether to write to pAlgid or not, if TRUE write wlse    */
/* don't. The function returns a -1 if it fails and         */
/* otherwise returns the number of total bytes in the       */
/* encoded algorithm identifier.                            */
/************************************************************/

long
DecodeKeyExchAlgid(
    DWORD *     pKeyId,
    BYTE *      pbEncoded,
    DWORD       cEncoded,
    BOOL    Writeflag)
{

    DWORD   i;
    DWORD   len;

    SP_ASSERT(pbEncoded != NULL);

    SP_ASSERT((!Writeflag) || (pKeyId != NULL));
    if(cEncoded < 2)
    {
        return(SP_LOG_RESULT(-1));
    }

    if (*pbEncoded++ != OBJECT_ID_TAG)
    {
        return(SP_LOG_RESULT(-1));
    }

    len = *pbEncoded++;

    if(cEncoded < 2 + len)
    {
        return(SP_LOG_RESULT(-1));
    }

    for (i = 0; i < sizeof(KnownKeyExchAlgs) / sizeof(_Algorithms) ; i++ )
    {
        if (KnownKeyExchAlgs[i].SequenceLen == len)
        {
            if (memcmp(pbEncoded, KnownKeyExchAlgs[i].Sequence, len) == 0)
            {
                if (Writeflag)
                {
                    *pKeyId = KnownKeyExchAlgs[i].Id;
                }
                return(len + 2);
            }
        }
    }
    return(SP_LOG_RESULT(-1));
}



/************************************************************/
/* DecodeHeader decodes an ASN1 encoded sequence type header.*/
/* pbEncoded parameter is the encoded header.  pdwLen is    */
/* the parameter used to return the length of the encoded   */
/* sequence. The function returns a -1 if it fails and      */
/* otherwise returns the number of total bytes in the       */
/* encoded header, not including the content.               */
/************************************************************/

long
DecodeHeader(
    DWORD * pdwLen,
    BYTE *  pbEncoded,
    DWORD cEncoded)
{
    long    len;

    SP_ASSERT(pdwLen != NULL);
    SP_ASSERT(pbEncoded != NULL);

    if(cEncoded < 1)
    {
       DebugLog((DEB_TRACE, "Buffer Overflow\n"));
       return(SP_LOG_RESULT(-1));
    }

    /* make sure this is a sequence type */
    if (pbEncoded[0] != SEQUENCE_TAG)
    {
        DebugLog((DEB_WARN, "Sequence Tag not found, %x instead\n", pbEncoded[0]));
        return(SP_LOG_RESULT(-1));
    }

    /* decode the length */
    if ((len = DecodeLength (pdwLen, pbEncoded + 1, cEncoded-1)) == -1)
    {
        DebugLog((DEB_TRACE, "Bad Length Decode\n"));
        return(SP_LOG_RESULT(-1));
    }

    return (len + 1);
}



/************************************************************/
/* DecodeSetOfHeader decodes an ASN1 encoded set of type    */
/* header. pbEncoded parameter is the encoded header. pdwLen*/
/* is the parameter used to return the length of the encoded*/
/* set of. The function returns a -1 if it fails and        */
/* otherwise returns the number of total bytes in the       */
/* encoded header, not including the content.               */
/************************************************************/

long
DecodeSetOfHeader(
    DWORD * pdwLen,
    BYTE *  pbEncoded,
    DWORD cEncoded)
{
    long    len;

    SP_ASSERT(pdwLen != NULL);
    SP_ASSERT(pbEncoded != NULL);


    if(cEncoded < 1)
    {
        return(SP_LOG_RESULT(-1));
    }

    /* make sure this is a sequence type */
    if (*pbEncoded != SET_OF_TAG)
    {
        return(SP_LOG_RESULT(-1));
    }

    /* decode the length */
    if ((len = DecodeLength (pdwLen, pbEncoded + 1, cEncoded-1)) == -1)
        return(-1);

    return (len + 1);
}

long
DecodeSetHeader(
    DWORD * pdwLen,
    BYTE *  pbEncoded,
    DWORD cEncoded)
{
    long len;

    SP_ASSERT(pdwLen != NULL);
    SP_ASSERT(pbEncoded != NULL);

    if(cEncoded < 1)
    {
        return(SP_LOG_RESULT(-1));
    }

    if (*pbEncoded != BER_SET)
    {
        return(SP_LOG_RESULT(-1));
    }

    if((len = DecodeLength(pdwLen, pbEncoded + 1, cEncoded-1)) == -1)
    {
        return(-1);
    }
    return(len + 1);
}

/****************************************************************/
/* DecodeInteger decodes an ASN1 encoded integer.  The encoded  */
/* integer is passed into the function with the pbEncoded       */
/* parameter.  The pbInt parameter is used to pass back the     */
/* integer as an array of bytes, and dwLen is the number of     */
/* in the array.  The least significant byte of the integer     */
/* is the zeroth byte of the array.  The Writeflag indicates    */
/* indicates if the result is to be written to the pbInt        */
/* parameter. The function returns a -1 if it fails and         */
/* otherwise returns the number of total bytes in the encoded   */
/* integer.                                                     */
/* This implementation will only deal with positive integers.   */
/****************************************************************/

long
DecodeInteger(
    BYTE *  pbInt,
    DWORD   cbBuff,
    DWORD * pdwLen,
    BYTE *  pbEncoded,
    DWORD   cEncoded,
    BOOL    Writeflag)
{
    long    count;
    long    i;


    SP_ASSERT(pdwLen != NULL);
    SP_ASSERT(pbEncoded != NULL);

    SP_ASSERT((!Writeflag) || (pbInt != NULL));

    if(cEncoded < 1)
    {
        return(SP_LOG_RESULT(-1));
    }

    /* make sure this is tagged as an integer */
    if (pbEncoded[0] != INTEGER_TAG)
    {
        return(SP_LOG_RESULT(-1));
    }

    count = 1;

    /* decode the length field */
    if ((i = DecodeLength (pdwLen, pbEncoded + 1, cEncoded-count)) == -1)
    {
        return(-1);
    }

    count += i;


    if(cEncoded < count+*pdwLen)
    {
        return(SP_LOG_RESULT(-1));
    }

    /* write the integer out if suppose to */
    if (Writeflag)
    {
        if (pbEncoded[count] == 0)
        {
            count++;
            (*pdwLen)--;
        }

        if(*pdwLen > cbBuff) return -1;

        i = (*pdwLen) - 1;

        while (i >= 0)
        {
            pbInt[i--] = pbEncoded[count++];

        }
    }
    else
    {
        count += (long) *pdwLen;
    }

    /* return the length of the encoded integer */
    return (count);
}


/****************************************************************/
/* DecodeString decodes an ASN1 encoded a character string.  The*/
/* encoded string is passed into the function with the pbEncoded*/
/* parameter.  The pbStr is used to pass the decoded string back*/
/* to the caller, and pdwLen is the number of characters in the */
/* decoded array.  The Writeflag indicates if the result is to  */
/* be written to the pbStr parameter.  The function returns a   */
/* -1 if it fails and otherwise returns the number of bytes in  */
/* the encoded string.                                          */
/****************************************************************/
long
DecodeString(
    BYTE *  pbStr,
    DWORD * pdwLen,
    BYTE *  pbEncoded,
    DWORD   cEncoded,
    BOOL    Writeflag)
{
    long    index;

    SP_ASSERT(pdwLen != NULL);
    SP_ASSERT(pbEncoded != NULL);

    SP_ASSERT((!Writeflag) || (pbStr != NULL));

    if(cEncoded < 1)
    {
        return(SP_LOG_RESULT(-1));
    }

    if ((*pbEncoded != BER_PRINTABLE_STRING) &&
        (*pbEncoded != BER_TELETEX_STRING) &&
        (*pbEncoded != BER_GRAPHIC_STRING) &&
        (*pbEncoded != BER_IA5STRING))
    {
        return(SP_LOG_RESULT(-1));
    }

    /* determine how long the string is */
    if ((index = DecodeLength (pdwLen, pbEncoded + 1, cEncoded-1)) == -1)
    {
        return(-1);
    }

    index++;

    if(cEncoded < index + *pdwLen)
    {
        return(SP_LOG_RESULT(-1));
    }

    if (Writeflag)
    {
        CopyMemory(pbStr, pbEncoded + index, *pdwLen);
    }

    return (index + *pdwLen);
}


/****************************************************************/
/* DecodeOctetString decodes an ASN1 encoded a octet string. The*/
/* encoded string is passed into the function with the pbEncoded*/
/* parameter.  The pbStr is used to pass the decoded string back*/
/* to the caller, and pdwLen is the number of characters in the */
/* decoded array.  The Writeflag indicates if the result is to  */
/* be written to the pbStr parameter.  The function returns a   */
/* -1 if it fails and otherwise returns the number of bytes in  */
/* the encoded string.                                          */
/****************************************************************/
long
DecodeOctetString(
    BYTE *  pbStr,
    DWORD * pdwLen,
    BYTE *  pbEncoded,
    DWORD   cEncoded,
    BOOL    Writeflag)
{
    long    index;

    SP_ASSERT(pdwLen != NULL);
    SP_ASSERT(pbEncoded != NULL);

    SP_ASSERT((!Writeflag) || (pbStr != NULL));


    if(cEncoded < 1)
    {
         DebugLog((DEB_TRACE, "cEncoded Overflow:%d\n", cEncoded));
         return(SP_LOG_RESULT(-1));
    }

    if (pbEncoded[0] != OCTET_STRING_TAG)
    {
        DebugLog((DEB_TRACE, "Invalid Tag, expected OCTET_STRING, got %d\n", pbEncoded[0]));
        return(SP_LOG_RESULT(-1));
    }

    /* determine how long the string is */
    if ((index = DecodeLength (pdwLen, pbEncoded + 1, cEncoded-1)) == -1)
    {
        return(-1);
    }

    index++;
    if(cEncoded < index+*pdwLen)
    {
        return(SP_LOG_RESULT(-1));
    }

    if (Writeflag)
    {
        CopyMemory(pbStr, pbEncoded + index, *pdwLen);
    }

    return (index + *pdwLen);
}


/****************************************************************/
/* DecodeBitString decodes an ASN1 encoded a bit string. The    */
/* encoded string is passed into the function with the pbEncoded*/
/* parameter.  The pbStr is used to pass the decoded string back*/
/* to the caller, and pdwLen is the number of characters in the */
/* decoded array.  The Writeflag indicates if the result is to  */
/* be written to the pbStr parameter.  The function returns a   */
/* -1 if it fails and otherwise returns the number of bytes in  */
/* the encoded string.  The DER are used in the decoding.       */
/****************************************************************/
long
DecodeBitString(
    BYTE *  pbStr,
    DWORD * pdwLen,
    BYTE *  pbEncoded,
    DWORD   cEncoded,
    BOOL    Writeflag)
{
    long    index;

    SP_ASSERT(pdwLen != NULL);
    SP_ASSERT(pbEncoded != NULL);

    SP_ASSERT((!Writeflag) || (pbStr != NULL));

    if(cEncoded < 1)
    {
        return(SP_LOG_RESULT(-1));
    }

    if (pbEncoded[0] != BIT_STRING_TAG)
    {
        return(SP_LOG_RESULT(-1));
    }

    /* determine how long the string is */
    if ((index = DecodeLength (pdwLen, pbEncoded + 1, cEncoded-1)) == -1)
    {
        return(-1);
    }

    /* move the index up two bytes, one for the tag and one for the byte after */
    /* the length which tells the number of unused bits in the last byte, that */
    /* byte is always zero in this implementation, so it is ignored */
    index += 2;

    /* subtract one from the length of the bit string (in bytes) since, */
    /* to account for the byte after the length */
    (*pdwLen)--;

    if(cEncoded < index + *pdwLen)
    {
        return(SP_LOG_RESULT(-1));
    }

    if (Writeflag)
    {
        CopyMemory(pbStr, pbEncoded + index, *pdwLen);
    }

    return (index + *pdwLen);
}

#ifdef SECURITY_LINUX
/****************************************************************/
/* DecodeUTCTime decodes an ASN1 encoded Universal time type.   */
/* time type. The Time parameter is the time passed into the    */
/* function as a time_t type.  The encoded result is passed back*/
/* in the pbEncoded parameter.  The Writeflag indicates if the  */
/* result is to be written to the pbEncoded parameter.  The     */
/* function returns a -1 if it fails and otherwise returns the  */
/* number of total bytes in the encoded universal time.         */
/****************************************************************/

long
DecodeUTCTime(time_t *pTime, BYTE *pbEncoded, DWORD cEncoded, BOOL Writeflag)
    {
    long        count;
    struct tm   tmTime;
    DWORD       dwLen;

    SP_ASSERT(pbEncoded != NULL);

    SP_ASSERT((!Writeflag) || (pTime != NULL));


    if(cEncoded < 1)
    {
        return(SP_LOG_RESULT(-1));
    }

    /* check to make sure this is a universal time type */
    if (pbEncoded[0] != UTCTIME_TAG)
    {
        return(SP_LOG_RESULT(-1));
    }

    /* decode the length */
    if ((count = DecodeLength (&dwLen, pbEncoded + 1, cEncoded-1)) == -1)
    {
        return -1;
    }

    count++;
    dwLen += count;

    if(cEncoded < dwLen)
    {
        return(SP_LOG_RESULT(-1));
    }

    if (Writeflag)
    {
        /* extract the year */
        tmTime.tm_year = (int)((pbEncoded[count] - 0x30) * 0xA
                                + (pbEncoded[count + 1] - 0x30));
        count += 2;

        /* extract the month */
        tmTime.tm_mon = (int)((pbEncoded[count] - 0x30) * 0xA
                                + (pbEncoded[count + 1] - 0x30));
        count += 2;

        /* extract the day */
        tmTime.tm_mday = (int)((pbEncoded[count] - 0x30) * 0xA
                                + (pbEncoded[count + 1] - 0x30));
        count += 2;

        /* extract the hour */
        tmTime.tm_hour = (int)((pbEncoded[count] - 0x30) * 0xA
                                + (pbEncoded[count + 1] - 0x30));
        count += 2;

        /* extract the minutes */
        tmTime.tm_min = (int)((pbEncoded[count] - 0x30) * 0xA
                                + (pbEncoded[count + 1] - 0x30));
        count += 2;

        /* extract the seconds */
        tmTime.tm_sec = (int)((pbEncoded[count] - 0x30) * 0xA
                                + (pbEncoded[count + 1] - 0x30));
        count += 2;

        /* make sure there is a Z at the end */
        if (pbEncoded[count] != 'Z')
        {
            return(SP_LOG_RESULT(-1));
        }

        *pTime = mktime (&tmTime);
    }

    return (long)dwLen;
}

#else /* SECURITY_LINUX */

long
DecodeFileTime(
    FILETIME *  pTime,
    BYTE *      pbEncoded,
    DWORD       cEncoded,
    BOOL        WriteFlag)
{
    LONGLONG    ft;
    LONGLONG    delta;
    SYSTEMTIME  st;
    long        count;
    DWORD       dwLen, dwTotalLen;
    BOOL        fUTC;
    int         Offset;

    SP_ASSERT(pTime != NULL);
    SP_ASSERT(pbEncoded != NULL);

    SP_ASSERT((!WriteFlag) || (pTime != NULL));

    if(cEncoded < 1)
    {
        return(SP_LOG_RESULT(-1));
    }

    /* check to make sure this is a universal time type */
    if (pbEncoded[0] != UTCTIME_TAG)
    {
        return(SP_LOG_RESULT(-1));
    }

    /* decode the length */
    if ((count = DecodeLength (&dwLen, pbEncoded + 1, cEncoded-1)) == -1)
    {
       return(-1);
    }

    count++;
    dwTotalLen = dwLen + count;

    if(cEncoded < dwLen)
    {
        return(SP_LOG_RESULT(-1));
    }

    pbEncoded += count;

    if (WriteFlag)
    {
        st.wYear = (WORD) ((pbEncoded[0] - '0') * 10) +
                            (pbEncoded[1] - '0');

        if (st.wYear < 90)
        {
            st.wYear += 2000;
        }
        else
        {
            st.wYear += 1900;
        }

        pbEncoded += 2;
        dwLen -= 2;

        st.wMonth = (WORD) ((pbEncoded[0] - '0') * 10) +
                            (pbEncoded[1] - '0');

        pbEncoded += 2;
        dwLen -= 2;

        st.wDay = (WORD) ((pbEncoded[0] - '0') * 10) +
                            (pbEncoded[1] - '0');

        pbEncoded += 2;
        dwLen -= 2;

        st.wHour = (WORD) ((pbEncoded[0] - '0') * 10) +
                            (pbEncoded[1] - '0');

        pbEncoded += 2;
        dwLen -= 2;

        st.wMinute = (WORD) ((pbEncoded[0] - '0') * 10) +
                            (pbEncoded[1] - '0');

        pbEncoded += 2;
        dwLen -= 2;

        fUTC = FALSE;
        Offset = 0;
        st.wSecond = 0;

        if (dwLen)
        {
            //
            // Ok, still more to go:
            //

            if (*pbEncoded == 'Z')
            {
                DebugLog((DEB_TRACE, "FileTime:  no seconds, Z term\n"));
                //
                // Ok, it is UTC.
                //

                dwLen++;
                pbEncoded++;

            }
            else
            {
                if ((*pbEncoded == '+') ||
                    (*pbEncoded == '-') )
                {
                    DebugLog((DEB_TRACE, "FileTime:  no seconds, offset\n"));
                    //
                    // Yuck!  Offset encoded!
                    //

                    if (dwLen != 5)
                    {
                        return( -1 );
                    }

                    Offset = (int) ((pbEncoded[1] - '0') * 10) +
                                    (pbEncoded[2] - '0');
                    Offset *= 60;

                    Offset += (int) ((pbEncoded[3] - '0') * 10) +
                                    (pbEncoded[4] - '0');

                    if (pbEncoded[0] == '-')
                    {
                        Offset *= -1;
                    }


                }
                else
                {
                    st.wSecond = (WORD) ((pbEncoded[0] - '0') * 10) +
                                        (pbEncoded[1] - '0');

                    if (dwLen == 3)
                    {
                        if (pbEncoded[2] != 'Z')
                        {
                            return( -1 );
                        }

                    }
                    else if (dwLen > 3)
                    {
                        Offset = (int) ((pbEncoded[3] - '0') * 10) +
                                    (pbEncoded[4] - '0');
                        Offset *= 60;

                        Offset += (int) ((pbEncoded[5] - '0') * 10) +
                                        (pbEncoded[6] - '0');

                        if (pbEncoded[2] == '-')
                        {
                            Offset *= -1;
                        }

                    }
                }
            }
        }

        st.wMilliseconds = 0;

        SystemTimeToFileTime(&st, (FILETIME *) &ft);
        if (Offset != 0)
        {
            delta = (LONGLONG) Offset * 10000000;
            ft += delta;
        }

        *pTime = *((FILETIME *) &ft);
    }
    return(dwTotalLen);

}
#endif / * SECURITY_LINUX */

/****************************************************************/
/* DecodeName decodes an ASN1 encoded Name type. The encoded    */
/* name is passed into the function with the pbEncoded parameter*/
/* The pbName parameter is used to pass the name back to the    */
/* caller and pdwLen is the length of the name in bytes.        */
/* The Writeflag indicates if the result is to be written to    */
/* the pbName parameter.  The function returns a -1 if it       */
/* fails and otherwise returns the number of total bytes in the */
/* encoded name.                                                */
/****************************************************************/

long
DecodeName(
    BYTE *  pbName,
    DWORD * pdwLen,
    BYTE *  pbEncoded,
    DWORD   cEncoded,
    BOOL    Writeflag)
{
    long        index;
    DWORD       dwLen;

    SP_ASSERT(pdwLen != NULL);
    SP_ASSERT(pbEncoded != NULL);

    SP_ASSERT((!Writeflag) || (pbName != NULL));

    /* decode the sequence header */
    if ((index = DecodeHeader (&dwLen, pbEncoded, cEncoded)) == -1)
    {
        return(-1);
    }

    /* decode the set of header */
    if ((index += DecodeSetOfHeader (&dwLen, pbEncoded + index, cEncoded-index)) < index)
    {
        return(-1);
    }

    /* decode the sequence header */
    if ((index += DecodeHeader (&dwLen, pbEncoded + index, cEncoded-index)) < index)
    {
        return(-1);
    }

    /* decode the attribute type, in this implementation it is fake */
    index += 3;  /* 3 because this is the length of the fake OBJECT IDENTIFIER */

    /* decode the string which is the name */
    if ((index += DecodeString (pbName, pdwLen, pbEncoded + index, cEncoded-index, Writeflag)) < index)
    {
        return(-1);
    }

    return index;
}

long
DecodeNull(
    BYTE *  pbEncoded, DWORD cEncoded)
{

    SP_ASSERT(pbEncoded != NULL);

    if(cEncoded < 2) return(SP_LOG_RESULT(-1));
    if (*pbEncoded != NULL_TAG)
    {
        return(SP_LOG_RESULT(-1));
    }
    return(2);
}


long
DecodeNameType(
    PSTR *      ppPrefix,
    BYTE *      pbEncoded,
    DWORD cEncoded)
{

    DWORD   i;
    DWORD   len;

    SP_ASSERT(ppPrefix != NULL);
    SP_ASSERT(pbEncoded != NULL);


    if(cEncoded < 1)
    {
        return(SP_LOG_RESULT(-1));
    }

    if (*pbEncoded != OBJECT_ID_TAG)
    {
        return(SP_LOG_RESULT(-1));
    }

    pbEncoded++;

    len = *pbEncoded++;
    if(cEncoded < len+2)
    {
        return(SP_LOG_RESULT(-1));
    }

    for (i = 0; i < sizeof(KnownNameTypes) / sizeof(NameTypes) ; i++ )
    {
        if (KnownNameTypes[i].SequenceLen == len)
        {
            if (memcmp(pbEncoded, KnownNameTypes[i].Sequence, len) == 0)
            {
                *ppPrefix = KnownNameTypes[i].Prefix;
                return(len + 2);
            }
        }
    }

    *ppPrefix = ""; //TEXT("");
    return len + 2;
}


long
DecodeRDN(
    PSTR    pName,
    DWORD * pdwComponentLength,
    BYTE *  pbEncoded,
    DWORD   cEncoded,
    BOOL    WriteFlag)
{
    static const TCHAR SEPARATOR[] = TEXT(" ");
    static const long SEPLEN = sizeof(SEPARATOR) / sizeof(TCHAR);
    long    index;
    DWORD   dwLen;
    PSTR    Prefix;
    long    PrefixLen;
    long    CompLen = 0;
    long    Processed;
    long    RdnLen;
    BOOL    fTmpWrite;

    index = DecodeSetHeader(&RdnLen, pbEncoded, cEncoded);
    if (index == -1)
    {
        return(-1);
    }
    Processed = RdnLen + index;
    pbEncoded += index;
    if (0 != RdnLen)
        for (;;)
        {
            index = DecodeHeader(&dwLen, pbEncoded, RdnLen);
            if (index < 0)
                return(-1);
            RdnLen -= index;
            pbEncoded += index;

            index = DecodeNameType(&Prefix, pbEncoded, RdnLen);
            if (index < 0)
            {
                return(-1);
            }
            RdnLen -= index;
            pbEncoded += index;

            PrefixLen = strlen(Prefix);
            fTmpWrite = WriteFlag && (0 < PrefixLen);
            if (fTmpWrite)
            {
                CopyMemory(pName, Prefix, PrefixLen);
                pName += PrefixLen;
            }

            index = DecodeString((PUCHAR)pName, &dwLen, pbEncoded, RdnLen, fTmpWrite);
            if (index < 0)
            {
                return(-1);
            }
            if (fTmpWrite)
            {
                pName += dwLen;
            }
            RdnLen -= index;
            pbEncoded += index;
            if (0 < PrefixLen)
            {
                CompLen += PrefixLen + dwLen;
            }
            if (0 < RdnLen)
            {
                if (fTmpWrite)
                {
                    CopyMemory(pName, SEPARATOR, sizeof(SEPARATOR));
                    pName += SEPLEN;
                }
                CompLen += SEPLEN;
            }
            else
            {
                break;
            }
        }

    *pdwComponentLength = CompLen;
    return Processed;
}


long
DecodeDN(
    PSTR    pName,      // Make this buffer 2 chars longer than tne size of the string!
    DWORD * pdwLen,
    BYTE *  pbEncoded,
    DWORD   cEncoded,
    BOOL    WriteFlag)
{
    long    index;
    DWORD   dwLen;
    long    TotalNameLength;
    DWORD   ComponentLength;
    DWORD   NameLength;
    long    EncodedNameLength;

    index = DecodeHeader(&dwLen, pbEncoded, cEncoded);

    if (index == -1)
    {
        return(-1);
    }

    EncodedNameLength = index + dwLen;

    TotalNameLength = dwLen;
    NameLength = 0;

    while (TotalNameLength > 0)
    {
        pbEncoded += index;

        index = DecodeRDN(  pName,
                            &ComponentLength,
                            pbEncoded,
                            cEncoded - index,
                            WriteFlag);
        if (index == -1)
            return(-1);

        if (WriteFlag)
            pName += ComponentLength;
        TotalNameLength -= index;
        NameLength += ComponentLength;

        if ((TotalNameLength > 0) && (0 < ComponentLength))
        {
            if (WriteFlag)
            {
                *pName++ = ',';
                *pName++ = ' ';
            }
            NameLength += 2;
        }
        else if ((TotalNameLength <= 0)
                 && (0 == ComponentLength)
                 && (0 < NameLength))
        {

            //
            // The last RDN didn't produce any output, so we need to
            // roll back that ", " we put on previously.
            //

            if (WriteFlag)
                pName -= 2;
            NameLength -= 2;
        }
    }

    NameLength++;   // For the Trailing NULL

    if (WriteFlag)
    {
        *pName++ = '\0';
    }

    *pdwLen = NameLength;

    return(EncodedNameLength);

}

long
DecodeSigAlg(
    DWORD *         pAlgId,
    PBYTE           pbEncoded,
    DWORD           cEncoded,
    BOOL            WriteFlag)
{
    long    Result;
    DWORD   dwLen;
    long    index;

    index = DecodeHeader(  &dwLen, pbEncoded, cEncoded);
    if (index == -1)
    {
        return(-1);
    }


    Result = DecodeSigAlgid(   pAlgId,
                            pbEncoded+index,
                            cEncoded - index,
                            WriteFlag );

    if (Result == -1)
    {
        return(-1);
    }
    index += Result;


    Result = DecodeNull(pbEncoded + index, cEncoded - index);
    if (Result == -1)
    {
        return(-1);
    }

    return(index + Result);
}

long
DecodeCryptAlg(
    DWORD *         pAlgId,
    DWORD *         pHashid,
    PBYTE           pbEncoded,
    DWORD           cEncoded,
    BOOL            WriteFlag)
{
    long    Result;
    DWORD   dwLen;
    long    index;

    index = DecodeHeader(  &dwLen, pbEncoded, cEncoded);
    if (index == -1)
    {
        return(-1);
    }


    Result = DecodeCryptAlgid(pAlgId, pHashid,
                            pbEncoded+index,
                            cEncoded - index,
                            WriteFlag );

    if (Result == -1)
    {
        return(-1);
    }
    index += Result;


    Result = DecodeNull(pbEncoded + index, cEncoded - index);
    if (Result == -1)
    {
        return(-1);
    }

    return(index + Result);
}

long
DecodeKeyType(
    DWORD *         pKeyType,
    PBYTE           pbEncoded,
    DWORD           cEncoded,
    BOOL            WriteFlag)
{
    long    Result;
    DWORD   dwLen;
    long    index;

    index = DecodeHeader(  &dwLen, pbEncoded, cEncoded);
    if (index == -1)
    {
        return(-1);
    }


    Result = DecodeKeyExchAlgid(pKeyType,
                            pbEncoded+index,
                            cEncoded - index,
                            WriteFlag );

    if (Result == -1)
    {
        return(-1);
    }
    index += Result;


    Result = DecodeNull(pbEncoded + index, cEncoded - index);
    if (Result == -1)
    {
        return(-1);
    }

    return(index + Result);
}

//
// Decode optional extensions in the certificate
// These have the form:
// SEQUENCE {   extnId OBJECT IDENTIFIER,
//              critical BOOLEAN DEFAULT FALSE,
//              extnValue OCTETSTRING }
//

long
DecodeExtension(
    CertExtension*         pCertExt,
    PBYTE           pbEncoded,
    DWORD           cEncoded
    )
{
    DWORD dwLength;
    int cbHdr;
    if (cEncoded < 2)
        return -1;

    // skip the SEQ hdr
    cbHdr = DecodeHeader(&dwLength, pbEncoded, cEncoded);

    if (cbHdr < 0 || cEncoded < cbHdr+dwLength)
        return -1;

    pbEncoded += cbHdr;
    cEncoded = dwLength;
    dwLength += cbHdr;    // dwLength saves the total length swallowed

    if (pbEncoded[0] != OBJECT_ID_TAG) {
        DebugLog((DEB_TRACE, "Invalid Tag, expected OBJECTID, got %d\n", pbEncoded[0]));
        return -1;
    }
    pbEncoded++;    // skip the tag byte
    cEncoded--;
    
    cbHdr = DecodeLength(&pCertExt->cbExtId, pbEncoded, cEncoded);

    if (cbHdr < 0)
        return -1;


    pCertExt->pExtId = pbEncoded + cbHdr;    // pExtId points to the encoded object id

    pbEncoded += cbHdr + pCertExt->cbExtId;    // skip the length and value bytes
    cEncoded -= cbHdr + pCertExt->cbExtId;

    // check for optional boolean
    pCertExt->fCritical = FALSE;        // default is "not critical"
    if (pbEncoded[0] == BOOLEAN_TAG && pbEncoded[1] == 1)
    {
        pCertExt->fCritical = pbEncoded[2];
        pbEncoded += 3;
        cEncoded -= 3;
    }
    // now get the octet string
    if (pbEncoded[0] != OCTET_STRING_TAG)
    {
        DebugLog((DEB_TRACE, "Invalid Tag, expected OCTETSTRING, got %d\n", pbEncoded[0]));
        return -1;
    }
    pbEncoded++;    // skip the tag byte
    cEncoded--;

    cbHdr = DecodeLength(&pCertExt->cbValue, pbEncoded, cEncoded);

    pCertExt->pbValue = pbEncoded + cbHdr;

    return dwLength;

}

// Decode the EnhancedKeyUsage extension ("2.5.29.37")
// This is a sequence of OBJECT IDs
// Returns a pointer to a EnhancedKeyUsage struct. The memory for the struct
// and the variable list OIDs and OID descriptors is allocated by this routine
//
long
DecodeEnhancedKeyUsage(EnhancedKeyUsage **ppeku, BYTE *pbEncoded, DWORD cEncoded)
{
    DWORD dwLength;
    PBYTE pUsageId;
    int cbUsageId, cUsageIds;
    ObjIdDesc *pObjIdDesc;
    int cbHdr = DecodeHeader(&dwLength, pbEncoded, cEncoded);
    *ppeku = NULL;
    if (cbHdr < 0 || cEncoded < cbHdr+dwLength)
        return -1;
    cEncoded = dwLength;
    pbEncoded += cbHdr;    // skip past SEQ OF Header
    pUsageId = pbEncoded;
    cbUsageId = cEncoded;
    cUsageIds = 0;
    while (cbUsageId > 0)
    {
        if (*pUsageId != OBJECT_ID_TAG)
        {
            DebugLog((DEB_TRACE, "Invalid Tag, expected OBJECTID, got %d\n", *pUsageId));
            return -1;
        }
        cbHdr = DecodeLength(&dwLength, pUsageId+1, cbUsageId);
        if (cbHdr < 0)
            return -1;
        cbUsageId -= cbHdr+1+dwLength;
        pUsageId += cbHdr+1+dwLength;
        ++cUsageIds;
    }

    // allocate memory for objid bytes and EnhancedKeyUsage structure
    // ( we are allocating a few more bytes than we need)
    *ppeku = SPExternalAlloc(sizeof(EnhancedKeyUsage)+ cUsageIds*sizeof(ObjIdDesc) + cEncoded);
    if (!*ppeku)
        return -1;

    // copy the encoded bytes to the end of the allocated memory
    pUsageId = (PBYTE)(*ppeku) + sizeof(EnhancedKeyUsage) + cUsageIds*sizeof(ObjIdDesc);
    CopyMemory(pUsageId, pbEncoded, cEncoded);
    // do one more pass, saving the pointers this time
    cbUsageId = cEncoded;
    pObjIdDesc = &(*ppeku)->aObjIds[0];
    (*ppeku)->cObjIds = cUsageIds;
    while (cbUsageId > 0)
    {
        cbHdr = DecodeLength(&dwLength, pUsageId+1, cbUsageId);
        pObjIdDesc->pbObjId = pUsageId+cbHdr+1;
        pObjIdDesc->cbObjId = dwLength;
        cbUsageId -= cbHdr+1+dwLength;
        
        pUsageId += cbHdr+1+dwLength;
        ++pObjIdDesc;
    }
    return cUsageIds;
}

long
DecryptOctetString(
    DWORD * pdwLen,
    BYTE *  pbEncoded,
    DWORD   cEncoded,
    BOOL    Writeflag,
    PSTR    pszPassword)

{

    long    index, Result;
    CipherSpec CryptId;
    HashSpec  HashId;
    SPBuffer Input, Output;
    const CryptoSystem *pCipher;
    const CheckSumFunction *pHash;

    if(cEncoded < 1)
    {
        return(SP_LOG_RESULT(-1));
    }
    /* Figure out what crypto alg and pasword has we are using. */
    index = DecodeCryptAlg( &CryptId, &HashId, pbEncoded, cEncoded, TRUE );
    if (index == -1)
    {
        return(-1);
    }

    pCipher = CipherFromSpec(CryptId, SP_PROT_CRED);
    if(pCipher == NULL)
    {
        return(SP_LOG_RESULT(-1));
    }

    pHash = HashFromSpec(HashId, SP_PROT_CRED);
    if(pHash == NULL)
    {
        return(SP_LOG_RESULT(-1));
    }

    if (*(pbEncoded + index) != OCTET_STRING_TAG)
    {
        return ( -1 );
    }

    index++;
    /* determine how long the string is */
    if ((Result = DecodeLength (pdwLen, pbEncoded + index, cEncoded-index)) == -1)
    if (Result == -1)
    {
        return(-1);
    }

    index += Result;

    if(cEncoded < (index + *pdwLen))
    {
        return(SP_LOG_RESULT(-1));
    }

    if (Writeflag)
    {
        HashBuf SumBuff, Buff;
        PStateBuffer pState;
        PCheckSumBuffer  Sum = (PCheckSumBuffer)SumBuff;
        pHash->Initialize(Sum,0);
        pHash->Sum(Sum, strlen(pszPassword), (PUCHAR)pszPassword);
        pHash->Finalize(Sum,  Buff);

        Input.pvBuffer = Output.pvBuffer = pbEncoded+index;
        Input.cbBuffer = Output.cbBuffer = *pdwLen;
        Input.cbData = Output.cbData = *pdwLen;

        pCipher->Initialize(Buff, pHash->cbCheckSum, &pState);
        pCipher->Decrypt(pState, &Input, &Output);
        pCipher->Discard(&pState);
    }

    return (index);
}



long
DecodePrivateKeyFile(
    PctPrivateKey     * *   ppKey,
    PBYTE               pbEncoded,
    DWORD               cEncoded,
    PSTR                Password )
{
    DWORD           dwLen;
    long            Result;
    long            index;
    DWORD           KeyId;
    DWORD           Version;
    const KeyExchangeSystem *pSys = NULL;

    index = 0;

    SP_BEGIN("DecodePrivateKeyFile");


    Result = DecodeHeader( &dwLen, pbEncoded , cEncoded);
    if (Result == -1)
    {
        SP_RETURN(-1);
    }
    index += Result;

    Result = DecodeOctetString( NULL, &dwLen, pbEncoded+ index, cEncoded-index, FALSE );
    if (Result == -1)
    {
        SP_RETURN(-1);
    }
    index += Result;

    Result = DecodeHeader( &dwLen, pbEncoded +index, cEncoded-index);
    if (Result == -1)
    {
        SP_RETURN(-1);
    }
    index += Result;



    /* Now, the next item should be an octet string, which is encrypted */
    /* with the password above.  So, we need to skip into it, decrypt it, */
    /* then treat it as a constructed type: */


    Result = DecryptOctetString(&dwLen,
                                pbEncoded+index,
                                cEncoded-index,
                                TRUE,
                                Password);

    if (Result == -1)
    {
        SP_RETURN(-1);
    }




    index += Result;


    /* The moment of truth */


    Result = DecodeHeader( &dwLen, pbEncoded+index, cEncoded-index );
    if (Result == -1)
    {
        SP_RETURN(-1);
    }
    index += Result;

    Version = 0;

    Result = DecodeInteger( (PUCHAR) &Version, sizeof(Version), &dwLen, pbEncoded+index, cEncoded-index, FALSE );

    if ((Result < 0) || ( dwLen > 4 ) )
    {
        SP_RETURN(SP_LOG_RESULT(-1));
    }

    Result = DecodeInteger( (PUCHAR) &Version, sizeof(Version), &dwLen, pbEncoded+index, cEncoded-index, TRUE );
    if (Result == -1 || Version != 0)
    {
        SP_RETURN(SP_LOG_RESULT(-1));
    }

    index += Result;

    Result = DecodeKeyType( &KeyId, pbEncoded+index, cEncoded-index, TRUE );

    if (Result == -1)
    {
        SP_RETURN(-1);
    }

    index += Result;


    /* This is now the serialized rsa key. */


    if (*(pbEncoded+index) != OCTET_STRING_TAG)
    {
        SP_RETURN(SP_LOG_RESULT(-1));
    }

    index ++;

    Result = DecodeLength( &dwLen, pbEncoded+index, cEncoded-index );

    if (Result == -1)
    {
        SP_RETURN(-1);
    }

    if(index + dwLen > cEncoded)
    {
        SP_RETURN(SP_LOG_RESULT(-1));
    }

    index += Result;

    /* The sequence is the key... */

    pSys = KeyExchangeFromSpec(KeyId, SP_PROT_CRED   );
    if(pSys == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(-1));
    }
    Result = pSys->DecodePrivate(pbEncoded+index, cEncoded-index, ppKey);
    if(Result < 0)
    {
        return Result;
    }
    index += Result;
    SP_RETURN(index);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\hack.c ===
//
// SHolden - need lstrcmpiA.
//


#include <tchar.h>

int __cdecl stricmp (const char *str1, const char *str2)
{
    for (;(*str1 != '\0') && (*str2 != '\0'); str1++, str2++) {
        if (_totupper(*str1) != _totupper(*str2)) {
            return *str1 - *str2;
        }
    }
    // Check last character.
    return *str1 - *str2;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\hashsha.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------
* RSA Public Key Cryptosystem, RC4, MD2, MD5 and RSA are trademarks
* of RSA Data Security, Inc.
*----------------------------------------------------------------------------*/

#include <spbase.h>
#ifdef __cplusplus
extern "C" {
#endif

#include <sha.h>

#ifdef __cplusplus
}
#endif


BOOL
WINAPI
shaInitialize(  PCheckSumBuffer pBuffer,
                ULONG               dwSeed);

BOOL
WINAPI
shaSum( PCheckSumBuffer     pcsBuffer,
        ULONG               cbData,
        PUCHAR               pbData);

BOOL
WINAPI
shaFinalize(    PCheckSumBuffer pcsBuffer,
                PUCHAR           pbSum);


const CheckSumFunction    ckSHA = {
    CALG_SHA,
    A_SHA_DIGEST_LEN,
    sizeof(A_SHA_CTX),
    "SHA",
    shaInitialize,
    shaSum,
    shaFinalize,
    };

BOOL
WINAPI
shaInitialize(PCheckSumBuffer     pBuffer,
              DWORD               Flags)

{
    if (!pBuffer)
    {
        return( FALSE );
    }

    A_SHAInit((A_SHA_CTX *)pBuffer);
    return( TRUE );
}

BOOL
WINAPI
shaSum( PCheckSumBuffer     pcsBuffer,
        ULONG               cbData,
        PUCHAR               pbData)
{

    A_SHAUpdate((A_SHA_CTX *) pcsBuffer, pbData, cbData);
    return( TRUE );
}


BOOL
WINAPI
shaFinalize(    PCheckSumBuffer pcsBuffer,
                PUCHAR           pbSum)
{
    A_SHAFinal((A_SHA_CTX *) pcsBuffer, pbSum);
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\encode.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology 
* reference implementation, version 1.0
* 
* The Private Communication Technology reference implementation, version 1.0 
* ("PCTRef"), is being provided by Microsoft to encourage the development and 
* enhancement of an open standard for secure general-purpose business and 
* personal communications on open networks.  Microsoft is distributing PCTRef 
* at no charge irrespective of whether you use PCTRef for non-commercial or 
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without 
* warranty of any kind, either express or implied, including, without 
* limitation, the implied warranties or merchantability, fitness for a 
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out 
* of use or performance of PCTRef remains with you.
* 
* Please see the file LICENSE.txt, 
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
* 
* Please see http://pct.microsoft.com/pct/pct.htm for The Private 
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/ 


#ifndef _ENCODE_H_
#define _ENCODE_H_

/* tag definitions for ASN.1 encoding decoding */
#define BOOLEAN_TAG             0x01
#define INTEGER_TAG             0x02
#define CHAR_STRING_TAG         0x16
#define OCTET_STRING_TAG        0x04
#define BIT_STRING_TAG          0x03
#define UTCTIME_TAG             0x17
#define SEQUENCE_TAG            0x30
#define SET_OF_TAG              0x11
#define OBJECT_ID_TAG           0x06
#define NULL_TAG                0x05
#define PRINTABLE_STRING_TAG    0x13
#define TELETEX_STRING_TAG      0x14
#define ATTRIBUTE_TAG           0xa0

/* definitions of maximum lengths needed for the ASN.1 encoded
   form of some of the common fields in a certificate */
#define MAXVALIDITYLEN          0x24
#define MAXKEYINFOLEN           0x50
#define MAXALGIDLEN             0x0A
#define MAXOBJIDLEN             0x0A
#define MAXNAMEVALUELEN         0x40
#define UTCTIMELEN              0x0F
#define MAXPUBKEYDATALEN        0x30
#define VERSIONLEN              0x03
#define MAXENCODEDSIGLEN        0x30
#define MAXHEADERLEN            0x08
#define MINHEADERLEN            0x03
#define MAXTIMELEN              0x20
#define MAXNAMELEN              0x60

/* definitions for scrubbing memory */
#define ALLBITSOFF              0x00
#define ALLBITSON               0xFF

/* prototypes for the functions in encode.c */
long EncodeLength(BYTE *pbEncoded, DWORD dwLen, BOOL Writeflag);
long EncodeAlgid(BYTE *pbEncoded, DWORD Algid, BOOL Writeflag);
long EncodeInteger(BYTE *pbEncoded, BYTE *pbInt, DWORD dwLen, BOOL Writeflag);
long EncodeString(BYTE *pbEncoded, BYTE *pbStr, DWORD dwLen, BOOL Writeflag);
long EncodeOctetString(BYTE *pbEncoded, BYTE *pbStr, DWORD dwLen, BOOL Writeflag);
long EncodeBitString(BYTE *pbEncoded, BYTE *pbStr, DWORD dwLen, BOOL Writeflag);
//long EncodeUTCTime(BYTE *pbEncoded, time_t Time, BOOL Writeflag);
long EncodeHeader(BYTE *pbEncoded, DWORD dwLen, BOOL Writeflag);
long EncodeSetOfHeader(BYTE *pbEncoded, DWORD dwLen, BOOL Writeflag);
long EncodeAttributeHeader(BYTE *pbEncoded, DWORD dwLen, BOOL Writeflag);
long EncodeName(BYTE *pbEncoded, BYTE *pbName, DWORD dwLen, BOOL Writeflag);


long DecodeLength(DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded);
long DecodeAlgid(DWORD *pAlgid, BYTE *pbEncoded, DWORD cEncoded, BOOL Writeflag);
long DecodeHeader(DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded);
long DecodeSetOfHeader(DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded);
long DecodeInteger(BYTE *pbInt, DWORD cbBuff, DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded, BOOL Writeflag);
long DecodeString(BYTE *pbStr, DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded,BOOL Writeflag);
long DecodeOctetString(BYTE *pbStr, DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded, BOOL Writeflag);
long DecodeBitString(BYTE *pbStr, DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded, BOOL Writeflag);
long DecodeName(BYTE *pbName, DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded, BOOL Writeflag);

// describes a x509 certificate extension
typedef struct 
{
    BYTE *pExtId;   // encode object id (excluding header)
    UINT cbExtId;   // size of object id
    BOOL fCritical;
    BYTE *pbValue;  // points to octet string value
    UINT cbValue;   // size of octet string value
} CertExtension;
long DecodeExtension(CertExtension *pCertExt, BYTE *pbEncoded, DWORD cEncoded);
long DecodeEnhancedKeyUsage(EnhancedKeyUsage **, BYTE *pbEncoded, DWORD cEncoded);

long
EncodeAlgorithm(
    BYTE *  pbEncoded,
    DWORD   AlgId,
    BOOL    WriteFlag);

#define ALGTYPE_SIG_RSA_MD5      0x01
#define ALGTYPE_KEYEXCH_RSA_MD5  0x02
#define ALGTYPE_CIPHER_RC4_MD5   0x03



long
EncodeDN(
    BYTE *  pbEncoded,
    PSTR    pszDN,
    BOOL    WriteFlag);


#ifndef SECURITY_LINUX
long
EncodeFileTime(
    BYTE *      pbEncoded,
    FILETIME    Time,
    BOOL        UTC,
    BOOL        WriteFlag);
#else /* SECURITY_LINUX */
long EncodeUTCTime(BYTE *pbEncoded, time_t Time, BOOL Writeflag);
#endif /* SECURITY_LINUX */

#ifndef SECURITY_LINUX
long
DecodeFileTime(
    FILETIME *  pTime,
    BYTE *      pbEncoded,
    DWORD       cEncoded,
    BOOL        WriteFlag);
#else /* SECURITY_LINUX */
long DecodeUTCTime(time_t *pTime, BYTE *pbEncoded, DWORD cEncoded, BOOL Writeflag);

#define DecodeFileTime DecodeUTCTime
#endif /* SECURITY_LINUX */

long
DecodeNull(
    BYTE *  pbEncoded, DWORD cEncoded);

long
DecodeDN(
    PSTR    pName,
    DWORD * pdwLen,
    BYTE *  pbEncoded,
    DWORD   cEncoded,
    BOOL    WriteFlag);

long
DecodeSigAlg(
    DWORD *         pAlgId,
    PBYTE           pbEncoded,
    DWORD           cEncoded,
    BOOL            WriteFlag);

long
DecodeCryptAlg(
    DWORD *         pAlgId,
    DWORD *         pHashid,
    PBYTE           pbEncoded,
    DWORD           cEncoded,
    BOOL            WriteFlag);

long
DecodeKeyType(
    DWORD *         pKeyType,
    PBYTE           pbEncoded,
    DWORD           cEncoded,
    BOOL            WriteFlag);

long
DecodePrivateKeyFile(
    PctPrivateKey  **   ppKey,
    PBYTE               pbEncoded,
    DWORD               cbEncoded,
    PSTR                Password );


#endif  /* _ENCODE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\hashmd5.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------
* RSA Public Key Cryptosystem, RC4, MD2, MD5 and RSA are trademarks
* of RSA Data Security, Inc.
*----------------------------------------------------------------------------*/

#include <spbase.h>
#ifdef __cplusplus
extern "C" {
#endif

#include <md5.h>

#ifdef __cplusplus
}
#endif


BOOL
WINAPI
md5Initialize(  PCheckSumBuffer pBuffer,
                ULONG               dwSeed);

BOOL
WINAPI
md5Sum( PCheckSumBuffer     pcsBuffer,
        ULONG               cbData,
        PUCHAR               pbData);

BOOL
WINAPI
md5Finalize(    PCheckSumBuffer pcsBuffer,
                PUCHAR           pbSum);


const CheckSumFunction    ckMD5 = {
    CALG_MD5,
    16,
    sizeof(MD5_CTX),
    "MD5",
    md5Initialize,
    md5Sum,
    md5Finalize,
    };

BOOL
WINAPI
md5Initialize(PCheckSumBuffer     pBuffer,
              DWORD               Flags)

{
    if (!pBuffer)
    {
        return( FALSE );
    }

    MD5Init((MD5_CTX *)pBuffer);
    return( TRUE );
}

BOOL
WINAPI
md5Sum( PCheckSumBuffer     pcsBuffer,
        ULONG               cbData,
        PUCHAR               pbData)
{

    MD5Update((MD5_CTX *) pcsBuffer, pbData, cbData);
    return( TRUE );
}


BOOL
WINAPI
md5Finalize(    PCheckSumBuffer pcsBuffer,
                PUCHAR           pbSum)
{
    MD5Final((MD5_CTX *) pcsBuffer);
	CopyMemory(pbSum, ((MD5_CTX *)pcsBuffer)->digest, 16);
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\keyexch.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/

#ifndef __KEYEXCH_H__
#define __KEYEXCH_H__




typedef struct _PctPrivateKey
{
    DWORD Type;
    DWORD cbKey;
    UCHAR pKey[1];
} PctPrivateKey, *PPctPrivateKey;


typedef
long
(WINAPI * KeyExchangeDecodePubFn)(
    PUCHAR          pbEncoded,
    DWORD           cbKey,
    PctPublicKey   **ppKey);

typedef
long
(WINAPI * KeyExchangeDecodePrvFn)(
    PUCHAR          pbEncoded,
    DWORD           cbKey,
    PctPrivateKey   **ppKey);

typedef
BOOL
(WINAPI * KeyExchangeEncryptFn)(
    PUCHAR          pbClean,
    DWORD           cbClean,
    PUCHAR          pbEncrypted,
    DWORD           *pcbEncrypted,
    PctPublicKey    *pKey,
    DWORD           fProtocol);

typedef
BOOL
(WINAPI * KeyExchangeDecryptFn)(
    PUCHAR          pbEncrypted,
    DWORD           cbEncrypted,
    PUCHAR          pbClean,
    DWORD           *pcbClean,
    PctPrivateKey   *pKey,
    DWORD           fProtocol);



typedef struct _KeyExchangeSystem {
    DWORD               Type;
    PSTR            pszName;
    KeyExchangeDecodePubFn DecodePublic;
    KeyExchangeDecodePrvFn DecodePrivate;
    KeyExchangeEncryptFn Encrypt;
    KeyExchangeDecryptFn Decrypt;
} KeyExchangeSystem, * PKeyExchangeSystem;



typedef struct kexchtoalg {
    ALG_ID  idAlg;
    KeyExchangeSystem *System;
} AlgToExch;

extern AlgToExch g_AlgToExchMapping[];
extern int g_iAlgToExchMappings;


/*
 * instantiations of systems
 */

extern const KeyExchangeSystem keyexchPKCS;

#endif /* __KEYEXCH_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\keys.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/


#include <spbase.h>
#include <defkeys.h>

static SP_STATUS
LoadRegKeys(
    LPDWORD lpiTrustedCAs,
    DWORD   cSubkeys
    );

static SP_STATUS
LoadKnownKeys(
    LPDWORD lpiTrustedCAs
    );

static BOOL
DeleteCACache();

//Didn't want to include whole bunch of include files ...
#define LSBOF(x)    ((UCHAR) (x & 0xFF))
#define MSBOF(x)    ((UCHAR) ((x >> 8) & 0xFF) )

#define PRIVATE_KEY_TEXT    "private-key"

#ifndef XBOX

extern CRITICAL_SECTION csSsl;
#if DBG
extern  DWORD   csSslOwner;
#define LockSsl(x)  EnterCriticalSection(&csSsl); csSslOwner = x
#define UnlockSsl() csSslOwner = 0; LeaveCriticalSection(&csSsl)
#else
#define LockSsl(x)  EnterCriticalSection(&csSsl)
#define UnlockSsl() LeaveCriticalSection(&csSsl)
#endif

#endif

#define SSL_INIT_CIPHER_CACHE   1
#define SSL_ADD_KEY_TO_CA_LIST  2
#define SSL_FIND_ISSUER         3


//
// SHolden -- hack hack hack...this defined in sspi\hack.c. When we build
// schannel.dll it will link properly.
//

int __cdecl stricmp(const char *, const char *);
#define lstrcmpiA stricmp

//
// TODO: this is the ntdev Certificate. Need to change this before we ship
//
BYTE g_RootCert[] = {
    0x30, 0x82, 0x03, 0xc9, 0x30, 0x82, 0x03, 0x32, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10, 0x0a,
    0x68, 0x8c, 0x6e, 0xc9, 0xb7, 0xf5, 0xb8, 0x4f, 0x09, 0x12, 0x96, 0x6d, 0xbf, 0x50, 0x9d, 0x30,
    0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x81,
    0x8a, 0x31, 0x17, 0x30, 0x15, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x09, 0x01,
    0x16, 0x08, 0x74, 0x6f, 0x6e, 0x79, 0x63, 0x68, 0x65, 0x6e, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03,
    0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08,
    0x13, 0x0a, 0x57, 0x61, 0x73, 0x68, 0x69, 0x6e, 0x67, 0x74, 0x6f, 0x6e, 0x31, 0x10, 0x30, 0x0e,
    0x06, 0x03, 0x55, 0x04, 0x07, 0x13, 0x07, 0x52, 0x65, 0x64, 0x6d, 0x6f, 0x6e, 0x64, 0x31, 0x0b,
    0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x02, 0x4d, 0x53, 0x31, 0x0d, 0x30, 0x0b, 0x06,
    0x03, 0x55, 0x04, 0x0b, 0x13, 0x04, 0x58, 0x62, 0x6f, 0x78, 0x31, 0x1f, 0x30, 0x1d, 0x06, 0x03,
    0x55, 0x04, 0x03, 0x13, 0x16, 0x54, 0x6f, 0x6e, 0x79, 0x20, 0x43, 0x68, 0x65, 0x6e, 0x20, 0x54,
    0x65, 0x73, 0x74, 0x20, 0x43, 0x41, 0x20, 0x52, 0x6f, 0x6f, 0x74, 0x30, 0x1e, 0x17, 0x0d, 0x30,
    0x30, 0x31, 0x30, 0x32, 0x37, 0x31, 0x36, 0x33, 0x34, 0x32, 0x35, 0x5a, 0x17, 0x0d, 0x30, 0x32,
    0x31, 0x30, 0x32, 0x37, 0x31, 0x36, 0x34, 0x32, 0x34, 0x33, 0x5a, 0x30, 0x81, 0x8a, 0x31, 0x17,
    0x30, 0x15, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x09, 0x01, 0x16, 0x08, 0x74,
    0x6f, 0x6e, 0x79, 0x63, 0x68, 0x65, 0x6e, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,
    0x13, 0x02, 0x55, 0x53, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x57,
    0x61, 0x73, 0x68, 0x69, 0x6e, 0x67, 0x74, 0x6f, 0x6e, 0x31, 0x10, 0x30, 0x0e, 0x06, 0x03, 0x55,
    0x04, 0x07, 0x13, 0x07, 0x52, 0x65, 0x64, 0x6d, 0x6f, 0x6e, 0x64, 0x31, 0x0b, 0x30, 0x09, 0x06,
    0x03, 0x55, 0x04, 0x0a, 0x13, 0x02, 0x4d, 0x53, 0x31, 0x0d, 0x30, 0x0b, 0x06, 0x03, 0x55, 0x04,
    0x0b, 0x13, 0x04, 0x58, 0x62, 0x6f, 0x78, 0x31, 0x1f, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x04, 0x03,
    0x13, 0x16, 0x54, 0x6f, 0x6e, 0x79, 0x20, 0x43, 0x68, 0x65, 0x6e, 0x20, 0x54, 0x65, 0x73, 0x74,
    0x20, 0x43, 0x41, 0x20, 0x52, 0x6f, 0x6f, 0x74, 0x30, 0x81, 0x9f, 0x30, 0x0d, 0x06, 0x09, 0x2a,
    0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 0x8d, 0x00, 0x30, 0x81,
    0x89, 0x02, 0x81, 0x81, 0x00, 0xa7, 0x21, 0xc7, 0x4d, 0x92, 0x1e, 0xef, 0x48, 0xb5, 0x73, 0xbf,
    0x9f, 0x55, 0xcd, 0x67, 0xdd, 0x12, 0xef, 0xe2, 0xe8, 0x71, 0x44, 0x64, 0x16, 0x5d, 0xd8, 0x05,
    0x61, 0xde, 0xf6, 0x4a, 0x22, 0x81, 0x9a, 0xf9, 0x1f, 0x97, 0x37, 0xe1, 0xe1, 0x42, 0x25, 0x69,
    0x15, 0xd4, 0x33, 0x76, 0xd4, 0xc8, 0x68, 0x4a, 0x18, 0xdc, 0x1c, 0x89, 0x82, 0xc3, 0x2e, 0x67,
    0x26, 0xa1, 0xb1, 0xa9, 0x4f, 0x02, 0x3d, 0x06, 0x15, 0xf2, 0x4f, 0xc7, 0xdf, 0x84, 0xeb, 0xce,
    0x78, 0x12, 0x66, 0x5a, 0xac, 0xe2, 0xde, 0xea, 0xfd, 0x23, 0x74, 0x92, 0x20, 0x97, 0x41, 0xc1,
    0x90, 0x09, 0x50, 0x6c, 0x4e, 0x89, 0x38, 0x55, 0xea, 0x37, 0x50, 0x66, 0x42, 0xfd, 0xa5, 0xf6,
    0xc6, 0x5a, 0xbb, 0x31, 0x77, 0xf0, 0x10, 0x14, 0x93, 0x5f, 0x7c, 0xb5, 0xef, 0x46, 0x6e, 0x06,
    0xb5, 0x57, 0x4c, 0xcd, 0x45, 0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x82, 0x01, 0x2c, 0x30, 0x82,
    0x01, 0x28, 0x30, 0x13, 0x06, 0x09, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x14, 0x02, 0x04,
    0x06, 0x1e, 0x04, 0x00, 0x43, 0x00, 0x41, 0x30, 0x0b, 0x06, 0x03, 0x55, 0x1d, 0x0f, 0x04, 0x04,
    0x03, 0x02, 0x01, 0x46, 0x30, 0x0f, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x01, 0x01, 0xff, 0x04, 0x05,
    0x30, 0x03, 0x01, 0x01, 0xff, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14,
    0xad, 0x61, 0x48, 0x60, 0x2d, 0xfe, 0x31, 0xa3, 0xfa, 0x51, 0x88, 0x9b, 0xc4, 0x38, 0x9b, 0xa1,
    0x07, 0xde, 0xd7, 0xe6, 0x30, 0x81, 0xc1, 0x06, 0x03, 0x55, 0x1d, 0x1f, 0x04, 0x81, 0xb9, 0x30,
    0x81, 0xb6, 0x30, 0x58, 0xa0, 0x56, 0xa0, 0x54, 0x86, 0x52, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f,
    0x2f, 0x74, 0x6f, 0x6e, 0x79, 0x63, 0x68, 0x65, 0x6e, 0x32, 0x2e, 0x6e, 0x74, 0x64, 0x65, 0x76,
    0x2e, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x43,
    0x65, 0x72, 0x74, 0x45, 0x6e, 0x72, 0x6f, 0x6c, 0x6c, 0x2f, 0x54, 0x6f, 0x6e, 0x79, 0x25, 0x32,
    0x30, 0x43, 0x68, 0x65, 0x6e, 0x25, 0x32, 0x30, 0x54, 0x65, 0x73, 0x74, 0x25, 0x32, 0x30, 0x43,
    0x41, 0x25, 0x32, 0x30, 0x52, 0x6f, 0x6f, 0x74, 0x2e, 0x63, 0x72, 0x6c, 0x30, 0x5a, 0xa0, 0x58,
    0xa0, 0x56, 0x86, 0x54, 0x66, 0x69, 0x6c, 0x65, 0x3a, 0x2f, 0x2f, 0x5c, 0x5c, 0x74, 0x6f, 0x6e,
    0x79, 0x63, 0x68, 0x65, 0x6e, 0x32, 0x2e, 0x6e, 0x74, 0x64, 0x65, 0x76, 0x2e, 0x6d, 0x69, 0x63,
    0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x5c, 0x43, 0x65, 0x72, 0x74, 0x45,
    0x6e, 0x72, 0x6f, 0x6c, 0x6c, 0x5c, 0x54, 0x6f, 0x6e, 0x79, 0x25, 0x32, 0x30, 0x43, 0x68, 0x65,
    0x6e, 0x25, 0x32, 0x30, 0x54, 0x65, 0x73, 0x74, 0x25, 0x32, 0x30, 0x43, 0x41, 0x25, 0x32, 0x30,
    0x52, 0x6f, 0x6f, 0x74, 0x2e, 0x63, 0x72, 0x6c, 0x30, 0x10, 0x06, 0x09, 0x2b, 0x06, 0x01, 0x04,
    0x01, 0x82, 0x37, 0x15, 0x01, 0x04, 0x03, 0x02, 0x01, 0x00, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86,
    0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x81, 0x81, 0x00, 0x34, 0xe6, 0x4b,
    0x82, 0xcb, 0xb6, 0x72, 0xf5, 0xc5, 0x61, 0x7a, 0xd5, 0x79, 0x48, 0x7a, 0xb2, 0xfe, 0x27, 0x37,
    0x9f, 0x28, 0x80, 0x65, 0x69, 0x6d, 0xf4, 0xc2, 0xba, 0x1e, 0x65, 0xf0, 0x75, 0x58, 0xd6, 0xf7,
    0x48, 0xaf, 0x15, 0xa5, 0xa5, 0x97, 0x32, 0x68, 0x49, 0x78, 0xfb, 0x15, 0x2f, 0x22, 0x42, 0x8f,
    0x3f, 0x4e, 0x35, 0x61, 0xa6, 0xd1, 0xc8, 0xc3, 0x61, 0xb4, 0x33, 0xf1, 0x48, 0xc9, 0x1e, 0xe0,
    0xbf, 0x1b, 0x99, 0xc5, 0x22, 0x1e, 0x1a, 0x4a, 0x2e, 0x9c, 0x99, 0x78, 0xd4, 0x9d, 0x4c, 0x18,
    0x5d, 0x3e, 0xcb, 0xeb, 0x7f, 0xf3, 0xe2, 0x6d, 0x79, 0x19, 0x96, 0xe7, 0xf2, 0x09, 0x54, 0xc6,
    0x44, 0x47, 0x3d, 0xc7, 0x96, 0x8f, 0xba, 0xea, 0xaf, 0xac, 0x6d, 0xda, 0x47, 0xbe, 0x01, 0xf3,
    0x9a, 0x60, 0x78, 0xdf, 0x0d, 0x50, 0x4f, 0x42, 0xdf, 0x14, 0x1d, 0xe2, 0x95
/*
// ntdev 4
	0x30, 0x82, 0x05, 0x2f, 0x30, 0x82, 0x04, 0xef, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x0a, 0x61,
	0x73, 0x07, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x30, 0x09, 0x06, 0x07, 0x2a, 0x86, 0x48,
	0xce, 0x38, 0x04, 0x03, 0x30, 0x61, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13,
	0x02, 0x55, 0x53, 0x31, 0x12, 0x30, 0x10, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x09, 0x4d, 0x69,
	0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x31, 0x0e, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x04, 0x0b,
	0x13, 0x05, 0x4e, 0x74, 0x64, 0x65, 0x76, 0x31, 0x2e, 0x30, 0x2c, 0x06, 0x03, 0x55, 0x04, 0x03,
	0x13, 0x25, 0x4e, 0x54, 0x44, 0x45, 0x56, 0x20, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6d, 0x65, 0x64,
	0x69, 0x61, 0x74, 0x65, 0x20, 0x53, 0x75, 0x62, 0x6f, 0x72, 0x64, 0x69, 0x6e, 0x61, 0x74, 0x65,
	0x20, 0x57, 0x68, 0x69, 0x63, 0x61, 0x32, 0x30, 0x1e, 0x17, 0x0d, 0x30, 0x30, 0x30, 0x39, 0x32,
	0x35, 0x32, 0x33, 0x33, 0x30, 0x35, 0x32, 0x5a, 0x17, 0x0d, 0x30, 0x31, 0x30, 0x39, 0x32, 0x35,
	0x32, 0x33, 0x33, 0x34, 0x31, 0x36, 0x5a, 0x30, 0x4b, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55,
	0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x12, 0x30, 0x10, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13,
	0x09, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x31, 0x0e, 0x30, 0x0c, 0x06, 0x03,
	0x55, 0x04, 0x0b, 0x13, 0x05, 0x4e, 0x74, 0x64, 0x65, 0x76, 0x31, 0x18, 0x30, 0x16, 0x06, 0x03,
	0x55, 0x04, 0x03, 0x13, 0x0f, 0x4e, 0x54, 0x44, 0x45, 0x56, 0x20, 0x49, 0x73, 0x73, 0x75, 0x65,
	0x34, 0x20, 0x43, 0x41, 0x30, 0x81, 0x9f, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,
	0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 0x8d, 0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81,
	0x00, 0xd8, 0x76, 0xd7, 0x9b, 0x84, 0x30, 0xa2, 0xdc, 0x16, 0x4d, 0xe1, 0xe5, 0xdf, 0xf1, 0x3b,
	0x11, 0x5e, 0x9e, 0xf5, 0xd4, 0x16, 0x73, 0x67, 0xc3, 0x8b, 0x44, 0x1f, 0xf9, 0xe7, 0xa3, 0x52,
	0x0a, 0xb4, 0x1e, 0x2a, 0x4a, 0x81, 0x16, 0x97, 0xb9, 0x72, 0x2f, 0xed, 0x3a, 0xa9, 0x3f, 0xac,
	0xd7, 0xe5, 0x1e, 0x98, 0xf5, 0x47, 0x1c, 0x16, 0x95, 0x3e, 0xa4, 0xb8, 0x21, 0xbf, 0xe1, 0xa7,
	0x01, 0xac, 0x70, 0x62, 0x77, 0xb1, 0xd8, 0x16, 0xba, 0xcf, 0x5b, 0x30, 0x6d, 0xff, 0x85, 0x89,
	0x12, 0x43, 0x66, 0xb9, 0x45, 0xb2, 0x82, 0xe8, 0x39, 0x03, 0xe6, 0x4d, 0x06, 0x7b, 0x5a, 0xd1,
	0x7a, 0x3f, 0x9f, 0xe7, 0x1a, 0x96, 0x97, 0x2f, 0x3d, 0xc8, 0x1d, 0xbd, 0x24, 0x00, 0x93, 0x07,
	0x79, 0x62, 0x00, 0xa6, 0x07, 0xdf, 0x8f, 0x52, 0x0c, 0xbf, 0x4f, 0x21, 0x49, 0x4f, 0x4c, 0x13,
	0x71, 0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x82, 0x03, 0x5d, 0x30, 0x82, 0x03, 0x59, 0x30, 0x10,
	0x06, 0x09, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x15, 0x01, 0x04, 0x03, 0x02, 0x01, 0x00,
	0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0x33, 0xa8, 0x66, 0x48, 0xbb,
	0x04, 0x1a, 0x7a, 0x93, 0x3a, 0x82, 0x4f, 0x15, 0xfa, 0xd0, 0x63, 0xc2, 0x12, 0xff, 0xb8, 0x30,
	0x19, 0x06, 0x09, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x14, 0x02, 0x04, 0x0c, 0x1e, 0x0a,
	0x00, 0x53, 0x00, 0x75, 0x00, 0x62, 0x00, 0x43, 0x00, 0x41, 0x30, 0x0b, 0x06, 0x03, 0x55, 0x1d,
	0x0f, 0x04, 0x04, 0x03, 0x02, 0x01, 0x46, 0x30, 0x0f, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x01, 0x01,
	0xff, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04,
	0x18, 0x30, 0x16, 0x80, 0x14, 0x79, 0x20, 0x8e, 0xde, 0xa4, 0xdf, 0x24, 0x57, 0x22, 0x82, 0xbe,
	0x6d, 0xce, 0x0b, 0x98, 0xfc, 0x14, 0xce, 0x41, 0x42, 0x30, 0x82, 0x01, 0x56, 0x06, 0x03, 0x55,
	0x1d, 0x1f, 0x04, 0x82, 0x01, 0x4d, 0x30, 0x82, 0x01, 0x49, 0x30, 0x82, 0x01, 0x45, 0xa0, 0x82,
	0x01, 0x41, 0xa0, 0x82, 0x01, 0x3d, 0x86, 0x5c, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77,
	0x68, 0x69, 0x63, 0x61, 0x32, 0x2e, 0x6e, 0x74, 0x64, 0x65, 0x76, 0x2e, 0x6d, 0x69, 0x63, 0x72,
	0x6f, 0x73, 0x6f, 0x66, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x43, 0x65, 0x72, 0x74, 0x45, 0x6e,
	0x72, 0x6f, 0x6c, 0x6c, 0x2f, 0x4e, 0x54, 0x44, 0x45, 0x56, 0x25, 0x32, 0x30, 0x49, 0x6e, 0x74,
	0x65, 0x72, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x74, 0x65, 0x25, 0x32, 0x30, 0x53, 0x75, 0x62, 0x6f,
	0x72, 0x64, 0x69, 0x6e, 0x61, 0x74, 0x65, 0x25, 0x32, 0x30, 0x57, 0x68, 0x69, 0x63, 0x61, 0x32,
	0x2e, 0x63, 0x72, 0x6c, 0x86, 0x81, 0xdc, 0x6c, 0x64, 0x61, 0x70, 0x3a, 0x2f, 0x2f, 0x2f, 0x43,
	0x4e, 0x3d, 0x4e, 0x54, 0x44, 0x45, 0x56, 0x25, 0x32, 0x30, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6d,
	0x65, 0x64, 0x69, 0x61, 0x74, 0x65, 0x25, 0x32, 0x30, 0x53, 0x75, 0x62, 0x6f, 0x72, 0x64, 0x69,
	0x6e, 0x61, 0x74, 0x65, 0x25, 0x32, 0x30, 0x57, 0x68, 0x69, 0x63, 0x61, 0x32, 0x2c, 0x43, 0x4e,
	0x3d, 0x77, 0x68, 0x69, 0x63, 0x61, 0x32, 0x2c, 0x43, 0x4e, 0x3d, 0x43, 0x44, 0x50, 0x2c, 0x43,
	0x4e, 0x3d, 0x50, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x25, 0x32, 0x30, 0x4b, 0x65, 0x79, 0x25, 0x32,
	0x30, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x2c, 0x43, 0x4e, 0x3d, 0x53, 0x65, 0x72,
	0x76, 0x69, 0x63, 0x65, 0x73, 0x2c, 0x43, 0x4e, 0x3d, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75,
	0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2c, 0x44, 0x43, 0x3d, 0x6e, 0x74, 0x64, 0x65, 0x76, 0x2c,
	0x44, 0x43, 0x3d, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x2c, 0x44, 0x43, 0x3d,
	0x63, 0x6f, 0x6d, 0x3f, 0x63, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x52,
	0x65, 0x76, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4c, 0x69, 0x73, 0x74, 0x3f, 0x62, 0x61,
	0x73, 0x65, 0x3f, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x63, 0x6c, 0x61, 0x73, 0x73, 0x3d, 0x63,
	0x52, 0x4c, 0x44, 0x69, 0x73, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x6f,
	0x69, 0x6e, 0x74, 0x30, 0x82, 0x01, 0x70, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01,
	0x01, 0x04, 0x82, 0x01, 0x62, 0x30, 0x82, 0x01, 0x5e, 0x30, 0x81, 0x83, 0x06, 0x08, 0x2b, 0x06,
	0x01, 0x05, 0x05, 0x07, 0x30, 0x02, 0x86, 0x77, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77,
	0x68, 0x69, 0x63, 0x61, 0x32, 0x2e, 0x6e, 0x74, 0x64, 0x65, 0x76, 0x2e, 0x6d, 0x69, 0x63, 0x72,
	0x6f, 0x73, 0x6f, 0x66, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x43, 0x65, 0x72, 0x74, 0x45, 0x6e,
	0x72, 0x6f, 0x6c, 0x6c, 0x2f, 0x77, 0x68, 0x69, 0x63, 0x61, 0x32, 0x2e, 0x6e, 0x74, 0x64, 0x65,
	0x76, 0x2e, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x5f,
	0x4e, 0x54, 0x44, 0x45, 0x56, 0x25, 0x32, 0x30, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6d, 0x65, 0x64,
	0x69, 0x61, 0x74, 0x65, 0x25, 0x32, 0x30, 0x53, 0x75, 0x62, 0x6f, 0x72, 0x64, 0x69, 0x6e, 0x61,
	0x74, 0x65, 0x25, 0x32, 0x30, 0x57, 0x68, 0x69, 0x63, 0x61, 0x32, 0x2e, 0x63, 0x72, 0x74, 0x30,
	0x81, 0xd5, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x02, 0x86, 0x81, 0xc8, 0x6c,
	0x64, 0x61, 0x70, 0x3a, 0x2f, 0x2f, 0x2f, 0x43, 0x4e, 0x3d, 0x4e, 0x54, 0x44, 0x45, 0x56, 0x25,
	0x32, 0x30, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x74, 0x65, 0x25, 0x32,
	0x30, 0x53, 0x75, 0x62, 0x6f, 0x72, 0x64, 0x69, 0x6e, 0x61, 0x74, 0x65, 0x25, 0x32, 0x30, 0x57,
	0x68, 0x69, 0x63, 0x61, 0x32, 0x2c, 0x43, 0x4e, 0x3d, 0x41, 0x49, 0x41, 0x2c, 0x43, 0x4e, 0x3d,
	0x50, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x25, 0x32, 0x30, 0x4b, 0x65, 0x79, 0x25, 0x32, 0x30, 0x53,
	0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x2c, 0x43, 0x4e, 0x3d, 0x53, 0x65, 0x72, 0x76, 0x69,
	0x63, 0x65, 0x73, 0x2c, 0x43, 0x4e, 0x3d, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x2c, 0x44, 0x43, 0x3d, 0x6e, 0x74, 0x64, 0x65, 0x76, 0x2c, 0x44, 0x43,
	0x3d, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x2c, 0x44, 0x43, 0x3d, 0x63, 0x6f,
	0x6d, 0x3f, 0x63, 0x41, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x3f,
	0x62, 0x61, 0x73, 0x65, 0x3f, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x63, 0x6c, 0x61, 0x73, 0x73,
	0x3d, 0x63, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x41, 0x75,
	0x74, 0x68, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x30, 0x09, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x38,
	0x04, 0x03, 0x03, 0x2f, 0x00, 0x30, 0x2c, 0x02, 0x14, 0x48, 0x07, 0xb8, 0x80, 0xce, 0x47, 0x7c,
	0xcf, 0xcd, 0xa0, 0xea, 0x8a, 0x33, 0x9f, 0x6a, 0xc5, 0xb6, 0x0d, 0xdc, 0x96, 0x02, 0x14, 0x78,
	0x35, 0xe3, 0x09, 0xac, 0x76, 0x8f, 0x2a, 0x06, 0x90, 0x79, 0xd1, 0xd8, 0x74, 0x44, 0xef, 0xef,
	0x8f, 0x0b, 0x45
*/
/*
// ntdev root
    0x30, 0x82, 0x03, 0x40, 0x30, 0x82, 0x02, 0xa9, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10, 0x21,
    0x25, 0x66, 0xf7, 0x5e, 0x75, 0x84, 0xb8, 0x47, 0x8f, 0x7b, 0x59, 0xb4, 0xa9, 0xe2, 0x12, 0x30,
    0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x4c,
    0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x12, 0x30,
    0x10, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x09, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66,
    0x74, 0x31, 0x0e, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x05, 0x4e, 0x74, 0x64, 0x65,
    0x76, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x10, 0x4e, 0x54, 0x44, 0x45,
    0x56, 0x20, 0x53, 0x41, 0x20, 0x52, 0x6f, 0x6f, 0x74, 0x20, 0x43, 0x41, 0x30, 0x1e, 0x17, 0x0d,
    0x30, 0x30, 0x30, 0x39, 0x32, 0x30, 0x32, 0x31, 0x32, 0x34, 0x34, 0x35, 0x5a, 0x17, 0x0d, 0x30,
    0x32, 0x30, 0x39, 0x32, 0x30, 0x32, 0x31, 0x33, 0x33, 0x32, 0x38, 0x5a, 0x30, 0x4c, 0x31, 0x0b,
    0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x12, 0x30, 0x10, 0x06,
    0x03, 0x55, 0x04, 0x0a, 0x13, 0x09, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x31,
    0x0e, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x05, 0x4e, 0x74, 0x64, 0x65, 0x76, 0x31,
    0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x10, 0x4e, 0x54, 0x44, 0x45, 0x56, 0x20,
    0x53, 0x41, 0x20, 0x52, 0x6f, 0x6f, 0x74, 0x20, 0x43, 0x41, 0x30, 0x81, 0x9f, 0x30, 0x0d, 0x06,
    0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 0x8d, 0x00,
    0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00, 0xc7, 0x29, 0xb7, 0x6c, 0x1b, 0x49, 0xf7, 0x77, 0xa9,
    0xf5, 0x83, 0x3d, 0x78, 0x5b, 0x6b, 0x25, 0x29, 0x85, 0x03, 0xc3, 0x46, 0xe8, 0xeb, 0x71, 0x4c,
    0xa4, 0x4b, 0x2f, 0x2a, 0x2b, 0x5c, 0xc6, 0x0d, 0x53, 0x32, 0xec, 0x76, 0x8c, 0xef, 0x19, 0x67,
    0x52, 0x67, 0x09, 0x73, 0x6e, 0xf0, 0x13, 0x6a, 0x4c, 0xeb, 0xce, 0xb8, 0xae, 0xaa, 0xae, 0xd0,
    0x81, 0xa0, 0x73, 0x26, 0xf4, 0xb4, 0x3a, 0xaf, 0x32, 0x03, 0x3b, 0x61, 0xa9, 0xfd, 0x23, 0x05,
    0x0c, 0xac, 0x1a, 0xf4, 0xc7, 0xd4, 0xb1, 0xe2, 0x7a, 0x8d, 0xdb, 0x98, 0x21, 0x45, 0x38, 0xe5,
    0x2d, 0x1a, 0xf7, 0xdd, 0x24, 0x66, 0xc4, 0x32, 0xf4, 0xdb, 0xf1, 0xc4, 0xf4, 0xcb, 0x10, 0x20,
    0x3c, 0x9e, 0xce, 0xaf, 0x45, 0x99, 0xb5, 0xae, 0xfb, 0x7f, 0xf0, 0x11, 0x50, 0xd5, 0x96, 0xbf,
    0xa8, 0x3b, 0x4c, 0xd5, 0x14, 0x85, 0xed, 0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x82, 0x01, 0x21,
    0x30, 0x82, 0x01, 0x1d, 0x30, 0x13, 0x06, 0x09, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x14,
    0x02, 0x04, 0x06, 0x1e, 0x04, 0x00, 0x43, 0x00, 0x41, 0x30, 0x0b, 0x06, 0x03, 0x55, 0x1d, 0x0f,
    0x04, 0x04, 0x03, 0x02, 0x01, 0x46, 0x30, 0x0f, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x01, 0x01, 0xff,
    0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16,
    0x04, 0x14, 0x77, 0xc9, 0x74, 0x69, 0x2c, 0x39, 0xfe, 0x38, 0x65, 0xf4, 0x87, 0x05, 0x58, 0x08,
    0xce, 0xbd, 0xba, 0x97, 0xda, 0x10, 0x30, 0x81, 0xb6, 0x06, 0x03, 0x55, 0x1d, 0x1f, 0x04, 0x81,
    0xae, 0x30, 0x81, 0xab, 0x30, 0x81, 0xa8, 0xa0, 0x81, 0xa5, 0xa0, 0x81, 0xa2, 0x86, 0x4e, 0x68,
    0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x68, 0x69, 0x63, 0x61, 0x73, 0x61, 0x72, 0x6f, 0x6f,
    0x74, 0x63, 0x61, 0x2e, 0x6e, 0x74, 0x64, 0x65, 0x76, 0x2e, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73,
    0x6f, 0x66, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x43, 0x65, 0x72, 0x74, 0x45, 0x6e, 0x72, 0x6f,
    0x6c, 0x6c, 0x2f, 0x4e, 0x54, 0x44, 0x45, 0x56, 0x25, 0x32, 0x30, 0x53, 0x41, 0x25, 0x32, 0x30,
    0x52, 0x6f, 0x6f, 0x74, 0x25, 0x32, 0x30, 0x43, 0x41, 0x2e, 0x63, 0x72, 0x6c, 0x86, 0x50, 0x66,
    0x69, 0x6c, 0x65, 0x3a, 0x2f, 0x2f, 0x5c, 0x5c, 0x77, 0x68, 0x69, 0x63, 0x61, 0x73, 0x61, 0x72,
    0x6f, 0x6f, 0x74, 0x63, 0x61, 0x2e, 0x6e, 0x74, 0x64, 0x65, 0x76, 0x2e, 0x6d, 0x69, 0x63, 0x72,
    0x6f, 0x73, 0x6f, 0x66, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x5c, 0x43, 0x65, 0x72, 0x74, 0x45, 0x6e,
    0x72, 0x6f, 0x6c, 0x6c, 0x5c, 0x4e, 0x54, 0x44, 0x45, 0x56, 0x25, 0x32, 0x30, 0x53, 0x41, 0x25,
    0x32, 0x30, 0x52, 0x6f, 0x6f, 0x74, 0x25, 0x32, 0x30, 0x43, 0x41, 0x2e, 0x63, 0x72, 0x6c, 0x30,
    0x10, 0x06, 0x09, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x15, 0x01, 0x04, 0x03, 0x02, 0x01,
    0x00, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00,
    0x03, 0x81, 0x81, 0x00, 0x08, 0xf9, 0xe1, 0x6f, 0x24, 0xcd, 0xa8, 0xac, 0xf6, 0xff, 0x37, 0x04,
    0x90, 0xa4, 0x40, 0x54, 0xa0, 0x55, 0xe8, 0xe3, 0xde, 0x3b, 0xa7, 0x3d, 0x90, 0xb1, 0x51, 0xe0,
    0xa7, 0x1b, 0x3c, 0xc3, 0x9a, 0xbc, 0x54, 0xb8, 0xe3, 0xdc, 0xa1, 0xfa, 0x18, 0x95, 0x2c, 0x19,
    0xff, 0x5d, 0x6e, 0x2e, 0x85, 0x55, 0x73, 0x9a, 0x82, 0x90, 0x46, 0x64, 0x9d, 0x64, 0xa6, 0xc1,
    0x14, 0x55, 0x8a, 0x28, 0xb3, 0xc9, 0xfd, 0xdd, 0x46, 0xe6, 0x2c, 0x47, 0xdb, 0x1e, 0x3f, 0x68,
    0xb1, 0x25, 0x4b, 0x4a, 0x1c, 0x7c, 0x1b, 0xa8, 0x77, 0xa8, 0x42, 0x95, 0x29, 0x66, 0x93, 0xad,
    0xf9, 0xcc, 0xf2, 0x2c, 0xe2, 0x89, 0xa4, 0xf7, 0x3d, 0x8a, 0x1c, 0x7d, 0xd7, 0xb5, 0xee, 0x98,
    0x30, 0xab, 0x35, 0x31, 0x74, 0x52, 0xb9, 0xfc, 0xa6, 0x8b, 0x86, 0xf7, 0x06, 0x32, 0x07, 0x7c,
    0x14, 0x9e, 0x64, 0x9d
*/
};

/****************************************
* IMPORTANT: Rules to follow for
* thread safety.  There is one global
* variable that needs to be thread safe.
* The array of trusted CA's which is nothing but array of
* Certificates.  The location
* of the array should be protected by
* a critical section.  Also, all certs
* from array[0] to array[cTrustedCAs] should
* be guaranteed to be there, so cTrustedCAs
* should be protected by a critical section,
* and should not be changed until the
* state of the certs is verified.
******************************************/

// TBDTBD: add reference counts to certificates
// to protect them from being deleted out from
// under us.

CRITICAL_SECTION csTrustedCAs;
CRITICAL_SECTION csUpdateCAs;

PPctCertificate * TrustedCAs;  // = NULL;
DWORD             cTrustedCAs; // = 0;
BOOL              fTrustedCAsLoaded; // = FALSE;

const char g_szVerisign3Root[] = "C=US, O=VeriSign, Inc., OU=Class 3 Public Primary Certification Authority";
const char g_szGenevaRoot[] = "CN=Root SGC Authority";

// Two SGC root CAs
PPctCertificate g_pVerisign3Root;
PPctCertificate g_pGenevaRoot;

// For loading resources as required.
HINSTANCE g_hInstance;

#ifdef DEBUG
const TCHAR *g_aKnownKeyNames[] = {
    TEXT("Verisign/RSA Secure Server"),
    TEXT("Verisign Class 2 Public Primary CA"),
    TEXT("Verisign Class 3 Public Primary CA"),
    TEXT("GTE Cybertrust ROOT"),
    TEXT("GTE Cybertrust Root"),
    TEXT("Thawte Server CA"),
    TEXT("Thawte Premium Server CA"),
    TEXT("Thawte Personal Basic CA"),
    TEXT("Thawte Personal Freemail CA"),
    TEXT("Thawte Personal Premium CA"),
    TEXT("Microsoft Root Authority"),
    TEXT("Root SGC Authority")
};

#endif //DEBUG

const DWORD g_aKnownKeyData[] = {
    {IDR_RSASSCA},
    {IDR_VSCLASS2},
    {IDR_VSCLASS3},
    {IDR_CYBERTRUST},
    {IDR_CYBERTRUSTv2},
    {IDR_THAWTE_SERVER_BASIC},
    {IDR_THAWTE_SERVER_PREMIUM},
    {IDR_THAWTE_PERSONAL_BASIC},
    {IDR_THAWTE_PERSONAL_FREEMAIL},
    {IDR_THAWTE_PERSONAL_PREMIUM},
    {IDR_MICROSOFT_ROOT_AUTH},
    {IDR_ENTRUST_SECURE_SERVER},
    {IDR_ENTRUST_2K_SECURE_SERVER},
    {IDR_GENEVA_SGC_CERT}
};

const DWORD g_cKnownKeys = sizeof(g_aKnownKeyData)/sizeof(DWORD);

BOOL
InitializeCACache(
    HINSTANCE hInstance
    )
{
    InitializeCriticalSection(&csTrustedCAs);
    InitializeCriticalSection(&csUpdateCAs);

    TrustedCAs        = NULL;
    cTrustedCAs       = 0;
    fTrustedCAsLoaded = FALSE;
    g_pVerisign3Root = NULL;
    g_pGenevaRoot = NULL;

    g_hInstance  = hInstance;

    return (TRUE);
}

//
// SHolden - Provide a way to shutdown the cache and clean up memory.
//

BOOL
ShutdownCACache()
{
    g_pVerisign3Root = NULL;
    g_pGenevaRoot = NULL;
    DeleteCACache();
    DeleteCriticalSection(&csTrustedCAs);
    DeleteCriticalSection(&csUpdateCAs);
    return (TRUE);
}

BOOL
DeleteCACache()
{
    DWORD iKey;

    EnterCriticalSection(&csTrustedCAs);
    EnterCriticalSection(&csUpdateCAs);

    if (fTrustedCAsLoaded == FALSE)
    {
        ASSERT(TrustedCAs == NULL);
        goto done;
    }

    fTrustedCAsLoaded = FALSE;

    if(TrustedCAs != NULL)
    {
        for(iKey = 0; iKey < cTrustedCAs; iKey++)
        {
            if(TrustedCAs[iKey])
            {
                // Cert will delete itelf when ref count is 0.
                DereferenceCert(TrustedCAs[iKey]->pIssuerCertificate);
                TrustedCAs[iKey]->pIssuerCertificate = NULL;
                DereferenceCert(TrustedCAs[iKey]);
            }
        }

        SPExternalFree(TrustedCAs);
        TrustedCAs  = NULL;
        cTrustedCAs = 0;
    }

done:

    LeaveCriticalSection(&csTrustedCAs);
    LeaveCriticalSection(&csUpdateCAs);

    return (TRUE);
}

PPctCertificate
FindIssuerKey(
    PSTR    pszIssuer)
{
    PPctCertificate Result = NULL;
    DWORD   i;

    EnterCriticalSection(&csTrustedCAs);

    if (fTrustedCAsLoaded == FALSE)
    {
        LoadCAKeys();
    }

    do
    {

        if(cTrustedCAs == 0 ||
           NULL == TrustedCAs)
        {
            break;
        }


        for (i = 0; i < cTrustedCAs ; i++ )
        {
            if (TrustedCAs[i] &&
                (lstrcmpiA(pszIssuer, TrustedCAs[i]->szSigningAuthority) ==0))
            {
                // Validated file time here
                Result = TrustedCAs[i];
                // Inc the reference count.
                break;
            }
        }
        break;
    } while(TRUE);

    // Reference the cert that we're
    // giving out.
    if (Result)
    {
        ReferenceCert(Result);
    }

    LeaveCriticalSection(&csTrustedCAs);
    return Result;
}


//
// SHolden - InitializeCACache used to read the certificates from the resource
//           file and then transfer to registry. This will use extra memory in
//           the registry. Instead, I will load the certificates from the
//           resource file on demand. I will also check the registry in case
//           the user has added their own.
//

SP_STATUS
LoadCAKeys(VOID)
{
    DWORD err;

    DWORD cKeys;
    DWORD cSubkeys;

    DWORD i;
    DWORD iKey;
    DWORD iTrustedKeys;

    DWORD cValues;
    DWORD cchMaxSubkeyLen;
    DWORD cchMaxClassLen;
    DWORD cchMaxValueLen;
    DWORD cchMaxDataLen;

    DEBUGMSG(ZONE_INIT | ZONE_CERT,
             (TEXT("SCHANNEL: +LoadCAKeys()\r\n"))
             );

    EnterCriticalSection(&csUpdateCAs);

    EnterCriticalSection(&csTrustedCAs);

    // Free the current cache if one exists before we re-load.
    DeleteCACache();

    // set first to prevent recursion! i.e. From FindIssuerKey.
    fTrustedCAsLoaded = TRUE;

    // Get the number of CA keys in the registry
#ifdef XBOX
	// BUGBUG Need to really lead certs from somewhere
    cKeys    = 1;
    cSubkeys = 0;
#else
    err = RegQueryInfoKey(g_hkCA,
                    NULL,             // Class name.
                    NULL,             // Size of class name.
                    NULL,             // Reserved. Must be NULL.
                    &cSubkeys,        // Count of number of subkeys.
                    &cchMaxSubkeyLen, // Size of subkey with longest name.
                    &cchMaxClassLen,  // Size of longest string specifying subkey class.
                    &cValues,         // Count of number of values associated with key.
                    &cchMaxValueLen,  // Size of longest value.
                    &cchMaxDataLen,   // Size of longest data component.
                    NULL,             // Must be NULL.
                    NULL);            // Must be NULL.

    if (err == 0)
    {
        DEBUGMSG(ZONE_INIT,
                 (TEXT("SCHANNEL: CA subkeys in registry = %d.\r\n"),
                  cSubkeys)
                 );

        cKeys = cSubkeys + g_cKnownKeys;
    }
    else
	{
        DEBUGMSG(ZONE_INIT,
                 (TEXT("SCHANNEL: RegQueryInfoKey failure = 0x%.8X (%d)\r\n"),
                  GetLastError(), GetLastError())
                 );

        cKeys    = g_cKnownKeys;
        cSubkeys = 0;
    }
#endif

    TrustedCAs  = SPExternalAlloc(cKeys * sizeof(PPctCertificate));
    cTrustedCAs = 0;

    if (TrustedCAs == NULL)
    {
        LeaveCriticalSection(&csTrustedCAs);
        LeaveCriticalSection(&csUpdateCAs);
        return SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY);
    }

    // We leave the critical section here so calls to
    // find issuer key do not block when we do the cert
    // decode.

    LeaveCriticalSection(&csTrustedCAs);

    iTrustedKeys = 0;

#ifndef XBOX
    LoadRegKeys(
        &iTrustedKeys,
        cSubkeys
        );
#endif

    LoadKnownKeys(
        &iTrustedKeys
        );

    ASSERT(iTrustedKeys == cKeys);

    EnterCriticalSection(&csTrustedCAs);

    cTrustedCAs = iTrustedKeys;

    // Hook up all of the signings.
    DEBUGMSG(ZONE_CERT,
            (TEXT("Hook cert signings...\r\n"))
            );

    for(iKey = 0; iKey < cTrustedCAs; iKey++)
    {
        if(TrustedCAs[iKey])
        {
            for (i = 0; i < cTrustedCAs ; i++ )
            {
                if (TrustedCAs[i] &&
                    (lstrcmpiA(TrustedCAs[i]->pszSubject, TrustedCAs[iKey]->szSigningAuthority) ==0))
                {
                    DEBUGMSG(ZONE_CERT,
                            (TEXT("    Cert%d issuer = Cert%d\r\n"),
                             TrustedCAs[iKey]->dwDebugId,
                             TrustedCAs[i]->dwDebugId)
                            );

                    // Validated file time here
                    TrustedCAs[iKey]->pIssuerCertificate = TrustedCAs[i];
                    // Inc the reference count.
                    ReferenceCert(TrustedCAs[i]);
                    break;
                }
            }
            if (!g_pVerisign3Root &&
                lstrcmpiA(TrustedCAs[iKey]->pszSubject,g_szVerisign3Root) == 0)
            {
                g_pVerisign3Root = TrustedCAs[iKey];
            }
            else if (!g_pGenevaRoot && 
                lstrcmpiA(TrustedCAs[iKey]->pszSubject,g_szGenevaRoot) == 0)
            {
                g_pGenevaRoot = TrustedCAs[iKey];
            }
        }
    }

    DEBUGMSG(ZONE_INIT | ZONE_CERT,
            (TEXT("SCHANNEL: -LoadCAKeys\r\n"))
            );

    LeaveCriticalSection(&csTrustedCAs);
    LeaveCriticalSection(&csUpdateCAs);
    return PCT_ERR_OK;
}


SP_STATUS
LoadKnownKeys(
    LPDWORD lpiTrustedCAs
    )
{
    const CertSystem *pSys = NULL;
#ifdef XBOX
    pSys = CertFromSpec(
        1, // dwCertType for all known = 1.
        SP_PROT_ALL
        );

    if (pSys != NULL)
    {
	    // Note, the issuer of the decoded cert should be NULL,
	    // as we have a size 0 issuer list.
	    pSys->Decode(g_RootCert, sizeof(g_RootCert), &TrustedCAs[*lpiTrustedCAs]);
	    TrustedCAs[(*lpiTrustedCAs)++]->fTrusted = TRUE;
	}
#else
    DWORD i;
    DWORD dwSize;
    HRSRC hResource;
    HGLOBAL hGlobal;

    void *pResource;

    for (i = 0; i < g_cKnownKeys; i++, (*lpiTrustedCAs)++)
    {
    #ifdef DEBUG

        DEBUGMSG(ZONE_INIT,
                 (TEXT("SCHANNEL: Loading CA from resource: %s\r\n"),
                  g_aKnownKeyNames[i])
                 );

    #endif

        hResource = FindResource(
            g_hInstance,
            MAKEINTRESOURCE(g_aKnownKeyData[i]),
            TEXT("CERT")
            );

        if(hResource == NULL)
        {
            DEBUGMSG(ZONE_ERROR,
                     (TEXT("SCHANNEL: FindResource failure 0x%.8X (%d).\r\n"),
                      GetLastError(), GetLastError())
                     );

            continue;
        }

        dwSize = SizeofResource(
            g_hInstance,
            hResource
            );

        if(dwSize == 0)
        {
            continue;
        }

        hGlobal = LoadResource(
            g_hInstance,
            hResource
            );

        if(hGlobal == NULL)
        {
            continue;
        }

        pResource = LockResource(hGlobal);

        if(pResource == NULL)
        {
            continue;
        }

        pSys = CertFromSpec(
            1, // dwCertType for all known = 1.
            SP_PROT_ALL
            );

        if (pSys == NULL)
        {
            continue;
        }

        // Note, the issuer of the decoded cert should be NULL,
        // as we have a size 0 issuer list.
        pSys->Decode(pResource, dwSize, &TrustedCAs[*lpiTrustedCAs]);
        TrustedCAs[*lpiTrustedCAs]->fTrusted = TRUE;
    }
#endif
    return (PCT_ERR_OK);
}

SP_STATUS
LoadRegKeys(
    LPDWORD lpiTrustedCAs,
    DWORD   cSubkeys
    )
{
    DWORD err;
    DWORD iSubkey;
    TCHAR szName[1024];
    DWORD cName;
    HKEY hSubKey;
    DWORD dwSize;
    DWORD dwType;
    DWORD dwEnabled;
    DWORD dwCertType;
    const CertSystem *pSys = NULL;
    PUCHAR pRawCert;

    for(iSubkey = 0;
        iSubkey < cSubkeys;
        iSubkey++
        )
    {
        pSys = NULL;
        TrustedCAs[*lpiTrustedCAs] = NULL;
        cName = sizeof(szName);

#ifndef XBOX
		// BUGBUG Need to really lead certs from resource

        // Now enum through the children of this key.
        err = RegEnumKeyEx(
            g_hkCA,
            iSubkey,
            szName,
            &cName,
            NULL,
            NULL,
            NULL,
            NULL
            );

        if(err)
        {
            continue;
        }

        DEBUGMSG(ZONE_INIT, (TEXT("SCHANNEL: Subkey %s\r\n"), szName));

        err = RegOpenKeyEx(g_hkCA, szName, 0, KEY_READ, &hSubKey);

        if(err)
        {
            continue;
        }

        dwSize = sizeof(DWORD);
        err = RegQueryValueEx(
            hSubKey,
            SP_REG_VAL_ENABLED,
            NULL,
            &dwType,
            (PUCHAR)&dwEnabled,
            &dwSize
            );

        if (err ||
            (REG_DWORD != dwType) ||
            (0 == dwEnabled)
            )
        {
            CloseHandle(hSubKey);
            continue;
        }

        dwSize = sizeof(DWORD);
        err = RegQueryValueEx(
            hSubKey,
            SP_REG_VAL_CERT_TYPE,
            NULL,
            &dwType,
            (PUCHAR)&dwCertType,
            &dwSize
            );

        if (err ||
            (REG_DWORD != dwType) ||
            (NULL == (pSys = CertFromSpec(dwCertType, SP_PROT_ALL)))
            )
        {
            CloseHandle(hSubKey);
            continue;
        }

        // Get the size of the cert
        err = RegQueryValueEx(
            hSubKey,
            SP_REG_VAL_CACERT,
            NULL,
            &dwType,
            NULL,
            &dwSize
            );

        if (err ||
            (REG_BINARY != dwType)
            )
        {
            CloseHandle(hSubKey);
            continue;
        }

        pRawCert = SPExternalAlloc(dwSize);
        if(NULL == pRawCert)
        {
            CloseHandle(hSubKey);
            // BUGBUG: did not clean up anything.
            return SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY);
        }

        // Get the cert for real this time.
        err = RegQueryValueEx(
            hSubKey,
            SP_REG_VAL_CACERT,
            NULL,
            &dwType,
            pRawCert,
            &dwSize
            );

        CloseHandle(hSubKey);

        if (err ||
            (REG_BINARY != dwType)
            )
        {
            SPExternalFree(pRawCert);
            continue;
        }

        DEBUGMSG(ZONE_INIT,
                 (TEXT("SCHANNEL: %s CA cert retrieved 0x%.8X.\r\n"),
                  szName, pRawCert)
                 );

        // Note, the issuer of the decoded cert should be NULL,
        // as we have a size 0 issuer list.
        if(pSys->Decode(pRawCert, dwSize, &TrustedCAs[*lpiTrustedCAs]))
        {
            TrustedCAs[*lpiTrustedCAs]->fTrusted = TRUE;
            (*lpiTrustedCAs)++;
        }
        SPExternalFree(pRawCert);
#endif

    }

    return (PCT_ERR_OK);
}

/*****************************************************************************/
BOOL GetDefaultIssuers(
    PBYTE pbIssuers,	    // out
    DWORD *pcbIssuers)	    // in, out
{
 	DWORD iCA;
    DWORD cbCurIssuerLen = 0;
 	DWORD cbIssuerLen = *pcbIssuers;
    PBYTE pbCurIssuer = pbIssuers;
	
    if (fTrustedCAsLoaded == FALSE)
    {
        LoadCAKeys();
    }

    if(TrustedCAs != NULL)
    {
        for(iCA = 0; iCA < cTrustedCAs; iCA++)
        {
            if(TrustedCAs[iCA])
            {
                cbCurIssuerLen += 2 + TrustedCAs[iCA]->cbIssuer;
                // Are we writing?
                if(pbIssuers)
                {
                    if(cbCurIssuerLen > cbIssuerLen)
                    {
                        return (FALSE);  // overrun
                    }

                    pbCurIssuer[0] = MSBOF(TrustedCAs[iCA]->cbIssuer);
			        pbCurIssuer[1] = LSBOF(TrustedCAs[iCA]->cbIssuer);
			        pbCurIssuer += 2;
	   			    CopyMemory(pbCurIssuer, TrustedCAs[iCA]->pbIssuer,
   							    TrustedCAs[iCA]->cbIssuer);
	         	    pbCurIssuer += TrustedCAs[iCA]->cbIssuer;
                }
            }
        }
        *pcbIssuers = cbCurIssuerLen;
    }
    else
    {
        *pcbIssuers = 0;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\keysx.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       keys.c
//
//  Contents:   Well known keys for certificate validation
//
//  Classes:
//
//  Functions:
//
//  History:    9-21-95   RichardW   Created
//
//----------------------------------------------------------------------------


#include "spbase.h"

#include <rsa.h>
#include <md5.h>
#include <rc4.h>

extern BOOL
WINAPI
SigRSAMD5Sign(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           *pcbSigned,
    PctPrivateKey    *pKey);

#define PRIVATE_KEY_TEXT    "private-key"

/*
UCHAR   bMD2SigPrefixReverse[] = { 0x10, 0x04, 0x00, 0x05, 0x02, 0x02, 0x0d,
                                   0xf7, 0x86, 0x48, 0x86, 0x2a, 0x08, 0x06,
                                   0x0c, 0x30, 0x20, 0x30 };

UCHAR   bMD5SigPrefixReverse[] = { 0x10, 0x04, 0x00, 0x05, 0x05, 0x02, 0x0d,
                                   0xf7, 0x86, 0x48, 0x86, 0x2a, 0x08, 0x06,
                                   0x0c, 0x30, 0x20, 0x30 };

UCHAR   bMD5SigPrefix[] =  { 0x30, 0x20, 0x30, 0x0c, 0x06, 0x08, 0x2a, 0x86,
                             0x48, 0x86, 0xf7, 0x0d, 0x02, 0x05, 0x05, 0x00,
                             0x04, 0x10 };
                             */


#define BIG_ENDIAN 2
#define NETWORK_ORDER BIG_ENDIAN

BOOL
EncodePrivateKey(
    PctPrivateKey * pKey,
    DWORD           InitialSize,
    PSTR            pszPassword,
    PUCHAR *        ppBuffer,
    DWORD *         pcbBuffer)
{
    BSAFE_PRV_KEY *pk;
    BSAFE_KEY_PARTS parts;
    PUCHAR  pBuffer;
    PUCHAR  pbEncoded;
    PUCHAR  pSave;
    int     Result;
    BYTE    Zero;
    DWORD   BigLen;
    DWORD   ShortLen;
    PUCHAR  pSequence;
    DWORD   Length;
    PUCHAR  pSave2;
    long    Delta2;
    UCHAR   Key[16];
    struct RC4_KEYSTRUCT  rc4Key;
    MD5_CTX md5Ctx;

    pk = (BSAFE_PRV_KEY *) pKey->pKey;
    BSafeGetPrvKeyParts(pk, &parts);

    pBuffer = SPExternalAlloc(InitialSize);
    if (NULL == pBuffer)
    {
        return(FALSE);
    }

    pbEncoded = pBuffer;

    BigLen = pk->bitlen / 8;
    ShortLen = BigLen / 2;

    //
    // We just do the key now, and then we'll add the other stuff later
    //
    // Encode the maximum length for now.  We'll patch this up later
    //

    Result = EncodeHeader(pbEncoded, InitialSize, TRUE);

    pbEncoded += Result;

    pSave = pbEncoded;

    Zero = 0;
    Result = EncodeInteger(pbEncoded, &Zero, sizeof(Zero), TRUE);
    pbEncoded += Result;

    Result = EncodeInteger(pbEncoded, parts.modulus, BigLen, TRUE);
    pbEncoded += Result;

    Result = EncodeInteger(pbEncoded, (PBYTE) &pk->pubexp, sizeof(DWORD), TRUE);
    pbEncoded += Result;

    Result = EncodeInteger(pbEncoded, parts.prvexp, BigLen, TRUE);
    pbEncoded += Result;

    Result = EncodeInteger(pbEncoded, parts.prime1, ShortLen, TRUE);
    pbEncoded += Result;

    Result = EncodeInteger(pbEncoded, parts.prime2, ShortLen, TRUE);
    pbEncoded += Result;

    Result = EncodeInteger(pbEncoded, parts.exp1, ShortLen, TRUE);
    pbEncoded += Result;

    Result = EncodeInteger(pbEncoded, parts.exp2, ShortLen, TRUE);
    pbEncoded += Result;

    Result = EncodeInteger(pbEncoded, parts.coef, ShortLen, TRUE);
    pbEncoded += Result;

    Length = pbEncoded - pSave;

    Result = EncodeHeader(pBuffer, Length, TRUE);
    Length += Result;

    pSequence = SPExternalAlloc(Length + 64);
    if (NULL == pSequence)
    {
        SPExternalFree(pBuffer);
        return(FALSE);
    }

    pbEncoded = pSequence;

    Result = EncodeHeader(pbEncoded, Length + 64, TRUE);
    pbEncoded += Result;

    pSave = pbEncoded;

    Result = EncodeInteger(pbEncoded, &Zero, sizeof(Zero), TRUE);
    pbEncoded += Result;

    Result = EncodeAlgorithm(pbEncoded, ALGTYPE_KEYEXCH_RSA_MD5, TRUE);
    pbEncoded += Result;

    Result = EncodeOctetString(pbEncoded, pBuffer, Length, TRUE);
    pbEncoded += Result;

    FillMemory(pBuffer, Length, 0);

    Length = pbEncoded - pSave;

    Result = EncodeHeader(pSequence, Length, TRUE);
    Length += Result;

    SPExternalFree(pBuffer);

    pBuffer = SPExternalAlloc(Length + 128);
    if (NULL == pBuffer)
    {
        SPExternalFree(pSequence);
        return(FALSE);
    }

    pbEncoded = pBuffer;

    Result = EncodeHeader(pBuffer, Length + 128, TRUE);
    pbEncoded += Result;

    pSave = pbEncoded;

    Result = EncodeOctetString(
			pbEncoded,
			PRIVATE_KEY_TEXT,
			strlen(PRIVATE_KEY_TEXT),
			TRUE);
    pbEncoded += Result;

    Result = EncodeHeader(pbEncoded, Length + 64, TRUE);
    pbEncoded += Result;

    pSave2 = pbEncoded;
    Delta2 = Result;

    Result = EncodeAlgorithm(pbEncoded, ALGTYPE_CIPHER_RC4_MD5, TRUE);
    pbEncoded += Result;

    //
    // Encrypt the data with the password
    //

    MD5Init(&md5Ctx);
    MD5Update(&md5Ctx, pszPassword, strlen(pszPassword));
    MD5Final(&md5Ctx);
    CopyMemory(Key, md5Ctx.digest, 16);

    FillMemory(&md5Ctx, sizeof(md5Ctx), 0);

    rc4_key(&rc4Key, 16, Key);
    rc4(&rc4Key, Length, pSequence);
    FillMemory(&rc4Key, sizeof(rc4Key), 0);


    Result = EncodeOctetString(pbEncoded, pSequence, Length, TRUE);

    SPExternalFree(pSequence);

    pbEncoded += Result;

    //
    // Now, back up and fill in the correct lengths:
    //

    Result = EncodeHeader(pSave2 - Delta2, pbEncoded - pSave2, TRUE);
    Result = EncodeHeader(pBuffer, pbEncoded - pSave2, TRUE);

    *pcbBuffer = pbEncoded - pBuffer;
    *ppBuffer = pBuffer;

    return(TRUE);
}


long
EncodeSubjectPubKeyInfo(
    PctPrivateKey * pKey,
    PUCHAR          pBuffer)
{
    PUCHAR  pbEncoded;
    LONG    Result, ResultHeader;
    LONG    PkResult, PkResultHeader;
    PUCHAR  pSave;
    PUCHAR  pBitString;
    PUCHAR  pBitStringBase;
    PUCHAR  pTop;
    DWORD   EstimatedLength;
    BSAFE_PRV_KEY * pk = (BSAFE_PRV_KEY *)pKey->pKey;

    //
    // Encode public key now...
    //

    EstimatedLength = pk->datalen + 32;

    pbEncoded = pBuffer;

    ResultHeader = EncodeHeader(pbEncoded, EstimatedLength, TRUE);
    pbEncoded += ResultHeader;

    pTop = pbEncoded;

    Result = EncodeAlgorithm(pbEncoded, ALGTYPE_KEYEXCH_RSA_MD5, TRUE);
    if (Result < 0)
    {
        return(-1);
    }
    pbEncoded += Result;

    //
    // now, serialize the rsa key data:
    //

    pBitString = SPExternalAlloc(EstimatedLength);
    if (NULL == pBitString)
    {
        return(-1);
    }
    pBitStringBase = pBitString;

    // Encode the Sequence header, public key base and exponent as integers

    PkResultHeader = EncodeHeader(pBitString, EstimatedLength, TRUE);
    pBitString += PkResultHeader;

    pSave = pBitString;

    PkResult = EncodeInteger(pBitString, (PBYTE) (pk + 1), pk->keylen, TRUE);
    pBitString += PkResult;

    PkResult = EncodeInteger(
			pBitString,
			(PBYTE) &pk->pubexp,
			sizeof(DWORD),
			TRUE);
    pBitString += PkResult;

    // Rewrite the bitstring header with an accurate length.

    PkResult = EncodeHeader(pBitStringBase, pBitString - pSave, TRUE);
    SP_ASSERT(PkResult == PkResultHeader);

    // Encode the public key sequence as a raw bitstring, and free the memory.

    Result = EncodeBitString(
			pbEncoded,
			pBitStringBase,
			pBitString - pBitStringBase,
			TRUE);
    pbEncoded += Result;

    SPExternalFree(pBitStringBase);

    // Rewrite the header with an accurate length.

    Result = EncodeHeader(pBuffer, pbEncoded - pTop, TRUE);
    SP_ASSERT(Result == ResultHeader);
    return(Result + (pbEncoded - pTop));
}


BOOL
EncodePublicKey(
    PctPrivateKey * pKey,
    PSTR            pszDN,
    PUCHAR *        ppBuffer,
    DWORD *         pcbBuffer)
{
    PUCHAR  pBuffer;
    PUCHAR  pBufferToSign;
    PBYTE   pBufferBase;		// base of allocated memory

    PUCHAR  pPubEncoded;
    PUCHAR  pPubEncodedBase = NULL;	// base of allocated memory
    PUCHAR  pbEncoded;

    PUCHAR  pSave;
    PUCHAR  pSave2;

    int     Result;
    BYTE    Zero;
    DWORD   ShortLen;
    DWORD   Length;
    LONG    PubRes;
    LONG    PubLen;
    int     ResultSave;
    int     LengthOfReqInfo;
    BSAFE_PRV_KEY * pk = (BSAFE_PRV_KEY *)pKey->pKey;

    ShortLen = EncodeDN(NULL, pszDN, FALSE);
    if (ShortLen < 0)
    {
	return(FALSE);
    }

    Length = pk->datalen + 32 + ShortLen + 16;

    pBuffer = SPExternalAlloc(Length);
    if (NULL == pBuffer)
    {
        return(FALSE);
    }
    pBufferBase = pBuffer;

    pbEncoded = pBuffer;

    // Encode SEQUENCE_TAG, <length>

    Result = EncodeHeader(pBuffer, Length, TRUE);
    ResultSave = Result;

    pbEncoded += Result;

    pSave = pbEncoded;

    // Encode integer 0

    Zero = 0;
    Result = EncodeInteger(pbEncoded, &Zero, sizeof(Zero), TRUE);
    pbEncoded += Result;

    // Encode sequence of names

    Result = EncodeDN(pbEncoded, pszDN, TRUE);
    if (Result < 0)
    {
	goto error;
    }
    pbEncoded += Result;

    Result = EncodeSubjectPubKeyInfo(pKey, pbEncoded);
    if (Result < 0)
    {
	goto error;
    }
    pbEncoded += Result;

    // Encode empty attributes set

    Result = EncodeAttributeHeader(pbEncoded, 0, TRUE);
    pbEncoded += Result;

    Result = EncodeHeader(pBuffer, pbEncoded - pSave, TRUE);

    // If the header sequence length takes up less space than we anticipated,
    // add the difference to the base pointer and encode the header again,
    // right before the encoded data.

    if (Result != ResultSave)
    {
	SP_ASSERT(ResultSave > Result);
        pBuffer += ResultSave - Result;
        Result = EncodeHeader(pBuffer, pbEncoded - pSave, TRUE);
    }

    LengthOfReqInfo = Result + (pbEncoded - pSave);

    pBufferToSign = pBuffer;

    // How much space do we need?

    PubLen = LengthOfReqInfo + pk->datalen + 32;
    pPubEncoded = SPExternalAlloc(PubLen);
    if (NULL == pPubEncoded)
    {
	goto error;
    }
    pPubEncodedBase = pPubEncoded;

    Result = EncodeHeader(pPubEncoded, PubLen, TRUE);

    pSave2 = pPubEncoded;

    ResultSave = Result;

    pPubEncoded += Result;

    pSave = pPubEncoded;

    CopyMemory(pPubEncoded, pBuffer, LengthOfReqInfo);

    pPubEncoded += LengthOfReqInfo;

    Result = EncodeAlgorithm(pPubEncoded, ALGTYPE_SIG_RSA_MD5, TRUE);

    pPubEncoded += Result;


    // pBufferBase has the real pointer

    pBuffer = SPExternalAlloc(pk->datalen + 16);
    if (NULL == pBuffer)
    {
        goto error;
    }

    Result = pk->datalen + 16;
    SigRSAMD5Sign(pBufferToSign, LengthOfReqInfo, pBuffer, &Result, pKey);


    PubRes = EncodeBitString(pPubEncoded, pBuffer, Result, TRUE);

    pPubEncoded += PubRes;

    Result = EncodeHeader(pSave2, pPubEncoded - pSave, TRUE);

    if (Result != ResultSave)
    {
        if (Result > ResultSave)
        {
            //
            // Yuck.  The chunk has actually grown from the estimate.
            //

            *ppBuffer = SPExternalAlloc(pPubEncoded - pSave + Result);
            if (NULL != *ppBuffer)
            {
                EncodeHeader(*ppBuffer, pPubEncoded - pSave, TRUE);
                CopyMemory(*ppBuffer + Result, pSave, pPubEncoded - pSave);

                SPExternalFree(pSave2);
                pSave2 = *ppBuffer;
            }
            else
            {
                SPExternalFree(pBufferBase);
                return(FALSE);
            }
        }
        else
        {
	    SP_ASSERT(Result == ResultSave - 1)
            pSave2++;
            Result = EncodeHeader(pSave2, pPubEncoded - pSave, TRUE);

        }
    }

    *ppBuffer = pSave2;

    *pcbBuffer = Result + (pPubEncoded - pSave);

    SPExternalFree(pBuffer);
    SPExternalFree(pBufferBase);
    return(TRUE);

error:
    SPExternalFree(pBufferBase);
    if (NULL != pPubEncodedBase)
    {
	SPExternalFree(pPubEncodedBase);
    }
    return(FALSE);
}


BOOL
GenerateKeyPair(
    PSSL_CREDENTIAL_CERTIFICATE pCerts,
    PSTR pszDN,
    PSTR pszPassword,
    DWORD Bits)
{
    DWORD BitsCopy;
    DWORD dwPrivateSize;
    DWORD dwPublicSize;
    PctPrivateKey *pPrivate;
    PctPublicKey *pPublic;


    BitsCopy = Bits;
    BSafeComputeKeySizes(&dwPublicSize, &dwPrivateSize, &BitsCopy);

    pPrivate = SPExternalAlloc(dwPrivateSize + sizeof(PctPrivateKey));
    if (NULL == pPrivate)
    {
        return(FALSE);
    }

    pPublic = SPExternalAlloc(dwPublicSize + sizeof(PctPublicKey));
    if (NULL == pPublic)
    {
	SPExternalFree(pPrivate);
        return(FALSE);
    }

    pPublic->cbKey = dwPublicSize;
    pPrivate->cbKey = dwPrivateSize;

    if (!BSafeMakeKeyPair(
		    (BSAFE_PUB_KEY *) pPublic->pKey,
		    (BSAFE_PRV_KEY *) pPrivate->pKey,
		    Bits))
    {
	goto error;
    }

    // Ah yes, now to encode them...
    //
    // First, the private key.  Why?  Well, it's at least straight-forward

    if (!EncodePrivateKey(
		    pPrivate,
		    dwPrivateSize,
		    pszPassword,
		    &pCerts->pPrivateKey,
		    &pCerts->cbPrivateKey))
    {
	goto error;
    }

    if (!EncodePublicKey(
		    pPrivate,
		    pszDN,
		    &pCerts->pCertificate,
		    &pCerts->cbCertificate))
    {
        SPExternalFree(pCerts->pPrivateKey);
	goto error;
    }

    return(TRUE);

error:
    SPExternalFree(pPublic);
    SPExternalFree(pPrivate);
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\httpsget.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    webclient.c

Abstract:

    Schannel web client sample application.

Revision History:

    09-18-97 jbanes     Created.

--*/

#include "xapip.h"
#include "winbasep.h"
#include <stdio.h>
#include <winsock2.h>
#include <wincrypt.h>
#include <tchar.h>
#include <xdbg.h>
#include <schnlsp.h>
#include <spdefs.h>
#include <ipmap.h>
#include <xrlp.h>
#include <httpsget.h>

#ifdef UNDER_CE
//
// Flags for identifying the various different protocols.
//

/* flag/identifiers for protocols we support */
#define SP_PROT_PCT1_SERVER             0x00000001
#define SP_PROT_PCT1_CLIENT             0x00000002
#define SP_PROT_PCT1                    (SP_PROT_PCT1_SERVER | SP_PROT_PCT1_CLIENT)

#define SP_PROT_SSL2_SERVER             0x00000004
#define SP_PROT_SSL2_CLIENT             0x00000008
#define SP_PROT_SSL2                    (SP_PROT_SSL2_SERVER | SP_PROT_SSL2_CLIENT)

#define SP_PROT_SSL3_SERVER             0x00000010
#define SP_PROT_SSL3_CLIENT             0x00000020
#define SP_PROT_SSL3                    (SP_PROT_SSL3_SERVER | SP_PROT_SSL3_CLIENT)

#define SP_PROT_TLS1_SERVER             0x00000040
#define SP_PROT_TLS1_CLIENT             0x00000080
#define SP_PROT_TLS1                    (SP_PROT_TLS1_SERVER | SP_PROT_TLS1_CLIENT)

#define SP_PROT_SSL3TLS1_CLIENTS        (SP_PROT_TLS1_CLIENT | SP_PROT_SSL3_CLIENT)
#define SP_PROT_SSL3TLS1_SERVERS        (SP_PROT_TLS1_SERVER | SP_PROT_SSL3_SERVER)
#define SP_PROT_SSL3TLS1                (SP_PROT_SSL3 | SP_PROT_TLS1)

#define SP_PROT_UNI_SERVER              0x40000000
#define SP_PROT_UNI_CLIENT              0x80000000
#define SP_PROT_UNI                     (SP_PROT_UNI_SERVER | SP_PROT_UNI_CLIENT)

#define SP_PROT_ALL                     0xffffffff
#define SP_PROT_ALL_NOT_TLS             (SP_PROT_PCT1 | SP_PROT_SSL2 | SP_PROT_SSL3)
#define SP_PROT_NONE                    0
#define SP_PROT_CLIENTS                 (SP_PROT_PCT1_CLIENT | SP_PROT_SSL2_CLIENT | SP_PROT_SSL3_CLIENT | SP_PROT_UNI_CLIENT | SP_PROT_TLS1_CLIENT)
#define SP_PROT_SERVERS                 (SP_PROT_PCT1_SERVER | SP_PROT_SSL2_SERVER | SP_PROT_SSL3_SERVER | SP_PROT_UNI_SERVER | SP_PROT_TLS1_SERVER)
#endif

#define SECURITY_WIN32
#include <security.h>
#include <sspi.h>

#define IO_BUFFER_SIZE  0x10000

#ifdef UNDER_CE
#define INITSECURITYNAME TEXT("InitSecurityInterfaceW")
#else // NT
#ifdef UNICODE
#define INITSECURITYNAME "InitSecurityInterfaceW"
#else
#define INITSECURITYNAME "InitSecurityInterfaceA"
#endif
#endif

#ifdef UNICODE
#define ATOI(p) wcstol(p,NULL,10)
#else
#define ATOI(p) atoi(p)
#endif

PSecurityFunctionTable g_pSecFuncs;


SECURITY_STATUS SEC_ENTRY
SealMessage(
    PCtxtHandle         phContext,
    DWORD               fQOP,
    PSecBufferDesc      pMessage,
    ULONG               MessageSeqNo
    );


SECURITY_STATUS SEC_ENTRY
UnsealMessage(
    PCtxtHandle         phContext,
    PSecBufferDesc      pMessage,
    ULONG               MessageSeqNo,
    DWORD *             pfQOP
    );

extern
BOOL
WINAPI
InitializeSSL();

typedef SECURITY_STATUS 
(SEC_ENTRY *PFSealMessage)( PCtxtHandle         phContext,
                unsigned long       fQOP,
                PSecBufferDesc      pMessage,
                unsigned long       MessageSeqNo);

typedef SECURITY_STATUS 
(SEC_ENTRY *PFUnsealMessage)( PCtxtHandle         phContext,
                PSecBufferDesc      pMessage,
                unsigned long       MessageSeqNo,
                unsigned long *     pfQOP);


LPSTR   pszProxyServer  = "itgproxy";
INT     iProxyPort      = 80;

// User options.
LPTSTR   pszServerName[10];
DWORD    cServers = 0;
char     strServerName[100];
INT     iPortNumber     = 443;
LPTSTR  pszFileName     = TEXT("default.htm");
BOOL    fVerbose        = FALSE;    
BOOL    fDumpSSL        = TRUE;     // display SSL header (if unencrypted)
BOOL    fUseProxy       = FALSE;    
BOOL    fUseSecSock     = FALSE;    // use winsock (otherwise use SSPI)
BOOL    fMultiThread    = FALSE;    // multi-threaded test
BOOL    fTime           = FALSE;    // display timing info
BOOL    fOnlyTime       = FALSE;    // only prints time info
BOOL    fOnlyTimeSummary= FALSE;    // only prints total time
BOOL    fQuiet          = FALSE;    // suppress all output
DWORD   tTotal          = 0;        // for total elapsed time
DWORD   tTimeConnect,               // for summary statistics 
        tTimeHS, 
        tTimeGetFile;
BOOL    fContinue       = FALSE;    // keep hitting the server
LPTSTR  pszUserName     = NULL;
char    strUserName[100];

BOOL    fClientAuth     = TRUE;
BOOL    fUseFortezza    = FALSE;
BOOL    fDebugBreak     = FALSE;

HCERTSTORE  hMyCertStore = NULL;

PTSTR    pszServerCertFilename = NULL;

static
SECURITY_STATUS
CreateCredentials(
    LPSTR pszUserName,
    DWORD dwProtocol,
    PCredHandle phCreds);

static DWORD
GetFortezzaContext(PCCERT_CONTEXT *ppCertContext);

static INT
ConnectToServer(
    LPSTR pszServerName,
    INT   iPortNumber,
    SOCKET *pSocket);

static
SECURITY_STATUS
PerformClientHandshake(
    SOCKET          Socket,
    PCredHandle     phCreds,
    LPTSTR           pszServerName,
    CtxtHandle *    phContext,
    SecBuffer *     pExtraData);

static
SECURITY_STATUS
ClientHandshakeLoop(
    SOCKET          Socket,
    PCredHandle     phCreds,
    CtxtHandle *    phContext,
    BOOL            fDoInitialRead,
    SecBuffer *     pExtraData);

static
HRESULT
HttpsGet(
    SOCKET          Socket,
    PCredHandle     phCreds,
    CtxtHandle *    phContext,
    const XRL xrl,
    DWORD* pcbBuffer,
    PBYTE pBuffer,
    XRL_KNOWN_HEADERS *pHTTPHeaders,
    PXAPPSERVICEINFO pServiceInfo);

static 
void
DisplayCertChain(
    PCCERT_CONTEXT pServerCert);

static 
DWORD
VerifyServerCertificate(
    PCCERT_CONTEXT  pServerCert,
    PSTR            pszServerName,
    DWORD           dwCertFlags);

void
DisplayConnectionInfo(
    SecPkgContext_ConnectionInfo *pConnectionInfo);

void PrintHexDump(DWORD length, PBYTE buffer);
static void DumpSSL(DWORD length, const BYTE *buffer);

// make a ANSI string from a LPSTR
void
CopyToStr(LPSTR pDest, LPTSTR pSrc, size_t cbDest)
{
#ifdef UNICODE
    wcstombs(pDest, pSrc, cbDest);
#else
    strncpy(pDest, pSrc, cbDest);
#endif
}

/*****************************************************************************/
#if 0
void Usage(void)
{
    printf("\n");
    printf("USAGE: webclient -s<server> [ <options> ]\n");
    printf("\n");
    printf("    -s<server>      DNS name of server.\n");
    printf("    -p<port>        Port that server is listing on (default 443).\n");
    printf("    -f<file>        Name of file to retrieve (default \"%s\")\n", pszFileName);
    printf("    -v              Verbose Mode.\n");
    printf("    -t              display timing info.\n");
    printf("    -x              Connect via the \"%s\" proxy server.\n", pszProxyServer);
    printf("    -w              Connect using secure WINSOCK instead of SSPI\n");
    printf("    -m              Multi-threaded test.\n");
    printf("    -c<filename>    Dump server certificate to file.\n");   
    printf("    -F              Attempt to acquire Fortezza credentials\n");
    printf("    -t              Display timing information\n");
    printf("    -o              Display only timing information\n");
    printf("    -n              Display only the total connection time\n");
    printf("    -a              Keep connecting to the server until you hold shift down\n");
    printf("    -q              Quiet - no output unless errors occur\n");
#ifdef DEBUG    
    printf("    -b              Debug break on entry\n");
#endif
    
    printf("\n");
    printf("  For client auth\n");
    printf("    -u<user>        Name of user (in existing client certificate)\n");
    printf("    -d              Don't send certificate to server unless it asks first.\n");

    DoExit(1);
}

void
DoMain(TCHAR *pCmdLine)
{
    WSADATA WsaData;
    DWORD i;

    INIT_SECURITY_INTERFACE pfnInitSecurity;
    HINSTANCE hLibSchannel;
    INT iOption;
    PTCHAR pszOption, pszEndOption;

    //
    // Parse the command line.
    //
    
    if(*pCmdLine == 0)
    {
        Usage();
    }

    while(*pCmdLine) 
    {
        
        if(*pCmdLine == '/') *pCmdLine = '-';

        if(*pCmdLine != '-') 
        {
            _tprintf(TEXT("**** Invalid argument \"%s\"\n"), pCmdLine);
            Usage();
        }

        iOption = pCmdLine[1];
        pszOption = pCmdLine+2;
        while (*pCmdLine != ' ' && *pCmdLine != 0)
            pCmdLine++;
        pszEndOption = pCmdLine;
        // advance to next option
        while (*pCmdLine == ' ')
            pCmdLine++;

        *pszEndOption = 0;    // null terminate the option

        switch(iOption) 
        {
        case 's':
            if (cServers < sizeof(pszServerName)/sizeof(pszServerName[0]))
                pszServerName[cServers++] = pszOption;         
            break;

        case 'p':
            iPortNumber = ATOI(pszOption);
            break;

        case 'f':
            pszFileName = pszOption;
             CopyToStr(strFileName, pszFileName, sizeof(strFileName));
            break;

        case 'v':
            fVerbose = TRUE;
            break;

        case 't':
            fTime = TRUE;
            break;
        case 'x':
            fUseProxy = TRUE;
            break;

        case 'w':
            fUseSecSock = TRUE;
            break;

        case 'm':
            fMultiThread = TRUE;
            break;
            
        case 'u':
            pszUserName = pszOption;
            CopyToStr(strUserName, pszUserName, sizeof(strUserName));
            break;

        case 'd':
            fClientAuth = FALSE;
            break;

        case 'c':
            pszServerCertFilename = pszOption;
            break;

        case 'F':
            fUseFortezza = TRUE;
            break;
        case 'b':
            fDebugBreak = TRUE;
            break;
        case 'o':
            fOnlyTime = TRUE;
            fTime = TRUE;
            break;
        case 'n':
            fOnlyTimeSummary = TRUE;
            fOnlyTime = TRUE;
            fTime = TRUE;
            break;
        case 'a':
            fContinue = TRUE;
            break;
        case 'q':
            fQuiet = TRUE;
            break;

        default:
            printf("**** Invalid option \"%c\"\n", iOption);
            Usage();
        }
    }

#ifdef DEBUG
    if (fDebugBreak)
        DebugBreak();
#endif
    //
    // Initialize the WinSock subsystem.
    //

    if(WSAStartup(0x0101, &WsaData) == SOCKET_ERROR)
    {
        XDBGTRC("Xonline", "Error %d returned by WSAStartup", GetLastError());
        DoExit(1);
    }

    if (!fUseSecSock)
    {
        // 
        // Load SCHANNEL
        //

        hLibSchannel = LoadLibrary(TEXT("SCHANNEL.DLL"));
        if (!hLibSchannel)
        {
            XDBGTRC("Xonline", "Error %d returned by LoadLibrary(SCHANNEL)", GetLastError());
            DoExit(1);
        }
        pfnInitSecurity = (INIT_SECURITY_INTERFACE)GetProcAddress(hLibSchannel,INITSECURITYNAME);


        if (!pfnInitSecurity || !(g_pSecFuncs = (*pfnInitSecurity)()))
        {
            XDBGTRC("Xonline", "Cant get SCHANNEL security interface pointers");
            DoExit(1);
        }
    }

    for (i = 0; i < cServers || fContinue; i++) {
        Sleep(1000);
        if ((GetAsyncKeyState(VK_LSHIFT) >> 1) || 
            (GetAsyncKeyState(VK_RSHIFT) >> 1))
            break;
        tTotal = GetTickCount();

#ifdef UNDER_CE    
        if (fUseSecSock)
        {
            SSLSockConnect(pszServerName[i]);
        }
        else
#endif
        if (fMultiThread)
        {
            MTSChannelConnect(pszServerName[(fContinue ? 0 : i)]);
        }
        else
        {
            SChannelConnect(pszServerName[(fContinue ? 0 : i)]);
        }

        tTotal = GetTickCount() - tTotal;
        if (fTime)
            XDBGTRC("Xonline", "Connect: %d  HandShake: %d  GetFile: %d  Total: %d", tTimeConnect, tTimeHS, 
                tTimeGetFile, tTotal);
    } 
       
    // Shutdown WinSock subsystem.
    WSACleanup();

#ifndef UNDER_CE
    // Close "MY" certificate store.
    if(hMyCertStore)
    {
        CertCloseStore(hMyCertStore, 0);
    }
#endif


    DoExit(0);
}
#endif

HRESULT XRL_SSLDownloadToMemory( const XRL xrl, DWORD* pcbBuffer, PBYTE pBuffer, XRL_KNOWN_HEADERS *pHTTPHeaders )
{
    static BOOL fFirstTime = TRUE;
    CredHandle hClientCreds;
    CtxtHandle hContext;
    SecBuffer  ExtraData;
    SecPkgContext_ConnectionInfo ConnectionInfo;
    SECURITY_STATUS Status;
    TimeStamp tsExpiry;
    HRESULT     hr;
    int         serr;
    XAPPSERVICEINFO serviceInfo;
    SOCKET      socketGet = INVALID_SOCKET;
    SOCKADDR_IN sockAddress;
    LINGER      l_linger;

    // values for the header parsing
    XRL_KNOWN_HEADERS   parsedHeaders;
    ULARGE_INTEGER      contentLength;

    RIP_ON_NOT_TRUE("XRL_DownloadToMemory()", (NULL != xrl));
    RIP_ON_NOT_TRUE("XRL_DownloadToMemory()", (NULL != pcbBuffer));
    RIP_ON_NOT_TRUE("XRL_DownloadToMemory()", (NULL != pBuffer));

    //
    // Initialize stuff if this is the first time called.
    //
    if (fFirstTime)
    {
        InitializeSSL();
        fFirstTime = FALSE;
    }

    //
    // Create credentials.
    //
    Status = AcquireCredentialsHandle(
                        NULL,                   // Name of principal
                        UNISP_NAME,             // Name of package
                        SECPKG_CRED_OUTBOUND,   // Flags indicating use
                        NULL,                   // Pointer to logon ID
                        NULL,                   // Package specific data
                        NULL,                   // Pointer to GetKey() func
                        NULL,                   // Value to pass to GetKey()
                        &hClientCreds,          // (out) Cred Handle
                        &tsExpiry);             // (out) Lifetime (optional)
    if(Status != SEC_E_OK)
    {
        XDBGTRC("Xonline", "Error 0x%x returned by AcquireCredentialsHandle", Status);
        hr = HRESULT_FROM_WIN32( Status );
        goto abort;
    }
        
    // prep the parsed headers structure
    // prepare to read the headers
    // we only care about content length here
    ZeroMemory( &parsedHeaders, sizeof(parsedHeaders) );
    // if they requested a headers structure, fill in the pointers
    if ( pHTTPHeaders )
    {
        CopyMemory( &parsedHeaders, pHTTPHeaders, sizeof(parsedHeaders) );
    }
    // if they didn't request content length, we still need it
    if ( !parsedHeaders.pContentLength )
    {
        parsedHeaders.pContentLength = &contentLength;
    }

    // reset the amount read to 0
    parsedHeaders.pContentLength->QuadPart = 0;
    parsedHeaders.dwHTTPResponseCode = 0;

    // get the XRL's target IP address
    hr = XRL_LookupXRLIPAddress( xrl, &sockAddress, &serviceInfo );
    // see if we were able to obtain the address - have not tried
    // connect to it. Just got the address
    if ( hr != S_OK )
    {
        goto abort;
    }

    // Open up the socket to the target address. This socket uses TCP over IP
    socketGet = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
    if (socketGet == INVALID_SOCKET)
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto abort;
    }

    // We have to set the linger to 0 or else the xbox socket layer runs out
    // of sockets if you execute the function lots of times really rapidly.
    l_linger.l_onoff=1;
    l_linger.l_linger=0;
    serr = setsockopt(socketGet,SOL_SOCKET,SO_LINGER,(char *)&l_linger,sizeof(l_linger));
    if (serr == SOCKET_ERROR)
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto abort;
    }

    // Initiate the connection
    serr = connect(socketGet, (PSOCKADDR) &sockAddress, sizeof(sockAddress));
    if (serr == SOCKET_ERROR)
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto abort;
    }

    //
    // Perform SSL handshake
    //
    if(PerformClientHandshake(socketGet,
                              &hClientCreds,
                              L"xaccount", // TODO: see if this matters
                              &hContext,
                              &ExtraData))
    {
        XDBGTRC("Xonline", "Error performing handshake");
        hr = E_FAIL;
        goto abort;
    }

    //
    // Authenticate server's credentials.
    //

#ifndef XBOX
    // Get server's certificate.
    Status = QueryContextAttributes(&hContext,
                                    SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                                    (PVOID)&pRemoteCertContext);
    if(Status != SEC_E_OK)
    {
        XDBGTRC("Xonline", "Error 0x%x querying remote certificate", Status);
        hr = HRESULT_FROM_WIN32( Status );
        goto abort;
    }

    // Display server certificate chain.
    DisplayCertChain(pRemoteCertContext);
#endif

#if 0
    // Attempt to validate server certificate.
    Status = VerifyServerCertificate(pRemoteCertContext,
                                     pszServerName,
                                     0);
    if(Status)
    {
        XDBGTRC("Xonline", "**** Error authenticating server credentials!");
    }
#endif

#ifdef  DBG
    //
    // Display connection info. 
    //    
    Status = QueryContextAttributes(&hContext,
                                    SECPKG_ATTR_CONNECTION_INFO,
                                    (PVOID)&ConnectionInfo);
    if(Status != SEC_E_OK)
    {
        XDBGTRC("Xonline", "Error 0x%x querying connection info", Status);
    }
    else
    {
        DisplayConnectionInfo(&ConnectionInfo);
    }
#endif

    //
    // Perform the HTTP Get from server.
    //
    hr = HttpsGet(socketGet, 
                  &hClientCreds,
                  &hContext, 
                  xrl,
                  pcbBuffer,
                  pBuffer,
                  pHTTPHeaders,
                  &serviceInfo);
    if( FAILED(hr) )
    {
        XDBGTRC("Xonline", "Error %x from HttpsGet", hr );
        goto abort;
    }

    //
    // Cleanup.
    //
abort:

    // Free security context.
    DeleteSecurityContext(&hContext);

    // Free SSPI credentials handle.
    FreeCredentialHandle(&hClientCreds);

    // Close socket.
    closesocket(socketGet);

    return hr;
}


#ifdef XBOX

/*****************************************************************************/
static
SECURITY_STATUS
CreateCredentials(
    LPSTR pszUserName,              // in
    DWORD dwProtocol,               // in
    PCredHandle phCreds)            // out
{
    TimeStamp       tsExpiry;
    SECURITY_STATUS Status;


    //
    // Create an SSPI credential.
    //

    Status = AcquireCredentialsHandle(
                        NULL,                   // Name of principal
                        UNISP_NAME,           // Name of package
                        SECPKG_CRED_OUTBOUND,   // Flags indicating use
                        NULL,                   // Pointer to logon ID
                        NULL,          // Package specific data
                        NULL,                   // Pointer to GetKey() func
                        NULL,                   // Value to pass to GetKey()
                        phCreds,                // (out) Cred Handle
                        &tsExpiry);             // (out) Lifetime (optional)
    if(Status != SEC_E_OK)
    {
        XDBGTRC("Xonline", "**** Error 0x%x returned by AcquireCredentialsHandle", Status);
        return Status;
    }



    return SEC_E_OK;
}
#else

/*****************************************************************************/
static
SECURITY_STATUS
CreateCredentials(
    LPSTR pszUserName,              // in
    DWORD dwProtocol,               // in
    PCredHandle phCreds)            // out
{
    SCHANNEL_CRED   SchannelCred;
    TimeStamp       tsExpiry;
    SECURITY_STATUS Status;

    PCCERT_CONTEXT  pCertContext = NULL;

    // Open the "MY" certificate store, which is where Internet Explorer
    // stores its client certificates.
    if(hMyCertStore == NULL)
    {
        hMyCertStore = CertOpenSystemStore(0, TEXT("MY"));

        if(!hMyCertStore)
        {
            XDBGTRC("Xonline", "**** Error 0x%x returned by CertOpenSystemStore", 
                GetLastError());
            return SEC_E_NO_CREDENTIALS;
        }
    }

    //
    // If a user name is specified, then attempt to find a client
    // certificate. Otherwise, just create a NULL credential.
    //

    if(pszUserName && *pszUserName)
    {
        // Find client certificate. Note that this sample just searchs for a 
        // certificate that contains the user name somewhere in the subject name.
        // A real application should be a bit less casual.
        pCertContext = CertFindCertificateInStore(hMyCertStore, 
                                                  X509_ASN_ENCODING, 
                                                  0,
                                                  CERT_FIND_SUBJECT_STR_A,
                                                  pszUserName,
                                                  NULL);
        if(pCertContext == NULL)
        {
            XDBGTRC("Xonline", "**** Error 0x%x returned by CertFindCertificateInStore",
                GetLastError());
            return SEC_E_NO_CREDENTIALS;
        }
    }
    else if(fUseFortezza)
    {
        Status = GetFortezzaContext(&pCertContext);
        if(Status != SEC_E_OK)
        {
            return Status;
        }
    }


    //
    // Build Schannel credential structure. Currently, this sample only
    // specifies the protocol to be used (and optionally the certificate, 
    // of course). Real applications may wish to specify other parameters 
    // as well.
    //

    ZeroMemory(&SchannelCred, sizeof(SchannelCred));

    SchannelCred.dwVersion  = SCHANNEL_CRED_VERSION;
    if(pCertContext)
    {
        SchannelCred.cCreds     = 1;
        SchannelCred.paCred     = &pCertContext;
    }

//    SchannelCred.grbitEnabledProtocols = SP_PROT_SSL3;

    
    //
    // Create an SSPI credential.
    //

    Status = AcquireCredentialsHandle(
                        NULL,                   // Name of principal
                        UNISP_NAME,           // Name of package
                        SECPKG_CRED_OUTBOUND,   // Flags indicating use
                        NULL,                   // Pointer to logon ID
                        &SchannelCred,          // Package specific data
                        NULL,                   // Pointer to GetKey() func
                        NULL,                   // Value to pass to GetKey()
                        phCreds,                // (out) Cred Handle
                        &tsExpiry);             // (out) Lifetime (optional)
    if(Status != SEC_E_OK)
    {
        XDBGTRC("Xonline", "**** Error 0x%x returned by AcquireCredentialsHandle", Status);
        return Status;
    }


    //
    // Free the certificate context. Schannel has already made its own copy.
    //

    if(pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }


    return SEC_E_OK;
}


/*****************************************************************************/
static DWORD
GetFortezzaContext(PCCERT_CONTEXT *ppCertContext)
{
    DWORD           Status;
    HCRYPTPROV      hProv = 0;
    CRYPT_HASH_BLOB HashBlob;
    CRYPT_DATA_BLOB DataBlob;
    BYTE            rgbHash[20];
    DWORD           cbHash;
    PBYTE           pbChain = NULL;
    DWORD           cbChain;
    PBYTE           pbCert;
    DWORD           cbCert;
    PCCERT_CONTEXT  pCertContext = NULL;


    //
    // Attempt to log on to Fortezza card. This call will typically 
    // display a dialog box.
    //
    // Note that within the CryptAcquireContext function, the Fortezza
    // CSP populated the MY store with the Fortezza certificate chain.
    // At least, it will once it's finished.
    //

    if(!CryptAcquireContext(&hProv, NULL, NULL, PROV_FORTEZZA, 0))
    {
        Status = GetLastError();
        XDBGTRC("Xonline", "Error 0x%x logging onto Fortezza card", Status);
        goto done; 
    }


    //
    // Read the appropriate leaf certificate from the card, and
    // obtain its MD5 thumbprint.
    //

    // Get length of certificate chain.
    if(!CryptGetProvParam(hProv, PP_CERTCHAIN, NULL, &cbChain, 0))
    {
        Status = GetLastError();
        XDBGTRC("Xonline", "**** Error 0x%x reading certificate from CSP", Status);
        goto done; 
    }

    // Allocate memory for certificate chain.
    pbChain = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cbChain);
    if(pbChain == NULL)
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        XDBGTRC("Xonline", "**** Out of memory");
        goto done;
    }

    // Download certificate chain from CSP.
    if(!CryptGetProvParam(hProv, PP_CERTCHAIN, pbChain, &cbChain, 0))
    {
        Status = GetLastError();
        XDBGTRC("Xonline", "**** Error 0x%x reading certificate from CSP", Status);
        goto done;
    }

    // Parse out the leaf certificate.
    cbCert = *(PDWORD)pbChain;
    pbCert = pbChain + sizeof(DWORD);

    // Decode the leaf certificate.
    pCertContext = CertCreateCertificateContext(X509_ASN_ENCODING,
                                                pbCert,
                                                cbCert);
    if(pCertContext == NULL)
    {
        Status = GetLastError();
        XDBGTRC("Xonline", "**** Error 0x%x parsing certificate", Status);
        goto done;
    }

    // Get thumbprint of certificate.
    cbHash = sizeof(rgbHash);
    if(!CertGetCertificateContextProperty(pCertContext,
                                          CERT_MD5_HASH_PROP_ID,
                                          rgbHash,
                                          &cbHash))
    {
        Status = GetLastError();
        XDBGTRC("Xonline", "**** Error 0x%x reading MD5 property", Status);
        goto done;
    }

    // Free certificate chain.
    LocalFree(pbChain);
    pbChain = NULL;

    // Free certificate context.
    CertFreeCertificateContext(pCertContext);
    pCertContext = NULL;

    
    //
    // Search the "MY" certificate store for the certificate with
    // the matching thumbprint.
    //

    HashBlob.cbData = cbHash;
    HashBlob.pbData = rgbHash;
    pCertContext = CertFindCertificateInStore(hMyCertStore, 
                                              X509_ASN_ENCODING, 
                                              0,
                                              CERT_FIND_MD5_HASH,
                                              &HashBlob,
                                              NULL);
    if(pCertContext == NULL)
    {
        XDBGTRC("Xonline", "**** Leaf certificate not found in MY store");
        Status = SEC_E_NO_CREDENTIALS;
        goto done;
    }


    //
    // Attach the Fortezza hProv to the certificate context.
    //

    DataBlob.pbData = (PBYTE)&hProv;
    DataBlob.cbData = sizeof(hProv);

    if(!CertSetCertificateContextProperty(
            pCertContext,
            CERT_KEY_PROV_HANDLE_PROP_ID,
            0,
            &DataBlob))
    {
        Status = GetLastError();
        XDBGTRC("Xonline", "**** Error 0x%x setting KEY_PROV_HANDLE property", GetLastError());
        goto done;
    }
    hProv = 0;


    *ppCertContext = pCertContext;
    pCertContext = NULL;
    
    Status = SEC_E_OK;

done:

    if(pbChain) LocalFree(pbChain);
    if(hProv) CryptReleaseContext(hProv, 0);
    if(pCertContext) CertFreeCertificateContext(pCertContext);

    return Status;
}
#endif

/*****************************************************************************/
static INT
ConnectToServer(
    LPSTR    strServerName, // in
    INT      iPortNumber,   // in
    SOCKET * pSocket)       // out
{
    SOCKET Socket;
    struct sockaddr_in sin;
    struct hostent *hp;
    DWORD hostip;
    
    Socket = socket(PF_INET, SOCK_STREAM, 0);
    if(Socket == INVALID_SOCKET)
    {
        XDBGTRC("Xonline", "**** Error %d creating socket", WSAGetLastError());
        return WSAGetLastError();
    }

    if(fUseProxy)
    {
        sin.sin_family = AF_INET;
        sin.sin_port = ntohs((u_short)iProxyPort);

        if((hp = gethostbyname(pszProxyServer)) == NULL)
        {
            XDBGTRC("Xonline", "**** Error %d returned by gethostbyname", WSAGetLastError());
            return WSAGetLastError();
        }
        else
        {
            memcpy(&sin.sin_addr, hp->h_addr, 4);
        }
    }
    else
    {
        sin.sin_family = AF_INET;
        sin.sin_port = htons((u_short)iPortNumber);

        if((hp = gethostbyname(strServerName)) == NULL)
        {
            XDBGTRC("Xonline", "**** Error %d returned by gethostbyname", WSAGetLastError());
            return WSAGetLastError();
        }
        else
        {
            memcpy(&sin.sin_addr, hp->h_addr, 4);
        }
    }

    if(connect(Socket, (struct sockaddr *)&sin, sizeof(sin)) == SOCKET_ERROR)
    {
        XDBGTRC("Xonline", "**** Error %d connecting to \"%s\" (%s)", 
            WSAGetLastError(),
            strServerName, 
            inet_ntoa(sin.sin_addr));
        closesocket(Socket);
        return WSAGetLastError();
    }

    if(fUseProxy)
    {
        BYTE  pbMessage[200]; 
        DWORD cbMessage;

        // Build message for proxy server
        strcpy(pbMessage, "CONNECT ");
        strcat(pbMessage, strServerName);
        strcat(pbMessage, ":");
        _itoa(iPortNumber, pbMessage + strlen(pbMessage), 10);
        strcat(pbMessage, " HTTP/1.0\r\nUser-Agent: webclient\r\n\r\n");
        cbMessage = strlen(pbMessage);

        // Send message to proxy server
        if(send(Socket, pbMessage, cbMessage, 0) == SOCKET_ERROR)
        {
            XDBGTRC("Xonline", "**** Error %d sending message to proxy!", WSAGetLastError());
            return WSAGetLastError();
        }

        // Receive message from proxy server
        cbMessage = recv(Socket, pbMessage, 200, 0);
        if(cbMessage == SOCKET_ERROR)
        {
            XDBGTRC("Xonline", "**** Error %d receiving message from proxy", WSAGetLastError());
            return WSAGetLastError();
        }

        // BUGBUG - should continue to receive until CR LF CR LF is received
    }

    *pSocket = Socket;

    return SEC_E_OK;
}


/*****************************************************************************/
static
SECURITY_STATUS
PerformClientHandshake(
    SOCKET          Socket,         // in
    PCredHandle     phCreds,        // in
    LPTSTR          pszServerName,  // in
    CtxtHandle *    phContext,      // out
    SecBuffer *     pExtraData)     // out
{
    SecBufferDesc   OutBuffer;
    SecBuffer       OutBuffers[1];
    DWORD           dwSSPIFlags;
    DWORD           dwSSPIOutFlags;
    TimeStamp       tsExpiry;
    SECURITY_STATUS scRet;
    DWORD           cbData;
    DWORD   tElapsed;

    dwSSPIFlags = ISC_REQ_SEQUENCE_DETECT   |
                  ISC_REQ_REPLAY_DETECT     |
                  ISC_REQ_CONFIDENTIALITY   |
                  ISC_RET_EXTENDED_ERROR    |
                  ISC_REQ_ALLOCATE_MEMORY   |
                  ISC_REQ_STREAM;

//    dwSSPIFlags |= ISC_REQ_MANUAL_CRED_VALIDATION;

    //
    //  Initiate a ClientHello message and generate a token.
    //

    OutBuffers[0].pvBuffer   = NULL;
    OutBuffers[0].BufferType = SECBUFFER_TOKEN;
    OutBuffers[0].cbBuffer   = 0;

    OutBuffer.cBuffers = 1;
    OutBuffer.pBuffers = OutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    tElapsed = GetTickCount();

    scRet = InitializeSecurityContext(
                    phCreds,
                    NULL,
                    pszServerName,
                    dwSSPIFlags,
                    0,
                    SECURITY_NATIVE_DREP,
                    NULL,
                    0,
                    phContext,
                    &OutBuffer,
                    &dwSSPIOutFlags,
                    &tsExpiry);

    if (fTime)
    {
        tElapsed = GetTickCount() - tElapsed;
        XDBGTRC("Xonline", "ISC - %d ms",tElapsed);
    }
    if(scRet != SEC_I_CONTINUE_NEEDED)
    {
        XDBGTRC("Xonline", "**** Error %d returned by InitializeSecurityContext (1)", scRet);
        return scRet;
    }

    // Send response to server if there is one.
    if(OutBuffers[0].cbBuffer != 0 && OutBuffers[0].pvBuffer != NULL)
    {
        cbData = send(Socket,
                      OutBuffers[0].pvBuffer,
                      OutBuffers[0].cbBuffer,
                      0);
        if(cbData == SOCKET_ERROR || cbData == 0)
        {
            XDBGTRC("Xonline", "**** Error %d sending data to server (1)", WSAGetLastError());
            FreeContextBuffer(OutBuffers[0].pvBuffer);
            DeleteSecurityContext(phContext);
            return SEC_E_INTERNAL_ERROR;
        }

        XDBGTRC("Xonline", "%d bytes of handshake data sent", cbData);

        if(fVerbose)
        {
            PrintHexDump(cbData, OutBuffers[0].pvBuffer);
            XDBGTRC("Xonline", "");
        }

        // Free output buffer.
        FreeContextBuffer(OutBuffers[0].pvBuffer);
        OutBuffers[0].pvBuffer = NULL;
    }


    return ClientHandshakeLoop(Socket, phCreds, phContext, TRUE, pExtraData);
}

/*****************************************************************************/
static
SECURITY_STATUS
ClientHandshakeLoop(
    SOCKET          Socket,         // in
    PCredHandle     phCreds,        // in
    CtxtHandle *    phContext,      // in, out
    BOOL            fDoInitialRead, // in
    SecBuffer *     pExtraData)     // out
{
    SecBufferDesc   InBuffer;
    SecBuffer       InBuffers[2];
    SecBufferDesc   OutBuffer;
    SecBuffer       OutBuffers[1];
    DWORD           dwSSPIFlags;
    DWORD           dwSSPIOutFlags;
    TimeStamp       tsExpiry;
    SECURITY_STATUS scRet;
    DWORD           cbData;

    PUCHAR          IoBuffer;
    DWORD           cbIoBuffer;
    BOOL            fDoRead;
    DWORD           tElapsed;


    dwSSPIFlags = ISC_REQ_SEQUENCE_DETECT   |
                  ISC_REQ_REPLAY_DETECT     |
                  ISC_REQ_CONFIDENTIALITY   |
                  ISC_RET_EXTENDED_ERROR    |
                  ISC_REQ_ALLOCATE_MEMORY   |
                  ISC_REQ_STREAM;

//    dwSSPIFlags |= ISC_REQ_MANUAL_CRED_VALIDATION;

    //
    // Allocate data buffer.
    //

    IoBuffer = LocalAlloc(LMEM_FIXED, IO_BUFFER_SIZE);
    if(IoBuffer == NULL)
    {
        XDBGTRC("Xonline", "**** Out of memory (1)");
        return SEC_E_INTERNAL_ERROR;
    }
    cbIoBuffer = 0;

    fDoRead = fDoInitialRead;


    // 
    // Loop until the handshake is finished or an error occurs.
    //

    scRet = SEC_I_CONTINUE_NEEDED;

    while(scRet == SEC_I_CONTINUE_NEEDED        ||
          scRet == SEC_E_INCOMPLETE_MESSAGE     ||
          scRet == SEC_I_INCOMPLETE_CREDENTIALS) 
    {

        //
        // Read data from server.
        //

        if(0 == cbIoBuffer || scRet == SEC_E_INCOMPLETE_MESSAGE)
        {
            if(fDoRead)
            {
                tElapsed = GetTickCount();
                cbData = recv(Socket, 
                              IoBuffer + cbIoBuffer, 
                              IO_BUFFER_SIZE - cbIoBuffer, 
                              0);
                if(cbData == SOCKET_ERROR)
                {
                    XDBGTRC("Xonline", "**** Error %d reading data from server", WSAGetLastError());
                    scRet = SEC_E_INTERNAL_ERROR;
                    break;
                }
                else if(cbData == 0)
                {
                    XDBGTRC("Xonline", "**** Server unexpectedly disconnected");
                    scRet = SEC_E_INTERNAL_ERROR;
                    break;
                }


                if (fTime)
                {
                    tElapsed = GetTickCount() - tElapsed;
                    XDBGTRC("Xonline", "Response time - %d ms",tElapsed);
                }
                XDBGTRC("Xonline", "%d bytes of handshake data received", cbData);

                if (fDumpSSL)
                {
                    DumpSSL(cbIoBuffer + cbData, IoBuffer);
                }

                if(fVerbose)
                {
                    PrintHexDump(cbData, IoBuffer + cbIoBuffer);
                    XDBGTRC("Xonline", "");
                }

                cbIoBuffer += cbData;
            }
            else
            {
                fDoRead = TRUE;
            }
        }


        //
        // Set up the input buffers. Buffer 0 is used to pass in data
        // received from the server. Schannel will consume some or all
        // of this. Leftover data (if any) will be placed in buffer 1 and
        // given a buffer type of SECBUFFER_EXTRA.
        //

        InBuffers[0].pvBuffer   = IoBuffer;
        InBuffers[0].cbBuffer   = cbIoBuffer;
        InBuffers[0].BufferType = SECBUFFER_TOKEN;

        InBuffers[1].pvBuffer   = NULL;
        InBuffers[1].cbBuffer   = 0;
        InBuffers[1].BufferType = SECBUFFER_EMPTY;

        InBuffer.cBuffers       = 2;
        InBuffer.pBuffers       = InBuffers;
        InBuffer.ulVersion      = SECBUFFER_VERSION;

        //
        // Set up the output buffers. These are initialized to NULL
        // so as to make it less likely we'll attempt to free random
        // garbage later.
        //

        OutBuffers[0].pvBuffer  = NULL;
        OutBuffers[0].BufferType= SECBUFFER_TOKEN;
        OutBuffers[0].cbBuffer  = 0;

        OutBuffer.cBuffers      = 1;
        OutBuffer.pBuffers      = OutBuffers;
        OutBuffer.ulVersion     = SECBUFFER_VERSION;

        //
        // Call InitializeSecurityContext.
        //
        tElapsed = GetTickCount();
        scRet = InitializeSecurityContext(phCreds,
                                          phContext,
                                          NULL,
                                          dwSSPIFlags,
                                          0,
                                          SECURITY_NATIVE_DREP,
                                          &InBuffer,
                                          0,
                                          NULL,
                                          &OutBuffer,
                                          &dwSSPIOutFlags,
                                          &tsExpiry);


        if (fTime)
        {
            tElapsed = GetTickCount() - tElapsed;
            XDBGTRC("Xonline", "ISC - %d ms",tElapsed);
        }
        //
        // If InitializeSecurityContext was successful (or if the error was 
        // one of the special extended ones), send the contends of the output
        // buffer to the server.
        //

        if(scRet == SEC_E_OK                ||
           scRet == SEC_I_CONTINUE_NEEDED   ||
           FAILED(scRet) && (dwSSPIOutFlags & ISC_RET_EXTENDED_ERROR))
        {
            if(OutBuffers[0].cbBuffer != 0 && OutBuffers[0].pvBuffer != NULL)
            {
                cbData = send(Socket,
                              OutBuffers[0].pvBuffer,
                              OutBuffers[0].cbBuffer,
                              0);
                if(cbData == SOCKET_ERROR || cbData == 0)
                {
                    XDBGTRC("Xonline", "**** Error %d sending data to server (2)", 
                        WSAGetLastError());
                    FreeContextBuffer(OutBuffers[0].pvBuffer);
                    DeleteSecurityContext(phContext);
                    return SEC_E_INTERNAL_ERROR;
                }

                XDBGTRC("Xonline", "%d bytes of handshake data sent", cbData);

                   if (fDumpSSL)
                {
                    DumpSSL(cbData, OutBuffers[0].pvBuffer);
                }

                if(fVerbose)
                {
                    PrintHexDump(cbData, OutBuffers[0].pvBuffer);
                    XDBGTRC("Xonline", "");
                }

                // Free output buffer.
                FreeContextBuffer(OutBuffers[0].pvBuffer);
                OutBuffers[0].pvBuffer = NULL;
            }
        }


        //
        // If InitializeSecurityContext returned SEC_E_INCOMPLETE_MESSAGE,
        // then we need to read more data from the server and try again.
        //

        if(scRet == SEC_E_INCOMPLETE_MESSAGE)
        {
            continue;
        }


        //
        // If InitializeSecurityContext returned SEC_E_OK, then the 
        // handshake completed successfully.
        //

        if(scRet == SEC_E_OK)
        {
            //
            // If the "extra" buffer contains data, this is encrypted application
            // protocol layer stuff. It needs to be saved. The application layer
            // will later decrypt it with DecryptMessage.
            //

            XDBGTRC("Xonline", "Handshake was successful");

            if(InBuffers[1].BufferType == SECBUFFER_EXTRA)
            {
                pExtraData->pvBuffer = LocalAlloc(LMEM_FIXED, 
                                                  InBuffers[1].cbBuffer);
                if(pExtraData->pvBuffer == NULL)
                {
                    XDBGTRC("Xonline", "**** Out of memory (2)");
                    return SEC_E_INTERNAL_ERROR;
                }

                memmove(pExtraData->pvBuffer,
                           IoBuffer + (cbIoBuffer - InBuffers[1].cbBuffer),
                           InBuffers[1].cbBuffer);

                pExtraData->cbBuffer   = InBuffers[1].cbBuffer;
                pExtraData->BufferType = SECBUFFER_TOKEN;

                XDBGTRC("Xonline", "%d bytes of app data was bundled with handshake data",
                    pExtraData->cbBuffer);
            }
            else
            {
                pExtraData->pvBuffer   = NULL;
                pExtraData->cbBuffer   = 0;
                pExtraData->BufferType = SECBUFFER_EMPTY;
            }

            //
            // Bail out to quit
            //

            break;
        }


        //
        // Check for fatal error.
        //

        if(FAILED(scRet))
        {
            XDBGTRC("Xonline", "**** Error 0x%x returned by InitializeSecurityContext (2)", scRet);
            break;
        }


        //
        // If InitializeSecurityContext returned SEC_I_INCOMPLETE_CREDENTIALS,
        // then the server just requested client authentication. 
        //

        if(scRet == SEC_I_INCOMPLETE_CREDENTIALS)
        {
            //
            // Now would be a good time perhaps to prompt the user to select
            // a client certificate and obtain a new credential handle, 
            // but I don't have the energy nor inclination.
            //
            // As this is currently written, Schannel will send a "no 
            // certificate" alert to the server in place of a certificate. 
            // The server might be cool with this, or it might drop the 
            // connection.
            // 

            // Go around again.
            fDoRead = FALSE;
            scRet = SEC_I_CONTINUE_NEEDED;
        }


        //
        // Copy any leftover data from the "extra" buffer, and go around
        // again.
        //

        if ( InBuffers[1].BufferType == SECBUFFER_EXTRA )
        {
            memmove(IoBuffer,
                       IoBuffer + (cbIoBuffer - InBuffers[1].cbBuffer),
                       InBuffers[1].cbBuffer);

            cbIoBuffer = InBuffers[1].cbBuffer;
        }
        else
        {
            cbIoBuffer = 0;
        }
    }

    // Delete the security context in the case of a fatal error.
    if(FAILED(scRet))
    {
        DeleteSecurityContext(phContext);
    }

    LocalFree(IoBuffer);

    return scRet;
}


/*****************************************************************************/
static
HRESULT
HttpsGet(
    SOCKET Socket,
    PCredHandle phCreds,
    CtxtHandle *phContext,
    const XRL xrl,
    DWORD* pcbBuffer,
    PBYTE pBuffer,
    XRL_KNOWN_HEADERS *pHTTPHeaders,
    PXAPPSERVICEINFO pServiceInfo)
{
    SecPkgContext_StreamSizes Sizes;
    SECURITY_STATUS scRet;
    SecBufferDesc   Message;
    SecBuffer       Buffers[4];
    SecBuffer *     pDataBuffer;
    SecBuffer *     pExtraBuffer;
    SecBuffer       ExtraBuffer;
    //PFSealMessage    pfSealMessage;
    //PFUnsealMessage    pfUnsealMessage;

    PBYTE pbIoBuffer;
    DWORD cbIoBuffer;
    DWORD cbIoBufferLength;
    PBYTE pbMessage;
    DWORD cbMessage;

    HRESULT hr;
    DWORD cbData;
    INT   i;
    BOOL  fHeaderParsed = FALSE;
    DWORD cbBuffer = 0;
    PBYTE pHeaderEnd;
    PBYTE pHeaderStart = pBuffer;
    
    //
    // Read stream encryption properties.
    //

    scRet = QueryContextAttributes(phContext,
                                   SECPKG_ATTR_STREAM_SIZES,
                                   &Sizes);
    if(scRet != SEC_E_OK)
    {
        XDBGTRC("Xonline", "**** Error 0x%x reading SECPKG_ATTR_STREAM_SIZES", scRet);
        return scRet;
    }

    XDBGTRC("Xonline", "Header: %d, Trailer: %d, MaxMessage: %d",
        Sizes.cbHeader,
        Sizes.cbTrailer,
        Sizes.cbMaximumMessage);

    //
    // Allocate a working buffer. The plaintext sent to EncryptMessage
    // should never be more than 'Sizes.cbMaximumMessage', so a buffer 
    // size of this plus the header and trailer sizes should be safe enough.
    // 

    cbIoBufferLength = Sizes.cbHeader + 
                       Sizes.cbMaximumMessage +
                       Sizes.cbTrailer;

    pbIoBuffer = LocalAlloc(LMEM_FIXED, cbIoBufferLength);
    if(pbIoBuffer == NULL)
    {
        XDBGTRC("Xonline", "Out of memory (2)");
        return SEC_E_INTERNAL_ERROR;
    }

    // Build the HTTP request offset into the data buffer by "header size"
    // bytes. This enables Schannel to perform the encryption in place,
    // which is a significant performance win.
    pbMessage = pbIoBuffer + Sizes.cbHeader;

    //
    // Build an HTTP request to send to the server.
    //
    cbMessage = Sizes.cbMaximumMessage;
    hr = XRL_BuildGetRequest( pbMessage, &cbMessage, xrl, NULL, pServiceInfo );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    XDBGTRC("Xonline", "Sending plaintext: %d bytes", cbMessage);

    if(fVerbose)
    {
        PrintHexDump(cbMessage, pbMessage);
        XDBGTRC("Xonline", "");
    }

    //
    // Encrypt the HTTP request.
    //

    Buffers[0].pvBuffer     = pbIoBuffer;
    Buffers[0].cbBuffer     = Sizes.cbHeader;
    Buffers[0].BufferType   = SECBUFFER_STREAM_HEADER;

    Buffers[1].pvBuffer     = pbMessage;
    Buffers[1].cbBuffer     = cbMessage;
    Buffers[1].BufferType   = SECBUFFER_DATA;

    Buffers[2].pvBuffer     = pbMessage + cbMessage;
    Buffers[2].cbBuffer     = Sizes.cbTrailer;
    Buffers[2].BufferType   = SECBUFFER_STREAM_TRAILER;

    Buffers[3].BufferType   = SECBUFFER_EMPTY;

    Message.ulVersion       = SECBUFFER_VERSION;
    Message.cBuffers        = 4;
    Message.pBuffers        = Buffers;

#ifdef XBOX
    scRet = SealMessage(phContext, 0, &Message, 0);
#else
    pfSealMessage = (PFSealMessage) Reserved3;
    scRet = (*pfSealMessage)(phContext, 0, &Message, 0);
#endif

    if(FAILED(scRet))
    {
        XDBGTRC("Xonline", "Error 0x%x returned by EncryptMessage", scRet);
        hr = HRESULT_FROM_WIN32( scRet );
        goto Cleanup;
    }


    // 
    // Send the encrypted data to the server.
    //

    cbData = send(Socket,
                  pbIoBuffer,
                  Buffers[0].cbBuffer + Buffers[1].cbBuffer + Buffers[2].cbBuffer,
                  0);
    if(cbData == SOCKET_ERROR || cbData == 0)
    {
        XDBGTRC("Xonline", "**** Error %d sending data to server (3)", 
            WSAGetLastError());
        DeleteSecurityContext(phContext);
        hr = HRESULT_FROM_WIN32( SEC_E_INTERNAL_ERROR );
        goto Cleanup;
    }

    XDBGTRC("Xonline", "%d bytes of application data sent", cbData);

    if(fVerbose)
    {
        PrintHexDump(cbData, pbIoBuffer);
        XDBGTRC("Xonline", "");
    }

    //
    // Read data from server until done.
    //

    cbIoBuffer = 0;

    while(TRUE)
    {
        //
        // Read some data.
        //

        if(0 == cbIoBuffer || scRet == SEC_E_INCOMPLETE_MESSAGE)
        {
            cbData = recv(Socket, 
                          pbIoBuffer + cbIoBuffer, 
                          cbIoBufferLength - cbIoBuffer, 
                          0);
            if(cbData == SOCKET_ERROR)
            {
                hr = HRESULT_FROM_WIN32( WSAGetLastError() );
                XDBGTRC("Xonline", "Error %x reading data from server", hr);
                break;
            }
            else if(cbData == 0)
            {
                // Server disconnected.
                if(cbIoBuffer)
                {
                    XDBGTRC("Xonline", "Server unexpectedly disconnected");
                    hr = E_FAIL;
                    goto Cleanup;
                }
                else
                {
                    // This is the normal way to terminate the while loop
                    break;
                }
            }
            else
            {
                XDBGTRC("Xonline", "%d bytes of application data received", cbData);

                if(fVerbose)
                {
                    PrintHexDump(cbData, pbIoBuffer + cbIoBuffer);
                    XDBGTRC("Xonline", "");
                }

                cbIoBuffer += cbData;
            }
        }

        // 
        // Attempt to decrypt the received data.
        //

        Buffers[0].pvBuffer     = pbIoBuffer;
        Buffers[0].cbBuffer     = cbIoBuffer;
        Buffers[0].BufferType   = SECBUFFER_DATA;

        Buffers[1].BufferType   = SECBUFFER_EMPTY;
        Buffers[2].BufferType   = SECBUFFER_EMPTY;
        Buffers[3].BufferType   = SECBUFFER_EMPTY;

        Message.ulVersion       = SECBUFFER_VERSION;
        Message.cBuffers        = 4;
        Message.pBuffers        = Buffers;

#ifdef XBOX
        scRet = UnsealMessage(phContext, &Message, 0, NULL);
#else
        pfUnsealMessage = (PFUnsealMessage) Reserved4;
        scRet = (*pfUnsealMessage)(phContext, &Message, 0, NULL);
#endif

        if(scRet == SEC_E_INCOMPLETE_MESSAGE)
        {
            // The input buffer contains only a fragment of an
            // encrypted record. Loop around and read some more
            // data.
            continue;
        }

        if(scRet != SEC_E_OK && scRet != SEC_I_RENEGOTIATE)
        {
            XDBGTRC("Xonline", "Error 0x%x returned by UnsealMessage", scRet);
            hr = HRESULT_FROM_WIN32( scRet );
            goto Cleanup;
        }

        // Locate data and (optional) extra buffers.
        pDataBuffer  = NULL;
        pExtraBuffer = NULL;
        for(i = 1; i < 4; i++)
        {
            if(pDataBuffer == NULL && Buffers[i].BufferType == SECBUFFER_DATA)
            {
                pDataBuffer = &Buffers[i];
            }
            if(pExtraBuffer == NULL && Buffers[i].BufferType == SECBUFFER_EXTRA)
            {
                pExtraBuffer = &Buffers[i];
            }
        }

        // Display or otherwise process the decrypted data.
        if(pDataBuffer)
        {
            // Check if enough space in buffer
            // Make sure we always have one extra byte for a termination character.
            if (*pcbBuffer - cbBuffer > pDataBuffer->cbBuffer)
            {
                memmove(pBuffer, pDataBuffer->pvBuffer, pDataBuffer->cbBuffer);
                pBuffer += pDataBuffer->cbBuffer;
                cbBuffer += pDataBuffer->cbBuffer;
            }
            else
            {
                XDBGTRC("Xonline", "Error HttpsGet buffer too small");
                hr = HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER );
                goto Cleanup;
            }
            
            if (!fHeaderParsed)
            {
                // Null terminate to make sure strstr works
                pHeaderStart[ cbBuffer ] = '\0';
                pHeaderEnd = strstr( pHeaderStart, "\r\n\r\n" );                

                if (pHeaderEnd)
                {
                    // Calculate length of header
                    cbData = pHeaderEnd - pHeaderStart + 4;

                    // Parse the header
                    hr = XRL_ParseHeaders( pHeaderStart, cbData, pHTTPHeaders, pServiceInfo );
                    if ( FAILED(hr) )
                    {
                        XDBGTRC("Xonline", "Error 0x%x returned by XRL_ParseHeaders", hr );
                        goto Cleanup;
                    }
                    
                    fHeaderParsed = TRUE;

                    // Header is parsed, shift buffer to reuse header memory
                    memmove( pHeaderStart, pBuffer, cbBuffer - cbData );
                    cbBuffer -= cbData;
                    pBuffer = pHeaderStart + cbBuffer;
                }                
            }

            XDBGTRC("Xonline", "Received plaintext: %d bytes", pDataBuffer->cbBuffer);
            PrintHexDump(pDataBuffer->cbBuffer, pDataBuffer->pvBuffer);
        }

        // Move any "extra" data to the input buffer.
        if(pExtraBuffer)
        {
            memmove(pbIoBuffer, pExtraBuffer->pvBuffer, pExtraBuffer->cbBuffer);
            cbIoBuffer = pExtraBuffer->cbBuffer;
        }
        else
        {
            cbIoBuffer = 0;
        }
       
        if(scRet == SEC_I_RENEGOTIATE)
        {
            // The server wants to perform another handshake
            // sequence.

            XDBGTRC("Xonline", "Server requested renegotiate!");

            scRet = ClientHandshakeLoop(Socket, 
                                        phCreds, 
                                        phContext, 
                                        FALSE, 
                                        &ExtraBuffer);
            if(scRet != SEC_E_OK)
            {
                hr = HRESULT_FROM_WIN32( scRet );
                goto Cleanup;
            }

            // Move any "extra" data to the input buffer.
            if(ExtraBuffer.pvBuffer)
            {
                memmove(pbIoBuffer, ExtraBuffer.pvBuffer, ExtraBuffer.cbBuffer);
                cbIoBuffer = ExtraBuffer.cbBuffer;
            }
        }
    }

    if (fHeaderParsed)
    {
        *pcbBuffer = cbBuffer;
    }
    else
    {
        XDBGTRC("Xonline", "No header");
        hr = E_FAIL;
        goto Cleanup;        
    }

    hr = S_OK;
    
Cleanup:
    LocalFree( pbIoBuffer );
    
    return hr;
}

#ifndef UNDER_CE
/*****************************************************************************/
static 
void
DisplayCertChain(
    PCCERT_CONTEXT pServerCert)
{
    TCHAR szName[1000];
    PCCERT_CONTEXT pCurrentCert;
    PCCERT_CONTEXT pIssuerCert;
    DWORD dwVerificationFlags;
    PCERT_ENHKEY_USAGE pEnhKeyUsage = NULL;
    UINT cbUsage, i;

    XDBGTRC("Xonline", "");

    // display leaf name
    if(!CertNameToStr(pServerCert->dwCertEncodingType,
                      &pServerCert->pCertInfo->Subject,
                      CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG,
                      szName, sizeof(szName)))
    {
        XDBGTRC("Xonline", "**** Error 0x%x building subject name", GetLastError());
    }
    XDBGTRC("Xonline", "Server subject: %s", szName);
    if(!CertNameToStr(pServerCert->dwCertEncodingType,
                      &pServerCert->pCertInfo->Issuer,
                      CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG,
                      szName, sizeof(szName)))
    {
        XDBGTRC("Xonline", "**** Error 0x%x building issuer name", GetLastError());
    }
    XDBGTRC("Xonline", "Server issuer: %s\n", szName);

    if (CertGetEnhancedKeyUsage(
            pServerCert,  // in - Pointer to the certificate
            0,       // in - Extension only flag
            NULL,        // out- Pointer to enhanced key usage
            &cbUsage))     // in/out - Size of enhanced key usage
    {
        pEnhKeyUsage = LocalAlloc(0,cbUsage);
        if (CertGetEnhancedKeyUsage(
                pServerCert,  // in - Pointer to the certificate
                0,       // in - Extension only flag
                pEnhKeyUsage,        // out- Pointer to enhanced key usage
                &cbUsage))     // in/out - Size of enhanced key usage
        {
            for (i=0;i<pEnhKeyUsage->cUsageIdentifier;i++)
            {
                XDBGTRC("Xonline", "Enhanced Key Usage : %s",pEnhKeyUsage->rgpszUsageIdentifier[i]);
            }
        }
    }

    // display certificate chain
    pCurrentCert = pServerCert;
    while(pCurrentCert != NULL)
    {
        dwVerificationFlags = 0;
        pIssuerCert = CertGetIssuerCertificateFromStore(pServerCert->hCertStore,
                                                        pCurrentCert,
                                                        NULL,
                                                        &dwVerificationFlags);
        if(pIssuerCert == NULL)
        {
            if(pCurrentCert != pServerCert)
            {
                CertFreeCertificateContext(pCurrentCert);
            }
            break;
        }

        if(!CertNameToStr(pIssuerCert->dwCertEncodingType,
                          &pIssuerCert->pCertInfo->Subject,
                          CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG,
                          szName, sizeof(szName)))
        {
            XDBGTRC("Xonline", "**** Error 0x%x building subject name", GetLastError());
        }
        XDBGTRC("Xonline", "CA subject: %s", szName);
        if(!CertNameToStr(pIssuerCert->dwCertEncodingType,
                          &pIssuerCert->pCertInfo->Issuer,
                          CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG,
                          szName, sizeof(szName)))
        {
            XDBGTRC("Xonline", "**** Error 0x%x building issuer name", GetLastError());
        }
        XDBGTRC("Xonline", "CA issuer: %s\n", szName);

        if(pCurrentCert != pServerCert)
        {
            CertFreeCertificateContext(pCurrentCert);
        }
        pCurrentCert = pIssuerCert;
        pIssuerCert = NULL;
    }
}

#endif

#if 0
/*****************************************************************************/
static 
DWORD
VerifyServerCertificate(
    PCCERT_CONTEXT  pServerCert,
    PSTR            pszServerName,
    DWORD           dwCertFlags)
{
    GUID                    gHTTPS = HTTPSPROV_ACTION;
    WINTRUST_DATA           sWTD;
    WINTRUST_CERT_INFO      sWTCI;
    HTTPSPolicyCallbackData polHttps;
    DWORD                   Status;
    SECURITY_STATUS         scRet;
    PWSTR                   pwszServerName;
    DWORD                   cchServerName;

    if(pServerCert == NULL)
    {
        return SEC_E_WRONG_PRINCIPAL;
    }
    if(pszServerName == NULL || strlen(pszServerName) == 0)
    {
        return SEC_E_WRONG_PRINCIPAL;
    }

    // Convert server name to unicode.
    cchServerName = MultiByteToWideChar(CP_ACP, 0, pszServerName, -1, NULL, 0);
    pwszServerName = LocalAlloc(LMEM_FIXED, cchServerName * sizeof(WCHAR));
    if(pwszServerName == NULL)
    {
        return SEC_E_INSUFFICIENT_MEMORY;
    }
    cchServerName = MultiByteToWideChar(CP_ACP, 0, pszServerName, -1, pwszServerName, cchServerName);
    if(cchServerName == 0)
    {
        return SEC_E_WRONG_PRINCIPAL;
    }

    ZeroMemory(&sWTD, sizeof(WINTRUST_DATA));
    sWTD.cbStruct               = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice             = WTD_UI_NONE;
    sWTD.pPolicyCallbackData    = (LPVOID)&polHttps;
    sWTD.dwUnionChoice          = WTD_CHOICE_CERT;
    sWTD.pCert                  = &sWTCI;
    sWTD.pwszURLReference       = NULL;

    ZeroMemory(&sWTCI, sizeof(WINTRUST_CERT_INFO));
    sWTCI.cbStruct              = sizeof(WINTRUST_CERT_INFO);
    sWTCI.psCertContext         = (CERT_CONTEXT *)pServerCert;
    sWTCI.chStores              = 1;
    sWTCI.pahStores             = (HCERTSTORE *)&pServerCert->hCertStore;
    sWTCI.pcwszDisplayName      = pwszServerName;

    ZeroMemory(&polHttps, sizeof(HTTPSPolicyCallbackData));
    polHttps.cbStruct           = sizeof(HTTPSPolicyCallbackData);
    polHttps.dwAuthType         = AUTHTYPE_SERVER;
    polHttps.fdwChecks          = dwCertFlags;
    polHttps.pwszServerName     = pwszServerName;


    Status = WinVerifyTrust(NULL, &gHTTPS, &sWTD);

    LocalFree(pwszServerName);
    pwszServerName = NULL;

    if(Status != ERROR_SUCCESS)
    {
        XDBGTRC("Xonline", "**** Error 0x%x returned by WinVerifyTrust", Status);
    }

    return Status;
}
#endif


/*****************************************************************************/

void
DisplayConnectionInfo(
    SecPkgContext_ConnectionInfo *pConnectionInfo)
{
    

    XDBGTRC("Xonline", "");

    switch(pConnectionInfo->dwProtocol)
    {
        case SP_PROT_SSL3_CLIENT:
            XDBGTRC("Xonline", "Protocol: SSL3");
            break;

        case SP_PROT_PCT1_CLIENT:
            XDBGTRC("Xonline", "Protocol: PCT");
            break;

        case SP_PROT_SSL2_CLIENT:
            XDBGTRC("Xonline", "Protocol: SSL2");
            break;

        default:
            XDBGTRC("Xonline", "Protocol: 0x%x", pConnectionInfo->dwProtocol);
    }

    switch(pConnectionInfo->aiCipher)
    {
        case CALG_RC4: 
            XDBGTRC("Xonline", "Cipher: RC4");
            break;

        case CALG_3DES: 
            XDBGTRC("Xonline", "Cipher: Triple DES");
            break;

        case CALG_RC2: 
            XDBGTRC("Xonline", "Cipher: RC2");
            break;

        case CALG_DES: 
            XDBGTRC("Xonline", "Cipher: DES");
            break;

        case CALG_SKIPJACK: 
            XDBGTRC("Xonline", "Cipher: Skipjack");
            break;

        default: 
            XDBGTRC("Xonline", "Cipher: 0x%x", pConnectionInfo->aiCipher);
    }

    XDBGTRC("Xonline", "Cipher strength: %d", pConnectionInfo->dwCipherStrength);

    switch(pConnectionInfo->aiHash)
    {
        case CALG_MD5: 
            XDBGTRC("Xonline", "Hash: MD5");
            break;

        case CALG_SHA: 
            XDBGTRC("Xonline", "Hash: SHA");
            break;

        default: 
            XDBGTRC("Xonline", "Hash: 0x%x", pConnectionInfo->aiHash);
    }

    XDBGTRC("Xonline", "Hash strength: %d", pConnectionInfo->dwHashStrength);

    switch(pConnectionInfo->aiExch)
    {
        case CALG_RSA_KEYX: 
        case CALG_RSA_SIGN: 
            XDBGTRC("Xonline", "Key exchange: RSA");
            break;

        case CALG_KEA_KEYX: 
            XDBGTRC("Xonline", "Key exchange: KEA");
            break;

        default: 
            XDBGTRC("Xonline", "Key exchange: 0x%x", pConnectionInfo->aiExch);
    }

    XDBGTRC("Xonline", "Key exchange strength: %d", pConnectionInfo->dwExchStrength);
}

typedef struct {
    BYTE contentType;
    BYTE majVer;
    BYTE minVer;
    BYTE lenHi;
    BYTE lenLo;
} SSL3HDR;

LPTSTR rszAlertLevel[] = {TEXT("Warning"),TEXT("Fatal")};
LPTSTR AlertType(UINT alertType)
{
    switch (alertType)
    {
    case 0:        return TEXT("close_notify");
    case 10:    return TEXT("unexpected_message");
    case 20:    return TEXT("bad_record_mac");
    case 30:    return TEXT("decompression_failure");
    case 40:    return TEXT("handshake_failure");
    case 41:    return TEXT("no_certificate");
    case 42:    return TEXT("bad_certificate");
    case 43:    return TEXT("unsupported_certificate");
    case 44:    return TEXT("certificate_revoked");
    case 45:    return TEXT("certificate_expired");
    case 46:    return TEXT("certificate_unknown");
    case 47:    return TEXT("illegal_parameter");
    default:
        break;
    }
    return TEXT("unknown alert type!");
}
static int
DumpSSL3Handshake(int length, const BYTE *buffer, int *pUsed, TCHAR szDump[])
{
    int cszDump = wsprintf(szDump,TEXT("Handshake: "));
    int cbMsg =(((int)buffer[1]) << 16)
                + (((int)buffer[2])<<8)
                + buffer[3];
    
    if (cbMsg > length-4)
    {
        cszDump += wsprintf(szDump+cszDump,TEXT("?\n"));
        *pUsed = length;
        return cszDump;
    }
    switch(buffer[0])
    {
    case 0:
        cszDump += wsprintf(szDump+cszDump,TEXT("hello_request"));
        break;
    case 1:
        cszDump += wsprintf(szDump+cszDump,TEXT("client_hello"));
        break;
    case 2:
        cszDump += wsprintf(szDump+cszDump,TEXT("server_hello"));
        break;
    case 11:
        cszDump += wsprintf(szDump+cszDump,TEXT("certificate"));
        break;
    case 12:
        cszDump += wsprintf(szDump+cszDump,TEXT("server_key_exchange"));
        break;
    case 13:
        cszDump += wsprintf(szDump+cszDump,TEXT("certificate_request"));
        break;
    case 14:
        cszDump += wsprintf(szDump+cszDump,TEXT("server_hello_done"));
        break;
    case 15:
        cszDump += wsprintf(szDump+cszDump,TEXT("certificate_verify"));
        break;
    case 16:
        cszDump += wsprintf(szDump+cszDump,TEXT("client_key_exchange"));
        break;
    case 20:
        cszDump += wsprintf(szDump+cszDump,TEXT("finished"));
        break;
    default:
        cszDump += wsprintf(szDump+cszDump,TEXT("Unknown HS type!"));
        break;
    }
    cszDump += wsprintf(szDump+cszDump,TEXT("\n"));
    *pUsed = cbMsg+4; 
    return cszDump;
}

typedef enum {
    CCS_TYPE = 20,
    ALERT_TYPE = 21,
    HANDSHAKE_TYPE = 22,
    APPDATA_TYPE = 23
} SSL3MsgTypes;

static void
DumpSSL(DWORD length, const BYTE *buffer)
{
    int cbLeft = (int) length;
    int cbContent;
    TCHAR szDump[2048];
    while (cbLeft > sizeof(SSL3HDR)) {
        int cszDump = 0;
        SSL3HDR *pSSL3Hdr = (SSL3HDR *) buffer;
        cbLeft -= sizeof(SSL3HDR);
        buffer += sizeof(SSL3HDR);
        cbContent = (((int)pSSL3Hdr->lenHi) << 8) + pSSL3Hdr->lenLo;
        if (cbLeft < cbContent)
            break;    // dont have the full message

        cbLeft -= cbContent;

        if (pSSL3Hdr->majVer != 3 && pSSL3Hdr->minVer != 0)
            break;    // only know about SSL3

        while (cbContent > 0)
        {
            cszDump = wsprintf(szDump, TEXT("SSL3 (%d bytes): "),cbContent);
            switch (pSSL3Hdr->contentType)
            {
            case CCS_TYPE:
                cszDump += wsprintf(szDump+cszDump,TEXT("Change Cipher Spec\n"));
                if (buffer[0] == 1)    // plaintext CCS msg
                {
                    cbContent -= 1;        // sizeof(CCS)
                    buffer += 1;
                } else // probably encrypted
                {
                    buffer += cbContent;
                    cbContent = 0;
                }
                break;
            case ALERT_TYPE:
                {
                UINT alertLevel = buffer[0];
                UINT alertType = buffer[1];
                if (alertLevel - 1 <= 1 )
                    cszDump += wsprintf(szDump+cszDump, TEXT("Alert : %s : %s\n"), rszAlertLevel[alertLevel-1], AlertType(alertType));
                cbContent -= 2;        // sizeof(ALERT)
                buffer += 2;
                break;
                }
            case HANDSHAKE_TYPE:
                {
                int cbContentUsed = 0;
                cszDump += DumpSSL3Handshake(cbContent, buffer, &cbContentUsed,szDump+cszDump);
                cbContent -= cbContentUsed;
                buffer += cbContentUsed;
                break;
                }

            case APPDATA_TYPE:
                cszDump += wsprintf(szDump+cszDump, TEXT("App Data\n"));
                buffer += cbContent;
                break;
            default:
                cszDump += wsprintf(szDump+cszDump,TEXT("Unknown Record!\n"));
                cbLeft = -1;
                cbContent = 0;
                break;
            }
            // XDBGTRC("Xonline", "%s", szDump);
        }
    }
}

/*****************************************************************************/
void 
PrintHexDump(DWORD length, PBYTE buffer)
{
    DWORD i,count,index;
    CHAR rgbDigits[]="0123456789abcdef";
    CHAR rgbLine[100];
    char cbLine;

    for(index = 0; length; length -= count, buffer += count, index += count) 
    {
        count = (length > 16) ? 16:length;

        sprintf(rgbLine, "%4.4x  ",index);
        cbLine = 6;

        for(i=0;i<count;i++) 
        {
            rgbLine[cbLine++] = rgbDigits[buffer[i] >> 4];
            rgbLine[cbLine++] = rgbDigits[buffer[i] & 0x0f];
            if(i == 7) 
            {
                rgbLine[cbLine++] = ':';
            } 
            else 
            {
                rgbLine[cbLine++] = ' ';
            }
        }
        for(; i < 16; i++) 
        {
            rgbLine[cbLine++] = ' ';
            rgbLine[cbLine++] = ' ';
            rgbLine[cbLine++] = ' ';
        }

        rgbLine[cbLine++] = ' ';

        for(i = 0; i < count; i++) 
        {
            if(buffer[i] < 32 || buffer[i] > 126) 
            {
                rgbLine[cbLine++] = '.';
            } 
            else 
            {
                rgbLine[cbLine++] = buffer[i];
            }
        }

        rgbLine[cbLine++] = 0;
        XDBGTRC("Xonline", "%s", rgbLine);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\md2.h ===
/* Copyright (C) 1990-2, RSA Data Security, Inc. Created 1990. All
   rights reserved.

   License to copy and use this software is granted for
   non-commercial Internet Privacy-Enhanced Mail provided that it is
   identified as the "RSA Data Security, Inc. MD2 Message Digest
   Algorithm" in all material mentioning or referencing this software
   or this function.

   RSA Data Security, Inc. makes no representations concerning either
   the merchantability of this software or the suitability of this
   software for any particular purpose. It is provided "as is"
   without express or implied warranty of any kind.

   These notices must be retained in any copies of any part of this
   documentation and/or software.
 */


typedef struct {
  unsigned char state[16];                                 /* state */
  unsigned char checksum[16];                           /* checksum */
  unsigned int count;                 /* number of bytes, modulo 16 */
  unsigned char buffer[16];                         /* input buffer */
} MD2_CTX;

int MD2Update(MD2_CTX *, unsigned char *, unsigned int);
int MD2Final(MD2_CTX *);
void MD2Transform(unsigned char [16], unsigned char [16],
                  unsigned char [16]);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\libmain.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       pctsspi.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-01-95   RichardW   Created
//              8-13-95   TerenceS   Mutated to PCT
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <security.h>
#include <certmap.h>
#include "spsspi.h"

#ifndef XBOX
CRITICAL_SECTION    csSsl;
#endif
BOOLEAN             CryptoOk;

DWORD g_ProtSupported = SP_PROT_ALL;

#if DBG
DWORD csSslOwner;

DWORD   csPctOwner;

#endif

#ifdef DEBUG

DBGPARAM dpCurSettings =
    {
        TEXT("Schannel"),
        {
            TEXT("Init"),       TEXT("ServerCache"),
            TEXT("RNG"),        TEXT("CertMgmt"),
            TEXT("Undefined"),  TEXT("Undefined"),
            TEXT("Undefined"),  TEXT("Undefined"),
            TEXT("Undefined"),  TEXT("Undefined"),
            TEXT("Undefined"),  TEXT("Undefined"),
            TEXT("Undefined"),  TEXT("Undefined"),
            TEXT("Warning"),    TEXT("Error")
        },
        0x0000c000
    };

char aszDebugDump[512];
void    CESPDebugLog(long fDebug, const char *szFormat, ...)
{
#if 0   // vsprintf not in all projects
    va_list paramlist;
    va_start(paramlist,szFormat);
    vsprintf(aszDebugDump,szFormat,paramlist);
    DEBUGMSG(fDebug,(TEXT("%a"),aszDebugDump));
#endif
}


#endif // DEBUG

// MyStrToL
//      Can't use CRT routines, so steal from the C runtime sources

DWORD MyStrToL(CHAR *InStr)
{
	DWORD dwVal = 0;

	while(*InStr)
	{
		dwVal = (10 * dwVal) + (*InStr - '0');
		InStr++;
	}

	return dwVal;
}

BOOLEAN
IsEncryptionPermitted(VOID)
/*++

Routine Description:

    This routine checks whether encryption is getting the system default
    LCID and checking whether the country code is CTRY_FRANCE.

Arguments:

    none


Return Value:

    TRUE - encryption is permitted
    FALSE - encryption is not permitted

    Encryption is always permitted! New France govt regulation...allow SSL, but
    disable PCT.

--*/

{
#ifdef SCHANNEL_PCT
    LCID  DefaultLcid;
    WCHAR CountryCode[10];
    CHAR  CountryCodeA[10];
    ULONG CountryValue;
    BOOL  fPCTAllowed = TRUE;

    DefaultLcid = GetSystemDefaultLCID();

    //
    // Check if the default language is Standard French or the user's country
    // is set to France.
    //

    if (LANGIDFROMLCID(DefaultLcid) == 0x40c)
    {
        fPCTAllowed = FALSE;
        goto done;
    }

    //
    // Check if the users's country is set to FRANCE
    //

    if (GetLocaleInfoW(DefaultLcid,LOCALE_ICOUNTRY,CountryCode,10) == 0)
    {
        fPCTAllowed = FALSE;
        goto done;
    }

    wcstombs(CountryCodeA, CountryCode, wcslen(CountryCode));

    CountryValue = (ULONG) MyStrToL(CountryCodeA);

    if (CountryValue == CTRY_FRANCE)
    {
        fPCTAllowed = FALSE;
        goto done;
    }

done:

    //
    // If PCT is NOT allowed and it is set, disable it and disable it in the
    // registry.
    //

    if ((fPCTAllowed == FALSE) &&
        (g_ProtEnabled & SP_PROT_PCT1)
        )
    {
        BOOL  fVal = 0; // Disabled.
        HKEY  hKey;
        DWORD dwDisp;
        DWORD err;

        g_ProtEnabled   &= ~SP_PROT_PCT1;
        g_ProtSupported &= ~SP_PROT_PCT1;

        err = RegCreateKeyEx(
            g_hkProtocols,              // Currently open protocol key.
            SP_REG_KEY_PCT1 TEXT("\\") SP_REG_KEY_CLIENT, // Key to open/create.
            0,                          // Must be 0.
            TEXT(""),                   // Class of object.
            REG_OPTION_NON_VOLATILE,    // Not used.
            KEY_ALL_ACCESS,             // Desired access. Not used.
            NULL,                       // Security attributes. Not used.
            &hKey,                      // Receives new/open key.
            &dwDisp                     // Receives disposition. (Opened | Created).
            );

        if (err == 0)
        {
            RegSetValueEx(
                hKey,               // Current open key.
                SP_REG_VAL_ENABLED, // Value "Enabled".
                0,                  // Must be 0.
                REG_DWORD,          // Key type.
                (PUCHAR)&fVal,      // Data.
                sizeof(fVal)        // Size of data.
                );

            RegCloseKey(hKey);
        }

        err = RegCreateKeyEx(
            g_hkProtocols,
            SP_REG_KEY_PCT1 TEXT("\\") SP_REG_KEY_SERVER,
            0,
            TEXT(""),
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hKey,
            &dwDisp
            );

        if (err == 0)
        {
            RegSetValueEx(
                hKey,
                SP_REG_VAL_ENABLED,
                0,
                REG_DWORD,
                (PUCHAR)&fVal,
                sizeof(fVal)
                );

            RegCloseKey(hKey);
        }
    }
#else
// no PCT in the build, no special checks needed
    g_ProtEnabled   &= ~SP_PROT_PCT1;
    g_ProtSupported &= ~SP_PROT_PCT1;
#endif // SCHANNEL_PCT
    

    // Always return success -- new French govt policy.
    return(TRUE);
}


BOOL
WINAPI
InitializeSSL()
{
#ifdef ENABLE_SELECTIVE_CRYPTO
    SPEnableFinanceCipher();
#endif

    InitializeCACache(0);

    SPInitSessionCache();
//  FBuildSsl3ExchgKeys();
    CryptoOk = IsEncryptionPermitted();

    return(TRUE);
}



BOOL WINAPI SPReInit()
{
    return TRUE;
}

#define SECUR32_VER_MS 0x00040000
#define SECUR32_VER_LS 0x00000800
#define SECUR32_FILENAME TEXT("secur32.dll")
#define SCHANNEL_FILENAME TEXT("schannel.dll")
#define VERSION_FILENAME  TEXT("version.dll")
#define SP_REG_KEY_SECURITY_PROVIDERS     TEXT("System\\CurrentControlSet\\Control\\SecurityProviders")
#define SP_REG_VAL_SECURITY_PROVIDERS   TEXT("SecurityProviders")
#define SECUR32_PATH_SIZE  256

#ifdef UNICODE
typedef DWORD
( APIENTRY * GET_FILE_VERSION_INFO_SIZE_FN)(
	LPWSTR lptstrFilename,
	LPDWORD lpdwHandle
	);
#define GET_FILE_VERSION_INFO_SIZE_NAME TEXT("GetFileVersionInfoSizeW")

typedef DWORD
( APIENTRY * GET_FILE_VERSION_INFO_FN)(
	LPWSTR lptstrFilename,
	DWORD dwHandle,
	DWORD dwLen,
	LPVOID lpData
	);
#define GET_FILE_VERSION_INFO_NAME TEXT("GetFileVersionInfoW")

typedef BOOL
( APIENTRY * VER_QUERY_VALUE_FN)(
	const LPVOID pBlock,
	LPWSTR lpSubBlock,
	LPVOID * lplpBuffer,
	PUINT puLen
	);
#define VER_QUERY_VALUE_NAME TEXT("VerQueryValueW")
#else
typedef DWORD
( APIENTRY * GET_FILE_VERSION_INFO_SIZE_FN)(
	LPSTR lptstrFilename,
	LPDWORD lpdwHandle
	);
#define GET_FILE_VERSION_INFO_SIZE_NAME TEXT("GetFileVersionInfoSizeA")
typedef DWORD
( APIENTRY * GET_FILE_VERSION_INFO_FN)(
	LPSTR lptstrFilename,
	DWORD dwHandle,
	DWORD dwLen,
	LPVOID lpData
	);
#define GET_FILE_VERSION_INFO_NAME TEXT("GetFileVersionInfoA")

typedef BOOL
( APIENTRY * VER_QUERY_VALUE_FN)(
	const LPVOID pBlock,
	LPSTR lpSubBlock,
	LPVOID * lplpBuffer,
	PUINT puLen
	);

#define VER_QUERY_VALUE_NAME TEXT("VerQueryValueA")

#endif // !UNICODE

DWORD
( APIENTRY * GET_FILE_VERSION_INFO_SIZE_FNA)(
	LPSTR lptstrFilename,
	LPDWORD lpdwHandle
	);


STDAPI DllRegisterServer(VOID)
{
#if 0
    DWORD  dwHandle;
    LPVOID pInfo;
    DWORD dwInfo;
    DWORD       err;
    DWORD       disp;
    DWORD       dwType;
    DWORD       dwSize;
    LPTSTR      pszProviders;
    LPTSTR      pszNewProviders;
    HKEY  hkSecurityProviders;
    BOOL  fComma;
    HINSTANCE   hVersion;
    GET_FILE_VERSION_INFO_SIZE_FN pGetFileVersionInfoSize = NULL;
    GET_FILE_VERSION_INFO_FN pGetFileVersionInfo = NULL;
    VER_QUERY_VALUE_FN pVerQueryValue = NULL;

    TCHAR       szSecur32Path[SECUR32_PATH_SIZE];

    LPTSTR      pszCurSource;
    LPTSTR      pszCurDest;
    DWORD       i, cSchannel;

    VS_FIXEDFILEINFO *pFixedInfo;
    UINT cbFixedInfo;

    SPLoadRegOptions();
    // Fix up the SecurityProviders key if we are
    // running an old version of secur32.dll

    hVersion = LoadLibrary(VERSION_FILENAME);
    if(hVersion == NULL)
    {
	return S_OK;
    }
    pGetFileVersionInfoSize = (GET_FILE_VERSION_INFO_SIZE_FN)GetProcAddress(hVersion, GET_FILE_VERSION_INFO_SIZE_NAME);
    if(pGetFileVersionInfoSize == NULL)
    {
	return S_OK;
    }

    pGetFileVersionInfo = (GET_FILE_VERSION_INFO_FN)GetProcAddress(hVersion, GET_FILE_VERSION_INFO_NAME);
    if(pGetFileVersionInfo == NULL)
    {
	return S_OK;
    }

    pVerQueryValue = (VER_QUERY_VALUE_FN)GetProcAddress(hVersion, VER_QUERY_VALUE_NAME);
    if(pVerQueryValue == NULL)
    {
	return S_OK;
    }
    GetSystemDirectory(szSecur32Path, SECUR32_PATH_SIZE);
    lstrcat(szSecur32Path, "\\");
    lstrcat(szSecur32Path, SECUR32_FILENAME);
    dwInfo = (*pGetFileVersionInfoSize)(szSecur32Path, &dwHandle);
    if(dwInfo == 0)
    {
	return S_OK;
    }
    pInfo = SPExternalAlloc(dwInfo);

    if(!(*pGetFileVersionInfo)(szSecur32Path, dwHandle, dwInfo, pInfo))
    {
	SPExternalFree(pInfo);
	return S_OK;
    }

    if(!(*pVerQueryValue)(pInfo, TEXT("\\"), &pFixedInfo, &cbFixedInfo))
    {
	SPExternalFree(pInfo);
	return S_OK;
    }

    if(pFixedInfo->dwFileVersionMS > SECUR32_VER_MS)
    {
	SPExternalFree(pInfo);
	return S_OK;
    }

    if(pFixedInfo->dwFileVersionMS == SECUR32_VER_MS && pFixedInfo->dwFileVersionLS > SECUR32_VER_LS)
    {
	SPExternalFree(pInfo);
	return S_OK;
    }
    SPExternalFree(pInfo);

    // We have an old version of SECUR32.DLL, so we must remove
    // schannel.dll from the security providers key.

    err = RegCreateKeyEx(   HKEY_LOCAL_MACHINE,
			    SP_REG_KEY_SECURITY_PROVIDERS,
			    0,
			    TEXT(""),
			    REG_OPTION_NON_VOLATILE,
			    KEY_ALL_ACCESS,
			    NULL,
			    &hkSecurityProviders,
			    &disp);

    if (err)
    {
	return( S_OK );
    }

    dwSize = 0;
    err = RegQueryValueEx(hkSecurityProviders,
			  SP_REG_VAL_SECURITY_PROVIDERS,
			  NULL,
			  &dwType,
			  NULL,
			  &dwSize);
    if(err) {
	return S_OK;
    }
    pszProviders = SPExternalAlloc(dwSize);

    err = RegQueryValueEx(hkSecurityProviders,
			  SP_REG_VAL_SECURITY_PROVIDERS,
			  NULL,
			  &dwType,
			  pszProviders,
			  &dwSize);


    if(err)
    {
	SPExternalFree(pszProviders);
	return S_OK;
    }
    // Now, parse through our list of providers, and
    // remove schannel.dll

    pszNewProviders = SPExternalAlloc(dwSize);

    pszCurSource = pszProviders;
    pszCurDest = pszNewProviders;

    *pszCurDest = 0;

    cSchannel = (DWORD)lstrlen(SCHANNEL_FILENAME);
    while(*pszCurSource != 0)
    {
	// Scan pszCurSource until either a comma or
	// a null.
	i = 0;
	while(pszCurSource[i] != 0 &&
	      pszCurSource[i] != TEXT(','))
	{
	    i++;
	}
	fComma = (pszCurSource[i] == TEXT(','));
	// pszCurSource points to start of dll path,
	// i is the length of the dll path
	pszCurSource[i] = 0;
	if(i < cSchannel ||
	    (lstrcmpi(&pszCurSource[i-cSchannel],
		     SCHANNEL_FILENAME) != 0))
	{
	    if(pszCurDest != pszNewProviders)
	    {
		*pszCurDest++ = TEXT(',');
	    }
	    CopyMemory(pszCurDest, pszCurSource, i);
	    pszCurDest[i]=0;
	    pszCurDest += i;
	}
	pszCurSource += i;
	if(fComma)
	{
	    pszCurSource++;
	}
    }

    err = RegSetValueEx(hkSecurityProviders,
			SP_REG_VAL_SECURITY_PROVIDERS,
			0,
			dwType,
			pszNewProviders,
			lstrlen(pszNewProviders)+1);
    SPExternalFree(pszProviders);
    SPExternalFree(pszNewProviders);
    RegCloseKey(hkSecurityProviders);

#endif // UNDER_CE

    return S_OK;

}

STDAPI DllUnregisterServer(VOID)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\linklist.h ===
/*****************************************************************************
*
*  Copyright (c) 1993-2000 Microsoft Corporation.  All rights reserved.
*
*  @doc		EXTERNAL LINKLIST
*
*  @module	LinkList.h | 
*
*  @comm	This file defines the LinkList functions used by the
*			Communications team.
*
*  @topic	Linked Listed Functions Overview |
*
*		The Linked List functions provide a standard way to use
*		Linked Lists.
*
*		<f InitializeListHead>		Initialize a list head
*
*		<f IsListEmpty>			Check if list is empty
*
*		<f RemoveHeadList>		Remove the first entry in a list
*
*		<f RemoveHeadLockedList>	Remove the first entry from a locked list
*
*		<f RemoveEntryList>		Remove an entry from a list
*
*		<f RemoveEntryLockedList>	Remove an entry from a locked list
*
*		<f RemoveTailList>		Remove the last entry from a list
*
*		<f RemoveTailLockedList>	Remove the last entry from a locked list
*
*		<f InsertTailList>			Insert at the tail of a list
*
*		<f InsertTailLockedList>		Insert at the tail of a locked list
*
*		<f InsertHeadList>		Insert at the head of a list
*
*		<f InsertHeadLockedList>		Insert at the head of a locked list
*
*
*/

/*
    linklist.h

    Macros for linked-list manipulation.


*/


#ifndef _LINKLIST_H_
#define _LINKLIST_H_

// Since this is in multiple modules it needs to be defined outside of
// the DEBUG Zone stuff.  Otherwise each would have to have
// a zone dedicated to debugging linked lists
#ifndef DEBUG_LINK_LIST
#define DEBUG_LINK_LIST	0
#endif


/*NOINC*/

#if !defined(WIN32)


/*****************************************************************************
*
*
*	@struct	LIST_ENTRY	| The Linked List Structure
*
*	@comm	This is the List Entry structure.

*	@ex		An example of how to use this function follows |
*			No Example
*
*/
typedef struct _LIST_ENTRY {
    struct _LIST_ENTRY FAR * Flink;	//@field	The Pointer to next
    struct _LIST_ENTRY FAR * Blink;	//@field	The Pointer to the previous
} LIST_ENTRY;
typedef LIST_ENTRY FAR * PLIST_ENTRY;
 
#endif  // !WIN32

//
// Linked List Manipulation Functions - from NDIS.H
//

// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure. - from NDIS.H

#ifndef CONTAINING_RECORD
#if defined(WIN32) || defined(UNDER_CE)
#define CONTAINING_RECORD(address, type, field) ((type *)( \
                          (LPBYTE)(address) - \
                          (LPBYTE)(&((type *)0)->field)))
#else   // !WIN32
#define CONTAINING_RECORD(address, type, field) ((type FAR *)( \
                          MAKELONG( \
                              ((LPBYTE)(address) - \
                               (LPBYTE)(&((type FAR *)0)->field)), \
                              SELECTOROF(address))))
#endif  // WIN32
#endif  // CONTAINING_RECORD

//  Doubly-linked list manipulation routines.  Implemented as macros

/*****************************************************************************
*
*
*	@func	void 	|	InitializeListHead | Initialize a Linked List Head
*
*	@rdesc	No return
*
*	@parm	PLIST_ENTRY	|	ListHead	| The head of the list
*
*	@comm
*			This will initialize the list head.
*
*	@ex		An example of how to use this function follows |
*			No Example
*
*/
#define InitializeListHead(ListHead) \
    ((ListHead)->Flink = (ListHead)->Blink = (ListHead) )

/*****************************************************************************
*
*
*	@func	BOOL 	|	IsListEmpty	|	Is the list Emtpy?
*
*	@rdesc	Boolean TRUE if the list is empty, FALSE if not empty.
*
*	@parm	PLIST_ENTRY	|	ListHead	| The head of the list
*
*	@comm
*			This function will test if the list is empty.
*
*	@ex		An example of how to use this function follows |
*			No Example
*
*/
#define IsListEmpty(ListHead) \
    (( ((ListHead)->Flink == (ListHead)) ? TRUE : FALSE ) )

/*****************************************************************************
*
*
*	@func	PLIST_ENTRY	|	RemoveHeadList	|
*			Remove the head of the list
*
*	@rdesc	Returns the entry from the head of the list.
*
*	@parm	PLIST_ENTRY	|	ListHead	| The head of the list
*
*	@comm
*			If this is called on an empty list it will return a pointer to
*			the list head (probably not what you wanted).
*
*	@ex		An example of how to use this function follows |
*			No Example
*
*/

_inline
PLIST_ENTRY
RemoveHeadList(PLIST_ENTRY ListHead)
{
	PLIST_ENTRY	FirstEntry;

	DEBUGMSG(DEBUG_LINK_LIST,
			 (TEXT("+RemoveHeadList: Head=%x(%x,%x)\r\n"),
			  ListHead, ListHead->Flink, ListHead->Blink));

	FirstEntry               = ListHead->Flink;
	FirstEntry->Flink->Blink = (ListHead);
	ListHead->Flink          = FirstEntry->Flink;

	DEBUGMSG(DEBUG_LINK_LIST,
			 (TEXT("-RemoveHeadList: %x Head=%x(%x,%x)\r\n"),
			  FirstEntry, ListHead, ListHead->Flink, ListHead->Blink));

	return FirstEntry;
}

/*****************************************************************************
*
*
*	@func	PLIST_ENTRY	|	RemoveHeadLockedList	|
*			Remove the first entry of a locked list
*
*	@rdesc	Returns the entry from the head of the list.
*
*	@parm	PLIST_ENTRY	|	ListHead	| The head of the list
*	@parm	LPCRITICAL_SECTION	|	CS	| The critical section
*
*	@comm
*			If this is called on an empty list it will return a pointer to
*			the list head (probably not what you wanted).
*
*	@ex		An example of how to use this function follows |
*			No Example
*
*/

_inline
PLIST_ENTRY
RemoveHeadLockedList(PLIST_ENTRY ListHead, LPCRITICAL_SECTION CS)
{
	PLIST_ENTRY	FirstEntry;

	DEBUGMSG(DEBUG_LINK_LIST,
			 (TEXT("+RemoveHeadLockedList: Head=%x(%x,%x) CS=%x\r\n"),
			  ListHead, ListHead->Flink, ListHead->Blink, CS));

	EnterCriticalSection(CS);

	FirstEntry               = ListHead->Flink;
	FirstEntry->Flink->Blink = (ListHead);
	ListHead->Flink          = FirstEntry->Flink;

	DEBUGMSG(DEBUG_LINK_LIST,
			 (TEXT("-RemoveHeadLockedList: %x Head=%x(%x,%x)\r\n"),
			  FirstEntry, ListHead, ListHead->Flink, ListHead->Blink));

	LeaveCriticalSection(CS);

	return FirstEntry;
}

/*****************************************************************************
*
*
*	@func	void	|	RemoveEntryList | Removes an entry from the list
*
*	@rdesc	No return
*
*	@parm	PLIST_ENTRY	|	Entry	| The entry to remove
*
*	@comm
*			This function will remove the specified entry from a list.
*
*	@ex		An example of how to use this function follows |
*			No Example
*
*/

_inline
void
RemoveEntryList(PLIST_ENTRY Entry)
{
	PLIST_ENTRY EX_Entry;
	
	DEBUGMSG(DEBUG_LINK_LIST, (TEXT("+RemoveEntryList: Entry=%x(%x,%x)\r\n"),
                               Entry, Entry->Flink, Entry->Blink));

    EX_Entry = (Entry);
    EX_Entry->Blink->Flink = EX_Entry->Flink;
    EX_Entry->Flink->Blink = EX_Entry->Blink;

	DEBUGMSG(DEBUG_LINK_LIST, (TEXT("-RemoveEntryList: \r\n")));
}

/*****************************************************************************
*
*
*	@func	void	|	RemoveEntryLockedList | Removes an entry from the list
*
*	@rdesc	No return
*
*	@parm	PLIST_ENTRY			|	Entry	| The entry to remove
*	@parm	LPCRITICAL_SECTION	|	CS		| The critical section to lock
*
*	@comm
*			This function will remove the specified entry from a list.
*
*	@ex		An example of how to use this function follows |
*			No Example
*
*/

_inline
void
RemoveEntryLockedList(PLIST_ENTRY Entry, LPCRITICAL_SECTION CS)
{
	PLIST_ENTRY EX_Entry;
	
	DEBUGMSG(DEBUG_LINK_LIST,
			 (TEXT("+RemoveEntryLockedList: Entry=%x(%x,%x) CS=%x\r\n"),
			  Entry, Entry->Flink, Entry->Blink, CS));

	EnterCriticalSection(CS);

    EX_Entry               = (Entry);
    EX_Entry->Blink->Flink = EX_Entry->Flink;
    EX_Entry->Flink->Blink = EX_Entry->Blink;

	DEBUGMSG(DEBUG_LINK_LIST, (TEXT("-RemoveEntryLockedList: \r\n")));

	LeaveCriticalSection(CS);
}

/*****************************************************************************
*
*
*	@func	PLIST_ENTRY	|	RemoveTailList	|
*			This function will remove the entry from the end of a list.
*
*	@rdesc	Returns a pointer to the tail entry.
*
*	@parm	PLIST_ENTRY	|	ListHead	| The List Head
*
*	@comm
*			Don't call this with a null list.
*
*	@ex		An example of how to use this function follows |
*			No Example
*
*/

_inline
PLIST_ENTRY
RemoveTailList(PLIST_ENTRY ListHead)
{
	PLIST_ENTRY _EX_Entry;

	DEBUGMSG(DEBUG_LINK_LIST, (TEXT("+RemoveTailList: ListHead=%x(%x,%x)\r\n"),
                               ListHead, ListHead->Flink, ListHead->Blink));

	_EX_Entry = ListHead->Blink;
	RemoveEntryList(_EX_Entry);

	DEBUGMSG(DEBUG_LINK_LIST, (TEXT("-RemoveTailList: ListHead=%x(%x,%x)\r\n"),
				 ListHead, ListHead->Flink, ListHead->Blink));

	return _EX_Entry;
}

/*****************************************************************************
*
*
*	@func	PLIST_ENTRY	|	RemoveTailLockedList	|
*			This function will remove the entry from the end of a list.
*
*	@rdesc	Returns a pointer to the tail entry.
*
*	@parm	PLIST_ENTRY	|	ListHead	| The List Head
*	@parm	LPCRITICAL_SECTION	|	CS			| Pointer to a Critical Section
*
*	@comm
*			Don't call this with a null list.
*
*	@ex		An example of how to use this function follows |
*			No Example
*
*/

_inline
PLIST_ENTRY
RemoveTailLockedList(PLIST_ENTRY ListHead, LPCRITICAL_SECTION CS)
{
	PLIST_ENTRY _EX_Entry;

	DEBUGMSG(DEBUG_LINK_LIST, (TEXT("+RemoveTailList: ListHead=%x(%x,%x)\r\n"),
				 ListHead, ListHead->Flink, ListHead->Blink));

	EnterCriticalSection(CS);

	_EX_Entry = ListHead->Blink;
	RemoveEntryList(_EX_Entry);

	DEBUGMSG(DEBUG_LINK_LIST, (TEXT("-RemoveTailList: ListHead=%x(%x,%x)\r\n"),
				 ListHead, ListHead->Flink, ListHead->Blink));

	LeaveCriticalSection(CS);

	return _EX_Entry;
}

/*****************************************************************************
*
*
*	@func	void	|	InsertTailList	|
*			Insert at the end of a list
*
*	@rdesc	No return
*
*	@parm	PLIST_ENTRY	|	ListHead	| The head of the list
*	@parm	PLIST_ENTRY	|	Entry		| The Entry to add to the list
*
*	@comm
*			Inserts an entry at the tail of a list
*
*	@ex		An example of how to use this function follows |
*			No Example
*
*/

_inline
void
InsertTailList(PLIST_ENTRY ListHead, PLIST_ENTRY Entry)
{
	DEBUGMSG(DEBUG_LINK_LIST,
			 (TEXT("+InsertTailList: Head=%x(%x,%x) Entry=%x\r\n"),
			  ListHead, ListHead->Flink, ListHead->Blink, Entry));

    Entry->Flink           = ListHead;
    Entry->Blink           = ListHead->Blink;
    ListHead->Blink->Flink = Entry;
    ListHead->Blink        = Entry;

	DEBUGMSG(DEBUG_LINK_LIST,
			 (TEXT("-InsertTailList: Head=%x(%x,%x) Entry=%x(%x,%x)\r\n"),
			  ListHead, ListHead->Flink, ListHead->Blink, Entry,
			  Entry->Flink, Entry->Blink));

	return;
}

/*****************************************************************************
*
*
*	@func	void	|	InsertTailLockedList	|
*			Insert at the end of a list
*
*	@rdesc	No return
*
*	@parm	PLIST_ENTRY			|	ListHead	| The head of the list
*	@parm	PLIST_ENTRY			|	Entry		| The Entry to add to the list
*	@parm	LPCRITICAL_SECTION	|	CS			| Pointer to a Critical Section
*
*	@comm
*			Inserts an entry at the tail of a list
*
*	@ex		An example of how to use this function follows |
*			No Example
*
*/

_inline
void
InsertTailLockedList(PLIST_ENTRY ListHead, PLIST_ENTRY Entry,
					 LPCRITICAL_SECTION CS)
{
	DEBUGMSG(DEBUG_LINK_LIST,
			 (TEXT("+InsertTailList: Head=%x(%x,%x) CS=%x Entry=%x\r\n"),
			  ListHead, ListHead->Flink, ListHead->Blink, CS, Entry));

	EnterCriticalSection(CS);

    Entry->Flink           = ListHead;
    Entry->Blink           = ListHead->Blink;
    ListHead->Blink->Flink = Entry;
    ListHead->Blink        = Entry;

	DEBUGMSG(DEBUG_LINK_LIST,
			 (TEXT("-InsertTailList: Head=%x(%x,%x) Entry=%x(%x,%x)\r\n"),
			  ListHead, ListHead->Flink, ListHead->Blink, Entry,
			  Entry->Flink, Entry->Blink));

	LeaveCriticalSection(CS);

	return;
}

/*****************************************************************************
*
*
*	@func	void	|	InsertHeadList	|
*			Insert an entry at the head of a list
*
*	@rdesc	No return.
*
*	@parm	PLIST_ENTRY	|	ListHead	| The head of the list
*	@parm	PLIST_ENTRY	|	Entry		| The Entry to add to the list
*
*	@comm
*			This will add an entry to the head of a list.
*
*	@ex		An example of how to use this function follows |
*			No Example
*
*/

_inline
void
InsertHeadList(PLIST_ENTRY ListHead, PLIST_ENTRY Entry)
{
	DEBUGMSG(DEBUG_LINK_LIST,
			 (TEXT("+InsertHeadList: Head=%x(%x,%x) Entry=%x\r\n"),
			  ListHead, ListHead->Flink, ListHead->Blink, Entry));

    Entry->Flink           = ListHead->Flink;
    Entry->Blink           = ListHead;
    ListHead->Flink->Blink = Entry;
    ListHead->Flink        = Entry;

	DEBUGMSG(DEBUG_LINK_LIST,
			 (TEXT("-InsertHeadList: Head=%x(%x,%x) Entry=%x(%x,%x)\r\n"),
			  ListHead, ListHead->Flink, ListHead->Blink,
			  Entry, Entry->Flink, Entry->Blink));
}

/*****************************************************************************
*
*
*	@func	void	|	InsertHeadLockedList	|
*			Insert an entry at the head of a critcal section locked list
*
*	@rdesc	No return.
*
*	@parm	PLIST_ENTRY			|	ListHead	| The head of the list
*	@parm	PLIST_ENTRY			|	Entry		| The Entry to add to the list
*	@parm	LPCRITICAL_SECTION	|	CS			| Pointer to a Critical Section
*
*	@comm
*			This will add an entry to the head of a list.
*
*	@ex		An example of how to use this function follows |
*			No Example
*
*/

_inline
void
InsertHeadLockedList(PLIST_ENTRY ListHead, PLIST_ENTRY Entry,
					 LPCRITICAL_SECTION CS)
{
	DEBUGMSG(DEBUG_LINK_LIST,
			 (TEXT("+InsertHeadLockedList: Head=%x(%x,%x) CS=%x Entry=%x\r\n"),
			  ListHead, ListHead->Flink, ListHead->Blink, CS, Entry));

	EnterCriticalSection (CS);

    Entry->Flink           = ListHead->Flink;
    Entry->Blink           = ListHead;
    ListHead->Flink->Blink = Entry;
    ListHead->Flink        = Entry;

	DEBUGMSG(DEBUG_LINK_LIST,
			 (TEXT("-InsertHeadLockedList: Head=%x(%x,%x) Entry=%x(%x,%x)\r\n"),
			  ListHead, ListHead->Flink, ListHead->Blink,
			  Entry, Entry->Flink, Entry->Blink));

	LeaveCriticalSection (CS);
}

/*INC*/

#endif  // _LINKLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\message.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       message.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9-22-95   RichardW   Created
//              10-8-95   TerenceS   Created PctSealMessage
//              10-8-95   TerenceS   Created PctUnSealMessage
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <security.h>
#include "spsspi.h"

SECURITY_STATUS
SEC_ENTRY
MakeSignature(PCtxtHandle         phContext,
              DWORD               fQOP,
              PSecBufferDesc      pMessage,
              ULONG               MessageSeqNo)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

SECURITY_STATUS SEC_ENTRY
VerifySignature(PCtxtHandle     phContext,
                PSecBufferDesc  pMessage,
                ULONG           MessageSeqNo,
                DWORD *         pfQOP)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

SECURITY_STATUS
SEC_ENTRY
SealMessage( PCtxtHandle         phContext,
             DWORD               fQOP,
             PSecBufferDesc      pMessage,
             ULONG               MessageSeqNo)
{

    PSecBuffer                  pHdrBuffer;
    PSecBuffer                  pDataBuffer;
    PSecBuffer                  pTlrBuffer;
    PSecBuffer                  pTokenBuffer;

    PSPContext                  pContext;
    SP_STATUS                  pctRet = PCT_ERR_OK;
    SPBuffer                   CommOut;
    SPBuffer                   AppIn;
    BOOL                       fAlloced=FALSE;
    BOOL                       fConnectionMode = FALSE;
    int i;
    SecPkgContext_StreamSizes  Sizes;

    pContext = ValidateContextHandle(phContext);

    if (!pContext)
    {
        return( SEC_E_INVALID_HANDLE );
    }
    if ((0 == (pContext->State & SP_STATE_CONNECTED)) || (NULL ==  pContext->Encrypt))
    {
        return( SEC_E_CONTEXT_EXPIRED );
    }


    QueryContextAttributesA(phContext, SECPKG_ATTR_STREAM_SIZES, &Sizes);

    //
    // Find the buffer with the data:
    //

    pHdrBuffer = NULL;
    pDataBuffer = NULL;
    pTlrBuffer = NULL;
    pTokenBuffer = NULL;

    /* Gibraltar passes in the following, in stream mode,
     * a TOKEN buffer (or SECBUFFER_STREAM_HEADER)
     * a DATA buffer
     * a TOKEN buffer (or SECBUFFER_STREAM_TRAILER)
     * or we can get a connection mode as in
     * DATA buffer
     * Token buffer
     */




    if(0 == (pContext->Flags & CONTEXT_FLAG_CONNECTION_MODE))
    {
        // Stream Mode
        // The output buffer should be a concatenation of
        // the header buffer, Data buffer, and Trailer buffers.
        for (i = 0 ; i < (int)pMessage->cBuffers ; i++ )
        {
            switch(pMessage->pBuffers[i].BufferType)
            {
                case SECBUFFER_STREAM_HEADER:
                     pHdrBuffer = &pMessage->pBuffers[i];
                     break;

                case SECBUFFER_DATA :
                     pDataBuffer = &pMessage->pBuffers[i];
                     break;

                case SECBUFFER_STREAM_TRAILER:
                     pTlrBuffer = &pMessage->pBuffers[i];
                     break;

                case SECBUFFER_TOKEN:
                     if(pHdrBuffer == NULL)
                     {
                         pHdrBuffer = &pMessage->pBuffers[i];
                     }
                     else if(pTlrBuffer == NULL)
                     {
                          pTlrBuffer = &pMessage->pBuffers[i];
                     }
                     break;
                default:
                    break;
            }
        }
        if((pHdrBuffer == NULL) || (pDataBuffer == NULL) )
        {
            return( SEC_E_INVALID_TOKEN );
        }
        if((PUCHAR)pDataBuffer->pvBuffer ==
           ((PUCHAR)pHdrBuffer->pvBuffer + pHdrBuffer->cbBuffer))
        {
            pTokenBuffer = pHdrBuffer;
            CommOut.pvBuffer = pHdrBuffer->pvBuffer;
            CommOut.cbData   = 0;
            CommOut.cbBuffer = pHdrBuffer->cbBuffer + pDataBuffer->cbBuffer;
            if(pTlrBuffer)
            {
                CommOut.cbBuffer += pTlrBuffer->cbBuffer;
            }
        }
        else
        {
            // We have to realloc the buffer
            fAlloced = TRUE;
            CommOut.cbBuffer = pDataBuffer->cbBuffer + pTokenBuffer->cbBuffer;
            if(pTlrBuffer)
            {
                CommOut.cbBuffer += pTlrBuffer->cbBuffer;
            }
            CommOut.pvBuffer = SPExternalAlloc(CommOut.cbBuffer);
            if(CommOut.pvBuffer == NULL)
            {
                return (SEC_E_INSUFFICIENT_MEMORY);
            }
            CommOut.cbData = 0;
        }
        // The data buffer always goes to AppIn
        AppIn.pvBuffer = pDataBuffer->pvBuffer;
        AppIn.cbData   = pDataBuffer->cbBuffer;
        AppIn.cbBuffer = pDataBuffer->cbBuffer;
        pctRet = pContext->Encrypt(pContext,
                                   &AppIn,
                                   &CommOut);
        if(fAlloced)
        {
            if(pctRet == PCT_ERR_OK)
            {

                CopyMemory(pHdrBuffer->pvBuffer,
                       CommOut.pvBuffer,
                       pHdrBuffer->cbBuffer);

                pDataBuffer->cbBuffer = min(pDataBuffer->cbBuffer, CommOut.cbBuffer - pHdrBuffer->cbBuffer);

                CopyMemory(pDataBuffer->pvBuffer,
                       (PUCHAR)CommOut.pvBuffer + pHdrBuffer->cbBuffer,
                       pDataBuffer->cbBuffer);

                if(pTlrBuffer)
                {
                    pTlrBuffer->cbBuffer = min(pTlrBuffer->cbBuffer,
                                               CommOut.cbBuffer - (pHdrBuffer->cbBuffer + pDataBuffer->cbBuffer));

                    CopyMemory(pTlrBuffer->pvBuffer,
                               (PUCHAR)CommOut.pvBuffer + pHdrBuffer->cbBuffer + pDataBuffer->cbBuffer,
                               pTlrBuffer->cbBuffer);
                }
            }
            SPExternalFree(CommOut.pvBuffer);
        }

    }
    else
    {
        // We're doing connection mode, so unpack buffers as a
        // Data and then Token buffer
        fConnectionMode = TRUE;
        for (i = 0 ; i < (int)pMessage->cBuffers ; i++ )
        {
            switch(pMessage->pBuffers[i].BufferType)
            {
                case SECBUFFER_DATA :
                     pDataBuffer = &pMessage->pBuffers[i];
                     break;


                case SECBUFFER_TOKEN:
                     if(pTokenBuffer == NULL)
                     {
                         pTokenBuffer = &pMessage->pBuffers[i];
                     }
                     break;
                default:
                    break;
            }
        }
        if((pTokenBuffer == NULL) || (pDataBuffer == NULL))
        {
            return( SEC_E_INVALID_TOKEN );
        }


        if((pDataBuffer->pvBuffer == NULL) || (pTokenBuffer->pvBuffer == NULL))
        {
            return( SEC_E_INVALID_TOKEN );
        }
        // Connection Mode
        // The output should get written to a concatenation of the
        // data buffer and the token buffer.  If no token buffer is
        // given, then we should allocate one.

        if((PUCHAR)pTokenBuffer->pvBuffer ==
           ((PUCHAR)pDataBuffer->pvBuffer + pDataBuffer->cbBuffer))
        {
            // If the buffers are contiguous, we can optimize!
            CommOut.pvBuffer = pDataBuffer->pvBuffer;
            CommOut.cbData   = 0;
            CommOut.cbBuffer = pDataBuffer->cbBuffer + pTokenBuffer->cbBuffer;
        }
        else
        {
            // We have to realloc the buffer
            fAlloced = TRUE;
            CommOut.pvBuffer = SPExternalAlloc(pDataBuffer->cbBuffer + pTokenBuffer->cbBuffer);
            if(CommOut.pvBuffer == NULL)
            {
                return (SEC_E_INSUFFICIENT_MEMORY);
            }
            CommOut.cbBuffer = pDataBuffer->cbBuffer + pTokenBuffer->cbBuffer;
            CommOut.cbData = 0;
        }
        // The data buffer always goes to AppIn
        AppIn.pvBuffer = pDataBuffer->pvBuffer;
        AppIn.cbData   = pDataBuffer->cbBuffer;
        AppIn.cbBuffer = pDataBuffer->cbBuffer;
        pctRet = pContext->Encrypt(pContext,
                                   &AppIn,
                                   &CommOut);

        if(fAlloced)
        {
            if(pctRet == PCT_ERR_OK)
            {
                // We encrypted into our temporary buffer, so we must
                // copy.
                CopyMemory(pDataBuffer->pvBuffer,
                           CommOut.pvBuffer,
                           pDataBuffer->cbBuffer);
                pTokenBuffer->cbBuffer = min(pTokenBuffer->cbBuffer, CommOut.cbData - pDataBuffer->cbBuffer);

                CopyMemory(pTokenBuffer->pvBuffer,
                           (PUCHAR)CommOut.pvBuffer + pDataBuffer->cbBuffer,
                           pTokenBuffer->cbBuffer);
            }
            SPExternalFree(CommOut.pvBuffer);
        }
    }
    return PctTranslateError(pctRet);
}


SECURITY_STATUS
SEC_ENTRY
UnsealMessage(  PCtxtHandle         phContext,
                PSecBufferDesc      pMessage,
                ULONG               MessageSeqNo,
                DWORD *             pfQOP)
{
    // Output Buffer Types
    PSecBuffer                  pHdrBuffer;
    PSecBuffer                  pDataBuffer;
    PSecBuffer                  pTokenBuffer;
    PSecBuffer                  pTlrBuffer;
    PSecBuffer                  pExtraBuffer;

    PSPContext                  pContext;
    SP_STATUS                  pctRet = PCT_ERR_OK;
    SPBuffer                   CommIn;
    SPBuffer                   AppOut;
//    DWORD                      cbBytes;
    SecPkgContext_StreamSizes  Sizes;
    BOOL                       fAlloced = FALSE;
    int i;

    pContext = ValidateContextHandle(phContext);

    if (!pContext)
    {
        return( SEC_E_INVALID_HANDLE );
    }
    QueryContextAttributesA(phContext, SECPKG_ATTR_STREAM_SIZES, &Sizes);

    if ((0 == (pContext->State & SP_STATE_CONNECTED)) || (NULL ==  pContext->Decrypt))
    {
        return( SEC_E_CONTEXT_EXPIRED );
    }

    //
    // Set up output buffers:
    //
    pHdrBuffer = NULL;
    pDataBuffer = NULL;
    pTokenBuffer = NULL;
    pTlrBuffer = NULL;
    pExtraBuffer = NULL;

    // On input, the buffers can either be
    // DataBuffer
    // TokenBuffer
    //
    // or
    //
    // Data Buffer
    // Empty
    // Empty
    // Empty
    //

    // on Output, the buffers are
    // DataBuffer
    // TokenBuffer
    //
    // or
    // HdrBuffer
    // DataBuffer
    // Tlrbuffer
    // Extrabuffer or Empty
    if(0 == (pContext->Flags & CONTEXT_FLAG_CONNECTION_MODE))
    {
        // Stream Mode
        // The output buffer should be a concatenation of
        // the header buffer, Data buffer, and Trailer buffers.

        for (i = 0 ; i < (int)pMessage->cBuffers ; i++ )
        {
            switch(pMessage->pBuffers[i].BufferType)
            {

                case SECBUFFER_DATA :
                     pHdrBuffer = &pMessage->pBuffers[i];
                     break;


                case SECBUFFER_EMPTY:
                    if(pHdrBuffer == NULL)
                    {
                        break;
                    }
                    if(pDataBuffer == NULL)
                    {
                        pDataBuffer = &pMessage->pBuffers[i];

                    } else if(pTlrBuffer == NULL)
                    {
                        pTlrBuffer = &pMessage->pBuffers[i];
                    } else if (pExtraBuffer == NULL)
                    {
                         pExtraBuffer = &pMessage->pBuffers[i];
                    }
                    break;
                default:
                    break;
            }
        }
        if((pHdrBuffer == NULL) ||
           (pDataBuffer == NULL) ||
           (pTlrBuffer == NULL) ||
           (pExtraBuffer == NULL))
        {
            return( SEC_E_INVALID_TOKEN );
        }
        if(pHdrBuffer->pvBuffer == NULL)
        {
            return( SEC_E_INVALID_TOKEN );
        }

        CommIn.pvBuffer = pHdrBuffer->pvBuffer;
        CommIn.cbData   = pHdrBuffer->cbBuffer;
        CommIn.cbBuffer = CommIn.cbData;

        AppOut.pvBuffer = (PUCHAR)CommIn.pvBuffer + Sizes.cbHeader;
        AppOut.cbData   = 0;
        AppOut.cbBuffer = CommIn.cbData-Sizes.cbHeader - Sizes.cbTrailer;

        pctRet = pContext->DecryptHandler(pContext,
                                   &CommIn,
                                   &AppOut);

        if((pctRet == PCT_ERR_OK) ||
            (pctRet == PCT_INT_RENEGOTIATE))
        {
            if(CommIn.cbData < pHdrBuffer->cbBuffer)
            {
                pExtraBuffer->BufferType = SECBUFFER_EXTRA;
                pExtraBuffer->cbBuffer = pHdrBuffer->cbBuffer-CommIn.cbData;
                pExtraBuffer->pvBuffer = (PUCHAR)pHdrBuffer->pvBuffer+CommIn.cbData;
            }
            pHdrBuffer->BufferType = SECBUFFER_STREAM_HEADER;
            pHdrBuffer->cbBuffer = Sizes.cbHeader;

            pDataBuffer->BufferType = SECBUFFER_DATA;
            pDataBuffer->pvBuffer = AppOut.pvBuffer;
            pDataBuffer->cbBuffer = AppOut.cbData;

            pTlrBuffer->BufferType = SECBUFFER_STREAM_TRAILER;
            pTlrBuffer->pvBuffer = (PUCHAR)pDataBuffer->pvBuffer + AppOut.cbData;
            pTlrBuffer->cbBuffer = Sizes.cbTrailer;

        }
        else if(pctRet == PCT_INT_INCOMPLETE_MSG)
        {
            pDataBuffer->BufferType = SECBUFFER_MISSING;
            pDataBuffer->cbBuffer = CommIn.cbData - pHdrBuffer->cbBuffer;
        }

    }
    else
    {
        // Connection Mode
        for (i = 0 ; i < (int)pMessage->cBuffers ; i++ )
        {
            switch(pMessage->pBuffers[i].BufferType)
            {
                case SECBUFFER_DATA :
                     pDataBuffer = &pMessage->pBuffers[i];
                     break;


                case SECBUFFER_TOKEN:
                     if(pTokenBuffer == NULL)
                     {
                         pTokenBuffer = &pMessage->pBuffers[i];
                     }
                     break;
                default:
                    break;
            }
        }
        if((pTokenBuffer == NULL) || (pDataBuffer == NULL))
        {
            return( SEC_E_INVALID_TOKEN );
        }


        if((pDataBuffer->pvBuffer == NULL) || (pTokenBuffer->pvBuffer == NULL))
        {
            return( SEC_E_INVALID_TOKEN );
        }
                // The Data and Token buffers are concatenated together to
        // form a single input buffer.
        if((PUCHAR)pDataBuffer->pvBuffer + pDataBuffer->cbBuffer ==
           (PUCHAR)pTokenBuffer->pvBuffer)
        {
            // Speed Opt,  If the buffers really are just one big buffer
            // then we can party on them directly.
            CommIn.pvBuffer = pDataBuffer->pvBuffer;
            CommIn.cbData   = pDataBuffer->cbBuffer + pTokenBuffer->cbBuffer;
            CommIn.cbBuffer = CommIn.cbData;
        }
        else
        {
            // We have to allocate a uniform input buffer
            CommIn.cbData   = pDataBuffer->cbBuffer + pTokenBuffer->cbBuffer;
            CommIn.pvBuffer = SPExternalAlloc(CommIn.cbData);
            CommIn.cbBuffer = CommIn.cbData;
            CopyMemory(CommIn.pvBuffer,  pDataBuffer->pvBuffer,  pDataBuffer->cbBuffer);

            CopyMemory((PUCHAR)CommIn.pvBuffer + pDataBuffer->cbBuffer,
                       pTokenBuffer->pvBuffer,
                       pTokenBuffer->cbBuffer);
            fAlloced = TRUE;

        }
        AppOut.pvBuffer = pDataBuffer->pvBuffer;
        AppOut.cbData   = 0;
        AppOut.cbBuffer = pDataBuffer->cbBuffer;
        pctRet = pContext->DecryptHandler(pContext,
                           &CommIn,
                           &AppOut);


        if((pctRet == PCT_ERR_OK) ||
           (pctRet == PCT_INT_RENEGOTIATE))
        {
            // We don't really care abou the contents of the
            // Token buffer, so just copy data

             pDataBuffer->cbBuffer = AppOut.cbData;

        }

        if(fAlloced)
        {
            SPExternalFree(CommIn.pvBuffer);
        }

    }


    return PctTranslateError(pctRet);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\mgmt.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       mgmt.c
//
//  Contents:   Management Functions
//
//  Classes:
//
//  Functions:
//
//  History:    8-07-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <security.h>
#include "spsspi.h"

#include "hack.h"

#define lstrcmpiA stricmp

const SecPkgInfoA SecPackagesA[] =
{
    {
	SECPKG_FLAG_INTEGRITY |
	    SECPKG_FLAG_PRIVACY |
	    SECPKG_FLAG_CONNECTION |
	    SECPKG_FLAG_STREAM |
	    SECPKG_FLAG_MULTI_REQUIRED |
        SECPKG_FLAG_IMPERSONATION |
	    SECPKG_FLAG_EXTENDED_ERROR,
	1,
	UNISP_RPC_ID,
	768,
	UNISP_NAME_A,
	"Microsoft Unified Security Provider"
    },
#ifdef SCHANNEL_PCT
    {
	SECPKG_FLAG_INTEGRITY |
	    SECPKG_FLAG_PRIVACY |
	    SECPKG_FLAG_CONNECTION |
	    SECPKG_FLAG_STREAM |
	    SECPKG_FLAG_MULTI_REQUIRED |
        SECPKG_FLAG_IMPERSONATION |
	    SECPKG_FLAG_EXTENDED_ERROR,
	1,
	UNISP_RPC_ID,
	768,
	PCT1SP_NAME_A,
	"Microsoft PCT 1.0  Security Provider"
    },
#endif
    {
	SECPKG_FLAG_INTEGRITY |
	    SECPKG_FLAG_PRIVACY |
	    SECPKG_FLAG_CONNECTION |
	    SECPKG_FLAG_STREAM |
	    SECPKG_FLAG_MULTI_REQUIRED |
        SECPKG_FLAG_IMPERSONATION |
	    SECPKG_FLAG_EXTENDED_ERROR,
	1,
	UNISP_RPC_ID,
	768,
	SSL3SP_NAME_A,
	"Microsoft SSL 3.0 Security Provider"
    },
    {
	SECPKG_FLAG_INTEGRITY |
	    SECPKG_FLAG_PRIVACY |
	    SECPKG_FLAG_CONNECTION |
	    SECPKG_FLAG_STREAM |
	    SECPKG_FLAG_MULTI_REQUIRED |
        SECPKG_FLAG_IMPERSONATION |
	    SECPKG_FLAG_EXTENDED_ERROR,
	1,
	UNISP_RPC_ID,
	768,
	SSL2SP_NAME_A,
	"Microsoft SSL 2.0 Security Provider"
    }
};



const SecPkgInfoW SecPackagesW[] =
{
    {
	SECPKG_FLAG_INTEGRITY |
	    SECPKG_FLAG_PRIVACY |
	    SECPKG_FLAG_CONNECTION |
	    SECPKG_FLAG_STREAM |
	    SECPKG_FLAG_MULTI_REQUIRED |
        SECPKG_FLAG_IMPERSONATION |
	    SECPKG_FLAG_EXTENDED_ERROR,
	1,
	UNISP_RPC_ID,
	768,
	UNISP_NAME_W,
	L"Microsoft Unified Security Provider"
    },
#ifdef SCHANNEL_PCT
    {
	SECPKG_FLAG_INTEGRITY |
	    SECPKG_FLAG_PRIVACY |
	    SECPKG_FLAG_CONNECTION |
	    SECPKG_FLAG_STREAM |
	    SECPKG_FLAG_MULTI_REQUIRED |
        SECPKG_FLAG_IMPERSONATION |
	    SECPKG_FLAG_EXTENDED_ERROR,
	1,
	UNISP_RPC_ID,
	768,
	PCT1SP_NAME_W,
	L"Microsoft PCT 1.0  Security Provider"
    },
#endif
    {
	SECPKG_FLAG_INTEGRITY |
	    SECPKG_FLAG_PRIVACY |
	    SECPKG_FLAG_CONNECTION |
	    SECPKG_FLAG_STREAM |
	    SECPKG_FLAG_MULTI_REQUIRED |
        SECPKG_FLAG_IMPERSONATION |
	    SECPKG_FLAG_EXTENDED_ERROR,
	1,
	UNISP_RPC_ID,
	768,
	SSL3SP_NAME_W,
	L"Microsoft SSL 3.0 Security Provider"
    },
    {
	SECPKG_FLAG_INTEGRITY |
	    SECPKG_FLAG_PRIVACY |
	    SECPKG_FLAG_CONNECTION |
	    SECPKG_FLAG_STREAM |
	    SECPKG_FLAG_MULTI_REQUIRED |
        SECPKG_FLAG_IMPERSONATION |
	    SECPKG_FLAG_EXTENDED_ERROR,
	1,
	UNISP_RPC_ID,
	768,
	SSL2SP_NAME_W,
	L"Microsoft SSL 2.0 Security Provider"
    }
};

const DWORD NumPackages = sizeof(SecPackagesW)/sizeof(SecPkgInfoW);


DWORD pGetInfoSizeW(const SecPkgInfoW * pInfo)
{
    return(
	sizeof(SecPkgInfoW) +
	(lstrlenW(pInfo->Name) + lstrlenW(pInfo->Comment) + 2) * sizeof(WCHAR));

}


DWORD pGetInfoSizeA(const SecPkgInfoA * pInfo)
{
    return(
	sizeof(SecPkgInfoA) +
	strlen(pInfo->Name) +
	strlen(pInfo->Comment) +
	2);
}


SECURITY_STATUS SEC_ENTRY
EnumerateSecurityPackagesW(
    unsigned long SEC_FAR *     pcPackages,         // Receives num. packages
    PSecPkgInfoW SEC_FAR *       ppPackageInfo       // Receives array of info
    )
{
    DWORD i;
    DWORD dwTotalSize;
    PWSTR pPack;
    PSecPkgInfoW pCurInfo;
    *ppPackageInfo = NULL;
    *pcPackages = 0;

    /* get size */
    dwTotalSize = 0;
    for(i=0; i<NumPackages; i++) {
        dwTotalSize += pGetInfoSizeW(&SecPackagesW[i]);
    }
    *ppPackageInfo = SPExternalAlloc(dwTotalSize);
    if(*ppPackageInfo == NULL) return(SEC_E_INSUFFICIENT_MEMORY);

    pPack = (PWSTR)&(*ppPackageInfo)[NumPackages];
    for(i=0; i<NumPackages; i++) {
        pCurInfo = &(*ppPackageInfo)[i];

        CopyMemory(pCurInfo, &SecPackagesW[i], sizeof(SecPkgInfoW));
        pCurInfo->Name = (PWSTR)pPack;
        lstrcpyW(pCurInfo->Name, SecPackagesW[i].Name);
        pPack += (lstrlenW(SecPackagesW[i].Name) + 1);

        pCurInfo->Comment = (PWSTR)pPack;
        lstrcpyW(pCurInfo->Comment, SecPackagesW[i].Comment);
        pPack += (lstrlenW(SecPackagesW[i].Comment) + 1);
    }

    *pcPackages = NumPackages;
    return(SEC_E_OK);

}

SECURITY_STATUS SEC_ENTRY
EnumerateSecurityPackagesA(
    unsigned long SEC_FAR *     pcPackages,         // Receives num. packages
    PSecPkgInfoA SEC_FAR *       ppPackageInfo       // Receives array of info
    )
{
    DWORD i;
    DWORD dwTotalSize;
    PUCHAR pPack;
    PSecPkgInfoA pCurInfo;
    *ppPackageInfo = NULL;
    *pcPackages = 0;

    /* get size */
    dwTotalSize = 0;
    for(i=0; i<NumPackages; i++) {
        dwTotalSize += pGetInfoSizeA(&SecPackagesA[i]);
    }
    *ppPackageInfo = SPExternalAlloc(dwTotalSize);
    if(*ppPackageInfo == NULL) return(SEC_E_INSUFFICIENT_MEMORY);

    pPack = (PUCHAR)&(*ppPackageInfo)[NumPackages];
    for(i=0; i<NumPackages; i++) {
        pCurInfo = &(*ppPackageInfo)[i];

        CopyMemory(pCurInfo, &SecPackagesA[i], sizeof(SecPkgInfoA));
        pCurInfo->Name = (PSTR)pPack;
        strcpy(pCurInfo->Name, SecPackagesA[i].Name);
        pPack += (strlen(SecPackagesA[i].Name) + 1);

        pCurInfo->Comment = (PSTR)pPack;
        strcpy(pCurInfo->Comment, SecPackagesA[i].Comment);
        pPack += (strlen(SecPackagesA[i].Comment) + 1);
    }

    *pcPackages = NumPackages;
    return(SEC_E_OK);

}


SECURITY_STATUS SEC_ENTRY
QuerySecurityPackageInfoW(
    SEC_WCHAR SEC_FAR *         pszPackageName,     // Name of package
    PSecPkgInfoW *               ppPackageInfo       // Receives package info
    )
{
    DWORD i;
    PWCHAR pPack;
    PSecPkgInfoW pCurInfo;

    for (i = 0; i < NumPackages; i++)
    {
        if (lstrcmpiW(pszPackageName, SecPackagesW[i].Name) == 0)
        {
            break;
        }
    }
    if (i == NumPackages)
    {
        return(SEC_E_SECPKG_NOT_FOUND);
    }
    pCurInfo = SPExternalAlloc(pGetInfoSizeW(&SecPackagesW[i]));
    if(pCurInfo == NULL) return(SEC_E_INSUFFICIENT_MEMORY);
    pPack = (PWSTR)(pCurInfo+1);

    CopyMemory(pCurInfo, &SecPackagesW[i], sizeof(SecPkgInfoW));
    pCurInfo->Name = (PWSTR)pPack;
    lstrcpyW(pCurInfo->Name, SecPackagesW[i].Name);
    pPack += (lstrlenW(SecPackagesW[i].Name) + 1);

    pCurInfo->Comment = (PWSTR)pPack;
    lstrcpyW(pCurInfo->Comment, SecPackagesW[i].Comment);
    *ppPackageInfo = pCurInfo;
    return(SEC_E_OK);
}


SECURITY_STATUS SEC_ENTRY
QuerySecurityPackageInfoA(
    SEC_CHAR SEC_FAR *         pszPackageName,     // Name of package
    PSecPkgInfoA *               ppPackageInfo     // Receives package info
    )
{
    DWORD i;
    PCHAR pPack;
    PSecPkgInfoA pCurInfo;

    for(i=0; i< NumPackages; i++) {
        if (!lstrcmpiA(pszPackageName, SecPackagesA[i].Name)) break;
    }
    if (i == NumPackages)
    {
        return(SEC_E_SECPKG_NOT_FOUND);
    }
    pCurInfo = SPExternalAlloc(pGetInfoSizeA(&SecPackagesA[i]));
    if(pCurInfo == NULL) return(SEC_E_INSUFFICIENT_MEMORY);
    pPack = (PUCHAR)(pCurInfo+1);

    CopyMemory(pCurInfo, &SecPackagesA[i], sizeof(SecPkgInfoA));
    pCurInfo->Name = (PSTR)pPack;
    strcpy(pCurInfo->Name, SecPackagesA[i].Name);
    pPack += (strlen(SecPackagesA[i].Name) + 1);

    pCurInfo->Comment = (PSTR)pPack;
    strcpy(pCurInfo->Comment, SecPackagesA[i].Comment);
    *ppPackageInfo = pCurInfo;
    return(SEC_E_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\keyxmspk.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------
* RSA Public Key Cryptosystem, RC4, MD2, MD5 and RSA are trademarks
* of RSA Data Security, Inc.
*----------------------------------------------------------------------------*/

#include <spbase.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <rsa.h>
#ifdef __cplusplus
}
#endif


static VOID
ReverseMemCopy(
    PUCHAR      Dest,
    PUCHAR      Source,
    ULONG       Size)
{
    PUCHAR  p;

    p = Dest + Size - 1;
    do
    {
        *p-- = *Source++;
    } while (p >= Dest);
}

VOID
ByteSwapDwords(
    DWORD *     Dest,
    DWORD *     Source,
    DWORD       Count)
{
    DWORD   Swap;

    while (Count--)
    {
        Swap = *Source++;
        Swap = htonl(Swap);
        *Dest++ = Swap;
    }
}



long
WINAPI
PkcsDecodePublic(
    PUCHAR          pbEncoded,
    DWORD           cEncoded,
    PctPublicKey   **ppKey);


long
WINAPI
PkcsDecodePrivate(
    PUCHAR          pbEncoded,
    DWORD           cEncoded,
    PctPrivateKey   **ppKey);


BOOL
WINAPI
PkcsEncrypt(
    PUCHAR          pbClean,
    DWORD           cbClean,
    PUCHAR          pbEncrypted,
    DWORD           *pcbEncrypted,
    PctPublicKey    *pKey,
    DWORD           fProtocol);

BOOL
WINAPI
PkcsDecrypt(
    PUCHAR          pbEncrypted,
    DWORD           cbEncrypted,
    PUCHAR          pbClean,
    DWORD           *pcbClean,
    PctPrivateKey   *pKey,
    DWORD           fProtocol);


const KeyExchangeSystem keyexchPKCS = {
    SP_EXCH_RSA_PKCS1,
    "RSA",
    PkcsDecodePublic,
    PkcsDecodePrivate,
    PkcsEncrypt,
    PkcsDecrypt,
};

long
WINAPI
PkcsDecodePublic(
    PUCHAR          pbEncoded,
    DWORD           cEncoded,
    PctPublicKey   **ppKey)
{

    BSAFE_PUB_KEY * pk;
    long            Result;
    long            Bitstring;
    DWORD           dwLen, Aligned;
    DWORD           dwKeySize;
    long            index;
    PctPublicKey    *pCreatedKey = NULL;


    SP_BEGIN("PkcsDecodePublic");

    SP_ASSERT(ppKey != NULL);

    index = 0;

    if(index > (index += DecodeHeader(&dwLen, pbEncoded, cEncoded)))
       goto DecodeKey_CleanUp;

    Bitstring = index + dwLen;

    /* Determine the size of the modulus */
    /* Grab the modulus into a buffer. */
    Result = DecodeInteger(NULL,
                           0,
                           &dwLen,
                           pbEncoded+index,
                           cEncoded - index,
                           FALSE);
    if (Result < 0)
    {
        goto DecodeKey_CleanUp;
    }

    /* rsa code requires QUADWORD size-aligned keys */
    Aligned = ((dwLen + sizeof(DWORD)*2-1) & ~(sizeof(DWORD)*2 - 1));

    /* rsa code requires two extra null DWORDS padded on the end of the aligned key */
    Aligned += sizeof(DWORD)*2;
    dwKeySize = (DWORD)((PctPublicKey *)NULL)->pKey + sizeof(BSAFE_PUB_KEY) + Aligned;
    pCreatedKey = (PctPublicKey *)SPExternalAlloc(dwKeySize);
    if (NULL == pCreatedKey)
    {
        SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY);
        goto DecodeKey_CleanUp;
    }
    pk = (BSAFE_PUB_KEY *)pCreatedKey->pKey;

    Result = DecodeInteger((BYTE *)(pk+1),
                           dwLen,
                           &dwLen,
                           pbEncoded+index,
                           cEncoded - index,
                           TRUE);
    if (Result < 0)
    {
        goto DecodeKey_CleanUp;
    }


    /* repeat calculation, just in case initial length was exaggerated */
    Aligned = ((dwLen + sizeof(DWORD)*2-1) & ~(sizeof(DWORD)*2 - 1));
    Aligned += sizeof(DWORD)*2;

    pk->magic = RSA1;

    pk->keylen = Aligned;
    pk->bitlen = dwLen * 8;
    pk->datalen = dwLen-1;


    pCreatedKey->cbKey = ( dwKeySize );
    pCreatedKey->Type = SP_EXCH_RSA_PKCS1;



    index += Result;

    Result = DecodeInteger((PUCHAR)&pk->pubexp,
                           sizeof(DWORD),
                           &dwLen,
                           pbEncoded+index,
                           cEncoded - index,
                           TRUE);
    if (Result < 0)
    {
        goto DecodeKey_CleanUp;
    }

    *ppKey = pCreatedKey;

    SP_RETURN(Bitstring);

DecodeKey_CleanUp:
    if (pCreatedKey)
    {
        SPExternalFree(pCreatedKey);
    }

    SP_RETURN(-1);
}


long
WINAPI
PkcsDecodePrivate(
    PUCHAR          pbEncoded,
    DWORD           cEncoded,
    PctPrivateKey   **ppKey)
{
    DWORD           dwLen;
    long            Result;
    DWORD           dwKeySize=0;
    DWORD           dwPub, dwPriv, dwBits;
    BSAFE_PRV_KEY * pKey;
    PctPrivateKey   *pNewKey = NULL;
    DWORD           Aligned;
    BSAFE_KEY_PARTS parts;
    long            index;

    SP_BEGIN("PkcsDecodePrivate");

    index = DecodeHeader( &dwLen, pbEncoded , cEncoded);
    if (index < 0)
    {
        SP_RETURN(-1);
    }


    /* Skip past the version */


    Result = DecodeInteger( NULL, 0, &dwLen, pbEncoded+index, cEncoded-index, FALSE );
    if (Result < 0)
    {
        goto DecodePrivate_CleanUp;
    }

    index += Result;
    // Get the first part of the key to compute the number of
    // bits
    Result = DecodeInteger( NULL,
                            0,
                            &dwLen, pbEncoded+index,
                            cEncoded-index,
                            FALSE );
    if (Result < 0)
    {
        goto DecodePrivate_CleanUp;
    }
    dwBits = dwLen * 8;

    BSafeComputeKeySizes(&dwPub, &dwPriv, &dwBits );

    dwKeySize = (DWORD)((PctPrivateKey *)NULL)->pKey + dwPriv;
    pNewKey = (PctPrivateKey *)SPExternalAlloc(dwKeySize);
    if (!pNewKey)
    {
        SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY);
    	SP_RETURN(-1);
    }
    pNewKey->cbKey = dwKeySize;
    pNewKey->Type = SP_EXCH_RSA_PKCS1;
    pKey = (BSAFE_PRV_KEY *)pNewKey->pKey;

    /* Get private key */
    Result = DecodeInteger( (PUCHAR)(pKey+1),
                            dwLen,
                            &dwLen, pbEncoded+index,
                            cEncoded-index,
                            TRUE );
    if (Result < 0)
    {
        goto DecodePrivate_CleanUp;
    }

    pKey->magic = RSA2;

    /* RSA code requires 2 null dwords padded on the end of the aligned key */
    Aligned = (dwLen + sizeof(DWORD)-1) / sizeof(DWORD);

    pKey->keylen = (Aligned+2) * 4;
    pKey->bitlen = dwLen * 8;
    pKey->datalen = dwLen-1;

    BSafeGetPrvKeyParts(pKey, &parts);

    index += Result;

    Result = DecodeInteger( (PUCHAR)&pKey->pubexp,
                            sizeof(DWORD),
                            &dwLen,
                            pbEncoded+index,
                            cEncoded-index,
                            TRUE );
    if ((Result <0))
    {
        goto DecodePrivate_CleanUp;
    }

    index += Result;
    Result = DecodeInteger( parts.prvexp,
                            pKey->datalen+1,
                            &dwLen,
                            pbEncoded+index,
                            cEncoded-index,
                            TRUE );
    if ((Result <0))
    {
        goto DecodePrivate_CleanUp;
    }

    index += Result;

    Result = DecodeInteger( parts.prime1,
                            pKey->datalen+1,
                            &dwLen,
                            pbEncoded+index,
                            cEncoded-index,
                            TRUE );
    if ((Result <0))
    {
        goto DecodePrivate_CleanUp;
    }


    index += Result;

    Result = DecodeInteger( parts.prime2,
                            pKey->datalen+1,
                            &dwLen,
                            pbEncoded+index,
                            cEncoded-index,
                            TRUE );
    if ((Result <0))
    {
        goto DecodePrivate_CleanUp;
    }


    index += Result;

    Result = DecodeInteger( parts.exp1,
                            pKey->datalen+1,
                            &dwLen,
                            pbEncoded+index,
                            cEncoded-index,
                            TRUE );
    if ((Result <0))
    {
        goto DecodePrivate_CleanUp;
    }


    index += Result;

    Result = DecodeInteger( parts.exp2,
                            pKey->datalen+1,
                            &dwLen,
                            pbEncoded+index,
                            cEncoded-index,
                            TRUE );
    if ((Result <0))
    {
        goto DecodePrivate_CleanUp;
    }


    index += Result;

    Result = DecodeInteger( parts.coef,
                            pKey->datalen+1,
                            &dwLen,
                            pbEncoded+index,
                            cEncoded-index,
                            TRUE );
    if ((Result <0))
    {
        goto DecodePrivate_CleanUp;
    }


    index += Result;
    *ppKey = pNewKey;

    SP_RETURN( index);

DecodePrivate_CleanUp:
    if(pNewKey) {
        FillMemory(pNewKey, dwKeySize, 0);
        SPExternalFree( pNewKey );
    }

    SP_RETURN(-1);
}



BOOL
WINAPI
PkcsEncrypt(
    PUCHAR          pbClean,
    DWORD           cbClean,
    PUCHAR          pbEncrypted,
    DWORD           *pcbEncrypted,
    PctPublicKey    *pKey,
    DWORD 			fProtocol)
{


    UCHAR LocalBuffer[500];
    UCHAR OutputBuffer[500];
    DWORD iLoc;

    BSAFE_PUB_KEY *pk;
    SP_ASSERT(pbClean != NULL);
    SP_ASSERT(pbEncrypted != NULL);
    SP_ASSERT(pKey != NULL);
    pk = (BSAFE_PUB_KEY *)pKey->pKey;
    if(cbClean > pk->datalen - 11) return FALSE;

    FillMemory(LocalBuffer, pk->keylen, 0);
    /* BSafeEncPublic wants the data in opposite of network order */
    ReverseMemCopy(LocalBuffer, pbClean, cbClean);
    LocalBuffer[cbClean] = 0;  /* Separator */

    iLoc = cbClean+1;
    // Rollback prevention checks
    switch(fProtocol)
    {
        case SP_PROT_SSL2_CLIENT:
            if(g_ProtEnabled & SP_PROT_SSL3)
            {
                // If we're a client doing SSL2, and
                // SSL3 is enabled, then for some reason
                // the server requested SSL2.  Maybe
                // A man in the middle changed the server
                // version in the server hello to roll
                // back.  Pad with 8 0x03's so the server
                // can detect this.
                if(iLoc + 8 >= pk->datalen-1)
                {
                    return FALSE;
                }
                FillMemory(&LocalBuffer[iLoc], 8, 0x03);
                iLoc += 8;
                if(fProtocol & SP_PROT_PCT1)
                {
                }
           }

    }


    for(; iLoc < pk->datalen-1; iLoc++ )
    {
        do {
	        GenerateRandomBits(&LocalBuffer[iLoc], 1);
        } while(!LocalBuffer[iLoc]);
    }

    /* Make into pkcs block type 2 */
    LocalBuffer[pk->datalen] = 0;
    LocalBuffer[pk->datalen-1] = 2;

    if (!BSafeEncPublic(pk, LocalBuffer, OutputBuffer))
    {
	    return FALSE;
    }
    	
    *pcbEncrypted = pk->datalen+1;

    ReverseMemCopy(pbEncrypted, OutputBuffer, *pcbEncrypted);

    return TRUE;
}


BOOL
WINAPI
PkcsDecrypt(
    PUCHAR          pbEncrypted,
    DWORD           cbEncrypted,
    PUCHAR          pbClean,
    DWORD           *pcbClean,
    PctPrivateKey   *pKey,
    DWORD           fProtocol)
{
    UCHAR InputBuffer[500];
    UCHAR LocalBuffer[500];
    UCHAR *pbLocal;
    BSAFE_PRV_KEY *pk = (BSAFE_PRV_KEY *)pKey->pKey;

    if(pk->magic != RSA2)
    {
        // This isn't a bsafe key,  so it must be a WinSock 2
        // LSP key.
        SSLKEYEXCHANGEFUNC pKeyExchHook;
        LPVOID pKeyExchArg;

        // Get pointer to callback function.
        pKeyExchHook = ((PSCH_CRED_SECRET_WINSOCK2)pKey->pKey)->pKeyExchangeHookFunc;
        pKeyExchArg  = ((PSCH_CRED_SECRET_WINSOCK2)pKey->pKey)->pKeyExchangeHookArg;

        // Invoke the callback function.
        if(pKeyExchHook(SSL_EXCH_RSADECRYPT,
                        pKeyExchArg,
                        pbEncrypted,
                        cbEncrypted,
                        0, //flags
                        pbClean,
                        pcbClean) != SSL_ERR_OKAY)
        {
            return FALSE;
        }

        // Return success.
        return TRUE;
    }

    if(cbEncrypted != pk->datalen+1) return FALSE;
    FillMemory(InputBuffer, pk->keylen, 0);

    ReverseMemCopy(InputBuffer, pbEncrypted, cbEncrypted);
    BSafeDecPrivate(pk, InputBuffer, LocalBuffer);
    pbLocal = &LocalBuffer[pk->datalen-1];
    if(*pbLocal-- != 2)
    {
        return FALSE;  /* Invalid block type */
    }
    // Search backwards for a 0 byte indicating
    // the start of data

    while(*pbLocal)
    {
        if(pbLocal-- <= LocalBuffer)
        {

            // we walked off the end of our buffer
            // without finding data.
            return FALSE;
        }
    }

    *pcbClean = pbLocal - LocalBuffer;

    ReverseMemCopy(pbClean, LocalBuffer, *pcbClean);
    FillMemory(LocalBuffer, cbEncrypted, 0);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\msgs.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology 
* reference implementation, version 1.0
* 
* The Private Communication Technology reference implementation, version 1.0 
* ("PCTRef"), is being provided by Microsoft to encourage the development and 
* enhancement of an open standard for secure general-purpose business and 
* personal communications on open networks.  Microsoft is distributing PCTRef 
* at no charge irrespective of whether you use PCTRef for non-commercial or 
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without 
* warranty of any kind, either express or implied, including, without 
* limitation, the implied warranties or merchantability, fitness for a 
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out 
* of use or performance of PCTRef remains with you.
* 
* Please see the file LICENSE.txt, 
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
* 
* Please see http://pct.microsoft.com/pct/pct.htm for The Private 
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/ 

#ifndef __MSGS_H__
#define __MSGS_H__



/*
 *
 * Useful Macros
 *
 */

#define LSBOF(x)    ((UCHAR) (x & 0xFF))
#define MSBOF(x)    ((UCHAR) ((x >> 8) & 0xFF) )

#define COMBINEBYTES(Msb, Lsb)  ((DWORD) (((DWORD) (Msb) << 8) | (DWORD) (Lsb)))

/* external representations of algorithm specs */

typedef DWORD   ExtCipherSpec, *PExtCipherSpec;
typedef WORD    ExtHashSpec,   *PExtHashSpec;
typedef WORD    ExtCertSpec,   *PExtCertSpec;
typedef WORD    ExtExchSpec,   *PExtExchSpec;
typedef WORD    ExtSigSpec,    *PExtSigSpec;

typedef struct _Pct_Message_Header {
    UCHAR   Byte0;
    UCHAR   Byte1;
} Pct_Message_Header, * PPct_Message_Header;

typedef struct _Pct_Message_Header_Ex {
    UCHAR   Byte0;
    UCHAR   Byte1;
    UCHAR   PaddingSize;
} Pct_Message_Header_Ex, * PPct_Message_Header_Ex;


typedef struct _Pct_Error {
    Pct_Message_Header   Header;
    UCHAR               MessageId;
    UCHAR               ErrorMsb;
    UCHAR               ErrorLsb;
    UCHAR               ErrorInfoMsb;
    UCHAR               ErrorInfoLsb;
    UCHAR               VariantData[1];
} Pct_Error, * PPct_Error;


typedef struct _Pct_Client_Hello {
    Pct_Message_Header   Header;
    UCHAR               MessageId;
    UCHAR               VersionMsb;
    UCHAR               VersionLsb;
    UCHAR               Pad;
    UCHAR               SessionIdData[PCT_SESSION_ID_SIZE];
    UCHAR               ChallengeData[PCT_CHALLENGE_SIZE];
    UCHAR               OffsetMsb;
    UCHAR               OffsetLsb;
    UCHAR               CipherSpecsLenMsb;
    UCHAR               CipherSpecsLenLsb;
    UCHAR               HashSpecsLenMsb;
    UCHAR               HashSpecsLenLsb;
    UCHAR               CertSpecsLenMsb;
    UCHAR               CertSpecsLenLsb;
    UCHAR               ExchSpecsLenMsb;
    UCHAR               ExchSpecsLenLsb;
    UCHAR               KeyArgLenMsb;
    UCHAR               KeyArgLenLsb;
    UCHAR               VariantData[1];
} Pct_Client_Hello, * PPct_Client_Hello;


typedef struct _Pct_Server_Hello {
    Pct_Message_Header   Header;
    UCHAR               MessageId;
    UCHAR               Pad;
    UCHAR               ServerVersionMsb;
    UCHAR               ServerVersionLsb;
    UCHAR               RestartSessionOK;
    UCHAR               ClientAuthReq;
    ExtCipherSpec       CipherSpecData;
    ExtHashSpec         HashSpecData;
    ExtCertSpec         CertSpecData;
    ExtExchSpec         ExchSpecData;
    UCHAR               ConnectionIdData[PCT_SESSION_ID_SIZE];
    UCHAR               CertificateLenMsb;
    UCHAR               CertificateLenLsb;
    UCHAR               CertSpecsLenMsb;
    UCHAR               CertSpecsLenLsb;
    UCHAR               ClientSigSpecsLenMsb;
    UCHAR               ClientSigSpecsLenLsb;
    UCHAR               ResponseLenMsb;
    UCHAR               ResponseLenLsb;
    UCHAR               VariantData[1];
} Pct_Server_Hello, * PPct_Server_Hello;

typedef struct _Pct_Client_Master_Key {
    Pct_Message_Header   Header;
    UCHAR               MessageId;
    UCHAR               Pad;
    ExtCertSpec         ClientCertSpecData;
    ExtSigSpec          ClientSigSpecData;
    UCHAR               ClearKeyLenMsb;
    UCHAR               ClearKeyLenLsb;
    UCHAR               EncryptedKeyLenMsb;
    UCHAR               EncryptedKeyLenLsb;
    UCHAR               KeyArgLenMsb;
    UCHAR               KeyArgLenLsb;
    UCHAR               VerifyPreludeLenMsb;
    UCHAR               VerifyPreludeLenLsb;
    UCHAR               ClientCertLenMsb;
    UCHAR               ClientCertLenLsb;
    UCHAR               ResponseLenMsb;
    UCHAR               ResponseLenLsb;
    UCHAR               VariantData[1];
} Pct_Client_Master_Key, * PPct_Client_Master_Key;


typedef struct _Pct_Server_Verify {
    Pct_Message_Header   Header;
    UCHAR               MessageId;
    UCHAR               Pad;
    UCHAR               SessionIdData[PCT_SESSION_ID_SIZE];
    UCHAR               ResponseLenMsb;
    UCHAR               ResponseLenLsb;
    UCHAR               VariantData[1];
} Pct_Server_Verify, * PPct_Server_Verify;



/*
 *
 * Expanded Form Messages:
 *
 */

typedef struct _PctError {
	DWORD			Error;
	DWORD			ErrInfoLen;
	BYTE			*ErrInfo;
} PctError, *PPctError;

typedef struct _Client_Hello {
    DWORD           cCipherSpecs;
    DWORD           cHashSpecs;
    DWORD           cCertSpecs;
    DWORD           cExchSpecs;
    DWORD           cbKeyArgSize;
    CipherSpec *    pCipherSpecs;
    HashSpec *      pHashSpecs;
    CertSpec *      pCertSpecs;
    ExchSpec *      pExchSpecs;
    PctSessionId    SessionId;
    PctChallenge    Challenge;
    PUCHAR          pKeyArg;
} Client_Hello, * PClient_Hello;


typedef struct _Server_Hello {
    DWORD           RestartOk;
    DWORD           ClientAuthReq;
    DWORD           CertificateLen;
    DWORD           ResponseLen;
    DWORD           cSigSpecs;
    DWORD           cCertSpecs;
    PctSessionId    Connection;
    UCHAR *         pCertificate;
    UCHAR           Response[RESPONSE_SIZE];
    CipherSpec      SrvCipherSpec;
    HashSpec        SrvHashSpec;
    CertSpec        SrvCertSpec;
    ExchSpec        SrvExchSpec;
    SigSpec *       pClientSigSpecs;
    CertSpec *      pClientCertSpecs;
} Server_Hello, * PServer_Hello;

typedef struct _Client_Master_Key {
    DWORD           ClearKeyLen;
    DWORD           EncryptedKeyLen;
    DWORD           KeyArgLen;
    DWORD           VerifyPreludeLen;
    DWORD           ClientCertLen;
    DWORD           ResponseLen;
    CertSpec        ClientCertSpec;
    SigSpec         ClientSigSpec;
    UCHAR           ClearKey[MASTER_KEY_SIZE];
    UCHAR           EncryptedKey[ENCRYPTED_KEY_SIZE];
    UCHAR           KeyArg[MASTER_KEY_SIZE];
    UCHAR           ClientCert[CERT_SIZE];
    UCHAR           Response[PCT_SIGNATURE_SIZE];
    UCHAR           VerifyPrelude[RESPONSE_SIZE];
} Client_Master_Key, * PClient_Master_Key;

typedef struct _Server_Verify {
    UCHAR           SessionIdData[PCT_SESSION_ID_SIZE];
    DWORD           ResponseLen;
    UCHAR           Response[RESPONSE_SIZE];
} Server_Verify, * PServer_Verify;

/*
 *
 * Pickling Prototypes
 *
 */

SP_STATUS
PackClientHello(
    PClient_Hello       pCanonical,
    PPctBuffer          pCommOutput);

SP_STATUS
UnpackClientHello(
    PPctBuffer          pInput,
    PClient_Hello *     ppClient);

SP_STATUS
PackServerHello(
    PServer_Hello       pCanonical,
    PPctBuffer          pCommOutput);

SP_STATUS
UnpackServerHello(
    PPctBuffer          pInput,
    PServer_Hello *     ppServer);

SP_STATUS
PackClientMasterKey(
    PClient_Master_Key      pCanonical,
    PPctBuffer              pCommOutput);

SP_STATUS
UnpackClientMasterKey(
    PPctBuffer              pInput,
    PClient_Master_Key *    ppClient);

SP_STATUS
PackServerVerify(
    PServer_Verify          pCanonical,
    PPctBuffer              pCommOutput);

SP_STATUS
UnpackServerVerify(
    PPctBuffer              pInput,
    PServer_Verify *        ppServer);

SP_STATUS
PackPctError(
    PPctError               pCanonical,
    PPctBuffer              pCommOutput);

#endif /* __MSGS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\nt5verp.h ===
/****************************************************************************
 *                                                                          *
 *      ntverp.H        -- Version information for internal builds          *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION, VER_PRODUCTVERSION_STR and             *
 *      VER_PRODUCTBETA_STR values.                                         *
 *                                                                          *
 ****************************************************************************/

/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*                                                              */
/* the VER_PRODUCTBUILD lines must contain the product          */
/* comments (Win9x or NT) and end with the build#<CR><LF>       */
/*                                                              */
/* the VER_PRODUCTBETA_STR lines must contain the product       */
/* comments (Win9x or NT) and end with "some string"<CR><LF>    */
/*--------------------------------------------------------------*/


#if defined(NASHVILLE)
#include <ieverp.h>
#else
#define VER_PRODUCTBUILD_QFE        1
#define VER_PRODUCTBUILD            /* NT */     1429
#define VER_PRODUCTBETA_STR         /* NT */     ""
#define VER_PRODUCTVERSION_STRING   "4.72"
#define VER_PRODUCTVERSION          4,72,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE
#define VER_PRODUCTVERSION_W        (0x0472)
#define VER_PRODUCTVERSION_DW       (0x04720000 | VER_PRODUCTBUILD)

#endif

#if 	(VER_PRODUCTBUILD < 10)
#define VER_BPAD "000"
#elif	(VER_PRODUCTBUILD < 100)
#define VER_BPAD "00"
#elif	(VER_PRODUCTBUILD < 1000)
#define VER_BPAD "0"
#else
#define VER_BPAD
#endif

#define VER_PRODUCTVERSION_STR2(x,y) VER_PRODUCTVERSION_STRING "." VER_BPAD #x "." #y
#define VER_PRODUCTVERSION_STR1(x,y) VER_PRODUCTVERSION_STR2(x, y)
#define VER_PRODUCTVERSION_STR       VER_PRODUCTVERSION_STR1(VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE)

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#if DBG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

/* default is prerelease */
#if BETA
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_NT_WINDOWS32
#define VER_FILEFLAGS               (VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation"
#define VER_PRODUCTNAME_STR         "Microsoft(R) Windows NT(R) Operating System"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft(R) is a registered trademark of Microsoft Corporation. Windows NT(R) is a registered trademark of Microsoft Corporation."
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\pct1msg.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology 
* reference implementation, version 1.0
* 
* The Private Communication Technology reference implementation, version 1.0 
* ("PCTRef"), is being provided by Microsoft to encourage the development and 
* enhancement of an open standard for secure general-purpose business and 
* personal communications on open networks.  Microsoft is distributing PCTRef 
* at no charge irrespective of whether you use PCTRef for non-commercial or 
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without 
* warranty of any kind, either express or implied, including, without 
* limitation, the implied warranties or merchantability, fitness for a 
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out 
* of use or performance of PCTRef remains with you.
* 
* Please see the file LICENSE.txt, 
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
* 
* Please see http://pct.microsoft.com/pct/pct.htm for The Private 
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/ 

#ifndef __PCT1MSG_H__
#define __PCT1MSG_H__

#define PCT_CH_OFFSET_V1		(WORD)10
#define PCT_VERSION_1			(WORD)0x8001

/* message type codes */
#define PCT1_MSG_NOMSG               0x00
#define PCT1_MSG_CLIENT_HELLO		0x01
#define PCT1_MSG_SERVER_HELLO		0x02
#define PCT1_MSG_CLIENT_MASTER_KEY	0x03
#define PCT1_MSG_SERVER_VERIFY		0x04
#define PCT1_MSG_ERROR				0x05

#define PCT1_ET_OOB_DATA             0x01
#define PCT1_ET_REDO_CONN            0x02



#define PCT1_SESSION_ID_SIZE         32
#define PCT1_CHALLENGE_SIZE          32
#define PCT1_MASTER_KEY_SIZE         16
#define PCT1_RESPONSE_SIZE           32
#define PCT1_ENCRYPTED_KEY_SIZE      272 // allows for 2048 bit keys
#define PCT1_SIGNATURE_SIZE          256 // allow for 2048 bit keys
#define PCT1_MAX_MESSAGE_LENGTH     32768
#define PCT1_MAX_CLIENT_HELLO       256


/*
 *
 * Useful Macros
 *
 */

#define LSBOF(x)    ((UCHAR) (x & 0xFF))
#define MSBOF(x)    ((UCHAR) ((x >> 8) & 0xFF) )

#define COMBINEBYTES(Msb, Lsb)  ((DWORD) (((DWORD) (Msb) << 8) | (DWORD) (Lsb)))

/* external representations of algorithm specs */

typedef DWORD   ExtCipherSpec, *PExtCipherSpec;
typedef WORD    ExtHashSpec,   *PExtHashSpec;
typedef WORD    ExtCertSpec,   *PExtCertSpec;
typedef WORD    ExtExchSpec,   *PExtExchSpec;
typedef WORD    ExtSigSpec,    *PExtSigSpec;

typedef struct _PCT1_MESSAGE_HEADER {
    UCHAR   Byte0;
    UCHAR   Byte1;
} PCT1_MESSAGE_HEADER, * PPCT1_MESSAGE_HEADER;

typedef struct _PCT1_MESSAGE_HEADER_EX {
    UCHAR   Byte0;
    UCHAR   Byte1;
    UCHAR   PaddingSize;
} PCT1_MESSAGE_HEADER_EX, * PPCT1_MESSAGE_HEADER_EX;


typedef struct _PCT1_ERROR {
    PCT1_MESSAGE_HEADER   Header;
    UCHAR               MessageId;
    UCHAR               ErrorMsb;
    UCHAR               ErrorLsb;
    UCHAR               ErrorInfoMsb;
    UCHAR               ErrorInfoLsb;
    UCHAR               VariantData[1];
} PCT1_ERROR, * PPCT1_ERROR;


typedef struct _PCT1_CLIENT_HELLO {
    PCT1_MESSAGE_HEADER   Header;
    UCHAR               MessageId;
    UCHAR               VersionMsb;
    UCHAR               VersionLsb;
    UCHAR               Pad;
    UCHAR               SessionIdData[PCT1_SESSION_ID_SIZE];
    UCHAR               ChallengeData[PCT1_CHALLENGE_SIZE];
    UCHAR               OffsetMsb;
    UCHAR               OffsetLsb;
    UCHAR               CipherSpecsLenMsb;
    UCHAR               CipherSpecsLenLsb;
    UCHAR               HashSpecsLenMsb;
    UCHAR               HashSpecsLenLsb;
    UCHAR               CertSpecsLenMsb;
    UCHAR               CertSpecsLenLsb;
    UCHAR               ExchSpecsLenMsb;
    UCHAR               ExchSpecsLenLsb;
    UCHAR               KeyArgLenMsb;
    UCHAR               KeyArgLenLsb;
    UCHAR               VariantData[1];
} PCT1_CLIENT_HELLO, * PPCT1_CLIENT_HELLO;


typedef struct _PCT1_SERVER_HELLO {
    PCT1_MESSAGE_HEADER   Header;
    UCHAR               MessageId;
    UCHAR               Pad;
    UCHAR               ServerVersionMsb;
    UCHAR               ServerVersionLsb;
    UCHAR               RestartSessionOK;
    UCHAR               ClientAuthReq;
    ExtCipherSpec       CipherSpecData;
    ExtHashSpec         HashSpecData;
    ExtCertSpec         CertSpecData;
    ExtExchSpec         ExchSpecData;
    UCHAR               ConnectionIdData[PCT1_SESSION_ID_SIZE];
    UCHAR               CertificateLenMsb;
    UCHAR               CertificateLenLsb;
    UCHAR               CertSpecsLenMsb;
    UCHAR               CertSpecsLenLsb;
    UCHAR               ClientSigSpecsLenMsb;
    UCHAR               ClientSigSpecsLenLsb;
    UCHAR               ResponseLenMsb;
    UCHAR               ResponseLenLsb;
    UCHAR               VariantData[1];
} PCT1_SERVER_HELLO, * PPCT1_SERVER_HELLO;

typedef struct _PCT1_CLIENT_MASTER_KEY {
    PCT1_MESSAGE_HEADER   Header;
    UCHAR               MessageId;
    UCHAR               Pad;
    ExtCertSpec         ClientCertSpecData;
    ExtSigSpec          ClientSigSpecData;
    UCHAR               ClearKeyLenMsb;
    UCHAR               ClearKeyLenLsb;
    UCHAR               EncryptedKeyLenMsb;
    UCHAR               EncryptedKeyLenLsb;
    UCHAR               KeyArgLenMsb;
    UCHAR               KeyArgLenLsb;
    UCHAR               VerifyPreludeLenMsb;
    UCHAR               VerifyPreludeLenLsb;
    UCHAR               ClientCertLenMsb;
    UCHAR               ClientCertLenLsb;
    UCHAR               ResponseLenMsb;
    UCHAR               ResponseLenLsb;
    UCHAR               VariantData[1];
} PCT1_CLIENT_MASTER_KEY, * PPCT1_CLIENT_MASTER_KEY;


typedef struct _PCT1_SERVER_VERIFY {
    PCT1_MESSAGE_HEADER   Header;
    UCHAR               MessageId;
    UCHAR               Pad;
    UCHAR               SessionIdData[PCT1_SESSION_ID_SIZE];
    UCHAR               ResponseLenMsb;
    UCHAR               ResponseLenLsb;
    UCHAR               VariantData[1];
} PCT1_SERVER_VERIFY, * PPCT1_SERVER_VERIFY;



/*
 *
 * Expanded Form Messages:
 *
 */

typedef struct _Pct1_Error {
	DWORD			Error;
	DWORD			ErrInfoLen;
	BYTE			*ErrInfo;
} Pct1Error, *PPct1_Error;

typedef struct _Pct1_Client_Hello {
    DWORD           cCipherSpecs;
    DWORD           cHashSpecs;
    DWORD           cCertSpecs;
    DWORD           cExchSpecs;
    DWORD           cbKeyArgSize;
	DWORD           cbSessionID;
	DWORD           cbChallenge;
    PUCHAR          pKeyArg;
    CipherSpec      * pCipherSpecs;
    HashSpec        * pHashSpecs;
    CertSpec        * pCertSpecs;
    ExchSpec        * pExchSpecs;
    UCHAR           SessionID[PCT1_SESSION_ID_SIZE];
	UCHAR           Challenge[PCT1_CHALLENGE_SIZE];
} Pct1_Client_Hello, * PPct1_Client_Hello;


typedef struct _Pct1_Server_Hello {
    DWORD           RestartOk;
    DWORD           ClientAuthReq;
    DWORD           CertificateLen;
    DWORD           ResponseLen;
    DWORD           cSigSpecs;
    DWORD           cCertSpecs;
	DWORD           cbConnectionID;
    UCHAR *         pCertificate;
    CipherSpec      SrvCipherSpec;
    HashSpec        SrvHashSpec;
    CertSpec        SrvCertSpec;
    ExchSpec        SrvExchSpec;
    SigSpec         * pClientSigSpecs;
    CertSpec        * pClientCertSpecs;
    UCHAR           ConnectionID[PCT1_SESSION_ID_SIZE];
    UCHAR           Response[PCT1_RESPONSE_SIZE];
} Pct1_Server_Hello, * PPct1_Server_Hello;

typedef struct _Pct1_Client_Master_Key {
    DWORD           ClearKeyLen;
    DWORD           EncryptedKeyLen;
    DWORD           KeyArgLen;
    DWORD           VerifyPreludeLen;
    DWORD           ClientCertLen;
    DWORD           ResponseLen;
    CertSpec        ClientCertSpec;
    SigSpec         ClientSigSpec;
    UCHAR           ClearKey[PCT1_MASTER_KEY_SIZE];
    UCHAR           EncryptedKey[PCT1_ENCRYPTED_KEY_SIZE];
    UCHAR           KeyArg[PCT1_MASTER_KEY_SIZE];
    PUCHAR          pClientCert;
    UCHAR           Response[PCT1_SIGNATURE_SIZE];
    UCHAR           VerifyPrelude[PCT1_RESPONSE_SIZE];
} Pct1_Client_Master_Key, * PPct1_Client_Master_Key;

typedef struct _Pct1_Server_Verify {
    UCHAR           SessionIdData[PCT1_SESSION_ID_SIZE];
    DWORD           ResponseLen;
    UCHAR           Response[PCT1_RESPONSE_SIZE];
} Pct1_Server_Verify, * PPct1_Server_Verify;

/*
 *
 * Pickling Prototypes
 *
 */

SP_STATUS
Pct1PackClientHello(
    PPct1_Client_Hello       pCanonical,
    PSPBuffer          pCommOutput);

SP_STATUS
Pct1UnpackClientHello(
    PSPBuffer          pInput,
    PPct1_Client_Hello *     ppClient);

SP_STATUS
Pct1PackServerHello(
    PPct1_Server_Hello       pCanonical,
    PSPBuffer          pCommOutput);

SP_STATUS
Pct1UnpackServerHello(
    PSPBuffer          pInput,
    PPct1_Server_Hello *     ppServer);

SP_STATUS
Pct1PackClientMasterKey(
    PPct1_Client_Master_Key      pCanonical,
    PSPBuffer              pCommOutput);

SP_STATUS
Pct1UnpackClientMasterKey(
    PSPBuffer              pInput,
    PPct1_Client_Master_Key *    ppClient);

SP_STATUS
Pct1PackServerVerify(
    PPct1_Server_Verify          pCanonical,
    PSPBuffer              pCommOutput);

SP_STATUS
Pct1UnpackServerVerify(
    PSPBuffer              pInput,
    PPct1_Server_Verify *        ppServer);

SP_STATUS
Pct1PackError(
    PPct1_Error               pCanonical,
    PSPBuffer              pCommOutput);

#endif /* __PCT1MSG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\pct1comp.h ===
#ifndef _PCT1COMP_H_
#define _PCT1COMP_H_

#ifdef DO_PCT_COMPAT

SP_STATUS PctCompatHandler(PPctContext pContext,
			   PSPBuffer  pCommInput,
			   PSsl2_Client_Hello pHello,
                           PSPBuffer  pCommOutput);

#endif

#endif /* _PCT1COMP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\pct1msg.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/

#include <spbase.h>
#include <pct1msg.h>
#include <pct1prot.h>


CipherSpec Pct1CipherRank[] = {
    SP_CIPHER_RC4 | SP_ENC_BITS_128 | SP_MAC_BITS_128,
    SP_CIPHER_RC4 | SP_ENC_BITS_64  | SP_MAC_BITS_128,
    SP_CIPHER_RC4 | SP_ENC_BITS_40  | SP_MAC_BITS_128
};

const DWORD Pct1NumCipher = sizeof(Pct1CipherRank)/sizeof(CipherSpec);

/* available hashes, in order of preference */
HashSpec Pct1HashRank[] = {
    SP_HASH_MD5,
    SP_HASH_SHA
};
const DWORD Pct1NumHash = sizeof(Pct1HashRank)/sizeof(HashSpec);

CertSpec Pct1CertRank[] = {
    SP_CERT_X509
};
const DWORD Pct1NumCert = sizeof(Pct1CertRank)/sizeof(CertSpec);


SigSpec Pct1SigRank[] = {
    SP_SIG_RSA_MD5,
};
const DWORD Pct1NumSig = sizeof(Pct1SigRank)/sizeof(SigSpec);


ExchSpec Pct1ExchRank[] = {
   SP_EXCH_RSA_PKCS1
};

const DWORD Pct1NumExch = sizeof(Pct1ExchRank)/sizeof(ExchSpec);


SP_STATUS WINAPI
Pct1EncryptRaw( PSPContext          pContext,
                    PSPBuffer       pAppInput,
                    PSPBuffer       pCommOutput,
                    DWORD           dwFlags)
{
    SP_STATUS                  pctRet;
    DWORD                       cPadding;
    SPBuffer                   Clean;
    SPBuffer                   Encrypted;

    PCheckSumBuffer             pSum, pSubSum;
    HashBuf                     SumBuf, SubSumBuf;
    DWORD                       ReverseSequence;
    BOOL                        fEscape;
    DWORD                       cbHeader;

#if DBG
    DWORD           di;
    CHAR            KeyDispBuf[MASTER_KEY_SIZE*2+1];
#endif


    fEscape = (0 != (dwFlags & PCT1_ENCRYPT_ESCAPE));
    /* Generate Padding */
    Clean.cbData = pAppInput->cbData;
    Clean.cbBuffer = pAppInput->cbBuffer;
    Clean.pvBuffer = pAppInput->pvBuffer;
    cPadding = Clean.cbData & (pContext->pSystem->BlockSize - 1);
    if(Clean.cbData + cPadding > Clean.cbBuffer)
    {
        return PCT_INT_BUFF_TOO_SMALL;
    }

    GenerateRandomBits( (PUCHAR)Clean.pvBuffer + Clean.cbData, cPadding );

    Clean.cbData += cPadding;

    if(fEscape || (0 != cPadding)) {
        cbHeader = sizeof(PCT1_MESSAGE_HEADER_EX);
    }
    else
    {
        cbHeader = sizeof(PCT1_MESSAGE_HEADER);
    }
    if(pCommOutput->cbBuffer < (cbHeader + cPadding + Clean.cbData))
    {
        return PCT_INT_BUFF_TOO_SMALL;
    }

    Encrypted.pvBuffer = (PUCHAR)pCommOutput->pvBuffer+cbHeader;
    Encrypted.cbBuffer = pCommOutput->cbBuffer-cbHeader;


    DebugLog((DEB_TRACE, "Sealing message %x\n", pContext->WriteCounter));


    /* Begin Checksum Process */
    CloneHashBuf(SumBuf, pContext->WriteMACState, pContext->pCheck);
    CloneHashBuf(SubSumBuf, pContext->InitMACState, pContext->pCheck);
    pSum = (PCheckSumBuffer)SumBuf;
    pSubSum = (PCheckSumBuffer)SubSumBuf;

    pContext->pCheck->Sum( pSubSum, pAppInput->cbData, (PUCHAR)pAppInput->pvBuffer );

    ReverseSequence = htonl( pContext->WriteCounter );
    pContext->pCheck->Sum( pSubSum, sizeof(DWORD), (PUCHAR) &ReverseSequence );


    pctRet = pContext->pSystem->Encrypt( pContext->pWriteState,
                     pAppInput,
                     &Encrypted);

    /* Perform encryption to fill buffer */
    if(PCT_ERR_OK != pctRet)
    {
        return pctRet;
    }

    if(Encrypted.cbData + pContext->pCheck->cbCheckSum > Encrypted.cbBuffer)
    {
        return PCT_INT_BUFF_TOO_SMALL;
    }


    /* complete checksum, now that we know where to put it */
    pContext->pCheck->Finalize( pSubSum, (PUCHAR)Encrypted.pvBuffer + Encrypted.cbData);

    pContext->pCheck->Sum( pSum, pContext->pCheck->cbCheckSum,
                           (PUCHAR)Encrypted.pvBuffer + Encrypted.cbData);
    pContext->pCheck->Finalize( pSum, (PUCHAR)Encrypted.pvBuffer + Encrypted.cbData );

    Encrypted.cbData += pContext->pCheck->cbCheckSum;

    /* set sizes */
    if(fEscape || (0 != cPadding)) {
        if(Encrypted.cbData > 0x3fff)
        {
            return PCT_INT_DATA_OVERFLOW;
        }

        ((PUCHAR)pCommOutput->pvBuffer)[0]= (UCHAR)(0x3f & (Encrypted.cbData>>8));
        if(fEscape)
        {
            ((PUCHAR)pCommOutput->pvBuffer)[0] |= 0x40;
        }

        ((PUCHAR)pCommOutput->pvBuffer)[1]= (UCHAR)(0xff & Encrypted.cbData);
        ((PUCHAR)pCommOutput->pvBuffer)[2]= (UCHAR)cPadding;

    } else {
        if(Encrypted.cbData > 0x7fff)
        {
            return PCT_INT_DATA_OVERFLOW;
        }
        ((PUCHAR)pCommOutput->pvBuffer)[0]= (UCHAR)(0x7f & (Encrypted.cbData>>8)) | 0x80;
        ((PUCHAR)pCommOutput->pvBuffer)[1]= (UCHAR)(0xff & Encrypted.cbData);
    }

    pCommOutput->cbData = Encrypted.cbData + cbHeader;

#if DBG
    for(di=0;di<MASTER_KEY_SIZE;di++)
        wsprintf(KeyDispBuf+(di*2), "%2.2x",
                ((BYTE *)Encrypted.pvBuffer+Encrypted.cbData-pContext->pCheck->cbCheckSum)[di]);
    DebugLog((DEB_TRACE, "  MAC\t%s\n", KeyDispBuf));
#endif

    pContext->WriteCounter ++ ;

    return( PCT_ERR_OK );

}
SP_STATUS WINAPI
Pct1EncryptMessage( PSPContext      pContext,
                    PSPBuffer       pAppInput,
                    PSPBuffer       pCommOutput)
{
    return Pct1EncryptRaw(pContext, pAppInput, pCommOutput,0);
}

SP_STATUS WINAPI
Pct1DecryptMessage( PSPContext          pContext,
                   PSPBuffer          pMessage,
                   PSPBuffer          pAppOutput)
{

    SP_STATUS              pctRet;
    DWORD                   cPadding;
    DWORD                   dwLength;
    PUCHAR                  pbMAC;
    DWORD                   cbData;

    SPBuffer               Encrypted;

    PCheckSumBuffer         pSum, pSubSum;
    HashBuf                 SumBuf, SubSumBuf;
    DWORD                   ReverseSequence;
    DWORD                   cbActualData;
    UCHAR                   Digest[16];
#if DBG
    DWORD           di;
    CHAR            KeyDispBuf[MASTER_KEY_SIZE*2+1];
#endif

    /* First determine the length of data, the length of padding,
     * and the location of data, and the location of MAC */
    cbActualData = pMessage->cbData;
    pMessage->cbData = 2; /* minimum amount of data we need */

    if(pMessage->cbData > cbActualData)
    {
        return PCT_INT_INCOMPLETE_MSG;
    }

    if(  ((PUCHAR)pMessage->pvBuffer)[0]&0x80 ) {
        /* 2 byte header */
        cPadding = 0;
        dwLength = ((((PUCHAR)pMessage->pvBuffer)[0]&0x7f)<< 8) | ((PUCHAR)pMessage->pvBuffer)[1];
        Encrypted.pvBuffer = ((PUCHAR)pMessage->pvBuffer) + 2;
    } else {
        pMessage->cbData++;
        if(pMessage->cbData > cbActualData)
        {
            return PCT_INT_INCOMPLETE_MSG;
        }
        /* 3 byte header */
        cPadding = ((PUCHAR)pMessage->pvBuffer)[2];
        dwLength = ((((PUCHAR)pMessage->pvBuffer)[0]&0x3f)<< 8) | ((PUCHAR)pMessage->pvBuffer)[1];
        Encrypted.pvBuffer = ((PUCHAR)pMessage->pvBuffer) + 3;
    }

    /* Now we know how mutch data we will eat, so set cbData on the Input to be that size */
    pMessage->cbData += dwLength;
    /* do we have enough bytes for the reported data */
    if(pMessage->cbData > cbActualData)
    {
        return PCT_INT_INCOMPLETE_MSG;
    }

    /* do we have engough data for our checksum */
    if(dwLength < pContext->pCheck->cbCheckSum)
    {
        return SP_LOG_RESULT(PCT_INT_MSG_ALTERED);
    }
    Encrypted.cbData = dwLength - pContext->pCheck->cbCheckSum; /* encrypted data size */
    pbMAC = (PUCHAR)Encrypted.pvBuffer + Encrypted.cbData;            /* location of MAC */
    cbData = Encrypted.cbData - cPadding;                       /* size of actual data */

    /* check to see if we have a block size violation */
    if(Encrypted.cbData % pContext->pSystem->BlockSize)
    {
        return SP_LOG_RESULT(PCT_INT_MSG_ALTERED);
    }

    Encrypted.cbBuffer = Encrypted.cbData;

    /* Decrypt */
    pctRet = pContext->pSystem->Decrypt( pContext->pReadState,
                                &Encrypted,
                                pAppOutput);
    if(PCT_ERR_OK != pctRet)
    {
        return pctRet;
    }

    /* Validate MAC: */


    CloneHashBuf(SumBuf, pContext->ReadMACState, pContext->pCheck);
    CloneHashBuf(SubSumBuf, pContext->InitMACState, pContext->pCheck);

    pSum = (PCheckSumBuffer)SumBuf;
    pSubSum = (PCheckSumBuffer)SubSumBuf;

    pContext->pCheck->Sum( pSubSum, pAppOutput->cbData, pAppOutput->pvBuffer);

    ReverseSequence = htonl( pContext->ReadCounter );

    DebugLog((DEB_TRACE, "Unsealing message %x\n", pContext->ReadCounter));

    pContext->pCheck->Sum( pSubSum, sizeof(DWORD), (PUCHAR) &ReverseSequence );
    pContext->pCheck->Finalize( pSubSum, Digest );
    pContext->pCheck->Sum( pSum, pContext->pCheck->cbCheckSum, Digest );
    pContext->pCheck->Finalize( pSum, Digest );

    pContext->ReadCounter++;

#if DBG

    for(di=0;di<MASTER_KEY_SIZE;di++)
        wsprintf(KeyDispBuf+(di*2), "%2.2x",
                pbMAC[di]);
    DebugLog((DEB_TRACE, "  Incoming MAC\t%s\n", KeyDispBuf));

    for(di=0;di<MASTER_KEY_SIZE;di++)
        wsprintf(KeyDispBuf+(di*2), "%2.2x",
                Digest[di]);
    DebugLog((DEB_TRACE, "  Computed MAC\t%s\n", KeyDispBuf));

#endif

    if (memcmp( Digest, pbMAC, pContext->pCheck->cbCheckSum ) )
    {
       return SP_LOG_RESULT(PCT_INT_MSG_ALTERED);
    }

    pAppOutput->cbData = cbData;

    return( PCT_ERR_OK );
}

SP_STATUS
PctComputeKey(PCheckSumBuffer *ppHash,
              PSPContext  pContext,
              UCHAR *Buffer,
              CONST CHAR * pConst,
              DWORD dwCLen,
              DWORD fFlags)
{
    DWORD               BufferLen;

#if DBG
#if DBG_WATCH_KEYS
    DWORD   di;
    CHAR    BufDispBuf[16 * 3 + 5];
#endif
#endif
    SP_BEGIN("PctComputeKey");


    BufferLen = 0;

    Buffer[BufferLen] = 1;
    BufferLen += 1;

    if (!(fFlags & PCT_MAKE_MAC))
    {
        /* add the first constant */
        CopyMemory(Buffer+BufferLen, pConst, dwCLen);
        BufferLen += dwCLen;
    }

    /* add the master key */
    CopyMemory(Buffer+BufferLen, pContext->RipeZombie->pMasterKey, MASTER_KEY_SIZE );
    BufferLen += MASTER_KEY_SIZE;

    /* repeat the constant */
    CopyMemory(Buffer+BufferLen, pConst, dwCLen);
    BufferLen += dwCLen;

    /* add the connection id */
    CopyMemory(Buffer+BufferLen, pContext->pConnectionID,
               pContext->cbConnectionID);
    BufferLen += pContext->cbConnectionID;

    /* repeat the constant */
    CopyMemory(Buffer+BufferLen, pConst, dwCLen);
    BufferLen += dwCLen;

    if (fFlags & PCT_USE_CERT)
    {
        /* add in the certificate */
        CopyMemory(Buffer+BufferLen, (UCHAR *)pContext->RipeZombie->pServerCert->pRawCert,
                   pContext->RipeZombie->pServerCert->cbRawCert);
        BufferLen += pContext->RipeZombie->pServerCert->cbRawCert;

        /* repeat the constant */
        CopyMemory(Buffer+BufferLen, pConst, dwCLen);
        BufferLen += dwCLen;
    }

    /* add the challenge */
    CopyMemory(Buffer+BufferLen, (UCHAR *)pContext->pChallenge,
               pContext->cbChallenge);
    BufferLen += pContext->cbChallenge;

    /* again, repeat the constant */
    CopyMemory(Buffer+BufferLen, pConst, dwCLen);
    BufferLen += dwCLen;

#if DBG

#if DBG_WATCH_KEYS

    DebugLog((DEB_TRACE, "Buffer:\n"));

    BufDispBuf[0] = 0;
    for(di=0;di<BufferLen;di++)
    {
        wsprintf(BufDispBuf+((di % 16)*3), "%2.2x ", Buffer[di]);

        if ((di & 15) == 15)
        {
            DebugLog((DEB_TRACE, "\t%s\n", BufDispBuf));
            BufDispBuf[0] = 0;
        }
    }

    DebugLog((DEB_TRACE, "\t%s\n", BufDispBuf));

#endif

#endif

    /* hash the buffer */
    pContext->pCheck->Sum( *ppHash, BufferLen, Buffer );
    SP_RETURN(PCT_ERR_OK);
}

SP_STATUS
Pct1MakeSessionKeys(
    PSPContext  pContext)
{
    SP_STATUS           pctRet;
    PCheckSumBuffer     CWriteHash, SWriteHash, CMacHash, SMacHash;
    PCheckSumBuffer     CExportKey, SExportKey;
    UCHAR               pWriteKey[MASTER_KEY_SIZE], pReadKey[MASTER_KEY_SIZE];
    UCHAR               Buffer[DERIVATION_BUFFER_SIZE];
    DWORD               BufferLen, MaxBufferLen, dwKeyLen;
    HashBuf             CWriteHB, SWriteHB, CMACHB, SMACHB, CExpHB, SExpHB;
#if DBG
    DWORD       i;
    CHAR        KeyDispBuf[MASTER_KEY_SIZE*2+1];
#endif

    SP_BEGIN("PctMakeSessionKeys");

    if (!pContext->InitMACState)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    InitHashBuf(CWriteHB, pContext);
    InitHashBuf(SWriteHB, pContext);
    InitHashBuf(CMACHB, pContext);
    InitHashBuf(SMACHB, pContext);
    InitHashBuf(CExpHB, pContext);
    InitHashBuf(SExpHB, pContext);

    CWriteHash = (PCheckSumBuffer)CWriteHB;
    SWriteHash = (PCheckSumBuffer)SWriteHB;
    CMacHash = (PCheckSumBuffer)CMACHB;
    SMacHash = (PCheckSumBuffer)SMACHB;
    CExportKey = (PCheckSumBuffer)CExpHB;
    SExportKey = (PCheckSumBuffer)SExpHB;


#if DBG
    DebugLog((DEB_TRACE, "Making session keys\n", KeyDispBuf));

    for(i=0;i<MASTER_KEY_SIZE;i++)
        wsprintf(KeyDispBuf+(i*2), "%2.2x",
                pContext->pConnectionID[i]);
    DebugLog((DEB_TRACE, "  ConnId\t%s\n", KeyDispBuf));

    for(i=0;i<MASTER_KEY_SIZE;i++)
        wsprintf(KeyDispBuf+(i*2), "%2.2x",
                pContext->RipeZombie->pServerCert->pRawCert[i]);
    DebugLog((DEB_TRACE, "  Cert\t%s\n", KeyDispBuf));

    for(i=0;i<MASTER_KEY_SIZE;i++)
        wsprintf(KeyDispBuf+(i*2), "%2.2x", (UCHAR)pContext->pChallenge[i]);
    DebugLog((DEB_TRACE, "  Challenge \t%s\n", KeyDispBuf));

    for(i=0;i<pContext->RipeZombie->cbClearKey;i++)
        wsprintf(KeyDispBuf+(i*2), "%2.2x", (UCHAR)pContext->RipeZombie->pClearKey[i]);
    DebugLog((DEB_TRACE, "  ClearKey \t%s\n", KeyDispBuf));

#endif


    MaxBufferLen = 1 +      /* initial number */
                   PCT_MAX_NUM_SEP * PCT_MAX_SEP_LEN +
                   MASTER_KEY_SIZE +
                   PCT_SESSION_ID_SIZE +
                   PCT_SESSION_ID_SIZE +
                   pContext->RipeZombie->pServerCert->cbRawCert;

    if (MaxBufferLen > DERIVATION_BUFFER_SIZE)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW));
    }

    /* compute the ClientWriteKey */

    pctRet = PctComputeKey( &CWriteHash, pContext, Buffer, PCT_CONST_CWK,
                   PCT_CONST_CWK_LEN, PCT_USE_CERT);

    if(PCT_ERR_OK != pctRet)
    {
        SP_RETURN(pctRet);
    }


    /* compute the ServerWriteKey */

    pctRet = PctComputeKey( &SWriteHash, pContext, Buffer, PCT_CONST_SWK,
                   PCT_CONST_SWK_LEN, 0);
    if(PCT_ERR_OK != pctRet)
    {
        SP_RETURN(pctRet);
    }

    /* compute the ClientMacKey */

    pctRet = PctComputeKey( &CMacHash, pContext, Buffer, PCT_CONST_CMK,
                   PCT_CONST_CMK_LEN, PCT_USE_CERT | PCT_MAKE_MAC);

    if(PCT_ERR_OK != pctRet)
    {
        SP_RETURN(pctRet);
    }

    /* compute the ServerMacKey */

    pctRet = PctComputeKey( &SMacHash, pContext, Buffer, PCT_CONST_SMK,
                   PCT_CONST_SMK_LEN, PCT_MAKE_MAC);

    if(PCT_ERR_OK != pctRet)
    {
        SP_RETURN(pctRet);
    }

    /* find bit strength of cipher */
    dwKeyLen = (pContext->RipeZombie->SessCiphSpec & SP_CIPHER_STRENGTH) >> SP_CSTR_POS;

    /* convert to bytes */
    dwKeyLen = dwKeyLen / 8;

    if (dwKeyLen < (pContext->pCheck->cbCheckSum))
    {
        /* chop the encryption keys down to selected length */

#if DBG
        DebugLog((DEB_TRACE, "Chopping down client write keys\n", KeyDispBuf));
#endif
        /* compute the standard length clientwritekey */

        BufferLen = 0;

        Buffer[BufferLen] = 1;
        BufferLen += 1;

        CopyMemory(Buffer+BufferLen, PCT_CONST_SLK, PCT_CONST_SLK_LEN);
        BufferLen += PCT_CONST_SLK_LEN;

        pContext->pCheck->Finalize( CWriteHash, Buffer+BufferLen );

        BufferLen += dwKeyLen;

        CopyMemory(Buffer+BufferLen, PCT_CONST_SLK, PCT_CONST_SLK_LEN);
        BufferLen += PCT_CONST_SLK_LEN;

        CopyMemory(Buffer+BufferLen, pContext->RipeZombie->pClearKey, pContext->RipeZombie->cbClearKey);
        BufferLen += pContext->RipeZombie->cbClearKey;

        InitHashBuf(CWriteHB, pContext);
        pContext->pCheck->Sum( CWriteHash, BufferLen, Buffer );

        /* compute the standard length serverwritekey */

#if DBG
        DebugLog((DEB_TRACE, "Chopping down server write keys\n", KeyDispBuf));
#endif

        BufferLen = 0;

        Buffer[BufferLen] = 1;
        BufferLen += 1;

        CopyMemory(Buffer+BufferLen, PCT_CONST_SLK, PCT_CONST_SLK_LEN);
        BufferLen += PCT_CONST_SLK_LEN;

        pContext->pCheck->Finalize( SWriteHash, Buffer+BufferLen );

        BufferLen += dwKeyLen;

        CopyMemory(Buffer+BufferLen, PCT_CONST_SLK, PCT_CONST_SLK_LEN);
        BufferLen += PCT_CONST_SLK_LEN;

        CopyMemory(Buffer+BufferLen, pContext->RipeZombie->pClearKey, pContext->RipeZombie->cbClearKey);
        BufferLen += pContext->RipeZombie->cbClearKey;

        InitHashBuf(SWriteHB, pContext);
        pContext->pCheck->Sum( SWriteHash, BufferLen, Buffer );
    }

    pContext->KeySize = MASTER_KEY_SIZE;

    if (pContext->Flags & CONTEXT_FLAG_CLIENT)
    {
        pContext->pCheck->Finalize( SWriteHash, pReadKey );
        pContext->pCheck->Finalize( CWriteHash, pWriteKey );
        pContext->pCheck->Finalize( SMacHash, pContext->ReadMACKey );
        pContext->pCheck->Finalize( CMacHash, pContext->WriteMACKey );
    }
    else
    {
        pContext->pCheck->Finalize( SWriteHash, pWriteKey );
        pContext->pCheck->Finalize( CWriteHash, pReadKey );
        pContext->pCheck->Finalize( SMacHash, pContext->WriteMACKey );
        pContext->pCheck->Finalize( CMacHash, pContext->ReadMACKey );
    }

    InitHashBuf(pContext->RdMACBuf, pContext);
    InitHashBuf(pContext->WrMACBuf, pContext);

    // Note, we truncuate the MACing keys down to the negotiated key size
    pContext->ReadMACState = (PCheckSumBuffer)pContext->RdMACBuf;

    pContext->pCheck->Sum( pContext->ReadMACState, pContext->KeySize,
               pContext->ReadMACKey);

    pContext->WriteMACState = (PCheckSumBuffer)pContext->WrMACBuf;

    pContext->pCheck->Sum( pContext->WriteMACState, pContext->KeySize,
               pContext->WriteMACKey);

#if DBG

    for(i=0;i<MASTER_KEY_SIZE;i++)
        wsprintf(KeyDispBuf+(i*2), "%2.2x", pContext->RipeZombie->pMasterKey[i]);
    DebugLog((DEB_TRACE, "  MasterKey \t%s\n", KeyDispBuf));

    for(i=0;i<CONTEXT_KEY_SIZE;i++)
        wsprintf(KeyDispBuf+(i*2), "%2.2x", pReadKey[i]);
    DebugLog((DEB_TRACE, "    ReadKey\t%s\n", KeyDispBuf));

    for(i=0;i<CONTEXT_KEY_SIZE;i++)
        wsprintf(KeyDispBuf+(i*2), "%2.2x", pContext->ReadMACKey[i]);
    DebugLog((DEB_TRACE, "     MACKey\t%s\n", KeyDispBuf));

    for(i=0;i<CONTEXT_KEY_SIZE;i++)
        wsprintf(KeyDispBuf+(i*2), "%2.2x", pWriteKey[i]);
    DebugLog((DEB_TRACE, "    WriteKey\t%s\n", KeyDispBuf));

    for(i=0;i<CONTEXT_KEY_SIZE;i++)
        wsprintf(KeyDispBuf+(i*2), "%2.2x", pContext->WriteMACKey[i]);
    DebugLog((DEB_TRACE, "     MACKey\t%s\n", KeyDispBuf));

#endif

    if (pContext->pSystem->Initialize(  pReadKey,
                                        CONTEXT_KEY_SIZE,
                                        &pContext->pReadState ) )
    {
        if (pContext->pSystem->Initialize(  pWriteKey,
                                            CONTEXT_KEY_SIZE,
                                            &pContext->pWriteState) )
        {

            SP_RETURN(PCT_ERR_OK);
        }
        pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
        pContext->pSystem->Discard( &pContext->pReadState );
    }

    SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
}

SP_STATUS WINAPI Pct1DecryptHandler(PSPContext  pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pAppOutput)
{
    SP_STATUS      pctRet= 0;
    BOOL           fEscape;
    PPCT1_CLIENT_HELLO pHello;
    if(pCommInput->cbData > 0) {
        /* first, we'll handle incoming data packets */
        if((pContext->State == SP_STATE_CONNECTED) && (pContext->Decrypt))
        {
            fEscape = (((*(PUCHAR)pCommInput->pvBuffer) & 0xc0) == 0x40);
            /* BUGFIX:  IE 3.0 and 3.0a incorrectly respond to a REDO request
             * by just sending a PCT1 client hello, instead of another REDO.
             * We therefore look at the incomming message and see if it
             * looks like a PCT1 client hello.
             */
            pHello = (PPCT1_CLIENT_HELLO)pCommInput->pvBuffer;

            if((pCommInput->cbData >= 5) &&
               (pHello->MessageId == PCT1_MSG_CLIENT_HELLO) &&
               (pHello->VersionMsb == MSBOF(PCT_VERSION_1)) &&
               (pHello->VersionLsb == LSBOF(PCT_VERSION_1)) &&
               (pHello->OffsetMsb  == MSBOF(PCT_CH_OFFSET_V1)) &&
               (pHello->OffsetLsb  == LSBOF(PCT_CH_OFFSET_V1)))
            {
                // This looks a lot like a client hello
                 /* InitiateRedo */
                pAppOutput->cbData = 0;
                pCommInput->cbData = 0;

                pContext->State = PCT1_STATE_RENEGOTIATE;
;
                return SP_LOG_RESULT(PCT_INT_RENEGOTIATE);
           }

            if(PCT_ERR_OK ==
               (pctRet = pContext->Decrypt(pContext,
                                           pCommInput,   /* message */
                                           pAppOutput /* Unpacked Message */
                                )))
            {
                /* look for escapes */
                if(fEscape)
                {
                    if(pAppOutput->cbData < 1)
                    {
                        return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
                    }
                    /* The first byte of the decrypt buffer is the escape code */
                    switch(*(PUCHAR)pAppOutput->pvBuffer)
                    {
                        case PCT1_ET_REDO_CONN:
                        {
                            /* InitiateRedo */
                            if(pAppOutput->cbData != 1)
                            {
                                return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
                            }
                            pContext->State = PCT1_STATE_RENEGOTIATE;
                            pAppOutput->cbData = 0;
                            return SP_LOG_RESULT(PCT_INT_RENEGOTIATE);
                        }
                        case PCT1_ET_OOB_DATA:
                            /* HandleOOB */
                        default:
                            /* Unknown escape, generate error */
                            pctRet = SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
                            /* Disconnect */
                            break;
                    }

                }
            }
            return (pctRet);

        }
        else
        {
			return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
		}
	}
    return PCT_INT_INCOMPLETE_MSG;
}

SP_STATUS Pct1GenerateError(PSPContext  pContext,
                              PSPBuffer  pCommOutput,
                              SP_STATUS  pError,
                              PSPBuffer  pErrData)
{
    Pct1Error            XmitError;

    /* Only pack up an error if we are allowed to return errors */
    if(!(pContext->Flags & CONTEXT_FLAG_EXT_ERR)) return pError;

    XmitError.Error = pError;
    XmitError.ErrInfoLen = 0;
    XmitError.ErrInfo = NULL;

    if(pErrData) {
        XmitError.ErrInfoLen = pErrData->cbData;
        XmitError.ErrInfo = pErrData->pvBuffer;
    }
    Pct1PackError(&XmitError,
                 pCommOutput);
    return pError;
}

/* session key computation */


SP_STATUS Pct1HandleError(PSPContext  pContext,
                          PSPBuffer  pCommInput,
                          PSPBuffer  pCommOutput)
{
    pCommOutput->cbData = 0;
    return(((PPCT1_ERROR)pCommInput->pvBuffer)->ErrorMsb << 8 )|  ((PPCT1_ERROR)pCommInput->pvBuffer)->ErrorLsb;
}

SP_STATUS Pct1BeginVerifyPrelude(PSPContext pContext,
                                 PUCHAR     pClientHello,
                                 DWORD      cbClientHello,
                                 PUCHAR     pServerHello,
                                 DWORD      cbServerHello)
{

    // Hash( "cvp", CLIENT_HELLO, SERVER_HELLO);

    InitHashBuf(pContext->pVerifyPrelude, pContext);

    pContext->pCheck->Sum((PCheckSumBuffer)(pContext->pVerifyPrelude),
                                            PCT_CONST_VP_LEN,
                                            (PUCHAR)PCT_CONST_VP);

    pContext->pCheck->Sum((PCheckSumBuffer)(pContext->pVerifyPrelude),
                                            cbClientHello,
                                            (PUCHAR)pClientHello);

    pContext->pCheck->Sum((PCheckSumBuffer)(pContext->pVerifyPrelude),
                                            cbServerHello,
                                            pServerHello);

    return PCT_ERR_OK;

}

SP_STATUS Pct1EndVerifyPrelude(PSPContext pContext,
                               PUCHAR     VerifyPrelude,
                               DWORD *    pcbVerifyPrelude
                               )
{

    HashBuf             SumBuf;
    PCheckSumBuffer     pSum;

    pContext->pCheck->Finalize(pContext->pVerifyPrelude,
                               VerifyPrelude);


    InitHashBuf(SumBuf, pContext);
    pSum = (PCheckSumBuffer)SumBuf;
    /* Finish up hashing the verify prelude */
    if(pContext->RipeZombie->fProtocol & SP_PROT_PCT1_SERVER)
    {
        pContext->pCheck->Sum(pSum, PCT1_MASTER_KEY_SIZE, pContext->ReadMACKey);
    }
    else
    {
        pContext->pCheck->Sum(pSum, PCT1_MASTER_KEY_SIZE, pContext->WriteMACKey);
    }
    pContext->pCheck->Sum(pSum,
                          pContext->pCheck->cbCheckSum,
                          VerifyPrelude);

    pContext->pCheck->Finalize(pSum, VerifyPrelude);

    *pcbVerifyPrelude = pContext->pCheck->cbCheckSum;

    return PCT_ERR_OK;

}


SP_STATUS Pct1BuildRestartResponse(PSPContext pContext,
                                   PUCHAR     Response,
                                   DWORD *    pcbResponse
                               )
{

    HashBuf             SumBuf, SubSumBuf;
    PCheckSumBuffer     pSum, pSubSum;


    /* calculate the response */
    // Don't suck in C runtimes in retail build:
	// printf("Calculating Response\n");

    if(pContext->RipeZombie->fProtocol & SP_PROT_PCT1_SERVER)
    {
        CloneHashBuf(SumBuf, pContext->WriteMACState, pContext->pCheck);
    }
    else
    {
         CloneHashBuf(SumBuf, pContext->ReadMACState, pContext->pCheck);
    }
    InitHashBuf(SubSumBuf, pContext);

    pSum = (PCheckSumBuffer)SumBuf;
    pSubSum = (PCheckSumBuffer)SubSumBuf;

    pContext->pCheck->Sum(pSubSum, PCT_CONST_RESP_LEN, (PUCHAR)PCT_CONST_RESP);
    pContext->pCheck->Sum(pSubSum,
                          pContext->cbChallenge,
                          pContext->pChallenge);

    pContext->pCheck->Sum(pSubSum,
                          pContext->cbConnectionID,
                          pContext->pConnectionID);

    pContext->pCheck->Sum(pSubSum,
                          pContext->RipeZombie->cbSessionID,
                          pContext->RipeZombie->SessionID);

    pContext->pCheck->Finalize(pSubSum, Response);

    pContext->pCheck->Sum(pSum,
                          pContext->pCheck->cbCheckSum,
                          Response);

    pContext->pCheck->Finalize(pSum, Response);

    *pcbResponse = pContext->pCheck->cbCheckSum;

    return PCT_ERR_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\pct1prot.h ===
#ifndef _PCT1PROT_H_
#define _PCT1PROT_H_


/* key derivation separators */

#define PCT_CONST_CWK			"cw"
#define PCT_CONST_CWK_LEN		2

#define PCT_CONST_SWK			"svw"
#define PCT_CONST_SWK_LEN		3

#define PCT_CONST_CMK			"cmac"
#define PCT_CONST_CMK_LEN		4

#define PCT_CONST_SMK			"svmac"
#define PCT_CONST_SMK_LEN		5

#define PCT_CONST_SR			"sv"
#define PCT_CONST_SR_LEN		2

#define PCT_CONST_SLK			"sl"
#define PCT_CONST_SLK_LEN		2

#define PCT_CONST_RESP			"sr"
#define PCT_CONST_RESP_LEN		2

#define PCT_CONST_VP			"cvp"
#define PCT_CONST_VP_LEN		3
#define PCT_USE_CERT					1
#define PCT_MAKE_MAC					2

#define DERIVATION_BUFFER_SIZE			2048

/* data structs */

/* message constants and types */

#define PCT_SESSION_ID_SIZE     32
#define PCT_CHALLENGE_SIZE      32

#define PCT_SIGNATURE_SIZE		8192	/* maximum signature size */

#define MASTER_KEY_SIZE     16
#define ENCRYPTED_KEY_SIZE  272         /* Allows for 2048 bit keys */
#define CERT_SIZE           1024
#define RESPONSE_SIZE       32      /* allows for hash output growth */

#define PCT_MAX_SHAKE_LEN	32768		/* longest handshake message len */
/* implementation constants */

#define PCT_MAX_NUM_SEP			5
#define PCT_MAX_SEP_LEN			5

/* mismatch vector */

#define PCT_NUM_MISMATCHES		6

#define PCT_IMIS_CIPHER			1
#define PCT_IMIS_HASH			2
#define PCT_IMIS_CERT			4
#define PCT_IMIS_EXCH			8
#define PCT_IMIS_CL_CERT		16
#define PCT_IMIS_CL_SIG			32


SP_STATUS WINAPI
Pct1ServerProtocolHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput,
    PSPBuffer pAppOutput);

SP_STATUS WINAPI
Pct1ClientProtocolHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput,
    PSPBuffer pAppOutput);

SP_STATUS WINAPI
Pct1DecryptHandler(
    PSPContext pContext,
    PSPBuffer  pCommInput,
    PSPBuffer  pAppOutput);


SP_STATUS WINAPI Pct1DecryptMessage(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pAppOutput);

SP_STATUS WINAPI Pct1EncryptRaw(PSPContext  pContext,
                             PSPBuffer      pAppInput,
                             PSPBuffer      pCommOutput,
                             DWORD          dwFlags);

#define PCT1_ENCRYPT_ESCAPE 0x00000001


SP_STATUS WINAPI Pct1EncryptMessage(PSPContext pContext,
                             PSPBuffer  pAppInput,
                             PSPBuffer  pCommOutput);



SP_STATUS Pct1SrvHandleClientHello(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PPct1_Client_Hello pHello,
                              PSPBuffer  pCommOutput);

SP_STATUS Pct1SrvHandleCMKey(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput);

SP_STATUS Pct1CliHandleServerHello(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PPct1_Server_Hello  pHello,
                              PSPBuffer  pCommOutput);

SP_STATUS Pct1CliHandleServerVerify(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput);

SP_STATUS Pct1HandleError(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput);

SP_STATUS Pct1GenerateError(PSPContext pContext,
                              PSPBuffer  pCommOutput,
                              SP_STATUS  pError,
                              PSPBuffer  pErrData);


SP_STATUS
WINAPI
GeneratePct1StyleHello(
    PSPContext              pContext,
    PSPBuffer               pOutput);

SP_STATUS
Pct1CliRestart(PSPContext  pContext,
              PPct1_Server_Hello pHello,
              PSPBuffer pCommOutput);

SP_STATUS
Pct1SrvRestart(PSPContext  pContext,
              PPct1_Client_Hello pHello,
              PSPBuffer pCommOutput,
              SessCacheItem *pSession);

SP_STATUS
Pct1MakeSessionKeys(PSPContext pContext);

SP_STATUS Pct1EndVerifyPrelude(PSPContext pContext,
                               PUCHAR     VerifyPrelude,
                               DWORD *    pcbVerifyPrelude
                               );

SP_STATUS Pct1BeginVerifyPrelude(PSPContext pContext,
                                 PUCHAR     pClientHello,
                                 DWORD      cbClientHello,
                                 PUCHAR     pServerHello,
                                 DWORD      cbServerHello);


SP_STATUS Pct1BuildRestartResponse(PSPContext pContext,
                                   PUCHAR     Response,
                                   DWORD *    pcbResponse
                               );

extern CipherSpec Pct1CipherRank[];
extern const DWORD Pct1NumCipher;

/* available hashes, in order of preference */
extern HashSpec Pct1HashRank[];
extern const DWORD Pct1NumHash;

extern CertSpec Pct1CertRank[];
extern const DWORD Pct1NumCert;

extern SigSpec Pct1SigRank[];
extern const DWORD Pct1NumSig;

extern ExchSpec Pct1ExchRank[];
extern const DWORD Pct1NumExch;


#endif /* _PCT1PROT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\pct1pckl.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/


#include <spbase.h>
#include <pct1msg.h>
#include <pct1prot.h>

#define PCT_OFFSET_OF(t, v) (DWORD)&(((t)NULL)->v)

#define SIZEOF(pMessage)    (Pct1RecordSize((PPCT1_MESSAGE_HEADER) pMessage ) )

DWORD MapCipherToExternal(CipherSpec Internal, ExtCipherSpec UNALIGNED *External)
{
    *External = htonl(Internal);
    return TRUE;
}

DWORD MapHashToExternal(HashSpec Internal, ExtHashSpec UNALIGNED *External)
{
    *External = htons((ExtHashSpec)Internal);
    return TRUE;
}

DWORD MapCertToExternal(CertSpec Internal, ExtCertSpec UNALIGNED *External)
{
    *External = htons((ExtCertSpec)Internal);
    return TRUE;
}

DWORD MapExchToExternal(ExchSpec Internal, ExtExchSpec UNALIGNED *External)
{
    *External = htons((ExtExchSpec)Internal);
    return TRUE;
}

DWORD MapSigToExternal(SigSpec Internal, ExtSigSpec UNALIGNED *External)
{
    *External = htons((ExtSigSpec)Internal);
    return TRUE;
}

CipherSpec MapCipherFromExternal(ExtCipherSpec External)
{
    return (CipherSpec)ntohl(External);
}

HashSpec MapHashFromExternal(ExtHashSpec External)
{
    return (HashSpec)ntohs(External);
}

CertSpec MapCertFromExternal(ExtCertSpec External)
{
    return (CertSpec)ntohs(External);
}

ExchSpec MapExchFromExternal(ExtExchSpec External)
{
    return (ExchSpec)ntohs(External);
}

SigSpec MapSigFromExternal(ExtSigSpec External)
{
    return (SigSpec)ntohs(External);
}


DWORD
Pct1RecordSize(
    PPCT1_MESSAGE_HEADER  pHeader)
{
    DWORD   Size;

    if (pHeader->Byte0 & 0x80)
    {
        Size = COMBINEBYTES(pHeader->Byte0, pHeader->Byte1) & 0x7FFF;
    }
    else
    {
        Size = COMBINEBYTES(pHeader->Byte0, pHeader->Byte1) & 0x3FFF;
    }
    return(Size);
}


SP_STATUS
Pct1PackClientHello(
    PPct1_Client_Hello       pCanonical,
    PSPBuffer          pCommOutput)
{
    DWORD               cbMessage;
    PPCT1_CLIENT_HELLO   pMessage;
    DWORD               Size;
    PUCHAR              pBuffer;
    DWORD               i, iBuff;

    SP_BEGIN("Pct1PackClientHello");

    if(pCanonical == NULL || pCommOutput == NULL) 
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    pCommOutput->cbData = 0;

    if(pCanonical->cbSessionID != PCT_SESSION_ID_SIZE ||
       pCanonical->cbChallenge != PCT_CHALLENGE_SIZE)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }


    pCommOutput->cbData = PCT_OFFSET_OF(PPCT1_CLIENT_HELLO, VariantData) +
                    pCanonical->cCipherSpecs * sizeof(ExtCipherSpec) +
                    pCanonical->cHashSpecs * sizeof(ExtHashSpec) +
                    pCanonical->cCertSpecs * sizeof(ExtCertSpec) +
                    pCanonical->cExchSpecs * sizeof(ExtExchSpec) +
                    pCanonical->cbKeyArgSize;


    cbMessage = pCommOutput->cbData - sizeof(PCT1_MESSAGE_HEADER);
    if (cbMessage > PCT_MAX_SHAKE_LEN)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW));
    }
    /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL) {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
        {
            SP_RETURN(SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY));
        }

        pCommOutput->cbBuffer = pCommOutput->cbData;
    }

    if(pCommOutput->cbData > pCommOutput->cbBuffer)
    {
        SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
    }

    pMessage = pCommOutput->pvBuffer;

    pMessage->MessageId = PCT1_MSG_CLIENT_HELLO;

    pMessage->VersionMsb = MSBOF(PCT_VERSION_1);
    pMessage->VersionLsb = LSBOF(PCT_VERSION_1);

    pMessage->OffsetMsb = MSBOF(PCT_CH_OFFSET_V1);
    pMessage->OffsetLsb = LSBOF(PCT_CH_OFFSET_V1);

    pMessage->KeyArgLenMsb = MSBOF(pCanonical->cbKeyArgSize);
    pMessage->KeyArgLenLsb = LSBOF(pCanonical->cbKeyArgSize);

    CopyMemory( pMessage->SessionIdData,
                pCanonical->SessionID,
                pCanonical->cbSessionID);

    CopyMemory( pMessage->ChallengeData,
                pCanonical->Challenge,
                pCanonical->cbChallenge);

    pBuffer = pMessage->VariantData;

    iBuff = 0;
    for (i = 0; i < pCanonical->cCipherSpecs ; i++ )
    {
        if (MapCipherToExternal(pCanonical->pCipherSpecs[i],
                                &((ExtCipherSpec UNALIGNED *) pBuffer)[iBuff]) )
        {
            iBuff++;
        }
    }
    Size = iBuff*sizeof(ExtCipherSpec);

    pMessage->CipherSpecsLenMsb = MSBOF(Size);
    pMessage->CipherSpecsLenLsb = LSBOF(Size);
    pBuffer += Size;

    cbMessage -= (pCanonical->cCipherSpecs - iBuff)*sizeof(ExtCipherSpec);


    iBuff = 0;
    for (i = 0; i < pCanonical->cHashSpecs ; i++ )
    {
        if (MapHashToExternal(pCanonical->pHashSpecs[i],
                              &((ExtHashSpec UNALIGNED *) pBuffer)[iBuff]) )
        {
            iBuff++;
        }
    }
    Size = iBuff*sizeof(ExtHashSpec);
    pBuffer += Size;

    pMessage->HashSpecsLenMsb = MSBOF(Size);
    pMessage->HashSpecsLenLsb = LSBOF(Size);
    cbMessage -= (pCanonical->cHashSpecs - iBuff)*sizeof(ExtHashSpec);


    iBuff = 0;
    for (i = 0; i < pCanonical->cCertSpecs ; i++ )
    {
        if (MapCertToExternal(pCanonical->pCertSpecs[i],
                                &((ExtCertSpec UNALIGNED *) pBuffer)[iBuff]))
        {
            iBuff ++;
        }
    }
    Size = iBuff*sizeof(ExtCertSpec);
    pBuffer += Size;

    pMessage->CertSpecsLenMsb = MSBOF(Size);
    pMessage->CertSpecsLenLsb = LSBOF(Size);
    cbMessage -= (pCanonical->cCertSpecs - iBuff)*sizeof(ExtCertSpec);


    iBuff = 0;
    for (i = 0; i < pCanonical->cExchSpecs ; i++ )
    {
        if (MapExchToExternal(pCanonical->pExchSpecs[i],
                                &((ExtExchSpec UNALIGNED *) pBuffer)[iBuff]) )
        {
            iBuff++;
        }
    }
    Size = iBuff*sizeof(ExtExchSpec);
    pBuffer += Size;


    pMessage->ExchSpecsLenMsb = MSBOF(Size);
    pMessage->ExchSpecsLenLsb = LSBOF(Size);
    cbMessage -= (pCanonical->cExchSpecs - iBuff)*sizeof(ExtExchSpec);

    if(pCanonical->pKeyArg)
    {
        CopyMemory(pBuffer, pCanonical->pKeyArg, pCanonical->cbKeyArgSize);
        pBuffer += pCanonical->cbKeyArgSize;
    }

    pCommOutput->cbData = cbMessage + 2;

    pMessage->Header.Byte0 = MSBOF(cbMessage) | 0x80;
    pMessage->Header.Byte1 = LSBOF(cbMessage);

    SP_RETURN(PCT_ERR_OK);
}

SP_STATUS
Pct1UnpackClientHello(
    PSPBuffer          pInput,
    PPct1_Client_Hello *     ppClient)
{

    PPCT1_CLIENT_HELLO   pMessage;

    DWORD               ReportedSize;
    DWORD               CipherSpecsSize, HashSpecsSize, CertSpecsSize;
    DWORD               ExchSpecsSize;
    DWORD               cCipherSpecs, cHashSpecs, cCertSpecs, cExchSpecs;
    DWORD               cOffsetBytes, KeyArgSize;
    PPct1_Client_Hello       pCanonical;
    PUCHAR              pBuffer;
    DWORD               i;

    SP_BEGIN("Pct1UnpackClientHello");

    pMessage = pInput->pvBuffer;

    if(pInput->cbData < 2) 
    {
        pInput->cbData = 2;
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    ReportedSize = SIZEOF(pMessage);

    if ((ReportedSize+2) > pInput->cbData)
    {
        pInput->cbData = ReportedSize+2;
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    if(ReportedSize < PCT_OFFSET_OF(PPCT1_CLIENT_HELLO, VariantData))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    if ((pMessage->VersionMsb & 0x80) == 0)
    {
        SP_RETURN (PCT_ERR_SSL_STYLE_MSG);
    }

    /* We don't recognize hello messages of less version than ourselves,
     * those will be handled by a previous version of the code */
    if ((pMessage->MessageId != PCT1_MSG_CLIENT_HELLO) ||
        ((pMessage->VersionMsb << 8 | pMessage->VersionLsb)  < PCT_VERSION_1))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    cOffsetBytes = COMBINEBYTES( pMessage->OffsetMsb,
                                  pMessage->OffsetLsb );

    if(cOffsetBytes < PCT_CH_OFFSET_V1)  
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    *ppClient = NULL;

    CipherSpecsSize = COMBINEBYTES( pMessage->CipherSpecsLenMsb,
                                    pMessage->CipherSpecsLenLsb );

    HashSpecsSize = COMBINEBYTES( pMessage->HashSpecsLenMsb,
                                  pMessage->HashSpecsLenLsb );

    CertSpecsSize = COMBINEBYTES( pMessage->CertSpecsLenMsb,
                                  pMessage->CertSpecsLenLsb );

    ExchSpecsSize = COMBINEBYTES( pMessage->ExchSpecsLenMsb,
                                  pMessage->ExchSpecsLenLsb );

    KeyArgSize = COMBINEBYTES( pMessage->KeyArgLenMsb,
                                          pMessage->KeyArgLenLsb );

    /* check that this all fits into the message */
    if (PCT_OFFSET_OF(PPCT1_CLIENT_HELLO, VariantData)
          - sizeof(PCT1_MESSAGE_HEADER)       /* don't count the header */
         + cOffsetBytes - PCT_CH_OFFSET_V1
         + CipherSpecsSize
         + HashSpecsSize
         + CertSpecsSize
         + ExchSpecsSize 
         + KeyArgSize > ReportedSize)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    cCipherSpecs = CipherSpecsSize / sizeof(ExtCipherSpec);
    cHashSpecs = HashSpecsSize / sizeof(ExtHashSpec);
    cExchSpecs = ExchSpecsSize / sizeof(ExtExchSpec);
    cCertSpecs = CertSpecsSize / sizeof(ExtCertSpec);


    /* Allocate a buffer for the canonical client hello */
    pCanonical = (PPct1_Client_Hello)SPExternalAlloc(
                            sizeof(Pct1_Client_Hello) +
                            cCipherSpecs * sizeof(CipherSpec) +
                            cHashSpecs * sizeof(HashSpec) +
                            cCertSpecs * sizeof(CertSpec) +
                            cExchSpecs * sizeof(ExchSpec) +
                            KeyArgSize);

    if (!pCanonical)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY));
    }
    pCanonical->cbKeyArgSize = KeyArgSize;

    pCanonical->pCipherSpecs = (PCipherSpec) (pCanonical + 1);
    pCanonical->pHashSpecs = (PHashSpec) (pCanonical->pCipherSpecs +
                                          cCipherSpecs);
    pCanonical->pCertSpecs = (PCertSpec) (pCanonical->pHashSpecs +
                                          cHashSpecs);
    pCanonical->pExchSpecs = (PExchSpec) (pCanonical->pCertSpecs +
                                          cCertSpecs);
    
    pCanonical->pKeyArg = (PUCHAR)(pCanonical->pExchSpecs + cExchSpecs);

    CopyMemory( pCanonical->SessionID,
                pMessage->SessionIdData,
                PCT_SESSION_ID_SIZE);
    pCanonical->cbSessionID = PCT_SESSION_ID_SIZE;

    CopyMemory( pCanonical->Challenge,
                pMessage->ChallengeData,
                PCT_CHALLENGE_SIZE );
    pCanonical->cbChallenge = PCT_CHALLENGE_SIZE;


    pBuffer = &pMessage->OffsetLsb + 1 + cOffsetBytes;

    pCanonical->cCipherSpecs = cCipherSpecs;

    for (i = 0 ; i < cCipherSpecs ; i++ )
    {
        pCanonical->pCipherSpecs[i] = MapCipherFromExternal(*(ExtCipherSpec UNALIGNED *)
                                                    pBuffer);

        pBuffer += sizeof(ExtCipherSpec);
    }

    pCanonical->cHashSpecs = cHashSpecs;

    for (i = 0 ; i < cHashSpecs ; i++ )
    {
        pCanonical->pHashSpecs[i] = MapHashFromExternal(*(ExtHashSpec UNALIGNED *)
                                                    pBuffer);

        pBuffer += sizeof(ExtHashSpec);
    }

    pCanonical->cCertSpecs = cCertSpecs;

    for (i = 0 ; i < cCertSpecs ; i++ )
    {
        pCanonical->pCertSpecs[i] = MapCertFromExternal(*(ExtCertSpec UNALIGNED *)
                                                    pBuffer);

        pBuffer += sizeof(ExtCertSpec);
    }

    pCanonical->cExchSpecs = cExchSpecs;

    for (i = 0 ; i < cExchSpecs ; i++ )
    {
        pCanonical->pExchSpecs[i] = MapExchFromExternal(*(ExtExchSpec UNALIGNED *)
                                                    pBuffer);

        pBuffer += sizeof(ExtExchSpec);
    }


    CopyMemory(pCanonical->pKeyArg, pBuffer, KeyArgSize);

    *ppClient = pCanonical;
    pInput->cbData = ReportedSize + sizeof(PCT1_MESSAGE_HEADER);

    SP_RETURN(PCT_ERR_OK);
}

SP_STATUS
Pct1PackServerHello(
    PPct1_Server_Hello       pCanonical,
    PSPBuffer          pCommOutput)
{
    DWORD               cbMessage;
    PPCT1_SERVER_HELLO   pMessage;
    DWORD               Size;
    PUCHAR              pBuffer;
    DWORD               i, iBuff;


    SP_BEGIN("Pct1PackServerHello");

    if(pCanonical == NULL || pCommOutput == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    pCommOutput->cbData = 0;
    if(pCanonical->cbConnectionID != PCT_SESSION_ID_SIZE)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    cbMessage = pCanonical->CertificateLen +
                    pCanonical->cCertSpecs * sizeof(ExtCertSpec) +
                    pCanonical->cSigSpecs * sizeof(ExtSigSpec) +
                    pCanonical->ResponseLen +
                    PCT_OFFSET_OF(PPCT1_SERVER_HELLO, VariantData) -
                    sizeof(PCT1_MESSAGE_HEADER);

    if (cbMessage > PCT_MAX_SHAKE_LEN)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW));
    }

    pCommOutput->cbData = cbMessage + 2;

    /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL) {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
        {
            SP_RETURN(SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY));
        }

        pCommOutput->cbBuffer = pCommOutput->cbData;
    }

    if(pCommOutput->cbData > pCommOutput->cbBuffer) 
    {
        SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
    }

    pMessage = pCommOutput->pvBuffer;


    pMessage->MessageId = PCT1_MSG_SERVER_HELLO;
    pMessage->ServerVersionMsb = MSBOF(PCT_VERSION_1);
    pMessage->ServerVersionLsb = LSBOF(PCT_VERSION_1);
    pMessage->RestartSessionOK = (UCHAR) pCanonical->RestartOk;
    pMessage->ClientAuthReq = (UCHAR)pCanonical->ClientAuthReq;

    MapCipherToExternal(pCanonical->SrvCipherSpec, &pMessage->CipherSpecData);
    MapHashToExternal(pCanonical->SrvHashSpec, &pMessage->HashSpecData);
    MapCertToExternal(pCanonical->SrvCertSpec, &pMessage->CertSpecData);
    MapExchToExternal(pCanonical->SrvExchSpec, &pMessage->ExchSpecData);

    CopyMemory(pMessage->ConnectionIdData, pCanonical->ConnectionID,
               pCanonical->cbConnectionID);

    pBuffer = pMessage->VariantData;


    /* Pack certificate if present */


    pMessage->CertificateLenMsb = MSBOF(pCanonical->CertificateLen);
    pMessage->CertificateLenLsb = LSBOF(pCanonical->CertificateLen);

    if (pCanonical->CertificateLen)
    {
        CopyMemory( pBuffer,
                    pCanonical->pCertificate,
                    pCanonical->CertificateLen);

        pBuffer += pCanonical->CertificateLen ;
    }

    iBuff = 0;
    for (i = 0; i < pCanonical->cCertSpecs ; i++ )
    {
        if (MapCertToExternal(pCanonical->pClientCertSpecs[i],
                                &((ExtCertSpec UNALIGNED *) pBuffer)[iBuff]))
        {
            iBuff ++;
        }
    }
    Size = iBuff*sizeof(ExtCertSpec);
    pBuffer += Size;

    pMessage->CertSpecsLenMsb = MSBOF(Size);
    pMessage->CertSpecsLenLsb = LSBOF(Size);
    cbMessage -= (pCanonical->cCertSpecs - iBuff)*sizeof(ExtCertSpec);

    iBuff = 0;
    for (i = 0; i < pCanonical->cSigSpecs ; i++ )
    {
        if (MapSigToExternal(pCanonical->pClientSigSpecs[i],
                              &((ExtSigSpec UNALIGNED *) pBuffer)[iBuff]) )
        {
            iBuff++;
        }
    }
    Size = iBuff*sizeof(ExtSigSpec);
    pBuffer += Size;

    pMessage->ClientSigSpecsLenMsb = MSBOF(Size);
    pMessage->ClientSigSpecsLenLsb = LSBOF(Size);
    cbMessage -= (pCanonical->cSigSpecs - iBuff)*sizeof(ExtSigSpec);

    pMessage->ResponseLenMsb = MSBOF(pCanonical->ResponseLen);
    pMessage->ResponseLenLsb = LSBOF(pCanonical->ResponseLen);

    CopyMemory( pBuffer,
                pCanonical->Response,
                pCanonical->ResponseLen);

    pBuffer += pCanonical->ResponseLen;

    pCommOutput->cbData = cbMessage + 2;

    pMessage->Header.Byte0 = MSBOF(cbMessage) | 0x80;
    pMessage->Header.Byte1 = LSBOF(cbMessage);


    SP_RETURN(PCT_ERR_OK);

}

SP_STATUS
Pct1UnpackServerHello(
    PSPBuffer          pInput,
    PPct1_Server_Hello *     ppServer)
{
    PPct1_Server_Hello       pCanonical;
    PPCT1_SERVER_HELLO   pMessage;
    PUCHAR              pBuffer;
    DWORD               cbCertificate, cbResponse;
    DWORD               cCertSpecs, cSigSpecs;
    DWORD               i;
    DWORD               ReportedSize;

    SP_BEGIN("Pct1UnpackServerHello");


    pMessage = pInput->pvBuffer;

    if(pInput->cbData < 2) 
    {
        pInput->cbData = 2;
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    ReportedSize = SIZEOF(pMessage);

    if ((ReportedSize+2) > pInput->cbData)
    {
        pInput->cbData = ReportedSize+2; 
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    if(ReportedSize <  PCT_OFFSET_OF(PPCT1_SERVER_HELLO, VariantData) )
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    /* Verify Header: */

    /* we don't handle server hello messages of latter version than ourselves,
     * those will be handled by latter verisions of the protocol */
    if ((pMessage->MessageId != PCT1_MSG_SERVER_HELLO) ||
        ((pMessage->ServerVersionMsb << 8 | pMessage->ServerVersionLsb)  > PCT_VERSION_1))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    *ppServer = NULL;

    cbCertificate = COMBINEBYTES(pMessage->CertificateLenMsb,
                                 pMessage->CertificateLenLsb);

    cCertSpecs = COMBINEBYTES(pMessage->CertSpecsLenMsb,
                              pMessage->CertSpecsLenLsb);

    cCertSpecs /= sizeof(ExtCertSpec);


    cSigSpecs = COMBINEBYTES(pMessage->ClientSigSpecsLenMsb,
                             pMessage->ClientSigSpecsLenLsb);

    cSigSpecs /= sizeof(ExtSigSpec);

    cbResponse = COMBINEBYTES(pMessage->ResponseLenMsb,
                              pMessage->ResponseLenLsb);


    pCanonical = (PPct1_Server_Hello)SPExternalAlloc(
                            sizeof(Pct1_Server_Hello) +
                            cCertSpecs * sizeof(CertSpec) +
                            cSigSpecs * sizeof(SigSpec) +
                            cbCertificate);

    if (!pCanonical)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }


    /* Set up pointers to be in this memory allocation. */


    pCanonical->pClientCertSpecs = (PCertSpec) (pCanonical + 1);
    pCanonical->pClientSigSpecs = (PSigSpec)(pCanonical->pClientCertSpecs +
                                    cCertSpecs);

    pCanonical->pCertificate = (PUCHAR) (pCanonical->pClientSigSpecs +
                                    cSigSpecs);

    /* Expand out: */

    pCanonical->RestartOk = (DWORD) pMessage->RestartSessionOK;
    pCanonical->ClientAuthReq = (DWORD)pMessage->ClientAuthReq;
    pCanonical->SrvCertSpec = MapCertFromExternal(pMessage->CertSpecData);
    pCanonical->SrvCipherSpec =MapCipherFromExternal(pMessage->CipherSpecData);
    pCanonical->SrvHashSpec = MapHashFromExternal(pMessage->HashSpecData);
    pCanonical->SrvExchSpec = MapExchFromExternal(pMessage->ExchSpecData);
    pCanonical->CertificateLen = cbCertificate;
    pCanonical->ResponseLen = cbResponse;
    pCanonical->cCertSpecs = cCertSpecs;
    pCanonical->cSigSpecs = cSigSpecs;

    CopyMemory(pCanonical->ConnectionID,
               pMessage->ConnectionIdData,
               PCT_SESSION_ID_SIZE);

    pCanonical->cbConnectionID= PCT_SESSION_ID_SIZE;

    pBuffer = pMessage->VariantData;

    CopyMemory(pCanonical->pCertificate, pBuffer, cbCertificate);
    pBuffer += cbCertificate;

    for (i = 0 ; i < cCertSpecs ; i++ )
    {
        pCanonical->pClientCertSpecs[i] = MapCertFromExternal(
                                            *(ExtCertSpec UNALIGNED *)pBuffer);
        pBuffer += sizeof(ExtCertSpec);
    }

    for (i = 0 ; i < cSigSpecs ; i++ )
    {
        pCanonical->pClientSigSpecs[i] = MapSigFromExternal(
                                            *(ExtSigSpec UNALIGNED *)pBuffer);
        pBuffer += sizeof(ExtSigSpec);
    }

    CopyMemory(pCanonical->Response, pBuffer, cbResponse);


    *ppServer = pCanonical;
    pInput->cbData = ReportedSize + sizeof(PCT1_MESSAGE_HEADER);

    SP_RETURN(PCT_ERR_OK);

}

SP_STATUS
Pct1PackClientMasterKey(
    PPct1_Client_Master_Key      pCanonical,
    PSPBuffer                    pCommOutput)
{
    DWORD                   cbMessage;
    PPCT1_CLIENT_MASTER_KEY  pMessage;
    PUCHAR                  pBuffer;

    SP_BEGIN("Pct1PackClientMasterKey");

    if(pCanonical == NULL || pCommOutput == NULL) 
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    pCommOutput->cbData = 0;

    cbMessage = pCanonical->ClearKeyLen +
                    pCanonical->EncryptedKeyLen +
                    pCanonical->KeyArgLen +
                    pCanonical->VerifyPreludeLen +
                    pCanonical->ClientCertLen +
                    pCanonical->ResponseLen +
                    PCT_OFFSET_OF(PPCT1_CLIENT_MASTER_KEY, VariantData) -
                    sizeof(PCT1_MESSAGE_HEADER);

    if (cbMessage > PCT_MAX_SHAKE_LEN)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW));
    }

    pCommOutput->cbData = cbMessage + 2;

        /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL) {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
        {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY));
        }

        pCommOutput->cbBuffer = pCommOutput->cbData;
    }


    if(pCommOutput->cbData > pCommOutput->cbBuffer) 
    {
        SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
    }

    pMessage = pCommOutput->pvBuffer;




    pBuffer = pMessage->VariantData;

    pMessage->Header.Byte0 = MSBOF(cbMessage) | 0x80;
    pMessage->Header.Byte1 = LSBOF(cbMessage);

    pMessage->MessageId = PCT1_MSG_CLIENT_MASTER_KEY;

    pMessage->ClearKeyLenMsb = MSBOF(pCanonical->ClearKeyLen);
    pMessage->ClearKeyLenLsb = LSBOF(pCanonical->ClearKeyLen);

    MapSigToExternal(pCanonical->ClientSigSpec, &pMessage->ClientSigSpecData);
    MapCertToExternal(pCanonical->ClientCertSpec, &pMessage->ClientCertSpecData);

    CopyMemory(pBuffer, pCanonical->ClearKey, pCanonical->ClearKeyLen);

    pBuffer += pCanonical->ClearKeyLen;

    pMessage->EncryptedKeyLenMsb = MSBOF(pCanonical->EncryptedKeyLen);
    pMessage->EncryptedKeyLenLsb = LSBOF(pCanonical->EncryptedKeyLen);

    CopyMemory(pBuffer, pCanonical->EncryptedKey, pCanonical->EncryptedKeyLen);
    pBuffer += pCanonical->EncryptedKeyLen;

    pMessage->KeyArgLenMsb = MSBOF(pCanonical->KeyArgLen);
    pMessage->KeyArgLenLsb = LSBOF(pCanonical->KeyArgLen);

    CopyMemory(pBuffer, pCanonical->KeyArg, pCanonical->KeyArgLen);
    pBuffer += pCanonical->KeyArgLen;

    pMessage->VerifyPreludeLenMsb = MSBOF(pCanonical->VerifyPreludeLen);
    pMessage->VerifyPreludeLenLsb = LSBOF(pCanonical->VerifyPreludeLen);

    CopyMemory(pBuffer, pCanonical->VerifyPrelude,
               pCanonical->VerifyPreludeLen);
    pBuffer += pCanonical->VerifyPreludeLen;

    pMessage->ClientCertLenMsb = MSBOF(pCanonical->ClientCertLen);
    pMessage->ClientCertLenLsb = LSBOF(pCanonical->ClientCertLen);

    CopyMemory(pBuffer, pCanonical->pClientCert, pCanonical->ClientCertLen);
    pBuffer += pCanonical->ClientCertLen;

    pMessage->ResponseLenMsb = MSBOF(pCanonical->ResponseLen);
    pMessage->ResponseLenLsb = LSBOF(pCanonical->ResponseLen);

    CopyMemory(pBuffer, pCanonical->Response, pCanonical->ResponseLen);


    SP_RETURN(PCT_ERR_OK);

}

SP_STATUS
Pct1UnpackClientMasterKey(
    PSPBuffer              pInput,
    PPct1_Client_Master_Key *    ppClient)
{
    PPct1_Client_Master_Key  pCanonical;

    PUCHAR              pBuffer;
    DWORD               ReportedSize;
    PCT1_CLIENT_MASTER_KEY  UNALIGNED *pMessage;
    DWORD cbClearKey, cbEncryptedKey, cbKeyArg, cbVerifyPrelude, cbClientCert, cbResponse;

    SP_BEGIN("Pct1UnpackClientMasterKey");

    pMessage = pInput->pvBuffer;

    if(pInput->cbData < 2) 
    {
        pInput->cbData = 2;
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    ReportedSize = SIZEOF(pMessage);

    if ((ReportedSize+2) > pInput->cbData)
    {
        pInput->cbData = ReportedSize+2;
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    if(ReportedSize < PCT_OFFSET_OF(PPCT1_CLIENT_MASTER_KEY, VariantData))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    /* Verify Header: */


    if (pMessage->MessageId != PCT1_MSG_CLIENT_MASTER_KEY )
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }
    cbClearKey = COMBINEBYTES( pMessage->ClearKeyLenMsb,
                                            pMessage->ClearKeyLenLsb );

    cbEncryptedKey = COMBINEBYTES( pMessage->EncryptedKeyLenMsb,
                                                pMessage->EncryptedKeyLenLsb );

    cbKeyArg = COMBINEBYTES( pMessage->KeyArgLenMsb,
                                          pMessage->KeyArgLenLsb );

    cbVerifyPrelude = COMBINEBYTES( pMessage->VerifyPreludeLenMsb,
                                            pMessage->VerifyPreludeLenLsb );

    cbClientCert = COMBINEBYTES( pMessage->ClientCertLenMsb,
                                              pMessage->ClientCertLenLsb );

    cbResponse = COMBINEBYTES( pMessage->ResponseLenMsb,
                                            pMessage->ResponseLenLsb );

    /* defensive checks..... */

    if ((cbClearKey > MASTER_KEY_SIZE) ||
        (cbEncryptedKey > ENCRYPTED_KEY_SIZE) ||
        (cbKeyArg) ||
        (cbVerifyPrelude > RESPONSE_SIZE) ||
        (cbResponse > PCT_SIGNATURE_SIZE))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }


    if ((PCT_OFFSET_OF(PPCT1_CLIENT_MASTER_KEY, VariantData) -
         sizeof(PCT1_MESSAGE_HEADER) +
         cbClearKey +
         cbEncryptedKey +
         cbKeyArg +
         cbVerifyPrelude +
         cbClientCert +
         cbResponse) !=
         ReportedSize)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }


    *ppClient = NULL;


    pCanonical = (PPct1_Client_Master_Key)SPExternalAlloc(
                            sizeof(Pct1_Client_Master_Key) + cbClientCert );

    if (!pCanonical)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY));

    }

    pCanonical->ClearKeyLen = cbClearKey;

    pCanonical->EncryptedKeyLen = cbEncryptedKey;

    pCanonical->KeyArgLen = cbKeyArg;

    pCanonical->VerifyPreludeLen = cbVerifyPrelude;
    pCanonical->ClientCertLen = cbClientCert;

    pCanonical->ResponseLen = cbResponse;
    /* defensive checks..... */


    pCanonical->ClientCertSpec = MapCertFromExternal(pMessage->ClientCertSpecData);

    pCanonical->pClientCert = (PUCHAR)(pCanonical+1);

    pCanonical->ClientSigSpec = MapSigFromExternal(pMessage->ClientSigSpecData);
    
    /* ok, we're pretty sure we aren't going to fault. */

    pBuffer = pMessage->VariantData;

    CopyMemory(pCanonical->ClearKey, pBuffer, pCanonical->ClearKeyLen );

    pBuffer += pCanonical->ClearKeyLen;

    CopyMemory(pCanonical->EncryptedKey, pBuffer, pCanonical->EncryptedKeyLen);

    pBuffer += pCanonical->EncryptedKeyLen;

    CopyMemory( pCanonical->KeyArg, pBuffer, pCanonical->KeyArgLen );

    pBuffer += pCanonical->KeyArgLen;

    CopyMemory( pCanonical->VerifyPrelude, pBuffer,
                pCanonical->VerifyPreludeLen );

    pBuffer += pCanonical->VerifyPreludeLen;

    CopyMemory( pCanonical->pClientCert, pBuffer, pCanonical->ClientCertLen );

    pBuffer += pCanonical->ClientCertLen;

    CopyMemory( pCanonical->Response, pBuffer, pCanonical->ResponseLen );

    *ppClient = pCanonical;
    pInput->cbData = ReportedSize + sizeof(PCT1_MESSAGE_HEADER);
    SP_RETURN( PCT_ERR_OK );
}


SP_STATUS
Pct1PackServerVerify(
    PPct1_Server_Verify          pCanonical,
    PSPBuffer              pCommOutput)
{
    DWORD               cbMessage;
    PPCT1_SERVER_VERIFY  pMessage;
    PUCHAR              pBuffer;


    SP_BEGIN("Pct1PackServerVerify");

    if(pCanonical == NULL || pCommOutput == NULL) 
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    pCommOutput->cbData = 0;

    cbMessage    = pCanonical->ResponseLen +
                    PCT_OFFSET_OF(PPCT1_SERVER_VERIFY, VariantData) -
                    sizeof(PCT1_MESSAGE_HEADER);

    if (cbMessage > PCT_MAX_SHAKE_LEN)
    {
        SP_RETURN(PCT_INT_DATA_OVERFLOW);
    }

    pCommOutput->cbData = cbMessage + 2;

        /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL) {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
        {
            SP_RETURN(SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY));
        }
        pCommOutput->cbBuffer = pCommOutput->cbData;
    }


    if(pCommOutput->cbData > pCommOutput->cbBuffer)
    {
        SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
    }

    pMessage = pCommOutput->pvBuffer;

    pMessage->MessageId = PCT1_MSG_SERVER_VERIFY;

    pMessage->Header.Byte0 = MSBOF(cbMessage) | 0x80;
    pMessage->Header.Byte1 = LSBOF(cbMessage);

    CopyMemory(pMessage->SessionIdData, pCanonical->SessionIdData,
               PCT_SESSION_ID_SIZE);

    pBuffer = pMessage->VariantData;


    /* Pack certificate if present */


    pMessage->ResponseLenMsb = MSBOF(pCanonical->ResponseLen);
    pMessage->ResponseLenLsb = LSBOF(pCanonical->ResponseLen);

    if (pCanonical->ResponseLen)
    {
        CopyMemory( pBuffer,
                    pCanonical->Response,
                    pCanonical->ResponseLen);
    }

    SP_RETURN( PCT_ERR_OK );

}

SP_STATUS
Pct1UnpackServerVerify(
    PSPBuffer              pInput,
    PPct1_Server_Verify *        ppServer)
{
    PPct1_Server_Verify      pCanonical;
    PPCT1_SERVER_VERIFY  pMessage;
    PUCHAR              pBuffer;
    DWORD               cbResponse;
    DWORD               ReportedSize;

    SP_BEGIN("Pct1UnpackServerVerify");

    pMessage = pInput->pvBuffer;

    if(pInput->cbData < 2) 
    {
        pInput->cbData = 2;
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    ReportedSize = SIZEOF(pMessage);

    if ((ReportedSize+2) > pInput->cbData)
    {
        pInput->cbData = ReportedSize+2;
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    if(ReportedSize < PCT_OFFSET_OF(PPCT1_SERVER_VERIFY, VariantData))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    /* Verify Header: */


    if (pMessage->MessageId != PCT1_MSG_SERVER_VERIFY )
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }


    *ppServer = NULL;

    /* Verify Header: */


    cbResponse = COMBINEBYTES(pMessage->ResponseLenMsb,
                              pMessage->ResponseLenLsb);

    if (cbResponse > PCT_SESSION_ID_SIZE)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    pCanonical = (PPct1_Server_Verify)SPExternalAlloc( sizeof(Pct1_Server_Verify));

    if (!pCanonical)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY));
    }


    /* Expand out: */


    pCanonical->ResponseLen = cbResponse;

    CopyMemory((PUCHAR)pCanonical->SessionIdData, pMessage->SessionIdData,
               PCT_SESSION_ID_SIZE);

    pBuffer = pMessage->VariantData;

    CopyMemory(pCanonical->Response, pBuffer, cbResponse);

    *ppServer = pCanonical;
    pInput->cbData = ReportedSize + sizeof(PCT1_MESSAGE_HEADER);
    SP_RETURN(PCT_ERR_OK);
}


SP_STATUS
Pct1PackError(
    PPct1_Error            pCanonical,
    PSPBuffer              pCommOutput)
{
    DWORD               cbMessage;
    PPCT1_ERROR          pMessage;


    SP_BEGIN("Pct1PackError");

    if(pCanonical == NULL || pCommOutput == NULL) 
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }
    pCommOutput->cbData = 0;

    cbMessage = pCanonical->ErrInfoLen +
                    PCT_OFFSET_OF(PPCT1_ERROR, VariantData) -
                    sizeof(PCT1_MESSAGE_HEADER);

    if (cbMessage > PCT_MAX_SHAKE_LEN)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW));
    }

    pCommOutput->cbData = cbMessage+2;

        /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL) {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
        {
            SP_RETURN(SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY));
        }
        pCommOutput->cbBuffer = pCommOutput->cbData;
    }


    if(pCommOutput->cbData > pCommOutput->cbBuffer) 
    {
        SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
    }

    pMessage = pCommOutput->pvBuffer;

    pMessage->Header.Byte0 = MSBOF(cbMessage) | 0x80;
    pMessage->Header.Byte1 = LSBOF(cbMessage);

    pMessage->MessageId = PCT1_MSG_ERROR;

    pMessage->ErrorMsb = MSBOF(pCanonical->Error);
    pMessage->ErrorLsb = LSBOF(pCanonical->Error);

    pMessage->ErrorInfoMsb = MSBOF(pCanonical->ErrInfoLen);
    pMessage->ErrorInfoLsb = LSBOF(pCanonical->ErrInfoLen);

    if(pCanonical->ErrInfoLen) {
        CopyMemory(pMessage->VariantData, pCanonical->ErrInfo, pCanonical->ErrInfoLen);
    }

    SP_RETURN( PCT_ERR_OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\pct1srv.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/



#include <spbase.h>


#include <pct1msg.h>
#include <pct1prot.h>
#include <ssl2msg.h>

SP_STATUS
Pct1SrvHandleUniHello(
    PSPContext          pContext,
    PSPBuffer           pCommInput,
    PSsl2_Client_Hello  pHello,
    PSPBuffer           pCommOutput);



SP_STATUS WINAPI
Pct1ServerProtocolHandler(PSPContext pContext,
                    PSPBuffer  pCommInput,
                    PSPBuffer  pCommOutput,
                    PSPBuffer  pAppOutput)
{
    SP_STATUS      pctRet= 0;
    DWORD          dwStateTransition;

    SP_BEGIN("Pct1ServerProtocolHandler");

    if(pCommOutput) pCommOutput->cbData = 0;
    if(pAppOutput) pAppOutput->cbData = 0;
    /* Protocol handling steps should be listed in most common
     * to least common in order to improve performance
     */

    /* We are not connected, so we're doing
     * protocol negotiation of some sort.  All protocol
     * negotiation messages are sent in the clear */
    /* There are no branches in the connecting protocol
     * state transition diagram, besides connection and error,
     * which means that a simple case statement will do */

    /* Do we have enough data to determine what kind of message we have */
    /* Do we have enough data to determine what kind of message we have, or how much data we need*/

    dwStateTransition = (pContext->State & 0xffff);

    if(((pContext->State & 0xffff) != SP_STATE_CONNECTED) &&
       ((pContext->State & 0xffff) != PCT1_STATE_RENEGOTIATE))
    {
        if(pCommInput->cbData < 3)
        {
            pctRet = PCT_INT_INCOMPLETE_MSG;
        }
    }
    if(pCommInput->cbData >= 1)
    {
        dwStateTransition |= (((PUCHAR)pCommInput->pvBuffer)[2]<<16);
    }


    if(pctRet == PCT_ERR_OK)
    {
        switch(dwStateTransition)
        {
            case SP_STATE_CONNECTED:
            {
                //We're connected, and we got called, so we must be doing a REDO
                SPBuffer    In;
                DWORD       cbMessage;

                // Calculate size of buffer

                pCommOutput->cbData = 0;

                cbMessage    =  pContext->pCheck->cbCheckSum +
                                pContext->pSystem->BlockSize +
                                sizeof(PCT1_MESSAGE_HEADER_EX);


                    /* are we allocating our own memory? */
                if(pCommOutput->pvBuffer == NULL)
                {
                    pCommOutput->pvBuffer = SPExternalAlloc(cbMessage);
                    if (NULL == pCommOutput->pvBuffer)
                    {
                        SP_RETURN(SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY));
                    }
                    pCommOutput->cbBuffer = cbMessage;
                }


                if(cbMessage > pCommOutput->cbBuffer)
                {
                    SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
                }

                In.pvBuffer = ((char *)pCommOutput->pvBuffer)+3;
                In.cbBuffer = pCommOutput->cbBuffer-3;
                In.cbData = 1;

                ((char *)In.pvBuffer)[0] = PCT1_ET_REDO_CONN;

                // Build a Redo Request
                pctRet = Pct1EncryptRaw(pContext, &In, pCommOutput, PCT1_ENCRYPT_ESCAPE);
                break;
            }

            /* Server receives client hello */
            case (SSL2_MT_CLIENT_HELLO << 16) | UNI_STATE_RECVD_UNIHELLO:
            {
                PSsl2_Client_Hello pSsl2Hello;

                // Attempt to recognize and handle various versions of client
                // hello, start by trying to unpickle the most recent version, and
                // then next most recent, until one unpickles.  Then run the handle
                // code.  We can also put unpickling and handling code in here for
                // SSL messages.

                pctRet = Ssl2UnpackClientHello(pCommInput, &pSsl2Hello);
                if(PCT_ERR_OK == pctRet)
                {

                    pContext->RipeZombie->fProtocol = SP_PROT_PCT1_SERVER;

                    pctRet = Pct1SrvHandleUniHello(
			                     pContext,
			                     pCommInput,
			                     pSsl2Hello,
			                     pCommOutput);
                    if (PCT_ERR_OK == pctRet)
                    {
                        pContext->State = PCT1_STATE_SERVER_HELLO;
                    }

                    SPExternalFree(pSsl2Hello);
                }

                if (SP_FATAL(pctRet))
                {
	                pContext->State = PCT1_STATE_ERROR;
                }
                break;
            }
            /* Server receives client hello */

            case (PCT1_MSG_CLIENT_HELLO << 16) | PCT1_STATE_RENEGOTIATE:
            {
                PPct1_Client_Hello pPct1Hello;
                UCHAR fRealSessId = 0;
//                SessCacheItem   CachedSession;
//                int i;

                // This is a renegotiate hello, so we do not restart

                pctRet = Pct1UnpackClientHello(
                                pCommInput,
                                &pPct1Hello);

                if(PCT_ERR_OK == pctRet)
                {

                    pContext->RipeZombie->fProtocol = SP_PROT_PCT1_SERVER;
                    pctRet = Pct1SrvHandleClientHello(pContext,
                                                 pCommInput,
                                                 pPct1Hello,
                                                 pCommOutput);
                    if(PCT_ERR_OK == pctRet) {
                        pContext->State = PCT1_STATE_SERVER_HELLO;
                    }

                    SPExternalFree(pPct1Hello);

                }
                else if(pctRet != PCT_INT_INCOMPLETE_MSG)
                {
                    pctRet |= PCT_INT_DROP_CONNECTION;
                }

                if(SP_FATAL(pctRet)) {
                    pContext->State = PCT1_STATE_ERROR;
                }
                break;
            }
            case (PCT1_MSG_CLIENT_HELLO << 16) | SP_STATE_NONE:
            {
                PPct1_Client_Hello pPct1Hello;
                UCHAR fRealSessId = 0;
                SessCacheItem   CachedSession;
                int i;

                /* Attempt to recognize and handle various versions
                 * of client hello, start by trying to unpickle the
                 * most recent version, and then next most recent, until
                 * one unpickles.  Then run the handle code.  We can also put
                 * unpickling and handling code in here for SSL messages */
                pctRet = Pct1UnpackClientHello(
                                pCommInput,
                                &pPct1Hello);

                if(PCT_ERR_OK == pctRet)
                {


                    for(i=0;i<(int)pPct1Hello->cbSessionID;i++)
                    {
                        fRealSessId |= pPct1Hello->SessionID[i];
                    }

                    if ((fRealSessId) &&
                        (SPCacheRetrieveBySession(SP_PROT_PCT1_SERVER,
                                                  pPct1Hello->SessionID,
                                                  pPct1Hello->cbSessionID,
                                                  &pContext->RipeZombie)))
                    {
                        // We have a good zombie
                        pctRet = Pct1SrvRestart(pContext,
                                                pPct1Hello,
                                                pCommOutput,
                                                &CachedSession);

                        if(PCT_ERR_OK == pctRet)
                        {
                            pContext->State = SP_STATE_CONNECTED;
                            pContext->DecryptHandler = Pct1DecryptHandler;
                            pContext->Encrypt = Pct1EncryptMessage;
                            pContext->Decrypt = Pct1DecryptMessage;
                        }
                    }
                    else
                    {


                        pContext->RipeZombie->fProtocol = SP_PROT_PCT1_SERVER;
                        pctRet = Pct1SrvHandleClientHello(pContext,
                                                     pCommInput,
                                                     pPct1Hello,
                                                     pCommOutput);
                        if(PCT_ERR_OK == pctRet) {
                            pContext->State = PCT1_STATE_SERVER_HELLO;
                        }

                    }
                    SPExternalFree(pPct1Hello);

                }
                else if(pctRet != PCT_INT_INCOMPLETE_MSG)
                {
                    pctRet |= PCT_INT_DROP_CONNECTION;
                }

                if(SP_FATAL(pctRet)) {
                    pContext->State = PCT1_STATE_ERROR;
                }
                break;
            }
            case (PCT1_MSG_CLIENT_MASTER_KEY << 16) | PCT1_STATE_SERVER_HELLO:
                pctRet = Pct1SrvHandleCMKey(pContext,
                                            pCommInput,
                                            pCommOutput);
                if(SP_FATAL(pctRet)) {
                    pContext->State = PCT1_STATE_ERROR;
                } else {
                    if(PCT_ERR_OK == pctRet) {
                        pContext->State = SP_STATE_CONNECTED;
                        pContext->DecryptHandler = Pct1DecryptHandler;
                        pContext->Encrypt = Pct1EncryptMessage;
                        pContext->Decrypt = Pct1DecryptMessage;
                    }
                    /* We received a non-fatal error, so the state doesn't
                     * change, giving the app time to deal with this */
                }
                break;


            default:
                pContext->State = PCT1_STATE_ERROR;
                {
                    pctRet = PCT_INT_ILLEGAL_MSG;
                    if(((PUCHAR)pCommInput->pvBuffer)[2] == PCT1_MSG_ERROR)
                    {
                        /* we received an error message, process it */
                        pctRet = Pct1HandleError(pContext,
                                                 pCommInput,
                                                 pCommOutput);

                    } else {
                        /* we received an unknown error, generate a
                         * PCT_ERR_ILLEGAL_MESSAGE */
                        pctRet = Pct1GenerateError(pContext,
                                                    pCommOutput,
                                                    PCT_ERR_ILLEGAL_MESSAGE,
                                                    NULL);
                    }
                }

        }
    }
    if(pctRet & PCT_INT_DROP_CONNECTION) {
        pContext->State &= ~SP_STATE_CONNECTED;
    }
    SP_RETURN(pctRet);
}

SP_STATUS
Pct1SrvHandleUniHello(
    PSPContext         pContext,
    PSPBuffer           pCommInput,
    PSsl2_Client_Hello  pHello,
    PSPBuffer           pCommOutput)
{
    SP_STATUS pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    PSPCredential  pCred;
    Pct1_Server_Hello    Reply;
    DWORD           i,/* j,*/ k , fMismatch;
    SPBuffer        ErrData;
    DWORD           ClientCipher;
    DWORD           PctCipher;
    PSessCacheItem  pZombie;


    BOOL            fCipher = FALSE;
    BOOL            fHash = FALSE;
    BOOL            fExch = FALSE;
    BOOL            fCert = FALSE;
    CertSpec        CertSpec = 0;


    SP_BEGIN("Pct1SrvHandlUniHello");

    pCommOutput->cbData = 0;

    /* validate the buffer configuration */

    if(NULL == pContext)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    pCred = pContext->pCred;
    pZombie = pContext->RipeZombie;

    if (!pCred)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }
    /* validate the buffer configuration */
    ErrData.cbData = 0;
    ErrData.pvBuffer = NULL;
    ErrData.cbBuffer = 0;

    do {

        FillMemory( &Reply, sizeof( Reply ), 0 );

        //
        // Calculate common ciphers:
        //

        pContext->pSystem = NULL;
        pContext->pCheck = NULL;
        pContext->pKeyExch = NULL;


        for (ClientCipher = 0;
             ClientCipher < pHello->cCipherSpecs ;
             ClientCipher++ )
        {
            PctCipher = pHello->CipherSpecs[ClientCipher] & 0xffff;

            switch(pHello->CipherSpecs[ClientCipher] >> 16)
            {
                case PCT_SSL_HASH_TYPE:
                {
                    if(!fHash)
                    {
                        // We've not picked a hash yet, so
                        // pick one.
                        for(k=0; k < Pct1NumHash; k++) {
                            if(Pct1HashRank[k] == PctCipher)
                            {
                                if(HashFromSpec(PctCipher, SP_PROT_PCT1_SERVER))
                                {
                                    fHash = TRUE;
                                    pZombie->SessHashSpec = PctCipher;
                                    Reply.SrvHashSpec = PctCipher;
                                    break;
                                }
                            }
                        }
                    }
                    break;
                }

                case PCT_SSL_EXCH_TYPE:
                {
                    if(!fExch)
                    {
                        for(k=0; k < Pct1NumExch; k++) {
                            if(Pct1ExchRank[k] == PctCipher)
                            {
                                if(KeyExchangeFromSpec(PctCipher, SP_PROT_PCT1_SERVER))
                                {
                                    fExch = TRUE;
                                    pZombie->SessExchSpec = PctCipher;
                                    Reply.SrvExchSpec = PctCipher;
                                    break;
                                }
                            }
                        }

                    }
                    break;
                }

                case PCT_SSL_CIPHER_TYPE_1ST_HALF:
                {
                    if(!fCipher)
                    {

                        // Do we have enough room for a 2nd half.
                        if(ClientCipher+1 >= pHello->cCipherSpecs)
                        {
                            break;
                        }
                        if((pHello->CipherSpecs[ClientCipher+1] >> 16) != PCT_SSL_CIPHER_TYPE_2ND_HALF)
                        {
                            break;
                        }

                        PctCipher = (pHello->CipherSpecs[ClientCipher+1] & 0xffff) |
                                     (PctCipher<< 16);

                        for(k=0; k < Pct1NumCipher; k++)
                        {
                            if(Pct1CipherRank[k] == PctCipher)
                            {
                                if(CipherFromSpec(PctCipher, SP_PROT_PCT1_SERVER))
                                {
                                    fCipher = TRUE;
                                    pZombie->SessCiphSpec = PctCipher;
                                    Reply.SrvCipherSpec = PctCipher;
                                    break;
                                }
                            }
                        }
                    }
                    break;
                }

                case PCT_SSL_CERT_TYPE:
                {
                    if(!fCert)
                    {
                         pctRet = SPCredPickCertificate(SP_PROT_PCT1_SERVER,
                                                       pCred,
                                                       Pct1CertRank,
                                                       Pct1NumCert,
                                                       &PctCipher,
                                                       1,
                                                       &pZombie->pServerCert,
                                                       &pContext->pPrivateKey);

                        if(PCT_ERR_OK == pctRet)
                        {
                            fCert = TRUE;
                            Reply.SrvCertSpec = PctCipher;
                            Reply.pCertificate = pZombie->pServerCert->pRawCert;
                            Reply.CertificateLen = pZombie->pServerCert->cbRawCert;
                        }
                    }
                    break;
                }
             }
        }

        fMismatch = 0;
        if (!fCert)
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
            fMismatch |= PCT_IMIS_CERT;
        }
        if (!fCipher)
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
            fMismatch |= PCT_IMIS_CIPHER;
        }
        if (!fHash)
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
            fMismatch |= PCT_IMIS_HASH;
        }
        if (!fExch)
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
            fMismatch |= PCT_IMIS_EXCH;
        }

        pctRet = ContextInitCiphers(pContext);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }
        /* Generate a conneciton id to use while establishing connection */

        GenerateRandomBits(  Reply.ConnectionID,
                             PCT1_SESSION_ID_SIZE );
		Reply.cbConnectionID = PCT1_SESSION_ID_SIZE;

        CopyMemory( pContext->pConnectionID,
                    Reply.ConnectionID,
                    PCT1_SESSION_ID_SIZE );

	    pContext->cbConnectionID = PCT1_SESSION_ID_SIZE;

        /* Note, there are no restarts allowed in a UNIHELLO  */

        Reply.RestartOk = FALSE;
        Reply.ClientAuthReq = ((pContext->Flags & CONTEXT_FLAG_CLIAUTH) != 0);

         /* sig and cert specs are pre-zeroed when Reply is initialized */

        if(Reply.ClientAuthReq)
        {
            Reply.pClientSigSpecs = Pct1SigRank;
            Reply.cSigSpecs = Pct1NumSig;

            Reply.pClientCertSpecs = Pct1CertRank;
            Reply.cCertSpecs = Pct1NumCert;
        }
        /* Make the SSL2 challenge into a PCT1 challenge as per the
         * compatability doc. */

        CopyMemory( pContext->pChallenge,
                    pHello->Challenge,
                    pHello->cbChallenge);


        for(i=0; i < pHello->cbChallenge; i++)
        {
            pContext->pChallenge[i + pHello->cbChallenge] = ~pContext->pChallenge[i];
        }
        pContext->cbChallenge = 2*pHello->cbChallenge;



        pctRet = Pct1PackServerHello(&Reply, pCommOutput);
        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        /* Regenerate the internal pVerifyPrelude, so we */
        /* can match it against the client when we get the */
        /* client master key */

        pctRet = Pct1BeginVerifyPrelude(pContext,
                               pCommInput->pvBuffer,
                               pCommInput->cbData,
                               pCommOutput->pvBuffer,
                               pCommOutput->cbData);



        if(PCT_ERR_OK != pctRet)
        {
            break;
        }


        SP_RETURN(PCT_ERR_OK);
    } while (TRUE); /* end Polish Loop */
     if(pctRet == PCT_ERR_SPECS_MISMATCH) {
            BYTE            MisData[PCT_NUM_MISMATCHES];

            for(i=0;i<PCT_NUM_MISMATCHES;i++)
            {
                MisData[i] = (BYTE)(fMismatch & 1);
                fMismatch = fMismatch >> 1;
            }

            ErrData.cbData = ErrData.cbBuffer = PCT_NUM_MISMATCHES;
            ErrData.pvBuffer = MisData;
    }

    pctRet = Pct1GenerateError(pContext,
                              pCommOutput,
                              pctRet,
                              &ErrData);

   SP_RETURN(pctRet | PCT_INT_DROP_CONNECTION);
}



/* Otherwise known as Handle Client Hello */
SP_STATUS
Pct1SrvHandleClientHello(
    PSPContext          pContext,
    PSPBuffer           pCommInput,
    PPct1_Client_Hello  pHello,
    PSPBuffer           pCommOutput
    )
{
    SP_STATUS           pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    PSPCredential       pCred;
    Pct1_Server_Hello   Reply;
    DWORD               i, j, /*k ,*/ fMismatch;
    BYTE                MisData[PCT_NUM_MISMATCHES];
    SPBuffer            ErrData;
    PSessCacheItem      pZombie;
    BOOL            fCipher = FALSE;
    BOOL            fHash = FALSE;
    BOOL            fExch = FALSE;
    BOOL            fCert = FALSE;
#if DBG
    DWORD               di;
#endif

    SP_BEGIN("Pct1SrvHandleClientHello");

    pCommOutput->cbData = 0;

    /* validate the buffer configuration */
    ErrData.cbData = 0;
    ErrData.pvBuffer = NULL;
    ErrData.cbBuffer = 0;

    pZombie = pContext->RipeZombie;


    pCred = pContext->pCred;
    if (!pCred)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }


    do {

#if DBG
        DebugLog((DEB_TRACE, "Client Hello at %x\n", pHello));
        DebugLog((DEB_TRACE, "  CipherSpecs  %d\n", pHello->cCipherSpecs));
        for (di = 0 ; di < pHello->cCipherSpecs ; di++ )
        {
            DebugLog((DEB_TRACE, "    Cipher[%d] = %06x (%s)\n", di,
                      pHello->pCipherSpecs[di],
                      DbgGetNameOfCrypto(pHello->pCipherSpecs[di]) ));
        }
#endif


        /* store the challenge in the auth block */
        CopyMemory( pContext->pChallenge,
                    pHello->Challenge,
                    pHello->cbChallenge );
		pContext->cbChallenge = pHello->cbChallenge;


        CopyMemory( pZombie->SessionID,
                    pHello->SessionID,
                    pHello->cbSessionID );
	    pZombie->cbSessionID = pHello->cbSessionID;

        /* Begin to build the server hello */
        FillMemory( &Reply, sizeof( Reply ), 0 );

        /* no matter what, we need to make a new connection id */

        GenerateRandomBits(  Reply.ConnectionID,
                             PCT1_SESSION_ID_SIZE );
		Reply.cbConnectionID = PCT1_SESSION_ID_SIZE;

        CopyMemory( pContext->pConnectionID,
                    Reply.ConnectionID,
                    PCT1_SESSION_ID_SIZE );

	    pContext->cbConnectionID = PCT_SESSION_ID_SIZE;

        /* no restart case */
        /* fill in from properties here... */

        Reply.RestartOk = FALSE;
        Reply.ClientAuthReq = ((pContext->Flags & CONTEXT_FLAG_CLIAUTH) != 0);

        fMismatch = 0;
        /* pick a cert, any cert   */
        /* Server order of preference for certificates:
         * Hardcoded Preference (CertRank)
         *    Client Preference    (Hello)
         *        What server has     (pCred)
         */

        pctRet = SPCredPickCertificate(SP_PROT_PCT1_SERVER,
                                       pCred,
                                       Pct1CertRank,
                                       Pct1NumCert,
                                       pHello->pCertSpecs,
                                       pHello->cCertSpecs,
                                       &pZombie->pServerCert,
                                       &pContext->pPrivateKey);

        if(PCT_ERR_OK != pctRet)
        {
            fMismatch |= PCT_IMIS_CERT;
        }
        else
        {

            Reply.SrvCertSpec =     pZombie->pServerCert->Spec;
            Reply.pCertificate =    pZombie->pServerCert->pRawCert;
            Reply.CertificateLen =  pZombie->pServerCert->cbRawCert;
        }



        /* Determine Cipher to use */
        /* Cipher order of preference:
         * Server Preference
         *    Client Preference
         */
        for(i=0; i < Pct1NumCipher; i++)
        {
            // Do we enable this cipher
            if(NULL == CipherFromSpec(Pct1CipherRank[i], SP_PROT_PCT1_SERVER))
            {
                continue;
            }

            for(j=0; j< pHello->cCipherSpecs; j++)
            {
                // Does the client want this cipher type
                if(Pct1CipherRank[i] == pHello->pCipherSpecs[j])
                {
                    fCipher = TRUE;
                    pZombie->SessCiphSpec = Pct1CipherRank[i];
                    Reply.SrvCipherSpec = Pct1CipherRank[i];
                    break;
                }
            }
            if(fCipher)
            {
                break;
            }

        }

        if (!fCipher)
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
            fMismatch |= PCT_IMIS_CIPHER;
        }

        /* Determine Hash to use */
        /* Hash order of preference:
         * Server Preference
         *    Client Preference
         */
        for(i=0; i < Pct1NumHash; i++)
        {
            // Do we enable this cipher
            if(NULL == HashFromSpec(Pct1HashRank[i], SP_PROT_PCT1_SERVER))
            {
                continue;
            }

            for(j=0; j< pHello->cHashSpecs; j++)
            {
                // Does the client want this cipher type
                if(Pct1HashRank[i] == pHello->pHashSpecs[j])
                {
                    fHash = TRUE;
                    pZombie->SessHashSpec = Pct1HashRank[i];
                    Reply.SrvHashSpec = Pct1HashRank[i];
                    break;
                }
            }
            if(fHash)
            {
                break;
            }
        }

        if (!fHash)
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
            fMismatch |= PCT_IMIS_HASH;
        }
        /* Determine Key Exchange to use */
        /* Key Exchange order of preference:
         * Server Preference
         *    Client Preference
         */
        for(i=0; i < Pct1NumExch; i++)
        {
            // Do we enable this cipher
            if(NULL == KeyExchangeFromSpec(Pct1ExchRank[i], SP_PROT_PCT1_SERVER))
            {
                continue;
            }

            for(j=0; j< pHello->cExchSpecs; j++)
            {
                // Does the client want this cipher type
                if(Pct1ExchRank[i] == pHello->pExchSpecs[j])
                {
                    fExch = TRUE;
                    pZombie->SessExchSpec = Pct1ExchRank[i];
                    Reply.SrvExchSpec = Pct1ExchRank[i];
                    break;
                }
            }
            if(fExch)
            {
                break;
            }
        }


        if (!fExch)
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
            fMismatch |= PCT_IMIS_EXCH;
        }


        if (fMismatch) {
            pctRet = PCT_ERR_SPECS_MISMATCH;
            break;
        }

        pctRet = ContextInitCiphers(pContext);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        /* sig and cert specs are pre-zeroed when Reply is initialized */

        if(Reply.ClientAuthReq)
        {
            Reply.pClientSigSpecs = Pct1SigRank;
            Reply.cSigSpecs = Pct1NumSig;

            Reply.pClientCertSpecs = Pct1CertRank;
            Reply.cCertSpecs = Pct1NumCert;
        }



#if DBG
        DebugLog((DEB_TRACE, "Server picks cipher %06x (%s)\n",
                  Reply.SrvCipherSpec,
                  DbgGetNameOfCrypto(Reply.SrvCipherSpec) ));
#endif


        Reply.ResponseLen = 0;

        pctRet = Pct1PackServerHello(&Reply, pCommOutput);
        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        /* Regenerate the internal pVerifyPrelude, so we */
        /* can match it against the client when we get the */
        /* client master key */

        pctRet = Pct1BeginVerifyPrelude(pContext,
                               pCommInput->pvBuffer,
                               pCommInput->cbData,
                               pCommOutput->pvBuffer,
                               pCommOutput->cbData);



        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        SP_RETURN(PCT_ERR_OK);
    } while (TRUE); /* end Polish Loop */



    if(pctRet == PCT_ERR_SPECS_MISMATCH) {
            for(i=0;i<PCT_NUM_MISMATCHES;i++)
            {
                MisData[i] = (BYTE)(fMismatch & 1);
                fMismatch = fMismatch >> 1;
            }

            ErrData.cbData = ErrData.cbBuffer = PCT_NUM_MISMATCHES;
            ErrData.pvBuffer = MisData;
    }

    pctRet = Pct1GenerateError(pContext,
                              pCommOutput,
                              pctRet,
                              &ErrData);


    SP_RETURN(pctRet | PCT_INT_DROP_CONNECTION);

}



SP_STATUS
Pct1SrvHandleCMKey(
    PSPContext     pContext,
    PSPBuffer       pCommInput,
    PSPBuffer       pCommOutput)
{
    SP_STATUS          pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    PPct1_Client_Master_Key  pMasterKey = NULL;
    DWORD               dwKeyLen;
    DWORD               EncryptedLen;
    PCheckSumBuffer     pSum, pSubSum;
    HashBuf             SumBuf, SubSumBuf;
    Pct1_Server_Verify       Verify;
    UCHAR               VerifyPrelude[RESPONSE_SIZE];
    DWORD               cbVerifyPrelude;
    SPBuffer           ErrData;
    DWORD k;
    PSessCacheItem      pZombie;

    const SignatureSystem     *pSigSys = NULL;

    SP_BEGIN("PctHandleClientMasterKey");

    pCommOutput->cbData = 0;

    ErrData.cbData = 0;
    ErrData.pvBuffer = NULL;
    ErrData.cbBuffer = 0;
    pZombie = pContext->RipeZombie;

    do {


        pctRet = Pct1UnpackClientMasterKey(pCommInput, &pMasterKey);
        if (PCT_ERR_OK != pctRet)
        {
            // If it's an incomplete message or something, just return;
            if(!SP_FATAL(pctRet))
            {
                return pctRet;
            }
            break;
        }




        /* Validate that the client properly authed */

        /* The server requested client auth */
        /* NOTE: this deviates from the first pct 1.0 spec,
         * Now, we continue with the protocol if client
         * auth fails.  By the first spec, we should
         * drop the connection */

        if (pContext->Flags & CONTEXT_FLAG_CLIAUTH)
        {



            /* Client auth polish loop */
            pctRet = PCT_ERR_OK;
            do
            {


                /* check to see if the client sent no cert */
                if(pMasterKey->ClientCertLen == 0)
                {
                    /* No client auth */
                    break;
                }

                pctRet = SPLoadCertificate(SP_PROT_PCT1_SERVER,
                                           pMasterKey->ClientCertSpec,
                                           pMasterKey->pClientCert,
                                           pMasterKey->ClientCertLen,
                                           &pZombie->pClientCert,
                                           NULL);

                if(PCT_ERR_OK != pctRet)
                {
                    break;
                }
                if(pZombie->pClientCert == NULL)
                {
                    break;
                }



                /* verify that we got a sig type that meets PCT spec */
                for(k=0; k < Pct1NumSig; k++) {
                    if(Pct1SigRank[k] == pMasterKey->ClientSigSpec)
                    {
                        break;
                    }
                }

                if(k == Pct1NumSig)
                {
                    break;
                }

                if(NULL == (pSigSys = SigFromSpec(pMasterKey->ClientSigSpec, SP_PROT_PCT1_SERVER)))
                {
                    pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
                    break;
                }


                /* Validate Signature */
                if(!pSigSys->Verify(pMasterKey->VerifyPrelude,
                               pMasterKey->VerifyPreludeLen,
                               pMasterKey->Response,
                               pMasterKey->ResponseLen,
                               pZombie->pClientCert->pPublicKey))
                {
                    /* client auth signature failed to verify, so client auth
                     * does not happen
                     */
                    break;
                }

                pctRet = SPContextDoMapping(pContext);


            } while(FALSE); /* end polish loop */

            if(PCT_ERR_OK != pctRet)
            {
                break;
            }

        }

        /* Client auth was successful */
        pctRet = PCT_ERR_ILLEGAL_MESSAGE;
        EncryptedLen = PCT1_MASTER_KEY_SIZE;

        if(pMasterKey->ClearKeyLen > PCT1_MASTER_KEY_SIZE)
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
            break;
        }

        /* Decrypt the client keys */
        if ((!pContext->pKeyExch->Decrypt(pMasterKey->EncryptedKey,
                             pMasterKey->EncryptedKeyLen,
                             pZombie->pMasterKey,
                             &EncryptedLen,
                             pContext->pPrivateKey,
                             SP_PROT_PCT1_SERVER)) ||
            (EncryptedLen != MASTER_KEY_SIZE))
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
            break;
        }


        dwKeyLen = ((pZombie->SessCiphSpec & SP_CIPHER_STRENGTH) >> SP_CSTR_POS) / 8;

        if((dwKeyLen == PCT1_MASTER_KEY_SIZE ) && (pMasterKey->ClearKeyLen))
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
            break;
        }

        pZombie->cbClearKey = pMasterKey->ClearKeyLen;

        CopyMemory(pZombie->pClearKey, pMasterKey->ClearKey, pZombie->cbClearKey);

        pctRet = Pct1MakeSessionKeys( pContext);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        pctRet = PCT_ERR_INTEGRITY_CHECK_FAILED;


        if (pMasterKey->VerifyPreludeLen != pContext->pCheck->cbCheckSum)
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_INTEGRITY_CHECK_FAILED);
            break;
        }

        /* Check the verify prelude hashes */
        /* Hash(CLIENT_MAC_KEY, Hash( "cvp", CLIENT_HELLO, SERVER_HELLO)) */
        /* The internal hash should already be in the verify prelude buffer */
        /* from the handle client master key. */

        pctRet = Pct1EndVerifyPrelude(pContext, VerifyPrelude, &cbVerifyPrelude);
        if(PCT_ERR_OK != pctRet)
        {
            break;
        }


        /* Did the verify prelude hash successfully? */
        if(memcmp(VerifyPrelude, pMasterKey->VerifyPrelude, pContext->pCheck->cbCheckSum))
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_INTEGRITY_CHECK_FAILED);
            break;
        }

        /* don't need master key info anymore */
        SPExternalFree(pMasterKey);
        pMasterKey = NULL;


        pContext->WriteCounter = 2;
        pContext->ReadCounter = 2;

        GenerateRandomBits( pZombie->SessionID, PCT1_SESSION_ID_SIZE );
        pZombie->cbSessionID = PCT1_SESSION_ID_SIZE;

        CopyMemory( Verify.SessionIdData,
                    pZombie->SessionID,
                    pZombie->cbSessionID);

        /* compute the response */

        CloneHashBuf(SumBuf, pContext->WriteMACState, pContext->pCheck);
        InitHashBuf(SubSumBuf, pContext);

        pSum = (PCheckSumBuffer)SumBuf;
        pSubSum = (PCheckSumBuffer)SubSumBuf;

        pContext->pCheck->Sum(pSubSum,
                              PCT_CONST_RESP_LEN,
                              (PUCHAR)PCT_CONST_RESP);

        pContext->pCheck->Sum(pSubSum,
                              pContext->cbChallenge,
                              pContext->pChallenge);

        pContext->pCheck->Sum(pSubSum,
                              pContext->cbConnectionID,
                              pContext->pConnectionID);

        pContext->pCheck->Sum(pSubSum,
                              pZombie->cbSessionID,
                              pZombie->SessionID);

        /* we don't need the challenge anymore, so finish the compare hash */
        /* out into the challenge data memory. */

        pContext->pCheck->Finalize(pSubSum, pContext->pChallenge);

        pContext->pCheck->Sum(pSum,
                              pContext->pCheck->cbCheckSum,
                              pContext->pChallenge);
        pContext->pCheck->Finalize(pSum, pContext->pChallenge);

		pContext->cbChallenge = pContext->pCheck->cbCheckSum;
		
        CopyMemory( Verify.Response, pContext->pChallenge,
                    pContext->pCheck->cbCheckSum );

        Verify.ResponseLen = pContext->pCheck->cbCheckSum;

        pctRet = Pct1PackServerVerify(&Verify, pCommOutput);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        /* set up the session in cache */
        SPCacheAdd(pContext->RipeZombie);

        SP_RETURN(PCT_ERR_OK);
    } while(TRUE); /* End of polish loop */

    if(pMasterKey) SPExternalFree(pMasterKey);

    pctRet = Pct1GenerateError(pContext,
                              pCommOutput,
                              pctRet,
                              NULL);

    SP_RETURN(pctRet | PCT_INT_DROP_CONNECTION);

}


SP_STATUS
Pct1SrvRestart(
    PSPContext         pContext,
    PPct1_Client_Hello  pHello,
    PSPBuffer           pCommOutput,
    SessCacheItem *     CachedSession)
{
//    PCheckSumBuffer pSum, pSubSum;
//    HashBuf         SumBuf, SubSumBuf;
    Pct1_Server_Hello    Reply;
    SPBuffer       ErrData;
    SP_STATUS	 pctRet = PCT_INT_ILLEGAL_MSG;
    PSessCacheItem      pZombie;

    SP_BEGIN("Pct1SrvRestart");

    pCommOutput->cbData = 0;

    /* validate the buffer configuration */
    ErrData.cbData = 0;
    ErrData.pvBuffer = NULL;
    ErrData.cbBuffer = 0;

    pZombie = pContext->RipeZombie;



     do {

        /* store the challenge in the auth block */
        CopyMemory( pContext->pChallenge,
                    pHello->Challenge,
                    pHello->cbChallenge );
		pContext->cbChallenge = pHello->cbChallenge;


        /* Begin to build the server hello */
        FillMemory( &Reply, sizeof( Reply ), 0 );


        /* Generate new connection id */
        GenerateRandomBits(  Reply.ConnectionID,
                             PCT1_SESSION_ID_SIZE );
		Reply.cbConnectionID = PCT1_SESSION_ID_SIZE;

        CopyMemory( pContext->pConnectionID,
                    Reply.ConnectionID,
                    Reply.cbConnectionID );
		pContext->cbConnectionID = Reply.cbConnectionID;

        Reply.RestartOk = TRUE;


        /* We don't pass a server cert back during a restart */
        Reply.pCertificate = NULL;
        Reply.CertificateLen = 0;
        /* setup the context */


        Reply.SrvCipherSpec = pZombie->SessCiphSpec;
        Reply.SrvHashSpec =   pZombie->SessHashSpec;
        Reply.SrvCertSpec =   pZombie->pServerCert->Spec;
        Reply.SrvExchSpec =   pZombie->SessExchSpec;

        // We know what our ciphers are, so init the cipher system
        pctRet = ContextInitCiphers(pContext);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        if ((pZombie->SessCiphSpec & SP_CIPHER_STRENGTH) <
            SP_ENC_BITS_128)
        {
            Pct1MakeSessionKeys(pContext);
        }
        else
        {
            Pct1MakeSessionKeys(pContext);
        }

        /* calculate the response */
        pctRet = Pct1BuildRestartResponse(pContext, Reply.Response, &Reply.ResponseLen);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        pctRet = Pct1PackServerHello(&Reply, pCommOutput);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        pContext->ReadCounter = 1;
        pContext->WriteCounter = 1;

        SP_RETURN(PCT_ERR_OK);
    } while (TRUE);
    pctRet = Pct1GenerateError(pContext,
                              pCommOutput,
                              pctRet,
                              &ErrData);


    SP_RETURN(pctRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\pct1cli.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/


#include <spbase.h>
#include <pct1msg.h>
#include <pct1prot.h>




SP_STATUS WINAPI
Pct1ClientProtocolHandler(PSPContext pContext,
    PSPBuffer  pCommInput,
    PSPBuffer  pCommOutput,
    PSPBuffer  pAppOutput)
{
    SP_STATUS      pctRet= PCT_ERR_OK;
    DWORD           dwStateTransition;

    SP_BEGIN("Pct1ClientProtocolHandler");

    if(pCommOutput) pCommOutput->cbData = 0;
    if(pAppOutput) pAppOutput->cbData = 0;
    /* Protocol handling steps should be listed in most common
     * to least common in order to improve performance
     */

    /* We are not connected, so we're doing
     * protocol negotiation of some sort.  All protocol
     * negotiation messages are sent in the clear */
    /* There are no branches in the connecting protocol
     * state transition diagram, besides connection and error,
     * which means that a simple case statement will do */

    /* Do we have enough data to determine what kind of message we have */
    /* Do we have enough data to determine what kind of message we have, or how much data we need*/

    if(pCommInput->cbData < 3)
    {
        if((pContext->State & 0xffff) == PCT1_STATE_RENEGOTIATE)
        {
            dwStateTransition = (pContext->State & 0xffff);
        }
        else
        {
            pctRet = PCT_INT_INCOMPLETE_MSG;
        }
    }
    else
    {

        dwStateTransition = (((PUCHAR)pCommInput->pvBuffer)[2]<<16) |
                          (pContext->State & 0xffff);
    }

    if(pctRet == PCT_ERR_OK)
    {
        switch(dwStateTransition)
        {
            case PCT1_STATE_RENEGOTIATE:
            {
                SPBuffer In;
                SPBuffer Out;
                DWORD    cbMessage;
                BOOL     fAllocated = FALSE;

                 cbMessage    =  pContext->pCheck->cbCheckSum +
                                pContext->pSystem->BlockSize +
                                sizeof(PCT1_MESSAGE_HEADER_EX) +
                                PCT1_MAX_CLIENT_HELLO;


                    /* are we allocating our own memory? */
                if(pCommOutput->pvBuffer == NULL)
                {
                    pCommOutput->pvBuffer = SPExternalAlloc(cbMessage);
                    if (NULL == pCommOutput->pvBuffer)
                    {
                        SP_RETURN(SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY));
                    }
                    fAllocated = TRUE;
                    pCommOutput->cbBuffer = cbMessage;
                }


                if(cbMessage > pCommOutput->cbBuffer)
                {
                    if (fAllocated)
                    {
                        SPExternalFree(pCommOutput->pvBuffer);
                        pCommOutput->pvBuffer = NULL;
                        SP_RETURN(PCT_INT_INTERNAL_ERROR);
                    }
                    SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
                }

                In.pvBuffer = ((char *)pCommOutput->pvBuffer)+3;
                In.cbBuffer = pCommOutput->cbBuffer-3;
                In.cbData = 1;

                ((char *)In.pvBuffer)[0] = PCT1_ET_REDO_CONN;

                // Build a Redo Request
                pctRet = Pct1EncryptRaw(pContext, &In, pCommOutput, PCT1_ENCRYPT_ESCAPE);
                if(pctRet != PCT_ERR_OK)
                {
                    if (fAllocated)
                    {
                        SPExternalFree(pCommOutput->pvBuffer);
                        pCommOutput->pvBuffer = NULL;
                    }
                    break;
                }
                Out.pvBuffer = (char *)pCommOutput->pvBuffer + pCommOutput->cbData;
                Out.cbBuffer = pCommOutput->cbBuffer - pCommOutput->cbData;

                if (!SPCacheClone(&pContext->RipeZombie))
                {
                    SPExternalFree(pCommOutput->pvBuffer);
                    pCommOutput->pvBuffer = NULL;
                    SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
                }
                pctRet = GeneratePct1StyleHello(pContext, &Out);
                pCommOutput->cbData += Out.cbData;
                break;
            }
            /* Client receives Server hello */
            case (PCT1_MSG_SERVER_HELLO << 16) | UNI_STATE_CLIENT_HELLO:
            case (PCT1_MSG_SERVER_HELLO << 16) | PCT1_STATE_CLIENT_HELLO:
            {
                PPct1_Server_Hello pHello;
                /* Attempt to recognize and handle various versions
                 * of Server hello, start by trying to unpickle the
                 * oldest, and the next version, until
                 * one unpickles.  Then run the handle code.  We can also put
                 * unpickling and handling code in here for SSL messages */
                if(PCT_ERR_OK == (pctRet = Pct1UnpackServerHello(
                                                    pCommInput,
                                                    &pHello)))
                {
                    /* let's resurrect the zombie session */
                    if (pHello->RestartOk)
                    {
                        pctRet = Pct1CliRestart(pContext, pHello, pCommOutput);
                        if(PCT_ERR_OK == pctRet)
                        {
                            pContext->State = SP_STATE_CONNECTED;
                            pContext->DecryptHandler = Pct1DecryptHandler;
                            pContext->Encrypt = Pct1EncryptMessage;
                            pContext->Decrypt = Pct1DecryptMessage;
                        }
                    }
                    else
                    {

                        pContext->RipeZombie->fProtocol = SP_PROT_PCT1_CLIENT;

                        if (pContext->RipeZombie->cbMasterKey != 0)
                        {
                            // We've attempted to do a reconnect and the server has
                            // blown us off. In this case we must use a new and different
                            // cache entry.
                            if (!SPCacheClone(&pContext->RipeZombie))
                            {
                                pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
                            }
                        }
                        
                        if (pctRet == PCT_ERR_OK)
                        {
                            pctRet = Pct1CliHandleServerHello(pContext,
                                                            pCommInput,
                                                            pHello,
                                                            pCommOutput);
                        }
                        if(PCT_ERR_OK == pctRet)
                        {
                            pContext->State = PCT1_STATE_CLIENT_MASTER_KEY;
                            pContext->DecryptHandler = Pct1DecryptHandler;
                            pContext->Encrypt = Pct1EncryptMessage;     /* ?DCB? */
                            pContext->Decrypt = Pct1DecryptMessage;     /* ?DCB? */
                        }

                    }
                    SPExternalFree(pHello);

                }
                else if(pctRet != PCT_INT_INCOMPLETE_MSG)
                {
                    pctRet |= PCT_INT_DROP_CONNECTION;
                }

                if(SP_FATAL(pctRet))
                {
                    pContext->State = PCT1_STATE_ERROR;
                }

                break;
            }

            case (PCT1_MSG_SERVER_VERIFY << 16) | PCT1_STATE_CLIENT_MASTER_KEY:
                pctRet = Pct1CliHandleServerVerify(pContext,
                                                    pCommInput,
                                                    pCommOutput);
                if(SP_FATAL(pctRet))
                {
                    pContext->State = PCT1_STATE_ERROR;
                }
                else
                {
                    if(PCT_ERR_OK == pctRet)
                    {
                        pContext->State = SP_STATE_CONNECTED;
                        pContext->DecryptHandler = Pct1DecryptHandler;
                        pContext->Encrypt = Pct1EncryptMessage;
                        pContext->Decrypt = Pct1DecryptMessage;
                    }
                    /* We received a non-fatal error, so the state doesn't
                     * change, giving the app time to deal with this */
                }
                break;

            default:
                pContext->State = PCT1_STATE_ERROR;
                {
                    pctRet = PCT_INT_ILLEGAL_MSG;
                    if(((PUCHAR)pCommInput->pvBuffer)[2] == PCT1_MSG_ERROR)
                    {
                        /* we received an error message, process it */
                        pctRet = Pct1HandleError(pContext,
                                                 pCommInput,
                                                 pCommOutput);

                    }
                    else
                    {
                        /* we received an unknown error, generate a
                         * PCT_ERR_ILLEGAL_MESSAGE */
                        pctRet = Pct1GenerateError(pContext,
                                                    pCommOutput,
                                                    PCT_ERR_ILLEGAL_MESSAGE,
                                                    NULL);
                    }
                }

        }
    }
    if(pctRet & PCT_INT_DROP_CONNECTION)
    {
        pContext->State &= ~SP_STATE_CONNECTED;
    }
    SP_RETURN(pctRet);
}

SP_STATUS Pct1CliHandleServerHello(PSPContext pContext,
                                   PSPBuffer  pCommInput,
                                   PPct1_Server_Hello pHello,
                                   PSPBuffer  pCommOutput)
{
    /* error to return to peer */
    SP_STATUS          pctRet=PCT_ERR_ILLEGAL_MESSAGE;

    PctPrivateKey *pClientAuthKey = NULL;
    PSessCacheItem      pZombie;
    PSPCredential       pCred;
    PPct1_Client_Master_Key   pCMKey = NULL;
    SPBuffer           ErrData;

    DWORD               i, dwKeyLen;
    DWORD               fMismatch = 0;
    DWORD               cbClientCert = 0;
    SignatureSystem *   pSigSys = NULL;
    CertSystem *        pCertSys = NULL;
    BYTE                MisData[PCT_NUM_MISMATCHES];

    SP_BEGIN("Pct1CliHandleServerHello");
    pCommOutput->cbData = 0;

    /* validate the buffer configuration */
    ErrData.cbData = 0;
    ErrData.pvBuffer = NULL;
    ErrData.cbBuffer = 0;


    pCred = pContext->pCred;
    pZombie = pContext->RipeZombie;
    do {

#if DBG
        DebugLog((DEB_TRACE, "Hello = %x\n", pHello));
        DebugLog((DEB_TRACE, "   Restart\t%s\n", pHello->RestartOk ? "Yes":"No"));
        DebugLog((DEB_TRACE, "   ClientAuth\t%s\n",
                  pHello->ClientAuthReq ? "Yes":"No"));
        DebugLog((DEB_TRACE, "   Certificate Type\t%x\n", pHello->SrvCertSpec));
        DebugLog((DEB_TRACE, "   Hash Type\t%x\n", pHello->SrvHashSpec));
        DebugLog((DEB_TRACE, "   Cipher Type\t%x (%s)\n", pHello->SrvCipherSpec,
        DbgGetNameOfCrypto(pHello->SrvCipherSpec)));
        DebugLog((DEB_TRACE, "   Certificate Len\t%ld\n", pHello->CertificateLen));
#endif
        if(pHello->ClientAuthReq)
        {
            // If we're doing client auth, check to see if we have
            // proper credentials.
//            DWORD j;

            // Choose a certificate/private key pair for client auth.
            pctRet = SPCredPickCertificate(SP_PROT_PCT1_CLIENT,
                                           pCred,
                                           pHello->pClientCertSpecs,
                                           pHello->cCertSpecs,
                                           Pct1CertRank,
                                           Pct1NumCert,
                                           &pZombie->pClientCert,
                                           &pClientAuthKey);


            if (pctRet != PCT_ERR_OK)
            {
                // It's okay to return here as we've not done anything
                // yet.  We need to return this error as a warning.
                if(!(pContext->Flags & CONTEXT_FLAG_NO_INCOMPLETE_CRED_MSG))
                {
                    pctRet = PCT_ERR_INCOMPLETE_CREDS;
                    SP_RETURN( pctRet);
                }
            }
            pctRet  = SPSerializeCertificate(SP_PROT_PCT1_CLIENT,
                                             NULL,
                                             &cbClientCert,
                                             pZombie->pClientCert);
            if(pctRet != PCT_ERR_OK)
            {
                SP_RETURN(pctRet);
            }

        }



        CopyMemory(pContext->pConnectionID,
                   pHello->ConnectionID,
                   pHello->cbConnectionID);

        pContext->cbConnectionID = pHello->cbConnectionID;

        /* Set up server selected systems */
        pZombie->SessCiphSpec = pHello->SrvCipherSpec;
        pZombie->SessHashSpec = pHello->SrvHashSpec;
        pZombie->SessExchSpec = pHello->SrvExchSpec;

        // We know what our ciphers are, so init the cipher system
        pctRet = ContextInitCiphers(pContext);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }


        /* we aren't restarting, so let's continue with the protocol. */

        /* Crack the server certificate */

        pctRet = SPLoadCertificate(pZombie->fProtocol,
                                 pHello->SrvCertSpec,
                                 pHello->pCertificate,
                                 pHello->CertificateLen,
                                 &pZombie->pServerCert,
                                 NULL);


        if(pctRet != PCT_ERR_OK)
        {
            break;
        }

        /* Start building Response message */
        GenerateRandomBits(pZombie->pMasterKey, PCT1_MASTER_KEY_SIZE);
        pZombie->cbMasterKey = PCT1_MASTER_KEY_SIZE;

        /* take care of generating the needed clearkey if we are not */
        /* using a full strength cipher. */

        dwKeyLen = ((pZombie->SessCiphSpec & SP_CIPHER_STRENGTH) >> SP_CSTR_POS) / 8;

        if (dwKeyLen < MASTER_KEY_SIZE)
        {
            pZombie->cbClearKey = MASTER_KEY_SIZE - dwKeyLen;
            GenerateRandomBits(pZombie->pClearKey, pZombie->cbClearKey);
        }
        else
        {
            pZombie->cbClearKey = 0;
        }


        pctRet = PCT_ERR_ILLEGAL_MESSAGE;

        /* Create the verify prelude hashes */
        /* Which should look like  */
        /* Hash(CLIENT_MAC_KEY, Hash( "cvp", CLIENT_HELLO, SERVER_HELLO)) */
        /* Here we just do the inner hash */


        if(pContext->pClHello == NULL) {
            pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
            break;
        }
        pctRet = Pct1BeginVerifyPrelude(pContext,
                               pContext->pClHello,
                               pContext->cbClHello,
                               pCommInput->pvBuffer,
                               pCommInput->cbData);


        if(PCT_ERR_OK != pctRet)
        {
            break;
        }


        pCMKey = (PPct1_Client_Master_Key)SPExternalAlloc(sizeof(Pct1_Client_Master_Key) + cbClientCert);

        if (NULL == pCMKey)
        {
            pctRet = SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY);
            break;
        }



        if(PCT_ERR_OK != (pctRet = Pct1MakeSessionKeys(pContext)))
        {
            break;
        }

        pctRet = Pct1EndVerifyPrelude(pContext,
                                      pCMKey->VerifyPrelude,
                                      &pCMKey->VerifyPreludeLen);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }


        pCMKey->ClearKeyLen = pZombie->cbClearKey;

        if (pZombie->cbClearKey)
        {
            CopyMemory(pCMKey->ClearKey, pZombie->pClearKey, pZombie->cbClearKey);
        }

        pCMKey->KeyArgLen = 0;


        /* Choose a client cert */
        /* For each Cert the server understands, check to see if we */
        /* have that type of cert */

        pCMKey->ClientCertLen = 0;
        pCMKey->ClientCertSpec = 0;
        pCMKey->ClientSigSpec = 0;
        pCMKey->ResponseLen = 0;

        if(pHello->ClientAuthReq &&
           pZombie->pClientCert != NULL &&
           pZombie->pClientCert->cbRawCert != 0)
        {
            DWORD j;
            const SignatureSystem *pSigSys = NULL;

            pCMKey->ClientCertSpec = pZombie->pClientCert->Spec;
            pCMKey->pClientCert = (PUCHAR)(pCMKey+1);

            pctRet  = SPSerializeCertificate(SP_PROT_PCT1_CLIENT,
                                            &pCMKey->pClientCert,
                                            &pCMKey->ClientCertLen,
                                            pZombie->pClientCert);
            if(pctRet != PCT_ERR_OK)
            {
                SP_RETURN(pctRet);
            }



            /* Choose the client signature that we want */
            for(j=0;j<pHello->cSigSpecs;j++)
            {
                if(pSigSys = SigFromSpec(pHello->pClientSigSpecs[j], pZombie->fProtocol))
                {
                    pCMKey->ClientSigSpec = pHello->pClientSigSpecs[j];
                    break;
                }
            }

            if (pSigSys == NULL)
            {
                fMismatch |= PCT_IMIS_CL_SIG;
                pctRet = SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
            }

            if(fMismatch) break;

            pCMKey->ResponseLen = PCT_SIGNATURE_SIZE;
            if(!pSigSys->Sign(pCMKey->VerifyPrelude,
                              pCMKey->VerifyPreludeLen,
                              pCMKey->Response,
                              &pCMKey->ResponseLen,
                              pClientAuthKey))
            {
                pctRet = SP_LOG_RESULT(PCT_ERR_BAD_CERTIFICATE);
                break;
            }
        }

        /* ok, we have the master key.  Now, encrypt it with the */
        /* public key we got from our friends on the net... */


        pCMKey->EncryptedKeyLen = ENCRYPTED_KEY_SIZE;


        if(!pContext->pKeyExch->Encrypt(
                            (PUCHAR)pZombie->pMasterKey,
                            pZombie->cbMasterKey,
                            pCMKey->EncryptedKey,
                            &pCMKey->EncryptedKeyLen,
                            pZombie->pServerCert->pPublicKey, 0))
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_BAD_CERTIFICATE);
            break;
        }

        pctRet = PCT_ERR_ILLEGAL_MESSAGE;
        if(PCT_ERR_OK != (pctRet = Pct1PackClientMasterKey(pCMKey,
                                                           pCommOutput)))
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
            break;
        }

        pContext->WriteCounter++;

        if(pCMKey)
        {
            SPExternalFree(pCMKey);
        }
        SP_RETURN(PCT_ERR_OK);
        break;
    } while(TRUE);

    if(pCMKey)
    {
        SPExternalFree(pCMKey);
    }
    if(pctRet == PCT_ERR_SPECS_MISMATCH)
    {
        for(i=0;i<PCT_NUM_MISMATCHES;i++)
        {
            MisData[i] = (BYTE)(fMismatch & 1);
            fMismatch = fMismatch >> 1;
        }

        ErrData.cbData = ErrData.cbBuffer = PCT_NUM_MISMATCHES;
        ErrData.pvBuffer = MisData;
    }

    pctRet = Pct1GenerateError(pContext,
                              pCommOutput,
                              pctRet,
                              &ErrData);


    SP_RETURN(pctRet | PCT_INT_DROP_CONNECTION);

}



SP_STATUS
Pct1CliRestart(PSPContext  pContext,
              PPct1_Server_Hello pHello,
              PSPBuffer pCommOutput)
{
    SP_STATUS           pctRet = PCT_ERR_ILLEGAL_MESSAGE;
//    HashBuf             SumBuf,
//                        SubSumBuf;
//    PCheckSumBuffer     pSum,
//                        pSubSum;
    UCHAR               Response[RESPONSE_SIZE];
    DWORD               cbResponse;
    PPct1_Server_Hello  pLocalHello = pHello;
    PSessCacheItem      pZombie;

    SP_BEGIN("Pct1CliRestart");
    pZombie = pContext->RipeZombie;

    do {
        /* if there's no zombie, the message is wrong.  We can't restart. */

        if(pZombie == NULL  ||
           pZombie->ZombieJuju == FALSE)
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
            break;
        }


		CopyMemory(pContext->pConnectionID,
		           pHello->ConnectionID,
		           pHello->cbConnectionID);

        pContext->cbConnectionID = pHello->cbConnectionID;



        // We know what our ciphers are, so init the cipher system
        pctRet = ContextInitCiphers(pContext);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        pctRet = Pct1MakeSessionKeys(pContext);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        pctRet = PCT_ERR_ILLEGAL_MESSAGE;

        DebugLog((DEB_TRACE, "Session Keys Made\n"));
        /* let's check the response in the message */

        /* check the length */
        if (pLocalHello->ResponseLen != pContext->pCheck->cbCheckSum)
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
            break;
        }

        /* calculate the correct response */
        /* calculate the response */
        pctRet = Pct1BuildRestartResponse(pContext, Response, &cbResponse);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        /* check it against the response in the message */

        if (memcmp(Response, pLocalHello->Response, pLocalHello->ResponseLen))
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_SERVER_AUTH_FAILED);
            break;
        }
        /* ok, we're done, so let's jettison the auth data */
        pContext->ReadCounter = 1;
        pContext->WriteCounter = 1;

        /* fini. */
        SP_RETURN(PCT_ERR_OK);
    } while (TRUE);

    pctRet = Pct1GenerateError(pContext,
                              pCommOutput,
                              pctRet,
                              NULL);

    SP_RETURN(pctRet | PCT_INT_DROP_CONNECTION);
}




SP_STATUS
Pct1CliHandleServerVerify(
                          PSPContext pContext,
                          PSPBuffer  pCommInput,
                          PSPBuffer  pCommOutput)
{
    SP_STATUS     pctRet = PCT_ERR_ILLEGAL_MESSAGE;

    PCheckSumBuffer         pSum,
                            pSubSum;
    PPct1_Server_Verify     pVerify = NULL;
    HashBuf                 SumBuf,
                            SubSumBuf;
    SPBuffer                ErrData;
    PSessCacheItem      pZombie;


    SP_BEGIN("Pct1CliHandleServerVerify");

    pZombie = pContext->RipeZombie;
    pContext->ReadCounter = 2;
    pContext->WriteCounter = 2;

    pCommOutput->cbData = 0;

    ErrData.cbData = 0;
    ErrData.pvBuffer = NULL;
    ErrData.cbBuffer = 0;

    do
    {

        /* unpack the message */
        pctRet = Pct1UnpackServerVerify(pCommInput, &pVerify);
        if (PCT_ERR_OK != pctRet)
        {
            // If it's an incomplete message or something, just return;
            if(!SP_FATAL(pctRet))
            {
                return pctRet;
            }
            break;
        }



        CloneHashBuf(SumBuf, pContext->ReadMACState, pContext->pCheck);
        InitHashBuf(SubSumBuf, pContext);

        pSum = (PCheckSumBuffer)SumBuf;
        pSubSum = (PCheckSumBuffer)SubSumBuf;

        /* Build this hash : Hash ("cvp", CH_CHALLENGE_DATE, SH_CONNECTION_ID_DATA, SV_SESSION_ID_DATA)
         * Place the result in pAuth->Challenge temporarily */
        pContext->pCheck->Sum(pSubSum,
                              PCT_CONST_RESP_LEN,
                              (PUCHAR)PCT_CONST_RESP);

        pContext->pCheck->Sum(pSubSum,
                              pContext->cbChallenge,
                              pContext->pChallenge);

        pContext->pCheck->Sum(pSubSum,
                              pContext->cbConnectionID,
                              pContext->pConnectionID);

        pContext->pCheck->Sum(pSubSum,
                              PCT_SESSION_ID_SIZE,
                              pVerify->SessionIdData);

        pContext->pCheck->Finalize(pSubSum, pContext->pChallenge);
        pContext->cbChallenge = pContext->pCheck->cbCheckSum;

        /*  Finish the hash, by hashing the result in pAuth->Challenge with
         * SERVER_MAC_KEY.  Note, SERVER_MAC_KEY has was pre-initialized
         * so there is no sum. */

        pContext->pCheck->Sum(pSum,
                              pContext->cbChallenge,
                              pContext->pChallenge);

        pContext->pCheck->Finalize(pSum, pContext->pChallenge);

        /* Result stored */
		pContext->cbChallenge = pContext->pCheck->cbCheckSum;

        if ((pVerify->ResponseLen != pContext->pCheck->cbCheckSum) ||
            (memcmp(pVerify->Response, pContext->pChallenge, pVerify->ResponseLen)))
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
            break;
        }

        CopyMemory(pZombie->SessionID,
                   pVerify->SessionIdData,
                   PCT_SESSION_ID_SIZE);

		pZombie->cbSessionID = PCT_SESSION_ID_SIZE;

        /* done with the verify data */
        SPExternalFree(pVerify);
        pVerify = NULL;

        /* set up the session in cache */
        SPCacheAdd(pContext->RipeZombie);

        SP_RETURN( PCT_ERR_OK );
    } while(TRUE); /* End of polish loop */

    if(pVerify) SPExternalFree(pVerify);

    pctRet = Pct1GenerateError(pContext,
                              pCommOutput,
                              pctRet,
                              NULL);

    SP_RETURN(pctRet | PCT_INT_DROP_CONNECTION);

}

SP_STATUS
WINAPI
GeneratePct1StyleHello(
    PSPContext             pContext,
    PSPBuffer              pOutput)
{
    Pct1_Client_Hello    HelloMessage;
    PSessCacheItem       pZombie;
    CipherSpec          aCipherSpecs[10];
    HashSpec            aHashSpecs[10];
    CertSpec            aCertSpecs[10];
    ExchSpec            aExchSpecs[10];
    DWORD i;

    SP_STATUS pctRet = PCT_INT_INTERNAL_ERROR;

    SP_BEGIN("Pct1CliInstigateHello");

    HelloMessage.pCipherSpecs = aCipherSpecs;
    HelloMessage.pHashSpecs = aHashSpecs;
    HelloMessage.pCertSpecs = aCertSpecs;
    HelloMessage.pExchSpecs = aExchSpecs;

    if(pContext == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    if (!pOutput)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    pZombie = pContext->RipeZombie;


    pContext->Flags |= CONTEXT_FLAG_CLIENT;

    GenerateRandomBits( pContext->pChallenge, PCT1_CHALLENGE_SIZE );
    pContext->cbChallenge = PCT1_CHALLENGE_SIZE;
    /* Build the hello message. */

    HelloMessage.cbChallenge = PCT1_CHALLENGE_SIZE;
    HelloMessage.pKeyArg = NULL;
    HelloMessage.cbKeyArgSize = 0;


    HelloMessage.cCipherSpecs = 0;
    for(i=0; i < Pct1NumCipher; i++)
    {
        if(NULL != CipherFromSpec(Pct1CipherRank[i], SP_PROT_PCT1_CLIENT))
        {
            HelloMessage.pCipherSpecs[HelloMessage.cCipherSpecs++] = Pct1CipherRank[i];
        }
    }

    HelloMessage.cHashSpecs = 0;
    for(i=0; i < Pct1NumHash; i++)
    {
        if(NULL != HashFromSpec(Pct1HashRank[i], SP_PROT_PCT1_CLIENT))
        {
            HelloMessage.pHashSpecs[HelloMessage.cHashSpecs++] = Pct1HashRank[i];
        }
    }

    HelloMessage.cCertSpecs = 0;
    for(i=0; i < Pct1NumCert; i++)
    {
        if(NULL != CertFromSpec(Pct1CertRank[i], SP_PROT_PCT1_CLIENT))
        {
            HelloMessage.pCertSpecs[HelloMessage.cCertSpecs++] = Pct1CertRank[i];
        }
    }

    HelloMessage.cExchSpecs = 0;
    for(i=0; i < Pct1NumExch; i++)
    {
        if(NULL != KeyExchangeFromSpec(Pct1ExchRank[i], SP_PROT_PCT1_CLIENT))
        {
            HelloMessage.pExchSpecs[HelloMessage.cExchSpecs++] = Pct1ExchRank[i];
        }
    }


    if (pZombie->cbSessionID)
    {
        CopyMemory(HelloMessage.SessionID, pZombie->SessionID, pZombie->cbSessionID);
        HelloMessage.cbSessionID = pZombie->cbSessionID;
    }
    else
    {
	    FillMemory(HelloMessage.SessionID, PCT_SESSION_ID_SIZE, 0);
	    HelloMessage.cbSessionID = PCT_SESSION_ID_SIZE;
    }

    CopyMemory(  HelloMessage.Challenge,
                pContext->pChallenge,
                HelloMessage.cbChallenge );
    HelloMessage.cbChallenge = pContext->cbChallenge;

    pctRet = Pct1PackClientHello(&HelloMessage,  pOutput);

    if(PCT_ERR_OK != pctRet)
    {
        SP_RETURN(pctRet);
    }


    /* we need to keep the actual message around, since we need to */
    /* hash it later, and we don't know the hash algorithm to use */
    /* yet. */

    pContext->pClHello = SPExternalAlloc(pOutput->cbData);
    if(pContext->pClHello == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY));
    }
    CopyMemory(pContext->pClHello, pOutput->pvBuffer, pOutput->cbData);
    pContext->cbClHello = pOutput->cbData;

    /* We set this here to tell the protocol engine that we just send a client
     * hello, and we're expecing a pct server hello */
    pContext->State = PCT1_STATE_CLIENT_HELLO;
    SP_RETURN(PCT_ERR_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\pct2msg.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology 
* reference implementation, version 1.0
* 
* The Private Communication Technology reference implementation, version 1.0 
* ("PCTRef"), is being provided by Microsoft to encourage the development and 
* enhancement of an open standard for secure general-purpose business and 
* personal communications on open networks.  Microsoft is distributing PCTRef 
* at no charge irrespective of whether you use PCTRef for non-commercial or 
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without 
* warranty of any kind, either express or implied, including, without 
* limitation, the implied warranties or merchantability, fitness for a 
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out 
* of use or performance of PCTRef remains with you.
* 
* Please see the file LICENSE.txt, 
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
* 
* Please see http://pct.microsoft.com/pct/pct.htm for The Private 
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/ 

#ifndef __PCT2MSG_H__
#define __PCT2MSG_H__

/* record types */
#define PCT2_RT_HANDSHAKE        0x0301
#define PCT2_RT_KEY_MGMT         0x0302
#define PCT2_RT_DATAGRAM         0x0303
#define PCT2_RT_ERROR            0x0304
#define PCT2_RT_USER_DATA        0x0305
#define PCT2_RT_PCT_VERSION_1_CH 0x0180
#define PCT2_RT_PCT_VERSION_1_SH 0x0280
#define PCT2_RT_SSL_VERSION_2_CH 0x0100
#define PCT2_RT_SSL_VERSION_3_CH 0x0000
#define PCT2_RT_CD_RESERVED      0x6364
#define PCT2_RT_KR_RESERVED      0x6B72
#define PCT2_RT_ESCROW           0x0310


/* HS message Types */
#define PCT2_HS_CLIENT_HELLO      0x0000
#define PCT2_HS_SERVER_HELLO      0x0001
#define PCT2_HS_CLIENT_MASTER_KEY 0x0002
#define PCT2_HS_SERVER_VERIFY     0x0003
#define PCT2_HS_CLIENT_VERIFY     0x0004

/* KM message types */
#define PCT2_KM_TYPE_FIXED_KEY       0x0001
#define PCT2_KM_TYPE_RESUME_KEY      0x0002
#define PCT2_KM_TYPE_REDO_HANDSHAKE  0x0003
#define PCT2_KM_TYPE_CLOSE_CONN      0x0004

/* DM message types */
#define PCT2_DM_TYPE_USER_DATA       0x0000

/* PV types */
#define PCT2_PV_TYPE_CERTIFICATE     0x0001
#define PCT2_PV_TYPE_PKCS_TOKEN      0x0002
#define PCT2_PV_TYPE_KEA             0x0003
#define PCT2_PV_TYPE_EPHEMERAL_RSA   0x0004
#define PCT2_PV_TYPE_EPHERERAL_DH    0x0005


/* CH Auth Types */
#define PCT2_CH_REQUEST_KEY_EXCH_SEND  0x0001
#define PCT2_CH_DEMAND_AUTH_KEY_EXCH   0x0002
#define PCT2_CH_DEMAND_AUTH_SIG        0x0004
#define PCT2_CH_DEMAND_AUTH_PASSWORD   0x0008
#define PCT2_CH_OFFER_KEY_EXCH_RECEIVE 0x0010
#define PCT2_CH_OFFER_AUTH_KEY_EXCH    0x0020
#define PCT2_CH_OFFER_AUTH_SIG         0x0040
#define PCT2_CH_OFFER_AUTH_PASSWORD    0x0080

/* SH auth types */
#define PCT2_SH_ACCEDE_KEY_EXCH_RECEIVE  0x0001
#define PCT2_SH_ACCEDE_AUTH_KEY_EXCH     0x0002
#define PCT2_SH_ACCEDE_AUTH_SIG          0x0004
#define PCT2_SH_ACCEDE_AUTH_PASSWORD     0x0008
#define PCT2_SH_ACCEPT_KEY_EXCH_SEND     0x0010
#define PCT2_SH_ACCEPT_AUTH_KEY_EXCH     0x0020
#define PCT2_SH_ACCEPT_AUTH_SIG          0x0040
#define PCT2_SH_ACCEPT_AUTH_PASSWORD     0x0080
#define PCT2_SH_ACCEPT_RECONNECT         0x0100


#define PCT2_HS_FLAG_TO_BE_CONTD  0x0001
#define PCT2_HS_FLAG_CONTINUATION 0x0002
#define PCT2_CONNECTION_ID_SIZE  30
#define PCT2_SESSION_ID_SIZE     30
#define PCT2_CHALLENGE_SIZE      30

#define PCT_VERSION_2   0x8002
#define PCT_CH_OFFSET_V2 0x0012
/*
 *
 * Useful Macros
 *
 */

#define LSBOF(x)    ((UCHAR) (x & 0xFF))
#define MSBOF(x)    ((UCHAR) ((x >> 8) & 0xFF) )

#define COMBINEBYTES(Msb, Lsb)  ((DWORD) (((DWORD) (Msb) << 8) | (DWORD) (Lsb)))

/* external representations of algorithm specs */

typedef DWORD   ExtCipherSpec, *PExtCipherSpec;
typedef WORD    ExtHashSpec,   *PExtHashSpec;
typedef WORD    ExtCertSpec,   *PExtCertSpec;
typedef WORD    ExtExchSpec,   *PExtExchSpec;
typedef WORD    ExtSigSpec,    *PExtSigSpec;
typedef WORD    ExtMsgSpec,    *PExtMsgSpec;

typedef WORD    Pct2MsgSpec , *PPct2MsgSpec;

typedef struct _PCT2_RECORD_HEADER {
    UCHAR   LengthMSB;
    UCHAR   LengthLSB;
    UCHAR   TypeMSB;
    UCHAR   TypeLSB;
} PCT2_RECORD_HEADER, * PPCT2_RECORD_HEADER;

typedef struct _PCT2_HS_MESSAGE_HEADER {
    PCT2_RECORD_HEADER  RecHeader;
    UCHAR               MessageTypeMsb;
    UCHAR               MessageTypeLsb;
    UCHAR               RecordFlagsMsb;
    UCHAR               RecordFlagsLsb;
} PCT2_HS_MESSAGE_HEADER, *PPCT2_HS_MESSAGE_HEADER;

typedef struct _PCT2_CLIENT_HELLO {
    UCHAR               SessionIdData[PCT2_SESSION_ID_SIZE];
    UCHAR               ChallengeData[PCT2_CHALLENGE_SIZE];
    UCHAR               VersionMsb;
    UCHAR               VersionLsb;
    UCHAR               OffsetMsb;
    UCHAR               OffsetLsb;
    UCHAR               CipherSpecsLenMsb;
    UCHAR               CipherSpecsLenLsb;
    UCHAR               HashSpecsLenMsb;
    UCHAR               HashSpecsLenLsb;
    UCHAR               CertSpecsLenMsb;
    UCHAR               CertSpecsLenLsb;
    UCHAR               ExchSpecsLenMsb;
    UCHAR               ExchSpecsLenLsb;
    UCHAR               KeyArgLenMsb;
    UCHAR               KeyArgLenLsb;
    /* Start of PCT2 specific data */

    UCHAR               MsgListLenMsb;
    UCHAR               MsgListLenLsb;
    UCHAR               SigListLenMsb;
    UCHAR               SigListLenLsb;
    UCHAR               CertifierListLenMsb;
    UCHAR               CertifierListLenLsb;
    UCHAR               QuickPublicValueLenMsb;
    UCHAR               QuickPublicValueLenLsb;
    UCHAR               QuickServerPublicValueLenMsb;
    UCHAR               QuickServerPublicValueLenLsb;
    UCHAR               QuickEncryptedKeyLenMsb;
    UCHAR               QuickEncryptedKeyLenLsb;
    UCHAR               AuthOptionsMsb;
    UCHAR               AuthOptionsLsb;

    UCHAR               VariantData[1];
} PCT2_CLIENT_HELLO, * PPCT2_CLIENT_HELLO;


typedef struct _PCT2_SERVER_HELLO {
    UCHAR               VersionMsb;
    UCHAR               VersionLsb;
    UCHAR               AuthOptionsMsb;
    UCHAR               AuthOptionsLsb;
   
    ExtCipherSpec       CipherSpecData;
    ExtHashSpec         HashSpecData;
    ExtExchSpec         ExchSpecData;
    ExtSigSpec          SigSpecData;

    UCHAR               ConnectionIdData[PCT2_CONNECTION_ID_SIZE];
    UCHAR               SessionIdData[PCT2_SESSION_ID_SIZE];
    UCHAR               AltCipherListLenMsb;
    UCHAR               AltCipherListLenLsb;
    UCHAR               AltHashListLenMsb;
    UCHAR               AltHashListLenLsb;
    UCHAR               MsgListLenMsb;
    UCHAR               MsgListLenLsb;
    UCHAR               ExchListLenMsb;
    UCHAR               ExchListLenLsb;
    UCHAR               CertListLenMsb;
    UCHAR               CertListLenLsb;
    UCHAR               QuickEncryptedKeyLenMsb;
    UCHAR               QuickEncryptedKeyLenLsb;
    UCHAR               ResponseLenMsb;
    UCHAR               ResponseLenLsb;
    UCHAR               CertifierListLenMsb;
    UCHAR               CertifierListLenLsb;
    UCHAR               PublicValueLenMsb;
    UCHAR               PublicValueLenLsb;
    UCHAR               SigCertLenMsb;
    UCHAR               SigCertLenLsb;

    UCHAR               VariantData[1];
} PCT2_SERVER_HELLO, * PPCT2_SERVER_HELLO;



typedef struct _PCT2_CLIENT_MASTER_KEY {

    UCHAR               EncryptedKeyLenMsb;
    UCHAR               EncryptedKeyLenLsb;
    UCHAR               ResponseLenMsb;
    UCHAR               ResponseLenLsb;
    UCHAR               PublicValueLenMsb;
    UCHAR               PublicValueLenLsb;
    UCHAR               SigCertLenMsb;
    UCHAR               SigCertLenLsb;
    UCHAR               VariantData[1];
} PCT2_CLIENT_MASTER_KEY, * PPCT2_CLIENT_MASTER_KEY;


typedef struct _PCT2_SERVER_VERIFY {

    UCHAR               EncryptedKeyLenMsb;
    UCHAR               EncryptedKeyLenLsb;
    UCHAR               ResponseLenMsb;
    UCHAR               ResponseLenLsb;
    UCHAR               SigCertLenMsb;
    UCHAR               SigCertLenLsb;
    UCHAR               VariantData[1];
} PCT2_SERVER_VERIFY, * PPCT2_SERVER_VERIFY;

typedef struct _PCT2_CLIENT_VERIFY {

    UCHAR               ResponseLenMsb;
    UCHAR               ResponseLenLsb;
    UCHAR               SigCertLenMsb;
    UCHAR               SigCertLenLsb;
    UCHAR               VariantData[1];
} PCT2_CLIENT_VERIFY, * PPCT2_CLIENT_VERIFY;

typedef struct _PCT2_PUBLIC_VALUE {
    UCHAR               ValueTypeMsb;
    UCHAR               ValueTypeLsb;
    UCHAR               UserSpecInfoLenMsb;
    UCHAR               UserSpecInfoLenLsb;
    UCHAR               Parameter1LenMsb;
    UCHAR               Parameter1LenLsb;
    UCHAR               Parameter2LenMsb;
    UCHAR               Parameter2LenLsb;
    UCHAR               VariantData[1];
} PCT2_PUBLIC_VALUE, *PPCT2_PUBLIC_VALUE, PCT2_QUICK_PUBLIC_VALUE, *PPCT2_QUICK_PUBLIC_VALUE;



typedef struct _PCT2_ENCRYPTED_KEY {
    UCHAR               EncryptedKey1LenMsb;
    UCHAR               EncryptedKey1LenLsb;
    UCHAR               EncryptedKey2LenMsb;
    UCHAR               EncryptedKey2LenLsb;
    UCHAR               KeyArgLenMsb;
    UCHAR               KeyArgLenLsb;
    UCHAR               VariantData[1];
} PCT2_ENCRYPTED_KEY, *PPCT2_ENCRYPTED_KEY, PCT2_QUICK_ENCRYPTED_KEY, *PPCT2_QUICK_ENCRYPTED_KEY;


/*
 *
 * Expanded Form Messages:
 *
 */

typedef struct _Pct2_Public_Value {
    DWORD           ValueType;
    DWORD           cbUserInfo;
    DWORD           cbParameter1;
    DWORD           cbParameter2;
    PUCHAR          pUserInfo;
    PUCHAR          pParameter1;
    PUCHAR          pParameter2;
} Pct2_Public_Value, *PPct2_Public_Value;

typedef struct _Pct2_Encrypted_Key_Data {
    DWORD           cbEncryptedKey1;
    DWORD           cbEncryptedKey2;
    DWORD           cbKeyArg;
    PUCHAR          pEncryptedKey1;
    PUCHAR          pEncryptedKey2;
    PUCHAR          pKeyArg;
} Pct2_Encrypted_Key, *PPct2_Encrypted_Key;

typedef struct _Pct2_Client_Hello {
    DWORD               AuthOptions;
    DWORD               cCipherSpecs;
    DWORD               cHashSpecs;
    DWORD               cCertSpecs;
    DWORD               cExchSpecs;
    DWORD               cbKeyArg;
    DWORD               cMessageSpecs;
    DWORD               cSigSpecs;
    DWORD               cbCertifiers;
	DWORD               cbSessionID;
	DWORD               cbChallenge;
    UCHAR               SessionID[PCT2_SESSION_ID_SIZE];
	UCHAR               Challenge[PCT2_CHALLENGE_SIZE];
    PUCHAR              pKeyArg;
    CipherSpec *        pCipherSpecs;
    HashSpec *          pHashSpecs;
    CertSpec *          pCertSpecs;
    ExchSpec *          pExchSpecs;
    Pct2MsgSpec *       pMessageSpecs;
    SigSpec *           pSigSpecs;
    PUCHAR              pCertifiers;
    PPct2_Public_Value  pQuickPublicValue;
    PPct2_Public_Value  pQuickServerPublicValue;
    PPct2_Encrypted_Key pQuickEncryptedKey; 
} Pct2_Client_Hello, * PPct2_Client_Hello;


typedef struct _Pct2_Server_Hello {
    DWORD           AuthOptions;
    CipherSpec      SrvCipherSpec;
    HashSpec        SrvHashSpec;
    CertSpec        SrvCertSpec;
    ExchSpec        SrvExchSpec;
    SigSpec         SrvSigSpec;

	DWORD           cbConnectionID;
    DWORD           cbSessionID;
    UCHAR           SessionID[PCT2_SESSION_ID_SIZE];
    UCHAR           ConnectionID[PCT2_SESSION_ID_SIZE];

    DWORD           cAltCipherSpecs;
    DWORD           cAltHashSpecs;
    DWORD           cMessageSpecs;
    DWORD           cExchSpecs;
    DWORD           cCertSpecs;
    DWORD           cbCertifiers;

    DWORD           cbSigCert;
    DWORD           cbResponse;

    CipherSpec *        pAltCipherSpecs;
    HashSpec *          pAltHashSpecs;
    Pct2MsgSpec *       pMessageSpecs;
    ExchSpec *          pExchSpecs;
    CertSpec *          pCertSpecs;
    PPct2_Encrypted_Key pQuickEncryptedKey; 
    PUCHAR              pResponse;

    PUCHAR              pCertifiers;
    PPct2_Public_Value  pPublicValue;
    PUCHAR              pSigCert;

    /* temporary data used in building server hello */
    PUCHAR          pCurUnpack;
    DWORD           UnpackState;
    DWORD           SubState;
} Pct2_Server_Hello, * PPct2_Server_Hello;
#define SH_UNPACK_CERTIFIERS   0
#define SH_UNPACK_PUBLIC_VALUE 1
#define SH_UNPACK_SIGCERT      2

typedef struct _Pct2_Client_Master_Key {
    DWORD           cbResponse;
    DWORD           cbSigCert;
    PPct2_Encrypted_Key pEncryptedKey; 
    PUCHAR          pResponse;
    PPct2_Public_Value  pPublicValue;
    PUCHAR          pSigCert;

    /* Helper members for unpacking */
    PUCHAR          pCurUnpack;
    DWORD           UnpackState;
    DWORD           SubState;
} Pct2_Client_Master_Key, * PPct2_Client_Master_Key;
#define CMK_UNPACK_PUBLIC_VALUE 0
#define CMK_UNPACK_SIGCERT      1

typedef struct _Pct2_Server_Verify {
    DWORD           cbResponse;
    DWORD           cbSigCert;
    PPct2_Encrypted_Key pEncryptedKey; 
    PUCHAR          pResponse;
    PUCHAR          pSigCert;

    /* Helper members for unpacking */
    PUCHAR          pCurUnpack;
    DWORD           SubState;
} Pct2_Server_Verify, * PPct2_Server_Verify;

typedef struct _Pct2_Client_Verify {
    DWORD           cbResponse;
    DWORD           cbSigCert;
    PUCHAR          pResponse;
    PUCHAR          pSigCert;
    /* Helper members for unpacking */
    PUCHAR          pCurUnpack;
    DWORD           SubState;
} Pct2_Client_Verify, * PPct2_Client_Verify;

/*
 *
 * Pickling Prototypes
 *
 */

SP_STATUS
Pct2PackClientHello(
    PPct2_Client_Hello       pCanonical,
    PSPBuffer          pCommOutput);

SP_STATUS
Pct2UnpackClientHello(
    PSPBuffer                pInput,
    PPct2_Client_Hello *     ppClient);

SP_STATUS
Pct2PackServerHello(
    PPct2_Server_Hello       pCanonical,
    PSPBuffer                pCommOutput);

SP_STATUS
Pct2UnpackServerHello(
    PSPBuffer                pInput,
    PPct2_Server_Hello *     ppServer);

SP_STATUS
Pct2PackClientMasterKey(
    PPct2_Client_Master_Key pCanonical,
    PSPBuffer               pCommOutput);

SP_STATUS
Pct2UnpackClientMasterKey(
    PSPBuffer                    pInput,
    PPct2_Client_Master_Key *    ppClient);

SP_STATUS
Pct2PackServerVerify(
    PPct2_Server_Verify    pCanonical,
    PSPBuffer              pCommOutput);

SP_STATUS
Pct2UnpackServerVerify(
    PSPBuffer                    pInput,
    PPct2_Server_Verify *        ppServer);

SP_STATUS
Pct2PackClientVerify(
    PPct2_Client_Verify    pCanonical,
    PSPBuffer              pCommOutput);

SP_STATUS
Pct2UnpackClientVerify(
    PSPBuffer                    pInput,
    PPct2_Client_Verify *        ppClient);



#endif /* __PCT1MSG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\pctsp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       sslsp.h
//
//  Contents:   Public Definitions for SSL Security Provider
//
//  Classes:
//
//  Functions:
//
//  History:    8-04-95   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __PCTSP_H__
#define __PCTSP_H__




#define PCTSP_NAME_A    "Microsoft PCT"
#define PCTSP_NAME_W    L"Microsoft PCT"

#ifdef UNICODE
#define PCTSP_NAME  PCTSP_NAME_W
#else
#define PCTSP_NAME  PCTSP_NAME_A
#endif

#define PCTSP_RPC_ID    13


typedef struct _PCT_CREDENTIAL_CERTIFICATE {
    DWORD   cbPrivateKey;
    PBYTE   pPrivateKey;
    DWORD   cbCertificate;
    PBYTE   pCertificate;
    PCHAR   pszPassword;
} PCT_CREDENTIAL_CERTIFICATE, * PPCT_CREDENTIAL_CERTIFICATE;






#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\protocol.h ===
#ifndef _PROTOCOL_H_
#define _PROTOCOL_H_

extern CipherSpec PctCipherRank[];
extern DWORD CipherRanks;

extern HashSpec PctHashRank[];
extern DWORD HashRanks;

extern CertSpec PctCertRank[];
extern DWORD CertRanks;


extern SigSpec PctSigRank[];
extern DWORD SigRanks;

extern ExchSpec PctExchRank[];
extern DWORD ExchRanks;

typedef struct _SPContext SPContext, *PSPContext;


typedef struct _UNICipherMap {
    DWORD             CipherKind;
    DWORD             fProt;
	HashSpec          Hash;
	CipherSpec        Cipher;
	ExchSpec          KeyExch;
} UNICipherMap, *PUNICipherMap;



SP_STATUS WINAPI
ServerProtocolHandler(PSPContext pContext,
    PSPBuffer  pCommInput,
    PSPBuffer  pCommOutput,
    PSPBuffer  pAppOutput);

SP_STATUS WINAPI
ClientProtocolHandler(PSPContext pContext,
    PSPBuffer  pCommInput,
    PSPBuffer  pCommOutput,
    PSPBuffer  pAppOutput);

SP_STATUS WINAPI
GenerateHello(
    PSPContext              pContext,
    PSPBuffer               pOutput,
    BOOL                    fCache);

SP_STATUS WINAPI
GenerateUniHello(
    PSPContext             pContext,
    PSPBuffer               pOutput,
    DWORD                   fProtocol
    );


// ProtEnabled is what is enabled for the current
extern DWORD g_ProtEnabled;
extern DWORD g_ProtSupported;

typedef SP_STATUS ( WINAPI * SPInitiateHelloFn)(
                    PSPContext             pContext,
                    PSPBuffer              pOutput,
                    BOOL                   fCache);

typedef SP_STATUS ( WINAPI * SPProtocolHandlerFn)(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput,
                              PSPBuffer  pAppOutput);

typedef SP_STATUS ( WINAPI * SPDecryptHandlerFn)(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pAppOutput);


typedef SP_STATUS ( WINAPI * SPDecryptMessageFn)(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pAppOutput);

typedef SP_STATUS ( WINAPI * SPEncryptMessageFn)(PSPContext pContext,
                             PSPBuffer  pAppInput,
                             PSPBuffer  pCommOutput);


/* State machine states */

#define SP_STATE_NONE                   0x00
#define PCT1_STATE_CLIENT_HELLO		    0x01
#define PCT1_STATE_SERVER_HELLO		    0x02
#define PCT1_STATE_CLIENT_MASTER_KEY	0x03
#define PCT1_STATE_SERVER_VERIFY		0x04
#define PCT1_STATE_ERROR				0x05
#define PCT1_STATE_RENEGOTIATE          0x06

#define SSL2_STATE_CLIENT_HELLO			0x11
#define SSL2_STATE_SERVER_HELLO			0x12
#define SSL2_STATE_CLIENT_MASTER_KEY	0x13
#define SSL2_STATE_CLIENT_FINISH		0x14
#define SSL2_STATE_SERVER_VERIFY  		0x15
#define SSL2_STATE_SERVER_FINISH  		0x16
#define SSL2_STATE_REQUEST_CERTIFICATE  0x17
#define SSL2_STATE_CLIENT_CERTIFICATE	0x18
#define SSL2_STATE_SERVER_RESTART       0x19
#define SSL2_STATE_CLIENT_RESTART       0x1a
#define SSL3_STATE_CLIENT_HELLO         0x1b
#define SSL3_STATE_CHANGE_CIPHER_SPEC   0x1c
#define SSL3_STATE_RESTART_CCS          0x1d
#define SSL3_STATE_RESTART_SERVER_FINISH 0x1e
#define SSL3_STATE_SERVER_FINISH		0x1f
#define SSL3_STATE_HELLO_REQUEST        0x20
#define UNI_STATE_RECVD_UNIHELLO        0xfe
#define UNI_STATE_CLIENT_HELLO			0xff
#define SSL3_STATE_CLIENT_FINISH		0x21
#define SSL3_STATE_RESTART_CLI_FINISH   0x22
#define SSL3_STATE_REDO					0x23  //Temp...
#define SSL3_STATE_REDO_RESTART         0x24



#define SP_STATE_CONNECTED      0x0000ffff  /* We are connected, and are
                                             * expecting data packets, otherwise
                                             * we are performing a protocol
                                             * negotiation lower word contains
                                             * last message sent, implying what
                                             * the next word will be */


// UNIHELLO codes.

#define PCT_SSL_COMPAT                  0x8f
#define PCT_SSL_CERT_TYPE               0x80
#define PCT_SSL_HASH_TYPE               0x81
#define PCT_SSL_EXCH_TYPE               0x82
#define PCT_SSL_CIPHER_TYPE_1ST_HALF    0x83
#define PCT_SSL_CIPHER_TYPE_2ND_HALF    0x84

#define UNI_CK_PCT  SSL_MKFAST(PCT_SSL_COMPAT, MSBOF(PCT_VERSION_1), LSBOF(PCT_VERSION_1))
#define PCT_SSL_CERT_X509  SSL_MKFAST(0x80, 0x00, 0x00)
#define PCT_SSL_CERT_PKCS7 SSL_MKFAST(0x80, 0x00, 0x01)

#endif /* _PROTOCOL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\pctprot.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology 
* reference implementation, version 1.0
* 
* The Private Communication Technology reference implementation, version 1.0 
* ("PCTRef"), is being provided by Microsoft to encourage the development and 
* enhancement of an open standard for secure general-purpose business and 
* personal communications on open networks.  Microsoft is distributing PCTRef 
* at no charge irrespective of whether you use PCTRef for non-commercial or 
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without 
* warranty of any kind, either express or implied, including, without 
* limitation, the implied warranties or merchantability, fitness for a 
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out 
* of use or performance of PCTRef remains with you.
* 
* Please see the file LICENSE.txt, 
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
* 
* Please see http://pct.microsoft.com/pct/pct.htm for The Private 
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/ 


/* TBD: add redo capability? */

#include <spbase.h>
#include <pct1msg.h>
#include <pct1prot.h>
#include <ssl2msg.h>
#include <ssl2prot.h>


CipherSpec PctCipherRank[] = {
#ifndef SCHANNEL_EXPORT
    PCT_CIPHER_RC4 | PCT_ENC_BITS_128 | PCT_MAC_BITS_128,
#endif 
    PCT_CIPHER_RC4 | PCT_ENC_BITS_40  | PCT_MAC_BITS_128
};

DWORD CipherRanks = sizeof(PctCipherRank)/sizeof(CipherSpec);

/* available hashes, in order of preference */
HashSpec PctHashRank[] = {
    PCT_HASH_MD5
};
DWORD HashRanks = sizeof(PctHashRank)/sizeof(HashSpec);

CertSpec PctCertRank[] = {
    PCT_CERT_X509
};
DWORD CertRanks = sizeof(PctCertRank)/sizeof(CertSpec);


SigSpec PctSigRank[] = {
    PCT_SIG_RSA_MD5,
};
DWORD SigRanks = sizeof(PctSigRank)/sizeof(SigSpec);


ExchSpec PctExchRank[] = {
   PCT_EXCH_RSA_PKCS1
};

DWORD ExchRanks = sizeof(PctExchRank)/sizeof(ExchSpec);



/*****************************************************************************
* 
* Main Protocol Handler
*   This procedure handles the state transitions of the protocol.
*
*
* Inputs -
*         PPctContext pContext   - Current Pct Context
*         PSPBuffer  pCommInput - Input Record from Communication Channel
*         PSPBuffer  pAppInput  - Input from the Application 
*
*
* Outputs -
*         pCommOutput - Pending Output to be sent over the communications channel.
*         pAppOutput  - Data for the app, unpacked. 
*
* Returns - status code
*
* NOTE:  The data streams to and from the protocol handler should work like 
*        this.
*                           _________________
*  Communications -------> | Protocol Handler| ----> Cleartext data to
*  Channel        <------- |_________________| <---- and from the Application
*
*  The surrounding environment should always transmit data in the CommOutput
*  if the count of bytes is greater than zero.  
*  CommInput should contain an input buffer with a count of bytes.  If the
*  data is successfully packaged, then the count of bytes in CommInput will
*  be set to zero.  If the data was not packaged, either due to protocol 
*  messages taking precedence, or due to an error, then the count of bytes
*  will not be changed.  The buffer should then be re-presented to the 
*  handler during the next pass.
*
*****************************************************************************/
SP_STATUS WINAPI PctProtocolHandler(PPctContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput,
                              PSPBuffer  pAppOutput)
{
    SP_STATUS      pctRet= 0;
    DWORD           dwStateTransition;
	BOOL           fRaw = TRUE;
    SPBuffer       MsgInput;

    if(pCommOutput) pCommOutput->cbData = 0;
    if(pAppOutput) pAppOutput->cbData = 0;
    /* Protocol handling steps should be listed in most common
     * to least common in order to improve performance 
     */
    MsgInput.pvBuffer = pCommInput->pvBuffer;
    MsgInput.cbBuffer = pCommInput->cbBuffer;
    MsgInput.cbData = pCommInput->cbData;

	/* in the following states, we should decrypt the message */
	switch(pContext->State) {  
        /* pct has no encrypted protocol messages */
    }
    /* first deal with incoming messages over the comm port, these
     * will protocol related, and take precedence over App messages
     */


    /* We are not connected, so we're doing
     * protocol negotiation of some sort.  All protocol
     * negotiation messages are sent in the clear */
    /* There are no branches in the connecting protocol
     * state transition diagram, besides connection and error,
     * which means that a simple case statement will do */

    /* Do we have enough data to determine what kind of message we have */
    if(MsgInput.cbData < 3) {
        pctRet = Pct1GenerateError(pContext, 
                                  pCommOutput, 
                                  PCT_ERR_ILLEGAL_MESSAGE, 
                                  NULL);

    }

    if((PCT_ERR_OK == pctRet) && (MsgInput.cbData > 3)) {        

	    /* build a single dword out of the last state and the incoming message
	     * to do a case off of */
        if(fRaw) {
            dwStateTransition = (((PUCHAR)MsgInput.pvBuffer)[2]<<16) |
                                  (pContext->State & 0xffff);
        } else {
            dwStateTransition = (((PUCHAR)MsgInput.pvBuffer)[0]<<16) |
                                  (pContext->State & 0xffff);
        }
        switch(dwStateTransition)
        {

#ifndef PCT_CLIENT_ONLY
            /* Server receives client hello */
            case (PCT_MSG_CLIENT_HELLO << 16) | SP_STATE_NONE:
                {
                    PPct1_Client_Hello pPct1Hello;
                    UCHAR fRealSessId = 0;
                    SessCacheItem   CachedSession;
                    int i;

                    /* Attempt to recognize and handle various versions
                     * of client hello, start by trying to unpickle the
                     * most recent version, and then next most recent, until
                     * one unpickles.  Then run the handle code.  We can also put
                     * unpickling and handling code in here for SSL messages */
                    if(PCT_ERR_OK == (pctRet = Pct1UnpackClientHello(
                                                &MsgInput,
                                                &pPct1Hello))) {

                        pContext->Protocol = CACHE_PROTOCOL_PCT1;
                        for(i=0;i<(int)pPct1Hello->cbSessionID;i++) 
                            fRealSessId |= pPct1Hello->SessionID[i];


                        if ((fRealSessId) &&
                            (PctFindSessIdInCache(CACHE_PROTOCOL_PCT1, 
                                                  pPct1Hello->SessionID, 
                                                  pPct1Hello->cbSessionID, 
                                                  &CachedSession))) {
                            pctRet = Pct1SrvRestart(pContext, 
                                                   pPct1Hello, 
                                                   pCommOutput, 
                                                   &CachedSession);
                            if(PCT_ERR_OK == pctRet) {
                                pContext->State = SP_STATE_CONNECTED;
								pContext->Encrypt = Pct1EncryptMessage;
								pContext->Decrypt = Pct1DecryptMessage;
                            } 
                       	}  else {

                            pctRet = Pct1SrvHandleClientHello(pContext,
                                                     &MsgInput,
                                                     pPct1Hello,
                                                     pCommOutput);
                            if(PCT_ERR_OK == pctRet) {
                                pContext->State = PCT1_STATE_SERVER_HELLO;
                            } 

                        }
                        SPExternalFree(pPct1Hello);

                    } 
                    if(SP_FATAL(pctRet)) {
                        pContext->State = PCT1_STATE_ERROR;
                    } 
                    break;
                }
            case (PCT_MSG_CLIENT_MASTER_KEY << 16) | PCT1_STATE_SERVER_HELLO:
                pctRet = Pct1SrvHandleCMKey(pContext,
                                                 &MsgInput,
                                                 pCommOutput);
                if(SP_FATAL(pctRet)) {
                    pContext->State = PCT1_STATE_ERROR;
                } else {
                    if(PCT_ERR_OK == pctRet) {
                        pContext->State = SP_STATE_CONNECTED;
						pContext->Encrypt = Pct1EncryptMessage;
						pContext->Decrypt = Pct1DecryptMessage;
                    } 
                    /* We received a non-fatal error, so the state doesn't
                     * change, giving the app time to deal with this */
                }
                break;

#endif /* PCT_CLIENT_ONLY */
#ifndef PCT_SERVER_ONLY
            /* Client receives Server hello */
            case (PCT_MSG_SERVER_HELLO << 16) | PCT1_STATE_CLIENT_HELLO:
                {
                    PPct1_Server_Hello pHello;
                    /* Attempt to recognize and handle various versions
                     * of Server hello, start by trying to unpickle the
                     * oldest, and the next version, until
                     * one unpickles.  Then run the handle code.  We can also put
                     * unpickling and handling code in here for SSL messages */
                    if(PCT_ERR_OK == (pctRet = Pct1UnpackServerHello(
                                                &MsgInput,
                                                &pHello))) {
                        pContext->Protocol = CACHE_PROTOCOL_PCT1;
                        /* let's resurrect the zombie session */
                        if (pHello->RestartOk) {
                            pctRet = Pct1CliRestart(pContext, pHello, pCommOutput);
                            if(PCT_ERR_OK == pctRet) {
                                pContext->State = SP_STATE_CONNECTED;
								pContext->Encrypt = Pct1EncryptMessage;
								pContext->Decrypt = Pct1DecryptMessage;
                            } 
                        } else {   
                            pctRet = Pct1CliHandleServerHello(pContext,
                                                         &MsgInput,
                                                         pHello,
                                                         pCommOutput);
                            if(PCT_ERR_OK == pctRet) {
                                pContext->State = PCT1_STATE_CLIENT_MASTER_KEY;
                            } 

                        }
                        SPExternalFree(pHello);

                    }
                    if(SP_FATAL(pctRet)) {
                        pContext->State = PCT1_STATE_ERROR;
                    }
                  
                    break;
                }

            case (PCT_MSG_SERVER_VERIFY << 16) | PCT1_STATE_CLIENT_MASTER_KEY:
                pctRet = Pct1CliHandleServerVerify(pContext,
                                                 &MsgInput,
                                                 pCommOutput);
                if(SP_FATAL(pctRet)) {
                    pContext->State = PCT1_STATE_ERROR;
                } else {
                    if(PCT_ERR_OK == pctRet) {
                        pContext->State = SP_STATE_CONNECTED;
						pContext->Encrypt = Pct1EncryptMessage;
						pContext->Decrypt = Pct1DecryptMessage;
                    } 
                    /* We received a non-fatal error, so the state doesn't
                     * change, giving the app time to deal with this */
                }
                break;
#endif /* PCT_SERVER_ONLY */

            default:
                pContext->State = PCT1_STATE_ERROR;
                {
                    if(((PUCHAR)MsgInput.pvBuffer)[2] == PCT_MSG_ERROR) {
                        /* we received an error message, process it */
                        pctRet = Pct1HandleError(pContext,
                                                 &MsgInput,
                                                 pCommOutput);

                    } else {
                        /* we received an unknown error, generate a 
                         * PCT_ERR_ILLEGAL_MESSAGE */
                        pctRet = Pct1GenerateError(pContext, 
                                                  pCommOutput, 
                                                  PCT_ERR_ILLEGAL_MESSAGE, 
                                                  NULL);
                    }
                }

        }

    }
     if(pctRet & PCT_INT_DROP_CONNECTION) {
        pContext->State &= ~SP_STATE_CONNECTED;
     }
    return pctRet;
}

SP_STATUS WINAPI PctDecryptHandler(PPctContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pAppOutput)
{
    SP_STATUS      pctRet= 0;
    if(pCommInput->cbData > 0) {        
        /* first, we'll handle incoming data packets */
        if((pContext->State & SP_STATE_CONNECTED) && (pContext->Decrypt)) {
            if(PCT_ERR_OK == 
               (pctRet = pContext->Decrypt(pContext, 
                                           pCommInput,   /* message */ 
                                           pAppOutput /* Unpacked Message */
                                ))) {  
                /* look for escapes */
                if((*(PUCHAR)pCommInput->pvBuffer) & 0x40 == 0xc0) {
                    switch(*(PUCHAR)pAppOutput->pvBuffer) {
                        case PCT_ET_REDO_CONN:
                            /* InitiateRedo */
                        case PCT_ET_OOB_DATA:
                            /* HandleOOB */
                        default:
                            /* Unknown escape, generate error */
                            pctRet = PCT_INT_ILLEGAL_MSG;
                            /* Disconnect */
                            break;
                    }

                }
            }

        } else {
			return PCT_INT_ILLEGAL_MSG;
		}
	}
}




SP_STATUS Pct1GenerateError(PPctContext pContext,
                              PSPBuffer  pCommOutput,
                              SP_STATUS  pError,
                              PSPBuffer  pErrData)
{
    Pct1Error            XmitError;
    
    /* Only pack up an error if we are allowed to return errors */
    if(!(pContext->Flags & CONTEXT_FLAG_EXT_ERR)) return pError;

    XmitError.Error = pError;
    XmitError.ErrInfoLen = 0;
    XmitError.ErrInfo = NULL;

    if(pErrData) {
        XmitError.ErrInfoLen = pErrData->cbData;
        XmitError.ErrInfo = pErrData->pvBuffer;
    }
    Pct1PackError(&XmitError,
                 pCommOutput);
    return pError;
}

/* session key computation */


SP_STATUS Pct1HandleError(PPctContext pContext,
                          PSPBuffer  pCommInput,
                          PSPBuffer  pCommOutput)
{
    pCommOutput->cbData = 0;
    return(((PPCT1_ERROR)pCommInput->pvBuffer)->ErrorMsb << 8 )|  ((PPCT1_ERROR)pCommInput->pvBuffer)->ErrorLsb;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\sha.h ===
/* Copyright (C) RSA Data Security, Inc. created 1993.  This is an
   unpublished work protected as such under copyright law.  This work
   contains proprietary, confidential, and trade secret information of
   RSA Data Security, Inc.  Use, disclosure or reproduction without the
   express written authorization of RSA Data Security, Inc. is
   prohibited.
 */

#ifndef _SHA_H_
#define _SHA_H_ 1

#ifdef __cplusplus
extern "C" {
#endif

#include "shacomm.h"

typedef struct {
	DWORD		FinishFlag;
	BYTE		HashVal[A_SHA_DIGEST_LEN];
	A_SHA_COMM_CTX	commonContext;
} A_SHA_CTX;

void A_SHAInit(A_SHA_CTX *);
void A_SHAUpdate(A_SHA_CTX *, unsigned char *, unsigned int);
void A_SHAFinal(A_SHA_CTX *, unsigned char [A_SHA_DIGEST_LEN]);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\scrypt.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       scrypt.h
//
//  Contents:
//
//	Definition of public key and other defines for selective financial
//	application crypto.
//
//  Classes:
//
//  Functions:
//
//  History:    5-12-96
//
//----------------------------------------------------------------------------

#ifdef ENABLE_SELECTIVE_CRYPTO

#ifndef __SCCRYPT_H__
#define __SCCRYPT_H__

#define MAX_PATH_LEN		256
#define MAX_CERT_LEN		256

#define SC_REG_KEY_BASE		TEXT("System\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\ApprovedApps")

#define CF_SC_ENABLED		1

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\protos.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/



SP_STATUS
LoadCAKeys(VOID);

VOID PCTGenRandom(
    PVOID       Reserved,
    DWORD       cbRandom,
    PBYTE       pbRandom);

BOOL InitializeCACache(HINSTANCE hInstance);
BOOL ShutdownCACache();


PPctCertificate
FindIssuerKey(PSTR    pszIssuer);

BOOL GetDefaultIssuers(
    PBYTE pbIssuers,
    DWORD *pcbIssuers);

BOOL GenerateKeyPair(
    PSSL_CREDENTIAL_CERTIFICATE pCert,
    PSTR pszDN,
    PSTR pszPassword,
    DWORD Bits );

BOOL LoadCertificate(
    PUCHAR      pbCertificate,
    DWORD       cbCertificate,
    BOOL        AddToWellKnownKeys);

SP_STATUS
SPEnableFinanceCipher(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\pct2pckl.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/


#include <spbase.h>
#include <pct2msg.h>

#define PCT_OFFSET_OF(t, v) (DWORD)&(((t)NULL)->v)


#define SIZEOF(pHeader)    COMBINEBYTES(((PPCT2_HS_MESSAGE_HEADER) pHeader)->RecHeader.LengthMSB, ((PPCT2_HS_MESSAGE_HEADER) pHeader)->RecHeader.LengthLSB)

DWORD MapCipherToExternal(CipherSpec Internal, ExtCipherSpec *External)
{
    *External = htonl(Internal);
    return TRUE;
}

DWORD MapHashToExternal(HashSpec Internal, ExtHashSpec *External)
{
    *External = htons((ExtHashSpec)Internal);
    return TRUE;
}

DWORD MapCertToExternal(CertSpec Internal, ExtCertSpec *External)
{
    *External = htons((ExtCertSpec)Internal);
    return TRUE;
}

DWORD MapExchToExternal(ExchSpec Internal, ExtExchSpec *External)
{
    *External = htons((ExtExchSpec)Internal);
    return TRUE;
}

DWORD MapMsgToExternal(Pct2MsgSpec Internal, ExtMsgSpec *External)
{
    *External = htons((ExtMsgSpec)Internal);
    return TRUE;
}

DWORD MapSigToExternal(SigSpec Internal, ExtSigSpec *External)
{
    *External = htons((ExtSigSpec)Internal);
    return TRUE;
}

CipherSpec MapCipherFromExternal(ExtCipherSpec External)
{
    return (CipherSpec)ntohl(External);
}

HashSpec MapHashFromExternal(ExtHashSpec External)
{
    return (HashSpec)ntohs(External);
}

CertSpec MapCertFromExternal(ExtCertSpec External)
{
    return (CertSpec)ntohs(External);
}

ExchSpec MapExchFromExternal(ExtExchSpec External)
{
    return (ExchSpec)ntohs(External);
}
Pct2MsgSpec MapMsgFromExternal(ExtMsgSpec External)
{
    return (Pct2MsgSpec)ntohs(External);
}

SigSpec MapSigFromExternal(ExtSigSpec External)
{
    return (SigSpec)ntohs(External);
}

#define CALC_PUBLIC_VALUE_SIZE(v)   (v)->cbUserInfo +   \
                               (v)->cbParameter1 +  \
                               (v)->cbParameter2 +  \
                                PCT_OFFSET_OF(PPCT2_PUBLIC_VALUE, VariantData)

#define CALC_ENCRYPTED_KEY_SIZE(k)  (k)->cbEncryptedKey1 +     \
                               (k)->cbEncryptedKey2 +      \
                               (k)->cbKeyArg +              \
                               PCT_OFFSET_OF(PPCT2_ENCRYPTED_KEY, VariantData)


#define CALC_CANONICAL_PUBLIC_VALUE_SIZE(s) s - PCT_OFFSET_OF(PPCT2_PUBLIC_VALUE, VariantData) + sizeof(Pct2_Public_Value)

#define CALC_CANONICAL_ENCRYPTED_KEY_SIZE(s) s - PCT_OFFSET_OF(PPCT2_ENCRYPTED_KEY, VariantData) + sizeof(Pct2_Encrypted_Key)

/* Helper to pack a PublicValue */
DWORD
Pct2PackPublicValue(
    PPct2_Public_Value   pCanonical,
    PUCHAR               pOut)
{
     PPCT2_PUBLIC_VALUE   pValue = (PPCT2_PUBLIC_VALUE)pOut;
     PUCHAR pBuffer = pValue->VariantData;
     pValue->ValueTypeMsb = MSBOF(pCanonical->ValueType);
     pValue->ValueTypeLsb = LSBOF(pCanonical->ValueType);
     pValue->UserSpecInfoLenMsb = MSBOF(pCanonical->cbUserInfo);
     pValue->UserSpecInfoLenLsb = LSBOF(pCanonical->cbUserInfo);
     pValue->Parameter1LenMsb = MSBOF(pCanonical->cbParameter1);
     pValue->Parameter1LenLsb = LSBOF(pCanonical->cbParameter1);
     pValue->Parameter2LenMsb = MSBOF(pCanonical->cbParameter2);
     pValue->Parameter2LenLsb = LSBOF(pCanonical->cbParameter2);
     CopyMemory(pBuffer, pCanonical->pUserInfo, pCanonical->cbUserInfo);
     pBuffer +=  pCanonical->cbUserInfo;

     CopyMemory(pBuffer, pCanonical->pUserInfo, pCanonical->cbParameter1);
     pBuffer +=  pCanonical->cbParameter1;

     CopyMemory(pBuffer, pCanonical->pUserInfo, pCanonical->cbParameter2);
     return CALC_PUBLIC_VALUE_SIZE(pCanonical);


}

DWORD
Pct2UnpackPublicValue(
    PUCHAR pIn,
    PPct2_Public_Value pCanonical)
{
    PPCT2_PUBLIC_VALUE   pValue = (PPCT2_PUBLIC_VALUE)pIn;
    pCanonical->ValueType = COMBINEBYTES(pValue->ValueTypeMsb, pValue->ValueTypeLsb);
    pCanonical->cbUserInfo = COMBINEBYTES(pValue->UserSpecInfoLenMsb, pValue->UserSpecInfoLenLsb);
    pCanonical->cbParameter1 = COMBINEBYTES(pValue->Parameter1LenMsb, pValue->Parameter1LenLsb);
    pCanonical->cbParameter2 = COMBINEBYTES(pValue->Parameter2LenMsb, pValue->Parameter2LenLsb);

    CopyMemory((PUCHAR)pCanonical+1, pValue->VariantData, pCanonical->cbUserInfo +
                                                          pCanonical->cbParameter1 +
                                                          pCanonical->cbParameter2);
    pCanonical->pUserInfo = (PUCHAR)(pCanonical+1);
    pCanonical->pParameter1 = pCanonical->pUserInfo + pCanonical->cbUserInfo;
    pCanonical->pParameter2 = pCanonical->pParameter1 + pCanonical->cbParameter1;

    return sizeof(Pct2_Public_Value) +
           pCanonical->cbUserInfo +
           pCanonical->cbParameter1 +
           pCanonical->cbParameter2;


}

/* Helper to pack a Encrypted_Key */
DWORD
Pct2PackEncryptedKey(
    PPct2_Encrypted_Key  pCanonical,
    PUCHAR               pOut)
{
     PPCT2_ENCRYPTED_KEY   pValue = (PPCT2_ENCRYPTED_KEY)pOut;
     PUCHAR pBuffer = pValue->VariantData;
     pValue->EncryptedKey1LenMsb = MSBOF(pCanonical->cbEncryptedKey1);
     pValue->EncryptedKey1LenLsb = LSBOF(pCanonical->cbEncryptedKey1);
     pValue->EncryptedKey2LenMsb = MSBOF(pCanonical->cbEncryptedKey2);
     pValue->EncryptedKey2LenLsb = LSBOF(pCanonical->cbEncryptedKey2);

     pValue->KeyArgLenMsb = MSBOF(pCanonical->cbKeyArg);
     pValue->KeyArgLenLsb = LSBOF(pCanonical->cbKeyArg);
     CopyMemory(pBuffer, pCanonical->pEncryptedKey1, pCanonical->cbEncryptedKey1);
     pBuffer +=  pCanonical->cbEncryptedKey1;

     CopyMemory(pBuffer, pCanonical->pEncryptedKey2, pCanonical->cbEncryptedKey2);
     pBuffer +=  pCanonical->cbEncryptedKey2;

     CopyMemory(pBuffer, pCanonical->pKeyArg, pCanonical->cbKeyArg);
     return CALC_ENCRYPTED_KEY_SIZE(pCanonical);

}

DWORD
Pct2UnpackEncryptedKey(
    PUCHAR pIn,
    PPct2_Encrypted_Key pCanonical)
{
    PPCT2_ENCRYPTED_KEY   pKey = (PPCT2_ENCRYPTED_KEY)pIn;
    pCanonical->cbEncryptedKey1 = COMBINEBYTES(pKey->EncryptedKey1LenMsb, pKey->EncryptedKey1LenLsb);
    pCanonical->cbEncryptedKey2 = COMBINEBYTES(pKey->EncryptedKey2LenMsb, pKey->EncryptedKey2LenLsb);
    pCanonical->cbKeyArg = COMBINEBYTES(pKey->KeyArgLenMsb, pKey->KeyArgLenLsb);

    CopyMemory((PUCHAR)pCanonical+1, pKey->VariantData, pCanonical->cbEncryptedKey1 +
                                                        pCanonical->cbEncryptedKey2+
                                                        pCanonical->cbKeyArg);
    pCanonical->pEncryptedKey1 = (PUCHAR)(pCanonical+1);
    pCanonical->pEncryptedKey2 = pCanonical->pEncryptedKey1 + pCanonical->cbEncryptedKey1;
    pCanonical->pKeyArg = pCanonical->pEncryptedKey2 + pCanonical->cbEncryptedKey2;

    return sizeof(Pct2_Encrypted_Key) +
           pCanonical->cbEncryptedKey1 +
           pCanonical->cbEncryptedKey2 +
           pCanonical->cbKeyArg;

}



SP_STATUS
Pct2PackClientHello(
    PPct2_Client_Hello pCanonical,
    PSPBuffer          pCommOutput)
{
    DWORD                    cbMessage;
    PPCT2_CLIENT_HELLO       pMessage;
    PPCT2_HS_MESSAGE_HEADER  pHeader;
    DWORD               Size;
    PUCHAR              pBuffer;
    DWORD               i, iBuff;
    DWORD               cbQuickPublicValue=0;
    DWORD               cbQuickServerSize=0;
    DWORD               cbQuickEncryptedKey=0;

    if(pCanonical == NULL || pCommOutput == NULL) return PCT_INT_INTERNAL_ERROR;
    pCommOutput->cbData = 0;

    /* Now add on the Quick Value sizes, if there are any */

    if(pCanonical->pQuickPublicValue) {
        cbQuickPublicValue =   CALC_PUBLIC_VALUE_SIZE(pCanonical->pQuickPublicValue);

    }

    if(pCanonical->pQuickServerPublicValue) {
        cbQuickServerSize    = CALC_PUBLIC_VALUE_SIZE(pCanonical->pQuickServerPublicValue);

    }
    if(pCanonical->pQuickEncryptedKey) {
        cbQuickEncryptedKey  = CALC_ENCRYPTED_KEY_SIZE(pCanonical->pQuickEncryptedKey);

    }

    cbMessage = PCT_OFFSET_OF(PPCT2_CLIENT_HELLO, VariantData) +
                    pCanonical->cCipherSpecs * sizeof(ExtCipherSpec) +
                    pCanonical->cHashSpecs * sizeof(ExtHashSpec) +
                    pCanonical->cCertSpecs * sizeof(ExtCertSpec) +
                    pCanonical->cExchSpecs * sizeof(ExtExchSpec) +
                    pCanonical->cbKeyArg +
                    pCanonical->cMessageSpecs * sizeof(ExtMsgSpec) +
                    pCanonical->cSigSpecs * sizeof(ExtSigSpec) +
                    pCanonical->cbCertifiers +
                    cbQuickPublicValue +
                    cbQuickServerSize +
                    cbQuickEncryptedKey;


    if (cbMessage > PCT_MAX_SHAKE_LEN)
        return PCT_INT_DATA_OVERFLOW;

    pCommOutput->cbData = cbMessage + sizeof(PCT2_HS_MESSAGE_HEADER);
    /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL) {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
            return PCT_INT_INTERNAL_ERROR;
        pCommOutput->cbBuffer = pCommOutput->cbData;
    }

    /* We cannot divide up a client hello into multiple messages */
    if(pCommOutput->cbData > pCommOutput->cbBuffer) return PCT_INT_BUFF_TOO_SMALL;

    pHeader = (PPCT2_HS_MESSAGE_HEADER)(pCommOutput->pvBuffer);

    pMessage = (PPCT2_CLIENT_HELLO)(pHeader+1);


    CopyMemory( pMessage->SessionIdData,
                pCanonical->SessionID,
                pCanonical->cbSessionID);

    CopyMemory( pMessage->ChallengeData,
                pCanonical->Challenge,
                pCanonical->cbChallenge);

    pMessage->VersionMsb = MSBOF(PCT_VERSION_2);
    pMessage->VersionLsb = LSBOF(PCT_VERSION_2);

    pMessage->OffsetMsb = MSBOF(PCT_CH_OFFSET_V2);
    pMessage->OffsetLsb = LSBOF(PCT_CH_OFFSET_V2);

    pBuffer = pMessage->VariantData;

    /* Pack cipher specs */
    iBuff = 0;
    for (i = 0; i < pCanonical->cCipherSpecs ; i++ )
    {
        if (MapCipherToExternal(pCanonical->pCipherSpecs[i],
                                &((ExtCipherSpec *) pBuffer)[iBuff]) )
        {
            iBuff++;
        }
    }
    Size = iBuff*sizeof(ExtCipherSpec);

    pMessage->CipherSpecsLenMsb = MSBOF(Size);
    pMessage->CipherSpecsLenLsb = LSBOF(Size);
    pBuffer += Size;

    cbMessage -= (pCanonical->cCipherSpecs - iBuff)*sizeof(ExtCipherSpec);

    /* Pack Hash Specs */
    iBuff = 0;
    for (i = 0; i < pCanonical->cHashSpecs ; i++ )
    {
        if (MapHashToExternal(pCanonical->pHashSpecs[i],
                              &((ExtHashSpec *) pBuffer)[iBuff]) )
        {
            iBuff++;
        }
    }
    Size = iBuff*sizeof(ExtHashSpec);
    pBuffer += Size;

    pMessage->HashSpecsLenMsb = MSBOF(Size);
    pMessage->HashSpecsLenLsb = LSBOF(Size);
    cbMessage -= (pCanonical->cHashSpecs - iBuff)*sizeof(ExtHashSpec);

    /* pack Cert specs */
    iBuff = 0;
    for (i = 0; i < pCanonical->cCertSpecs ; i++ )
    {
        if (MapCertToExternal(pCanonical->pCertSpecs[i],
                                &((ExtCertSpec *) pBuffer)[iBuff]))
        {
            iBuff ++;
        }
    }
    Size = iBuff*sizeof(ExtCertSpec);
    pBuffer += Size;

    pMessage->CertSpecsLenMsb = MSBOF(Size);
    pMessage->CertSpecsLenLsb = LSBOF(Size);
    cbMessage -= (pCanonical->cCertSpecs - iBuff)*sizeof(ExtCertSpec);

    /* Pack Exch Specs */
    iBuff = 0;
    for (i = 0; i < pCanonical->cExchSpecs ; i++ )
    {
        if (MapExchToExternal(pCanonical->pExchSpecs[i],
                                &((ExtExchSpec *) pBuffer)[iBuff]) )
        {
            iBuff++;
        }
    }
    Size = iBuff*sizeof(ExtExchSpec);
    pBuffer += Size;

    pMessage->ExchSpecsLenMsb = MSBOF(Size);
    pMessage->ExchSpecsLenLsb = LSBOF(Size);
    cbMessage -= (pCanonical->cExchSpecs - iBuff)*sizeof(ExtExchSpec);

    CopyMemory(pBuffer, pCanonical->pKeyArg, pCanonical->cbKeyArg);
    pBuffer += pCanonical->cbKeyArg;
    /* End of PCT1 compatable data */

    /* Pack Msg Specs */
    iBuff = 0;
    for (i = 0; i < pCanonical->cMessageSpecs ; i++ )
    {
        if (MapMsgToExternal(pCanonical->pMessageSpecs[i],
                                &((ExtMsgSpec *) pBuffer)[iBuff]) )
        {
            iBuff++;
        }
    }
    Size = iBuff*sizeof(ExtMsgSpec);
    pBuffer += Size;

    pMessage->MsgListLenMsb = MSBOF(Size);
    pMessage->MsgListLenLsb = LSBOF(Size);
    cbMessage -= (pCanonical->cMessageSpecs - iBuff)*sizeof(ExtMsgSpec);

    /* Pack Sig Specs */
    iBuff = 0;
    for (i = 0; i < pCanonical->cSigSpecs ; i++ )
    {
        if (MapSigToExternal(pCanonical->pSigSpecs[i],
                                &((ExtSigSpec *) pBuffer)[iBuff]) )
        {
            iBuff++;
        }
    }
    Size = iBuff*sizeof(ExtSigSpec);
    pBuffer += Size;

    pMessage->SigListLenMsb = MSBOF(Size);
    pMessage->SigListLenLsb = LSBOF(Size);
    cbMessage -= (pCanonical->cSigSpecs - iBuff)*sizeof(ExtSigSpec);

    /* Certifier list data */
    CopyMemory(pBuffer, pCanonical->pCertifiers, pCanonical->cbCertifiers);
    pMessage->CertifierListLenMsb = MSBOF(pCanonical->cbCertifiers);
    pMessage->CertifierListLenLsb = LSBOF(pCanonical->cbCertifiers);
    pBuffer += pCanonical->cbCertifiers;

    if(pCanonical->pQuickPublicValue) {
        pBuffer += Pct2PackPublicValue(pCanonical->pQuickPublicValue, pBuffer);
    }
    pMessage->QuickPublicValueLenMsb = MSBOF(cbQuickPublicValue);
    pMessage->QuickPublicValueLenLsb = LSBOF(cbQuickPublicValue);

    if(pCanonical->pQuickServerPublicValue) {
        pBuffer += Pct2PackPublicValue(pCanonical->pQuickServerPublicValue, pBuffer);
    }
    pMessage->QuickServerPublicValueLenMsb = MSBOF(cbQuickServerSize);
    pMessage->QuickServerPublicValueLenLsb = LSBOF(cbQuickServerSize);

    if(pCanonical->pQuickEncryptedKey){
        pBuffer += Pct2PackEncryptedKey(pCanonical->pQuickEncryptedKey, pBuffer);
    }
    pMessage->QuickEncryptedKeyLenMsb = MSBOF(cbQuickEncryptedKey);
    pMessage->QuickEncryptedKeyLenLsb = LSBOF(cbQuickEncryptedKey);

    pMessage->AuthOptionsMsb = MSBOF(pCanonical->AuthOptions);
    pMessage->AuthOptionsLsb = LSBOF(pCanonical->AuthOptions);

    pCommOutput->cbData = cbMessage + sizeof(PCT2_HS_MESSAGE_HEADER);

    pHeader->RecHeader.LengthMSB = MSBOF(cbMessage) | 0x80;
    pHeader->RecHeader.LengthLSB = LSBOF(cbMessage);
    pHeader->RecHeader.TypeMSB = MSBOF(PCT2_RT_HANDSHAKE);
    pHeader->RecHeader.TypeLSB = MSBOF(PCT2_RT_HANDSHAKE);
    pHeader->MessageTypeMsb = MSBOF(PCT2_HS_CLIENT_HELLO);
    pHeader->MessageTypeMsb = LSBOF(PCT2_HS_CLIENT_HELLO);
    pHeader->RecordFlagsMsb = 0; /* we can't break up message in CH */
    pHeader->RecordFlagsLsb = 0; /* we can't break up message in CH */

    return(PCT_ERR_OK);
}

SP_STATUS
Pct2UnpackClientHello(
    PSPBuffer          pInput,
    PPct2_Client_Hello *     ppClient)
{

    PPCT2_HS_MESSAGE_HEADER  pHeader;
    PPCT2_CLIENT_HELLO   pMessage;

    DWORD               ReportedSize;
    DWORD               CipherSpecsSize, HashSpecsSize, CertSpecsSize;
    DWORD               ExchSpecsSize, MsgSpecsSize, SigSpecsSize;
    DWORD               cbCertifierList, cbQuickPub, cbQuickServerPub;
    DWORD               cbQuickEncryptedKey;

    DWORD               cCipherSpecs, cHashSpecs, cCertSpecs, cExchSpecs,
                        cMsgSpecs, cSigSpecs;

    DWORD               cbKeyArg;
    DWORD               cOffsetBytes;
    PPct2_Client_Hello  pCanonical;
    PUCHAR              pBuffer, pCurUnpack;
    DWORD               i;
    DWORD               cbCanonical;

    pHeader = pInput->pvBuffer;

    if(pInput->cbBuffer < sizeof(PCT2_HS_MESSAGE_HEADER)) {
        return PCT_INT_INCOMPLETE_MSG;
    }

    /*******
     * NOTE: For the client hello only, we are guaranteed that the
     * complete message will come as one record
     *******/
    ReportedSize = SIZEOF(pHeader);

    if ((ReportedSize+sizeof(PCT2_HS_MESSAGE_HEADER)) > pInput->cbBuffer)
    {
        return PCT_INT_INCOMPLETE_MSG;
    }

    if(ReportedSize < PCT_OFFSET_OF(PPCT2_CLIENT_HELLO, VariantData))
    {
        return PCT_ERR_ILLEGAL_MESSAGE;
    }
    /* Now start validating the message */
    pMessage = (PPCT2_CLIENT_HELLO)(pHeader+1);

    if(COMBINEBYTES(pHeader->MessageTypeMsb, pHeader->MessageTypeLsb) !=
       PCT2_HS_CLIENT_HELLO)
    {
        return PCT_ERR_ILLEGAL_MESSAGE;
    }
    /* Client hello messages can't be chopped */
    if(COMBINEBYTES(pHeader->RecordFlagsMsb, pHeader->RecordFlagsLsb) &
       ( PCT2_HS_FLAG_TO_BE_CONTD | PCT2_HS_FLAG_CONTINUATION))
    {
        return PCT_ERR_ILLEGAL_MESSAGE;
    }


    /* We don't recognize hello messages of less version than ourselves,
     * those will be handled by a previous version of the code */
    if(COMBINEBYTES(pMessage->VersionMsb, pMessage->VersionLsb) < PCT_VERSION_2)
    {
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

    cOffsetBytes = COMBINEBYTES( pMessage->OffsetMsb,
                                  pMessage->OffsetLsb );

    if(cOffsetBytes < PCT_CH_OFFSET_V2)  {
        return(PCT_ERR_ILLEGAL_MESSAGE);
    }

    *ppClient = NULL;

    CipherSpecsSize = COMBINEBYTES( pMessage->CipherSpecsLenMsb,
                                    pMessage->CipherSpecsLenLsb );

    HashSpecsSize = COMBINEBYTES( pMessage->HashSpecsLenMsb,
                                  pMessage->HashSpecsLenLsb );

    CertSpecsSize = COMBINEBYTES( pMessage->CertSpecsLenMsb,
                                  pMessage->CertSpecsLenLsb );

    ExchSpecsSize = COMBINEBYTES( pMessage->ExchSpecsLenMsb,
                                  pMessage->ExchSpecsLenLsb );

    MsgSpecsSize =  COMBINEBYTES( pMessage->MsgListLenMsb,
                                  pMessage->MsgListLenLsb );

    SigSpecsSize =  COMBINEBYTES( pMessage->SigListLenMsb,
                                  pMessage->SigListLenLsb );

    cbKeyArg     =  COMBINEBYTES( pMessage->KeyArgLenMsb,
                                  pMessage->KeyArgLenLsb );


    cbCertifierList = COMBINEBYTES(pMessage->CertifierListLenMsb,
                                   pMessage->CertifierListLenLsb);

    cbQuickPub      = COMBINEBYTES(pMessage->QuickPublicValueLenMsb,
                                   pMessage->QuickPublicValueLenLsb);

    cbQuickServerPub= COMBINEBYTES(pMessage->QuickServerPublicValueLenMsb,
                                   pMessage->QuickServerPublicValueLenLsb);

    cbQuickEncryptedKey= COMBINEBYTES(pMessage->QuickEncryptedKeyLenMsb,
                                   pMessage->QuickEncryptedKeyLenLsb);


    /* we do this to precalc the offset to certifier list */
    i = PCT_OFFSET_OF(PPCT2_CLIENT_HELLO, VariantData)
         + cOffsetBytes - PCT_CH_OFFSET_V2
         + CipherSpecsSize
         + HashSpecsSize
         + CertSpecsSize
         + ExchSpecsSize
         + MsgSpecsSize
         + SigSpecsSize
         + cbKeyArg;

    /* check that this all fits into the message */
    if (i + cbCertifierList
         + cbQuickPub
         + cbQuickServerPub
         +cbQuickEncryptedKey  > ReportedSize)
    {
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

    cCipherSpecs = CipherSpecsSize / sizeof(ExtCipherSpec);
    cHashSpecs = HashSpecsSize / sizeof(ExtHashSpec);
    cExchSpecs = ExchSpecsSize / sizeof(ExtExchSpec);
    cCertSpecs = CertSpecsSize / sizeof(ExtCertSpec);
    cMsgSpecs  = MsgSpecsSize / sizeof(ExtMsgSpec);
    cSigSpecs  = SigSpecsSize / sizeof(ExtSigSpec);

    /* Count certifiers */
    cbCanonical =  sizeof(Pct2_Client_Hello) +
                   cbKeyArg +
                   cCipherSpecs * sizeof(CipherSpec) +
                   cHashSpecs * sizeof(HashSpec) +
                   cCertSpecs * sizeof(CertSpec) +
                   cExchSpecs * sizeof(ExchSpec) +
                   cMsgSpecs * sizeof(Pct2MsgSpec) +
                   cSigSpecs * sizeof(SigSpec) +
                   cbCertifierList;

    if(cbQuickPub) cbCanonical += CALC_CANONICAL_PUBLIC_VALUE_SIZE(cbQuickPub);
    if(cbQuickServerPub) cbCanonical += CALC_CANONICAL_PUBLIC_VALUE_SIZE(cbQuickServerPub);
    if(cbQuickEncryptedKey) cbCanonical += CALC_CANONICAL_ENCRYPTED_KEY_SIZE(cbQuickEncryptedKey);


    /* Allocate a buffer for the canonical client hello */
    pCanonical = (PPct2_Client_Hello)SPExternalAlloc(cbCanonical);

    if (!pCanonical)
    {
        return(PCT_INT_INTERNAL_ERROR);
    }


     /* Begin Unpacking Client Hello */

    pCanonical->AuthOptions = COMBINEBYTES(pMessage->AuthOptionsMsb, pMessage->AuthOptionsLsb);

    CopyMemory( pCanonical->SessionID,
                pMessage->SessionIdData,
                PCT2_SESSION_ID_SIZE);
    pCanonical->cbSessionID = PCT2_SESSION_ID_SIZE;

    CopyMemory( pCanonical->Challenge,
                pMessage->ChallengeData,
                PCT2_CHALLENGE_SIZE );
    pCanonical->cbChallenge = PCT2_CHALLENGE_SIZE;

    /* Pre-set all sizes */
    pCanonical->cHashSpecs = cHashSpecs;
    pCanonical->cCipherSpecs = cCipherSpecs;
    pCanonical->cCertSpecs = cCertSpecs;
    pCanonical->cExchSpecs = cExchSpecs;
    pCanonical->cbKeyArg = cbKeyArg;
    pCanonical->cMessageSpecs = cMsgSpecs;
    pCanonical->cSigSpecs = cSigSpecs;
    pCanonical->cbCertifiers = cbCertifierList;

    /* Start unpacking the variant data */
    pBuffer = &pMessage->OffsetLsb + 1 + cOffsetBytes;

    /* Pointer to free memory in canonical */
    pCurUnpack = (PUCHAR)(pCanonical + 1);



    /* Unpack Cipher Specs */
    if(pCanonical->cCipherSpecs) {
        pCanonical->pCipherSpecs = (PCipherSpec)pCurUnpack;
        for (i = 0 ; i < cCipherSpecs ; i++ )
        {
            pCanonical->pCipherSpecs[i] = MapCipherFromExternal(*(ExtCipherSpec *)
                                                        pBuffer);
        }
        pCurUnpack += sizeof(CipherSpec)*pCanonical->cCipherSpecs;
        pBuffer += sizeof(ExtCipherSpec)*pCanonical->cCipherSpecs;
    }

    /* Unpack Hash Specs */
    if(pCanonical->cHashSpecs) {
        pCanonical->pHashSpecs = (PHashSpec)pCurUnpack;

        for (i = 0 ; i < cHashSpecs ; i++ )
        {
            pCanonical->pHashSpecs[i] = MapHashFromExternal(*(ExtHashSpec *)
                                                        pBuffer);
        }
        pCurUnpack += sizeof(HashSpec)*pCanonical->cHashSpecs;
        pBuffer += sizeof(ExtHashSpec)*pCanonical->cHashSpecs;
    }

    /* Unpack Cert Specs */
    if(pCanonical->cCertSpecs) {
        pCanonical->pCertSpecs = (PCertSpec) pCurUnpack;
        for (i = 0 ; i < cCertSpecs ; i++ )
        {
            pCanonical->pCertSpecs[i] = MapCertFromExternal(*(ExtCertSpec *)
                                                        pBuffer);
        }
        pCurUnpack += sizeof(CertSpec)*pCanonical->cCertSpecs;
        pBuffer += sizeof(ExtCertSpec)*pCanonical->cCertSpecs;
    }


    /* Unpack Key Exchange Specs */
    if(pCanonical->cExchSpecs) {
        pCanonical->pExchSpecs = (PExchSpec)pCurUnpack;
        for (i = 0 ; i < cExchSpecs ; i++ )
        {
            pCanonical->pExchSpecs[i] = MapExchFromExternal(*(ExtExchSpec *)
                                                        pBuffer);
        }
        pBuffer += sizeof(ExtExchSpec)*pCanonical->cExchSpecs;
        pCurUnpack += sizeof(ExchSpec)*pCanonical->cExchSpecs;
    }

    /* Unpack KeyArg */
    if(pCanonical->cbKeyArg) {
        pCanonical->pKeyArg = pCurUnpack;
        CopyMemory(pCanonical->pKeyArg, pBuffer, cbKeyArg);
        pBuffer += pCanonical->cbKeyArg;
        pCurUnpack += pCanonical->cbKeyArg;
    }

    /* Unpack Messages */
    if(pCanonical->cMessageSpecs) {
        pCanonical->pMessageSpecs = (PPct2MsgSpec)pCurUnpack;
        for (i = 0 ; i < cMsgSpecs ; i++ )
        {
            pCanonical->pMessageSpecs[i] = MapMsgFromExternal(*(ExtMsgSpec *)
                                                        pBuffer);
        }
        pBuffer += sizeof(ExtMsgSpec)*pCanonical->cMessageSpecs;
        pCurUnpack += sizeof(Pct2MsgSpec)*pCanonical->cMessageSpecs;
    }

    /* Unpack Sig Specs */
    if(pCanonical->cSigSpecs) {
        pCanonical->pSigSpecs = (PSigSpec)pCurUnpack;
        for (i = 0 ; i < cSigSpecs ; i++ )
        {
            pCanonical->pSigSpecs[i] = MapSigFromExternal(*(ExtSigSpec *)
                                                        pBuffer);
        }
        pBuffer += sizeof(ExtSigSpec)*pCanonical->cSigSpecs;
        pCurUnpack += sizeof(SigSpec)*pCanonical->cSigSpecs;
    }

    /* Unpack the certifier list */

    if(pCanonical->cbCertifiers) {
        pCanonical->pCertifiers = (PUCHAR) pCurUnpack;
        CopyMemory(pCurUnpack, pBuffer, cbCertifierList);

        pBuffer += cbCertifierList;
        pCurUnpack += cbCertifierList;
    }

    if(cbQuickPub) {
        pCanonical->pQuickPublicValue = (PPct2_Public_Value)pCurUnpack;
        pCurUnpack += Pct2UnpackPublicValue(pBuffer, pCanonical->pQuickPublicValue);
        pBuffer += cbQuickPub;
    }
    if(cbQuickServerPub) {
        pCanonical->pQuickServerPublicValue = (PPct2_Public_Value)pCurUnpack;
        pCurUnpack += Pct2UnpackPublicValue(pBuffer, pCanonical->pQuickServerPublicValue);
        pBuffer += cbQuickServerPub;
    }
    if(cbQuickEncryptedKey) {
        pCanonical->pQuickEncryptedKey = (PPct2_Encrypted_Key)pCurUnpack;
        pCurUnpack += Pct2UnpackEncryptedKey(pBuffer, pCanonical->pQuickEncryptedKey);
        pBuffer += cbQuickEncryptedKey;
    }

    *ppClient = pCanonical;
    pInput->cbData = ReportedSize + sizeof(PCT2_RECORD_HEADER);
    return( PCT_ERR_OK);
}

BOOL RepackHsMessage(DWORD * pcbMessage,
                     PPCT2_HS_MESSAGE_HEADER *ppHeader,
                     PUCHAR *ppBuffer,
                     DWORD MsgType,
                     DWORD Flags)
{
    (*ppHeader)->RecHeader.LengthMSB = MSBOF(min(PCT_MAX_SHAKE_LEN, *pcbMessage));
    (*ppHeader)->RecHeader.LengthLSB = LSBOF(min(PCT_MAX_SHAKE_LEN, *pcbMessage));
    (*ppHeader)->RecHeader.TypeMSB = MSBOF(PCT2_RT_HANDSHAKE);
    (*ppHeader)->RecHeader.TypeLSB = LSBOF(PCT2_RT_HANDSHAKE);
    (*ppHeader)->MessageTypeMsb = MSBOF(MsgType);
    (*ppHeader)->MessageTypeLsb = LSBOF(MsgType);
    (*ppHeader)->RecordFlagsMsb = MSBOF(Flags);
    (*ppHeader)->RecordFlagsLsb = LSBOF(Flags);

    if(*pcbMessage > PCT_MAX_SHAKE_LEN) {
        *ppHeader = (PPCT2_HS_MESSAGE_HEADER)((PUCHAR)*ppHeader) + PCT_MAX_SHAKE_LEN;
        *pcbMessage -= PCT_MAX_SHAKE_LEN;
        CopyMemory((*ppHeader)+1, *ppHeader, *pcbMessage);
        *ppBuffer += sizeof(PCT2_HS_MESSAGE_HEADER);
        return TRUE;
    }
    return FALSE;
}

SP_STATUS
Pct2PackServerHello(
    PPct2_Server_Hello       pCanonical,
    PSPBuffer          pCommOutput)
{
    DWORD               cbMessage;
    PPCT2_HS_MESSAGE_HEADER pHeader;
    PPCT2_SERVER_HELLO      pMessage;
    DWORD               Size;
    PUCHAR              pBuffer;
    DWORD               i, iBuff;
    DWORD               cbPublicValue,  cbQuickEncryptedKey;

    DWORD               cbMessageSent;

    DWORD               cbCopied, iCopy;
    DWORD               Flags;

    /* Note, when packing messages that are longer than the max message length,
     * we break them into multiple records, and pack them all into one buffer
     */
    if(pCanonical == NULL || pCommOutput == NULL) return PCT_INT_INTERNAL_ERROR;
    pCommOutput->cbData = 0;

    /* Now add on the Quick Value sizes, if there are any */
    if(pCanonical->pPublicValue) {
        cbPublicValue =   CALC_PUBLIC_VALUE_SIZE(pCanonical->pPublicValue);

    }

    if(pCanonical->pQuickEncryptedKey) {
        cbQuickEncryptedKey  = CALC_ENCRYPTED_KEY_SIZE(pCanonical->pQuickEncryptedKey);

    }

    cbMessageSent =  PCT_OFFSET_OF(PPCT2_SERVER_HELLO, VariantData) +
                    pCanonical->cAltCipherSpecs * sizeof(ExtCipherSpec) +
                    pCanonical->cAltHashSpecs * sizeof(ExtHashSpec) +
                    pCanonical->cMessageSpecs * sizeof(ExtMsgSpec) +
                    pCanonical->cExchSpecs * sizeof(ExtExchSpec) +
                    pCanonical->cCertSpecs * sizeof(ExtCertSpec) +
                    cbQuickEncryptedKey +
                    pCanonical->cbResponse;

    cbMessage = cbMessageSent +
                pCanonical->cbCertifiers +
                cbPublicValue +
                pCanonical->cbSigCert;


    /* The number of message headers should be equal to the number
     * of blocks we split the message into.
     */
    pCommOutput->cbData = cbMessage + sizeof(PPCT2_HS_MESSAGE_HEADER)*((cbMessage / PCT_MAX_SHAKE_LEN)+1);

    /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL) {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
            return PCT_INT_INTERNAL_ERROR;
        pCommOutput->cbBuffer = pCommOutput->cbData;
    }

    if(pCommOutput->cbData > pCommOutput->cbBuffer) return PCT_INT_BUFF_TOO_SMALL;


    pHeader = pCommOutput->pvBuffer;
    pMessage = (PPCT2_SERVER_HELLO)(pHeader+1);

    /* Build base portion of server hello message */
    pMessage->VersionMsb = MSBOF(PCT_VERSION_2);
    pMessage->VersionLsb = LSBOF(PCT_VERSION_2);
    pMessage->AuthOptionsMsb = MSBOF(pCanonical->AuthOptions);
    pMessage->AuthOptionsLsb = LSBOF(pCanonical->AuthOptions);

    MapCipherToExternal(pCanonical->SrvCipherSpec, &pMessage->CipherSpecData);
    MapHashToExternal(pCanonical->SrvHashSpec, &pMessage->HashSpecData);
    MapExchToExternal(pCanonical->SrvExchSpec, &pMessage->ExchSpecData);
    MapSigToExternal(pCanonical->SrvSigSpec, &pMessage->SigSpecData);

    CopyMemory(pMessage->ConnectionIdData, pCanonical->ConnectionID,
               pCanonical->cbConnectionID);

    CopyMemory(pMessage->SessionIdData, pCanonical->SessionID,
               pCanonical->cbSessionID);


    pBuffer = pMessage->VariantData;

    /* Start packing the various specs */

    /* Pack cipher specs */
    iBuff = 0;
    for (i = 0; i < pCanonical->cAltCipherSpecs ; i++ )
    {
        if (MapCipherToExternal(pCanonical->pAltCipherSpecs[i],
                                &((ExtCipherSpec *) pBuffer)[iBuff]) )
        {
            iBuff++;
        }
    }
    Size = iBuff*sizeof(ExtCipherSpec);

    pMessage->AltCipherListLenMsb = MSBOF(Size);
    pMessage->AltCipherListLenLsb = LSBOF(Size);
    pBuffer += Size;

    cbMessageSent -= (pCanonical->cAltCipherSpecs - iBuff)*sizeof(ExtCipherSpec);

    /* Pack Hash Specs */
    iBuff = 0;
    for (i = 0; i < pCanonical->cAltHashSpecs ; i++ )
    {
        if (MapHashToExternal(pCanonical->pAltHashSpecs[i],
                              &((ExtHashSpec *) pBuffer)[iBuff]) )
        {
            iBuff++;
        }
    }
    Size = iBuff*sizeof(ExtHashSpec);
    pBuffer += Size;

    pMessage->AltHashListLenMsb = MSBOF(Size);
    pMessage->AltHashListLenLsb = LSBOF(Size);
    cbMessageSent -= (pCanonical->cAltHashSpecs - iBuff)*sizeof(ExtHashSpec);
    /* Pack Msg Specs */
    iBuff = 0;
    for (i = 0; i < pCanonical->cMessageSpecs ; i++ )
    {
        if (MapMsgToExternal(pCanonical->pMessageSpecs[i],
                                &((ExtMsgSpec *) pBuffer)[iBuff]) )
        {
            iBuff++;
        }
    }
    Size = iBuff*sizeof(ExtMsgSpec);
    pBuffer += Size;

    pMessage->MsgListLenMsb = MSBOF(Size);
    pMessage->MsgListLenLsb = LSBOF(Size);
    cbMessageSent -= (pCanonical->cMessageSpecs - iBuff)*sizeof(ExtMsgSpec);

    /* Pack Exch Specs */
    iBuff = 0;
    for (i = 0; i < pCanonical->cExchSpecs ; i++ )
    {
        if (MapExchToExternal(pCanonical->pExchSpecs[i],
                                &((ExtExchSpec *) pBuffer)[iBuff]) )
        {
            iBuff++;
        }
    }
    Size = iBuff*sizeof(ExtExchSpec);
    pBuffer += Size;

    pMessage->ExchListLenMsb = MSBOF(Size);
    pMessage->ExchListLenLsb = LSBOF(Size);
    cbMessageSent -= (pCanonical->cExchSpecs - iBuff)*sizeof(ExtExchSpec);

    /* pack Cert specs */
    iBuff = 0;
    for (i = 0; i < pCanonical->cCertSpecs ; i++ )
    {
        if (MapCertToExternal(pCanonical->pCertSpecs[i],
                                &((ExtCertSpec *) pBuffer)[iBuff]))
        {
            iBuff ++;
        }
    }
    Size = iBuff*sizeof(ExtCertSpec);
    pBuffer += Size;

    pMessage->CertListLenMsb = MSBOF(Size);
    pMessage->CertListLenLsb = LSBOF(Size);
    cbMessageSent -= (pCanonical->cCertSpecs - iBuff)*sizeof(ExtCertSpec);




    if(pCanonical->pQuickEncryptedKey){
        pBuffer += Pct2PackEncryptedKey(pCanonical->pQuickEncryptedKey, pBuffer);
    }
    pMessage->QuickEncryptedKeyLenMsb = MSBOF(cbQuickEncryptedKey);
    pMessage->QuickEncryptedKeyLenLsb = LSBOF(cbQuickEncryptedKey);

    CopyMemory(pBuffer, pCanonical->pResponse, pCanonical->cbResponse);
    pMessage->ResponseLenMsb = MSBOF(pCanonical->cbResponse);
    pMessage->ResponseLenLsb = LSBOF(pCanonical->cbResponse);

    /* Okay, we shouldn't have run over our record length max yet, but just to
     * be sure, repack.
     */
    /* Certifier list data */

    CopyMemory(pBuffer, pCanonical->pCertifiers, pCanonical->cbCertifiers);
    pBuffer += pCanonical->cbCertifiers;
    pMessage->CertifierListLenMsb = MSBOF(pCanonical->cbCertifiers);
    pMessage->CertifierListLenLsb = LSBOF(pCanonical->cbCertifiers);


    if(pCanonical->pPublicValue) {
        pBuffer += Pct2PackPublicValue(pCanonical->pPublicValue, pBuffer);
    }
    pMessage->PublicValueLenMsb = MSBOF(cbPublicValue);
    pMessage->PublicValueLenLsb = LSBOF(cbPublicValue);

    while(cbMessageSent >= PCT_MAX_SHAKE_LEN) {
        if(Flags & PCT2_HS_FLAG_TO_BE_CONTD) Flags = PCT2_HS_FLAG_CONTINUATION;
        else if(Flags == 0) Flags = PCT2_HS_FLAG_TO_BE_CONTD;
        RepackHsMessage(&cbMessageSent, &pHeader, &pBuffer, PCT2_HS_SERVER_HELLO, Flags);
    }

    /* Okay, now pack the potentially big things */
    pMessage->SigCertLenMsb = MSBOF(pCanonical->cbSigCert);
    pMessage->SigCertLenLsb = LSBOF(pCanonical->cbSigCert);



    /* Yeah, I know this looks wierd, but we should not have to do any Copies
     * to move data out of the way of an inline header if we do this */

    iCopy = 0;
    while(iCopy < pCanonical->cbSigCert) {

        cbCopied = min(pCanonical->cbSigCert-iCopy, (PCT_MAX_SHAKE_LEN-cbMessageSent));
        CopyMemory(pBuffer, pCanonical->pSigCert + iCopy, cbCopied);
        iCopy += cbCopied;
        pBuffer += iCopy;

        while(cbMessageSent >= PCT_MAX_SHAKE_LEN) {
            if(Flags & PCT2_HS_FLAG_TO_BE_CONTD) Flags = PCT2_HS_FLAG_CONTINUATION;
            else if(Flags == 0) Flags = PCT2_HS_FLAG_TO_BE_CONTD;
            RepackHsMessage(&cbMessageSent, &pHeader, &pBuffer, PCT2_HS_SERVER_HELLO, Flags);
        }

    }

    /* Finish up */
    RepackHsMessage(&cbMessageSent, &pHeader, &pBuffer, PCT2_HS_SERVER_HELLO, Flags);




    return( PCT_ERR_OK );

}

SP_STATUS
Pct2UnpackServerHello(
    PSPBuffer          pInput,
    PPct2_Server_Hello *     ppServer)
{

    PPCT2_HS_MESSAGE_HEADER  pHeader;
    PPCT2_SERVER_HELLO   pMessage;

    DWORD               ReportedSize;
    DWORD               cbAltCipherList, cbAltHashList, cbCertList;
    DWORD               cbExchList, cbMsgList;
    DWORD               cbCertifierList, cbPublicValue, cbSigCert, cbResponse;
    DWORD               cbQuickEncryptedKey;

    DWORD               cAltCipherSpecs, cAltHashSpecs, cCertSpecs, cExchSpecs,
                        cMsgSpecs;

    PPct2_Server_Hello  pCanonical;
    PUCHAR              pBuffer;
    DWORD               i;
    DWORD               cbCanonical;

    DWORD               dwRecordFlags;
    pHeader = pInput->pvBuffer;

    if(pInput->cbBuffer < sizeof(PCT2_HS_MESSAGE_HEADER)) {
        return PCT_INT_INCOMPLETE_MSG;
    }

    /* BUGBUG: Right now, we're not dealing with record spanning server
     * hello's */

    ReportedSize = SIZEOF(pHeader);

    if ((ReportedSize+sizeof(PCT2_HS_MESSAGE_HEADER)) > pInput->cbBuffer)
    {
        return PCT_INT_INCOMPLETE_MSG;
    }

    dwRecordFlags = COMBINEBYTES(pHeader->RecordFlagsMsb, pHeader->RecordFlagsLsb);
    /* Only create a new ClientHello canonical if this is a complete
     * message, or the first message in a completion string */

    if(!(dwRecordFlags & PCT2_HS_FLAG_CONTINUATION)) {

        if(ReportedSize < PCT_OFFSET_OF(PPCT2_CLIENT_HELLO, VariantData))
        {
            return PCT_ERR_ILLEGAL_MESSAGE;
        }
        /* Now start validating the message */
        pMessage = (PPCT2_SERVER_HELLO)(pHeader+1);

        if(COMBINEBYTES(pHeader->MessageTypeMsb, pHeader->MessageTypeLsb) !=
           PCT2_HS_CLIENT_HELLO)
        {
            return PCT_ERR_ILLEGAL_MESSAGE;
        }


        /* We don't recognize hello messages of less version than ourselves,
         * those will be handled by a previous version of the code */
        if(COMBINEBYTES(pMessage->VersionMsb, pMessage->VersionLsb) < PCT_VERSION_2)
        {
            return PCT_ERR_ILLEGAL_MESSAGE;
        }

        *ppServer = NULL;

        cbAltCipherList =     COMBINEBYTES( pMessage->AltCipherListLenMsb,
                                            pMessage->AltCipherListLenLsb );

        cbAltHashList =       COMBINEBYTES( pMessage->AltHashListLenMsb,
                                            pMessage->AltHashListLenLsb );

        cbMsgList =           COMBINEBYTES( pMessage->MsgListLenMsb,
                                            pMessage->MsgListLenLsb );

        cbExchList =          COMBINEBYTES( pMessage->ExchListLenMsb,
                                            pMessage->ExchListLenLsb );

        cbCertList =          COMBINEBYTES( pMessage->CertListLenMsb,
                                            pMessage->CertListLenLsb );

        cbCertifierList=      COMBINEBYTES( pMessage->CertifierListLenMsb,
                                            pMessage->CertifierListLenLsb);

        cbPublicValue =       COMBINEBYTES( pMessage->PublicValueLenMsb,
                                            pMessage->PublicValueLenLsb);

        cbQuickEncryptedKey = COMBINEBYTES( pMessage->QuickEncryptedKeyLenMsb,
                                            pMessage->QuickEncryptedKeyLenLsb);

        cbSigCert =           COMBINEBYTES( pMessage->SigCertLenMsb,
                                            pMessage->SigCertLenLsb);

        cbResponse =          COMBINEBYTES( pMessage->ResponseLenMsb,
                                            pMessage->ResponseLenLsb);

        /* we do this to precalc the offset to certifier list */
        i = PCT_OFFSET_OF(PPCT2_CLIENT_HELLO, VariantData)
             + cbAltCipherList
             + cbAltHashList
             + cbMsgList
             + cbExchList
             + cbCertList;

        cAltCipherSpecs = cbAltCipherList / sizeof(ExtCipherSpec);
        cAltHashSpecs = cbAltHashList / sizeof(ExtHashSpec);
        cMsgSpecs  = cbMsgList   / sizeof(ExtMsgSpec);
        cExchSpecs = cbExchList  / sizeof(ExtMsgSpec);
        cCertSpecs = cbCertList  / sizeof(ExtCertSpec);

        cbCanonical =  sizeof(Pct2_Client_Hello) +
                       cAltCipherSpecs * sizeof(CipherSpec) +
                       cAltHashSpecs * sizeof(HashSpec) +
                       cMsgSpecs * sizeof(Pct2MsgSpec) +
                       cExchSpecs * sizeof(ExchSpec) +
                       cCertSpecs * sizeof(CertSpec) +
                       cbCertifierList +
                       cbSigCert +
                       cbResponse;

        if(cbPublicValue) cbCanonical += CALC_CANONICAL_PUBLIC_VALUE_SIZE(cbPublicValue);
        if(cbQuickEncryptedKey) cbCanonical += CALC_CANONICAL_ENCRYPTED_KEY_SIZE(cbQuickEncryptedKey);


        /* Allocate a buffer for the canonical client hello */
        pCanonical = (PPct2_Server_Hello)SPExternalAlloc(cbCanonical);

        if (!pCanonical)
        {
            return(PCT_INT_INTERNAL_ERROR);
        }

        /* Begin Unpacking Client Hello */

        pCanonical->AuthOptions = COMBINEBYTES(pMessage->AuthOptionsMsb, pMessage->AuthOptionsLsb);

        pCanonical->SrvCipherSpec = MapCipherFromExternal(pMessage->CipherSpecData);
        pCanonical->SrvHashSpec   = MapHashFromExternal(pMessage->HashSpecData);

        pCanonical->SrvExchSpec   = MapExchFromExternal(pMessage->ExchSpecData);
        pCanonical->SrvSigSpec    = MapSigFromExternal(pMessage->SigSpecData);

        CopyMemory( pCanonical->SessionID,
                    pMessage->SessionIdData,
                    PCT2_SESSION_ID_SIZE);
        pCanonical->cbSessionID = PCT2_SESSION_ID_SIZE;

        CopyMemory( pCanonical->ConnectionID,
                    pMessage->ConnectionIdData,
                    PCT2_CONNECTION_ID_SIZE );
        pCanonical->cbConnectionID = PCT2_CONNECTION_ID_SIZE;

        /* Pre-set all sizes */
        pCanonical->cAltCipherSpecs = cAltCipherSpecs;
        pCanonical->cAltHashSpecs =   cAltHashSpecs;
        pCanonical->cMessageSpecs =   cMsgSpecs;
        pCanonical->cCertSpecs =      cCertSpecs;
        pCanonical->cExchSpecs =      cExchSpecs;
        pCanonical->cbSigCert = cbSigCert;
        pCanonical->cbResponse = cbResponse;

        /* Start unpacking the variant data */
        pBuffer = pMessage->VariantData;
        /* Pointer to free memory in canonical */
        pCanonical->pCurUnpack = (PUCHAR)(pCanonical + 1);

        /* Unpack Cipher Specs */
        if(pCanonical->cAltCipherSpecs) {
            pCanonical->pAltCipherSpecs = (PCipherSpec)pCanonical->pCurUnpack;
            for(i=0; i< cAltCipherSpecs; i++ )
            {
                pCanonical->pAltCipherSpecs[i] = MapCipherFromExternal(*(ExtCipherSpec *)
                                                            pBuffer);
            }
            pCanonical->pCurUnpack += sizeof(CipherSpec)*pCanonical->cAltCipherSpecs;
            pBuffer += sizeof(ExtCipherSpec)*pCanonical->cAltCipherSpecs;
        }

        /* Unpack Hash Specs */
        if(pCanonical->cAltHashSpecs) {
            pCanonical->pAltHashSpecs = (PHashSpec)pCanonical->pCurUnpack;

            for(i=0; i< cAltHashSpecs; i++ )
            {
                pCanonical->pAltHashSpecs[i] = MapHashFromExternal(*(ExtHashSpec *)
                                                            pBuffer);
            }
            pCanonical->pCurUnpack += sizeof(HashSpec)*pCanonical->cAltHashSpecs;
            pBuffer += sizeof(ExtHashSpec)*pCanonical->cAltHashSpecs;
        }

        /* Unpack Messages */
        if(pCanonical->cMessageSpecs) {
            pCanonical->pMessageSpecs = (PPct2MsgSpec)pCanonical->pCurUnpack;

            for(i=0; i< cMsgSpecs; i++ )
            {
                pCanonical->pMessageSpecs[i] = MapMsgFromExternal(*(ExtMsgSpec *)
                                                            pBuffer);
            }
            pBuffer += sizeof(ExtMsgSpec)*pCanonical->cMessageSpecs;
            pCanonical->pCurUnpack += sizeof(Pct2MsgSpec)*pCanonical->cMessageSpecs;
        }

        /* Unpack Key Exchange Specs */
        if(pCanonical->cExchSpecs) {
            pCanonical->pExchSpecs = (PExchSpec)pCanonical->pCurUnpack;
            for(i=0; i< cExchSpecs; i++ )
            {
                pCanonical->pExchSpecs[i] = MapExchFromExternal(*(ExtExchSpec *)
                                                            pBuffer);
            }
            pBuffer += sizeof(ExtExchSpec)*pCanonical->cExchSpecs;
            pCanonical->pCurUnpack += sizeof(ExchSpec)*pCanonical->cExchSpecs;
        }

        /* Unpack Cert Specs */
        if(pCanonical->cCertSpecs) {
            pCanonical->pCertSpecs = (PCertSpec) pCanonical->pCurUnpack;
            for(i=0; i< cCertSpecs; i++ )
            {
                pCanonical->pCertSpecs[i] = MapCertFromExternal(*(ExtCertSpec *)
                                                            pBuffer);
            }
            pCanonical->pCurUnpack += sizeof(CertSpec)*pCanonical->cCertSpecs;
            pBuffer += sizeof(ExtCertSpec)*pCanonical->cCertSpecs;
        }

        /* Unpack Quick Encrypted Key */
        if(cbQuickEncryptedKey) {
            pCanonical->pQuickEncryptedKey = (PPct2_Encrypted_Key)pCanonical->pCurUnpack;
            pCanonical->pCurUnpack += Pct2UnpackEncryptedKey(pBuffer, pCanonical->pQuickEncryptedKey);
            pBuffer += cbQuickEncryptedKey;
        }

        /* Unpack Response */
        pCanonical->pResponse = pCanonical->pCurUnpack;
        CopyMemory(pCanonical->pResponse, pBuffer, cbResponse);
        pCanonical->pCurUnpack += cbResponse;
        pBuffer += cbResponse;

        pCanonical->UnpackState = SH_UNPACK_CERTIFIERS;
        pCanonical->SubState = 0;
        pCanonical->pCertifiers = pCanonical->pCurUnpack;
    } else {
        pBuffer = (PUCHAR)(pHeader+1);
    }
    *ppServer = pCanonical;
    pInput->cbData = ReportedSize + sizeof(PCT2_RECORD_HEADER);

    /* Everything up to the certifier list is required to come in the first
     * message.  All of the following stuff could come split across records
     */
    switch(pCanonical->UnpackState) {
        case SH_UNPACK_CERTIFIERS:
            /* Unpack the certifier list */
            /* pBuffer should point to data where the certifier list is */
            /* pCurUnpack is where the data goes */
            /* ReportedSize - DWORD(pBuffer - pHeader) is how much data we have */

            i = min(pCanonical->cbCertifiers - pCanonical->SubState,
                    ReportedSize - (DWORD)(pBuffer - (PUCHAR)pHeader));

            CopyMemory(pCanonical->pCurUnpack, pBuffer, i);
            pCanonical->pCurUnpack += i;
            pBuffer += i;
            pCanonical->SubState += i;
            /* We've not yet finished unpacking */
            if(pCanonical->SubState < pCanonical->cbCertifiers) return PCT_INT_NEXT_RECORD;

            if(cbPublicValue) {
                pCanonical->SubState = 0;
                pCanonical->UnpackState = SH_UNPACK_PUBLIC_VALUE;
                pCanonical->pPublicValue = (PPct2_Public_Value)pCanonical->pCurUnpack;
            } else {
                pCanonical->SubState = 0;
                pCanonical->UnpackState = SH_UNPACK_SIGCERT;
                pCanonical->pSigCert = (PUCHAR)pCanonical->pCurUnpack;
            }
        case SH_UNPACK_PUBLIC_VALUE:
            if(cbPublicValue) {
                pCanonical->pCurUnpack += Pct2UnpackPublicValue(pBuffer, pCanonical->pPublicValue);
                pBuffer += cbPublicValue;
            }
            pCanonical->SubState = 0;
            pCanonical->UnpackState = SH_UNPACK_SIGCERT;
            pCanonical->pSigCert = (PUCHAR)pCanonical->pCurUnpack;

        case SH_UNPACK_SIGCERT:
            i = min(pCanonical->cbSigCert - pCanonical->SubState,
                    ReportedSize - (DWORD)(pBuffer - (PUCHAR)pHeader));

            CopyMemory(pCanonical->pCurUnpack, pBuffer, i);
            pCanonical->pCurUnpack += i;
            pBuffer += i;
            pCanonical->SubState += i;
            /* We've not yet finished unpacking */
            if(pCanonical->SubState < pCanonical->cbSigCert) return PCT_INT_NEXT_RECORD;
            return PCT_ERR_OK;
        default:
              break;
    }
    return( PCT_ERR_ILLEGAL_MESSAGE);
}

SP_STATUS
Pct2PackClientMasterKey(
    PPct2_Client_Master_Key      pCanonical,
    PSPBuffer              pCommOutput)
{
    DWORD               cbMessage;
    PPCT2_HS_MESSAGE_HEADER pHeader;
    PPCT2_CLIENT_MASTER_KEY     pMessage;
    PUCHAR              pBuffer;
    DWORD               cbPublicValue,  cbEncryptedKey;

    DWORD               cbMessageSent;

    DWORD               cbCopied, iCopy;
    DWORD               Flags;

    /* Note, when packing messages that are longer than the max message length,
     * we break them into multiple records, and pack them all into one buffer
     */
    if(pCanonical == NULL || pCommOutput == NULL) return PCT_INT_INTERNAL_ERROR;
    pCommOutput->cbData = 0;

    /* Now add on the Quick Value sizes, if there are any */
    if(pCanonical->pPublicValue) {
        cbPublicValue =   CALC_PUBLIC_VALUE_SIZE(pCanonical->pPublicValue);

    }

    if(pCanonical->pEncryptedKey) {
        cbEncryptedKey  = CALC_ENCRYPTED_KEY_SIZE(pCanonical->pEncryptedKey);

    }

    cbMessageSent =  PCT_OFFSET_OF(PPCT2_SERVER_HELLO, VariantData) +
                    pCanonical->cbResponse +
                    cbEncryptedKey;

    cbMessage = cbMessageSent +
                cbPublicValue +
                pCanonical->cbSigCert;


    /* The number of message headers should be equal to the number
     * of blocks we split the message into.
     */
    pCommOutput->cbData = cbMessage + sizeof(PPCT2_HS_MESSAGE_HEADER)*((cbMessage / PCT_MAX_SHAKE_LEN)+1);

    /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL) {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
            return PCT_INT_INTERNAL_ERROR;
        pCommOutput->cbBuffer = pCommOutput->cbData;
    }

    if(pCommOutput->cbData > pCommOutput->cbBuffer) return PCT_INT_BUFF_TOO_SMALL;


    pHeader = pCommOutput->pvBuffer;
    pMessage = (PPCT2_CLIENT_MASTER_KEY)(pHeader+1);

    /* Build base portion of server hello message */
    pMessage->EncryptedKeyLenMsb = MSBOF(cbEncryptedKey);
    pMessage->EncryptedKeyLenLsb = LSBOF(cbEncryptedKey);
    pMessage->ResponseLenMsb = MSBOF(pCanonical->cbResponse);
    pMessage->ResponseLenLsb = LSBOF(pCanonical->cbResponse);
    pMessage->PublicValueLenMsb = MSBOF(cbPublicValue);
    pMessage->PublicValueLenLsb = LSBOF(cbPublicValue);
    pMessage->SigCertLenMsb = MSBOF(pCanonical->cbSigCert);
    pMessage->SigCertLenLsb = LSBOF(pCanonical->cbSigCert);


    pBuffer = pMessage->VariantData;


    if(pCanonical->pEncryptedKey){
        pBuffer += Pct2PackEncryptedKey(pCanonical->pEncryptedKey, pBuffer);
    }

    CopyMemory(pBuffer, pCanonical->pResponse, pCanonical->cbResponse);

    pBuffer += pCanonical->cbResponse;

    /* Okay, we shouldn't have run over our record length max yet, but just to
     * be sure, repack.
     */

    if(pCanonical->pPublicValue) {
        pBuffer += Pct2PackPublicValue(pCanonical->pPublicValue, pBuffer);
    }

    while(cbMessageSent >= PCT_MAX_SHAKE_LEN) {
        if(Flags & PCT2_HS_FLAG_TO_BE_CONTD) Flags = PCT2_HS_FLAG_CONTINUATION;
        else if(Flags == 0) Flags = PCT2_HS_FLAG_TO_BE_CONTD;
        RepackHsMessage(&cbMessageSent, &pHeader, &pBuffer, PCT2_HS_CLIENT_MASTER_KEY, Flags);
    }



    /* Yeah, I know this looks wierd, but we should not have to do any Copies
     * to move data out of the way of an inline header if we do this */

    iCopy = 0;
    while(iCopy < pCanonical->cbSigCert) {

        cbCopied = min(pCanonical->cbSigCert-iCopy, (PCT_MAX_SHAKE_LEN-cbMessageSent));
        CopyMemory(pBuffer, pCanonical->pSigCert + iCopy, cbCopied);
        iCopy += cbCopied;
        pBuffer += iCopy;

        while(cbMessageSent >= PCT_MAX_SHAKE_LEN) {
            if(Flags & PCT2_HS_FLAG_TO_BE_CONTD) Flags = PCT2_HS_FLAG_CONTINUATION;
            else if(Flags == 0) Flags = PCT2_HS_FLAG_TO_BE_CONTD;
            RepackHsMessage(&cbMessageSent, &pHeader, &pBuffer, PCT2_HS_CLIENT_MASTER_KEY, Flags);
        }

    }

    /* Finish up */
    RepackHsMessage(&cbMessageSent, &pHeader, &pBuffer, PCT2_HS_CLIENT_MASTER_KEY, Flags);


    return( PCT_ERR_OK );

}

SP_STATUS
Pct2UnpackClientMasterKey(
    PSPBuffer          pInput,
    PPct2_Client_Master_Key *     ppClient)
{

    PPCT2_HS_MESSAGE_HEADER   pHeader;
    PPCT2_CLIENT_MASTER_KEY   pMessage;

    DWORD               ReportedSize;
    DWORD               cbPublicValue, cbSigCert, cbResponse;
    DWORD               cbEncryptedKey;


    PPct2_Client_Master_Key  pCanonical;
    PUCHAR              pBuffer;
    DWORD               i;
    DWORD               cbCanonical;

    DWORD               dwRecordFlags;
    pHeader = pInput->pvBuffer;

    if(pInput->cbBuffer < sizeof(PCT2_HS_MESSAGE_HEADER)) {
        return PCT_INT_INCOMPLETE_MSG;
    }

    /* BUGBUG: Right now, we're not dealing with record spanning server
     * hello's */

    ReportedSize = SIZEOF(pHeader);

    if ((ReportedSize+sizeof(PCT2_HS_MESSAGE_HEADER)) > pInput->cbBuffer)
    {
        return PCT_INT_INCOMPLETE_MSG;
    }

    dwRecordFlags = COMBINEBYTES(pHeader->RecordFlagsMsb, pHeader->RecordFlagsLsb);
    /* Only create a new ClientHello canonical if this is a complete
     * message, or the first message in a completion string */

    if(!(dwRecordFlags & PCT2_HS_FLAG_CONTINUATION)) {

        if(ReportedSize < PCT_OFFSET_OF(PPCT2_CLIENT_MASTER_KEY, VariantData))
        {
            return PCT_ERR_ILLEGAL_MESSAGE;
        }
        /* Now start validating the message */
        pMessage = (PPCT2_CLIENT_MASTER_KEY)(pHeader+1);

        if(COMBINEBYTES(pHeader->MessageTypeMsb, pHeader->MessageTypeLsb) !=
           PCT2_HS_CLIENT_MASTER_KEY)
        {
            return PCT_ERR_ILLEGAL_MESSAGE;
        }



        *ppClient = NULL;


        cbEncryptedKey =      COMBINEBYTES( pMessage->EncryptedKeyLenMsb,
                                            pMessage->EncryptedKeyLenLsb);

        cbResponse =          COMBINEBYTES( pMessage->ResponseLenMsb,
                                            pMessage->ResponseLenLsb);

        cbPublicValue =       COMBINEBYTES( pMessage->PublicValueLenMsb,
                                            pMessage->PublicValueLenLsb);

        cbSigCert =           COMBINEBYTES( pMessage->SigCertLenMsb,
                                            pMessage->SigCertLenLsb);




        cbCanonical =  sizeof(Pct2_Client_Master_Key) +
                       cbResponse +
                       cbSigCert;

        if(cbPublicValue) cbCanonical += CALC_CANONICAL_PUBLIC_VALUE_SIZE(cbPublicValue);
        if(cbEncryptedKey) cbCanonical += CALC_CANONICAL_ENCRYPTED_KEY_SIZE(cbEncryptedKey);


        /* Allocate a buffer for the canonical client hello */
        pCanonical = (PPct2_Client_Master_Key)SPExternalAlloc(cbCanonical);

        if (!pCanonical)
        {
            return(PCT_INT_INTERNAL_ERROR);
        }

        /* Begin Unpacking Client Hello */


        /* Pre-set all sizes */
        pCanonical->cbResponse = cbResponse;
        pCanonical->cbSigCert = cbSigCert;

        /* Start unpacking the variant data */
        pBuffer = pMessage->VariantData;
        /* Pointer to free memory in canonical */
        pCanonical->pCurUnpack = (PUCHAR)(pCanonical + 1);


        /* Unpack Quick Encrypted Key */
        if(cbEncryptedKey) {
            pCanonical->pEncryptedKey = (PPct2_Encrypted_Key)pCanonical->pCurUnpack;
            pCanonical->pCurUnpack += Pct2UnpackEncryptedKey(pBuffer, pCanonical->pEncryptedKey);
            pBuffer += cbEncryptedKey;
        }

        /* Unpack Response */
        pCanonical->pResponse = pCanonical->pCurUnpack;
        CopyMemory(pCanonical->pResponse, pBuffer, cbResponse);
        pCanonical->pCurUnpack += cbResponse;
        pBuffer += cbResponse;

        pCanonical->UnpackState = CMK_UNPACK_PUBLIC_VALUE;
        pCanonical->SubState = 0;
        pCanonical->pPublicValue = (PPct2_Public_Value)pCanonical->pCurUnpack;
    } else {
        pBuffer = (PUCHAR)(pHeader+1);
    }
    *ppClient = pCanonical;
    pInput->cbData = ReportedSize + sizeof(PCT2_RECORD_HEADER);

    /* Everything up to the certifier list is required to come in the first
     * message.  All of the following stuff could come split across records
     */
    switch(pCanonical->UnpackState) {
        case CMK_UNPACK_PUBLIC_VALUE:
            if(cbPublicValue) {
                pCanonical->pCurUnpack += Pct2UnpackPublicValue(pBuffer, pCanonical->pPublicValue);
                pBuffer += cbPublicValue;
            }
            pCanonical->SubState = 0;
            pCanonical->UnpackState = CMK_UNPACK_SIGCERT;
            pCanonical->pSigCert = (PUCHAR)pCanonical->pCurUnpack;

        case CMK_UNPACK_SIGCERT:
            i = min(pCanonical->cbSigCert - pCanonical->SubState,
                    ReportedSize - (DWORD)(pBuffer - (PUCHAR)pHeader));

            CopyMemory(pCanonical->pCurUnpack, pBuffer, i);
            pCanonical->pCurUnpack += i;
            pBuffer += i;
            pCanonical->SubState += i;
            /* We've not yet finished unpacking */
            if(pCanonical->SubState < pCanonical->cbSigCert) return PCT_INT_NEXT_RECORD;
            return PCT_ERR_OK;
        default:
              break;
    }
    return( PCT_ERR_ILLEGAL_MESSAGE);
}


SP_STATUS
Pct2PackServerVerify(
    PPct2_Server_Verify    pCanonical,
    PSPBuffer              pCommOutput)
{
    DWORD               cbMessage;
    PPCT2_HS_MESSAGE_HEADER pHeader;
    PPCT2_SERVER_VERIFY     pMessage;
    PUCHAR              pBuffer;
    DWORD               cbEncryptedKey;

    DWORD               cbMessageSent;

    DWORD               cbCopied, iCopy;
    DWORD               Flags;

    /* Note, when packing messages that are longer than the max message length,
     * we break them into multiple records, and pack them all into one buffer
     */
    if(pCanonical == NULL || pCommOutput == NULL) return PCT_INT_INTERNAL_ERROR;
    pCommOutput->cbData = 0;


    if(pCanonical->pEncryptedKey) {
        cbEncryptedKey  = CALC_ENCRYPTED_KEY_SIZE(pCanonical->pEncryptedKey);

    }

    cbMessageSent =  PCT_OFFSET_OF(PPCT2_SERVER_VERIFY, VariantData) +
                    pCanonical->cbResponse +
                    cbEncryptedKey;

    cbMessage = cbMessageSent +
                pCanonical->cbSigCert;


    /* The number of message headers should be equal to the number
     * of blocks we split the message into.
     */
    pCommOutput->cbData = cbMessage + sizeof(PPCT2_HS_MESSAGE_HEADER)*((cbMessage / PCT_MAX_SHAKE_LEN)+1);

    /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL) {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
            return PCT_INT_INTERNAL_ERROR;
        pCommOutput->cbBuffer = pCommOutput->cbData;
    }

    if(pCommOutput->cbData > pCommOutput->cbBuffer) return PCT_INT_BUFF_TOO_SMALL;


    pHeader = pCommOutput->pvBuffer;
    pMessage = (PPCT2_SERVER_VERIFY)(pHeader+1);

    /* Build base portion of server hello message */
    pMessage->EncryptedKeyLenMsb = MSBOF(cbEncryptedKey);
    pMessage->EncryptedKeyLenLsb = LSBOF(cbEncryptedKey);
    pMessage->ResponseLenMsb = MSBOF(pCanonical->cbResponse);
    pMessage->ResponseLenLsb = LSBOF(pCanonical->cbResponse);
    pMessage->SigCertLenMsb = MSBOF(pCanonical->cbSigCert);
    pMessage->SigCertLenLsb = LSBOF(pCanonical->cbSigCert);


    pBuffer = pMessage->VariantData;


    if(pCanonical->pEncryptedKey){
        pBuffer += Pct2PackEncryptedKey(pCanonical->pEncryptedKey, pBuffer);
    }

    CopyMemory(pBuffer, pCanonical->pResponse, pCanonical->cbResponse);

    pBuffer += pCanonical->cbResponse;



    /* Yeah, I know this looks wierd, but we should not have to do any Copies
     * to move data out of the way of an inline header if we do this */

    iCopy = 0;
    while(iCopy < pCanonical->cbSigCert) {

        cbCopied = min(pCanonical->cbSigCert-iCopy, (PCT_MAX_SHAKE_LEN-cbMessageSent));
        CopyMemory(pBuffer, pCanonical->pSigCert + iCopy, cbCopied);
        iCopy += cbCopied;
        pBuffer += iCopy;

        while(cbMessageSent >= PCT_MAX_SHAKE_LEN) {
            if(Flags & PCT2_HS_FLAG_TO_BE_CONTD) Flags = PCT2_HS_FLAG_CONTINUATION;
            else if(Flags == 0) Flags = PCT2_HS_FLAG_TO_BE_CONTD;
            RepackHsMessage(&cbMessageSent, &pHeader, &pBuffer, PCT2_HS_SERVER_VERIFY, Flags);
        }

    }

    /* Finish up */
    RepackHsMessage(&cbMessageSent, &pHeader, &pBuffer, PCT2_HS_SERVER_VERIFY, Flags);


    return( PCT_ERR_OK );

}

SP_STATUS
Pct2UnpackServerVerify(
    PSPBuffer                pInput,
    PPct2_Server_Verify*     ppServer)
{

    PPCT2_HS_MESSAGE_HEADER   pHeader;
    PPCT2_SERVER_VERIFY   pMessage;

    DWORD               ReportedSize;
    DWORD               cbSigCert, cbResponse;
    DWORD               cbEncryptedKey;


    PPct2_Server_Verify  pCanonical;
    PUCHAR              pBuffer;
    DWORD               i;
    DWORD               cbCanonical;

    DWORD               dwRecordFlags;
    pHeader = pInput->pvBuffer;

    if(pInput->cbBuffer < sizeof(PCT2_HS_MESSAGE_HEADER)) {
        return PCT_INT_INCOMPLETE_MSG;
    }

    /* BUGBUG: Right now, we're not dealing with record spanning server
     * hello's */

    ReportedSize = SIZEOF(pHeader);

    if ((ReportedSize+sizeof(PCT2_HS_MESSAGE_HEADER)) > pInput->cbBuffer)
    {
        return PCT_INT_INCOMPLETE_MSG;
    }

    dwRecordFlags = COMBINEBYTES(pHeader->RecordFlagsMsb, pHeader->RecordFlagsLsb);
    /* Only create a new ClientHello canonical if this is a complete
     * message, or the first message in a completion string */

    if(!(dwRecordFlags & PCT2_HS_FLAG_CONTINUATION)) {

        if(ReportedSize < PCT_OFFSET_OF(PPCT2_SERVER_VERIFY, VariantData))
        {
            return PCT_ERR_ILLEGAL_MESSAGE;
        }
        /* Now start validating the message */
        pMessage = (PPCT2_SERVER_VERIFY)(pHeader+1);

        if(COMBINEBYTES(pHeader->MessageTypeMsb, pHeader->MessageTypeLsb) !=
           PCT2_HS_SERVER_VERIFY)
        {
            return PCT_ERR_ILLEGAL_MESSAGE;
        }



        *ppServer = NULL;


        cbEncryptedKey =      COMBINEBYTES( pMessage->EncryptedKeyLenMsb,
                                            pMessage->EncryptedKeyLenLsb);

        cbResponse =          COMBINEBYTES( pMessage->ResponseLenMsb,
                                            pMessage->ResponseLenLsb);

        cbSigCert =           COMBINEBYTES( pMessage->SigCertLenMsb,
                                            pMessage->SigCertLenLsb);




        cbCanonical =  sizeof(Pct2_Server_Verify) +
                       cbResponse +
                       cbSigCert;

        if(cbEncryptedKey) cbCanonical += CALC_CANONICAL_ENCRYPTED_KEY_SIZE(cbEncryptedKey);


        /* Allocate a buffer for the canonical client hello */
        pCanonical = (PPct2_Server_Verify)SPExternalAlloc(cbCanonical);

        if (!pCanonical)
        {
            return(PCT_INT_INTERNAL_ERROR);
        }

        /* Begin Unpacking Client Hello */


        /* Pre-set all sizes */
        pCanonical->cbResponse = cbResponse;
        pCanonical->cbSigCert = cbSigCert;

        /* Start unpacking the variant data */
        pBuffer = pMessage->VariantData;
        /* Pointer to free memory in canonical */
        pCanonical->pCurUnpack = (PUCHAR)(pCanonical + 1);


        /* Unpack Encrypted Key */
        if(cbEncryptedKey) {
            pCanonical->pEncryptedKey = (PPct2_Encrypted_Key)pCanonical->pCurUnpack;
            pCanonical->pCurUnpack += Pct2UnpackEncryptedKey(pBuffer, pCanonical->pEncryptedKey);
            pBuffer += cbEncryptedKey;
        }

        /* Unpack Response */
        pCanonical->pResponse = pCanonical->pCurUnpack;
        CopyMemory(pCanonical->pResponse, pBuffer, cbResponse);
        pCanonical->pCurUnpack += cbResponse;
        pBuffer += cbResponse;

        pCanonical->SubState = 0;
        pCanonical->pSigCert = (PUCHAR)pCanonical->pCurUnpack;
    } else {
        pBuffer = (PUCHAR)(pHeader+1);
    }
    *ppServer = pCanonical;
    pInput->cbData = ReportedSize + sizeof(PCT2_RECORD_HEADER);

    /* Everything up to the certifier list is required to come in the first
     * message.  All of the following stuff could come split across records
     */
    i = min(pCanonical->cbSigCert - pCanonical->SubState,
            ReportedSize - (DWORD)(pBuffer - (PUCHAR)pHeader));

    CopyMemory(pCanonical->pCurUnpack, pBuffer, i);
    pCanonical->pCurUnpack += i;
    pBuffer += i;
    pCanonical->SubState += i;
    /* We've not yet finished unpacking */
    if(pCanonical->SubState < pCanonical->cbSigCert) return PCT_INT_NEXT_RECORD;
    return PCT_ERR_OK;
}


SP_STATUS
Pct2PackClientVerify(
    PPct2_Client_Verify    pCanonical,
    PSPBuffer              pCommOutput)
{
    DWORD               cbMessage;
    PPCT2_HS_MESSAGE_HEADER pHeader;
    PPCT2_CLIENT_VERIFY     pMessage;
    PUCHAR              pBuffer;

    DWORD               cbMessageSent;

    DWORD               cbCopied, iCopy;
    DWORD               Flags;

    /* Note, when packing messages that are longer than the max message length,
     * we break them into multiple records, and pack them all into one buffer
     */
    if(pCanonical == NULL || pCommOutput == NULL) return PCT_INT_INTERNAL_ERROR;
    pCommOutput->cbData = 0;



    cbMessageSent =  PCT_OFFSET_OF(PPCT2_CLIENT_VERIFY, VariantData) +
                    pCanonical->cbResponse;

    cbMessage = cbMessageSent +
                pCanonical->cbSigCert;


    /* The number of message headers should be equal to the number
     * of blocks we split the message into.
     */
    pCommOutput->cbData = cbMessage + sizeof(PPCT2_HS_MESSAGE_HEADER)*((cbMessage / PCT_MAX_SHAKE_LEN)+1);

    /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL) {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
            return PCT_INT_INTERNAL_ERROR;
        pCommOutput->cbBuffer = pCommOutput->cbData;
    }

    if(pCommOutput->cbData > pCommOutput->cbBuffer) return PCT_INT_BUFF_TOO_SMALL;


    pHeader = pCommOutput->pvBuffer;
    pMessage = (PPCT2_CLIENT_VERIFY)(pHeader+1);

    /* Build base portion of server hello message */
    pMessage->ResponseLenMsb = MSBOF(pCanonical->cbResponse);
    pMessage->ResponseLenLsb = LSBOF(pCanonical->cbResponse);
    pMessage->SigCertLenMsb = MSBOF(pCanonical->cbSigCert);
    pMessage->SigCertLenLsb = LSBOF(pCanonical->cbSigCert);


    pBuffer = pMessage->VariantData;
    CopyMemory(pBuffer, pCanonical->pResponse, pCanonical->cbResponse);

    pBuffer += pCanonical->cbResponse;


    /* Yeah, I know this looks wierd, but we should not have to do any Copies
     * to move data out of the way of an inline header if we do this */

    iCopy = 0;
    while(iCopy < pCanonical->cbSigCert) {

        cbCopied = min(pCanonical->cbSigCert-iCopy, (PCT_MAX_SHAKE_LEN-cbMessageSent));
        CopyMemory(pBuffer, pCanonical->pSigCert + iCopy, cbCopied);
        iCopy += cbCopied;
        pBuffer += iCopy;

        while(cbMessageSent >= PCT_MAX_SHAKE_LEN) {
            if(Flags & PCT2_HS_FLAG_TO_BE_CONTD) Flags = PCT2_HS_FLAG_CONTINUATION;
            else if(Flags == 0) Flags = PCT2_HS_FLAG_TO_BE_CONTD;
            RepackHsMessage(&cbMessageSent, &pHeader, &pBuffer, PCT2_HS_CLIENT_VERIFY, Flags);
        }

    }

    /* Finish up */
    RepackHsMessage(&cbMessageSent, &pHeader, &pBuffer, PCT2_HS_CLIENT_VERIFY, Flags);


    return( PCT_ERR_OK );

}


SP_STATUS
Pct2UnpackClientVerify(
    PSPBuffer                pInput,
    PPct2_Client_Verify*     ppClient)
{

    PPCT2_HS_MESSAGE_HEADER   pHeader;
    PPCT2_CLIENT_VERIFY   pMessage;

    DWORD               ReportedSize;
    DWORD               cbSigCert, cbResponse;


    PPct2_Client_Verify  pCanonical;
    PUCHAR              pBuffer;
    DWORD               i;
    DWORD               cbCanonical;

    DWORD               dwRecordFlags;
    pHeader = pInput->pvBuffer;

    if(pInput->cbBuffer < sizeof(PCT2_HS_MESSAGE_HEADER)) {
        return PCT_INT_INCOMPLETE_MSG;
    }

    /* BUGBUG: Right now, we're not dealing with record spanning server
     * hello's */

    ReportedSize = SIZEOF(pHeader);

    if ((ReportedSize+sizeof(PCT2_HS_MESSAGE_HEADER)) > pInput->cbBuffer)
    {
        return PCT_INT_INCOMPLETE_MSG;
    }

    dwRecordFlags = COMBINEBYTES(pHeader->RecordFlagsMsb, pHeader->RecordFlagsLsb);
    /* Only create a new ClientHello canonical if this is a complete
     * message, or the first message in a completion string */

    if(!(dwRecordFlags & PCT2_HS_FLAG_CONTINUATION)) {

        if(ReportedSize < PCT_OFFSET_OF(PPCT2_CLIENT_VERIFY, VariantData))
        {
            return PCT_ERR_ILLEGAL_MESSAGE;
        }
        /* Now start validating the message */
        pMessage = (PPCT2_CLIENT_VERIFY)(pHeader+1);

        if(COMBINEBYTES(pHeader->MessageTypeMsb, pHeader->MessageTypeLsb) !=
           PCT2_HS_SERVER_VERIFY)
        {
            return PCT_ERR_ILLEGAL_MESSAGE;
        }



        *ppClient = NULL;



        cbResponse =          COMBINEBYTES( pMessage->ResponseLenMsb,
                                            pMessage->ResponseLenLsb);

        cbSigCert =           COMBINEBYTES( pMessage->SigCertLenMsb,
                                            pMessage->SigCertLenLsb);




        cbCanonical =  sizeof(Pct2_Client_Verify) +
                       cbResponse +
                       cbSigCert;


        /* Allocate a buffer for the canonical client hello */
        pCanonical = (PPct2_Client_Verify)SPExternalAlloc(cbCanonical);

        if (!pCanonical)
        {
            return(PCT_INT_INTERNAL_ERROR);
        }

        /* Begin Unpacking Client Hello */


        /* Pre-set all sizes */
        pCanonical->cbResponse = cbResponse;
        pCanonical->cbSigCert = cbSigCert;

        /* Start unpacking the variant data */
        pBuffer = pMessage->VariantData;
        /* Pointer to free memory in canonical */
        pCanonical->pCurUnpack = (PUCHAR)(pCanonical + 1);



        /* Unpack Response */
        pCanonical->pResponse = pCanonical->pCurUnpack;
        CopyMemory(pCanonical->pResponse, pBuffer, cbResponse);
        pCanonical->pCurUnpack += cbResponse;
        pBuffer += cbResponse;

        pCanonical->SubState = 0;
        pCanonical->pSigCert = (PUCHAR)pCanonical->pCurUnpack;
    } else {
        pBuffer = (PUCHAR)(pHeader+1);
    }
    *ppClient = pCanonical;
    pInput->cbData = ReportedSize + sizeof(PCT2_RECORD_HEADER);

    /* Everything up to the certifier list is required to come in the first
     * message.  All of the following stuff could come split across records
     */
    i = min(pCanonical->cbSigCert - pCanonical->SubState,
            ReportedSize - (DWORD)(pBuffer - (PUCHAR)pHeader));

    CopyMemory(pCanonical->pCurUnpack, pBuffer, i);
    pCanonical->pCurUnpack += i;
    pBuffer += i;
    pCanonical->SubState += i;
    /* We've not yet finished unpacking */
    if(pCanonical->SubState < pCanonical->cbSigCert) return PCT_INT_NEXT_RECORD;
    return PCT_ERR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\schnlsp.h ===
/*++

Copyright (c) 1992-2000 Microsoft Corporation.  All rights reserved.

Module Name: schnlsp.h

Purpose: Prototypes and structures for schannel security provider.

--*/

#ifndef __SCHNLSP_H__
#define __SCHNLSP_H__

#include <wincrypt.h>
#include <sslsock.h>

#define SSLOLD_NAME_A "Microsoft SSL"
#define SSLOLD_NAME_W L"Microsoft SSL"
#define PCTOLD_NAME_A "Microsoft PCT"
#define PCTOLD_NAME_W L"Microsoft PCT"

#define UNISP_NAME_A    "Microsoft Unified Security Protocol Provider"
#define UNISP_NAME_W    L"Microsoft Unified Security Protocol Provider"

#define SSL2SP_NAME_A    "Microsoft SSL 2.0"
#define SSL2SP_NAME_W    L"Microsoft SSL 2.0"

#define SSL3SP_NAME_A    "Microsoft SSL 3.0"
#define SSL3SP_NAME_W    L"Microsoft SSL 3.0"

#define PCT1SP_NAME_A    "Microsoft PCT 1.0"
#define PCT1SP_NAME_W    L"Microsoft PCT 1.0"


#ifdef UNICODE
#define SSLOLD_NAME  SSLOLD_NAME_W
#define PCTOLD_NAME  PCTOLD_NAME_W
#define UNISP_NAME   UNISP_NAME_W
#define PCT1SP_NAME  PCT1SP_NAME_W
#define SSL2SP_NAME  SSL2SP_NAME_W
#define SSL3SP_NAME  SSL3SP_NAME_W

#else
#define SSLOLD_NAME  SSLOLD_NAME_A
#define PCTOLD_NAME  PCTOLD_NAME_A
#define UNISP_NAME  UNISP_NAME_A
#define PCT1SP_NAME  PCT1SP_NAME_A
#define SSL2SP_NAME  SSL2SP_NAME_A
#define SSL3SP_NAME  SSL3SP_NAME_A

#endif

#define SSL2SP_RPC_ID   12
#define PCT1SP_RPC_ID   13
#define SSL3SP_RPC_ID   14
#define UNISP_RPC_ID    15


#define SCH_CRED_V1      0x00000001
#define SCH_CRED_VERSION 0x00000002

#define SCHANNEL_SECRET_TYPE_CAPI       0x00000001
#define SCHANNEL_SECRET_PRIVKEY         0x00000002
#define SCHANNEL_SECRET_TYPE_WINSOCK2   0x00000003

#define SCH_CRED_X509_CERTCHAIN   0x00000001
#define SCH_CRED_X509_CAPI        0x00000002
/*
 * WinSock2 Secret Credential
 * Points to a set of callback functions.
 */
typedef struct _SCH_CRED_SECRET_WINSOCK2
{
    DWORD dwType; // SCHANNEL_SECRET_TYPE_WINSOCK2

    // Key exchange hook.
    SSLKEYEXCHANGEFUNC pKeyExchangeHookFunc;
    LPVOID pKeyExchangeHookArg;

    // Signature hook.
    SSLSIGNATUREFUNC pSignatureHookFunc;
    LPVOID pSignatureHookArg;
} SCH_CRED_SECRET_WINSOCK2, * PSCH_CRED_SECRET_WINSOCK2;


//
// QueryCredentialsAttribute extensions.
//

#define SECPKG_ATTR_SUPPORTED_PROTOCOLS  0x58  // returns SecPkgCred_SupportedProtocols

typedef struct _SecPkgCred_SupportedProtocols
{
    DWORD       grbitProtocol;
} SecPkgCred_SupportedProtocols, *PSecPkgCred_SupportedProtocols;


/*
 * CAPI Secret Credential
 * Points to a pre-initialized Capi Provider handle
 */
typedef struct _SCH_CRED_SECRET_CAPI
{
    DWORD           dwType;      // SCHANNEL_SECRET_TYPE_CAPI
    HCRYPTPROV      hProv;       // credential secret information.

} SCH_CRED_SECRET_CAPI, * PSCH_CRED_SECRET_CAPI;


/*
 * Private Key Secret Credential
 * Contains a potentially encrypted private key in DER
 * format, and a password to crack the key.
 */
typedef struct _SCH_CRED_SECRET_PRIVKEY
{
    DWORD           dwType;       // SCHANNEL_SECRET_PRIVKEY
    PBYTE           pPrivateKey;   // Der encoded private key
    DWORD           cbPrivateKey;
    PSTR            pszPassword;  // Password to crack the private key.

} SCH_CRED_SECRET_PRIVKEY, * PSCH_CRED_SECRET_PRIVKEY;


/*
 * Public Cert Chain Credential
 * DER encoded chain of certificates, with
 * the leaf certificate corresponding to the
 * Secret credential
 */
typedef struct _SCH_CRED_PUBLIC_CERTCHAIN
{
    DWORD       dwType;
    DWORD       cbCertChain;
    PBYTE       pCertChain;
}SCH_CRED_PUBLIC_CERTCHAIN, *PSCH_CRED_PUBLIC_CERTCHAIN;

struct _HMAPPER;

typedef struct _SCH_CRED
{
    DWORD     dwVersion;          // always SCH_CRED_VERSION.
    DWORD     cCreds;             // Number of credentials.
    PVOID     *paSecret;          // Array of SCH_CRED_SECRET_* pointers
    PVOID     *paPublic;          // Array of SCH_CRED_PUBLIC_* pointers
    DWORD     cMappers;           // Number of credential mappers.
    struct _HMAPPER **aphMappers; // pointer to an array of pointers to credential mappers
} SCH_CRED, * PSCH_CRED;




/*
 * QueryContextAttributes extensions
 */

#ifndef SECPKG_ATTR_ISSUER_LIST

#define SECPKG_ATTR_ISSUER_LIST  0x50
#define SECPKG_ATTR_REMOTE_CRED  0x51

typedef struct _SecPkgContext_IssuerListInfo
{
    DWORD   cbIssuerList;
    PBYTE   pIssuerList;
}SecPkgContext_IssuerListInfo, *PSecPkgContext_IssuerListInfo;

typedef struct _SecPkgContext_RemoteCredentialInfo
{
    DWORD   cbCertificateChain;     // count of bytes in cert chain buffer.
    PBYTE   pbCertificateChain;     // DER encoded chain of certificates, leaf cert first.
    DWORD   cCertificates;
    DWORD   fFlags;
    DWORD   dwBits;                 // Number of bits in the remote credentials
}SecPkgContext_RemoteCredentialInfo, *PSecPkgContext_RemoteCredentialInfo;

#define SecPkgContext_RemoteCredenitalInfo  SecPkgContext_RemoteCredentialInfo
#define PSecPkgContext_RemoteCredenitalInfo PSecPkgContext_RemoteCredentialInfo

#endif

#define SECPKG_ATTR_LOCAL_CRED   0x52

typedef struct _SecPkgContext_LocalCredentialInfo
{
    DWORD   cbCertificateChain;     // count of bytes in cert chain buffer.
    PBYTE   pbCertificateChain;     // DER encoded chain of certificates, leaf cert first.
    DWORD   cCertificates;
    DWORD   fFlags;
    DWORD   dwBits;                 // Number of bits in the remote credentials.
} SecPkgContext_LocalCredentialInfo, *PSecPkgContext_LocalCredentialInfo;

#define SecPkgContext_LocalCredenitalInfo  SecPkgContext_LocalCredentialInfo
#define PSecPkgContext_LocalCredenitalInfo PSecPkgContext_LocalCredentialInfo


// The following two attributes return
// a PCCERT_CONTEXT
#define SECPKG_ATTR_REMOTE_CERT_CONTEXT 0x53
#define SECPKG_ATTR_LOCAL_CERT_CONTEXT  0x54
#define SECPKG_ATTR_ROOT_STORE          0x55 // returns HCERTCONTEXT to the root store

typedef struct _PctPublicKey
{
    DWORD Type;
    DWORD cbKey;
    UCHAR pKey[1];
} PctPublicKey;

typedef struct _X509Certificate {
    DWORD           Version;
    DWORD           SerialNumber[4];
    ALG_ID          SignatureAlgorithm;
    FILETIME         ValidFrom;
    FILETIME          ValidUntil;
    PSTR            pszIssuer;
    PSTR            pszSubject;
    PctPublicKey    *pPublicKey;
} X509Certificate, * PX509Certificate;



#define RCRED_STATUS_NOCRED          0x00000000
#define RCRED_CRED_EXISTS            0x00000001
#define RCRED_STATUS_UNKNOWN_ISSUER  0x00000002    // The last cert in this chain has
                                                   // an issuer that is unknown to us.

#define LCRED_STATUS_NOCRED          0x00000000
#define LCRED_CRED_EXISTS            0x00000001
#define LCRED_STATUS_UNKNOWN_ISSUER  0x00000002    // The last cert in this chain has
                                                   // an issuer that is unknown to us.
//
// QueryContextAttributes extension.
//

#define SECPKG_ATTR_CONNECTION_INFO 0x5a // returns SecPkgContext_ConnectionInfo

typedef struct _SecPkgContext_ConnectionInfo
{
    DWORD dwProtocol;
    ALG_ID   aiCipher;
    DWORD    dwCipherStrength;
    ALG_ID   aiHash;
    DWORD    dwHashStrength;
    ALG_ID   aiExch;
    DWORD    dwExchStrength;
}SecPkgContext_ConnectionInfo, *PSecPkgContext_ConnectionInfo;

//
// MessageId: SEC_I_INCOMPLETE_CREDENTIALS
//
// MessageText:
//
//  If this is returned from InitializeSecurityContext, it indicates
//  that the credentials supplied were incomplete, and client-auth was
//  attempted.  On receipt, the client should call QueryContextAttributes
//  with SECPKG_ATTR_LOCAL_CERT to get the cert that was negotiated,
//  and the supply the private key with this cert to AcquireCredential
//  to get a new credential.  The context should then be closed,
//  and renegotiation should be completed.
//
//
#ifndef SEC_I_INCOMPLETE_CREDENTIALS
#define SEC_I_INCOMPLETE_CREDENTIALS      ((HRESULT)0x00090320L)
#endif

#ifndef SEC_E_INCOMPLETE_CREDENTIALS
#define SEC_E_INCOMPLETE_CREDENTIALS      ((HRESULT)0x80090320L)
#endif


//
// MessageId: SEC_I_RENEGOTIATE
//
// MessageText:
//
// This is returned by UnsealMessage, and indicates that the app should
// restart the renegotiation loop.  It should use the existing context, and
// pass in no data in the input buffers for the first call to AcceptSecurityContext
// or InitializeSecurityContext.
//
#ifndef SEC_I_RENEGOTIATE
#define SEC_I_RENEGOTIATE            ((HRESULT)0x00090321L)
#endif



#define NETWORK_DREP    0x00000000



// Structures for compatability with the old
// SCHANNEL cred interface.

typedef struct _SSL_CREDENTIAL_CERTIFICATE {
    DWORD   cbPrivateKey;
    PBYTE   pPrivateKey;
    DWORD   cbCertificate;
    PBYTE   pCertificate;
    PSTR    pszPassword;
} SSL_CREDENTIAL_CERTIFICATE, * PSSL_CREDENTIAL_CERTIFICATE;



BOOL
WINAPI
SslGenerateKeyPair(
    PSSL_CREDENTIAL_CERTIFICATE pCerts,
    PSTR pszDN,
    PSTR pszPassword,
    DWORD Bits );


VOID
WINAPI
SslGenerateRandomBits(
    PUCHAR      pRandomData,
    LONG        cRandomData
    );


BOOL
WINAPI
SslCrackCertificate(
    PUCHAR              pbCertificate,
    DWORD               cbCertificate,
    DWORD               dwFlags,
    PX509Certificate *  ppCertificate
    );


VOID
WINAPI
SslFreeCertificate(
    PX509Certificate    pCertificate
    );

BOOL
WINAPI
SslGetDefaultIssuers(
    PBYTE pbIssuers,
    DWORD *pcbIssuers);

#define SSL_CRACK_CERTIFICATE_NAME  TEXT("SslCrackCertificate")
#define SSL_FREE_CERTIFICATE_NAME   TEXT("SslFreeCertificate")

typedef BOOL
(WINAPI * SSL_CRACK_CERTIFICATE_FN)
(
    PUCHAR              pbCertificate,
    DWORD               cbCertificate,
    BOOL                VerifySignature,
    PX509Certificate *  ppCertificate
);


typedef VOID
(WINAPI * SSL_FREE_CERTIFICATE_FN)
(
    PX509Certificate    pCertificate
);

#define SSL_SET_PROTOCOLS_NAME TEXT("SslSetProtocols")
#define SSL_GET_PROTOCOLS_NAME TEXT("SslGetProtocols")

typedef BOOL
(WINAPI * SSL_SET_PROTOCOLS_FN)(
    DWORD rgbitsProtocols
    );

typedef DWORD
(WINAPI * SSL_GET_PROTOCOLS_FN)();

BOOL
WINAPI
SslSetProtocols(
    DWORD rgbitsProtocols
    );

DWORD
WINAPI
SslGetProtocols();

#endif //__SCHNLSP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\shacomm.h ===
/* Copyright (C) RSA Data Security, Inc. created 1993.  This is an
   unpublished work protected as such under copyright law.  This work
   contains proprietary, confidential, and trade secret information of
   RSA Data Security, Inc.  Use, disclosure or reproduction without the
   express written authorization of RSA Data Security, Inc. is
   prohibited.
 */

#ifndef _SHACOMM_H_
#define _SHACOMM_H_ 1

#define A_SHA_DIGEST_LEN 20

typedef struct {
  DWORD state[5];                                           /* state (ABCDE) */
  DWORD count[2];                              /* number of bytes, msb first */
  unsigned char buffer[64];                                  /* input buffer */
} A_SHA_COMM_CTX;

typedef void (A_SHA_TRANSFORM) (DWORD [5], unsigned char [64]);

void A_SHAInitCommon (A_SHA_COMM_CTX *);
void A_SHAUpdateCommon(A_SHA_COMM_CTX *, BYTE *, DWORD, A_SHA_TRANSFORM *);
void A_SHAFinalCommon(A_SHA_COMM_CTX *, BYTE[A_SHA_DIGEST_LEN],
		      A_SHA_TRANSFORM *);

void DWORDToBigEndian(unsigned char *, DWORD *, unsigned int);
void DWORDFromBigEndian(DWORD *, unsigned int, unsigned char *);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\sign.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       sign.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-30-95   TerenceS      created
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <security.h>
#include "spsspi.h"


BOOL 
PctSign(PSPContext        pContext,
        PUCHAR            pData,
        DWORD             dwDataLen,
        PUCHAR            pOutBuf,
        DWORD            *dwBufLen)
{
        if (*dwBufLen < dwDataLen)
        {
                *dwBufLen = dwDataLen;
                return FALSE;
        }
        *dwBufLen = dwDataLen;

        CopyMemory(pOutBuf, pData, dwDataLen);

        return TRUE;
}

BOOL PctVerifySign(PSPContext  pContext,
                   PVOID                pCert,
                   PUCHAR               pSigData,
                   DWORD                dwSigLen)
{
        // get public key from certificate

        // verify signature with public key

        return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\sigmsrsa.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------
* RSA Public Key Cryptosystem, RC4, MD2, MD5 and RSA are trademarks
* of RSA Data Security, Inc.
*----------------------------------------------------------------------------*/

#include <spbase.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <rsa.h>
#include <md2.h>
#include <md5.h>
#include <sha.h>


#ifdef __cplusplus
}
#endif

static unsigned char SHA_PRELUDE[] = {
  0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a,
  0x05, 0x00, 0x04, 0x14
};

static unsigned char MD5_PRELUDE[] = {
  0x30, 0x20, 0x30, 0x0c, 0x06, 0x08, 0x2a, 0x86, 0x48, 0x86, 0xf7,
  0x0d, 0x02, 0x05, 0x05, 0x00, 0x04, 0x10
};

static unsigned char MD2_PRELUDE[] = {
  0x30, 0x20, 0x30, 0x0c, 0x06, 0x08, 0x2a, 0x86, 0x48, 0x86, 0xf7,
  0x0d, 0x02, 0x02, 0x05, 0x00, 0x04, 0x10
};

static VOID
ReverseMemCopy(
    PUCHAR      Dest,
    PUCHAR      Source,
    ULONG       Size)
{
    PUCHAR  p;

    p = Dest + Size - 1;
    do
    {
        *p-- = *Source++;
    } while (p >= Dest);
}

BOOL
WINAPI
SigRSASHASign(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           *pcbSigned,
    PctPrivateKey    *pKey);
BOOL
WINAPI SigRSASHAVerify(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           cbSigned,
    PctPublicKey    *pKey);

BOOL
WINAPI
SigRSAMD2Sign(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           *pcbSigned,
    PctPrivateKey    *pKey);

BOOL
WINAPI
SigRSAMD5Sign(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           *pcbSigned,
    PctPrivateKey    *pKey);

BOOL
WINAPI SigRSASHAMD5Sign(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           *pcbSigned,
    PctPrivateKey    *pKey);

BOOL
WINAPI SigRSAMD2Verify(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           cbSigned,
    PctPublicKey    *pKey);

BOOL
WINAPI SigRSAMD5Verify(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           cbSigned,
    PctPublicKey    *pKey);

BOOL
WINAPI SigRSASHAMD5Verify(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           cbSigned,
    PctPublicKey    *pKey);


#ifdef UNDER_CE
#define CRYPT_CREATE_HASH_NAME      TEXT("CryptCreateHash")
#define CRYPT_HASH_DATA_NAME        TEXT("CryptHashData")
#define CRYPT_SIGN_HASH_NAMEA       TEXT("CryptSignHashA")
#define CRYPT_SIGN_HASH_NAMEW       TEXT("CryptSignHashW")
#define CRYPT_DESTROY_HASH_NAME     TEXT("CryptDestroyHash")
#define CRYPT_SET_HASH_PARAM_NAME   TEXT("CryptSetHashParam")
#else
// NT wants a LPCSTR for GetProcAddress
#define CRYPT_CREATE_HASH_NAME      "CryptCreateHash"
#define CRYPT_HASH_DATA_NAME        "CryptHashData"
#define CRYPT_SIGN_HASH_NAMEA       "CryptSignHashA"
#define CRYPT_SIGN_HASH_NAMEW       "CryptSignHashW"
#define CRYPT_DESTROY_HASH_NAME     "CryptDestroyHash"
#define CRYPT_SET_HASH_PARAM_NAME   "CryptSetHashParam"
#endif // UNDER_CE


typedef BOOL
( WINAPI * CRYPT_CREATE_HASH_FN)(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTKEY hKey,
    DWORD dwFlags,
    HCRYPTHASH *phHash);


typedef BOOL
( WINAPI * CRYPT_HASH_DATA_FN)(
    HCRYPTHASH hHash,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    DWORD dwFlags);

typedef BOOL
( WINAPI * CRYPT_DESTROY_HASH_FN) (
    HCRYPTHASH hHash);

typedef BOOL
( WINAPI * CRYPT_SIGN_HASH_FNA)(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen);

typedef BOOL
( WINAPI * CRYPT_SIGN_HASH_FNW)(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen);

typedef BOOL
( WINAPI * CRYPT_SET_HASH_PARAM_FN)(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags);


HINSTANCE               g_hCoredll; //          = NULL;
CRYPT_CREATE_HASH_FN    g_CryptCreateHash; //   = NULL;
CRYPT_HASH_DATA_FN      g_CryptHashData; //     = NULL;
CRYPT_DESTROY_HASH_FN   g_CryptDestroyHash; //  = NULL;
CRYPT_SIGN_HASH_FNA     g_CryptSignHashA; //    = NULL;
CRYPT_SIGN_HASH_FNW     g_CryptSignHashW; //    = NULL;
CRYPT_SET_HASH_PARAM_FN g_CryptSetHashParam; // = NULL;


const SignatureSystem sigRSAMD2 = { SP_SIG_RSA_MD2, SigRSAMD2Sign, SigRSAMD2Verify};
const SignatureSystem sigRSAMD5 = { SP_SIG_RSA_MD5, SigRSAMD5Sign, SigRSAMD5Verify};
const SignatureSystem sigRSASHA = { SP_SIG_RSA_SHA, SigRSASHASign, SigRSASHAVerify};
const SignatureSystem sigRSASHAMD5 = { SP_SIG_RSA_SHAMD5, SigRSASHAMD5Sign, SigRSASHAMD5Verify};


BOOL
WINAPI capiCryptCreateHash(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTKEY hKey,
    DWORD dwFlags,
    HCRYPTHASH *phHash)
{
    if(!g_CryptCreateHash)
    {
        g_CryptCreateHash = &CryptCreateHash;
        if(!g_CryptCreateHash)
        {
            return FALSE;
        }
    }
    return g_CryptCreateHash(hProv, Algid, hKey, dwFlags, phHash);
}


BOOL
WINAPI capiCryptHashData(
    HCRYPTHASH hHash,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    DWORD dwFlags)
{
    if(!g_CryptHashData)
    {
        g_CryptHashData = &CryptHashData;
        if(!g_CryptHashData)
        {
            return FALSE;
        }
    }
    return g_CryptHashData(hHash, pbData, dwDataLen, dwFlags);
}


BOOL
WINAPI capiCryptDestroyHash(
    HCRYPTHASH hHash)
{
    if(!g_CryptDestroyHash)
    {
        g_CryptDestroyHash = &CryptDestroyHash;
        if(!g_CryptDestroyHash)
        {
            return FALSE;
        }
    }
    return g_CryptDestroyHash(hHash);
}

#ifndef XBOX
BOOL
WINAPI capiCryptSignHashA(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen)
{
    if(!g_CryptSignHashA)
    {
        g_CryptSignHashA = &CryptSignHashA;
        if(!g_CryptSignHashA)
        {
            return FALSE;
        }
    }
    return g_CryptSignHashA(hHash, dwKeySpec, sDescription, dwFlags, pbSignature, pdwSigLen);
}
#endif

BOOL
WINAPI capiCryptSignHashW(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen)
{
    if(!g_CryptSignHashW)
    {
        g_CryptSignHashW = &CryptSignHashW;
        if(!g_CryptSignHashW)
        {
            return FALSE;
        }
    }
    return g_CryptSignHashW(hHash, dwKeySpec, sDescription, dwFlags, pbSignature, pdwSigLen);
}

BOOL
WINAPI capiCryptSetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags)
{
    if(!g_CryptSetHashParam)
    {
        g_CryptSetHashParam = &CryptSetHashParam;
        if(!g_CryptSetHashParam)
        {
            return FALSE;
        }
    }
    return g_CryptSetHashParam(hHash, dwParam, pbData, dwFlags);
}

#ifdef UNICODE
#define capiCryptSignHash  capiCryptSignHashW
#else
#define capiCryptSignHash  capiCryptSignHashA
#endif // !UNICODE



BOOL
WINAPI
SigRSASHAVerify(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           cbSigned,
    PctPublicKey    *pKey)
{
    A_SHA_CTX DigCtx;
    BSAFE_PUB_KEY *pk = (BSAFE_PUB_KEY *)pKey->pKey;
    UCHAR Buffer[500];
    UCHAR SigBuffer[500];
    DWORD iLoc;

    if(pk->datalen > sizeof(Buffer) || cbSigned != pk->datalen+1)
    {
        return FALSE;
    }


    FillMemory(SigBuffer, pk->keylen, 0);
    FillMemory(Buffer, pk->keylen, 0);

    ReverseMemCopy(SigBuffer, pSigned, cbSigned);

    if(!BSafeEncPublic(pk, SigBuffer, Buffer))
    {
        return FALSE;
    }

    ReverseMemCopy(SigBuffer, Buffer, cbSigned);

    /* Make sure pkcs block type 1 */
    if(SigBuffer[0] != 0 || SigBuffer[1] != 1)
    {
        return FALSE;
    }

    for(iLoc = 2; iLoc < pk->datalen; iLoc++ ){
        if(!SigBuffer[iLoc])
        {
            break;
        }
        if(SigBuffer[iLoc] != 0xff)
        {
            return FALSE;
        }
    }

    if(iLoc == pk->datalen) return FALSE;

    iLoc++; /* skip past separator */


    if(memcmp(&SigBuffer[iLoc], SHA_PRELUDE, sizeof(SHA_PRELUDE))   != 0)
    {
        return FALSE;
    }

    iLoc += sizeof(SHA_PRELUDE);
    A_SHAInit(&DigCtx);
    A_SHAUpdate(&DigCtx, pData, cbData);
    A_SHAFinal(&DigCtx,&Buffer[0]);
    if(memcmp(&SigBuffer[iLoc],  &Buffer[0], A_SHA_DIGEST_LEN) != 0)
    {
        return FALSE;
    }

    return TRUE;
}

BOOL
WINAPI
SigRSASHASign(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           *pcbSigned,
    PctPrivateKey    *pKey)
{
    // dont need the signing if client certification is not supported
    // DBGCHK(TEXT("SCHANNEL"),0);
    return FALSE;
    
}

BOOL
WINAPI
SigRSAMD5Sign(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           *pcbSigned,
    PctPrivateKey    *pKey)
{
    MD5_CTX DigCtx;
    BSAFE_PRV_KEY *pk = (BSAFE_PRV_KEY *)pKey->pKey;
    UCHAR LocalBuffer[300];
    UCHAR LocalOutput[300];

    unsigned int cbSize;

    if(pk->magic != RSA2 && pKey->cbKey == sizeof(HCRYPTPROV))
    {
        // This isn't a bsafe key, and it's the right size, so it must
        // be a CAPI key. BUGBUG - is this a hack, or is this a hack?
        HCRYPTHASH hHash;
        DWORD cbSigned;
        HCRYPTPROV hProv = *((HCRYPTPROV *)pKey->pKey);

        if(!capiCryptCreateHash(hProv, CALG_MD5, 0, 0, &hHash))
        {
            return FALSE;
        }
        if(!capiCryptHashData(hHash, pData, cbData, 0))
        {
            capiCryptDestroyHash(hHash);
            return FALSE;
        }
        cbSigned = sizeof(LocalOutput);

        if(!capiCryptSignHash(hHash, AT_KEYEXCHANGE, NULL, 0, LocalOutput, &cbSigned))
        {
            capiCryptDestroyHash(hHash);
            return FALSE;
        }
        capiCryptDestroyHash(hHash);
        ReverseMemCopy(pSigned, LocalOutput, cbSigned);
        *pcbSigned = cbSigned;
        return TRUE;
    }
    else if(pk->magic != RSA2)
    {
        // This isn't a bsafe key or a CAPI key, so it must be a WinSock 2
        // LSP key.
        SSLSIGNATUREFUNC pSignHook;
        LPVOID pSignArg;

        /* Generate the checksum */
        MD5Init(&DigCtx);
        MD5Update(&DigCtx, pData, cbData);
        MD5Final(&DigCtx);

        // Get the prelude data and the hash value.
        memcpy(LocalBuffer, MD5_PRELUDE, sizeof(MD5_PRELUDE));
        memcpy(LocalBuffer + sizeof(MD5_PRELUDE), DigCtx.digest, MD5DIGESTLEN);

        // Get pointer to callback function.
        pSignHook = ((PSCH_CRED_SECRET_WINSOCK2)pKey->pKey)->pSignatureHookFunc;
        pSignArg  = ((PSCH_CRED_SECRET_WINSOCK2)pKey->pKey)->pSignatureHookArg;

        // Invoke the callback function.
        if(pSignHook(SSL_SIGN_RSA_MD5,
                     pSignArg,
                     LocalBuffer,
                     sizeof(MD5_PRELUDE) + MD5DIGESTLEN,
                     SSL_SIGN_PERFORM_HASH,
                     pSigned,
                     pcbSigned) != SSL_ERR_OKAY)
        {
            return FALSE;
        }

        // Return success.
        return TRUE;
    }

    cbSize = sizeof(MD5_PRELUDE)+16;
    if(pk->datalen > sizeof(LocalBuffer))
    {
        return FALSE;
    }

    /* Generate the checksum */
    MD5Init(&DigCtx);
    MD5Update(&DigCtx, pData, cbData);
    MD5Final(&DigCtx);

    FillMemory(LocalBuffer, pk->keylen, 0);

    ReverseMemCopy(LocalBuffer, DigCtx.digest, 16);
    ReverseMemCopy(LocalBuffer+16, MD5_PRELUDE, sizeof(MD5_PRELUDE));
    LocalBuffer[cbSize++]=0;
    while(cbSize < pk->datalen-1) {
        LocalBuffer[cbSize++] = 0xff;
    }

    /* Make into pkcs block type 1 */
    LocalBuffer[pk->datalen-1] = 1;

    *pcbSigned = pk->datalen+1;

    if(!BSafeDecPrivate(pk, LocalBuffer, LocalOutput))
    {
        return FALSE;
    }
    ReverseMemCopy(pSigned, LocalOutput,  *pcbSigned);
    return TRUE;
}

BOOL
WINAPI
SigRSAMD2Sign(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           *pcbSigned,
    PctPrivateKey    *pKey)
{
    MD2_CTX DigCtx;
    BSAFE_PRV_KEY *pk = (BSAFE_PRV_KEY *)pKey->pKey;
    UCHAR LocalBuffer[500];
    UCHAR LocalOutput[500];

    unsigned int cbSize;
    if(pk->magic != RSA2)
    {
        // This is not a bsafe key, so it must be a CAPI
        // key.
        HCRYPTHASH hHash;
        DWORD cbSigned;
        HCRYPTPROV hProv = *((HCRYPTPROV *)pKey->pKey);

        if(!capiCryptCreateHash(hProv, CALG_MD2, 0, 0, &hHash))
        {
            return FALSE;
        }
        if(!capiCryptHashData(hHash, pData, cbData, 0))
        {
            capiCryptDestroyHash(hHash);
            return FALSE;
        }
        cbSigned = sizeof(LocalOutput);
        if(!capiCryptSignHash(hHash, AT_KEYEXCHANGE, NULL, 0, LocalOutput, &cbSigned))
        {
            capiCryptDestroyHash(hHash);
            return FALSE;
        }
        capiCryptDestroyHash(hHash);
        ReverseMemCopy(pSigned, LocalOutput, cbSigned);
        *pcbSigned = cbSigned;
        return TRUE;
    }


    cbSize = sizeof(MD2_PRELUDE)+16;
    if(pk->datalen > sizeof(LocalBuffer))
    {
        return FALSE;
    }

    //MD2Init(&DigCtx);
    FillMemory( &DigCtx, sizeof( DigCtx ), 0 );

    MD2Update(&DigCtx, pData, cbData);
    MD2Final(&DigCtx);
    FillMemory(LocalBuffer, pk->keylen, 0);
    ReverseMemCopy(LocalBuffer, DigCtx.state, 16);
    ReverseMemCopy(LocalBuffer+16, MD2_PRELUDE, sizeof(MD2_PRELUDE));
    LocalBuffer[cbSize++]=0;
    while(cbSize < pk->datalen-1) {
        LocalBuffer[cbSize++] = 0xff;
    }

    /* Make into pkcs block type 1 */
    LocalBuffer[pk->datalen-1] = 1;

    *pcbSigned = pk->datalen+1;

    if(!BSafeDecPrivate(pk, LocalBuffer, LocalOutput))
    {
        return FALSE;
    }
    ReverseMemCopy(pSigned, LocalOutput,  *pcbSigned);
    return TRUE;
}


BOOL
WINAPI
SigRSAMD5Verify(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           cbSigned,
    PctPublicKey    *pKey)
{
    MD5_CTX DigCtx;
    BSAFE_PUB_KEY *pk = (BSAFE_PUB_KEY *)pKey->pKey;
    UCHAR Buffer[500];
    UCHAR SigBuffer[500];
    DWORD iLoc;

    if(pk->datalen > sizeof(Buffer) || cbSigned != pk->datalen+1)
    {
        return FALSE;
    }

    MD5Init(&DigCtx);
    MD5Update(&DigCtx, pData, cbData);
    MD5Final(&DigCtx);

    FillMemory(SigBuffer, pk->keylen, 0);
    FillMemory(Buffer, pk->keylen, 0);

    ReverseMemCopy(SigBuffer, pSigned, cbSigned);

    if(!BSafeEncPublic(pk, SigBuffer, Buffer))
    {
        return FALSE;
    }

    ReverseMemCopy(SigBuffer, Buffer, cbSigned);

    /* Make sure pkcs block type 1 */
    if(SigBuffer[0] != 0 || SigBuffer[1] != 1)
    {
        return FALSE;
    }

    for(iLoc = 2; iLoc < pk->datalen; iLoc++ ){
        if(!SigBuffer[iLoc])
        {
            break;
        }
        if(SigBuffer[iLoc] != 0xff)
        {
            return FALSE;
        }
    }

    if(iLoc == pk->datalen) return FALSE;

    iLoc++; /* skip past separator */


    if(memcmp(&SigBuffer[iLoc], MD5_PRELUDE, sizeof(MD5_PRELUDE))   != 0)
    {
        return FALSE;
    }

    iLoc += sizeof(MD5_PRELUDE);
    if(memcmp(&SigBuffer[iLoc],  DigCtx.digest, 16) != 0)
    {
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
SigRSAMD2Verify(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           cbSigned,
    PctPublicKey    *pKey)
{
    MD2_CTX DigCtx;
    BSAFE_PUB_KEY *pk = (BSAFE_PUB_KEY *)pKey->pKey;
    UCHAR Buffer[500];
    UCHAR SigBuffer[500];
    DWORD iLoc;

    if ((pk->datalen > sizeof(Buffer)) ||
        (cbSigned != pk->datalen + 1))
    {
        return FALSE;
    }

    // MD2Init(&DigCtx);

    FillMemory( &DigCtx, sizeof( DigCtx ), 0 );

    MD2Update(&DigCtx, pData, cbData);

    MD2Final(&DigCtx);

    FillMemory(SigBuffer, pk->keylen, 0);
    FillMemory(Buffer, pk->keylen, 0);

    ReverseMemCopy(SigBuffer, pSigned, cbSigned);

    if(!BSafeEncPublic(pk, SigBuffer, Buffer))
    {
        return FALSE;
    }

    ReverseMemCopy(SigBuffer, Buffer, cbSigned);

    /* Make sure pkcs block type 1 */
    if(SigBuffer[0] != 0 || SigBuffer[1] != 1)
    {
        return FALSE;
    }

    for(iLoc = 2; iLoc < pk->datalen; iLoc++ )
    {
        if(!SigBuffer[iLoc])
        {
            break;
        }

        if(SigBuffer[iLoc] != 0xff)
        {
            return FALSE;
        }
    }

    if(iLoc == pk->datalen)
    {
        return FALSE;
    }

    iLoc++; /* skip past separator */


    if(memcmp(&SigBuffer[iLoc], MD2_PRELUDE, sizeof(MD2_PRELUDE))   != 0)
    {
        return FALSE;
    }
    iLoc += sizeof(MD2_PRELUDE);
    if(memcmp(&SigBuffer[iLoc],  DigCtx.state, 16)  != 0)
    {
        return FALSE;
    }



    return TRUE;
}

BOOL
WINAPI
SigRSASHAMD5Sign(
    PUCHAR          pData,          // pointer to hash value
    DWORD           cbData,         // always 36
    PUCHAR          pSigned,
    DWORD           *pcbSigned,
    PctPrivateKey   *pKey)
{
    BSAFE_PRV_KEY *pk = (BSAFE_PRV_KEY *)pKey->pKey;

    if(pk->magic == RSA2)
    {
        // BSAFE key
        UCHAR LocalBuffer[500];
        UCHAR LocalOutput[500];

      pk = (BSAFE_PRV_KEY *)pKey;
      if(pk->keylen > sizeof(LocalBuffer))
        {
            return FALSE;
        }

        FillMemory(LocalBuffer, pk->keylen, 0);
        ReverseMemCopy(LocalBuffer, pData, cbData);

        LocalBuffer[cbData++] = 0;

        while(cbData < pk->datalen-1) {
            LocalBuffer[cbData++] = 0xff;
        }

        /* Make into pkcs block type 1 */
        LocalBuffer[pk->datalen-1] = 1;

        *pcbSigned = pk->datalen+1;

        BSafeDecPrivate(pk, LocalBuffer, LocalOutput);
        ReverseMemCopy(pSigned, LocalOutput,  *pcbSigned);

        return TRUE;
    }
    else
    {
        // capiCryptoAPI key
        HCRYPTPROV hProv;
        HCRYPTHASH hHash;
        DWORD dwAlgid;
        DWORD i;
        DWORD dwT;

        // get handle to CSP
        hProv = *((HCRYPTPROV *)pKey->pKey);

        // create hash object
        dwAlgid = ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SSL3SHAMD5;
        if(RCRYPT_FAILED(capiCryptCreateHash(hProv, dwAlgid, 0, 0, &hHash)))
        {
            return FALSE;
        }

        // set hash value
        if(RCRYPT_FAILED(capiCryptSetHashParam(hHash, HP_HASHVAL, pData, 0)))
        {
            capiCryptDestroyHash(hHash);
            return FALSE;
        }

        // sign hash
        if(RCRYPT_FAILED(capiCryptSignHash(hHash,
                                       AT_KEYEXCHANGE,
                                       NULL,
                                       0,
                                       pSigned,
                                       pcbSigned)))
        {
            capiCryptDestroyHash(hHash);
            return FALSE;
        }

        // free hash object
        capiCryptDestroyHash(hHash);

        //Convert to Big-endian
        dwT = *pcbSigned;
        for( i = 0 ; i < dwT/2 ; i++)
        {
            BYTE bT = pSigned[i];

            pSigned[i] = pSigned[dwT-1-i];
            pSigned[dwT-1-i] = bT;
        }
        return TRUE;
    }
}

BOOL
WINAPI
SigRSASHAMD5Verify(
    PUCHAR          pData,          // pointer to hash value
    DWORD           cbData,         // always 36
    PUCHAR          pSigned,
    DWORD           cbSigned,
    PctPublicKey    *pKey)
{
    BSAFE_PUB_KEY *pk = (BSAFE_PUB_KEY *)pKey->pKey;
    UCHAR Buffer[500];
    UCHAR SigBuffer[500];
    DWORD iLoc;

    if(pk->keylen > sizeof(Buffer) || cbSigned != pk->datalen + 1)
    {
        return FALSE;
    }

    FillMemory(SigBuffer, pk->keylen, 0);
    FillMemory(Buffer, pk->keylen, 0);

    ReverseMemCopy(SigBuffer, pSigned, cbSigned);

    BSafeEncPublic(pk, SigBuffer, Buffer);

    ReverseMemCopy(SigBuffer, Buffer, cbSigned);

    /* Make sure pkcs block type 1 */
    if(SigBuffer[0] != 0 || SigBuffer[1] != 1) return FALSE;

    for(iLoc = 2; iLoc < pk->datalen; iLoc++ ){
        if(!SigBuffer[iLoc]) break;
        if(SigBuffer[iLoc] != 0xff) return FALSE;
    }

    if(iLoc == pk->datalen) return FALSE;

    iLoc++; /* skip past separator */

    if(memcmp(&SigBuffer[iLoc], pData, cbData) != 0) return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\specmap.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/

#include <spbase.h>


/* supported cipher type arrays */

CipherInfo  SPAvailableCiphers[] = {
    {
#ifndef SCHANNEL_EXPORT
        SP_PROT_ALL,
#else
        SP_PROT_CRED | SP_PROT_SGC,
#endif
        SP_PROT_ALL,
        SP_CIPHER_RC4 | SP_ENC_BITS_128 | SP_MAC_BITS_128,
        TEXT("RC4 128/128"),
        &csRC4
    },

    {

#ifdef ENABLE_SERVER_SELECTIVE_CRYPTO
        SP_PROT_SERVERS | SP_PROT_CRED,
#else
        SP_PROT_CRED | SP_PROT_SGC,
#endif
        SP_PROT_ALL,
        SP_CIPHER_RC4 | SP_ENC_BITS_64 | SP_MAC_BITS_128,
        TEXT("RC4 64/128"),
        &csRC4
    },
    {
        SP_PROT_ALL,
        SP_PROT_ALL,
        SP_CIPHER_RC4 | SP_ENC_BITS_40  | SP_MAC_BITS_128,
        TEXT("RC4 40/128"),
        &csRC4
    }
        ,
    {
        SP_PROT_SSL3,
        SP_PROT_SSL3,
        SP_CIPHER_NONE | SP_ENC_BITS_128 | SP_MAC_BITS_128,
        TEXT("NULL 0/128"),
        &csNONE
    }

};

const DWORD SPNumAvailableCiphers = sizeof(SPAvailableCiphers)/sizeof(CipherInfo);

HashInfo  SPAvailableHashes[] =
{
    {
        SP_PROT_ALL,
        SP_PROT_ALL,
        SP_HASH_MD5,
        TEXT("MD5"),
        &ckMD5
    },
    {
        SP_PROT_ALL,
        SP_PROT_ALL,
        SP_HASH_SHA,
        TEXT("SHA"),
        &ckSHA
    }
};

const DWORD SPNumAvailableHashes = sizeof(SPAvailableHashes)/sizeof(HashInfo);

CertSysInfo   SPAvailableCerts[] =
{
    {
        SP_PROT_ALL,
        SP_PROT_ALL,
        SP_CERT_X509,
        TEXT("X.509"),
        &certX509
    }
};

const DWORD SPNumAvailableCerts = sizeof(SPAvailableCerts)/sizeof(CertSysInfo);

SigInfo SPAvailableSigs[] =
{
    {
        SP_PROT_ALL,
        SP_PROT_ALL,
        SP_SIG_RSA_MD2,
        TEXT("RSA Signed MD2"),
        &sigRSAMD2
    },
    {
        SP_PROT_ALL,
        SP_PROT_ALL,
        SP_SIG_RSA_MD5,
        TEXT("RSA Signed MD5"),
        &sigRSAMD5
    },
    {
        SP_PROT_ALL,
        SP_PROT_ALL,
        SP_SIG_RSA_SHA,
        TEXT("RSA Signed SHA"),
        &sigRSASHA
    },
    {
        SP_PROT_SSL3,
        SP_PROT_SSL3,
        SP_SIG_RSA_SHAMD5,
        TEXT("RSA Signed MD5/SHA combination (SSL3 only)"),
        &sigRSASHAMD5
    }
};

const DWORD SPNumAvailableSigs = sizeof(SPAvailableSigs)/sizeof(SigInfo);

KeyExchangeInfo SPAvailableExch[] =
{
    {
        SP_PROT_ALL,
        SP_PROT_ALL,
        SP_EXCH_RSA_PKCS1,
        TEXT("PKCS"),
        &keyexchPKCS
    }
};

const DWORD SPNumAvailableExch = sizeof(SPAvailableExch)/sizeof(KeyExchangeInfo);

PCipherInfo GetCipherInfo(CipherSpec Spec)
{
    DWORD i;
    for (i=0; i<SPNumAvailableCiphers; i++ )
    {
        if(SPAvailableCiphers[i].Spec == Spec)
        {
            return &SPAvailableCiphers[i];
        }
    }
    return NULL;
}

PHashInfo GetHashInfo(HashSpec Spec)
{
    DWORD i;
    for (i=0; i<SPNumAvailableHashes; i++ )
    {
        if(SPAvailableHashes[i].Spec == Spec)
        {
            return &SPAvailableHashes[i];
        }
    }
    return NULL;
}

PKeyExchangeInfo GetKeyExchangeInfo(ExchSpec Spec)
{
    DWORD i;
    for (i=0; i<SPNumAvailableExch; i++ )
    {
        if(SPAvailableExch[i].Spec == Spec)
        {
            return &SPAvailableExch[i];
        }
    }
    return NULL;
}

PCertSysInfo GetCertSysInfo(CertSpec Spec)
{
    DWORD i;
    for (i=0; i<SPNumAvailableCerts; i++ )
    {
        if(SPAvailableCerts[i].Spec == Spec)
        {
            return &SPAvailableCerts[i];
        }
    }
    return NULL;
}


PSigInfo GetSigInfo(SigSpec Spec)
{
    DWORD i;
    for (i=0; i<SPNumAvailableSigs; i++ )
    {
        if(SPAvailableSigs[i].Spec == Spec)
        {
            return &SPAvailableSigs[i];
        }
    }
    return NULL;
}

const
CryptoSystem *
CipherFromSpec(CipherSpec Spec, DWORD fProtocol)
{
    PCipherInfo pInfo;
    pInfo = GetCipherInfo(Spec);
    if(pInfo == NULL)
    {
        return NULL;
    }
    if(pInfo->fProtocol & fProtocol)
    {
        return pInfo->System;
    }
    return NULL;
}

const
CheckSumFunction *
HashFromSpec(HashSpec Spec, DWORD fProtocol)
{
    PHashInfo pInfo;
    pInfo = GetHashInfo(Spec);
    if(pInfo == NULL)
    {
        return NULL;
    }
    if(pInfo->fProtocol & fProtocol)
    {
        return pInfo->System;
    }
    return NULL;
}

const
KeyExchangeSystem *
KeyExchangeFromSpec(ExchSpec Spec, DWORD fProtocol)
{
    PKeyExchangeInfo pInfo;
    pInfo = GetKeyExchangeInfo(Spec);
    if(pInfo == NULL)
    {
        return NULL;
    }
    if(pInfo->fProtocol & fProtocol)
    {
        return pInfo->System;
    }
    return NULL;
}

const
CertSystem *
CertFromSpec(CertSpec Spec, DWORD fProtocol)
{
    PCertSysInfo pInfo;
    pInfo = GetCertSysInfo(Spec);
    if(pInfo == NULL)
    {
        return NULL;
    }
    if(pInfo->fProtocol & fProtocol)
    {
        return pInfo->System;
    }
    return NULL;
}

const
SignatureSystem *
SigFromSpec(SigSpec Spec, DWORD fProtocol)
{
    PSigInfo pInfo;
    pInfo = GetSigInfo(Spec);
    if(pInfo == NULL)
    {
        return NULL;
    }
    if(pInfo->fProtocol & fProtocol)
    {
        return pInfo->System;
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\sigsys.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------
* RSA Public Key Cryptosystem, RC4, MD2, MD5 and RSA are trademarks
* of RSA Data Security, Inc.
*----------------------------------------------------------------------------*/


#ifndef __SIGSYS_H__
#define __SIGSYS_H__




typedef BOOL
( WINAPI * SignatureSignFn)(
    PUCHAR          pData,
    DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           *pcbSigned,
    PctPrivateKey    *pKey);


typedef BOOL
( WINAPI * SignatureVerifyFn)(
    PUCHAR          pData,
	DWORD           cbData,
    PUCHAR          pSigned,
    DWORD           cbSigned,
    PctPublicKey    *pKey);



typedef struct _SignatureSystem {
    SigSpec   Spec;
    SignatureSignFn Sign;
    SignatureVerifyFn Verify;
} SignatureSystem, * PSignatureSystem;





/*
 * instantiations of systems
 */
extern const SignatureSystem sigRSAMD2;
extern const SignatureSystem sigRSAMD5;
extern const SignatureSystem sigRSASHA;
extern const SignatureSystem sigRSASHAMD5;

#endif /* __SIGSYS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\spbase.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/

#ifdef _WINDOWS

#include <windows.h>
#include <winsock2.h>
#ifndef UNDER_CE
#include <wchar.h>
#endif // !UNDER_CE
//#include <wincrypt.h>

#else
// #include <malloc.h>
#include <xtl.h>
// #include <netinet/in.h>
#endif

#include <stdlib.h>
#ifndef UNDER_CE
#include <stdio.h>
#endif // !UNDER_CE
#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _WIN32
#define SECURITY_WIN32
#define MULTI_THREADED
#endif

#include "hack.h"

/*
///////////////////////////////////////////////////////
//
// Private Headers
//
///////////////////////////////////////////////////////
*/

#include "spreg.h"
#include "debug.h"



#include "schnlsp.h"
#include "sperr.h"
#include "spdefs.h"
#include "bulk.h"

#include "keyexch.h"
#include "sigsys.h"
#include "cert.h"
#include <certmap.h>
#include "cred.h"
#include "specmap.h"
#include "protocol.h"
#include "cache.h"
#include "context.h"

#include "protos.h"
#include "rng.h"

#include "encode.h"
// #include "sslsock2.h"


#define PCT_INVALID_MAGIC       *(DWORD *)"eerF"

#if DBG

void SPAssert(
    void *FailedAssertion,
    void *FileName,
    unsigned long LineNumber,
    char * Message);

#define SP_ASSERT(x) \
	    if (!(x)) \
		SPAssert(#x, __FILE__, __LINE__, NULL); else

#else // DBG

#define SP_ASSERT(x)

#endif // DBG


#ifdef SECURITY_LINUX

#define SPExternalAlloc(cb)    malloc(cb)
#define SPExternalFree(pv)     free(pv);

#else // SECURITY_LINUX

#if DBG
VOID *SPExternalAlloc(DWORD cb);
VOID SPExternalFree(VOID *pv);
#else // DBG
#define SPExternalAlloc(cb)    LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cb)
#define SPExternalFree(pv)     LocalFree(pv)
#endif // DBG

#endif // SECURITY_LINUX

#undef RtlMoveMemory

NTSYSAPI
VOID
NTAPI
RtlMoveMemory (
   VOID UNALIGNED *Destination,
   CONST VOID UNALIGNED *Source,
   ULONG Length
   );

#ifdef DEBUG

#define ZONE_INIT        DEBUGZONE(0)
#define ZONE_SERVERCACHE DEBUGZONE(1)
#define ZONE_RNG         DEBUGZONE(2)
#define ZONE_CERT        DEBUGZONE(3)
#define ZONE_FUNCTION    DEBUGZONE(13)
#define ZONE_WARN        DEBUGZONE(14)
#define ZONE_ERROR       DEBUGZONE(15)

#endif // DEBUG

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\spreg.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/

#ifndef _SPREG_H_
#define _SPREG_H_

/*
 *[HKEY_LOCAL_MACHINE]
 *   [Comm]
 *       [SecurityProviders]
 *                   SecurityProviders:REG_SZ:     - security provider dll's installed on this machine
 *
 *                   [SCHANNEL] or [SSLSSPI]       - this security provider
 *                       EventLogging:REG_DWORD:   - Flag specifing event logging level
 *                       LogFile:REG_SZ:           - debug logfile name (Not published)
 *                       LogLevel:REG_SZ:          - debug logging level flags.
 *                       DebugBreak:REG_DWORD:     - Flag specifing what type of errors cause a debug break (Not published)
 *                       CertMapper:REG_SZ         - location of cert mapper dll
 *                       ClientCache:REG_DWORD     - size of client cache (defaults to 10)
 *                       ServerCache:REG_DWORD     - size of server cache (defaults to 100)
 *                       ClientCacheTime:REG_DWORD - time to expire client side cache elements
 *                       ServerCacheTime:REG_DWORD - time to expire server side cache elements
 *
 *                       [Protocols]
 *                           [Multi-Protocol Unified Hello]
 *                               [Client]
 *                                  Enabled:REG_DWORD: - Is this protocol enabled
 *                               [Server]
 *                                  Enabled:REG_DWORD: - Is this protocol enabled                          [SSL2]
 *                           [SSL2]
 *                               [Client]
 *                                  Enabled:REG_DWORD: - Is this protocol enabled
 *                               [Server]
 *                                  Enabled:REG_DWORD: - Is this protocol enabled                          [SSL2]
 *                           [SSL3]
 *                               [Client]
 *                                  Enabled:REG_DWORD: - Is this protocol enabled
 *                               [Server]
 *                                  Enabled:REG_DWORD: - Is this protocol enabled
 *                           [PCT1]
 *                               [Client]
 *                                  Enabled:REG_DWORD: - Is this protocol enabled
 *                               [Server]
 *                                  Enabled:REG_DWORD: - Is this protocol enabled
 *
 *                       [Ciphers]
 *                           [Cipher Name]
 *                               Enabled:REG_DWORD: - Enable Mask
 *                           [RC4_128]
 *                               Enabled:REG_DWORD: - Is this Ciphers enabled
 *                       [Hashes]
 *                           [Hash Name]
 *                               Enabled:REG_DWORD: - Enable Mask
 *                       [KeyExchAlgs]
 *                           [Exch Name]
 *                               Enabled:REG_DWORD: - Enable Mask
 *
 *                       [CAs]
 *                           [C=US.....]
 *                               Enabled:REG_DWORD: - Is this Cert enabled
 *                               CACert:REG_BINARY:   - BER encoded self signed certificate.
 *
 *	                            							
 *
 *
 */



/* Key Names */
#define SP_REG_KEY_BASE     TEXT("Comm\\SecurityProviders\\SCHANNEL")
#define SP_REG_KEY_PROTOCOL TEXT("Protocols")
#define SP_REG_KEY_CIPHERS  TEXT("Ciphers")
#define SP_REG_KEY_HASHES   TEXT("Hashes")
#define SP_REG_KEY_KEYEXCH  TEXT("KeyExchAlgs")
#define SP_REG_KEY_CA       TEXT("CAs")

/* Value Names */
#define SP_REG_VAL_EVENTLOG  TEXT("EventLogging")
#define SP_REG_VAL_LOGFILE   TEXT("LogFile")
#define SP_REG_VAL_LOGLEVEL  TEXT("LogLevel")
#define SP_REG_VAL_BREAK     TEXT("DebugBreak")
#define SP_REG_VAL_CERTMAPPER TEXT("CertMapper")

#define SP_REG_VAL_CLIENT_CACHE        TEXT("ClientCache")
#define SP_REG_VAL_SERVER_CACHE        TEXT("ServerCache")
#define SP_REG_VAL_CLIENT_CACHE_TIME   TEXT("ClientCacheTime")
#define SP_REG_VAL_SERVER_CACHE_TIME   TEXT("ServerCacheTime")

#define SP_REG_VAL_ENABLED   TEXT("Enabled")
#define SP_REG_VAL_CACERT    TEXT("CACert")
#define SP_REG_VAL_CERT_TYPE TEXT("Type")


#define SP_REG_KEY_CLIENT    TEXT("Client")
#define SP_REG_KEY_SERVER    TEXT("Server")

#define SP_REG_KEY_PCT1      TEXT("PCT 1.0")
#define SP_REG_KEY_SSL2      TEXT("SSL 2.0")
#define SP_REG_KEY_SSL3      TEXT("SSL 3.0")
#define SP_REG_KEY_UNIHELLO  TEXT("Multi-Protocol Unified Hello")

#define SP_EVENT_CONFIG_CHANGED TEXT("Schannel Config Changed")

/* Base keys, created when DLL is first loaded */
extern HKEY g_hkBase;
extern HKEY g_hkProtocols;
extern HKEY g_hkCiphers;
extern HKEY g_hkHashes;
extern HKEY g_hkKeyExch;
extern HKEY g_hkCA;

BOOL SPInitRegKeys();
BOOL SPCloseRegKeys();

BOOL SPLoadRegOptions();



/* Event Logging Definitions */
#define SP_EVLOG_RESOURCE           0x0001
#define SP_EVLOG_ASSERT             0x0002
#define SP_EVLOG_ILLEGAL_MESSAGE    0x0004
#define SP_EVLOG_SECAUDIT           0x0008


#define SP_LOG_ERROR                0x0001
#define SP_LOG_WARNING              0x0002
#define SP_LOG_TRACE                0x0004
#define SP_LOG_ALLOC                0x0008
#define SP_LOG_RES                  0x0010

#define SP_LOG_FILE             0x80000000

#define SP_LOG_TYPEMASK         0x0000ffff

#define SP_BREAK_ERROR              0x0001
#define SP_BREAK_WARNING            0x0002
#define SP_BREAK_ENTRY              0x0004

#endif // _SPREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\sperr.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology 
* reference implementation, version 1.0
* 
* The Private Communication Technology reference implementation, version 1.0 
* ("PCTRef"), is being provided by Microsoft to encourage the development and 
* enhancement of an open standard for secure general-purpose business and 
* personal communications on open networks.  Microsoft is distributing PCTRef 
* at no charge irrespective of whether you use PCTRef for non-commercial or 
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without 
* warranty of any kind, either express or implied, including, without 
* limitation, the implied warranties or merchantability, fitness for a 
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out 
* of use or performance of PCTRef remains with you.
* 
* Please see the file LICENSE.txt, 
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
* 
* Please see http://pct.microsoft.com/pct/pct.htm for The Private 
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/ 





/* BUGBUG,TBDTBD.  We really have to straighten out
 * the error message situation */
/* basic error codes, for transmission over the 
 * communications channel */
#define PCT_ERR_OK                      0x0000
#define PCT_ERR_BAD_CERTIFICATE		    0x0001
#define PCT_ERR_CLIENT_AUTH_FAILED	    0x0002
#define PCT_ERR_ILLEGAL_MESSAGE		    0x0003
#define PCT_ERR_INTEGRITY_CHECK_FAILED	0x0004
#define PCT_ERR_SERVER_AUTH_FAILED	    0x0005
#define PCT_ERR_SPECS_MISMATCH		    0x0006
#define PCT_ERR_INCOMPLETE_CREDS        0x0007
#define PCT_ERR_SSL_STYLE_MSG		    0x00ff
#define PCT_ERR_RENEGOTIATE             0x0008
#define PCT_ERR_UNKNOWN_CREDENTIAL      0x0009

/* internal error codes, for communications with
 * the application */
#define PCT_INT_BUFF_TOO_SMALL          0x40000000
#define PCT_INT_INCOMPLETE_MSG          0x40000001  /* this specifies to the comm layer to pass
                                                     * more data */

#define PCT_INT_DROP_CONNECTION    0x80000000
#define PCT_INT_BAD_CERT           (PCT_INT_DROP_CONNECTION | PCT_ERR_BAD_CERTIFICATE)
#define PCT_INT_CLI_AUTH           (PCT_INT_DROP_CONNECTION | PCT_ERR_CLIENT_AUTH_FAILED)
#define PCT_INT_ILLEGAL_MSG        (PCT_INT_DROP_CONNECTION | PCT_ERR_ILLEGAL_MESSAGE)
#define PCT_INT_MSG_ALTERED        0x80000101
#define PCT_INT_INTERNAL_ERROR     0xffffffff
#define PCT_INT_OUT_OF_MEMORY      0xfffffffe
#define PCT_INT_DATA_OVERFLOW      0x80000102
#define PCT_INT_SPECS_MISMATCH     (PCT_INT_DROP_CONNECTION | PCT_ERR_SPECS_MISMATCH)
#define PCT_INT_INCOMPLETE_CREDS   (PCT_INT_DROP_CONNECTION | PCT_ERR_INCOMPLETE_CREDS)
#define PCT_INT_RENEGOTIATE        (PCT_INT_DROP_CONNECTION | PCT_ERR_RENEGOTIATE)
#define PCT_INT_UNKNOWN_CREDENTIAL (PCT_INT_DROP_CONNECTION | PCT_ERR_UNKNOWN_CREDENTIAL)

#define SP_FATAL(s) (PCT_INT_DROP_CONNECTION & (s))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\spdefs.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/

/* versions */

/* spec codes */

/* keyexchange algs */
#define SP_EXCH_RSA_PKCS1		        0x0001
#define SP_EXCH_RSA_PKCS1_TOKEN_DES     0x0002
#define SP_EXCH_RSA_PKCS1_TOKEN_DES3    0x0003
#define SP_EXCH_RSA_PKCS1_TOKEN_RC2     0x0004
#define SP_EXCH_RSA_PKCS1_TOKEN_RC4     0x0005

#define SP_EXCH_DH_PKCS3                0x0006
#define SP_EXCH_DH_PKCS3_TOKEN_DES      0x0007
#define SP_EXCH_DH_PKCS3_TOKEN_DES3     0x0008
#define SP_EXCH_FORTEZZA_TOKEN          0x0009

#define SP_EXCH_UNKNOWN                 0xffff


/* data encryption algs */
/* encryption alg masks */
#define SP_CIPHER_ALG			        0xffff0000
#define SP_CIPHER_STRENGTH		        0x0000ff00
#define SP_CSTR_POS			            8
#define SP_CIPHER_MAC			        0x000000ff

/* specific algs */
#define SP_CIPHER_DES			        0x00010000
#define SP_CIPHER_IDEA			        0x00020000
#define SP_CIPHER_RC2			        0x00030000
#define SP_CIPHER_RC4			        0x00040000
#define SP_CIPHER_DES_112               0x00050000
#define SP_CIPHER_DES_168               0x00060000
#define SP_CIPHER_NONE                  0x00000000

#define SP_CIPHER_UNKNOWN               0xffffffff

/* data encryption strength specs */
#define SP_ENC_BITS_40			        0x00002800
#define SP_ENC_BITS_64			        0x00004000
#define SP_ENC_BITS_128		            0x00008000

/* mac strength specs */
#define SP_MAC_BITS_128		            0x00000040

/* hashing algs */
#define SP_HASH_MD5			            0x0001
#define SP_HASH_MD5_TRUNC_64	        0x0002
#define SP_HASH_SHA                     0x0003
#define SP_HASH_SHA_TRUNC_80            0x0004
#define SP_HASH_DES_DM                  0x0005
#define SP_HASH_MD2			            0x0006
#define SP_HASH_UNKNOWN                 0xffff

/* certificate types */
#define SP_CERT_NONE			        0x0000
#define SP_CERT_X509			        0x0001
#define SP_CERT_PKCS7			        0x0002

/* signature algorithms */
#define SP_SIG_NONE			            0x0000
#define SP_SIG_RSA_MD5		            0x0001
#define SP_SIG_RSA_SHA                  0x0002
#define SP_SIG_DSA_SHA                  0x0003

/* these are for internal use only */
#define SP_SIG_RSA_MD2			        0x0004
#define SP_SIG_RSA  			        0x0005
#define SP_SIG_RSA_SHAMD5               0x0006

/* flag/identifiers for protocols we support */
#define SP_PROT_PCT1_SERVER             0x00000001
#define SP_PROT_PCT1_CLIENT             0x00000002
#define SP_PROT_PCT1                    (SP_PROT_PCT1_SERVER | SP_PROT_PCT1_CLIENT)

#define SP_PROT_SSL2_SERVER             0x00000004
#define SP_PROT_SSL2_CLIENT             0x00000008
#define SP_PROT_SSL2                    (SP_PROT_SSL2_SERVER | SP_PROT_SSL2_CLIENT)

#define SP_PROT_SSL3_SERVER             0x00000010
#define SP_PROT_SSL3_CLIENT             0x00000020
#define SP_PROT_SSL3                    (SP_PROT_SSL3_SERVER | SP_PROT_SSL3_CLIENT)

#define SP_PROT_UNI_SERVER              0x40000000
#define SP_PROT_UNI_CLIENT              0x80000000
#define SP_PROT_UNI                     (SP_PROT_UNI_SERVER | SP_PROT_UNI_CLIENT)


#define SP_PROT_CRED                    0x00010000

// flag to identify ciphers allowed with Server-Gated-Crypt
// use along with SP_PROT_SSL3
#define SP_PROT_SGC                     0x00020000

#define SP_PROT_ALL                     0xffffffff
#undef SP_PROT_CLIENTS
#define SP_PROT_CLIENTS                 (SP_PROT_PCT1_CLIENT | SP_PROT_SSL2_CLIENT | SP_PROT_SSL3_CLIENT | SP_PROT_UNI_CLIENT )
#undef SP_PROT_SERVERS
#define SP_PROT_SERVERS                 (SP_PROT_PCT1_SERVER | SP_PROT_SSL2_SERVER | SP_PROT_SSL3_SERVER | SP_PROT_UNI_SERVER )


/* sizing of local structures */
#define SP_MAX_SESSION_ID           32
#define SP_MAX_MASTER_KEY           48
#define SP_MAX_MAC_KEY              48
#define SP_MAX_CACHE_ID             64
#define SP_MAX_CHALLENGE            32
#define SP_MAX_CONNECTION_ID        32
#define SP_MAX_KEY_ARGS             32

#define SP_OFFSET_OF(t, v) (DWORD)&(((t)NULL)->v)
/* tuning constants */

#define SP_DEF_SERVER_CACHE_SIZE		10
#define SP_DEF_CLIENT_CACHE_SIZE		10


typedef DWORD SP_STATUS;


/* internal representations of algorithm specs */

typedef DWORD   CipherSpec, *PCipherSpec;
typedef DWORD   KeyExchangeSpec, *PKeyExchangeSpec;
typedef DWORD   HashSpec,   *PHashSpec;
typedef DWORD   CertSpec,   *PCertSpec;
typedef DWORD   ExchSpec,   *PExchSpec;
typedef DWORD   SigSpec,    *PSigSpec;



typedef struct _SPBuffer {
    unsigned long cbBuffer;             /* Size of the buffer, in bytes */
    unsigned long cbData;               /* size of the actual data in the
                                         * buffer, in bytes */
    void * pvBuffer;                    /* Pointer to the buffer */
} SPBuffer, * PSPBuffer;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\spsspi.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       protos.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-08-95   RichardW   Created
//
//----------------------------------------------------------------------------






SECURITY_STATUS PctTranslateError(SP_STATUS spRet);




///////////////////////////////////////////////////////
//
// Prototypes for PCT SSPI
//
///////////////////////////////////////////////////////


SECURITY_STATUS SEC_ENTRY
AcquireCredentialsHandleW(
    SEC_WCHAR SEC_FAR *         pszPrincipal,       // Name of principal
    SEC_WCHAR SEC_FAR *         pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    );

SECURITY_STATUS SEC_ENTRY
AcquireCredentialsHandleA(
    SEC_CHAR SEC_FAR *         pszPrincipal,       // Name of principal
    SEC_CHAR SEC_FAR *         pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    );


SECURITY_STATUS SEC_ENTRY
FreeCredentialsHandle(
    PCredHandle                 phCredential        // Handle to free
    );


SECURITY_STATUS SEC_ENTRY
InitializeSecurityContextW(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    SEC_WCHAR SEC_FAR *          pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    );

SECURITY_STATUS SEC_ENTRY
InitializeSecurityContextA(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    SEC_CHAR SEC_FAR *          pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    );


SECURITY_STATUS SEC_ENTRY
AcceptSecurityContext(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    PSecBufferDesc              pInput,             // Input buffer
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               TargetDataRep,      // Target Data Rep
    PCtxtHandle                 phNewContext,       // (out) New context handle
    PSecBufferDesc              pOutput,            // (inout) Output buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attributes
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    );

SECURITY_STATUS SEC_ENTRY
CompleteAuthToken(
    PCtxtHandle phContext,              // Context to complete
    PSecBufferDesc pToken               // Token to complete
    );

SECURITY_STATUS SEC_ENTRY
DeleteSecurityContext(
    PCtxtHandle                 phContext           // Context to delete
    );



SECURITY_STATUS SEC_ENTRY
ApplyControlToken(
    PCtxtHandle                 phContext,          // Context to modify
    PSecBufferDesc              pInput              // Input token to apply
    );


SECURITY_STATUS SEC_ENTRY
EnumerateSecurityPackagesW(
    unsigned long SEC_FAR *     pcPackages,         // Receives num. packages
    PSecPkgInfoW SEC_FAR *      ppPackageInfo       // Receives array of info
    );

SECURITY_STATUS SEC_ENTRY
EnumerateSecurityPackagesA(
    unsigned long SEC_FAR *     pcPackages,         // Receives num. packages
    PSecPkgInfoA SEC_FAR *      ppPackageInfo       // Receives array of info
    );


SECURITY_STATUS SEC_ENTRY
QuerySecurityPackageInfoW(
    SEC_WCHAR SEC_FAR *         pszPackageName,     // Name of package
    PSecPkgInfoW *              ppPackageInfo       // Receives package info
    );

SECURITY_STATUS SEC_ENTRY
QuerySecurityPackageInfoA(
    SEC_CHAR SEC_FAR *         pszPackageName,     // Name of package
    PSecPkgInfoA *              ppPackageInfo       // Receives package info
    );


SECURITY_STATUS SEC_ENTRY
FreeContextBuffer(
    void SEC_FAR *      pvContextBuffer
    );


SECURITY_STATUS SEC_ENTRY
QueryCredentialsAttributesW(
    PCredHandle phCredential,
    ULONG ulAttribute,
    PVOID pBuffer
    );


SECURITY_STATUS SEC_ENTRY
ImpersonateSecurityContext(
    PCtxtHandle                 phContext           // Context to impersonate
    );


SECURITY_STATUS SEC_ENTRY
RevertSecurityContext(
    PCtxtHandle                 phContext           // Context from which to re
    );


SECURITY_STATUS SEC_ENTRY
QueryContextAttributesW(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    );

SECURITY_STATUS SEC_ENTRY
QueryContextAttributesA(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    );


SECURITY_STATUS SEC_ENTRY
MakeSignature(
    PCtxtHandle         phContext,
    DWORD               fQOP,
    PSecBufferDesc      pMessage,
    ULONG               MessageSeqNo
    );

SECURITY_STATUS SEC_ENTRY
VerifySignature(
    PCtxtHandle     phContext,
    PSecBufferDesc  pMessage,
    ULONG           MessageSeqNo,
    DWORD *         pfQOP
    );


SECURITY_STATUS SEC_ENTRY
SealMessage(
    PCtxtHandle         phContext,
    DWORD               fQOP,
    PSecBufferDesc      pMessage,
    ULONG               MessageSeqNo
    );


SECURITY_STATUS SEC_ENTRY
UnsealMessage(
    PCtxtHandle         phContext,
    PSecBufferDesc      pMessage,
    ULONG               MessageSeqNo,
    DWORD *             pfQOP
    );

PSPContext
ValidateContextHandle(PCtxtHandle phContext);

PSPCredential
ValidateCredentialHandle(
    PCredHandle     phCred);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\spverp.h ===
#define VER_SCHANNEL 1710
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\srvprot.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/


/* TBD: add redo capability? */

#include <spbase.h>
#include <pct1msg.h>
#include <pct1prot.h>
#include <md5.h>
#include <sha.h>
#include <ssl2msg.h>
#include <ssl3msg.h>
#include <ssl2prot.h>


/* The main purpose of this handler is to determine what kind of protocol
 * the client hello is
 */

SP_STATUS WINAPI
ServerProtocolHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput,
    PSPBuffer pAppOutput)
{
    SP_STATUS pctRet = PCT_INT_ILLEGAL_MSG;
#ifndef SCHANNEL_CLIENT_ONLY    
    PUCHAR pb;
    DWORD dwVersion;

    /* PCTv1.0 Hello starts with
     * RECORD_LENGTH_MSB  (ignore)
     * RECORD_LENGTH_LSB  (ignore)
     * PCT1_CLIENT_HELLO  (must be equal)
     * PCT1_CLIENT_VERSION_MSB (if version greater than PCTv1)
     * PCT1_CLIENT_VERSION_LSB (if version greater than PCTv1) 
     *
     * ... PCT hello ...
     */


    /* Microsft Unihello starts with
     * RECORD_LENGTH_MSB  (ignore)
     * RECORD_LENGTH_LSB  (ignore)
     * SSL2_CLIENT_HELLO  (must be equal)
     * SSL2_CLIENT_VERSION_MSB (if version greater than SSLv2) ( or v3)
     * SSL2_CLIENT_VERSION_LSB (if version greater than SSLv2) ( or v3)
     *
     * ... SSLv2 Compatable Hello ...
     */

    /* SSLv2 Hello starts with
     * RECORD_LENGTH_MSB  (ignore)
     * RECORD_LENGTH_LSB  (ignore)
     * SSL2_CLIENT_HELLO  (must be equal)
     * SSL2_CLIENT_VERSION_MSB (if version greater than SSLv2) ( or v3)
     * SSL2_CLIENT_VERSION_LSB (if version greater than SSLv2) ( or v3)
     *
     * ... SSLv2 Hello ...
     */

    /* SSLv3 Type 2 Hello starts with
     * RECORD_LENGTH_MSB  (ignore)
     * RECORD_LENGTH_LSB  (ignore)
     * SSL2_CLIENT_HELLO  (must be equal)
     * SSL2_CLIENT_VERSION_MSB (if version greater than SSLv3)
     * SSL2_CLIENT_VERSION_LSB (if version greater than SSLv3)
     *
     * ... SSLv2 Compatable Hello ...
     */

    /* SSLv3 Type 3 Hello starts with
     * 0x15 Hex (HANDSHAKE MESSAGE)
     * VERSION MSB
     * VERSION LSB
     * RECORD_LENGTH_MSB  (ignore)
     * RECORD_LENGTH_LSB  (ignore)
     * HS TYPE (CLIENT_HELLO)
     * 3 bytes HS record length
     * HS Version
     * HS Version
     */

    // We need at least 5 bytes to determine what we have.
    if (pCommInput->cbData < 5)
    {
        return(PCT_INT_INCOMPLETE_MSG);
    }

    pb = pCommInput->pvBuffer;
    // If the first byte is 0x15, then check if we have a
    // SSLv3 Type3 client hello
    
    if(pb[0] == SSL3_CT_HANDSHAKE)
    {
        if(!(SP_PROT_SSL3_SERVER & g_ProtEnabled))
        {
            return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
        }
        // SSLv3 message
        dwVersion = COMBINEBYTES(pb[1], pb[2]);
        pContext->ProtocolHandler = Ssl3ServerProtocolHandler;
        pContext->DecryptHandler = Ssl3DecryptHandler;
        return(Ssl3ServerProtocolHandler(pContext, pCommInput, pCommOutput, pAppOutput));
   }
 	else
 	{
        // SSL type header, so get the version
        dwVersion = COMBINEBYTES(pb[3], pb[4]);
 	}
    if(dwVersion >= PCT_VERSION_1)
    {
#ifdef SCHANNEL_PCT    
        if(!(SP_PROT_PCT1_SERVER & g_ProtEnabled))
        {
            return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
        }
        // We're running PCT, so set up the PCT handlers
        pContext->ProtocolHandler = Pct1ServerProtocolHandler;
        pContext->DecryptHandler = Pct1DecryptHandler;
        return(Pct1ServerProtocolHandler(pContext, pCommInput, pCommOutput, pAppOutput));
#else
        return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
#endif        
    }
    if(dwVersion >= SSL2_CLIENT_VERSION)
    {
        // we're either receiving ssl2, ssl3, or pct1 compat

        PSSL2_CLIENT_HELLO pRawHello = pCommInput->pvBuffer;

        // Do we have one client hello message with at least one
        // cipher spec.
        if (pCommInput->cbData < (sizeof(SSL2_CLIENT_HELLO)+2))
        {
            return(PCT_INT_INCOMPLETE_MSG);
        }

        // We must have at least one cipher spec
        if(COMBINEBYTES(pRawHello->CipherSpecsLenMsb, pRawHello->CipherSpecsLenLsb)< 1)
        {
            return(SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG));
        }

        // Is the PCT compatability flag set.
        if(pRawHello->VariantData[0] == PCT_SSL_COMPAT)
        {
            // Get the pct version.
            dwVersion = COMBINEBYTES(pRawHello->VariantData[1], pRawHello->VariantData[2]);
        }
        if((dwVersion >= PCT_VERSION_1) &&
           (0 != (SP_PROT_PCT1_SERVER & g_ProtEnabled)))
        {
#ifdef SCHANNEL_PCT        
            pContext->State = UNI_STATE_RECVD_UNIHELLO;
            pContext->ProtocolHandler = Pct1ServerProtocolHandler;
            pContext->DecryptHandler = Pct1DecryptHandler;
            return(Pct1ServerProtocolHandler(pContext, pCommInput, pCommOutput, pAppOutput));
#else
            return (SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG));
#endif            
        }

        else 

        if((dwVersion >= SSL3_CLIENT_VERSION) &&
           (0 != (SP_PROT_SSL3_SERVER & g_ProtEnabled)))
        {
            pContext->State = UNI_STATE_RECVD_UNIHELLO;
            pContext->ProtocolHandler = Ssl3ServerProtocolHandler;
            pContext->DecryptHandler = Ssl3DecryptHandler;
            return(Ssl3ServerProtocolHandler(pContext, pCommInput, pCommOutput, pAppOutput));
        }
        if((dwVersion >= SSL2_CLIENT_VERSION) &&
           (0 != (SP_PROT_SSL2_SERVER & g_ProtEnabled)))
        {
            pContext->ProtocolHandler = Ssl2ServerProtocolHandler;
            pContext->DecryptHandler = Ssl2DecryptHandler;
            return(Ssl2ServerProtocolHandler(pContext, pCommInput, pCommOutput, pAppOutput));
       }
        return(SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG));

    }
#endif // !SCHANNEL_CLIENT_ONLY    
    return (pctRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\ssl2cli.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       context.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-08-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <ssl2msg.h>
#include <ssl3msg.h>
#include <ssl2prot.h>



SP_STATUS WINAPI
Ssl2ClientProtocolHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput,
    PSPBuffer pAppOutput)
{
    SP_STATUS pctRet = 0;
    DWORD cMessageType;

    DWORD dwStateTransition;
    BOOL fRaw = TRUE;
    SPBuffer MsgInput;
//    DWORD cbMsg;
//    PUCHAR pb;
//    UCHAR bCT;

    if (NULL != pCommOutput)
    {
        pCommOutput->cbData = 0;
    }
    if (NULL != pAppOutput)
    {
        pAppOutput->cbData = 0;
    }


    MsgInput.pvBuffer = pCommInput->pvBuffer;
    MsgInput.cbBuffer = pCommInput->cbBuffer;
    MsgInput.cbData = pCommInput->cbData;

    cMessageType = ((PUCHAR) MsgInput.pvBuffer)[2];
    // In the following states, we should decrypt the message:
    switch(pContext->State)
    {
        case SSL2_STATE_CLIENT_MASTER_KEY:
        case SSL2_STATE_CLIENT_FINISH:
        case SSL2_STATE_CLIENT_RESTART:
            pctRet = Ssl2DecryptMessage(pContext, pCommInput, &MsgInput);
            cMessageType = ((PUCHAR) MsgInput.pvBuffer)[0];
            fRaw = FALSE;
    }


    if (MsgInput.cbData < 3)
    {
        pctRet = PCT_INT_INCOMPLETE_MSG;
    }

    dwStateTransition = (cMessageType << 16) |
			            (pContext->State & 0xffff);

    if (pctRet != PCT_ERR_OK)
    {
        // to handle incomplete message errors
        return(pctRet);
    }

	switch(dwStateTransition)
    {
        // Client receives Server hello:

        case (SSL2_MT_SERVER_HELLO << 16) | UNI_STATE_CLIENT_HELLO:
        case (SSL2_MT_SERVER_HELLO << 16) | SSL2_STATE_CLIENT_HELLO:
        {
            PSsl2_Server_Hello pHello;

            // Attempt to recognize and handle various versions of Server
            // hello, start by trying to unpickle the oldest, and the next
            // version, until one unpickles.  Then run the handle code.
            // We can also put unpickling and handling code in here for SSL
            // messages.

            pctRet = Ssl2UnpackServerHello(pCommInput, &pHello);
            if (PCT_ERR_OK == pctRet)
            {
                if (pHello->SessionIdHit)
                {
                    pctRet = Ssl2CliHandleServerRestart(
				                    pContext,
				                    pCommInput,
				                    pHello,
				                    pCommOutput);
                    if (PCT_ERR_OK == pctRet)
                    {
	                    pContext->State = SSL2_STATE_CLIENT_RESTART;
                    }
                }
                else
                {
                    if (pContext->RipeZombie->cbMasterKey != 0)
                    {
                        // We've attempted to do a reconnect and the server has
                        // blown us off. In this case we must use a new and different
                        // cache entry.
                        if (!SPCacheClone(&pContext->RipeZombie))
                        {
                            pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
                        }
                    }
                    if (pctRet == PCT_ERR_OK)
                    {
                        pContext->RipeZombie->fProtocol = SP_PROT_SSL2_CLIENT;
                        pctRet = Ssl2CliHandleServerHello(
                                        pContext,
                                        pCommInput,
                                        pHello,
                                        pCommOutput);
                    }
                    if (PCT_ERR_OK == pctRet)
                    {
	                    pContext->State = SSL2_STATE_CLIENT_MASTER_KEY;
                    }
                }
                SPExternalFree(pHello);
            }
            else if(pctRet != PCT_INT_INCOMPLETE_MSG)
            {
                pctRet |= PCT_INT_DROP_CONNECTION;
            }

            if (SP_FATAL(pctRet))
            {
                pContext->State = PCT1_STATE_ERROR;
            }
            break;
        }

        case (SSL2_MT_SERVER_VERIFY << 16) | SSL2_STATE_CLIENT_MASTER_KEY:
            pctRet = Ssl2CliHandleServerVerify(
		            pContext,
		            &MsgInput,
		            pCommOutput);
            if (PCT_ERR_OK == pctRet)
            {
                pContext->State =SSL2_STATE_CLIENT_FINISH;
            }
            if (SP_FATAL(pctRet))
            {
                pContext->State = PCT1_STATE_ERROR;
            }
            break;

        case (SSL2_MT_SERVER_VERIFY << 16) | SSL2_STATE_CLIENT_RESTART:
            pctRet = Ssl2CliFinishRestart(pContext, &MsgInput, pCommOutput);
            if (PCT_ERR_OK == pctRet)
            {
                pContext->State =SSL2_STATE_CLIENT_FINISH;
            }
            if (SP_FATAL(pctRet))
            {
                pContext->State = PCT1_STATE_ERROR;
            }

            // Note, we will transmit no data, but we expect a server finished message.
            // If the SSPI EXTRA DATA message is not processed by wininet
            // then we may be in trouble.

            break;

        case (SSL2_MT_SERVER_FINISHED_V2 << 16) | SSL2_STATE_CLIENT_FINISH:
            pctRet = Ssl2CliHandleServerFinish(
                                                pContext,
                                                &MsgInput,
                                                pCommOutput);
            if (SP_FATAL(pctRet))
            {
                pContext->State = PCT1_STATE_ERROR;
            }
            else
            {
                if (PCT_ERR_OK == pctRet)
                {
                    pContext->State = SP_STATE_CONNECTED;
                    pContext->DecryptHandler = Ssl2DecryptHandler;
                    pContext->Encrypt = Ssl2EncryptMessage;
                    pContext->Decrypt = Ssl2DecryptMessage;
                }
                // We received a non-fatal error, so the state doesn't
                // change, giving the app time to deal with this.
            }
            break;

        default:
            DebugLog((DEB_WARN, "Error in protocol, dwStateTransition is %lx\n", dwStateTransition));
            pContext->State = PCT1_STATE_ERROR;
            pctRet = PCT_INT_ILLEGAL_MSG;
            if (cMessageType == SSL2_MT_ERROR)
            {
                // BUGBUG: handle an SSL2 error message
            }
            break;
    }
    if (pctRet & PCT_INT_DROP_CONNECTION)
    {
	    pContext->State &= ~SP_STATE_CONNECTED;
    }
    // To handle incomplete message errors:
    return(pctRet);
}




SP_STATUS
Ssl2CliHandleServerHello(
    PSPContext pContext,
    PSPBuffer  pCommInput,
    PSsl2_Server_Hello pHello,
    PSPBuffer  pCommOutput)
{
    /* error to return to peer */
    SP_STATUS          pctRet=PCT_ERR_ILLEGAL_MESSAGE;

    Ssl2_Client_Master_Key   Key;
    DWORD               i,j;
    PUCHAR              pPortionToEncrypt;
    PSessCacheItem      pZombie;
    CertSystem *        pCertSys = NULL;
    DWORD dwKeyLen;
    Ssl2CipherMap       *pRank;
    DWORD               cRank;

    pCommOutput->cbData = 0;


    SP_BEGIN("Ssl2CliHandleServerHello");


     pZombie = pContext->RipeZombie;

    do {


        pContext->ReadCounter++;

        #if DBG
        DebugLog((DEB_TRACE, "Hello = %x\n", pHello));
        DebugLog((DEB_TRACE, "   Session ID hit \t%s\n", pHello->SessionIdHit ? "Yes" : "No"));
        DebugLog((DEB_TRACE, "   Certificate Type\t%d\n", pHello->CertificateType));
        DebugLog((DEB_TRACE, "   Certificate Len\t%d\n", pHello->cbCertificate));
        DebugLog((DEB_TRACE, "   cCipherSpecs   \t%d\n", pHello->cCipherSpecs));
        DebugLog((DEB_TRACE, "   ConnectionId   \t%d\n", pHello->cbConnectionID));
        for (i = 0 ; i < pHello->cCipherSpecs ; i++ )
        {
            DebugLog((DEB_TRACE, "    Cipher[%i] = %06x (%s)\n", i, pHello->pCipherSpecs[i],
                                    DbgGetNameOfCrypto(pHello->pCipherSpecs[i]) ));
        }
        #endif

        /* Cycle throug the array of cipher tuples to spec mappings
         * to find one that we support */

        pContext->pSystem = NULL;
        pContext->pCheck = NULL;
        pContext->pKeyExch = NULL;

        cRank = Ssl2NumCipherRanks;
        pRank = Ssl2CipherRank;

        for(j=0;j<pHello->cCipherSpecs;j++)
        {
            for(i=0; i<cRank; i++)
	        {

                if(pRank[i].Kind == pHello->pCipherSpecs[j])
                    break;
            }
            if(pRank[i].Kind != pHello->pCipherSpecs[j])
                continue;


            pZombie->SessCiphSpec  = pRank[i].Cipher;
            pZombie->SessHashSpec  = pRank[i].Hash;
            pZombie->SessExchSpec  = pRank[i].KeyExch;
            Key.CipherKind = pHello->pCipherSpecs[j];
            pctRet = ContextInitCiphers(pContext);
            if(PCT_ERR_OK == pctRet)
            {
                break;
            }

        }

        if(pContext->pSystem  == NULL ||
           pContext->pCheck   == NULL ||
           pContext->pKeyExch == NULL)
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
            break; /* Break out to error handler */
        }


        pctRet = SPLoadCertificate(pZombie->fProtocol,
                         pHello->CertificateType,
                         pHello->pCertificate,
                         pHello->cbCertificate,
                         &pZombie->pServerCert,
                         NULL);




        if(pctRet != PCT_ERR_OK)
        {
            break;
        }



        GenerateRandomBits(pZombie->pMasterKey, SSL2_MASTER_KEY_SIZE);
        pZombie->cbMasterKey = SSL2_MASTER_KEY_SIZE;


        CopyMemory(pContext->pConnectionID, pHello->ConnectionID, pHello->cbConnectionID);
        pContext->cbConnectionID = pHello->cbConnectionID;

        pctRet = Ssl2MakeSessionKeys(pContext);

        dwKeyLen = ((pZombie->SessCiphSpec & SP_CIPHER_STRENGTH) >> SP_CSTR_POS) / 8;

        if (dwKeyLen < SSL2_MASTER_KEY_SIZE)
        {
            pZombie->cbClearKey = SSL2_MASTER_KEY_SIZE - dwKeyLen;

            /* The clear key is just the first portion of the Master Key */
            CopyMemory(pZombie->pClearKey, pZombie->pMasterKey, pZombie->cbClearKey);
        }
        else
        {
            pZombie->cbClearKey = 0;
        }

        if (pZombie->cbClearKey)
        {
            CopyMemory(Key.ClearKey, pZombie->pMasterKey, pZombie->cbClearKey);
        }

        Key.ClearKeyLen = pZombie->cbClearKey;
        pPortionToEncrypt = &pZombie->pMasterKey[pZombie->cbClearKey];


        Key.EncryptedKeyLen = SSL2_ENCRYPTED_KEY_SIZE;


        if(!pContext->pKeyExch->Encrypt(
                            pPortionToEncrypt,
                            dwKeyLen,
                            Key.EncryptedKey,
                            &Key.EncryptedKeyLen,
                            pZombie->pServerCert->pPublicKey,
                            SP_PROT_SSL2_CLIENT))
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_BAD_CERTIFICATE);
            break;
        }

        Key.KeyArgLen = 0;
        pctRet = Ssl2PackClientMasterKey(&Key, pCommOutput);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        pContext->WriteCounter++;
        SP_RETURN(PCT_ERR_OK);
    } while(TRUE);
    if((pContext->Flags & CONTEXT_FLAG_EXT_ERR) &&
        (pctRet == PCT_ERR_SPECS_MISMATCH))
    {
        // Our SSL2 implementation does not do client auth,
        // so there is only one error message, cipher error.
        pCommOutput->cbData = 3; // MSG-ERROR + ERROR-CODE-MSB + ERROR-CODE-LSB

        if(pCommOutput->pvBuffer == NULL)
        {
            pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
            if (NULL == pCommOutput->pvBuffer)
            {
                return SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY);
            }
            pCommOutput->cbBuffer = pCommOutput->cbData;
        }
        if(pCommOutput->cbData > pCommOutput->cbBuffer)
        {
            return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
        }
        ((PUCHAR)pCommOutput->pvBuffer)[0] = SSL2_MT_ERROR;
        ((PUCHAR)pCommOutput->pvBuffer)[1] = MSBOF(SSL_PE_NO_CIPHER);
        ((PUCHAR)pCommOutput->pvBuffer)[2] = LSBOF(SSL_PE_NO_CIPHER);
    }
    SP_RETURN(pctRet | PCT_INT_DROP_CONNECTION);

}

SP_STATUS
Ssl2CliHandleServerRestart(
    PSPContext         pContext,
    PSPBuffer           pCommInput,
    PSsl2_Server_Hello  pHello,
    PSPBuffer           pCommOutput)
{
    /* error to return to peer */
    SP_STATUS          pctRet=PCT_ERR_ILLEGAL_MESSAGE;
    PSessCacheItem      pZombie;
    pCommOutput->cbData = 0;


    SP_BEGIN("Ssl2CliHandleServerRestart");

    pZombie = pContext->RipeZombie;

    do {
        pContext->ReadCounter++;


        /* if there's no zombie, the message is wrong.  We can't restart. */

        if(pZombie == NULL  ||
           pZombie->ZombieJuju == FALSE)
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
            break;
        }

		CopyMemory(pContext->pConnectionID,
		           pHello->ConnectionID,
		           pHello->cbConnectionID);

        pContext->cbConnectionID = pHello->cbConnectionID;


        /* Cert length, Cipher Specs, and Cert Type should be zero */

        // We know what our ciphers are, so init the cipher system
        pctRet = ContextInitCiphers(pContext);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }


        pctRet = Ssl2MakeSessionKeys(pContext);

        /* okay, now send the client finish */

        pctRet = Ssl2GenCliFinished(pContext, pCommOutput);

        SP_RETURN(pctRet);
    } while(TRUE);

    SP_RETURN(pctRet | PCT_INT_DROP_CONNECTION);
}


SP_STATUS
Ssl2GenCliFinished(
    PSPContext pContext,
    PSPBuffer  pCommOutput)
{
    SP_STATUS     pctRet = PCT_ERR_ILLEGAL_MESSAGE;

    PSSL2_SERVER_VERIFY     pVerify = NULL;
    PSSL2_CLIENT_FINISHED   pFinish;
    DWORD                   HeaderSize;
    SPBuffer                MsgOutput;
    DWORD                   cPadding;
    BOOL                    fAlloced=FALSE;

    SP_BEGIN("Ssl2GenCliFinished");



    pCommOutput->cbData = 0;

    MsgOutput.cbData = sizeof(UCHAR) + pContext->cbConnectionID;
    cPadding = (MsgOutput.cbData+pContext->pCheck->cbCheckSum) &
               (pContext->pSystem->BlockSize - 1);
    HeaderSize = (cPadding?3:2);
    pCommOutput->cbData = MsgOutput.cbData +
                          pContext->pCheck->cbCheckSum +
                          cPadding +
                          HeaderSize;

    /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL)
    {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);

        if (NULL == pCommOutput->pvBuffer)
        {
            SP_RETURN(SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY));
        }
        fAlloced = TRUE;
        pCommOutput->cbBuffer = pCommOutput->cbData;
    }

    if(pCommOutput->cbData > pCommOutput->cbBuffer)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL));
    }
    MsgOutput.pvBuffer= (PUCHAR)pCommOutput->pvBuffer +
                        HeaderSize +
                        pContext->pCheck->cbCheckSum;

    MsgOutput.cbBuffer = pCommOutput->cbBuffer -
                         HeaderSize-pContext->pCheck->cbCheckSum;

    MsgOutput.cbData = MsgOutput.cbBuffer;

    pFinish = (PSSL2_CLIENT_FINISHED) MsgOutput.pvBuffer;
    pFinish->MessageId = SSL2_MT_CLIENT_FINISHED_V2;

    CopyMemory( pFinish->ConnectionID,
                pContext->pConnectionID,
                pContext->cbConnectionID );

    pctRet = Ssl2EncryptMessage( pContext, &MsgOutput, pCommOutput);
    if(PCT_ERR_OK != pctRet)
    {
        SPExternalFree(pCommOutput->pvBuffer);
        pCommOutput->pvBuffer = NULL;
        pctRet |= PCT_INT_DROP_CONNECTION;
        pCommOutput->cbBuffer = 0;
    }

    SP_RETURN(pctRet);

}


SP_STATUS
Ssl2CliHandleServerVerify(
    PSPContext pContext,
    PSPBuffer   pCommInput,
    PSPBuffer   pCommOutput)
{
    SP_STATUS     pctRet = PCT_ERR_ILLEGAL_MESSAGE;

    PSSL2_SERVER_VERIFY     pVerify = NULL;

    /* Read and Write Counters are incremented by the encrypt and decrypt */
    SP_BEGIN("Ssl2CliHandleServerVerify");



    pCommOutput->cbData = 0;

    /* Note, there is no header in this message, as it has been pre-decrypted */
    if(pCommInput->cbData != sizeof(UCHAR) + pContext->cbChallenge)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    pVerify = pCommInput->pvBuffer;

    if (pVerify->MessageId != SSL2_MT_SERVER_VERIFY)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    if (memcmp( pVerify->ChallengeData,
                pContext->pChallenge,
                pContext->cbChallenge) )
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }


    pctRet = Ssl2GenCliFinished( pContext, pCommOutput);
    SP_RETURN(pctRet);
}

SP_STATUS
Ssl2CliFinishRestart(
    PSPContext pContext,
    PSPBuffer   pCommInput,
    PSPBuffer   pCommOutput)
{
    SP_STATUS     pctRet = PCT_ERR_ILLEGAL_MESSAGE;

    PSSL2_SERVER_VERIFY     pVerify = NULL;

    /* Read and Write Counters are incremented by the encrypt and decrypt */
    SP_BEGIN("Ssl2CliFinishRestart");



    pCommOutput->cbData = 0;

    /* Note, there is no header in this message, as it has been pre-decrypted */
    if(pCommInput->cbData != sizeof(UCHAR) + pContext->cbChallenge)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    pVerify = pCommInput->pvBuffer;

    if (pVerify->MessageId != SSL2_MT_SERVER_VERIFY)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    if (memcmp( pVerify->ChallengeData,
                pContext->pChallenge,
                pContext->cbChallenge) )
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }
    SP_RETURN(PCT_ERR_OK);
}

SP_STATUS
Ssl2CliHandleServerFinish(
    PSPContext pContext,
    PSPBuffer  pCommInput,
    PSPBuffer  pCommOutput)
{
    SP_STATUS     pctRet = PCT_ERR_ILLEGAL_MESSAGE;

    PSSL2_SERVER_FINISHED     pFinished = NULL;

    SP_BEGIN("Ssl2CliHandleServerFinish");



    pCommOutput->cbData = 0;


    /* Note, there is no header in this message, as it has been pre-decrypted */
    if(pCommInput->cbData < sizeof(UCHAR))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    pFinished = pCommInput->pvBuffer;

    if (pFinished->MessageId != SSL2_MT_SERVER_FINISHED_V2)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    if((pCommInput->cbData-1) != SSL2_SESSION_ID_LEN)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }
    CopyMemory( pContext->RipeZombie->SessionID,
                pFinished->SessionID,
                pCommInput->cbData - 1);
    pContext->RipeZombie->cbSessionID = pCommInput->cbData - 1;

    SPCacheAdd(pContext->RipeZombie);

    SP_RETURN(PCT_ERR_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\specmap.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/

typedef struct csel
{
    DWORD               fProtocol;
    DWORD               fDefault;
    CipherSpec          Spec;
    PTSTR               szName;
    const CryptoSystem *      System;
} CipherInfo, *PCipherInfo;

typedef struct hsel
{
    DWORD               fProtocol;
    DWORD               fDefault;
    HashSpec            Spec;
    PTSTR               szName;
    const CheckSumFunction *  System;
} HashInfo, *PHashInfo;

typedef struct kexch
{
    DWORD               fProtocol;
    DWORD               fDefault;
    ExchSpec            Spec;
    PTSTR               szName;
    const KeyExchangeSystem * System;
} KeyExchangeInfo, *PKeyExchangeInfo;

typedef struct certsel
{
    DWORD               fProtocol;
    DWORD               fDefault;
    CertSpec            Spec;
    PTSTR               szName;
    const CertSystem   *      System;
} CertSysInfo, *PCertSysInfo;

typedef struct sigsel
{
    DWORD               fProtocol;
    DWORD               fDefault;
    SigSpec             Spec;
    PTSTR               szName;
    const SignatureSystem  *  System;
} SigInfo, *PSigInfo;


PCipherInfo         GetCipherInfo(CipherSpec Spec);

PHashInfo           GetHashInfo(HashSpec Spec);

PKeyExchangeInfo    GetKeyExchangeInfo(ExchSpec Spec);

PCertSysInfo        GetCertSysInfo(CertSpec Spec);

PSigInfo            GetSigInfo(SigSpec Spec);


const CryptoSystem *      CipherFromSpec(CipherSpec Spec, DWORD fProtocol);

const CheckSumFunction *  HashFromSpec(HashSpec Spec, DWORD fProtocol);

const KeyExchangeSystem * KeyExchangeFromSpec(ExchSpec Spec, DWORD fProtocol);

const CertSystem *        CertFromSpec(CertSpec Spec, DWORD fProtocol);

const SignatureSystem *   SigFromSpec(SigSpec Spec, DWORD fProtocol);


extern CipherInfo  SPAvailableCiphers[];
extern const DWORD SPNumAvailableCiphers;

extern HashInfo  SPAvailableHashes[];
extern const DWORD SPNumAvailableHashes;

extern CertSysInfo   SPAvailableCerts[];
extern const DWORD SPNumAvailableCerts;

extern SigInfo SPAvailableSigs[];
extern const DWORD SPNumAvailableSigs;

extern KeyExchangeInfo SPAvailableExch[];
extern const DWORD SPNumAvailableExch;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\ssl2msg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       msgs.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-02-95   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __SSL2MSG_H__
#define __SSL2MSG_H__

typedef struct _Ssl2_Cipher_Tuple {
    UCHAR   C1;
    UCHAR   C2;
    UCHAR   C3;
} Ssl2_Cipher_Tuple, * PSsl2_Cipher_Tuple;

///////////////////////////////////////////////////////////////////
//
// Useful Macros
//
///////////////////////////////////////////////////////////////////

#define LSBOF(x)    ((UCHAR) (x & 0xFF))
#define MSBOF(x)    ((UCHAR) ((x >> 8) & 0xFF) )

#define COMBINEBYTES(Msb, Lsb)  ((DWORD) (((DWORD) (Msb) << 8) | (DWORD) (Lsb)))



///////////////////////////////////////////////////////////////////
//
// Message Constants
//
///////////////////////////////////////////////////////////////////

#define SSL2_CLIENT_VERSION          0x0002
#define SSL2_SERVER_VERSION          0x0002

#define SSL2_CLIENT_VERSION_MSB      0x00
#define SSL2_CLIENT_VERSION_LSB      0x02

#define SSL2_SERVER_VERSION_MSB      0x00
#define SSL2_SERVER_VERSION_LSB      0x02

#ifdef DO_PCT_COMPAT
#define PCT_COMPAT_VERSION_MSB		0x83
#define PCT_COMPAT_VERSION_LSB		0x01
#endif

#define SSL2_MT_ERROR                0
#define SSL2_MT_CLIENT_HELLO         1
#define SSL2_MT_CLIENT_MASTER_KEY    2
#define SSL2_MT_CLIENT_FINISHED_V2   3
#define SSL2_MT_SERVER_HELLO         4
#define SSL2_MT_SERVER_VERIFY        5
#define SSL2_MT_SERVER_FINISHED_V2   6
#define SSL2_MT_REQUEST_CERTIFICATE  7
#define SSL2_MT_CLIENT_CERTIFICATE   8
#define SSL2_MT_CLIENT_DH_KEY        9
#define SSL2_MT_CLIENT_SESSION_KEY   10
#define SSL2_MT_CLIENT_FINISHED      11
#define SSL2_MT_SERVER_FINISHED      12

#define SSL_PE_NO_CIPHER            0x0001
#define SSL_PE_NO_CERTIFICATE       0x0002
#define SSL_PE_BAD_CERTIFICATE      0x0004
#define SSL_PE_UNSUPPORTED_CERTIFICATE_TYPE 0x0006


#define SSL_CT_X509_CERTIFICATE     0x01
#define SSL_CT_PKCS7_CERTIFICATE    0x02

#if DBG
#define SSL_CT_DEBUG_CERT           0x80
#endif

#define SSL2_MAX_CHALLENGE_LEN       32  /* max accepted challenge size */
#define SSL2_CHALLENGE_SIZE          16  /* default generated challenge size */
#define SSL2_SESSION_ID_LEN          16
#define SSL2_GEN_CONNECTION_ID_LEN   16  /* Dont change this, netscape requires 16 byte 
                                          * id's */
#define SSL2_MAX_CONNECTION_ID_LEN   32
#define SSL3_SESSION_ID_LEN			 32
#define SSL2_MAC_LENGTH              16
#define SSL2_MASTER_KEY_SIZE         16
#define SSL2_ENCRYPTED_KEY_SIZE     272         // Allows for 2048 bit keys
#define SSL2_MAX_MESSAGE_LENGTH     32768
#define MAX_UNI_CIPHERS 32

#define SSL_MKFAST(a, b, c) (DWORD)(((a)<<16) | ((b)<<8) | (c))

#define SSL_MKSLOW(a) (UCHAR)((a>>16)& 0xff), (UCHAR)((a>>8)& 0xff), (UCHAR)((a)& 0xff)

#define SSL_RSA_WITH_RC4_128_MD5				SSL_MKFAST(0x00, 0x00,  0x04)
#define SSL_RSA_EXPORT_WITH_RC4_40_MD5			SSL_MKFAST(0x00, 0x00,  0x03)

#define SSL_CK_RC4_128_WITH_MD5                 SSL_MKFAST(0x01, 0x00,  0x80)
#define SSL_CK_RC4_128_EXPORT40_WITH_MD5        SSL_MKFAST(0x02, 0x00,  0x80)
#define SSL_CK_RC2_128_CBC_WITH_MD5             SSL_MKFAST(0x03, 0x00,  0x80)
#define SSL_CK_RC2_128_CBC_EXPORT40_WITH_MD5    SSL_MKFAST(0x04, 0x00,  0x80)
#define SSL_CK_IDEA_128_CBC_WITH_MD5            SSL_MKFAST(0x05, 0x00,  0x80)
#define SSL_CK_DES_64_CBC_WITH_MD5              SSL_MKFAST(0x06, 0x00,  0x40)
#define SSL_CK_DES_192_EDE3_CBC_WITH_MD5        SSL_MKFAST(0x07, 0x00,  0xC0)
#define SSL_CK_NULL_WITH_MD5                    SSL_MKFAST(0x00, 0x00,  0x00)
#define SSL_CK_DES_64_CBC_WITH_SHA              SSL_MKFAST(0x06, 0x01,  0x40)
#define SSL_CK_DES_192_EDE3_WITH_SHA            SSL_MKFAST(0x07, 0x01,  0xC0)

#define SSL_CK_RC4_128_FINANCE64_WITH_MD5	SSL_MKFAST(0x08, 0x00, 0x80)

#ifdef ENABLE_NONE_CIPHER
#define SSL_CK_NONE                        SSL_MKFAST(0x09, 0x00,  0x00)
#endif



#define SSL_KEA_RSA                             {(UCHAR) 0x10, (UCHAR) 0x00, (UCHAR) 0x00}
#define SSL_KEA_RSA_TOKEN_WITH_DES              {(UCHAR) 0x10, (UCHAR) 0x01, (UCHAR) 0x00}
#define SSL_KEA_RSA_TOKEN_WITH_DES_EDE3         {(UCHAR) 0x10, (UCHAR) 0x01, (UCHAR) 0x01}
#define SSL_KEA_RSA_TOKEN_WITH_RC4              {(UCHAR) 0x10, (UCHAR) 0x01, (UCHAR) 0x02}
#define SSL_KEA_DH                              {(UCHAR) 0x11, (UCHAR) 0x00, (UCHAR) 0x00}
#define SSL_KEA_DH_TOKEN_WITH_DES               {(UCHAR) 0x11, (UCHAR) 0x01, (UCHAR) 0x00}
#define SSL_KEA_DH_TOKEN_WITH_DES_EDE3          {(UCHAR) 0x11, (UCHAR) 0x01, (UCHAR) 0x01}
#define SSL_KEA_DH_ANON                         {(UCHAR) 0x12, (UCHAR) 0x00, (UCHAR) 0x00}

#define CRYPTO_RC4_128  0x00010080
#define CRYPTO_RC4_40   0x00020080
#define CRYPTO_RC2_128  0x00030080
#define CRYPTO_RC2_40   0x00040080
#define CRYPTO_IDEA_128 0x00050080
#define CRYPTO_NULL     0x00000000
#define CRYPTO_DES_64   0x00060040
#define CRYPTO_3DES_192 0x000700C0


typedef DWORD Ssl2_Cipher_Kind;

typedef struct _Ssl2CipherMap {
	Ssl2_Cipher_Kind  Kind;
	HashSpec          Hash;
	CipherSpec        Cipher;
	ExchSpec          KeyExch;
} Ssl2CipherMap, *PSsl2CipherMap;


typedef struct _SSL2_MESSAGE_HEADER {
    UCHAR   Byte0;
    UCHAR   Byte1;
} SSL2_MESSAGE_HEADER, * PSSL2_MESSAGE_HEADER;

typedef struct _SSL2_MESSAGE_HEADER_EX {
    UCHAR   Byte0;
    UCHAR   Byte1;
    UCHAR   PaddingSize;
} SSL2_MESSAGE_HEADER_EX, * PSSL2_MESSAGE_HEADER_EX;


typedef struct _SSL2_ERROR {
    SSL2_MESSAGE_HEADER   Header;
    UCHAR               MessageId;
    UCHAR               ErrorMsb;
    UCHAR               ErrorLsb;
} SSL2_ERROR, * PSSL2_ERROR;


typedef struct _SSL2_CLIENT_HELLO {
    SSL2_MESSAGE_HEADER   Header;
    UCHAR               MessageId;
    UCHAR               VersionMsb;
    UCHAR               VersionLsb;
    UCHAR               CipherSpecsLenMsb;
    UCHAR               CipherSpecsLenLsb;
    UCHAR               SessionIdLenMsb;
    UCHAR               SessionIdLenLsb;
    UCHAR               ChallengeLenMsb;
    UCHAR               ChallengeLenLsb;
    UCHAR               VariantData[1];
} SSL2_CLIENT_HELLO, * PSSL2_CLIENT_HELLO;


typedef struct _SSL2_SERVER_HELLO {
    SSL2_MESSAGE_HEADER   Header;
    UCHAR               MessageId;
    UCHAR               SessionIdHit;
    UCHAR               CertificateType;
    UCHAR               ServerVersionMsb;
    UCHAR               ServerVersionLsb;
    UCHAR               CertificateLenMsb;
    UCHAR               CertificateLenLsb;
    UCHAR               CipherSpecsLenMsb;
    UCHAR               CipherSpecsLenLsb;
    UCHAR               ConnectionIdLenMsb;
    UCHAR               ConnectionIdLenLsb;
    UCHAR               VariantData[1];
} SSL2_SERVER_HELLO, * PSSL2_SERVER_HELLO;

typedef struct _SSL2_CLIENT_MASTER_KEY {
    SSL2_MESSAGE_HEADER   Header;
    UCHAR               MessageId;
    Ssl2_Cipher_Tuple    CipherKind;
    UCHAR               ClearKeyLenMsb;
    UCHAR               ClearKeyLenLsb;
    UCHAR               EncryptedKeyLenMsb;
    UCHAR               EncryptedKeyLenLsb;
    UCHAR               KeyArgLenMsb;
    UCHAR               KeyArgLenLsb;
    UCHAR               VariantData[1];
} SSL2_CLIENT_MASTER_KEY, * PSSL2_CLIENT_MASTER_KEY;


typedef struct _SSL2_SERVER_VERIFY {
    UCHAR               MessageId;
    UCHAR               ChallengeData[SSL2_MAX_CHALLENGE_LEN];
} SSL2_SERVER_VERIFY, * PSSL2_SERVER_VERIFY;

typedef struct _SSL2_CLIENT_FINISHED {
    UCHAR               MessageId;
    UCHAR               ConnectionID[SSL2_MAX_CONNECTION_ID_LEN];
} SSL2_CLIENT_FINISHED, * PSSL2_CLIENT_FINISHED;

typedef struct _SSL2_SERVER_FINISHED {
    UCHAR               MessageId;
    UCHAR               SessionID[SSL2_SESSION_ID_LEN];
} SSL2_SERVER_FINISHED, * PSSL2_SERVER_FINISHED;



////////////////////////////////////////////////////
//
// Expanded Form Messages:
//
////////////////////////////////////////////////////

/* Rules for buffer in expanded form */
/* Only things which are going to be allocated
 * anyway, or are created statically are not created 
 * as arrays */

typedef DWORD   CipherSpec;
typedef DWORD * PCipherSpec;

typedef struct _Ssl2_Client_Hello {
	DWORD			dwVer;
    DWORD           cCipherSpecs;
	DWORD           cbSessionID;
	DWORD           cbChallenge;
    Ssl2_Cipher_Kind CipherSpecs[MAX_UNI_CIPHERS]; /* points to static array */
    UCHAR           SessionID[SSL3_SESSION_ID_LEN];   //NOTE: changed to 32 bytes long....
    UCHAR           Challenge[SSL2_MAX_CHALLENGE_LEN];
} Ssl2_Client_Hello, * PSsl2_Client_Hello;

typedef struct _Ssl2_Server_Hello {
    DWORD           SessionIdHit;
    DWORD           CertificateType;
    DWORD           cbCertificate;
    DWORD           cCipherSpecs;
	DWORD           cbConnectionID;
    UCHAR           ConnectionID[SSL2_MAX_CONNECTION_ID_LEN];
    PUCHAR          pCertificate;       /* points to pre-created cert */
    Ssl2_Cipher_Kind *    pCipherSpecs; /* points to static array */
} Ssl2_Server_Hello, * PSsl2_Server_Hello;


typedef struct _Ssl2_Client_Master_Key {
    DWORD           	ClearKeyLen;
    DWORD           	EncryptedKeyLen;
    DWORD           	KeyArgLen;
    Ssl2_Cipher_Kind    CipherKind;
    UCHAR           	ClearKey[SSL2_MASTER_KEY_SIZE];
    UCHAR           	EncryptedKey[SSL2_ENCRYPTED_KEY_SIZE];
    UCHAR           	KeyArg[SSL2_MASTER_KEY_SIZE];
} Ssl2_Client_Master_Key, * PSsl2_Client_Master_Key;

///////////////////////////////////////////////////
//
// Pickling Prototypes
//
///////////////////////////////////////////////////
SP_STATUS
Ssl2PackClientHello(
    PSsl2_Client_Hello      pCanonical,
    PSPBuffer               pCommOutput);

SP_STATUS
Ssl2UnpackClientHello(
    PSPBuffer          pInput,
    PSsl2_Client_Hello *     ppClient);

SP_STATUS
Ssl2PackServerHello(
    PSsl2_Server_Hello       pCanonical,
    PSPBuffer          pCommOutput);

SP_STATUS
Ssl2UnpackServerHello(
    PSPBuffer          pInput,
    PSsl2_Server_Hello *     ppServer);

SP_STATUS
Ssl2PackClientMasterKey(
    PSsl2_Client_Master_Key      pCanonical,
    PSPBuffer              pCommOutput);

SP_STATUS
Ssl2UnpackClientMasterKey(
    PSPBuffer              pInput,
    PSsl2_Client_Master_Key *    ppClient);



#endif /* __SSL2MSG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\ssl2pkl.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       pickle.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-02-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <ssl2msg.h>

#define SSL_OFFSET_OF(t, v) (DWORD)&(((t)NULL)->v)



#define SIZEOF(pMessage)    (SslRecordSize((PSSL2_MESSAGE_HEADER) pMessage ) )

DWORD
SslRecordSize(
    PSSL2_MESSAGE_HEADER  pHeader)
{
    DWORD   Size;

    if (pHeader->Byte0 & 0x80)
    {
        Size = COMBINEBYTES(pHeader->Byte0, pHeader->Byte1) & 0x7FFF;
    }
    else
    {
        Size = COMBINEBYTES(pHeader->Byte0, pHeader->Byte1) & 0x3FFF;
    }
    return(Size);
}



BOOL
Ssl2MapCipherToExternal(
    Ssl2_Cipher_Kind     FastForm,
    PSsl2_Cipher_Tuple   pTuple)
{
    pTuple->C1 = (UCHAR)((FastForm >> 16) & 0xff);
    pTuple->C2 = (UCHAR)((FastForm >> 8) & 0xff);
    pTuple->C3 = (UCHAR)(FastForm & 0xff);


    return(TRUE);
}

Ssl2_Cipher_Kind
Ssl2MapCipherFromExternal(
    PSsl2_Cipher_Tuple   pTuple)
{

    return SSL_MKFAST(pTuple->C1, pTuple->C2, pTuple->C3);
}



SP_STATUS
Ssl2PackClientHello(
    PSsl2_Client_Hello       pCanonical,
    PSPBuffer                pCommOutput)
{
    DWORD               cbMessage;
    PSSL2_CLIENT_HELLO  pMessage;
    DWORD               Size;
    PUCHAR              pBuffer;
    DWORD               i;

    if(pCanonical == NULL || pCommOutput == NULL) return PCT_INT_INTERNAL_ERROR;
    pCommOutput->cbData = 0;

    pCommOutput->cbData = pCanonical->cbSessionID +
                            pCanonical->cbChallenge +
                            pCanonical->cCipherSpecs * sizeof(Ssl2_Cipher_Tuple) +
                            SSL_OFFSET_OF(PSSL2_CLIENT_HELLO, VariantData);

    cbMessage = pCommOutput->cbData - sizeof(SSL2_MESSAGE_HEADER);

    /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL) 
    {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
        {
            return SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY);
        }
        pCommOutput->cbBuffer = pCommOutput->cbData;
    }
    if(pCommOutput->cbData > pCommOutput->cbBuffer)
    {
        return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
    }

    pMessage = pCommOutput->pvBuffer;

    pMessage->MessageId = SSL2_MT_CLIENT_HELLO;
    
    pMessage->VersionMsb = MSBOF(pCanonical->dwVer);
    pMessage->VersionLsb = LSBOF(pCanonical->dwVer);

    pBuffer = pMessage->VariantData;

    cbMessage -= pCanonical->cCipherSpecs * sizeof(Ssl2_Cipher_Tuple);
    pCommOutput->cbData -= pCanonical->cCipherSpecs * sizeof(Ssl2_Cipher_Tuple);

    Size = 0;

    for (i = 0; i < pCanonical->cCipherSpecs ; i++ )
    {
        if (!Ssl2MapCipherToExternal(pCanonical->CipherSpecs[i],
                                (PSsl2_Cipher_Tuple) pBuffer) )
        {
            continue;
        }

        pBuffer += sizeof(Ssl2_Cipher_Tuple);
        Size += sizeof(Ssl2_Cipher_Tuple);
    }

    cbMessage += Size;
    pCommOutput->cbData += Size;

    pCommOutput->cbData = cbMessage + 2;

    pMessage->Header.Byte0 = MSBOF(cbMessage) | 0x80;
    pMessage->Header.Byte1 = LSBOF(cbMessage);

    pMessage->CipherSpecsLenMsb = MSBOF(Size);
    pMessage->CipherSpecsLenLsb = LSBOF(Size);

    pMessage->SessionIdLenMsb = MSBOF(pCanonical->cbSessionID);
    pMessage->SessionIdLenLsb = LSBOF(pCanonical->cbSessionID);
    if (pCanonical->cbSessionID)
    {
        CopyMemory( pBuffer,
                    pCanonical->SessionID,
                    pCanonical->cbSessionID);

        pBuffer += pCanonical->cbSessionID;
    }

    pMessage->ChallengeLenMsb = MSBOF(pCanonical->cbChallenge);
    pMessage->ChallengeLenLsb = LSBOF(pCanonical->cbChallenge);
    if (pCanonical->cbChallenge)
    {
        CopyMemory( pBuffer,
                    pCanonical->Challenge,
                    pCanonical->cbChallenge);
    }

    return(PCT_ERR_OK);
}


SP_STATUS
Ssl2UnpackClientHello(
    PSPBuffer              pInput,
    PSsl2_Client_Hello *   ppClient)
{

    PSSL2_CLIENT_HELLO   pMessage;
    DWORD               ReportedSize;
    DWORD               CipherSpecsSize;
    DWORD               cCipherSpecs;
    PSsl2_Client_Hello       pCanonical;
    PUCHAR              pBuffer;
    DWORD               Size;
    DWORD               i, dwVer;

    pMessage = pInput->pvBuffer;

    if(pInput->cbData < 2) 
    {
        pInput->cbData = 2;
        return PCT_INT_INCOMPLETE_MSG;
    }

    ReportedSize = SIZEOF(pMessage);
    if ((ReportedSize+2) > pInput->cbData)
    {
        pInput->cbData = ReportedSize+2;
        return PCT_INT_INCOMPLETE_MSG;
    }
    if(ReportedSize < SSL_OFFSET_OF(PSSL2_CLIENT_HELLO, VariantData))
    {
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

    if (pMessage->MessageId != SSL2_MT_CLIENT_HELLO) {
        return (PCT_ERR_ILLEGAL_MESSAGE);
    }
 
    dwVer = COMBINEBYTES(pMessage->VersionMsb, pMessage->VersionLsb);

    if (dwVer  < 2) //VERSION 2 WILL COMPUTE TO 2 (00:02)
    {
        return(PCT_ERR_ILLEGAL_MESSAGE);
    }

    CipherSpecsSize = COMBINEBYTES( pMessage->CipherSpecsLenMsb,
                                    pMessage->CipherSpecsLenLsb );


    *ppClient = NULL;
    /* check that this all fits into the message */
    if (SSL_OFFSET_OF(PSSL2_CLIENT_HELLO, VariantData)
        - sizeof(SSL2_MESSAGE_HEADER)       /* don't count the header */
        + CipherSpecsSize
        > ReportedSize)
    {
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

        cCipherSpecs = CipherSpecsSize / sizeof(Ssl2_Cipher_Tuple);


    /* Allocate a buffer for the canonical client hello */
    pCanonical = (PSsl2_Client_Hello)SPExternalAlloc(
                                    sizeof(Ssl2_Client_Hello) +
                                    cCipherSpecs * sizeof(UNICipherMap));

    if (!pCanonical)
    {
        return(PCT_INT_INTERNAL_ERROR);
    }

    pCanonical->dwVer = COMBINEBYTES(    pMessage->VersionMsb,
                            pMessage->VersionLsb );

    pBuffer = pMessage->VariantData;


    pCanonical->cCipherSpecs = cCipherSpecs;

    for (i = 0 ; i < cCipherSpecs ; i++ )
    {
        pCanonical->CipherSpecs[i] = Ssl2MapCipherFromExternal((PSsl2_Cipher_Tuple)
                                                    pBuffer);

        pBuffer += sizeof(Ssl2_Cipher_Tuple);
    }

    Size = COMBINEBYTES(    pMessage->SessionIdLenMsb,
                            pMessage->SessionIdLenLsb );

    if ((Size >= 0) && (Size <= SSL2_SESSION_ID_LEN))
    {
        CopyMemory( pCanonical->SessionID, pBuffer, Size);
        pBuffer += Size;

    }
    else
    {
        SPExternalFree( pCanonical );
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

    pCanonical->cbSessionID = Size;

    Size = COMBINEBYTES(    pMessage->ChallengeLenMsb,
                            pMessage->ChallengeLenLsb );

    if ((Size > 0) && (Size <= SSL2_MAX_CHALLENGE_LEN))
    {
        CopyMemory( pCanonical->Challenge, pBuffer, Size );

        pBuffer += Size;
    }
    else
    {
        SPExternalFree( pCanonical );
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

    pCanonical->cbChallenge = Size;

    *ppClient = pCanonical;
    pInput->cbData = ReportedSize + sizeof(SSL2_MESSAGE_HEADER);
    return( PCT_ERR_OK );

}

SP_STATUS
Ssl2PackServerHello(
    PSsl2_Server_Hello       pCanonical,
    PSPBuffer          pCommOutput)
{
    DWORD               cbMessage;
    PSSL2_SERVER_HELLO  pMessage;
    DWORD               Size;
    PUCHAR              pBuffer;
    DWORD               i;

    if(pCanonical == NULL || pCommOutput == NULL)
    {
        return PCT_INT_INTERNAL_ERROR;
    }
    pCommOutput->cbData = 0;

    cbMessage = pCanonical->cbConnectionID +
                    pCanonical->cbCertificate +
                    pCanonical->cCipherSpecs * sizeof(Ssl2_Cipher_Tuple) +
                    SSL_OFFSET_OF(PSSL2_SERVER_HELLO, VariantData) -
                    sizeof(SSL2_MESSAGE_HEADER);

    pCommOutput->cbData = cbMessage + 2;


    /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL) 
    {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
        {
            return SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY);
        }
        pCommOutput->cbBuffer = pCommOutput->cbData;
    }
    if(pCommOutput->cbData > pCommOutput->cbBuffer)
    {
        return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
    }

    pMessage = pCommOutput->pvBuffer;


    pMessage->MessageId = SSL2_MT_SERVER_HELLO;
    pMessage->ServerVersionMsb = SSL2_SERVER_VERSION_MSB;
    pMessage->ServerVersionLsb = SSL2_SERVER_VERSION_LSB;
    pMessage->SessionIdHit = (UCHAR) pCanonical->SessionIdHit;
    pMessage->CertificateType = (UCHAR) pCanonical->CertificateType;

    pBuffer = pMessage->VariantData;

    //
    // Pack certificate if present
    //

    pMessage->CertificateLenMsb = MSBOF(pCanonical->cbCertificate);
    pMessage->CertificateLenLsb = LSBOF(pCanonical->cbCertificate);

    if (pCanonical->cbCertificate)
    {
        CopyMemory( pBuffer,
                    pCanonical->pCertificate,
                    pCanonical->cbCertificate);

        pBuffer += pCanonical->cbCertificate ;
    }

    Size = pCanonical->cCipherSpecs * sizeof(Ssl2_Cipher_Tuple);

    for (i = 0; i < pCanonical->cCipherSpecs ; i++ )
    {
        if (Ssl2MapCipherToExternal(pCanonical->pCipherSpecs[i],
                                (PSsl2_Cipher_Tuple) pBuffer) )
        {
            pBuffer += sizeof(Ssl2_Cipher_Tuple);
        }
        else
        {
            Size -= sizeof(Ssl2_Cipher_Tuple);
            cbMessage -= sizeof(Ssl2_Cipher_Tuple);
        }
    }

    pCommOutput->cbData = cbMessage + 2;

    pMessage->Header.Byte0 = MSBOF(cbMessage) | 0x80;
    pMessage->Header.Byte1 = LSBOF(cbMessage);

    pMessage->CipherSpecsLenMsb = MSBOF(Size);
    pMessage->CipherSpecsLenLsb = LSBOF(Size);

    pMessage->ConnectionIdLenMsb = MSBOF(pCanonical->cbConnectionID);
    pMessage->ConnectionIdLenLsb = LSBOF(pCanonical->cbConnectionID);
    if (pCanonical->cbConnectionID)
    {
        CopyMemory( pBuffer,
                    pCanonical->ConnectionID,
                    pCanonical->cbConnectionID);

        pBuffer += pCanonical->cbConnectionID;
    }


    return( PCT_ERR_OK );

}


SP_STATUS
Ssl2UnpackServerHello(
    PSPBuffer          pInput,
    PSsl2_Server_Hello *     ppServer)
{
    PSsl2_Server_Hello       pCanonical;
    PSSL2_SERVER_HELLO   pMessage;
    PUCHAR              pBuffer;
    DWORD               cbCertificate;
    DWORD               cCipherSpecs;
    DWORD               cbConnId;
    DWORD               i;
    DWORD               ReportedSize;

    pMessage = pInput->pvBuffer;
    if(pInput->cbData < 2) 
    {
        pInput->cbData = 2;
        return PCT_INT_INCOMPLETE_MSG;
    }

    ReportedSize = SIZEOF(pMessage);
    if ((ReportedSize+2) > pInput->cbData)
    {
        pInput->cbData = ReportedSize+2;
        return PCT_INT_INCOMPLETE_MSG;
    }


    if(ReportedSize <  SSL_OFFSET_OF(PSSL2_SERVER_HELLO, VariantData) )
    {
        return PCT_ERR_ILLEGAL_MESSAGE;
    }
    *ppServer = NULL;

    //
    // Verify Header:
    //

    if ((pMessage->MessageId != SSL2_MT_SERVER_HELLO) ||
        (pMessage->ServerVersionMsb != SSL2_SERVER_VERSION_MSB) ||
        (pMessage->ServerVersionLsb != SSL2_SERVER_VERSION_LSB) )
    {
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

    cbCertificate = COMBINEBYTES(   pMessage->CertificateLenMsb,
                                    pMessage->CertificateLenLsb);

    cCipherSpecs = COMBINEBYTES(pMessage->CipherSpecsLenMsb,
                                pMessage->CipherSpecsLenLsb);

    cCipherSpecs /= sizeof(Ssl2_Cipher_Tuple);

    cbConnId = COMBINEBYTES(pMessage->ConnectionIdLenMsb,
                            pMessage->ConnectionIdLenLsb);

    pCanonical = (PSsl2_Server_Hello)SPExternalAlloc(
                        sizeof(Ssl2_Server_Hello) +
                        cCipherSpecs * sizeof(Ssl2_Cipher_Kind)  +
                        cbCertificate );


    if (!pCanonical)
    {
        return(PCT_INT_OUT_OF_MEMORY);
    }

    pCanonical->pCertificate = (PUCHAR) (pCanonical + 1);
    pCanonical->pCipherSpecs = (PCipherSpec) (pCanonical + 1);
    pCanonical->pCertificate = (PUCHAR) (pCanonical->pCipherSpecs + cCipherSpecs);



    //
    // Expand out:
    //

    pCanonical->SessionIdHit = (DWORD) pMessage->SessionIdHit;
    pCanonical->CertificateType = (DWORD) pMessage->CertificateType;
    pCanonical->cbCertificate = cbCertificate;
    pCanonical->cCipherSpecs = cCipherSpecs;
    pCanonical->cbConnectionID = cbConnId;

    pBuffer = pMessage->VariantData;

    CopyMemory(pCanonical->pCertificate, pBuffer, cbCertificate);
    pBuffer += cbCertificate;

    for (i = 0 ; i < cCipherSpecs ; i++ )
    {
        pCanonical->pCipherSpecs[i] = Ssl2MapCipherFromExternal((PSsl2_Cipher_Tuple)
                                                                pBuffer);

        pBuffer += sizeof(Ssl2_Cipher_Tuple);
    }

    if ((cbConnId) && (cbConnId <= SSL2_MAX_CONNECTION_ID_LEN))
    {
        CopyMemory(pCanonical->ConnectionID, pBuffer, cbConnId);
    } 
    else
    {
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

    *ppServer = pCanonical;
    pInput->cbData = ReportedSize + sizeof(SSL2_MESSAGE_HEADER);
    return( PCT_ERR_OK);

}

SP_STATUS
Ssl2PackClientMasterKey(
    PSsl2_Client_Master_Key      pCanonical,
    PSPBuffer              pCommOutput)
{
    DWORD                   cbMessage;
    PSSL2_CLIENT_MASTER_KEY pMessage;
    PUCHAR                  pBuffer;

    cbMessage = pCanonical->ClearKeyLen +
                    pCanonical->EncryptedKeyLen +
                    pCanonical->KeyArgLen +
                    SSL_OFFSET_OF(PSSL2_CLIENT_MASTER_KEY, VariantData) -
                    sizeof(SSL2_MESSAGE_HEADER);

    pCommOutput->cbData = cbMessage + 2;

        /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL) 
    {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
        {
            return SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY);
        }
        pCommOutput->cbBuffer = pCommOutput->cbData;
    }
    if(pCommOutput->cbData > pCommOutput->cbBuffer)
    {
        return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
    }
    pMessage = pCommOutput->pvBuffer;

    pBuffer = pMessage->VariantData;

    pMessage->Header.Byte0 = MSBOF(cbMessage) | 0x80;
    pMessage->Header.Byte1 = LSBOF(cbMessage);

    pMessage->MessageId = SSL2_MT_CLIENT_MASTER_KEY;
    Ssl2MapCipherToExternal(pCanonical->CipherKind, &pMessage->CipherKind);

    pMessage->ClearKeyLenMsb = MSBOF(pCanonical->ClearKeyLen);
    pMessage->ClearKeyLenLsb = LSBOF(pCanonical->ClearKeyLen);

    CopyMemory(pBuffer, pCanonical->ClearKey, pCanonical->ClearKeyLen);
    pBuffer += pCanonical->ClearKeyLen;

    pMessage->EncryptedKeyLenMsb = MSBOF(pCanonical->EncryptedKeyLen);
    pMessage->EncryptedKeyLenLsb = LSBOF(pCanonical->EncryptedKeyLen);

    CopyMemory(pBuffer, pCanonical->EncryptedKey, pCanonical->EncryptedKeyLen);
    pBuffer += pCanonical->EncryptedKeyLen;

    pMessage->KeyArgLenMsb = MSBOF(pCanonical->KeyArgLen);
    pMessage->KeyArgLenLsb = LSBOF(pCanonical->KeyArgLen);

    CopyMemory(pBuffer, pCanonical->KeyArg, pCanonical->KeyArgLen);

    return(PCT_ERR_OK);

}


SP_STATUS
Ssl2UnpackClientMasterKey(
    PSPBuffer              pInput,
    PSsl2_Client_Master_Key *    ppClient)
{
    PSsl2_Client_Master_Key  pCanonical;
    PSSL2_CLIENT_MASTER_KEY  pMessage;
    PUCHAR              pBuffer;
    DWORD               ReportedSize;

    pMessage = pInput->pvBuffer;

    if(pInput->cbData < 2) 
    {
        pInput->cbData = 2;
        return PCT_INT_INCOMPLETE_MSG;
    }
    ReportedSize = SIZEOF(pMessage);

    if ((ReportedSize+2) > pInput->cbData)
    {
        pInput->cbData = ReportedSize+2; 
        return PCT_INT_INCOMPLETE_MSG;
    }

    if(ReportedSize < SSL_OFFSET_OF(PSSL2_CLIENT_MASTER_KEY, VariantData))
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    *ppClient = NULL;

    if ((pMessage->MessageId != SSL2_MT_CLIENT_MASTER_KEY))
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    pCanonical = (PSsl2_Client_Master_Key)SPExternalAlloc(
                            sizeof(Ssl2_Client_Master_Key) );

    if (!pCanonical)
    {
        return SP_LOG_RESULT( PCT_INT_INTERNAL_ERROR );
    }

    pCanonical->CipherKind = Ssl2MapCipherFromExternal( &pMessage->CipherKind );
    pCanonical->ClearKeyLen = COMBINEBYTES( pMessage->ClearKeyLenMsb,
                                            pMessage->ClearKeyLenLsb );

    pCanonical->EncryptedKeyLen = COMBINEBYTES( pMessage->EncryptedKeyLenMsb,
                                                pMessage->EncryptedKeyLenLsb );

    pCanonical->KeyArgLen = COMBINEBYTES(   pMessage->KeyArgLenMsb,
                                            pMessage->KeyArgLenLsb );


    //
    // Validate
    //
    if ((pCanonical->ClearKeyLen > SSL2_MASTER_KEY_SIZE) ||
        (pCanonical->EncryptedKeyLen > SSL2_ENCRYPTED_KEY_SIZE) ||
        (pCanonical->KeyArgLen))
    {
        SPExternalFree(pCanonical);
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }


    if ((SSL_OFFSET_OF(PSSL2_CLIENT_MASTER_KEY, VariantData) -
         sizeof(SSL2_MESSAGE_HEADER) +
         pCanonical->ClearKeyLen +
         pCanonical->EncryptedKeyLen +
         pCanonical->KeyArgLen ) !=
         ReportedSize)
    {
        SPExternalFree(pCanonical);
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }



    pBuffer = pMessage->VariantData;

    CopyMemory(pCanonical->ClearKey, pBuffer, pCanonical->ClearKeyLen );

    pBuffer += pCanonical->ClearKeyLen;

    CopyMemory(pCanonical->EncryptedKey, pBuffer, pCanonical->EncryptedKeyLen );

    pBuffer += pCanonical->EncryptedKeyLen;

    CopyMemory( pCanonical->KeyArg, pBuffer, pCanonical->KeyArgLen );

    *ppClient = pCanonical;

    return( PCT_ERR_OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\ssl2prot.h ===
#ifndef _SSL2PROT_H_
#define _SSL2PROT_H_

SP_STATUS WINAPI
Ssl2ClientProtocolHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput,
    PSPBuffer pAppOutput);

SP_STATUS WINAPI
Ssl2ServerProtocolHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput,
    PSPBuffer pAppOutput);

SP_STATUS WINAPI
Ssl3ClientProtocolHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput,
    PSPBuffer pAppOutput);

SP_STATUS WINAPI
Ssl2DecryptHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pAppOutput);

SP_STATUS WINAPI
GenerateUniHelloMessage(
    PSPContext              pContext,
    Ssl2_Client_Hello *     pHelloMessage,
    DWORD                   fProtocol
    );


SP_STATUS WINAPI Ssl2DecryptMessage(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pAppOutput);

SP_STATUS WINAPI Ssl2EncryptMessage(PSPContext pContext,
                             PSPBuffer  pAppInput,
                             PSPBuffer  pCommOutput);

SP_STATUS WINAPI Ssl3DecryptMessage(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pAppOutput);

SP_STATUS WINAPI Ssl3EncryptMessage(PSPContext pContext,
                             PSPBuffer  pAppInput,
                             PSPBuffer  pCommOutput);


SP_STATUS Ssl2SrvHandleClientHello(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSsl2_Client_Hello pHello,
                              PSPBuffer  pCommOutput);


SP_STATUS Ssl2SrvHandleCMKey(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl3SrvHandleCMKey(PSPContext pContext,
                              PUCHAR  pCommInput,
                              DWORD cbMsg,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl3SrvHandleCMKey(PSPContext pContext,
                              PUCHAR  pCommInput,
                              DWORD cbMsg,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl2SrvHandleClientFinish(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl2CliHandleServerHello(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSsl2_Server_Hello  pHello,
                              PSPBuffer  pCommOutput);
SP_STATUS Ssl3CliHandleServerHello(PSPContext pContext,
                              PUCHAR  pSrvHello,
                              DWORD cbMessage,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl2CliHandleServerVerify(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl2CliHandleServerFinish(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl2SrvGenRestart(PSPContext pContext,
                              PSsl2_Client_Hello pHello,
                              PSPBuffer  pCommOutput);


SP_STATUS Ssl2SrvFinishClientRestart(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl2CliHandleServerRestart(PSPContext pContext,
                                   PSPBuffer  pCommInput,
                                   PSsl2_Server_Hello pHello,
                                   PSPBuffer  pCommOutput);

SP_STATUS Ssl2CliFinishRestart(PSPContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl2GenCliFinished(PSPContext pContext,
                              PSPBuffer  pCommOutput);

SP_STATUS
Ssl2MakeSessionKeys(PSPContext pContext);


extern Ssl2CipherMap Ssl2CipherRank[];
extern const DWORD Ssl2NumCipherRanks;

extern CertSpec Ssl2CertRank[];
extern const DWORD Ssl2NumCert;

#endif /* _SSL2PROT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\ssl2msg.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/

#include <spbase.h>
#include <ssl2msg.h>
#include <ssl2prot.h>
#include <rc4.h>

Ssl2CipherMap Ssl2CipherRank[] =
{
    {SSL_CK_RC4_128_WITH_MD5, SP_HASH_MD5 , SP_CIPHER_RC4 | SP_ENC_BITS_128 | SP_MAC_BITS_128, SP_EXCH_RSA_PKCS1},
    {SSL_CK_RC4_128_FINANCE64_WITH_MD5, SP_HASH_MD5 , SP_CIPHER_RC4 | SP_ENC_BITS_64 | SP_MAC_BITS_128, SP_EXCH_RSA_PKCS1},
    {SSL_CK_RC4_128_EXPORT40_WITH_MD5,SP_HASH_MD5 , SP_CIPHER_RC4 | SP_ENC_BITS_40 | SP_MAC_BITS_128, SP_EXCH_RSA_PKCS1},
};
const DWORD Ssl2NumCipherRanks = sizeof(Ssl2CipherRank)/sizeof(Ssl2CipherMap);

CertSpec Ssl2CertRank[] = {
    SP_CERT_X509
};
const DWORD Ssl2NumCert = sizeof(Ssl2CertRank)/sizeof(CertSpec);

SP_STATUS WINAPI
Ssl2DecryptHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pAppOutput)
{
    SP_STATUS pctRet = PCT_ERR_OK;

    if (pCommInput->cbData > 0)
    {
        // First, we'll handle incoming data packets:

        if ((pContext->State & SP_STATE_CONNECTED) && pContext->Decrypt)
        {
            pctRet = pContext->Decrypt(
		                    pContext,
		                    pCommInput,		// message
		                    pAppOutput);	// Unpacked Message
            if (PCT_ERR_OK == pctRet)
            {
                /* look for escapes */
            }
            return(pctRet);
        }
        else
        {
            return(PCT_INT_ILLEGAL_MSG);
        }
    }
    return (PCT_INT_INCOMPLETE_MSG);
}


SP_STATUS WINAPI
Ssl2EncryptMessage(
    PSPContext     pContext,
    PSPBuffer       pAppInput,
    PSPBuffer       pCommOutput)
{
    SP_STATUS                  pctRet;
    DWORD                      cPadding, cPad2;
    SPBuffer                   Clean;
    SPBuffer                   Encrypted;

    PCheckSumBuffer            pSum;
    HashBuf                    SumBuf;
    DWORD                      ReverseSequence;

#if DBG
    DWORD           di;
    CHAR            KeyDispBuf[SSL2_MASTER_KEY_SIZE*2+1];
#endif

    SP_BEGIN("Ssl2EncryptMessage");

    /* Estimate if we have padding or not */
    Clean.cbData = pAppInput->cbData+pContext->pCheck->cbCheckSum;
    cPadding = Clean.cbData & (pContext->pSystem->BlockSize - 1);

    Clean.cbData += cPadding;

    if(cPadding) {
        if(pCommOutput->cbBuffer + Clean.cbData + cPadding < 3)
        {
            SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
        }
        Clean.pvBuffer = Encrypted.pvBuffer = (PUCHAR)pCommOutput->pvBuffer+3;
        Clean.cbBuffer = Encrypted.cbBuffer = pCommOutput->cbBuffer-3;

    }
    else
    {
        if(pCommOutput->cbBuffer + Clean.cbData + cPadding< 2)
        {
            SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
        }
        Clean.pvBuffer = Encrypted.pvBuffer = (PUCHAR)pCommOutput->pvBuffer+2;
        Clean.cbBuffer = Encrypted.cbBuffer = pCommOutput->cbBuffer-2;
    }

    DebugLog((DEB_TRACE, "Sealing message %x\n", pContext->WriteCounter));


    /* Begin Checksum Process */
	/* Clone Hash(SECRET... */
    CloneHashBuf(SumBuf, pContext->WriteMACState, pContext->pCheck);
    pSum = (PCheckSumBuffer)SumBuf;
    /* add data */
    pContext->pCheck->Sum( pSum, pAppInput->cbData, (PUCHAR)pAppInput->pvBuffer );

    ReverseSequence = htonl( pContext->WriteCounter );
    /* add count */
    pContext->pCheck->Sum( pSum, sizeof(DWORD), (PUCHAR) &ReverseSequence );

   /* Move data out of the way if necessary */
    if((PUCHAR)Clean.pvBuffer+pContext->pCheck->cbCheckSum != (PUCHAR)pAppInput->pvBuffer)
    {
        DebugLog((DEB_WARN, "SSL2EncryptMessage: Unnecessary Move, performance hog\n"));
        /* if caller wasn't being smart, then we must copy memory here */
        MoveMemory((PUCHAR)Clean.pvBuffer+pContext->pCheck->cbCheckSum,
		           (PUCHAR)pAppInput->pvBuffer,
		           pAppInput->cbData);
    }

	/* finalize and store the hash */
    pContext->pCheck->Finalize( pSum, (PUCHAR)Clean.pvBuffer);


    /* Perform encryption to fill buffer */
    pctRet = pContext->pSystem->Encrypt( pContext->pWriteState,
		                                 &Clean,
		                                 &Encrypted);
    if(PCT_ERR_OK != pctRet)
    {
        SP_RETURN(pctRet);
    }

	cPad2 = Encrypted.cbData - Clean.cbData;
	if(cPad2 & !cPadding)
    {
		/* Our first padding calc was wrong, so we must move all data */
        DebugLog((DEB_WARN, "SSL2EncryptMessage-pad1: Unnecessary Move, performance hog\n"));

        MoveMemory(&((PUCHAR)pCommOutput->pvBuffer)[3],
                   Encrypted.pvBuffer,
                   Encrypted.cbData);
	}
    else  if(!cPad2 & cPadding)
    {
        DebugLog((DEB_WARN, "SSL2EncryptMessage-pad2: Unnecessary Move, performance hog\n"));

        MoveMemory(&((PUCHAR)pCommOutput->pvBuffer)[2],
                   Encrypted.pvBuffer,
                   Encrypted.cbData);
	}

	cPadding = cPad2;
    /* set sizes */
    if(cPadding) {
        if(Encrypted.cbData > 0x3fff)
        {
            SP_RETURN(SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW));
        }

        ((PUCHAR)pCommOutput->pvBuffer)[0]= (UCHAR)(0x80 || (0x3f & (Encrypted.cbData>>8)));
        ((PUCHAR)pCommOutput->pvBuffer)[1]= (UCHAR)(0xff & Encrypted.cbData);
        ((PUCHAR)pCommOutput->pvBuffer)[2]= (UCHAR)cPadding;

    }
    else
    {
        if(Encrypted.cbData > 0x7fff)
        {
            SP_RETURN(SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW));
        }
        ((PUCHAR)pCommOutput->pvBuffer)[0]= (UCHAR)(0x7f & (Encrypted.cbData>>8)) | 0x80;
        ((PUCHAR)pCommOutput->pvBuffer)[1]= (UCHAR)(0xff & Encrypted.cbData);
    }

    pCommOutput->cbData = Encrypted.cbData + (cPadding?3:2);

#if DBG
    for(di=0;di<SSL2_MASTER_KEY_SIZE;di++)
	sprintf(KeyDispBuf+(di*2), "%2.2x",
		((BYTE *)Encrypted.pvBuffer+Encrypted.cbData-pContext->pCheck->cbCheckSum)[di]);
    DebugLog((DEB_TRACE, "  MAC\t%s\n", KeyDispBuf));
#endif

    pContext->WriteCounter ++ ;

    SP_RETURN( PCT_ERR_OK );

}

SP_STATUS WINAPI
Ssl2DecryptMessage(
    PSPContext         pContext,
    PSPBuffer          pMessage,
    PSPBuffer          pAppOutput)
{

    SP_STATUS              pctRet;
    DWORD                   cPadding;
    DWORD                   dwLength;
    PUCHAR                  pbMAC;
    DWORD                   cbData;

    SPBuffer               Encrypted;
    SPBuffer               Clean;

    PCheckSumBuffer         pSum;
    HashBuf                 SumBuf;
    DWORD                   ReverseSequence;
    DWORD                   cbActualData;

    UCHAR                   Digest[16];
#if DBG
    DWORD           di;
    CHAR            KeyDispBuf[SSL2_MASTER_KEY_SIZE*2+1];
#endif

    SP_BEGIN("Ssl2DecryptMessage");

    /* First determine the length of data, the length of padding,
     * and the location of data, and the location of MAC */
    cbActualData = pMessage->cbData;
    pMessage->cbData = 2; /* minimum amount of data we need */


    if(pMessage->cbData > cbActualData)
    {
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    if(  ((PUCHAR)pMessage->pvBuffer)[0]&0x80 )
    {
        /* 2 byte header */
        cPadding = 0;
        dwLength = ((((PUCHAR)pMessage->pvBuffer)[0]&0x7f)<< 8) |
                   ((PUCHAR)pMessage->pvBuffer)[1];

        Clean.pvBuffer = Encrypted.pvBuffer = ((PUCHAR)pMessage->pvBuffer) + 2;
	    Clean.cbBuffer = pMessage->cbBuffer - 2;
    }
    else
    {
        pMessage->cbData++;
        if(pMessage->cbData > cbActualData)
        {
            SP_RETURN(PCT_INT_INCOMPLETE_MSG);
        }

        /* 3 byte header */
        cPadding = ((PUCHAR)pMessage->pvBuffer)[2];
        dwLength = ((((PUCHAR)pMessage->pvBuffer)[0]&0x3f)<< 8) |
                    ((PUCHAR)pMessage->pvBuffer)[1];

        Clean.pvBuffer = Encrypted.pvBuffer = ((PUCHAR)pMessage->pvBuffer) + 3;
        Clean.cbBuffer = pMessage->cbBuffer - 3;
    }
    /* Now we know how mutch data we will eat, so set cbData on the Input to be that size */
    pMessage->cbData += dwLength;
    /* do we have enough bytes for the reported data */
    if(pMessage->cbData > cbActualData)
    {
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    /* do we have engough data for our checksum */
    if(dwLength < pContext->pCheck->cbCheckSum)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_MSG_ALTERED));
    }

    Encrypted.cbData = dwLength;    /* encrypted data size */
    pbMAC = (PUCHAR)Clean.pvBuffer; /* location of MAC */

    /* check to see if we have a block size violation */
    if(Encrypted.cbData % pContext->pSystem->BlockSize)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_MSG_ALTERED));
    }

    Encrypted.cbBuffer = Encrypted.cbData;

    /* Decrypt */
    pctRet = pContext->pSystem->Decrypt( pContext->pReadState,
			    &Encrypted,
			    &Clean);

    if(PCT_ERR_OK != pctRet)
    {
        SP_RETURN(pctRet);
    }


    (PUCHAR)Clean.pvBuffer += pContext->pCheck->cbCheckSum; /* move pointer to start of data */
    Clean.cbData -=  pContext->pCheck->cbCheckSum;
    cbData = Clean.cbData - cPadding;
    /* Validate MAC: */


    CloneHashBuf(SumBuf, pContext->ReadMACState, pContext->pCheck);

    pSum = (PCheckSumBuffer)SumBuf;

    pContext->pCheck->Sum( pSum, Clean.cbData, Clean.pvBuffer);

    ReverseSequence = htonl( pContext->ReadCounter );

    DebugLog((DEB_TRACE, "Unsealing message %x\n", pContext->ReadCounter));

    pContext->pCheck->Sum( pSum, sizeof(DWORD), (PUCHAR) &ReverseSequence );
    pContext->pCheck->Finalize( pSum, Digest );

    pContext->ReadCounter++;

#if DBG

    for(di=0;di<SSL2_MASTER_KEY_SIZE;di++)
	sprintf(KeyDispBuf+(di*2), "%2.2x",
		pbMAC[di]);
    DebugLog((DEB_TRACE, "  Incoming MAC\t%s\n", KeyDispBuf));

    for(di=0;di<SSL2_MASTER_KEY_SIZE;di++)
	sprintf(KeyDispBuf+(di*2), "%2.2x",
		Digest[di]);
    DebugLog((DEB_TRACE, "  Computed MAC\t%s\n", KeyDispBuf));

#endif

    if (memcmp( Digest, pbMAC, pContext->pCheck->cbCheckSum ) )
    {
       SP_RETURN(SP_LOG_RESULT(PCT_INT_MSG_ALTERED));
    }

	if(pAppOutput->pvBuffer != Clean.pvBuffer)
    {
        DebugLog((DEB_WARN, "SSL2DecryptMessage: Unnecessary Move, performance hog\n"));
		MoveMemory(pAppOutput->pvBuffer,
                   Clean.pvBuffer,
                   cbData);
	}
    pAppOutput->cbData = cbData;

    SP_RETURN( PCT_ERR_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:   Ssl2MakeSessionKeys
//
//  Synopsis:   Initializes the session keys (mac, crypt) from the context.
//
//  Arguments:  [pContext] --
//              [Bits]     --
//
//  Algorithm:
//
//  History:    10-10-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SP_STATUS
Ssl2MakeSessionKeys(
    PSPContext         pContext)
{

    PCheckSumBuffer     CReadHash, CWriteHash;
    HashBuf             CReadHB, CWriteHB;
    UCHAR               pWriteKey[SSL2_MASTER_KEY_SIZE], pReadKey[SSL2_MASTER_KEY_SIZE];

    UCHAR       Buffer[SSL2_MASTER_KEY_SIZE +
                       1 +
			           SSL2_MAX_CHALLENGE_LEN +
                       SSL2_MAX_CONNECTION_ID_LEN
                      ];

    DWORD       BufferLen;


    // Validate that the context can be used for
    // generating an SSL2 style keyset.

    if((pContext == NULL) ||
        (pContext->RipeZombie == NULL))
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(pContext->RipeZombie->cbMasterKey != SSL2_MASTER_KEY_SIZE)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    InitHashBuf(CWriteHB, pContext);
    InitHashBuf(CReadHB, pContext);
    CWriteHash = (PCheckSumBuffer)CWriteHB;
    CReadHash = (PCheckSumBuffer)CReadHB;



    BufferLen = pContext->RipeZombie->cbMasterKey;

    CopyMemory(Buffer, pContext->RipeZombie->pMasterKey, BufferLen);

    Buffer[BufferLen++] = '0';

    CopyMemory(&Buffer[BufferLen],
               pContext->pChallenge,
               pContext->cbChallenge );

    BufferLen += pContext->cbChallenge ;


    CopyMemory( &Buffer[BufferLen],
		pContext->pConnectionID,
		pContext->cbConnectionID );

    BufferLen += pContext->cbConnectionID ;

    /* hash the buffer */
    pContext->pCheck->Sum( CReadHash, BufferLen, Buffer );
    Buffer[16] = '1';
    pContext->pCheck->Sum( CWriteHash, BufferLen, Buffer );

    if (pContext->Flags & CONTEXT_FLAG_CLIENT)
    {
	    pContext->pCheck->Finalize( CReadHash, pReadKey );
	    pContext->pCheck->Finalize( CWriteHash, pWriteKey );
    }
    else
    {
	    pContext->pCheck->Finalize( CWriteHash, pReadKey );
	    pContext->pCheck->Finalize( CReadHash, pWriteKey );
    }

    pContext->KeySize = 16;
    InitHashBuf(pContext->RdMACBuf, pContext);
    InitHashBuf(pContext->WrMACBuf, pContext);

    pContext->ReadMACState = (PCheckSumBuffer)pContext->RdMACBuf;
    pContext->WriteMACState = (PCheckSumBuffer)pContext->WrMACBuf;

    if (pContext->pSystem->Initialize(  pReadKey,
			    CONTEXT_KEY_SIZE,
			    &pContext->pReadState ) )
    {
        if (pContext->pSystem->Initialize(  pWriteKey,
				        CONTEXT_KEY_SIZE,
				        &pContext->pWriteState) )
        {
	            /* initialize the Hash SECRET */

            pContext->pCheck->Sum( pContext->ReadMACState, pContext->KeySize,
					               pReadKey);

            pContext->pCheck->Sum( pContext->WriteMACState, pContext->KeySize,
					               pWriteKey);

            return (PCT_ERR_OK);
        }

        pContext->pSystem->Discard( &pContext->pReadState );
    }

    return( PCT_INT_INTERNAL_ERROR );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\ssl3key.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
*	Owner 			:ramas
*	Date			:4/16/96
*	description		: Main Crypto functions for SSL3
*----------------------------------------------------------------------------*/
#ifndef _SSL3KEY_H_
#define _SSL3KEY_H_

void 
Ssl3BuildMasterKeys(
    PSPContext pContext, 
    PUCHAR pbPreMaster
);

SP_STATUS
Ssl3MakeMasterKeyBlock(PSPContext pContext);

SP_STATUS
Ssl3MakeWriteSessionKeys(PSPContext pContext);

SP_STATUS
Ssl3MakeReadSessionKeys(PSPContext pContext);


#endif _SSL3KEY_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\ssl3key.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
*	Owner 			:ramas
*	Date			:4/16/96
*	description		: Main Crypto functions for SSL3
*----------------------------------------------------------------------------*/

#include <spbase.h>
#include <ssl3key.h>
#include <ssl2msg.h>
#include <ssl3msg.h>
#include <ssl2prot.h>
#include <md5.h>
#include <sha.h>
#include <rsa.h>


#define CB_SSL3_MAX_MAC_PAD 48
#define CB_SSL3_MD5_MAC_PAD 48
#define CB_SSL3_SHA_MAC_PAD 40

#define PAD1_CONSTANT 0x36
#define PAD2_CONSTANT 0x5c

void Ssl3BuildMasterKeys(PSPContext pContext, PUCHAR pbPreMaster)
{

    WORD i;
    PBYTE sz[3] = { "A","BB","CCC" } ;
    MD5_CTX Md5Hash;
    A_SHA_CTX ShaHash;
    BYTE bShaHashValue[A_SHA_DIGEST_LEN];


    //UNDONE DO WE NEED THESE MEMSETs
    // zero buffers
#if DBG
    DebugLog((DEB_TRACE, "  Pre Master Secret\n"));
    DbgDumpHexString(pbPreMaster, CB_SSL3_PRE_MASTER_SECRET);

#endif





    for ( i = 0 ; i < 3 ; i++)
    {
        // SHA('A' or 'BB' or 'CCC' + pre_master_secret + ClientHello.random + ServerHello.random)
        A_SHAInit(&ShaHash);
        A_SHAUpdate(&ShaHash, sz[i], i + 1);
        A_SHAUpdate(&ShaHash, pbPreMaster, CB_SSL3_PRE_MASTER_SECRET);
        A_SHAUpdate(&ShaHash, pContext->rgbS3CRandom, CB_SSL3_RANDOM);
        A_SHAUpdate(&ShaHash, pContext->rgbS3SRandom, CB_SSL3_RANDOM);
        A_SHAFinal(&ShaHash, bShaHashValue);

        // MD5(pre_master_secret + SHA-hash)
        MD5Init(&Md5Hash);
        MD5Update(&Md5Hash, pbPreMaster, CB_SSL3_PRE_MASTER_SECRET);
        MD5Update(&Md5Hash, bShaHashValue, A_SHA_DIGEST_LEN);
        MD5Final(&Md5Hash);
        CopyMemory(pContext->RipeZombie->pMasterKey + (i * MD5DIGESTLEN), Md5Hash.digest, MD5DIGESTLEN);
    }

    pContext->RipeZombie->cbMasterKey = 3*MD5DIGESTLEN;

#if DBG
    DebugLog((DEB_TRACE, "  Master Secret\n"));
    DbgDumpHexString(pContext->RipeZombie->pMasterKey, pContext->RipeZombie->cbMasterKey);

#endif


}


SP_STATUS
Ssl3MakeMasterKeyBlock(PSPContext pContext)
{

    MD5_CTX 	Md5Hash;
    A_SHA_CTX 	ShaHash;
    BYTE rgbShaHashValue[A_SHA_DIGEST_LEN];
    PBYTE sz[5] = { "A","BB","CCC","DDDD","EEEEE" };
    DWORD ib;


    //pContext->RipeZombe->pMasterKey containst the master secret.

#if DBG
    DebugLog((DEB_TRACE, "  Master Secret\n"));
    DbgDumpHexString(pContext->RipeZombie->pMasterKey, pContext->RipeZombie->cbMasterKey);

#endif

    for(ib=0 ; ib<5 ; ib++)
    {
        // SHA('A' + master_secret + ServerHello.random + ClientHello.random )
        A_SHAInit  (&ShaHash);
        A_SHAUpdate(&ShaHash, sz[ib], ib + 1);
        A_SHAUpdate(&ShaHash, pContext->RipeZombie->pMasterKey, pContext->RipeZombie->cbMasterKey);
        A_SHAUpdate(&ShaHash, pContext->rgbS3SRandom, CB_SSL3_RANDOM);
        A_SHAUpdate(&ShaHash, pContext->rgbS3CRandom, CB_SSL3_RANDOM);
        A_SHAFinal (&ShaHash, rgbShaHashValue);

        // MD5(master_secret + SHA-hash)
        MD5Init  (&Md5Hash);
        MD5Update(&Md5Hash, pContext->RipeZombie->pMasterKey, pContext->RipeZombie->cbMasterKey);
        MD5Update(&Md5Hash, rgbShaHashValue, A_SHA_DIGEST_LEN);
        MD5Final (&Md5Hash);
        CopyMemory(pContext->Ssl3MasterKeyBlock + ib * MD5DIGESTLEN, Md5Hash.digest, MD5DIGESTLEN);
	}
 #if DBG
    DebugLog((DEB_TRACE, "  Master Key Block\n"));
    DbgDumpHexString(pContext->Ssl3MasterKeyBlock, MD5DIGESTLEN*5);

#endif
   return( PCT_ERR_OK );
}

SP_STATUS
Ssl3MakeWriteSessionKeys(PSPContext pContext)
{

//    PCheckSumBuffer     CWriteHash;
//    HashBuf             CWriteHB;
    MD5_CTX 	        Md5Hash;
//    A_SHA_CTX 	        ShaHash;

//    BYTE rgbShaHashValue[A_SHA_DIGEST_LEN];
    BYTE rgbWriteKey[SSL3_MASTER_KEY_SIZE];
    BYTE rgbPad[CB_SSL3_MAX_MAC_PAD];
    WORD cbPad = CB_SSL3_MD5_MAC_PAD;
//    DWORD ib;
    BOOL fSHA = FALSE;
    DWORD dwKeyLen;
    BOOL fClient;
    DWORD dwMACOffset;
    DWORD dwKEYOffset;
    DWORD dwIVOffset;



    fClient = (0 != (pContext->RipeZombie->fProtocol & SP_PROT_SSL3_CLIENT));

    /* find bit strength of cipher */
    dwKeyLen = (pContext->RipeZombie->SessCiphSpec & SP_CIPHER_STRENGTH) >> SP_CSTR_POS;
    /* convert to bytes */
    dwKeyLen = dwKeyLen / 8;

    dwMACOffset = (fClient?0:pContext->pCheck->cbCheckSum);
    dwKEYOffset = 2*pContext->pCheck->cbCheckSum + (fClient?0:dwKeyLen);
    dwIVOffset = 2*pContext->pCheck->cbCheckSum + 2*dwKeyLen; // + IV Size;

    //
    // extract keys from key block
    //




    pContext->KeySize = SSL3_MASTER_KEY_SIZE;

    // Initialize the Write Key and Write State
    CopyMemory(rgbWriteKey, pContext->Ssl3MasterKeyBlock + dwKEYOffset, dwKeyLen);

    // If key is exportable, perform export calculations
    if(dwKeyLen != SSL3_MASTER_KEY_SIZE)
    {
        MD5Init  (&Md5Hash);
        MD5Update(&Md5Hash, rgbWriteKey, dwKeyLen);
        if(fClient)
        {
            MD5Update(&Md5Hash, pContext->rgbS3CRandom, CB_SSL3_RANDOM);
            MD5Update(&Md5Hash, pContext->rgbS3SRandom, CB_SSL3_RANDOM);
        }
        else
        {
            MD5Update(&Md5Hash, pContext->rgbS3SRandom, CB_SSL3_RANDOM);
            MD5Update(&Md5Hash, pContext->rgbS3CRandom, CB_SSL3_RANDOM);
        }
        MD5Final (&Md5Hash);
        CopyMemory(rgbWriteKey, Md5Hash.digest, pContext->KeySize);
    }
#if DBG
    DebugLog((DEB_TRACE, "  Write Key\n"));
    DbgDumpHexString(rgbWriteKey, pContext->KeySize);

#endif

    if (!pContext->pSystem->Initialize(  rgbWriteKey,
                                        pContext->KeySize,
                                        &pContext->pWriteState))
    {
            return SP_LOG_RESULT( PCT_INT_INTERNAL_ERROR );
    }

    // Initialize the MAC Key and Mac State.
    CopyMemory(pContext->WriteMACKey,
               pContext->Ssl3MasterKeyBlock + dwMACOffset,
               pContext->pCheck->cbCheckSum);
#if DBG
    DebugLog((DEB_TRACE, "  Write MAC Key\n"));
    DbgDumpHexString(pContext->WriteMACKey, pContext->pCheck->cbCheckSum);

#endif

    // Precalc the two states needed to do an SSL3 mac.
    InitHashBuf(pContext->WrMACBuf, pContext);
    InitHashBuf(pContext->WrMACBuf1, pContext);

    pContext->WriteMACState = (PCheckSumBuffer)pContext->WrMACBuf;
    pContext->WriteMACState1 = (PCheckSumBuffer)pContext->WrMACBuf1;

    // Precalc hash(MAC_write_secret + pad_1)

    pContext->pCheck->Sum(  pContext->WriteMACState,
                            pContext->pCheck->cbCheckSum,
                            pContext->WriteMACKey);

    cbPad = (fSHA?CB_SSL3_SHA_MAC_PAD:CB_SSL3_MD5_MAC_PAD);
    FillMemory(rgbPad, cbPad, PAD1_CONSTANT);

    pContext->pCheck->Sum(  pContext->WriteMACState,
                            cbPad,
                            rgbPad);

    // Precalc hash(MAC_write_secret + pad_2)

    pContext->pCheck->Sum(  pContext->WriteMACState1,
                            pContext->pCheck->cbCheckSum,
                            pContext->WriteMACKey);

    FillMemory(rgbPad, cbPad, PAD2_CONSTANT);

    pContext->pCheck->Sum(  pContext->WriteMACState1,
                            cbPad,
                            rgbPad);

    DebugLog((DEB_TRACE, "Write Keys are Computed\n"));
    return (PCT_ERR_OK);
}

SP_STATUS
Ssl3MakeReadSessionKeys(PSPContext pContext)
{

//    PCheckSumBuffer     CWriteHash;
//    HashBuf             CWriteHB;
    MD5_CTX 	        Md5Hash;
//    A_SHA_CTX 	        ShaHash;

//    BYTE rgbShaHashValue[A_SHA_DIGEST_LEN];
    BYTE rgbReadKey[SSL3_MASTER_KEY_SIZE];
    BYTE rgbPad[CB_SSL3_MAX_MAC_PAD];
    WORD cbPad = CB_SSL3_MD5_MAC_PAD;
//    DWORD ib;
    BOOL fSHA = FALSE;
    DWORD dwKeyLen;
    BOOL fClient;
    DWORD dwMACOffset;
    DWORD dwKEYOffset;
    DWORD dwIVOffset;



    fClient = (0 != (pContext->RipeZombie->fProtocol & SP_PROT_SSL3_CLIENT));

    /* find bit strength of cipher */
    dwKeyLen = (pContext->RipeZombie->SessCiphSpec & SP_CIPHER_STRENGTH) >> SP_CSTR_POS;
    /* convert to bytes */
    dwKeyLen = dwKeyLen / 8;

    dwMACOffset = (fClient?pContext->pCheck->cbCheckSum:0);
    dwKEYOffset = 2*pContext->pCheck->cbCheckSum + (fClient?dwKeyLen:0);
    dwIVOffset = 2*pContext->pCheck->cbCheckSum + 2*dwKeyLen; // + IV Size;

    //
    // extract keys from key block
    //

    pContext->KeySize = SSL3_MASTER_KEY_SIZE;

    // Initialize the Write Key and Write State
    CopyMemory(rgbReadKey, pContext->Ssl3MasterKeyBlock + dwKEYOffset, dwKeyLen);

    // If key is exportable, perform export calculations
    if(dwKeyLen != SSL3_MASTER_KEY_SIZE)
    {
        MD5Init  (&Md5Hash);
        MD5Update(&Md5Hash, rgbReadKey, dwKeyLen);
        if(fClient)
        {
            MD5Update(&Md5Hash, pContext->rgbS3SRandom, CB_SSL3_RANDOM);
            MD5Update(&Md5Hash, pContext->rgbS3CRandom, CB_SSL3_RANDOM);
        }
        else
        {
            MD5Update(&Md5Hash, pContext->rgbS3CRandom, CB_SSL3_RANDOM);
            MD5Update(&Md5Hash, pContext->rgbS3SRandom, CB_SSL3_RANDOM);
       }
        MD5Final (&Md5Hash);
        CopyMemory(rgbReadKey, Md5Hash.digest, pContext->KeySize);
    }
#if DBG
    DebugLog((DEB_TRACE, "  Read Key\n"));
    DbgDumpHexString(rgbReadKey,  pContext->KeySize);

#endif

    if (!pContext->pSystem->Initialize(  rgbReadKey,
                                        pContext->KeySize,
                                        &pContext->pReadState))
    {
            return SP_LOG_RESULT( PCT_INT_INTERNAL_ERROR );
    }

    // Initialize the MAC Key and Mac State.
    CopyMemory(pContext->ReadMACKey,
               pContext->Ssl3MasterKeyBlock + dwMACOffset,
               pContext->pCheck->cbCheckSum);
#if DBG
    DebugLog((DEB_TRACE, "  Read MAC Key\n"));
    DbgDumpHexString(pContext->ReadMACKey, pContext->pCheck->cbCheckSum);

#endif

    // Precalc the two states needed to do an SSL3 mac.
    InitHashBuf(pContext->RdMACBuf, pContext);
    InitHashBuf(pContext->RdMACBuf1, pContext);

    pContext->ReadMACState = (PCheckSumBuffer)pContext->RdMACBuf;
    pContext->ReadMACState1 = (PCheckSumBuffer)pContext->RdMACBuf1;

    // Precalc hash(MAC_read_secret + pad_1)

    pContext->pCheck->Sum(  pContext->ReadMACState,
                            pContext->pCheck->cbCheckSum,
                            pContext->ReadMACKey);

    cbPad = (fSHA?CB_SSL3_SHA_MAC_PAD:CB_SSL3_MD5_MAC_PAD);
    FillMemory(rgbPad, cbPad, PAD1_CONSTANT);

    pContext->pCheck->Sum(  pContext->ReadMACState,
                            cbPad,
                            rgbPad);

    // Precalc hash(MAC_read_secret + pad_2)

    pContext->pCheck->Sum(  pContext->ReadMACState1,
                            pContext->pCheck->cbCheckSum,
                            pContext->ReadMACKey);

    FillMemory(rgbPad, cbPad, PAD2_CONSTANT);

    pContext->pCheck->Sum(  pContext->ReadMACState1,
                            cbPad,
                            rgbPad);

    DebugLog((DEB_TRACE, "Read Keys are Computed\n"));
    return (PCT_ERR_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\ssl3sign.c ===
#include <spbase.h>
#include <ssl2msg.h>
#include <ssl3msg.h>
#include <ssl2prot.h>
#include <md5.h>
#include <sha.h>
#include <rsa.h>



DWORD vcbPrivKey = 748;
DWORD vcbCert = 593;

	UCHAR vrgbCert[] = {
 0x30, 0x82, 0x02, 0x4d, 0x30, 0x82, 0x01, 0xba, 0x02, 0x05, 0x02, 0x72, 0x00, 0x06, 0xf9, 0x30, 
 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x02, 0x05, 0x00, 0x30, 0x5f, 
 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x20, 0x30, 
 0x1e, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x17, 0x52, 0x53, 0x41, 0x20, 0x44, 0x61, 0x74, 0x61, 
 0x20, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x2c, 0x20, 0x49, 0x6e, 0x63, 0x2e, 0x31, 
 0x2e, 0x30, 0x2c, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x25, 0x53, 0x65, 0x63, 0x75, 0x72, 0x65, 
 0x20, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 
 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x30, 
 0x1e, 0x17, 0x0d, 0x39, 0x36, 0x30, 0x32, 0x31, 0x32, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5a, 
 0x17, 0x0d, 0x39, 0x36, 0x30, 0x38, 0x31, 0x33, 0x32, 0x33, 0x35, 0x39, 0x35, 0x39, 0x5a, 0x30, 
 0x7f, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x12, 
 0x30, 0x10, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x09, 0x57, 0x61, 0x68, 0x69, 0x6e, 0x67, 0x74, 
 0x6f, 0x6e, 0x31, 0x10, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13, 0x07, 0x52, 0x65, 0x64, 
 0x6d, 0x6f, 0x6e, 0x64, 0x31, 0x1e, 0x30, 0x1c, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x15, 0x4d, 
 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x43, 0x6f, 0x72, 0x70, 0x6f, 0x72, 0x61, 
 0x74, 0x69, 0x6f, 0x6e, 0x31, 0x0e, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x05, 0x42, 
 0x4c, 0x44, 0x31, 0x30, 0x31, 0x1a, 0x30, 0x18, 0x06, 0x03, 0x55, 0x04, 0x03, 0x14, 0x11, 0x70, 
 0x63, 0x74, 0x2e, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 
 0x30, 0x81, 0x9f, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 
 0x05, 0x00, 0x03, 0x81, 0x8d, 0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00, 0x83, 0x0c, 0xfe, 
 0x5c, 0x37, 0xd2, 0xc2, 0x0d, 0x3b, 0xa1, 0xee, 0xdb, 0xe8, 0x51, 0xca, 0xb4, 0x15, 0x54, 0x42, 
 0xdb, 0xc4, 0x2f, 0xd0, 0x29, 0xf7, 0x08, 0x1a, 0xb0, 0x0c, 0x00, 0x43, 0xa6, 0x5c, 0x67, 0x77, 
 0x5d, 0xc1, 0x9b, 0x3f, 0x43, 0xd9, 0x9a, 0x09, 0x4f, 0xa1, 0xa0, 0x19, 0xc9, 0xba, 0xac, 0x03, 
 0xf8, 0xa9, 0x82, 0x11, 0x6b, 0xe2, 0x92, 0x7f, 0x56, 0x2b, 0x2f, 0x62, 0xa5, 0xae, 0x09, 0x93, 
 0xc9, 0xd4, 0xc4, 0x66, 0x68, 0xbd, 0x5c, 0x1e, 0xdf, 0x41, 0xb1, 0xfd, 0x55, 0x58, 0x25, 0xad, 
 0x8f, 0x31, 0xe9, 0x32, 0xfd, 0x8f, 0x30, 0x8f, 0x8e, 0x9b, 0x60, 0x8c, 0xe6, 0xac, 0xc7, 0x6c, 
 0xb7, 0x1b, 0x6d, 0x4f, 0xd9, 0x31, 0x98, 0xd8, 0x8c, 0xf8, 0xb2, 0xe6, 0x2b, 0x64, 0x86, 0x93, 
 0xe7, 0xd3, 0xd5, 0x53, 0xa2, 0x21, 0xad, 0xd4, 0xca, 0x76, 0xca, 0x6b, 0x27, 0x02, 0x03, 0x01, 
 0x00, 0x01, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x02, 0x05, 
 0x00, 0x03, 0x7e, 0x00, 0x5f, 0x08, 0xa2, 0x1e, 0xb4, 0x14, 0x05, 0xa3, 0xb8, 0x51, 0xd1, 0xa1, 
 0xe9, 0x13, 0xe7, 0x2a, 0x8c, 0x88, 0x90, 0xf9, 0x6c, 0x53, 0x37, 0xdf, 0xcf, 0x2f, 0x30, 0x8f, 
 0x7c, 0x35, 0x0c, 0x3a, 0x12, 0x99, 0xa9, 0x60, 0x87, 0xed, 0xe2, 0x1b, 0xf3, 0xa5, 0xa8, 0x5a, 
 0xf5, 0xd0, 0x62, 0xfd, 0x9f, 0xdc, 0x9c, 0xdb, 0x8b, 0x9b, 0xcd, 0x15, 0xf5, 0x14, 0xaf, 0xfb, 
 0xfc, 0x7a, 0x1e, 0x5d, 0x7c, 0xa5, 0x06, 0x43, 0xa9, 0xf8, 0xe2, 0xd0, 0x02, 0x95, 0xd8, 0x38, 
 0xd2, 0xfa, 0x86, 0xfe, 0x7f, 0x3e, 0x7d, 0x86, 0x5a, 0xc5, 0xda, 0xd4, 0xe8, 0x11, 0xe8, 0xf7, 
 0x57, 0xf5, 0x82, 0x48, 0x6c, 0x75, 0x82, 0x57, 0xd8, 0x01, 0x6b, 0xd2, 0x22, 0x9f, 0xc7, 0x25, 
 0x57, 0x49, 0xe2, 0xfc, 0xac, 0xb0, 0x68, 0xea, 0x29, 0xd2, 0xb6, 0xa3, 0x7f, 0x94, 0x1d, 0x2f, 
 0x71
 } ;
UCHAR vrgbPrivKey[] = 
	{

 0x52, 0x53, 0x41, 0x32, 0x88, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 
 0x01, 0x00, 0x01, 0x00, 0x27, 0x6b, 0xca, 0x76, 0xca, 0xd4, 0xad, 0x21, 0xa2, 0x53, 0xd5, 0xd3, 
 0xe7, 0x93, 0x86, 0x64, 0x2b, 0xe6, 0xb2, 0xf8, 0x8c, 0xd8, 0x98, 0x31, 0xd9, 0x4f, 0x6d, 0x1b, 
 0xb7, 0x6c, 0xc7, 0xac, 0xe6, 0x8c, 0x60, 0x9b, 0x8e, 0x8f, 0x30, 0x8f, 0xfd, 0x32, 0xe9, 0x31, 
 0x8f, 0xad, 0x25, 0x58, 0x55, 0xfd, 0xb1, 0x41, 0xdf, 0x1e, 0x5c, 0xbd, 0x68, 0x66, 0xc4, 0xd4, 
 0xc9, 0x93, 0x09, 0xae, 0xa5, 0x62, 0x2f, 0x2b, 0x56, 0x7f, 0x92, 0xe2, 0x6b, 0x11, 0x82, 0xa9, 
 0xf8, 0x03, 0xac, 0xba, 0xc9, 0x19, 0xa0, 0xa1, 0x4f, 0x09, 0x9a, 0xd9, 0x43, 0x3f, 0x9b, 0xc1, 
 0x5d, 0x77, 0x67, 0x5c, 0xa6, 0x43, 0x00, 0x0c, 0xb0, 0x1a, 0x08, 0xf7, 0x29, 0xd0, 0x2f, 0xc4, 
 0xdb, 0x42, 0x54, 0x15, 0xb4, 0xca, 0x51, 0xe8, 0xdb, 0xee, 0xa1, 0x3b, 0x0d, 0xc2, 0xd2, 0x37, 
 0x5c, 0xfe, 0x0c, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0xe2, 0xba, 0xbd, 
 0xc4, 0x03, 0xc0, 0xa6, 0x7e, 0x05, 0x6a, 0x77, 0x61, 0x1a, 0x43, 0xb1, 0xf1, 0xfb, 0xde, 0xc0, 
 0xad, 0x28, 0x2e, 0x7f, 0xf5, 0xe8, 0x63, 0xcd, 0x2e, 0x01, 0xbc, 0x4b, 0x2f, 0x90, 0x7d, 0x82, 
 0x8f, 0xc7, 0x7a, 0xa9, 0x8a, 0x5f, 0xc6, 0x9d, 0x46, 0xb2, 0xbd, 0xf4, 0x21, 0x89, 0x50, 0x9f, 
 0xa8, 0x05, 0x1a, 0x0f, 0xdf, 0x63, 0xc6, 0x76, 0xc6, 0x4d, 0xa6, 0xef, 0x00, 0x00, 0x00, 0x00, 
 0x13, 0xbf, 0x98, 0xda, 0x6b, 0x6e, 0x23, 0xc4, 0x86, 0xf2, 0x50, 0x94, 0x94, 0x86, 0x6a, 0x0d, 
 0x69, 0x88, 0x50, 0x83, 0x0b, 0x4b, 0xb9, 0x9c, 0x3f, 0x26, 0x9f, 0x4f, 0x8f, 0x0a, 0x2c, 0x08, 
 0xd8, 0x1c, 0x8b, 0x10, 0xb8, 0x58, 0x49, 0x5b, 0x01, 0xe1, 0xfe, 0xa9, 0xfd, 0x4b, 0x03, 0x36, 
 0x9d, 0x32, 0x4e, 0x04, 0xa4, 0xad, 0x80, 0xf2, 0x71, 0x00, 0xbb, 0xb5, 0xb3, 0xe9, 0xfd, 0x8b, 
 0x00, 0x00, 0x00, 0x00, 0x09, 0x6c, 0x3d, 0x4b, 0xa2, 0x7b, 0x63, 0x6c, 0x1f, 0xe5, 0xa4, 0x12, 
 0x48, 0x7a, 0x2a, 0xb0, 0x01, 0xd0, 0x2c, 0xc7, 0x15, 0x9c, 0x1d, 0x9c, 0x8a, 0x43, 0x1e, 0x30, 
 0xa1, 0x26, 0xa1, 0x08, 0x2a, 0xf3, 0xcc, 0xa3, 0x5d, 0xd9, 0xae, 0x5f, 0x16, 0x78, 0x97, 0x23, 
 0x3b, 0xe0, 0x01, 0x9c, 0x0d, 0xfa, 0xb9, 0xe1, 0xd3, 0x64, 0xa1, 0x90, 0x4a, 0x18, 0x23, 0xc3, 
 0xed, 0x81, 0xd2, 0x60, 0x00, 0x00, 0x00, 0x00, 0x81, 0x96, 0x14, 0xf0, 0xb5, 0x88, 0xfc, 0xec, 
 0x05, 0xc5, 0x1b, 0xfb, 0x3b, 0xf6, 0x63, 0xc1, 0xf4, 0x26, 0xdd, 0x30, 0xc5, 0xee, 0xfc, 0x74, 
 0x4c, 0x35, 0xfb, 0xff, 0x03, 0xf1, 0xfe, 0xc9, 0x1b, 0x47, 0x99, 0x91, 0xaf, 0x5a, 0x44, 0x42, 
 0xa9, 0x81, 0x50, 0x91, 0x83, 0x8b, 0x1a, 0x35, 0xaa, 0x03, 0x10, 0xb1, 0x92, 0xdd, 0x63, 0x84, 
 0xfb, 0xc4, 0xef, 0x84, 0xd9, 0xff, 0x2d, 0x35, 0x00, 0x00, 0x00, 0x00, 0xcf, 0x2b, 0xf7, 0x27, 
 0x13, 0x99, 0xea, 0x1e, 0xe7, 0x45, 0xf3, 0x0e, 0x62, 0xd4, 0xff, 0x09, 0x16, 0x7b, 0xf2, 0x2a, 
 0xfb, 0x36, 0xc0, 0x78, 0x11, 0x94, 0x95, 0x90, 0xac, 0xda, 0x42, 0x3b, 0x61, 0xee, 0xf7, 0xaf, 
 0xef, 0x19, 0x6b, 0xee, 0xb9, 0xc5, 0x38, 0x9e, 0x3c, 0x21, 0x80, 0xb8, 0x6b, 0x88, 0xac, 0x01, 
 0x36, 0xb6, 0xda, 0x1e, 0xce, 0x26, 0x82, 0x9d, 0x2c, 0x4f, 0xa7, 0xa1, 0x00, 0x00, 0x00, 0x00, 
 0xa9, 0x3f, 0x66, 0x02, 0x0c, 0x8b, 0xe8, 0x85, 0x76, 0x3b, 0x9f, 0x9b, 0xd2, 0x51, 0x34, 0x3e, 
 0xf5, 0x47, 0x36, 0x6f, 0x5e, 0x5a, 0x22, 0xa4, 0x48, 0x3f, 0x9d, 0xa8, 0xdb, 0xf0, 0xbe, 0x86, 
 0xdd, 0xf8, 0x1c, 0x89, 0x54, 0x44, 0xe6, 0xff, 0x06, 0xe2, 0x29, 0xd4, 0xd5, 0x1d, 0x82, 0xa0, 
 0x6a, 0x7b, 0x13, 0xad, 0x21, 0x8b, 0x37, 0xf6, 0xbf, 0x40, 0xab, 0x44, 0xb0, 0xc8, 0x4c, 0x57, 
 0xcf, 0x93, 0x42, 0xba, 0x8d, 0x17, 0xb5, 0x6a, 0xcb, 0x8f, 0x07, 0x9f, 0x1b, 0x07, 0xbb, 0x7d, 
 0xb7, 0xac, 0x0d, 0xad, 0x36, 0x8b, 0xa4, 0x79, 0x9c, 0x4d, 0x4b, 0x6e, 0xc9, 0xb8, 0x76, 0x01, 
 0x20, 0xaa, 0x92, 0x03, 0x63, 0x1d, 0x68, 0xbe, 0x5e, 0x0f, 0x35, 0xd5, 0x60, 0xf6, 0x70, 0xa0, 
 0x70, 0x8d, 0xbb, 0xd4, 0x1f, 0x71, 0xc5, 0x27, 0x4b, 0xd6, 0xd6, 0xae, 0x85, 0x92, 0xc6, 0x50, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab, 0xab 
 } ;

static VOID
ReverseMemCopy(
    PUCHAR      Dest,
    PUCHAR      Source,
    ULONG       Size)
{
    PUCHAR  p;

    p = Dest + Size - 1;
    do
    {
	*p-- = *Source++;
    } while (p >= Dest);
}


BOOL FSignCertVerify(PBYTE rgbHash, PBYTE pbSigned, DWORD *pdwcbSigned)
	{
    INT   iBlockLen;
    INT   iPadLen;
    BYTE  pbInputBlock[ENCRYPTED_KEY_SIZE];
    BYTE  pbOutputBlock[ENCRYPTED_KEY_SIZE];



    // Build signature block (in network order)
    iBlockLen = 0x80;  //MONDO KLUDGE:::
    iPadLen = iBlockLen - MD5DIGESTLEN - A_SHA_DIGEST_LEN - 3;
    pbOutputBlock[0] = 0;
    pbOutputBlock[1] = 1;
    FillMemory(pbOutputBlock + 2, iPadLen, 0xff);
    pbOutputBlock[iPadLen + 2] = 0;
    CopyMemory(pbOutputBlock + iPadLen + 3, rgbHash, 
    			MD5DIGESTLEN + A_SHA_DIGEST_LEN);


    // Convert signature block to little endian (so BSAFE is happy)
    FillMemory(pbInputBlock, ENCRYPTED_KEY_SIZE, 0);
    ReverseMemCopy(pbInputBlock, pbOutputBlock, iBlockLen);

    // Encrypt (aka "sign") signature block with (large) private key
    if(!BSafeDecPrivate((LPBSAFE_PRV_KEY)vrgbPrivKey,
			pbInputBlock,
			pbOutputBlock)) 
	{
		return FALSE;
    }


    // Store signature block to message, converting it back to network order
    ReverseMemCopy(pbSigned, pbOutputBlock, iBlockLen);
    *pdwcbSigned = iBlockLen;

	return(TRUE);
	}



BOOL FindClientAuthCertsByIssuer
(
PBYTE pb, 
DWORD dwcbIssuerName, 
PBYTE pbCert, 
DWORD *pdwcbCert
)
	{
	if(*pdwcbCert < vcbCert)
		return(FALSE);
	*pdwcbCert = vcbCert;
	CopyMemory(pbCert, vrgbCert, sizeof(vrgbCert));
	return(TRUE);
	}

#ifdef EXPORT
Initialize(
    PctPrivateKey *pPrivate;
    PctPublicKey  *pPublic;


    BitsCopy = Bits;
    BSafeComputeKeySizes( &dwPublicSize, &dwPrivateSize, &BitsCopy );

    pPrivate = SPExternalAlloc( dwPrivateSize + sizeof(PctPrivateKey));
    pPublic = SPExternalAlloc(  dwPublicSize + sizeof(PctPublicKey));

    if (!pPrivate || !pPublic)
    {
        if (pPrivate)
        {
            SPExternalFree( pPrivate );
        }

        if (pPublic)
        {
            SPExternalFree( pPublic );
        }

        return( FALSE );
    }

    pPublic->cbKey = dwPublicSize;
    pPrivate->cbKey = dwPrivateSize;
    if (!BSafeMakeKeyPair((BSAFE_PUB_KEY *)pPublic->pKey, (BSAFE_PRV_KEY *)pPrivate->pKey, Bits ) )
    {
        SPExternalFree( pPrivate );
        SPExternalFree( pPublic );
        return( FALSE );
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\ssl2srv.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       context.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-08-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <ssl2msg.h>
#include <ssl2prot.h>



SP_STATUS Ssl2SrvGenerateServerFinish(PSPContext pContext,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl2SrvGenerateServerVerify(PSPContext pContext,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl2SrvVerifyClientFinishMsg(PSPContext pContext,
                              PSPBuffer  pCommInput);

#define SSL_OFFSET_OF(t, v) (DWORD)&(((t)NULL)->v)

SP_STATUS WINAPI
Ssl2ServerProtocolHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput,
    PSPBuffer pAppOutput)
{
    SP_STATUS pctRet = 0;
    DWORD cMessageType;

    DWORD dwStateTransition;
    BOOL fRaw = TRUE;
    SPBuffer MsgInput;
//    DWORD cbMsg;
//    PUCHAR pb;
//    UCHAR bCT;

    if (NULL != pCommOutput)
    {
        pCommOutput->cbData = 0;
    }
    if (NULL != pAppOutput)
    {
        pAppOutput->cbData = 0;
    }


    MsgInput.pvBuffer = pCommInput->pvBuffer;
    MsgInput.cbBuffer = pCommInput->cbBuffer;
    MsgInput.cbData = pCommInput->cbData;

    cMessageType = ((PUCHAR) MsgInput.pvBuffer)[2];
    // In the following states, we should decrypt the message:
    switch(pContext->State)
    {
        case SSL2_STATE_SERVER_VERIFY:
        case SSL2_STATE_SERVER_RESTART:
            pctRet = Ssl2DecryptMessage(pContext, pCommInput, &MsgInput);
            cMessageType = ((PUCHAR) MsgInput.pvBuffer)[0];
            fRaw = FALSE;
    }


    if (MsgInput.cbData < 3)
    {
        pctRet = PCT_INT_INCOMPLETE_MSG;
    }

    dwStateTransition = (cMessageType << 16) |
			        (pContext->State & 0xffff);

    if (pctRet != PCT_ERR_OK)
    {
        // to handle incomplete message errors
        return(pctRet);
    }

	switch(dwStateTransition)
    {

        /* Server receives client hello */
        case (SSL2_MT_CLIENT_HELLO << 16) | SP_STATE_NONE:
        {
            PSsl2_Client_Hello pSsl2Hello;

            // Attempt to recognize and handle various versions of client
            // hello, start by trying to unpickle the most recent version, and
            // then next most recent, until one unpickles.  Then run the handle
            // code.  We can also put unpickling and handling code in here for
            // SSL messages.

            pctRet = Ssl2UnpackClientHello(pCommInput, &pSsl2Hello);

            if (PCT_ERR_OK == pctRet)
            {

                if ((pSsl2Hello->cbSessionID) &&
                    (SPCacheRetrieveBySession(SP_PROT_SSL2_SERVER,
                                              pSsl2Hello->SessionID,
                                              pSsl2Hello->cbSessionID,
                                              &pContext->RipeZombie)))

                {
                    pctRet = Ssl2SrvGenRestart(
                                                pContext,
                                                pSsl2Hello,
                                                pCommOutput);
                    if (PCT_ERR_OK == pctRet)
                    {
                        pContext->State = SSL2_STATE_SERVER_VERIFY;
                    }
                }
                else
                {
                   pContext->RipeZombie->fProtocol = SP_PROT_SSL2_SERVER;
                   pctRet = Ssl2SrvHandleClientHello(
			                     pContext,
			                     pCommInput,
			                     pSsl2Hello,
			                     pCommOutput);
                    if (PCT_ERR_OK == pctRet)
                    {
                        pContext->State = SSL2_STATE_SERVER_HELLO;
                    }
                }
                SPExternalFree(pSsl2Hello);

            }
            else if(pctRet != PCT_INT_INCOMPLETE_MSG)
            {
                pctRet |= PCT_INT_DROP_CONNECTION;
            }


            if (SP_FATAL(pctRet))
            {
	            pContext->State = PCT1_STATE_ERROR;
            }
            break;
        }

        case (SSL2_MT_CLIENT_MASTER_KEY << 16) | SSL2_STATE_SERVER_HELLO:

            pctRet = Ssl2SrvHandleCMKey(pContext, pCommInput, pCommOutput);
            if (SP_FATAL(pctRet))
            {
                pContext->State = PCT1_STATE_ERROR;
            }
            else
            {
                if (PCT_ERR_OK == pctRet)
                {
                    pContext->State = SSL2_STATE_SERVER_VERIFY;
                }
                // We received a non-fatal error, so the state doesn't change,
                // giving the app time to deal with this.
            }
            break;

        case (SSL2_MT_CLIENT_FINISHED_V2 << 16) | SSL2_STATE_SERVER_VERIFY:
            pctRet = Ssl2SrvHandleClientFinish(
                                                pContext,
                                                &MsgInput,
                                                pCommOutput);
            if (SP_FATAL(pctRet))
            {
                pContext->State = PCT1_STATE_ERROR;
            }
            else
            {
            if (PCT_ERR_OK == pctRet)
            {
                pContext->State = SP_STATE_CONNECTED;
                pContext->DecryptHandler = Ssl2DecryptHandler;
                pContext->Encrypt = Ssl2EncryptMessage;
                pContext->Decrypt = Ssl2DecryptMessage;
            }
            // We received a non-fatal error, so the state doesn't change,
            // giving the app time to deal with this.
            }
            break;

        default:
            DebugLog((DEB_WARN, "Error in protocol, dwStateTransition is %lx\n", dwStateTransition));
            pContext->State = PCT1_STATE_ERROR;
            pctRet = PCT_INT_ILLEGAL_MSG;
            if (cMessageType == SSL2_MT_ERROR)
            {
                // BUGBUG: handle an SSL2 error message
            }
            break;
    }
    if (pctRet & PCT_INT_DROP_CONNECTION)
    {
        pContext->State &= ~SP_STATE_CONNECTED;
    }
    // To handle incomplete message errors:

    return(pctRet);
}



SP_STATUS
Ssl2SrvHandleClientHello(
    PSPContext         pContext,
    PSPBuffer           pCommInput,
    PSsl2_Client_Hello  pHello,
    PSPBuffer           pCommOutput)
{
    SP_STATUS pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    PSPCredential  pCred;
    Ssl2_Server_Hello    Reply;
//    DWORD           i, k;
    DWORD           cCommonCiphers, ServerCipher, ClientCipher;
    DWORD           CommonCiphers[16];
    PSessCacheItem  pZombie;

    SP_BEGIN("Ssl2SrvHandleClientHello");

    pCommOutput->cbData = 0;

    /* validate the buffer configuration */

    if(NULL == pContext)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }
    pCred = pContext->pCred;
    pZombie = pContext->RipeZombie;
    if (!pCred)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }


    do {

        FillMemory( &Reply, sizeof( Reply ), 0 );

        //
        // Calculate common ciphers:
        //

        cCommonCiphers = 0;

        for (ServerCipher = 0;
             ServerCipher < Ssl2NumCipherRanks ;
             ServerCipher++)
        {
            // Is this cipher set enabled for
            // ssl2 server.


            if(NULL == CipherFromSpec(Ssl2CipherRank[ServerCipher].Cipher, SP_PROT_SSL2_SERVER))
            {
                continue;
            }
            if(NULL == HashFromSpec(Ssl2CipherRank[ServerCipher].Hash, SP_PROT_SSL2_SERVER))
            {
                continue;
            }
            if(NULL == KeyExchangeFromSpec(Ssl2CipherRank[ServerCipher].KeyExch, SP_PROT_SSL2_SERVER))
            {
                continue;
            }
            // Does the client want this cipher type?
            for (ClientCipher = 0;
                 ClientCipher < pHello->cCipherSpecs ;
                 ClientCipher++ )
            {
                if ( Ssl2CipherRank[ServerCipher].Kind ==
                            pHello->CipherSpecs[ClientCipher] )
                {
                    CommonCiphers[cCommonCiphers++] = Ssl2CipherRank[ServerCipher].Kind;
                    break;
                }
            }

        }

        //
        // if cCommonCipers == 0, then we have none in common.  At this point, we
        // should generate an error response, but that is for later.  For now,
        // we will generate an invalid_token return, and bail out.
        //

        if (cCommonCiphers == 0)
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
            break;
        }


        Reply.cCipherSpecs = cCommonCiphers;
        Reply.pCipherSpecs = CommonCiphers;
        Reply.SessionIdHit = 0;

        /* pick a cert, any cert   */

        pctRet = SPCredPickCertificate(SP_PROT_PCT1_SERVER,
                                       pCred,
                                       Ssl2CertRank,
                                       Ssl2NumCert,
                                       Ssl2CertRank,
                                       Ssl2NumCert,
                                       &pZombie->pServerCert,
                                       &pContext->pPrivateKey);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }
        else
        {

            Reply.CertificateType =   pZombie->pServerCert->Spec;
            Reply.pCertificate =    pZombie->pServerCert->pRawCert;
            Reply.cbCertificate =  pZombie->pServerCert->cbRawCert;
        }



        /* Generate a conneciton id to use while establishing connection */

        Reply.cbConnectionID = SSL2_GEN_CONNECTION_ID_LEN;	
        GenerateRandomBits(  Reply.ConnectionID,
                             Reply.cbConnectionID );

        CopyMemory(pContext->pConnectionID,
                   Reply.ConnectionID,
                   Reply.cbConnectionID);
        pContext->cbConnectionID = Reply.cbConnectionID;


        /* keep challenge around for later */
        CopyMemory( pContext->pChallenge,
                    pHello->Challenge,
                    pHello->cbChallenge);
        pContext->cbChallenge = pHello->cbChallenge;



        pctRet = Ssl2PackServerHello(&Reply, pCommOutput);
        if (PCT_ERR_OK != pctRet)
        {
            break;
        }
        pContext->WriteCounter = 1;  /* received client hello */
        pContext->ReadCounter = 1;   /* Sending server hello */


        SP_RETURN(PCT_ERR_OK);
    } while (TRUE); /* end Polish Loop */

    if((pContext->Flags & CONTEXT_FLAG_EXT_ERR) &&
        (pctRet == PCT_ERR_SPECS_MISMATCH))
    {
        // Our SSL2 implementation does not do client auth,
        // so there is only one error message, cipher error.
        pCommOutput->cbData = 3; // MSG-ERROR + ERROR-CODE-MSB + ERROR-CODE-LSB

        if(pCommOutput->pvBuffer == NULL)
        {
            pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
            if (NULL == pCommOutput->pvBuffer)
            {
                return SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY);
            }
            pCommOutput->cbBuffer = pCommOutput->cbData;
        }
        if(pCommOutput->cbData > pCommOutput->cbBuffer)
        {
            return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
        }

        ((PUCHAR)pCommOutput->pvBuffer)[0] = SSL2_MT_ERROR;
        ((PUCHAR)pCommOutput->pvBuffer)[1] = MSBOF(SSL_PE_NO_CIPHER);
        ((PUCHAR)pCommOutput->pvBuffer)[2] = LSBOF(SSL_PE_NO_CIPHER);

    }
    SP_RETURN(pctRet | PCT_INT_DROP_CONNECTION);
}



 SP_STATUS
 Ssl2SrvGenRestart(
    PSPContext         pContext,
    PSsl2_Client_Hello  pHello,
    PSPBuffer           pCommOutput)
{
    SP_STATUS pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    SPBuffer SecondOutput;
    Ssl2_Server_Hello    Reply;
    DWORD cbMessage, cbMsg, cPadding;
    PSessCacheItem  pZombie;

    SP_BEGIN("Ssl2SrvGenRestart");

    pCommOutput->cbData = 0;

    /* validate the buffer configuration */

    /* make sure we have the needed authentication data area */
    if (NULL == pContext)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }
    pZombie = pContext->RipeZombie;




    do {

        FillMemory( &Reply, sizeof( Reply ), 0 );

        Reply.SessionIdHit = (DWORD)1;
        Reply.cCipherSpecs = 0;
        Reply.pCipherSpecs = NULL;
        Reply.pCertificate = NULL;
        Reply.cbCertificate = 0;
        Reply.CertificateType = 0;

        /* Note, we generate both a server hello, and a server verify in
         * this handling routing.  This is because netscape will not send
         * us a client finish until the server verify is received
         */


        pctRet = ContextInitCiphers(pContext);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        Reply.cbConnectionID = SSL2_GEN_CONNECTION_ID_LEN;
        GenerateRandomBits(  Reply.ConnectionID,
                             Reply.cbConnectionID );

        CopyMemory(pContext->pConnectionID,
                   Reply.ConnectionID,
                   Reply.cbConnectionID);
        pContext->cbConnectionID = Reply.cbConnectionID;


        /* keep challenge around for later */
        CopyMemory( pContext->pChallenge,
                    pHello->Challenge,
                    pHello->cbChallenge);
        pContext->cbChallenge = pHello->cbChallenge;


        Ssl2MakeSessionKeys( pContext);

        /* calc size of the server hello (restart only) */
        cbMessage = Reply.cbConnectionID +
                        Reply.cbCertificate +
                        Reply.cCipherSpecs * sizeof(Ssl2_Cipher_Tuple) +
                        SSL_OFFSET_OF(PSSL2_SERVER_HELLO, VariantData) -
                        sizeof(SSL2_MESSAGE_HEADER);

        pCommOutput->cbData = cbMessage + 2;

        /* calc size of server verify */
        cbMsg  = sizeof(UCHAR) + pContext->cbChallenge;
        cPadding = (cbMsg+pContext->pCheck->cbCheckSum) &
                   (pContext->pSystem->BlockSize - 1);
        pCommOutput->cbData += cbMsg +
                              pContext->pCheck->cbCheckSum +
                              cPadding +
                              (cPadding?3:2);


        /* are we allocating our own memory? */
        if(pCommOutput->pvBuffer == NULL) {
            pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
            if (NULL == pCommOutput->pvBuffer)
                SP_RETURN(SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY));
            pCommOutput->cbBuffer = pCommOutput->cbData;
        }

        if(pCommOutput->cbData > pCommOutput->cbBuffer)
        {
            SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
        }


        pctRet = Ssl2PackServerHello(&Reply, pCommOutput);
        if (PCT_ERR_OK != pctRet)
        {
            break;
        }
        pContext->WriteCounter = 1;  /* received client hello */
        pContext->ReadCounter = 1;   /* Sending server hello */

        /* Now pack the server verify message and encrypt it */
        SecondOutput.pvBuffer = (PUCHAR)pCommOutput->pvBuffer+pCommOutput->cbData;
        SecondOutput.cbBuffer = pCommOutput->cbBuffer-pCommOutput->cbData;


        pctRet = Ssl2SrvGenerateServerVerify(pContext, &SecondOutput);
        if (PCT_ERR_OK != pctRet)
        {
            break;
        }
        pCommOutput->cbData += SecondOutput.cbData;

        SP_RETURN(PCT_ERR_OK);
    } while (TRUE); /* end Polish Loop */
    SP_RETURN(pctRet | PCT_INT_DROP_CONNECTION);
}



SP_STATUS
Ssl2SrvHandleCMKey(
    PSPContext pContext,
    PSPBuffer   pCommInput,
    PSPBuffer   pCommOutput)
{
    SP_STATUS          pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    PSsl2_Client_Master_Key  pMasterKey = NULL;
    DWORD               dwKeyLen;
    DWORD               EncryptedLen;
    DWORD              i;
    SignatureSystem     *pSigSys = NULL;
    SignatureSystem     *pCASigSys = NULL;
    CertSystem          *pCertSys = NULL;
    DWORD               cbData;
    PSessCacheItem  pZombie;

    SP_BEGIN("Ssl2SrvHandleCMKey");

    pCommOutput->cbData = 0;

    pZombie = pContext->RipeZombie;

    do {

        /* make sure we have the needed authentication data area */

        cbData = pCommInput->cbData;
        pctRet = Ssl2UnpackClientMasterKey(pCommInput, &pMasterKey);


        if (PCT_ERR_OK != pctRet)
        {
            // If it's an incomplete message or something, just return;
            if(!SP_FATAL(pctRet))
            {
                SP_RETURN(pctRet);
            }
            break;
        }

	    pctRet = PCT_ERR_ILLEGAL_MESSAGE;


        /* CMK sent cleartext, so we must auto-inc the read counter */
        pContext->ReadCounter++;

        pContext->pSystem = NULL;
        pContext->pCheck = NULL;
        pContext->pKeyExch = NULL;

        // Pick a cipher suite

        for(i=0; i<Ssl2NumCipherRanks; i++) {
            if(NULL == CipherFromSpec(Ssl2CipherRank[i].Cipher, SP_PROT_SSL2_SERVER))
            {
                continue;
            }
            if(NULL == HashFromSpec(Ssl2CipherRank[i].Hash, SP_PROT_SSL2_SERVER))
            {
                continue;
            }
            if(NULL == KeyExchangeFromSpec(Ssl2CipherRank[i].KeyExch, SP_PROT_SSL2_SERVER))
            {
                continue;
            }

            if (Ssl2CipherRank[i].Kind == pMasterKey->CipherKind) {

                pZombie->SessCiphSpec  = Ssl2CipherRank[i].Cipher;
                pZombie->SessHashSpec  = Ssl2CipherRank[i].Hash;
                pZombie->SessExchSpec  = Ssl2CipherRank[i].KeyExch;
                pctRet = ContextInitCiphers(pContext);
                if(PCT_ERR_OK == pctRet)
                {
                    break;
                }
            }
        }

        if (pContext->pSystem == NULL ||
            pContext->pCheck == NULL ||
            pContext->pKeyExch == NULL)
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
            break;
        }

        /* unpack the clear portion of the master key */
        dwKeyLen = ((pZombie->SessCiphSpec & SP_CIPHER_STRENGTH) >> SP_CSTR_POS) / 8;
        if (dwKeyLen < SSL2_MASTER_KEY_SIZE) {
            pZombie->cbClearKey = SSL2_MASTER_KEY_SIZE - dwKeyLen;
        }
        else {
            pZombie->cbClearKey = 0;
        }

        if (pMasterKey->ClearKeyLen != pZombie->cbClearKey)
        {
            break;
        }


        CopyMemory( pZombie->pMasterKey,
                    pMasterKey->ClearKey,
                    pMasterKey->ClearKeyLen);

        /* Decrypt the encrypted portion of the master key */
        if (!pContext->pKeyExch->Decrypt(
				    pMasterKey->EncryptedKey,
				    pMasterKey->EncryptedKeyLen,
				    pZombie->pMasterKey+pMasterKey->ClearKeyLen,
				    &EncryptedLen,
				    pContext->pPrivateKey,
                    SP_PROT_SSL2_SERVER))
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_BAD_CERTIFICATE);
            break;
        }

        pZombie->cbMasterKey = pMasterKey->ClearKeyLen + EncryptedLen;

        SPExternalFree( pMasterKey );
        pMasterKey = NULL;

        if (EncryptedLen != dwKeyLen)
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
            break;
        }


        pctRet = Ssl2MakeSessionKeys( pContext );

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        pctRet = Ssl2SrvGenerateServerVerify(pContext, pCommOutput);
        SP_RETURN(pctRet);

    } while(TRUE);

    if (pMasterKey)
    {
        SPExternalFree( pMasterKey );
    }
    if((pContext->Flags & CONTEXT_FLAG_EXT_ERR) &&
        (pctRet == PCT_ERR_SPECS_MISMATCH))
    {
        // Our SSL2 implementation does not do client auth,
        // so there is only one error message, cipher error.
        pCommOutput->cbData = 3; // MSG-ERROR + ERROR-CODE-MSB + ERROR-CODE-LSB

        /* are we allocating our own memory? */
        if(pCommOutput->pvBuffer == NULL)
        {
            pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);

            if (NULL == pCommOutput->pvBuffer)
            {
                SP_RETURN(SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY));
            }
            pCommOutput->cbBuffer = pCommOutput->cbData;
        }
        if(pCommOutput->cbData <= pCommOutput->cbBuffer)
        {
            ((PUCHAR)pCommOutput->pvBuffer)[0] = SSL2_MT_ERROR;
            ((PUCHAR)pCommOutput->pvBuffer)[1] = MSBOF(SSL_PE_NO_CIPHER);
            ((PUCHAR)pCommOutput->pvBuffer)[2] = LSBOF(SSL_PE_NO_CIPHER);
        }
        else
        {
            pCommOutput->cbData = 0;
        }

    }
    SP_RETURN((PCT_INT_DROP_CONNECTION | pctRet));
}



SP_STATUS
Ssl2SrvVerifyClientFinishMsg(
    PSPContext pContext,
    PSPBuffer  pCommInput)
{
    SP_STATUS     pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    PSSL2_CLIENT_FINISHED pFinished;

    SP_BEGIN("Ssl2SrvVerifyClientFinishMsg");


    /* Note, there is no header in this message, as it has been pre-decrypted */
    if (pCommInput->cbData != sizeof(UCHAR) + pContext->cbConnectionID)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG));
    }
    pFinished = pCommInput->pvBuffer;
    if (pFinished->MessageId != SSL2_MT_CLIENT_FINISHED_V2)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG));
    }

    if ( memcmp(pFinished->ConnectionID,
            pContext->pConnectionID,
            pContext->cbConnectionID))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG));
    }
    SP_RETURN(PCT_ERR_OK);

}

SP_STATUS
Ssl2SrvGenerateServerVerify(
    PSPContext pContext,
    PSPBuffer   pCommOutput)
{
    SP_STATUS     pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    PSSL2_SERVER_VERIFY     pVerify;
    DWORD                   HeaderSize;
    SPBuffer                MsgOutput;
    DWORD                   cPadding;
    BOOL                    fAlloced = FALSE;

    pCommOutput->cbData = 0;

    SP_BEGIN("Ssl2SrvGenerateServerVerify");

    do {

        MsgOutput.cbData = sizeof(UCHAR) + pContext->cbChallenge;
        cPadding = (MsgOutput.cbData+pContext->pCheck->cbCheckSum) &
                   (pContext->pSystem->BlockSize - 1);

        HeaderSize = (cPadding?3:2);

        pCommOutput->cbData = MsgOutput.cbData +
                              pContext->pCheck->cbCheckSum +
                              cPadding + HeaderSize;


        /* are we allocating our own memory? */
        if (pCommOutput->pvBuffer == NULL) {
            pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
            if (NULL == pCommOutput->pvBuffer)
            {
                SP_RETURN(SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY));
            }
            fAlloced = TRUE;
            pCommOutput->cbBuffer = pCommOutput->cbData;
        }

        MsgOutput.pvBuffer= (PUCHAR)pCommOutput->pvBuffer +
                             HeaderSize+pContext->pCheck->cbCheckSum;

        MsgOutput.cbBuffer=  pCommOutput->cbBuffer -
                             HeaderSize-pContext->pCheck->cbCheckSum;


        pVerify = (PSSL2_SERVER_VERIFY) MsgOutput.pvBuffer;
        pVerify->MessageId = SSL2_MT_SERVER_VERIFY;


        CopyMemory( pVerify->ChallengeData,
                pContext->pChallenge,
                pContext->cbChallenge );


        pctRet = Ssl2EncryptMessage( pContext, &MsgOutput, pCommOutput);
        if(PCT_ERR_OK != pctRet)
        {
            break;
        }
        SP_RETURN(PCT_ERR_OK);

    } while(TRUE);

    if(fAlloced && (NULL != pCommOutput->pvBuffer))
    {
        SPExternalFree(pCommOutput->pvBuffer);
        pCommOutput->cbBuffer = 0;
        pCommOutput->cbData = 0;
        pCommOutput->pvBuffer = NULL;

    }
    SP_RETURN(PCT_INT_DROP_CONNECTION | pctRet);
}

SP_STATUS
Ssl2SrvGenerateServerFinish(
    PSPContext pContext,
    PSPBuffer   pCommOutput)
{
    SP_STATUS     pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    PSSL2_SERVER_FINISHED pFinish;
    DWORD                   HeaderSize;
    SPBuffer                MsgOutput;
    DWORD                   cPadding;
    BOOL                    fAlloced = FALSE;
    pCommOutput->cbData = 0;
    SP_BEGIN("Ssl2SrvGenerateServerFinish");

    do {

        /* Generate a session id to use during the session */
        pContext->RipeZombie->cbSessionID = SSL2_SESSION_ID_LEN;
        GenerateRandomBits(  pContext->RipeZombie->SessionID,
                             pContext->RipeZombie->cbSessionID );

        /* store this context in the cache */
        /* note - we don't check error 'cause it's recoverable
         * if we don't cache */

        SPCacheAdd(pContext->RipeZombie);

        MsgOutput.cbData = sizeof(UCHAR) + pContext->RipeZombie->cbSessionID;
        cPadding = (MsgOutput.cbData+pContext->pCheck->cbCheckSum) &
                   (pContext->pSystem->BlockSize - 1);

        HeaderSize = (cPadding?3:2);

        pCommOutput->cbData = MsgOutput.cbData +
                              pContext->pCheck->cbCheckSum +
                              cPadding +
                              HeaderSize;

        /* are we allocating our own memory? */
        if(pCommOutput->pvBuffer == NULL)
        {
            pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
            if (NULL == pCommOutput->pvBuffer)
            {
                return SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY);
            }
            fAlloced = TRUE;

            pCommOutput->cbBuffer = pCommOutput->cbData;
        }
        if(pCommOutput->cbData > pCommOutput->cbBuffer)
        {
            return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
        }

        MsgOutput.pvBuffer= (PUCHAR)pCommOutput->pvBuffer + HeaderSize+pContext->pCheck->cbCheckSum;
        MsgOutput.cbBuffer=  pCommOutput->cbBuffer-HeaderSize-pContext->pCheck->cbCheckSum;


        pFinish = (PSSL2_SERVER_FINISHED) MsgOutput.pvBuffer;
        pFinish->MessageId = SSL2_MT_SERVER_FINISHED_V2;


        CopyMemory( pFinish->SessionID,
                pContext->RipeZombie->SessionID,
                pContext->RipeZombie->cbSessionID );

        /* Cache Context Here */

        pctRet = Ssl2EncryptMessage( pContext, &MsgOutput, pCommOutput);
        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        SP_RETURN(PCT_ERR_OK);

    } while(TRUE);
    if(fAlloced && (NULL != pCommOutput->pvBuffer))
    {
        SPExternalFree(pCommOutput->pvBuffer);
        pCommOutput->cbBuffer = 0;
        pCommOutput->cbData = 0;
        pCommOutput->pvBuffer = NULL;

    }
    SP_RETURN(PCT_INT_DROP_CONNECTION | pctRet);

 }

SP_STATUS
Ssl2SrvHandleClientFinish(
    PSPContext pContext,
    PSPBuffer   pCommInput,
    PSPBuffer   pCommOutput)
{
    SP_STATUS     pctRet = PCT_ERR_ILLEGAL_MESSAGE;

    SP_BEGIN("Ssl2SrvHandleClientFinish");

    pCommOutput->cbData = 0;

    pctRet = Ssl2SrvVerifyClientFinishMsg(pContext, pCommInput);
    if (PCT_ERR_OK != pctRet)
    {
        SP_RETURN(pctRet);
    }
    pctRet = Ssl2SrvGenerateServerFinish(pContext, pCommOutput);

    SP_RETURN(pctRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\ssl3msg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       msgs.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-02-95   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __SSL3MSG_H__
#define __SSL3MSG_H__


#define CB_SSL3_SESSION_ID 	 32
#define CB_SSL3_RANDOM		 32
#define CB_SSL3_UNIXTIME	  4
#define CB_SSL3_PRE_MASTER_SECRET  48
#define CB_SSL3_MAX_SRV_KEY_EXCHANGE 500
#define CB_SSL3_PROTOLCOL	  2
#define CB_SSL3_SHA_PAD       40
#define CB_SSL3_MD5_PAD       48
#define CB_SSL3_MAX_CERT_VERIFY 500

#define CB_SLL3_CHANGE_CIPHER_SPEC    (sizeof(SWRAP) + 1)
#define CB_MD5DIGESTLEN 	  16
#define CB_A_SHA_DIGEST_LEN   20
#define CB_SSL3_FINISHED_MSG  (sizeof(FMWIRE))

#define CH_SLL3_MD5_PAD_CHAR	0x36
#define CH_SSL3_SHA_PAD_CHAR    0x5c

#define SSL3_NULL_WITH_NULL_NULL	    0x0000
#define SSL3_RSA_WITH_NULL_MD5		    0x0001
#define SSL3_RSA_WITH_NULL_SHA		    0x0002
#define SSL3_RSA_EXPORT_WITH_RC4_40_MD5     0x0003
#define SSL3_RSA_WITH_RC4_128_MD5	    0x0004
#define SSL3_RSA_WITH_RC4_128_SHA	    0x0005
#define SSL3_RSA_EXPORT_WITH_RC2_CBC_40_MD5 0x0006  // not supported
#define SSL3_RSA_WITH_IDEA_CBC_SHA	    0x0007  // not supported
#define SSL3_RSA_EXPORT_WITH_DES40_CBC_SHA  0x0008  // not supported
#define SSL3_RSA_WITH_DES_CBC_SHA	    0x0009  // not supported
#define SSL3_RSA_WITH_3DES_EDE_CBC_SHA	    0x000A  // not supported

#define SSL_RSA_FINANCE64_WITH_RC4_64_MD5    0x0080
#define SSL_RSA_FINANCE64_WITH_RC4_64_SHA    0x0081

#define  SSL3_HS_HELLO_REQUEST			0x00
#define  SSL3_HS_CLIENT_HELLO			0x01
#define  SSL3_HS_SERVER_HELLO			0x02
#define  SSL3_HS_CERTIFICATE			0x0B
#define  SSL3_HS_SERVER_KEY_EXCHANGE 	0x0C
#define  SSL3_HS_CERTIFICATE_REQUEST	0x0D
#define  SSL3_HS_SERVER_HELLO_DONE		0x0E
#define  SSL3_HS_CERTIFICATE_VERIFY		0x0F
#define  SSL3_HS_CLIENT_KEY_EXCHANGE	0x10
#define  SSL3_HS_FINISHED				0x14
#define  SSL3_CT_CHANGE_CIPHER_SPEC     20
#define  SSL3_CT_ALERT					21
#define  SSL3_CT_HANDSHAKE			    22
#define  SSL3_CT_APPLICATIONDATA		23
#define  SSL3_NULL_WRAP					15
#define  SSL3_CERTTYPE_RSA_SIGN			1
#define SSL3_CLIENT_VERSION_MSB			0x03
#define SSL3_CLIENT_VERSION_LSB			0x00
#define CB_SSL3_CERT_VECTOR   			3
#define CB_SSL3_ALERT					(sizeof(SWRAP) +2)

// Alert levels
#define SSL3_ALERT_WARNING		1
#define SSL3_ALERT_FATAL		2

// Alert message types
#define SSL3_ALERT_CLOSE_NOTIFY 	0
#define SSL3_ALERT_UNEXPECTED_MESSAGE	10
#define SSL3_ALERT_BAD_RECORD_MAC	20
#define SSL3_ALERT_DECOMPRESSION_FAIL	30
#define SSL3_ALERT_HANDSHAKE_FAILURE	40
#define SSL3_ALERT_NO_CERTIFICATE	41
#define SSL3_ALERT_BAD_CERTIFICATE	42
#define SSL3_ALERT_UNSUPPORTED_CERT	43
#define SSL3_ALERT_CERTIFICATE_REVOKED	44
#define SSL3_ALERT_CERTIFICATE_EXPIRED	45
#define SSL3_ALERT_CERTIFICATE_UNKNOWN	46
#define SSL3_ALERT_ILLEGAL_PARAMETER	47

#define SSL3_MASTER_KEY_SIZE            16
#define SSL3_ENCRYPTED_KEY_SIZE         272
#define SSL3_MAX_MESSAGE_LENGTH         32768
#define MAX_DIGEST_LEN                  32
#define SSL3_CLIENT_VERSION             0x0300

#define SSL3_CHANGE_CIPHER_MSG 	{ 0x14, 0x03, 0x00, 0x00, 0x01, 0x01 }

#define FSsl3CipherClient() (0 != pContext->wS3CipherSuiteClient)
#define FSsl3CipherServer() (0 != pContext->wS3CipherSuiteServer)

#define FSsl3Cipher(fClient) ((fClient ? pContext->wS3CipherSuiteClient : pContext->wS3CipherSuiteServer))
extern PctPrivateKey *g_pSsl3Private;
extern PctPublicKey *g_pSsl3Public;

#define MS24BOF(x)    ((UCHAR) ((x >> 16) & 0xFF) )

extern const Ssl2CipherMap Ssl3CipherRank[];
extern const DWORD Ssl3NumCipherRanks;

extern CertSpec Ssl3CertRank[];
extern const DWORD Ssl3NumCert;

typedef struct _shsh  //Structure hand shake header
	{
	UCHAR   typHS;
	UCHAR   bcb24;
	UCHAR   bcbMSB;
	UCHAR   bcbLSB;
	} SHSH;


typedef struct _swrap
	{
	UCHAR  bCType;
	UCHAR  bMajor;
	UCHAR  bMinor;
	UCHAR  bcbMSBSize;
	UCHAR  bcbLSBSize;
//	UCHAR  rgb[];
	} SWRAP;
	
typedef struct _ssh
	{
	SHSH;
	UCHAR 	bMajor;
	UCHAR   bMinor;
	UCHAR   rgbRandom[CB_SSL3_RANDOM];
	UCHAR   cbSessionId;
	UCHAR   rgbSessionId[CB_SSL3_SESSION_ID];
	UCHAR	wCipherSelectedMSB;
	UCHAR	wCipherSelectedLSB;
	UCHAR 	bCMSelected;
	} SSH;


typedef struct _alrt
	{
	SWRAP;
	UCHAR bAlertLevel;
	UCHAR bAlertDesc;
	} ALRT;

	
typedef struct _fm
	{
	UCHAR	rgbMD5[CB_MD5DIGESTLEN];
	UCHAR   rgbSHA[CB_A_SHA_DIGEST_LEN];
	} FM; //finished message

typedef struct _fmwire
	{
	SWRAP;
	SHSH;
	FM;
	} FMWIRE;

typedef struct _clh
	{
	SHSH;
	UCHAR 	bMajor;
	UCHAR   bMinor;
	UCHAR   rgbRandom[CB_SSL3_RANDOM];
	UCHAR   cbSessionId;
	UCHAR   rgbSessionId[CB_SSL3_SESSION_ID];
	UCHAR   bMSBCipher;
	UCHAR	bLSBCipher;
	// short   rgbCipher[0];  // ALignment problem, but never used.
	//UCHAR	bCM;
	//UCHAR rgbCM[bCM];
	} CLH ;	//CLient Hello	

								
typedef struct _cert
	{
	SHSH;
	UCHAR bcbClist24;
	UCHAR bcbMSBClist;
	UCHAR bcbLSBClist;
	UCHAR bcbCert24;
	UCHAR bcbMSBCert;
	UCHAR bcbLSBCert;
	UCHAR rgbCert[];
	/* followed by the real cert */
	} CERT;

	
typedef struct _certReq
    {
    SHSH;
    UCHAR bcbCertType; //This value be just 1 byte
    UCHAR bCertType;  //This will be Only one for quite sometime
    UCHAR bcbMSBList;
    UCHAR bcbLSBList;
    UCHAR rgbIss[];
    } CERTREQ;

typedef struct _shs
	{
	UCHAR	typHs;  //type of handshake
	UCHAR	cb24;
	short	cb16;
	union
		{
//		struct SHR  shr;
//		struct SCH  sch;
		SSH  ssh;
		CERT cert;
//		struct SRVKEYEXCH srvkeyex;
//		struct CERTRQ certrq;
//		struct SRVDONE srvdone;
//		struct SRVVER srvver;
//		struct CLKEYEX clkeyex;
//		struct FINISH  finish;
		} ;
	} SHS;

typedef struct _shwire
	{
	PUCHAR  pcbCipher;
	PUCHAR  pCiperSpec;
	PUCHAR  pcbCompM;
	PUCHAR  pCompM;
	PUCHAR  pcbCert;
	PUCHAR  pCert;
	PUCHAR  pHelloDone;
	} SHWIRE ;


SP_STATUS WINAPI
Ssl3DecryptHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pAppOutput);

SP_STATUS WINAPI
GenerateSsl3ClientHello(
    PSPContext             pContext,
    PSPBuffer               pOutput);
	
void Ssl3BuildMasterKeys(PSPContext pContext, PUCHAR pbPreMaster);

SP_STATUS
Ssl3PackClientHello(PSPContext pContext,
    PSsl2_Client_Hello       pCanonical,
    PSPBuffer          pCommOutput);



SP_STATUS Ssl3CliHandleServerHello(PSPContext pContext,
                                   PUCHAR pSrvHello,
                                   DWORD cbMessage,
                                   PSPBuffer  pCommOutput);
SP_STATUS Ssl3HandleServerFinish(PSPContext pContext,
                                   PUCHAR pSrvHello,
                                   DWORD cbMessage,
                                   PSPBuffer  pCommOutput);


SP_STATUS Ssl3SrvHandleCMKey(PSPContext pContext,
                              PUCHAR  pCommInput,
                              DWORD cbMsg,
                              PSPBuffer  pCommOutput);

BOOL FVerifyFinishedMessage(PSPContext  pContext, PUCHAR pb, BOOL fClient);

SP_STATUS
ParseAlertMessage
(
PSPContext pContext,
PUCHAR pSrvHello,
DWORD cbMessage,
PSPBuffer  pCommOutput
);

SP_STATUS
Ssl3SelectCipher    (
    PSPContext pContext,
    DWORD   dwCipher
);

void BuildAlertMessage(PBYTE pb, UCHAR bAlertLevel, UCHAR bAlertDesc);
void Ssl3BuildFinishMessage(PSPContext pContext, BYTE *pbMd5Digest, BYTE *pbSHADigest, BOOL fClient);
void SetWrap(PSPContext pContext, PUCHAR pb, UCHAR bCType, DWORD wT, BOOL fClient);
void SetHandshake(PUCHAR pb, BYTE bHandshake, PUCHAR pbData, WORD wSize);
void   UpdateHandshakeHash(PSPContext pContext, PUCHAR pb, DWORD dwcb, BOOL fInit);

void BuildS3FinalFinish(PSPContext pContext, PUCHAR pb, BOOL fClient);
SP_STATUS
VerifyCCSAndFinishMsg(PSPContext pContext, PBYTE pbMsg, DWORD cbMessage, BOOL fClient);


void ComputeCertVerifyHashes(PSPContext pContext, PBYTE pbHash);

void BuildCertificateMessage(PBYTE pb, PBYTE rgbCert, DWORD dwCert);
SP_STATUS
BuildCCSAndFinishMessage
(
PSPContext pContext,
PUCHAR pb,
DWORD cbMessage,
BOOL fClient
);
SP_STATUS
ProcessCertificateMessage
(
PSPContext pContext,
BOOL fServer,
DWORD   dwCipher,
CERT *pcert,
DWORD dwCert,
Ssl2_Client_Master_Key *pKey
);
VOID
ReverseMemCopy(
    PUCHAR      Dest,
    PUCHAR      Source,
    ULONG       Size) ;

SP_STATUS WINAPI
Ssl3ServerProtocolHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput,
    PSPBuffer pAppOutput);
void Ssl3GetCipherSpec(
    short  wCipherSuite, // in
    PINT pwKeySize,    // out
    PINT pwMacSize) ; // out
VOID ComputeServerExchangeHashes(
	PSPContext pContext,
    PBYTE pbServerParams,      // in
    INT   iServerParamsLen,    // in
    PBYTE pbMd5HashVal,        // out
    PBYTE pbShaHashVal) ;       // out

SP_STATUS
UnwrapSsl3Message
(
PSPContext pContext,
PSPBuffer MsgInput
);

void SetWrapNoEncrypt(PUCHAR pb, UCHAR bCType, DWORD wT);

SP_STATUS Ssl3HandleCCS(PSPContext pContext,
				   PUCHAR pb,
				   DWORD cbMessage,
				   BOOL fClient);
SP_STATUS
VerifyFinishMsg(PSPContext pContext, PBYTE pbMsg, DWORD cbMessage, BOOL fClient);
SP_STATUS
WrapSsl3Message
(
PSPContext pContext,
PSPBuffer pMsgInput,
UCHAR bContentType
);

BOOL Ssl3ParseClientHello
(
PSPContext  pContext,
PBYTE pbMessage,
INT iMessageLen,
BOOL *pfRestart
);

#endif //__SSL3MSG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\ssl3cli.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       context.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-08-95   Ramas   Created
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <md5.h>
#include <sha.h>
#include <ssl2msg.h>
#include <ssl3msg.h>
#include <ssl3key.h>
#include <ssl2prot.h>
#include <rsa.h>
#include <ssl3sign.h>




DWORD
IMacParseSrvHello(
    PUCHAR  pSrvHello,
    DWORD   cbMsg,
    PUCHAR  prgchHandshake,
    SHSH *  prgpshsh[]
);

BOOL FImportServerPublicKeyBlob(
    PBYTE    pbMod,                 // in
    INT      iModLen,               // in
    PBYTE    pbExp,                 // in
    INT      iKeyExpLen,            // in
    PctPublicKey   **ppKey) ;  // out

#define iHandshakeMax 10



BOOL
FCompleteMessageSrvHello(
    PSPContext  pContext,
    PBYTE       pSrvHello,
    DWORD       cbMessage,
    DWORD *     pichHandshakeMac,
    PUCHAR      prgchHandshake,
    SHSH *      prgpshsh[],
    BOOL *      pfRestartServer
);

SP_STATUS
ParseHelloRequest(
    PSPContext  pContext,
    PUCHAR      pSrvHello,
    DWORD       cbMessage,
    PSPBuffer   pCommOutput
);

SP_STATUS
BuildCertVerify(
    PctPrivateKey * pClientAuthKey,
    PctCertificate *pClientCert,
    PSPContext      pContext,
    PBYTE           pb,
    DWORD *         pdwcbCertVerify
);

SP_STATUS
PatchNetscapeBugAndStore
(
    PSPContext  pContext,
    PBYTE       pb
);

DWORD
CbLenOfEncode(DWORD dw, PBYTE pbDst);



static
BOOL
FSsl3ParseServerKeyExchange(
    PSPContext      pContext,
    PBYTE           pbMessage,
    DWORD           iMessageLen,
    LPBSAFE_PUB_KEY lpServerPublicKey,      //in
    PctPublicKey   **ppKey);

#define PbSessionid(pssh)  (((BYTE *)&pssh->cbSessionId) + 1)


SP_STATUS
ParseCertificateRequest
(
    PSPContext          pContext,
    PBYTE               pb,
    DWORD               dwcb,
    PctCertificate **   ppClientCert,
    DWORD *             pdwcbCert,
    PctPrivateKey **    ppClientAuthKey
);




//--------------------------------------------------------------------------------------------
SP_STATUS WINAPI
Ssl3ClientProtocolHandler(
    PSPContext  pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput,
    PSPBuffer pAppOutput)
{
    SP_STATUS pctRet = 0;
    DWORD cMessageType;
    SWRAP *pswrap;
    DWORD dwStateTransition;
    SPBuffer MsgInput;
    DWORD cbMsg;
//    PUCHAR pb;
//    UCHAR bCT;
    DWORD cbDataT;

    if (NULL != pCommOutput)
    {
        pCommOutput->cbData = 0;
    }
    if (NULL != pAppOutput)
    {
        pAppOutput->cbData = 0;
    }


    MsgInput.pvBuffer = pCommInput->pvBuffer;
    MsgInput.cbBuffer = pCommInput->cbBuffer;
    cbDataT = MsgInput.cbData = pCommInput->cbData;

    // Did we just process a Hello Request?
    if(pCommInput->cbData < 3)
    {
        if((pContext->State & 0xffff) == SSL3_STATE_HELLO_REQUEST)
        {
            dwStateTransition = (pContext->State & 0xffff);
            cbMsg = 0;
            pswrap = NULL;
            cMessageType = 0;
        }
        else
        {
            pctRet = PCT_INT_INCOMPLETE_MSG;
        }
    }
    else
    {

        pswrap = (SWRAP *) MsgInput.pvBuffer;
	    cbMsg = COMBINEBYTES(pswrap->bcbMSBSize, pswrap->bcbLSBSize);
	    if (cbMsg > MsgInput.cbData)
	    {
	        return PCT_INT_INCOMPLETE_MSG;
	    }

        pCommInput->cbData = cbMsg + sizeof(SWRAP); //Do One record at one time...

        if(0 != pContext->wS3CipherSuiteServer)
        {
            pctRet = UnwrapSsl3Message(pContext, &MsgInput);

        }
        else
        {
        	pContext->ReadCounter++;
        }

        switch(((PUCHAR) MsgInput.pvBuffer)[0])
        {
            case SSL3_CT_ALERT:
                cMessageType = SSL3_CT_ALERT;
                break;
            case SSL3_CT_CHANGE_CIPHER_SPEC:
                cMessageType = SSL3_CT_CHANGE_CIPHER_SPEC;
                break;
            case SSL3_CT_HANDSHAKE:
                if(pContext->State == SP_STATE_CONNECTED)
                {//We may be  getting a REDO message
                    DebugLog((DEB_WARN, "May be a ReDO"));
                    pContext->State = SSL3_STATE_CLIENT_HELLO;
                }
                cMessageType = ((PUCHAR) MsgInput.pvBuffer)[5];
                break;
            default:
                pctRet = PCT_INT_ILLEGAL_MSG;
                break;
        }



	    if(cMessageType == SSL3_CT_ALERT)
	        dwStateTransition = cMessageType ;
	    else
	        dwStateTransition = (cMessageType << 16) |
	                        (pContext->State & 0xffff);
    }

    if (pctRet != PCT_ERR_OK)
    {
        // to handle incomplete message errors
        return(pctRet);
    }

    switch(dwStateTransition)
    {
        // Client receives Server hello:

        case  (SSL3_CT_ALERT):
            pctRet = ParseAlertMessage(pContext,
                                        MsgInput.pvBuffer,
                                        MsgInput.cbData,
                                        pCommOutput);

            break;

        case  SSL3_STATE_HELLO_REQUEST:
        	//Temp Disabling Reconnect during REDO
        	if(SPCacheRetrieveNew(NULL, &pContext->RipeZombie))
            	{
            	pContext->RipeZombie->fProtocol = pContext->pCred->Type;
	            pctRet =  GenerateSsl3ClientHello(pContext, pCommOutput);
	            pContext->State = SSL3_STATE_CLIENT_HELLO;
            	}
            break;

        case  (SSL3_HS_SERVER_HELLO << 16) | SSL3_STATE_CLIENT_HELLO:
        case  (SSL3_HS_SERVER_HELLO << 16) | UNI_STATE_CLIENT_HELLO:
        {

            pctRet = Ssl3CliHandleServerHello(
                                                pContext,
                                                MsgInput.pvBuffer,
                                                MsgInput.cbData,
                                                pCommOutput);
            if (SP_FATAL(pctRet))
            {
                pContext->State = PCT1_STATE_ERROR;
            }
            else if(pContext->State != SSL3_STATE_RESTART_CCS)
            {
                //for Server hello, we take in one big chunk... if not RESTART...
                pCommInput->cbData = cbDataT;
            }
        }
        break;

        case (SSL3_CT_CHANGE_CIPHER_SPEC << 16) | SSL3_STATE_RESTART_CCS:
            pctRet = Ssl3HandleCCS(
                                    pContext,
		                            MsgInput.pvBuffer,
		                            MsgInput.cbData,
		                            FALSE);

            if (PCT_ERR_OK == pctRet)
            {
                pContext->State = SSL3_STATE_RESTART_SERVER_FINISH;
            }
            break;

        case (SSL3_CT_CHANGE_CIPHER_SPEC << 16) | SSL3_STATE_CHANGE_CIPHER_SPEC:
            pctRet = Ssl3HandleCCS(
                                    pContext,
                                    MsgInput.pvBuffer,
                                    MsgInput.cbData,
                                    FALSE);
            // State is set within the function call.

            break;
        case (SSL3_HS_FINISHED << 16) | SSL3_STATE_RESTART_SERVER_FINISH:
            pctRet = Ssl3HandleServerFinish(
                                            pContext,
                                            MsgInput.pvBuffer,
                                            MsgInput.cbData,
                                            pCommOutput);

            if(pctRet == PCT_ERR_OK)
            {
                DWORD cbOutMessage;
                cbOutMessage =  CB_SLL3_CHANGE_CIPHER_SPEC +   //ChangeCipherSpec.
                                CB_SSL3_FINISHED_MSG +
                                pContext->pCheck->cbCheckSum ; //Finished Message;

                pCommOutput->cbData = cbOutMessage;
                /* are we allocating our own memory? */
                if(pCommOutput->pvBuffer == NULL)
                {
                    pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
                    if (NULL == pCommOutput->pvBuffer)
                    {
                        SP_RETURN(SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY));
                    }
                    pCommOutput->cbBuffer = pCommOutput->cbData;
                }


                if(pCommOutput->cbData > pCommOutput->cbBuffer)
                {
                    SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
                }
                pctRet = BuildCCSAndFinishMessage(pContext,
                                                    pCommOutput->pvBuffer,
                                                    cbOutMessage,
                                                    TRUE);
                pContext->State = SP_STATE_CONNECTED;
                pContext->DecryptHandler = Ssl3DecryptHandler;
                pContext->Encrypt = Ssl3EncryptMessage;
                pContext->Decrypt = Ssl3DecryptMessage;
            }
            break;

        case (SSL3_HS_FINISHED << 16) | SSL3_STATE_SERVER_FINISH:
            pctRet = Ssl3HandleServerFinish(
                                            pContext,
                                            MsgInput.pvBuffer,
                                            MsgInput.cbData,
                                            pCommOutput);
            if (PCT_ERR_OK == pctRet)
            {
                // pContext->State = SSL3_STATE_CLIENT_HELLO;
                pContext->State = SP_STATE_CONNECTED;
                pContext->DecryptHandler = Ssl3DecryptHandler;
                pContext->Encrypt = Ssl3EncryptMessage;
                pContext->Decrypt = Ssl3DecryptMessage;
            }
            else if (PCT_ERR_RENEGOTIATE == pctRet)
            {
        	    if(SPCacheClone(&pContext->RipeZombie))
            	{
                    pctRet =  GenerateSsl3ClientHello(pContext, pCommOutput);
                    pContext->State = SSL3_STATE_CLIENT_HELLO;
         	
            	}
            }
            break;

        default:
            DebugLog((DEB_WARN, "Error in protocol, dwStateTransition is %lx\n", dwStateTransition));
            pContext->State = PCT1_STATE_ERROR;
            if (cMessageType == SSL2_MT_ERROR)
            {
                // BUGBUG: handle an SSL2 error message
            }
            break;
    }


    if (pctRet & PCT_INT_DROP_CONNECTION)
    {
        pContext->State &= ~ SP_STATE_CONNECTED;
    }
    // To handle incomplete message errors:
    return(pctRet);
}

SP_STATUS
Ssl3HandleServerFinish(
    PSPContext  pContext,
    PUCHAR      pb,
    DWORD       cbMessage,
    PSPBuffer   pCommOutput
    )
{
    SP_STATUS          pctRet;
    pctRet = VerifyFinishMsg(pContext, pb, cbMessage, FALSE);

#ifdef SCHANNEL_EXPORT
    if (pctRet == PCT_ERR_OK && pContext->fSGC && !pContext->RipeZombie->fSGC)
    {   // set the SGC flag and Renegotiate
        pContext->RipeZombie->fSGC = pContext->fSGC;
        return(PCT_ERR_RENEGOTIATE);
    }
#endif
        
    /* Cache Session Here */
    if(pctRet == PCT_ERR_OK)
    {
        /* set up the session in cache */
        SPCacheAdd(pContext->RipeZombie);
    }
    return(pctRet);
}



SP_STATUS Ssl3CliHandleServerHello(
    PSPContext  pContext,
    PUCHAR pSrvHello,
    DWORD cbMessage,
    PSPBuffer  pCommOutput
    )
{
    /* error to return to peer */
    SP_STATUS                   pctRet=PCT_ERR_ILLEGAL_MESSAGE;
    Ssl2_Client_Master_Key      Key;
    UCHAR                       rgbToEncrypt[CB_SSL3_PRE_MASTER_SECRET];
    DWORD                       dwKeyLen, dwSrvHello;
    SWRAP *                     pswrap = (SWRAP *)pSrvHello;
    SSH *                       pssh = (SSH *) (pSrvHello + sizeof(SWRAP));




    pCommOutput->cbData = 0;
    dwSrvHello = COMBINEBYTES(pswrap->bcbMSBSize, pswrap->bcbLSBSize);


    // Pad the random structure with zero's if the challenge is
    // smaller than the normal SSL3 size (SSL2 v3 hello, Unihello, PCT1 wierdness if
    // we add it)
    FillMemory(pContext->rgbS3CRandom, CB_SSL3_RANDOM - pContext->cbChallenge, 0);

    CopyMemory(  pContext->rgbS3CRandom + CB_SSL3_RANDOM - pContext->cbChallenge,
                 pContext->pChallenge,
                 pContext->cbChallenge);



    do
    {
        DWORD   PrevHs = 0;
        BOOL    fLoopDone = FALSE;

        SHSH *pshsh;
        CERT *pcert;
        DWORD dwcb;
        DWORD cbCert;
        SHORT wCipher, wCompression;
        DWORD  ichHandshakeMac = 0;
        UCHAR   rgchHandshakeTypes[iHandshakeMax] ;
        SHSH    *prgpshsh [iHandshakeMax];
        WORD    iHandshake = 0;
        WORD    iHS = 0;
        PctPublicKey    *pCreatedKey = NULL;
        BOOL        fServerKeyExchange = FALSE;
        BOOL    fRestartServer = FALSE;
        BOOL 	fClientAuth = FALSE;
        DWORD dwCertClient;
        PctPrivateKey *pClientAuthKey = NULL;
        PctCertificate *pClientCert= NULL;
        PSessCacheItem      pZombie;
        const KeyExchangeSystem *KeyExchSys;
        const CheckSumFunction *Check;
        //UNDONE: Handling seperate Wrappers for Handshake messages....
        //UNDONE: Split into four Cases with ServerHello/Cert/ServerKeyExchange/Server_done

        //Initialize with the individual Message pointers and their types...

        if(!FCompleteMessageSrvHello(pContext,
                                     pSrvHello,
                                     cbMessage,
					                 &ichHandshakeMac,
                                     (PUCHAR)&rgchHandshakeTypes,
                                     prgpshsh,
					                &fRestartServer))
        {
	        return(PCT_INT_INCOMPLETE_MSG);
        }


        pZombie = pContext->RipeZombie;


        if(0 == ichHandshakeMac)
        {
            pctRet=SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
		    break;
        }

        //We need to check whether we have the appropriate CRED before we process
        // other messages....Client Auth..

        pctRet = PCT_ERR_OK;
        for( iHS = 0; iHS < ichHandshakeMac; iHS++)
        {
            if(rgchHandshakeTypes[iHS] == SSL3_HS_CERTIFICATE_REQUEST)
	        {
	            pshsh = prgpshsh[iHS];
	            dwcb = COMBINEBYTES(pshsh->bcbMSB, pshsh->bcbLSB);

	            pctRet = ParseCertificateRequest(pContext,
                                                (PBYTE)pshsh,
                                                dwcb,
                                                &pClientCert,
                                                &dwCertClient,
                                                &pClientAuthKey
                                                );
	            if(PCT_ERR_OK != pctRet)
                {
		            break;
                }
	            fClientAuth = TRUE;
	        }
        }
        if(pctRet != PCT_ERR_OK)
        {
            break;
        }

        iHandshake = 0;
        PrevHs = 0;
        fLoopDone = FALSE;
        pctRet = PCT_ERR_OK;
        do
        {
            if(iHandshake > ichHandshakeMac)
            {
                pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
                break;
            }
            pshsh = prgpshsh[iHandshake];
            dwcb = COMBINEBYTES(pshsh->bcbMSB, pshsh->bcbLSB);

            switch(( PrevHs << 8 ) | rgchHandshakeTypes[iHandshake])
            {
                case SSL3_HS_SERVER_HELLO:
                {
                    // Process Server Hello Message
                    pssh = (SSH *)prgpshsh[iHandshake];
                    if(pssh->cbSessionId < 0 && pssh->cbSessionId > CB_SSL3_SESSION_ID)
                    {
                        pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
		                break;
                    }
                    if(COMBINEBYTES(pssh->bMajor, pssh->bMinor)  < 0x300)
                    {
                        pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
		                break;
                    }
                    CopyMemory(pContext->rgbS3SRandom, pssh->rgbRandom, CB_SSL3_RANDOM);
                    wCipher = (SHORT)COMBINEBYTES(pssh->rgbSessionId[pssh->cbSessionId],
                                           pssh->rgbSessionId[pssh->cbSessionId+1]);
                    wCompression = pssh->rgbSessionId[pssh->cbSessionId+2];



                    if( wCompression != 0)
                    {
                        pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
                        break; //Non - NULL compression method..
                    }
                    if(pssh->cbSessionId && !fRestartServer)
                    {
                        CopyMemory(pZombie->SessionID, PbSessionid(pssh), pssh->cbSessionId);
                        pZombie->cbSessionID = pssh->cbSessionId;
                    }

                    Ssl3SelectCipher(pContext, wCipher);
                    pContext->wS3pendingCipherSuite = wCipher ;
                    if(fRestartServer)
                    {
                        fLoopDone = TRUE;
                    }
                    else
                    {
                        pContext->RipeZombie->fProtocol = SP_PROT_SSL3_CLIENT;
                    }
                    break;

                }
                case SSL3_HS_CERTIFICATE | (SSL3_HS_SERVER_HELLO<<8):
                {
                    DWORD dwSGC = 0;
                    // Process Certificate Message
                    pcert = (CERT *)prgpshsh[iHandshake];
                    if(pcert->bcbCert24 != 0x00)
                    {
                        pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
                        break; //This is NOT YET implemented..
                    }

                    cbCert = COMBINEBYTES(pcert->bcbMSBClist, pcert->bcbLSBClist);

                    pctRet = SPLoadCertificate(SP_PROT_SSL3_CLIENT,
                                     SP_CERT_X509,
                                     (PUCHAR)&pcert->bcbCert24,
                                     cbCert,
                                     &pContext->RipeZombie->pServerCert,
                                     &dwSGC);
                    if (dwSGC)
                    {   // the server supports SGC.
                        //This will trigger a renegotiate on non-US systems
                        pContext->fSGC = TRUE;
                    }

                    break;
                }
                case SSL3_HS_SERVER_KEY_EXCHANGE | (SSL3_HS_CERTIFICATE<<8):
                {
                    LPBSAFE_PUB_KEY pk = (LPBSAFE_PUB_KEY)(pZombie->pServerCert->pPublicKey->pKey);

                    if(!FSsl3ParseServerKeyExchange(pContext, (
                                                    PBYTE)pshsh + sizeof(SHSH),
                                                    dwcb,
								                    pk,
                                                    &pCreatedKey))
                    {
                        pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
                        break;
                    }
                    fServerKeyExchange = TRUE;
                    break;
                }
                case SSL3_HS_CERTIFICATE_REQUEST | (SSL3_HS_SERVER_KEY_EXCHANGE<<8):
                case SSL3_HS_CERTIFICATE_REQUEST | (SSL3_HS_CERTIFICATE<<8):
                {

                    // We already dealt with this message above when we were checking
                    // for client auth.

                    break;
                }

                case SSL3_HS_SERVER_HELLO_DONE | (SSL3_HS_SERVER_KEY_EXCHANGE<<8):
                case SSL3_HS_SERVER_HELLO_DONE | (SSL3_HS_CERTIFICATE<<8):
                case SSL3_HS_SERVER_HELLO_DONE | (SSL3_HS_CERTIFICATE_REQUEST<<8):
                {
                    fLoopDone = TRUE;
                    break;
                }

                default:
                {
                    pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
                    // We received an error
                    break;
                }
            }
            if(PCT_ERR_OK != pctRet)
            {
                break;
            }
            PrevHs = rgchHandshakeTypes[iHandshake];
            UpdateHandshakeHash(pContext, (LPBYTE)pshsh, dwcb + sizeof(SHSH), FALSE);
            // Each message, we increment our read counter
            // pContext->ReadCounter++;
            iHandshake++;
        } while(!fLoopDone);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }
        if(fRestartServer)
        {
            Ssl3MakeMasterKeyBlock(pContext);
            pContext->State = SSL3_STATE_RESTART_CCS;

            return PCT_ERR_OK;
        }



        //-----------------------PREPARE to return with information
        //Generate Pre_master_secret..
        //Encrypt Pre_master_secret with Server's Public Key
        //Add ChangeCipher message and finish message

        rgbToEncrypt[0] = (UCHAR)SSL3_CLIENT_VERSION_MSB;       //MajorVesion
        rgbToEncrypt[1] = (UCHAR)SSL3_CLIENT_VERSION_LSB;       //Minor version
        //2 : 2 bytes of version #
        GenerateRandomBits((PUCHAR)&(rgbToEncrypt[2]), CB_SSL3_PRE_MASTER_SECRET - 2);
        //Build Master Secret
        Ssl3BuildMasterKeys(pContext, (PUCHAR) rgbToEncrypt);
        Ssl3MakeMasterKeyBlock(pContext);

        dwKeyLen = ((pContext->PendingCiphSpec & SP_CIPHER_STRENGTH) >> SP_CSTR_POS) / 8;
        if (dwKeyLen < SSL3_MASTER_KEY_SIZE)
        {
            pZombie->cbClearKey = SSL3_MASTER_KEY_SIZE - dwKeyLen;
            /* The clear key is just the first portion of the Master Key */
            CopyMemory(pZombie->pClearKey, pZombie->pMasterKey, pZombie->cbClearKey);
        }
        else
        {
            pZombie->cbClearKey = 0;
        }
        if (pZombie->cbClearKey)
        {
            CopyMemory(Key.ClearKey, pZombie->pMasterKey, pZombie->cbClearKey);
        }
        Key.ClearKeyLen = pZombie->cbClearKey;
        Key.EncryptedKeyLen = SSL3_ENCRYPTED_KEY_SIZE;
        //NOTE: we always encrypt the pCreatedKey, so if no serverexchange, put the real one
        if(!fServerKeyExchange)
        {
            pCreatedKey = pZombie->pServerCert->pPublicKey;
        }

        KeyExchSys = KeyExchangeFromSpec(pContext->PendingExchSpec, SP_PROT_SSL3_CLIENT);
        if(KeyExchSys == NULL)
        {
            pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
            break;
        }
        if(!KeyExchSys->Encrypt(
            (PUCHAR)rgbToEncrypt,
            CB_SSL3_PRE_MASTER_SECRET,
            Key.EncryptedKey,
            &Key.EncryptedKeyLen,
            pCreatedKey, 0))
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_BAD_CERTIFICATE);
            if(fServerKeyExchange)
            {
                SPExternalFree(pCreatedKey);
                pCreatedKey = NULL; //Do we really need to do this ???
            }
            break;
        }

		if(fServerKeyExchange)
        {
            SPExternalFree(pCreatedKey);
            pCreatedKey = NULL; //Do we really need to do this ???
        }

        Key.KeyArgLen = 0;

        //Now create message to send...
        {
            DWORD                   cbMessage;
            PUCHAR                  pb;
            PUCHAR pbHash;
            DWORD 	dwClientAuth = 0;
            DWORD   dwHash = 0;

            if(fClientAuth)
            {

                if(pClientCert == NULL)
                {
                    dwClientAuth = SSL3_ALERT_NO_CERTIFICATE;
                }
                else
                {
                    pctRet  = SPSerializeCertificate(SP_PROT_SSL3_CLIENT,
                                                     NULL,
                                                     &dwCertClient,
                                                     pClientCert);
                    if(pctRet != PCT_ERR_OK)
                    {
                        return pctRet;
                    }
                    if(dwCertClient > 0x3fff) //Seperate Wrappers after this
                    {   		               // is a BIG UNDONE...
                        pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
                        break;
                    }
                    dwClientAuth = sizeof(SHSH) +              // Certificate Message
                                   CB_SSL3_CERT_VECTOR +
                                   dwCertClient +
                                   CB_SSL3_MAX_CERT_VERIFY;
                }

            }
            Check = HashFromSpec(pContext->PendingHashSpec, SP_PROT_SSL3_CLIENT);
            if (Check == NULL)
            {
                break;
            }
            cbMessage = sizeof(SWRAP) +
                        dwClientAuth +
                        sizeof(SHSH) +                  // Client Key Exchange
                        Key.EncryptedKeyLen +
                        CB_SLL3_CHANGE_CIPHER_SPEC +    //ChangeCipherSpec.
                        CB_SSL3_FINISHED_MSG +          //Finished Message;
                        Check->cbCheckSum ;

            cbMessage += FSsl3Cipher(TRUE) ? ( 2 * pContext->pCheck->cbCheckSum) : 0;
            pCommOutput->cbData = cbMessage;

            /* are we allocating our own memory? */
            if(pCommOutput->pvBuffer == NULL)
            {
                pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
                if (NULL == pCommOutput->pvBuffer)
                {
                    SP_RETURN(SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY));
                }
                pCommOutput->cbBuffer = pCommOutput->cbData;
            }


            if(pCommOutput->cbData > pCommOutput->cbBuffer)
            {
                SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
            }

            pbHash = pb = (PUCHAR)pCommOutput->pvBuffer + sizeof(SWRAP);

            if(fClientAuth)
            {
                if(pClientCert != NULL)
                {
                    CERT *pcert = (CERT *) pb ;
                    PUCHAR pbCert = &pcert->bcbCert24;
                    //Handle CertChain....

                    pctRet = SPSerializeCertificate(SP_PROT_SSL3_CLIENT,
                                                    &pbCert,
                                                    &dwCertClient,
                                                    pClientCert);
                    if(pctRet != PCT_ERR_OK)
                    {
                        break;
                    }
                    pcert->bcbClist24 = MS24BOF(dwCertClient);
                    pcert->bcbMSBClist = MSBOF(dwCertClient);
                    pcert->bcbLSBClist = LSBOF(dwCertClient);

                    SetHandshake(pb,  SSL3_HS_CERTIFICATE, NULL,  (WORD)(dwCertClient + CB_SSL3_CERT_VECTOR));

                    pb += sizeof(SHSH) + CB_SSL3_CERT_VECTOR + dwCertClient;
                    dwHash += sizeof(SHSH) + CB_SSL3_CERT_VECTOR + dwCertClient;
                }
                else
                {
                    BuildAlertMessage(pb, SSL3_ALERT_WARNING, SSL3_ALERT_NO_CERTIFICATE);
                    pb += SSL3_ALERT_NO_CERTIFICATE;
                    dwHash += SSL3_ALERT_NO_CERTIFICATE;
               }
            }

            // Add the KeyExchange message;

            SetHandshake(pb,
                         SSL3_HS_CLIENT_KEY_EXCHANGE,
                         (PUCHAR)Key.EncryptedKey,
                         (WORD) Key.EncryptedKeyLen);

            pb += sizeof(SHSH) + Key.EncryptedKeyLen;
            dwHash += sizeof(SHSH) + Key.EncryptedKeyLen;

            // Update the handhsake hash for the CertVerify message
            UpdateHandshakeHash(pContext,
                            (PUCHAR)pbHash,
                            (UINT)dwHash, FALSE);
            if(fClientAuth && (pClientCert != NULL))
            {
                DWORD dwCertVerifyMsgLen = 0;

                pctRet = BuildCertVerify(   pClientAuthKey,
                                            pClientCert,
                                            pContext, pb,
                                            &dwCertVerifyMsgLen);
                if(pctRet != PCT_ERR_OK)
                {
                    break;
                }
                UpdateHandshakeHash(pContext,  (PUCHAR)pb, (UINT)dwCertVerifyMsgLen, FALSE);
                pCommOutput->cbData -= CB_SSL3_MAX_CERT_VERIFY - dwCertVerifyMsgLen; //Extra allocation
                pb += dwCertVerifyMsgLen;
                dwHash += dwCertVerifyMsgLen;

          }


            // Encrypt the whole message if necessary.
            SetWrap(pContext, (PUCHAR)pCommOutput->pvBuffer, SSL3_CT_HANDSHAKE, dwHash, TRUE);
            if(FSsl3Cipher(TRUE))
            {
                pb += pContext->pCheck->cbCheckSum;
            }
            pctRet = BuildCCSAndFinishMessage(pContext,
                                    pb,
                                    CB_SLL3_CHANGE_CIPHER_SPEC +
                                    CB_SSL3_FINISHED_MSG +
                                    Check->cbCheckSum,
                                    TRUE);

            if(pctRet != PCT_ERR_OK)
            {
                break;
            }
            pContext->State = SSL3_STATE_CHANGE_CIPHER_SPEC;


		}
    	return(PCT_ERR_OK);
    } while(TRUE);

    if(pctRet == PCT_ERR_INCOMPLETE_CREDS)
    {
        return(pctRet); //DON'T Drop connection, it's a WARNING...
    }
    return pctRet | PCT_INT_DROP_CONNECTION;
}



DWORD IMacParseSrvHello
(
PUCHAR pbSrvHello,
DWORD cbMsg,
PUCHAR prgchHandshake,
SHSH *prgpshsh[]
)
	{
	DWORD dwcb;
	SHSH *pshsh = (SHSH *)pbSrvHello;
	DWORD iHandshake = 0;
	PUCHAR pbMax = pbSrvHello + cbMsg;

	do
		{
		if((PUCHAR)pshsh > pbMax)
			break;
		prgchHandshake[iHandshake] = pshsh->typHS;
		prgpshsh[iHandshake++] = pshsh;
	    dwcb = COMBINEBYTES(pshsh->bcbMSB, pshsh->bcbLSB);
	    cbMsg -= dwcb + sizeof(SHSH);
	    pshsh = (SHSH *) ((PUCHAR) pshsh + dwcb + sizeof(SHSH));
	    } while(cbMsg > 0);
	return(iHandshake);
	}





/*****************************************************************************/
static BOOL FSsl3ParseServerKeyExchange
(
PSPContext  pContext,
PBYTE pbMessage,                                //in
DWORD iMessageLen,                              //in
LPBSAFE_PUB_KEY lpServerPublicKey,      //in
PctPublicKey   **ppctKey                //out
)
{
    PBYTE pbMessageStart = pbMessage;
    PBYTE pbModulus = NULL;
    INT   iModulusLen;
    PBYTE pbExponent = NULL;
    INT   iExponentLen;
    BYTE  pbInputBlock[SSL3_ENCRYPTED_KEY_SIZE];
    BYTE  pbOutputBlock[SSL3_ENCRYPTED_KEY_SIZE];
    INT   iBlockLen;
    PBYTE pbServerParams = NULL;
    INT   iServerParamsLen;
    BYTE  pbMd5HashValue[16];
    BYTE  pbShaHashValue[20];
    INT   iPadLen;
    INT   i;
    //
    // struct {
    //   select (KeyExchangeAlgorithm) {
    //       case diffie_hellman:
    //             ServerDHParams params;
    //             Signature signed_params;
    //       case rsa:
    //             ServerRSAParams params;
    //             Signature signed_params;
    //       case fortezza_dms:
    //             ServerFortezzaParams params;
    //   };
    // } ServerKeyExchange;
    //


    //
    // struct {
    //   opaque rsa_modulus<1..2^16-1>;
    //   opaque rsa_exponent<1..2^16-1>;
    // } ServerRSAParams;
    //

    // Mark start of ServerRSAParams structure.
    // This is used to build hash values.
    pbServerParams = pbMessage;

    // Modulus length
    iModulusLen = ((INT)pbMessage[0] << 8) + pbMessage[1];
    if(iModulusLen < 512/8 || iModulusLen > 2048/8)
		return FALSE;
    pbMessage += 2;

    // Since the modulus is encoded as an INTEGER, it is padded with a leading
    // zero if its most significant bit is one. Remove this padding, if
    // present.
    if(pbMessage[0] == 0)
	{
		iModulusLen -= 1;
		pbMessage   += 1;
	}

    // Modulus
    pbModulus = pbMessage;
    pbMessage += iModulusLen;


    // Exponent length
    iExponentLen = ((INT)pbMessage[0] << 8) + pbMessage[1];
    if(iExponentLen < 1 || iExponentLen > 4)
		return FALSE;
    pbMessage += 2;

    // Exponent
    pbExponent = pbMessage;
    pbMessage += iExponentLen;


    // Compute length of ServerRSAParams structure.
    iServerParamsLen = pbMessage - pbServerParams;

    // build BSAFE_PUB_KEY structure from modulus and exponent
    if(!FImportServerPublicKeyBlob(
	    pbModulus,              // in
	    iModulusLen,            // in
	    pbExponent,             // in
	    iExponentLen,           // in
	    ppctKey))       // out
			return FALSE;

    //
    // digitally-signed struct {
    //   select(SignatureAlgorithm) {
    //        case anonymous: struct { };
    //        case rsa:
    //             opaque md5_hash[16];
    //             opaque sha_hash[20];
    //        case dsa:
    //             opaque sha_hash[20];
    //   };
    // } Signature;
    //

    // Signature block length
    iBlockLen = ((INT)pbMessage[0] << 8) + pbMessage[1];
    pbMessage += 2;

    // Signature block. Convert to little endian with at least 8 bytes of
    // zero padding at the end.
    FillMemory(pbInputBlock, SSL3_ENCRYPTED_KEY_SIZE, 0);
    ReverseMemCopy(pbInputBlock, pbMessage, iBlockLen);
    pbMessage += iBlockLen;
    // Zero destination buffer
    FillMemory(pbOutputBlock, SSL3_ENCRYPTED_KEY_SIZE, 0);

    // Decrypt signature block, using public key contained in certificate
    if(BSafeEncPublic(lpServerPublicKey, pbInputBlock, pbOutputBlock) == FALSE)
		return FALSE;

    // Convert decrypted signature block to little endian.
	ReverseMemCopy(pbInputBlock, pbOutputBlock, iBlockLen);

    // Verify signature block format
    iPadLen = iBlockLen - MD5DIGESTLEN - A_SHA_DIGEST_LEN - 3;
    if(pbInputBlock[0] != 0 || pbInputBlock[1] != 1 ||
       pbInputBlock[2 + iPadLen] != 0)
		return FALSE;
    for(i=0 ; i<iPadLen ; i++)
	{
		if(pbInputBlock[i + 2] != 0xff)
		    return FALSE;
	    }

    // Generate hash values
    ComputeServerExchangeHashes(pContext, pbServerParams,
				iServerParamsLen,
				pbMd5HashValue,
				pbShaHashValue);

    // Verify hash values
    if(memcmp(pbMd5HashValue, pbInputBlock + iPadLen + 3, MD5DIGESTLEN) ||
       memcmp(pbShaHashValue, pbInputBlock + iPadLen + 3 + MD5DIGESTLEN, A_SHA_DIGEST_LEN))
		return FALSE;

    // Validate message length
    if(iMessageLen != (DWORD) (pbMessage - pbMessageStart))
		return FALSE;

    return TRUE;
}



//
// Import public key from modulus and exponent
//
/******************************************************************************
* ImportServerPublicKeyBlob
*
* Build BSAFE public key structure from modulus and exponent. Caller is
* responsible for freeing this structure using LocalFree.
*/
BOOL FImportServerPublicKeyBlob(
    PBYTE    pbMod,                 // in
    INT      iModLen,               // in
    PBYTE    pbExp,                 // in
    INT      iKeyExpLen,            // in
    PctPublicKey   **ppKey)  //out
{
    DWORD Aligned, dwKeySize;
    INT iCnt;
    PctPublicKey    *pCreatedKey = NULL;
    BSAFE_PUB_KEY * pPublicKey;


    // Allocate DWORD aligned memory for public key
    // Correction: Allocate QUADWORD aligned memory for public key    
    Aligned = ((iModLen + sizeof(DWORD)*2 -1) & ~(sizeof(DWORD)*2-1));
    
    /* rsa code requires two extra null DWORDS padded on the end of the aligned key */
    Aligned += sizeof(DWORD)*2;
    dwKeySize = (DWORD)((PctPublicKey *)NULL)->pKey + sizeof(BSAFE_PUB_KEY) + Aligned;
    pCreatedKey = (PctPublicKey *)SPExternalAlloc(dwKeySize);
    pPublicKey = (BSAFE_PUB_KEY *)pCreatedKey->pKey;

    pPublicKey->magic   = RSA1;
    pPublicKey->keylen  = Aligned;
    pPublicKey->bitlen  = iModLen * 8;

    // max number of bytes to be encoded
    pPublicKey->datalen = (pPublicKey->bitlen / 8) - 1;

    // copy modulus; convert to big endian format
    ReverseMemCopy((BYTE *)(pPublicKey + 1), pbMod, iModLen);

    // form a (little endian) DWORD from *pbExp data
    pPublicKey->pubexp =  0;
    for(iCnt=0; iCnt<iKeyExpLen; iCnt++)
	{
		pPublicKey->pubexp <<= 8;
		pPublicKey->pubexp |=  pbExp[iCnt];
	    }
    pCreatedKey->cbKey = ( dwKeySize );
    *ppKey = pCreatedKey;
    return TRUE;
}







SP_STATUS
Ssl3PackClientHello(
    PSPContext              pContext,
    PSsl2_Client_Hello       pCanonical,
    PSPBuffer          pCommOutput)
{
//    DWORD               cbMessage;
    CLH                                 *pclh;
    DWORD               dwSize;
    PUCHAR              pbBuffer;
    DWORD               i, dwFixed;
    DWORD                               dwCipherSize = pCanonical->cCipherSpecs * sizeof(short);
//    short                               *pw;



    if(pCanonical == NULL || pCommOutput == NULL)
	return PCT_INT_INTERNAL_ERROR;

	//Calculate the size...
    dwSize = pCommOutput->cbData = ( dwFixed = sizeof(SWRAP) +
							 sizeof(SHSH) + CB_SSL3_RANDOM + 3) +
					 pCanonical->cbSessionID + sizeof(short) +
					pCanonical->cCipherSpecs * sizeof(short) +
					  2 ; //Size of Compression Alogorithm 1 + null (0)

    pCommOutput->cbData += FSsl3Cipher(TRUE) ? pContext->pCheck->cbCheckSum : 0;
    /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL)
    {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
        {
            SP_RETURN(SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY));
        }
        pCommOutput->cbBuffer = pCommOutput->cbData;
    }


    if(pCommOutput->cbData > pCommOutput->cbBuffer)
    {
        SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
    }

	//Initialize the member varaibles
    pclh = (CLH *)  ((BYTE *)pCommOutput->pvBuffer + sizeof(SWRAP));
	pclh->bMajor = SSL3_CLIENT_VERSION_MSB;
	pclh->bMinor = SSL3_CLIENT_VERSION_LSB;
	CopyMemory(pclh->rgbRandom, pCanonical->Challenge, CB_SSL3_RANDOM);
	pclh->cbSessionId = (UCHAR) pCanonical->cbSessionID;
	CopyMemory(pclh->rgbSessionId, pCanonical->SessionID, pCanonical->cbSessionID);

	pbBuffer = (BYTE *)     (BYTE *)pCommOutput->pvBuffer + dwFixed + pCanonical->cbSessionID;
	*pbBuffer++ =   MSBOF(dwCipherSize);
	*pbBuffer++ =   LSBOF(dwCipherSize);

	for(i = 0 ; i < pCanonical->cCipherSpecs ; i++)
		{
			*pbBuffer++ =   MSBOF(pCanonical->CipherSpecs[i]);
			*pbBuffer++ =   LSBOF(pCanonical->CipherSpecs[i]);
		}
	*pbBuffer++ = 0x1 ; //One compression Method;
	*pbBuffer = 0x00 ; //NULL Compression.
	SetHandshake((BYTE *)&pclh->typHS,  SSL3_HS_CLIENT_HELLO,  NULL,
				(WORD) (dwSize - sizeof(SWRAP) - sizeof(SHSH)));
	    // In case of SSL3, do the handshare hash.
	UpdateHandshakeHash(pContext, (PUCHAR)pCommOutput->pvBuffer + sizeof(SWRAP),
											dwSize - sizeof(SWRAP), TRUE);

	SetWrap(pContext, pCommOutput->pvBuffer,  SSL3_CT_HANDSHAKE, dwSize - sizeof(SWRAP), TRUE);

    return(PCT_ERR_OK);
}

SP_STATUS WINAPI
GenerateSsl3ClientHello(
    PSPContext              pContext,
    PSPBuffer               pOutput)
{
    Ssl2_Client_Hello    HelloMessage;
    SP_STATUS pctRet = PCT_INT_INTERNAL_ERROR;

    SP_BEGIN("GenerateSsl3ClientHello");


    GenerateRandomBits( pContext->pChallenge, CB_SSL3_RANDOM );
    pContext->cbChallenge = CB_SSL3_RANDOM;



    pctRet = GenerateUniHelloMessage(pContext, &HelloMessage, SP_PROT_SSL3_CLIENT);

    if(PCT_ERR_OK != pctRet)
    {
        SP_RETURN(pctRet);
    }


    if(PCT_ERR_OK != (pctRet = Ssl3PackClientHello(pContext, &HelloMessage,  pOutput)))
    {
        SP_RETURN(pctRet);
    }



    SP_RETURN(PCT_ERR_OK);
}


// Do we have all the information to process Server Hello message.
// WE could get 2 types of messages
//   1. Restart enabled.
//       2. No restart, serverhello done.
//
//   case 1: In the first case we get ServerHello with matching sessionid followed by
//                       Change_cipher_spec message and Finished message
//
//   case 2: SeverHello Message, Certificate*, CertificateRequest*, ServerKeyExchange
//                       followed by Server_hello_done.
//
//
//      So this routine checks whether  we expect Restart and if yes, looks for Finished message
//       if it doesn't expect Restart message, then it looks for server hello done.
//
//      RETURNS TRUE if Finished message or server hello done message is present in the packet
//                      FALSE otherwise.
//
//
//
//              In case of REDO, we need to DECRYPT and look inside....( probably we should use
//                              temp key state to peek for completeness.

BOOL FCompleteMessageSrvHello(
    PSPContext  pContext,
    PBYTE pSrvHello,
    DWORD cbMessage,
    DWORD *pichHandshakeMac,
    PUCHAR prgchHandshake,
    SHSH *prgpshsh[],
    BOOL *pfRestartServer
    )
{
    BOOL fExpectRestart = pContext->RipeZombie->ZombieJuju;
    SWRAP *pswrap = (SWRAP *)pSrvHello;
    DWORD cbMsg;
    DWORD cbRecord;
    DWORD iRecord = 0;


    if(cbMessage <= sizeof(SWRAP))
    {
        return(FALSE);
    }
    cbMsg = COMBINEBYTES(pswrap->bcbMSBSize, pswrap->bcbLSBSize);
    cbRecord = cbMsg + sizeof(SWRAP);

    //if total bytes in the packet is less than what the header says,return false
    if( cbMessage < cbRecord)
    {
        return(FALSE);
    }

    *pichHandshakeMac = 0;

    if(fExpectRestart)
    {       //Look for finished message in the packet...
        SSH *pssh;

        pssh = (SSH *) (pSrvHello + sizeof(SWRAP));
        if (!memcmp(pContext->RipeZombie->SessionID, PbSessionid(pssh),
					        pssh->cbSessionId))
        {
            DWORD dwExpect = CB_SLL3_CHANGE_CIPHER_SPEC + CB_SSL3_FINISHED_MSG +
                            MD5DIGESTLEN ; //we need to change this to SHA iff
            *pfRestartServer = TRUE;
            if( (cbMessage - cbRecord) < dwExpect)
            {
	            return(FALSE);
            }
            *pichHandshakeMac = IMacParseSrvHello((PBYTE)pswrap + sizeof(SWRAP),
                                                    cbMsg,
                                                    prgchHandshake + iRecord,
                                                    prgpshsh + iRecord);
	        return(TRUE);
	    }
	    else
	    {
	        // the server refused a restart
	        // release the SessCacheItme and get a new one
	        SPCacheClone(&pContext->RipeZombie);
	    }
    }
    //              UNDONE: this wont work for Combined hasndshake....
    do
    {               //Look for Server hello done message
        DWORD ich;

        //Initialize with the individual Message pointers and their types...
        cbMsg = COMBINEBYTES(pswrap->bcbMSBSize, pswrap->bcbLSBSize);
        cbRecord = cbMsg + sizeof(SWRAP);
        //if total bytes in the packet is less than what the header says,return false
        if( cbMessage < cbRecord)
        {
	        return(FALSE);
        }

        *pichHandshakeMac += IMacParseSrvHello((PBYTE)pswrap + sizeof(SWRAP),
                                                cbMsg,
                                                prgchHandshake + iRecord,
                                                prgpshsh + iRecord);
        for( ich = 0 ; ich < *pichHandshakeMac ; ich++)
        {
            if(*(prgchHandshake + ich) == SSL3_HS_SERVER_HELLO_DONE)
            {
	            return(TRUE);
            }
        }
        pswrap = (SWRAP *) ((PBYTE)pswrap + cbRecord);
        cbMessage -= cbRecord;
        iRecord ++;
    } while(cbMessage);
    return(FALSE);

}






SP_STATUS
ParseCertificateRequest
(
PSPContext  pContext,
PBYTE pb,
DWORD dwcb,
PctCertificate **ppClientCert,
DWORD *pdwcbCert,
PctPrivateKey **ppClientAuthKey
)
	{
    SP_STATUS          pctRet=PCT_ERR_ILLEGAL_MESSAGE;
    UCHAR cbCertType;
    INT wCertType;
    DWORD dwcbIssuerName;
    DWORD dwcbIssuerList;
    PSPCredential      pCred;

    //
    // enum {
    //	   rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
    //	   rsa_ephemeral_dh(5), dss_ephemeral_dh(6), fortezza_dms(20), (255)
    // } ClientCertificateType;
    //
    // opaque DistinguishedName<1..2^16-1>;
    //
    // struct {
    //	   ClientCertificateType certificate_types<1..2^8-1>;
    //	   DistinguishedName certificate_authorities<3..2^16-1>;
    // } CertificateRequest;
    //

	pb += sizeof(SHSH);

	do
	{
	    // certificate type list length
	    cbCertType = pb[0];

	    pb += 1;

	    // certificate type list (only one entry allowed by test program)
	    wCertType = pb[0];
	    if(wCertType != SSL3_CERTTYPE_RSA_SIGN)   //we suppport only rsa-sign for now
	    {
            pctRet=SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
		    break;
	    }
	    pb += cbCertType;

	    // issuer list length
	    dwcbIssuerList = COMBINEBYTES(pb[0], pb[1]);
	    if(dwcbIssuerList > dwcb)
	    {
            pctRet=SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
		    break;
	    }

		pctRet = PatchNetscapeBugAndStore(pContext, pb);
		if(pctRet != PCT_ERR_OK)
        {
            pctRet=SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
		    break;
        }
	    pb = pContext->pbIssuerList + 2;

        *ppClientAuthKey = NULL;
        *ppClientCert = NULL;
        pCred = pContext->pCred;
        dwcbIssuerName = dwcbIssuerList;
        pctRet = PCT_ERR_OK;
        {
            // If we're doing client auth, check to see if we have
            // proper credentials.
            DWORD i, dwcbIss = dwcbIssuerList;
            BOOL fGot = FALSE;
            // Choose a certificate/private key pair for client auth.
            for(; dwcbIss;)
            {
                for(i=0; i<pCred->cCerts; i++)
                {
          	    	PctCertificate *pCertT = pCred->paCerts[i];
					PctCertificate *pCertTT;
					
            	    dwcbIssuerName = COMBINEBYTES(pb[0], pb[1]) + 2 ;
            	    if(dwcbIssuerName > dwcb)
            	    {
		                break;
            	    }
            	    do
            	    {

	                    if(memcmp(pCertT->pbIssuer, pb+2, pCertT->cbIssuer))
	                    {
	                        /* Set up the certificate */
	                        if(ReferenceCert(pCred->paCerts[i]) <= 0)
	                        {
	                            continue;
	                        }
	                        *ppClientCert = pCred->paCerts[i];
	                        *ppClientAuthKey = pCred->paPrivateKeys[i];
	                        fGot = TRUE;
	                        break;
	                    }
	                    pCertTT = pCertT;
	                    pCertT = pCertT->pIssuerCertificate;
                    } while(pCertT != NULL && pCertT != pCertTT);
                }
                if(dwcbIss < dwcbIssuerName) //Prevent Wrap around and Hang...
                    break;
                if(fGot)
                	break;
                dwcbIss -= dwcbIssuerName;
                pb += dwcbIssuerName;
            }
            if ((*ppClientAuthKey == NULL) ||
                (*ppClientCert == NULL))
            {
                if(!(pContext->Flags & CONTEXT_FLAG_NO_INCOMPLETE_CRED_MSG))
                {
	                pctRet = SP_LOG_RESULT(PCT_ERR_INCOMPLETE_CREDS);
                    SP_RETURN( pctRet);
                }
            }
        }

	    break;
	} while(TRUE);

	return (pctRet);
#ifdef VERISIGN
	*ppClientAuthKey = g_pbClientKey;
	*ppClientCert = g_pbClientCert;
	return(PCT_ERR_OK);
#endif
	}

SP_STATUS
BuildCertVerify
(
PctPrivateKey *pClientAuthKey,
PctCertificate *pClientCert,
PSPContext  pContext,
PBYTE pb,
DWORD *pdwcbCertVerify
)
	{
	SP_STATUS pctRet;
    BYTE  rgbSigned[SSL3_ENCRYPTED_KEY_SIZE];
    DWORD dwcbSigned = SSL3_ENCRYPTED_KEY_SIZE;
    PBYTE pbT = pb + sizeof(SHSH);
    BYTE  rgbHashValue[MD5DIGESTLEN+A_SHA_DIGEST_LEN];
    const SignatureSystem *pSigSys = NULL;


    //
    // digitally-signed struct {
    //	   opaque md5_hash[16];
    //	   opaque sha_hash[20];
    // } Signature;
    //
    // struct {
    //	   Signature signature;
    // } CertificateVerify;
    //
    // CertificateVerify.signature.md5_hash = MD5(master_secret + pad2 +
    //		MD5(handshake_messages + master_secret + pad1));
    //
    // CertificateVerify.signature.sha_hash = SHA(master_secret + pad2 +
    //		SHA(handshake_messages + master_secret + pad1));
    //

    // Generate hash values

    ComputeCertVerifyHashes(pContext, rgbHashValue);


    pSigSys = SigFromSpec(SP_SIG_RSA_SHAMD5, SP_PROT_SSL3_CLIENT);
    if (pSigSys == NULL)
    {
        pctRet = SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
        return pctRet;
   }

    if(!pSigSys->Sign(rgbHashValue,
                      MD5DIGESTLEN+A_SHA_DIGEST_LEN,
                      rgbSigned,
                      &dwcbSigned,
                      pClientAuthKey))
    {
        pctRet = SP_LOG_RESULT(PCT_ERR_BAD_CERTIFICATE);
        return pctRet;
    }

    pbT[0] = MSBOF(dwcbSigned);
    pbT[1] = LSBOF(dwcbSigned);
    *pdwcbCertVerify =  dwcbSigned + 2 + sizeof(SHSH);
    pbT += 2;
	SetHandshake(pb,  SSL3_HS_CERTIFICATE_VERIFY, NULL,  (WORD)(dwcbSigned + 2));
    CopyMemory(pbT, rgbSigned, dwcbSigned);
    return PCT_ERR_OK;
}

SP_STATUS
ParseHelloRequest
(
PSPContext  pContext,
PUCHAR pSrvHello,
DWORD cbMessage,
PSPBuffer  pCommOutput
)
    {
    return (GenerateSsl3ClientHello(pContext, pCommOutput));

    }





SP_STATUS
PatchNetscapeBugAndStore
(
PSPContext  pContext,
PBYTE pb
)
	{
	PBYTE pbAlloc, pbAllocT;
	DWORD dwcbToAllocate ;
	DWORD dwcb ;
	PBYTE pbTemp = pb;

	dwcb = dwcbToAllocate = COMBINEBYTES(pbTemp[0], pbTemp[1]); //IssuerListLength

	pbTemp += 2;
	while(dwcb)
	{
		DWORD dwT;

		dwT =  COMBINEBYTES(pbTemp[0], pbTemp[1]); //IssuerListLength
		if(pbTemp[2] != SEQUENCE_TAG) //if there is NO Sequence TAG
	 		dwcbToAllocate +=  CbLenOfEncode(dwT, NULL);
 		dwcb -= (2 + dwT);
 		pbTemp += (2 + dwT);
	}

	dwcbToAllocate += 2; //for the list header...
	pbAlloc = SPExternalAlloc(dwcbToAllocate);
	if(!pbAlloc)
		return(SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY));

	pbAllocT = pbAlloc;
	pbTemp = pb;
	dwcb = COMBINEBYTES(pbTemp[0], pbTemp[1]);
	pbAlloc[0] = MSBOF((dwcbToAllocate-2));
	pbAlloc[1] = LSBOF((dwcbToAllocate-2));
	pbTemp += 2;
	pbAlloc += 2;
	while(dwcb)
	{
		DWORD dwT;
		DWORD dwPad;

		dwT =  COMBINEBYTES(pbTemp[0], pbTemp[1]); //IssuerListLength

		dwPad = 0;
		if(pbTemp[2] != 0x30) //if there is NO Sequence TAG
	 		dwPad =  CbLenOfEncode(dwT, pbAlloc+2);
	 	pbAlloc[0] = MSBOF((dwT+dwPad));
	 	pbAlloc[1] = LSBOF((dwT+dwPad));
	 	pbAlloc += (dwPad + 2);
	 	CopyMemory(pbAlloc, pbTemp+2, dwT);
	 	pbAlloc += dwT;
 		dwcb -= (dwT+2);
 		pbTemp += (dwT+2);
	}

	if(pContext->pbIssuerList != NULL)
		{
	    SPExternalFree(pContext->pbIssuerList);
	    pContext->pbIssuerList = NULL;
		}
	pContext->cbIssuerList = dwcbToAllocate;
	pContext->pbIssuerList = SPExternalAlloc(dwcbToAllocate);
    if(!pContext->pbIssuerList)
    {
	    SPExternalFree(pbAllocT);
    	return SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY);
    }

    CopyMemory(pContext->pbIssuerList, pbAllocT, dwcbToAllocate);
    //FREE the extra allocation...
    SPExternalFree(pbAllocT);
	return(PCT_ERR_OK);
	}



DWORD  CbLenOfEncode(DWORD dw, PBYTE pbDst)
	{
	BYTE   lenbuf[8];
    DWORD   length = sizeof(lenbuf) - 1;
    LONG    lth;

	if (0x80 > dw)
    {
    	lenbuf[length] = (BYTE)dw;
        lth = 1;
    }
    else
    {
    	while (0 < dw)
	    {
		    lenbuf[length] = (BYTE)(dw & 0xff);
		    length -= 1;
		    dw = (dw >> 8) & 0x00ffffff;
	    }
	    lth = sizeof(lenbuf) - length;
	    lenbuf[length] = (BYTE)(0x80 | (lth - 1));
    }

	if(NULL != pbDst)
	{
		pbDst[0] = 0x30;
		memcpy(pbDst+1, &lenbuf[length], lth);

	}
 	return ++lth; //for 0x30
  	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\ssl3sign.h ===
BOOL FindClientAuthCertsByIssuer
(
PBYTE pb, 
DWORD dwcbIssuerName, 
PBYTE pbCert, 
DWORD *pdwcbCert
);


BOOL FSignCertVerify(PBYTE rgbHash, PBYTE pbSigned, DWORD *pdwcbSigned);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\ssl3msg.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
*	Owner 			:ramas
*	Date			:4/16/96
*	description		: Main Crypto functions for SSL3
*----------------------------------------------------------------------------*/

#include <spbase.h>
#include <ssl2msg.h>
#include <ssl3msg.h>
#include <ssl3key.h>

#include <ssl2prot.h>
#include <md5.h>
#include <sha.h>
#include <rsa.h>

const Ssl2CipherMap Ssl3CipherRank[] =
{
    {SSL3_RSA_WITH_RC4_128_MD5, SP_HASH_MD5 , SP_CIPHER_RC4 | SP_ENC_BITS_128 | SP_MAC_BITS_128, SP_EXCH_RSA_PKCS1},
    {SSL3_RSA_WITH_RC4_128_SHA, SP_HASH_SHA , SP_CIPHER_RC4 | SP_ENC_BITS_128 | SP_MAC_BITS_128, SP_EXCH_RSA_PKCS1},
    {SSL_RSA_FINANCE64_WITH_RC4_64_MD5, SP_HASH_MD5 , SP_CIPHER_RC4 | SP_ENC_BITS_64 | SP_MAC_BITS_128, SP_EXCH_RSA_PKCS1},
    {SSL_RSA_FINANCE64_WITH_RC4_64_SHA, SP_HASH_SHA , SP_CIPHER_RC4 | SP_ENC_BITS_64 | SP_MAC_BITS_128, SP_EXCH_RSA_PKCS1},
    {SSL3_RSA_EXPORT_WITH_RC4_40_MD5, SP_HASH_MD5 , SP_CIPHER_RC4 | SP_ENC_BITS_40 | SP_MAC_BITS_128, SP_EXCH_RSA_PKCS1},
    {SSL3_RSA_WITH_NULL_MD5, SP_HASH_MD5, SP_CIPHER_NONE | SP_ENC_BITS_128 | SP_MAC_BITS_128, SP_EXCH_RSA_PKCS1},
    {SSL3_RSA_WITH_NULL_SHA, SP_HASH_SHA, SP_CIPHER_NONE | SP_ENC_BITS_128 | SP_MAC_BITS_128, SP_EXCH_RSA_PKCS1}
};

const DWORD Ssl3NumCipherRanks = sizeof(Ssl3CipherRank)/sizeof(Ssl2CipherMap);

CertSpec Ssl3CertRank[] = {
    SP_CERT_X509
};

const DWORD Ssl3NumCert = sizeof(Ssl3CertRank)/sizeof(CertSpec);


void DoSsl3MAC
(
	PSPContext pContext,
	PSPBuffer pClean,
	PCheckSumBuffer pwriteread,		//Need to pass in WriteMacState, WriteMacState1 for Encrypt
	PCheckSumBuffer pwriteread1,		//AND pas in ReadMacState. ReadMACstate1 for decrypt
	DWORD	dwSeq,
	CHAR cType,
	PUCHAR pbMAC
);



#if VERIFYHASH
BYTE  rgbF[5000];
DWORD ibF = 0;
#endif

#define CB_PAD1  48


//------------------------------------------------------------------------------------------

SP_STATUS WINAPI
Ssl3DecryptHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pAppOutput)
{
    SP_STATUS pctRet = 0;

    if (pCommInput->cbData > 0)
    {
        // First, we'll handle incoming data packets:

        if ((pContext->State & SP_STATE_CONNECTED) && pContext->Decrypt)
        {
            pctRet = pContext->Decrypt(
		                    pContext,
		                    pCommInput,		// message
		                    pAppOutput);	// Unpacked Message
            if (PCT_ERR_OK != pctRet)
            {
                return pctRet;
            }
            if(*(PBYTE)pCommInput->pvBuffer == SSL3_CT_HANDSHAKE /*Escape*/)
    	    {

    	        if(pAppOutput->cbData == 0)
                {
                    return (PCT_INT_ILLEGAL_MSG);
                }
                switch(*(PBYTE)pAppOutput->pvBuffer)
                {
                    case SSL3_HS_HELLO_REQUEST:
                        // We're fully reading the hello request here
                        pContext->State = SSL3_STATE_HELLO_REQUEST;
                        pAppOutput->cbData = 0;
                        return SP_LOG_RESULT(PCT_INT_RENEGOTIATE);

#ifndef SCHANNEL_CLIENT_ONLY
                    case SSL3_HS_CLIENT_HELLO:
                        {
	                        BOOL 				fRestart = FALSE;
                            PBYTE pbMessage = (PBYTE) pAppOutput->pvBuffer;
                            DWORD dwHandshakeLen = pAppOutput->cbData;
                            // We received a client hello, so process the hello,
                            // Validate handshake type

                            UpdateHandshakeHash(pContext,
				                                (PUCHAR)pAppOutput->pvBuffer,
				                                dwHandshakeLen,
				                                TRUE);

                            pbMessage += sizeof(SHSH);

                            if(!Ssl3ParseClientHello(pContext, pbMessage, dwHandshakeLen - sizeof(SHSH), &fRestart))
                            {
	                            SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
                            }
                           	//WE SHOULDn't be doing Retstart on REDO's. May be we may ask for Client-auth
                            SPCacheDereference(pContext->RipeZombie);
                           	if(!SPCacheRetrieveNew(NULL, &pContext->RipeZombie))
			            	{
	                            SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
                            }

							pContext->RipeZombie->fProtocol = pContext->pCred->Type;

                            pContext->State = SSL3_STATE_REDO;
                            pAppOutput->cbData = 0;
                            return SP_LOG_RESULT(PCT_INT_RENEGOTIATE);
                        }
#endif //!SCHANNEL_CLIENT_ONLY                        
                    default:
                         /* Unknown escape, generate error */
                        pctRet = SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
                        /* Disconnect */
                        break;
               }

    	    }
    	    else  if(*(PBYTE)pCommInput->pvBuffer == SSL3_CT_ALERT /*Escape*/)
            {
                UCHAR bAlertLevel;
                UCHAR bAlertDesc;
                if(pAppOutput->cbData != 2)
                {
                    pctRet =  SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
                }

                bAlertLevel = *(PBYTE)pAppOutput->pvBuffer;
                bAlertDesc = *((PBYTE)pAppOutput->pvBuffer + 1);
                if(bAlertLevel == SSL3_ALERT_WARNING)
                {
                    if (bAlertDesc == SSL3_ALERT_CLOSE_NOTIFY)
                    {
                        // we dont expect any more messages on this connection
                        pContext->State = SP_STATE_NONE;
                    }
                }
                else if (bAlertLevel == SSL3_ALERT_FATAL)
                {
                    pctRet = SP_LOG_RESULT(PCT_INT_MSG_ALTERED);
                }
                else
                {
                    pctRet =  SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
                }
                pAppOutput->cbData = 0; // swallow the decrypted data in all cases

                // DBGCHK(TEXT("SCHANNEL ALERT"),pctRet==0);
            }
            /* look for escapes */
            return pctRet;
        }
        else
        {
            return(PCT_INT_ILLEGAL_MSG);
        }
    }
    return PCT_INT_INCOMPLETE_MSG;
}




#if   DBG
BYTE rgb3Mac[2048];
DWORD ibMac = 0;
#endif

void DoSsl3MAC
(
PSPContext pContext,
PSPBuffer pClean,
PCheckSumBuffer pwriteread,		//Need to pass in WriteMacState, WriteMacState1 for Encrypt
PCheckSumBuffer pwriteread1,		//AND pas in ReadMacState. ReadMACstate1 for decrypt
DWORD	dwSeq,
CHAR cType,
PUCHAR pbMAC
)
	{
    PCheckSumBuffer             pSum;
    HashBuf                     SumBuf;
    PCheckSumBuffer             pSumFinal;
    HashBuf                     SumBufFinal;
    DWORD                       dwReverseSeq;
    DWORD                       dw32High = 0;
    SHORT                       wData, wDataReverse;
    UCHAR                       rgbDigest[MAX_DIGEST_LEN];

	CloneHashBuf(SumBuf, pwriteread, pContext->pCheck);
    pSum = (PCheckSumBuffer)SumBuf;
    dwReverseSeq = htonl(dwSeq);

    /* add count */
    pContext->pCheck->Sum( pSum, sizeof(DWORD), (PUCHAR) &dw32High);
    pContext->pCheck->Sum( pSum, sizeof(DWORD), (PUCHAR) &dwReverseSeq );
    if(cType != 0)
	    pContext->pCheck->Sum( pSum, 1 , &cType );

    /* add length */
    wData = (short) (pClean->cbData - pContext->pCheck->cbCheckSum); //length to be MAC'ed
 	wDataReverse = wData >> 8 | wData << 8;
    pContext->pCheck->Sum( pSum, sizeof(short), (PUCHAR) &wDataReverse );

   /* add data */
    pContext->pCheck->Sum( pSum, wData, (PUCHAR)pClean->pvBuffer );
#if VERIFYHASH
	if(ibMac > 1800)
		ibMac = 0;
	CopyMemory(&rgb3Mac[ibMac], (BYTE *)&dw32High, sizeof(DWORD));
	ibMac += sizeof(DWORD);
	CopyMemory(&rgb3Mac[ibMac], (BYTE *)&dwReverseSeq, sizeof(DWORD));
	ibMac += sizeof(DWORD);
	CopyMemory(&rgb3Mac[ibMac], (BYTE *)&wDataReverse, sizeof(WORD));
	ibMac += sizeof(WORD);
	if(wData < 50)
		{
		CopyMemory(&rgb3Mac[ibMac], (PUCHAR)pClean->pvBuffer, wData);
		ibMac += wData;
		}
#endif

    pContext->pCheck->Finalize(pSum, rgbDigest);
#if VERIFYHASH
	CopyMemory(&rgb3Mac[ibMac], rgbDigest, pContext->pCheck->cbCheckSum);
	ibMac += pContext->pCheck->cbCheckSum;
#endif
	CloneHashBuf(SumBufFinal, pwriteread1, pContext->pCheck);

    pSumFinal = (PCheckSumBuffer)SumBufFinal;
    pContext->pCheck->Sum(pSumFinal, pContext->pCheck->cbCheckSum,  rgbDigest);

    pContext->pCheck->Finalize(pSumFinal, rgbDigest);
#if VERIFYHASH
	CopyMemory(&rgb3Mac[ibMac], rgbDigest, pContext->pCheck->cbCheckSum);
	ibMac += pContext->pCheck->cbCheckSum;
#endif
	CopyMemory(pbMAC, rgbDigest, pContext->pCheck->cbCheckSum);
	}



void Ssl3BuildFinishMessage(
PSPContext pContext,
BYTE *pbMd5Digest,
BYTE *pbSHADigest,
BOOL fClient //This is needed to Verify the Finished messages
)
	{
    MD5_CTX Md5Hash;
    A_SHA_CTX ShaHash;
    BYTE rgbPad1[CB_PAD1];
    BYTE rgbPad2[CB_PAD1];
    DWORD ib;
    BYTE szClnt[] = "CLNT";
    BYTE szSrvr[] = "SRVR";
//    DWORD cbMessage;

    for(ib = 0 ; ib < CB_PAD1; ib++)
    {
    	rgbPad1[ib] = CH_SLL3_MD5_PAD_CHAR;
    	rgbPad2[ib] = CH_SSL3_SHA_PAD_CHAR;
    }
	//UNDONE: cbPad = CB_SSL3_SHA_PAD if SHA
    // HandshakeType

    //
    // Compute the two hash values as follows:
    //
    // enum { client(0x434c4e54), server(0x53525652) } Sender;
    // enum { client("CLNT"), server("SRVR") } Sender;
    //
    // struct {
    //	   opaque md5_hash[16];
    //	   opaque sha_hash[20];
    // } Finished;
    //
    // md5_hash  -  MD5(master_secret + pad2 + MD5(handshake_messages +
    //			Sender + master_secret + pad1))
    //
    // sha_hash  -  SHA(master_secret + pad2 + SHA(handshake_messages +
    //			Sender + master_secret + pad1))
    //
    // pad_1 - The character 0x36 repeated 48 times for MD5 or
    //	       40 times for SHA.
    //
    // pad_2 - The character 0x5c repeated the same number of times.
    //

    //
    // Build MD5 Hash
    //

    // Make local copy of the handshake_messages MD5 hash object
    CopyMemory((BYTE *)&Md5Hash,
	   (BYTE *)pContext->MD5Handshake,
	   sizeof(MD5_CTX));

    // Add rest of stuff to local MD5 hash object.
    if (fClient)
		MD5Update(&Md5Hash, szClnt, 4);  // This is Better be 4, NO # define...
	else
		MD5Update(&Md5Hash, szSrvr, 4);
    MD5Update(&Md5Hash, pContext->RipeZombie->pMasterKey, pContext->RipeZombie->cbMasterKey);

    MD5Update(&Md5Hash, rgbPad1, CB_SSL3_MD5_PAD);
    MD5Final(&Md5Hash);
    CopyMemory(pbMd5Digest, Md5Hash.digest, MD5DIGESTLEN);

    // Compute "parent" MD5 hash
    MD5Init(&Md5Hash);
    MD5Update(&Md5Hash, pContext->RipeZombie->pMasterKey, pContext->RipeZombie->cbMasterKey);
    MD5Update(&Md5Hash, rgbPad2, CB_SSL3_MD5_PAD);
    MD5Update(&Md5Hash, pbMd5Digest, MD5DIGESTLEN);
    MD5Final(&Md5Hash);
    CopyMemory(pbMd5Digest, Md5Hash.digest, MD5DIGESTLEN);

    // Build SHA Hash

    // Make local copy of the handshake_messages SHA hash object
    CopyMemory((BYTE *)&ShaHash, (BYTE *)pContext->SHAHandshake, sizeof(A_SHA_CTX));

    // SHA(handshake_messages + Sender + master_secret + pad1)
    if (fClient)
		A_SHAUpdate(&ShaHash, szClnt, 4);
	else
		A_SHAUpdate(&ShaHash, szSrvr, 4);

    A_SHAUpdate(&ShaHash, pContext->RipeZombie->pMasterKey, pContext->RipeZombie->cbMasterKey);
    A_SHAUpdate(&ShaHash, rgbPad1, CB_SSL3_SHA_PAD);
    A_SHAFinal(&ShaHash, pbSHADigest);

    // SHA(master_secret + pad2 + SHA-hash);
    A_SHAInit(&ShaHash);
    A_SHAUpdate(&ShaHash, pContext->RipeZombie->pMasterKey, pContext->RipeZombie->cbMasterKey);
    A_SHAUpdate(&ShaHash, rgbPad2, CB_SSL3_SHA_PAD);
    A_SHAUpdate(&ShaHash, pbSHADigest, A_SHA_DIGEST_LEN);
    A_SHAFinal(&ShaHash, pbSHADigest);

}




SP_STATUS WINAPI
Ssl3EncryptRaw( PSPContext pContext,
                    PSPBuffer   pAppInput,
                    PSPBuffer   pCommOutput,
                    BYTE        bType)
{
    SP_STATUS       pctRet;
    SPBuffer        Clean;
    SPBuffer        Encrypted;
    UCHAR           rgbMAC[MAX_DIGEST_LEN];
    PUCHAR          pbMAC;
//    SWRAP *         pwsrap;


    Clean.cbData = Encrypted.cbData = pAppInput->cbData+pContext->pCheck->cbCheckSum;
    Clean.pvBuffer = Encrypted.pvBuffer = (PUCHAR)pCommOutput->pvBuffer+sizeof(SWRAP);
    Clean.cbBuffer = Encrypted.cbBuffer = pCommOutput->cbBuffer-sizeof(SWRAP);

    /* Move data out of the way if necessary */
    if((PUCHAR)Clean.pvBuffer != (PUCHAR)pAppInput->pvBuffer)
    {
        DebugLog((DEB_WARN, "SSL3EncryptRaw: Unnecessary Move, performance hog\n"));
        MoveMemory((PUCHAR)Clean.pvBuffer,
                    (PUCHAR)pAppInput->pvBuffer,
                    pAppInput->cbData);
    }

    DoSsl3MAC(pContext,
              &Clean,
              pContext->WriteMACState,
              pContext->WriteMACState1,
              pContext->WriteCounter,
              bType,
              rgbMAC);

    pbMAC = (PUCHAR)Clean.pvBuffer + (Clean.cbBuffer - pContext->pCheck->cbCheckSum);

    CopyMemory(pbMAC, rgbMAC, pContext->pCheck->cbCheckSum);
    pContext->WriteCounter ++ ;

    pctRet = pContext->pSystem->Encrypt(pContext->pWriteState, &Clean, &Encrypted);
    pCommOutput->cbData = Encrypted.cbData + sizeof(SWRAP);

    return(pctRet);
}

SP_STATUS WINAPI
Ssl3EncryptMessage( PSPContext pContext,
                    PSPBuffer   pAppInput,
                    PSPBuffer   pCommOutput)
{

    SetWrapNoEncrypt(pCommOutput->pvBuffer,
                        SSL3_CT_APPLICATIONDATA,
                        pAppInput->cbData+pContext->pCheck->cbCheckSum);
    return Ssl3EncryptRaw(pContext, pAppInput, pCommOutput, SSL3_CT_APPLICATIONDATA);
}


SP_STATUS WINAPI
Ssl3DecryptMessage( PSPContext         pContext,
                    PSPBuffer          pMessage,
                    PSPBuffer          pAppOutput)
{
    SP_STATUS                  pctRet;
    SPBuffer                   Clean;
    SPBuffer                   Encrypted;
	UCHAR 					   rgbDigest[MAX_DIGEST_LEN];
	PUCHAR 						pbMAC;
	DWORD  					dwLength, cbActualData;
	SWRAP					*pswrap = pMessage->pvBuffer;

    /* First determine the length of data, the length of padding,
     * and the location of data, and the location of MAC */
    cbActualData = pMessage->cbData;
    pMessage->cbData = sizeof(SWRAP); /* minimum amount of data we need */

    if(pMessage->cbData > cbActualData)
    	return PCT_INT_INCOMPLETE_MSG;

    dwLength = COMBINEBYTES(pswrap->bcbMSBSize, pswrap->bcbLSBSize);

    Clean.pvBuffer = Encrypted.pvBuffer = ((PUCHAR)pMessage->pvBuffer) + sizeof(SWRAP);
	Clean.cbBuffer = pMessage->cbBuffer - sizeof(SWRAP);

    pMessage->cbData += dwLength ;

    if(pMessage->cbData > cbActualData)
        return PCT_INT_INCOMPLETE_MSG;
    Encrypted.cbData = Clean.cbData = dwLength;	/* encrypted data size */

    pctRet = pContext->pSystem->Decrypt(pContext->pReadState, &Encrypted, &Clean);
    pbMAC = (PUCHAR)Clean.pvBuffer + (Clean.cbData - pContext->pCheck->cbCheckSum);
    DoSsl3MAC(pContext,
              &Clean,
              pContext->ReadMACState,
			  pContext->ReadMACState1,
              pContext->ReadCounter,
              pswrap->bCType,
              rgbDigest);

	pContext->ReadCounter++;
    if (memcmp(rgbDigest, pbMAC, pContext->pCheck->cbCheckSum))
    {
        DebugLog((DEB_WARN, "FINISHED Message: Checksum Invalid\n"));
        pctRet = SP_LOG_RESULT(PCT_INT_MSG_ALTERED);
    }

    if(pAppOutput->pvBuffer != Clean.pvBuffer)
        CopyMemory(pAppOutput->pvBuffer, Clean.pvBuffer, Clean.cbData);
    pAppOutput->cbData = Clean.cbData - pContext->pCheck->cbCheckSum;
    //THIS is mondo KLUDGE: We don't support Esc after the connection is
    //Established. This needs work from IE 3.0 side which we are postponing for POST beta
    //if(*(PBYTE)pMessage->pvBuffer == SSL3_CT_ALERT /*Escape*/)
    //	{
    //	pAppOutput->cbData = 0;
    //	}
    return(pctRet);
}

SP_STATUS
VerifyFinishMsg(
    PSPContext pContext,
    PBYTE       pbMsg,
    DWORD       cbMessage,
    BOOL        fClient
    )
{
    BYTE rgbDigest[MD5DIGESTLEN+A_SHA_DIGEST_LEN];
    SP_STATUS pctRet = PCT_ERR_OK;


    if(cbMessage < sizeof(SWRAP))
    {
        return PCT_INT_INCOMPLETE_MSG;
    }

    do
    {
//        SHSH *pshsh;
        SWRAP *pswrap = (SWRAP *)pbMsg;
        DWORD dwSize = COMBINEBYTES(pswrap->bcbMSBSize, pswrap->bcbLSBSize);
        FMWIRE *pfmwire = (FMWIRE *) pbMsg;

        if(cbMessage < dwSize)
        {
          return PCT_INT_INCOMPLETE_MSG;
        }


        if(*pbMsg != SSL3_CT_HANDSHAKE)
        {
            pctRet = SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
	        break;
        }

        if(pfmwire->typHS != SSL3_HS_FINISHED)
        {
            pctRet = SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
	        break;
        }
        dwSize = COMBINEBYTES(pfmwire->bcbMSB, pfmwire->bcbLSB);
        if(dwSize != (MD5DIGESTLEN+A_SHA_DIGEST_LEN))
        {
            pctRet = SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
	        break;
        }
        Ssl3BuildFinishMessage(pContext, rgbDigest, &rgbDigest[MD5DIGESTLEN], fClient);
        if (memcmp(rgbDigest, (BYTE *)pfmwire->rgbMD5,MD5DIGESTLEN+A_SHA_DIGEST_LEN))
        {
            DebugLog((DEB_WARN, "Finished MAC didn't matchChecksum Invalid\n"));
            pctRet = SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
	        break;
        }
        //Server's Finished message contains the finished message of client...
        //This is NOT used by the client, but it doesn't matter, we could put an if...
        UpdateHandshakeHash(pContext, (BYTE *)&pfmwire->typHS, dwSize + sizeof(SHSH), FALSE);
        return (PCT_ERR_OK);
    } while(TRUE);
    return(pctRet);
}

void BuildS3FinalFinish(PSPContext pContext, PUCHAR pb, BOOL fClient)
{
    BYTE rgbMd5Digest[MD5DIGESTLEN];
    BYTE rgbSHADigest[A_SHA_DIGEST_LEN];
    FMWIRE *pfmwire = (FMWIRE *) pb ;

    FillMemory((BYTE *)pfmwire, sizeof(FMWIRE), 0);
    Ssl3BuildFinishMessage(pContext, rgbMd5Digest, rgbSHADigest, fClient);
    CopyMemory(pfmwire->rgbMD5, rgbMd5Digest, MD5DIGESTLEN);
    CopyMemory(pfmwire->rgbSHA, rgbSHADigest, A_SHA_DIGEST_LEN);

    SetHandshake((BYTE *)&pfmwire->typHS,  SSL3_HS_FINISHED,  NULL, MD5DIGESTLEN+A_SHA_DIGEST_LEN);
    UpdateHandshakeHash(pContext, (BYTE *)&pfmwire->typHS, sizeof(FMWIRE) - sizeof(SWRAP), FALSE);
    SetWrap(pContext, pb,  SSL3_CT_HANDSHAKE, sizeof(FMWIRE) - sizeof(SWRAP), fClient);
}



void SetWrap(PSPContext pContext, PUCHAR pb, UCHAR bCType, DWORD wT, BOOL fClient)
	{
	SWRAP *pswrap = (SWRAP *)pb;
	DWORD wTT = wT + (FSsl3Cipher(fClient) ? pContext->pCheck->cbCheckSum : 0);

	FillMemory(pswrap, sizeof(SWRAP), 0);
    pswrap->bCType = bCType;
	pswrap->bMajor = 0x03;
	pswrap->bcbMSBSize = MSBOF(wTT);
	pswrap->bcbLSBSize = LSBOF(wTT);
    if(FSsl3Cipher(fClient))
    {
        SPBuffer   Clean;

        Clean.pvBuffer = pb;
        Clean.cbBuffer = wT+sizeof(SWRAP);
        Clean.cbData = wT;
        WrapSsl3Message(pContext, &Clean, bCType);
    }

}


void SetWrapNoEncrypt(PUCHAR pb, UCHAR bCType, DWORD wT)
	{
	SWRAP *pswrap = (SWRAP *)pb;

	FillMemory(pswrap, sizeof(SWRAP), 0);
    pswrap->bCType = bCType;
	pswrap->bMajor = 0x03;
	pswrap->bcbMSBSize = MSBOF(wT);
	pswrap->bcbLSBSize = LSBOF(wT);
    }


void SetHandshake(PUCHAR pb, BYTE bHandshake, PUCHAR pbData, WORD wSize)
{
    SHSH *pshsh = (SHSH *) pb;

    FillMemory(pshsh, sizeof(SHSH), 0);
    pshsh->typHS = bHandshake;
    pshsh->bcbMSB = MSBOF(wSize) ;
    pshsh->bcbLSB = LSBOF(wSize) ;
    if(NULL != pbData)
    {
        CopyMemory( pb + sizeof(SHSH) , pbData, wSize);
    }
}





void   UpdateHandshakeHash(PSPContext pContext, PUCHAR pb, DWORD dwcb, BOOL fInit)
{

    SP_BEGIN("UpdateHandshakeHash");

    DebugLog((DEB_TRACE, "Number of Bytes:%d\n", dwcb));

    if(fInit)
    {
        MD5Init((MD5_CTX *)pContext->MD5Handshake);
        A_SHAInit((A_SHA_CTX *)pContext->SHAHandshake);
    }

    MD5Update((MD5_CTX *)pContext->MD5Handshake, pb,  dwcb);
    A_SHAUpdate((A_SHA_CTX *)pContext->SHAHandshake, pb, dwcb);

#if DBG_HASHING
    DebugLog((DEB_TRACE, "  MD5:"));
    DbgDumpHexString(pContext->MD5Handshake,  sizeof(MD5_CTX));
    DebugLog((DEB_TRACE, "  SHA:"));
    DbgDumpHexString(pContext->SHAHandshake,  sizeof(A_SHA_CTX));

#endif

#if VERIFYHASH
    CopyMemory(&rgbF[ibF], pb, dwcb);
    ibF += dwcb;
#endif
    SP_END();
}


/*****************************************************************************/
//It better be allocated and of length 16+20
void ComputeCertVerifyHashes(PSPContext pContext, PBYTE pbHash)
{
    MD5_CTX Md5Hash;
    A_SHA_CTX ShaHash;
    BYTE rgbPad1[CB_PAD1];
    BYTE rgbPad2[CB_PAD1];
    DWORD ib;

    for(ib = 0 ; ib < CB_PAD1; ib++)
    {
    	rgbPad1[ib] = CH_SLL3_MD5_PAD_CHAR;
    	rgbPad2[ib] = CH_SSL3_SHA_PAD_CHAR;
    }

    //
    // CertificateVerify.signature.md5_hash = MD5(master_secret + pad2 +
    //		MD5(handshake_messages + master_secret + pad1));
    //

    // Make copy of handshake hash and add stuff to it
    CopyMemory(&Md5Hash, (BYTE *)pContext->MD5Handshake, sizeof(MD5_CTX));
    MD5Update(&Md5Hash, pContext->RipeZombie->pMasterKey, pContext->RipeZombie->cbMasterKey);
    MD5Update(&Md5Hash, rgbPad1, CB_SSL3_MD5_PAD);
    MD5Final(&Md5Hash);
    CopyMemory(pbHash, Md5Hash.digest, MD5DIGESTLEN);

    MD5Init(&Md5Hash);
    MD5Update(&Md5Hash, pContext->RipeZombie->pMasterKey, pContext->RipeZombie->cbMasterKey);
    MD5Update(&Md5Hash, rgbPad2, CB_SSL3_MD5_PAD);
    MD5Update(&Md5Hash, pbHash, MD5DIGESTLEN);
    MD5Final(&Md5Hash);
    CopyMemory(pbHash, Md5Hash.digest, MD5DIGESTLEN);

    //
    // CertificateVerify.signature.sha_hash = SHA(master_secret + pad2 +
    //		SHA(handshake_messages + master_secret + pad1));
    //

    // Make copy of handshake hash and add stuff to it
    CopyMemory(&ShaHash, (BYTE *)pContext->SHAHandshake, sizeof(A_SHA_CTX));
    A_SHAUpdate(&ShaHash, pContext->RipeZombie->pMasterKey, pContext->RipeZombie->cbMasterKey);
    A_SHAUpdate(&ShaHash, rgbPad1, CB_SSL3_SHA_PAD);
    A_SHAFinal(&ShaHash, pbHash+MD5DIGESTLEN);

    A_SHAInit(&ShaHash);
    A_SHAUpdate(&ShaHash, pContext->RipeZombie->pMasterKey, pContext->RipeZombie->cbMasterKey);
    A_SHAUpdate(&ShaHash, rgbPad2, CB_SSL3_SHA_PAD);
    A_SHAUpdate(&ShaHash, pbHash+MD5DIGESTLEN, A_SHA_DIGEST_LEN);
    A_SHAFinal(&ShaHash, pbHash+MD5DIGESTLEN);
}

//Assumes one cert and NOT cert chanin....
void BuildCertificateMessage(PBYTE pb, PBYTE rgbCert, DWORD dwCert)
    {
    	CERT *pcert = (CERT *) pb ;
        WORD wT = (WORD)dwCert + sizeof(CERT) - sizeof(SHSH);
        WORD wTT = wT - 3; //for the list....

    	FillMemory(pcert, sizeof(CERT), 0);
    	pcert->typHS = SSL3_HS_CERTIFICATE;
    	pcert->bcbMSBClist = MSBOF(wTT);
    	pcert->bcbLSBClist = LSBOF(wTT);
    	pcert->bcbMSB = MSBOF(wT) ;
    	pcert->bcbLSB = LSBOF(wT) ;
    	pcert->bcbMSBCert = MSBOF(dwCert) ;
    	pcert->bcbLSBCert = LSBOF(dwCert) ;
        CopyMemory( pcert->rgbCert, rgbCert, dwCert);
    }



SP_STATUS Ssl3HandleCCS(PSPContext pContext,
				   PUCHAR pb,
				   DWORD cbMessage,
				   BOOL fClient)
{

    SP_STATUS pctRet = PCT_ERR_OK;

    BYTE rgbCCS[CB_SLL3_CHANGE_CIPHER_SPEC] = SSL3_CHANGE_CIPHER_MSG;


    if(memcmp(rgbCCS, pb, CB_SLL3_CHANGE_CIPHER_SPEC))
    {
        pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
        return (pctRet);
    }

    // We always zero out the read counter on receipt
    // of a change cipher spec message.
    pContext->ReadCounter = 0;

    pContext->RipeZombie->SessCiphSpec = pContext->PendingCiphSpec;
    pContext->RipeZombie->SessHashSpec = pContext->PendingHashSpec;
    pContext->RipeZombie->SessExchSpec = pContext->PendingExchSpec;

    pctRet = ContextInitCiphers(pContext);

    if(pctRet != PCT_ERR_OK)
    {
        return(pctRet);
    }

    pctRet = Ssl3MakeReadSessionKeys(pContext);

    if(pctRet != PCT_ERR_OK)
    {
        return(pctRet);
    }
    if(fClient)
    {
        pContext->State = SSL3_STATE_CLIENT_FINISH;
        pContext->wS3CipherSuiteClient = pContext->wS3pendingCipherSuite;
    }
    else
    {
        pContext->State = SSL3_STATE_SERVER_FINISH;
        pContext->wS3CipherSuiteServer = pContext->wS3pendingCipherSuite;
    }
    return(PCT_ERR_OK);
}


SP_STATUS
BuildCCSAndFinishMessage
(
PSPContext pContext,
PUCHAR pb,
DWORD cbMessage,
BOOL fClient
)
{
    SP_STATUS pctRet;
    PUCHAR pbT = pb + sizeof(SWRAP);


    *pbT = 0x1;
    SetWrap(pContext, pb,  SSL3_CT_CHANGE_CIPHER_SPEC, 1, fClient);
    pb += CB_SLL3_CHANGE_CIPHER_SPEC + (FSsl3Cipher(fClient) ? pContext->pCheck->cbCheckSum : 0) ;

    pContext->WriteCounter = 0 ;
    pContext->RipeZombie->SessCiphSpec = pContext->PendingCiphSpec;
    pContext->RipeZombie->SessHashSpec = pContext->PendingHashSpec;
    pContext->RipeZombie->SessExchSpec = pContext->PendingExchSpec;

    pctRet = ContextInitCiphers(pContext);

    if(pctRet != PCT_ERR_OK)
    {
        return(pctRet);
    }

    pctRet = Ssl3MakeWriteSessionKeys(pContext);

    if(pctRet != PCT_ERR_OK)
    {
        return(pctRet);
    }
    if(fClient)
    {
        pContext->wS3CipherSuiteClient = pContext->wS3pendingCipherSuite;
    }
    else
    {
        pContext->wS3CipherSuiteServer = pContext->wS3pendingCipherSuite;
    }

    BuildS3FinalFinish(pContext, pb, fClient);
    return(PCT_ERR_OK);
}



SP_STATUS
Ssl3SelectCipher    (
    PSPContext pContext,
    DWORD   dwCipher
)
{
    DWORD               i;

    for(i=0; i<Ssl3NumCipherRanks; i++) {
        if(NULL == CipherFromSpec(Ssl3CipherRank[i].Cipher,
            pContext->RipeZombie->fProtocol | (pContext->RipeZombie->fSGC ? SP_PROT_SGC : 0)))
        {
            continue;
        }
        if(NULL == HashFromSpec(Ssl3CipherRank[i].Hash, pContext->RipeZombie->fProtocol))
        {
            continue;
        }
        if(NULL == KeyExchangeFromSpec(Ssl3CipherRank[i].KeyExch, pContext->RipeZombie->fProtocol))
        {
            continue;
        }

        if (Ssl3CipherRank[i].Kind == dwCipher) {

            pContext->wS3pendingCipherSuite = (WORD)Ssl3CipherRank[i].Kind;
            pContext->PendingCiphSpec  = Ssl3CipherRank[i].Cipher;
            pContext->PendingHashSpec  = Ssl3CipherRank[i].Hash;
            pContext->PendingExchSpec  = Ssl3CipherRank[i].KeyExch;
            return PCT_ERR_OK;
        }
    }



    return(PCT_ERR_ILLEGAL_MESSAGE);
}


VOID
ReverseMemCopy(
    PUCHAR      Dest,
    PUCHAR      Source,
    ULONG       Size)
{
    PUCHAR  p;

    p = Dest + Size - 1;
    do
    {
	*p-- = *Source++;
    } while (p >= Dest);
}


#ifdef LATER
SP_STATUSBuildAlertMessage()
{
    UCHAR rgbCertAlert[] = { 21, 3, 0, 0, 2, 2, 40 };
    pCommOutput->cbData = 7;
		/* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL)
    {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
        {
            SP_RETURN(SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY));
        }
        pCommOutput->cbBuffer = pCommOutput->cbData;
    }


    if(pCommOutput->cbData > pCommOutput->cbBuffer)
    {
        SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
    }
    CopyMemory(pCommOutput->pvBuffer, rgbCertAlert, 7);
    return PCT_ERR_OK;
}

 #endif

PctPrivateKey *g_pSsl3Private; // = NULL;
PctPublicKey *g_pSsl3Public;   // = NULL;

BOOL FBuildSsl3ExchgKeys()
{
    BOOL fSucc = FALSE;
    DWORD dwPrivateSize;
    DWORD dwPublicSize;
    DWORD BitsCopy;

  	if(g_pSsl3Private != NULL && g_pSsl3Public != NULL)
  		return(TRUE);

    DebugLog((DEB_WARN, "Doing BuildSSl3ExchgKeys ...\n"));
    BitsCopy = 512; //We always generate 512 bits keys
    BSafeComputeKeySizes(&dwPublicSize, &dwPrivateSize, &BitsCopy);
    BitsCopy = 512;

    g_pSsl3Private = SPExternalAlloc(dwPrivateSize + sizeof(PctPrivateKey));
    if (NULL == g_pSsl3Private)
        goto Ret;

    g_pSsl3Public = SPExternalAlloc(dwPublicSize + sizeof(PctPublicKey));
    if (NULL == g_pSsl3Public)
        goto Ret;

    g_pSsl3Public->cbKey = dwPublicSize;
    g_pSsl3Private->cbKey = dwPrivateSize;

    if (BSafeMakeKeyPair(
		    (LPBSAFE_PUB_KEY) g_pSsl3Public->pKey,
		    (LPBSAFE_PRV_KEY) g_pSsl3Private->pKey,
		    BitsCopy))
	   return(TRUE);
Ret:
    	SPExternalFree(g_pSsl3Public);
    	SPExternalFree(g_pSsl3Private);
        return(fSucc);

}



/*****************************************************************************/
VOID ComputeServerExchangeHashes(
	PSPContext pContext,
    PBYTE pbServerParams,      // in
    INT   iServerParamsLen,    // in
    PBYTE pbMd5HashVal,        // out
    PBYTE pbShaHashVal)        // out
{
    MD5_CTX Md5Hash;
    A_SHA_CTX ShaHash;

    //
    // md5_hash = MD5(ClientHello.random + ServerHello.random + ServerParams);
    //
    // sha_hash = SHA(ClientHello.random + ServerHello.random + ServerParams);
    //

	//UNDONE: pbRandom should be another parameter rathe taking from pContext
    MD5Init(&Md5Hash);
    MD5Update(&Md5Hash, pContext->rgbS3CRandom, 32);
    MD5Update(&Md5Hash, pContext->rgbS3SRandom, 32);
    MD5Update(&Md5Hash, pbServerParams, iServerParamsLen);
    MD5Final(&Md5Hash);
    CopyMemory(pbMd5HashVal, Md5Hash.digest, 16);

    A_SHAInit(&ShaHash);
    A_SHAUpdate(&ShaHash, pContext->rgbS3CRandom, 32);
    A_SHAUpdate(&ShaHash, pContext->rgbS3SRandom, 32);
    A_SHAUpdate(&ShaHash, pbServerParams, iServerParamsLen);
    A_SHAFinal(&ShaHash, pbShaHashVal);
}

SP_STATUS
UnwrapSsl3Message
(
PSPContext pContext,
PSPBuffer pMsgInput
)
    {
    SPBuffer   Encrypted;
    SPBuffer   Clean;
    DWORD cbData;
    SP_STATUS pctRet;
    SWRAP *pswrap = (SWRAP *)pMsgInput->pvBuffer;


    cbData = COMBINEBYTES(pswrap->bcbMSBSize, pswrap->bcbLSBSize) -
                    pContext->pCheck->cbCheckSum;
    Encrypted.pvBuffer = pMsgInput->pvBuffer;
    Encrypted.cbBuffer = pMsgInput->cbBuffer;
    Encrypted.cbData = pMsgInput->cbData;
    Clean.pvBuffer = (PUCHAR)pMsgInput->pvBuffer + sizeof(SWRAP);
    pctRet = Ssl3DecryptMessage(pContext, &Encrypted, &Clean);
   	pswrap->bcbMSBSize = MSBOF(cbData);
   	pswrap->bcbLSBSize = LSBOF(cbData);
    return(pctRet);

    }


SP_STATUS
WrapSsl3Message
(
PSPContext pContext,
PSPBuffer pMsgInput,
UCHAR bContentType
)
    {
    SPBuffer   Encrypted;
    SPBuffer   Clean;
//    SP_STATUS pctRet;

    Clean.pvBuffer = (PUCHAR)pMsgInput->pvBuffer + sizeof(SWRAP);
    Clean.cbData = pMsgInput->cbData;
    Encrypted.pvBuffer = pMsgInput->pvBuffer;
    Encrypted.cbData = pMsgInput->cbData;
    Encrypted.cbBuffer = pMsgInput->cbData + pContext->pCheck->cbCheckSum + sizeof(SWRAP);
    return(Ssl3EncryptRaw(pContext, &Clean, &Encrypted, bContentType));
    }



SP_STATUS
ParseAlertMessage(
    PSPContext pContext,
    PUCHAR pbAlertMsg,
    DWORD cbMessage,
    PSPBuffer  pCommOutput
    )
{
    SP_STATUS   pctRet=PCT_ERR_OK;
    ALRT *      palrt = (ALRT *) pbAlertMsg;
    DWORD       cbMsg = COMBINEBYTES(palrt->bcbMSBSize, palrt->bcbLSBSize);
    if(cbMsg != 2)
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    if(palrt->bCType != SSL3_CT_ALERT)
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    if(palrt->bAlertLevel != SSL3_ALERT_WARNING  &&  palrt->bAlertLevel != SSL3_ALERT_FATAL)
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    DebugLog((DEB_WARN, "AlertMessage, Alert Level -  %lx\n", (DWORD)palrt->bAlertLevel));
    DebugLog((DEB_WARN, "AlertMessage, Alert Description -  %lx\n", (DWORD)palrt->bAlertDesc));

    switch(palrt->bAlertDesc)
    {
        case SSL3_ALERT_CLOSE_NOTIFY:
             pctRet = PCT_INT_ILLEGAL_MSG;
           break;

        case SSL3_ALERT_UNEXPECTED_MESSAGE:
        case SSL3_ALERT_DECOMPRESSION_FAIL:
        case SSL3_ALERT_HANDSHAKE_FAILURE:
        case SSL3_ALERT_ILLEGAL_PARAMETER:
            pctRet = PCT_INT_ILLEGAL_MSG;
            break;


        case SSL3_ALERT_BAD_CERTIFICATE:
        case SSL3_ALERT_CERTIFICATE_REVOKED:
        case SSL3_ALERT_CERTIFICATE_EXPIRED:
        case SSL3_ALERT_CERTIFICATE_UNKNOWN:
            pctRet = PCT_INT_ILLEGAL_MSG;
            break;

        case SSL3_ALERT_NO_CERTIFICATE:
        case SSL3_ALERT_UNSUPPORTED_CERT:
            pctRet = PCT_INT_ILLEGAL_MSG;
            break;
    }

    return pctRet;
}


void BuildAlertMessage(PBYTE pbAlertMsg, UCHAR bAlertLevel, UCHAR bAlertDesc)
	{
    ALRT *palrt = (ALRT *) pbAlertMsg;

    FillMemory(palrt, sizeof(ALRT), 0);

	palrt->bCType = SSL3_CT_ALERT;
	palrt->bMajor = SSL3_CLIENT_VERSION_MSB;
//	palrt->bMinor = SSL3_CLIENT_VERSION_LSB; DONE by FillMemory
//	palrt->bcbMSBSize = 0; Done by FillMemory
	palrt->bcbLSBSize = 2;
	palrt->bAlertLevel = bAlertLevel;
	palrt->bAlertDesc  = bAlertDesc ;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\ssl3srv.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ssl3srv.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    05-21-96   ramas   Created
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <ssl2msg.h>
#include <ssl3msg.h>
#include <ssl3key.h>
#include <md5.h>
#include <sha.h>
#include <rsa.h>
#include <ssl2prot.h>
#include <certmap.h>





BOOL
FSSL3(PBYTE pb, BYTE *pchCT);

static DWORD vcbIssuerList = 0x61;

static BYTE  pbPctIssuer[] = {
    0x30, 0x5f, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31,
    0x20, 0x30, 0x1e, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x17, 0x52, 0x53, 0x41, 0x20, 0x44, 0x61,
    0x74, 0x61, 0x20, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x2c, 0x20, 0x49, 0x6e, 0x63,
    0x2e, 0x31, 0x2e, 0x30, 0x2c, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x25, 0x53, 0x65, 0x63, 0x75,
    0x72, 0x65, 0x20, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66,
    0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x74,
    0x79
};


static BYTE  pbClass1Issuer[] =
{
0x30,0x5f,0x31,0x0b,0x30,0x09,0x06,0x03,0x55,0x04,0x06,0x13,0x02,0x55,0x53,0x31,0x17,0x30,
0x15,0x06,0x03,0x55,0x04,0x0a,0x13,0x0e,0x56,0x65,0x72,0x69,0x53,0x69,0x67,0x6e,
0x2c,0x20,0x49,0x6e,0x63,0x2e,0x31,0x37,0x30,0x35,0x06,0x03,0x55,0x04,0x0b,0x13,
0x2e,0x43,0x6c,0x61,0x73,0x73,0x20,0x31,0x20,0x50,0x75,0x62,0x6c,0x69,0x63,0x20,
0x50,0x72,0x69,0x6d,0x61,0x72,0x79,0x20,0x43,0x65,0x72,0x74,0x69,0x66,0x69,0x63,
0x61,0x74,0x69,0x6f,0x6e,0x20,0x41,0x75,0x74,0x68,0x6f,0x72,0x69,0x74,0x79
};

BOOL GetServerIssuer(
    PBYTE    pbIssuer,      // out
    DWORD *  piIssuerLen);          // in, out


SP_STATUS
Ssl3HandleClientFinish(
    PSPContext  pContext,
    PUCHAR      pb,
    DWORD       cbMessage,
    PSPBuffer   pCommOutput
    );
SP_STATUS
Ssl3SrvHandleClientHello(PSPContext  pContext,
			 PSPBuffer  pCommInput,
			 PSPBuffer  pCommOutput);
SP_STATUS
Ssl3SrvHandleUniHello(PSPContext  pContext,
			 PSPBuffer  pCommInput,
			 PSsl2_Client_Hello pHello,
			 PSPBuffer  pCommOutput);

BOOL FGetServerIssuer(
    PBYTE pbIssuer,         // out
    DWORD *pdwIssuer);    // in, out

DWORD CbIssuerLists();

SP_STATUS
Ssl3SrvGenRestart(
    PSPContext         pContext,
    PSPBuffer          pCommOutput);

SP_STATUS
Ssl3SrvGenServerHello(
    PSPContext         pContext,
    PSPBuffer          pCommOutput);


BOOL FBuildSsl3ExchgKeys();
static
BOOL
Ssl3ParseCertificateVerify(PSPContext  pContext, PBYTE pbMessage, INT iMessageLen);

SP_STATUS
BuildHelloRequest
(
PSPContext  pContext,
PSPBuffer  pCommOutput
);

BOOL FInitCertSystem(PSPContext  pContext, BYTE **ppbCert, DWORD *pcbCert);

SP_STATUS EnoughDataCKeyExchg(PBYTE pCommInput, DWORD cbMsg);
SP_STATUS ParseKeyExchgMsg(PSPContext  pContext, PBYTE pCommInput, DWORD cbMsg, DWORD *pcbExchMsg);

static BOOL Ssl3BuildCertificateRequest(
    PSPContext  pContext,   // in
    PBYTE pbMessage,        // out
    DWORD cbIssuerLen,      //in
    DWORD   *pdwMessageLen);// out

void
Ssl3BuildServerHello(PSPContext pContext, PBYTE pb);

void BuildServerHelloDone(PBYTE pb, DWORD cb);

static BOOL Ssl3BuildServerKeyExchange(
    PSPContext  pContext,
    PBYTE pbMessage,                // out
    PINT  piMessageLen) ;           // out

SP_STATUS BuildCCSAndFinishForServer
(
PSPContext  pContext,
PSPBuffer  pCommOutput,
BOOL fDone
);


//--------------------------------------------------------------------------------------------
SP_STATUS WINAPI
Ssl3ServerProtocolHandler(
    PSPContext  pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput,
    PSPBuffer pAppOutput)
{
    SP_STATUS pctRet = 0;
    DWORD cMessageType;
    SWRAP *pswrap;
    DWORD dwStateTransition;
    BOOL fRaw = TRUE;
    SPBuffer MsgInput;
    DWORD cbMsg;
    DWORD cbInputData = 0;
//    PUCHAR pb;
//    UCHAR bCT;
//    BOOL fSsl3;

    SP_BEGIN("Ssl3ServerProtocolHandler");
    if (NULL != pCommOutput)
    {
	pCommOutput->cbData = 0;
    }
    if (NULL != pAppOutput)
    {
	pAppOutput->cbData = 0;
    }


	do
	{
	MsgInput.pvBuffer = (PUCHAR) pCommInput->pvBuffer + cbInputData;
	MsgInput.cbBuffer = pCommInput->cbBuffer;
	MsgInput.cbData = pCommInput->cbData - cbInputData;


	switch(pContext->State & 0xffff)
	{
	    case UNI_STATE_RECVD_UNIHELLO:
	    {
		if(MsgInput.cbData < 3)
		{
		    pctRet = PCT_INT_INCOMPLETE_MSG;
		}
		dwStateTransition = (((PUCHAR) MsgInput.pvBuffer)[2] << 16) |
							  (pContext->State & 0xffff);
			cbInputData = pCommInput->cbData;
		break;
	    }
	    case SSL3_STATE_REDO:
	    case SSL3_STATE_REDO_RESTART:
	    case SP_STATE_CONNECTED:
		  dwStateTransition =  pContext->State & 0xffff;
	      break;
	
	    default:
	    {

                pswrap = (SWRAP *) MsgInput.pvBuffer;
		        cbMsg = COMBINEBYTES(pswrap->bcbMSBSize, pswrap->bcbLSBSize);
		
                if(COMBINEBYTES(pswrap->bMajor, pswrap->bMinor)  < 0x300)
                    {
                        pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
		                break;
                    }
		
		        if (cbMsg > MsgInput.cbData)
	            {
	                return PCT_INT_INCOMPLETE_MSG;
	            }
	            cbInputData += cbMsg + sizeof(SWRAP); //Do One record at one time...
                if(0 != pContext->wS3CipherSuiteClient)
                {
                    pctRet = UnwrapSsl3Message(pContext, &MsgInput);
                }
                else
                {
                	pContext->ReadCounter++;
                }

		switch(((PUCHAR) MsgInput.pvBuffer)[0])
		{
		    case SSL3_CT_CHANGE_CIPHER_SPEC:
			cMessageType = SSL3_CT_CHANGE_CIPHER_SPEC;
			break;
		    case SSL3_CT_HANDSHAKE:
			cMessageType = ((PUCHAR) MsgInput.pvBuffer)[5];
			break;
		    case SSL3_CT_APPLICATIONDATA:
			cMessageType = SSL3_CT_APPLICATIONDATA;
			break;
		  default:
			pctRet = PCT_INT_ILLEGAL_MSG;
			break;
		}

		if (MsgInput.cbData < 5)
		{
		    pctRet = PCT_INT_INCOMPLETE_MSG;
		}

		dwStateTransition = (cMessageType << 16) |
				    (pContext->State & 0xffff);

	    }




	}
	if (pctRet != PCT_ERR_OK)
	{
	    // to handle incomplete message errors
		SP_RETURN(pctRet);
	}

	switch(dwStateTransition)
	{
	
	    case SP_STATE_CONNECTED:
	    // We were called from a connected state, so the app
	    // is requesting a redo.
		    BuildHelloRequest(pContext, pCommOutput);
		    break;

	case SSL3_STATE_REDO:
	    // We processed a client hello from the decrypt handler,
	    // so generate a server hello.
	    pctRet = Ssl3SrvGenServerHello(pContext, pCommOutput);
	    break;

	case SSL3_STATE_REDO_RESTART:
	    // We processed a client hello from the decrypt handler,
	    // so generate a server hello. (restart case)
	    pctRet = Ssl3SrvGenRestart(pContext, pCommOutput);
	    break;

	    case (SSL2_MT_CLIENT_HELLO << 16) | UNI_STATE_RECVD_UNIHELLO:
	    {
		    PSsl2_Client_Hello pSsl2Hello = NULL;

		pctRet = Ssl2UnpackClientHello(pCommInput, &pSsl2Hello);

		if (PCT_ERR_OK == pctRet)
		{
		    pctRet = Ssl3SrvHandleUniHello(
							    pContext,
							    pCommInput,
							    pSsl2Hello,
							    pCommOutput);


		    if (SP_FATAL(pctRet))
		    {
			pContext->State = PCT1_STATE_ERROR;
		    }
		}
		if(NULL != pSsl2Hello)
		{
			    SPExternalFree(pSsl2Hello);
		}
	    }
	    break;

	    case (SSL3_HS_CLIENT_HELLO << 16) :
	    {

		pctRet = Ssl3SrvHandleClientHello(
							pContext,
							pCommInput,
							pCommOutput);


		if (SP_FATAL(pctRet))
		{
		    pContext->State = PCT1_STATE_ERROR;
		}
	    }
	    break;

	    case (SSL3_CT_CHANGE_CIPHER_SPEC << 16) | SSL3_STATE_RESTART_CCS:
		pctRet = Ssl3HandleCCS(
					pContext,
					MsgInput.pvBuffer,
					MsgInput.cbData,
					TRUE);
		// State is set within the function call.
		pContext->State = SSL3_STATE_RESTART_CLI_FINISH;

		break;

	    case (SSL3_CT_CHANGE_CIPHER_SPEC << 16) | SSL3_STATE_CHANGE_CIPHER_SPEC:
		pctRet = Ssl3HandleCCS(
					pContext,
					MsgInput.pvBuffer,
					MsgInput.cbData,
					TRUE);


		break;
	    case (SSL3_HS_FINISHED << 16) | SSL3_STATE_CLIENT_FINISH:
		pctRet = Ssl3HandleClientFinish(
						pContext,
						MsgInput.pvBuffer,
						MsgInput.cbData,
						pCommOutput);
		if (PCT_ERR_OK == pctRet)
		{
		    pContext->State = SP_STATE_CONNECTED;
		    pContext->RipeZombie->fProtocol = SP_PROT_SSL3_SERVER;
		    pContext->Encrypt = Ssl3EncryptMessage;
		    pContext->Decrypt = Ssl3DecryptMessage;
		}
		break;

	    case (SSL3_HS_FINISHED << 16) | SSL3_STATE_RESTART_CLI_FINISH:
		    pctRet = VerifyFinishMsg(pContext, MsgInput.pvBuffer, MsgInput.cbData, TRUE);

		if (PCT_ERR_OK == pctRet)
		{
			pContext->State = SP_STATE_CONNECTED;
		    pContext->RipeZombie->fProtocol = SP_PROT_SSL3_SERVER;
		    pContext->Encrypt = Ssl3EncryptMessage;
		    pContext->Decrypt = Ssl3DecryptMessage;
		}
		break;


	    case (SSL3_HS_CLIENT_KEY_EXCHANGE << 16) | SSL2_STATE_SERVER_HELLO:
	    case ( SSL3_HS_CERTIFICATE << 16) | SSL2_STATE_SERVER_HELLO:
	    pctRet = Ssl3SrvHandleCMKey(pContext,
				(PBYTE)MsgInput.pvBuffer,
				MsgInput.cbData,
				pCommOutput);

            if (SP_FATAL(pctRet))
            {
                pContext->State = PCT1_STATE_ERROR;
            }
           break;
        default:
                DebugLog((DEB_WARN, "Error in protocol, dwStateTransition is %lx\n", dwStateTransition));
                pContext->State = PCT1_STATE_ERROR;
                pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
                if (cMessageType == SSL2_MT_ERROR)
                {
                // BUGBUG: handle an SSL2 error message
                }
                break;
        }
        if(pContext->State == SP_STATE_CONNECTED)
        {
            break;
        }

    } while(pCommInput->cbData - cbInputData) ;

    if (pctRet & PCT_INT_DROP_CONNECTION)
    {
	pContext->State &= ~SP_STATE_CONNECTED;
    }
    // To handle incomplete message errors:
    pCommInput->cbData = cbInputData;
    SP_RETURN(pctRet);
}





SP_STATUS
Ssl3SrvHandleClientHello(PSPContext  pContext,
			 PSPBuffer  pCommInput,
			 PSPBuffer  pCommOutput)
{
    SP_STATUS pctRet = PCT_ERR_ILLEGAL_MESSAGE;
	BOOL                            fRestart = FALSE;
    PBYTE pbMessage = (PBYTE) pCommInput->pvBuffer+sizeof(SWRAP);
    SWRAP *pswrap = (SWRAP *) pCommInput->pvBuffer;
    DWORD dwHandshakeLen;
    DWORD dwMessageLen = (INT) COMBINEBYTES(pswrap->bcbMSBSize, pswrap->bcbLSBSize);




    // Validate handshake type
    if(pbMessage[0] != SSL3_HS_CLIENT_HELLO)
    {
	SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    dwHandshakeLen = ((INT)pbMessage[1] << 16) +
			     ((INT)pbMessage[2] << 8) +
			     (INT)pbMessage[3];
    if( (dwHandshakeLen + sizeof(SHSH)) > dwMessageLen)
    {
	SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    UpdateHandshakeHash(pContext,
					(PUCHAR)pCommInput->pvBuffer+sizeof(SWRAP),
					pCommInput->cbData-sizeof(SWRAP),
					TRUE);

    pbMessage += sizeof(SHSH);

    if(!Ssl3ParseClientHello(pContext, pbMessage, dwHandshakeLen, &fRestart))
    {
	    SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    if(fRestart)
    {
	return Ssl3SrvGenRestart(pContext, pCommOutput);
    }
    else
    {
	return Ssl3SrvGenServerHello(pContext, pCommOutput);
    }
}


SP_STATUS
Ssl3SrvHandleUniHello(PSPContext  pContext,
		      PSPBuffer  pCommInput,
		      PSsl2_Client_Hello pHello,
		      PSPBuffer  pCommOutput)
{
    SP_STATUS   pctRet = PCT_ERR_ILLEGAL_MESSAGE;
//	DWORD       ServerCipher, ClientCipher;
    DWORD ClientCipher;


	UpdateHandshakeHash(pContext,
			(PUCHAR)pCommInput->pvBuffer+sizeof(SSL2_MESSAGE_HEADER),
			pCommInput->cbData-sizeof(SSL2_MESSAGE_HEADER),
			TRUE);


    /* keep challenge around for later */
    CopyMemory( pContext->pChallenge,
		pHello->Challenge,
		pHello->cbChallenge);
    pContext->cbChallenge = pHello->cbChallenge;

    /* Initialize the "Client.random" from the challenge */

    FillMemory(pContext->rgbS3CRandom, CB_SSL3_RANDOM - pContext->cbChallenge, 0);

    CopyMemory(  pContext->rgbS3CRandom + CB_SSL3_RANDOM - pContext->cbChallenge,
		 pContext->pChallenge,
		 pContext->cbChallenge);

	//
	// Calculate common ciphers:
	//
    pContext->wS3pendingCipherSuite = 0;
    // Does the client want this cipher type?
    for (ClientCipher = 0;
	 ClientCipher < pHello->cCipherSpecs ;
	 ClientCipher++ )
    {
	pctRet = Ssl3SelectCipher(pContext, pHello->CipherSpecs[ClientCipher]);
	if(pctRet == PCT_ERR_OK)
	{
	    break;
	}
    }
	//
    if (pctRet != PCT_ERR_OK)
    {
	return( pctRet );
    }
	// Generate the response
    return Ssl3SrvGenServerHello(pContext, pCommOutput);
}


SP_STATUS
Ssl3SrvGenRestart(
    PSPContext          pContext,
    PSPBuffer           pCommOutput)
{
    SP_STATUS   pctRet;
//  BOOL        fExchKey;
    DWORD       cbMessage;
    PUCHAR      pb;
    BOOL        fClientAuth = ((pContext->Flags & CONTEXT_FLAG_CLIAUTH) != 0);
    const CheckSumFunction * pHash = NULL;

    if(pCommOutput == NULL)
    {
	return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }
    pCommOutput->cbData = 0;
    pHash = HashFromSpec(pContext->PendingHashSpec, SP_PROT_SSL3_SERVER);
    if(pHash == NULL)
    {
	return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    // Calculate size of server hello
     cbMessage = sizeof(SWRAP) + // Record Wrapper
	 sizeof(SSH) +        // Server Hello message
	 CB_SLL3_CHANGE_CIPHER_SPEC +
	 CB_SSL3_FINISHED_MSG +
	 pHash->cbCheckSum;


    DebugLog((DEB_TRACE, "Server hello message %x\n", cbMessage));

    pCommOutput->cbData = cbMessage ;
    /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL)
    {
	pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
	if (NULL == pCommOutput->pvBuffer)
	{
	    SP_RETURN(SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY));
	}
	pCommOutput->cbBuffer = pCommOutput->cbData;
    }


    if(pCommOutput->cbData > pCommOutput->cbBuffer)
    {
	SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
    }
    // Generate internal values to make server hello
    GenerateRandomBits(pContext->rgbS3SRandom, CB_SSL3_RANDOM);
    Ssl3MakeMasterKeyBlock(pContext);

    // Build Server Hello
    pb = pCommOutput->pvBuffer;
    pb  +=  sizeof(SWRAP);
    cbMessage -= sizeof(SWRAP);
    Ssl3BuildServerHello(pContext, pb);
    SetWrap(pContext, pCommOutput->pvBuffer, SSL3_CT_HANDSHAKE, sizeof(SSH), FALSE);
    UpdateHandshakeHash(pContext, pb, sizeof(SSH), FALSE);

    pb += sizeof(SSH);
    cbMessage -= sizeof(SSH);

    pContext->WriteCounter = 0;

    pctRet = BuildCCSAndFinishMessage(pContext,
				      pb,
					  cbMessage,
				      FALSE);

    if(pctRet != PCT_ERR_OK)
    {
	return pctRet;
    }
    pContext->State =  SSL3_STATE_RESTART_CCS;
    return(PCT_ERR_OK);

}

SP_STATUS
Ssl3SrvGenServerHello(
    PSPContext         pContext,
    PSPBuffer          pCommOutput)
{
    SP_STATUS   pctRet;
    BOOL        fExchKey = FALSE;
    DWORD       cbMessage;
    DWORD       cbCert, cbCertMsg;
	PUCHAR      pbCert;
    DWORD       dwKeyLen;
    DWORD       dwModulusLen;
    PUCHAR      pb;
    CERT *pcert ;
    DWORD               cbIssuerLists = 0;

    BOOL        fClientAuth = ((pContext->Flags & CONTEXT_FLAG_CLIAUTH) != 0);
    const CheckSumFunction * pHash = NULL;

    if(pCommOutput == NULL)
    {
	return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }
    pCommOutput->cbData = 0;

    pctRet = SPCredPickCertificate(SP_PROT_SSL3_SERVER,
				   pContext->pCred,
				   Ssl3CertRank,
				   Ssl3NumCert,
				   Ssl3CertRank,
				   Ssl3NumCert,
				   &pContext->RipeZombie->pServerCert,
				   &pContext->pPrivateKey);

    if(pctRet != PCT_ERR_OK)
    {
	return pctRet;
    }
    pctRet  = SPSerializeCertificate(SP_PROT_SSL3_SERVER,
				   NULL,
				   &cbCert,
				   pContext->RipeZombie->pServerCert);
    if(pctRet != PCT_ERR_OK)
    {
	return pctRet;
    }

    pHash = HashFromSpec(pContext->PendingHashSpec, SP_PROT_SSL3_SERVER);
    if(pHash == NULL)
    {
	return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    cbMessage = sizeof(SWRAP) + // Record Wrapper
	 sizeof(SSH) +        // Server Hello message
	 sizeof(SHSH) +         // Certificate Message
	 CB_SSL3_CERT_VECTOR +
	 cbCert +
	 sizeof(SHSH);          // Server Hello Done message

    dwKeyLen = (pContext->PendingCiphSpec & SP_CIPHER_STRENGTH) >> SP_CSTR_POS;
    // BUGBUG: Only works for LPBSAFE_PRV_KEY
    dwModulusLen = ((LPBSAFE_PRV_KEY)pContext->pPrivateKey->pKey)->bitlen;

    if(dwKeyLen <= 40 && dwModulusLen > 512)
    {
	    fExchKey = FBuildSsl3ExchgKeys();
	cbMessage += CB_SSL3_MAX_SRV_KEY_EXCHANGE;
    }

    if(fClientAuth)
    {
	pctRet = SPContextGetIssuers(pContext, NULL, &cbIssuerLists);

	if(PCT_ERR_OK != pctRet)
	{
	    return(pctRet);
	}
	cbMessage += cbIssuerLists  + sizeof(CERTREQ);
    }
    pContext->fCertReq = fClientAuth;

    DebugLog((DEB_TRACE, "Server hello message %x\n", cbMessage));

    pCommOutput->cbData = cbMessage ;
    pCommOutput->cbData += (FSsl3Cipher(FALSE)) ? pContext->pCheck->cbCheckSum : 0;
    /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL)
    {
	pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
	if (NULL == pCommOutput->pvBuffer)
	{
	    SP_RETURN(SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY));
	}
	pCommOutput->cbBuffer = pCommOutput->cbData;
    }


    if(pCommOutput->cbData > pCommOutput->cbBuffer)
    {
	SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
    }

    // Generate the session ID (actually previously generated)
    pContext->RipeZombie->cbSessionID = CB_SSL3_SESSION_ID;

    // Generate internal values to make server hello
    GenerateRandomBits(pContext->rgbS3SRandom, CB_SSL3_RANDOM);

    // Build Server Hello
    pb = pCommOutput->pvBuffer;
    pb  +=  sizeof(SWRAP);
    Ssl3BuildServerHello(pContext, pb);
    pb +=sizeof(SSH);

    pcert = (CERT *) pb ;
    pbCert = &pcert->bcbCert24;
    //Handle CertChain....

    pctRet = SPSerializeCertificate(SP_PROT_SSL3_CLIENT,
				    &pbCert,
				    &cbCert,
				    pContext->RipeZombie->pServerCert);
    if(pctRet != PCT_ERR_OK)
    {
	return pctRet;
    }
    cbCertMsg = cbCert + CB_SSL3_CERT_VECTOR;
    SetHandshake(pb,  SSL3_HS_CERTIFICATE, NULL,  (WORD)(cbCertMsg));

    pcert->bcbClist24 = MS24BOF(cbCert);
    pcert->bcbMSBClist = MSBOF(cbCert);
    pcert->bcbLSBClist = LSBOF(cbCert);

    pb += sizeof(SHSH) + cbCertMsg;

    if(fExchKey)
    {
	int wLen;
		Ssl3BuildServerKeyExchange(pContext, pb, &wLen);
		pb += wLen;
		cbMessage -= (CB_SSL3_MAX_SRV_KEY_EXCHANGE - wLen);
	pCommOutput->cbBuffer = pCommOutput->cbData -= (CB_SSL3_MAX_SRV_KEY_EXCHANGE - wLen);
	}
	if(fClientAuth)
	{
	DWORD dwT;
	    Ssl3BuildCertificateRequest(pContext, pb, cbIssuerLists, &dwT);
	pb += dwT;
	}
    BuildServerHelloDone(pb, sizeof(SHSH));
    //Initialize the wrapper..
    UpdateHandshakeHash(pContext, (PUCHAR)pCommOutput->pvBuffer+sizeof(SWRAP), cbMessage-sizeof(SWRAP), FALSE);
    SetWrap(pContext, pCommOutput->pvBuffer, SSL3_CT_HANDSHAKE, cbMessage - sizeof(SWRAP), FALSE);

    pContext->State = SSL2_STATE_SERVER_HELLO;
    return(PCT_ERR_OK);

}

SP_STATUS Ssl3SrvHandleCMKey(PSPContext  pContext,
			      PUCHAR  pbInput,
			      DWORD cbMsg,
			      PSPBuffer  pCommOutput)
{
    SP_STATUS               pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    PUCHAR                                  pb;
//    Ssl2_Client_Master_Key  Key;  //DON"T CHEKIN..
    INT iHandshakeLen;

    pCommOutput->cbData = 0;
    DebugLog((DEB_TRACE, "%3d:Input parameter from SSPI\n", cbMsg));

    do {
	DWORD cbExchgMsg, cbCert;
	CERT *pcert;
//	DWORD cbMessage;
	SWRAP *pswrap = (SWRAP *)pbInput;
	SHSH *pshsh;
	DWORD cbCertMsg;


	pb = pbInput;
	//Check for the Certificate message and send alert that YOU NEED CERTIFICATE...
	pshsh = (SHSH *) ((PBYTE)pbInput + sizeof(SWRAP));
	//IF we expect a Certificate we should error out...
	if(pContext->fCertReq && pshsh->typHS != SSL3_HS_CERTIFICATE)
	{ //Send out the client auth alert require certificate
	    break;
	}


	if(pContext->fCertReq)
	{
	    pcert = (CERT *) (pbInput + sizeof(SWRAP));
	    if(pcert->bcbCert24 != 0x00)
	    {
		    break; //This is NOT YET implemented..
	    }
	    cbCertMsg = COMBINEBYTES(pcert->bcbMSB, pcert->bcbLSB) + sizeof(SHSH);
	    cbCert = COMBINEBYTES(pcert->bcbMSBClist, pcert->bcbLSBClist) | ( pcert->bcbClist24 << 16);
	    UpdateHandshakeHash(pContext, (PUCHAR)pcert, cbCertMsg, FALSE);


	    pctRet = SPLoadCertificate(SP_PROT_SSL3_CLIENT,
					 SP_CERT_X509,
					 (PUCHAR)&pcert->bcbCert24,
					 cbCert,
					 &pContext->RipeZombie->pClientCert,
					 NULL);


	    if(pctRet != PCT_ERR_OK)
		    break;
	    pb += sizeof(SWRAP) + cbCertMsg ;
	}
	pctRet = ParseKeyExchgMsg(pContext, pb, cbMsg, &cbExchgMsg);
	if(pctRet != PCT_ERR_OK)
	{
	    return(pctRet);
	}
	pb += cbExchgMsg;

	if(*pb == SSL3_CT_HANDSHAKE)
	{
	    pb += sizeof(SWRAP);
	}
		// Validate handshake type
	if(pContext->fCertReq)
	{
	    if(pb[0] != SSL3_HS_CERTIFICATE_VERIFY)
	    {
		//Need a better error

		pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
		break;
	    }
	    // Validate handshake length
	    iHandshakeLen = ((INT)pb[1] << 16) +
			    ((INT)pb[2] << 8) +
			    (INT)pb[3];

	    if(!Ssl3ParseCertificateVerify(pContext, pb+sizeof(SHSH), iHandshakeLen))
	    {
		pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
		break;
	    }

	    pctRet = SPContextDoMapping(pContext);

	    if(pctRet != PCT_ERR_OK)
	    {
		break;
	    }

	    UpdateHandshakeHash(pContext, pb, iHandshakeLen + sizeof(SHSH), FALSE);
	    pb += iHandshakeLen + sizeof(SHSH);
	}



		    pContext->State = SSL3_STATE_CHANGE_CIPHER_SPEC;
	return( PCT_ERR_OK );
    } while(TRUE);

    return pctRet;
}



//Build Server hello onto pb... we need to check the boundary condition with cb
void
Ssl3BuildServerHello(PSPContext pContext, PBYTE pb)
{
    SSH *pssh = (SSH *) pb;
    WORD wT = sizeof(SSH) - sizeof(SHSH);

    FillMemory(pssh, sizeof(SSH), 0);
    pssh->typHS = SSL3_HS_SERVER_HELLO;
    pssh->bcbMSB = MSBOF(wT) ;
    pssh->bcbLSB = LSBOF(wT) ;
    pssh->bMajor = SSL3_CLIENT_VERSION_MSB;
    pssh->wCipherSelectedMSB = MSBOF(pContext->wS3pendingCipherSuite);
    pssh->wCipherSelectedLSB = LSBOF(pContext->wS3pendingCipherSuite);
    pssh->cbSessionId = (char)pContext->RipeZombie->cbSessionID;
    CopyMemory(pssh->rgbSessionId, pContext->RipeZombie->SessionID, pContext->RipeZombie->cbSessionID) ;
    //UNDONE: do t_time and convert to unix
    //  t_time - time(NULL);
    //  htonl(&t_time, pssh->rgbTime);
    CopyMemory(pssh->rgbRandom, pContext->rgbS3SRandom, CB_SSL3_RANDOM);
}


	// Server Hello Done
void BuildServerHelloDone(PBYTE pb, DWORD cb)
{
SHSH *pshsh = (SHSH *) pb ;

    SP_BEGIN("BuildServerHelloDone");
    FillMemory(pshsh, sizeof(SHSH), 0);
    pshsh->typHS = SSL3_HS_SERVER_HELLO_DONE;
    SP_END();
}

SP_STATUS
BuildCCSAndFinishForServer
(
PSPContext  pContext,
PSPBuffer  pCommOutput,
BOOL fDone
)
	//Build Change_cipher_spec message and finished message...
{
    // BUILD Change Cipher messages.
    DWORD cbOutMessage =    CB_SLL3_CHANGE_CIPHER_SPEC +  //ChangeCipherSpec.
				CB_SSL3_FINISHED_MSG +
			    pContext->pCheck->cbCheckSum ; //Finished Message;
    cbOutMessage += FSsl3Cipher(FALSE) ? pContext->pCheck->cbCheckSum : 0;
    pCommOutput->cbData = cbOutMessage;

    /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL)
    {
	pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
	if (NULL == pCommOutput->pvBuffer)
	{
	    SP_RETURN(SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY));
	}
	pCommOutput->cbBuffer = pCommOutput->cbData;
    }


    if(pCommOutput->cbData > pCommOutput->cbBuffer)
    {
	SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
    }

    return(BuildCCSAndFinishMessage(pContext,
				    pCommOutput->pvBuffer,
							    cbOutMessage,
				    FALSE));
}


SP_STATUS
EnoughDataCKeyExchg(PBYTE pCommInput, DWORD cbMsg)
    {
    DWORD dwTmp;
    DWORD dwKeyMsg;
	SHSH *pshsh = (SHSH *) ((PBYTE)pCommInput + sizeof(SWRAP));
    DWORD dwEncryptedKey;
    SWRAP *pswrap = (SWRAP *)pCommInput;
    DWORD dwAll;

    dwAll = COMBINEBYTES(pswrap->bcbMSBSize, pswrap->bcbLSBSize) + sizeof(SWRAP);

	dwEncryptedKey = COMBINEBYTES(pshsh->bcbMSB, pshsh->bcbLSB);
	dwKeyMsg = dwEncryptedKey + sizeof(SHSH) + sizeof(SWRAP);
    dwTmp = dwAll + CB_SLL3_CHANGE_CIPHER_SPEC
			    + CB_SSL3_FINISHED_MSG   ; //752 ? client auth cert+certverify
							    //Please don't checkin this.
	if(cbMsg <  dwTmp)
	{ // There could be ChangeCipher spec also
	    DebugLog((DEB_TRACE, "%3d:SIZE reported by SSPI\n", cbMsg));
	    DebugLog((DEB_TRACE, "%3d:SIZE Comparing\n", dwTmp));
		return(PCT_INT_INCOMPLETE_MSG);
	}
    else
	{
	    DebugLog((DEB_TRACE, "%3d:SIZE reported by SSPI\n", dwTmp));
	    return(PCT_ERR_OK);
	}
   }

SP_STATUS
ParseKeyExchgMsg(PSPContext  pContext, PBYTE pCommInput, DWORD cbMsg, DWORD *pcbExchgMsg)
{
    SP_STATUS pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    SHSH *pshsh;
    UCHAR  rgbPreMasterSecret[CB_SSL3_PRE_MASTER_SECRET];
    DWORD dwEncryptedKey;
    DWORD dwDecrypted;
    PBYTE pbEncryptedKey;
    DWORD dwcbWrap = 0;
    PPctPrivateKey pPvtKey;
    const KeyExchangeSystem *KeyExchSys = NULL;
    CheckSumFunction *Check = NULL;

    if(*pCommInput == SSL3_CT_HANDSHAKE)
    {
	pshsh = (SHSH *) ((PBYTE)pCommInput + sizeof(SWRAP));
	dwcbWrap = sizeof(SWRAP);
    }
    else
    {
	pshsh = (SHSH *) pCommInput;
    }
    do
    {
	if(pshsh->typHS != SSL3_HS_CLIENT_KEY_EXCHANGE)
	{
	    break;
	}

	dwEncryptedKey = COMBINEBYTES(pshsh->bcbMSB, pshsh->bcbLSB);
	pbEncryptedKey = pCommInput + (sizeof(SHSH)) + dwcbWrap;


	if(pContext->fExchKey)
	{
		pPvtKey = g_pSsl3Private;
	}
	else
	{
		pPvtKey = pContext->pPrivateKey;
	}
	KeyExchSys = KeyExchangeFromSpec(pContext->PendingExchSpec, SP_PROT_SSL3_CLIENT);
	if(KeyExchSys == NULL)
	{
	    break;
	}

	/* Decrypt the encrypted portion of the master key */
	if (!KeyExchSys->Decrypt(pbEncryptedKey,
				dwEncryptedKey,
				rgbPreMasterSecret,
				&dwDecrypted,
				pPvtKey,
				SP_PROT_SSL3_SERVER))
	{
	    break;
	}
        if(COMBINEBYTES(rgbPreMasterSecret[0], rgbPreMasterSecret[1]) != SSL3_CLIENT_VERSION)
        	break;
	pctRet = PCT_ERR_OK;
	*pcbExchgMsg = dwEncryptedKey + sizeof(SHSH) + dwcbWrap;
	UpdateHandshakeHash(pContext,
			    pCommInput+dwcbWrap,
				    *pcbExchgMsg - dwcbWrap,
			    FALSE);

	Ssl3BuildMasterKeys(pContext, rgbPreMasterSecret);
	Ssl3MakeMasterKeyBlock(pContext);
	    break;
    } while(TRUE);
    return(pctRet);
}




/******************************************************************************
* Ssl3BuildCertificateRequest
*
* Build the CERTIFICATE_REQUEST handshake message.
*/
static BOOL Ssl3BuildCertificateRequest(
    PSPContext pContext,
    PBYTE pbMessage,        // out
    DWORD cbIssuerLen,  //in
    DWORD   *pdwMessageLen)     // out
{
    SP_STATUS       pctRet;
    PBYTE           pbMessageStart = pbMessage;
    PBYTE           pbIssuerLenLoc;
    DWORD           dwBodyLength;
    DWORD           cbIssuerLenLocal = cbIssuerLen;
    PSPCredential   pCred;
//    DWORD           iMapper;
    BOOL            fLocalMap = TRUE;

    //
    // Get server's certificate issuer. For now, this is the only issuer
    // we will accept from the client.
    //

    pCred = pContext->pCred;

    // HandshakeType
    pbMessage[0] = SSL3_HS_CERTIFICATE_REQUEST;
    pbMessage += 1;

    // Skip message body length field (3 bytes)
    pbMessage += 3;

    //
    // enum {
    //     rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
    //     rsa_ephemeral_dh(5), dss_ephemeral_dh(6), fortezza_dms(20), (255)
    // } ClientCertificateType;
    //
    // opaque DistinguishedName<1..2^16-1>;
    //
    // struct {
    //     ClientCertificateType certificate_types<1..2^8-1>;
    //     DistinguishedName certificate_authorities<3..2^16-1>;
    // } CertificateRequest;
    //

    // Certificate type
    pbMessage[0] = 1;       // certificate type vector length
    pbMessage[1] = 1;       // rsa_sign
    pbMessage += 2;

    pbIssuerLenLoc = pbMessage;

    // Issuer name list length (just one entry in list for now)
    pbMessage += 2;

    pctRet = SPContextGetIssuers(pContext, pbMessage, &cbIssuerLenLocal);
    if(PCT_ERR_OK != pctRet)
    {
	return FALSE;
    }
    pbIssuerLenLoc[0] = MSBOF(cbIssuerLenLocal);
    pbIssuerLenLoc[1] = LSBOF(cbIssuerLenLocal);

    pbMessage += cbIssuerLenLocal;

    // Compute message body length (subtract 4 byte header)
    dwBodyLength = pbMessage - pbMessageStart - 4;

    // Fill in message body length field (3 bytes)
    pbMessageStart[1] = (UCHAR) ((dwBodyLength & 0x00ff0000) >> 16);
    pbMessageStart[2] = MSBOF(dwBodyLength);
    pbMessageStart[3] = LSBOF(dwBodyLength);

    *pdwMessageLen = dwBodyLength + 4;

    return TRUE;
}






/*****************************************************************************/
static BOOL Ssl3ParseCertificateVerify(PSPContext  pContext, PBYTE pbMessage, INT iMessageLen)
{
    PBYTE pbMessageStart = pbMessage;
    BYTE  pbInputBlock[SSL3_ENCRYPTED_KEY_SIZE];
    BYTE  pbOutputBlock[SSL3_ENCRYPTED_KEY_SIZE];
    INT   iBlockLen;
    INT   iPadLen;
    INT   i;
    BYTE  rgbHashValue[MD5DIGESTLEN+A_SHA_DIGEST_LEN];
	LPBSAFE_PUB_KEY pk;

    pk  = (LPBSAFE_PUB_KEY)(pContext->RipeZombie->pClientCert->pPublicKey->pKey);

    //
    // digitally-signed struct {
    //     opaque md5_hash[16];
    //     opaque sha_hash[20];
    // } Signature;
    //
    // struct {
    //     Signature signature;
    // } CertificateVerify;
    //
    // CertificateVerify.signature.md5_hash = MD5(master_secret + pad2 +
    //          MD5(handshake_messages + master_secret + pad1));
    //
    // CertificateVerify.signature.sha_hash = SHA(master_secret + pad2 +
    //          SHA(handshake_messages + master_secret + pad1));
    //

    // Signature block length
    iBlockLen = ((INT)pbMessage[0] << 8) + pbMessage[1];
//    if(iBlockLen != (INT)pSslContext->lpClientPublicKey->keylen)
//       {
//          iBlockLen, pSslContext->lpClientPublicKey->keylen);
//          return FALSE;
//        }
    pbMessage += 2;

    // Signature block. Convert to little endian with at least 8 bytes of
    // zero padding at the end.
    FillMemory(pbInputBlock, SSL3_ENCRYPTED_KEY_SIZE, 0);
    ReverseMemCopy(pbInputBlock, pbMessage, iBlockLen);
    pbMessage += iBlockLen;


    // Zero destination buffer
    FillMemory(pbOutputBlock, SSL3_ENCRYPTED_KEY_SIZE, 0);


    // Decrypt signature block, using public key contained in certificate
    if(BSafeEncPublic(pk, pbInputBlock, pbOutputBlock) == FALSE)
    {
	return FALSE;
    }

    // Convert decrypted signature block to little endian.
    ReverseMemCopy(pbInputBlock, pbOutputBlock, iBlockLen);


    // Verify signature block format
    iPadLen = iBlockLen - MD5DIGESTLEN - A_SHA_DIGEST_LEN - 3;
    if(pbInputBlock[0] != 0 || pbInputBlock[1] != 1 ||
       pbInputBlock[2 + iPadLen] != 0)
    {
	return FALSE;
    }
    for(i=0 ; i<iPadLen ; i++)
    {
	    if(pbInputBlock[i + 2] != 0xff)
	    return FALSE;
    }

    // Generate hash values
    ComputeCertVerifyHashes(pContext, rgbHashValue);


    // Verify hash values
    if(memcmp(rgbHashValue, pbInputBlock + iPadLen + 3, MD5DIGESTLEN + A_SHA_DIGEST_LEN))
    {
	return FALSE;
    }

    // Validate message length
//    if(iMessageLen != pbMessage - pbMessageStart)
//    {
//      return FALSE;
//   }

    return TRUE;
}







BOOL
FSSL3(PBYTE pb, BYTE *pchCT)
{
    UCHAR bCT = pb[0];

    *pchCT = bCT;

    // if (major == 3 && minor == 0)
    if (pb[1] == 0x03 && pb[2] == 0x00)
    {
	if (bCT >= 20 && bCT <= 23)             // VOILA! Version 3
	{
	    return(TRUE);
	}
    }
    return(FALSE);
}





/******************************************************************************
* Ssl3BuildServerKeyExchange
*
* Determine if it is necessary to send a SERVER_KEY_EXCHANGE handshake
* message. If so, build the message.
*/
static BOOL Ssl3BuildServerKeyExchange(
    PSPContext  pContext,
    PBYTE pbMessage,                // out
    PINT  piMessageLen)             // out
{
    PBYTE pbMessageStart = pbMessage;
    INT   iBodyLength;
    BYTE  pbModulus[SSL3_ENCRYPTED_KEY_SIZE];
    DWORD   iModulusLen;
    BYTE  pbExponent[4];
    DWORD   iExponentLen;
    PBYTE pbServerParams = NULL;
    INT   iServerParamsLen;
    BYTE  pbInputBlock[SSL3_ENCRYPTED_KEY_SIZE];
    BYTE  pbOutputBlock[SSL3_ENCRYPTED_KEY_SIZE];
    DWORD   iBlockLen;
    INT   iPadLen;
    BYTE  pbMd5HashValue[16];
    BYTE  pbShaHashValue[20];
    LPBSAFE_PUB_KEY pPublicKey = NULL;

    //
    // If we are using an export cipher suite and the certificate
    // has a modulas of more than 512 bits, then we need to send a
    // SERVER_KEY_EXCHANGE message (containing a 512-bit public key)
    // so that the client has something with which to encrypt the
    // PRE_MASTER_KEY.
    //


    // HandshakeType
    pbMessage[0] = SSL3_HS_SERVER_KEY_EXCHANGE;
    pbMessage += 1;

    // Skip message body length field (3 bytes)
    pbMessage += 3;

    //
    // struct {
    //   select (KeyExchangeAlgorithm) {
    //       case diffie_hellman:
    //             ServerDHParams params;
    //             Signature signed_params;
    //       case rsa:
    //             ServerRSAParams params;
    //             Signature signed_params;
    //       case fortezza_dms:
    //             ServerFortezzaParams params;
    //   };
    // } ServerKeyExchange;
    //

    //
    // struct {
    //   opaque rsa_modulus<1..2^16-1>;
    //   opaque rsa_exponent<1..2^16-1>;
    // } ServerRSAParams;
    //

    // Extract modulus from BSAFE public key structure. Add padding byte
    // if necessary.
    pPublicKey = (LPBSAFE_PUB_KEY)g_pSsl3Public->pKey;
    iModulusLen = pPublicKey->bitlen / 8;
    ReverseMemCopy(pbModulus, (PBYTE)(pPublicKey + 1), iModulusLen);
    if(pbModulus[0] & 0x80)
    {
	// Add padding byte
	MoveMemory(pbModulus + 1, pbModulus, iModulusLen);
	pbModulus[0] = 0;
	iModulusLen += 1;
    }

    // Extract exponent from BSAFE public key structure.
    ReverseMemCopy(pbExponent, (PBYTE)&pPublicKey->pubexp, sizeof(DWORD));
    iExponentLen = sizeof(DWORD);
    while(pbExponent[0] == 0)
    {
	iExponentLen--;
	MoveMemory(pbExponent, pbExponent + 1, iExponentLen);
    }

    // Mark start of ServerRSAParams structure.
    // This is used to build hash values.
    pbServerParams = pbMessage;

    // Modulus length
    pbMessage[0] = MSBOF(iModulusLen);
    pbMessage[1] = LSBOF(iModulusLen);
    pbMessage += 2;

	CopyMemory(pbMessage, pbModulus, iModulusLen);
    pbMessage += iModulusLen;

    // Exponent length
    pbMessage[0] = MSBOF(iExponentLen);
    pbMessage[1] = LSBOF(iExponentLen);
    pbMessage += 2;

    // Exponent data
    CopyMemory(pbMessage, pbExponent, iExponentLen);
    pbMessage += iExponentLen;

    // Compute length of ServerRSAParams structure.
    iServerParamsLen = pbMessage - pbServerParams;

    //
    // digitally-signed struct {
    //   select(SignatureAlgorithm) {
    //        case anonymous: struct { };
    //        case rsa:
    //             opaque md5_hash[16];
    //             opaque sha_hash[20];
    //        case dsa:
    //             opaque sha_hash[20];
    //   };
    // } Signature;
    //

    // Generate hash values
    ComputeServerExchangeHashes(pContext, pbServerParams,
				iServerParamsLen,
				pbMd5HashValue,
				pbShaHashValue);



    // Build signature block (in network order)
    iBlockLen = ((LPBSAFE_PRV_KEY)pContext->pPrivateKey->pKey)->bitlen / 8;
    iPadLen = iBlockLen - MD5DIGESTLEN - A_SHA_DIGEST_LEN - 3;
    pbOutputBlock[0] = 0;
    pbOutputBlock[1] = 1;
    FillMemory(pbOutputBlock + 2, iPadLen, 0xff);
    pbOutputBlock[iPadLen + 2] = 0;
    CopyMemory(pbOutputBlock + iPadLen + 3, pbMd5HashValue, MD5DIGESTLEN);
    CopyMemory(pbOutputBlock + iPadLen + 3 + MD5DIGESTLEN, pbShaHashValue, A_SHA_DIGEST_LEN);


    // Convert signature block to little endian (so BSAFE is happy)
    FillMemory(pbInputBlock, SSL3_ENCRYPTED_KEY_SIZE, 0);
    ReverseMemCopy(pbInputBlock, pbOutputBlock, iBlockLen);

    // Encrypt (aka "sign") signature block with (large) private key
    if(!BSafeDecPrivate((LPBSAFE_PRV_KEY)pContext->pPrivateKey->pKey,
			pbInputBlock,
			pbOutputBlock))
	{
	return FALSE;
    }

    // Store block length to message
    pbMessage[0] = MSBOF(iBlockLen);
    pbMessage[1] = LSBOF(iBlockLen);
    pbMessage += 2;

    // Store signature block to message, converting it back to network order
    ReverseMemCopy(pbMessage, pbOutputBlock, iBlockLen);
    pbMessage += iBlockLen;

    // Compute message body length (subtract 4 byte header)
    iBodyLength = pbMessage - pbMessageStart - 4;


	SetHandshake(pbMessageStart,  SSL3_HS_SERVER_KEY_EXCHANGE, NULL,  (WORD)iBodyLength);


    *piMessageLen = iBodyLength + 4;
	pContext->fExchKey = TRUE;
    return TRUE;
}


SP_STATUS
Ssl3HandleClientFinish(
    PSPContext  pContext,
    PUCHAR      pb,
    DWORD       cbMessage,
    PSPBuffer   pCommOutput
    )
{
    SP_STATUS          pctRet;
	SP_BEGIN("Ssl3HandleClientFinish");


    pctRet = VerifyFinishMsg(pContext, pb, cbMessage, TRUE);
	if(pctRet != PCT_ERR_OK)
		return(pctRet);
	pctRet = BuildCCSAndFinishForServer(pContext, pCommOutput, FALSE);
	/* Cache Session Here */
    if(pctRet == PCT_ERR_OK)
    {
	SPCacheAdd(pContext->RipeZombie);
    }
    SP_END();
    return(pctRet);
}


/******************************************************************************
* Ssl3ParseClientHello
*
* This routine parses just the CLIENT_HELLO message itself. The
* handshake crud has already been stripped off.
*/
BOOL Ssl3ParseClientHello
(
PSPContext  pContext,
PBYTE pbMessage,
INT iMessageLen,
BOOL *pfRestart
)
{
    PBYTE pbMessageStart = pbMessage;
    PBYTE pbCliRandom = NULL;
    INT iVersion;
    INT iSessionIdLen;
    INT iCipherSpecLen;
//    INT iCipherSpec;
    INT iCompMethodLen;
    INT iCompMethod;
    INT i;
//	SessCacheItem CachedSession;
    SP_STATUS pctRet = PCT_INT_INTERNAL_ERROR;

    //
    // struct {
    //     ProtocolVersion client_version;
    //     Random random;
    //     SessinoID session_id;
    //     CipherSuite cipher_suites<2..2^16-1>
    //     CompressionMethod compression_methods<1..2^8-1>;
    // } ClientHello;
    //

	*pfRestart = FALSE;


    // ProtocolVersion = client_version;
    iVersion = ((INT)pbMessage[0] << 8) + pbMessage[1];
    if(iVersion < SSL3_CLIENT_VERSION)
    {
		return FALSE;
    }
    pbMessage += 2;

	pbCliRandom = pbMessage;
    // Random random
    CopyMemory(pContext->rgbS3CRandom, pbMessage, CB_SSL3_RANDOM);
	pContext->cbChallenge = CB_SSL3_RANDOM;
    pbMessage += CB_SSL3_RANDOM;

    // SessionID session_id; (length)
    iSessionIdLen = pbMessage[0];
    if(iSessionIdLen > CB_SSL3_SESSION_ID)
    {
		return FALSE;
    }
    pbMessage += 1;
    if ((iSessionIdLen) &&
	(SPCacheRetrieveBySession(SP_PROT_SSL3_SERVER,
				  pbMessage,
				  iSessionIdLen,
				  &pContext->RipeZombie)))
    {
	    CopyMemory(pContext->rgbS3CRandom, pbCliRandom, CB_SSL3_RANDOM);
		DebugLog((DEB_TRACE, "------------TRYING TO DO RESTART---------"));
		*pfRestart = TRUE;
    }
    pbMessage += iSessionIdLen;
    // CipherSuite cipher_suites<2..2^16-1>; (length)
    iCipherSpecLen = ((INT)pbMessage[0] << 8) + pbMessage[1];
    if(iCipherSpecLen % 2)
	{
	    return FALSE;
	}
    pbMessage += 2;

    // CipherSuite cipher_suites<2..2^16-1>;
    pContext->wS3pendingCipherSuite = SSL3_NULL_WITH_NULL_NULL;
    // Does the client want this cipher type?
    for(i = 0 ; i < iCipherSpecLen / 2 ; i++)
    {
	pctRet = Ssl3SelectCipher(pContext, COMBINEBYTES(pbMessage[i*2], pbMessage[(2*i)+1]));
	if(pctRet == PCT_ERR_OK)
	{
	    break;
	}
    }
	//
    if (pctRet != PCT_ERR_OK)
    {
	return( FALSE );
    }


    pbMessage += iCipherSpecLen;
    // CompressionMethod compression_methods<1..2^8-1>; (length)
    iCompMethodLen = pbMessage[0];
    if(iCompMethodLen < 1)
    {
		return FALSE;
    }
    pbMessage += 1;

	for(i = 0 ; i <iCompMethodLen; i++)
	{
		if(pbMessage[i] == 0)
		{
			iCompMethod = 0;
			break;
		}
		
	}
    pbMessage += iCompMethodLen;
    // CompressionMethod compression_methods<1..2^8-1>;
    if(iCompMethod != 0)
    {
		return FALSE;
    }

    // Validate message length
    if(iMessageLen != pbMessage - pbMessageStart)
    {
		return TRUE;
    }

    return TRUE;
}


SP_STATUS
BuildHelloRequest
(
PSPContext  pContext,
PSPBuffer  pCommOutput
)
{
	DWORD cbMessage = sizeof(SHSH) + sizeof(SWRAP) + pContext->pCheck->cbCheckSum;
	PBYTE pb;

	pCommOutput->cbData = cbMessage ;

    if(pCommOutput->pvBuffer == NULL)
    {
	pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
	if (NULL == pCommOutput->pvBuffer)
	{
	    SP_RETURN(SP_LOG_RESULT(PCT_INT_OUT_OF_MEMORY));
	}
	pCommOutput->cbBuffer = pCommOutput->cbData;
    }


    if(pCommOutput->cbData > pCommOutput->cbBuffer)
    {
	SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
    }

	pb = pCommOutput->pvBuffer;
	pb  +=  sizeof(SWRAP);

	FillMemory(pb, sizeof(SHSH), 0);
	pb[0] = SSL3_HS_HELLO_REQUEST;

	SetWrap(pContext, pCommOutput->pvBuffer, SSL3_CT_HANDSHAKE, sizeof(SHSH), FALSE);
    return PCT_ERR_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\sslprot.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology 
* reference implementation, version 1.0
* 
* The Private Communication Technology reference implementation, version 1.0 
* ("PCTRef"), is being provided by Microsoft to encourage the development and 
* enhancement of an open standard for secure general-purpose business and 
* personal communications on open networks.  Microsoft is distributing PCTRef 
* at no charge irrespective of whether you use PCTRef for non-commercial or 
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without 
* warranty of any kind, either express or implied, including, without 
* limitation, the implied warranties or merchantability, fitness for a 
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out 
* of use or performance of PCTRef remains with you.
* 
* Please see the file LICENSE.txt, 
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
* 
* Please see http://pct.microsoft.com/pct/pct.htm for The Private 
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/ 


/* TBD: add redo capability? */

#include <spbase.h>
#include <pct1msg.h>
#include <pct1prot.h>
#include <ssl2msg.h>
#include <ssl2prot.h>


/*****************************************************************************
* 
* Main Protocol Handler
*   This procedure handles the state transitions of the protocol.
*
*
* Inputs -
*         PPctContext pContext   - Current Pct Context
*         PSPBuffer  pCommInput - Input Record from Communication Channel
*         PSPBuffer  pAppInput  - Input from the Application 
*
*
* Outputs -
*         pCommOutput - Pending Output to be sent over the communications channel.
*         pAppOutput  - Data for the app, unpacked. 
*
* Returns - status code
*
* NOTE:  The data streams to and from the protocol handler should work like 
*        this.
*                           _________________
*  Communications -------> | Protocol Handler| ----> Cleartext data to
*  Channel        <------- |_________________| <---- and from the Application
*
*  The surrounding environment should always transmit data in the CommOutput
*  if the count of bytes is greater than zero.  
*  CommInput should contain an input buffer with a count of bytes.  If the
*  data is successfully packaged, then the count of bytes in CommInput will
*  be set to zero.  If the data was not packaged, either due to protocol 
*  messages taking precedence, or due to an error, then the count of bytes
*  will not be changed.  The buffer should then be re-presented to the 
*  handler during the next pass.
*
*****************************************************************************/
SP_STATUS WINAPI SslProtocolHandler(PPctContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pCommOutput,
                              PSPBuffer  pAppOutput)
{
    SP_STATUS      pctRet= 0;
    DWORD           dwStateTransition;
	BOOL           fRaw = TRUE;
    SPBuffer       MsgInput;

    if(pCommOutput) pCommOutput->cbData = 0;
    if(pAppOutput) pAppOutput->cbData = 0;
    /* Protocol handling steps should be listed in most common
    * to least common in order to improve performance 
    */
    MsgInput.pvBuffer = pCommInput->pvBuffer;
    MsgInput.cbBuffer = pCommInput->cbBuffer;
    MsgInput.cbData = pCommInput->cbData;

    /* in the following states, we should decrypt the message */
    switch(pContext->State) {
        case SSL2_STATE_SERVER_VERIFY:
        case SSL2_STATE_CLIENT_MASTER_KEY:
        case SSL2_STATE_CLIENT_FINISH:
        case SSL2_STATE_SERVER_RESTART:
        case SSL2_STATE_CLIENT_RESTART:
            pctRet = Ssl2DecryptMessage(pContext, pCommInput, &MsgInput);
            fRaw = FALSE;
    }
    /* first deal with incoming messages over the comm port, these
    * will protocol related, and take precedence over App messages
    */

    /* We are not connected, so we're doing
     * protocol negotiation of some sort.  All protocol
     * negotiation messages are sent in the clear */
    /* There are no branches in the connecting protocol
     * state transition diagram, besides connection and error,
     * which means that a simple case statement will do */

    /* Do we have enough data to determine what kind of message we have */
#ifdef BUGBUG
    if(MsgInput.cbData < 3) {
        pctRet = Pct1GenerateError(pContext, 
                                  pCommOutput, 
                                  PCT_ERR_ILLEGAL_MESSAGE, 
                                  NULL);

    }
#endif
    if((PCT_ERR_OK == pctRet) && (MsgInput.cbData > (DWORD)(fRaw?3:1))) {        

        /* build a single dword out of the last state and the incoming message
         * to do a case off of */
        if(fRaw) {
            dwStateTransition = (((PUCHAR)MsgInput.pvBuffer)[2]<<16) |
                                  (pContext->State & 0xffff);
        } else {
            dwStateTransition = (((PUCHAR)MsgInput.pvBuffer)[0]<<16) |
                                  (pContext->State & 0xffff);
        }
        switch(dwStateTransition)
        {

#ifndef SCHANNEL_CLIENT_ONLY
            /* Server receives client hello */
            case (SSL2_MT_CLIENT_HELLO << 16) | SP_STATE_NONE:
                {
                    PSsl2_Client_Hello pSsl2Hello;
                    UCHAR fRealSessId = 0;
                    SessCacheItem   CachedSession;

                    /* Attempt to recognize and handle various versions
                     * of client hello, start by trying to unpickle the
                     * most recent version, and then next most recent, until
                     * one unpickles.  Then run the handle code.  We can also put
                     * unpickling and handling code in here for SSL messages */
                    if(PCT_ERR_OK == (pctRet = Ssl2UnpackClientHello(
                                                    &MsgInput,
                                                    &pSsl2Hello))) {
                        pContext->Protocol = CACHE_PROTOCOL_SSL2;
                        pSsl2Hello->cbSessionID = 0;
                        if ((pSsl2Hello->cbSessionID) &&
                            (PctFindSessIdInCache(CACHE_PROTOCOL_SSL2, 
                                                  pSsl2Hello->SessionID, 
                                                  pSsl2Hello->cbSessionID, 
                                                  &CachedSession))) {
                              pctRet = Ssl2SrvGenRestart(pContext,
                                                     pSsl2Hello,
                                                     pCommOutput,
                                                     &CachedSession);
                            if(PCT_ERR_OK == pctRet) {
                                pContext->State = SSL2_STATE_SERVER_RESTART;
                            }

                        } else {
                            pctRet = Ssl2SrvHandleClientHello(pContext,
                                                     &MsgInput,
                                                     pSsl2Hello,
                                                     pCommOutput);
                            if(PCT_ERR_OK == pctRet) {
                                pContext->State = SSL2_STATE_SERVER_HELLO;
                            }
                        }     
                        SPExternalFree(pSsl2Hello);
                    }
                    if(SP_FATAL(pctRet)) {
                        pContext->State = PCT1_STATE_ERROR;
                    } 
                    break;
                }
            case (SSL2_MT_CLIENT_MASTER_KEY << 16) | SSL2_STATE_SERVER_HELLO:
                pctRet = Ssl2SrvHandleCMKey(pContext,
                                            &MsgInput,
                                            pCommOutput);
                if(SP_FATAL(pctRet)) {
                    pContext->State = PCT1_STATE_ERROR;
                } else {
                    if(PCT_ERR_OK == pctRet) {
                        pContext->State = SSL2_STATE_SERVER_VERIFY;
                    } 
                    /* We received a non-fatal error, so the state doesn't
                     * change, giving the app time to deal with this */
                }
                break;
            case (SSL2_MT_CLIENT_FINISHED_V2 << 16) | SSL2_STATE_SERVER_VERIFY:
                pctRet = Ssl2SrvHandleClientFinish(pContext,
                                            &MsgInput,
                                            pCommOutput);
                if(SP_FATAL(pctRet)) {
                    pContext->State = PCT1_STATE_ERROR;
                } else {
                    if(PCT_ERR_OK == pctRet) {
                        pContext->State = SP_STATE_CONNECTED;
                        pContext->Encrypt = Ssl2EncryptMessage;
                        pContext->Decrypt = Ssl2DecryptMessage;
                    } 
                    /* We received a non-fatal error, so the state doesn't
                     * change, giving the app time to deal with this */
                }
                break;
            case (SSL2_MT_CLIENT_FINISHED_V2 << 16) | SSL2_STATE_SERVER_RESTART:
                pctRet = Ssl2SrvFinishClientRestart(pContext,
                                            &MsgInput,
                                            pCommOutput);
                if(SP_FATAL(pctRet)) {
                    pContext->State = PCT1_STATE_ERROR;
                } else {
                    if(PCT_ERR_OK == pctRet) {
                        pContext->State = SP_STATE_CONNECTED;
                        pContext->Encrypt = Ssl2EncryptMessage;
                        pContext->Decrypt = Ssl2DecryptMessage;
                    } 
                    /* We received a non-fatal error, so the state doesn't
                     * change, giving the app time to deal with this */
                }
                break;

#endif /* PCT_CLIENT_ONLY */
            /* Client receives Server hello */
           /* Client receives Server hello */
            case (SSL2_MT_SERVER_HELLO << 16) | SSL2_STATE_CLIENT_HELLO:
                {
                    PSsl2_Server_Hello pHello;
                    /* Attempt to recognize and handle various versions
                     * of Server hello, start by trying to unpickle the
                     * oldest, and the next version, until
                     * one unpickles.  Then run the handle code.  We can also put
                     * unpickling and handling code in here for SSL messages */
                    if(PCT_ERR_OK == (pctRet = Ssl2UnpackServerHello(
                                                &MsgInput,
                                                &pHello))) {

                       pContext->Protocol = CACHE_PROTOCOL_SSL2;
                       if(pHello->SessionIdHit) {
                             pctRet = Ssl2CliHandleServerRestart(pContext,
                                                         &MsgInput,
                                                         pHello,
                                                         pCommOutput);
                            if(PCT_ERR_OK == pctRet) {
                                pContext->State = SSL2_STATE_CLIENT_RESTART;
                            }
                           
                        } else {
                            pctRet = Ssl2CliHandleServerHello(pContext,
                                                         &MsgInput,
                                                         pHello,
                                                         pCommOutput);
                            if(PCT_ERR_OK == pctRet) {
                                pContext->State = SSL2_STATE_CLIENT_MASTER_KEY;
                            }
                        } 
                        SPExternalFree(pHello);

                    }
                    if(SP_FATAL(pctRet)) {
                        pContext->State = PCT1_STATE_ERROR;
                    }
                  
                    break;
                }
            case (SSL2_MT_SERVER_VERIFY << 16) | SSL2_STATE_CLIENT_MASTER_KEY:
                pctRet = Ssl2CliHandleServerVerify(pContext,
                                                 &MsgInput,
                                                 pCommOutput);
                if(PCT_ERR_OK == pctRet) {
                    pContext->State =SSL2_STATE_CLIENT_FINISH;
                } 
                if(SP_FATAL(pctRet)) {
                    pContext->State = PCT1_STATE_ERROR;
                } 
                break;
            case (SSL2_MT_SERVER_VERIFY << 16) | SSL2_STATE_CLIENT_RESTART:
                pctRet = Ssl2CliFinishRestart(pContext,
                                              &MsgInput,
                                              pCommOutput);
                if(PCT_ERR_OK == pctRet) {
                    pContext->State =SSL2_STATE_CLIENT_FINISH;
                } 
                if(SP_FATAL(pctRet)) {
                    pContext->State = PCT1_STATE_ERROR;
                } 
                break;

            case (SSL2_MT_SERVER_FINISHED_V2 << 16) | SSL2_STATE_CLIENT_FINISH:
                pctRet = Ssl2CliHandleServerFinish(pContext,
                                            &MsgInput,
                                            pCommOutput);
                if(SP_FATAL(pctRet)) {
                    pContext->State = PCT1_STATE_ERROR;
                } else {
                    if(PCT_ERR_OK == pctRet) {
                        pContext->State = SP_STATE_CONNECTED;
                        pContext->Encrypt = Ssl2EncryptMessage;
                        pContext->Decrypt = Ssl2DecryptMessage;
                    } 
                    /* We received a non-fatal error, so the state doesn't
                     * change, giving the app time to deal with this */
                }
                break;

            default:
                pContext->State = PCT1_STATE_ERROR;
                {
                    if(((PUCHAR)MsgInput.pvBuffer)[2] == PCT_MSG_ERROR) {
                        /* we received an error message, process it */
                        pctRet = Pct1HandleError(pContext,
                                                 &MsgInput,
                                                 pCommOutput);

                    } else {
                        /* we received an unknown error, generate a 
                         * PCT_ERR_ILLEGAL_MESSAGE */
                        pctRet = Pct1GenerateError(pContext, 
                                                  pCommOutput, 
                                                  PCT_ERR_ILLEGAL_MESSAGE, 
                                                  NULL);
                    }
                }

        }

    }
     if(pctRet & PCT_INT_DROP_CONNECTION) {
        pContext->State &= ~SP_STATE_CONNECTED;
     }
     /* to handle incomplete message errors */
     pCommInput->cbData = MsgInput.cbData;

    return pctRet;
}

SP_STATUS WINAPI SslDecryptHandler(PPctContext pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pAppOutput)
{
    SP_STATUS      pctRet= 0;
    if(pCommInput->cbData > 0) {        
        /* first, we'll handle incoming data packets */
        if((pContext->State & SP_STATE_CONNECTED) && (pContext->Decrypt)) {
            if(PCT_ERR_OK == 
               (pctRet = pContext->Decrypt(pContext, 
                                           pCommInput,   /* message */ 
                                           pAppOutput /* Unpacked Message */
                                ))) {  
                /* look for escapes */
            }

        } else {
			return PCT_INT_ILLEGAL_MSG;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\sslsock.h ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.

Module Name:

    sslsock.h

Abstract:

    WinSock SSL external function prototypes and data declarations.

--*/

#ifndef __SSLSOCK_H__
#define __SSLSOCK_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// SSL PROVIDER_INFO security protocol tag
//

#define SECURITY_PROTOCOL_SSL           0x0001

//
// SSL WSAIoctl control code tags
//

#define SO_SSL_FAMILY                   0x00730000
#define SO_SSL_FAMILY_MASK              0x07ff0000

#define _SO_SSL                         ((2L << 27) | SO_SSL_FAMILY)

// Base SSL WSAIoctl tags
#define _SO_SSL_CAPABILITIES            0x01
#define _SO_SSL_FLAGS                   0x02
#define _SO_SSL_PROTOCOLS               0x03
#define _SO_SSL_CIPHERS                 0x04
#define _SO_SSL_CLIENT_OPTS             0x05
#define _SO_SSL_SERVER_OPTS             0x06
#define _SO_SSL_CLIENT_AUTH_OPTS        0x07
#define _SO_SSL_VALIDATE_CERT_HOOK      0x08
#define _SO_SSL_AUTH_REQUEST_HOOK       0x09
#define _SO_SSL_KEY_EXCH_HOOK           0x0a
#define _SO_SSL_SIGNATURE_HOOK          0x0b
#define _SO_SSL_PERFORM_HANDSHAKE       0x0d
#define _SO_SSL_CONNECTION_INFO         0x0e

// Actual SSL WSAIoctl commands
#define SO_SSL_GET_CAPABILITIES         (IOC_OUT | _SO_SSL | _SO_SSL_CAPABILITIES)
#define SO_SSL_SET_FLAGS                (IOC_IN  | _SO_SSL | _SO_SSL_FLAGS)
#define SO_SSL_GET_FLAGS                (IOC_OUT | _SO_SSL | _SO_SSL_FLAGS)
#define SO_SSL_SET_PROTOCOLS            (IOC_IN  | _SO_SSL | _SO_SSL_PROTOCOLS)
#define SO_SSL_GET_PROTOCOLS            (IOC_OUT | _SO_SSL | _SO_SSL_PROTOCOLS)
#define SO_SSL_SET_CIPHERS              (IOC_IN  | _SO_SSL | _SO_SSL_CIPHERS)
#define SO_SSL_GET_CIPHERS              (IOC_OUT | IOC_IN | _SO_SSL | _SO_SSL_CIPHERS)
#define SO_SSL_SET_CLIENT_OPTS          (IOC_IN  | _SO_SSL | _SO_SSL_CLIENT_OPTS)
#define SO_SSL_GET_CLIENT_OPTS          (IOC_OUT | _SO_SSL | _SO_SSL_CLIENT_OPTS)
#define SO_SSL_SET_SERVER_OPTS          (IOC_IN  | _SO_SSL | _SO_SSL_SERVER_OPTS)
#define SO_SSL_GET_SERVER_OPTS          (IOC_OUT | _SO_SSL | _SO_SSL_SERVER_OPTS)
#define SO_SSL_SET_CLIENT_AUTH_OPTS     (IOC_IN  | _SO_SSL | _SO_SSL_CLIENT_AUTH_OPTS)
#define SO_SSL_GET_CLIENT_AUTH_OPTS     (IOC_OUT | _SO_SSL | _SO_SSL_CLIENT_AUTH_OPTS)
#define SO_SSL_SET_VALIDATE_CERT_HOOK   (IOC_IN  | _SO_SSL | _SO_SSL_VALIDATE_CERT_HOOK)
#define SO_SSL_GET_VALIDATE_CERT_HOOK   (IOC_OUT | _SO_SSL | _SO_SSL_VALIDATE_CERT_HOOK)
#define SO_SSL_SET_AUTH_REQUEST_HOOK    (IOC_IN  | _SO_SSL | _SO_SSL_AUTH_REQUEST_HOOK)
#define SO_SSL_GET_AUTH_REQUEST_HOOK    (IOC_OUT | _SO_SSL | _SO_SSL_AUTH_REQUEST_HOOK)
#define SO_SSL_SET_KEY_EXCH_HOOK        (IOC_IN  | _SO_SSL | _SO_SSL_KEY_EXCH_HOOK)
#define SO_SSL_GET_KEY_EXCH_HOOK        (IOC_OUT | _SO_SSL | _SO_SSL_KEY_EXCH_HOOK)
#define SO_SSL_SET_SIGNATURE_HOOK       (IOC_IN  | _SO_SSL | _SO_SSL_SIGNATURE_HOOK)
#define SO_SSL_GET_SIGNATURE_HOOK       (IOC_OUT | _SO_SSL | _SO_SSL_SIGNATURE_HOOK)
#define SO_SSL_PERFORM_HANDSHAKE        (          _SO_SSL | _SO_SSL_PERFORM_HANDSHAKE)
#define SO_SSL_GET_CONNECTION_INFO      (IOC_OUT | _SO_SSL | _SO_SSL_CONNECTION_INFO)

//
// Error codes to be returned by the hook functions.
//

#define SSL_ERR_OKAY            0
#define SSL_ERR_FAILED          2
#define SSL_ERR_BAD_LEN         3
#define SSL_ERR_BAD_TYPE        4
#define SSL_ERR_BAD_DATA        5
#define SSL_ERR_NO_CERT         6
#define SSL_ERR_BAD_SIG         7
#define SSL_ERR_CERT_EXPIRED    8
#define SSL_ERR_CERT_REVOKED    9
#define SSL_ERR_CERT_UNKNOWN    10
#define SSL_ERR_SIGNATURE       11

//
// Definition copied from <winsock2.h>.
//

#ifndef _tagBLOB_DEFINED
#define _tagBLOB_DEFINED
#define _BLOB_DEFINED
#define _LPBLOB_DEFINED
typedef struct _BLOB {
    ULONG cbSize ;
#ifdef MIDL_PASS
    [size_is(cbSize)] BYTE *pBlobData;
#else  /* MIDL_PASS */
    BYTE *pBlobData ;
#endif /* MIDL_PASS */
} BLOB, *LPBLOB ;
#endif

//
// Declarations for _SO_SSL_CAPABILITIES
//

#define SSL_CAP_CLIENT          0x0001
#define SSL_CAP_SERVER          0x0002
#define SSL_CAP_CLIENT_AUTH     0x0004
#define SSL_CAP_CRYPTOAPI       0x0008

//
// Declarations for _SO_SSL_FLAGS
//

// Provider option flags.
#define SSL_FLAG_SERVER          0x0002
#define SSL_FLAG_AUTH_CLIENT     0x0004
#define SSL_FLAG_DEFER_HANDSHAKE 0x0008

//
// Declarations for _SO_SSL_PROTOCOLS
//

#define SSL_PROTOCOL_PCT1       1
#define SSL_PROTOCOL_SSL2       2
#define SSL_PROTOCOL_SSL3       3

typedef struct _SSLPROTOCOL {
    DWORD dwProtocol;
    DWORD dwVersion;
    DWORD dwFlags;
} SSLPROTOCOL, FAR *LPSSLPROTOCOL;

typedef struct _SSLPROTOCOLS {
    DWORD dwCount;
    SSLPROTOCOL ProtocolList[1];   // array of 'count' structures
} SSLPROTOCOLS, FAR *LPSSLPROTOCOLS;

//
// Declarations for _SO_SSL_CIPHERS
//

typedef struct _SSLCIPHERS {
    DWORD dwProtocol;
    DWORD dwCount;
    DWORD CipherList[1];             // array of 'count' integers
} SSLCIPHERS, FAR *LPSSLCIPHERS;

//
// Declarations for _SO_SSL_CLIENT_OPTS
//

typedef struct _SSLCLIENTOPTS {
    time_t CacheTimeout;
    DWORD  dwCacheEntries;
    DWORD  dwFlags;
} SSLCLIENTOPTS, FAR *LPSSLCLIENTOPTS;

//
// Declarations for _SO_SSL_SERVER_OPTS
//

typedef struct _SSLSERVEROPTS {
    time_t CacheTimeout;
    DWORD  dwCacheEntries;
    DWORD  dwFlags;
} SSLSERVEROPTS, FAR *LPSSLSERVEROPTS;

//
// Declarations for _SO_SSL_CLIENT_AUTH_OPTS
//

typedef struct _SSLCLIENTAUTHOPTS {
    DWORD  dwRequestClientAuth;
    DWORD  dwRedoHandshake;
    DWORD  dwType;
    DWORD  dwIssuerCount;
    LPBLOB pIssuerList;
    DWORD  dwFlags;
} SSLCLIENTAUTHOPTS, FAR *LPSSLCLIENTAUTHOPTS;

//
// Declarations for _SO_SSL_VALIDATE_CERT_HOOK
//

#define SSL_CERT_X509       0x0001
#define SSL_CERT_FLAG_ISSUER_UNKNOWN 0x0001

typedef int (CALLBACK FAR *SSLVALIDATECERTFUNC)(
    DWORD  dwType,          // in
    LPVOID pvArg,           // in
    DWORD  dwChainLen,      // in
    LPBLOB pCertChain,      // in
    DWORD dwFlags);         // in

typedef struct _SSLVALIDATECERTHOOK {
    SSLVALIDATECERTFUNC HookFunc;
    LPVOID pvArg;
} SSLVALIDATECERTHOOK, FAR *LPSSLVALIDATECERTHOOK;

//
// Declarations for _SO_SSL_AUTH_REQUEST_HOOK
//

typedef int (CALLBACK FAR *SSLAUTHREQUESTFUNC)(
    DWORD         dwType,           // in
    LPVOID        pvArg,            // in
    DWORD         dwIssuerCount,    // in
    LPBLOB        pIssuerList,      // in
    DWORD         dwFlags,          // in
    LPDWORD       pdwChainLen,      // out
    LPBLOB        *ppCertChain);    // out

typedef struct _SSLAUTHREQUESTHOOK {
    SSLAUTHREQUESTFUNC HookFunc;
    LPVOID pvArg;
} SSLAUTHREQUESTHOOK, FAR *LPSSLAUTHREQUESTHOOK;

//
// Declarations for _SO_SSL_KEY_EXCH_HOOK
//

#define SSL_EXCH_RSAENCRYPT   1
#define SSL_EXCH_RSADECRYPT   2

typedef int (CALLBACK FAR *SSLKEYEXCHANGEFUNC)(
    DWORD   dwType,           // in
    LPVOID  pvArg,            // in
    LPBYTE  pSource,          // in
    DWORD   dwSourceLen,      // in
    DWORD   dwFlags,          // in
    LPBYTE  pDest,            // out
    LPDWORD pdwDestLen);      // in, out

typedef struct _SSLKEYEXCHANGEHOOK {
    SSLKEYEXCHANGEFUNC HookFunc;
    LPVOID pvArg;
} SSLKEYEXCHANGEHOOK, FAR *LPSSLKEYEXCHANGEHOOK;

//
// Declarations for _SO_SSL_SIGNATURE_HOOK
//

// Values for 'dwType'.
#define SSL_SIGN_RSA_MD2    1
#define SSL_SIGN_RSA_MD5    2
#define SSL_SIGN_RSA_SHA    3
#define SSL_SIGN_RSA_SHAMD5 4

// Values for 'dwFlags'.
#define SSL_SIGN_VERIFY_SIGNATURE   0x00000001
#define SSL_SIGN_PERFORM_HASH       0x00000002

typedef int (CALLBACK FAR *SSLSIGNATUREFUNC)(
    DWORD   dwType,           // in
    LPVOID  pvArg,            // in
    LPBYTE  pSource,          // in
    DWORD   dwSourceLen,      // in
    DWORD   dwFlags,          // in
    LPBYTE  pDest,            // out
    LPDWORD pdwDestLen);      // in, out

typedef struct _SSLSIGNATUREHOOK {
    SSLSIGNATUREFUNC HookFunc;
    LPVOID pvArg;
} SSLSIGNATUREHOOK, FAR *LPSSLSIGNATUREHOOK;

//
// ALG_ID definitions.
//

#ifndef ALGIDDEF

#define ALGIDDEF
typedef unsigned int ALG_ID;

// ALG_ID crackers
#define GET_ALG_CLASS(x)                (x & (7 << 13))
#define GET_ALG_TYPE(x)                 (x & (15 << 9))
#define GET_ALG_SID(x)                  (x & (511))

// Algorithm classes
#define ALG_CLASS_ANY                   (0)
#define ALG_CLASS_SIGNATURE             (1 << 13)
#define ALG_CLASS_MSG_ENCRYPT           (2 << 13)
#define ALG_CLASS_DATA_ENCRYPT          (3 << 13)
#define ALG_CLASS_HASH                  (4 << 13)
#define ALG_CLASS_KEY_EXCHANGE          (5 << 13)

// Algorithm types
#define ALG_TYPE_ANY                    (0)
#define ALG_TYPE_DSS                    (1 << 9)
#define ALG_TYPE_RSA                    (2 << 9)
#define ALG_TYPE_BLOCK                  (3 << 9)
#define ALG_TYPE_STREAM                 (4 << 9)
#define ALG_TYPE_DH                     (5 << 9)
#define ALG_TYPE_SECURECHANNEL          (6 << 9)

// Generic sub-ids
#define ALG_SID_ANY                     (0)

// Some RSA sub-ids
#define ALG_SID_RSA_ANY                 0
#define ALG_SID_RSA_PKCS                1
#define ALG_SID_RSA_MSATWORK            2
#define ALG_SID_RSA_ENTRUST             3
#define ALG_SID_RSA_PGP                 4

// Some DSS sub-ids
//
#define ALG_SID_DSS_ANY                 0
#define ALG_SID_DSS_PKCS                1
#define ALG_SID_DSS_DMS                 2

// Block cipher sub ids
// DES sub_ids
#define ALG_SID_DES                     1
#define ALG_SID_3DES                    3
#define ALG_SID_DESX                    4
#define ALG_SID_IDEA                    5
#define ALG_SID_CAST                    6
#define ALG_SID_SAFERSK64               7
#define ALD_SID_SAFERSK128              8
#define ALG_SID_3DES_112                9
#define ALG_SID_CYLINK_MEK              12

// Fortezza sub-ids
#define ALG_SID_SKIPJACK                10
#define ALG_SID_TEK                     11

// RC2 sub-ids
#define ALG_SID_RC2                     2

// Stream cipher sub-ids
#define ALG_SID_RC4                     1
#define ALG_SID_SEAL                    2

// Diffie-Hellman sub-ids
#define ALG_SID_DH_SANDF                1
#define ALG_SID_DH_EPHEM                2
#define ALG_SID_AGREED_KEY_ANY          3
#define ALG_SID_KEA                     4

// Hash sub ids
#define ALG_SID_MD2                     1
#define ALG_SID_MD4                     2
#define ALG_SID_MD5                     3
#define ALG_SID_SHA                     4
#define ALG_SID_SHA1                    4
#define ALG_SID_MAC                     5
#define ALG_SID_RIPEMD                  6
#define ALG_SID_RIPEMD160               7
#define ALG_SID_SSL3SHAMD5              8

// secure channel sub ids
#define ALG_SID_SSL3_MASTER             1
#define ALG_SID_SCHANNEL_MASTER_HASH    2
#define ALG_SID_SCHANNEL_MAC_KEY        3
#define ALG_SID_PCT1_MASTER             4
#define ALG_SID_SSL2_MASTER             5
#define ALG_SID_TLS1_MASTER             6
#define ALG_SID_SCHANNEL_ENC_KEY        7

// Our example sub-id
#define ALG_SID_EXAMPLE                 80

// algorithm identifier definitions
#define CALG_MD2                (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MD2)
#define CALG_MD4                (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MD4)
#define CALG_MD5                (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MD5)
#define CALG_SHA                (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SHA)
#define CALG_SHA1               (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SHA1)
#define CALG_MAC                (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MAC)
#define CALG_RSA_SIGN           (ALG_CLASS_SIGNATURE | ALG_TYPE_RSA | ALG_SID_RSA_ANY)
#define CALG_DSS_SIGN           (ALG_CLASS_SIGNATURE | ALG_TYPE_DSS | ALG_SID_DSS_ANY)
#define CALG_RSA_KEYX           (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_RSA|ALG_SID_RSA_ANY)
#define CALG_DES                (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_DES)
#define CALG_3DES_112           (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_3DES_112)
#define CALG_3DES               (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_3DES)
#define CALG_RC2                (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_RC2)
#define CALG_RC4                (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_STREAM|ALG_SID_RC4)
#define CALG_SEAL               (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_STREAM|ALG_SID_SEAL)
#define CALG_DH_SF              (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_DH|ALG_SID_DH_SANDF)
#define CALG_DH_EPHEM           (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_DH|ALG_SID_DH_EPHEM)
#define CALG_AGREEDKEY_ANY      (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_DH|ALG_SID_AGREED_KEY_ANY)
#define CALG_KEA_KEYX           (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_DH|ALG_SID_KEA)
#define CALG_HUGHES_MD5         (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_ANY|ALG_SID_MD5)
#define CALG_SKIPJACK           (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_SKIPJACK)
#define CALG_TEK                (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_TEK)
#define CALG_CYLINK_MEK         (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_CYLINK_MEK)
#define CALG_SSL3_SHAMD5        (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SSL3SHAMD5)
#define CALG_SSL3_MASTER        (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_SSL3_MASTER)
#define CALG_SCHANNEL_MASTER_HASH   (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_SCHANNEL_MASTER_HASH)
#define CALG_SCHANNEL_MAC_KEY   (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_SCHANNEL_MAC_KEY)
#define CALG_SCHANNEL_ENC_KEY   (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_SCHANNEL_ENC_KEY)
#define CALG_PCT1_MASTER        (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_PCT1_MASTER)
#define CALG_SSL2_MASTER        (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_SSL2_MASTER)
#define CALG_TLS1_MASTER        (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_TLS1_MASTER)

#endif // !ALGIDDEF

//
// Declarations for _SO_SSL_GET_CONNECTION_INFO
//

typedef struct _SSLCONNECTIONINFO
{
    DWORD   dwProtocol;
    ALG_ID  aiCipher;
    DWORD   dwCipherStrength;
    ALG_ID  aiHash;
    DWORD   dwHashStrength;
    ALG_ID  aiExch;
    DWORD   dwExchStrength;
} SSLCONNECTIONINFO, FAR *PSSLCONNECTIONINFO;

//
// dwProtocol bit array values.
//

#define SSL_PROT_PCT1_SERVER        0x00000001
#define SSL_PROT_PCT1_CLIENT        0x00000002
#define SSL_PROT_SSL2_SERVER        0x00000004
#define SSL_PROT_SSL2_CLIENT        0x00000008
#define SSL_PROT_SSL3_SERVER        0x00000010
#define SSL_PROT_SSL3_CLIENT        0x00000020

#ifdef __cplusplus
}
#endif

#endif //__SSLSOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\sspicred.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cred.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-07-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <security.h>
#include "spsspi.h"

#include "hack.h"

#define lstrcmpiA stricmp

#define LockCredential(p)   EnterCriticalSection(&((PSPCredential) p)->csLock)
#define UnlockCredential(p) LeaveCriticalSection(&((PSPCredential) p)->csLock)

typedef struct _PACKAGEMAP {
    DWORD Type;
    SEC_CHAR SEC_FAR * pszPackageName;
    SEC_WCHAR SEC_FAR * wszPackageName;
} PACKAGEMAP;

const PACKAGEMAP SupportedClientPackages[] = {
    { SP_PROT_UNI_CLIENT, UNISP_NAME_A, UNISP_NAME_W },
#ifdef SCHANNEL_PCT
    { SP_PROT_PCT1_CLIENT, PCT1SP_NAME_A, PCT1SP_NAME_W },
#endif
    { SP_PROT_SSL3_CLIENT, SSL3SP_NAME_A, SSL3SP_NAME_W },
    { SP_PROT_SSL2_CLIENT, SSL2SP_NAME_A, SSL2SP_NAME_W }
};

#ifndef SCHANNEL_CLIENT_ONLY
const PACKAGEMAP SupportedServerPackages[] = {
    { SP_PROT_UNI_SERVER, UNISP_NAME_A, UNISP_NAME_W },
#ifdef SCHANNEL_PCT
    { SP_PROT_PCT1_SERVER, PCT1SP_NAME_A, PCT1SP_NAME_W },
#endif
    { SP_PROT_SSL3_SERVER, SSL3SP_NAME_A, SSL3SP_NAME_W },
    { SP_PROT_SSL2_SERVER, SSL2SP_NAME_A, SSL2SP_NAME_W }
};
#endif    

SECURITY_STATUS SEC_ENTRY
AcquireCredentialsHandleA(
    SEC_CHAR SEC_FAR *          pszPrincipal,       // Name of principal
    SEC_CHAR SEC_FAR *          pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    )
{
    SP_STATUS           pctRet;
    PSPCredential      pCred;
    SCH_CRED            CredData;
    SCH_CRED_PUBLIC_CERTCHAIN  Cert;
    SCH_CRED_SECRET_PRIVKEY    Key;
    PSSL_CREDENTIAL_CERTIFICATE  pSslCert;

    PSCH_CRED_PUBLIC_CERTCHAIN aCerts[1] = {&Cert};
    PSCH_CRED_SECRET_PRIVKEY aKeys[1] = {&Key};

    PVOID               pData;
    DWORD               Type = 0;
    DWORD               i;

    SP_BEGIN("AcquireCredentialsHandleA");

    pData = pAuthData;
    FillMemory(&CredData, sizeof(CredData), 0);
    if(pszPackageName == NULL)
    {
        SP_RETURN(SEC_E_SECPKG_NOT_FOUND);
    }
    if(0 == (fCredentialUse & SECPKG_CRED_INBOUND))
    {
        for(i=0; i< sizeof(SupportedClientPackages)/sizeof(PACKAGEMAP); i++ ) {
            if(!lstrcmpiA(pszPackageName, SupportedClientPackages[i].pszPackageName)) {
                Type = SupportedClientPackages[i].Type;
                break;
            }
        }
    }
    else
    {
#ifndef SCHANNEL_CLIENT_ONLY
        for(i=0; i< sizeof(SupportedServerPackages)/sizeof(PACKAGEMAP); i++ ) {
            if(!lstrcmpiA(pszPackageName, SupportedServerPackages[i].pszPackageName)) {
                Type = SupportedServerPackages[i].Type;
                break;
            }
        }
#endif        
    }
    if(Type == 0) {
        SP_RETURN(SEC_E_SECPKG_NOT_FOUND);
    }

    // HACK to make the old style credentials work
    if((pAuthData) &&
        (fCredentialUse & SECPKG_CRED_INBOUND) &&
        (*(DWORD *)pAuthData != SCH_CRED_VERSION))
    {
        pSslCert = pAuthData;
        pData = &CredData;
        CredData.dwVersion = SCH_CRED_VERSION;
        CredData.cCreds = 1;
        CredData.paSecret = aKeys;
        CredData.paPublic = aCerts;
        Cert.dwType = SCH_CRED_X509_CERTCHAIN;
        Cert.pCertChain = pSslCert->pCertificate + 17;
        Cert.cbCertChain = pSslCert->cbCertificate - 17;

        Key.dwType = SCHANNEL_SECRET_PRIVKEY;
        Key.pPrivateKey = pSslCert->pPrivateKey;
        Key.cbPrivateKey = pSslCert->cbPrivateKey;
        Key.pszPassword = pSslCert->pszPassword;

    }

    pctRet = SPCreateCredential(&pCred,
                                 Type,
                                 pData);

    if (PCT_ERR_OK == pctRet)
    {
        phCredential->dwUpper = (DWORD) pCred;
        phCredential->dwLower = i;
        SP_RETURN(SEC_E_OK);

    }
    SP_RETURN(PctTranslateError(pctRet));
}





SECURITY_STATUS SEC_ENTRY
AcquireCredentialsHandleW(
    SEC_WCHAR SEC_FAR *         pszPrincipal,       // Name of principal
    SEC_WCHAR SEC_FAR *         pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    )
{
    PCHAR   pszAnsiPrincipal;
    PCHAR   szPackage;
    DWORD   cchPackage;
    DWORD   cchPrincipal;
    SECURITY_STATUS scRet;


    if(pszPackageName == NULL) return SEC_E_SECPKG_NOT_FOUND;
    if (pszPrincipal)
    {
        cchPrincipal = lstrlenW(pszPrincipal) + 1;
        pszAnsiPrincipal = SPExternalAlloc(cchPrincipal * sizeof(WCHAR));
        if (pszAnsiPrincipal == NULL)
        {
            return(SEC_E_INSUFFICIENT_MEMORY);
        }

        WideCharToMultiByte(
                    CP_ACP,
                    0,
                    pszPrincipal,
                    cchPrincipal,
                    pszAnsiPrincipal,
                    cchPrincipal * sizeof(WCHAR),
                    NULL,
                    NULL);
    }
    else
    {
        pszAnsiPrincipal = NULL;
    }
    cchPackage = lstrlenW(pszPackageName) + 1;
    szPackage = SPExternalAlloc(cchPackage * sizeof(WCHAR));
    if (szPackage == NULL)
    {
        scRet = SEC_E_INSUFFICIENT_MEMORY;
        goto error;
    }

    WideCharToMultiByte(
                CP_ACP,
                0,
                pszPackageName,
                cchPackage,
                szPackage,
                cchPackage * sizeof(WCHAR),
                NULL,
                NULL);

    scRet = AcquireCredentialsHandleA(
                        pszAnsiPrincipal,
                        szPackage,
                        fCredentialUse,
                        pvLogonId,
                        pAuthData,
                        pGetKeyFn,
                        pvGetKeyArgument,
                        phCredential,
                        ptsExpiry);

    SPExternalFree(szPackage);
error:
    if (pszAnsiPrincipal != NULL)
    {
        SPExternalFree(pszAnsiPrincipal);
    }
    return(scRet);
}


SECURITY_STATUS SEC_ENTRY
FreeCredentialsHandle(
    PCredHandle                 phCredential        // Handle to free
    )
{
    PSPCredential  pCred;

    pCred = ValidateCredentialHandle(phCredential);

    if (pCred)
    {
        SPDereferenceCredential(pCred);
        return(SEC_E_OK);
    }

    return(SEC_E_INVALID_HANDLE);

}

SECURITY_STATUS SEC_ENTRY
QueryCredentialsAttributes(
    PCredHandle phCredential,
    ULONG ulAttribute,
    PVOID pBuffer
    )
{
    PSPCredential   pCred;
    SECURITY_STATUS error = 0;

    pCred = ValidateCredentialHandle(phCredential);

    if (pCred == NULL)
    {
        return (SEC_E_INVALID_HANDLE);
    }

    switch (ulAttribute)
    {
        case SECPKG_ATTR_SUPPORTED_PROTOCOLS:
        {
            PSecPkgCred_SupportedProtocols pProtocols = pBuffer;

            if (pBuffer == NULL)
            {
                error = SEC_E_INVALID_HANDLE;
            }
            else
            {
                pProtocols->grbitProtocol = g_ProtEnabled;
            }

        }
            break;

        default:

            error = SEC_E_INVALID_TOKEN;
            break;
    }

    return (error);
}


PSPCredential
ValidateCredentialHandle(
    PCredHandle     phCred)
{
    BOOL            fReturn;
    PSPCredential  pCred;
    SP_BEGIN("PctpValidateCredentialHandle");

    fReturn = FALSE;

    if (phCred)
    {
#ifdef USE_EXCEPTIONS
        try
        {
#endif
            pCred = (PSPCredential)phCred->dwUpper;
            if(pCred == NULL)
            {
                SP_RETURN(NULL);
            }
            if (pCred->Magic == PCT_CRED_MAGIC)
            {
                fReturn = 1;
            }
#ifdef USE_EXCEPTIONS
        }
#ifdef SECURITY_LINUX
        catch(...)
#else
        except (EXCEPTION_EXECUTE_HANDLER)
#endif
        {
            pCred = NULL;
        }
#endif /* USE_EXCEPTIONS */
    }

    if (fReturn)
    {
        SP_RETURN(pCred);
    }

    SP_RETURN(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\sspictxt.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:   context.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-08-95   RichardW   Created
//  8-13-95   TerenceS   PCTized
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <security.h>
#include <certmap.h>
#include <ssl2msg.h>
#include <ssl3msg.h>
#include <pct1msg.h>
#include <rsa.h>
#include "spsspi.h"

extern BOOLEAN CryptoOk;

#ifndef SECPKG_ATTR_PROTO_INFO

//
// We seem to not have the new sspi.h file yet.  So as to not break any builds,
// we'll just sneak in the missing definitions here.
//

#define SECPKG_ATTR_PROTO_INFO      7
typedef struct _SecPkgContext_ProtoInfoA
{
    SEC_CHAR SEC_FAR * sProtocolName;
    unsigned long majorVersion;
    unsigned long minorVersion;
} SecPkgContext_ProtoInfoA, SEC_FAR * PSecPkgContext_ProtoInfoA;

typedef struct _SecPkgContext_ProtoInfoW
{
    SEC_WCHAR SEC_FAR * sProtocolName;
    unsigned long majorVersion;
    unsigned long minorVersion;
} SecPkgContext_ProtoInfoW, SEC_FAR * PSecPkgContext_ProtoInfoW;

#ifdef UNICODE
#define SecPkgContext_ProtoInfo   SecPkgContext_ProtoInfoW
#define PSecPkgContext_ProtoInfo  PSecPkgContext_ProtoInfoW
#else
#define SecPkgContext_ProtoInfo   SecPkgContext_ProtoInfoA
#define PSecPkgContext_ProtoInfo  PSecPkgContext_ProtoInfoA
#endif

#endif  // !SECPKG_ATTR_PROTO_INFO


typedef struct {
    DWORD dwProtoId;
    LPCSTR szProto;
    DWORD dwMajor;
    DWORD dwMinor;
} PROTO_ID;

const PROTO_ID
rgProts[]
    = {
        { SP_PROT_SSL2_CLIENT, "SSL", 2, 0 },
        { SP_PROT_SSL2_SERVER, "SSL", 2, 0 },
        { SP_PROT_PCT1_CLIENT, "PCT", 1, 0 },
        { SP_PROT_PCT1_SERVER, "PCT", 1, 0 },
        { SP_PROT_SSL3_CLIENT, "SSL", 3, 0 },
        { SP_PROT_SSL3_SERVER, "SSL", 3, 0 }
};

SECURITY_STATUS SEC_ENTRY
InitializeSecurityContextA(
    PCredHandle             phCred,         // Cred to base context
    PCtxtHandle             phContext,      // Existing context (OPT)
    SEC_CHAR SEC_FAR *      pszTargetName,  // Name of target
    unsigned long           fContextReq,    // Context Requirements
    unsigned long           Reserved1,      // Reserved, MBZ
    unsigned long           TargetDataRep,  // Data rep of target
    PSecBufferDesc          pInput,         // Input Buffers
    unsigned long           Reserved2,      // Reserved, MBZ
    PCtxtHandle             phNewContext,   // (out) New Context handle
    PSecBufferDesc          pOutput,        // (inout) Output Buffers
    unsigned long SEC_FAR * pfContextAttr,  // (out) Context attrs
    PTimeStamp              ptsExpiry       // (out) Life span (OPT)
)
{
    PSPContext  pContext = NULL;
    PSPCredential pCred = NULL;
    SPBuffer CommOut;
    SPBuffer CommIn;
    PSecBuffer pInToken = NULL;
    PSecBuffer pOutToken = NULL;
    PSecBuffer pExtra = NULL;
    unsigned long fAttr;
    BOOL fCache;

    DWORD         fContext = CONTEXT_FLAG_CLIENT;
    int i;

    SP_STATUS pctRet = PCT_ERR_OK;

    if (!CryptoOk)
    {
        return (SEC_E_UNSUPPORTED_FUNCTION );
    }

    /* These flags are never allowed */
    if (fContextReq & (ISC_REQ_DELEGATE |
                       ISC_REQ_INTEGRITY |
                       ISC_REQ_PROMPT_FOR_CREDS |
                       ISC_REQ_USE_DCE_STYLE |
                       ISC_REQ_DATAGRAM))
    {
       return SEC_E_UNSUPPORTED_FUNCTION;
    }

    fAttr = ISC_RET_REPLAY_DETECT | ISC_RET_SEQUENCE_DETECT | ISC_RET_CONFIDENTIALITY;

    if(fContextReq & ISC_REQ_MUTUAL_AUTH)
    {
         fAttr |= ISC_RET_MUTUAL_AUTH;
         fContext |= CONTEXT_FLAG_CLIAUTH;
    }
    if (fContextReq & (ISC_REQ_EXTENDED_ERROR))
    {
        fAttr |= ISC_RET_EXTENDED_ERROR;
        fContext |= CONTEXT_FLAG_EXT_ERR;
    }
    if (fContextReq & (ISC_REQ_CONNECTION))
    {
        fAttr |= ISC_RET_CONNECTION;
        fContext |= CONTEXT_FLAG_CONNECTION_MODE;
        if (fContextReq & (ISC_REQ_STREAM))
        {
           return SEC_E_UNSUPPORTED_FUNCTION;
        }
    }
    if (fContextReq & (ISC_REQ_STREAM))
    {
        fAttr |= ISC_RET_STREAM;
    }

    if (fContextReq & (ISC_REQ_USE_SESSION_KEY))
    {
        fAttr |= ISC_RET_USE_SESSION_KEY;
        fContext |= CONTEXT_FLAG_NOCACHE;
    }
    if(fContextReq & (ISC_REQ_USE_SUPPLIED_CREDS)) {
        fAttr |= ISC_REQ_USE_SUPPLIED_CREDS;
        fContext |= CONTEXT_FLAG_NO_INCOMPLETE_CRED_MSG;
    }


    /* Initialize output buffer locations */
    for (i = 0; i < (int)pOutput->cBuffers; i++ )
    {
        switch(pOutput->pBuffers[i].BufferType)
        {
            case SECBUFFER_EMPTY:
                if(!pOutToken)
                    pOutToken = &pOutput->pBuffers[i];
                break;

            case SECBUFFER_TOKEN:
                    pOutToken = &pOutput->pBuffers[i];
                break;
            case SECBUFFER_DATA:
            case SECBUFFER_STREAM_HEADER:
            case SECBUFFER_STREAM_TRAILER:
            default:
                break;
        }
    }
    if (pOutToken == NULL)
    {
        return SEC_E_INVALID_TOKEN;
    }
    pOutToken->BufferType = SECBUFFER_TOKEN;




    if (Reserved2)
    {
        return(SEC_E_UNSUPPORTED_FUNCTION);
    }


    if (fContextReq & ISC_REQ_ALLOCATE_MEMORY)
    {
        fAttr |= ISC_RET_ALLOCATED_MEMORY;
        pOutToken->pvBuffer = NULL;
        pOutToken->cbBuffer = 0;
    }
    else
    {
        if(pOutToken->pvBuffer == NULL)
        {
            return (SEC_E_INVALID_HANDLE);
        }
    }

    CommOut.pvBuffer = pOutToken->pvBuffer;
    CommOut.cbBuffer = pOutToken->cbBuffer;
    CommOut.cbData = 0;


    if(pfContextAttr)
    {
        *pfContextAttr = fAttr;
    }

    if(phContext == NULL)
    {
        pContext = SPContextCreate(pszTargetName);
        if(pContext == NULL)
        {
            return SEC_E_INSUFFICIENT_MEMORY;
        }
        pCred = ValidateCredentialHandle(phCred);

        if(pctRet == PCT_ERR_OK)
        {
            pctRet = SPContextSetCredentials(pContext, pCred);
        }

        if(pctRet != PCT_ERR_OK){
            SPContextDelete(pContext);
           if(phNewContext) phNewContext->dwUpper = 0;
           if(phContext) phContext->dwUpper = 0;
            return PctTranslateError(pctRet);
        }

        //KLUDGE: to make sure that we call with Vanilla SSL2 because of OLD servers
        if(pInput)
        {
            pctRet = (DWORD) SEC_E_UNSUPPORTED_FUNCTION;
            /* Initialize intput buffer locations */
            for (i = 0; i < (int)pInput->cBuffers; i++ )
            {
                switch(pInput->pBuffers[i].BufferType)
                {
                    case SECBUFFER_PKG_PARAMS:
                        pInToken = &pInput->pBuffers[i];
                        break;
                    case SECBUFFER_EMPTY:
                        if(!pExtra)
                        {
                            pExtra = &pInput->pBuffers[i];
                        }
                    break;
                    default:
                        break;
                }
            }

            if (!pInToken)
            {
                return(pctRet);
            }

            if (pInToken->cbBuffer != sizeof(DWORD))
            {
                return(pctRet);
            }
        }

        // use session cache only if target name specified
        fCache = (pszTargetName && pszTargetName[0]); 
        pctRet = pContext->InitiateHello(pContext, &CommOut, fCache);
        if(CommOut.cbBuffer == 0 && pctRet == PCT_INT_BUFF_TOO_SMALL)
            return SEC_E_INSUFFICIENT_MEMORY;
        if(pctRet != PCT_ERR_OK) {
            SPContextDelete(pContext);
            if(phNewContext) phNewContext->dwUpper = 0;
            if(phContext) phContext->dwUpper = 0;
            return PctTranslateError(pctRet);
        }
        phNewContext->dwUpper = (DWORD) pContext;
        /* the following is because there is a requirement with the sspi
         * implementation that the lower word of the context handle be equal
         * to the index of the package in the table returned by EnumerateSecurityPackages
         */

        if(pCred)
        {
            phNewContext->dwLower = phCred->dwLower;
        }
        else
        {
            phNewContext->dwLower = 0;
        }
        pOutToken->pvBuffer = CommOut.pvBuffer;
        pOutToken->cbBuffer = CommOut.cbBuffer;

    }
    else
    {
        /* Initialize intput buffer locations */
        for (i = 0; i < (int)pInput->cBuffers; i++ )
        {
            switch(pInput->pBuffers[i].BufferType)
            {
                case SECBUFFER_TOKEN:
                case SECBUFFER_TOKEN | SECBUFFER_READONLY:
                    pInToken = &pInput->pBuffers[i];
                    break;
                case SECBUFFER_EMPTY:
                    if(!pInToken)
                    {
                        pInToken = &pInput->pBuffers[i];
                    }
                    else if(!pExtra)
                    {
                        pExtra = &pInput->pBuffers[i];
                    }
                break;

                case SECBUFFER_DATA:
                case SECBUFFER_STREAM_HEADER:
                case SECBUFFER_STREAM_TRAILER:
                default:
                    break;
            }
        }
        if(pInToken == NULL)
        {
            return SEC_E_INVALID_TOKEN;
        }
        CommIn.pvBuffer = pInToken->pvBuffer;
        CommIn.cbBuffer = pInToken->cbBuffer;
        CommIn.cbData = pInToken->cbBuffer;

        pContext= ValidateContextHandle(phContext);
        pCred = ValidateCredentialHandle(phCred);

        if(pContext == NULL || pCred == NULL)
        {
            return( SEC_E_INVALID_HANDLE );
        }

        pctRet = SPContextSetCredentials(pContext, pCred);

        pctRet =  pContext->ProtocolHandler(pContext,
                                         &CommIn,
                                         &CommOut,
                                         NULL);
        if(CommOut.cbBuffer == 0 && pctRet == PCT_INT_BUFF_TOO_SMALL) {
            CommOut.pvBuffer = SPExternalAlloc(CommOut.cbData);
            if (NULL == CommOut.pvBuffer)
                return SEC_E_INSUFFICIENT_MEMORY;
            pctRet =  pContext->ProtocolHandler(pContext,
                                         &CommIn,
                                         &CommOut,
                                         NULL);
        }

        if(pctRet == PCT_INT_INCOMPLETE_MSG)
        {
            if(pExtra)
            {
                pExtra->BufferType = SECBUFFER_MISSING;
                pExtra->cbBuffer = CommIn.cbData -  pInToken->cbBuffer;
            }
        } else {
            pOutToken->pvBuffer = CommOut.pvBuffer;
            pOutToken->cbBuffer = CommOut.cbData;
        }

        if(SP_FATAL(pctRet))
        {
           SPContextDelete(pContext);
           if(phNewContext) phNewContext->dwUpper = 0;
           if(phContext) phContext->dwUpper = 0;
        }

        if(PCT_ERR_OK != pctRet)
        {
            return PctTranslateError(pctRet);
        }
        if(CommIn.cbData < pInToken->cbBuffer && pExtra) {
            pExtra->BufferType = SECBUFFER_EXTRA;
            pExtra->cbBuffer = pInToken->cbBuffer - CommIn.cbData;
        }

    }
    return(pContext->State == SP_STATE_CONNECTED?SEC_E_OK:SEC_I_CONTINUE_NEEDED);
}


SECURITY_STATUS SEC_ENTRY
InitializeSecurityContextW(
    PCredHandle             phCredential,   // Cred to base context
    PCtxtHandle             phContext,      // Existing context (OPT)
    SEC_WCHAR SEC_FAR *     pszTargetName,  // Name of target
    unsigned long           fContextReq,    // Context Requirements
    unsigned long           Reserved1,      // Reserved, MBZ
    unsigned long           TargetDataRep,  // Data rep of target
    PSecBufferDesc          pInput,     // Input Buffers
    unsigned long           Reserved2,      // Reserved, MBZ
    PCtxtHandle             phNewContext,   // (out) New Context handle
    PSecBufferDesc          pOutput,        // (inout) Output Buffers
    unsigned long SEC_FAR * pfContextAttr,  // (out) Context attrs
    PTimeStamp              ptsExpiry)      // (out) Life span (OPT)
{
    PCHAR   pszAnsiTarget;
    DWORD   cchTarget;
    SECURITY_STATUS scRet;

    if (pszTargetName != NULL)
    {
        cchTarget = lstrlenW(pszTargetName) + 1;
        pszAnsiTarget = SPExternalAlloc(cchTarget * sizeof(WCHAR));

        if (pszAnsiTarget == NULL)
        {
            return(SEC_E_INSUFFICIENT_MEMORY);
        }

        WideCharToMultiByte(
                    CP_ACP,
                    0,
                    pszTargetName,
                    cchTarget,
                    pszAnsiTarget,
                    cchTarget * sizeof(WCHAR),
                    NULL,
                    NULL);
    }
    else
    {
        pszAnsiTarget = NULL;
    }

    scRet = InitializeSecurityContextA(phCredential,
                                       phContext,
                                       pszAnsiTarget,
                                       fContextReq,
                                       Reserved1,
                                       TargetDataRep,
                                       pInput,
                                       Reserved2,
                                       phNewContext,
                                       pOutput,
                                       pfContextAttr,
                                       ptsExpiry );

    if (pszAnsiTarget != NULL)
    {
        SPExternalFree(pszAnsiTarget);
    }
    return(scRet);
}


SECURITY_STATUS SEC_ENTRY
AcceptSecurityContext(
    PCredHandle             phCred,         // Cred to base context
    PCtxtHandle             phContext,      // Existing context (OPT)
    PSecBufferDesc          pInput,         // Input buffer
    unsigned long           fContextReq,    // Context Requirements
    unsigned long           TargetDataRep,  // Target Data Rep
    PCtxtHandle             phNewContext,   // (out) New context handle
    PSecBufferDesc          pOutput,        // (inout) Output buffers
    unsigned long SEC_FAR * pfContextAttr,  // (out) Context attributes
    PTimeStamp              ptsExpiry       // (out) Life span (OPT)
)
{
    PSPContext  pContext = NULL;
    PSPCredential pCred = NULL;
    SPBuffer CommOut;
    SPBuffer CommIn;
    PSecBuffer pInToken = NULL;
    PSecBuffer pOutToken = NULL;
    PSecBuffer pExtra = NULL;

    // SCHANNEL Contexts always have these req's .
    unsigned long fAttr;

    DWORD         fContext = 0;
    int i;
    SP_STATUS pctRet = PCT_ERR_OK;

    if (!CryptoOk)
    {
        return( SEC_E_UNSUPPORTED_FUNCTION );
    }

    /* These flags are never allowed */
    if (fContextReq & (ASC_REQ_DELEGATE |
                       ASC_REQ_INTEGRITY |
                       ASC_REQ_USE_DCE_STYLE |
                       ASC_REQ_DATAGRAM))
    {
       return SEC_E_UNSUPPORTED_FUNCTION;
    }

    fAttr = ASC_RET_REPLAY_DETECT | ASC_RET_SEQUENCE_DETECT | ASC_RET_CONFIDENTIALITY;

    if(fContextReq & ASC_REQ_MUTUAL_AUTH)
    {
         fAttr |= ASC_RET_MUTUAL_AUTH;
         fContext |= CONTEXT_FLAG_CLIAUTH;
    }
    if (fContextReq & (ASC_REQ_EXTENDED_ERROR))
    {
        fAttr |= ASC_RET_EXTENDED_ERROR;
        fContext |= CONTEXT_FLAG_EXT_ERR;
    }
    if (fContextReq & (ASC_REQ_CONNECTION))
    {
        fAttr |= ASC_RET_CONNECTION;
        fContext |= CONTEXT_FLAG_CONNECTION_MODE;
        if (fContextReq & (ASC_REQ_STREAM))
        {
           return SEC_E_UNSUPPORTED_FUNCTION;
        }
    }
    if (fContextReq & (ASC_REQ_STREAM))
    {
        fAttr |= ASC_RET_STREAM;
    }

    if (fContextReq & (ASC_REQ_USE_SESSION_KEY))
    {
        fAttr |= ASC_RET_USE_SESSION_KEY;
        fContext |= CONTEXT_FLAG_NOCACHE;
    }

    /* Initialize intput buffer locations */
    for (i = 0; i < (int)pInput->cBuffers; i++ )
    {
        switch(pInput->pBuffers[i].BufferType)
        {
            case SECBUFFER_TOKEN:
            case SECBUFFER_TOKEN | SECBUFFER_READONLY:
                pInToken = &pInput->pBuffers[i];
                break;
            case SECBUFFER_EMPTY:
                if(!pInToken)
                {
                    pInToken = &pInput->pBuffers[i];
                }
                else if(!pExtra)
                {
                    pExtra = &pInput->pBuffers[i];
                }
                break;

            case SECBUFFER_DATA:
            case SECBUFFER_STREAM_HEADER:
            case SECBUFFER_STREAM_TRAILER:
            default:
                break;
        }
    }

    /* Initialize output buffer locations */
    for (i = 0; i < (int) pOutput->cBuffers; i++ )
    {
        switch(pOutput->pBuffers[i].BufferType)
        {
            case SECBUFFER_EMPTY:
                if(!pOutToken)
                    pOutToken = &pOutput->pBuffers[i];
                break;
            case SECBUFFER_TOKEN:
                    pOutToken = &pOutput->pBuffers[i];
                break;
            case SECBUFFER_DATA:
            case SECBUFFER_STREAM_HEADER:
            case SECBUFFER_STREAM_TRAILER:
            default:
                break;
        }
    }

    if (pInToken == NULL || pOutToken == NULL)
    {
        return SEC_E_INVALID_TOKEN;
    }
    pOutToken->BufferType = SECBUFFER_TOKEN;

    if(pInToken->BufferType == SECBUFFER_TOKEN)
    {
        CommIn.pvBuffer = pInToken->pvBuffer;
        CommIn.cbBuffer = pInToken->cbBuffer;
        CommIn.cbData = pInToken->cbBuffer;
    }
    else
    {
        CommIn.pvBuffer = NULL;
        CommIn.cbBuffer = 0;
        CommIn.cbData = 0;
    }
    if (fContextReq & ASC_REQ_ALLOCATE_MEMORY)
    {
        fAttr |= ASC_RET_ALLOCATED_MEMORY;
        pOutToken->pvBuffer = NULL;
        pOutToken->cbBuffer = 0;
    }
    else
    {
        if(pOutToken->pvBuffer == NULL)
        {
            return (SEC_E_INVALID_HANDLE);
        }
    }

    CommOut.pvBuffer = pOutToken->pvBuffer;
    CommOut.cbBuffer = pOutToken->cbBuffer;
    CommOut.cbData = 0;

    if (pfContextAttr)
    {
        *pfContextAttr = fAttr;
    }

    if (phContext == NULL)
    {
        pContext = SPContextCreate(NULL);
        if (pContext == NULL)
        {
            return SEC_E_INSUFFICIENT_MEMORY;
        }

    }
    else
    {
        pContext= ValidateContextHandle(phContext);
    }

    pCred = ValidateCredentialHandle(phCred);

    if(pContext == NULL || pCred == NULL)
    {
        return( SEC_E_INVALID_HANDLE );
    }

    pctRet = SPContextSetCredentials(pContext, pCred);

    pContext->Flags = fContext;

    if(pctRet == PCT_ERR_OK)
    {
        pctRet = pContext->ProtocolHandler(pContext, &CommIn, &CommOut, NULL);
    }

    if(phContext == NULL)
    {
        if(pctRet != PCT_ERR_OK)
        {
            SPContextDelete(pContext);
        }
        else
        {
            phNewContext->dwUpper = (DWORD) pContext;

            // The following is because there is a requirement with the sspi
            // implementation that the lower word of the context handle be equal
            // to the index of the package in the table returned by
            // EnumerateSecurityPackages

            if(pCred)
            {
                phNewContext->dwLower = phCred->dwLower;
            }
            else
            {
                phNewContext->dwLower = 0;
            }
        }
    }
    else
    {
        if(SP_FATAL(pctRet))
        {
           SPContextDelete(pContext);
           if(phNewContext) phNewContext->dwUpper = 0;
           if(phContext) phContext->dwUpper = 0;
        }
    }

    if (CommOut.cbBuffer == 0 && pctRet == PCT_INT_BUFF_TOO_SMALL)
    {
        return SEC_E_INSUFFICIENT_MEMORY;
    }
    if (pctRet == PCT_INT_INCOMPLETE_MSG) {
        if(pExtra)
        {
            pExtra->BufferType = SECBUFFER_MISSING;
            pExtra->cbBuffer = CommIn.cbData -  pInToken->cbBuffer;
        }
    } else {
        pOutToken->pvBuffer = CommOut.pvBuffer;
        pOutToken->cbBuffer = CommOut.cbData;
    }

    if (PCT_ERR_OK != pctRet)
    {
       return PctTranslateError(pctRet);
    }
    if (CommIn.cbData < pInToken->cbBuffer && pExtra) {
        pExtra->BufferType = SECBUFFER_EXTRA;
        pExtra->cbBuffer = pInToken->cbBuffer - CommIn.cbData;
    }

    return (pContext->State == SP_STATE_CONNECTED?SEC_E_OK : SEC_I_CONTINUE_NEEDED);
}


SECURITY_STATUS SEC_ENTRY
CompleteAuthToken(
    PCtxtHandle phContext,              // Context to complete
    PSecBufferDesc pToken               // Token to complete
    )
{
    PSPContext  pContext;

    pContext = ValidateContextHandle(phContext);

    if (!pContext)
    {
        return( SEC_E_INVALID_HANDLE );
    }
    return (SEC_E_OK);
}



SECURITY_STATUS SEC_ENTRY
DeleteSecurityContext(
        PCtxtHandle         phContext       // Context to delete
)
{
    PSPContext  pContext;

    pContext = ValidateContextHandle(phContext);

    if (!pContext)
    {
        return( SEC_E_INVALID_HANDLE );
    }

    SPContextDelete( pContext );
    return (SEC_E_OK);
}


SECURITY_STATUS SEC_ENTRY
QueryContextAttributesA(
    PCtxtHandle         phContext,      // Context to query
    unsigned long           ulAttribute,    // Attribute to query
    void SEC_FAR *          pBuffer     // Buffer for attributes
)
{
    PSPContext                  pContext;
    PSecPkgContext_StreamSizes  pStrSizes;
    PSecPkgContext_Lifespan     pLifeSpan;
    PSecPkgContext_NamesA       pNames;
    PSecPkgContext_AuthorityA   pAuthority;
    PSecPkgContext_KeyInfoA     pKeyInfo;
    PPctCertificate             pCert;

    pContext = ValidateContextHandle(phContext);

    if ( !pContext )
    {
        return( SEC_E_INVALID_HANDLE );
    }


    if (0 == (pContext->Flags & CONTEXT_FLAG_CLIENT))
    {
        pCert = pContext->RipeZombie->pClientCert;
    }
    else
    {
        pCert = pContext->RipeZombie->pServerCert;
    }

    switch ( ulAttribute )
    {
        case SECPKG_ATTR_SIZES:
        {
            PSecPkgContext_Sizes        pSizes;
            if (NULL == pContext->pSystem)
            {
                return(SEC_E_INVALID_HANDLE);
            }
            pSizes = (PSecPkgContext_Sizes) pBuffer;
            switch(pContext->RipeZombie->fProtocol)
            {
                case SP_PROT_SSL2_CLIENT:
                case SP_PROT_SSL2_SERVER:
                    pSizes->cbMaxToken = SSL2_MAX_MESSAGE_LENGTH;
                    break;

                case SP_PROT_PCT1_CLIENT:
                case SP_PROT_PCT1_SERVER:
                    pSizes->cbMaxToken = PCT1_MAX_MESSAGE_LENGTH;
                    break;

                case SP_PROT_SSL3_CLIENT:
                case SP_PROT_SSL3_SERVER:
                    pSizes->cbMaxToken = SSL3_MAX_MESSAGE_LENGTH;
                    break;

                default:
                    pSizes->cbMaxToken = 32768;
            }

            pSizes->cbMaxSignature = pCert? pCert->cbSig : 0;
            pSizes->cbBlockSize = pContext->pSystem->BlockSize;
            pSizes->cbSecurityTrailer = pSizes->cbMaxSignature;

            return( SEC_E_OK );
        }
        case SECPKG_ATTR_STREAM_SIZES:
            if (NULL == pContext->pCheck)
            {
                return SEC_E_INVALID_HANDLE;
            }

            pStrSizes = (PSecPkgContext_StreamSizes)pBuffer;
            switch(pContext->RipeZombie->fProtocol)
            {
                case SP_PROT_SSL2_CLIENT:
                case SP_PROT_SSL2_SERVER:
                    pStrSizes->cbHeader = 2 + pContext->pCheck->cbCheckSum;
                    pStrSizes->cbTrailer = 0;
                    break;

                case SP_PROT_PCT1_CLIENT:
                case SP_PROT_PCT1_SERVER:
                    pStrSizes->cbHeader = 2;
                    pStrSizes->cbTrailer = pContext->pCheck->cbCheckSum;
                    break;

                case SP_PROT_SSL3_CLIENT:
                case SP_PROT_SSL3_SERVER:
                    pStrSizes->cbHeader = 5;
                    pStrSizes->cbTrailer = pContext->pCheck->cbCheckSum;
                    break;

                default:
                    pStrSizes->cbHeader = 0;
                    pStrSizes->cbTrailer = 0;
            }

            pStrSizes->cbMaximumMessage = 32768;
            if(pContext->pSystem)
            {
                pStrSizes->cbBlockSize = pContext->pSystem->BlockSize;
            }
            else
            {
                pStrSizes->cbBlockSize = 0;
            }
            pStrSizes->cBuffers = 4;

            return( SEC_E_OK );

        case SECPKG_ATTR_NAMES:
            pNames = (PSecPkgContext_NamesA) pBuffer;

#ifdef FOO
            /* First try to return the NT Auth Name */
            if(pContext->pszAuthName)
            {
                pNames->sUserName = SPExternalAlloc(strlen(pCert->pszSubject) + 1);
                if (NULL == pNames->sUserName)
                {
                    return(SEC_E_INSUFFICIENT_MEMORY);
                }
                strcpy(pNames->sUserName, pContext->pszAuthName);
                return(SEC_E_OK);
            }

            if (NULL == pCert || NULL == pCert->pszSubject)
            {
                return( SEC_E_UNSUPPORTED_FUNCTION );
            }
#endif
            pNames->sUserName = SPExternalAlloc(strlen(pCert->pszSubject) + 1);
            if (NULL == pNames->sUserName)
            {
                return(SEC_E_INSUFFICIENT_MEMORY);
            }
            strcpy(pNames->sUserName, pCert->pszSubject);
            return(SEC_E_OK);

        case SECPKG_ATTR_LIFESPAN:
            if (NULL == pCert)
            {
                return(SEC_E_UNSUPPORTED_FUNCTION);
            }
            pLifeSpan = (PSecPkgContext_Lifespan) pBuffer;

            pLifeSpan->tsStart.QuadPart = *((LONGLONG *) &pCert->ValidFrom);
            pLifeSpan->tsExpiry.QuadPart = *((LONGLONG*) &pCert->ValidUntil);
            return( SEC_E_OK );

        case SECPKG_ATTR_DCE_INFO:
            return( SEC_E_UNSUPPORTED_FUNCTION );

        case SECPKG_ATTR_KEY_INFO:
            if (NULL == pContext->pSystem ||
                NULL == pContext->pCheck ||
                NULL == pContext->pKeyExch)
            {
                return( SEC_E_UNSUPPORTED_FUNCTION );
            }
            if (NULL == pContext->pSystem->pszName ||
                NULL == pContext->pCheck->pszName ||
                NULL == pContext->pKeyExch->pszName)
            {
                return SEC_E_INTERNAL_ERROR;
            }

            pKeyInfo = (PSecPkgContext_KeyInfoA) pBuffer;
            pKeyInfo->KeySize = (pContext->RipeZombie->SessCiphSpec & SP_CIPHER_STRENGTH) >>
                                    SP_CSTR_POS;
            pKeyInfo->EncryptAlgorithm = pContext->RipeZombie->SessCiphSpec;
            pKeyInfo->SignatureAlgorithm = pContext->RipeZombie->SessHashSpec;

            pKeyInfo->sSignatureAlgorithmName = SPExternalAlloc(
                            strlen(pContext->pKeyExch->pszName) +
                            1 +
                            strlen(pContext->pCheck->pszName) +
                            1);

            if (NULL == pKeyInfo->sSignatureAlgorithmName)
            {
                return( SEC_E_INSUFFICIENT_MEMORY );
            }
            strcpy(
                pKeyInfo->sSignatureAlgorithmName,
                pContext->pKeyExch->pszName);
            strcat(pKeyInfo->sSignatureAlgorithmName, "/");
            strcat(
                pKeyInfo->sSignatureAlgorithmName,
                pContext->pCheck->pszName);

            pKeyInfo->sEncryptAlgorithmName = SPExternalAlloc(
                            strlen( pContext->pSystem->pszName ) + 1 );

            if ( pKeyInfo->sEncryptAlgorithmName )
            {
                strcpy( pKeyInfo->sEncryptAlgorithmName,
                        pContext->pSystem->pszName );
            }
            else
            {
                SPExternalFree( pKeyInfo->sSignatureAlgorithmName );
                return( SEC_E_INSUFFICIENT_MEMORY );
            }

            return( SEC_E_OK );

        case SECPKG_ATTR_AUTHORITY:
            if (NULL == pCert)
            {
                return( SEC_E_UNSUPPORTED_FUNCTION );
            }

            pAuthority = (PSecPkgContext_AuthorityA) pBuffer;

            if ( pCert->pszSubject && pCert->szSigningAuthority)
            {
                pAuthority->sAuthorityName = SPExternalAlloc(strlen(pCert->szSigningAuthority) + 1);
                if (pAuthority->sAuthorityName )
                {
                    strcpy(
            pAuthority->sAuthorityName,
            pCert->szSigningAuthority);
                    return( SEC_E_OK );
                }

                return( SEC_E_INSUFFICIENT_MEMORY );
            }

            return( SEC_E_UNSUPPORTED_FUNCTION );

        case SECPKG_ATTR_PROTO_INFO:
            {
                DWORD index;
                PSecPkgContext_ProtoInfoA pProtoInfo
                    = (PSecPkgContext_ProtoInfoA)pBuffer;
                for (index = 0;
                     index < sizeof(rgProts) / sizeof(PROTO_ID);
                     index += 1)
                {
                    if (pContext->RipeZombie->fProtocol == rgProts[index].dwProtoId)
                        break;
                }
                if (index == sizeof(rgProts) / sizeof(PROTO_ID))
                    return( SEC_E_UNSUPPORTED_FUNCTION );

                pProtoInfo->sProtocolName =
                    SPExternalAlloc(strlen(rgProts[index].szProto) + 1);
                if (NULL == pProtoInfo->sProtocolName)
                    return SEC_E_INSUFFICIENT_MEMORY;
                strcpy(pProtoInfo->sProtocolName, rgProts[index].szProto);
                pProtoInfo->majorVersion = rgProts[index].dwMajor;
                pProtoInfo->minorVersion = rgProts[index].dwMinor;
                switch(pContext->RipeZombie->fProtocol)
                {
                    case SP_PROT_PCT1_CLIENT:
                    case SP_PROT_PCT1_SERVER:
                        pProtoInfo->majorVersion = 1;
                        break;
                    case SP_PROT_SSL2_CLIENT:
                    case SP_PROT_SSL2_SERVER:
                        pProtoInfo->majorVersion = 2;
                        break;
                    case SP_PROT_SSL3_CLIENT:
                    case SP_PROT_SSL3_SERVER:
                        pProtoInfo->majorVersion = 3;
                        break;
                }
            }
            return SEC_E_OK;

        case SECPKG_ATTR_ISSUER_LIST:
            {
                PSecPkgContext_IssuerListInfo pIssuerList
                    = (PSecPkgContext_IssuerListInfo)pBuffer;

                if(pBuffer == NULL)
                {
                    return(SEC_E_INVALID_HANDLE);
                }

                pIssuerList->cbIssuerList = pContext->cbIssuerList;
                pIssuerList->pIssuerList = pContext->pbIssuerList;
//                pIssuerList->cbIssuerList = 0;
//                pIssuerList->pIssuerList = NULL;

                return SEC_E_OK;
            }

        case SECPKG_ATTR_REMOTE_CRED:
            {
                PSecPkgContext_RemoteCredenitalInfo pRemoteCred
                    = (PSecPkgContext_RemoteCredenitalInfo)pBuffer;
                PPctCertificate pRemoteCert, pCurCert;
//                SP_STATUS pctRet;

                if(pBuffer == NULL)
                {
                    return(SEC_E_INVALID_HANDLE);
                }


                if (0 == (pContext->Flags & CONTEXT_FLAG_CLIENT))
                {
                    pRemoteCert = pContext->RipeZombie->pClientCert;
                }
                else
                {
                    pRemoteCert = pContext->RipeZombie->pServerCert;
                }

                pRemoteCred->pbCertificateChain = NULL;
                pRemoteCred->cbCertificateChain  = 0;
                pRemoteCred->cCertificates = 0;
                pRemoteCred->fFlags = RCRED_STATUS_NOCRED;

                if(pRemoteCert == NULL)
                {
                    return (SEC_E_OK);
                }

                if(pRemoteCert->pRawCert == NULL ||
                    pRemoteCert->cbRawCert == 0)
                {
                    return(SEC_E_OK);
                }
                pRemoteCred->fFlags |= RCRED_CRED_EXISTS;

                pRemoteCred->pbCertificateChain = pRemoteCert->pRawCert;
                pRemoteCred->cbCertificateChain = pRemoteCert->cbRawCert;
                pRemoteCred->cCertificates = 1;

                pCurCert = pRemoteCert;

                // We perform basically the same loop we do in SPSerializeCertificate
                // to get to the root cert, and then we check to see if it is known.
                while(pCurCert != NULL)
                {
                    if(pCurCert->pIssuerCertificate == pCurCert)
                    {
                        break;
                    }
                    pCurCert = pCurCert->pIssuerCertificate;

                }

                if((pCurCert == NULL) || (pCurCert->fTrusted == FALSE))
                {
                    pRemoteCred->fFlags |= RCRED_STATUS_UNKNOWN_ISSUER;
                }
                pRemoteCred->dwBits = 0;
                switch(pRemoteCert->Spec)
                {
                    case SP_CERT_X509:
                    {
                        BSAFE_PRV_KEY *pk;
                        PctPublicKey  *pKey;
                        pKey = pRemoteCert->pPublicKey;
                        pk = (BSAFE_PRV_KEY *)pKey->pKey;
                        pRemoteCred->dwBits = pk->bitlen;

                    }
                    break;

                }

                return SEC_E_OK;
            }

        case SECPKG_ATTR_LOCAL_CRED:
            {
                PSecPkgContext_LocalCredenitalInfo pLocalCred
                    = (PSecPkgContext_LocalCredenitalInfo)pBuffer;
                PPctCertificate pLocalCert, pCurCert;
//                SP_STATUS pctRet;


                if(pBuffer == NULL)
                {
                    return(SEC_E_INVALID_HANDLE);
                }


                if (0 == (pContext->Flags & CONTEXT_FLAG_CLIENT))
                {
                    pLocalCert = pContext->RipeZombie->pServerCert;
                }
                else
                {
                    pLocalCert = pContext->RipeZombie->pClientCert;
                }

                pLocalCred->pbCertificateChain = NULL;
                pLocalCred->cbCertificateChain  = 0;
                pLocalCred->cCertificates = 0;
                pLocalCred->fFlags = LCRED_STATUS_NOCRED;

                if(pLocalCert == NULL)
                {
                    return (SEC_E_OK);
                }

                if(pLocalCert->pRawCert == NULL ||
                    pLocalCert->cbRawCert == 0)
                {
                    return(SEC_E_OK);
                }
                pLocalCred->fFlags |= LCRED_CRED_EXISTS;


                pLocalCred->pbCertificateChain = pLocalCert->pRawCert;
                pLocalCred->cbCertificateChain = pLocalCert->cbRawCert;
                pLocalCred->cCertificates = 1;
                pCurCert = pLocalCert;
                // We perform basically the same loop we do in SPSerializeCertificate
                // to get to the root cert, and then we check to see if it is known.

                while(pCurCert != NULL)
                {
                    if(pCurCert->pIssuerCertificate == pCurCert)
                    {
                        break;
                    }
                    pCurCert = pCurCert->pIssuerCertificate;

                }

                if((pCurCert == NULL) || (pCurCert->fTrusted == FALSE))
                {
                    pLocalCred->fFlags |= LCRED_STATUS_UNKNOWN_ISSUER;
                }


                pLocalCred->dwBits = 0;
                switch(pLocalCert->Spec)
                {
                    case SP_CERT_X509:
                    {
                        BSAFE_PRV_KEY *pk;
                        PctPublicKey  *pKey;
                        pKey = pLocalCert->pPublicKey;
                        pk = (BSAFE_PRV_KEY *)pKey->pKey;
                        pLocalCred->dwBits = pk->bitlen;

                    }
                    break;

                }

                return SEC_E_OK;
            }

        case SECPKG_ATTR_CONNECTION_INFO:
        {
            PSecPkgContext_ConnectionInfo pResult = pBuffer;

            if (pBuffer == NULL)
            {
                return (SEC_E_INVALID_HANDLE);
            }

            pResult->dwProtocol = pContext->RipeZombie->fProtocol;

            // This is in the correct ALG_ID CALG_XXX format.
            pResult->aiCipher = pContext->pSystem->Type;
            // Need to take this from the CipherInfo struct...
            pResult->dwCipherStrength =
                (pContext->RipeZombie->SessCiphSpec & SP_CIPHER_STRENGTH)
                >> SP_CSTR_POS;

            // This is in the correct ALG_ID CALG_XXX format.
            pResult->aiHash = pContext->pCheck->Type;
            pResult->dwHashStrength = pContext->pCheck->cbCheckSum * 8;

            // How we store it is in the wrong format, but we always know that
            // we use the RSA PKCS1 key exch.
            ASSERT(pContext->pKeyExch->Type == SP_EXCH_RSA_PKCS1);
            pResult->aiExch = CALG_RSA_KEYX;

            // BUGBUG: How do I find the real key exch strength???????
            pResult->dwExchStrength = 512;

            return (SEC_E_OK);
        }
            break;

        default:
            return( SEC_E_INVALID_TOKEN );


    }

    return( SEC_E_INVALID_TOKEN );
}

SECURITY_STATUS SEC_ENTRY
QueryContextAttributesW(
    PCtxtHandle         phContext,      // Context to query
    unsigned long           ulAttribute,    // Attribute to query
    void SEC_FAR *          pBuffer     // Buffer for attributes
)
{
    PSPContext                  pContext;
    PSecPkgContext_NamesW       pNames;
    PSecPkgContext_AuthorityW   pAuthority;
    PSecPkgContext_KeyInfoW     pKeyInfo;
    PPctCertificate             pCert;

    pContext = ValidateContextHandle(phContext);

    if ( !pContext )
    {
        return( SEC_E_INVALID_HANDLE );
    }


    if (0 == (pContext->Flags & CONTEXT_FLAG_CLIENT))
    {
        pCert = pContext->RipeZombie->pClientCert;
    }
    else
    {
        pCert = pContext->RipeZombie->pServerCert;
    }

    switch ( ulAttribute )
    {
        // Non-unicode specific types.
        case SECPKG_ATTR_SIZES:
        case SECPKG_ATTR_STREAM_SIZES:
        case SECPKG_ATTR_LIFESPAN:
        case SECPKG_ATTR_ISSUER_LIST:
        case SECPKG_ATTR_REMOTE_CRED:
        case SECPKG_ATTR_LOCAL_CRED:
        case SECPKG_ATTR_CONNECTION_INFO:
        case SECPKG_ATTR_DCE_INFO:

            return( QueryContextAttributesA( phContext, ulAttribute, pBuffer ) );

        case SECPKG_ATTR_NAMES:
            pNames = (PSecPkgContext_NamesW) pBuffer;

#ifdef FOO
            /* First try to return the NT Auth Name */
            if(pContext->pszAuthName)
            {
                pNames->sUserName = SPExternalAlloc(strlen(pCert->pszSubject) + 1);
                if (NULL == pNames->sUserName)
                {
                    return(SEC_E_INSUFFICIENT_MEMORY);
                }
                strcpy(pNames->sUserName, pContext->pszAuthName);
                return(SEC_E_OK);
            }

            if (NULL == pCert || NULL == pCert->pszSubject)
            {
                return( SEC_E_UNSUPPORTED_FUNCTION );
            }
#endif
            pNames->sUserName = SPExternalAlloc((strlen(pCert->pszSubject) + 1) * sizeof(WCHAR) );
            if (NULL == pNames->sUserName)
            {
                return(SEC_E_INSUFFICIENT_MEMORY);
            }
            mbstowcs(pNames->sUserName, pCert->pszSubject, 
                strlen(pCert->pszSubject) + 1);
            return(SEC_E_OK);


        case SECPKG_ATTR_KEY_INFO:
            if (NULL == pContext->pSystem ||
                NULL == pContext->pCheck ||
                NULL == pContext->pKeyExch)
            {
                return( SEC_E_UNSUPPORTED_FUNCTION );
            }
            if (NULL == pContext->pSystem->pszName ||
                NULL == pContext->pCheck->pszName ||
                NULL == pContext->pKeyExch->pszName)
            {
                return SEC_E_INTERNAL_ERROR;
            }

            pKeyInfo = (PSecPkgContext_KeyInfoW) pBuffer;
            pKeyInfo->KeySize = (pContext->RipeZombie->SessCiphSpec & SP_CIPHER_STRENGTH) >>
                                    SP_CSTR_POS;
            pKeyInfo->EncryptAlgorithm = pContext->RipeZombie->SessCiphSpec;
            pKeyInfo->SignatureAlgorithm = pContext->RipeZombie->SessHashSpec;

            pKeyInfo->sSignatureAlgorithmName = SPExternalAlloc(
                (strlen(pContext->pKeyExch->pszName) + 1 +
                 strlen(pContext->pCheck->pszName) +1) * sizeof(WCHAR));

            if (NULL == pKeyInfo->sSignatureAlgorithmName)
            {
                return( SEC_E_INSUFFICIENT_MEMORY );
            }
            mbstowcs(
                pKeyInfo->sSignatureAlgorithmName,
                pContext->pKeyExch->pszName,
                strlen(pContext->pKeyExch->pszName) + 1);
            // strcat(pKeyInfo->sSignatureAlgorithmName, "/");
            pKeyInfo->sSignatureAlgorithmName[strlen(pContext->pKeyExch->pszName)] = L'/';
            mbstowcs(
                &pKeyInfo->sSignatureAlgorithmName[strlen(pContext->pKeyExch->pszName) + 1],
                pContext->pCheck->pszName,
                strlen(pContext->pCheck->pszName) + 1);

            pKeyInfo->sEncryptAlgorithmName = SPExternalAlloc(
                            (strlen( pContext->pSystem->pszName ) + 1) * sizeof(WCHAR) );

            if ( pKeyInfo->sEncryptAlgorithmName )
            {
                mbstowcs( pKeyInfo->sEncryptAlgorithmName,
                        pContext->pSystem->pszName,
                        strlen(pContext->pSystem->pszName) + 1 );
            }
            else
            {
                SPExternalFree( pKeyInfo->sSignatureAlgorithmName );
                return( SEC_E_INSUFFICIENT_MEMORY );
            }

            return( SEC_E_OK );

        case SECPKG_ATTR_AUTHORITY:
            if (NULL == pCert)
            {
                return( SEC_E_UNSUPPORTED_FUNCTION );
            }

            pAuthority = (PSecPkgContext_Authority) pBuffer;

            if ( pCert->pszSubject && pCert->szSigningAuthority)
            {
                pAuthority->sAuthorityName = SPExternalAlloc(
                    (strlen(pCert->szSigningAuthority) + 1) * sizeof(WCHAR));
                if (pAuthority->sAuthorityName )
                {
                    mbstowcs(
                        pAuthority->sAuthorityName,
                        pCert->szSigningAuthority,
                        strlen(pCert->szSigningAuthority) + 1);
                    return( SEC_E_OK );
                }

                return( SEC_E_INSUFFICIENT_MEMORY );
            }

            return( SEC_E_UNSUPPORTED_FUNCTION );

        case SECPKG_ATTR_PROTO_INFO:
        {
            DWORD index;
            PSecPkgContext_ProtoInfoW pProtoInfo
                = (PSecPkgContext_ProtoInfoW)pBuffer;
            for (index = 0;
                 index < sizeof(rgProts) / sizeof(PROTO_ID);
                 index += 1)
            {
                if (pContext->RipeZombie->fProtocol == rgProts[index].dwProtoId)
                    break;
            }
            if (index == sizeof(rgProts) / sizeof(PROTO_ID))
                return( SEC_E_UNSUPPORTED_FUNCTION );

            pProtoInfo->sProtocolName = SPExternalAlloc(
                (strlen(rgProts[index].szProto) + 1) * sizeof(WCHAR));
            if (NULL == pProtoInfo->sProtocolName)
                return SEC_E_INSUFFICIENT_MEMORY;
            mbstowcs(pProtoInfo->sProtocolName, 
                rgProts[index].szProto,
                strlen(rgProts[index].szProto) + 1);
            pProtoInfo->majorVersion = rgProts[index].dwMajor;
            pProtoInfo->minorVersion = rgProts[index].dwMinor;
            switch(pContext->RipeZombie->fProtocol)
            {
                case SP_PROT_PCT1_CLIENT:
                case SP_PROT_PCT1_SERVER:
                    pProtoInfo->majorVersion = 1;
                    break;
                case SP_PROT_SSL2_CLIENT:
                case SP_PROT_SSL2_SERVER:
                    pProtoInfo->majorVersion = 2;
                    break;
                case SP_PROT_SSL3_CLIENT:
                case SP_PROT_SSL3_SERVER:
                    pProtoInfo->majorVersion = 3;
                    break;
            }
        }
            return SEC_E_OK;

        default:
            return( SEC_E_INVALID_TOKEN );


    }

    return( SEC_E_INVALID_TOKEN );
}



SECURITY_STATUS SEC_ENTRY
ImpersonateSecurityContext(
    PCtxtHandle         phContext       // Context to impersonate
)
{
#ifndef XBOX
    PSPContext  pContext;
    HANDLE hToken;

    pContext = ValidateContextHandle( phContext );
    if ( !pContext )
    {
         return( SEC_E_INVALID_HANDLE );
    }

    if((NULL == pContext->RipeZombie->phMapper) ||
       (NULL == pContext->RipeZombie->phMapper->m_vtable))
    {
        return( SEC_E_NO_IMPERSONATION );
    }

    if(!pContext->RipeZombie->phMapper->m_vtable->GetAccessToken(pContext->RipeZombie->phMapper,
                                                       pContext->RipeZombie->hLocator,
                                                       &hToken))
    {
        return (SEC_E_NO_IMPERSONATION);
    }
    if(hToken == NULL)
    {
        return( SEC_E_NO_IMPERSONATION );
    }

    if(!ImpersonateLoggedOnUser(hToken))
    {
        return(GetLastError());
    }

    return(SEC_E_OK);
#else // !UNDER_CE
    return (SEC_E_NO_IMPERSONATION);
#endif // UNDER_CE
}




SECURITY_STATUS SEC_ENTRY
RevertSecurityContext(
    PCtxtHandle         phContext       // Context from which to re
)
{
#ifndef XBOX
    PSPContext  pContext;

    pContext = ValidateContextHandle( phContext );

    if ( pContext )
    {
        if((NULL == pContext->RipeZombie->phMapper) ||
           (NULL == pContext->RipeZombie->phMapper->m_vtable))
        {
            return( SEC_E_NO_IMPERSONATION );
        }
        if(!RevertToSelf())
        {
            return(GetLastError());
        }
        return(SEC_E_OK);
    }

    return( SEC_E_INVALID_HANDLE );
#else // !UNDER_CE
    return (SEC_E_NO_IMPERSONATION);
#endif // UNDER_CE
}

SECURITY_STATUS SEC_ENTRY
ApplyControlToken(
    PCtxtHandle                 phContext,          // Context to modify
    PSecBufferDesc              pInput              // Input token to apply
    )
{
    PSPContext  pContext;

    pContext = ValidateContextHandle(phContext);

    if (!pContext)
    {
        return( SEC_E_INVALID_HANDLE );
    }

    return(SEC_E_UNSUPPORTED_FUNCTION);
}

#if 0

SECURITY_STATUS SEC_ENTRY
QuerySecurityContextToken(
    PCtxtHandle phContext,
    void SEC_FAR * Token
    )
{
    PSPContext  pContext;

    pContext = ValidateContextHandle( phContext );

    if (!pContext)
    {
        return( SEC_E_INVALID_HANDLE );
    }

    if((NULL == pContext->RipeZombie->phMapper) ||
       (NULL == pContext->RipeZombie->phMapper->m_vtable))
    {
        *((HANDLE *)Token) = NULL;
        return SEC_E_OK;
    }

    pContext->RipeZombie->phMapper->m_vtable->GetAccessToken(pContext->RipeZombie->phMapper,
                                                       pContext->RipeZombie->hLocator,
                                                       Token);

    return SEC_E_OK;
}

#else // !UNDER_CE

SECURITY_STATUS SEC_ENTRY
QuerySecurityContextToken(
    PCtxtHandle phContext,
    void SEC_FAR * SEC_FAR * Token
    )
{
    PSPContext  pContext;

    pContext = ValidateContextHandle( phContext );

    if (!pContext)
    {
        return( SEC_E_INVALID_HANDLE );
    }

    if((NULL == pContext->RipeZombie->phMapper) ||
       (NULL == pContext->RipeZombie->phMapper->m_vtable))
    {
        **((HANDLE **)Token) = NULL;
        return SEC_E_OK;
    }

    pContext->RipeZombie->phMapper->m_vtable->GetAccessToken(pContext->RipeZombie->phMapper,
                                                       pContext->RipeZombie->hLocator,
                                                       Token);

    return SEC_E_OK;
}

#endif // !UNDER_CE


/************************************************************************
* PSPContext  ValidateContextHandle(PCtxtHandle phContext)
*
* Derive a valid context pointer from a context handle
*
\***********************************************************************/
PSPContext
ValidateContextHandle(PCtxtHandle phContext)
{
    BOOL        fReturn;
    PSPContext  pContext;


    fReturn = FALSE;
    if (phContext)
    {

#ifdef USE_EXCEPTIONS
        try
#endif
        {
            pContext = (PSPContext )phContext->dwUpper;
            if(pContext == NULL)
            {
                return (NULL);
            }


            if (pContext->Magic == SP_CONTEXT_MAGIC)
            {
                fReturn = TRUE;
            }
        }
#ifdef USE_EXCEPTIONS
#ifdef SECURITY_LINUX
        catch(...)
#else
        except(EXCEPTION_EXECUTE_HANDLER);
#endif
        {
            pContext = NULL;
        }
#endif

    }

    if (fReturn)
    {
        return (pContext);
    }

    return (NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\sslsp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       sslsp.h
//
//  Contents:   Public Definitions for SSL Security Provider
//
//  Classes:
//
//  Functions:
//
//  History:    8-04-95   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __SSLSP_H__
#define __SSLSP_H__




#define SSLSP_NAME_A    "Microsoft SSL"
#define SSLSP_NAME_W    L"Microsoft SSL"

#ifdef UNICODE
#define SSLSP_NAME  SSLSP_NAME_W
#else
#define SSLSP_NAME  SSLSP_NAME_A
#endif

#define SSLSP_RPC_ID    12


typedef struct _SSL_CREDENTIAL_CERTIFICATE {
    DWORD   cbPrivateKey;
    PBYTE   pPrivateKey;
    DWORD   cbCertificate;
    PBYTE   pCertificate;
    PSTR    pszPassword;
} SSL_CREDENTIAL_CERTIFICATE, * PSSL_CREDENTIAL_CERTIFICATE;

#define NETWORK_DREP    0x00000000

BOOL
SslGenerateKeyPair(
    PSSL_CREDENTIAL_CERTIFICATE pCerts,
    PSTR pszDN,
    PSTR pszPassword,
    DWORD Bits );


VOID
SslGenerateRandomBits(
    PUCHAR      pRandomData,
    LONG        cRandomData
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\wscntl.h ===
/**********************************************************************/
/**                        Microsoft Windows                         **/
/**Copyright (c) 1993-2000 Microsoft Corporation.  All rights reserved.**/
/**********************************************************************/

/*
    wscntl.h

    private include file for the WsControl API in the Windows Sockets implementation.


*/


#ifndef _WSCNTL_H_
#define _WSCNTL_H_


//
//  Function prototypes.
//

DWORD
FAR PASCAL
WsControl(
    DWORD   Protocol,
    DWORD   Action,
    LPVOID  InputBuffer,
    LPDWORD InputBufferLength,
    LPVOID  OutputBuffer,
    LPDWORD OutputBufferLength
    );

typedef DWORD (FAR PASCAL * LPWSCONTROL)( DWORD   Protocol,
                                          DWORD   Action,
                                          LPVOID  InputBuffer,
                                          LPDWORD InputBufferLength,
                                          LPVOID  OutputBuffer,
                                          LPDWORD OutputBufferLength );


//
//  Ws Control action codes.
//

#define WSCNTL_TCPIP_QUERY_INFO             0x00000000
#define WSCNTL_TCPIP_SET_INFO               0x00000001
#define WSCNTL_TCPIP_ICMP_ECHO              0x00000002
#define WSCNTL_TCPIP_TEST                   0x00000003
#define WSCNTL_AFD_INFO						0x00000004
#define WSCNTL_AFD_GATHER_RAND              0x00000005


// For WSCNTL_AFD_INFO
// All selections must fit in the mask.
#define WSCNTL_AFD_INFO_MASK				0x0000ffff
#define	WSCNTL_AFD_INFO_LOCK				0x00000001
#define WSCNTL_AFD_INFO_SOCK				0x00000002
#define WSCNTL_AFD_INFO_CONN				0x00000004
#define WSCNTL_AFD_INFO_ENDP				0x00000008
#define WSCNTL_AFD_INFO_BUFFER				0x00000010
#define WSCNTL_AFD_IRDA_INFO				0x00000020
#define WSCNTL_AFD_CXPORT_INFO				0x00000040

// Option bits.
#define WSCNTL_AFD_INFO_VERBOSE				0x80000000


#endif  // _WSCNTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\stubs.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       stubs.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-01-95   RichardW   Created
//
//----------------------------------------------------------------------------


#include <spbase.h>
#include <security.h>
#include "spsspi.h"
#include <cert509.h>


const CHAR CertTag[ 13 ] = { 0x04, 0x0b, 'c', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e' };

const SecurityFunctionTableW SPFunctionTable = {
    SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION,
    EnumerateSecurityPackagesW,
    NULL,
    AcquireCredentialsHandleW,
    FreeCredentialsHandle,
    NULL,
    InitializeSecurityContextW,
    AcceptSecurityContext,
    CompleteAuthToken,
    DeleteSecurityContext,
    ApplyControlToken,
    QueryContextAttributesW,
    ImpersonateSecurityContext,
    RevertSecurityContext,
    MakeSignature,
    VerifySignature,
    FreeContextBuffer,
    QuerySecurityPackageInfoW,
    SealMessage,
    UnsealMessage,
    NULL, /* GrantProxyW */
    NULL, /* RevokeProxyW */
    NULL, /* InvokeProxyW */
    NULL, /* RenewProxyW */
    QuerySecurityContextToken
    };

const SecurityFunctionTableA SPFunctionTableA = {
    SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION,
    EnumerateSecurityPackagesA,
    NULL,
    AcquireCredentialsHandleA,
    FreeCredentialsHandle,
    NULL,
    InitializeSecurityContextA,
    AcceptSecurityContext,
    CompleteAuthToken,
    DeleteSecurityContext,
    ApplyControlToken,
    QueryContextAttributesA,
    ImpersonateSecurityContext,
    RevertSecurityContext,
    MakeSignature,
    VerifySignature,
    FreeContextBuffer,
    QuerySecurityPackageInfoA,
    SealMessage,
    UnsealMessage,
    NULL, /* GrantProxyA */
    NULL, /* RevokeProxyA */
    NULL, /* InvokeProxyA */
    NULL, /* RenewProxyA */
    QuerySecurityContextToken
    };


PSecurityFunctionTableW SEC_ENTRY
InitSecurityInterfaceW(
    VOID )
{
    return((PSecurityFunctionTableW)&SPFunctionTable);
}

PSecurityFunctionTableA SEC_ENTRY
InitSecurityInterfaceA(
    VOID )
{
    return((PSecurityFunctionTableA)&SPFunctionTableA);
}



SECURITY_STATUS SEC_ENTRY
FreeContextBuffer(
    void SEC_FAR *      pvContextBuffer
    )
{
    SPExternalFree( pvContextBuffer );
    return(SEC_E_OK);
}



SECURITY_STATUS SEC_ENTRY
SecurityPackageControl(
    SEC_WCHAR SEC_FAR *      pszPackageName,
    unsigned long           dwFunctionCode,
    unsigned long           cbInputBuffer,
    unsigned char SEC_FAR * pbInputBuffer,
    unsigned long SEC_FAR * pcbOutputBuffer,
    unsigned char SEC_FAR * pbOutputBuffer)
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

SECURITY_STATUS PctTranslateError(SP_STATUS spRet)
{
    switch(spRet) {
        case PCT_ERR_OK: return SEC_E_OK;
        case PCT_ERR_BAD_CERTIFICATE: return SEC_E_INVALID_TOKEN;
        case PCT_ERR_CLIENT_AUTH_FAILED: return SEC_E_INVALID_TOKEN;
        case PCT_ERR_ILLEGAL_MESSAGE: return SEC_E_INVALID_TOKEN;
        case PCT_ERR_INTEGRITY_CHECK_FAILED: return SEC_E_MESSAGE_ALTERED;
        case PCT_ERR_SERVER_AUTH_FAILED: return SEC_E_INVALID_TOKEN;
        case PCT_ERR_SPECS_MISMATCH: return SEC_E_INVALID_TOKEN;
        case PCT_ERR_SSL_STYLE_MSG: return SEC_E_INVALID_TOKEN;
        case PCT_ERR_INCOMPLETE_CREDS: return SEC_I_INCOMPLETE_CREDENTIALS;
        case PCT_ERR_RENEGOTIATE: return SEC_I_RENEGOTIATE;
        case PCT_ERR_UNKNOWN_CREDENTIAL: return SEC_E_UNKNOWN_CREDENTIALS;


        case PCT_INT_BAD_CERT: return SEC_E_INVALID_TOKEN;
        case PCT_INT_CLI_AUTH: return SEC_E_INVALID_TOKEN;
        case PCT_INT_ILLEGAL_MSG: return  SEC_E_INVALID_TOKEN;
        case PCT_INT_INCOMPLETE_MSG: return SEC_E_INCOMPLETE_MESSAGE;
        case PCT_INT_MSG_ALTERED: return SEC_E_MESSAGE_ALTERED;
        case PCT_INT_INTERNAL_ERROR: return SEC_E_INTERNAL_ERROR;
        case PCT_INT_DATA_OVERFLOW: return SEC_E_INTERNAL_ERROR;
        case PCT_INT_INCOMPLETE_CREDS: return SEC_E_INCOMPLETE_CREDENTIALS;
        case PCT_INT_RENEGOTIATE: return SEC_I_RENEGOTIATE;
        case PCT_INT_UNKNOWN_CREDENTIAL: return SEC_E_UNKNOWN_CREDENTIALS;
        default: return SEC_E_INTERNAL_ERROR;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   SslGenerateRandomBits
//
//  Synopsis:   Hook for setup to get a good random stream
//
//  Arguments:  [pRandomData] --
//              [cRandomData] --
//
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
WINAPI
SslGenerateRandomBits(
    PUCHAR      pRandomData,
    LONG        cRandomData
    )
{
        GenerateRandomBits(pRandomData, (ULONG)cRandomData);
}

//+---------------------------------------------------------------------------
//
//  Function:   SslGetDefaultIssuers
//
//  Synopsis:   Get a list of the default issuers
//
//  Arguments:  [pRandomData] --
//              [cRandomData] --
//
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI SslGetDefaultIssuers(
    PBYTE pbIssuers,
    DWORD *pcbIssuers)
{
     return  GetDefaultIssuers(pbIssuers, pcbIssuers);
}

//+---------------------------------------------------------------------------
//
//  Function:   SslGenerateKeyPair
//
//  Synopsis:   Generates a public/private key pair, protected by password
//
//  Arguments:  [pCerts]      --
//              [pszDN]       --
//              [pszPassword] --
//              [Bits]        --
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
SslGenerateKeyPair(
    PSSL_CREDENTIAL_CERTIFICATE pCerts,
    PSTR pszDN,
    PSTR pszPassword,
    DWORD Bits )
{

#ifdef SCHANNEL_EXPORT
    if ( Bits > 512 )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return( FALSE );
    }
#endif
    return GenerateKeyPair(pCerts, pszDN, pszPassword, Bits);
}


//+---------------------------------------------------------------------------
//
//  Function:   SslGetMaximumKeySize
//
//  Synopsis:   Returns maximum public key size
//
//  Arguments:  [Reserved] --
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
SslGetMaximumKeySize(
    DWORD   Reserved )
{

#ifdef SCHANNEL_EXPORT
    return( 512 );
#else
    return( 2048 );
#endif

}


//+---------------------------------------------------------------------------
//
//  Function:   SslFreeCertificate
//
//  Synopsis:   Frees a certificate created from SslCrackCertificate
//
//  Arguments:  [pCertificate] --
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
WINAPI
SslFreeCertificate(
    PX509Certificate    pCertificate)
{
    if ( pCertificate )
    {

        if (pCertificate->pszSubject)
        {
                SPExternalFree(pCertificate->pszSubject);
        }

        if (pCertificate->pszIssuer)
        {
                SPExternalFree(pCertificate->pszIssuer);
        }

        SPExternalFree(pCertificate);

    }
}

extern BOOL WINAPI
X509DecodeCertificate(
    PUCHAR              pbCertificate,
    DWORD               cbCertificate,
    PPctCertificate *   ppCertificate);

extern BOOL WINAPI
X509DeleteCert(
    PPctCertificate pCertificate
    );

//+---------------------------------------------------------------------------
//
//  Function:   SslCrackCertificate
//
//  Synopsis:   Cracks a X509 certificate into remotely easy format
//
//  Arguments:  [pbCertificate] --
//              [cbCertificate] --
//              [dwFlags]       --
//              [ppCertificate] --
//
//  Notes:
//
//  SHolden - Originally this code would allocate a PctCertificate and then
//            return the pointer to the X509Certificate in the PctCertificate.
//            The PctCertificate would never be freed.
//
//            Now, I still create a PctCertificate so that we can validate
//            the cert, but then I copy the X509Certificate and delete
//            the PctCertificate.
//
//----------------------------------------------------------------------------
BOOL
WINAPI
SslCrackCertificate(
    PUCHAR              pbCertificate,
    DWORD               cbCertificate,
    DWORD               dwFlags,
    PX509Certificate *  ppCertificate)
{
    PX509Certificate        pX509Cert = NULL;
    PPctCertificate         pPctCert  = NULL;
    const SignatureSystem   *pSigSys  = NULL;
    BOOL                    VerifySignature;
    BOOL                    fSuccess;

    *ppCertificate = NULL;

    VerifySignature = dwFlags & CF_VERIFY_SIG;

    if (dwFlags & CF_CERT_FROM_FILE)
    {
        if (cbCertificate < CERT_HEADER_LEN + 1 )
        {
            return (FALSE);
        }

        //
        // Sleazy quick check.  Some CAs wrap certs in a cert wrapper.
        // Some don't.  Some do both, but we won't mention any names.
        // Quick check for the wrapper tag.  If so, scoot in by enough
        // to bypass it (17 bytes. Sheesh).
        //

        if ( memcmp( pbCertificate + 4, CertTag, sizeof( CertTag ) ) == 0 )
        {
            pbCertificate += CERT_HEADER_LEN;
            cbCertificate -= CERT_HEADER_LEN;
        }
    }

    fSuccess = X509DecodeCertificate(pbCertificate, cbCertificate, &pPctCert);

    if (fSuccess == FALSE)
    {
        goto done;
    }

    if(VerifySignature == TRUE)
    {
        pSigSys = SigFromSpec(pPctCert->SigType, SP_PROT_ALL);

        if ((pSigSys == NULL)  ||
            (pPctCert == NULL) ||
            (pPctCert->pIssuerCertificate == NULL) ||
            (pPctCert->pIssuerCertificate->pPublicKey == NULL)
            )
        {
            fSuccess = FALSE;
            goto done;
        }

        fSuccess = pSigSys->Verify(
            pPctCert->pSignedPortion,
            pPctCert->cbSignedPortion,
            pPctCert->pSig,
            pPctCert->cbSig,
            pPctCert->pIssuerCertificate->pPublicKey
            );

        if (fSuccess == FALSE)
        {
            goto done;
        }
    }

    ASSERT(fSuccess == TRUE);

    pX509Cert = (PX509Certificate)SPExternalAlloc(sizeof(X509Certificate));

    if (pX509Cert == NULL)
    {
        fSuccess = FALSE;
        goto done;
    }

    memcpy(pX509Cert, pPctCert->pCert, sizeof(X509Certificate));

    pX509Cert->pszIssuer  = (PSTR)SPExternalAlloc(
        strlen(((PX509Certificate)pPctCert->pCert)->pszIssuer) + 1
        );
    pX509Cert->pszSubject = (PSTR)SPExternalAlloc(
        strlen(((PX509Certificate)pPctCert->pCert)->pszSubject) + 1
        );

    if ((pX509Cert->pszIssuer == NULL) ||
        (pX509Cert->pszSubject == NULL)
        )
    {
        fSuccess = FALSE;
        goto done;
    }

    strcpy(pX509Cert->pszIssuer,  ((PX509Certificate)pPctCert->pCert)->pszIssuer);
    strcpy(pX509Cert->pszSubject, ((PX509Certificate)pPctCert->pCert)->pszSubject);

    *ppCertificate = pX509Cert;

done:

    // Always delete the PctCertificate.
    if (pPctCert)
    {
        X509DeleteCert(pPctCert);
    }

    if (fSuccess == FALSE)
    {
        SslFreeCertificate(pX509Cert);
    }

    return (fSuccess);
}

//+---------------------------------------------------------------------------
//
//  Function:   SslLoadCertificate
//
//  Synopsis:   Not supported.
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
SslLoadCertificate(
    PUCHAR      pbCertificate,
    DWORD       cbCertificate,
    BOOL        AddToWellKnownKeys)
{
    return FALSE;
}

BOOL IsEncryptionPermitted(VOID);

/*++

Function:       SslSetProtocols

Description:

Arguments:

Returns:

History:        mm-dd-yyyy   Author    Comment
                7/14/1997    sholden   author

Comments:

--*/

BOOL
WINAPI
SslSetProtocols(
    DWORD rgbitsProtocols
    )
{
    BOOL fSuccess;

    if (rgbitsProtocols & ~(SP_PROT_PCT1 | SP_PROT_SSL2 | SP_PROT_SSL3))
    {
        return (FALSE);
    }
#ifndef SCHANNEL_PCT
    // quietly disable PCT
    rgbitsProtocols &= ~SP_PROT_PCT1;
#endif

    // Enable unified hello if more than one protocol is enabled.
    if (rgbitsProtocols)
    {
        rgbitsProtocols |= SP_PROT_UNI;
    }

    // Enable "credential" protocol.
    rgbitsProtocols |= SP_PROT_CRED;

    // BUGBUG: add critical section??
    g_ProtEnabled   = rgbitsProtocols;
    g_ProtSupported = rgbitsProtocols;
    // Should always return TRUE. Will disable PCT in France.
    fSuccess = IsEncryptionPermitted();
    return (fSuccess);
}

/*++

Function:       SslGetProtocols

Description:

Arguments:

Returns:

History:        mm-dd-yyyy   Author    Comment
                7/14/1997    sholden   author

Comments:

--*/

DWORD
WINAPI
SslGetProtocols()
{
    return (g_ProtSupported);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ui\inc\bitmapfile.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: bitmapfile.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the Interface for the bitmap file handler
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <stdio.h>

class CBitmapFile 
{

public:

	//
	// constructor and destructor
	//

	CBitmapFile( void );
	~CBitmapFile( void );

	//
	// read from memory a file to memory
	//

	HRESULT Read( INT iXloc, INT iYloc, LPSTR pszFile );

	//
	// render bitmap to a d3d device
	//

	HRESULT Render( IDirect3DDevice8* pD3DDevice ); 

	//
	// accessor for widht, height, and bitmap position
	//

    DWORD GetWidth() { return m_dwWidth; };    
    DWORD GetHeight() { return m_dwHeight; }; 
    INT   GetXPos() { return m_iXpos; };        
    INT   GetYPos() { return m_iYpos; };       

	//
	// modifiers for x and y pos
	//

    void  SetXPos( INT iX ) { m_iXpos = iX; };  
    void  SetYPos( INT iY ) { m_iYpos = iY; };  

private:

	//
	// helper function to clean up internal state
	//

    void CleanUp( void );       

	//
	// the tital image size
	//

	DWORD   m_dwImageSize;

	//
	// the array of pixels values
	//

	PDWORD  m_pdwPixels;

	//
	// the x and y positions
	//

	INT     m_iXpos;
    INT     m_iYpos;

	//
	// BMP header file info
	//

	WORD    m_wType;
	DWORD   m_dwFileSize;
	WORD    m_wReserved1;
	WORD    m_wReserved2;
	DWORD   m_dwOffBits;
	
	DWORD   m_dwInfoSize;
	DWORD   m_dwWidth;
	DWORD   m_dwHeight;
	WORD    m_wPlanes;
	WORD    m_wBitCount;
	DWORD   m_dwCompression;
	DWORD   m_dwSizeImage;
	DWORD   m_dwXPelsPerMeter;
	DWORD   m_dwYPelsPerMeter;
	DWORD   m_dwClrUsed;
	DWORD   m_dwClrImportant; 
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ssl\test\ssltestmain.cpp ===
#include <xtl.h>
#include <xdbg.h>
#include <httpsget.h>

#define    XRL_TEST_BIG1       "xolab-1:/read/00100000.000"
#define    XRL_TEST            "xolab-1:/read/00000001.001"
#define    XRL_TEST_BIG1       "xolab-1:/read/00100000.000"
#define    XRL_TEST_BIG2       "xolab-1:/read/00400000.001"
#define    XRL_HELLO           "boydm-xs:/XRLTest/hello.txt"
#define    XRL_ELDORADO        "boydm-xs:/XRLTest/Eldorado.mp3"

#define DEST_FILE1          L"t:\\test\\Eldo.mp3"
#define DEST_FILE2          L"t:\\test\\00100000.000"

//======================== The main function
//void __cdecl main()
extern "C" int WINAPI wWinMain(HINSTANCE hi, HINSTANCE hprev, LPSTR lpcmd, int nShow)
{
    WSADATA WsaData;
    DWORD err;
    BYTE                membuff[2000];
    DWORD               memread;
    HRESULT             herr;
    DWORD               dwHTTPerr;

    XDBGWRN("Xonline", "Loading XBox network stack...\n");
    err = XnetInitialize(NULL, TRUE);
    if ( err != NO_ERROR)
    {
        XDBGWRN("Xonline", "Failed XnetInitialize with %d\n", err);
        return 1;
    }

    XDBGWRN("Xonline", "Calling WSAStartup...\n");
    if(WSAStartup(0x0101, &WsaData) == SOCKET_ERROR)
    {
        XDBGWRN("Xonline", "Error %d returned by WSAStartup\n", GetLastError());
        return 1;
    }
    
    _asm int 3;

    HTTPSGet(L"tonychen2", L"test.htm");

    // Shutdown WinSock subsystem.
    WSACleanup();

    XDBGWRN("Xonline", "Unloading XBox network stack...\n");
    XnetCleanup();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ui\inc\UserInterfaceText.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: UserInterfaceText.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the interface for the text class
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <stdio.h>

#include "UserInterfaceInput.h"
#include "UserInterfaceAudio.h"

//
// the actual text class
//

class CUserInterfaceText {

public:

	//
	// constructor and destructor
	//

	CUserInterfaceText( LPSTR szText, 
		                DWORD dwX, 
						DWORD dwY, 
						DWORD dwFGColor, 
						DWORD dwBGColor );

	~CUserInterfaceText( void );

	//
	// Update the UI Text
	//

	virtual HRESULT Update( CUserInterfaceInput* pInput, CUserInterfaceAudio* pAudio );

	//
	// accessors for each member
	//

	LPSTR Text( void ) { return m_szText; };
	DWORD X( void ) { return m_dwX; };
	DWORD Y( void ) { return m_dwY; };
	DWORD FGColor( void ) { return m_dwFGColor; };
	DWORD BGColor( void ) { return m_dwBGColor; };
	void SetFGColor( DWORD dwColor ) { m_dwFGColor = dwColor; };
	void SetBGColor( DWORD dwColor ) { m_dwBGColor = dwColor; };
	void Hide( BOOL bHide ) { m_bHide = bHide; };
	BOOL Hidden( void ) { return m_bHide; };

	//
	// update text
	//

	void SetText( LPSTR szText ) { m_szText = szText; };

private:

	//
	// the string
	//

	LPSTR m_szText;

	//
	// x and y pos
	//

	DWORD m_dwX;
	DWORD m_dwY;

	//
	// the fore- and back-ground colors
	//

	DWORD m_dwFGColor;
	DWORD m_dwBGColor;

	//
	// hidden or not
	//

	BOOL m_bHide;

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ui\inc\UserInterface.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: UserInterface.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the Interface for the user interface class
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#include <xtl.h>
#include <xdbg.h>

#include "UserInterfaceInput.h"
#include "UserInterfaceAudio.h"
#include "UserInterfaceVideo.h"

//
// the user interface class decleration
//

class CUserInterface : public CUserInterfaceInput,
					   public CUserInterfaceAudio,
					   public CUserInterfaceVideo {

public:

	//
	// the singleton pattern entry to the class
	//

	static CUserInterface* Instance( void );

	//
	// External state transition calls
	//

	HRESULT Initialize( CUserInterfaceScreen* pScreen,
						ULONG uWidth, 
						ULONG uHeight,
						DWORD dwClearColor, 
						LPSTR szBackground );

	HRESULT Update( void );

private:

	//
	// Constructor and Destructor. They are protected so no one
	// ever tries to allocate / deallocate the class without
	// going through instance() method
	//

	CUserInterface();
	~CUserInterface();

	//
	// the actual instance pointer of the UI
	//

	static CUserInterface* m_pInterface;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ui\inc\UserInterfaceInput.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: UserInterfaceInput.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the Interface for the Input part of the UI
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#include <xtl.h>
#include <xdbg.h>

//
// the number of joysticks supported by the input class
//

static const DWORD NUM_JOYSTICKS = 4;

//
// the input user interface class decleration
//

class CUserInterfaceInput {

public:

	//
	// Constructor and destructor for UI input
	//

	CUserInterfaceInput( void );
	~CUserInterfaceInput( void );

	//
	// methods to init and update input
	//

	HRESULT Initialize( void );
	HRESULT Update( void );

	//
	// button state accessors
	//

	BOOL UpPressed          ( void ) { return m_bUpPressed;          };
	BOOL DownPressed        ( void ) { return m_bDownPressed;        };
	BOOL LeftPressed        ( void ) { return m_bLeftPressed;        };
	BOOL RightPressed       ( void ) { return m_bRightPressed;       };
	BOOL APressed           ( void ) { return m_bAPressed;           };
	BOOL BPressed           ( void ) { return m_bBPressed;           };
	BOOL XPressed           ( void ) { return m_bXPressed;           };
	BOOL YPressed           ( void ) { return m_bYPressed;           };
	BOOL BlackPressed       ( void ) { return m_bBlackPressed;       };
	BOOL WhitePressed       ( void ) { return m_bWhitePressed;       };
	BOOL BackPressed        ( void ) { return m_bBackPressed;        };
	BOOL StartPressed       ( void ) { return m_bStartPressed;       };
	BOOL LeftTriggerPressed ( void ) { return m_bLeftTriggerPressed; };
	BOOL RightTriggerPressed( void ) { return m_bRightTriggerPressed;};
	BOOL LeftThumbPressed   ( void ) { return m_bLeftThumbPressed;   };
	BOOL RightThumbPressed  ( void ) { return m_bRightThumbPressed;  };

private:

	//
	// button state modifiers
	// 

	void UpdateButtonState( PXINPUT_STATE pInputState );
	void ResetButtonState( void );

	//
	// the state of the buttons
	//

	struct {

		unsigned m_bUpPressed           : 1;
		unsigned m_bDownPressed         : 1;
		unsigned m_bLeftPressed         : 1;
		unsigned m_bRightPressed        : 1;
		unsigned m_bAPressed            : 1;
		unsigned m_bBPressed            : 1;
		unsigned m_bXPressed            : 1;
		unsigned m_bYPressed            : 1;
		unsigned m_bBlackPressed        : 1;
		unsigned m_bWhitePressed        : 1;
		unsigned m_bBackPressed         : 1;
		unsigned m_bStartPressed        : 1;
		unsigned m_bLeftTriggerPressed  : 1;
		unsigned m_bRightTriggerPressed : 1;
		unsigned m_bLeftThumbPressed    : 1;
		unsigned m_bRightThumbPressed   : 1;
	};

	//
	// the handles to the joysticks
	//

	HANDLE m_ahInput[NUM_JOYSTICKS];

	//
	// the old input state
	//

	XINPUT_STATE m_oldInputState;

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ui\inc\UserInterfaceAudio.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: UserInterfaceAudio.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the Interface for the audio portion of the UI
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include "wavemedia.h"

//
// the number of audio files
//

static const DWORD NUM_AUDIO_FILES = 4;

//
// the audio files
//

static LPSTR AUDIO_FILES[] = { "d:\\media\\sounds\\back_button.wav",
							   "d:\\media\\sounds\\keyboard_stroke.wav",
							   "d:\\media\\sounds\\menu_item_select.wav",
							   "d:\\media\\sounds\\select_button.wav" };

//
// enum for audio sounds
//

static const DWORD SOUND_BACK_BUTTON     = 0;
static const DWORD SOUND_KEYBOARD_STROKE = 1;
static const DWORD SOUND_MENU_ITEM       = 2;
static const DWORD SOUND_SELECT_BUTTON   = 3;

//
// decleration of audio ui class
//

class CUserInterfaceAudio {

public:

	//
	// Constructor and destructor for UI audio
	//

	CUserInterfaceAudio( void );
	~CUserInterfaceAudio( void );

	//
	// methods to init and play audio
	//

	HRESULT Initialize( void );

	HRESULT PlayBackButton()     { return Play( SOUND_BACK_BUTTON     ); };
	HRESULT PlayKeyboardStroke() { return Play( SOUND_KEYBOARD_STROKE ); };
	HRESULT PlayMenuItem()       { return Play( SOUND_MENU_ITEM       ); };
	HRESULT PlaySelectButton()   { return Play( SOUND_SELECT_BUTTON   ); };

private:

	//
	// internal play method
	//

	HRESULT Play( DWORD dwSound );

	//
	// the dsound object
	//

	LPDIRECTSOUND m_pDSound;

	//
	// the wave array
	//

	CWaveMedia m_sounds[NUM_AUDIO_FILES];

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ui\inc\UserInterfaceScreen.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: UserInterfaceScreen.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the Interface for the user interface screen base class
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <vector>

using namespace std;

#include "UserInterfaceInput.h"
#include "UserInterfaceAudio.h"
#include "UserInterfaceMenu.h"
#include "UserInterfaceText.h"

//
// the screen class
//

class CUserInterfaceScreen {

public:

	//
	// constructor and destructor
	//

	CUserInterfaceScreen( CUserInterfaceScreen* pParent, 
		                  DWORD dwFGColor, 
						  DWORD dwBGColor, 
						  DWORD dwTextX, 
						  DWORD dwTextY );

	~CUserInterfaceScreen( void );

	//
	// add a menu to the screen
	//

	void AddMenu( CUserInterfaceMenu* pMenu );

	//
	// add UI text to the screen
	//

	void AddUIText( CUserInterfaceText* pText );

	//
	// get the number of menus
	//

	DWORD NumMenus( void );

	//
	// get the number of ui text objects
	//

	DWORD NumUIText( void );

	//
	// get the menu at the given index
	//

	CUserInterfaceMenu* Menu( DWORD dwIndex );

	//
	// get the ui text at the given index
	//

	CUserInterfaceText* UIText( DWORD dwIndex );

	//
	// update the user input
	//

	virtual CUserInterfaceScreen* Update( CUserInterfaceInput* pInput, 
		                                  CUserInterfaceAudio* pAudio );

	//
	// set/get the text of the screen
	//

	void SetText( LPSTR szText );
	LPSTR GetText( void );

	//
	// remove the menus from the screen
	//

	void RemoveMenus( void );

	//
	// see if this is the active menu
	//

	BOOL ActiveMenu( DWORD dwMenuID ) { return dwMenuID == m_dwActive; };

	//
	// get the active menu index
	//

	DWORD ActiveMenuIndex( void ) { return m_dwActive; }

	//
	// get the foreground / background color
	//

	DWORD FGColor( void ) { return m_dwFGColor; };
	DWORD BGColor( void ) { return m_dwBGColor; };

	//
	// get the x and y location of the text
	//

	DWORD TextX( void ) { return m_dwTextX; };
	DWORD TextY( void ) { return m_dwTextY; };

protected:

	//
	// helpers for derived classes to query screen info
	// without being able to modify the screen state
	//

	//
	// is there more than 1 menu?
	//

	BOOL HasMultipleMenus( void ) { return NumMenus() > 1; };

	//
	// is the first or last menu active?
	//

	BOOL FirstActive( void ) { return 0 == m_dwActive; };
	BOOL LastActive( void ) { return NumMenus() - 1 == m_dwActive; };

	//
	// index of the first and last menu
	//

	DWORD LastMenu( void ) { return NumMenus() - 1; };
	DWORD FirstMenu( void ) { return 0; };

	//
	// goto the previous/next menu
	//

	DWORD PreviousMenu( void ) { return m_dwActive - 1; };
	DWORD NextMenu( void ) { return m_dwActive + 1; };

	//
	// scroll to the next/previous menu
	//

	void ScrollActiveMenuUp( void ) { m_dwActive = FirstActive() ? LastMenu() : PreviousMenu(); };
	void ScrollActiveMenuDown( void ) { m_dwActive = LastActive() ? FirstMenu() : NextMenu(); };

	//
	// see if there are no menus
	//

	BOOL NoActiveMenus( void ) { return m_menus.empty(); };

	//
	// get the active menu
	//

	CUserInterfaceMenu* ActiveMenu( void ) { return m_menus[m_dwActive]; };
	
	//
	// find the parent screen
	//

	CUserInterfaceScreen* ParentScreen( void ) { return m_pParent; };

private:

	//
	// the list of menus
	//

	vector<CUserInterfaceMenu*> m_menus;

	//
	// the list of layout text
	//

	vector<CUserInterfaceText*> m_uiText;

	//
	// the parent screen
	//

	CUserInterfaceScreen* m_pParent;

	//
	// the text of the screen
	//

	LPSTR m_szText;

	//
	// the active menu index
	//

	DWORD m_dwActive;

	//
	// the foreground/background color
	//

	DWORD m_dwFGColor;
	DWORD m_dwBGColor;

	//
	// the x/y location of the text
	//

	DWORD m_dwTextX;
	DWORD m_dwTextY;

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ui\inc\UserInterfaceMenu.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: UserInterfaceMenu.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the Interface for base menu class
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <vector>

using namespace std;

#include "UserInterfaceInput.h"
#include "UserInterfaceAudio.h"

//
// forward decleration to keep from having circular includes
// due to circular dependency on screen and menu classes
//

class CUserInterfaceScreen;

//
// the menu ui class
//

class CUserInterfaceMenu {

public:

	//
	// constructor and destructor
	//

	CUserInterfaceMenu( LPSTR szTitle, 
		                DWORD dwFGColor, 
						DWORD dwBGColor, 
						DWORD dwTextX, 
						DWORD dwTextY );

	~CUserInterfaceMenu( void );

	//
	// code to add a menu item to the menu
	//

	void AddItem( LPSTR szStr, CUserInterfaceScreen* pScreen );

	//
	// accessor to get the number of items
	//

	DWORD NumItems( void );

	//
	// get the item at the inputted index
	//

	LPSTR Item( DWORD dwIndex );

	//
	// remove all the items from the menu
	//

	void RemoveItems( void );

	//
	// overloaded input handler
	//

	virtual CUserInterfaceScreen* Update( CUserInterfaceInput* pInput, CUserInterfaceAudio* pAudio );

	//
	// get the title of the menu
	//

	LPSTR GetTitle( void ) { return m_szTitle; };

	//
	// find out if the inputted item is the active item
	//

	BOOL ActiveItem( DWORD dwItemID ) { return dwItemID == m_dwActive; };

	//
	// get the active item index
	//

	DWORD ActiveItemIndex( void ) { return m_dwActive; }

	//
	// get the foreground and background color fo the title
	//

	DWORD FGColor( void ) { return m_dwFGColor; };
	DWORD BGColor( void ) { return m_dwBGColor; };

	//
	// get the x and y position of the text
	//

	DWORD TextX( void ) { return m_dwTextX; };
	DWORD TextY( void ) { return m_dwTextY; };

	//
	// set the foreground / background color for the active item
	//

	void SetFGColorActive( DWORD dwColor ) { m_dwFGColors[m_dwActive] = dwColor; };
	void SetBGColorActive( DWORD dwColor ) { m_dwBGColors[m_dwActive] = dwColor; };

	//
	//
	// get the foreground / background color for a specific item

	DWORD FGColor( DWORD dwIndex ) { return m_dwFGColors[dwIndex]; };
	DWORD BGColor( DWORD dwIndex ) { return m_dwBGColors[dwIndex]; };

protected:

	//
	// helpers for derived classes to query menu info
	// without being able to modify the menu state
	//

	//
	// does this menu have more than 1 item?
	//

	BOOL HasMultipleItems( void ) { return NumItems() > 1; };

	//
	// is the first item in the menu the active one?
	//

	BOOL FirstActive( void ) { return 0 == m_dwActive; };

	//
	// is the last item in the menu the active one?
	//

	BOOL LastActive( void ) { return (NumItems() - 1) == m_dwActive; };

	//
	// get the index of the last item
	//

	DWORD LastItem( void ) { return NumItems() - 1; };

	//
	// get hte index of the first item
	//

	DWORD FirstItem( void ) { return 0; };

	//
	// create the index of the previous item and the next item
	//

	DWORD PreviousItem( void ) { return m_dwActive - 1; };
	DWORD NextItem( void ) { return m_dwActive + 1; };

	//
	// scroll the items in the menu up and down
	//

	void ScrollActiveItemUp( void ) { m_dwActive = FirstActive() ? LastItem() : PreviousItem(); };
	void ScrollActiveItemDown( void ) { m_dwActive = LastActive() ? FirstItem() : NextItem(); };

	//
	// check if the active item has a screen also
	//

	BOOL ActiveItemHasScreen( void ) { return ! m_screens.empty() && m_screens[m_dwActive]; };

	//
	// see if the items have screens
	//

	BOOL NoActiveItems( void ) { return m_screens.empty(); };

	//
	// get the screen that is highlited by the active item
	//

	CUserInterfaceScreen* ActiveScreen( void ) { return m_screens[m_dwActive]; };


private:

	//
	// the actual items in the menu
	//

	vector<LPSTR> m_items;

	//
	// the screens that go along with the strings
	//

	vector<CUserInterfaceScreen*> m_screens;

	//
	// the index of hte active item
	//

	DWORD m_dwActive;

	//
	// the fg / bg colors for the items in the list
	//

	vector<DWORD> m_dwFGColors;
	vector<DWORD> m_dwBGColors;

	//
	// th fg / bg color for the menu
	//

	DWORD m_dwFGColor;
	DWORD m_dwBGColor;

	//
	// the title of the menu
	//

	LPSTR m_szTitle;

	//
	// the location of the text for the menu
	//

	DWORD m_dwTextX;
	DWORD m_dwTextY;

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ui\inc\UserInterfaceVideo.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: UserInterfaceVideo.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the Interface for the video ui class
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#include <xtl.h>
#include <xdbg.h>
#define XFONT_TRUETYPE
#include <xfont.h>

#include "bitmapfile.h"

#include <vector>
using namespace std;

#include "UserInterfaceInput.h"
#include "UserInterfaceAudio.h"
#include "UserInterfaceScreen.h"

//
// the user interface video decleration
//

class CUserInterfaceVideo {

public:

	//
	// constructor and destructor
	//

	CUserInterfaceVideo( void );
	~CUserInterfaceVideo( void );

	//
	// methods to init and update video
	//

	HRESULT Initialize( CUserInterfaceScreen* pScreen,
		                UINT uWidth, 
						UINT uHeight,
						DWORD dwClearColor,
						LPSTR szFileName );

	HRESULT Update( CUserInterfaceInput* pInput, 
		            CUserInterfaceAudio* pAudio );

private:

	//
	// Display modifiers
	//

	HRESULT ClearScreen( DWORD dwColor );

	//
	// Prints formatted text
	//
							 
	HRESULT DrawText( LONG lX,						   
					  LONG lY, 
					  DWORD dwFGColor, 
					  DWORD dwBGColor, 
					  LPCWSTR szFormat, 
				      ... );

	//
	// draw the ui screen
	//

	HRESULT DrawScreen( void );

	//
	// the d3d device pointer
	//

	PDIRECT3DDEVICE8 m_pDevice;

	//
	// a pointer to the current Screen
	//

	CUserInterfaceScreen* m_pScreen;

	//
	// the font
	//

    XFONT* m_pFont;

    //
    // the backbuffer (surprise surprise)
    //

    D3DSurface* m_pBackBuffer;

	//
	// the width, height
	//

	UINT m_uWidth;
	UINT m_uHeight;

	//
	// the clear color
	//

	DWORD m_dwClearColor;

	//
	// the optional bitmap background
	//

	CBitmapFile* m_pBitmap;

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ui\inc\UserInterfaceTextEntry.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: UserInterfaceTextEntry.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the interface for the text entry class
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#include <xtl.h>
#include <xdbg.h>

#include "UserInterfaceText.h"
#include "UserInterfaceInput.h"
#include "UserInterfaceAudio.h"

//
// the number of chars in select string
//

static const DWORD MAX_SELECT_CHARS = 9;

//
// the range of chars
//

static const CHAR START_CHAR = 'A';
static const CHAR END_CHAR = 'Z';

//
// the formatting string
//

static const LPSTR SELECT_FORMAT_STRING = "%s <<%c>>";

//
// the actual text class
//

class CUserInterfaceTextEntry : public CUserInterfaceText {

public:

	//
	// constructor and destructor
	//

	CUserInterfaceTextEntry(  DWORD dwMaxChars,
							  DWORD dwX, 
							  DWORD dwY, 
							  DWORD dwFGColor, 
							  DWORD dwBGColor );

	~CUserInterfaceTextEntry( void );

	//
	// Update the UI
	//

	virtual HRESULT Update( CUserInterfaceInput* pInput, CUserInterfaceAudio* pAudio );

	//
	// get the inputed text
	//

	LPSTR GetInputText( void ) { return m_szInput; };

private:

	//
	// update the select text
	//

	void UpdateSelectText( void );

	//
	// init the text entry
	//

	HRESULT Init( void );

	//
	// the max number of chars
	//

	DWORD m_dwMaxChars;

	//
	// the inputted text
	//

	LPSTR m_szInput;

	//
	// the rotating letter string
	//

	LPSTR m_szSelect;

	//
	// the current charecter
	//

	CHAR m_cCurChar;

	//
	// current index
	//

	DWORD m_dwCurIndex;

	//
	// flag for previous init
	//

	BOOL m_bInit;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ui\inc\wavemedia.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: wavemedia.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the Interface for the wave media class
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#include <xtl.h>
#include <xdbg.h>

class CWaveMedia
{
public:

	//
    // Constructors and Destructors
	//

    CWaveMedia( void );
    ~CWaveMedia( void );

	//
	// see if sound is playing
	//

    BOOL IsPlaying( void );         
	
	//
	// Play and stop the sound
	//

    HRESULT Play( void );                             
    HRESULT Stop( void );              
	
	//
	// reset the wave to the beginning
	//

    HRESULT ResetToBeginning( void ); 
	
	//
	// set the volume of the wave
	//

    HRESULT SetVolume( LONG lVolume );            
    
	//
	// Initialize the wave file
	//

    HRESULT Initialize( LPSTR szWaveFileName, LONG lDefaultVolume = 0 );

private:

	//
	// Load the WAV file in to our local DSound Buffer
	//

    HRESULT ProcessWaveFile( LPSTR szWaveFileName );                            
	
	//
	// Pointer to the local DSound buffer
	//

	LPDIRECTSOUNDBUFFER m_pDSoundBuffer;  

	//
	// Pointer to our XFileMediaObject file
	//

	XFileMediaObject*   m_pFMOFile;
	
	//
	// XMedia Packet
	//

    XMEDIAPACKET        m_xmp; 	                               
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ui\src\UserInterfaceText.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: UserInterfaceText.cpp
//
// Author: Dan Rosenstein (danrose)
//
// Description: the implementation for the user interface text class
//
///////////////////////////////////////////////////////////////////////////////

#include "UserInterfaceText.h"

///////////////////////////////////////////////////////////////////////////////
//
// Name: constructor
//
// Input: szText - the string for the text object
//        dwX - the X location for the text
//        dwY - the Y location for the text
//        dwFGColor - the foreground color for the text
//        dwBGColor - the background color for the text
//
// Output: None
//
// Description: creates a ui text object
//
///////////////////////////////////////////////////////////////////////////////

CUserInterfaceText::CUserInterfaceText( LPSTR szText, 
										DWORD dwX, 
										DWORD dwY, 
										DWORD dwFGColor, 
										DWORD dwBGColor )

	: m_szText( szText ),
	  m_dwX( dwX ),
	  m_dwY( dwY ),
	  m_dwFGColor( dwFGColor ),
	  m_dwBGColor( dwBGColor ),
	  m_bHide( FALSE )
{
	//
	// No code here
	//
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Destructor
//
// Input: None
//
// Output: None
//
// Description: destroys a UI Text object
//
///////////////////////////////////////////////////////////////////////////////

CUserInterfaceText::~CUserInterfaceText( void )
{
	//
	// No code here
	//
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Update
//
// Input: pInput - the input ui class
//        pAudio - the input audio class
//
// Output: the final HR
//
// Description: process input
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
CUserInterfaceText::Update( CUserInterfaceInput* pInput, CUserInterfaceAudio* pAudio )
{
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ui\src\UserInterfaceInput.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: UserInterfaceInput.cpp
//
// Author: Dan Rosenstein (danrose)
//
// Description: the implementation for ui input class
//
///////////////////////////////////////////////////////////////////////////////

#include "UserInterfaceInput.h"

///////////////////////////////////////////////////////////////////////////////
//
// Name: CUserInterfaceInput
//
// Input: None
//
// Output: an instance of the user interface input class
//
// Description: constructs the input for the UI
//
///////////////////////////////////////////////////////////////////////////////

CUserInterfaceInput::CUserInterfaceInput( void )
{
	//
	// Zero out the handle array
	//

	ZeroMemory( m_ahInput, sizeof( m_ahInput ) );

	//
	// Zero out the old input state
	//

	ZeroMemory( &m_oldInputState, sizeof( XINPUT_STATE ) );

	//
	// reset the button state
	//

	ResetButtonState();
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: ~CUserInterfaceInput
//
// Input: None
//
// Output: None
//
// Description: destructs the input ui
//
///////////////////////////////////////////////////////////////////////////////

CUserInterfaceInput::~CUserInterfaceInput( void )
{
	//
	// Destroy the handles
	//

	for ( DWORD i = 0; i < NUM_JOYSTICKS; i++ )
	{
		if ( NULL != m_ahInput[i] )
		{
			XInputClose( m_ahInput[i] );
			m_ahInput[i] = NULL;
		}
	}
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Initialize
//
// Input: None
//
// Output: S_OK if input creation was successful, E_XXXX otherwise
//
// Description: sets up the app for getting input from the controllers
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
CUserInterfaceInput::Initialize( void )
{
	HRESULT hr = S_OK;

	DWORD dwRet = 0;
	DWORD dwPort = -1;

	//
	// init the devices with the default values
	//

	XInitDevices( 0, NULL );
	
	//
	// Get the devices
	//

	dwRet = XGetDevices( XDEVICE_TYPE_GAMEPAD );

	//
	// strip off high bits; low bits hold controller info
	//

	dwRet &= 0xF;

	//
	// Open the available gamepads
	// it is ok for no devices to be attached for the app
	//

	for ( DWORD i = 0; i < NUM_JOYSTICKS && SUCCEEDED( hr ); i++, dwRet >>= 1 )
	{
		//
		// Only create a handle if the device exists
		//

		if ( dwRet & 0x1 )
		{
			//
			// make sure the handle did not exist
			//

			ASSERT( NULL == m_ahInput[i] || ! "input handle already allocated" );

			//
			// create the handle
			//

			m_ahInput[i] = XInputOpen( XDEVICE_TYPE_GAMEPAD, 
									   i, 
									   XDEVICE_NO_SLOT, 
									   NULL );

			hr = NULL == m_ahInput[i] ? E_FAIL : S_OK;

			ASSERT( SUCCEEDED( hr ) || !"Could not open input handle" );
		}
	}

	//
	// spit back the final hresult
	//

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: UpdateButtonState
//
// Input: pInputState - the state of the inputted buttons
//
// Output: S_OK on success. E_XXXX on failure
//
// Description: updates the ui state with the currently pressed buttons
//
///////////////////////////////////////////////////////////////////////////////

void
CUserInterfaceInput::UpdateButtonState( PXINPUT_STATE pInputState )
{
	ASSERT( pInputState || !"Passed in NULL to pInputState" );

	if ( ! pInputState )
	{
		return;
	}

	//
	// get the digital changes
	//

	if ( pInputState->Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP )
		m_bUpPressed = TRUE;

	if ( pInputState->Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN )
		m_bDownPressed = TRUE;

	if ( pInputState->Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_LEFT )
		m_bLeftPressed = TRUE;

	if ( pInputState->Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT )
		m_bRightPressed = TRUE;

	if ( ( m_oldInputState.Gamepad.wButtons & XINPUT_GAMEPAD_START ) &&
		 ( ( pInputState->Gamepad.wButtons & XINPUT_GAMEPAD_START ) == 0 ) )
		m_bStartPressed = TRUE;

	if ( ( m_oldInputState.Gamepad.wButtons & XINPUT_GAMEPAD_BACK ) &&
		 ( ( pInputState->Gamepad.wButtons & XINPUT_GAMEPAD_BACK ) == 0 ) )
		m_bBackPressed = TRUE;

	if ( ( m_oldInputState.Gamepad.wButtons & XINPUT_GAMEPAD_LEFT_THUMB ) &&
		 ( ( pInputState->Gamepad.wButtons & XINPUT_GAMEPAD_LEFT_THUMB ) == 0 ) )
		m_bLeftThumbPressed = TRUE;

	if ( ( m_oldInputState.Gamepad.wButtons & XINPUT_GAMEPAD_RIGHT_THUMB ) &&
		 ( ( pInputState->Gamepad.wButtons & XINPUT_GAMEPAD_RIGHT_THUMB ) == 0 ) )
		m_bRightThumbPressed = TRUE;

	//
	// get the analog changes
	//

	if ( m_oldInputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A] > 0 &&
		 pInputState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A] == 0 )
		m_bAPressed = TRUE;

	if ( m_oldInputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B] > 0 &&
		 pInputState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B] == 0 )
		m_bBPressed = TRUE;

	if ( m_oldInputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X] > 0 &&
		 pInputState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X] == 0 )
		m_bXPressed = TRUE;

	if ( m_oldInputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] > 0 &&
		 pInputState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] == 0 )
		m_bYPressed = TRUE;

	if ( pInputState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] > 0 )
		m_bBlackPressed = TRUE;

	if ( pInputState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE] > 0 )
		m_bWhitePressed = TRUE;

	if ( pInputState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > 0 )
		m_bLeftTriggerPressed = TRUE;

	if ( pInputState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > 0 )
		m_bRightTriggerPressed = TRUE;

	//
	// save the old state
	//

	memcpy( &m_oldInputState, pInputState, sizeof( XINPUT_STATE ) );

	//
	// get the analog stick changes
	//

	#pragma message( "TODO: add handling of analog sticks" )

}

///////////////////////////////////////////////////////////////////////////////
//
// Name: ResetButtonState
//
// Input: None
//
// Output: None
//
// Description: resets the state of the buttons to 0
//
///////////////////////////////////////////////////////////////////////////////

void
CUserInterfaceInput::ResetButtonState( void )
{
	m_bUpPressed = FALSE;
	m_bDownPressed = FALSE;
	m_bLeftPressed = FALSE;
	m_bRightPressed = FALSE;
	m_bAPressed = FALSE;
	m_bBPressed = FALSE;
	m_bXPressed = FALSE;
	m_bYPressed = FALSE;
	m_bBlackPressed = FALSE;
	m_bWhitePressed = FALSE;
	m_bBackPressed = FALSE;
	m_bStartPressed = FALSE;
	m_bLeftTriggerPressed = FALSE;
	m_bRightTriggerPressed = FALSE;
	m_bLeftThumbPressed = FALSE;
	m_bRightThumbPressed = FALSE;
}


///////////////////////////////////////////////////////////////////////////////
//
// Name: Update
//
// Input: None
//
// Output: S_OK on success. E_XXXX on failure
//
// Description: gets input from the joypads
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
CUserInterfaceInput::Update( void )
{
	HRESULT hr = S_OK;
	DWORD dwInsertions = 0;
	DWORD dwRemovals = 0;
	DWORD dwError = 0;

	XINPUT_STATE inputState;

	//
	// Zero out the input state
	//

	ZeroMemory( &inputState, sizeof( XINPUT_STATE ) );

	//
	// get the changed controller state
	//

	if ( XGetDeviceChanges( XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals ) )
	{
		//
		// strip off high bits
		//

		dwRemovals &= 0xF;
		dwInsertions &= 0xF;

		//
		// handle insertions / removals
		//

		for ( DWORD i = 0; 
		      i < NUM_JOYSTICKS && SUCCEEDED( hr ); 
			  i++, 
			  dwRemovals >>= 1, 
			  dwInsertions >>= 1 )
		{
			//
			// close the handle
			//

			if ( dwRemovals & 0x1 && SUCCEEDED( hr ) )
			{
				//
				// make sure handle existed
				//

				ASSERT( NULL != m_ahInput[i] || !"input handle was never allocated" );

				//
				// close the existing handle
				//

				XInputClose( m_ahInput[i] );
				m_ahInput[i] = NULL;
			}

			//
			// Only create a handle if the device exists
			//

			if ( dwInsertions & 0x1 && SUCCEEDED( hr ) )
			{
				//
				// make sure handle never existed
				//

				ASSERT( NULL == m_ahInput[i] || ! "input handle already allocated" );

				//
				// open the new handle
				//

				m_ahInput[i] = XInputOpen( XDEVICE_TYPE_GAMEPAD, 
										   i, 
										   XDEVICE_NO_SLOT, 
										   NULL );

				hr = NULL == m_ahInput[i] ? E_FAIL : S_OK;

				ASSERT( SUCCEEDED( hr ) || !"Could not open input handle" );
			}
		}
	}

	//
	// Reset the button state
	//

	ResetButtonState();

	//
	// get the button presses from the controllers
	//

	for ( DWORD i = 0; i < NUM_JOYSTICKS && SUCCEEDED( hr ); i++ )
	{
		//
		// zero out the input state
		//

		ZeroMemory( &inputState, sizeof( XINPUT_STATE ) );

		//
		// read the current joystick button state
		//

		if ( m_ahInput[i] )
		{
			//
			// get the state
			//

			dwError = XInputGetState( m_ahInput[i], &inputState );

			hr = ERROR_SUCCESS == dwError ? S_OK : E_FAIL;
			ASSERT( SUCCEEDED( hr ) || ! "could not get input state" );

			//
			// Update the internal button state
			//

			if ( SUCCEEDED( hr ) )
			{
				UpdateButtonState( &inputState );
			}
		}
	}

	//
	// reboot if L-R-Black was pushed
	//

	if ( SUCCEEDED( hr ) && LeftTriggerPressed() && RightTriggerPressed() && BlackPressed() )
	{
		XLaunchNewImage (NULL, NULL);
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ui\src\UserInterfaceScreen.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: UserInterfaceScreen.cpp
//
// Author: Dan Rosenstein (danrose)
//
// Description: the implementation for the user interface screen class
//
///////////////////////////////////////////////////////////////////////////////

#include "UserInterfaceScreen.h"
#include "UserInterfaceMenu.h"
#include "UserInterfaceInput.h"
#include "UserInterfaceAudio.h"

///////////////////////////////////////////////////////////////////////////////
//
// Name: Constructor
//
// Input: pParent - the parent screen for this screen
//        dwFGColor - the fg color
//        dwBGColor - the bg color
//        dwTextX - the x location of text
//        dwTextY - the Y location of text
//
// Output: an instance of the UI Screen
//
// Description: constructs a UI Screen
//
///////////////////////////////////////////////////////////////////////////////

CUserInterfaceScreen::CUserInterfaceScreen( CUserInterfaceScreen* pParent, 
										    DWORD dwFGColor, 
											DWORD dwBGColor, 
											DWORD dwTextX, 
											DWORD dwTextY )
	: m_menus(),
	  m_uiText(),
	  m_pParent( pParent ),
	  m_szText( NULL ),
	  m_dwActive( 0 ),
	  m_dwFGColor( dwFGColor ),
	  m_dwBGColor( dwBGColor ),
	  m_dwTextX( dwTextX ),
	  m_dwTextY( dwTextY )
{
	//
	// no code here
	//
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Destructor
//
// Input: None
//
// Output: None
//
// Description: destroys a UI Screen
//
///////////////////////////////////////////////////////////////////////////////

CUserInterfaceScreen::~CUserInterfaceScreen( void )
{
	//
	// remove all menus
	//

	RemoveMenus();

	//
	// remove ui text
	//

	while ( ! m_uiText.empty() )
	{
		m_uiText.pop_back();
	}
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: SetText
//
// Input: szText - the text to set for the screen
//
// Output: None
//
// Description: updates the text with the new text
//
///////////////////////////////////////////////////////////////////////////////

void 
CUserInterfaceScreen::SetText( LPSTR szText )
{
	m_szText = szText;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: GetText
//
// Input: None
//
// Output: the text held in the Screen
//
// Description: retrieves the text on the screen. Can be NULL
//
///////////////////////////////////////////////////////////////////////////////

LPSTR
CUserInterfaceScreen::GetText( void )
{
	return m_szText;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: AddMenu
//
// Input: pMenu - the menu to add to the screen
//
// Output: None
//
// Description: adds a menu to the current screen
//
///////////////////////////////////////////////////////////////////////////////

void
CUserInterfaceScreen::AddMenu( CUserInterfaceMenu* pMenu )
{
	//
	// make sure the pointer is good
	//

	ASSERT( pMenu || !"Menu pointer can not be null" );

	//
	// insert the menu pointer
	//

	if ( pMenu && ! m_szText )
	{
		m_menus.push_back( pMenu );
	}
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: AddUIText
//
// Input: pText - the ui text to add to the screen
//
// Output: None
//
// Description: adds ui text to the screen
//
///////////////////////////////////////////////////////////////////////////////

void
CUserInterfaceScreen::AddUIText( CUserInterfaceText* pText )
{
	//
	// make sure the pointer is good
	//

	ASSERT( pText || !"UI text pointer can not be null" );

	//
	// insert the pointer in the menu
	//

	if ( pText )
	{
		m_uiText.push_back( pText );
	}
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: NumMenus
//
// Input: None
//
// Output: the number of menus on the screen
//
// Description: returns the number of menus associated with the screen
//
///////////////////////////////////////////////////////////////////////////////

DWORD
CUserInterfaceScreen::NumMenus( void )
{
	return m_menus.size();
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: NumUIText
//
// Input: None
//
// Output: the number of ui text objects on the screen
//
// Description: returns the number of ui text objects on the screen
//
///////////////////////////////////////////////////////////////////////////////

DWORD
CUserInterfaceScreen::NumUIText( void )
{
	return m_uiText.size();
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Menu
//
// Input: dwIndex - the index of the menu
//
// Output: a pointer ot the menu at hte inputted index
//
// Description: gets a menu at the desired index
//
///////////////////////////////////////////////////////////////////////////////

CUserInterfaceMenu* 
CUserInterfaceScreen::Menu( DWORD dwIndex )
{
	//
	// make sure the index is valid
	//

	ASSERT( dwIndex < NumMenus() || !"index out of range" );

	//
	// get the menu
	//

	if ( dwIndex < NumMenus() )
	{
		return m_menus[dwIndex];
	}
	else
	{
		return NULL;
	}
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: UIText
//
// Input: dwIndex - the index of the ui text
//
// Output: a pointer ot the text at hte inputted index
//
// Description: gets a text object at the desired index
//
///////////////////////////////////////////////////////////////////////////////

CUserInterfaceText*
CUserInterfaceScreen::UIText( DWORD dwIndex )
{
	//
	// make sure the index is valid
	//

	ASSERT( dwIndex < NumUIText() || !"index out of range" );

	//
	// get the ui text
	//

	if ( dwIndex < NumUIText() )
	{
		return m_uiText[dwIndex];
	}
	else
	{
		return NULL;
	}
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: RemoveMenu
//
// Input: None
//
// Output: None
//
// Description: removes the menus from the screen
//
///////////////////////////////////////////////////////////////////////////////

void
CUserInterfaceScreen::RemoveMenus( void )
{ 
	//
	// go through the menus until the menu list is empty
	//

	while ( ! m_menus.empty() ) { 
		m_menus.pop_back(); 
	}

	//
	// reset the active menu
	//

	m_dwActive = 0;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Update
//
// Input: pInput - the input ui class
//        pAudio - the input audio class
//
// Output: the next screen to display
//
// Description: process input
//
///////////////////////////////////////////////////////////////////////////////

CUserInterfaceScreen*
CUserInterfaceScreen::Update( CUserInterfaceInput* pInput, CUserInterfaceAudio* pAudio )
{
	HRESULT hr = S_OK;
	CUserInterfaceScreen* pRet = NULL;

	//
	// make sure inputs are good
	//

	ASSERT( pInput && pAudio || !"input can not be null" );

	if ( ! pInput || ! pAudio )
	{
		return pRet;
	}

	//
	// if left pressed and there are multiple menus
	//

	if ( pInput->LeftPressed() && HasMultipleMenus() )
	{

		//
		// scroll up a menu
		//

		ScrollActiveMenuUp();
		hr = pAudio->PlayMenuItem();
	}

	//
	// if right is pressed and there are multiple menus
	//

	else if ( pInput->RightPressed() && HasMultipleMenus() )
	{
		//
		// scroll down a menu
		//

		ScrollActiveMenuDown();
		hr = pAudio->PlayMenuItem();
	}

	//
	// if b is pressed and there is a parent screen
	//

	else if ( pInput->BPressed() && ParentScreen() )
	{
		//
		// goto the parent screen
		//

		pRet = ParentScreen();
		hr = pAudio->PlayBackButton();
	}

	//
	// if a is pressed and no menus exist
	//

	else if ( pInput->APressed() && NoActiveMenus() )
	{
		//
		// this acts as a selection
		//

		hr = pAudio->PlaySelectButton();
	}

	//
	// if x is pressed and no active menus
	//

	else if ( pInput->XPressed() && NoActiveMenus() )
	{
		//
		// this acts as an X selection
		//

		hr = pAudio->PlayKeyboardStroke();
	}

	//
	// otherwise if there are menus and no text to display
	//

	else if ( ! NoActiveMenus() && ! GetText() )
	{

		//
		// let the active menu drive the input
		//

		pRet = ActiveMenu()->Update( pInput, pAudio );
	} 

	ASSERT( SUCCEEDED( hr ) || !"could not play audio file" );

	return pRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ui\src\UserInterface.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: UserInterface.cpp
//
// Author: Dan Rosenstein (danrose)
//
// Description: the implementation for the user interface class
//
///////////////////////////////////////////////////////////////////////////////

#include "UserInterface.h"

//
// Need to init the static members
//

CUserInterface* CUserInterface::m_pInterface = NULL;

///////////////////////////////////////////////////////////////////////////////
//
// Name: Instance
//
// Input: None
//
// Output: a pointer to the instance of the UserInterface
//
// Description: this function is the entry point to the user interface. 
//              it will create the ui pointer if it does not already exist
//              otherwise it will return the existing pointer
//
///////////////////////////////////////////////////////////////////////////////

CUserInterface*
CUserInterface::Instance( void )
{
	//
	// check to see if the ui has been created
	//

	if ( ! m_pInterface )
	{
		//
		// allocate a new UI
		//

		m_pInterface = new CUserInterface();
		ASSERT( m_pInterface || ! "could not create ui" );
	}

	//
	// return the ui pointer
	//

	return m_pInterface;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: CUserInterface
//
// Input: None
//
// Output: an instance of the user interface class
//
// Description: constructs the UI
//
///////////////////////////////////////////////////////////////////////////////

CUserInterface::CUserInterface( void )
{
	//
	// no code here
	//
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: ~CUserInterface
//
// Input: None
//
// Output: None
//
// Description: destroys the UI
//
///////////////////////////////////////////////////////////////////////////////

CUserInterface::~CUserInterface( void )
{
	//
	// no code here
	//
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Initialize
//
// Input: pScreen - the root screen for the ui
//        uWidth - the width of the screen
//        uHeight - the height of the screen
//        dwClearColor - the color to clear the screen with
//        szBackground - the name of the background image
//                       can be NULL
//
// Output: S_OK on success. E_XXXX on failure
//
// Description: sets up the User interface
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
CUserInterface::Initialize( CUserInterfaceScreen* pScreen,
							ULONG uWidth, 
							ULONG uHeight,
							DWORD dwClearColor,
							LPSTR szBackground )
{
	HRESULT hr = S_OK;

	//
	// Initialize Input
	//

	if( SUCCEEDED( hr ) )
	{
		hr = CUserInterfaceInput::Initialize();
		ASSERT( SUCCEEDED( hr ) || !"Could not Init input" );
	}

	//
	// Initialize Audio
	//

	if( SUCCEEDED( hr ) )
	{
		hr = CUserInterfaceAudio::Initialize();
		DbgPrint( "0x%x\n", hr );

		if ( E_FAIL == hr )
		{
			hr = S_OK;
		}
	//	ASSERT( SUCCEEDED( hr ) || !"Could not Init audio" );
	}

	//
	// Initialize Video
	//

	if( SUCCEEDED( hr ) )
	{
		hr = CUserInterfaceVideo::Initialize( pScreen,
											  uWidth, 
											  uHeight,
											  dwClearColor,
											  szBackground );

		ASSERT( SUCCEEDED( hr ) || !"Could not Init video" );
	}

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Update
//
// Input: None
//
// Output: S_OK on success. E_XXXX on failure
//
// Description: updates the User interface for the next frame
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
CUserInterface::Update( void )
{
	HRESULT hr = S_OK;

	//
	// Process the input
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = CUserInterfaceInput::Update();
		ASSERT( SUCCEEDED( hr ) || ! "Could not process input" );
	}

	//
	// render the scene
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = CUserInterfaceVideo::Update( this, this );
		ASSERT( SUCCEEDED( hr ) || ! "Could not update video" );
	}

	//
	// sleep since we are rendering so quick
	//

	Sleep( 130 );

	//
	// spit back the hresult
	//

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ui\src\UserInterfaceAudio.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: UserInterfaceAuido.cpp
//
// Author: Dan Rosenstein (danrose)
//
// Description: the implementation for the audio ui class
//
///////////////////////////////////////////////////////////////////////////////

#include "UserInterfaceAudio.h"

///////////////////////////////////////////////////////////////////////////////
//
// Name: CUserInterfaceAudio
//
// Input: None
//
// Output: an instance of the user interface audio class
//
// Description: constructs the audio for the UI
//
///////////////////////////////////////////////////////////////////////////////

CUserInterfaceAudio::CUserInterfaceAudio( void )
	: m_pDSound( NULL )
{
	//
	// No code here
	//
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: ~CUserInterfaceAudio
//
// Input: None
//
// Output: None
//
// Description: destructs the audio ui
//
///////////////////////////////////////////////////////////////////////////////

CUserInterfaceAudio::~CUserInterfaceAudio( void )
{
	//
	// shut down audio
	//

	if ( m_pDSound )
	{
		m_pDSound->Release();
		m_pDSound = NULL;
	}

}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Initialize
//
// Input: None
//
// Output: S_OK if input creation was successful, E_XXXX otherwise
//
// Description: sets up the app for processing sound
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
CUserInterfaceAudio::Initialize( void )
{
	HRESULT hr = S_OK;

	//
	// load up wave files
	//

	for ( DWORD i = 0; i < NUM_AUDIO_FILES && SUCCEEDED( hr ); i++ )
	{
		//
		// load the wave file
		//

		hr = m_sounds[i].Initialize( AUDIO_FILES[i] );
	//	ASSERT( SUCCEEDED( hr ) || ! "Could not load audio file" );
	}

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Play
//
// Input: dwSound - the id of the sound to play
//
// Output: S_OK if audio update was successful, E_XXXX otherwise
//
// Description: starts a sound playing
//
///////////////////////////////////////////////////////////////////////////////

HRESULT 
CUserInterfaceAudio::Play( DWORD dwSound )
{	
	HRESULT hr = S_OK;

	//
	// make sure sound value is in valid range
	//

	ASSERT( dwSound < NUM_AUDIO_FILES || ! "sound index is out of range" );

	if ( dwSound >= NUM_AUDIO_FILES )
	{
		hr = E_FAIL;
	}

	//
	// only play the sound if it is not playing
	//

	if ( SUCCEEDED( hr ) && ! m_sounds[dwSound].IsPlaying() )
	{
		hr = m_sounds[dwSound].Play();
		ASSERT( SUCCEEDED( hr ) || !"Could not play file" );
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ui\src\UserInterfaceMenu.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: UserInterfaceMenu.cpp
//
// Author: Dan Rosenstein (danrose)
//
// Description: the implementation for the base menu class
//
///////////////////////////////////////////////////////////////////////////////

#include "UserInterfaceMenu.h"
#include "UserInterfaceInput.h"
#include "UserInterfaceAudio.h"

///////////////////////////////////////////////////////////////////////////////
//
// Name: CUserInterfaceMenu constructor
//
// Input: szTitle - the title of the menu
//        dwFGColor - the default text fg color
//        dwBGColor - the defailt text bg color
//        dwTextX - the x location for text 
//        dwTextY - the y location for text
//
// Output: None
//
// Description: creates an instance of menu class
//
///////////////////////////////////////////////////////////////////////////////

CUserInterfaceMenu::CUserInterfaceMenu( LPSTR szTitle, 
									    DWORD dwFGColor, 
										DWORD dwBGColor, 
										DWORD dwTextX, 
										DWORD dwTextY )
	: m_items(),
	  m_screens(),
	  m_dwActive( 0 ),
	  m_dwFGColor( dwFGColor ),
	  m_dwBGColor( dwBGColor ),
	  m_dwFGColors(),
	  m_dwBGColors(),
	  m_szTitle( szTitle ),
	  m_dwTextX( dwTextX ),
	  m_dwTextY( dwTextY )
{
	//
	// no code here
	//
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: CAccountsScreen destructor
//
// Input: None
//
// Output: None
//
// Description: destroys an instance of the Account screen
//
///////////////////////////////////////////////////////////////////////////////

CUserInterfaceMenu::~CUserInterfaceMenu( void )
{
	//
	// remove the items from the menu
	//

	RemoveItems();
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: AddItem
//
// Input: szStr - the string to be displayed for this item
//        pScreen - the screen to goto if this item is selected, can be null
//
// Output: None
//
// Description: adds an item to a menu
//
///////////////////////////////////////////////////////////////////////////////

void
CUserInterfaceMenu::AddItem( LPSTR szStr, CUserInterfaceScreen* pScreen )
{
	ASSERT( szStr || !"need to pass in a valid string" );

	//
	// if the string was passed in
	//

	if ( szStr )
	{

		//
		// add the string and the screen to the lists
		//

		m_items.push_back( szStr );
		m_screens.push_back( pScreen );

		//
		// set the colors to the defailt
		//

		m_dwFGColors.push_back( m_dwFGColor );
		m_dwBGColors.push_back( m_dwBGColor );

		//
		// update the x drawing location for later
		//

		if ( NumItems() > 1 )
		{
			m_dwTextY -= 14;
		}
	}
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: NumImtes
//
// Input: None
//
// Output: DWORD - any non negative value is possible. 0 means there is nothing
//
// Description: returns the number of items in the menu
//
///////////////////////////////////////////////////////////////////////////////

DWORD
CUserInterfaceMenu::NumItems( void )
{
	return m_items.size();
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Item
//
// Input: dwIndex - an index into the array of items
//
// Output: the string at the index
//
// Description: returns the item string at the index provided
//
///////////////////////////////////////////////////////////////////////////////

LPSTR
CUserInterfaceMenu::Item( DWORD dwIndex )
{
	ASSERT( dwIndex < NumItems() || !"index out of range" );

	//
	// as long as the index is in range, return the string
	//

	if ( dwIndex < NumItems() )
	{
		return m_items[dwIndex];
	}

	//
	// otherwise return null
	//

	else
	{
		return NULL;
	}
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: RemoveItems
//
// Input: None
//
// Output: None
//
// Description: removes everything from the menu
//
///////////////////////////////////////////////////////////////////////////////

void
CUserInterfaceMenu::RemoveItems( void )
{ 
	//
	// go through the items until they are empty
	//

	while ( ! m_items.empty() ) { 

		//
		// pop the string, the screen
		//

		m_items.pop_back(); 
		m_screens.pop_back();

		//
		// and the colors
		//

		m_dwFGColors.pop_back();
		m_dwBGColors.pop_back();

		//
		// update the y location of text
		//

		if ( NumItems() > 1 )
		{
			m_dwTextY += 14;
		}
	}

	//
	// reset the active value
	//

	m_dwActive = 0;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Update
//
// Input: pInput - the ui input class
//        pAudio - the ui audio class
//
// Output: the next screen to display
//
// Description: does the default input handling for a menu
//
///////////////////////////////////////////////////////////////////////////////

CUserInterfaceScreen*
CUserInterfaceMenu::Update( CUserInterfaceInput* pInput, CUserInterfaceAudio* pAudio )
{
	HRESULT hr = S_OK;

	CUserInterfaceScreen* pRet = NULL;

	//
	// make sure params are good
	//

	ASSERT( pInput && pAudio || !"Parameters must not be null" );

	if ( ! pInput || ! pAudio )
	{
		return pRet;
	}

	//
	// process the input
	//

	//
	// if up was pressed and there are multiple items
	//

	if ( pInput->UpPressed() && HasMultipleItems() )
	{
		//
		// scroll up
		//

		ScrollActiveItemUp();
		hr = pAudio->PlayMenuItem();
	}

	//
	// down pressed and multiple items
	//

	else if ( pInput->DownPressed() && HasMultipleItems() )
	{
		//
		// scroll down
		//

		ScrollActiveItemDown();
		hr = pAudio->PlayMenuItem();
	}

	//
	// a pressed and no items active
	//

	else if ( pInput->APressed() && NoActiveItems() )
	{
		hr = pAudio->PlaySelectButton();
	} 

	//
	// a pressed an the active item does not have a screen
	//

	else if ( pInput->APressed() && ! ActiveItemHasScreen() )
	{
		hr = pAudio->PlaySelectButton();
	}

	//
	// a pressed and the active item does have a screen
	//

	else if ( pInput->APressed() && ActiveItemHasScreen() )
	{
		pRet = ActiveScreen();
		hr = pAudio->PlaySelectButton();
	}

	//
	// x is pressed and there are active items
	// and the active item has no screen
	//

	else if ( pInput->XPressed() && ! NoActiveItems() && ! ActiveItemHasScreen() )
	{
		hr = pAudio->PlayKeyboardStroke();
	}

	ASSERT( SUCCEEDED( hr ) || !"could not play audio file" );

	return pRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\voice\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ui\src\bitmapfile.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: BitmapFile.cpp
//
// Author: Dan Rosenstein (danrose)
//
// Description: the implementation for bitmap file class
//
///////////////////////////////////////////////////////////////////////////////

#include "bitmapfile.h"

///////////////////////////////////////////////////////////////////////////////
//
// Name: CBitmapFile constructor
//
// Input: None
//
// Output: None
//
// Description: creates an instance of the bitmap file class
//
///////////////////////////////////////////////////////////////////////////////

CBitmapFile::CBitmapFile( void ) 
	: m_dwImageSize( 0 ),
	  m_pdwPixels( NULL ),
	  m_iXpos( 0 ),
	  m_iYpos( 0 ),
	  m_wType( 19778 ),
	  m_dwFileSize( 192056 ), 
	  m_wReserved1( 0 ),
	  m_wReserved2( 0 ),
	  m_dwOffBits( 54 ),
	  m_dwInfoSize( 40 ),
	  m_dwWidth( 0 ),
	  m_dwHeight( 0 ),
	  m_wPlanes( 1 ),
	  m_wBitCount( 24 ),
	  m_dwCompression( 0 ),
	  m_dwSizeImage( 0 ),
	  m_dwXPelsPerMeter( 2834 ),
	  m_dwYPelsPerMeter( 2834 ),
	  m_dwClrUsed( 0 ),
	  m_dwClrImportant( 0 )
{
	//
	// no code here
	//
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: CBitmapFile destructor
//
// Input: None
//
// Output: None
//
// Description: destroys an instance of the bitmap file class
//
///////////////////////////////////////////////////////////////////////////////

CBitmapFile::~CBitmapFile( void )
{
	//
	// simply clean up the array
	//

    CleanUp();
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Cleanup
//
// Input: None
//
// Output: None
//
// Description: destroy any memory allocated for the bitmap file
//
///////////////////////////////////////////////////////////////////////////////

void 
CBitmapFile::CleanUp( void )
{
	//
	// if the array exists, delete it and reset it
	//

    if( m_pdwPixels )
    {
        delete [] m_pdwPixels;
        m_pdwPixels = NULL;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Read
//
// Input: iXloc - the x location to read from
//        iYloc - the y location to read from
//        pszFile - the name of the file ot read from
//
// Output: None
//
// Description: creates an instance of the bitmap file class
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
CBitmapFile::Read( INT iXloc, INT iYloc, LPSTR pszFile )
{
    FILE* pfInput = NULL;
    m_iXpos = iXloc;
    m_iYpos = iYloc;

	size_t uiSize = 0;

	//
    // Clean up any memory if necessary
	//

    CleanUp();

	//
    //open the new bitmap file
	//

    pfInput = fopen( pszFile, "rb" );

	//
	// return a failure if appropriate
	//

    if( !pfInput )
    {
		ASSERT( !"Could not open file" );
		return E_FAIL;
    }

	//
    // Read the Bitmap File header information
	//

    uiSize = fread( &m_wType, sizeof( WORD ), 1, pfInput );
	ASSERT( uiSize == 1 );

    uiSize = fread( &m_dwFileSize, sizeof( DWORD ), 1, pfInput );
	ASSERT( uiSize == 1 );

    uiSize = fread( &m_wReserved1, sizeof( WORD ), 1, pfInput );
	ASSERT( uiSize == 1 );

    uiSize = fread( &m_wReserved2, sizeof( WORD ), 1, pfInput );
	ASSERT( uiSize == 1 );

    uiSize = fread( &m_dwOffBits, sizeof( DWORD ), 1, pfInput );
	ASSERT( uiSize == 1 );

    uiSize = fread( &m_dwInfoSize, sizeof( DWORD ), 1, pfInput );
	ASSERT( uiSize == 1 );

    uiSize = fread( &m_dwWidth, sizeof( DWORD ), 1, pfInput );
	ASSERT( uiSize == 1 );

    uiSize = fread( &m_dwHeight, sizeof( DWORD ), 1, pfInput );
	ASSERT( uiSize == 1 );

    uiSize = fread( &m_wPlanes, sizeof( WORD ), 1, pfInput );
	ASSERT( uiSize == 1 );

    uiSize = fread( &m_wBitCount, sizeof( WORD ), 1, pfInput );
	ASSERT( uiSize == 1 );

    uiSize = fread( &m_dwCompression, sizeof( DWORD ), 1, pfInput );
	ASSERT( uiSize == 1 );

    uiSize = fread( &m_dwSizeImage, sizeof( DWORD ), 1, pfInput );
	ASSERT( uiSize == 1 );

    uiSize = fread( &m_dwXPelsPerMeter, sizeof( DWORD ), 1, pfInput );
	ASSERT( uiSize == 1 );

    uiSize = fread( &m_dwYPelsPerMeter, sizeof( DWORD ), 1, pfInput );
	ASSERT( uiSize == 1 );

    uiSize = fread( &m_dwClrUsed, sizeof( DWORD ), 1, pfInput );
	ASSERT( uiSize == 1 );

    uiSize = fread( &m_dwClrImportant, sizeof( DWORD ), 1, pfInput );
	ASSERT( uiSize == 1 );


	//
	// claculate the image isze
	//

    m_dwImageSize = m_dwWidth * m_dwHeight;

	//
	// allocate the pixels
	//

    m_pdwPixels = new DWORD[m_dwImageSize];

	//
	// return an error if there is one
	//

	if ( !m_pdwPixels )
	{
		ASSERT( !"Could not allocate memory" );
		return E_OUTOFMEMORY;
	}

	//
	// calculate the delta and remainder
	//

    float fRemainer = (float)m_dwWidth / 4;
    float fDelta = fRemainer - (int)fRemainer;

	//
	// start to read pixels
	//

    BYTE bBlue, bGreen, bRed;

	//
	// go through each row
	//

    for( int y = (int)m_dwHeight - 1; y >= 0 ; y-- )
    {

		//
		// go through each column
		//

        for( int x = 0; x < (int)m_dwWidth; x++ )
        {
			//
			// read the red, green and blue values
			//

            uiSize = fread( &bBlue, sizeof( BYTE ), 1, pfInput );
			ASSERT( uiSize == 1 );

            uiSize = fread( &bGreen, sizeof( BYTE ), 1, pfInput );
			ASSERT( uiSize == 1 );

            uiSize = fread( &bRed, sizeof( BYTE ), 1, pfInput );
			ASSERT( uiSize == 1 );


			//
			// calculate the psosition
			//

            int iPosition = ( y * (int)m_dwWidth ) + x;

			//
			// construct a 32 bit pixel value
			//

            m_pdwPixels[iPosition] = ( 0xff << 24 ) | 
				                     ( bRed << 16 ) | 
									 ( bGreen << 8 ) | 
									 ( bBlue );
        }

		//
        //account for the extra bytes in bitmap files
		//

        if( fDelta == 0.25f )
        {
            uiSize = fseek( pfInput, 1, SEEK_CUR );
			ASSERT( 0 == uiSize );
        }
        else if( fDelta == 0.50f )
        {
            uiSize = fseek( pfInput, 2, SEEK_CUR );
			ASSERT( 0 == uiSize );
        }
        else if( fDelta == 0.75f )
        {
            uiSize = fseek( pfInput, 3, SEEK_CUR );
			ASSERT( 0 == uiSize );
        }
    }

	//
	// close the file
	//

    fclose( pfInput );

	//
	// error paths above
	//

	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Render
//
// Input: pD3DDevice - the pointer to the screen
//
// Output: S_OK on success, E_XXXX on failure
//
// Description: renders the bitman to the back buffer
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
CBitmapFile::Render( IDirect3DDevice8* pD3DDevice )
{
    HRESULT hr = S_OK;
	IDirect3DSurface8* pD3DSurface = NULL;
    D3DLOCKED_RECT surfaceInfo;
    RECT container;

	//
    // Get the back buffer
	//

    hr = pD3DDevice->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &pD3DSurface );
	ASSERT( SUCCEEDED( hr ) || !"could not get back buffer" );

	//
	// fail if we can't get it
	//

	if ( FAILED( hr ) )
	{
		return hr;
    }

	//
	// set up the rect where we will draw to
	//

    container.top    = m_iYpos;
    container.left   = m_iXpos;
    container.bottom = m_iYpos + m_dwHeight;
    container.right  = m_iXpos + m_dwWidth;

	//
    // Lock our surface so we can write to it
	//

    hr = pD3DSurface->LockRect( &surfaceInfo, &container, D3DLOCK_TILED );
	ASSERT( SUCCEEDED( hr ) || !"could not lock rect" );

	//
	// fail off if an error occured
	//

	if ( FAILED( hr ) )
	{
		return hr;
	}

	//
	// copy the bits!
	//

    int iDestPitch = surfaceInfo.Pitch;
    int iSourcePitch = m_dwWidth * 4;
    BYTE* pbS = (BYTE*)m_pdwPixels;
    BYTE* pbP = (BYTE*)surfaceInfo.pBits;

    for( int y = 0; y < (int)m_dwHeight; y++ )
    {
        memcpy( pbP, pbS, iSourcePitch );
        pbS += iSourcePitch;
        pbP += iDestPitch;
    }

	//
    // Unlock our surface
	//

    pD3DSurface->UnlockRect();

	//
    // Release our Surface
	//

    if( pD3DSurface )
    {
        pD3DSurface->Release();
        pD3DSurface = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ui\src\UserInterfaceTextEntry.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: UserInterfaceTextEntry.cpp
//
// Author: Dan Rosenstein (danrose)
//
// Description: the implementation for the user interface text entry class
//
///////////////////////////////////////////////////////////////////////////////

#include "UserInterfaceTextEntry.h"

///////////////////////////////////////////////////////////////////////////////
//
// Name: constructor
//
// Input: dwMaxChars - the maximum number of chars allowed to be inputted
//        dwX - the X location for the text
//        dwY - the Y location for the text
//        dwFGColor - the foreground color for the text
//        dwBGColor - the background color for the text
//
// Output: None
//
// Description: creates a ui text entry object
//
///////////////////////////////////////////////////////////////////////////////

CUserInterfaceTextEntry::CUserInterfaceTextEntry( DWORD dwMaxChars,
										          DWORD dwX, 
										          DWORD dwY, 
										          DWORD dwFGColor, 
										          DWORD dwBGColor )

	//
	// create the base text UI object
	//

	: CUserInterfaceText( "", dwX, dwY, dwFGColor, dwBGColor ),
	  m_dwMaxChars( dwMaxChars ),
	  m_szInput( NULL ),
	  m_szSelect( NULL ),
	  m_cCurChar( START_CHAR ),
	  m_dwCurIndex( 0 ),
	  m_bInit( FALSE )
{
	ASSERT( 0 != dwMaxChars );
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Destructor
//
// Input: None
//
// Output: None
//
// Description: destroys a UI Text entry object
//
///////////////////////////////////////////////////////////////////////////////

CUserInterfaceTextEntry::~CUserInterfaceTextEntry( void )
{
	//
	// destory the internal string
	//

	if ( NULL != m_szInput )
	{
		delete [] m_szInput;
		m_szInput = NULL;
	}

	//
	// destroy the select string
	//

	if ( NULL != m_szSelect )
	{
		delete [] m_szSelect;
		m_szSelect = NULL;
	}
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: UpdateSelectText
//
// Input: none
//
// Output: none
//
// Description: updates the text buffer
//
///////////////////////////////////////////////////////////////////////////////

void  
CUserInterfaceTextEntry::UpdateSelectText( void )
{
	//
	// concatenante the strings, set the text
	//

	sprintf( m_szSelect, SELECT_FORMAT_STRING, m_szInput, m_cCurChar );

	SetText( m_szSelect );
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Init
//
// Input: none
//
// Output: the final HR
//
// Description: init the text entry class
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
CUserInterfaceTextEntry::Init( void )
{
	HRESULT hr = S_OK;

	//
	// reset the current index
	//

	m_dwCurIndex = 0;

	//
	// kill off the input string if necessary
	//

	if ( m_szInput )
	{
		delete [] m_szInput;
	}

	//
	// kill of the select string
	//

	if ( m_szSelect )
	{
		delete [] m_szSelect;
	}

	//
	// allocate the input string
	//

	if ( SUCCEEDED( hr ) )
	{
		m_szInput = new CHAR[m_dwMaxChars + 1];
		hr = NULL == m_szInput ? E_OUTOFMEMORY : S_OK;
	}

	//
	// allocate the select string
	//

	if ( SUCCEEDED( hr ) )
	{
		m_szSelect = new CHAR[strlen( Text() ) + m_dwMaxChars + MAX_SELECT_CHARS + 1];
		hr = NULL == m_szInput ? E_OUTOFMEMORY : S_OK;
	}

	//
	// zero out the strings
	//

	if ( SUCCEEDED( hr ) )
	{
		ZeroMemory( m_szInput, m_dwMaxChars + 1 );
		ZeroMemory( m_szSelect, strlen( Text() ) + MAX_SELECT_CHARS + m_dwMaxChars + 1 );
	}

	//
	// don't init again
	//

	if ( SUCCEEDED( hr ) )
	{
		m_bInit = TRUE;
	}

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Update
//
// Input: pInput - the input ui class
//        pAudio - the input audio class
//
// Output: the final HR
//
// Description: process input
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
CUserInterfaceTextEntry::Update( CUserInterfaceInput* pInput, CUserInterfaceAudio* pAudio )
{
	HRESULT hr = S_OK;

	//
	// only init once
	//

	if ( ! m_bInit )
	{
		hr = Init();
	}

	//
	// if left is pressed, scroll left
	//

	if ( pInput->LeftPressed() )
	{
		if ( --m_cCurChar < START_CHAR )
			m_cCurChar = END_CHAR;

		hr = pAudio->PlayMenuItem();
	}

	//
	// if right is pressed, scroll right
	//

	if ( pInput->RightPressed() )
	{
		if ( ++m_cCurChar > END_CHAR )
			m_cCurChar = START_CHAR;

		hr = pAudio->PlayMenuItem();
	}

	//
	// if A is pressed
	//

	if ( pInput->XPressed() )
	{
		m_szInput[m_dwCurIndex] = m_cCurChar;

		if ( m_dwMaxChars == ++m_dwCurIndex )
		{
			m_dwCurIndex = m_dwMaxChars - 1;
		}

		hr = pAudio->PlayKeyboardStroke();
	}

	//
	// if B is pressed
	//

	if ( pInput->YPressed() )
	{
		if ( 0xFFFFFFFF == --m_dwCurIndex )
		{
			m_dwCurIndex = 0;
		}

		m_szInput[m_dwCurIndex] = '\0';

		hr = pAudio->PlayKeyboardStroke();
	}

	//
	// update the select string
	//
	
	if ( SUCCEEDED( hr ) )
	{
		UpdateSelectText();
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ui\src\wavemedia.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: wavemedia.cpp
//
// Author: Dan Rosenstein (danrose)
//
// Description: the implementation of the wavemedia class
//
///////////////////////////////////////////////////////////////////////////////

#include "wavemedia.h"

///////////////////////////////////////////////////////////////////////////////
//
// Name: CWaveMedia
//
// Input: None
//
// Output: an instance of the wave media class
//
// Description: constructs a wave media object
//
///////////////////////////////////////////////////////////////////////////////

CWaveMedia::CWaveMedia( void )
	: m_pDSoundBuffer( NULL ),
	  m_pFMOFile( NULL )
{
	//
    // Zero Out our local object memory
	//

    ZeroMemory( &m_xmp, sizeof( XMEDIAPACKET ) );
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: ~CWaveMedia
//
// Input: None
//
// Output: None
//
// Description: destorys the wave file
//
///////////////////////////////////////////////////////////////////////////////

CWaveMedia::~CWaveMedia( void )
{

	//
    // Clean up our DSound buffer if it was allocated
	//

    if( m_pDSoundBuffer )
    {
        m_pDSoundBuffer->Release();
        m_pDSoundBuffer = NULL;
    }

	//
    // Clean up our WAV Data
	//

    if( m_xmp.pvBuffer )
    {
        delete[] m_xmp.pvBuffer;
        m_xmp.pvBuffer = NULL;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Initialize
//
// Input: szWaveFileName - the name of the file to open
//        lDefaultVolume - the volume for the sound
//
// Output: None
//
// Description: destorys the wave file
//
///////////////////////////////////////////////////////////////////////////////

HRESULT 
CWaveMedia::Initialize( LPSTR szWaveFileName, LONG lDefaultVolume )
{
	HRESULT hr = S_OK;

	//
	// make sure input parameters are ok
	//

	ASSERT( szWaveFileName || !"Need to pass in wave file name" );

    if( ! szWaveFileName )
    {
		hr = E_POINTER;
    }

	//
	// Process the wave file
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = ProcessWaveFile( szWaveFileName );
	//	ASSERT( SUCCEEDED( hr ) || !"could not process wave file" );
	}

	//
	// set up the volume
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = SetVolume( lDefaultVolume );
		ASSERT( SUCCEEDED( hr ) || ! "could not set volume" );
	}

	//
	// spit back the hr
	//

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: ProcessWaveFile
//
// Input: szWaveFileName - the name of the wave file to process
//
// Output: S_OK if processing was ok, E_XXXX otherwise
//
// Description: opens the wave file, puts it in memory
//
///////////////////////////////////////////////////////////////////////////////

HRESULT 
CWaveMedia::ProcessWaveFile( LPSTR szWaveFileName )
{
	HRESULT hr = S_OK;

	LPDIRECTSOUND pDSound = NULL;
	LPCWAVEFORMATEX pWfx = NULL;

    DSBUFFERDESC dsbd;

	//
	// check to make sure sound buffer does not exists
	//

	ASSERT( !m_pDSoundBuffer || !"Dsound buffer allocated" );

	if ( m_pDSoundBuffer )
	{
		hr = E_POINTER;
	}

	//
	// Zero out hte buffer description
	//

    ZeroMemory( &dsbd, sizeof( DSBUFFERDESC ) );

	//
	// init dsound
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = DirectSoundCreate( NULL, &pDSound, NULL );
		ASSERT( SUCCEEDED( hr ) || ! "Could not init dsound" );
	}

	//
    // Create the File Media Object
	//

    if( SUCCEEDED( hr ) )
	{
		hr = XWaveFileCreateMediaObject( szWaveFileName, &pWfx, &m_pFMOFile );
	//	ASSERT( SUCCEEDED( hr ) || ! "Could not create File XMO" );
    }

	//
	// create the sound buffer
	//

	if ( SUCCEEDED( hr ) )
	{
		//
		// fill in the sound buffer
		//

		dsbd.dwSize = sizeof( DSBUFFERDESC );
		dsbd.lpwfxFormat = (LPWAVEFORMATEX) pWfx;

		//
		// Create the DSound Buffer
		//

		hr = pDSound->CreateSoundBuffer( &dsbd, &m_pDSoundBuffer, NULL );
		ASSERT( SUCCEEDED( hr ) || !"Could not create sound buffer" );
    }

	//
    // Get the length of the media file
	//
    if( SUCCEEDED( hr ) )
	{
		hr = m_pFMOFile->GetLength( &m_xmp.dwMaxSize );
		ASSERT( SUCCEEDED( hr ) || !"Could not get length of file" );
    }

	//
	// Create a buffer of the size of the length
	//

	if ( SUCCEEDED( hr ) )
	{
		m_xmp.pvBuffer = new BYTE[ m_xmp.dwMaxSize ];
		hr = m_xmp.pvBuffer ? S_OK : E_OUTOFMEMORY;

		ASSERT( SUCCEEDED( hr ) || !"could not allocate memory for buffer" );
	}

	//
	// Precache out the buffer data
	//

    if ( SUCCEEDED( hr ) )
	{
		hr = m_pFMOFile->Process( NULL, &m_xmp );
		ASSERT( SUCCEEDED( hr ) || !"Could not precache audio data" );
	}

    //
    // Set the buffer data
    //
    
	if ( SUCCEEDED( hr ) )
	{
		hr = m_pDSoundBuffer->SetBufferData( m_xmp.pvBuffer, m_xmp.dwMaxSize );
		ASSERT( SUCCEEDED( hr ) || !"Could not set buffer data" );
	}

	//
	// spit back the hr
	//

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: IsPlaying
//
// Input: None
//
// Output: None
//
// Description: destorys the wave file
//
///////////////////////////////////////////////////////////////////////////////

BOOL 
CWaveMedia::IsPlaying( void )
{
	HRESULT hr = S_OK;
    DWORD dwSoundStatus = 0;
  
	//
	// check to make sure sound buffer exists
	//

	if ( ! m_pDSoundBuffer )
	{
		return FALSE;
	}

	//
	// get the status of dsound
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = m_pDSoundBuffer->GetStatus( &dwSoundStatus );
		ASSERT( SUCCEEDED( hr ) || !"Could not get status" );
	}

	//
	// return if the sound is still playing or not
	//

	return SUCCEEDED( hr ) && dwSoundStatus & DSBSTATUS_PLAYING;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: SetVolume
//
// Input: lVolume - the new volume for the wave file
//
// Output: S_OK if setting volume succeeded, E_XXX otherwise
//
// Description: Set the volume of the WAV file
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
CWaveMedia::SetVolume( LONG lVolume )
{
	HRESULT hr = S_OK;

	//
	// check to make sure sound buffer exists
	//

	ASSERT( m_pDSoundBuffer || !"Dsound buffer not allocated" );

	if ( ! m_pDSoundBuffer )
	{
		hr = E_POINTER;
	}

	//
	// set the volume
	//

    if ( SUCCEEDED( hr ) )
	{
		hr = m_pDSoundBuffer->SetVolume( lVolume ); 
		ASSERT( SUCCEEDED( hr ) || !"could not set volume" );
	}

	//
	// spit back the hr
	//

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Play
//
// Input: None
//
// Output: S_OK if playing succeeded, E_XXX otherwise
//
// Description: Play the wave file
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
CWaveMedia::Play( void )
{
	HRESULT hr = S_OK;

	//
	// check to make sure sound buffer exists
	//

	if ( ! m_pDSoundBuffer )
	{
		return S_OK;
	}

	//
	// reset the wave
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = ResetToBeginning();
		ASSERT( SUCCEEDED( hr ) || !"Could not reset wave" );
	}

	//
	// play the buffer
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = m_pDSoundBuffer->Play( 0, 0, 0 );
		ASSERT( SUCCEEDED( hr ) || !"Could not play buffer" );
	}

	//
	// spit back the hr
	//

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Stop
//
// Input: None
//
// Output: S_OK if playing succeeded, E_XXX otherwise
//
// Description: Stop the wave file
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
 CWaveMedia::Stop( void )
{
	HRESULT hr = S_OK;

	//
	// check to make sure sound buffer exists
	//

	ASSERT( m_pDSoundBuffer || !"Dsound buffer not allocated" );

	if ( ! m_pDSoundBuffer )
	{
		hr = E_POINTER;
	}

	//
	// stop the buffer
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = m_pDSoundBuffer->Stop();
		ASSERT( SUCCEEDED( hr ) || !"Could not stop buffer" );
	}

	//
	// spit back hr
	//

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: ResetToBeginning
//
// Input: None
//
// Output: S_OK if playing succeeded, E_XXX otherwise
//
// Description: resets the wave file to the beginning
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
CWaveMedia::ResetToBeginning( void )
{
	HRESULT hr = S_OK;

	//
	// check to make sure sound buffer exists
	//

	ASSERT( m_pDSoundBuffer || !"Dsound buffer not allocated" );

	if ( ! m_pDSoundBuffer )
	{
		hr = E_POINTER;
	}

	//
	// reset the current position
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = m_pDSoundBuffer->SetCurrentPosition( 0 );
		ASSERT( SUCCEEDED( hr ) || !"Could not set current position" );
	}

	//
	// spit back the hr
	//

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\voice\queuexmo.cpp ===
//-----------------------------------------------------------------------------
// File: QueueXMO.cpp
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntos.h>

#ifdef __cplusplus
}
#endif // __cplusplus

#define  NODSOUND
#include <xtl.h>
#include <dsound.h>

#include "xvocver.h"
#include "xvoice.h"
#include "QueueXMOp.h"
#include "voiceencoder.h"

//
// The interface
//
//////////////////////////////////////////////////////////////////////////////
XBOXAPI 
HRESULT 
WINAPI
XVoiceQueueCreateMediaObject(LPQUEUE_XMO_CONFIG pConfig , LPXVOICEQUEUEMEDIAOBJECT *ppVoiceQueueMediaObject)
{   
    
    CQueueXMO *pQueueXmo;

	HRESULT hr = QUEUE_S_OK;
    
    do
    {
		*ppVoiceQueueMediaObject = NULL;

		//
		// Create Queue XMO
		//
		pQueueXmo = new CQueueXMO;

		if ( NULL == pQueueXmo )
		{
			hr = QUEUE_E_OUTOFMEMORY;
			break;
		}

		//
        // Initialize with the given parameters
        //
		hr = pQueueXmo->Initialize(pConfig);

		if (SUCCEEDED(hr)) 
		{
			*ppVoiceQueueMediaObject = pQueueXmo;
		}
		else
		{
			delete pQueueXmo;
		}
     
    }
    while( FALSE );
    
    return( hr );

}

//
// Public Method: Get output buffer size for the encoder depending on the PCM buffer size to be encoded 
// The same buffer sizes apply to the decoder , too
//
XBOXAPI 
HRESULT 
WINAPI
XVoiceGetCodecBufferSize( const LPXMEDIAOBJECT pCodecMediaObject, WORD wPCMBufferSize , WORD *pwCodecBufferSize)
{
	DOUBLE dCompressionRate;

    if( NULL !=  pCodecMediaObject)
    {
        XMEDIAINFO info;
        pCodecMediaObject->GetInfo(&info);

        //
        // The codec has a fixed compression rate and the compressed packet contains a header
        //
		if( info.dwInputSize >  info.dwOutputSize)
        {
			//
            // Encoder
            //
			dCompressionRate = (DOUBLE)info.dwInputSize / (DOUBLE)(info.dwOutputSize - sizeof(VOICE_ENCODER_HEADER));
        }
		else
		{
            //
            // Decoder
            //
			dCompressionRate = (DOUBLE)info.dwOutputSize / (DOUBLE)(info.dwInputSize - sizeof(VOICE_ENCODER_HEADER));
		}

        *pwCodecBufferSize = (WORD)((DOUBLE)wPCMBufferSize / dCompressionRate) + sizeof(VOICE_ENCODER_HEADER);
    }
    else
    {
        *pwCodecBufferSize = 0;
    }

	return (QUEUE_S_OK);
}


//
// Class CQueueXMO implementation
//
//////////////////////////////////////////////////////////////////////////////
void CQueueXMO::Cleanup()
{
	if( NULL != m_pdHighWaterMarkQuality )
    {
		delete [] m_pdHighWaterMarkQuality;
    }

	if( NULL != m_pBufferPool )
    {
		delete [] m_pBufferPool;
    }

	if( NULL != m_pHeapForBuffers )
    {
		delete [] m_pHeapForBuffers;
    }

	if( NULL != m_pSavedBuffer )
    {
		delete [] m_pSavedBuffer;
    }

    if(m_pDecoder)
    {
        m_pDecoder->Release();
        m_pDecoder = NULL;
    }
}

void CQueueXMO::SetConfigDefaults(LPQUEUE_XMO_CONFIG pConfig)
{
    //
    // In case pConfig members set to 0 -> use defaults
    //
	if( 0 == pConfig->wVoiceSamplingRate )
    {
		pConfig->wVoiceSamplingRate = 8000;
    }
	RIP_ON_NOT_TRUE("XVoiceQueueCreateMediaObject()", ( 8000 == pConfig->wVoiceSamplingRate));

	if( 0 ==  pConfig->dwCodecTag)
    {
		pConfig->dwCodecTag = WAVE_FORMAT_VOXWARE_SC06;
    }
	RIP_ON_NOT_TRUE("XVoiceQueueCreateMediaObject()", ((WAVE_FORMAT_VOXWARE_SC06 == pConfig->dwCodecTag) ||
		                                               (WAVE_FORMAT_VOXWARE_SC03 == pConfig->dwCodecTag)));

	if( 0 ==  pConfig->wMsOfDataPerPacket)
    {
		pConfig->wMsOfDataPerPacket = 40;
    }
	RIP_ON_NOT_TRUE("XVoiceQueueCreateMediaObject()", ( 0 == pConfig->wMsOfDataPerPacket % 20 ));

	if( 0 == pConfig->wMinDelay )
    {
		pConfig->wMinDelay = 80;
    }

	if( 0 ==  pConfig->wMaxDelay)
    {
		pConfig->wMaxDelay = 1000;
    }
	RIP_ON_NOT_TRUE("XVoiceQueueCreateMediaObject()", ( pConfig->wMaxDelay >= pConfig->wMinDelay ));

	if( 0 == pConfig->wInitialHighWaterMark )
    {
		pConfig->wInitialHighWaterMark = 80;
    }
	RIP_ON_NOT_TRUE("XVoiceQueueCreateMediaObject()", ( pConfig->wInitialHighWaterMark >= pConfig->wMinDelay ));

	if( 0.0 == pConfig->dIdealQuality )
    {
		pConfig->dIdealQuality = 0.005;
    }
	RIP_ON_NOT_TRUE("XVoiceQueueCreateMediaObject()", (( 0 <= pConfig->dIdealQuality ) && (1 >= pConfig->dIdealQuality)));

	pConfig->dInitialFrameStrength = (DOUBLE)(pConfig->wMsOfDataPerPacket)/(DOUBLE)30000;

}

HRESULT STDMETHODCALLTYPE CQueueXMO::Initialize( LPQUEUE_XMO_CONFIG pConfig )
{
	HRESULT hr = QUEUE_S_OK;
	int i;

	do
	{
		SetConfigDefaults(pConfig);

		//
        // Compute dimensions for the queue
        //
		m_wMsOfDataPerBuffer = pConfig->wMsOfDataPerPacket;
		m_wBufferPoolSize = pConfig->wMaxDelay / m_wMsOfDataPerBuffer;

		WORD wXVoiceBytesPerMs = ( pConfig->wVoiceSamplingRate / 1000 ) * 2 ;
		m_wXVoiceBufferSize = wXVoiceBytesPerMs * pConfig->wMsOfDataPerPacket;
				
		m_wHighWaterMark = pConfig->wInitialHighWaterMark;
		m_PreviousTime = 0;

		m_dIdealQuality = pConfig->dIdealQuality;
		m_dFrameStrength = pConfig->dInitialFrameStrength;
		m_dCurrentTalkspurtWeighting = 0;
		m_wNumberOfFramesInTalkspurt = 0;
		m_bCurrentTalkspurtID = 0;
		m_wErrorCount = 0;

		m_wMaxHighWaterMark = pConfig->wMaxDelay;
	    m_wMinHighWaterMark = pConfig->wMinDelay;

		m_wHighWaterMarkQualitySize = (m_wMaxHighWaterMark - m_wMinHighWaterMark) / m_wMsOfDataPerBuffer + 1;

		//
        // Create voice decoder
        //
		WAVEFORMATEX wfxFormat;
		wfxFormat.wFormatTag = WAVE_FORMAT_PCM;
		wfxFormat.nChannels = 1;
		wfxFormat.nSamplesPerSec = pConfig->wVoiceSamplingRate;
		wfxFormat.nAvgBytesPerSec = 2 * pConfig->wVoiceSamplingRate;
		wfxFormat.nBlockAlign = 2;
		wfxFormat.wBitsPerSample = 16;
		wfxFormat.cbSize = 0;

        hr = XVoiceDecoderCreateMediaObject( pConfig->dwCodecTag,
                                             &wfxFormat,
                                             &m_pDecoder );
        if( FAILED( hr ) )
        {

#ifdef _DEBUG_PRINT
            DebugPrint("CQueueXMO::Initialize( )...Voice decoder failed with %x", hr);
#endif
            break;
        }

		//
        // Get the codec buffer size for this decoder
        //
		XVoiceGetCodecBufferSize( m_pDecoder, m_wXVoiceBufferSize , &m_wCodecBufferSize);
		
		//
        // Allocate memory for the array of HWM quality history
        //
		m_pdHighWaterMarkQuality = new DOUBLE[m_wHighWaterMarkQualitySize];
		if ( NULL == m_pdHighWaterMarkQuality )
		{
			hr = QUEUE_E_OUTOFMEMORY;
			break;
		}

		//
        // Allocate memory for saved buffer for lost packets
        //
		m_pSavedBuffer = new BYTE[m_wXVoiceBufferSize];
		if( NULL ==  m_pSavedBuffer)
        {	
			hr = QUEUE_E_OUTOFMEMORY;
			break;
        }
				
		//
        // Allocate memory for the buffers
        //
		m_pHeapForBuffers = new BYTE[ m_wBufferPoolSize * m_wCodecBufferSize];		
		if ( NULL == m_pHeapForBuffers )
		{
			hr = QUEUE_E_OUTOFMEMORY;
			break;
		}

		//
        // Allocate memory for the list of buffers
        //
		m_pBufferPool = new BufferList[m_wBufferPoolSize];
		if ( NULL == m_pBufferPool )
		{
			Cleanup();
			hr = QUEUE_E_OUTOFMEMORY;
			break;
		}

		//
        // Initialize free buffers list 
        //
		for( i = 1 ; i < m_wBufferPoolSize - 1; i++ )
        {
			m_pBufferPool[i].m_pbBuffer = m_pHeapForBuffers + i * m_wCodecBufferSize;
			m_pBufferPool[i].m_pPrev = &m_pBufferPool[i - 1];
			m_pBufferPool[i].m_pNext = &m_pBufferPool[i + 1];
        }
		m_pFreeEntriesList = &m_pBufferPool[0];
		m_pBufferPool[0].m_pNext = &m_pBufferPool[1];
		m_pBufferPool[0].m_pbBuffer = m_pHeapForBuffers;
		m_pBufferPool[m_wBufferPoolSize - 1].m_pPrev = &m_pBufferPool[m_wBufferPoolSize - 2];
		m_pBufferPool[m_wBufferPoolSize - 1].m_pbBuffer = m_pHeapForBuffers + (m_wBufferPoolSize - 1) * m_wCodecBufferSize;

		//
		// Initialize the array of HWM quality history
		//
		for( i = 0 ; i < m_wHighWaterMarkQualitySize ; i++ )
        {
			m_pdHighWaterMarkQuality[i] = m_dIdealQuality;
        }
	}
	while( FALSE );

	return( hr );
}

HRESULT STDMETHODCALLTYPE CQueueXMO::Process( LPCXMEDIAPACKET pSrcBuffer, LPCXMEDIAPACKET pDstBuffer )
{
	HRESULT hr = QUEUE_S_OK;
    
    if( NULL != pSrcBuffer )
    {
    	hr = InputProcess(pSrcBuffer);
    }

	if( NULL != pDstBuffer )
    {
		hr = OutputProcess(pDstBuffer);
    }
    
    return( hr );
}


HRESULT CQueueXMO::InputProcess(LPCXMEDIAPACKET pInMediaPacket)
{
	HRESULT hr = QUEUE_S_OK;
    
    do
    {
		if( VOICE_MESSAGE_TYPE_VOICE != ((PVOICE_ENCODER_HEADER)(pInMediaPacket->pvBuffer))->bType)
        {
			if(m_bStartTiming)
			{
#ifdef _DEBUG_PRINT
			    DebugPrint("CQueueXMO::InputProcess...Drop silence packet!\n");
#endif
			    break;
			}
        }

		//
        // Get an empty buffer for putting the new data in
        //
		BufferList *pWorkingBuffer = GetInputWorkingBuffer();
		if( NULL == pWorkingBuffer )
        {
			hr = QUEUE_E_FULL;
#ifdef _DEBUG_PRINT
			DebugPrint("CQueueXMO::InputProcess...The queue is full!\n");
#endif
			break;
        }
     

		//
        // Fill the buffer with the contents of input media packet
        //
		WORD wInSeqNo = ((PVOICE_ENCODER_HEADER)(pInMediaPacket->pvBuffer))->wSeqNum;
		BYTE bMsgNum = ((PVOICE_ENCODER_HEADER)(pInMediaPacket->pvBuffer))->bMsgNum;

		if( !m_bStartTiming )
	    {
			//
			// Start measuring the real time
			//
			m_RealStartOutputTime = GetTickCount();
			m_LogicalOutputTime = 0;
			m_wCurrentSeqNo = wInSeqNo;
		    m_bCurrentTalkspurtID = bMsgNum;

			//
            // Up to 1 second of difference between arrived sequences 
			// After that, we do some computation to recover from the "discontinuity"
            // that came up on the other end
			//
			m_wSafeDeltaSeq = 1000 / m_wMsOfDataPerBuffer;
			
			m_bStartTiming = TRUE;
		}

		
		if( wInSeqNo + m_wSafeDeltaSeq < m_wCurrentSeqNo )
        {
			// Assuming reset sequence numbers on the other side
		    // GetTickCount() - m_RealStartOutputTime + m_wMsOfDataPerBuffer -> fair guess of this packet's output time
		    // round to complete packet time 
		    TimeStamp outputTime = GetTickCount() - m_RealStartOutputTime + m_wMsOfDataPerBuffer;
		    outputTime -= (outputTime % m_wMsOfDataPerBuffer);
			
			//
            // Make sure 2 packets don't have the same output time
            //
			pWorkingBuffer->m_timestamp = max(outputTime , m_PreviousTime + m_wMsOfDataPerBuffer);

        }
		else
		{
			//
            // Normal sequencing
            //
			LONG nCandidateTimestamp = (LONG)m_PreviousTime + ((LONG)wInSeqNo - (LONG)m_wCurrentSeqNo) * m_wMsOfDataPerBuffer; 
			if(nCandidateTimestamp >= 0)
			{
				pWorkingBuffer->m_timestamp = nCandidateTimestamp;
			}
			else
			{
#ifdef _DEBUG_PRINT
			DebugPrint("Drop buffer created before we started counting time: pWorkingBuffer->m_timestamp = %d\n", nCandidateTimestamp);
#endif
				//
                // This packet came before we started counting time; drop it
                //
				AddFreeBuffer(pWorkingBuffer);
				break;
			}
		}

		//
        // Check for a new talkspurt
        //
		if( bMsgNum !=  m_bCurrentTalkspurtID )
        {
			//
            // Get into account the completed talkspurt - adapt to new network conditions
            //
			RecomputeQueueParameters();
			m_bCurrentTalkspurtID = bMsgNum;
        }

		if( 0 == m_wNumberOfFramesInTalkspurt  )
        {
			//
			// Resync the local clock with the time given by the input
			//
#ifdef _DEBUG_PRINT
			DebugPrint("***Resync clock - Before: %d\n" , m_RealStartOutputTime);
#endif

			m_RealStartOutputTime = GetTickCount() - pWorkingBuffer->m_timestamp;

#ifdef _DEBUG_PRINT
			DebugPrint("***Resync clock - After: %d\n" , m_RealStartOutputTime);
#endif
        }
		m_wNumberOfFramesInTalkspurt++;

#ifdef _DEBUG_PRINT
		DebugPrint("wInSeqNo=%d bCurrentTalkspurtID=%d\n", wInSeqNo , m_bCurrentTalkspurtID);
#endif

		if( m_LogicalOutputTime > pWorkingBuffer->m_timestamp)
        {
			//
            // This buffer is late
            //
#ifdef _DEBUG_PRINT
			DebugPrint("Buffer late: pWorkingBuffer->m_timestamp = %d\n", pWorkingBuffer->m_timestamp);
#endif
			if( bMsgNum ==  m_bCurrentTalkspurtID )
            {
           		//
				// Count it as an error only if it's part of the current talkspurt
				//
				IncrementErrorCount();
			}
		    AddFreeBuffer(pWorkingBuffer);
        }
		else
		{
			memcpy(pWorkingBuffer->m_pbBuffer , pInMediaPacket->pvBuffer , m_wCodecBufferSize);

			//
			// Add the buffer to the list of in use entries
			//
			hr = AddInUseBuffer(pWorkingBuffer);
			
			if( SUCCEEDED( hr ) )
            {
				//
				// Update the current sequence number and previous time
				//
				m_wCurrentSeqNo = wInSeqNo;
				m_PreviousTime = pWorkingBuffer->m_timestamp;

#ifdef _DEBUG_PRINT
			DebugPrint("Insert buffer: pWorkingBuffer->m_timestamp = %d\n", pWorkingBuffer->m_timestamp);
#endif

            }
			else
			{
				AddFreeBuffer(pWorkingBuffer);
#ifdef _DEBUG_PRINT
			DebugPrint("Drop duplicated buffer: pWorkingBuffer->m_timestamp = %d\n", pWorkingBuffer->m_timestamp);
#endif
			}
		}			

    }
    while( FALSE );

	//
    // Update output parameters
    //
	if(pInMediaPacket->pdwCompletedSize) 
	{
        *pInMediaPacket->pdwCompletedSize = SUCCEEDED(hr) ? pInMediaPacket->dwMaxSize : 0;
    }

    if(pInMediaPacket->pdwStatus) 
	{
        *pInMediaPacket->pdwStatus = SUCCEEDED(hr) ? XMEDIAPACKET_STATUS_SUCCESS : XMEDIAPACKET_STATUS_FAILURE;
    }

    if (pInMediaPacket->hCompletionEvent)
	{
        SetEvent(pInMediaPacket->hCompletionEvent);
    }
    
    return( hr );

}


HRESULT CQueueXMO::OutputProcess(LPCXMEDIAPACKET pOutMediaPacket)
{
	HRESULT hr = QUEUE_S_OK;
	BOOL bReturnSilence;
	BOOL bIsNextPacketLost;
    
	assert(pOutMediaPacket->dwMaxSize % m_wXVoiceBufferSize == 0);

    do
    {
		if( !m_bStartTiming )
        {
			hr = QUEUE_E_NOINPUTYET;
#ifdef _DEBUG_PRINT
			DebugPrint("CQueueXMO::OutputProcess...No input yet!\n");
#endif
			break;
        }
		//
        // Get the next buffer to be decoded and returned
        //
		BufferList *pWorkingBuffer = GetOutputWorkingBuffer(&bReturnSilence , &bIsNextPacketLost);	        
		memset(pOutMediaPacket->pvBuffer , 0 , pOutMediaPacket->dwMaxSize);

		if( NULL == pWorkingBuffer )
        {
			if(!bReturnSilence)
			{
				//
                // The high water mark is not reached
                //
				hr = QUEUE_E_HWMNOTREACHED;
#ifdef _DEBUG_PRINT
				DebugPrint("CQueueXMO::OutputProcess...High water mark not reached!\n");
#endif
				break;
			}
			else
			{
				//
                // Packet lost or late
                //
			    if(m_bVoiceReturned)
				{
    				//
                    // Mark the starting moment for rendering previous packet
                    //
				    m_bVoiceReturned = FALSE;
			        m_wAttenuatedBackupMs = 0;
				}

			    if(m_wAttenuatedBackupMs < MAX_MILISECONDS_OF_ATTENUATED_VOICE)
				{
					m_wAttenuatedBackupMs += m_wMsOfDataPerBuffer;

					CopyAttenuatedBuffer(pOutMediaPacket , 1.0);

					// m_LastOutputInfo.nMaxPower is the same as the previous

#ifdef _DEBUG_PRINT
					DebugPrint("CQueueXMO::OutputProcess...Return attenuated(1.0) previous packet!\n");
#endif
				}
				else
				{
				    //
                    // Silence returned for some time now
                    //
#ifdef _DEBUG_PRINT
				    DebugPrint("CQueueXMO::OutputProcess...Return silence!\n");
#endif
					m_LastOutputInfo.nMaxPower = 0;
				}
			}
        }
		else
		{
			m_LastOutputInfo.nMaxPower = (((PVOICE_ENCODER_HEADER)(pWorkingBuffer->m_pbBuffer))->bType);

			//
            // Decompress 
            //
			hr = DecompressMediaBuffer(pWorkingBuffer, pOutMediaPacket);
#ifdef _DEBUG_PRINT
			DebugPrint("CQueueXMO::Return buffer pWorkingBuffer->m_timestamp = %d\n", pWorkingBuffer->m_timestamp);
#endif

			//
			// Free the working buffer
			//
			AddFreeBuffer(pWorkingBuffer);

			m_bVoiceReturned = TRUE;
			if( bIsNextPacketLost )
            {
				//
                // Save this buffer in case next one doesn't show up until its output time
                //
				memcpy(m_pSavedBuffer , pOutMediaPacket->pvBuffer , pOutMediaPacket->dwMaxSize); 
            }

			
		}
    
		//
        // Update the logical output time
        //
		m_LogicalOutputTime += m_wMsOfDataPerBuffer;

        hr = QUEUE_S_OK;
    }
    while( FALSE );

	//
    // Update output parameters
    //
	if(pOutMediaPacket->pdwCompletedSize) 
	{
	    *pOutMediaPacket->pdwCompletedSize = SUCCEEDED(hr) ? pOutMediaPacket->dwMaxSize : 0;
    }

    if(pOutMediaPacket->pdwStatus) 
	{
        *pOutMediaPacket->pdwStatus = SUCCEEDED(hr) ? XMEDIAPACKET_STATUS_SUCCESS : XMEDIAPACKET_STATUS_FAILURE;
    }

    if (pOutMediaPacket->hCompletionEvent)
	{
        SetEvent(pOutMediaPacket->hCompletionEvent);
    }
    
    return( hr );
}

BufferList* CQueueXMO::GetInputWorkingBuffer()
{
	BufferList *pWorkingBuffer;

	if( NULL == m_pFreeEntriesList )
    {
		//
        // All the buffers are in use: drop this packet
        //
		pWorkingBuffer = NULL;
    }
	else
	{
		//
        // Get the first free buffer
        //
		pWorkingBuffer = RemoveFirstBuffer(&m_pFreeEntriesList);
	}

	return pWorkingBuffer;

}


BufferList* CQueueXMO::RemoveFirstBuffer(BufferList **pHead , BufferList **pTail)
{
	assert(*pHead);

	//
    // Remove the head of the double linked list and return it
    //
	BufferList *pTemp = *pHead;
	*pHead = pTemp->m_pNext;

	if( NULL !=  *pHead)
    {
		(*pHead)->m_pPrev = NULL;
    }
	pTemp->m_pNext = NULL;

	if(( NULL != pTail ) && (NULL == *pHead))
    {
		*pTail = NULL;
    }

	return pTemp;

}

HRESULT CQueueXMO::AddInUseBuffer(BufferList *pBuffer)
{
	HRESULT hr = S_OK;

	m_wInUseEntriesCount++;

	if( NULL == m_pInUseEntriesListHead )
    {
		//
        // Empty in use list
        //
		assert(NULL == m_pInUseEntriesListTail);
		m_pInUseEntriesListHead = m_pInUseEntriesListTail = pBuffer;
    }
	else
	{
		//
        // At least one element, insert in sorted list
        //
		BufferList *pTmpBuffer = m_pInUseEntriesListTail;
		while((NULL != pTmpBuffer) && (pBuffer->m_timestamp < pTmpBuffer->m_timestamp))
		{		
			pTmpBuffer = pTmpBuffer->m_pPrev;
		}

		if( NULL == pTmpBuffer )
        {
			//
            // We are at the beginning of the list
            //
			m_pInUseEntriesListHead->m_pPrev = pBuffer;
			pBuffer->m_pNext = m_pInUseEntriesListHead;
			m_pInUseEntriesListHead = pBuffer;
        }
		else
		{
			if( pBuffer->m_timestamp != pTmpBuffer->m_timestamp )
            {
			    //
                // Insert after pTmpBuffer
			    //
			    pBuffer->m_pNext = pTmpBuffer->m_pNext;
			    pBuffer->m_pPrev = pTmpBuffer;

			    pTmpBuffer->m_pNext = pBuffer;
			    if( NULL == pBuffer->m_pNext )
				{
				    m_pInUseEntriesListTail = pBuffer;
				}
			    else
				{
				    (pBuffer->m_pNext)->m_pPrev = pBuffer;
				}	
            }
			else
			{
				//
                // Drop duplicate
                //
				m_wInUseEntriesCount--;
				hr = E_FAIL;
			}
		}
	}

	return (hr);
}

BufferList* CQueueXMO::GetOutputWorkingBuffer(BOOL *pbReturnSilence , BOOL *pbIsNextPacketLost)
{
	BufferList *pOutBuffer = NULL;
	*pbReturnSilence = FALSE;
	*pbIsNextPacketLost = TRUE;

	assert(((0 == m_wInUseEntriesCount) && (NULL == m_pInUseEntriesListHead)) ||
		   ((0 != m_wInUseEntriesCount) && (NULL != m_pInUseEntriesListHead)));

	DWORD realOutputTime = GetTickCount() - m_RealStartOutputTime;

#ifdef _DEBUG_PRINT
	DebugPrint("CQueueXMO::LogicalOutputTime = %d InUseEntriesCount = %d RealOutputTime=%d HWM=%d\n" , 
		        m_LogicalOutputTime , m_wInUseEntriesCount , realOutputTime , m_wHighWaterMark);
#endif


	//
    // 1. Because a packet can be asked for output just before the high water mark is reached, 
	// allow a window of 5 ms around HWM for output
    //
	//
    // 2. If more packets in the queue than HWM enforces, let them go
    //
	if( ((LONG)realOutputTime - (LONG)m_LogicalOutputTime >= (LONG)m_wHighWaterMark - 5) ||
		(m_wInUseEntriesCount > m_wHighWaterMark / m_wMsOfDataPerBuffer))
	{
		//
		// We send to output packet either silence or decompressed data
		//
		if(( m_wInUseEntriesCount > 0 ) && (m_LogicalOutputTime == m_pInUseEntriesListHead->m_timestamp))
		{
			//
			// The buffer is in the list
			//
			pOutBuffer = RemoveFirstBuffer(&m_pInUseEntriesListHead , &m_pInUseEntriesListTail); 
			m_wInUseEntriesCount--;
			if( (m_wInUseEntriesCount > 0 ) && (m_pInUseEntriesListHead->m_timestamp == pOutBuffer->m_timestamp + m_wMsOfDataPerBuffer) )
            {
				*pbIsNextPacketLost = FALSE;
            }
		}
		else
		{
			*pbReturnSilence = TRUE;
		}
	}
	
	return pOutBuffer;
}

void CQueueXMO::AddFreeBuffer(BufferList *pBuffer)
{
	
	//
    // Attach buffer to the head of free buffers list
    //
	if( NULL == m_pFreeEntriesList )
    {
		m_pFreeEntriesList = pBuffer;
    }
	else
	{
		m_pFreeEntriesList->m_pPrev = pBuffer;
		pBuffer->m_pNext = m_pFreeEntriesList;
		m_pFreeEntriesList = pBuffer;
	}
}

HRESULT CQueueXMO::DecompressMediaBuffer(BufferList *pSrc, LPCXMEDIAPACKET pDst)
{
	HRESULT hr;
        
	memset(pDst->pvBuffer , 0 , pDst->dwMaxSize);

	XMEDIAPACKET xmb;

	memset(&xmb,0,sizeof(xmb));
	xmb.dwMaxSize = m_wCodecBufferSize;
	xmb.pvBuffer = pSrc->m_pbBuffer;
	xmb.hCompletionEvent = NULL;

		
	//
	// Call decoding xmo
	//
	hr = m_pDecoder->Process( &xmb , pDst);

	assert(!FAILED(hr));

    return( hr );
}

void CQueueXMO::RecomputeQueueParameters()
{
	WORD wCurrentIndex = (m_wHighWaterMark - m_wMinHighWaterMark) / m_wMsOfDataPerBuffer;

	DOUBLE dTalkspurtQuality = min( ((DOUBLE)m_wErrorCount) / ((DOUBLE)m_wNumberOfFramesInTalkspurt) , 1.0);

	assert(wCurrentIndex < m_wHighWaterMarkQualitySize);

#ifdef _DEBUG_PRINT
	DebugPrint("***CurrentTalkspurt = %d NumberOfFramesInTalkspurt = %d Errors = %d m_dFrameStrength = %f\n",
		       m_bCurrentTalkspurtID , m_wNumberOfFramesInTalkspurt , m_wErrorCount , m_dFrameStrength);
#endif

	//
    // Compute new parameters
    //
	m_dCurrentTalkspurtWeighting = min( m_dFrameStrength * m_wNumberOfFramesInTalkspurt , 1.0);
	m_pdHighWaterMarkQuality[wCurrentIndex] = m_pdHighWaterMarkQuality[wCurrentIndex] * (1 - m_dCurrentTalkspurtWeighting) +
		                                      dTalkspurtQuality * m_dCurrentTalkspurtWeighting;

	//
    // Reset counters for the new talkspurt
    //
	m_wNumberOfFramesInTalkspurt = 0;
	m_wErrorCount = 0;

	if( m_pdHighWaterMarkQuality[wCurrentIndex] < m_dIdealQuality )
    {
		//
        // Better quality --> try to decrease the highwatermark
        //
		if( wCurrentIndex > 0 )
        {
			//
            // See if wCurrentIndex - 1 is closer to ideal quality
            //
			if( fabs( m_pdHighWaterMarkQuality[ wCurrentIndex - 1 ] - m_dIdealQuality) < 
				fabs( m_pdHighWaterMarkQuality[ wCurrentIndex ] - m_dIdealQuality))
            {
				m_wHighWaterMark -= m_wMsOfDataPerBuffer;

				//
                // When we decrease the HWM, we already render packets with the delay introduced by the previous HWM
				// By skipping one packet(if the queue was empty, we don't lose anything), we reduce the delay 
				// between LOT and ROT
                //
				m_LogicalOutputTime += m_wMsOfDataPerBuffer;

		        if(( m_wInUseEntriesCount > 0 ) && 
				   (m_LogicalOutputTime > m_pInUseEntriesListHead->m_timestamp))
                {
					BufferList *pDroppedBuffer = RemoveFirstBuffer(&m_pInUseEntriesListHead , &m_pInUseEntriesListTail); 
					m_wInUseEntriesCount--;
					AddFreeBuffer(pDroppedBuffer);
                }
            }
        }

    }
	else
	{
		//
        // Worse quality --> try to increase the highwatermark 
        //
		if( wCurrentIndex + 1 < m_wHighWaterMarkQualitySize  )
        {
			//
            // See if wCurrentIndex + 1 is closer to ideal quality
            //
			if( fabs( m_pdHighWaterMarkQuality[ wCurrentIndex + 1 ] - m_dIdealQuality) < 
				fabs( m_pdHighWaterMarkQuality[ wCurrentIndex ] - m_dIdealQuality))
            {
				m_wHighWaterMark += m_wMsOfDataPerBuffer;

				//
                // In order for the queueXMO to behave continuous, and the hwm stuff to not affect the user of the queue,
                // we will "play again" one packet to give time to the HWM to be reached
				// By changing the LOT, there will be silence(attenuated packet) returned
				//
				assert(0 != m_LogicalOutputTime);
				m_LogicalOutputTime -= m_wMsOfDataPerBuffer;
            }
        }

	}

#ifdef _DEBUG_PRINT
	DebugPrint("***TalkspurtQuality = %f CurrentTalkspurtWeighting = %f HighWaterMarkQuality[%d] = %f HighWaterMark = %d\n" ,
		       dTalkspurtQuality , m_dCurrentTalkspurtWeighting , wCurrentIndex , 
			   m_pdHighWaterMarkQuality[wCurrentIndex] , m_wHighWaterMark);
#endif



}

void CQueueXMO::CopyAttenuatedBuffer(LPCXMEDIAPACKET pOutMediaPacket , DOUBLE dAttenuationFactor)
{
	assert(pOutMediaPacket);

	//
    // TBD : take into account attenuation factor
    //
	memcpy(pOutMediaPacket->pvBuffer , m_pSavedBuffer , pOutMediaPacket->dwMaxSize);

#ifdef _DEBUG_PRINT
	DebugPrint("Copy attenuated buffer = %d\n", pOutMediaPacket->dwMaxSize);
#endif
}

HRESULT STDMETHODCALLTYPE CQueueXMO::GetLastOutputInfo(LPPCM_INFO pPCMInfo)
{
	if( NULL != pPCMInfo )
    {
		pPCMInfo->cbSize = sizeof(PCM_INFO);
		pPCMInfo->nMaxPower = m_LastOutputInfo.nMaxPower;
    }

	return (QUEUE_S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\ui\src\UserInterfaceVideo.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: UserInterfaceMenu.cpp
//
// Author: Dan Rosenstein (danrose)
//
// Description: the implementation for the base menu class
//
///////////////////////////////////////////////////////////////////////////////

#include "UserInterfaceVideo.h"
#include "UserInterfaceScreen.h"
#include "UserInterfaceMenu.h"

///////////////////////////////////////////////////////////////////////////////
//
// Name: CUserInterfaceVideo
//
// Input: None
//
// Output: an instance of the user interface video class
//
// Description: constructs the video for the UI
//
///////////////////////////////////////////////////////////////////////////////

CUserInterfaceVideo::CUserInterfaceVideo( void )
	: m_pDevice( NULL ),
	  m_pScreen( NULL ),
	  m_pFont( NULL ),
      m_pBackBuffer( NULL ),
	  m_uHeight( 0 ),
	  m_uWidth( 0 ),
	  m_dwClearColor( 0 ),
	  m_pBitmap( NULL )
{
	//
	// no code here
	//
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: ~CUserInterfaceVideo
//
// Input: None
//
// Output: None
//
// Description: destructs the video ui
//
///////////////////////////////////////////////////////////////////////////////

CUserInterfaceVideo::~CUserInterfaceVideo( void )
{
	//
	// delete font
	//

	if ( m_pFont )
	{
		XFONT_Release(m_pFont);
		m_pFont = NULL;
	}

    //
    // release the back buffer
    //

    if ( m_pBackBuffer )
    {
        m_pBackBuffer->Release();
    }

	//
	// delete the bitmap
	//

	if ( m_pBitmap )
	{
		delete m_pBitmap;
		m_pBitmap = NULL;
	}

	//
	// shut down graphics
	//

	if ( m_pDevice )
	{
		m_pDevice->Release();
		m_pDevice = NULL;
	}
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Initialize
//
// Input: pScreen - the root screen
//        uWidth - the width of the d3d screen
//        uHeight - the height of the d3d screen
//        dwClearColor - the color to clear with
//        szFileName - the name of the bitmap file
//
// Output: S_OK if input creation was successful, E_XXXX otherwise
//
// Description: sets up the app for displaying video
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
CUserInterfaceVideo::Initialize( CUserInterfaceScreen* pScreen,
								 UINT uWidth, 
								 UINT uHeight,
								 DWORD dwClearColor, 
								 LPSTR szFileName )
{
	HRESULT hr = S_OK;
	PDIRECT3D8 pD3D = NULL;
	D3DSurface* pBackBuffer = NULL;

	D3DPRESENT_PARAMETERS d3dpp;

	//
	// insert screen
	//

	m_pScreen = pScreen;

	//
	// width, height
	//

	m_uWidth = uWidth;
	m_uHeight = uHeight;

	//
	// clear color
	//

	m_dwClearColor = dwClearColor;

	//
	// zero out the presentation params
	//

	ZeroMemory( &d3dpp, sizeof( D3DPRESENT_PARAMETERS ) );

	//
	// Create d3d
	//

	if ( SUCCEEDED( hr ) )
	{
		pD3D = Direct3DCreate8( D3D_SDK_VERSION );
		hr = pD3D ? S_OK : E_OUTOFMEMORY;

		ASSERT( SUCCEEDED( hr ) || ! "Could not create d3d object" );
	}

	if ( SUCCEEDED( hr ) )
	{	
		
		//
        // Set the screen mode.
		//

		d3dpp.BackBufferWidth                 = uWidth;
		d3dpp.BackBufferHeight                = uHeight;
		d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
		d3dpp.BackBufferCount                 = 1;
        d3dpp.hDeviceWindow                   = NULL;               
		d3dpp.Windowed                        = FALSE;                 
		d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
        d3dpp.EnableAutoDepthStencil          = FALSE; 
        d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
        d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;
		d3dpp.FullScreen_RefreshRateInHz      = D3DPRESENT_RATE_DEFAULT;
		d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_ONE;

		//
		// Create the device
		//

		hr = pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                 D3DDEVTYPE_HAL,
                                 NULL,
                                 D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                 &d3dpp,
                                 &m_pDevice );
	
		ASSERT( SUCCEEDED( hr ) || !"could not create d3d device" );
	}

	//
	// open the true type font
	//

    if ( SUCCEEDED( hr ) )
	{
		hr = XFONT_OpenTrueTypeFont( L"d:\\media\\fonts\\tahoma.ttf", 4096, &m_pFont );
		ASSERT( SUCCEEDED( hr ) || !"Could not open font" );
	}

	//
	// get the back buffer
	//

	if( SUCCEEDED( hr ) )
    {
	    hr = m_pDevice->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &m_pBackBuffer );
		ASSERT( SUCCEEDED( hr ) || !"could not get back buffer" );
	}

	//
	// set font properties
	//

	if ( SUCCEEDED( hr ) )
	{
        XFONT_SetTextColor( m_pFont, 0 );
        XFONT_SetTextAlignment( m_pFont, XFONT_CENTER );
        XFONT_SetBkColor( m_pFont, 0 );
        XFONT_SetTextHeight( m_pFont, 20 );
        XFONT_SetTextAntialiasLevel( m_pFont, 0 );
        XFONT_SetTextStyle( m_pFont, XFONT_NORMAL );
		XFONT_SetBkMode( m_pFont, XFONT_OPAQUE );
    }

	//
	// load the bitmap
	//

	if ( SUCCEEDED( hr ) && szFileName )
	{
		m_pBitmap = new CBitmapFile();
		hr = m_pBitmap ? S_OK : E_OUTOFMEMORY;

		ASSERT( SUCCEEDED( hr ) || !"could not create bitmap" );

		if ( SUCCEEDED( hr ) )
		{
			hr = m_pBitmap->Read( 0, 0, szFileName );
			ASSERT( SUCCEEDED( hr ) || !"Could not read from file" );
		}
	}


	//
	// Now we no longer need the D3D interface so let's free it.
	//

	if ( pD3D )
	{
		pD3D->Release();
		pD3D = NULL;
	}

	//
	// if there was a failure, we don't want the bitmap
	//

	if ( FAILED( hr ) && m_pBitmap )
	{
		delete m_pBitmap;
		m_pBitmap = NULL;
	}

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: Update
//
// Input: pInput - the input state
//        pAudio - the audio class
//
// Output: S_OK on success. E_XXXX on failure
//
// Description: Renders the User interface 
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
CUserInterfaceVideo::Update( CUserInterfaceInput* pInput, CUserInterfaceAudio* pAudio )
{
	HRESULT hr = S_OK;
	CUserInterfaceScreen* pNextScreen = NULL;

	//
	// check to make sure the device is allocated
	//

	ASSERT( m_pDevice || !"d3d device not allocated" );

	if ( ! m_pDevice )
	{
		hr = E_POINTER;
	}

	//
	// check to make sure screen exists
	//

	ASSERT( m_pScreen || !"screen needs to be inserted before updating" );

	if ( ! m_pScreen )
	{
		hr = E_POINTER;
	}

	//
	// clear the screen
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = ClearScreen( m_dwClearColor );
		ASSERT( SUCCEEDED( hr ) || ! "Could not clear screen" );
	}

	//
	// update the screen
	//

	if ( SUCCEEDED( hr ) )
	{
		pNextScreen = m_pScreen->Update( pInput, pAudio );

		//
		// we may want to stay on this screen
		//

		if ( pNextScreen )
		{
			m_pScreen = pNextScreen;
		}
	}

	//
	// draw the current screen to the graphics device
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = DrawScreen();
		ASSERT( SUCCEEDED( hr ) || ! "Could not draw screen" );
	}

	//
	// render the screen
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = m_pDevice->Present( NULL, NULL, NULL, NULL );
		ASSERT( SUCCEEDED( hr ) || !"could not present scene" );
	}

	//
	// set soft rendering
	//

	static BOOL bPresented = FALSE;

	if (! bPresented && SUCCEEDED( hr ) )
	{
		m_pDevice->SetSoftDisplayFilter( TRUE );
		bPresented = TRUE;
	}

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: ClearScreen
//
// Input: dwColor - 32 bit ARGB color
//
// Output: S_OK on success. E_XXXX on failure
//
// Description: clears the screen on the device
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
CUserInterfaceVideo::ClearScreen( DWORD dwColor )
{
	//
	// make sure device was allocated, clear the screen
	//

	ASSERT( m_pDevice || !"d3d device not allocated" );

	if ( m_pDevice )
	{
		return m_pDevice->Clear( 0, NULL, D3DCLEAR_TARGET, dwColor, 0.0f, 0 );
	}
	else
	{
		return E_POINTER;
	}
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: DrawScreen
//
// Input: None
//
// Output: S_OK on success. E_XXXX on failure
//
// Description: draws the current screen 
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
CUserInterfaceVideo::DrawScreen( void )
{
	HRESULT hr = S_OK;
	CUserInterfaceMenu* pMenu = NULL;
	CUserInterfaceText* pText = NULL;
	LPSTR szItem = NULL;

	//
	// make sure device was allocated
	//

	ASSERT( m_pDevice || !"d3d device not allocated" );
	
	if ( ! m_pDevice )
	{
		hr = E_POINTER;
	}

	//
	// make sure there is a screen
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = m_pScreen ? S_OK : E_FAIL;
		ASSERT( SUCCEEDED( hr ) || !"need to insert a screen before drawing!" );
	}

	//
	// draw the background
	//

	if ( SUCCEEDED( hr ) && m_pBitmap )
	{
		hr = m_pBitmap->Render( m_pDevice );
		ASSERT( SUCCEEDED( hr ) || !" could not render background" );
	}

	//
	// deal with a screen that has text
	//

	if ( SUCCEEDED( hr ) && m_pScreen->GetText() )
	{
		hr = DrawText( m_pScreen->TextX(), 
					   m_pScreen->TextY(), 
					   m_pScreen->FGColor(),
					   m_pScreen->BGColor(),
					   L"%S", 
					   m_pScreen->GetText() );

		ASSERT( SUCCEEDED( hr ) || !"Could not write text" );
	}

	//
	// the screen has no text. It should have menus
	//

	else
	{

	//
	// loop through the menus
	//

		for ( DWORD dwMenu = 0; 
			  SUCCEEDED( hr ) && dwMenu < m_pScreen->NumMenus(); 
			  dwMenu++ )
		{
			//
			// find hte active menu
			//

			if ( m_pScreen->ActiveMenu( dwMenu ) )
				break;
		}

		if ( SUCCEEDED( hr ) )
		{
			//
			// save the menu
			//

			pMenu = m_pScreen->Menu( dwMenu );
			ASSERT( pMenu || ! "menu was NULL!" );

			if ( ! pMenu )
			{
				hr = E_POINTER;
			}

			//
			// draw the title if it exists
			//

			if ( SUCCEEDED( hr ) && 0 != pMenu->GetTitle() )
			{
				hr = DrawText( pMenu->TextX(), 
							   pMenu->TextY() - 28, 
							   pMenu->FGColor(),
							   pMenu->BGColor(),
							   L"%S", 
							   pMenu->GetTitle() );

				ASSERT( SUCCEEDED( hr ) || !"Could not render empty list" );
			}

			//
			// deal with an empty menu
			//

			if ( SUCCEEDED( hr ) && 0 == pMenu->NumItems() )
			{
				hr = DrawText( pMenu->TextX(), 
							   pMenu->TextY(), 
							   m_pScreen->ActiveMenu( dwMenu ) ? 
							   pMenu->BGColor() : 
							   pMenu->FGColor(),
							   m_pScreen->ActiveMenu( dwMenu ) ? 
							   pMenu->FGColor() : 
							   pMenu->BGColor(),
							   L"%S", 
							   "Empty" );

				ASSERT( SUCCEEDED( hr ) || !"Could not render empty list" );
			}

			//
			// loop through the items in the menu
			//

			for ( DWORD dwItem = 0; 
			      dwItem < pMenu->NumItems() && SUCCEEDED( hr ); 
				  dwItem++ )
			{
				//
				// get the item in the menu
				//

				szItem = pMenu->Item( dwItem );

				//
				// draw and highlite it if it is active
				//

				hr = DrawText( pMenu->TextX(), 
							   pMenu->TextY() + dwItem * 28,
							   pMenu->ActiveItem( dwItem ) && 
							   m_pScreen->ActiveMenu( dwMenu ) ? 
							   pMenu->BGColor( dwItem ) : 
  							   pMenu->FGColor( dwItem ),
							   pMenu->ActiveItem( dwItem ) &&
							   m_pScreen->ActiveMenu( dwMenu ) ? 
							   pMenu->FGColor( dwItem ) : 
  							   pMenu->BGColor(dwItem ),
							   L"%S", 
							   szItem );

				ASSERT( SUCCEEDED( hr ) || !"Could not draw text" );

			}

		}
	}

	//
	// draw the rest of the UI text
	//

	for ( DWORD i = 0; SUCCEEDED( hr ) && i < m_pScreen->NumUIText(); i++ )
	{
		//
		// get each text object
		//

		pText = m_pScreen->UIText( i );

		//
		// draw it to the screen, if it is not hidden
		//

		if ( ! pText->Hidden() )
		{
			hr = DrawText( pText->X(),
						   pText->Y(),
						   pText->FGColor(),
						   pText->BGColor(),
						   L"%S",
						   pText->Text() );

			ASSERT( SUCCEEDED( hr ) || !"Could not draw ui text" );
		}
	}

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: DrawText
//
// Input: lX - the x location
//        lY - the y location
//        dwFGColor - the fg color
//        dwBGColor - the bg color
//        wszFormat - printf compatible format
//
// Output: S_OK if drawing was successful, E_XXX otherwise
//
// Description: prints text to the screen
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
CUserInterfaceVideo::DrawText( LONG lX, 
							   LONG lY, 
							   DWORD dwFGColor, 
							   DWORD dwBGColor, 
							   LPCWSTR wszFormat, 
							   ... )
{
	HRESULT hr = S_OK;
	int i = 0;
	va_list v;
	WCHAR wszStr[256];

	//
	// Set the foreground color
	//

	XFONT_SetTextColor( m_pFont, dwFGColor );

	//
	// Set the background color
	//

	XFONT_SetBkColor( m_pFont, dwBGColor );

	//
	// print the formatted string to the buffer
	//

	va_start( v, wszFormat );
	i = wvsprintfW( wszStr, wszFormat, v );
	va_end( v );

	//
    // Print the Text to the backbuffer
	//

	hr = XFONT_TextOut( m_pFont, m_pBackBuffer, wszStr, i, lX, lY );
	ASSERT( SUCCEEDED( hr ) || !"Could not set output text" );
	
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\aseConv\ASEConv.cpp ===
//-----------------------------------------------------------------------------
// File: XBApp.cpp
//
// Desc: Application class for the XBox samples.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       12.19.01 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "std.h"
#include "ASEConv.h"
#include "ASEScene.h"

#include "utilities.h"
#include "XOConst.h"
#include "XBInput.h"
#include "Globals.h"
#include "CSVFile.h"
#include "TextureCache.h"
#include "MaterialLibrary.h"

#include "DSoundManager.h"
#include "ntiosvc.h"

//#include "ntiosvc.h"
//-----------------------------------------------------------------------------
// Global access to common members
//-----------------------------------------------------------------------------
ASEConv*    g_pAseApp     = NULL;
LPDIRECT3DDEVICE8  g_pd3dDevice = NULL;
CMaterialLibrary g_MaterialLib;

float* g_fAppTime = 0;
TCHAR* g_szAppDir = NULL;

CNtIoctlCdromService g_cdrom;
int g_nDiscType = eDiscNone;
int GetDiscType();



//-----------------------------------------------------------------------------
// Name: ASEConv()
// Desc: Constructor
//-----------------------------------------------------------------------------
ASEConv::ASEConv()
{
    // Initialize member variables
    g_pAseApp          = this;

    // Direct3D variables
    m_pD3D            = NULL;
    m_pd3dDevice      = NULL;
    m_pDepthBuffer    = NULL;
    m_pBackBuffer     = NULL;

    // Variables to perform app timing
    m_bPaused         = FALSE;
    m_fTime           = 0.0f;
    m_fElapsedTime    = 0.0f;
    m_fAppTime        = 0.0f;
    m_fElapsedAppTime = 0.0f;
    m_fFPS            = 0.0f;
    m_strFrameRate[0] = L'\0';

    // Set up the presentation parameters for a double-bufferd, 640x480,
    // 32-bit display using depth-stencil. Override these parameters in
    // your derived class as your app requires.
    ZeroMemory( &m_d3dpp, sizeof(m_d3dpp) );
    m_d3dpp.BackBufferWidth        = 640;
    m_d3dpp.BackBufferHeight       = 480;
    m_d3dpp.BackBufferFormat       = D3DFMT_A8R8G8B8;
    m_d3dpp.BackBufferCount        = 1;
    m_d3dpp.EnableAutoDepthStencil = TRUE;
    m_d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
    m_d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;
	m_d3dpp.FullScreen_RefreshRateInHz = D3DPRESENT_RATE_DEFAULT;
	m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_ONE;
	m_d3dpp.MultiSampleType = D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN;
	m_d3dpp.EnableAutoDepthStencil = 0;
	m_d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
    m_d3dpp.Flags = D3DPRESENTFLAG_INTERLACED;	
	m_d3dpp.hDeviceWindow = NULL;
	m_d3dpp.Windowed = FALSE;


    // Specify number and type of input devices this app will be using. By
    // default, you can use 0 and NULL, which triggers XInputDevices() to
    // prealloc the default number and types of devices. To use chat or
    // other devices, override these variables in your derived class.
	g_fAppTime = &m_fAppTime;
    _tcscpy( m_szAppDir, _T("d:\\") );
	g_szAppDir = m_szAppDir;

    curFile = 0;

    
    m_ConvertedFiles = NULL;
}

ASEConv::~ASEConv()
{
   
}


//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Create the app
//-----------------------------------------------------------------------------
HRESULT ASEConv::Create()
{
    HRESULT hr = S_OK;

    // Create the Direct3D object
    DbgPrint( "XBApp: Creating Direct3D...\n" );
    if( NULL == ( m_pD3D = Direct3DCreate8(D3D_SDK_VERSION) ) )
    {
        DbgPrint( "XBApp: Unable to create Direct3D!\n");
        return E_FAIL;
    }

    // Create the device
    DbgPrint( "XBApp: Creating the D3D device...\n");
    if( FAILED( hr = m_pD3D->CreateDevice( 0, D3DDEVTYPE_HAL, NULL, 
                                           D3DCREATE_HARDWARE_VERTEXPROCESSING, 
                                           &m_d3dpp, &m_pd3dDevice ) ) )
    {
        DbgPrint( "XBApp: Could not create D3D device!\n");
        return hr;
    }

    // Allow global access to the device
    g_pd3dDevice = m_pd3dDevice;

    // Store pointers to the depth and back buffers
    m_pd3dDevice->GetDepthStencilSurface( &m_pDepthBuffer );
    m_pd3dDevice->GetBackBuffer( 0, 0, &m_pBackBuffer );

    // Initialize core peripheral port support. Note: If these parameters
    // are 0 and NULL, respectively, then the default number and types of 
    // controllers will be initialized.
    XInitDevices( m_dwNumInputDeviceTypes, m_InputDeviceTypes );

    // Create the gamepad devices
    DbgPrint( "XBApp: Creating gamepad devices...\n");
    if( FAILED( hr = XBInput_CreateGamepads( &m_Gamepad ) ) )
    {
        DbgPrint( "XBApp: Call to CreateGamepads() failed!\n" );
        return hr;
    }

    // Initialize the app's device-dependent objects
    DbgPrint("XBApp: Initializing the app...\n");
    if( FAILED( hr = Initialize() ) )
    {
        DbgPrint("XBApp: Call to Initialize() failed!\n" );
        return hr;
    }

	// retreive the status of DVD/CD Rom 
		g_cdrom.Open(1);
        g_nDiscType = GetDiscType();
	
		// initialize DSound 
	if(!DSoundManager::Instance())
	{
		hr = E_OUTOFMEMORY; 
	}
	
	hr = DSoundManager::Instance()->Initialize();
    if ( FAILED( hr ) )
	    ASSERT( !"XOApplication::InitAudio fail to init DSound");


	return hr;



}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Cleanup objects
//-----------------------------------------------------------------------------
VOID ASEConv::Destroy()
{
    // Perform app-specific cleanup
    Cleanup();

    // Release display objects
    m_pd3dDevice->Release();
    m_pD3D->Release(  );

    CTranslator::Instance()->Cleanup();

     for ( ULONG i =0; i < m_nConvertedFileCount; i++ )
    {
        if ( m_ConvertedFiles[i].m_pAseName )
            delete [] m_ConvertedFiles[i].m_pAseName;

       for ( int j = 0; j < m_ConvertedFiles[i].m_nTextButtonCount; j++ )
       {
           delete [] m_ConvertedFiles[i].m_pTextButtonNames[j];
       }
    }

    delete [] m_ConvertedFiles;
    m_ConvertedFiles = 0;
}




//-----------------------------------------------------------------------------
// Name: Run()
// Desc: 
//-----------------------------------------------------------------------------
INT ASEConv::Run()
{
    
	HRESULT hr;
    // Run the game loop, animating and rendering frames
    while( TRUE )
    {
    
        //-----------------------------------------
        // Animate and render a frame
        //-----------------------------------------
		
		hr = Update();
        // Frame move the scene
        FrameMove();

        // Render the scene
        Render();

        // Finally, show the frame (swaps the backbuffer to the front)
        m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
    }

    return 0;
}



HRESULT ASEConv::Update()
{
	HRESULT hr = S_OK;
	// Get the frequency of the timer
    LARGE_INTEGER qwTicksPerSec;
    QueryPerformanceFrequency( &qwTicksPerSec );
    FLOAT fSecsPerTick = 1.0f / (FLOAT)qwTicksPerSec.QuadPart;

    // Save the start time
    LARGE_INTEGER qwTime, qwLastTime, qwElapsedTime;
    QueryPerformanceCounter( &qwTime );
    qwLastTime.QuadPart = qwTime.QuadPart;

    LARGE_INTEGER qwAppTime, qwElapsedAppTime;
    qwAppTime.QuadPart        = 0;
    qwElapsedTime.QuadPart    = 0;
    qwElapsedAppTime.QuadPart = 0;


        //-----------------------------------------
        // Handle input
        //-----------------------------------------

        // Read the input for all connected gampads
        XBInput_GetInput( m_Gamepad );

        // Lump inputs of all connected gamepads into one common structure.
        // This is done so apps that need only one gamepad can function with
        // any gamepad.
        ZeroMemory( &m_DefaultGamepad, sizeof(m_DefaultGamepad) );
        for( DWORD i=0; i<4; i++ )
        {
            if( m_Gamepad[i].hDevice )
            {
                m_DefaultGamepad.sThumbLX += m_Gamepad[i].sThumbLX;
                m_DefaultGamepad.sThumbLY += m_Gamepad[i].sThumbLY;
                m_DefaultGamepad.sThumbRX += m_Gamepad[i].sThumbRX;
                m_DefaultGamepad.sThumbRY += m_Gamepad[i].sThumbRY;
                m_DefaultGamepad.fX1      += m_Gamepad[i].fX1;
                m_DefaultGamepad.fY1      += m_Gamepad[i].fY1;
                m_DefaultGamepad.fX2      += m_Gamepad[i].fX2;
                m_DefaultGamepad.fY2      += m_Gamepad[i].fY2;
                m_DefaultGamepad.wButtons        |= m_Gamepad[i].wButtons;
                m_DefaultGamepad.wPressedButtons |= m_Gamepad[i].wPressedButtons;
                m_DefaultGamepad.wLastButtons    |= m_Gamepad[i].wLastButtons;

                for( DWORD b=0; b<8; b++ )
                {
                    m_DefaultGamepad.bAnalogButtons[b]        |= m_Gamepad[i].bAnalogButtons[b];
                    m_DefaultGamepad.bPressedAnalogButtons[b] |= m_Gamepad[i].bPressedAnalogButtons[b];
                    m_DefaultGamepad.bLastAnalogButtons[b]    |= m_Gamepad[i].bLastAnalogButtons[b];
                }
            }
        }

        // Handle special input combo to trigger a reboot to the Xbox Dashboard
        if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > 0 )
        {
            if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > 0 )
            {
                if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK] )
                    XLaunchNewImage( NULL, NULL );
            }
        }
        //-----------------------------------------
        // Perform app timing
        //-----------------------------------------
        // Get the current time (keep in LARGE_INTEGER format for precision)
        QueryPerformanceCounter( &qwTime );
        qwElapsedTime.QuadPart = qwTime.QuadPart - qwLastTime.QuadPart;
        qwLastTime.QuadPart    = qwTime.QuadPart;
        if( m_bPaused )
            qwElapsedAppTime.QuadPart = 0;
        else
            qwElapsedAppTime.QuadPart = qwElapsedTime.QuadPart;
        qwAppTime.QuadPart    += qwElapsedAppTime.QuadPart;

        // Store the current time values as floating point
        float oldTime = m_fTime;
        m_fTime           = fSecsPerTick * ((FLOAT)(qwTime.QuadPart));
        m_fElapsedTime    = oldTime - m_fTime;
        if ( m_fElapsedTime >.1f || m_fElapsedTime < 0.f )
            m_fElapsedTime = .1f;
        m_fAppTime        = fSecsPerTick * ((FLOAT)(qwAppTime.QuadPart));
        m_fElapsedAppTime = fSecsPerTick * ((FLOAT)(qwElapsedAppTime.QuadPart));

        // Compute the FPS (frames per second) once per second
        static FLOAT fLastTime = 0.0f;
        static DWORD dwFrames  = 0L;
        dwFrames++;

        if( m_fTime - fLastTime > 1.0f )
        {
            m_fFPS    = dwFrames / ( m_fTime - fLastTime );
            fLastTime = m_fTime;
            dwFrames  = 0L;
            swprintf( m_strFrameRate, L"%0.02f fps", m_fFPS );
        }

        if ( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] == 1)
        {
            curFile++;
            if ( curFile >= m_nConvertedFileCount )
                curFile = 0;
            m_pScene->SaveBinary( m_ConvertedFiles[curFile].m_pAseName );
            DbgPrint( "Saving\n" );
        }
        else if ( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_Y] == 1 )
        {
            curFile++;
            if ( curFile >= m_nConvertedFileCount )
                curFile = 0;

            m_pScene->Cleanup();
            m_pScene->LoadFromXBG(g_pd3dDevice, m_ConvertedFiles[curFile].m_pAseName, m_ConvertedFiles[curFile].m_pTextButtonNames[0] );
            DbgPrint( "Loading\n" );
        }

		return hr;
}

//-----------------------------------------------------------------------------
// Name: RenderGradientBackground()
// Desc: Draws a gradient filled background
//-----------------------------------------------------------------------------
HRESULT ASEConv::RenderGradientBackground( DWORD dwTopColor, 
                                                  DWORD dwBottomColor )
{
    // First time around, allocate a vertex buffer
    static LPDIRECT3DVERTEXBUFFER8 g_pVB  = NULL;
    if( g_pVB == NULL )
    {
        m_pd3dDevice->CreateVertexBuffer( 4*5*sizeof(FLOAT), D3DUSAGE_WRITEONLY, 
                                          0L, D3DPOOL_DEFAULT, &g_pVB );
        struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
        BACKGROUNDVERTEX* v;
        g_pVB->Lock( 0, 0, (BYTE**)&v, 0L );
        v[0].p = D3DXVECTOR4(   0,   0, 1.0f, 1.0f ); v[0].color = dwTopColor;
        v[1].p = D3DXVECTOR4( 640,   0, 1.0f, 1.0f ); v[1].color = dwTopColor;
        v[2].p = D3DXVECTOR4(   0, 480, 1.0f, 1.0f ); v[2].color = dwBottomColor;
        v[3].p = D3DXVECTOR4( 640, 480, 1.0f, 1.0f ); v[3].color = dwBottomColor;
        g_pVB->Unlock();
    }

    // Set states
    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE ); 
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE ); 
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
    m_pd3dDevice->SetStreamSource( 0, g_pVB, 5*sizeof(FLOAT) );

    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Clear the zbuffer
    m_pd3dDevice->Clear( 0, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 0x00000000, 1.0f, 0L );

    return S_OK;
}

HRESULT ASEConv::Cleanup()
{
	HRESULT hr = S_OK;


	if ( m_pScene )
		delete m_pScene;


    hr = DSoundManager::Instance()->Cleanup();
	if (FAILED(hr))
	{
		DbgPrint("XOApplication::Cleanup - fail to cleanup DirectSound, hr = 0x%x", hr);
	}
	else
	{
		DbgPrint("XOApplication::Cleanup - DirectSound clean");
	}

	return hr;
}

HRESULT ASEConv::Render()
{
	if ( m_pd3dDevice )
	{
	
		m_pd3dDevice->BeginScene();

		// Clear the backbuffer 
		m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 
                         D3DCOLOR_XRGB( (int)0, (int)0, (int)0 ), 1.0f, 0L );

		if ( m_Gamepad->bPressedAnalogButtons[0] )
		{
//			m_pButton->ToggleRotation();
		}

		m_pScene->Render( (DWORD)m_fElapsedTime );


		m_pd3dDevice->EndScene();
	}

	return S_OK;
}


HRESULT ASEConv::FrameMove()
{

	m_pScene->FrameMove( m_DefaultGamepad, m_fElapsedTime);
	return S_OK;
}



HRESULT ASEConv::Initialize()
{
	HRESULT hr = S_OK;
    CTranslator::Instance()->Initialize();
    if ( !m_pScene )
	{

        GetFilesToOpen( ASE_PATH_ANSI, ".ase" );

        char textPath[256];
        strcpy( textPath, MEDIA_PATH_ANSI );
        strcat( textPath, "text.csv" );
        CSVFile csvFile;
        csvFile.open( textPath );

		// BugBug: Testing
		//strcpy( pFileName, "d:\\media\\ase\\sphere.ase");

		//-----------------------------------------------------
		// Fully loads and parses an ASE File.  These files are
		// output by 3D Studio MAX's ASCII Scene Exporter.
        ULONG i = 0;
        while( true )
        {
            if ( i >= m_nConvertedFileCount )
                break;

		    HANDLE hFile = CreateFile( m_ConvertedFiles[i].m_pAseName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL );

		    if ( hFile == INVALID_HANDLE_VALUE )
            {
                DbgPrint( "Couldn't open the ase file\n" );
                ASSERT( !"Couldn't open an ASE file\n" );
                return -1;
            }

		    //------------------------------------------
		    // Check if exists by getting size
		    long aseFileSize =  ::GetFileSize( hFile, 0 );

		    _ASSERT(aseFileSize > 0);

		    //---------------------------------------
		    // Create Buffer to read entire file into
		    char *aseContents = new char[aseFileSize+1];
		    aseContents[aseFileSize] = 0;
		    _ASSERT(aseContents != NULL);

		    unsigned long nBytesRead = 0;
		    
		    int dataRead = ::ReadFile( hFile, aseContents,sizeof( char )*aseFileSize, &nBytesRead, NULL);
		    _ASSERT(nBytesRead == aseFileSize);



		    ::CloseHandle( hFile );

            m_pScene = new ASEScene;

            char* pExt = strstr( m_ConvertedFiles[i].m_pAseName, ".ase" );
            *pExt = 0;
            char* pFileNoPath = ( m_ConvertedFiles[i].m_pAseName + strlen(  ASE_PATH_ANSI ) );

            char tmpFileName[256];
            strcpy( tmpFileName, pFileNoPath );

            void    LoadStrings( CSVFile* pFile, const char* aseName, const char** pSceneName, long sceneCount   );

            m_pScene->LoadStrings( &csvFile, pFileNoPath, (const char** )m_ConvertedFiles[i].m_pTextButtonNames, m_ConvertedFiles[i].m_nTextButtonCount );

            strcpy( m_ConvertedFiles[i].m_pAseName, XBG_PATH_ANSI );
            strcat( m_ConvertedFiles[i].m_pAseName, tmpFileName );
            strcat( m_ConvertedFiles[i].m_pAseName, ".xbg" );


		    m_pScene->Load( aseContents);

		    delete [] aseContents;
		    aseContents = NULL;

            m_pScene->SaveBinary( m_ConvertedFiles[i].m_pAseName );

            i++;
        }


	}	
    
    float zero = 0.0f;
	float one = 1.0f;


    g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, 0 );
	g_pd3dDevice->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
	g_pd3dDevice->SetRenderState(D3DRS_SHADEMODE, D3DSHADE_GOURAUD);
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
	g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ZERO);
	g_pd3dDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);
	g_pd3dDevice->SetRenderState(D3DRS_ZFUNC, D3DCMP_LESSEQUAL);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHAREF, 0);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_ALWAYS);
	g_pd3dDevice->SetRenderState(D3DRS_DITHERENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_FOGENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_SPECULARENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_FOGCOLOR, 0);
	g_pd3dDevice->SetRenderState(D3DRS_FOGTABLEMODE, D3DFOG_NONE);
//	g_pd3dDevice->SetRenderState(D3DRS_FOGSTART, ); // Undocumented!
//	g_pd3dDevice->SetRenderState(D3DRS_FOGEND, ); // Undocumented!
	g_pd3dDevice->SetRenderState(D3DRS_FOGDENSITY, *(LPDWORD)&one);
	g_pd3dDevice->SetRenderState(D3DRS_EDGEANTIALIAS, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ZBIAS, 0);
	g_pd3dDevice->SetRenderState(D3DRS_RANGEFOGENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILFAIL, D3DSTENCILOP_KEEP);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILZFAIL, D3DSTENCILOP_KEEP);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILPASS, D3DSTENCILOP_KEEP);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILFUNC, D3DCMP_ALWAYS);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILREF, 0);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILMASK, 0xffffffff);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILWRITEMASK, 0xffffffff);
//	g_pd3dDevice->SetRenderState(D3DRS_TEXTUREFACTOR, ); // Undocumented!
	g_pd3dDevice->SetRenderState(D3DRS_WRAP0, 0);
	g_pd3dDevice->SetRenderState(D3DRS_WRAP1, 0);
	g_pd3dDevice->SetRenderState(D3DRS_WRAP2, 0);
	g_pd3dDevice->SetRenderState(D3DRS_WRAP3, 0);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_AMBIENT, 0);
	g_pd3dDevice->SetRenderState(D3DRS_COLORVERTEX, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_LOCALVIEWER, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_NORMALIZENORMALS, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_DIFFUSEMATERIALSOURCE, D3DMCS_COLOR1);
	g_pd3dDevice->SetRenderState(D3DRS_SPECULARMATERIALSOURCE, D3DMCS_COLOR2);
	g_pd3dDevice->SetRenderState(D3DRS_AMBIENTMATERIALSOURCE, D3DMCS_COLOR2);
	g_pd3dDevice->SetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_MATERIAL);
	g_pd3dDevice->SetRenderState(D3DRS_VERTEXBLEND, D3DVBF_DISABLE);
	g_pd3dDevice->SetRenderState(D3DRS_POINTSIZE, *(LPDWORD)&one);
	g_pd3dDevice->SetRenderState(D3DRS_POINTSIZE_MIN, *(LPDWORD)&one);
	g_pd3dDevice->SetRenderState(D3DRS_POINTSPRITEENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_POINTSCALEENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_POINTSCALE_A, *(LPDWORD)&one);
	g_pd3dDevice->SetRenderState(D3DRS_POINTSCALE_B, *(LPDWORD)&zero);
	g_pd3dDevice->SetRenderState(D3DRS_POINTSCALE_C, *(LPDWORD)&zero);
	g_pd3dDevice->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_MULTISAMPLEMASK, 0xffffffff);
//	g_pd3dDevice->SetRenderState(D3DRS_PATCHEDGESTYLE, ); // Undocumented!
//	g_pd3dDevice->SetRenderState(D3DRS_PATCHSEGMENTS, ); // Undocumented!
//	g_pd3dDevice->SetRenderState(D3DRS_DEBUGMONITORTOKEN, ); // Undocumented!
//	g_pd3dDevice->SetRenderState(D3DRS_POINTSIZE_MAX, ); // Undocumented!
	g_pd3dDevice->SetRenderState(D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_RED | D3DCOLORWRITEENABLE_GREEN | D3DCOLORWRITEENABLE_BLUE | D3DCOLORWRITEENABLE_ALPHA);
//	g_pd3dDevice->SetRenderState(D3DRS_TWEENFACTOR, ); // Undocumented!
	return hr;
}


void    ASEConv::GetFilesToOpen( const char* path, const char* pExtension )
{   
    curFile = 0;
    char pInputFileName[255];
    strcpy( pInputFileName, MEDIA_PATH_ANSI );
    strcat( pInputFileName, "sceneToLoad.csv" );

    CSVFile file;
    long sceneToLoadFileOpenResult = file.open( pInputFileName );
    if ( NO_ERR == sceneToLoadFileOpenResult )
    {
        long rowCount = file.getTotalRows();
        m_ConvertedFiles = new XBGFileData[rowCount];
        memset( m_ConvertedFiles, 0, sizeof( XBGFileData ) * rowCount );

        m_nConvertedFileCount = rowCount;
        for ( int i = 0; i < rowCount; i++ )
        {
            char aseFileName[256];
            file.readString( i+1, 1, aseFileName, 255 );

            long len = strlen( path ) + strlen( pExtension ) + strlen( aseFileName ) + 1;

            m_ConvertedFiles[i].m_pAseName = new char[len];
            // make the path
            strcpy( m_ConvertedFiles[i].m_pAseName, path );
            strcat( m_ConvertedFiles[i].m_pAseName, aseFileName );

            // swap extensions
            char* pExt = strstr( m_ConvertedFiles[i].m_pAseName, "." );
            if ( pExt )
                strcpy( pExt, pExtension );
            else
                strcat( m_ConvertedFiles[i].m_pAseName, pExtension );

            // count the number of button and text objects
            for ( int j = 1; j < file.getTotalCols(); j++ )
            {
                char buttonTextName[256];
                buttonTextName[0] = 0;
                file.readString( i+1, j+1, buttonTextName, 255 );

                if ( strlen( buttonTextName ) )
                {
                    m_ConvertedFiles[i].m_nTextButtonCount++;
                }
            }

            // now figure go ahead and allocate...
            if ( m_ConvertedFiles[i].m_nTextButtonCount )
            {
                m_ConvertedFiles[i].m_pTextButtonNames = new char*[m_ConvertedFiles[i].m_nTextButtonCount];
            }

            // do it again
            for ( int j = 0; j < m_ConvertedFiles[i].m_nTextButtonCount; j++ )
            {
                char buttonTextName[256];
                file.readString( i+1, j+2, buttonTextName, 255 );

                if ( strlen( buttonTextName ) )
                {
                    m_ConvertedFiles[i].m_pTextButtonNames[j] = new char[strlen(buttonTextName)+1];
                    strcpy( m_ConvertedFiles[i].m_pTextButtonNames[j], buttonTextName );
                }
            }


            
        }
    }
    else
        ASSERT( sceneToLoadFileOpenResult == 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\aseConv\aseScene.cpp ===
#include "std.h"
#include "ASEScene.h"
#include "TGL.h"
#include <stdio.h>
#include "File.h"
#include "XBInput.h"
#include "Globals.h"
#include "utilities.h"
#include "XOConst.h" 
#include "csvfile.h"  
#include <malloc.h>


#define ASE_NODE_PARENT			"*NODE_PARENT"

ASEScene::ASEScene()
{
    m_SceneStringNames = 0; // name in the csv file identifying strings
    m_SceneStringNameCount = 0;

}
ASEScene::~ASEScene()
{
    ClearIntelligentObjects();


    for ( std::list< StringInfo* >::iterator stIter = m_StringList.begin(); stIter != m_StringList.end(); stIter++ )
    {
        delete (*stIter );
    }

    for ( int i = 0; i < m_SceneStringNameCount; i++ )
    {
        if ( m_SceneStringNames[i] )
            delete m_SceneStringNames[i];
    }

    if ( m_SceneStringNames )
        delete m_SceneStringNames;

    m_SceneStringNames = 0;

    m_StringList.clear();
}

void ASEScene::ClearIntelligentObjects()
{
for ( std::list< ButtonInfo*>::iterator bIter = m_ButtonList.begin(); bIter != m_ButtonList.end(); bIter++ )
    {
        for ( int i = 0; i < (*bIter)->m_cStandardMatCount; i++ )
        {
            delete (*bIter)->m_cStandardMaterials[i];
        }
        for ( int i = 0; i < (*bIter)->m_cEgglowMatCount; i++ )
        {
            delete (*bIter)->m_cEgglowMaterials[i];
        }

        delete (*bIter );
    }

    m_ButtonList.clear();
    
    for ( std::list< TextInfo* >::iterator tIter = m_TextList.begin(); tIter != m_TextList.end(); tIter++ )
    {
        if ( (*tIter)->m_pTextID )
        {
            delete (*tIter)->m_pTextID;
        }

        delete (*tIter );
    }

    m_TextList.clear();

    for ( std::list< SpinnerInfo* >::iterator spIter = m_SpinnerList.begin(); spIter != m_SpinnerList.end(); spIter++ )
    {
        delete (*spIter );
    }

    m_SpinnerList.clear();

    for ( std::list< ListBoxInfo* >::iterator lbIter = m_ListBoxList.begin(); lbIter != m_ListBoxList.end(); lbIter++ )
    {
        delete( *lbIter );
    }

    m_ListBoxList.clear();

	m_TextCount = m_ButtonCount = m_SpinnerCount = m_ListBoxCount = 0;
}


//////////////////////////////////////////////////////////////////////////////
// This loads an ASE file, this is only used to create an XBG file
/////////////////////////////////////////////////////////////////////////////
struct GroupInfo
{
    char NodeName[64];
    long BraceCount;
    GroupInfo* pParent;
};

#define GROUP_TAG "*GROUP "

// hacky helper function to create group heirarch 
// since MAX doesn't helpfully spit out names like it
// does for geometry
void SetUpGroups( const char* pBuffer, list< GroupInfo >& groupList )
{
   char* pGroupStr = (char*)pBuffer;
   char* pNextGroupStr = NULL;
   char GroupName[256];
   long curBraceCount = 0;
   GroupInfo* pParent = NULL;

   while( pGroupStr = strstr( pGroupStr, GROUP_TAG  ) )
   {
       GroupInfo groupInfo;
       memset( &groupInfo, 0, sizeof ( GroupInfo ) );
       GetNameData(pGroupStr + strlen( GROUP_TAG ) ,groupInfo.NodeName );
       groupInfo.BraceCount = curBraceCount;
       groupInfo.pParent = pParent;
       long oldBraceCount = curBraceCount;

       CharUpperA( groupInfo.NodeName );

       groupList.push_back( groupInfo );
       
       pNextGroupStr = strstr( pGroupStr + strlen( GROUP_TAG ), GROUP_TAG );
       if ( pNextGroupStr )
        *pNextGroupStr = NULL;

       char* pOpenBrace = pGroupStr;
       while( pOpenBrace = strchr( pOpenBrace, '{' ) )
       {
           pOpenBrace++;
           curBraceCount++;
       }
       char* pCloseBrace = pGroupStr;
       while( pCloseBrace = strchr( pCloseBrace, '}' ) )
       {
           pCloseBrace++;
           curBraceCount--;
       }

       if ( curBraceCount < 1 )
       {
           pParent = NULL;
       }
       else if ( curBraceCount > oldBraceCount )
       {
            pParent = &groupList.back();
       }


       if ( pNextGroupStr )
           *pNextGroupStr = '*';

       if ( !pNextGroupStr )
           break;
       
       pGroupStr = pNextGroupStr;


   }


}

char* FindNextObject( const char* pBuffer )
{
    char* pSeeker = NULL;
    char* pNextObject = strstr( pBuffer, "GEOMOBJECT ");
    char* pNextGroup = strstr( pBuffer, "GROUP ");

    if ( (pNextGroup && pNextGroup < pNextObject) || !pNextObject )
    {
        pSeeker = pNextGroup;
    }
    else
    {
        pSeeker = pNextObject;
    }

    return pSeeker;

}
void ASEScene::Load(const char* pBuffer )
{
    m_ButtonCount = 0;
    m_TextCount = 0;
    m_ListBoxCount = 0;
    m_SpinnerCount = 0;

    
    list< GroupInfo > groupList;
    // Last second hack, it turns out that max doesn't write out the
    // names of the parents if the group isn't a geomobject.  So we need 
    // to figure out the group relationship and factor that in
    SetUpGroups( pBuffer, groupList );
 

    TG_Animation animHeader;
    TG_Animation* pHeader = NULL;
    bool bAnimInfo = false;
    if ( S_OK == TG_Shape::ParseAnimationHeader( (char*)pBuffer, &animHeader ) )
    {
        pHeader = &animHeader;
    }

  	m_Camera.Load( pBuffer, &animHeader );


	memset ( &m_Light, 0x00, sizeof ( D3DLIGHT8 ) );

	
	m_Light.Type = (D3DLIGHTTYPE)0;

	if ( !m_pRoot )
	{
		m_pRoot = new TG_Shape( );

		// load up materials
		OutputDebugStringA("Loading the material library\n");
		g_MaterialLib.LoadFromASE( 0, (BYTE*)pBuffer );

		int numObjects = 0;
        // skip to geometry
		const char* pSeeker = FindNextObject( pBuffer );

        TG_Shape* pKid = NULL;
        OutputDebugStringA("Loading objects from the scene\n");
 
		while( pSeeker )
		{
            char tmp = pSeeker[44];
            ((char*)pSeeker)[44] = NULL;
			OutputDebugStringA("Importing Object");
            OutputDebugStringA(pSeeker + strlen("GEOMOBJECT ") + 1);
            OutputDebugStringA("\n");
            ((char*)pSeeker)[44] = tmp;

			// only parse next object
            char* pNext = FindNextObject( pSeeker + strlen( "GEOMOBJECT " ) );
			if ( pNext )
				*pNext = NULL;
			if ( NULL == pKid )
			{
				pKid = new TG_Shape;
			}

            char* parentName = strstr((char *)pSeeker,ASE_NODE_PARENT);
            TG_Shape* pParent = NULL;
            char pStrParent[64];
            pStrParent[0] = 0;

	        //-------------------------------------------------------------------
	        // Must also check to make sure we HAVE a parent.
	        // We will get the next GeomObject's parent if we don't check length!
	        if ((parentName != NULL))
	        {
		        parentName += strlen(ASE_NODE_PARENT)+1;
                pStrParent[0] = 0;
		        GetNameData(parentName,pStrParent);
		        
                pParent = m_pRoot->FindObject( pStrParent );

	        }
            

            D3DXVECTOR3 parentVec;
            parentVec.x = 0.f;
            parentVec.y = 0.f;
            parentVec.z = 0.f;
            TG_Shape* pTmpParent = pParent;
            while( pTmpParent )
            {
                D3DXVECTOR3 tmpParentVec;
                pTmpParent->GetNodeCenter( tmpParentVec.x, tmpParentVec.y, tmpParentVec.z );
                pTmpParent = pTmpParent->GetParent();
                parentVec += tmpParentVec;
            }
	        

			if ( S_OK == pKid->Load( pSeeker, NULL, parentVec, pHeader) )
			{
                if ( strlen( pStrParent ) )
                {
                    if ( !pParent )
                    {
                       pParent = new TG_Shape();
                       pParent->SetNodeName( pStrParent );

                       TG_Shape* pGrandParent = m_pRoot;

                       // look through group list, and see if we can find a parent
                       // got a group
                        for ( list< GroupInfo >::iterator iter = groupList.begin();
                        iter != groupList.end(); iter++ )
                        {
                            if ( _stricmp( pStrParent, (*iter).NodeName ) == 0 )
                            {
                                if ( (*iter).pParent )
                                {
                                    pGrandParent = m_pRoot->FindObject( (*iter).pParent->NodeName );
                                    if ( !pGrandParent )
                   